{"sha": "5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzN2VhMGVmMWJiOGQ5YTI3ZTY1MDJhODJiN2IxNGYzMGQ2ZDZiNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-02T16:53:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-02T16:53:16Z"}, "message": "Fix PR45199: do not aggregate memory accesses to the same array for -ftree-loop-distribute-patterns\n\n2010-11-30  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/45199\n\t* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p): New.\n\t(stores_zero_from_loop): Call\n\tmem_write_stride_of_same_size_as_unit_type_p.\n\t* tree-data-ref.h (stride_of_unit_type_p): New.\n\t* tree-loop-distribution.c (generate_memset_zero): Simplified.\n\tCall stride_of_unit_type_p.\n\t(build_rdg_partition_for_component): Do not call\n\trdg_flag_similar_memory_accesses when\n\tflag_tree_loop_distribute_patterns is set.\n\n\t* gcc.dg/tree-ssa/ldist-15.c: New.\n\t* gcc.dg/tree-ssa/ldist-16.c: New.\n\t* gfortran.dg/ldist-pr45199.f: New.\n\nFrom-SVN: r167380", "tree": {"sha": "88b1433f2415d2ff73482de80bdbdb30c4c04d7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88b1433f2415d2ff73482de80bdbdb30c4c04d7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2087e8dad076c2482622329023cde67c631edbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2087e8dad076c2482622329023cde67c631edbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2087e8dad076c2482622329023cde67c631edbb"}], "stats": {"total": 174, "additions": 142, "deletions": 32}, "files": [{"sha": "c72c6934f411a12b1b44f3ab88b4f0fe876cad2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -1,3 +1,16 @@\n+2010-12-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/45199\n+\t* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p): New.\n+\t(stores_zero_from_loop): Call\n+\tmem_write_stride_of_same_size_as_unit_type_p.\n+\t* tree-data-ref.h (stride_of_unit_type_p): New.\n+\t* tree-loop-distribution.c (generate_memset_zero): Simplified.\n+\tCall stride_of_unit_type_p.\n+\t(build_rdg_partition_for_component): Do not call\n+\trdg_flag_similar_memory_accesses when\n+\tflag_tree_loop_distribute_patterns is set.\n+\n 2010-12-02  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_analyze_scalar_cycles_1): Disregard"}, {"sha": "3eeee8347d91aba4e3cc5d044272c46032fcedf3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -1,3 +1,10 @@\n+2010-12-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/45199\n+\t* gcc.dg/tree-ssa/ldist-15.c: New.\n+\t* gcc.dg/tree-ssa/ldist-16.c: New.\n+\t* gfortran.dg/ldist-pr45199.f: New.\n+\n 2010-12-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46723\n@@ -23,8 +30,8 @@\n 2010-12-02  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/exceptions-6.m: New.\n-\t* obj-c++.dg/exceptions-6.mm: New.\t\n-\t\n+\t* obj-c++.dg/exceptions-6.mm: New.\n+\n 2010-12-01  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.c-torture/execute/bcp-1.c: Make ready for -fuse-linker-plugin"}, {"sha": "7ce3b956b96c126b0f5db762580853624444f9f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-15.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-15.c?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ldist-details\" } */\n+\n+int x[1000];\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      x[2*i] = 0;\n+      x[2*i + 1] = 1;\n+    }\n+}\n+\n+/* We should not apply loop distribution as it is not beneficial from\n+   a data locality point of view.  Also it is not possible to generate\n+   a memset (0) as the write has a stride of 2.  */\n+\n+/* { dg-final { scan-tree-dump-not \"distributed: split to\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin_memset\" \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "61e8e56d5bfe467355d1dcfc759db2812811d53d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ldist-details\" } */\n+\n+int x[1000];\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      x[i] = 0;\n+      x[2*i + 1] = 1;\n+    }\n+}\n+\n+/* We should apply loop distribution and generate a memset (0).  */\n+\n+/* { dg-final { scan-tree-dump \"distributed: split to 2\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_memset\" 2 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "6f65501a4f678ace904e7a8f7b0471c2fe027c3f", "filename": "gcc/testsuite/gfortran.dg/ldist-pr45199.f", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fdump-tree-ldist-details\" }\n+\n+      parameter(numlev=3,numoblev=1000)\n+      integer i_otyp(numoblev,numlev), i_styp(numoblev,numlev)\n+      logical l_numob(numoblev,numlev)\n+      do ixe=1,numoblev\n+         do iye=1,numlev\n+            i_otyp(ixe,iye)=0\n+            i_styp(ixe,iye)=0\n+            l_numob(ixe,iye)=.false.\n+         enddo\n+      enddo\n+      do i=1,m\n+         do j=1,n\n+            if (l_numob(i,j)) then\n+               write(20,'(7I4,F12.2,4F16.10)') i_otyp(i,j),i_styp(i,j)\n+            endif\n+         enddo\n+      enddo\n+      end\n+\n+! GCC should apply memset zero loop distribution and it should not ICE.\n+\n+! { dg-final { scan-tree-dump \"distributed: split to 9 loops\" \"ldist\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memset\" 18 \"ldist\" } }\n+! { dg-final { cleanup-tree-dump \"ldist\" } }"}, {"sha": "094d16822a9481e9c8953f4875c4e51251c80e57", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -4974,6 +4974,27 @@ stores_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n   free (bbs);\n }\n \n+/* Returns true when STMT is an assignment that contains a data\n+   reference on its LHS with a stride of the same size as its unit\n+   type.  */\n+\n+static bool\n+mem_write_stride_of_same_size_as_unit_type_p (gimple stmt)\n+{\n+  struct data_reference *dr = XCNEW (struct data_reference);\n+  tree op0 = gimple_assign_lhs (stmt);\n+  bool res;\n+\n+  DR_STMT (dr) = stmt;\n+  DR_REF (dr) = op0;\n+\n+  res = dr_analyze_innermost (dr)\n+    && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0));\n+\n+  free_data_ref (dr);\n+  return res;\n+}\n+\n /* Initialize STMTS with all the statements of LOOP that contain a\n    store to memory of the form \"A[i] = 0\".  */\n \n@@ -4994,7 +5015,8 @@ stores_zero_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n \t  && is_gimple_assign (stmt)\n \t  && gimple_assign_rhs_code (stmt) == INTEGER_CST\n \t  && (op = gimple_assign_rhs1 (stmt))\n-\t  && (integer_zerop (op) || real_zerop (op)))\n+\t  && (integer_zerop (op) || real_zerop (op))\n+\t  && mem_write_stride_of_same_size_as_unit_type_p (stmt))\n \tVEC_safe_push (gimple, heap, *stmts, gsi_stmt (si));\n \n   free (bbs);"}, {"sha": "d929f315bf1b10202e49e7df850a2a24d16da172", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -603,6 +603,17 @@ void remove_similar_memory_refs (VEC (gimple, heap) **);\n bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n bool have_similar_memory_accesses (gimple, gimple);\n \n+/* Returns true when STRIDE is equal in absolute value to the size of\n+   the unit type of TYPE.  */\n+\n+static inline bool\n+stride_of_unit_type_p (tree stride, tree type)\n+{\n+  return tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),\n+\t\t\t\t\t stride),\n+\t\t\t     TYPE_SIZE_UNIT (type));\n+}\n+\n /* Determines whether RDG vertices V1 and V2 access to similar memory\n    locations, in which case they have to be in the same partition.  */\n "}, {"sha": "357f51fe275647856d90e138bafa4a77de4d6e6b", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=5e37ea0ef1bb8d9a27e6502a82b7b14f30d6d6b6", "patch": "@@ -258,42 +258,27 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   if (!dr_analyze_innermost (dr))\n     goto end;\n \n-  /* Test for a positive stride, iterating over every element.  */\n-  if (integer_zerop (size_binop (MINUS_EXPR,\n-\t\t\t\t fold_convert (sizetype, DR_STEP (dr)),\n-\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (op0)))))\n-    {\n-      addr_base = fold_convert_loc (loc, sizetype,\n-\t\t\t\t    size_binop_loc (loc, PLUS_EXPR,\n-\t\t\t\t\t\t    DR_OFFSET (dr),\n-\t\t\t\t\t\t    DR_INIT (dr)));\n-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n-\t\t\t\t   TREE_TYPE (DR_BASE_ADDRESS (dr)),\n-\t\t\t\t   DR_BASE_ADDRESS (dr), addr_base);\n-\n-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n-    }\n+  if (!stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)))\n+    goto end;\n+\n+  nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n+  addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n+  addr_base = fold_convert_loc (loc, sizetype, addr_base);\n \n   /* Test for a negative stride, iterating over every element.  */\n-  else if (integer_zerop (size_binop (PLUS_EXPR,\n-\t\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (op0)),\n-\t\t\t\t      fold_convert (sizetype, DR_STEP (dr)))))\n+  if (integer_zerop (size_binop (PLUS_EXPR,\n+\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (op0)),\n+\t\t\t\t fold_convert (sizetype, DR_STEP (dr)))))\n     {\n-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n-\n-      addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n-      addr_base = fold_convert_loc (loc, sizetype, addr_base);\n       addr_base = size_binop_loc (loc, MINUS_EXPR, addr_base,\n \t\t\t\t  fold_convert_loc (loc, sizetype, nb_bytes));\n       addr_base = size_binop_loc (loc, PLUS_EXPR, addr_base,\n \t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (op0)));\n-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n-\t\t\t\t   TREE_TYPE (DR_BASE_ADDRESS (dr)),\n-\t\t\t\t   DR_BASE_ADDRESS (dr), addr_base);\n     }\n-  else\n-    goto end;\n \n+  addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n+\t\t\t       TREE_TYPE (DR_BASE_ADDRESS (dr)),\n+\t\t\t       DR_BASE_ADDRESS (dr), addr_base);\n   mem = force_gimple_operand (addr_base, &stmts, true, NULL);\n   gimple_seq_add_seq (&stmt_list, stmts);\n \n@@ -781,8 +766,9 @@ build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n      and determine those vertices that have some memory affinity with\n      the current nodes in the component: these are stores to the same\n      arrays, i.e. we're taking care of cache locality.  */\n-  rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,\n-\t\t\t\t    other_stores);\n+  if (!flag_tree_loop_distribute_patterns)\n+    rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,\n+\t\t\t\t      other_stores);\n \n   rdg_flag_loop_exits (rdg, loops, partition, processed, part_has_writes);\n "}]}