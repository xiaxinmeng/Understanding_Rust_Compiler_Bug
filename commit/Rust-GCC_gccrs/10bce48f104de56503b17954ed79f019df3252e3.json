{"sha": "10bce48f104de56503b17954ed79f019df3252e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiY2U0OGYxMDRkZTU2NTAzYjE3OTU0ZWQ3OWYwMTlkZjMyNTJlMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-22T07:47:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-22T07:47:07Z"}, "message": "[C++] Avoid exposing internal details in aka types\n\nThis patch extends r276951 to work for C++ too.\n\n2019-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/cp/\n\t* cp-tree.h (STF_USER_VISIBLE): New constant.\n\t(strip_typedefs, strip_typedefs_expr): Take a flags argument.\n\t* tree.c (strip_typedefs, strip_typedefs_expr): Likewise,\n\tupdating mutual calls accordingly.  When STF_USER_VISIBLE is true,\n\tonly look through typedefs if user_facing_original_type_p.\n\t* error.c (dump_template_bindings, type_to_string): Pass\n\tSTF_USER_VISIBLE to strip_typedefs.\n\t(dump_type): Likewise, unless pp_c_flag_gnu_v3 is set.\n\ngcc/testsuite/\n\t* g++.dg/diagnostic/aka5.h: New test.\n\t* g++.dg/diagnostic/aka5a.C: Likewise.\n\t* g++.dg/diagnostic/aka5b.C: Likewise.\n\t* g++.target/aarch64/diag_aka_1.C: Likewise.\n\nFrom-SVN: r277281", "tree": {"sha": "31f95815c57840905ddcf9b8efc15e4cd333833a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31f95815c57840905ddcf9b8efc15e4cd333833a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10bce48f104de56503b17954ed79f019df3252e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bce48f104de56503b17954ed79f019df3252e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bce48f104de56503b17954ed79f019df3252e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bce48f104de56503b17954ed79f019df3252e3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24b54eb2fd9ee616d899683a459756072e3a1c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24b54eb2fd9ee616d899683a459756072e3a1c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24b54eb2fd9ee616d899683a459756072e3a1c4d"}], "stats": {"total": 410, "additions": 372, "deletions": 38}, "files": [{"sha": "2b15bf722cae6e9fc3198474086c179775787d94", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -1,3 +1,14 @@\n+2019-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* cp-tree.h (STF_USER_VISIBLE): New constant.\n+\t(strip_typedefs, strip_typedefs_expr): Take a flags argument.\n+\t* tree.c (strip_typedefs, strip_typedefs_expr): Likewise,\n+\tupdating mutual calls accordingly.  When STF_USER_VISIBLE is true,\n+\tonly look through typedefs if user_facing_original_type_p.\n+\t* error.c (dump_template_bindings, type_to_string): Pass\n+\tSTF_USER_VISIBLE to strip_typedefs.\n+\t(dump_type): Likewise, unless pp_c_flag_gnu_v3 is set.\n+\n 2019-10-21  Kamlesh Kumar  <kamleshbhalui@gmail.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "e9d54466289ef377df2ff90284666cd4aa89f0a0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -5722,6 +5722,13 @@ enum auto_deduction_context\n #define TFF_NO_TEMPLATE_BINDINGS\t\t(1 << 13)\n #define TFF_POINTER\t\t                (1 << 14)\n \n+/* These constants can be used as bit flags to control strip_typedefs.\n+\n+   STF_USER_VISIBLE: use heuristics to try to avoid stripping user-facing\n+       aliases of internal details.  This is intended for diagnostics,\n+       where it should (for example) give more useful \"aka\" types.  */\n+const unsigned int STF_USER_VISIBLE = 1U;\n+\n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL(NODE)\t\\\n@@ -7259,8 +7266,10 @@ extern int zero_init_p\t\t\t\t(const_tree);\n extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree,\n \t\t\t\t\t\t const_tree);\n extern bool check_abi_tag_args\t\t\t(tree, tree);\n-extern tree strip_typedefs\t\t\t(tree, bool * = NULL);\n-extern tree strip_typedefs_expr\t\t\t(tree, bool * = NULL);\n+extern tree strip_typedefs\t\t\t(tree, bool * = NULL,\n+\t\t\t\t\t\t unsigned int = 0);\n+extern tree strip_typedefs_expr\t\t\t(tree, bool * = NULL,\n+\t\t\t\t\t\t unsigned int = 0);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);"}, {"sha": "83b8b12e4bdb19975cc5fba6eb2a6d08416668d8", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -410,7 +410,7 @@ dump_template_bindings (cxx_pretty_printer *pp, tree parms, tree args,\n       pop_deferring_access_checks ();\n       /* Strip typedefs.  We can't just use TFF_CHASE_TYPEDEF because\n \t pp_simple_type_specifier doesn't know about it.  */\n-      t = strip_typedefs (t);\n+      t = strip_typedefs (t, NULL, STF_USER_VISIBLE);\n       dump_type (pp, t, TFF_PLAIN_IDENTIFIER);\n     }\n }\n@@ -449,7 +449,11 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n \t       || DECL_SELF_REFERENCE_P (decl)\n \t       || (!flag_pretty_templates\n \t\t   && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)))\n-\tt = strip_typedefs (t);\n+\t{\n+\t  unsigned int stf_flags = (!(pp->flags & pp_c_flag_gnu_v3)\n+\t\t\t\t    ? STF_USER_VISIBLE : 0);\n+\t  t = strip_typedefs (t, NULL, stf_flags);\n+\t}\n       else if (alias_template_specialization_p (t))\n \t{\n \t  dump_alias_template_specialization (pp, t, flags);\n@@ -3205,7 +3209,7 @@ type_to_string (tree typ, int verbose, bool postprocessed, bool *quote,\n       && !uses_template_parms (typ))\n     {\n       int aka_start, aka_len; char *p;\n-      tree aka = strip_typedefs (typ);\n+      tree aka = strip_typedefs (typ, NULL, STF_USER_VISIBLE);\n       if (quote && *quote)\n \tpp_end_quote (cxx_pp, show_color);\n       pp_string (cxx_pp, \" {aka\");"}, {"sha": "9d63736a394f645109d2e04e0205dab383c6d268", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -1431,7 +1431,10 @@ apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)\n   return cp_build_type_attribute_variant (result, new_attribs);\n }\n \n-/* Builds a qualified variant of T that is not a typedef variant.\n+/* Builds a qualified variant of T that is either not a typedef variant\n+   (the default behavior) or not a typedef variant of a user-facing type\n+   (if FLAGS contains STF_USER_FACING).\n+\n    E.g. consider the following declarations:\n      typedef const int ConstInt;\n      typedef ConstInt* PtrConstInt;\n@@ -1456,7 +1459,7 @@ apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)\n    stripped.  */\n \n tree\n-strip_typedefs (tree t, bool *remove_attributes)\n+strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n {\n   tree result = NULL, type = NULL, t0 = NULL;\n \n@@ -1471,7 +1474,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n       for (; t; t = TREE_CHAIN (t))\n \t{\n \t  gcc_assert (!TREE_PURPOSE (t));\n-\t  tree elt = strip_typedefs (TREE_VALUE (t), remove_attributes);\n+\t  tree elt = strip_typedefs (TREE_VALUE (t), remove_attributes, flags);\n \t  if (elt != TREE_VALUE (t))\n \t    changed = true;\n \t  vec_safe_push (vec, elt);\n@@ -1494,28 +1497,29 @@ strip_typedefs (tree t, bool *remove_attributes)\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n       result = build_pointer_type (type);\n       break;\n     case REFERENCE_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n       result = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n       break;\n     case OFFSET_TYPE:\n-      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t), remove_attributes);\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t), remove_attributes, flags);\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n       result = build_offset_type (t0, type);\n       break;\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n-\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t), remove_attributes);\n+\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t),\n+\t\t\t       remove_attributes, flags);\n \t  result = build_ptrmemfunc_type (t0);\n \t}\n       break;\n     case ARRAY_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n-      t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n+      t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes, flags);\n       result = build_cplus_array_type (type, t0);\n       break;\n     case FUNCTION_TYPE:\n@@ -1534,7 +1538,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t    && (TYPE_ATTRIBUTES (t) || TYPE_USER_ALIGN (t)))\n \t  is_variant = true;\n \n-\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n \ttree canon_spec = (flag_noexcept_type\n \t\t\t   ? canonical_eh_spec (TYPE_RAISES_EXCEPTIONS (t))\n \t\t\t   : NULL_TREE);\n@@ -1548,7 +1552,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t    if (arg_node == void_list_node)\n \t      break;\n \t    arg_type = strip_typedefs (TREE_VALUE (arg_node),\n-\t\t\t\t       remove_attributes);\n+\t\t\t\t       remove_attributes, flags);\n \t    gcc_assert (arg_type);\n \t    if (arg_type == TREE_VALUE (arg_node) && !changed)\n \t      continue;\n@@ -1612,9 +1616,10 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t\ttree arg = TREE_VEC_ELT (args, i);\n \t\ttree strip_arg;\n \t\tif (TYPE_P (arg))\n-\t\t  strip_arg = strip_typedefs (arg, remove_attributes);\n+\t\t  strip_arg = strip_typedefs (arg, remove_attributes, flags);\n \t\telse\n-\t\t  strip_arg = strip_typedefs_expr (arg, remove_attributes);\n+\t\t  strip_arg = strip_typedefs_expr (arg, remove_attributes,\n+\t\t\t\t\t\t   flags);\n \t\tTREE_VEC_ELT (new_args, i) = strip_arg;\n \t\tif (strip_arg != arg)\n \t\t  changed = true;\n@@ -1630,7 +1635,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t    else\n \t      ggc_free (new_args);\n \t  }\n-\ttree ctx = strip_typedefs (TYPE_CONTEXT (t), remove_attributes);\n+\ttree ctx = strip_typedefs (TYPE_CONTEXT (t), remove_attributes, flags);\n \tif (!changed && ctx == TYPE_CONTEXT (t) && !typedef_variant_p (t))\n \t  return t;\n \ttree name = fullname;\n@@ -1643,7 +1648,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n       break;\n     case DECLTYPE_TYPE:\n       result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t),\n-\t\t\t\t    remove_attributes);\n+\t\t\t\t    remove_attributes, flags);\n       if (result == DECLTYPE_TYPE_EXPR (t))\n \tresult = NULL_TREE;\n       else\n@@ -1653,7 +1658,8 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t\t   tf_none));\n       break;\n     case UNDERLYING_TYPE:\n-      type = strip_typedefs (UNDERLYING_TYPE_TYPE (t), remove_attributes);\n+      type = strip_typedefs (UNDERLYING_TYPE_TYPE (t),\n+\t\t\t     remove_attributes, flags);\n       result = finish_underlying_type (type);\n       break;\n     default:\n@@ -1664,15 +1670,18 @@ strip_typedefs (tree t, bool *remove_attributes)\n     {\n       if (typedef_variant_p (t))\n \t{\n-\t  /* Explicitly get the underlying type, as TYPE_MAIN_VARIANT doesn't\n-\t     strip typedefs with attributes.  */\n-\t  result = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (TYPE_NAME (t)));\n-\t  result = strip_typedefs (result);\n+\t  if ((flags & STF_USER_VISIBLE)\n+\t      && !user_facing_original_type_p (t))\n+\t    return t;\n+\t  result = strip_typedefs (DECL_ORIGINAL_TYPE (TYPE_NAME (t)),\n+\t\t\t\t   remove_attributes, flags);\n \t}\n       else\n \tresult = TYPE_MAIN_VARIANT (t);\n     }\n-  gcc_assert (!typedef_variant_p (result));\n+  gcc_assert (!typedef_variant_p (result)\n+\t      || ((flags & STF_USER_VISIBLE)\n+\t\t  && !user_facing_original_type_p (result)));\n \n   if (COMPLETE_TYPE_P (result) && !COMPLETE_TYPE_P (t))\n   /* If RESULT is complete and T isn't, it's likely the case that T\n@@ -1721,7 +1730,7 @@ strip_typedefs (tree t, bool *remove_attributes)\n    sizeof(TT) is replaced by sizeof(T).  */\n \n tree\n-strip_typedefs_expr (tree t, bool *remove_attributes)\n+strip_typedefs_expr (tree t, bool *remove_attributes, unsigned int flags)\n {\n   unsigned i,n;\n   tree r, type, *ops;\n@@ -1738,7 +1747,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n   /* Some expressions have type operands, so let's handle types here rather\n      than check TYPE_P in multiple places below.  */\n   if (TYPE_P (t))\n-    return strip_typedefs (t, remove_attributes);\n+    return strip_typedefs (t, remove_attributes, flags);\n \n   code = TREE_CODE (t);\n   switch (code)\n@@ -1752,8 +1761,10 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \n     case TRAIT_EXPR:\n       {\n-\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t), remove_attributes);\n-\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t), remove_attributes);\n+\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t),\n+\t\t\t\t     remove_attributes, flags);\n+\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t),\n+\t\t\t\t     remove_attributes, flags);\n \tif (type1 == TRAIT_EXPR_TYPE1 (t)\n \t    && type2 == TRAIT_EXPR_TYPE2 (t))\n \t  return t;\n@@ -1770,7 +1781,8 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \ttree it;\n \tfor (it = t; it; it = TREE_CHAIN (it))\n \t  {\n-\t    tree val = strip_typedefs_expr (TREE_VALUE (it), remove_attributes);\n+\t    tree val = strip_typedefs_expr (TREE_VALUE (it),\n+\t\t\t\t\t    remove_attributes, flags);\n \t    vec_safe_push (vec, val);\n \t    if (val != TREE_VALUE (it))\n \t      changed = true;\n@@ -1796,7 +1808,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i),\n-\t\t\t\t\t   remove_attributes);\n+\t\t\t\t\t   remove_attributes, flags);\n \t    vec->quick_push (op);\n \t    if (op != TREE_VEC_ELT (t, i))\n \t      changed = true;\n@@ -1820,18 +1832,19 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n \tvec<constructor_elt, va_gc> *vec\n \t  = vec_safe_copy (CONSTRUCTOR_ELTS (t));\n \tn = CONSTRUCTOR_NELTS (t);\n-\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    constructor_elt *e = &(*vec)[i];\n-\t    tree op = strip_typedefs_expr (e->value, remove_attributes);\n+\t    tree op = strip_typedefs_expr (e->value, remove_attributes, flags);\n \t    if (op != e->value)\n \t      {\n \t\tchanged = true;\n \t\te->value = op;\n \t      }\n \t    gcc_checking_assert\n-\t      (e->index == strip_typedefs_expr (e->index, remove_attributes));\n+\t      (e->index == strip_typedefs_expr (e->index, remove_attributes,\n+\t\t\t\t\t\tflags));\n \t  }\n \n \tif (!changed && type == TREE_TYPE (t))\n@@ -1875,12 +1888,13 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n     case REINTERPRET_CAST_EXPR:\n     case CAST_EXPR:\n     case NEW_EXPR:\n-      type = strip_typedefs (type, remove_attributes);\n+      type = strip_typedefs (type, remove_attributes, flags);\n       /* fallthrough */\n \n     default:\n       for (i = 0; i < n; ++i)\n-\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i), remove_attributes);\n+\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i),\n+\t\t\t\t      remove_attributes, flags);\n       break;\n     }\n "}, {"sha": "b0edb291b0e4303ee2d49edef04c0b46f9c49cfb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -1,3 +1,10 @@\n+2019-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* g++.dg/diagnostic/aka5.h: New test.\n+\t* g++.dg/diagnostic/aka5a.C: Likewise.\n+\t* g++.dg/diagnostic/aka5b.C: Likewise.\n+\t* g++.target/aarch64/diag_aka_1.C: Likewise.\n+\n 2019-10-22  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* gcc.dg/Wnonnull.c: Provide prototypes for strlen and memcpy."}, {"sha": "0c7404d766404a8d6ce35460970dc96b7d8b2e2b", "filename": "gcc/testsuite/g++.dg/diagnostic/aka5.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5.h?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -0,0 +1,22 @@\n+#ifdef IS_SYSTEM_HEADER\n+#pragma GCC system_header\n+#endif\n+\n+typedef enum __internal_enum { A, B } user_enum;\n+typedef user_enum *user_enum_ptr;\n+\n+typedef struct __internal_struct { int i; } user_struct;\n+typedef user_struct user_struct_copy;\n+typedef user_struct *user_struct_ptr;\n+\n+typedef union __internal_union { int i; } user_union;\n+typedef user_union user_union_copy;\n+typedef user_union *user_union_ptr;\n+\n+typedef unsigned int user_vector __attribute__((__vector_size__(16)));\n+typedef user_vector user_vector_copy;\n+typedef user_vector *user_vector_ptr;\n+\n+typedef int user_int;\n+typedef user_int user_int_copy;\n+typedef user_int *user_int_ptr;"}, {"sha": "e9d4c02f61d389086a517f19b6a9e3dc17c3259e", "filename": "gcc/testsuite/g++.dg/diagnostic/aka5a.C", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5a.C?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -0,0 +1,127 @@\n+#define IS_SYSTEM_HEADER\n+#include \"aka5.h\"\n+\n+typedef user_enum user_enum_copy;\n+\n+struct s { int i; };\n+\n+user_enum ue1;\n+user_enum_copy ue2;\n+user_enum_ptr ue_ptr1;\n+user_enum *ue_ptr2;\n+const user_enum *const_ue_ptr1;\n+const user_enum_copy *const_ue_ptr2;\n+volatile user_enum *volatile_ue_ptr1;\n+volatile user_enum_copy *volatile_ue_ptr2;\n+user_enum (*ue_array_ptr1)[10];\n+user_enum_copy (*ue_array_ptr2)[10];\n+user_enum (*ue_fn_ptr1) (void);\n+void (*ue_fn_ptr2) (user_enum);\n+void (*ue_fn_ptr3) (user_enum, ...);\n+user_enum_copy (*ue_fn_ptr4) (void);\n+void (*ue_fn_ptr5) (user_enum_copy);\n+void (*ue_fn_ptr6) (user_enum_copy, ...);\n+user_enum (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr1) (void);\n+user_enum_copy (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr2) (void);\n+\n+user_struct us1;\n+user_struct_copy us2;\n+user_struct_ptr us_ptr1;\n+user_struct *us_ptr2;\n+const user_struct *const_us_ptr1;\n+const user_struct_copy *const_us_ptr2;\n+\n+user_union uu1;\n+user_union_copy uu2;\n+user_union_ptr uu_ptr1;\n+user_union *uu_ptr2;\n+const user_union *const_uu_ptr1;\n+const user_union_copy *const_uu_ptr2;\n+\n+user_vector uv1;\n+user_vector_copy uv2;\n+user_vector_ptr uv_ptr1;\n+user_vector *uv_ptr2;\n+const user_vector *const_uv_ptr1;\n+const user_vector_copy *const_uv_ptr2;\n+\n+user_int ui1;\n+user_int_copy ui2;\n+user_int_ptr ui_ptr1;\n+user_int *ui_ptr2;\n+const user_int *const_ui_ptr1;\n+const user_int_copy *const_ui_ptr2;\n+volatile user_int *volatile_ui_ptr1;\n+volatile user_int_copy *volatile_ui_ptr2;\n+user_int (*ui_array_ptr1)[10];\n+user_int_copy (*ui_array_ptr2)[10];\n+user_int (*ui_fn_ptr1) (void);\n+void (*ui_fn_ptr2) (user_int);\n+void (*ui_fn_ptr3) (user_int, ...);\n+user_int_copy (*ui_fn_ptr4) (void);\n+void (*ui_fn_ptr5) (user_int_copy);\n+void (*ui_fn_ptr6) (user_int_copy, ...);\n+user_int (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr1) (void);\n+user_int_copy (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr2) (void);\n+\n+void f (s s1)\n+{\n+  ue1 = s1; // { dg-error {cannot convert 's' to 'user_enum' in assignment} }\n+  ue2 = s1; // { dg-error {cannot convert 's' to 'user_enum_copy' {aka 'user_enum'} in assignment} }\n+  ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_ptr' {aka 'user_enum\\*'} in assignment} }\n+  ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum\\*' in assignment} }\n+  const_ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_enum\\*' in assignment} }\n+  const_ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_enum_copy\\*' {aka 'const user_enum\\*'} in assignment} }\n+  volatile_ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_enum\\*' in assignment} }\n+  volatile_ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_enum_copy\\*' {aka 'volatile user_enum\\*'} in assignment} }\n+  ue_array_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(\\*\\)\\[10\\]' in assignment} }\n+  ue_array_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(\\*\\)\\[10\\]' {aka 'user_enum \\(\\*\\)\\[10\\]'} in assignment} }\n+  ue_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(\\*\\)\\(\\)' in assignment} }\n+  ue_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum\\)' in assignment} }\n+  ue_fn_ptr3 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)' in assignment} }\n+  ue_fn_ptr4 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(\\*\\)\\(\\)' {aka 'user_enum \\(\\*\\)\\(\\)'} in assignment} }\n+  ue_fn_ptr5 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum_copy\\)' {aka 'void \\(\\*\\)\\(user_enum\\)'} in assignment} }\n+  ue_fn_ptr6 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)'} in assignment} }\n+  unsafe_ue_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' in assignment} }\n+  unsafe_ue_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+\n+  us1 = s1; // { dg-error {no match for 'operator=' in 'us1 = s1' \\(operand types are 'user_struct' and 's'\\)} }\n+  us2 = s1; // { dg-error {no match for 'operator=' in 'us2 = s1' \\(operand types are 'user_struct_copy' {aka 'user_struct'} and 's'\\)} }\n+  us_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_struct_ptr' {aka 'user_struct\\*'} in assignment} }\n+  us_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_struct\\*' in assignment} }\n+  const_us_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_struct\\*' in assignment} }\n+  const_us_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_struct_copy\\*' {aka 'const user_struct\\*'} in assignment} }\n+\n+  uu1 = s1; // { dg-error {no match for 'operator=' in 'uu1 = s1' \\(operand types are 'user_union' and 's'\\)} }\n+  uu2 = s1; // { dg-error {no match for 'operator=' in 'uu2 = s1' \\(operand types are 'user_union_copy' {aka 'user_union'} and 's'\\)} }\n+  uu_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_union_ptr' {aka 'user_union\\*'} in assignment} }\n+  uu_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_union\\*' in assignment} }\n+  const_uu_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_union\\*' in assignment} }\n+  const_uu_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_union_copy\\*' {aka 'const user_union\\*'} in assignment} }\n+\n+  uv1 = s1; // { dg-error {cannot convert 's' to 'user_vector' in assignment} }\n+  uv2 = s1; // { dg-error {cannot convert 's' to 'user_vector_copy' {aka 'user_vector'} in assignment} }\n+  uv_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_vector_ptr' {aka 'user_vector\\*'} in assignment} }\n+  uv_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_vector\\*' in assignment} }\n+  const_uv_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_vector\\*' in assignment} }\n+  const_uv_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_vector_copy\\*' {aka 'const user_vector\\*'} in assignment} }\n+\n+  ui1 = s1; // { dg-error {cannot convert 's' to 'user_int' {aka 'int'} in assignment} }\n+  ui2 = s1; // { dg-error {cannot convert 's' to 'user_int_copy' {aka 'int'} in assignment} }\n+  ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_ptr' {aka 'int\\*'} in assignment} }\n+  ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int\\*' {aka 'int\\*'} in assignment} }\n+  const_ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_int\\*' {aka 'const int\\*'} in assignment} }\n+  const_ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_int_copy\\*' {aka 'const int\\*'} in assignment} }\n+  volatile_ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_int\\*' {aka 'volatile int\\*'} in assignment} }\n+  volatile_ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_int_copy\\*' {aka 'volatile int\\*'} in assignment} }\n+  ui_array_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} in assignment} }\n+  ui_array_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} in assignment} }\n+  ui_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(\\*\\)\\(\\)' {aka 'int \\(\\*\\)\\(\\)'} in assignment} }\n+  ui_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int\\)' {aka 'void \\(\\*\\)\\(int\\)'} in assignment} }\n+  ui_fn_ptr3 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} in assignment} }\n+  ui_fn_ptr4 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(\\*\\)\\(\\)' {aka 'int \\(\\*\\)\\(\\)'} in assignment} }\n+  ui_fn_ptr5 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int_copy\\)' {aka 'void \\(\\*\\)\\(int\\)'} in assignment} }\n+  ui_fn_ptr6 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} in assignment} }\n+  unsafe_ui_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+  unsafe_ui_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+}"}, {"sha": "6942be3eef1a830c5cf985fac399c39a37bdcc02", "filename": "gcc/testsuite/g++.dg/diagnostic/aka5b.C", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Faka5b.C?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -0,0 +1,127 @@\n+#include \"aka5.h\"\n+\n+typedef user_enum user_enum_copy;\n+\n+struct s { int i; };\n+\n+user_enum ue1;\n+user_enum_copy ue2;\n+user_enum_ptr ue_ptr1;\n+user_enum *ue_ptr2;\n+const user_enum *const_ue_ptr1;\n+const user_enum_copy *const_ue_ptr2;\n+volatile user_enum *volatile_ue_ptr1;\n+volatile user_enum_copy *volatile_ue_ptr2;\n+user_enum (*ue_array_ptr1)[10];\n+user_enum_copy (*ue_array_ptr2)[10];\n+user_enum (*ue_fn_ptr1) (void);\n+void (*ue_fn_ptr2) (user_enum);\n+void (*ue_fn_ptr3) (user_enum, ...);\n+user_enum_copy (*ue_fn_ptr4) (void);\n+void (*ue_fn_ptr5) (user_enum_copy);\n+void (*ue_fn_ptr6) (user_enum_copy, ...);\n+user_enum (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr1) (void);\n+user_enum_copy (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr2) (void);\n+\n+user_struct us1;\n+user_struct_copy us2;\n+user_struct_ptr us_ptr1;\n+user_struct *us_ptr2;\n+const user_struct *const_us_ptr1;\n+const user_struct_copy *const_us_ptr2;\n+\n+user_union uu1;\n+user_union_copy uu2;\n+user_union_ptr uu_ptr1;\n+user_union *uu_ptr2;\n+const user_union *const_uu_ptr1;\n+const user_union_copy *const_uu_ptr2;\n+\n+user_vector uv1;\n+user_vector_copy uv2;\n+user_vector_ptr uv_ptr1;\n+user_vector *uv_ptr2;\n+const user_vector *const_uv_ptr1;\n+const user_vector_copy *const_uv_ptr2;\n+\n+user_int ui1;\n+user_int_copy ui2;\n+user_int_ptr ui_ptr1;\n+user_int *ui_ptr2;\n+const user_int *const_ui_ptr1;\n+const user_int_copy *const_ui_ptr2;\n+volatile user_int *volatile_ui_ptr1;\n+volatile user_int_copy *volatile_ui_ptr2;\n+user_int (*ui_array_ptr1)[10];\n+user_int_copy (*ui_array_ptr2)[10];\n+user_int (*ui_fn_ptr1) (void);\n+void (*ui_fn_ptr2) (user_int);\n+void (*ui_fn_ptr3) (user_int, ...);\n+user_int_copy (*ui_fn_ptr4) (void);\n+void (*ui_fn_ptr5) (user_int_copy);\n+void (*ui_fn_ptr6) (user_int_copy, ...);\n+user_int (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr1) (void);\n+user_int_copy (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr2) (void);\n+\n+void f (s s1)\n+{\n+  ue1 = s1; // { dg-error {cannot convert 's' to 'user_enum' {aka '__internal_enum'} in assignment} }\n+  ue2 = s1; // { dg-error {cannot convert 's' to 'user_enum_copy' {aka '__internal_enum'} in assignment} }\n+  ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_ptr' {aka '__internal_enum\\*'} in assignment} }\n+  ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum\\*' {aka '__internal_enum\\*'} in assignment} }\n+  const_ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_enum\\*' {aka 'const __internal_enum\\*'} in assignment} }\n+  const_ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_enum_copy\\*' {aka 'const __internal_enum\\*'} in assignment} }\n+  volatile_ue_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_enum\\*' {aka 'volatile __internal_enum\\*'} in assignment} }\n+  volatile_ue_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_enum_copy\\*' {aka 'volatile __internal_enum\\*'} in assignment} }\n+  ue_array_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(\\*\\)\\[10\\]' {aka '__internal_enum \\(\\*\\)\\[10\\]'} in assignment} }\n+  ue_array_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(\\*\\)\\[10\\]' {aka '__internal_enum \\(\\*\\)\\[10\\]'} in assignment} }\n+  ue_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(\\*\\)\\(\\)' {aka '__internal_enum \\(\\*\\)\\(\\)'} in assignment} }\n+  ue_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum\\)' {aka 'void \\(\\*\\)\\(__internal_enum\\)'} in assignment} }\n+  ue_fn_ptr3 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(__internal_enum, \\.\\.\\.\\)'} in assignment} }\n+  ue_fn_ptr4 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(\\*\\)\\(\\)' {aka '__internal_enum \\(\\*\\)\\(\\)'} in assignment} }\n+  ue_fn_ptr5 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum_copy\\)' {aka 'void \\(\\*\\)\\(__internal_enum\\)'} in assignment} }\n+  ue_fn_ptr6 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_enum_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(__internal_enum, \\.\\.\\.\\)'} in assignment} }\n+  unsafe_ue_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka '__internal_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+  unsafe_ue_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_enum_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka '__internal_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+\n+  us1 = s1; // { dg-error {no match for 'operator=' in 'us1 = s1' \\(operand types are 'user_struct' {aka '__internal_struct'} and 's'\\)} }\n+  us2 = s1; // { dg-error {no match for 'operator=' in 'us2 = s1' \\(operand types are 'user_struct_copy' {aka '__internal_struct'} and 's'\\)} }\n+  us_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_struct_ptr' {aka '__internal_struct\\*'} in assignment} }\n+  us_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_struct\\*' {aka '__internal_struct\\*'} in assignment} }\n+  const_us_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_struct\\*' {aka 'const __internal_struct\\*'} in assignment} }\n+  const_us_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_struct_copy\\*' {aka 'const __internal_struct\\*'} in assignment} }\n+\n+  uu1 = s1; // { dg-error {no match for 'operator=' in 'uu1 = s1' \\(operand types are 'user_union' {aka '__internal_union'} and 's'\\)} }\n+  uu2 = s1; // { dg-error {no match for 'operator=' in 'uu2 = s1' \\(operand types are 'user_union_copy' {aka '__internal_union'} and 's'\\)} }\n+  uu_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_union_ptr' {aka '__internal_union\\*'} in assignment} }\n+  uu_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_union\\*' {aka '__internal_union\\*'} in assignment} }\n+  const_uu_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_union\\*' {aka 'const __internal_union\\*'} in assignment} }\n+  const_uu_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_union_copy\\*' {aka 'const __internal_union\\*'} in assignment} }\n+\n+  uv1 = s1; // { dg-error {cannot convert 's' to 'user_vector' {aka '__vector\\([48]\\) unsigned int'} in assignment} }\n+  uv2 = s1; // { dg-error {cannot convert 's' to 'user_vector_copy' {aka '__vector\\([48]\\) unsigned int'} in assignment} }\n+  uv_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_vector_ptr' {aka '__vector\\([48]\\) unsigned int\\*'} in assignment} }\n+  uv_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_vector\\*' {aka '__vector\\([48]\\) unsigned int\\*'} in assignment} }\n+  const_uv_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_vector\\*' {aka 'const __vector\\([48]\\) unsigned int\\*'} in assignment} }\n+  const_uv_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_vector_copy\\*' {aka 'const __vector\\([48]\\) unsigned int\\*'} in assignment} }\n+\n+  ui1 = s1; // { dg-error {cannot convert 's' to 'user_int' {aka 'int'} in assignment} }\n+  ui2 = s1; // { dg-error {cannot convert 's' to 'user_int_copy' {aka 'int'} in assignment} }\n+  ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_ptr' {aka 'int\\*'} in assignment} }\n+  ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int\\*' {aka 'int\\*'} in assignment} }\n+  const_ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_int\\*' {aka 'const int\\*'} in assignment} }\n+  const_ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'const user_int_copy\\*' {aka 'const int\\*'} in assignment} }\n+  volatile_ui_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_int\\*' {aka 'volatile int\\*'} in assignment} }\n+  volatile_ui_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'volatile user_int_copy\\*' {aka 'volatile int\\*'} in assignment} }\n+  ui_array_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} in assignment} }\n+  ui_array_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} in assignment} }\n+  ui_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(\\*\\)\\(\\)' {aka 'int \\(\\*\\)\\(\\)'} in assignment} }\n+  ui_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int\\)' {aka 'void \\(\\*\\)\\(int\\)'} in assignment} }\n+  ui_fn_ptr3 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} in assignment} }\n+  ui_fn_ptr4 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(\\*\\)\\(\\)' {aka 'int \\(\\*\\)\\(\\)'} in assignment} }\n+  ui_fn_ptr5 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int_copy\\)' {aka 'void \\(\\*\\)\\(int\\)'} in assignment} }\n+  ui_fn_ptr6 = &s1; // { dg-error {cannot convert 's\\*' to 'void \\(\\*\\)\\(user_int_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} in assignment} }\n+  unsafe_ui_fn_ptr1 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+  unsafe_ui_fn_ptr2 = &s1; // { dg-error {cannot convert 's\\*' to 'user_int_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(\\)'} in assignment} }\n+}\n+"}, {"sha": "6b489981f9c0e4196a447a299961fc69e7e61ebb", "filename": "gcc/testsuite/g++.target/aarch64/diag_aka_1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fdiag_aka_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bce48f104de56503b17954ed79f019df3252e3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fdiag_aka_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fdiag_aka_1.C?ref=10bce48f104de56503b17954ed79f019df3252e3", "patch": "@@ -0,0 +1,13 @@\n+#include <arm_neon.h>\n+\n+typedef int16x4_t myvec;\n+\n+void f (float x)\n+{\n+  __Int8x8_t y1 = x; // { dg-error {cannot convert 'float' to '__Int8x8_t' in initialization} }\n+  __Int8x8_t *ptr1 = &x; // { dg-error {cannot convert 'float\\*' to '__Int8x8_t\\*' in initialization} }\n+  int8x8_t y2 = x; // { dg-error {cannot convert 'float' to 'int8x8_t' in initialization} }\n+  int8x8_t *ptr2 = &x; // { dg-error {cannot convert 'float\\*' to 'int8x8_t\\*' in initialization} }\n+  myvec y3 = x; // { dg-error {cannot convert 'float' to 'myvec' {aka 'int16x4_t'} in initialization} }\n+  myvec *ptr3 = &x; // { dg-error {cannot convert 'float\\*' to 'myvec\\*' {aka 'int16x4_t\\*'} in initialization} }\n+}"}]}