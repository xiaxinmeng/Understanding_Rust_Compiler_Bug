{"sha": "2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIyNWI5ZjI5ODI3NzVjN2Q4OWZjZDdkMDRhZGJlNDcyMmJhNTljMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-07-24T17:28:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-07-24T17:28:41Z"}, "message": "Introduce and use unknown_optab\n\nPrep for a later patch where this becomes an enum value.\n\n        * optabs.h (unknown_optab): New.\n        * builtins.c (interclass_mathfn_icode): Use it.\n        * dojump.c (do_compare_rtx_and_jump): Likewise.\n        * optabs.c (optab_for_tree_code, expand_binop): Likewise.\n        * tree-vect-generic.c (add_rshift, expand_vector_divmod): Likewise.\n        (expand_vector_operations_1): Likewise.\n        * tree-vect-patterns.c (vect_recog_divmod_pattern): Likewise.\n        * tree-vect-stmts.c (supportable_narrowing_operation): Likewise.\n\nFrom-SVN: r189816", "tree": {"sha": "528f887d302a83c24849f9d2bb197affe426e5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528f887d302a83c24849f9d2bb197affe426e5e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/comments", "author": null, "committer": null, "parents": [{"sha": "0c471ab87bdb5fc3ff87560f64f78375ae6d386e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c471ab87bdb5fc3ff87560f64f78375ae6d386e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c471ab87bdb5fc3ff87560f64f78375ae6d386e"}], "stats": {"total": 68, "additions": 39, "deletions": 29}, "files": [{"sha": "e6479f2ae2dedf293907c9161e7364bac30a4f17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -1,3 +1,14 @@\n+2012-07-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.h (unknown_optab): New.\n+\t* builtins.c (interclass_mathfn_icode): Use it.\n+\t* dojump.c (do_compare_rtx_and_jump): Likewise.\n+\t* optabs.c (optab_for_tree_code, expand_binop): Likewise.\n+\t* tree-vect-generic.c (add_rshift, expand_vector_divmod): Likewise.\n+\t(expand_vector_operations_1): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Likewise.\n+\t* tree-vect-stmts.c (supportable_narrowing_operation): Likewise.\n+\n 2012-07-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* alloc-pool.c (create_alloc_pool): Fix ENABLE_CHECKING check."}, {"sha": "ba0655bea8e0ad5b4b3a122509846fd41f518a8a", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -2360,7 +2360,7 @@ static enum insn_code\n interclass_mathfn_icode (tree arg, tree fndecl)\n {\n   bool errno_set = false;\n-  optab builtin_optab = 0;\n+  optab builtin_optab = unknown_optab;\n   enum machine_mode mode;\n \n   switch (DECL_FUNCTION_CODE (fndecl))"}, {"sha": "24eed63e491d36ded8978b4543c4b884c798c5e6", "filename": "gcc/dojump.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -1028,19 +1028,16 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t  op0 = op1;\n \t  op1 = tmp;\n \t}\n-\n       else if (SCALAR_FLOAT_MODE_P (mode)\n \t       && ! can_compare_p (code, mode, ccp_jump)\n-\n-\t       /* Never split ORDERED and UNORDERED.  These must be implemented.  */\n+\t       /* Never split ORDERED and UNORDERED.\n+\t\t  These must be implemented.  */\n \t       && (code != ORDERED && code != UNORDERED)\n-\n-               /* Split a floating-point comparison if we can jump on other\n-\t          conditions...  */\n+               /* Split a floating-point comparison if\n+\t\t  we can jump on other conditions...  */\n \t       && (have_insn_for (COMPARE, mode)\n-\n \t           /* ... or if there is no libcall for it.  */\n-\t           || code_to_optab[code] == NULL))\n+\t           || code_to_optab[code] == unknown_optab))\n         {\n \t  enum rtx_code first_code;\n \t  bool and_them = split_comparison (code, mode, &first_code, &code);"}, {"sha": "f30a20dd3fd36cd27fc413951aa43e3450db0f5e", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -390,7 +390,7 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n       if (TREE_CODE (type) == VECTOR_TYPE)\n \t{\n \t  if (subtype == optab_vector)\n-\t    return TYPE_SATURATING (type) ? NULL : vashl_optab;\n+\t    return TYPE_SATURATING (type) ? unknown_optab : vashl_optab;\n \n \t  gcc_assert (subtype == optab_scalar);\n \t}\n@@ -560,7 +560,7 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n       return trapv ? absv_optab : abs_optab;\n \n     default:\n-      return NULL;\n+      return unknown_optab;\n     }\n }\n \f\n@@ -1580,7 +1580,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      shift by a vector.  If so, broadcast the scalar into a vector.  */\n   if (mclass == MODE_VECTOR_INT)\n     {\n-      optab otheroptab = NULL;\n+      optab otheroptab = unknown_optab;\n \n       if (binoptab == ashl_optab)\n \totheroptab = vashl_optab;"}, {"sha": "c502766d9e8e98d41d00b1de08635b454749a877", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -412,6 +412,8 @@ enum optab_index\n   OTI_MAX\n };\n \n+#define unknown_optab NULL\n+\n #define ssadd_optab (&optab_table[OTI_ssadd])\n #define usadd_optab (&optab_table[OTI_usadd])\n #define sssub_optab (&optab_table[OTI_sssub])"}, {"sha": "9c8a70ed218375c9b7da1d7d2c0a770c3b4f79b1", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -414,14 +414,14 @@ add_rshift (gimple_stmt_iterator *gsi, tree type, tree op0, int *shiftcnts)\n   if (scalar_shift)\n     {\n       op = optab_for_tree_code (RSHIFT_EXPR, type, optab_scalar);\n-      if (op != NULL\n+      if (op != unknown_optab\n \t  && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n \treturn gimplify_build2 (gsi, RSHIFT_EXPR, type, op0,\n \t\t\t\tbuild_int_cst (NULL_TREE, shiftcnts[0]));\n     }\n \n   op = optab_for_tree_code (RSHIFT_EXPR, type, optab_vector);\n-  if (op != NULL\n+  if (op != unknown_optab\n       && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n     {\n       tree *vec = XALLOCAVEC (tree, nunits);\n@@ -462,7 +462,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n     return NULL_TREE;\n \n   op = optab_for_tree_code (RSHIFT_EXPR, type, optab_vector);\n-  if (op == NULL\n+  if (op == unknown_optab\n       || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n     has_vector_shift = false;\n \n@@ -689,7 +689,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t      /* t1 = op0 + addend;\n \t\t q = t1 >> shift;  */\n \t      op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n-\t      if (op != NULL\n+\t      if (op != unknown_optab\n \t\t  && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n \t\t{\n \t\t  cur_op = gimplify_build2 (gsi, PLUS_EXPR, type, op0, addend);\n@@ -708,7 +708,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t\t\t     << shifts[i]) - 1);\n \t  mask = build_vector (type, vec);\n \t  op = optab_for_tree_code (BIT_AND_EXPR, type, optab_default);\n-\t  if (op != NULL\n+\t  if (op != unknown_optab\n \t      && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n \t    {\n \t      if (unsignedp)\n@@ -720,7 +720,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t     t2 = t1 & mask;\n \t\t     r = t2 - addend;  */\n \t\t  op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n-\t\t  if (op != NULL\n+\t\t  if (op != unknown_optab\n \t\t      && optab_handler (op, TYPE_MODE (type))\n \t\t\t != CODE_FOR_nothing)\n \t\t    {\n@@ -730,7 +730,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t\t\t\t\tcur_op, mask);\n \t\t      op = optab_for_tree_code (MINUS_EXPR, type,\n \t\t\t\t\t\toptab_default);\n-\t\t      if (op != NULL\n+\t\t      if (op != unknown_optab\n \t\t\t  && optab_handler (op, TYPE_MODE (type))\n \t\t\t     != CODE_FOR_nothing)\n \t\t\treturn gimplify_build2 (gsi, MINUS_EXPR, type,\n@@ -801,13 +801,13 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t t4 = t1 + t3;\n \t q = t4 >> (post_shift - 1);  */\n       op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n-      if (op == NULL\n+      if (op == unknown_optab\n \t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n \treturn NULL_TREE;\n       tem = gimplify_build2 (gsi, MINUS_EXPR, type, op0, cur_op);\n       tem = add_rshift (gsi, type, tem, shift_temps);\n       op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n-      if (op == NULL\n+      if (op == unknown_optab\n \t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n \treturn NULL_TREE;\n       tem = gimplify_build2 (gsi, PLUS_EXPR, type, cur_op, tem);\n@@ -829,7 +829,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       if ((mode & 2) == 0)\n \t{\n \t  op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n-\t  if (op == NULL\n+\t  if (op == unknown_optab\n \t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n \t    return NULL_TREE;\n \t  cur_op = gimplify_build2 (gsi, PLUS_EXPR, type, cur_op, op0);\n@@ -841,7 +841,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       if (tem == NULL_TREE)\n \treturn NULL_TREE;\n       op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n-      if (op == NULL\n+      if (op == unknown_optab\n \t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n \treturn NULL_TREE;\n       if ((mode & 1) == 0)\n@@ -860,12 +860,12 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n      t1 = q * oprnd1;\n      r = oprnd0 - t1;  */\n   op = optab_for_tree_code (MULT_EXPR, type, optab_default);\n-  if (op == NULL\n+  if (op == unknown_optab\n       || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n     return NULL_TREE;\n   tem = gimplify_build2 (gsi, MULT_EXPR, type, cur_op, op1);\n   op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n-  if (op == NULL\n+  if (op == unknown_optab\n       || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n     return NULL_TREE;\n   return gimplify_build2 (gsi, MINUS_EXPR, type, op0, tem);\n@@ -1235,7 +1235,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   tree lhs, rhs1, rhs2 = NULL, type, compute_type;\n   enum tree_code code;\n   enum machine_mode compute_mode;\n-  optab op = NULL;\n+  optab op = unknown_optab;\n   enum gimple_rhs_class rhs_class;\n   tree new_rhs;\n \n@@ -1344,7 +1344,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   /* Optabs will try converting a negation into a subtraction, so\n      look for it as well.  TODO: negation of floating-point vectors\n      might be turned into an exclusive OR toggling the sign bit.  */\n-  if (op == NULL\n+  if (op == unknown_optab\n       && code == NEGATE_EXPR\n       && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n     op = optab_for_tree_code (MINUS_EXPR, type, optab_default);"}, {"sha": "aa731cae3a5730dfaf9a7607bfe26add04ef3142", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -1675,7 +1675,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n   /* If the target can handle vectorized division or modulo natively,\n      don't attempt to optimize this.  */\n   optab = optab_for_tree_code (rhs_code, vectype, optab_default);\n-  if (optab != NULL)\n+  if (optab != unknown_optab)\n     {\n       enum machine_mode vec_mode = TYPE_MODE (vectype);\n       int icode = (int) optab_handler (optab, vec_mode);"}, {"sha": "6b9d327082a8451c5d584ea4cfa0dd10c6cd35c4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b9f2982775c7d89fcd7d04adbe4722ba59c3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2225b9f2982775c7d89fcd7d04adbe4722ba59c3", "patch": "@@ -6545,7 +6545,7 @@ supportable_narrowing_operation (enum tree_code code,\n \t= lang_hooks.types.type_for_mode (TYPE_MODE (vectype_out), 0);\n       interm_optab\n \t= optab_for_tree_code (c1, intermediate_type, optab_default);\n-      if (interm_optab != NULL\n+      if (interm_optab != unknown_optab\n \t  && (icode2 = optab_handler (optab1, vec_mode)) != CODE_FOR_nothing\n \t  && insn_data[icode1].operand[0].mode\n \t     == insn_data[icode2].operand[0].mode)"}]}