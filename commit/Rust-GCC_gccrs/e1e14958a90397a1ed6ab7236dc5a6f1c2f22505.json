{"sha": "e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFlMTQ5NThhOTAzOTdhMWVkNmFiNzIzNmRjNWE2ZjFjMmYyMjUwNQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-07-08T22:32:30Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-07-11T19:09:21Z"}, "message": "Handle doc comment strings in lexer and parser\n\nRemove (unused) comment related tokens and replace them with\nINNER_DOC_COMMENT and OUTER_DOC_COMMENT tokens, which keep the comment\ntext as a string. These can be constructed with the new\nmake_inner_doc_comment and make_outer_doc_comment methods.\n\nMake sure to not confuse doc strings with normal comments in the lexer\nwhen detecting shebang lines. Both single line //! and /*! */ blocks\nare turned into INNER_DOC_COMMENT tokens. And both single line /// and\n/** */ blocks are turned into OUTER_DOC_COMMENT tokens.\n\nAlso fixes some issues with cr/lf line endings and keeping the line\nmap correct when seeing \\n in a comment.\n\nIn the parser handle INNER_DOC_COMMENT and OUTER_DOC_COMMENTS where\ninner (#[]) and outer (#![]) attributes are handled. Add a method\nparse_doc_comment which turns the tokens into an \"doc\" Attribute with\nthe string as literal expression.\n\nAdd get_locus method to Attribute class for better error reporting.\n\nTests are added for correctly placed and formatted doc strings, with\nor without cr/lf line endings. Incorrect formatted (isolated CRs) doc\nstrings and badly placed inner doc strings. No tests add handling of\nthe actual doc attributes yet. These could be tested once we add\nsupport for the #![warn(missing_docs)] attribute.", "tree": {"sha": "9c16ca669be22146c007ad846f32f81158828b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c16ca669be22146c007ad846f32f81158828b65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/comments", "author": null, "committer": null, "parents": [{"sha": "4560f469ee33536cec6af0f8e5816ff97de60de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4560f469ee33536cec6af0f8e5816ff97de60de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4560f469ee33536cec6af0f8e5816ff97de60de0"}], "stats": {"total": 431, "additions": 401, "deletions": 30}, "files": [{"sha": "3e3e185b9b5945967a64ba31e0381ec28e3fc5e6", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -455,6 +455,8 @@ struct Attribute\n   // Returns whether the attribute is considered an \"empty\" attribute.\n   bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n \n+  Location get_locus () const { return locus; }\n+\n   /* e.g.:\n       #![crate_type = \"lib\"]\n       #[test]"}, {"sha": "0b8a8eae65198a880f8bf2db39e2de03b29ace69", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 198, "deletions": 16, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -265,9 +265,16 @@ Lexer::build_token ()\n \t      int next_char = peek_input (n);\n \t      if (is_whitespace (next_char))\n \t\tn++;\n-\t      else if (next_char == '/' && peek_input (n + 1) == '/')\n+\t      else if ((next_char == '/' && peek_input (n + 1) == '/'\n+\t\t\t&& peek_input (n + 2) != '!'\n+\t\t\t&& peek_input (n + 2) != '/')\n+\t\t       || (next_char == '/' && peek_input (n + 1) == '/'\n+\t\t\t   && peek_input (n + 2) == '/'\n+\t\t\t   && peek_input (n + 3) == '/'))\n \t\t{\n+\t\t  // two // or four ////\n \t\t  // A single line comment\n+\t\t  // (but not an inner or outer doc comment)\n \t\t  n += 2;\n \t\t  next_char = peek_input (n);\n \t\t  while (next_char != '\\n' && next_char != EOF)\n@@ -278,9 +285,30 @@ Lexer::build_token ()\n \t\t  if (next_char == '\\n')\n \t\t    n++;\n \t\t}\n-\t      else if (next_char == '/' && peek_input (n + 1) == '*')\n+\t      else if (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t       && peek_input (n + 2) == '*'\n+\t\t       && peek_input (n + 3) == '/')\n \t\t{\n+\t\t  /**/\n+\t\t  n += 4;\n+\t\t}\n+\t      else if (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t       && peek_input (n + 2) == '*' && peek_input (n + 3) == '*'\n+\t\t       && peek_input (n + 4) == '/')\n+\t\t{\n+\t\t  /***/\n+\t\t  n += 5;\n+\t\t}\n+\t      else if ((next_char == '/' && peek_input (n + 1) == '*'\n+\t\t\t&& peek_input (n + 2) != '*'\n+\t\t\t&& peek_input (n + 2) != '!')\n+\t\t       || (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t\t   && peek_input (n + 2) == '*'\n+\t\t\t   && peek_input (n + 3) == '*'))\n+\t\t{\n+\t\t  // one /* or three /***\n \t\t  // Start of a block comment\n+\t\t  // (but not an inner or outer doc comment)\n \t\t  n += 2;\n \t\t  int level = 1;\n \t\t  while (level > 0)\n@@ -339,6 +367,9 @@ Lexer::build_token ()\n \t  // tell line_table that new line starts\n \t  line_map->start_line (current_line, max_column_hint);\n \t  continue;\n+\tcase '\\r': // cr\n+\t  // Ignore, we expect a newline (lf) soon.\n+\t  continue;\n \tcase ' ': // space\n \t  current_column++;\n \t  continue;\n@@ -445,11 +476,14 @@ Lexer::build_token ()\n \n \t      return Token::make (DIV_EQ, loc);\n \t    }\n-\t  else if (peek_input () == '/')\n+\t  else if ((peek_input () == '/' && peek_input (1) != '!'\n+\t\t    && peek_input (1) != '/')\n+\t\t   || (peek_input () == '/' && peek_input (1) == '/'\n+\t\t       && peek_input (2) == '/'))\n \t    {\n-\t      // TODO: single-line doc comments\n-\n+\t      // two // or four ////\n \t      // single line comment\n+\t      // (but not an inner or outer doc comment)\n \t      skip_input ();\n \t      current_column += 2;\n \n@@ -461,23 +495,85 @@ Lexer::build_token ()\n \t\t  current_char = peek_input ();\n \t\t}\n \t      continue;\n-\t      break;\n \t    }\n-\t  else if (peek_input () == '*')\n+\t  else if (peek_input () == '/'\n+\t\t   && (peek_input (1) == '!' || peek_input (1) == '/'))\n \t    {\n+\t      /* single line doc comment, inner or outer.  */\n+\t      bool is_inner = peek_input (1) == '!';\n+\t      skip_input (1);\n+\t      current_column += 3;\n+\n+\t      std::string str;\n+\t      str.reserve (32);\n+\t      current_char = peek_input ();\n+\t      while (current_char != '\\n')\n+\t\t{\n+\t\t  skip_input ();\n+\t\t  if (current_char == '\\r')\n+\t\t    {\n+\t\t      char next_char = peek_input ();\n+\t\t      if (next_char == '\\n')\n+\t\t\t{\n+\t\t\t  current_char = '\\n';\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      rust_error_at (\n+\t\t\tloc, \"Isolated CR %<\\\\r%> not allowed in doc comment\");\n+\t\t      current_char = next_char;\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (current_char == EOF)\n+\t\t    {\n+\t\t      rust_error_at (\n+\t\t\tloc, \"unexpected EOF while looking for end of comment\");\n+\t\t      break;\n+\t\t    }\n+\t\t  str += current_char;\n+\t\t  current_char = peek_input ();\n+\t\t}\n+\t      skip_input ();\n+\t      current_line++;\n+\t      current_column = 1;\n+\t      // tell line_table that new line starts\n+\t      line_map->start_line (current_line, max_column_hint);\n+\n+\t      str.shrink_to_fit ();\n+\t      if (is_inner)\n+\t\treturn Token::make_inner_doc_comment (loc, std::move (str));\n+\t      else\n+\t\treturn Token::make_outer_doc_comment (loc, std::move (str));\n+\t    }\n+\t  else if (peek_input () == '*' && peek_input (1) == '*'\n+\t\t   && peek_input (2) == '/')\n+\t    {\n+\t      /**/\n+\t      skip_input (2);\n+\t      current_column += 4;\n+\t      continue;\n+\t    }\n+\t  else if (peek_input () == '*' && peek_input (1) == '*'\n+\t\t   && peek_input (2) == '*' && peek_input (3) == '/')\n+\t    {\n+\t      /***/\n+\t      skip_input (3);\n+\t      current_column += 5;\n+\t      continue;\n+\t    }\n+\t  else if ((peek_input () == '*' && peek_input (1) != '!'\n+\t\t    && peek_input (1) != '*')\n+\t\t   || (peek_input () == '*' && peek_input (1) == '*'\n+\t\t       && peek_input (2) == '*'))\n+\t    {\n+\t      // one /* or three /***\n \t      // block comment\n+\t      // (but not an inner or outer doc comment)\n \t      skip_input ();\n \t      current_column += 2;\n \n-\t      // TODO: block doc comments\n-\n-\t      current_char = peek_input ();\n-\n \t      int level = 1;\n \t      while (level > 0)\n \t\t{\n-\t\t  skip_input ();\n-\t\t  current_column++; // for error-handling\n \t\t  current_char = peek_input ();\n \n \t\t  if (current_char == EOF)\n@@ -496,6 +592,7 @@ Lexer::build_token ()\n \t\t      current_column += 2;\n \n \t\t      level += 1;\n+\t\t      continue;\n \t\t    }\n \n \t\t  // ignore until */ is found\n@@ -505,16 +602,101 @@ Lexer::build_token ()\n \t\t      skip_input (1);\n \n \t\t      current_column += 2;\n-\t\t      // should only break inner loop here - seems to do so\n-\t\t      // break;\n \n \t\t      level -= 1;\n+\t\t      continue;\n \t\t    }\n+\n+\t\t  if (current_char == '\\n')\n+\t\t    {\n+\t\t      skip_input ();\n+\t\t      current_line++;\n+\t\t      current_column = 1;\n+\t\t      // tell line_table that new line starts\n+\t\t      line_map->start_line (current_line, max_column_hint);\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  skip_input ();\n+\t\t  current_column++;\n \t\t}\n \n \t      // refresh new token\n \t      continue;\n-\t      break;\n+\t    }\n+\t  else if (peek_input () == '*'\n+\t\t   && (peek_input (1) == '!' || peek_input (1) == '*'))\n+\t    {\n+\t      // block doc comment, inner /*! or outer /**\n+\t      bool is_inner = peek_input (1) == '!';\n+\t      skip_input (1);\n+\t      current_column += 3;\n+\n+\t      std::string str;\n+\t      str.reserve (96);\n+\n+\t      int level = 1;\n+\t      while (level > 0)\n+\t\t{\n+\t\t  current_char = peek_input ();\n+\n+\t\t  if (current_char == EOF)\n+\t\t    {\n+\t\t      rust_error_at (\n+\t\t\tloc, \"unexpected EOF while looking for end of comment\");\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  // if /* found\n+\t\t  if (current_char == '/' && peek_input (1) == '*')\n+\t\t    {\n+\t\t      // skip /* characters\n+\t\t      skip_input (1);\n+\t\t      current_column += 2;\n+\n+\t\t      level += 1;\n+\t\t      str += \"/*\";\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  // ignore until */ is found\n+\t\t  if (current_char == '*' && peek_input (1) == '/')\n+\t\t    {\n+\t\t      // skip */ characters\n+\t\t      skip_input (1);\n+\t\t      current_column += 2;\n+\n+\t\t      level -= 1;\n+\t\t      if (level > 0)\n+\t\t\tstr += \"*/\";\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  if (current_char == '\\r' && peek_input (1) != '\\n')\n+\t\t    rust_error_at (\n+\t\t      loc, \"Isolated CR %<\\\\r%> not allowed in doc comment\");\n+\n+\t\t  if (current_char == '\\n')\n+\t\t    {\n+\t\t      skip_input ();\n+\t\t      current_line++;\n+\t\t      current_column = 1;\n+\t\t      // tell line_table that new line starts\n+\t\t      line_map->start_line (current_line, max_column_hint);\n+\t\t      str += '\\n';\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  str += current_char;\n+\t\t  skip_input ();\n+\t\t  current_column++;\n+\t\t}\n+\n+\t      str.shrink_to_fit ();\n+\t      if (is_inner)\n+\t\treturn Token::make_inner_doc_comment (loc, std::move (str));\n+\t      else\n+\t\treturn Token::make_outer_doc_comment (loc, std::move (str));\n \t    }\n \t  else\n \t    {"}, {"sha": "1c397c839fdbfc99e0358217bf088122639e5daa", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -151,15 +151,10 @@ enum PrimitiveCoreType\n   RS_TOKEN (RIGHT_SQUARE, \"]\")                                                 \\\n   /* Macros */                                                                 \\\n   RS_TOKEN (DOLLAR_SIGN, \"$\")                                                  \\\n-  /* Comments */                                                               \\\n-  RS_TOKEN (LINE_COMMENT, \"//\")                                                \\\n-  RS_TOKEN (INNER_LINE_DOC, \"//!\")                                             \\\n-  RS_TOKEN (OUTER_LINE_DOC, \"///\")                                             \\\n-  RS_TOKEN (BLOCK_COMMENT_START, \"/*\")                                         \\\n-  RS_TOKEN (BLOCK_COMMENT_END, \"*/\")                                           \\\n-  RS_TOKEN (INNER_BLOCK_DOC_START, \"/*!\")                                      \\\n-  RS_TOKEN (OUTER_BLOCK_DOC_START,                                             \\\n-\t    \"/**\") /* have \"weak\" union and 'static keywords? */               \\\n+  /* Doc Comments */                                                           \\\n+  RS_TOKEN (INNER_DOC_COMMENT, \"#![doc]\")                                      \\\n+  RS_TOKEN (OUTER_DOC_COMMENT, \"#[doc]\")                                       \\\n+  /* have \"weak\" union and 'static keywords? */                                \\\n                                                                                \\\n   RS_TOKEN_KEYWORD (ABSTRACT, \"abstract\") /* unused */                         \\\n   RS_TOKEN_KEYWORD (AS, \"as\")                                                  \\\n@@ -368,6 +363,18 @@ class Token\n     return TokenPtr (new Token (BYTE_STRING_LITERAL, locus, std::move (str)));\n   }\n \n+  // Makes and returns a new TokenPtr of type INNER_DOC_COMMENT.\n+  static TokenPtr make_inner_doc_comment (Location locus, std::string &&str)\n+  {\n+    return TokenPtr (new Token (INNER_DOC_COMMENT, locus, std::move (str)));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type OUTER_DOC_COMMENT.\n+  static TokenPtr make_outer_doc_comment (Location locus, std::string &&str)\n+  {\n+    return TokenPtr (new Token (OUTER_DOC_COMMENT, locus, std::move (str)));\n+  }\n+\n   // Makes and returns a new TokenPtr of type LIFETIME.\n   static TokenPtr make_lifetime (Location locus, std::string &&str)\n   {"}, {"sha": "eedc76db43ed3ea4afe2da8f2075b8138d89754a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -434,8 +434,9 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n   AST::AttrVec inner_attributes;\n \n   // only try to parse it if it starts with \"#!\" not only \"#\"\n-  while (lexer.peek_token ()->get_id () == HASH\n-\t && lexer.peek_token (1)->get_id () == EXCLAM)\n+  while ((lexer.peek_token ()->get_id () == HASH\n+\t  && lexer.peek_token (1)->get_id () == EXCLAM)\n+\t || lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n     {\n       AST::Attribute inner_attr = parse_inner_attribute ();\n \n@@ -457,11 +458,33 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n   return inner_attributes;\n }\n \n+// Parse a inner or outer doc comment into an doc attribute\n+template <typename ManagedTokenSource>\n+AST::Attribute\n+Parser<ManagedTokenSource>::parse_doc_comment ()\n+{\n+  const_TokenPtr token = lexer.peek_token ();\n+  Location locus = token->get_locus ();\n+  AST::SimplePathSegment segment (\"doc\", locus);\n+  std::vector<AST::SimplePathSegment> segments;\n+  segments.push_back (std::move (segment));\n+  AST::SimplePath attr_path (std::move (segments), false, locus);\n+  AST::LiteralExpr lit_expr (token->get_str (), AST::Literal::STRING,\n+\t\t\t     PrimitiveCoreType::CORETYPE_STR, {}, locus);\n+  std::unique_ptr<AST::AttrInput> attr_input (\n+    new AST::AttrInputLiteral (std::move (lit_expr)));\n+  lexer.skip_token ();\n+  return AST::Attribute (std::move (attr_path), std::move (attr_input), locus);\n+}\n+\n // Parse a single inner attribute.\n template <typename ManagedTokenSource>\n AST::Attribute\n Parser<ManagedTokenSource>::parse_inner_attribute ()\n {\n+  if (lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n+    return parse_doc_comment ();\n+\n   if (lexer.peek_token ()->get_id () != HASH)\n     {\n       Error error (lexer.peek_token ()->get_locus (),\n@@ -1019,7 +1042,15 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n   switch (t->get_id ())\n     {\n     case END_OF_FILE:\n-      // not necessarily an error\n+      // not necessarily an error, unless we just read outer\n+      // attributes which needs to be attached\n+      if (!outer_attrs.empty ())\n+\t{\n+\t  Rust::AST::Attribute attr = outer_attrs.back ();\n+\t  Error error (attr.get_locus (),\n+\t\t       \"expected item after outer attribute or doc comment\");\n+\t  add_error (std::move (error));\n+\t}\n       return nullptr;\n     case PUB:\n     case MOD:\n@@ -1091,7 +1122,11 @@ Parser<ManagedTokenSource>::parse_outer_attributes ()\n {\n   AST::AttrVec outer_attributes;\n \n-  while (lexer.peek_token ()->get_id () == HASH)\n+  while (lexer.peek_token ()->get_id ()\n+\t   == HASH /* Can also be #!, which catches errors.  */\n+\t || lexer.peek_token ()->get_id () == OUTER_DOC_COMMENT\n+\t || lexer.peek_token ()->get_id ()\n+\t      == INNER_DOC_COMMENT) /* For error handling.  */\n     {\n       AST::Attribute outer_attr = parse_outer_attribute ();\n \n@@ -1121,6 +1156,20 @@ template <typename ManagedTokenSource>\n AST::Attribute\n Parser<ManagedTokenSource>::parse_outer_attribute ()\n {\n+  if (lexer.peek_token ()->get_id () == OUTER_DOC_COMMENT)\n+    return parse_doc_comment ();\n+\n+  if (lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n+    {\n+      Error error (\n+\tlexer.peek_token ()->get_locus (),\n+\t\"inner doc (%<//!%> or %</*!%>) only allowed at start of item \"\n+\t\"and before any outer attribute or doc (%<#[%>, %<///%> or %</**%>)\");\n+      add_error (std::move (error));\n+      lexer.skip_token ();\n+      return AST::Attribute::create_empty ();\n+    }\n+\n   /* OuterAttribute -> '#' '[' Attr ']' */\n \n   if (lexer.peek_token ()->get_id () != HASH)\n@@ -1134,12 +1183,13 @@ Parser<ManagedTokenSource>::parse_outer_attribute ()\n       if (id == EXCLAM)\n \t{\n \t  // this is inner attribute syntax, so throw error\n+\t  // inner attributes were either already parsed or not allowed here.\n \t  Error error (\n \t    lexer.peek_token ()->get_locus (),\n \t    \"token %<!%> found, indicating inner attribute definition. Inner \"\n \t    \"attributes are not possible at this location\");\n \t  add_error (std::move (error));\n-\t} // TODO: are there any cases where this wouldn't be an error?\n+\t}\n       return AST::Attribute::create_empty ();\n     }\n "}, {"sha": "1cd85eae8c2e66f316368cb543304f7ab1c6a2ff", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -107,6 +107,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::Attribute parse_outer_attribute ();\n   AST::Attribute parse_attribute_body ();\n   std::unique_ptr<AST::AttrInput> parse_attr_input ();\n+  AST::Attribute parse_doc_comment ();\n \n   // Path-related\n   AST::SimplePath parse_simple_path ();"}, {"sha": "cfd166ce3ec9d244892bdd6632bd2288e3b56404", "filename": "gcc/testsuite/rust/compile/bad_inner_doc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,15 @@\n+pub fn main ()\n+{\n+  //! inner doc allowed\n+  let _x = 42;\n+  // { dg-error \"inner doc\" \"\" { target *-*-* } .+1 }\n+  //! inner doc disallowed\n+  mod module\n+  {\n+    /*! inner doc allowed */\n+    /// outer doc allowed\n+    // { dg-error \"inner doc\" \"\" { target *-*-* } .+1 }\n+    /*! but inner doc not here */\n+    mod x { }\n+  }\n+}"}, {"sha": "0ada77f69cf76627b43ef274c6df7b59bf0c8ebd", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_block_comment.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,3 @@\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+/** doc cr\r comment */\n+pub fn main () { }"}, {"sha": "7db35341bee163327ceaffeb36578600ef097b80", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_inner_block_comment.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,5 @@\n+pub fn main ()\n+{\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+  /*! doc cr\r comment */\n+}"}, {"sha": "d75da75e2189b0e1ebd255e9f849382fc53dd52d", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_inner_line_comment.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,5 @@\n+pub fn main ()\n+{\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+  //! doc cr\r comment\n+}"}, {"sha": "7b6ef989c308ad9f658c19163d40d7f7dfce7867", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_line_comment.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,3 @@\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+/// doc cr\r comment\n+pub fn main () { }"}, {"sha": "ab38ac696105dd4a3c19e6421b00f9fa697ca494", "filename": "gcc/testsuite/rust/compile/torture/all_doc_comment_line_blocks.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,47 @@\n+// comment line not a doc\n+/* comment block not a doc                   */\n+\n+//! inner line comment for most outer crate\n+/*! inner block comment for most outer crate */\n+\n+// comment line not a doc\n+/* comment block not a doc                   */\n+\n+/// outer doc line for module\n+/** outer doc block for module               */\n+pub mod module\n+{\n+  //!  inner line doc\n+  //!! inner line doc!\n+  /*!  inner block doc  */\n+  /*!! inner block doc! */\n+\n+  //   line comment\n+  ///  outer line doc\n+  //// line comment\n+\n+  /*   block comment   */\n+  /**  outer block doc */\n+  /*** block comment   */\n+\n+  mod block_doc_comments\n+  {\n+    /*   /* */  /** */  /*! */  */\n+    /*!  /* */  /** */  /*! */  */\n+    /**  /* */  /** */  /*! */  */\n+    mod item { }\n+  }\n+\n+  pub mod empty\n+  {\n+    //!\n+    /*!*/\n+    //\n+\n+    ///\n+    mod doc { }\n+    /**/\n+    /***/\n+  }\n+}\n+pub fn main () { }"}, {"sha": "3ea2cd01c8cf7961783d259cc52de00ccd633cb8", "filename": "gcc/testsuite/rust/compile/torture/all_doc_comment_line_blocks_crlf.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,47 @@\n+// comment line not a doc\r\n+/* comment block not a doc                   */\r\n+\r\n+//! inner line comment for most outer crate\r\n+/*! inner block comment for most outer crate */\r\n+\r\n+// comment line not a doc\r\n+/* comment block not a doc                   */\r\n+\r\n+/// outer doc line for module\r\n+/** outer doc block for module               */\r\n+pub mod module\r\n+{\r\n+  //!  inner line doc\r\n+  //!! inner line doc!\r\n+  /*!  inner block doc  */\r\n+  /*!! inner block doc! */\r\n+\r\n+  //   line comment\r\n+  ///  outer line doc\r\n+  //// line comment\r\n+\r\n+  /*   block comment   */\r\n+  /**  outer block doc */\r\n+  /*** block comment   */\r\n+\r\n+  mod block_doc_comments\r\n+  {\r\n+    /*   /* */  /** */  /*! */  */\r\n+    /*!  /* */  /** */  /*! */  */\r\n+    /**  /* */  /** */  /*! */  */\r\n+    mod item { }\r\n+  }\r\n+\r\n+  pub mod empty\r\n+  {\r\n+    //!\r\n+    /*!*/\r\n+    //\r\n+\r\n+    ///\r\n+    mod doc { }\r\n+    /**/\r\n+    /***/\r\n+  }\r\n+}\r\n+pub fn main () { }\r"}, {"sha": "9a1e090f330f1ecc3a79493b952f30b35c3afc79", "filename": "gcc/testsuite/rust/compile/torture/isolated_cr_block_comment.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,2 @@\n+/* comment cr\r is allowed */\n+pub fn main () { }"}, {"sha": "4e921a225c27baddc346e7a83fc6e8eb43ef61e0", "filename": "gcc/testsuite/rust/compile/torture/isolated_cr_line_comment.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e14958a90397a1ed6ab7236dc5a6f1c2f22505/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs?ref=e1e14958a90397a1ed6ab7236dc5a6f1c2f22505", "patch": "@@ -0,0 +1,2 @@\n+// comment cr\r is allowed\n+pub fn main () { }"}]}