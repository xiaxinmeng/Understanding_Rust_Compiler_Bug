{"sha": "09845ad7569bac27c3a1dc7b410d9df764d2ca06", "node_id": "C_kwDOANBUbNoAKDA5ODQ1YWQ3NTY5YmFjMjdjM2ExZGM3YjQxMGQ5ZGY3NjRkMmNhMDY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-20T14:25:49Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-20T14:25:49Z"}, "message": "c++: CTAD inside alias template [PR91911, PR103672]\n\nIn the first testcase below, when processing the alias template\nConstSpanType, transparency of alias template specializations means we\nreplace SpanType<T> with its instantiated definition.  But this\ninstantiation lowers the level of the CTAD placeholder for span{T()} from\n2 to 1, and so the later instantiation of ConstSpanType<int> erroneously\nsubstitutes this CTAD placeholder with the template argument at level 1\nindex 0, i.e. with int, before we get a chance to perform the CTAD.\n\nAlthough we represent CTAD placeholders as template parameters, we never\nactually want to replace them via tsubst.  So this patch adjusts tsubst\nto handle CTAD placeholders by simply substituting the template and\nreturning a new CTAD placeholder.  Moreover, this means that the level\nof a CTAD placeholder doesn't matter, so we may as well give them all\nthe same level.  This patch gives them the special level 0.\n\nThe change in tsubst_decl removes a likely dead !CHECKING_P safeguard\nadded in 2017, which would otherwise now get triggered for variables\nwith CTAD placeholder types (since their level is 0).\n\n\tPR c++/91911\n\tPR c++/103672\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (keep_template_parm): Punt on a level 0 template parm.\n\t(tsubst_decl) <case VAR_DECL>: Remove !CHECKING_P safeguard.\n\t(tsubst) <case TEMPLATE_TYPE_PARM>: Handle CTAD placeholders\n\tspecially.\n\t(make_auto_1): Add defaulted 'level' parameter.\n\t(make_template_placeholder): Pass 0 as 'level' to make_auto_1.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/class-deduction101.C: New test.\n\t* g++.dg/cpp1z/class-deduction101a.C: New test.\n\t* g++.dg/cpp1z/class-deduction101b.C: New test.\n\t* g++.dg/cpp1z/class-deduction102.C: New test.\n\t* g++.dg/cpp1z/class-deduction102a.C: New test.\n\t* g++.dg/cpp1z/class-deduction102b.C: New test.\n\t* g++.dg/cpp1z/class-deduction103.C: New test.", "tree": {"sha": "0a10b62413a6a7f4ad8b225a71a84a0030617967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a10b62413a6a7f4ad8b225a71a84a0030617967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09845ad7569bac27c3a1dc7b410d9df764d2ca06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09845ad7569bac27c3a1dc7b410d9df764d2ca06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09845ad7569bac27c3a1dc7b410d9df764d2ca06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09845ad7569bac27c3a1dc7b410d9df764d2ca06/comments", "author": null, "committer": null, "parents": [{"sha": "2cda2bfa3fd0f2a0122433d2d870843633e2a312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cda2bfa3fd0f2a0122433d2d870843633e2a312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cda2bfa3fd0f2a0122433d2d870843633e2a312"}], "stats": {"total": 225, "additions": 191, "deletions": 34}, "files": [{"sha": "5afcb41eccd9ab2eff501ddda7485a11cb2cee3c", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -10660,7 +10660,7 @@ keep_template_parm (tree t, void* data)\n   int level;\n   int index;\n   template_parm_level_and_index (t, &level, &index);\n-  if (level > ftpi->max_depth)\n+  if (level == 0 || level > ftpi->max_depth)\n     return 0;\n \n   if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n@@ -14799,20 +14799,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t&& VAR_HAD_UNKNOWN_BOUND (t)\n \t\t&& type != error_mark_node)\n \t      type = strip_array_domain (type);\n-\t    tree sub_args = args;\n-\t    if (tree auto_node = type_uses_auto (type))\n-\t      {\n-\t\t/* Mask off any template args past the variable's context so we\n-\t\t   don't replace the auto with an unrelated argument.  */\n-\t\tint nouter = TEMPLATE_TYPE_LEVEL (auto_node) - 1;\n-\t\tint extra = TMPL_ARGS_DEPTH (args) - nouter;\n-\t\tif (extra > 0)\n-\t\t  /* This should never happen with the new lambda instantiation\n-\t\t     model, but keep the handling just in case.  */\n-\t\t  gcc_assert (!CHECKING_P),\n-\t\t  sub_args = strip_innermost_template_args (args, extra);\n-\t      }\n-\t    type = tsubst (type, sub_args, complain, in_decl);\n+\t    type = tsubst (type, args, complain, in_decl);\n \t    /* Substituting the type might have recursively instantiated this\n \t       same alias (c++/86171).  */\n \t    if (gen_tmpl && DECL_ALIAS_TEMPLATE_P (gen_tmpl)\n@@ -15564,6 +15551,19 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case TEMPLATE_TYPE_PARM:\n+      if (template_placeholder_p (t))\n+\t{\n+\t  tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (t);\n+\t  tmpl = tsubst_copy (tmpl, args, complain, in_decl);\n+\t  if (TREE_CODE (tmpl) == TEMPLATE_TEMPLATE_PARM)\n+\t    tmpl = TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (tmpl);\n+\n+\t  if (tmpl != CLASS_PLACEHOLDER_TEMPLATE (t))\n+\t    return make_template_placeholder (tmpl);\n+\t  else\n+\t    return t;\n+\t}\n+      /* Fall through.  */\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_PARM_INDEX:\n@@ -15737,7 +15737,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t of a constrained placeholder.  */;\n \t    else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n \t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t)\n-\t\t     && !CLASS_PLACEHOLDER_TEMPLATE (t)\n \t\t     && (arg = TEMPLATE_TYPE_PARM_INDEX (t),\n \t\t\t r = TEMPLATE_PARM_DESCENDANTS (arg))\n \t\t     && (TEMPLATE_PARM_LEVEL (r)\n@@ -15756,19 +15755,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tTYPE_REFERENCE_TO (r) = NULL_TREE;\n \n                 if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\t  {\n+\t\t  if (tree ci = PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t))\n \t\t    /* Propagate constraints on placeholders since they are\n \t\t       only instantiated during satisfaction.  */\n-\t\t    if (tree ci = PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t))\n-\t\t      PLACEHOLDER_TYPE_CONSTRAINTS_INFO (r) = ci;\n-\t\t    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))\n-\t\t      {\n-\t\t\tpl = tsubst_copy (pl, args, complain, in_decl);\n-\t\t\tif (TREE_CODE (pl) == TEMPLATE_TEMPLATE_PARM)\n-\t\t\t  pl = TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (pl);\n-\t\t\tCLASS_PLACEHOLDER_TEMPLATE (r) = pl;\n-\t\t      }\n-\t\t  }\n+\t\t    PLACEHOLDER_TYPE_CONSTRAINTS_INFO (r) = ci;\n \n \t\tif (TREE_CODE (r) == TEMPLATE_TEMPLATE_PARM)\n \t\t  /* We have reduced the level of the template\n@@ -28492,18 +28482,18 @@ make_args_non_dependent (vec<tree, va_gc> *args)\n }\n \n /* Returns a type which represents 'auto' or 'decltype(auto)'.  We use a\n-   TEMPLATE_TYPE_PARM with a level one deeper than the actual template\n-   parms.  If set_canonical is true, we set TYPE_CANONICAL on it.  */\n+   TEMPLATE_TYPE_PARM with a level one deeper than the actual template parms,\n+   by default.  If set_canonical is true, we set TYPE_CANONICAL on it.  */\n \n static tree\n-make_auto_1 (tree name, bool set_canonical)\n+make_auto_1 (tree name, bool set_canonical,\n+\t     int level = current_template_depth + 1)\n {\n   tree au = cxx_make_type (TEMPLATE_TYPE_PARM);\n   TYPE_NAME (au) = build_decl (input_location, TYPE_DECL, name, au);\n   TYPE_STUB_DECL (au) = TYPE_NAME (au);\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n-    (0, current_template_depth + 1, current_template_depth + 1,\n-     TYPE_NAME (au), NULL_TREE);\n+    (0, level, level, TYPE_NAME (au), NULL_TREE);\n   if (set_canonical)\n     TYPE_CANONICAL (au) = canonical_type_parameter (au);\n   DECL_ARTIFICIAL (TYPE_NAME (au)) = 1;\n@@ -28526,12 +28516,14 @@ make_auto (void)\n   return make_auto_1 (auto_identifier, true);\n }\n \n-/* Return a C++17 deduction placeholder for class template TMPL.  */\n+/* Return a C++17 deduction placeholder for class template TMPL.\n+   There are represented as an 'auto' with the special level 0 and\n+   CLASS_PLACEHOLDER_TEMPLATE set.  */\n \n tree\n make_template_placeholder (tree tmpl)\n {\n-  tree t = make_auto_1 (auto_identifier, false);\n+  tree t = make_auto_1 (auto_identifier, false, /*level=*/0);\n   CLASS_PLACEHOLDER_TEMPLATE (t) = tmpl;\n   /* Our canonical type depends on the placeholder.  */\n   TYPE_CANONICAL (t) = canonical_type_parameter (t);"}, {"sha": "379eb960da6bf944a267655b5162a935ac5430d4", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction101.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/91911\n+// { dg-do compile { target c++17 } }\n+\n+template<class T>\n+struct span {\n+  using value_type = T;\n+  span(T);\n+};\n+\n+template<class T>\n+using SpanType = decltype(span{T()});\n+\n+template<class T>\n+using ConstSpanType = span<const typename SpanType<T>::value_type>;\n+\n+using type = ConstSpanType<int>;\n+using type = span<const int>;"}, {"sha": "97869e647cc15f5c1af89fcc839231224bafce62", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction101a.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101a.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/91911\n+// { dg-do compile { target c++17 } }\n+// A variant of class-deduction101.C where SpanType has more levels than\n+// ConstSpanType.\n+\n+template<class T>\n+struct span {\n+  using value_type = T;\n+  span(T);\n+};\n+\n+template<class>\n+struct A {\n+  template<class T>\n+  using SpanType = decltype(span{T()});\n+};\n+\n+template<class T>\n+using ConstSpanType = span<const typename A<int>::SpanType<const T>::value_type>;\n+\n+using type = ConstSpanType<int>;\n+using type = span<const int>;"}, {"sha": "a823c9c38166f3b642d7dc062f48135098d80d49", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction101b.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction101b.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/91911\n+// { dg-do compile { target c++17 } }\n+// A variant of class-deduction101.C where SpanType has fewer levels than\n+// ConstSpanType.\n+\n+template<class T>\n+struct span {\n+  using value_type = T;\n+  span(T);\n+};\n+\n+template<class T>\n+using SpanType = decltype(span{T()});\n+\n+template<class>\n+struct B {\n+  template<class T>\n+  using ConstSpanType = span<const typename SpanType<T>::value_type>;\n+};\n+\n+using type = B<int>::ConstSpanType<int>;\n+using type = span<const int>;"}, {"sha": "20504780d32de82cc38df4435f2608e8169732c3", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction102.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/98077\n+// { dg-do compile { target c++17 } }\n+\n+template<class R>\n+struct function {\n+  template<class T> function(T);\n+  using type = R;\n+};\n+\n+template<class T> function(T) -> function<decltype(T()())>;\n+\n+template<class T>\n+struct CallableTrait;\n+\n+template<class R>\n+struct CallableTrait<function<R>> { using ReturnType = R; };\n+\n+template<class F>\n+using CallableTraitT = CallableTrait<decltype(function{F()})>;\n+\n+template<class F>\n+using ReturnType = typename CallableTraitT<F>::ReturnType;\n+\n+using type = ReturnType<int(*)()>;\n+using type = int;"}, {"sha": "7a4b684b7cfb48fba30f30cd923096407126465e", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction102a.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102a.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/98077\n+// { dg-do compile { target c++17 } }\n+// A variant of class-deduction102.C where the template placeholder is a template\n+// template parameter.\n+\n+template<class R>\n+struct function {\n+  template<class T> function(T);\n+  using type = R;\n+};\n+\n+template<class T> function(T) -> function<decltype(T()())>;\n+\n+template<class T>\n+struct CallableTrait;\n+\n+template<class R>\n+struct CallableTrait<function<R>> { using ReturnType = R; };\n+\n+template<class F, template<class> class Tmpl>\n+using CallableTraitT = CallableTrait<decltype(Tmpl{F()})>;\n+\n+template<class F, template<class> class Tmpl>\n+using ReturnType = typename CallableTraitT<F, Tmpl>::ReturnType;\n+\n+using type = ReturnType<int(*)(), function>;\n+using type = int;"}, {"sha": "64e3f8c7ab080ad343aee28ecfb8d9b558032dd7", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction102b.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction102b.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/98077\n+// { dg-do compile { target c++17 } }\n+// A variant of class-deduction102.C where the template placeholder is a template\n+// template parameter and ReturnType has more levels than CallableTraitT.\n+\n+template<class R>\n+struct function {\n+  template<class T> function(T);\n+  using type = R;\n+};\n+\n+template<class T> function(T) -> function<decltype(T()())>;\n+\n+template<class T>\n+struct CallableTrait;\n+\n+template<class R>\n+struct CallableTrait<function<R>> { using ReturnType = R; };\n+\n+template<class F, template<class> class Tmpl>\n+using CallableTraitT = CallableTrait<decltype(Tmpl{F()})>;\n+\n+template<class>\n+struct A {\n+  template<class F, template<class> class Tmpl>\n+  using ReturnType = typename CallableTraitT<F, Tmpl>::ReturnType;\n+};\n+\n+using type = A<int>::ReturnType<int(*)(), function>;\n+using type = int;"}, {"sha": "a1a3808afdcffdff36403533b93c3a7742bdbee2", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction103.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction103.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09845ad7569bac27c3a1dc7b410d9df764d2ca06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction103.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction103.C?ref=09845ad7569bac27c3a1dc7b410d9df764d2ca06", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/103672\n+// { dg-do compile { target c++17 } }\n+\n+template<class T>\n+struct unique {\n+  template<class... Args>\n+  T* operator()(Args&&... args);\n+};\n+\n+template<template<class...> class T, class... Args>\n+using deduced_type = decltype(T{Args{}...});\n+\n+template<template<class> class F, template<class...> class T, class... Args>\n+auto make(Args&&... args) {\n+  return F<deduced_type<T, Args...>>{}(args...);\n+}\n+\n+template<class A, class B>\n+struct Foo { Foo(A,B); };\n+\n+using type = decltype(make<unique, Foo>(1, 2));\n+using type = Foo<int, int>*;"}]}