{"sha": "39c01e4c532100e8e5239591146eec1b20593547", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljMDFlNGM1MzIxMDBlOGU1MjM5NTkxMTQ2ZWVjMWIyMDU5MzU0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-31T15:01:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-31T15:01:21Z"}, "message": "cp-tree.h (PROCESSING_REAL_TEMPLATE_DECL_P): New macro.\n\n1998-07-31  Mark Mitchell  <mark@markmitchell.com>\n\t* cp-tree.h (PROCESSING_REAL_TEMPLATE_DECL_P): New macro.\n\t(maybe_check_template_type): New function.\n\t* decl.c (maybe_process_template_type_declaration): New function,\n\tsplit out from pushtag  Call maybe_check_template_type.\n\t(pushtag): Use it.  Use PROCESSING_REAL_TEMPLATE_DECL_P.\n\t(xref_tag): Use PROCESSING_REAL_TEMPLATE_DECL_P.\n\t* friend.c (do_friend): Use PROCESSING_REAL_TEMPLATE_DECL_P.\n\t* pt.c (template_class_depth_real): Generalization of ...\n\t(template_class_depth): Use it.\n\t(register_specialization): Use duplicate_decls for duplicate\n\tdeclarations of specializations.\n\t(maybe_check_template_type): New function.\n\t(push_template_decl_real): Fix comment.\n\t(convert_nontype_argument): Likewise.\n\t(lookup_template_class): Likewise.  Avoid an infinite loop on\n\terroneous code.\n\t(tsubst_friend_function): Fix comment.\n\t(tsubst, case FUNCTION_DECL): Deal with a DECL_TI_TEMPLATE that is\n\tan IDENTIFIER_NODE.\n\t* semantics.c (begin_function_definition): Use\n\treset_specialization to note that template headers don't apply\n\tdirectly to declarations after the opening curly for a function.\n\nFrom-SVN: r21505", "tree": {"sha": "cde82810bdca623c7d1ae0769916edf5170cd355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cde82810bdca623c7d1ae0769916edf5170cd355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39c01e4c532100e8e5239591146eec1b20593547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c01e4c532100e8e5239591146eec1b20593547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c01e4c532100e8e5239591146eec1b20593547", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c01e4c532100e8e5239591146eec1b20593547/comments", "author": null, "committer": null, "parents": [{"sha": "5f97de0ac982f8439ca78db6652fb722fe4fafe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f97de0ac982f8439ca78db6652fb722fe4fafe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f97de0ac982f8439ca78db6652fb722fe4fafe9"}], "stats": {"total": 372, "additions": 284, "deletions": 88}, "files": [{"sha": "3feeaac7e8be80f608591be236851bd00d3efa53", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -1,3 +1,28 @@\n+1998-07-31  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (PROCESSING_REAL_TEMPLATE_DECL_P): New macro.\n+\t(maybe_check_template_type): New function.\n+\t* decl.c (maybe_process_template_type_declaration): New function,\n+\tsplit out from pushtag  Call maybe_check_template_type.\n+\t(pushtag): Use it.  Use PROCESSING_REAL_TEMPLATE_DECL_P.\n+\t(xref_tag): Use PROCESSING_REAL_TEMPLATE_DECL_P.\n+\t* friend.c (do_friend): Use PROCESSING_REAL_TEMPLATE_DECL_P.\n+\t* pt.c (template_class_depth_real): Generalization of ...\n+\t(template_class_depth): Use it.\n+\t(register_specialization): Use duplicate_decls for duplicate\n+\tdeclarations of specializations.\n+\t(maybe_check_template_type): New function.\n+\t(push_template_decl_real): Fix comment.\n+\t(convert_nontype_argument): Likewise.\n+\t(lookup_template_class): Likewise.  Avoid an infinite loop on\n+\terroneous code.\n+\t(tsubst_friend_function): Fix comment.\n+\t(tsubst, case FUNCTION_DECL): Deal with a DECL_TI_TEMPLATE that is\n+\tan IDENTIFIER_NODE.\n+\t* semantics.c (begin_function_definition): Use\n+\treset_specialization to note that template headers don't apply\n+\tdirectly to declarations after the opening curly for a function.\n+\n 1998-07-29  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (push_overloaded_decl): Use current_namespace instead of"}, {"sha": "4e1d1bd4a3c98101d7c3c8f44dde0c7f2d83024b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -1692,6 +1692,12 @@ extern int flag_new_for_scope;\n #define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n   (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n \n+/* Non-zero iff we are currently processing a declaration for an\n+   entity with its own template parameter list, and which is not a\n+   full specialization.  */\n+#define PROCESSING_REAL_TEMPLATE_DECL_P() \\\n+  (processing_template_decl > template_class_depth (current_class_type))\n+\n /* This function may be a guiding decl for a template.  */\n #define DECL_MAYBE_TEMPLATE(NODE) DECL_LANG_FLAG_4 (NODE)\n /* We know what we're doing with this decl now.  */\n@@ -2794,6 +2800,7 @@ extern int template_class_depth                 PROTO((tree));\n extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));\n extern void maybe_process_partial_specialization PROTO((tree));\n+extern void maybe_check_template_type           PROTO((tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;"}, {"sha": "0b32a3d8d5cd971db3da1b6716c72f1cdc146863", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -176,6 +176,7 @@ static int member_function_or_else PROTO((tree, tree, char *));\n static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n \t\t\t\t  int));\n static void lang_print_error_function PROTO((char *));\n+static tree maybe_process_template_type_declaration PROTO((tree, int, struct binding_level*));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -2223,6 +2224,88 @@ pop_everything ()\n #endif\n }\n \n+/* The type TYPE is being declared.  If it is a class template, or a\n+   specialization of a class template, do any processing required and\n+   perform error-checking.  If IS_FRIEND is non-zero, this TYPE is\n+   being declared a friend.  B is the binding level at which this TYPE\n+   should be bound.\n+\n+   Returns the TYPE_DECL for TYPE, which may have been altered by this\n+   processing.  */\n+\n+static tree \n+maybe_process_template_type_declaration (type, globalize, b)\n+     tree type;\n+     int globalize;\n+     struct binding_level* b;\n+{\n+  tree decl = TYPE_NAME (type);\n+ \n+  if (processing_template_parmlist)\n+    /* You can't declare a new template type in a template parameter\n+       list.  But, you can declare a non-template type:\n+       \n+         template <class A*> struct S;\n+       \n+       is a forward-declaration of `A'.  */\n+    ;\n+  else \n+    {\n+      maybe_check_template_type (type);\n+\n+      if (IS_AGGR_TYPE (type)\n+\t  && (/* If !GLOBALIZE then we are looking at a definition.\n+\t\t It may not be a primary template.  (For example, in:\n+\t\t  \n+\t\t template <class T>\n+\t\t struct S1 { class S2 {}; }\n+\t\t  \n+\t\t we have to push_template_decl for S2.)  */\n+\t      (processing_template_decl && !globalize)\n+\t      /* If we are declaring a friend template class, we will\n+\t\t have GLOBALIZE set, since something like:\n+\n+\t\t template <class T>\n+\t\t struct S1 {\n+\t\t   template <class U>\n+\t\t   friend class S2; \n+\t\t };\n+\n+\t\t declares S2 to be at global scope.  */\n+\t      || PROCESSING_REAL_TEMPLATE_DECL_P ()))\n+\t{\n+\t  /* This may change after the call to\n+\t     push_template_decl_real, but we want the original value.  */\n+\t  tree name = DECL_NAME (decl);\n+\n+\t  decl = push_template_decl_real (decl, globalize);\n+\t  /* If the current binding level is the binding level for the\n+\t     template parameters (see the comment in\n+\t     begin_template_parm_list) and the enclosing level is a class\n+\t     scope, and we're not looking at a friend, push the\n+\t     declaration of the member class into the class scope.  In the\n+\t     friend case, push_template_decl will already have put the\n+\t     friend into global scope, if appropriate.  */\n+\t  if (!globalize && b->pseudo_global\n+\t      && b->level_chain->parm_flag == 2)\n+\t    {\n+\t      pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n+\t\t\t\t   b->level_chain);\n+\t      /* Put this tag on the list of tags for the class, since\n+\t\t that won't happen below because B is not the class\n+\t\t binding level, but is instead the pseudo-global level.  */\n+\t      b->level_chain->tags = \n+\t\tsaveable_tree_cons (name, type, b->level_chain->tags);\n+\t      TREE_NONLOCAL_FLAG (type) = 1;\n+\t      if (TYPE_SIZE (current_class_type) == NULL_TREE)\n+\t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n+\t    }\n+\t}\n+    }\n+\n+  return decl;\n+}\n+\n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n    Normally put it into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n@@ -2298,63 +2381,8 @@ pushtag (name, type, globalize)\n \t  TYPE_NAME (type) = d;\n \t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n \n-\t  if (processing_template_parmlist)\n-\t    /* You can't declare a new template type in a template\n-\t       parameter list.  But, you can declare a non-template\n-\t       type:\n-\n-\t         template <class A*> struct S;\n-\n-\t       is a forward-declaration of `A'.  */\n-\t    ;\n-\t  else if (IS_AGGR_TYPE (type)\n-\t      && (/* If !GLOBALIZE then we are looking at a\n-\t\t     definition.  It may not be a primary template.\n-\t\t     (For example, in:\n-\t\t  \n-\t\t       template <class T>\n-\t\t       struct S1 { class S2 {}; }\n-\t\t  \n-\t\t     we have to push_template_decl for S2.)  */\n-\t\t  (processing_template_decl && !globalize)\n-\t\t  /* If we are declaring a friend template class, we\n-\t\t     will have GLOBALIZE set, since something like:\n-\n-\t\t       template <class T>\n-\t\t       struct S1 {\n-\t\t         template <class U>\n-\t\t         friend class S2; \n-\t\t       };\n-\n-\t\t     declares S2 to be at global scope.  */\n-\t\t  || (processing_template_decl > \n-\t\t      template_class_depth (current_class_type))))\n-\t    {\n-\t      d = push_template_decl_real (d, globalize);\n-\t      /* If the current binding level is the binding level for\n-\t\t the template parameters (see the comment in\n-\t\t begin_template_parm_list) and the enclosing level is\n-\t\t a class scope, and we're not looking at a friend,\n-\t\t push the declaration of the member class into the\n-\t\t class scope.  In the friend case, push_template_decl\n-\t\t will already have put the friend into global scope,\n-\t\t if appropriate.  */ \n-\t      if (!globalize && b->pseudo_global\n-\t\t  && b->level_chain->parm_flag == 2)\n-\t\t{\n-\t\t  pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n-\t\t\t\t       b->level_chain);\n-\t\t  /* Put this tag on the list of tags for the class,\n-\t\t     since that won't happen below because B is not\n-\t\t     the class binding level, but is instead the\n-\t\t     pseudo-global level.  */\n-\t\t  b->level_chain->tags = \n-\t\t    saveable_tree_cons (name, type, b->level_chain->tags);\n-\t\t  TREE_NONLOCAL_FLAG (type) = 1;\n-\t\t  if (TYPE_SIZE (current_class_type) == NULL_TREE)\n-\t\t    CLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n-\t\t}\n-\t    }\n+\t  d = maybe_process_template_type_declaration (type,\n+\t\t\t\t\t\t       globalize, b);\n \n \t  if (b->parm_flag == 2)\n \t    d = pushdecl_class_level (d);\n@@ -11349,8 +11377,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n     {\n       if (current_class_type \n \t  && template_class_depth (current_class_type) \n-\t  && (processing_template_decl \n-\t      > template_class_depth (current_class_type)))\n+\t  && PROCESSING_REAL_TEMPLATE_DECL_P ())\n       /* Since GLOBALIZE is non-zero, we are not looking at a\n \t definition of this tag.  Since, in addition, we are currently\n \t processing a (member) template declaration of a template"}, {"sha": "db50258af716efbacdff1b69a3949588d7fc00fd", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -354,8 +354,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    is_friend_template = processing_template_decl >\n-      template_class_depth (current_class_type);\n+    is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ();\n \n   if (ctype)\n     {"}, {"sha": "9e13916b41875047935d7c76f3cc501a9b5b2565", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 108, "deletions": 26, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -121,6 +121,7 @@ static tree most_specialized PROTO((tree, tree, tree));\n static tree most_specialized_class PROTO((tree, tree));\n static tree most_general_template PROTO((tree));\n static void set_mangled_name_for_template_decl PROTO((tree));\n+static int template_class_depth_real PROTO((tree, int));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -234,12 +235,19 @@ finish_member_template_decl (template_parameters, decl)\n        struct B {};\n      };\n \n-   A<T>::B<U> has depth two, while A<T> has depth one.  Also,\n-   both A<T>::B<int> and A<int>::B<U> have depth one.  */\n+   A<T>::B<U> has depth two, while A<T> has depth one.  \n+   Both A<T>::B<int> and A<int>::B<U> have depth one, if\n+   COUNT_SPECIALIZATIONS is 0 or if they are instantiations, not\n+   specializations.  \n+\n+   This function is guaranteed to return 0 if passed NULL_TREE so\n+   that, for example, `template_class_depth (current_class_type)' is\n+   always safe.  */\n \n int \n-template_class_depth (type)\n+template_class_depth_real (type, count_specializations)\n      tree type;\n+     int count_specializations;\n {\n   int depth;\n \n@@ -249,12 +257,25 @@ template_class_depth (type)\n        type = TYPE_CONTEXT (type))\n     if (CLASSTYPE_TEMPLATE_INFO (type)\n \t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n-\t&& uses_template_parms (CLASSTYPE_TI_ARGS (type)))\n+\t&& ((count_specializations\n+\t     && CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n+\t    || uses_template_parms (CLASSTYPE_TI_ARGS (type))))\n       ++depth;\n \n   return depth;\n }\n \n+/* Returns the template nesting level of the indicated class TYPE.\n+   Like template_class_depth_real, but instantiations do not count in\n+   the depth.  */\n+\n+int \n+template_class_depth (type)\n+     tree type;\n+{\n+  return template_class_depth_real (type, /*count_specializations=*/0);\n+}\n+\n /* Returns 1 if processing DECL as part of do_pending_inlines\n    needs us to push template parms.  */\n \n@@ -742,11 +763,8 @@ register_specialization (spec, tmpl, args)\n \t      }\n \t    else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n \t      {\n-\t\tif (DECL_INITIAL (fn))\n-\t\t  cp_error (\"duplicate specialization of %D\", fn);\n-\n-\t\tTREE_VALUE (s) = spec;\n-\t\treturn spec;\n+\t\tduplicate_decls (spec, TREE_VALUE (s));\n+\t\treturn TREE_VALUE (s);\n \t      }\n \t  }\n       }\n@@ -1300,6 +1318,50 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n   return decl;\n }\n \n+/* TYPE is being declared.  Verify that the use of template headers\n+   and such is reasonable.  Issue error messages if not.  */\n+\n+void\n+maybe_check_template_type (type)\n+     tree type;\n+{\n+  if (template_header_count)\n+    {\n+      /* We are in the scope of some `template <...>' header.  */\n+\n+      int context_depth \n+\t= template_class_depth_real (TYPE_CONTEXT (type),\n+\t\t\t\t     /*count_specializations=*/1);\n+\n+      if (template_header_count <= context_depth)\n+\t/* This is OK; the template headers are for the context.  We\n+\t   are actually too lenient here; like\n+\t   check_explicit_specialization we should consider the number\n+\t   of template types included in the actual declaration.  For\n+\t   example, \n+\n+\t     template <class T> struct S {\n+\t       template <class U> template <class V>\n+\t       struct I {};\n+\t     }; \n+\n+\t   is illegal, but:\n+\n+\t     template <class T> struct S {\n+\t       template <class U> struct I;\n+\t     }; \n+\n+\t     template <class T> template <class U.\n+\t     struct S<T>::I {};\n+\n+\t   is not.  */\n+\t; \n+      else if (template_header_count > context_depth + 1)\n+\t/* There are two many template parameter lists.  */\n+\tcp_error (\"too many template parameter lists in declaration of `%T'\", type); \n+    }\n+}\n+\n /* Returns 1 iff PARMS1 and PARMS2 are identical sets of template\n    parameters.  These are represented in the same format used for\n    DECL_TEMPLATE_PARMS.  */\n@@ -1951,9 +2013,7 @@ push_template_decl_real (decl, is_friend)\n   /* Push template declarations for global functions and types.  Note\n      that we do not try to push a global template friend declared in a\n      template class; such a thing may well depend on the template\n-     parameters of the class.  With guiding declarations, however, we\n-     push the template so that subsequent declarations of the template\n-     will match this one.  */\n+     parameters of the class.  */\n   if (! ctx \n       && !(is_friend && template_class_depth (current_class_type) > 0))\n     tmpl = pushdecl_namespace_level (tmpl);\n@@ -2278,10 +2338,10 @@ convert_nontype_argument (type, expr)\n \tif (TREE_CODE (type_referred_to) == FUNCTION_TYPE)\n \t  {\n \t    /* For a non-type template-parameter of type reference to\n-\t      function, no conversions apply.  If the\n-\t      template-argument represents a set of overloaded\n-\t      functions, the matching function is selected from the\n-\t      set (_over.over_).  */\n+\t       function, no conversions apply.  If the\n+\t       template-argument represents a set of overloaded\n+\t       functions, the matching function is selected from the\n+\t       set (_over.over_).  */\n \t    tree fns = expr;\n \t    tree fn;\n \n@@ -3096,7 +3156,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n       if (arg_depth == 1 && parm_depth > 1)\n \t{\n-\t  /* We've been with an incomplete set of template arguments.\n+\t  /* We've been given an incomplete set of template arguments.\n \t     For example, given:\n \n \t       template <class T> struct S1 {\n@@ -3109,8 +3169,28 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t     <class U> struct S1<T>::S2'.  We must fill in the missing\n \t     arguments.  */\n \t  my_friendly_assert (context != NULL_TREE, 0);\n-\t  while (!IS_AGGR_TYPE_CODE (TREE_CODE (context)))\n+\t  while (!IS_AGGR_TYPE_CODE (TREE_CODE (context))\n+\t\t && context != global_namespace)\n \t    context = DECL_REAL_CONTEXT (context);\n+\n+\t  if (context == global_namespace)\n+\t    /* This is bad.  We cannot get enough arguments, even from\n+\t       the surrounding context, to resolve this class.  One\n+\t       case where this might happen is (illegal) code like:\n+\n+\t           template <class U> \n+\t\t   template <class T>\n+\t\t   struct S { \n+\t\t     A(const A<T>& a) {}\n+\t\t   };  \n+\t    \n+\t       We should catch this error sooner (at the opening curly\n+\t       for `S', but it is better to be safe than sorry here.  */\n+\t    {\n+\t      cp_error (\"invalid use of `%D'\", template);\n+\t      return error_mark_node;\n+\t    }\n+\n \t  arglist = add_to_template_args (CLASSTYPE_TI_ARGS (context),\n \t\t\t\t\t  arglist);\n \t  arg_depth = TMPL_ARGS_DEPTH (arglist);\n@@ -3667,8 +3747,8 @@ tsubst_friend_function (decl, args)\n \t\t\t\t\t\t args, NULL_TREE),\n \t\t\t\t    tsubst (DECL_TI_ARGS (decl),\n \t\t\t\t\t    args, NULL_TREE));\n-      /* FIXME: The decl we create via the next tsubst be created on a\n-\t temporary obstack.  */\n+      /* FIXME: The decl we create via the next tsubst could be\n+\t created on a temporary obstack.  */\n       new_friend = tsubst (decl, args, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args, \n@@ -4833,12 +4913,14 @@ tsubst (t, args, in_decl)\n \t\t };\n \n \t       Here, the DECL_TI_TEMPLATE for the friend declaration\n-\t       will be a LOOKUP_EXPR.  We are being called from\n-\t       tsubst_friend_function, and we want only to create a\n-\t       new decl (R) with appropriate types so that we can call\n-\t       determine_specialization.  */\n-\t    my_friendly_assert (TREE_CODE (DECL_TI_TEMPLATE (t)) \n-\t\t\t\t== LOOKUP_EXPR, 0);\n+\t       will be a LOOKUP_EXPR or an IDENTIFIER_NODE.  We are\n+\t       being called from tsubst_friend_function, and we want\n+\t       only to create a new decl (R) with appropriate types so\n+\t       that we can call determine_specialization.  */\n+\t    my_friendly_assert ((TREE_CODE (DECL_TI_TEMPLATE (t)) \n+\t\t\t\t == LOOKUP_EXPR)\n+\t\t\t\t|| (TREE_CODE (DECL_TI_TEMPLATE (t))\n+\t\t\t\t    == IDENTIFIER_NODE), 0);\n \t    gen_tmpl = NULL_TREE;\n \t  }\n "}, {"sha": "fa3dd49722166a3fb786bf895ab65d841dc1002f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -1098,6 +1098,10 @@ begin_function_definition (decl_specs, declarator)\n     return 0;\n   \n   reinit_parse_for_function ();\n+  /* The things we're about to see are not directly qualified by any\n+     template headers we've seen thus far.  */\n+  reset_specialization ();\n+\n   return 1;\n }\n "}, {"sha": "75b10544ac9da52c17a4523b83990c1a8a1e533b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash15.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+\n+template <class T>\n+template <class U>\n+struct A { // ERROR - too many template parameter lists\n+public:\n+  A() {}\n+\n+  A(const A<T>& b) {} // ERROR - invalid use of template\n+};"}, {"sha": "f6feefb56082b4da3f98443af60795195e6d82b8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum5.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -0,0 +1,4 @@\n+// Build don't link:\n+\n+template <>\n+enum E {e}; // ERROR - template declaration of enum"}, {"sha": "0aede3824bdf49d1c28a05118701d5adb5c652bc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit34.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit34.C?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -4,7 +4,7 @@ template <class T>\n void foo(T t);\n \n template <>\n-void foo(int) {}; \n+void foo(int) {}; // ERROR - previously defined here.\n \n template <>\n void foo<int>(int) {} // ERROR - duplicate specialization."}, {"sha": "f86d0b67b95219c04c05ca0a988c9f521f4ef9b2", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend28.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend28.C?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+\n+class mystream;\n+\n+template <class T> class a {\n+public:\n+\tfriend mystream& operator>> <>( mystream&, a<T>& thea );\n+private:\n+\tT amember;\n+};\n+\n+template <class T> mystream& operator>>( mystream& s, a<T>& thea );\n+\n+template<> mystream& operator>> <int>( mystream& s, a<int>& thea );\n+\n+template class a<int>;\n+\n+template<> mystream& operator>> <int>( mystream& s, a<int>& thea )\n+{\n+\tthea.amember = 0;\n+\treturn s;\n+}"}, {"sha": "e141aaa363fb8f2f7650bbedfca0cf20b48f67bb", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend29.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c01e4c532100e8e5239591146eec1b20593547/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend29.C?ref=39c01e4c532100e8e5239591146eec1b20593547", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+\n+template <class T> class a {\n+public:\n+\tfriend void foo<>( a<T>& thea );\n+private:\n+\tT amember;\n+};\n+\n+template <class T> void foo( a<T>& thea )\n+{\n+\tthea.amember = 0;\n+}\n+\n+template class a<int>;\n+"}]}