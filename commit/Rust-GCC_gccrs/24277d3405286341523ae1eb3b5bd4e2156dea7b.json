{"sha": "24277d3405286341523ae1eb3b5bd4e2156dea7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQyNzdkMzQwNTI4NjM0MTUyM2FlMWViM2I1YmQ0ZTIxNTZkZWE3Yg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-09-04T18:55:25Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-04T18:55:25Z"}, "message": "var-tracking.c (dv_is_decl_p): Adjust NULL behavior to match comment.\n\n* var-tracking.c (dv_is_decl_p): Adjust NULL behavior to match\ncomment.  Use switch statement to catch overlaps between rtx\nand tree codes.  Accept FUNCTION_DECLs in addition to those in...\n(IS_DECL_CODE): ... here. Remove.\n(check_value_is_not_decl): Remove.\n(dv_from_decl, dv_from_value): Check after conversion.\n\nFrom-SVN: r151432", "tree": {"sha": "35410dc4adf51ca2f7859c276006c99b0612357d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35410dc4adf51ca2f7859c276006c99b0612357d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24277d3405286341523ae1eb3b5bd4e2156dea7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24277d3405286341523ae1eb3b5bd4e2156dea7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24277d3405286341523ae1eb3b5bd4e2156dea7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24277d3405286341523ae1eb3b5bd4e2156dea7b/comments", "author": null, "committer": null, "parents": [{"sha": "5f1a9ebbc159cb2cad9605777f92e0c73f4cee76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1a9ebbc159cb2cad9605777f92e0c73f4cee76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f1a9ebbc159cb2cad9605777f92e0c73f4cee76"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "ceafb4536ff81def7af30e352c00b1794fdf4868", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24277d3405286341523ae1eb3b5bd4e2156dea7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24277d3405286341523ae1eb3b5bd4e2156dea7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24277d3405286341523ae1eb3b5bd4e2156dea7b", "patch": "@@ -1,3 +1,12 @@\n+2009-09-04  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* var-tracking.c (dv_is_decl_p): Adjust NULL behavior to match\n+\tcomment.  Use switch statement to catch overlaps between rtx\n+\tand tree codes.  Accept FUNCTION_DECLs in addition to those in...\n+\t(IS_DECL_CODE): ... here. Remove.\n+\t(check_value_is_not_decl): Remove.\n+\t(dv_from_decl, dv_from_value): Check after conversion.\n+\n 2009-09-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41257"}, {"sha": "475ba57553ed2cdb9a8a0060d63f06f4f033b949", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24277d3405286341523ae1eb3b5bd4e2156dea7b/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24277d3405286341523ae1eb3b5bd4e2156dea7b/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=24277d3405286341523ae1eb3b5bd4e2156dea7b", "patch": "@@ -723,12 +723,24 @@ static inline bool\n dv_is_decl_p (decl_or_value dv)\n {\n   if (!dv)\n-    return false;\n+    return true;\n \n-  if (GET_CODE ((rtx)dv) == VALUE)\n-    return false;\n+  /* Make sure relevant codes don't overlap.  */\n+  switch ((int)TREE_CODE ((tree)dv))\n+    {\n+    case (int)VAR_DECL:\n+    case (int)PARM_DECL:\n+    case (int)RESULT_DECL:\n+    case (int)FUNCTION_DECL:\n+    case (int)COMPONENT_REF:\n+      return true;\n \n-  return true;\n+    case (int)VALUE:\n+      return false;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Return true if a decl_or_value is a VALUE rtl.  */\n@@ -790,21 +802,13 @@ dv_pool (decl_or_value dv)\n   return dv_onepart_p (dv) ? valvar_pool : var_pool;\n }\n \n-#define IS_DECL_CODE(C) ((C) == VAR_DECL || (C) == PARM_DECL \\\n-\t\t\t || (C) == RESULT_DECL || (C) == COMPONENT_REF)\n-\n-/* Check that VALUE won't ever look like a DECL.  */\n-static char check_value_is_not_decl [(!IS_DECL_CODE ((enum tree_code)VALUE))\n-\t\t\t\t     ? 1 : -1] ATTRIBUTE_UNUSED;\n-\n-\n /* Build a decl_or_value out of a decl.  */\n static inline decl_or_value\n dv_from_decl (tree decl)\n {\n   decl_or_value dv;\n-  gcc_assert (!decl || IS_DECL_CODE (TREE_CODE (decl)));\n   dv = decl;\n+  gcc_assert (dv_is_decl_p (dv));\n   return dv;\n }\n \n@@ -813,8 +817,8 @@ static inline decl_or_value\n dv_from_value (rtx value)\n {\n   decl_or_value dv;\n-  gcc_assert (value);\n   dv = value;\n+  gcc_assert (dv_is_value_p (dv));\n   return dv;\n }\n "}]}