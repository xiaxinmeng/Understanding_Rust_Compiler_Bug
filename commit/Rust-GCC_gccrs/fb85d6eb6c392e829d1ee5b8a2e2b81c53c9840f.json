{"sha": "fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI4NWQ2ZWI2YzM5MmU4MjlkMWVlNWI4YTJlMmI4MWM1M2M5ODQwZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-13T18:21:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-13T18:23:58Z"}, "message": "Warn for reads from write-only arguments [PR101734].\n\nResolves:\nPR middle-end/101734 - missing warning reading from a write-only object\n\ngcc/ChangeLog:\n\n\tPR middle-end/101734\n\t* tree-ssa-uninit.c (maybe_warn_read_write_only): New function.\n\t(maybe_warn_operand): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/101734\n\t* gcc.dg/uninit-42.c: New test.", "tree": {"sha": "3224d9384343767b06b6d06b267f3930cf5f5f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3224d9384343767b06b6d06b267f3930cf5f5f51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5c00544cce1feb2c8c4e9aad766315d389c69c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c00544cce1feb2c8c4e9aad766315d389c69c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c00544cce1feb2c8c4e9aad766315d389c69c4"}], "stats": {"total": 176, "additions": 167, "deletions": 9}, "files": [{"sha": "efaaacdf9bcc7d565d24dd03143ca5f0e3498651", "filename": "gcc/testsuite/gcc.dg/uninit-42.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-42.c?ref=fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "patch": "@@ -0,0 +1,87 @@\n+/* PR middle-end/101734 - missing warning reading from a write-only object\n+   Verify that reading objects pointed to by arguments\n+   declared with attribute access none or write-only is diagnosed by\n+   -Wmaybe-uninitialized.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(mode, ...) __attribute__ ((access (mode, __VA_ARGS__)))\n+\n+void sink (void *, ...);\n+\n+\n+A (write_only, 1, 2)\n+int nowarn_wo_assign_r0 (int *p, int n)\n+{\n+  *p = n;\n+  return *p;\n+}\n+\n+A (write_only, 1, 2)\n+int nowarn_wo_sink_r0 (int *p, int n)\n+{\n+  sink (p, p + 1, p + n);\n+  return *p;\n+}\n+\n+A (write_only, 1, 2)\n+int warn_wo_r0 (int *p, int n)\n+{\n+  return *p;        // { dg-warning \"'\\\\*p' may be used uninitialized \\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+\n+A (write_only, 1, 2)\n+int nowarn_wo_w1_r1 (int *p, int n)\n+{\n+  p[1] = n;\n+  return p[1];\n+}\n+\n+A (write_only, 1, 2)\n+int warn_wo_r1 (int *p, int n)\n+{\n+  return p[1];      // { dg-warning \"'p\\\\\\[1]' may be used uninitialized\" }\n+}\n+\n+\n+A (write_only, 1, 2)\n+int nowarn_wo_rwi_rj (int *p, int n, int i, int j)\n+{\n+  p[i] = n;\n+  return p[j];\n+}\n+\n+A (write_only, 1, 2)\n+  int warn_wo_ri (int *p, int n, int i)\n+{\n+  return p[i];      // { dg-warning \" may be used uninitialized\" }\n+}\n+\n+\n+\n+A (none, 1, 2)\n+int* nowarn_none_sink_return (int *p, int n)\n+{\n+  sink (p, p + 1, p + n);\n+  return p;\n+}\n+\n+A (none, 1, 2)\n+int warn_none_r0 (int *p, int n)\n+{\n+  (void)&n;\n+  return *p;        // { dg-warning \"'\\\\*p' may be used uninitialized\" }\n+}\n+\n+A (none, 1, 2)\n+int warn_none_r1 (int *p, int n)\n+{\n+  return p[1];      // { dg-warning \"'p\\\\\\[1]' may be used uninitialized\" }\n+}\n+\n+A (write_only, 1, 2)\n+int warn_none_ri (int *p, int n, int i)\n+{\n+  return p[i];      // { dg-warning \" may be used uninitialized\" }\n+}"}, {"sha": "d5cdffbae8bf5e362a609204960ec712c8c0a982", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=fb85d6eb6c392e829d1ee5b8a2e2b81c53c9840f", "patch": "@@ -283,6 +283,64 @@ builtin_call_nomodifying_p (gimple *stmt)\n   return true;\n }\n \n+/* If ARG is a FNDECL parameter declared with attribute access none or\n+   write_only issue a warning for its read access via PTR.  */\n+\n+static void\n+maybe_warn_read_write_only (tree fndecl, gimple *stmt, tree arg, tree ptr)\n+{\n+  if (!fndecl)\n+    return;\n+\n+  if (get_no_uninit_warning (arg))\n+    return;\n+\n+  tree fntype = TREE_TYPE (fndecl);\n+  if (!fntype)\n+    return;\n+\n+  /* Initialize a map of attribute access specifications for arguments\n+     to the function function call.  */\n+  rdwr_map rdwr_idx;\n+  init_attr_rdwr_indices (&rdwr_idx, TYPE_ATTRIBUTES (fntype));\n+\n+  unsigned argno = 0;\n+  tree parms = DECL_ARGUMENTS (fndecl);\n+  for (tree parm = parms; parm; parm = TREE_CHAIN (parm), ++argno)\n+    {\n+      if (parm != arg)\n+\tcontinue;\n+\n+      const attr_access* access = rdwr_idx.get (argno);\n+      if (!access)\n+\tbreak;\n+\n+      if (access->mode != access_none\n+\t  && access->mode != access_write_only)\n+\tcontinue;\n+\n+      location_t stmtloc\n+\t= linemap_resolve_location (line_table, gimple_location (stmt),\n+\t\t\t\t    LRK_SPELLING_LOCATION, NULL);\n+\n+      if (!warning_at (stmtloc, OPT_Wmaybe_uninitialized,\n+\t\t       \"%qE may be used uninitialized\", ptr))\n+\tbreak;\n+\n+      suppress_warning (arg, OPT_Wmaybe_uninitialized);\n+\n+      const char* const access_str =\n+\tTREE_STRING_POINTER (access->to_external_string ());\n+\n+      location_t parmloc = DECL_SOURCE_LOCATION (parm);\n+      inform (parmloc, \"accessing argument %u of a function declared with \"\n+\t      \"attribute %<%s%>\",\n+\t      argno + 1, access_str);\n+\n+      break;\n+    }\n+}\n+\n /* Callback for walk_aliased_vdefs.  */\n \n static bool\n@@ -350,7 +408,9 @@ struct wlimits\n };\n \n /* Determine if REF references an uninitialized operand and diagnose\n-   it if so.  */\n+   it if so.  STMS is the referencing statement.  LHS is the result\n+   of the access and may be null.  RHS is the variable referenced by\n+   the access; it may not be null.  */\n \n static tree\n maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n@@ -497,14 +557,25 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n   /* Do not warn if it can be initialized outside this function.\n      If we did not reach function entry then we found killing\n      clobbers on all paths to entry.  */\n-  if (!found_alloc\n-      && fentry_reached\n-      /* ???  We'd like to use ref_may_alias_global_p but that\n-\t excludes global readonly memory and thus we get bogus\n-\t warnings from p = cond ? \"a\" : \"b\" for example.  */\n-      && (!VAR_P (base)\n-\t  || is_global_var (base)))\n-    return NULL_TREE;\n+  if (!found_alloc && fentry_reached)\n+    {\n+      if (TREE_CODE (base) == SSA_NAME)\n+\t{\n+\t  tree var = SSA_NAME_VAR (base);\n+\t  if (var && TREE_CODE (var) == PARM_DECL)\n+\t    {\n+\t      maybe_warn_read_write_only (cfun->decl, stmt, var, rhs);\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+\n+      if (!VAR_P (base)\n+\t  || is_global_var (base))\n+\t/* ???  We'd like to use ref_may_alias_global_p but that\n+\t   excludes global readonly memory and thus we get bogus\n+\t   warnings from p = cond ? \"a\" : \"b\" for example.  */\n+\treturn NULL_TREE;\n+    }\n \n   /* Strip the address-of expression from arrays passed to functions. */\n   if (TREE_CODE (rhs) == ADDR_EXPR)"}]}