{"sha": "594740f365ed33c25f3ad1a43bdbbd2326a932de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0NzQwZjM2NWVkMzNjMjVmM2FkMWE0M2JkYmJkMjMyNmE5MzJkZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-19T21:46:24Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-19T21:46:24Z"}, "message": "87th Cygnus<->FSF quick merge\n\nFrom-SVN: r12535", "tree": {"sha": "8c74e2ca959c3e405c52bda9123223639630aa9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c74e2ca959c3e405c52bda9123223639630aa9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/594740f365ed33c25f3ad1a43bdbbd2326a932de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594740f365ed33c25f3ad1a43bdbbd2326a932de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/594740f365ed33c25f3ad1a43bdbbd2326a932de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594740f365ed33c25f3ad1a43bdbbd2326a932de/comments", "author": null, "committer": null, "parents": [{"sha": "686cada41d2970b45a29ebaeddb787f747295a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686cada41d2970b45a29ebaeddb787f747295a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686cada41d2970b45a29ebaeddb787f747295a07"}], "stats": {"total": 516, "additions": 410, "deletions": 106}, "files": [{"sha": "d9936ecccf8a61b95f00bdfd856cb99e6d899771", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 82, "deletions": 5, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -1,3 +1,85 @@\n+Fri Jul 19 14:04:05 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Make sure we do obj->X::i correctly.\n+\n+Thu Jul 18 14:48:23 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl2.c (import_export_vtable): ASM_OUTPUT_EXTERNAL, not\n+\tASSEMBLE_EXTERNAL.\n+\n+Mon Jul 15 17:48:43 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck2.c (process_init_constructor): New pedwarn for using { }\n+\tto initialize a pointer to member function.\n+\t* typeck.c (build_ptrmemfunc1): Avoid use of digest_init so that\n+\twe can avoid the new error.\n+\n+Mon Jul 15 15:42:03 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_ptrmemfunc1): New function to hide details of\n+\tpointer to member functions better.\n+\n+Mon Jul 15 14:23:02 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Resolve OFFSET_REFs that are\n+\tmethods into the actual method, as we know the implied object is\n+\tnot used.\n+\n+Mon Jul 15 13:08:29 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (maybecomma_warn): Only emit the pedwarn if we're not\n+\tinside a system header.\n+\n+Fri Jul 12 16:30:05 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* call.c (build_method_call): Call complete_type on the\n+\tinstance type.\n+\n+Thu Jul 11 17:16:40 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Always build up an OFFSET_REF\n+\tfor obj_ptr->func so that we can know which object to use in a\n+\tmethod call.\n+\n+Wed Jul 10 19:36:37 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_ptrmemfunc): Remove sorry, now we can cast\n+\taround things.  Also improve maintainability.\n+\n+Wed Jul 10 18:20:11 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Check for overflow when evaluating an\n+ \tarray dimension.\n+\n+Wed Jul 10 17:26:19 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (cp_convert): Don't check for ambiguity with constructor\n+ \tif NEW_OVER.\n+\n+\t* typeck.c (build_x_function_call): Pass function overload\n+ \tquestions to new overloading code if NEW_OVER.\n+\t* init.c (expand_aggr_init_1): Only check for type conversion ops\n+ \tif we're doing copy-initialization (i.e. LOOKUP_ONLYCONVERTING).\n+  \tDon't check for ambiguity with constructor if NEW_OVER.\n+\t* cvt.c (convert_to_reference): Dereference the result of a type\n+ \tconversion operator.\n+\t(build_conv): Propagate ICS_USER_FLAG.\n+\t(implicit_conversion): Call instantiate_type.\n+\tPass LOOKUP_ONLYCONVERTING instead of LOOKUP_NORMAL.\n+\t(add_function_candidate): Fix cv-quals on argtype.\n+\t(print_z_candidates): New function.\n+\t(build_new_function_call): Call it.\n+\t(build_user_type_conversion_1): If LOOKUP_ONLYCONVERTING, don't\n+\tconsider non-converting constructors.\n+\tCall print_z_candidates.\n+\tReturn an AMBIG_CONV for an ambiguous conversion.\n+\t(build_user_type_conversion): Handle AMBIG_CONV.\n+\t(convert_like): Fix test for building TARGET_EXPR.\n+\tCall instantiate_type.\n+\tHandle AMBIG_CONV and LVALUE_CONV.\n+\t(build_over_call): Handle 0 args and ellipsis.\n+\t* cp-tree.def: Add AMBIG_CONV.\n+\n Tue Jul  9 17:48:48 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (lookup_name_real): If we find mem in obj when parsing\n@@ -223,11 +305,6 @@ Fri Jun  7 10:37:33 1996  Mike Stump  <mrs@cygnus.com>\n \t* typeck.c (c_expand_return): Don't try and convert the return\n \tvalue twice when we want a reference, once is enough.\n \t\n-Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n-\n-\t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n-\t(finish_file): Likewise.\n-\n Tue Jun  4 15:41:45 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (tsubst_expr, case DECL_STMT): Don't pass"}, {"sha": "dc8d29976568929bffd36dda46d7e92f84ca1762", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -1928,6 +1928,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      && TYPE_IDENTIFIER (basetype) != name)\n \t    basetype = SIGNATURE_TYPE (basetype);\n \n+\t  basetype = complete_type (basetype);\n+\n \t  if ((IS_SIGNATURE (basetype)\n \t       && (instance_ptr = instance))\n \t      || (lvalue_p (instance)"}, {"sha": "6301973cf13d0b4fe1736572aed8e14617a258c8", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -147,3 +147,4 @@ DEFTREECODE (PMEM_CONV, \"pmem_conv\", \"e\", 1)\n DEFTREECODE (BASE_CONV, \"base_conv\", \"e\", 1)\n DEFTREECODE (REF_BIND, \"ref_bind\", \"e\", 1)\n DEFTREECODE (USER_CONV, \"user_conv\", \"e\", 4)\n+DEFTREECODE (AMBIG_CONV, \"ambig_conv\", \"e\", 1)"}, {"sha": "e0a0b1976a8c26cab61824438d8a476aedc52b4a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 76, "deletions": 17, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -719,6 +719,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n #ifdef NEW_OVER\n       rval_as_conversion\n \t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n+      if (rval_as_conversion)\n+\trval_as_conversion = convert_from_reference (rval_as_conversion);\n #else\n       rval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n #endif\n@@ -1340,6 +1342,7 @@ cp_convert (type, expr, convtype, flags)\n \t  return conversion;\n \t}\n \n+#ifndef NEW_OVER\n       if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n \tctor = build_method_call (NULL_TREE, ctor_identifier,\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n@@ -1366,13 +1369,14 @@ cp_convert (type, expr, convtype, flags)\n \t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n-      else if (conversion)\n-\treturn conversion;\n       else if (ctor)\n \t{\n \t  ctor = build_cplus_new (type, ctor);\n \t  return ctor;\n \t}\n+#endif\n+      else if (conversion)\n+\treturn conversion;\n     }\n \n   /* If TYPE or TREE_TYPE (E) is not on the permanent_obstack,\n@@ -1914,6 +1918,7 @@ build_conv (code, type, from)\n       break;\n     }\n   ICS_STD_RANK (t) = rank;\n+  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n   return t;\n }\n \n@@ -2124,6 +2129,14 @@ implicit_conversion (to, from, expr, flags)\n   tree conv;\n   struct z_candidate *cand;\n \n+  if (expr && type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (to, expr, 0);\n+      if (expr == error_mark_node)\n+\treturn 0;\n+      from = TREE_TYPE (expr);\n+    }\n+\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr);\n   else\n@@ -2137,15 +2150,15 @@ implicit_conversion (to, from, expr, flags)\n \t    || IS_AGGR_TYPE (non_reference (to)))\n \t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n-      cand = build_user_type_conversion_1 (to, expr, LOOKUP_NORMAL);\n+      cand = build_user_type_conversion_1 (to, expr, LOOKUP_ONLYCONVERTING);\n       if (cand)\n \tconv = cand->second_conv;\n       else if (TREE_CODE (to) == REFERENCE_TYPE\n \t       && TYPE_READONLY (TREE_TYPE (to))\n \t       && ! TYPE_VOLATILE (TREE_TYPE (to)))\n \t{\n \t  cand = build_user_type_conversion_1\n-\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_NORMAL);\n+\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n \t  if (cand)\n \t    conv = build_conv (REF_BIND, TREE_TYPE (to), cand->second_conv);\n \t}\n@@ -2181,6 +2194,9 @@ add_function_candidate (candidates, fn, arglist, flags)\n       tree argtype = TREE_TYPE (arg);\n       tree t;\n \n+      argtype = cp_build_type_variant\n+\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+\n       if (parmnode == void_list_node)\n \tbreak;\n       else if (parmnode)\n@@ -2286,6 +2302,17 @@ build_this (obj)\n   return build_unary_op (ADDR_EXPR, obj, 0);\n }\n \n+void\n+print_z_candidates (candidates)\n+     struct z_candidate *candidates;\n+{\n+  cp_error_at (\"candidates are: %D\", candidates->fn);\n+  candidates = candidates->next;\n+\n+  for (; candidates; candidates = candidates->next)\n+    cp_error_at (\"                %D\", candidates->fn);\n+}\n+\n /* Returns the best overload candidate to perform the requested\n    conversion.  */\n \n@@ -2314,6 +2341,9 @@ build_user_type_conversion_1 (totype, expr, flags)\n     }\n   for (; ctors; ctors = DECL_CHAIN (ctors))\n     {\n+      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n+\tcontinue;\n+\n       candidates = add_function_candidate (candidates, ctors, args, flags);\n       candidates->second_conv = build1 (EXACT_CONV, totype, NULL_TREE);\n       candidates->basetype_path = TYPE_BINFO (totype);\n@@ -2355,12 +2385,16 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n   if (cand == 0)\n     {\n-      /* For recursive overloading, we need to wait and only diagnose this\n-\t if we are chosen */\n       if (flags & LOOKUP_COMPLAIN)\n-\tcp_error (\"ambiguous user-defined type conversion\");\n+\t{\n+\t  cp_error (\"ambiguous user-defined type conversion\");\n+\t  print_z_candidates (candidates);\n+\t}\n \n-      return 0;\n+      cand = candidates;\t/* any one will do */\n+      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n+\n+      return cand;\n     }\n \n   for (p = &(cand->second_conv); TREE_CODE (*p) != EXACT_CONV; )\n@@ -2384,7 +2418,11 @@ build_user_type_conversion (totype, expr, flags)\n     = build_user_type_conversion_1 (totype, expr, flags);\n \n   if (cand)\n-    return convert_like (cand->second_conv, expr);\n+    {\n+      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n+\treturn error_mark_node;\n+      return convert_like (cand->second_conv, expr);\n+    }\n   return NULL_TREE;\n }\n \n@@ -2422,6 +2460,7 @@ build_new_function_call (fn, args, obj)\n       if (cand == 0)\n \t{\n \t  cp_error (\"ambiguous function call\");\n+\t  print_z_candidates (candidates);\n \t  return error_mark_node;\n \t}\n \n@@ -2466,21 +2505,35 @@ convert_like (convs, expr)\n \texpr = build_over_call\n \t  (TREE_OPERAND (convs, 1), TREE_OPERAND (convs, 2),\n \t   DECL_CONSTRUCTOR_P (fn) ? expr : build_this (expr), LOOKUP_NORMAL);\n-\t\n-\tif (IS_AGGR_TYPE (TREE_TYPE (convs)))\n+\n+\t/* If this is a constructor or a function returning an aggr type,\n+\t   we need to build up a TARGET_EXPR.  */\n+\tif (DECL_CONSTRUCTOR_P (fn)\n+\t    || IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (fn))))\n \t  expr = build_cplus_new (TREE_TYPE (convs), expr);\n \n \treturn expr;\n       }\n     case EXACT_CONV:\n+      if (type_unknown_p (expr))\n+\texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n       return expr;\n+    case AMBIG_CONV:\n+      /* Call build_user_type_conversion again for the error.  */\n+      return build_user_type_conversion\n+\t(TREE_TYPE (convs), TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n+    };\n+\n+  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+  switch (TREE_CODE (convs))\n+    {\n     case REF_BIND:\n-      expr = convert_like (TREE_OPERAND (convs, 0), expr);\n       return convert_to_reference\n \t(build_reference_type (TREE_TYPE (convs)), expr,\n \t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION, error_mark_node);\n+    case LVALUE_CONV:\n+      return decay_conversion (expr);\n     }\n-  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n   return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n \t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n@@ -2526,7 +2579,7 @@ build_over_call (fn, convs, args, flags)\n   tree conv, arg;\n   int i;\n \n-  if (TREE_CODE (args) != TREE_LIST)\n+  if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_tree_list (NULL_TREE, args);\n   arg = args;\n \n@@ -2555,18 +2608,24 @@ build_over_call (fn, convs, args, flags)\n       conv = TREE_CHAIN (conv);\n     }\n \n-  for (i = 0; conv = TREE_VEC_ELT (convs, i), arg;\n+  for (i = 0; conv = TREE_VEC_ELT (convs, i), arg && parm;\n        parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n     converted_args = tree_cons\n       (NULL_TREE, convert_like (conv, TREE_VALUE (arg)),\n        converted_args);\n \n+  /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n     converted_args = tree_cons\n       (NULL_TREE,\n        convert_default_arg (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n        converted_args);\n \n+  /* Ellipsis */\n+  for (; arg; arg = TREE_CHAIN (arg))\n+    converted_args = tree_cons\n+      (NULL_TREE, default_conversion (TREE_VALUE (arg)), converted_args);\n+\n   converted_args = nreverse (converted_args);\n \n   mark_used (fn);\n@@ -2594,9 +2653,9 @@ build_over_call (fn, convs, args, flags)\n }\n \n /* Compare two implicit conversion sequences that differ only in their\n-   qualification conversion.  */\n+   qualification conversion.  Subroutine of compare_ics.  */\n \n-int\n+static int\n compare_qual (ics1, ics2)\n      tree ics1, ics2;\n {"}, {"sha": "3ac5bb8beb6e091f29c04a3b4e55b067e8b75839", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -4444,11 +4444,9 @@ lookup_name_real (name, prefer_type, nonclass)\n \t}\n #endif\n \n-      if (got_scope || val)\n+      if (got_scope)\n \tgoto done;\n-\n-      /* This special lookup only applies to types.  */\n-      else if (got_object && val && TREE_CODE (val) == TYPE_DECL)\n+      else if (got_object && val)\n \tfrom_obj = val;\n     }\n \n@@ -4522,6 +4520,8 @@ lookup_name_real (name, prefer_type, nonclass)\n \t      cp_pedwarn (\"  does not match lookup in the current scope (`%#T')\",\n \t\t\t  TREE_TYPE (val));\n \t    }\n+\n+\t  val = from_obj;\n \t}\n \n       if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n@@ -8435,6 +8435,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t\t\t\t\t  integer_one_node), 1));\n \t\tif (! TREE_CONSTANT (itype))\n \t\t  itype = variable_size (itype);\n+\t\telse if (TREE_OVERFLOW (itype))\n+\t\t  {\n+\t\t    error (\"overflow in array dimension\");\n+\t\t    TREE_OVERFLOW (itype) = 0;\n+\t\t  }\n \n \t\t/* If we're a parm, we need to have a permanent type so\n                    mangling checks for re-use will work right.  If both the"}, {"sha": "389cd06571b128ee47621b733c294b95a626798f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -2542,7 +2542,7 @@ import_export_vtable (decl, type, final)\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_WEAK (decl) = 1;\n \t    }\n-#ifdef ASSEMBLE_EXTERNAL\n+#ifdef ASM_OUTPUT_EXTERNAL\n \t  else if (TREE_PUBLIC (decl))\n \t    cp_error (\"all virtual functions redeclared inline\");\n #endif"}, {"sha": "862dca75a66b103343d9e30262469d9e582147e0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -1530,21 +1530,20 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t  return;\n \t}\n \n-#ifndef NEW_OVER\n-      /* See whether we can go through a type conversion operator.\n-\t This wins over going through a non-existent constructor.  If\n-\t there is a constructor, it is ambiguous.  */\n-      if (TREE_CODE (init) != TREE_LIST)\n+      /* If this is copy-initialization, see whether we can go through a\n+\t type conversion operator.  */\n+      if (TREE_CODE (init) != TREE_LIST && (flags & LOOKUP_ONLYCONVERTING))\n \t{\n \t  tree ttype = TREE_CODE (init_type) == REFERENCE_TYPE\n \t    ? TREE_TYPE (init_type) : init_type;\n \n \t  if (ttype != type && IS_AGGR_TYPE (ttype))\n \t    {\n-\t      tree rval = build_type_conversion (CONVERT_EXPR, type, init, 0);\n+\t      tree rval = build_type_conversion (CONVERT_EXPR, type, init, 1);\n \n \t      if (rval)\n \t\t{\n+#ifndef NEW_OVER\n \t\t  /* See if there is a constructor for``type'' that takes a\n \t\t     ``ttype''-typed object.  */\n \t\t  tree parms = build_tree_list (NULL_TREE, init);\n@@ -1558,12 +1557,13 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n \t\t\t      type);\n \t\t  else\n+#endif\n+\t\t  if (rval != error_mark_node)\n \t\t    expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n \t\t  return;\n \t\t}\n \t    }\n \t}\n-#endif\n     }\n \n   /* We know that expand_default_init can handle everything we want\n@@ -2022,7 +2022,8 @@ resolve_offset_ref (exp)\n \n   if ((TREE_CODE (member) == VAR_DECL\n        && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (member)))\n-      || TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE)\n+      || TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE\n+      || TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n     {\n       /* These were static members.  */\n       if (mark_addressable (member) == 0)"}, {"sha": "88dd85f72e9fe63e5dc424a8ca7f6eeea8f574f0", "filename": "gcc/cp/mpw-config.in", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fmpw-config.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fmpw-config.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmpw-config.in?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -0,0 +1,11 @@\n+# Configuration fragment for G++.\n+# Most of the real configuration work happens in the main GCC configure.\n+\n+# We need to join some lines in the Makefile.in before the sed\n+# process will work properly.  The funky little sed script works by\n+# recognizing lines with a trailing '$@ \\', adding the next line to\n+# its \"pattern space\", editing out the backslash and line, then\n+# putting the result out.\n+\n+sed -e '/$@ \\\\/{N;s/$@ \\\\./$@ /;P;D;}' \\Option-d\n+    \"{srcdir}\"Makefile.in >\"{o}\"hacked_Makefile.in"}, {"sha": "e821e9b43208277984eb21dbe5dfd7abaa65a033", "filename": "gcc/cp/mpw-make.sed", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fmpw-make.sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fmpw-make.sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmpw-make.sed?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -0,0 +1,110 @@\n+# Sed commands to finish translating the G++ Unix makefile into MPW syntax.\n+\n+# Remove control-Ls, they upset MPW make.\n+s/\f//g\n+\n+# Remove references to always-empty variables used to mark things.\n+/CYGNUS-LOCAL-/s/{CYGNUS-LOCAL-[a-z0-9]*}//g\n+\n+# Add a bunch of definitions, mostly empty.\n+/^# Variables that exist for you to override.$/a\\\n+\\\n+xmake_file = \\\n+tmake_file = \\\n+build_xm_file = \\\n+MALLOC = \\\n+MD_DEPS = \\\n+REAL_H = \\\n+HOST_CC_LD = {CC_LD}\\\n+ALL_CCLDFLAGS = \\\n+HOST_CCLDFLAGS = \\\n+CONFIG_H = \\\n+LIBDEPS = \\\n+\n+# The \"target\" variable is special to MPW make, avoid it.\n+/{target}/s/{target}/{target_canonical}/g\n+\n+# Suppress the suppression of smart makes.\n+/^\\.y\\.c/d\n+\n+# Whack out \"...\" assignments.\n+/\\.\\.\\./s/^\\([a-z_]*= \\.\\.\\.\\)/#\\1/\n+\n+# Previous edits go a little overboard, undo.\n+/^objext = /s/\"{o}\"//\n+\n+# Always link in low-level MPW functions.\n+/^LIBDEPS=/s/$/ ::strerror.c.o ::mpwlib.c.o/\n+/{CLIB}/s/{CLIB}/ ::strerror.c.o ::mpwlib.c.o {CLIB}/\n+\n+# Don't get tricky about finding various .o file, point at dir above.\n+/^SUBDIR_OBSTACK/s/`.*`/::obstack.c.o/\n+/^SUBDIR_USE_ALLOCA/s/`.*`/::alloca.c.o/\n+/^SUBDIR_MALLOC/s/`.*`//\n+\n+# Point includes at parent directly correctly.\n+/^INCLUDES = .*$/s/:\\./::/g\n+/^INCLUDES = .*$/s/\"{srcdir}\"\\.\\./\"{topsrcdir}\"gcc:/g\n+\n+# Add the special MPW include dirs.\n+/^INCLUDES = .*$/s/$/ -i \"{topsrcdir}\"include:mpw: -i :::extra-include:/\n+\n+# A nasty hack to reduce confusion.\n+/true/s/ ; @true$//\n+\n+# (should be in common translation?)\n+/{CC_LD} /s/$/ {EXTRALIBS}/\n+\n+# Don't use general compiler flags (which may include definitions\n+# and other compiler-only bits) with linking commands.\n+/{CC_LD} /s/ALL_CFLAGS/ALL_CCLDFLAGS/\n+\n+# Whack out build rules that are not useful.\n+/^Makefile \\\\Option-f /,/^$/d\n+/^config.status \\\\Option-f /,/^$/d\n+# (Note that MPW make is not case sensitive, and so this name\n+# is considered the same as \"md_file\".)\n+/^{MD_FILE} \\\\Option-f/,/^$/d\n+\n+# Depending on config.status is not useful for us.\n+/config.status/s/ config.status//\n+\n+# Repeat of stuff from generic edit.\n+/{s}/s/\"{s}\"\"{s}\"/\"{s}\"/g\n+/{s}/s/\"{s}\"\"{srcdir}\"/\"{s}\"/g\n+/{s}/s/\"{srcdir}\"\"{s}\"/\"{s}\"/g\n+\n+# Fix references to C frontend files in main dir.\n+/::c-/s/\"{o}\"::c-/\"{o}\":c-/g\n+\n+# Fix pathnames to generated files in the objdir.\n+/parse/s/\"{s}\"parse\\.\\([chy]\\)/\"{o}\"parse.\\1/g\n+/parse/s/^parse\\.\\([chy]\\)/\"{o}\"parse.\\1/\n+/y.tab.c/s/\"{s}\"y\\.tab\\.c/\"{o}\"y.tab.c/g\n+/y.tab.c/s/^y\\.tab\\.c/\"{o}\"y.tab.c/\n+/y.tab.h/s/\"{s}\"y\\.tab\\.h/\"{o}\"y.tab.h/g\n+/y.tab.h/s/^y\\.tab\\.h/\"{o}\"y.tab.h/\n+\n+# Put in the definition of YYEMPTY directly.\n+/grep/s/grep .* >>/Echo '#define YYEMPTY -1' >>/\n+\n+# If the dates are wrong, then this tries to run gperf, which we don't\n+# really want.\n+/^\"{srcdir}\"hash.h/,/hash.h$/d\n+\n+# Sed the object file list instead of using cat (meow).\n+/cat/s/`cat /`sed -e 's,:,::,g' -e 's,{objext},.o,g' /\n+\n+# Simplify dependencies of generated parser files.\n+/^{PARSE_C}/s/^/#/\n+/^stamp-parse/s/^stamp-parse/{PARSE_C}/\n+\n+# Fix the compile line for the generated parser.\n+/{CC} -c/,/echo {PARSE_C}/c\\\n+\t{CC} {ALL_CFLAGS} {ALL_CPPFLAGS} {INCLUDES} {BIG_SWITCHFLAG} \"{o}\"parse.c -o \"{o}\"parse.c.o\\\n+\n+# Change all Rez commands to use mac-gcc.r.\n+/{REZ}/s/\"{s}\"[-a-zA-Z{}]*\\.r/\"{topsrcdir}\"gcc:mac-gcc.r/\n+\n+# Remove pathname junk from the container name.\n+/{REZ}/s/'\"'::cc1plus'\"'/'\"'cc1plus'\"'/"}, {"sha": "eedfd11bca003293739099ec832c645387a6fda0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -2246,7 +2246,8 @@ maybecomma:\n maybecomma_warn:\n \t  /* empty */\n \t| ','\n-\t\t{ if (pedantic) pedwarn (\"comma at end of enumerator list\"); }\n+\t\t{ if (pedantic && !in_system_header)\n+\t\t    pedwarn (\"comma at end of enumerator list\"); }\n \t;\n \n aggr:\t  AGGR"}, {"sha": "3e837f78d5b632a02dcf706cf9391fbedd828a6d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 104, "deletions": 70, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -1889,7 +1889,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n \t\t\t}\n \t\t      mark_used (fndecl);\n-\t\t      return fndecl;\n+\t\t      return build (OFFSET_REF, TREE_TYPE (fndecl), datum, fndecl);\n \t\t    }\n \t\t  if (access == access_protected_node)\n \t\t    cp_error (\"member function `%D' is protected\", fndecl);\n@@ -2372,6 +2372,9 @@ build_x_function_call (function, params, decl)\n \t}\n       else\n \t{\n+#ifdef NEW_OVER\n+\t  return build_new_function_call (function, params, NULL_TREE);\n+#else\n \t  tree val = TREE_VALUE (function);\n \n \t  if (TREE_CODE (val) == TEMPLATE_DECL)\n@@ -2382,6 +2385,7 @@ build_x_function_call (function, params, decl)\n \t      (function, params, LOOKUP_COMPLAIN);\n \t  else\n \t    my_friendly_abort (360);\n+#endif\n \t}\n     }\n \n@@ -6007,6 +6011,79 @@ get_delta_difference (from, to, force)\n   return BINFO_OFFSET (binfo);\n }\n \n+static tree\n+build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n+     tree type, delta, idx, pfn, delta2;\n+{\n+  tree u;\n+\n+#if 0\n+  /* This is the old way we did it.  We want to avoid calling\n+     digest_init, so that it can give an error if we use { } when\n+     initializing a pointer to member function.  */\n+\n+  if (pfn)\n+    {\n+      u = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t    tree_cons (pfn_identifier, pfn, NULL_TREE));\n+    }\n+  else\n+    {\n+      u = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t    tree_cons (delta2_identifier, delta2, NULL_TREE));\n+    }\n+\n+  u = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\ttree_cons (NULL_TREE, delta,\n+\t\t\t   tree_cons (NULL_TREE, idx,\n+\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\n+  return digest_init (type, u, (tree*)0);\n+#else\n+  tree delta_field, idx_field, pfn_or_delta2_field, pfn_field, delta2_field;\n+  tree subtype;\n+  int allconstant, allsimple;\n+\n+  delta_field = TYPE_FIELDS (type);\n+  idx_field = TREE_CHAIN (delta_field);\n+  pfn_or_delta2_field = TREE_CHAIN (idx_field);\n+  subtype = TREE_TYPE (pfn_or_delta2_field);\n+  pfn_field = TYPE_FIELDS (subtype);\n+  delta2_field = TREE_CHAIN (pfn_field);\n+\n+  if (pfn)\n+    {\n+      allconstant = TREE_CONSTANT (pfn);\n+      allsimple = initializer_constant_valid_p (pfn, TREE_TYPE (pfn));\n+      u = tree_cons (pfn_field, pfn, NULL_TREE);\n+    }\n+  else\n+    {\n+      delta2 = convert_and_check (delta_type_node, delta2);\n+      allconstant = TREE_CONSTANT (delta2);\n+      allsimple = initializer_constant_valid_p (delta2, TREE_TYPE (delta2));\n+      u = tree_cons (delta2_field, delta2, NULL_TREE);\n+    }\n+\n+  delta = convert_and_check (delta_type_node, delta);\n+  idx = convert_and_check (delta_type_node, idx);\n+\n+  allconstant = allconstant && TREE_CONSTANT (delta) && TREE_CONSTANT (idx);\n+  allsimple = allsimple\n+    && initializer_constant_valid_p (delta, TREE_TYPE (delta))\n+      && initializer_constant_valid_p (idx, TREE_TYPE (idx));\n+\n+  u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n+  u = tree_cons (delta_field, delta,\n+\t\t tree_cons (idx_field, idx,\n+\t\t\t    tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n+  u = build (CONSTRUCTOR, type, NULL_TREE, u);\n+  TREE_CONSTANT (u) = allconstant;\n+  TREE_STATIC (u) = allconstant && allsimple;\n+  return u;\n+#endif\n+}\n+\n /* Build a constructor for a pointer to member function.  It can be\n    used to initialize global variables, local variable, or used\n    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we\n@@ -6027,87 +6104,50 @@ build_ptrmemfunc (type, pfn, force)\n   tree delta = integer_zero_node;\n   tree delta2 = integer_zero_node;\n   tree vfield_offset;\n-  tree npfn;\n+  tree npfn = NULL_TREE;\n   tree u;\n \n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n       tree ndelta, ndelta2, nindex;\n+      tree e1, e2, e3, n;\n+\n       /* Is is already the right type? */\n       if (type == TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n \treturn pfn;\n \n-      if (TREE_CODE (pfn) != CONSTRUCTOR)\n-\t{\n-\t  tree e1, e2, e3;\n-\t  ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n-\t  ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n-\t  idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n-\t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n-\t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n-\t\t\t\t\tforce);\n-\t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n-\t  delta2 = build_binary_op (PLUS_EXPR, ndelta2, delta2, 1);\n-\t  e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n+      ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n+      ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n+      idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n+\n+      n = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n+\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+\t\t\t\tforce);\n+\n+      delta = build_binary_op (PLUS_EXPR, ndelta, n, 1);\n+      delta2 = build_binary_op (PLUS_EXPR, ndelta2, n, 1);\n+      e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n-\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n-\t  e2 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+      e2 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx,\n+\t\t\t      NULL_TREE, delta2);\n \n-\t  pfn = PFN_FROM_PTRMEMFUNC (pfn);\n-\t  npfn = build1 (NOP_EXPR, type, pfn);\n-\t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n+      pfn = PFN_FROM_PTRMEMFUNC (pfn);\n+      npfn = build1 (NOP_EXPR, type, pfn);\n+      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, npfn, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n-\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n-\t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n-\t  return build_conditional_expr (e1, e2, e3);\n-\t}\n-\n-      ndelta = TREE_VALUE (CONSTRUCTOR_ELTS (pfn));\n-      nindex = TREE_VALUE (TREE_CHAIN (CONSTRUCTOR_ELTS (pfn)));\n-      npfn = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (pfn))));\n-      npfn = TREE_VALUE (CONSTRUCTOR_ELTS (npfn));\n-      if (integer_zerop (nindex))\n-\tpfn = integer_zero_node;\n-      else if (integer_zerop (fold (size_binop (PLUS_EXPR, nindex, integer_one_node))))\n-\t{\n-\t  tree e3;\n-\t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n-\t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n-\t\t\t\t\tforce);\n-\t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n-\t  pfn = build1 (NOP_EXPR, type, npfn);\n-\t  TREE_CONSTANT (pfn) = TREE_CONSTANT (npfn);\n-\n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, pfn, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t\t   tree_cons (NULL_TREE, nindex,\n-\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n-\t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n-\t  return e3;\n-\t}\n-      else\n-\t{\n-\t  sorry (\"value casting of variable nonnull pointer to member functions not supported\");\n-\t  return error_mark_node;\n-\t}\n+      e3 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx, npfn,\n+\t\t\t      NULL_TREE);\n+      return build_conditional_expr (e1, e2, e3);\n     }\n \n   /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n       pfn = build_c_cast (type, integer_zero_node, 0);\n-      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, pfn, NULL_TREE));\n-      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t\t       tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t\t\t\t  tree_cons (NULL_TREE, u, NULL_TREE))));\n-      return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+      return build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type),\n+\t\t\t\tinteger_zero_node, integer_zero_node,\n+\t\t\t\tpfn, NULL_TREE);\n     }\n \n   if (TREE_CODE (pfn) == TREE_LIST\n@@ -6151,7 +6191,6 @@ build_ptrmemfunc (type, pfn, force)\n       idx = size_binop (PLUS_EXPR,\n \t\t\tDECL_VINDEX (TREE_OPERAND (pfn, 0)),\n \t\t\tinteger_one_node);\n-      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n     }\n   else\n     {\n@@ -6166,14 +6205,9 @@ build_ptrmemfunc (type, pfn, force)\n \t  npfn = build1 (NOP_EXPR, type, pfn);\n \t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \t}\n-\n-      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, npfn, NULL_TREE));\n     }\n \n-  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n-\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n-  return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+  return build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx, npfn, delta2);\n }\n \n /* Convert value RHS to type TYPE as preparation for an assignment"}, {"sha": "c224892f0638d1f4b0ebd88865d947a7fa0fc306", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594740f365ed33c25f3ad1a43bdbbd2326a932de/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=594740f365ed33c25f3ad1a43bdbbd2326a932de", "patch": "@@ -1011,6 +1011,9 @@ process_init_constructor (type, init, elts)\n \t      sorry (\"initializer list for object using virtual functions\");\n \t      return error_mark_node;\n \t    }\n+\n+\t  if (TYPE_PTRMEMFUNC_P (type))\n+\t    cp_pedwarn (\"initializer list for `%T'\", type);\n \t}\n \n       for (field = TYPE_FIELDS (type); field && tail;"}]}