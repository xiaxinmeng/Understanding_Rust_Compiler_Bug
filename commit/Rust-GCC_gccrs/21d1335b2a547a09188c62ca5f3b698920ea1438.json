{"sha": "21d1335b2a547a09188c62ca5f3b698920ea1438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFkMTMzNWIyYTU0N2EwOTE4OGM2MmNhNWYzYjY5ODkyMGVhMTQzOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-03-10T17:22:31Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-03-10T17:22:31Z"}, "message": "libgfortran.h (descriptor_dimension, [...]): Rename _lbound to lower_bound and data to base_addr.\n\n2012-03-10  Tobias Burnus  <burnus@net-b.de>\n\n        * libgfortran.h (descriptor_dimension, GFC_DIMENSION_LBOUND,\n        GFC_DIMENSION_EXTENT, GFC_DIMENSION_SET, GFC_DESCRIPTOR_DATA,\n        GFC_ARRAY_DESCRIPTOR): Rename _lbound to lower_bound and\n        data to base_addr.\n        * intrinsics/cshift0.c (size0, cshift0): Handle data to\n        base_addr rename.\n        * intrinsics/date_and_time.c (date_and_time, secnds, itime_i4,\n        itime_i8, gmtime_i4, gmtime_i8, ltime_i4, ltime_i8): Ditto.\n        * intrinsics/dtime.c (dtime_sub): Ditto.\n        * intrinsics/eoshift0.c (eoshift0): Ditto.\n        * intrinsics/eoshift2.c (eoshift2): Ditto.\n        * intrinsics/etime.c (etime_sub): Ditto.\n        * intrinsics/iso_c_binding.c (c_f_pointer_u0): Ditto.\n        * intrinsics/move_alloc.c (move_alloc): Ditto.\n        * intrinsics/pack_generic.c (pack_internal, pack,\n        pack_s_internal): Ditto.\n        * intrinsics/random.c (arandom_r4, arandom_r8, arandom_r10,\n        arandom_r16, random_seed_i4, random_seed_i8): Ditto.\n        * intrinsics/reshape_generic.c (reshape_internal): Ditto.\n        * intrinsics/spread_generic.c (spread_internal,\n        spread_internal_scalar, spread, spread_scalar): Ditto.\n        * intrinsics/stat.c (stat_i4_sub_0, stat_i8_sub_0, fstat_i4_sub,\n        fstat_i8_sub): Ditto.\n        * intrinsics/transpose_generic.c (transpose_internal): Ditto.\n        * intrinsics/unpack_generic.c (unpack_bounds, unpack_internal,\n        unpack1, unpack0, unpack0_char4): Ditto.\n        * m4/bessel.m4 (bessel_jn_r'rtype_kind`,\n        * bessel_yn_r'rtype_kind`):\n        Ditto.\n        * m4/cshift0.m4 (cshift0_'rtype_code`): Ditto.\n        * m4/cshift1.m4 (cshift1): Ditto.\n        * m4/eoshift1.m4 (eoshift1): Ditto.\n        * m4/eoshift3.m4 (eoshift3): Ditto.\n        * m4/iforeach.m4 (name`'rtype_qual`_'atype_code): Ditto.\n        * m4/ifunction.m4 (name`'rtype_qual`_'atype_code): Ditto.\n        * m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code):\n        * Ditto.\n        * m4/in_pack.m4 (internal_pack_'rtype_ccode`): Ditto.\n        * m4/in_unpack.m4 (internal_unpack_'rtype_ccode`): Ditto.\n        * m4/matmul.m4 (matmul_'rtype_code`): Ditto.\n        * m4/matmull.m4 (matmul_'rtype_code`): Ditto.\n        * m4/pack.m4 (pack_'rtype_code`): Ditto.\n        * m4/reshape.m4 (reshape_'rtype_ccode`): Ditto.\n        * m4/shape.m4 (shape_'rtype_kind`): Ditto.\n        * m4/spread.m4 (spread_'rtype_code`): Ditto.\n        * m4/transpose.m4 (transpose_'rtype_code`): Ditto.\n        * m4/unpack.m4 (unpack0_'rtype_code`, unpack1_'rtype_code`):\n        * Ditto.\n        * runtime/bounds.c (count_0): Ditto.\n        * runtime/in_pack_generic.c (internal_pack): Ditto.\n        * runtime/in_unpack_generic.c (internal_unpack): Ditto.\n        * generated/cshift0_r4.c: Regenerated.\n        * generated/unpack_r8.c: Regenerated.\n        * generated/cshift0_c10.c: Regenerated.\n        * generated/in_unpack_i1.c: Regenerated.\n        * generated/eoshift1_16.c: Regenerated.\n        * generated/iany_i16.c: Regenerated.\n        * generated/reshape_i4.c: Regenerated.\n        * generated/parity_l16.c: Regenerated.\n        * generated/in_unpack_r16.c: Regenerated.\n        * generated/iparity_i1.c: Regenerated.\n        * generated/minloc0_16_r10.c: Regenerated.\n        * generated/minloc1_16_i8.c: Regenerated.\n        * generated/bessel_r8.c: Regenerated.\n        * generated/maxloc0_4_i8.c: Regenerated.\n        * generated/maxloc1_8_i1.c: Regenerated.\n        * generated/sum_c10.c: Regenerated.\n        * generated/maxloc0_8_r10.c: Regenerated.\n        * generated/unpack_r16.c: Regenerated.\n        * generated/maxloc1_16_i1.c: Regenerated.\n        * generated/minloc1_4_i1.c: Regenerated.\n        * generated/unpack_i4.c: Regenerated.\n        * generated/in_pack_i1.c: Regenerated.\n        * generated/cshift0_i1.c: Regenerated.\n        * generated/minloc0_16_i4.c: Regenerated.\n        * generated/minloc1_8_r8.c: Regenerated.\n        * generated/maxval_r8.c: Regenerated.\n        * generated/unpack_i2.c: Regenerated.\n        * generated/matmul_r16.c: Regenerated.\n        * generated/maxloc0_16_r8.c: Regenerated.\n        * generated/maxloc1_8_i16.c: Regenerated.\n        * generated/maxloc0_4_r4.c: Regenerated.\n        * generated/pack_c10.c: Regenerated.\n        * generated/in_unpack_c8.c: Regenerated.\n        * generated/maxloc1_8_i8.c: Regenerated.\n        * generated/in_pack_c16.c: Regenerated.\n        * generated/parity_l1.c: Regenerated.\n        * generated/in_pack_i2.c: Regenerated.\n        * generated/maxloc0_4_r8.c: Regenerated.\n        * generated/pack_r4.c: Regenerated.\n        * generated/matmul_r8.c: Regenerated.\n        * generated/pack_i1.c: Regenerated.\n        * generated/minloc0_16_r16.c: Regenerated.\n        * generated/cshift0_c8.c: Regenerated.\n        * generated/minloc1_4_i16.c: Regenerated.\n        * generated/minloc0_4_r4.c: Regenerated.\n        * generated/product_i2.c: Regenerated.\n        * generated/maxval_r10.c: Regenerated.\n        * generated/minloc0_16_r8.c: Regenerated.\n        * generated/in_pack_i8.c: Regenerated.\n        * generated/all_l8.c: Regenerated.\n        * generated/minloc0_8_i16.c: Regenerated.\n        * generated/minloc1_8_i2.c: Regenerated.\n        * generated/matmul_l8.c: Regenerated.\n        * generated/spread_r10.c: Regenerated.\n        * generated/product_c4.c: Regenerated.\n        * generated/reshape_r16.c: Regenerated.\n        * generated/cshift0_i16.c: Regenerated.\n        * generated/minloc1_8_r10.c: Regenerated.\n        * generated/iparity_i8.c: Regenerated.\n        * generated/minloc0_16_i8.c: Regenerated.\n        * generated/minloc1_8_i1.c: Regenerated.\n        * generated/maxloc0_16_r10.c: Regenerated.\n        * generated/maxloc1_8_i4.c: Regenerated.\n        * generated/maxloc0_16_i8.c: Regenerated.\n        * generated/maxloc1_16_i16.c: Regenerated.\n        * generated/reshape_i8.c: Regenerated.\n        * generated/all_l16.c: Regenerated.\n        * generated/cshift1_8.c: Regenerated.\n        * generated/matmul_c10.c: Regenerated.\n        * generated/pack_r16.c: Regenerated.\n        * generated/transpose_r10.c: Regenerated.\n        * generated/maxloc1_16_i2.c: Regenerated.\n        * generated/minloc1_4_r4.c: Regenerated.\n        * generated/reshape_r8.c: Regenerated.\n        * generated/product_r10.c: Regenerated.\n        * generated/spread_c10.c: Regenerated.\n        * generated/reshape_r4.c: Regenerated.\n        * generated/in_unpack_i4.c: Regenerated.\n        * generated/minval_r4.c: Regenerated.\n        * generated/minloc1_16_r16.c: Regenerated.\n        * generated/norm2_r8.c: Regenerated.\n        * generated/iany_i2.c: Regenerated.\n        * generated/eoshift3_8.c: Regenerated.\n        * generated/maxloc1_16_r8.c: Regenerated.\n        * generated/maxloc0_16_r16.c: Regenerated.\n        * generated/cshift0_i8.c: Regenerated.\n        * generated/all_l1.c: Regenerated.\n        * generated/minloc1_16_r10.c: Regenerated.\n        * generated/spread_i16.c: Regenerated.\n        * generated/minloc1_8_r16.c: Regenerated.\n        * generated/spread_r16.c: Regenerated.\n        * generated/matmul_c8.c: Regenerated.\n        * generated/pack_r10.c: Regenerated.\n        * generated/reshape_r10.c: Regenerated.\n        * generated/sum_r10.c: Regenerated.\n        * generated/count_8_l.c: Regenerated.\n        * generated/minloc1_16_i16.c: Regenerated.\n        * generated/maxloc0_16_i2.c: Regenerated.\n        * generated/count_1_l.c: Regenerated.\n        * generated/unpack_c16.c: Regenerated.\n        * generated/any_l8.c: Regenerated.\n        * generated/minloc1_16_i1.c: Regenerated.\n        * generated/sum_r4.c: Regenerated.\n        * generated/in_unpack_r8.c: Regenerated.\n        * generated/product_r8.c: Regenerated.\n        * generated/in_unpack_r4.c: Regenerated.\n        * generated/unpack_i1.c: Regenerated.\n        * generated/cshift0_r8.c: Regenerated.\n        * generated/spread_i2.c: Regenerated.\n        * generated/minloc1_4_r10.c: Regenerated.\n        * generated/minloc1_16_i2.c: Regenerated.\n        * generated/minloc0_16_i2.c: Regenerated.\n        * generated/eoshift3_16.c: Regenerated.\n        * generated/maxloc0_8_i4.c: Regenerated.\n        * generated/maxloc1_16_r10.c: Regenerated.\n        * generated/maxloc1_4_i16.c: Regenerated.\n        * generated/maxloc1_4_r8.c: Regenerated.\n        * generated/parity_l2.c: Regenerated.\n        * generated/maxloc0_16_i16.c: Regenerated.\n        * generated/product_r4.c: Regenerated.\n        * generated/in_unpack_r10.c: Regenerated.\n        * generated/maxloc1_8_i2.c: Regenerated.\n        * generated/iparity_i2.c: Regenerated.\n        * generated/maxloc1_8_r4.c: Regenerated.\n        * generated/maxloc1_8_r8.c: Regenerated.\n        * generated/iall_i4.c: Regenerated.\n        * generated/maxloc0_4_i16.c: Regenerated.\n        * generated/cshift0_i4.c: Regenerated.\n        * generated/in_unpack_c10.c: Regenerated.\n        * generated/unpack_c8.c: Regenerated.\n        * generated/transpose_c8.c: Regenerated.\n        * generated/in_unpack_c16.c: Regenerated.\n        * generated/product_c16.c: Regenerated.\n        * generated/minval_r8.c: Regenerated.\n        * generated/minloc0_4_i1.c: Regenerated.\n        * generated/minloc0_8_r16.c: Regenerated.\n        * generated/in_unpack_i16.c: Regenerated.\n        * generated/reshape_c16.c: Regenerated.\n        * generated/pack_i4.c: Regenerated.\n        * generated/minval_r10.c: Regenerated.\n        * generated/maxloc0_4_r10.c: Regenerated.\n        * generated/unpack_i8.c: Regenerated.\n        * generated/minloc1_16_r8.c: Regenerated.\n        * generated/pack_c16.c: Regenerated.\n        * generated/maxval_r4.c: Regenerated.\n        * generated/spread_r8.c: Regenerated.\n        * generated/minloc0_16_r4.c: Regenerated.\n        * generated/maxval_i4.c: Regenerated.\n        * generated/matmul_r4.c: Regenerated.\n        * generated/product_c8.c: Regenerated.\n        * generated/maxloc1_4_i4.c: Regenerated.\n        * generated/any_l4.c: Regenerated.\n        * generated/cshift0_r16.c: Regenerated.\n        * generated/maxloc1_16_r4.c: Regenerated.\n        * generated/in_pack_r10.c: Regenerated.\n        * generated/iall_i1.c: Regenerated.\n        * generated/product_i1.c: Regenerated.\n        * generated/maxloc0_4_i1.c: Regenerated.\n        * generated/maxloc0_8_r16.c: Regenerated.\n        * generated/minloc1_8_i16.c: Regenerated.\n        * generated/reshape_c10.c: Regenerated.\n        * generated/matmul_l4.c: Regenerated.\n        * generated/cshift0_c16.c: Regenerated.\n        * generated/spread_r4.c: Regenerated.\n        * generated/sum_r16.c: Regenerated.\n        * generated/in_unpack_c4.c: Regenerated.\n        * generated/maxval_i8.c: Regenerated.\n        * generated/maxloc0_8_r8.c: Regenerated.\n        * generated/unpack_i16.c: Regenerated.\n        * generated/norm2_r4.c: Regenerated.\n        * generated/maxloc1_4_r16.c: Regenerated.\n        * generated/in_pack_r4.c: Regenerated.\n        * generated/sum_c8.c: Regenerated.\n        * generated/parity_l8.c: Regenerated.\n        * generated/minval_i2.c: Regenerated.\n        * generated/transpose_c10.c: Regenerated.\n        * generated/cshift0_r10.c: Regenerated.\n        * generated/cshift0_i2.c: Regenerated.\n        * generated/spread_c4.c: Regenerated.\n        * generated/maxval_r16.c: Regenerated.\n        * generated/unpack_c10.c: Regenerated.\n        * generated/bessel_r4.c: Regenerated.\n        * generated/minloc0_8_i1.c: Regenerated.\n        * generated/product_c10.c: Regenerated.\n        * generated/minloc1_4_i4.c: Regenerated.\n        * generated/minloc1_4_i2.c: Regenerated.\n        * generated/transpose_c4.c: Regenerated.\n        * generated/in_pack_c8.c: Regenerated.\n        * generated/minval_i8.c: Regenerated.\n        * generated/maxloc1_4_i2.c: Regenerated.\n        * generated/maxloc1_4_i1.c: Regenerated.\n        * generated/iall_i8.c: Regenerated.\n        * generated/iany_i8.c: Regenerated.\n        * generated/sum_c16.c: Regenerated.\n        * generated/spread_i8.c: Regenerated.\n        * generated/sum_i8.c: Regenerated.\n        * generated/pack_i2.c: Regenerated.\n        * generated/unpack_r10.c: Regenerated.\n        * generated/minloc0_4_i4.c: Regenerated.\n        * generated/iany_i4.c: Regenerated.\n        * generated/maxloc0_4_i4.c: Regenerated.\n        * generated/in_pack_r8.c: Regenerated.\n        * generated/spread_i1.c: Regenerated.\n        * generated/maxval_i16.c: Regenerated.\n        * generated/pack_c8.c: Regenerated.\n        * generated/iparity_i16.c: Regenerated.\n        * generated/matmul_c16.c: Regenerated.\n        * generated/eoshift1_8.c: Regenerated.\n        * generated/any_l16.c: Regenerated.\n        * generated/maxloc1_4_i8.c: Regenerated.\n        * generated/minloc0_8_r4.c: Regenerated.\n        * generated/transpose_c16.c: Regenerated.\n        * generated/reshape_c4.c: Regenerated.\n        * generated/minloc0_8_r8.c: Regenerated.\n        * generated/count_16_l.c: Regenerated.\n        * generated/minloc0_16_i1.c: Regenerated.\n        * generated/minloc1_16_r4.c: Regenerated.\n        * generated/maxloc0_8_i1.c: Regenerated.\n        * generated/matmul_i1.c: Regenerated.\n        * generated/sum_i2.c: Regenerated.\n        * generated/cshift1_4.c: Regenerated.\n        * generated/minloc0_4_i2.c: Regenerated.\n        * generated/bessel_r10.c: Regenerated.\n        * generated/matmul_c4.c: Regenerated.\n        * generated/parity_l4.c: Regenerated.\n        * generated/in_unpack_i2.c: Regenerated.\n        * generated/product_i16.c: Regenerated.\n        * generated/maxloc0_16_i4.c: Regenerated.\n        * generated/minloc0_4_r10.c: Regenerated.\n        * generated/transpose_i16.c: Regenerated.\n        * generated/matmul_l16.c: Regenerated.\n        * generated/any_l1.c: Regenerated.\n        * generated/minval_r16.c: Regenerated.\n        * generated/shape_i16.c: Regenerated.\n        * generated/in_pack_c4.c: Regenerated.\n        * generated/minloc1_8_r4.c: Regenerated.\n        * generated/iany_i1.c: Regenerated.\n        * generated/matmul_i16.c: Regenerated.\n        * generated/maxloc0_16_r4.c: Regenerated.\n        * generated/spread_c8.c: Regenerated.\n        * generated/product_i8.c: Regenerated.\n        * generated/minloc1_8_i4.c: Regenerated.\n        * generated/product_i4.c: Regenerated.\n        * generated/minval_i16.c: Regenerated.\n        * generated/pack_r8.c: Regenerated.\n        * generated/matmul_r10.c: Regenerated.\n        * generated/shape_i8.c: Regenerated.\n        * generated/eoshift1_4.c: Regenerated.\n        * generated/minloc1_16_i4.c: Regenerated.\n        * generated/transpose_r16.c: Regenerated.\n        * generated/spread_c16.c: Regenerated.\n        * generated/maxloc0_8_i16.c: Regenerated.\n        * generated/minval_i1.c: Regenerated.\n        * generated/sum_i4.c: Regenerated.\n        * generated/in_pack_r16.c: Regenerated.\n        * generated/iall_i16.c: Regenerated.\n        * generated/minloc0_8_r10.c: Regenerated.\n        * generated/maxloc0_8_i8.c: Regenerated.\n        * generated/transpose_i4.c: Regenerated.\n        * generated/maxloc0_4_i2.c: Regenerated.\n        * generated/iall_i2.c: Regenerated.\n        * generated/maxloc0_8_r4.c: Regenerated.\n        * generated/minloc0_4_r16.c: Regenerated.\n        * generated/minloc1_4_r8.c: Regenerated.\n        * generated/minloc0_4_i8.c: Regenerated.\n        * generated/minval_i4.c: Regenerated.\n        * generated/minloc1_8_i8.c: Regenerated.\n        * generated/in_pack_i16.c: Regenerated.\n        * generated/spread_i4.c: Regenerated.\n        * generated/cshift0_c4.c: Regenerated.\n        * generated/minloc0_4_i16.c: Regenerated.\n        * generated/sum_r8.c: Regenerated.\n        * generated/minloc0_16_i16.c: Regenerated.\n        * generated/sum_i1.c: Regenerated.\n        * generated/all_l2.c: Regenerated.\n        * generated/sum_c4.c: Regenerated.\n        * generated/shape_i4.c: Regenerated.\n        * generated/maxval_i1.c: Regenerated.\n        * generated/norm2_r10.c: Regenerated.\n        * generated/unpack_c4.c: Regenerated.\n        * generated/maxloc0_16_i1.c: Regenerated.\n        * generated/all_l4.c: Regenerated.\n        * generated/maxloc1_16_i8.c: Regenerated.\n        * generated/sum_i16.c: Regenerated.\n        * generated/maxloc1_8_r16.c: Regenerated.\n        * generated/minloc1_4_r16.c: Regenerated.\n        * generated/maxloc1_16_r16.c: Regenerated.\n        * generated/transpose_i8.c: Regenerated.\n        * generated/minloc0_8_i2.c: Regenerated.\n        * generated/product_r16.c: Regenerated.\n        * generated/in_pack_c10.c: Regenerated.\n        * generated/maxloc0_4_r16.c: Regenerated.\n        * generated/pack_c4.c: Regenerated.\n        * generated/bessel_r16.c: Regenerated.\n        * generated/norm2_r16.c: Regenerated.\n        * generated/in_unpack_i8.c: Regenerated.\n        * generated/maxloc1_16_i4.c: Regenerated.\n        * generated/minloc1_4_i8.c: Regenerated.\n        * generated/eoshift3_4.c: Regenerated.\n        * generated/maxloc1_8_r10.c: Regenerated.\n        * generated/matmul_i8.c: Regenerated.\n        * generated/matmul_i4.c: Regenerated.\n        * generated/reshape_i16.c: Regenerated.\n        * generated/matmul_i2.c: Regenerated.\n        * generated/transpose_r8.c: Regenerated.\n        * generated/transpose_r4.c: Regenerated.\n        * generated/cshift1_16.c: Regenerated.\n        * generated/maxloc1_4_r10.c: Regenerated.\n        * generated/iparity_i4.c: Regenerated.\n        * generated/in_pack_i4.c: Regenerated.\n        * generated/maxloc0_8_i2.c: Regenerated.\n        * generated/unpack_r4.c: Regenerated.\n        * generated/count_4_l.c: Regenerated.\n        * generated/maxloc1_4_r4.c: Regenerated.\n        * generated/minloc0_8_i8.c: Regenerated.\n        * generated/any_l2.c: Regenerated.\n        * generated/minloc0_8_i4.c: Regenerated.\n        * generated/pack_i8.c: Regenerated.\n        * generated/count_2_l.c: Regenerated.\n        * generated/reshape_c8.c: Regenerated.\n        * generated/maxval_i2.c: Regenerated.\n        * generated/minloc0_4_r8.c: Regenerated.\n\nFrom-SVN: r185177", "tree": {"sha": "185023329e4ecc90e5a247a71df7042a7bd6bf19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/185023329e4ecc90e5a247a71df7042a7bd6bf19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21d1335b2a547a09188c62ca5f3b698920ea1438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d1335b2a547a09188c62ca5f3b698920ea1438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d1335b2a547a09188c62ca5f3b698920ea1438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d1335b2a547a09188c62ca5f3b698920ea1438/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30823ba60cafe3c1236e5ee89621f17e6dbae181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30823ba60cafe3c1236e5ee89621f17e6dbae181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30823ba60cafe3c1236e5ee89621f17e6dbae181"}], "stats": {"total": 7453, "additions": 3909, "deletions": 3544}, "files": [{"sha": "a5094358aaccc3f3ab1c87861d88bd4da8662f36", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,3 +1,376 @@\n+2012-03-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* libgfortran.h (descriptor_dimension, GFC_DIMENSION_LBOUND,\n+\tGFC_DIMENSION_EXTENT, GFC_DIMENSION_SET, GFC_DESCRIPTOR_DATA,\n+\tGFC_ARRAY_DESCRIPTOR): Rename _lbound to lower_bound and\n+\tdata to base_addr.\n+\t* intrinsics/cshift0.c (size0, cshift0): Handle data to\n+\tbase_addr rename.\n+\t* intrinsics/date_and_time.c (date_and_time, secnds, itime_i4,\n+\titime_i8, gmtime_i4, gmtime_i8, ltime_i4, ltime_i8): Ditto.\n+\t* intrinsics/dtime.c (dtime_sub): Ditto.\n+\t* intrinsics/eoshift0.c (eoshift0): Ditto.\n+\t* intrinsics/eoshift2.c (eoshift2): Ditto.\n+\t* intrinsics/etime.c (etime_sub): Ditto.\n+\t* intrinsics/iso_c_binding.c (c_f_pointer_u0): Ditto.\n+\t* intrinsics/move_alloc.c (move_alloc): Ditto.\n+\t* intrinsics/pack_generic.c (pack_internal, pack,\n+\tpack_s_internal): Ditto.\n+\t* intrinsics/random.c (arandom_r4, arandom_r8, arandom_r10,\n+\tarandom_r16, random_seed_i4, random_seed_i8): Ditto.\n+\t* intrinsics/reshape_generic.c (reshape_internal): Ditto.\n+\t* intrinsics/spread_generic.c (spread_internal,\n+\tspread_internal_scalar, spread, spread_scalar): Ditto.\n+\t* intrinsics/stat.c (stat_i4_sub_0, stat_i8_sub_0, fstat_i4_sub,\n+\tfstat_i8_sub): Ditto.\n+\t* intrinsics/transpose_generic.c (transpose_internal): Ditto.\n+\t* intrinsics/unpack_generic.c (unpack_bounds, unpack_internal,\n+\tunpack1, unpack0, unpack0_char4): Ditto.\n+\t* m4/bessel.m4 (bessel_jn_r'rtype_kind`, bessel_yn_r'rtype_kind`):\n+\tDitto.\n+\t* m4/cshift0.m4 (cshift0_'rtype_code`): Ditto.\n+\t* m4/cshift1.m4 (cshift1): Ditto.\n+\t* m4/eoshift1.m4 (eoshift1): Ditto.\n+\t* m4/eoshift3.m4 (eoshift3): Ditto.\n+\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code): Ditto.\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code): Ditto.\n+\t* m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code): Ditto.\n+\t* m4/in_pack.m4 (internal_pack_'rtype_ccode`): Ditto.\n+\t* m4/in_unpack.m4 (internal_unpack_'rtype_ccode`): Ditto.\n+\t* m4/matmul.m4 (matmul_'rtype_code`): Ditto.\n+\t* m4/matmull.m4 (matmul_'rtype_code`): Ditto.\n+\t* m4/pack.m4 (pack_'rtype_code`): Ditto.\n+\t* m4/reshape.m4 (reshape_'rtype_ccode`): Ditto.\n+\t* m4/shape.m4 (shape_'rtype_kind`): Ditto.\n+\t* m4/spread.m4 (spread_'rtype_code`): Ditto.\n+\t* m4/transpose.m4 (transpose_'rtype_code`): Ditto.\n+\t* m4/unpack.m4 (unpack0_'rtype_code`, unpack1_'rtype_code`): Ditto.\n+\t* runtime/bounds.c (count_0): Ditto.\n+\t* runtime/in_pack_generic.c (internal_pack): Ditto.\n+\t* runtime/in_unpack_generic.c (internal_unpack): Ditto.\n+\t* generated/cshift0_r4.c: Regenerated.\n+\t* generated/unpack_r8.c: Regenerated.\n+\t* generated/cshift0_c10.c: Regenerated.\n+\t* generated/in_unpack_i1.c: Regenerated.\n+\t* generated/eoshift1_16.c: Regenerated.\n+\t* generated/iany_i16.c: Regenerated.\n+\t* generated/reshape_i4.c: Regenerated.\n+\t* generated/parity_l16.c: Regenerated.\n+\t* generated/in_unpack_r16.c: Regenerated.\n+\t* generated/iparity_i1.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/bessel_r8.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/unpack_r16.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/unpack_i4.c: Regenerated.\n+\t* generated/in_pack_i1.c: Regenerated.\n+\t* generated/cshift0_i1.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/unpack_i2.c: Regenerated.\n+\t* generated/matmul_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/pack_c10.c: Regenerated.\n+\t* generated/in_unpack_c8.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/in_pack_c16.c: Regenerated.\n+\t* generated/parity_l1.c: Regenerated.\n+\t* generated/in_pack_i2.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/pack_r4.c: Regenerated.\n+\t* generated/matmul_r8.c: Regenerated.\n+\t* generated/pack_i1.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/cshift0_c8.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/in_pack_i8.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/matmul_l8.c: Regenerated.\n+\t* generated/spread_r10.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/reshape_r16.c: Regenerated.\n+\t* generated/cshift0_i16.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/iparity_i8.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/reshape_i8.c: Regenerated.\n+\t* generated/all_l16.c: Regenerated.\n+\t* generated/cshift1_8.c: Regenerated.\n+\t* generated/matmul_c10.c: Regenerated.\n+\t* generated/pack_r16.c: Regenerated.\n+\t* generated/transpose_r10.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/reshape_r8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/spread_c10.c: Regenerated.\n+\t* generated/reshape_r4.c: Regenerated.\n+\t* generated/in_unpack_i4.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/norm2_r8.c: Regenerated.\n+\t* generated/iany_i2.c: Regenerated.\n+\t* generated/eoshift3_8.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/cshift0_i8.c: Regenerated.\n+\t* generated/all_l1.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/spread_i16.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/spread_r16.c: Regenerated.\n+\t* generated/matmul_c8.c: Regenerated.\n+\t* generated/pack_r10.c: Regenerated.\n+\t* generated/reshape_r10.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/count_8_l.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/count_1_l.c: Regenerated.\n+\t* generated/unpack_c16.c: Regenerated.\n+\t* generated/any_l8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/in_unpack_r8.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/in_unpack_r4.c: Regenerated.\n+\t* generated/unpack_i1.c: Regenerated.\n+\t* generated/cshift0_r8.c: Regenerated.\n+\t* generated/spread_i2.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/eoshift3_16.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/parity_l2.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/in_unpack_r10.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/iparity_i2.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/iall_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/cshift0_i4.c: Regenerated.\n+\t* generated/in_unpack_c10.c: Regenerated.\n+\t* generated/unpack_c8.c: Regenerated.\n+\t* generated/transpose_c8.c: Regenerated.\n+\t* generated/in_unpack_c16.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/in_unpack_i16.c: Regenerated.\n+\t* generated/reshape_c16.c: Regenerated.\n+\t* generated/pack_i4.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/unpack_i8.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/pack_c16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/spread_r8.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/matmul_r4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/any_l4.c: Regenerated.\n+\t* generated/cshift0_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/in_pack_r10.c: Regenerated.\n+\t* generated/iall_i1.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/reshape_c10.c: Regenerated.\n+\t* generated/matmul_l4.c: Regenerated.\n+\t* generated/cshift0_c16.c: Regenerated.\n+\t* generated/spread_r4.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/in_unpack_c4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/unpack_i16.c: Regenerated.\n+\t* generated/norm2_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/in_pack_r4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/parity_l8.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/transpose_c10.c: Regenerated.\n+\t* generated/cshift0_r10.c: Regenerated.\n+\t* generated/cshift0_i2.c: Regenerated.\n+\t* generated/spread_c4.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/unpack_c10.c: Regenerated.\n+\t* generated/bessel_r4.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/transpose_c4.c: Regenerated.\n+\t* generated/in_pack_c8.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/iall_i8.c: Regenerated.\n+\t* generated/iany_i8.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/spread_i8.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/pack_i2.c: Regenerated.\n+\t* generated/unpack_r10.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/iany_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/in_pack_r8.c: Regenerated.\n+\t* generated/spread_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/pack_c8.c: Regenerated.\n+\t* generated/iparity_i16.c: Regenerated.\n+\t* generated/matmul_c16.c: Regenerated.\n+\t* generated/eoshift1_8.c: Regenerated.\n+\t* generated/any_l16.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/transpose_c16.c: Regenerated.\n+\t* generated/reshape_c4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/count_16_l.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/matmul_i1.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/cshift1_4.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/bessel_r10.c: Regenerated.\n+\t* generated/matmul_c4.c: Regenerated.\n+\t* generated/parity_l4.c: Regenerated.\n+\t* generated/in_unpack_i2.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/transpose_i16.c: Regenerated.\n+\t* generated/matmul_l16.c: Regenerated.\n+\t* generated/any_l1.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/shape_i16.c: Regenerated.\n+\t* generated/in_pack_c4.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/iany_i1.c: Regenerated.\n+\t* generated/matmul_i16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/spread_c8.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/pack_r8.c: Regenerated.\n+\t* generated/matmul_r10.c: Regenerated.\n+\t* generated/shape_i8.c: Regenerated.\n+\t* generated/eoshift1_4.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/transpose_r16.c: Regenerated.\n+\t* generated/spread_c16.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/in_pack_r16.c: Regenerated.\n+\t* generated/iall_i16.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/transpose_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/iall_i2.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/in_pack_i16.c: Regenerated.\n+\t* generated/spread_i4.c: Regenerated.\n+\t* generated/cshift0_c4.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/all_l2.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/shape_i4.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/norm2_r10.c: Regenerated.\n+\t* generated/unpack_c4.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/transpose_i8.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/in_pack_c10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/pack_c4.c: Regenerated.\n+\t* generated/bessel_r16.c: Regenerated.\n+\t* generated/norm2_r16.c: Regenerated.\n+\t* generated/in_unpack_i8.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/eoshift3_4.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/matmul_i8.c: Regenerated.\n+\t* generated/matmul_i4.c: Regenerated.\n+\t* generated/reshape_i16.c: Regenerated.\n+\t* generated/matmul_i2.c: Regenerated.\n+\t* generated/transpose_r8.c: Regenerated.\n+\t* generated/transpose_r4.c: Regenerated.\n+\t* generated/cshift1_16.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/iparity_i4.c: Regenerated.\n+\t* generated/in_pack_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/unpack_r4.c: Regenerated.\n+\t* generated/count_4_l.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/any_l2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/pack_i8.c: Regenerated.\n+\t* generated/count_2_l.c: Regenerated.\n+\t* generated/reshape_c8.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\n 2012-01-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR libgfortran/51899"}, {"sha": "541e72585169eba67594d2c52c3fc7ad0c5a81d3", "filename": "libgfortran/generated/all_l1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "8162ac1596ee362ec694a311164fbe91c477e81c", "filename": "libgfortran/generated/all_l16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "0e98cf64acb641eb93ad0906fc638ee491cca001", "filename": "libgfortran/generated/all_l2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "857175159a4f79fe35d27b045d1207690be255b7", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "9b9d16a884441d9319883131779713e46bdf96fb", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "e8b9cab99e847bc6dba4ffb49f705eb4962f091c", "filename": "libgfortran/generated/any_l1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "c6055886b4130a1fc861883d1ca91e800f71437b", "filename": "libgfortran/generated/any_l16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "6c4afeea01bebfed78979824127b13066478f9fb", "filename": "libgfortran/generated/any_l2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "b2c4cde3c3d15a2a760b54d35d27fa96a5c973d3", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "86fd28c1462e3cff743ee841423e359249b7db36", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "7d11614b0391d86f9a3f9af5ed8c677b6d943016", "filename": "libgfortran/generated/bessel_r10.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the BESSEL_JN and BESSEL_YN transformational\n    function using a recurrence algorithm.\n-   Copyright 2010 Free Software Foundation, Inc.\n+   Copyright 2010, 2012 Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n@@ -51,11 +51,11 @@ bessel_jn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2, GFC_REAL_10 x\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n       ret->offset = 0;\n     }\n \n@@ -72,21 +72,20 @@ bessel_jn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2, GFC_REAL_10 x\n \n   if (unlikely (x == 0))\n     {\n-      ret->data[0] = 1;\n+      ret->base_addr[0] = 1;\n       for (i = 1; i <= n2-n1; i++)\n-        ret->data[i*stride] = 0;\n+        ret->base_addr[i*stride] = 0;\n       return;\n     }\n \n-  ret->data = ret->data;\n   last1 = MATHFUNC(jn) (n2, x);\n-  ret->data[(n2-n1)*stride] = last1;\n+  ret->base_addr[(n2-n1)*stride] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(jn) (n2 - 1, x);\n-  ret->data[(n2-n1-1)*stride] = last2;\n+  ret->base_addr[(n2-n1-1)*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -95,9 +94,9 @@ bessel_jn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2, GFC_REAL_10 x\n \n   for (i = n2-n1-2; i >= 0; i--)\n     {\n-      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      ret->base_addr[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n       last1 = last2;\n-      last2 = ret->data[i*stride];\n+      last2 = ret->base_addr[i*stride];\n     }\n }\n \n@@ -119,11 +118,11 @@ bessel_yn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2,\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n       ret->offset = 0;\n     }\n \n@@ -142,22 +141,22 @@ bessel_yn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2,\n     {\n       for (i = 0; i <= n2-n1; i++)\n #if defined(GFC_REAL_10_INFINITY)\n-        ret->data[i*stride] = -GFC_REAL_10_INFINITY;\n+        ret->base_addr[i*stride] = -GFC_REAL_10_INFINITY;\n #else\n-        ret->data[i*stride] = -GFC_REAL_10_HUGE;\n+        ret->base_addr[i*stride] = -GFC_REAL_10_HUGE;\n #endif\n       return;\n     }\n \n-  ret->data = ret->data;\n+  ret->base_addr = ret->base_addr;\n   last1 = MATHFUNC(yn) (n1, x);\n-  ret->data[0] = last1;\n+  ret->base_addr[0] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(yn) (n1 + 1, x);\n-  ret->data[1*stride] = last2;\n+  ret->base_addr[1*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -169,14 +168,14 @@ bessel_yn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2,\n #if defined(GFC_REAL_10_INFINITY)\n       if (unlikely (last2 == -GFC_REAL_10_INFINITY))\n \t{\n-\t  ret->data[i*stride] = -GFC_REAL_10_INFINITY;\n+\t  ret->base_addr[i*stride] = -GFC_REAL_10_INFINITY;\n \t}\n       else\n #endif\n \t{\n-\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  ret->base_addr[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n \t  last1 = last2;\n-\t  last2 = ret->data[i*stride];\n+\t  last2 = ret->base_addr[i*stride];\n \t}\n     }\n }"}, {"sha": "ae23dbced72b9de9b35ed38abc7c1586778fdc92", "filename": "libgfortran/generated/bessel_r16.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the BESSEL_JN and BESSEL_YN transformational\n    function using a recurrence algorithm.\n-   Copyright 2010 Free Software Foundation, Inc.\n+   Copyright 2010, 2012 Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n@@ -55,11 +55,11 @@ bessel_jn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2, GFC_REAL_16 x\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n       ret->offset = 0;\n     }\n \n@@ -76,21 +76,20 @@ bessel_jn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2, GFC_REAL_16 x\n \n   if (unlikely (x == 0))\n     {\n-      ret->data[0] = 1;\n+      ret->base_addr[0] = 1;\n       for (i = 1; i <= n2-n1; i++)\n-        ret->data[i*stride] = 0;\n+        ret->base_addr[i*stride] = 0;\n       return;\n     }\n \n-  ret->data = ret->data;\n   last1 = MATHFUNC(jn) (n2, x);\n-  ret->data[(n2-n1)*stride] = last1;\n+  ret->base_addr[(n2-n1)*stride] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(jn) (n2 - 1, x);\n-  ret->data[(n2-n1-1)*stride] = last2;\n+  ret->base_addr[(n2-n1-1)*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -99,9 +98,9 @@ bessel_jn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2, GFC_REAL_16 x\n \n   for (i = n2-n1-2; i >= 0; i--)\n     {\n-      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      ret->base_addr[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n       last1 = last2;\n-      last2 = ret->data[i*stride];\n+      last2 = ret->base_addr[i*stride];\n     }\n }\n \n@@ -123,11 +122,11 @@ bessel_yn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2,\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n       ret->offset = 0;\n     }\n \n@@ -146,22 +145,22 @@ bessel_yn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2,\n     {\n       for (i = 0; i <= n2-n1; i++)\n #if defined(GFC_REAL_16_INFINITY)\n-        ret->data[i*stride] = -GFC_REAL_16_INFINITY;\n+        ret->base_addr[i*stride] = -GFC_REAL_16_INFINITY;\n #else\n-        ret->data[i*stride] = -GFC_REAL_16_HUGE;\n+        ret->base_addr[i*stride] = -GFC_REAL_16_HUGE;\n #endif\n       return;\n     }\n \n-  ret->data = ret->data;\n+  ret->base_addr = ret->base_addr;\n   last1 = MATHFUNC(yn) (n1, x);\n-  ret->data[0] = last1;\n+  ret->base_addr[0] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(yn) (n1 + 1, x);\n-  ret->data[1*stride] = last2;\n+  ret->base_addr[1*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -173,14 +172,14 @@ bessel_yn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2,\n #if defined(GFC_REAL_16_INFINITY)\n       if (unlikely (last2 == -GFC_REAL_16_INFINITY))\n \t{\n-\t  ret->data[i*stride] = -GFC_REAL_16_INFINITY;\n+\t  ret->base_addr[i*stride] = -GFC_REAL_16_INFINITY;\n \t}\n       else\n #endif\n \t{\n-\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  ret->base_addr[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n \t  last1 = last2;\n-\t  last2 = ret->data[i*stride];\n+\t  last2 = ret->base_addr[i*stride];\n \t}\n     }\n }"}, {"sha": "d3b05907082b4feb8e12a5b9be85de6fa58180da", "filename": "libgfortran/generated/bessel_r4.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the BESSEL_JN and BESSEL_YN transformational\n    function using a recurrence algorithm.\n-   Copyright 2010 Free Software Foundation, Inc.\n+   Copyright 2010, 2012 Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n@@ -51,11 +51,11 @@ bessel_jn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2, GFC_REAL_4 x)\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n       ret->offset = 0;\n     }\n \n@@ -72,21 +72,20 @@ bessel_jn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2, GFC_REAL_4 x)\n \n   if (unlikely (x == 0))\n     {\n-      ret->data[0] = 1;\n+      ret->base_addr[0] = 1;\n       for (i = 1; i <= n2-n1; i++)\n-        ret->data[i*stride] = 0;\n+        ret->base_addr[i*stride] = 0;\n       return;\n     }\n \n-  ret->data = ret->data;\n   last1 = MATHFUNC(jn) (n2, x);\n-  ret->data[(n2-n1)*stride] = last1;\n+  ret->base_addr[(n2-n1)*stride] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(jn) (n2 - 1, x);\n-  ret->data[(n2-n1-1)*stride] = last2;\n+  ret->base_addr[(n2-n1-1)*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -95,9 +94,9 @@ bessel_jn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2, GFC_REAL_4 x)\n \n   for (i = n2-n1-2; i >= 0; i--)\n     {\n-      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      ret->base_addr[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n       last1 = last2;\n-      last2 = ret->data[i*stride];\n+      last2 = ret->base_addr[i*stride];\n     }\n }\n \n@@ -119,11 +118,11 @@ bessel_yn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2,\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n       ret->offset = 0;\n     }\n \n@@ -142,22 +141,22 @@ bessel_yn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2,\n     {\n       for (i = 0; i <= n2-n1; i++)\n #if defined(GFC_REAL_4_INFINITY)\n-        ret->data[i*stride] = -GFC_REAL_4_INFINITY;\n+        ret->base_addr[i*stride] = -GFC_REAL_4_INFINITY;\n #else\n-        ret->data[i*stride] = -GFC_REAL_4_HUGE;\n+        ret->base_addr[i*stride] = -GFC_REAL_4_HUGE;\n #endif\n       return;\n     }\n \n-  ret->data = ret->data;\n+  ret->base_addr = ret->base_addr;\n   last1 = MATHFUNC(yn) (n1, x);\n-  ret->data[0] = last1;\n+  ret->base_addr[0] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(yn) (n1 + 1, x);\n-  ret->data[1*stride] = last2;\n+  ret->base_addr[1*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -169,14 +168,14 @@ bessel_yn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2,\n #if defined(GFC_REAL_4_INFINITY)\n       if (unlikely (last2 == -GFC_REAL_4_INFINITY))\n \t{\n-\t  ret->data[i*stride] = -GFC_REAL_4_INFINITY;\n+\t  ret->base_addr[i*stride] = -GFC_REAL_4_INFINITY;\n \t}\n       else\n #endif\n \t{\n-\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  ret->base_addr[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n \t  last1 = last2;\n-\t  last2 = ret->data[i*stride];\n+\t  last2 = ret->base_addr[i*stride];\n \t}\n     }\n }"}, {"sha": "b48c04bfcc34f80fecb122ae09b39ece7f16a1f3", "filename": "libgfortran/generated/bessel_r8.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fbessel_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the BESSEL_JN and BESSEL_YN transformational\n    function using a recurrence algorithm.\n-   Copyright 2010 Free Software Foundation, Inc.\n+   Copyright 2010, 2012 Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n@@ -51,11 +51,11 @@ bessel_jn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2, GFC_REAL_8 x)\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n       ret->offset = 0;\n     }\n \n@@ -72,21 +72,20 @@ bessel_jn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2, GFC_REAL_8 x)\n \n   if (unlikely (x == 0))\n     {\n-      ret->data[0] = 1;\n+      ret->base_addr[0] = 1;\n       for (i = 1; i <= n2-n1; i++)\n-        ret->data[i*stride] = 0;\n+        ret->base_addr[i*stride] = 0;\n       return;\n     }\n \n-  ret->data = ret->data;\n   last1 = MATHFUNC(jn) (n2, x);\n-  ret->data[(n2-n1)*stride] = last1;\n+  ret->base_addr[(n2-n1)*stride] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(jn) (n2 - 1, x);\n-  ret->data[(n2-n1-1)*stride] = last2;\n+  ret->base_addr[(n2-n1-1)*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -95,9 +94,9 @@ bessel_jn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2, GFC_REAL_8 x)\n \n   for (i = n2-n1-2; i >= 0; i--)\n     {\n-      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      ret->base_addr[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n       last1 = last2;\n-      last2 = ret->data[i*stride];\n+      last2 = ret->base_addr[i*stride];\n     }\n }\n \n@@ -119,11 +118,11 @@ bessel_yn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2,\n \n   stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       size_t size = n2 < n1 ? 0 : n2-n1+1; \n       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n-      ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n+      ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n       ret->offset = 0;\n     }\n \n@@ -142,22 +141,22 @@ bessel_yn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2,\n     {\n       for (i = 0; i <= n2-n1; i++)\n #if defined(GFC_REAL_8_INFINITY)\n-        ret->data[i*stride] = -GFC_REAL_8_INFINITY;\n+        ret->base_addr[i*stride] = -GFC_REAL_8_INFINITY;\n #else\n-        ret->data[i*stride] = -GFC_REAL_8_HUGE;\n+        ret->base_addr[i*stride] = -GFC_REAL_8_HUGE;\n #endif\n       return;\n     }\n \n-  ret->data = ret->data;\n+  ret->base_addr = ret->base_addr;\n   last1 = MATHFUNC(yn) (n1, x);\n-  ret->data[0] = last1;\n+  ret->base_addr[0] = last1;\n \n   if (n1 == n2)\n     return;\n \n   last2 = MATHFUNC(yn) (n1 + 1, x);\n-  ret->data[1*stride] = last2;\n+  ret->base_addr[1*stride] = last2;\n \n   if (n1 + 1 == n2)\n     return;\n@@ -169,14 +168,14 @@ bessel_yn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2,\n #if defined(GFC_REAL_8_INFINITY)\n       if (unlikely (last2 == -GFC_REAL_8_INFINITY))\n \t{\n-\t  ret->data[i*stride] = -GFC_REAL_8_INFINITY;\n+\t  ret->base_addr[i*stride] = -GFC_REAL_8_INFINITY;\n \t}\n       else\n #endif\n \t{\n-\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  ret->base_addr[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n \t  last1 = last2;\n-\t  last2 = ret->data[i*stride];\n+\t  last2 = ret->base_addr[i*stride];\n \t}\n     }\n }"}, {"sha": "652244004fe15679aaa752ff35ab610b5eec2f2f", "filename": "libgfortran/generated/count_16_l.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_16_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_16_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "5b7776eb9b39933aa0856a7dbac9fa72f477692e", "filename": "libgfortran/generated/count_1_l.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_1_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_1_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_1_l.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "8a104d1bdfcb3b95b299a7e716c2651078178f96", "filename": "libgfortran/generated/count_2_l.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_2_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_2_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_2_l.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "0edca41c49255b94b93c92bfd13c13b30bb61cc5", "filename": "libgfortran/generated/count_4_l.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_4_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_4_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "e3d95dca825bc71dc771b004ba247764806f4917", "filename": "libgfortran/generated/count_8_l.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_8_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcount_8_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -111,7 +111,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -145,7 +145,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -159,7 +159,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "43e173bf417d65600b88a6a5b80d76a00d92bd4e", "filename": "libgfortran/generated/cshift0_c10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "f1f2539bc77190305e702bd45cdf93bb734219b3", "filename": "libgfortran/generated/cshift0_c16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "bf8554e1abefddbfdd7fb0284a52f55b0150a938", "filename": "libgfortran/generated/cshift0_c4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "e3fd5b66e22be2583934cca01280935fd1cf02c5", "filename": "libgfortran/generated/cshift0_c8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "f2315de95fa632a06f8c3343a4848d134046b220", "filename": "libgfortran/generated/cshift0_i1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "7566042c8fb6959ff469c119ba123abe780f9a73", "filename": "libgfortran/generated/cshift0_i16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "4a8154c4c55ceb5022110432fb638d45272eeee3", "filename": "libgfortran/generated/cshift0_i2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "7d25b7b0200d5c380f49959b120e71dd98be0615", "filename": "libgfortran/generated/cshift0_i4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "2f565caeedef757a78ed89f64e604d8bb05a7b9a", "filename": "libgfortran/generated/cshift0_i8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "b7f21caffb24a6fba042f58417924f625984ec71", "filename": "libgfortran/generated/cshift0_r10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "320b705f3826b52adf591f1b461655ca6ee184b1", "filename": "libgfortran/generated/cshift0_r16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "93ccf529b6d26b447bf1bfcb39b9cfc631490475", "filename": "libgfortran/generated/cshift0_r4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "a3f747993c9c0f89262fc90e3b98db0fd0f4231d", "filename": "libgfortran/generated/cshift0_r8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift0_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for cshift functions.\n-   Copyright 2008, 2009 Free Software Foundation, Inc.\n+   Copyright 2008, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -94,8 +94,8 @@ cshift0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array, ptrdiff_t shift,\n   dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n \n   shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n   if (shift < 0)"}, {"sha": "41cc1ea81f530fc684cece3de3759258fa380b08", "filename": "libgfortran/generated/cshift1_16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the CSHIFT intrinsic\n-   Copyright 2003, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Feng Wang <wf_cs@yahoo.com>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -76,11 +76,11 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   arraysize = size0 ((array_t *)array);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -156,9 +156,9 @@ cshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "9652222bda067d204e652491bf90ed44f6dd788f", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the CSHIFT intrinsic\n-   Copyright 2003, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Feng Wang <wf_cs@yahoo.com>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -76,11 +76,11 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   arraysize = size0 ((array_t *)array);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -156,9 +156,9 @@ cshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "8ccd63b52089e1c8bf97a986fcaed81704540507", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the CSHIFT intrinsic\n-   Copyright 2003, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Feng Wang <wf_cs@yahoo.com>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -76,11 +76,11 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   arraysize = size0 ((array_t *)array);\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -156,9 +156,9 @@ cshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "2de9208cf9da72a6ff48f88011d99adec5084736", "filename": "libgfortran/generated/eoshift1_16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -84,7 +84,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   count[0] = 0;\n \n   arraysize = size0 ((array_t *) array);\n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n@@ -106,7 +106,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -159,9 +159,9 @@ eoshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "8a9f1aaafbf8c14301a541b10a8422d883d21334", "filename": "libgfortran/generated/eoshift1_4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -84,7 +84,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   count[0] = 0;\n \n   arraysize = size0 ((array_t *) array);\n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n@@ -106,7 +106,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -159,9 +159,9 @@ eoshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "136f5464c1742feb9395601f95e5fb6a954a4d5f", "filename": "libgfortran/generated/eoshift1_8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -84,7 +84,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   count[0] = 0;\n \n   arraysize = size0 ((array_t *) array);\n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n@@ -106,7 +106,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -159,9 +159,9 @@ eoshift1 (gfc_array_char * const restrict ret,\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n \n   while (rptr)\n     {"}, {"sha": "d363d90ae0c54b1d18bebd157ee51ae1cf443f2e", "filename": "libgfortran/generated/eoshift3_16.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -85,11 +85,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   else\n     which = 0;\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -108,7 +108,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -170,11 +170,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n   bstride0 = bstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n   if (bound)\n-    bptr = bound->data;\n+    bptr = bound->base_addr;\n   else\n     bptr = NULL;\n "}, {"sha": "1b623c28f51c852c1082a0b5a8b6e830226ee89a", "filename": "libgfortran/generated/eoshift3_4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -85,11 +85,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   else\n     which = 0;\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -108,7 +108,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -170,11 +170,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n   bstride0 = bstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n   if (bound)\n-    bptr = bound->data;\n+    bptr = bound->base_addr;\n   else\n     bptr = NULL;\n "}, {"sha": "2af1ccb9cf561fd603703e99e02cb78ec8388bd3", "filename": "libgfortran/generated/eoshift3_8.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Feoshift3_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the EOSHIFT intrinsic\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -85,11 +85,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   else\n     which = 0;\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -108,7 +108,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \n         }\n       /* internal_malloc_size allocates a single byte for zero size.  */\n-      ret->data = internal_malloc_size (size * arraysize);\n+      ret->base_addr = internal_malloc_size (size * arraysize);\n \n     }\n   else if (unlikely (compile_options.bounds_check))\n@@ -170,11 +170,11 @@ eoshift3 (gfc_array_char * const restrict ret,\n   sstride0 = sstride[0];\n   hstride0 = hstride[0];\n   bstride0 = bstride[0];\n-  rptr = ret->data;\n-  sptr = array->data;\n-  hptr = h->data;\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n   if (bound)\n-    bptr = bound->data;\n+    bptr = bound->base_addr;\n   else\n     bptr = NULL;\n "}, {"sha": "d60f7f358ba854d2b824c514408d1e292572f501", "filename": "libgfortran/generated/iall_i1.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siall_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siall_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siall_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "88be6a8bad89ad7f16dacfc02c33e7a5d75c4c1b", "filename": "libgfortran/generated/iall_i16.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siall_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siall_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siall_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "14fa83b1c60257ee95454872fe81411e3161513e", "filename": "libgfortran/generated/iall_i2.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siall_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siall_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siall_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ce5e185d6905cc69a5627c2edbef5139e5b6b621", "filename": "libgfortran/generated/iall_i4.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siall_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siall_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siall_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "fee269a8cfed01cc50b938e15dd5d952528c49c2", "filename": "libgfortran/generated/iall_i8.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiall_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siall_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siall_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siall_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "f1b0aebe936c0a16491d7957f5a322fb82e2b6e2", "filename": "libgfortran/generated/iany_i1.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siany_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siany_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siany_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "511e36989e4938180e18dd3d7a43feb73efb23b8", "filename": "libgfortran/generated/iany_i16.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siany_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siany_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siany_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "b52f5512cef96bf1d2dd3346e12f54ad7faebd37", "filename": "libgfortran/generated/iany_i2.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siany_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siany_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siany_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "a0949e17ec98e1d45e068e59a1a03cea3dab13fc", "filename": "libgfortran/generated/iany_i4.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siany_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siany_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siany_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "e365f5f97b0ca8b82cbb902a0f35427ad8d3929e", "filename": "libgfortran/generated/iany_i8.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiany_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siany_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siany_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siany_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "1d6b0db637bc7aa00a601e28e32c4b533b95e6ea", "filename": "libgfortran/generated/in_pack_c10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_c10 (gfc_array_c10 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_COMPLEX_10 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_10));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "a627094ee43c26086ad0117366a50c67eed43670", "filename": "libgfortran/generated/in_pack_c16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_c16 (gfc_array_c16 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_COMPLEX_16 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_16));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "833d7e8d515c40692d70679e11155371f6a86012", "filename": "libgfortran/generated/in_pack_c4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_c4 (gfc_array_c4 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_COMPLEX_4 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_4));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "d86ce9f1b67b08d90acb752eba30d92b737bdd20", "filename": "libgfortran/generated/in_pack_c8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_c8 (gfc_array_c8 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_COMPLEX_8 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_8));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "2b582a5df6fd864b447c47321db8970c5f80199e", "filename": "libgfortran/generated/in_pack_i1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_1 (gfc_array_i1 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_INTEGER_1 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_1));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "294e3ca47ffc82ea925abd483ca6b72f57e8cb20", "filename": "libgfortran/generated/in_pack_i16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_16 (gfc_array_i16 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_INTEGER_16 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_16));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "6a95af3b5168f24f2076ddd4c8d08ee238b1ac2b", "filename": "libgfortran/generated/in_pack_i2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_2 (gfc_array_i2 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_INTEGER_2 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_2));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "4a5a8637172c62e65fa1beda53749310adecd375", "filename": "libgfortran/generated/in_pack_i4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_4 (gfc_array_i4 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_INTEGER_4 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_4));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "cb7e785f06009f9bb6b4604fd26233a520301b4f", "filename": "libgfortran/generated/in_pack_i8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_8 (gfc_array_i8 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_INTEGER_8 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_8));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "b479001562fa90b0765338d935c88122f4090915", "filename": "libgfortran/generated/in_pack_r10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_r10 (gfc_array_r10 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_REAL_10 *)internal_malloc_size (ssize * sizeof (GFC_REAL_10));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "f16fd2fea66b130812abf3974d050f6dd82f5c7e", "filename": "libgfortran/generated/in_pack_r16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_r16 (gfc_array_r16 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_REAL_16 *)internal_malloc_size (ssize * sizeof (GFC_REAL_16));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "e5b09a70f1bed76434a23b8326fc5acd6654d333", "filename": "libgfortran/generated/in_pack_r4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_r4 (gfc_array_r4 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_REAL_4 *)internal_malloc_size (ssize * sizeof (GFC_REAL_4));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "12670d277240a72879c2e34e3f21c1735b4595e8", "filename": "libgfortran/generated/in_pack_r8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_pack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -73,12 +73,12 @@ internal_pack_r8 (gfc_array_r8 * source)\n     }\n \n   if (packed)\n-    return source->data;\n+    return source->base_addr;\n \n   /* Allocate storage for the destination.  */\n   destptr = (GFC_REAL_8 *)internal_malloc_size (ssize * sizeof (GFC_REAL_8));\n   dest = destptr;\n-  src = source->data;\n+  src = source->base_addr;\n   stride0 = stride[0];\n \n "}, {"sha": "1afa8761ba9d6d43fab769b6cb13e406223f4726", "filename": "libgfortran/generated/in_unpack_c10.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_c10 (gfc_array_c10 * d, const GFC_COMPLEX_10 * src)\n   GFC_COMPLEX_10 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "11c6127ea0eaf6f84bcc283d716724d95a911968", "filename": "libgfortran/generated/in_unpack_c16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_c16 (gfc_array_c16 * d, const GFC_COMPLEX_16 * src)\n   GFC_COMPLEX_16 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "558f3b145e9e3083c25bc0a212f67ccd99cd11de", "filename": "libgfortran/generated/in_unpack_c4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_c4 (gfc_array_c4 * d, const GFC_COMPLEX_4 * src)\n   GFC_COMPLEX_4 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "72b00d84fd83e560d7bf14a5f1aa57cba9071769", "filename": "libgfortran/generated/in_unpack_c8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_c8 (gfc_array_c8 * d, const GFC_COMPLEX_8 * src)\n   GFC_COMPLEX_8 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "d045c92e9204747c51080adf40be5a67a5a12f3a", "filename": "libgfortran/generated/in_unpack_i1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_1 (gfc_array_i1 * d, const GFC_INTEGER_1 * src)\n   GFC_INTEGER_1 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "612e7d83fd8fb5b59b3a57fee58cf8a98adc82fc", "filename": "libgfortran/generated/in_unpack_i16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_16 (gfc_array_i16 * d, const GFC_INTEGER_16 * src)\n   GFC_INTEGER_16 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "e9a08071546d8359af991539371f55d84b224442", "filename": "libgfortran/generated/in_unpack_i2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_2 (gfc_array_i2 * d, const GFC_INTEGER_2 * src)\n   GFC_INTEGER_2 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "6fc836b7c16fad3d7a637d2d1589bdfdea90e90b", "filename": "libgfortran/generated/in_unpack_i4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_4 (gfc_array_i4 * d, const GFC_INTEGER_4 * src)\n   GFC_INTEGER_4 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "d7bd81182444d196dd8fcc74560fffccc0a9ac9f", "filename": "libgfortran/generated/in_unpack_i8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_8 (gfc_array_i8 * d, const GFC_INTEGER_8 * src)\n   GFC_INTEGER_8 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "afc8e2d9b13d8767b43a27c33f1d96579510d96c", "filename": "libgfortran/generated/in_unpack_r10.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_r10 (gfc_array_r10 * d, const GFC_REAL_10 * src)\n   GFC_REAL_10 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "57fcb176292efa60ba579bcc0a3aae52b61aaf2c", "filename": "libgfortran/generated/in_unpack_r16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_r16 (gfc_array_r16 * d, const GFC_REAL_16 * src)\n   GFC_REAL_16 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "9e1d69fba163ac53a862c8bfcc36f1056b90a11c", "filename": "libgfortran/generated/in_unpack_r4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_r4 (gfc_array_r4 * d, const GFC_REAL_4 * src)\n   GFC_REAL_4 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "4a5ccb2429b0720380bee87c23d8f4873f463f2b", "filename": "libgfortran/generated/in_unpack_r8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Helper function for repacking arrays.\n-   Copyright 2003, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2003, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,7 @@ internal_unpack_r8 (gfc_array_r8 * d, const GFC_REAL_8 * src)\n   GFC_REAL_8 * restrict dest;\n   int n;\n \n-  dest = d->data;\n+  dest = d->base_addr;\n   if (src == dest || !src)\n     return;\n "}, {"sha": "5fcb29d1af752b57091aa4122f621ed8c4753002", "filename": "libgfortran/generated/iparity_i1.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siparity_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siparity_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siparity_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "aef94588875a02a83c57c9263d6d3447b569c405", "filename": "libgfortran/generated/iparity_i16.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siparity_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siparity_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siparity_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "22f95e360dda39bad29d4733d8a68308134fb8f6", "filename": "libgfortran/generated/iparity_i2.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siparity_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siparity_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siparity_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "58b18b86a0ee41512ac35df644e51bc4dabf8789", "filename": "libgfortran/generated/iparity_i4.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siparity_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siparity_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siparity_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "78de1c429e287b7b43efe95545693985bf95557d", "filename": "libgfortran/generated/iparity_i8.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fiparity_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,15 +100,14 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -131,8 +130,8 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -222,7 +221,7 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -258,7 +257,7 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -286,7 +285,7 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -311,8 +310,8 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -418,7 +417,7 @@ siparity_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -446,7 +445,7 @@ siparity_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -478,7 +477,7 @@ siparity_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "3496a83eea09e96cc1b66744e70ffef6d0ed70a3", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "0140dd311cdc527051733dd64f77af88dab7df91", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "fd8ce9f1794e84ae3f60815e48b5f615913e60a2", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "e71b5fb58ade32b18622110d5911efc7faef56ba", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "7525ea77ab3e6ecf3d0d24c6efdf8f11367edf3b", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_INTEGER_1) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "19b6995a3fbb1069a89b91e627d683d43a8d2549", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_INTEGER_16) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "73935067a16d20da23fdab83aeabe6416ff4e3c5", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_INTEGER_2) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "2e9e016816a51b81b46f523a020ec8c8d707dcd2", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_INTEGER_4) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "6c6c655625adc37288c7bd75423d159b03aa6221", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_INTEGER_8) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "1ae8f7a9cb679960b41eea538044019a0fb3c247", "filename": "libgfortran/generated/matmul_l16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -65,7 +65,7 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -87,7 +87,7 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_LOGICAL_16) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -133,7 +133,7 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n \t  }\n       }\n \n-  abase = a->data;\n+  abase = a->base_addr;\n   a_kind = GFC_DESCRIPTOR_SIZE (a);\n \n   if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n@@ -145,7 +145,7 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  bbase = b->data;\n+  bbase = b->base_addr;\n   b_kind = GFC_DESCRIPTOR_SIZE (b);\n \n   if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n@@ -157,7 +157,7 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)"}, {"sha": "dfe3369c0a752402f5539fed48ce962f7570df6d", "filename": "libgfortran/generated/matmul_l4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -65,7 +65,7 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -87,7 +87,7 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_LOGICAL_4) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -133,7 +133,7 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n \t  }\n       }\n \n-  abase = a->data;\n+  abase = a->base_addr;\n   a_kind = GFC_DESCRIPTOR_SIZE (a);\n \n   if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n@@ -145,7 +145,7 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  bbase = b->data;\n+  bbase = b->base_addr;\n   b_kind = GFC_DESCRIPTOR_SIZE (b);\n \n   if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n@@ -157,7 +157,7 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)"}, {"sha": "258a953d023f5fc888d8faedac894c4d3d0248ef", "filename": "libgfortran/generated/matmul_l8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -65,7 +65,7 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -87,7 +87,7 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_LOGICAL_8) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -133,7 +133,7 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n \t  }\n       }\n \n-  abase = a->data;\n+  abase = a->base_addr;\n   a_kind = GFC_DESCRIPTOR_SIZE (a);\n \n   if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n@@ -145,7 +145,7 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  bbase = b->data;\n+  bbase = b->base_addr;\n   b_kind = GFC_DESCRIPTOR_SIZE (b);\n \n   if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n@@ -157,7 +157,7 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     internal_error (NULL, \"Funny sized logical array\");\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)"}, {"sha": "79a577129515fbf6ec51442d15f8bc781255075c", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_REAL_10) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "87bc587acee461a3dd24ace143c12b0899fb3c0c", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_REAL_16) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "4f72b6a4c80e675f60232c8ac4cfd10aa62a4b65", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_REAL_4) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "422a1f03ea3c0473d4819bf648749222aebcc4cc", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the MATMUL intrinsic\n-   Copyright 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -101,7 +101,7 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n      dimensioned [count, 1], so ycount=1.\n   */\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n@@ -123,7 +123,7 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n-      retarray->data\n+      retarray->base_addr\n \t= internal_malloc_size (sizeof (GFC_REAL_8) * size0 ((array_t *) retarray));\n       retarray->offset = 0;\n     }\n@@ -226,9 +226,9 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n       ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n-  abase = a->data;\n-  bbase = b->data;\n-  dest = retarray->data;\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n \n \n   /* Now that everything is set up, we're performing the multiplication"}, {"sha": "fbac3ad12ff9737115a63f6c2074a3aaaedf81a7", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "e15ebf26e53b2d1bca6969f94bf223616c60a94a", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "90b2b3a8ff7d3a8f50c17ab6b192eef4d1b227bb", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "dc75d83e78c1e894ab38384b249b30d64bbe0d7b", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "43879c7ddcdce0fcaa5c721aa25b4a0b3b306f29", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "3e3bcb5ffdde3a73bd05716b512e8f3ce9788077", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "cec39633b65eca6bdd4c2ff9e7c36285c5facb8e", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "985dcd6bdf69abaa6b2b7d69c951466f2ab344d2", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "7f385d713f614f90b77f724be2d1c65847ab41cf", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "6d7cf6188b9d5578d97fae4c57da635148a2ae86", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "0d8bf75667ff279bccace6407545c6482520bffe", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "b0c05c80a2d539eb4153d2b3b976f45f7c4fa746", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "9be7099176440a69297a2716c1042a02ffaf254a", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "cb337239b2c2fcc78bc4e96d03fa861813128962", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "48abb630b9c4bb3db452b515bae9e9792b0a37d4", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "3fae48df1be34679fe9c286a4c52bd3bbda19726", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d2a985d0a27fa1ff5718d0cee10003b8829bb7f3", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "6f57fca5aea10bbfa6871fcc12613e2104d94bf4", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "07815cf551837762d82bd9315ddd04350a00f708", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "dc5c57503e0cdb30683a08539a776d41d4358097", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "f01ec69905e2722d27bc55ed55294b1b92fef6e6", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "13f32e02820ba1bc875aea7f984cb7f5a9f67c45", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "066cedf61217793e92956fd1b1f635b70c5bcb38", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "f34984dcd49ccbe375e5cd284e6f5aa8e0ad2fa2", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "e28ba0fe89fbeb01d49266a24ca0039764345a5f", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d6594ab3004efd2636eb0eea12c2e93358c642a6", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "2a9b7546da94663980d2e9a9c07c0087a1cd5682", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "2621fafe625ac50688d899b1d6472918c99d2efe", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "51758850181ed2852ccae249db1151b03514f954", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "a8067821b127f197bd848bb4de28230b6b17f7d3", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "85dd48c7c5c1d5fa64365157aa704d3f0fd8dec9", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d6a96ec4bf71097da8c139974a25c0d485c50dbb", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "551d207212b894c5b05e393f76ce668533bf06f1", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d44ecd44fce33fb79aad1acbcafdbfa7798d2083", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ffd484ca6785652d9e26be7ba896debef0d33f81", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d03ba72a2c43228d25e219ea3ab0c36da848ff25", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "4c528f27d5b6bfcbaeb7fb4c488bf789545f5aaf", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "5c0a8017f7850c65c3662070d794d8610d74c35f", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "3d35b0c46c4489da6ec653451cebabe66c534b33", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ec2f43422dc8a18eb18956a140c3c3ac599b4ca9", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "0bee414b6815e7b68d9600c849f7372e582bd3fa", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "cfb16f96716783c289213bd019a32aa7faaaa889", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "4bf9b8c03789748a51a6c5b2609bd6890cb6f4b6", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "c3721d9e51a636971171d7d375bcb2d70b8cc95d", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "a756665a53a4ea49bce29774e0dbfbced1a5ce69", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "59be8b71f127e96a7e5b8550f197405a78f84889", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "107426e96c7277771034d2d9c3e027186432caab", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "21a8dceaab8267ee56512f5ddeabe717f892aad0", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "2c7d860bc62837e3f657c2a68234bec4149dd2b7", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "0638ab03332869d6129c4735de36df000d6c3cb4", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "acc5689a0f682ac47d8bd8f0a53efd2da143a0ad", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "1cd2a45c45986e353e73cac560b0a8de62973b51", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "177f06e4d9702c448f8db5ae04947e20ef0ae447", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "35739aa8159e5b7cf3110d4852d911714d73fbb7", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "7a4a58e711bbf89cf5586c4e7f225a4dae0198ec", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "fe42c27a6e8d914cc93da2eed21ae9947d3b529f", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "19b233d80ec6a72e06aca966303bcae4094dab87", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d4ef8ed2c6a2eec8e8e4bd488a88f69983c9693d", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "814357d457733dc4d3730c40b0f6f92e7709464c", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "736cced85a6684094688fe811bf8a8eb4968ed01", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "37ae298a6b942ff7755a9119e0a0f10e21d4b44e", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "0cd7319476311a43fa6b842940281f0c4cddf4b6", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "f8ac97d08f292faba73fcc6dd70ba58ae036ae18", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "617588528d3bb8b4c866ebbd9135f8690f90afde", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d938dd7b90d5109dfb17be17a1a5779a42d6f6cb", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "8f0528e8cc3a444f0b949aa1a4bb906f8731547c", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "cf57b7936d8379bd46d15fcf831e4050a16d1dda", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "23c72931570e9b43faee089d7c20d74fd3e42e55", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "52c0ab74c90638691b9bbecb3cccb92dc4c9cd2e", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "e35ad66d4bec85c7c4d8a1109804e9e04a86f64f", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "37e877b8c1ee366d831fe34b88ecbe560a4dfc9f", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "dbd7ad37b113ae6c52b5b359d334d1f879a80926", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "fa9dcf5941687bc7cd7ea381cea92e3cfde661a9", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "5a8e4401a638526445a7a5a4bb4dca6a7ca58d91", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d3ce2ede03270b9472fa4d7850131623e0863592", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "dc2d60692a444a3199de696dfd7c5258e165d40c", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "98da2decf9206fa0c22b6c711274a7d51baaa530", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "8302d23518d64e845aeaff9dcea76164a0610261", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d8617ff948334b858725a7ffe14850760fc8b810", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "2cdbc7dafcacbb757c7d39d5ec8f57f62a9bf4b9", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "f8ef3a55c117e8b76e3c78bcb7ae8b24b00a40fd", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "0d6b52194fed1ffc95f396e890da06c6ce037e85", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "37d6561a8d25d39ae46cf8d555838834b3e0657d", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "3418ceee2f67b74ccd159fc76408499f2919bd7d", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "c36785e67f5e665c8b6c34185439e8fe6709f0d3", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "817f1c17ee89c1ed00cd3344f3b677baaa9ddbfa", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "d5a68eae6356ebcf7f736d9616adbb5d345d9bac", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "c2235b8f3b2bea087d63ab924fb802bfa0036cbc", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "05230f516b3e371dea25ac05f514884408ae6ba3", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "0ec3067f4bc26766da6e86484304e306c1701653", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -53,12 +53,12 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -68,7 +68,7 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -83,7 +83,7 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -194,12 +194,12 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else\n     {\n@@ -215,7 +215,7 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n #ifdef HAVE_GFC_LOGICAL_16\n@@ -227,7 +227,7 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     runtime_error (\"Funny sized logical array\");\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n@@ -243,7 +243,7 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n \n-  base = array->data;\n+  base = array->base_addr;\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n@@ -362,12 +362,12 @@ sminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n   else if (unlikely (compile_options.bounds_check))\n     {\n@@ -376,7 +376,7 @@ sminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;\n }"}, {"sha": "7b5ae81ff966e038d21792a9cc62fc409ed93bed", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "c08cb66e238d7923e575b372919d5c806fa71f34", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "3e89ba7cf2829295f0007264860e86954855c084", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "1097c3b11315b4ba158400f8c21b81fc95e8bd69", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "326b9cfd799d9154ace37fced738735e78dde391", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "7bf30bd4d1ea504ab50059aff51eb6478a72f918", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "bc65a036f5955cdccab07b26593e436a8bf13a28", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "baa2bc42dae7d4ce088cb0eacdc1778b21613dcc", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "482391dfb0243083318709239c5cda9b2f7e0498", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "73c1a235c439cd8bd316017d513c64ef6dde40a4", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "442f518c5210147ca650aeeb03f79bce7b8ba37c", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "f235b0931be2dbbd975a7e229ba95e0cc58f791a", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "e0a54f2f8b1b05f45ba31cff659fbefb903b8541", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "2d2882954d7a45c723a5dfea3d11f5a317ae4b1b", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "08947086bd5ae1df6fe5699c3301d2cf50c9f35d", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "082d4097e3242c04c3e9f7e3acc63b5fb7c9cba3", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "60c8f731a331c8785e3a86990d58aff36dd2c83d", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "267bdae40450aad822d0da0c98393c32417997a9", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "17fc399b0c54dd91c514ee68f0438683d6d1116d", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "350d762fc2a424e78d27241c26e0f39122037df4", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "22b10b8828b0bad244aaf4799efe305cb42cf839", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "f01ef6dc3708a7c9b8d7ff406e45fdb59efe1311", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "91cbc7e6a2614657f92ba6dd53ca44e7c1c435ed", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "b04ebfcbd09edc88143bfa04c9a86019eefcad6c", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "02f9b477f4fe73f358cd8a8c7fe4cd70d0a12550", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "bd7fb36ee6fca97ccbd3b47b8e46dd54f8efe26f", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "cd300bbe218c90e61b3955825d07b0dada4ef190", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,7 +101,7 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -131,8 +131,8 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -243,7 +243,7 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -279,7 +279,7 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -307,7 +307,7 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -332,8 +332,8 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -472,7 +472,7 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -500,7 +500,7 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -532,7 +532,7 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ed9fb22ae349fcac8174ee691ea7c84ca0a7d6ab", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "7f11f411230b6fa2d19a54b1a37fc6e439e1b925", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "18663d7664dcf72335b9da969b9a4dd7f74f7ded", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "f6d4803506940cadde226c74624432c2ea86434e", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "2fdf455b02b4d0e9018e9f32ad93640d971af37c", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "590a4dba8d386bb68c1b306d9a4e1482fb41eb30", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ca30114a585b281f1eb24100780e5114d270b6ad", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "8ec3c7c24a02b88af8687357eb5ccebef06eec39", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d03f5135339d6d1151ac070bde9c65f5048ef449", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -235,7 +235,7 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -271,7 +271,7 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -299,7 +299,7 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -324,8 +324,8 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -459,7 +459,7 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -487,7 +487,7 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -519,7 +519,7 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "d3e8c7a9306d5a4d6425af980f0a588caeb50c3e", "filename": "libgfortran/generated/norm2_r10.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -104,15 +104,14 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -135,8 +134,8 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "dc5aeac43cec7e2142a86b51aea0a7be0cd51233", "filename": "libgfortran/generated/norm2_r16.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -87,7 +87,7 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -108,15 +108,14 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -139,8 +138,8 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "8c7fae0902542491693933bb759cdd4972a746c2", "filename": "libgfortran/generated/norm2_r4.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -104,15 +104,14 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -135,8 +134,8 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "9dcd8cfa6f962d91f18d7f30f558815b613c47a7", "filename": "libgfortran/generated/norm2_r8.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fnorm2_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -83,7 +83,7 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -104,15 +104,14 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -135,8 +134,8 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "577c68a4476278ab44aef6d8109bfe00e6e256a0", "filename": "libgfortran/generated/pack_c10.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_COMPLEX_10) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "121b0a86b475caf323a25ff4e49e994cd7ad327b", "filename": "libgfortran/generated/pack_c16.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_COMPLEX_16) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "c9ad6e80e2f21082be9fea2005a5f98b504c9b98", "filename": "libgfortran/generated/pack_c4.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_COMPLEX_4) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "d1a6941a9400ad4102024bbf26ed80bff7ad3d69", "filename": "libgfortran/generated/pack_c8.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_COMPLEX_8) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "2aa75c19debe64bef15f732d76fa4e3fd04520a5", "filename": "libgfortran/generated/pack_i1.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_1) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "451c8da6c95f36a05ea0abe2c286ffd1972d1417", "filename": "libgfortran/generated/pack_i16.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_16) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "9b68c5207f599ed3be3af424fae72f6a883dcd1e", "filename": "libgfortran/generated/pack_i2.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_2) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "36d1eb149e139acc7812ef13cd8996e2e7d3bebf", "filename": "libgfortran/generated/pack_i4.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_4) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "8f75038efb0f3ba7c0853ead0fdd90fd93f6f9f5", "filename": "libgfortran/generated/pack_i8.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_INTEGER_8) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "b8b81359030510f5088885d96f92cf0509173c3f", "filename": "libgfortran/generated/pack_r10.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_10) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "932e190aebaad2d34547f8bc5617e5f6030e3613", "filename": "libgfortran/generated/pack_r16.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_16) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "a57daba216bbd7b3887f64c1a9c837a9b41babd2", "filename": "libgfortran/generated/pack_r4.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_4) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "9516551b443c24a4ea3deecd0605961403c5b427", "filename": "libgfortran/generated/pack_r8.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,9 @@\n /* Specific implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -98,7 +99,7 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  mptr = mask->data;\n+  mptr = mask->base_addr;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n      and using shifting to address size and endian issues.  */\n@@ -136,9 +137,9 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n   if (zero_sized)\n     sptr = NULL;\n   else\n-    sptr = array->data;\n+    sptr = array->base_addr;\n \n-  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -160,15 +161,15 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n \t  total = count_0 (mask);\n         }\n \n-      if (ret->data == NULL)\n+      if (ret->base_addr == NULL)\n \t{\n \t  /* Setup the array descriptor.  */\n \t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n \n \t  ret->offset = 0;\n \n \t  /* internal_malloc_size allocates a single byte for zero size.  */\n-\t  ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * total);\n+\t  ret->base_addr = internal_malloc_size (sizeof (GFC_REAL_8) * total);\n \n \t  if (total == 0)\n \t    return;\n@@ -191,7 +192,7 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n     rstride0 = 1;\n   sstride0 = sstride[0];\n   mstride0 = mstride[0];\n-  rptr = ret->data;\n+  rptr = ret->base_addr;\n \n   while (sptr && mptr)\n     {\n@@ -236,14 +237,14 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n   if (vector)\n     {\n       n = GFC_DESCRIPTOR_EXTENT(vector,0);\n-      nelem = ((rptr - ret->data) / rstride0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n       if (n > nelem)\n         {\n           sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n           if (sstride0 == 0)\n             sstride0 = 1;\n \n-          sptr = vector->data + sstride0 * nelem;\n+          sptr = vector->base_addr + sstride0 * nelem;\n           n -= nelem;\n           while (n--)\n             {"}, {"sha": "84b1e9676d0a08521a80f88abe65de27989b13f7", "filename": "libgfortran/generated/parity_l1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,15 +101,14 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n       alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -132,8 +131,8 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "184fdf0f8ed10443943b2fa4ba64c092dffe6787", "filename": "libgfortran/generated/parity_l16.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,15 +101,14 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n       alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -132,8 +131,8 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "5906c2a8c9557ccab51057bbc718f0776a930a39", "filename": "libgfortran/generated/parity_l2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,15 +101,14 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n       alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -132,8 +131,8 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "b9f183a5b163be1ca969517c83f7b2f92f9ce938", "filename": "libgfortran/generated/parity_l4.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,15 +101,14 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n       alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -132,8 +131,8 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "651350b62e045e7a4a38bf006cb83e26f5a0fc62", "filename": "libgfortran/generated/parity_l8.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fparity_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -80,7 +80,7 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -101,15 +101,14 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n       alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n \t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \n \t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -132,8 +131,8 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)"}, {"sha": "349ab55bf8a7d465c7412cc21010836ee7ae4a11", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n       alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "9680b76f347c3a7ac526706f12ef3caeedf4941f", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n       alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "5e5346518bec4a152b34e8abc84363a95021c703", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n       alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "5e5a9116ff41a510bdcd3d7f6ac8f9e376627c76", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n       alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "fd19554b36264811bdaa0e81ac3c3484c5b68cab", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "6105413dadc6f684bc6a03f57522b9fa8aea5137", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "803bd0cd7e81981f140b7b3aee13e82a7bde83b2", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "71f353eb2fb50b179503cbbdfe09226e67c42f1c", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "2422ce62b1c9965b4561480cf70fb18be0de31ac", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "6621f9f394831fd992dd539e79e34f23b94e0858", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "846b5c226b1b899f674d91d158a27e6797cd5cb9", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "2c6feffc4582b4b0c01dd1a498e8e6233682a48f", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "ddb021564c498aa54e7b6825a351b2126f4ab5ab", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -79,7 +79,7 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -100,7 +100,7 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n       alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n-      retarray->data = internal_malloc_size (alloc_size);\n+      retarray->base_addr = internal_malloc_size (alloc_size);\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -130,8 +130,8 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  base = array->data;\n-  dest = retarray->data;\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n \n   continue_loop = 1;\n   while (continue_loop)\n@@ -221,7 +221,7 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   if (len <= 0)\n     return;\n \n-  mbase = mask->data;\n+  mbase = mask->base_addr;\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n \n@@ -257,7 +257,7 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -285,7 +285,7 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n \n     }\n   else\n@@ -310,8 +310,8 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n \treturn;\n     }\n \n-  dest = retarray->data;\n-  base = array->data;\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n \n   while (base)\n     {\n@@ -417,7 +417,7 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n \textent[n] = 0;\n     }\n \n-  if (retarray->data == NULL)\n+  if (retarray->base_addr == NULL)\n     {\n       size_t alloc_size, str;\n \n@@ -445,7 +445,7 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->data = internal_malloc_size (alloc_size);\n+\tretarray->base_addr = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -477,7 +477,7 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n-  dest = retarray->data;\n+  dest = retarray->base_addr;\n \n   while(1)\n     {"}, {"sha": "13dedbcc5ad86ff97a140ec608ccf289f84a7223", "filename": "libgfortran/generated/reshape_c10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the RESHAPE intrinsic\n-   Copyright 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -87,15 +87,15 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n \n   for (n = 0; n < rdim; n++)\n     {\n-      shape_data[n] = shape->data[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n       if (shape_data[n] <= 0)\n       {\n         shape_data[n] = 0;\n \tshape_empty = 1;\n       }\n     }\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       index_type alloc_size;\n \n@@ -115,7 +115,7 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n       else\n         alloc_size = rs * sizeof (GFC_COMPLEX_10);\n \n-      ret->data = internal_malloc_size (alloc_size);\n+      ret->base_addr = internal_malloc_size (alloc_size);\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n \n@@ -143,7 +143,7 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n           else\n             psize = 0;\n         }\n-      pptr = pad->data;\n+      pptr = pad->base_addr;\n     }\n   else\n     {\n@@ -193,7 +193,7 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n \n \t  for (n = 0; n < rdim; n++)\n \t    {\n-\t      v = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n \n \t      if (v < 0 || v >= rdim)\n \t\truntime_error(\"Value %ld out of range in ORDER argument\"\n@@ -212,7 +212,7 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n   for (n = 0; n < rdim; n++)\n     {\n       if (order)\n-        dim = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n       else\n         dim = n;\n \n@@ -258,12 +258,12 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n       rsize *= sizeof (GFC_COMPLEX_10);\n       ssize *= sizeof (GFC_COMPLEX_10);\n       psize *= sizeof (GFC_COMPLEX_10);\n-      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n-\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n       return;\n     }\n-  rptr = ret->data;\n-  src = sptr = source->data;\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n "}, {"sha": "72aba60fb4be2edcf5beed3d8cedc6ae96299fb0", "filename": "libgfortran/generated/reshape_c16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the RESHAPE intrinsic\n-   Copyright 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -87,15 +87,15 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n \n   for (n = 0; n < rdim; n++)\n     {\n-      shape_data[n] = shape->data[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n       if (shape_data[n] <= 0)\n       {\n         shape_data[n] = 0;\n \tshape_empty = 1;\n       }\n     }\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       index_type alloc_size;\n \n@@ -115,7 +115,7 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n       else\n         alloc_size = rs * sizeof (GFC_COMPLEX_16);\n \n-      ret->data = internal_malloc_size (alloc_size);\n+      ret->base_addr = internal_malloc_size (alloc_size);\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n \n@@ -143,7 +143,7 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n           else\n             psize = 0;\n         }\n-      pptr = pad->data;\n+      pptr = pad->base_addr;\n     }\n   else\n     {\n@@ -193,7 +193,7 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n \n \t  for (n = 0; n < rdim; n++)\n \t    {\n-\t      v = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n \n \t      if (v < 0 || v >= rdim)\n \t\truntime_error(\"Value %ld out of range in ORDER argument\"\n@@ -212,7 +212,7 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n   for (n = 0; n < rdim; n++)\n     {\n       if (order)\n-        dim = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n       else\n         dim = n;\n \n@@ -258,12 +258,12 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n       rsize *= sizeof (GFC_COMPLEX_16);\n       ssize *= sizeof (GFC_COMPLEX_16);\n       psize *= sizeof (GFC_COMPLEX_16);\n-      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n-\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n       return;\n     }\n-  rptr = ret->data;\n-  src = sptr = source->data;\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n "}, {"sha": "63f66ecdd7b7a4dc67e2963c127c464e3ee3a03b", "filename": "libgfortran/generated/reshape_c4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the RESHAPE intrinsic\n-   Copyright 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -87,15 +87,15 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n \n   for (n = 0; n < rdim; n++)\n     {\n-      shape_data[n] = shape->data[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n       if (shape_data[n] <= 0)\n       {\n         shape_data[n] = 0;\n \tshape_empty = 1;\n       }\n     }\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       index_type alloc_size;\n \n@@ -115,7 +115,7 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n       else\n         alloc_size = rs * sizeof (GFC_COMPLEX_4);\n \n-      ret->data = internal_malloc_size (alloc_size);\n+      ret->base_addr = internal_malloc_size (alloc_size);\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n \n@@ -143,7 +143,7 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n           else\n             psize = 0;\n         }\n-      pptr = pad->data;\n+      pptr = pad->base_addr;\n     }\n   else\n     {\n@@ -193,7 +193,7 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n \n \t  for (n = 0; n < rdim; n++)\n \t    {\n-\t      v = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n \n \t      if (v < 0 || v >= rdim)\n \t\truntime_error(\"Value %ld out of range in ORDER argument\"\n@@ -212,7 +212,7 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n   for (n = 0; n < rdim; n++)\n     {\n       if (order)\n-        dim = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n       else\n         dim = n;\n \n@@ -258,12 +258,12 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n       rsize *= sizeof (GFC_COMPLEX_4);\n       ssize *= sizeof (GFC_COMPLEX_4);\n       psize *= sizeof (GFC_COMPLEX_4);\n-      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n-\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n       return;\n     }\n-  rptr = ret->data;\n-  src = sptr = source->data;\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n "}, {"sha": "ab646834825bdef33b9ef3f8d5a7b9ccc7782370", "filename": "libgfortran/generated/reshape_c8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the RESHAPE intrinsic\n-   Copyright 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -87,15 +87,15 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n \n   for (n = 0; n < rdim; n++)\n     {\n-      shape_data[n] = shape->data[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n       if (shape_data[n] <= 0)\n       {\n         shape_data[n] = 0;\n \tshape_empty = 1;\n       }\n     }\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       index_type alloc_size;\n \n@@ -115,7 +115,7 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n       else\n         alloc_size = rs * sizeof (GFC_COMPLEX_8);\n \n-      ret->data = internal_malloc_size (alloc_size);\n+      ret->base_addr = internal_malloc_size (alloc_size);\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n \n@@ -143,7 +143,7 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n           else\n             psize = 0;\n         }\n-      pptr = pad->data;\n+      pptr = pad->base_addr;\n     }\n   else\n     {\n@@ -193,7 +193,7 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n \n \t  for (n = 0; n < rdim; n++)\n \t    {\n-\t      v = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n \n \t      if (v < 0 || v >= rdim)\n \t\truntime_error(\"Value %ld out of range in ORDER argument\"\n@@ -212,7 +212,7 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n   for (n = 0; n < rdim; n++)\n     {\n       if (order)\n-        dim = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n       else\n         dim = n;\n \n@@ -258,12 +258,12 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n       rsize *= sizeof (GFC_COMPLEX_8);\n       ssize *= sizeof (GFC_COMPLEX_8);\n       psize *= sizeof (GFC_COMPLEX_8);\n-      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n-\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n       return;\n     }\n-  rptr = ret->data;\n-  src = sptr = source->data;\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n "}, {"sha": "dbf812d8e36b1248107ee21a8ec9d6491fdf9e9a", "filename": "libgfortran/generated/reshape_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the RESHAPE intrinsic\n-   Copyright 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -87,15 +87,15 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n \n   for (n = 0; n < rdim; n++)\n     {\n-      shape_data[n] = shape->data[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n       if (shape_data[n] <= 0)\n       {\n         shape_data[n] = 0;\n \tshape_empty = 1;\n       }\n     }\n \n-  if (ret->data == NULL)\n+  if (ret->base_addr == NULL)\n     {\n       index_type alloc_size;\n \n@@ -115,7 +115,7 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n       else\n         alloc_size = rs * sizeof (GFC_INTEGER_16);\n \n-      ret->data = internal_malloc_size (alloc_size);\n+      ret->base_addr = internal_malloc_size (alloc_size);\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n \n@@ -143,7 +143,7 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n           else\n             psize = 0;\n         }\n-      pptr = pad->data;\n+      pptr = pad->base_addr;\n     }\n   else\n     {\n@@ -193,7 +193,7 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n \n \t  for (n = 0; n < rdim; n++)\n \t    {\n-\t      v = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n \n \t      if (v < 0 || v >= rdim)\n \t\truntime_error(\"Value %ld out of range in ORDER argument\"\n@@ -212,7 +212,7 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n   for (n = 0; n < rdim; n++)\n     {\n       if (order)\n-        dim = order->data[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n       else\n         dim = n;\n \n@@ -258,12 +258,12 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n       rsize *= sizeof (GFC_INTEGER_16);\n       ssize *= sizeof (GFC_INTEGER_16);\n       psize *= sizeof (GFC_INTEGER_16);\n-      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n-\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n       return;\n     }\n-  rptr = ret->data;\n-  src = sptr = source->data;\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n "}, {"sha": "a4c83adc3868e85f9de4c375a8bc29494d0493c8", "filename": "libgfortran/generated/reshape_i4.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "e7288bb20d6238a4fd543e4d7bba18af648f8892", "filename": "libgfortran/generated/reshape_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "87216f49936440dc3037938206c684f5e26c5a12", "filename": "libgfortran/generated/reshape_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "cb1f7f34993dd7af79d82cd310ea77aa5703e99f", "filename": "libgfortran/generated/reshape_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "64f3991e363fb200f4b66d4680c3d26defc08cc6", "filename": "libgfortran/generated/reshape_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "4b6f4c67dd4d1824fb50cc8be4092f07c2856c65", "filename": "libgfortran/generated/reshape_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Freshape_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "c42aca9d63d46271a604bdc338449c849b77bf34", "filename": "libgfortran/generated/shape_i16.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "3f5739996292c2d44062adabcfc0a12d28fdec6c", "filename": "libgfortran/generated/shape_i4.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "49910ac7e4c03adac75841793928def1da88945d", "filename": "libgfortran/generated/shape_i8.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fshape_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "fb4efb0fa24ededcabc82a14b509e1bf09e46de9", "filename": "libgfortran/generated/spread_c10.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "46789ca8adcbfcc8667aa82bac6257d07800015d", "filename": "libgfortran/generated/spread_c16.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "ef91ca55bc8b0a45cea95085b44fae02238ce796", "filename": "libgfortran/generated/spread_c4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "dbcc0293a21741aecc9aec00dc8bd0044066d784", "filename": "libgfortran/generated/spread_c8.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "0e654eb75b80dd6804963fb21ffe7668e1ea83e9", "filename": "libgfortran/generated/spread_i1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "41676510f8860ca3509fbe1e07f4f601b3b95f92", "filename": "libgfortran/generated/spread_i16.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "e65b942bd27389bbb79f264140b41927e695236f", "filename": "libgfortran/generated/spread_i2.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "599da3fe129671db4835d115c64ca8b94d30830f", "filename": "libgfortran/generated/spread_i4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "ddb8163d5a5956ed4446c0ee4935517ba1ec9a99", "filename": "libgfortran/generated/spread_i8.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "d023a2774f120da8e82cbd33f58164c87c14fad0", "filename": "libgfortran/generated/spread_r10.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "17bffbe5d0b7034b1072d453468cb8b60bfba17a", "filename": "libgfortran/generated/spread_r16.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "656205fc153cf0e9739b9064cb9f5a3677346b6a", "filename": "libgfortran/generated/spread_r4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "2c77f1cf2b3bdc0e8a66a14981363743f5ef3ef0", "filename": "libgfortran/generated/spread_r8.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fspread_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "2a289f4ee409b32e75f28cb3879c8f856658789a", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "d87e086bfed60a6afeb71f7fe15fdfae44c39b4c", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "7964eb912764ddc8df2badd799fdbff1b21f2377", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "2fd67828d95b939b9a44dfaff49ca3fab98e7424", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "c746e073f76c35b0acdf95468a040fca565a13d5", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "02d6cc86b1b8831ef83cfc1e3e53d29430b1937e", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "5e6d3b98df3e5f5b05cbe6abeb9239cbcffd147c", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "e199544f193f55b510ebe0ac88264cbd08b20db9", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "68e8539a7850eb60d2520d2d65f0b1cc696f681c", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "42f676eaf9253b025d7877997cd3c33e70b852ae", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "ca98de1bfe12936425bb5b7560e6b4b0fc856adf", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "863191af478080012fb11b7914012c2df691e2d7", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}, {"sha": "45de9f4f649b3d957ff713611933fbdd6f85c1bb", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d1335b2a547a09188c62ca5f3b698920ea1438/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=21d1335b2a547a09188c62ca5f3b698920ea1438"}]}