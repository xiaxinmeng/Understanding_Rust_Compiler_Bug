{"sha": "d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU4YjdjMmQ1ZGVjNGU2MDNiNGViNzQwYjRkN2IyY2UxN2NjNmNlMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-06-10T07:19:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-06-10T07:19:57Z"}, "message": "re PR c++/11131 (Unrelated declaration removes inline flag from function)\n\n\tPR c++/11131\n\t* tree-inline.c (inlinable_function_p): Call the language-specific\n\thook early.\n\n\tPR c++/11131\n\t* cp-tree.h (template_for_substitution): Declare.\n\t* decl2.c (mark_used): Use it when figuring out whether or not a\n\tfunction is inline.\n\t* pt.c (template_for_substitution): Give it external linkage.\n\t* tree.c (cp_cannot_inline_tree_fn): Instantiate as early as\n\tpossible.\n\n\tPR c++/11131\n\t* g++.dg/opt/template1.C: New test.\n\nFrom-SVN: r67698", "tree": {"sha": "99bd6c6f94bdf41422f8f7a377f59d5cb319ff5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99bd6c6f94bdf41422f8f7a377f59d5cb319ff5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/comments", "author": null, "committer": null, "parents": [{"sha": "c566f9bd367cf07de6e9151dd5a5882241b367bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c566f9bd367cf07de6e9151dd5a5882241b367bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c566f9bd367cf07de6e9151dd5a5882241b367bf"}], "stats": {"total": 86, "additions": 62, "deletions": 24}, "files": [{"sha": "3c34fe2c21fd2d95649329f8396e93b9291c5b9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -1,3 +1,9 @@\n+2003-06-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11131\n+\t* tree-inline.c (inlinable_function_p): Call the language-specific\n+\thook early.\n+\n 2003-06-09  David Taylor  <dtaylor@emc.com>\n \n \t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_va_arg):  Skip over"}, {"sha": "0de9c7b840d8c8ba63d2c924300345e13ab57285", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -1,3 +1,13 @@\n+2003-06-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11131\n+\t* cp-tree.h (template_for_substitution): Declare.\n+\t* decl2.c (mark_used): Use it when figuring out whether or not a\n+\tfunction is inline.\n+\t* pt.c (template_for_substitution): Give it external linkage.\n+\t* tree.c (cp_cannot_inline_tree_fn): Instantiate as early as\n+\tpossible.\n+\n 2003-06-09  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR 8861"}, {"sha": "4639e174ee0f8224e0461d7e09b5f781a6de8ccc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -3978,6 +3978,7 @@ extern bool type_dependent_expression_p         (tree);\n extern bool value_dependent_expression_p        (tree);\n extern tree resolve_typename_type               (tree, bool);\n extern tree resolve_typename_type_in_current_instantiation (tree);\n+extern tree template_for_substitution           (tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);"}, {"sha": "08a2d663b2a3b423c942037b38b548c01e0df056", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -4590,7 +4590,9 @@ mark_used (tree decl)\n   if ((DECL_NON_THUNK_FUNCTION_P (decl) || TREE_CODE (decl) == VAR_DECL)\n       && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n       && (!DECL_EXPLICIT_INSTANTIATION (decl)\n-\t  || (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))))\n+\t  || (TREE_CODE (decl) == FUNCTION_DECL \n+\t      && DECL_INLINE (DECL_TEMPLATE_RESULT \n+\t\t\t      (template_for_substitution (decl))))))\n     {\n       bool defer;\n "}, {"sha": "1f64f747ca623a9abe61311d82ac9be762a86bbc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -171,7 +171,6 @@ static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n static int eq_local_specializations (const void *, const void *);\n-static tree template_for_substitution (tree);\n static bool dependent_type_p_r (tree);\n static bool dependent_template_id_p (tree, tree);\n static tree tsubst (tree, tree, tsubst_flags_t, tree);\n@@ -10736,7 +10735,7 @@ regenerate_decl_from_template (decl, tmpl)\n /* Return the TEMPLATE_DECL into which DECL_TI_ARGS(DECL) should be\n    substituted to get DECL.  */\n \n-static tree\n+tree\n template_for_substitution (tree decl)\n {\n   tree tmpl = DECL_TI_TEMPLATE (decl);"}, {"sha": "b696c3bd655c6671016d71fc2dcb747015e34c24", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -2204,10 +2204,6 @@ cp_cannot_inline_tree_fn (fnp)\n {\n   tree fn = *fnp;\n \n-  if (flag_really_no_inline\n-      && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n-    return 1;\n-\n   /* We can inline a template instantiation only if it's fully\n      instantiated.  */\n   if (DECL_TEMPLATE_INFO (fn)\n@@ -2218,6 +2214,13 @@ cp_cannot_inline_tree_fn (fnp)\n \treturn 1;\n     }\n \n+  if (!DECL_INLINE (fn))\n+    return 1;\n+\n+  if (flag_really_no_inline\n+      && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n+    return 1;\n+\n   /* Don't auto-inline anything that might not be bound within\n      this unit of translation.  */\n   if (!DECL_DECLARED_INLINE_P (fn) && !(*targetm.binds_local_p) (fn))"}, {"sha": "88381678bf14f447d8321527bf4453e6928acd50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -1,3 +1,8 @@\n+2003-06-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11131\n+\t* g++.dg/opt/template1.C: New test.\n+\n 2003-06-09  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lib/gcc-dg.exp (dg-test): Clear additional_files and"}, {"sha": "9003be1ee17eff920285551a8dae55a00bc11877", "filename": "gcc/testsuite/g++.dg/opt/template1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemplate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemplate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemplate1.C?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-O2\" }\n+// { dg-final { scan-assembler-not \"foo1\" } }\n+\n+template <int>\n+struct A {\n+    void foo1 () throw ();\n+    void foo2 ();\n+\n+    void UNRELATED ();\n+};\n+\n+template <> void A<0>::UNRELATED ();\n+\n+template <int dim> inline void A<dim>::foo1 () throw () {}\n+template <int dim> inline void A<dim>::foo2 ()          {}\n+\n+void bar (A<0> &a) {\n+  a.foo1 ();\n+}"}, {"sha": "dd50ca1d63130af88aa81dbfa90422e1ee8cbbf7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d58b7c2d5dec4e603b4eb740b4d7b2ce17cc6ce1", "patch": "@@ -979,8 +979,10 @@ inlinable_function_p (fn, id, nolimit)\n   if (DECL_UNINLINABLE (fn))\n     return 0;\n \n-  /* Assume it is not inlinable.  */\n-  inlinable = 0;\n+  /* See if there is any language-specific reason it cannot be\n+     inlined.  (It is important that this hook be called early because\n+     in C++ it may result in template instantiation.)  */\n+  inlinable = !(*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn);\n        \n   /* We may be here either because fn is declared inline or because\n      we use -finline-functions.  For the second case, we are more\n@@ -993,48 +995,42 @@ inlinable_function_p (fn, id, nolimit)\n \n   /* If we're not inlining things, then nothing is inlinable.  */\n   if (! flag_inline_trees)\n-    ;\n+    inlinable = 0;\n   /* If we're not inlining all functions and the function was not\n      declared `inline', we don't inline it.  Don't think of\n      disregarding DECL_INLINE when flag_inline_trees == 2; it's the\n      front-end that must set DECL_INLINE in this case, because\n      dwarf2out loses if a function is inlined that doesn't have\n      DECL_INLINE set.  */\n   else if (! DECL_INLINE (fn) && !nolimit)\n-    ;\n+    inlinable = 0;\n #ifdef INLINER_FOR_JAVA\n   /* Synchronized methods can't be inlined.  This is a bug.  */\n   else if (METHOD_SYNCHRONIZED (fn))\n-    ;\n+    inlinable = 0;\n #endif /* INLINER_FOR_JAVA */\n   /* We can't inline functions that are too big.  Only allow a single\n      function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n      allowance for extern inline functions, though.  */\n   else if (!nolimit\n \t   && ! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && currfn_insns > max_inline_insns_single)\n-    ;\n+    inlinable = 0;\n   /* We can't inline functions that call __builtin_longjmp at all.\n      The non-local goto machenery really requires the destination\n      be in a different function.  If we allow the function calling\n      __builtin_longjmp to be inlined into the function calling\n      __builtin_setjmp, Things will Go Awry.  */\n   /* ??? Need front end help to identify \"regular\" non-local goto.  */\n   else if (find_builtin_longjmp_call (DECL_SAVED_TREE (fn)))\n-    ;\n+    inlinable = 0;\n   /* Refuse to inline alloca call unless user explicitly forced so as this may\n      change program's memory overhead drastically when the function using alloca\n      is called in loop.  In GCC present in SPEC2000 inlining into schedule_block\n      cause it to require 2GB of ram instead of 256MB.  */\n   else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL\n \t   && find_alloca_call (DECL_SAVED_TREE (fn)))\n-    ;\n-  /* All is well.  We can inline this function.  Traditionally, GCC\n-     has refused to inline functions using alloca, or functions whose\n-     values are returned in a PARALLEL, and a few other such obscure\n-     conditions.  We are not equally constrained at the tree level.  */\n-  else\n-    inlinable = 1;\n+    inlinable = 0;\n \n   /* Squirrel away the result so that we don't have to check again.  */\n   DECL_UNINLINABLE (fn) = ! inlinable;\n@@ -1065,9 +1061,6 @@ inlinable_function_p (fn, id, nolimit)\n \t}\n     }\n \n-  if (inlinable && (*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn))\n-    inlinable = 0;\n-\n   /* If we don't have the function body available, we can't inline\n      it.  */\n   if (! DECL_SAVED_TREE (fn))"}]}