{"sha": "ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ0NWFjNDNlNDUxODcxNWY0YTU2YTdjZjkyZjlkNzNhZWE2ZWQ2Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2016-01-15T16:38:08Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2016-01-15T16:38:08Z"}, "message": "re PR target/68609 (PowerPC reciprocal estimate missed opportunities)\n\n        PR target/68609\n        * config/rs6000/rs6000.c (rs6000_emit_msub): Delete.\n        (rs6000_emit_swsqrt): Convert to Goldschmidt's Algorithm\n        * config/rs6000/rs6000.md (sqrt<mode>2): Limit swsqrt to high\n        precision estimate.\n\nFrom-SVN: r232439", "tree": {"sha": "d7bfc6ea51651abdaf482620ea6f6569cdae9ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7bfc6ea51651abdaf482620ea6f6569cdae9ba8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5e3b6fc95b12720da53b81e047e77cfe63a2c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e3b6fc95b12720da53b81e047e77cfe63a2c3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e3b6fc95b12720da53b81e047e77cfe63a2c3c"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "609b135dbb5b1bb1c1f435d1fab65eb06cd757e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "patch": "@@ -1,3 +1,11 @@\n+2016-01-15  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\tPR target/68609\n+\t* config/rs6000/rs6000.c (rs6000_emit_msub): Delete.\n+\t(rs6000_emit_swsqrt): Convert to Goldschmidt's Algorithm\n+\t* config/rs6000/rs6000.md (sqrt<mode>2): Limit swsqrt to high\n+\tprecision estimate.\n+\n 2016-01-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66856"}, {"sha": "c589118a797752f276d3f3e830f96341ec273961", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "patch": "@@ -32769,29 +32769,6 @@ rs6000_emit_madd (rtx target, rtx m1, rtx m2, rtx a)\n     emit_move_insn (target, dst);\n }\n \n-/* Generate a FMSUB instruction: dst = fma(m1, m2, -a).  */\n-\n-static void\n-rs6000_emit_msub (rtx target, rtx m1, rtx m2, rtx a)\n-{\n-  machine_mode mode = GET_MODE (target);\n-  rtx dst;\n-\n-  /* Altivec does not support fms directly;\n-     generate in terms of fma in that case.  */\n-  if (optab_handler (fms_optab, mode) != CODE_FOR_nothing)\n-    dst = expand_ternary_op (mode, fms_optab, m1, m2, a, target, 0);\n-  else\n-    {\n-      a = expand_unop (mode, neg_optab, a, NULL_RTX, 0);\n-      dst = expand_ternary_op (mode, fma_optab, m1, m2, a, target, 0);\n-    }\n-  gcc_assert (dst != NULL);\n-\n-  if (dst != target)\n-    emit_move_insn (target, dst);\n-}\n-    \n /* Generate a FNMSUB instruction: dst = -fma(m1, m2, -a).  */\n \n static void\n@@ -32890,15 +32867,16 @@ rs6000_emit_swdiv (rtx dst, rtx n, rtx d, bool note_p)\n     add_reg_note (get_last_insn (), REG_EQUAL, gen_rtx_DIV (mode, n, d));\n }\n \n-/* Newton-Raphson approximation of single/double-precision floating point\n-   rsqrt.  Assumes no trapping math and finite arguments.  */\n+/* Goldschmidt's Algorithm for single/double-precision floating point\n+   sqrt and rsqrt.  Assumes no trapping math and finite arguments.  */\n \n void\n rs6000_emit_swsqrt (rtx dst, rtx src, bool recip)\n {\n   machine_mode mode = GET_MODE (src);\n-  rtx x0 = gen_reg_rtx (mode);\n-  rtx y = gen_reg_rtx (mode);\n+  rtx e = gen_reg_rtx (mode);\n+  rtx g = gen_reg_rtx (mode);\n+  rtx h = gen_reg_rtx (mode);\n \n   /* Low precision estimates guarantee 5 bits of accuracy.  High\n      precision estimates guarantee 14 bits of accuracy.  SFmode\n@@ -32909,55 +32887,68 @@ rs6000_emit_swsqrt (rtx dst, rtx src, bool recip)\n   if (mode == DFmode || mode == V2DFmode)\n     passes++;\n \n-  REAL_VALUE_TYPE dconst3_2;\n   int i;\n-  rtx halfthree;\n+  rtx mhalf;\n   enum insn_code code = optab_handler (smul_optab, mode);\n   insn_gen_fn gen_mul = GEN_FCN (code);\n \n   gcc_assert (code != CODE_FOR_nothing);\n \n-  /* Load up the constant 1.5 either as a scalar, or as a vector.  */\n-  real_from_integer (&dconst3_2, VOIDmode, 3, SIGNED);\n-  SET_REAL_EXP (&dconst3_2, REAL_EXP (&dconst3_2) - 1);\n+  mhalf = rs6000_load_constant_and_splat (mode, dconsthalf);\n \n-  halfthree = rs6000_load_constant_and_splat (mode, dconst3_2);\n-\n-  /* x0 = rsqrt estimate */\n-  emit_insn (gen_rtx_SET (x0, gen_rtx_UNSPEC (mode, gen_rtvec (1, src),\n-\t\t\t\t\t      UNSPEC_RSQRT)));\n+  /* e = rsqrt estimate */\n+  emit_insn (gen_rtx_SET (e, gen_rtx_UNSPEC (mode, gen_rtvec (1, src),\n+\t\t\t\t\t     UNSPEC_RSQRT)));\n \n   /* If (src == 0.0) filter infinity to prevent NaN for sqrt(0.0).  */\n   if (!recip)\n     {\n       rtx zero = force_reg (mode, CONST0_RTX (mode));\n-      rtx target = emit_conditional_move (x0, GT, src, zero, mode,\n-\t\t\t\t\t  x0, zero, mode, 0);\n-      if (target != x0)\n-\temit_move_insn (x0, target);\n+      rtx target = emit_conditional_move (e, GT, src, zero, mode,\n+\t\t\t\t\t  e, zero, mode, 0);\n+      if (target != e)\n+\temit_move_insn (e, target);\n     }\n \n-  /* y = 0.5 * src = 1.5 * src - src -> fewer constants */\n-  rs6000_emit_msub (y, src, halfthree, src);\n+  /* g = sqrt estimate.  */\n+  emit_insn (gen_mul (g, e, src));\n+  /* h = 1/(2*sqrt) estimate.  */\n+  emit_insn (gen_mul (h, e, mhalf));\n \n-  for (i = 0; i < passes; i++)\n+  if (recip)\n     {\n-      rtx x1 = gen_reg_rtx (mode);\n-      rtx u = gen_reg_rtx (mode);\n-      rtx v = gen_reg_rtx (mode);\n+      if (passes == 1)\n+\t{\n+\t  rtx t = gen_reg_rtx (mode);\n+\t  rs6000_emit_nmsub (t, g, h, mhalf);\n+\t  /* Apply correction directly to 1/rsqrt estimate.  */\n+\t  rs6000_emit_madd (dst, e, t, e);\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < passes; i++)\n+\t    {\n+\t      rtx t1 = gen_reg_rtx (mode);\n+\t      rtx g1 = gen_reg_rtx (mode);\n+\t      rtx h1 = gen_reg_rtx (mode);\n \n-      /* x1 = x0 * (1.5 - y * (x0 * x0)) */\n-      emit_insn (gen_mul (u, x0, x0));\n-      rs6000_emit_nmsub (v, y, u, halfthree);\n-      emit_insn (gen_mul (x1, x0, v));\n-      x0 = x1;\n-    }\n+\t      rs6000_emit_nmsub (t1, g, h, mhalf);\n+\t      rs6000_emit_madd (g1, g, t1, g);\n+\t      rs6000_emit_madd (h1, h, t1, h);\n \n-  /* If not reciprocal, multiply by src to produce sqrt.  */\n-  if (!recip)\n-    emit_insn (gen_mul (dst, src, x0));\n+\t      g = g1;\n+\t      h = h1;\n+\t    }\n+\t  /* Multiply by 2 for 1/rsqrt.  */\n+\t  emit_insn (gen_add3_insn (dst, h, h));\n+\t}\n+    }\n   else\n-    emit_move_insn (dst, x0);\n+    {\n+      rtx t = gen_reg_rtx (mode);\n+      rs6000_emit_nmsub (t, g, h, mhalf);\n+      rs6000_emit_madd (dst, g, t, g);\n+    }\n \n   return;\n }"}, {"sha": "d8834a2731413b4d1726e0e3623b0438526f6db2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ad45ac43e4518715f4a56a7cf92f9d73aea6ed6c", "patch": "@@ -4444,6 +4444,7 @@\n    && (TARGET_PPC_GPOPT || (<MODE>mode == SFmode && TARGET_XILINX_FPU))\"\n {\n   if (<MODE>mode == SFmode\n+      && TARGET_RECIP_PRECISION\n       && RS6000_RECIP_HAVE_RSQRTE_P (<MODE>mode)\n       && !optimize_function_for_size_p (cfun)\n       && flag_finite_math_only && !flag_trapping_math"}]}