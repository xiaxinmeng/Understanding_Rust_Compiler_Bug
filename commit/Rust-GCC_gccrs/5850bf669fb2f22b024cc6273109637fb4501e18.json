{"sha": "5850bf669fb2f22b024cc6273109637fb4501e18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg1MGJmNjY5ZmIyZjIyYjAyNGNjNjI3MzEwOTYzN2ZiNDUwMWUxOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-09-19T18:53:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-09-19T18:53:50Z"}, "message": "compiler: Pass constant arguments directly to thunk functions.\n\nFrom-SVN: r215402", "tree": {"sha": "b63efa4114cb120ea108cbe0f7bfdb24b4747405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b63efa4114cb120ea108cbe0f7bfdb24b4747405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5850bf669fb2f22b024cc6273109637fb4501e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5850bf669fb2f22b024cc6273109637fb4501e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5850bf669fb2f22b024cc6273109637fb4501e18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5850bf669fb2f22b024cc6273109637fb4501e18/comments", "author": null, "committer": null, "parents": [{"sha": "2bfbb8613327472484037c20d5fc3647e82113dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bfbb8613327472484037c20d5fc3647e82113dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bfbb8613327472484037c20d5fc3647e82113dc"}], "stats": {"total": 50, "additions": 36, "deletions": 14}, "files": [{"sha": "f8478051f94df264a6686869fc21274c6f7b17bc", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5850bf669fb2f22b024cc6273109637fb4501e18/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5850bf669fb2f22b024cc6273109637fb4501e18/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5850bf669fb2f22b024cc6273109637fb4501e18", "patch": "@@ -2178,7 +2178,11 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n       for (Expression_list::const_iterator p = ce->args()->begin();\n \t   p != ce->args()->end();\n \t   ++p)\n-\tvals->push_back(*p);\n+\t{\n+\t  if ((*p)->is_constant())\n+\t    continue;\n+\t  vals->push_back(*p);\n+\t}\n     }\n \n   // Build the struct.\n@@ -2281,6 +2285,9 @@ Thunk_statement::build_struct(Function_type* fntype)\n \t   p != args->end();\n \t   ++p, ++i)\n \t{\n+\t  if ((*p)->is_constant())\n+\t    continue;\n+\n \t  char buf[50];\n \t  this->thunk_field_param(i, buf, sizeof buf);\n \t  fields->push_back(Struct_field(Typed_identifier(buf, (*p)->type(),\n@@ -2418,21 +2425,36 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n     ++p;\n   bool is_recover_call = ce->is_recover_call();\n   Expression* recover_arg = NULL;\n-  for (; p != fields->end(); ++p, ++next_index)\n+\n+  const Expression_list* args = ce->args();\n+  if (args != NULL)\n     {\n-      Expression* thunk_param = Expression::make_var_reference(named_parameter,\n-\t\t\t\t\t\t\t       location);\n-      thunk_param = Expression::make_unary(OPERATOR_MULT, thunk_param,\n-\t\t\t\t\t   location);\n-      Expression* param = Expression::make_field_reference(thunk_param,\n-\t\t\t\t\t\t\t   next_index,\n-\t\t\t\t\t\t\t   location);\n-      if (!is_recover_call)\n-\tcall_params->push_back(param);\n-      else\n+      for (Expression_list::const_iterator arg = args->begin();\n+\t   arg != args->end();\n+\t   ++arg)\n \t{\n-\t  go_assert(call_params->empty());\n-\t  recover_arg = param;\n+\t  Expression* param;\n+\t  if ((*arg)->is_constant())\n+\t    param = *arg;\n+\t  else\n+\t    {\n+\t      Expression* thunk_param =\n+\t\tExpression::make_var_reference(named_parameter, location);\n+\t      thunk_param =\n+\t\tExpression::make_unary(OPERATOR_MULT, thunk_param, location);\n+\t      param = Expression::make_field_reference(thunk_param,\n+\t\t\t\t\t\t       next_index,\n+\t\t\t\t\t\t       location);\n+\t      ++next_index;\n+\t    }\n+\n+\t  if (!is_recover_call)\n+\t    call_params->push_back(param);\n+\t  else\n+\t    {\n+\t      go_assert(call_params->empty());\n+\t      recover_arg = param;\n+\t    }\n \t}\n     }\n "}]}