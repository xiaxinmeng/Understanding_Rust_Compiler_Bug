{"sha": "f76e50b9f88eeea7df662f42010951f45952bee7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2ZTUwYjlmODhlZWVhN2RmNjYyZjQyMDEwOTUxZjQ1OTUyYmVlNw==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-02-06T18:49:03Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2008-02-06T18:49:03Z"}, "message": "re PR c++/35049 (g++.dg/conversion/simd3.C:12: error: invalid operands to binary + (have 'float __vector__' and 'int __vector__'))\n\n2008-02-06  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/35049\n\tPR c++/35096\n\t* typeck.c (structural_comptypes): Call cp_comptypes.\n\t(comptypes): New; called from the C/C++ common bits to perform\n\tstrict checks.\n\t(cp_comptypes): Renamed from comptypes, which is already used,\n\twith a different signature, by the C++ front end.\n\t(build_reinterpret_cast_1): Call cp_comptypes.\n\t(ptr_reasonably_similar): Ditto.\n\t* decl.c (decls_match): Ditto.\n\t* cvt.c (convert_to_reference): Ditto.\n\t* cp-tree.h (same_type_p): Ditto.\n\t(same_or_base_type_p): Ditto.\n\t(comptypes): Rename to cp_comptypes.\n\t* pt.c (canonical_type_parameter): Call cp_comptypes.\n\n2008-02-06  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/35049\n\tPR c++/35096\n\t* g++.dg/ext/vector13.C: New.\n\nFrom-SVN: r132152", "tree": {"sha": "b2fa93432255d537bfd6685ef2779c940e133fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2fa93432255d537bfd6685ef2779c940e133fbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f76e50b9f88eeea7df662f42010951f45952bee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76e50b9f88eeea7df662f42010951f45952bee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f76e50b9f88eeea7df662f42010951f45952bee7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76e50b9f88eeea7df662f42010951f45952bee7/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1be5b2fbe172da17625fa4bc60328edcd45b490e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be5b2fbe172da17625fa4bc60328edcd45b490e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be5b2fbe172da17625fa4bc60328edcd45b490e"}], "stats": {"total": 85, "additions": 60, "deletions": 25}, "files": [{"sha": "3aa5e761be4bfb407786cd5458a7b50128b4711c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -1,3 +1,21 @@\n+2008-02-06  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/35049\n+\tPR c++/35096\n+\t* typeck.c (structural_comptypes): Call cp_comptypes.\n+\t(comptypes): New; called from the C/C++ common bits to perform\n+\tstrict checks.\n+\t(cp_comptypes): Renamed from comptypes, which is already used,\n+\twith a different signature, by the C++ front end.\n+\t(build_reinterpret_cast_1): Call cp_comptypes.\n+\t(ptr_reasonably_similar): Ditto.\n+\t* decl.c (decls_match): Ditto.\n+\t* cvt.c (convert_to_reference): Ditto.\n+\t* cp-tree.h (same_type_p): Ditto.\n+\t(same_or_base_type_p): Ditto.\n+\t(comptypes): Rename to cp_comptypes.\n+\t* pt.c (canonical_type_parameter): Call cp_comptypes.\n+\n 2008-02-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33553"}, {"sha": "27892b9c0fadcf73e39084aae617b821c8f16094", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -281,7 +281,7 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n    sense of `same'.  */\n #define same_type_p(TYPE1, TYPE2) \\\n-  comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n+  cp_comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n \n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n    top-level qualifiers.  */\n@@ -3744,7 +3744,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define WANT_VECTOR    32 /* vector types */\n #define WANT_ARITH\t(WANT_INT | WANT_FLOAT | WANT_VECTOR)\n \n-/* Used with comptypes, and related functions, to guide type\n+/* Used with cp_comptypes, and related functions, to guide type\n    comparison.  */\n \n #define COMPARE_STRICT\t      0 /* Just check if the types are the\n@@ -3780,7 +3780,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    is derived from TYPE1, or if TYPE2 is a pointer (reference) to a\n    class derived from the type pointed to (referred to) by TYPE1.  */\n #define same_or_base_type_p(TYPE1, TYPE2) \\\n-  comptypes ((TYPE1), (TYPE2), COMPARE_BASE)\n+  cp_comptypes ((TYPE1), (TYPE2), COMPARE_BASE)\n \n /* These macros are used to access a TEMPLATE_PARM_INDEX.  */\n #define TEMPLATE_PARM_INDEX_CAST(NODE) \\\n@@ -4764,7 +4764,7 @@ extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern int type_unknown_p\t\t\t(const_tree);\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, bool);\n-extern bool comptypes\t\t\t\t(tree, tree, int);\n+extern bool cp_comptypes\t\t\t(tree, tree, int);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qual_signature\t\t(tree, tree);"}, {"sha": "a75036f53c115353bcc1d9d41a5dd14517a52efd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -465,8 +465,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n \t meant.  */\n       if (TREE_CODE (intype) == POINTER_TYPE\n-\t  && (comptypes (TREE_TYPE (intype), type,\n-\t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n+\t  && (cp_comptypes (TREE_TYPE (intype), type,\n+                            COMPARE_BASE | COMPARE_DERIVED)))\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, reftype);\n \n@@ -604,7 +604,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t/* The call to fold will not always remove the NOP_EXPR as\n \t   might be expected, since if one of the types is a typedef;\n \t   the comparison in fold is just equality of pointers, not a\n-\t   call to comptypes.  We don't call fold in this case because\n+\t   call to cp_comptypes.  We don't call fold in this case because\n \t   that can result in infinite recursion; fold will call\n \t   convert, which will call ocp_convert, etc.  */\n \treturn e;"}, {"sha": "6b807125d9d8818268a8f2ce4d49033bcb47427c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -1015,9 +1015,9 @@ decls_match (tree newdecl, tree olddecl)\n       else if (TREE_TYPE (newdecl) == NULL_TREE)\n \ttypes_match = 0;\n       else\n-\ttypes_match = comptypes (TREE_TYPE (newdecl),\n-\t\t\t\t TREE_TYPE (olddecl),\n-\t\t\t\t COMPARE_REDECLARATION);\n+\ttypes_match = cp_comptypes (TREE_TYPE (newdecl),\n+                                    TREE_TYPE (olddecl),\n+                                    COMPARE_REDECLARATION);\n     }\n \n   return types_match;"}, {"sha": "2a8296efef0715f054a2088fb21c7cd5f80c1701", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -2905,7 +2905,7 @@ canonical_type_parameter (tree type)\n     VEC_safe_push (tree, gc, canonical_template_parms, NULL_TREE);\n \n   list = VEC_index (tree, canonical_template_parms, idx);\n-  while (list && !comptypes (type, TREE_VALUE (list), COMPARE_STRUCTURAL))\n+  while (list && !cp_comptypes (type, TREE_VALUE (list), COMPARE_STRUCTURAL))\n     list = TREE_CHAIN (list);\n \n   if (list)"}, {"sha": "9764ed369a2d68b4260d64b43c89ceb123cbd02c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -160,7 +160,7 @@ type_unknown_p (const_tree exp)\n \n \f\n /* Return the common type of two parameter lists.\n-   We assume that comptypes has already been done and returned 1;\n+   We assume that cp_comptypes has already been done and returned 1;\n    if that isn't so, this may crash.\n \n    As an optimization, free the space we allocate if the parameter\n@@ -573,7 +573,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n }\n \n /* Return the merged type of two types.\n-   We assume that comptypes has already been done and returned 1;\n+   We assume that cp_comptypes has already been done and returned 1;\n    if that isn't so, this may crash.\n \n    This just combines attributes and default arguments; any other\n@@ -735,7 +735,7 @@ merge_types (tree t1, tree t2)\n }\n \n /* Return the common type of two types.\n-   We assume that comptypes has already been done and returned 1;\n+   We assume that cp_comptypes has already been done and returned 1;\n    if that isn't so, this may crash.\n \n    This is the type for the result of most arithmetic operations\n@@ -926,7 +926,7 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n   return true;\n }\n \n-/* Subroutine in comptypes.  */\n+/* Subroutine in cp_comptypes.  */\n \n static bool\n structural_comptypes (tree t1, tree t2, int strict)\n@@ -1034,8 +1034,8 @@ structural_comptypes (tree t1, tree t2, int strict)\n       return false;\n \n     case OFFSET_TYPE:\n-      if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n-\t\t      strict & ~COMPARE_REDECLARATION))\n+      if (!cp_comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n+                         strict & ~COMPARE_REDECLARATION))\n \treturn false;\n       if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n@@ -1123,11 +1123,22 @@ structural_comptypes (tree t1, tree t2, int strict)\n   return targetm.comp_type_attributes (t1, t2);\n }\n \n+extern int comptypes (tree, tree);\n+\n+/* Type comparison function that matches the signature of comptypes\n+   from c-tree.h, which is used by the C front end and some of the\n+   C/C++ common bits.  */\n+int\n+comptypes (tree t1, tree t2)\n+{\n+  return cp_comptypes (t1, t2, COMPARE_STRICT);\n+}\n+\n /* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n    is a bitwise-or of the COMPARE_* flags.  */\n \n bool\n-comptypes (tree t1, tree t2, int strict)\n+cp_comptypes (tree t1, tree t2, int strict)\n {\n   if (strict == COMPARE_STRICT)\n     {\n@@ -1224,7 +1235,7 @@ comp_cv_qual_signature (tree type1, tree type2)\n     return 0;\n }\n \f\n-/* Subroutines of `comptypes'.  */\n+/* Subroutines of `cp_comptypes'.  */\n \n /* Return true if two parameter type lists PARMS1 and PARMS2 are\n    equivalent in the sense that functions with those parameter types\n@@ -5249,8 +5260,8 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t \"B\" are related class types; the reinterpret_cast does not\n \t adjust the pointer.  */\n       if (TYPE_PTR_P (intype)\n-\t  && (comptypes (TREE_TYPE (intype), TREE_TYPE (type),\n-\t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n+\t  && (cp_comptypes (TREE_TYPE (intype), TREE_TYPE (type),\n+                            COMPARE_BASE | COMPARE_DERIVED)))\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, type);\n \n@@ -6913,9 +6924,9 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n \treturn 0;\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n-\t  && comptypes (TYPE_OFFSET_BASETYPE (to),\n-\t\t\tTYPE_OFFSET_BASETYPE (from),\n-\t\t\tCOMPARE_BASE | COMPARE_DERIVED))\n+\t  && cp_comptypes (TYPE_OFFSET_BASETYPE (to),\n+                           TYPE_OFFSET_BASETYPE (from),\n+                           COMPARE_BASE | COMPARE_DERIVED))\n \tcontinue;\n \n       if (TREE_CODE (to) == VECTOR_TYPE\n@@ -6930,7 +6941,7 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n \treturn 1;\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n-\treturn comptypes\n+\treturn cp_comptypes\n \t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from),\n \t   COMPARE_BASE | COMPARE_DERIVED);\n     }"}, {"sha": "c1db06f86469e1d514f925340c9087dbbb88fc40", "filename": "gcc/testsuite/g++.dg/ext/vector13.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76e50b9f88eeea7df662f42010951f45952bee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector13.C?ref=f76e50b9f88eeea7df662f42010951f45952bee7", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/35096\n+// { dg-do compile }\n+\n+typedef const int X __attribute((vector_size(8)));\n+extern const int x[] __attribute((vector_size(8)));\n+X x[] = {};"}]}