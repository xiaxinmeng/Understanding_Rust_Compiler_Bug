{"sha": "b8ac4f3b22887143eec7e51497e95ff7301631df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhYzRmM2IyMjg4NzE0M2VlYzdlNTE0OTdlOTVmZjczMDE2MzFkZg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-10-25T12:28:57Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-10-25T12:28:57Z"}, "message": "re PR fortran/66927 (ICE in gfc_conf_procedure_call)\n\ngcc/fortran/ChangeLog:\n\n2015-10-25  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/66927\n\tPR fortran/67044\n\t* trans-array.c (build_array_ref): Modified call to \n\tgfc_get_class_array_ref to adhere to new interface.\n\t(gfc_conv_expr_descriptor): For one-based arrays that\n\tare filled by a loop starting at one the start index of the\n\tsource array has to be mangled into the offset.\n\t* trans-expr.c (gfc_get_class_array_ref): When the tree to get\n\tthe _data component is present already, add a way to supply it.\n\t(gfc_copy_class_to_class): Allow to copy to a derived type also.\n\t* trans-stmt.c (gfc_trans_allocate): Do not conv_expr_descriptor\n\tfor functions returning\ta class or derived object. Get the\n\treference instead.\n\t* trans.h: Interface change of gfc_get_class_array_ref.\n\ngcc/testsuite/ChangeLog:\n\n2015-10-25  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/66927\n\tPR fortran/67044\n\t* gfortran.dg/allocate_with_source_10.f08: New test.\n\t* gfortran.dg/allocate_with_source_11.f08: New test.\n\t* gfortran.dg/class_array_15.f03: Changed count of expected\n\t_builtin_frees to 11. One step of temporaries is spared, therefore\n\tthe allocatable component of that temporary is not to be freeed.\n\nFrom-SVN: r229294", "tree": {"sha": "2bf4d8a03141715e2374e096c4386e41791de20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bf4d8a03141715e2374e096c4386e41791de20e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ac4f3b22887143eec7e51497e95ff7301631df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ac4f3b22887143eec7e51497e95ff7301631df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ac4f3b22887143eec7e51497e95ff7301631df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ac4f3b22887143eec7e51497e95ff7301631df/comments", "author": null, "committer": null, "parents": [{"sha": "f63df1373912b1c8b65e34e064594c0eb15153f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63df1373912b1c8b65e34e064594c0eb15153f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63df1373912b1c8b65e34e064594c0eb15153f9"}], "stats": {"total": 171, "additions": 137, "deletions": 34}, "files": [{"sha": "1a351be0fe177961e7a380a94c2d7e28a8d9743c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -1,3 +1,20 @@\n+2015-10-25  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/66927\n+\tPR fortran/67044\t\n+\t* trans-array.c (build_array_ref): Modified call to \n+\tgfc_get_class_array_ref to adhere to new interface.\n+\t(gfc_conv_expr_descriptor): For one-based arrays that\n+\tare filled by a loop starting at one the start index of the\n+\tsource array has to be mangled into the offset.\n+\t* trans-expr.c (gfc_get_class_array_ref): When the tree to get\n+\tthe _data component is present already, add a way to supply it.\n+\t(gfc_copy_class_to_class): Allow to copy to a derived type also.\n+\t* trans-stmt.c (gfc_trans_allocate): Do not conv_expr_descriptor\n+\tfor functions returning\ta class or derived object. Get the\n+\treference instead.\n+\t* trans.h: Interface change of gfc_get_class_array_ref.\n+\n 2015-10-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68055"}, {"sha": "45c18a5b41840c0610ec5417f42c78c98fd1132c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -3250,7 +3250,7 @@ build_array_ref (tree desc, tree offset, tree decl, tree vptr)\n     {\n       type = gfc_get_element_type (type);\n       tmp = TREE_OPERAND (cdecl, 0);\n-      tmp = gfc_get_class_array_ref (offset, tmp);\n+      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE);\n       tmp = fold_convert (build_pointer_type (type), tmp);\n       tmp = build_fold_indirect_ref_loc (input_location, tmp);\n       return tmp;\n@@ -7107,9 +7107,20 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t    }\n \t  else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)) || se->use_offset)\n \t    {\n+\t      bool toonebased;\n \t      tmp = gfc_conv_array_lbound (desc, n);\n+\t      toonebased = integer_onep (tmp);\n+\t      // lb(arr) - from (- start + 1)\n \t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t     TREE_TYPE (base), tmp, from);\n+\t      if (onebased && toonebased)\n+\t\t{\n+\t\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t TREE_TYPE (base), tmp, start);\n+\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t TREE_TYPE (base), tmp,\n+\t\t\t\t\t gfc_index_one_node);\n+\t\t}\n \t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t     TREE_TYPE (base), tmp,\n \t\t\t\t     gfc_conv_array_stride (desc, n));\n@@ -7183,12 +7194,13 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n   /* For class arrays add the class tree into the saved descriptor to\n      enable getting of _vptr and the like.  */\n   if (expr->expr_type == EXPR_VARIABLE && VAR_P (desc)\n-      && IS_CLASS_ARRAY (expr->symtree->n.sym)\n-      && DECL_LANG_SPECIFIC (expr->symtree->n.sym->backend_decl))\n+      && IS_CLASS_ARRAY (expr->symtree->n.sym))\n     {\n       gfc_allocate_lang_decl (desc);\n       GFC_DECL_SAVED_DESCRIPTOR (desc) =\n-\t  GFC_DECL_SAVED_DESCRIPTOR (expr->symtree->n.sym->backend_decl);\n+\t  DECL_LANG_SPECIFIC (expr->symtree->n.sym->backend_decl) ?\n+\t    GFC_DECL_SAVED_DESCRIPTOR (expr->symtree->n.sym->backend_decl)\n+\t  : expr->symtree->n.sym->backend_decl;\n     }\n   if (!se->direct_byref || se->byref_noassign)\n     {"}, {"sha": "9585de6284d6ecaf49fa1812d0aa0aeb8c063b24", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -1039,9 +1039,10 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n    of the referenced element.  */\n \n tree\n-gfc_get_class_array_ref (tree index, tree class_decl)\n+gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp)\n {\n-  tree data = gfc_class_data_get (class_decl);\n+  tree data = data_comp != NULL_TREE ? data_comp :\n+\t\t\t\t       gfc_class_data_get (class_decl);\n   tree size = gfc_class_vtab_size_get (class_decl);\n   tree offset = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t gfc_array_index_type,\n@@ -1075,6 +1076,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n   tree stdcopy;\n   tree extcopy;\n   tree index;\n+  bool is_from_desc = false, is_to_class = false;\n \n   args = NULL;\n   /* To prevent warnings on uninitialized variables.  */\n@@ -1088,7 +1090,19 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n   fcn_type = TREE_TYPE (TREE_TYPE (fcn));\n \n   if (from != NULL_TREE)\n-    from_data = gfc_class_data_get (from);\n+    {\n+      is_from_desc = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from));\n+      if (is_from_desc)\n+\t{\n+\t  from_data = from;\n+\t  from = GFC_DECL_SAVED_DESCRIPTOR (from);\n+\t}\n+      else\n+\t{\n+\t  from_data = gfc_class_data_get (from);\n+\t  is_from_desc = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data));\n+\t}\n+     }\n   else\n     from_data = gfc_class_vtab_def_init_get (to);\n \n@@ -1100,9 +1114,16 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \tfrom_len = integer_zero_node;\n     }\n \n-  to_data = gfc_class_data_get (to);\n-  if (unlimited)\n-    to_len = gfc_class_len_get (to);\n+  if (GFC_CLASS_TYPE_P (TREE_TYPE (to)))\n+    {\n+      is_to_class = true;\n+      to_data = gfc_class_data_get (to);\n+      if (unlimited)\n+\tto_len = gfc_class_len_get (to);\n+    }\n+  else\n+    /* When to is a BT_DERIVED and not a BT_CLASS, then to_data == to.  */\n+    to_data = to;\n \n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (to_data)))\n     {\n@@ -1118,15 +1139,23 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       nelems = gfc_evaluate_now (tmp, &body);\n       index = gfc_create_var (gfc_array_index_type, \"S\");\n \n-      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)))\n+      if (is_from_desc)\n \t{\n-\t  from_ref = gfc_get_class_array_ref (index, from);\n+\t  from_ref = gfc_get_class_array_ref (index, from, from_data);\n \t  vec_safe_push (args, from_ref);\n \t}\n       else\n         vec_safe_push (args, from_data);\n \n-      to_ref = gfc_get_class_array_ref (index, to);\n+      if (is_to_class)\n+\tto_ref = gfc_get_class_array_ref (index, to, to_data);\n+      else\n+\t{\n+\t  tmp = gfc_conv_array_data (to);\n+\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t  to_ref = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\tgfc_build_array_ref (tmp, index, to));\n+\t}\n       vec_safe_push (args, to_ref);\n \n       tmp = build_call_vec (fcn_type, fcn, args);\n@@ -1183,7 +1212,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n     }\n   else\n     {\n-      gcc_assert (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)));\n+      gcc_assert (!is_from_desc);\n       vec_safe_push (args, from_data);\n       vec_safe_push (args, to_data);\n       stdcopy = build_call_vec (fcn_type, fcn, args);"}, {"sha": "1bd131e7f8b2af6425f4e51bdd397a9598805cb5", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -5186,9 +5186,16 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* In all other cases evaluate the expr3.  */\n \t  symbol_attribute attr;\n \t  /* Get the descriptor for all arrays, that are not allocatable or\n-\t     pointer, because the latter are descriptors already.  */\n+\t     pointer, because the latter are descriptors already.\n+\t     The exception are function calls returning a class object:\n+\t     The descriptor is stored in their results _data component, which\n+\t     is easier to access, when first a temporary variable for the\n+\t     result is created and the descriptor retrieved from there.  */\n \t  attr = gfc_expr_attr (code->expr3);\n-\t  if (code->expr3->rank != 0 && !attr.allocatable && !attr.pointer)\n+\t  if (code->expr3->rank != 0\n+\t      && ((!attr.allocatable && !attr.pointer)\n+\t\t  || (code->expr3->expr_type == EXPR_FUNCTION\n+\t\t      && code->expr3->ts.type != BT_CLASS)))\n \t    gfc_conv_expr_descriptor (&se, code->expr3);\n \t  else\n \t    gfc_conv_expr_reference (&se, code->expr3);\n@@ -5205,17 +5212,40 @@ gfc_trans_allocate (gfc_code * code)\n \t     variable declaration.  */\n       if (se.expr != NULL_TREE && temp_var_needed)\n \t{\n-\t  tree var;\n+\t  tree var, desc;\n \t  tmp = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)) ?\n \t\tse.expr\n \t      : build_fold_indirect_ref_loc (input_location, se.expr);\n+\n+\t  /* Get the array descriptor and prepare it to be assigned to the\n+\t     temporary variable var.  For classes the array descriptor is\n+\t     in the _data component and the object goes into the\n+\t     GFC_DECL_SAVED_DESCRIPTOR.  */\n+\t  if (code->expr3->ts.type == BT_CLASS\n+\t      && code->expr3->rank != 0)\n+\t    {\n+\t      /* When an array_ref was in expr3, then the descriptor is the\n+\t\t first operand.  */\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t\t{\n+\t\t  desc = TREE_OPERAND (tmp, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  desc = tmp;\n+\t\t  tmp = gfc_class_data_get (tmp);\n+\t\t}\n+\t      e3_is = E3_DESC;\n+\t    }\n+\t  else\n+\t    desc = se.expr;\n \t  /* We need a regular (non-UID) symbol here, therefore give a\n \t     prefix.  */\n \t  var = gfc_create_var (TREE_TYPE (tmp), \"source\");\n-\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n \t    {\n \t      gfc_allocate_lang_decl (var);\n-\t      GFC_DECL_SAVED_DESCRIPTOR (var) = se.expr;\n+\t      GFC_DECL_SAVED_DESCRIPTOR (var) = desc;\n \t    }\n \t  gfc_add_modify_loc (input_location, &block, var, tmp);\n \n@@ -5241,11 +5271,12 @@ gfc_trans_allocate (gfc_code * code)\n \t  expr3_len = se.string_length;\n \t}\n       /* Store what the expr3 is to be used for.  */\n-      e3_is = expr3 != NULL_TREE ?\n-\t    (code->ext.alloc.arr_spec_from_expr3 ?\n-\t       E3_DESC\n-\t     : (code->expr3->mold ? E3_MOLD : E3_SOURCE))\n-\t  : E3_UNSET;\n+      if (e3_is == E3_UNSET)\n+\te3_is = expr3 != NULL_TREE ?\n+\t      (code->ext.alloc.arr_spec_from_expr3 ?\n+\t\t E3_DESC\n+\t       : (code->expr3->mold ? E3_MOLD : E3_SOURCE))\n+\t    : E3_UNSET;\n \n       /* Figure how to get the _vtab entry.  This also obtains the tree\n \t expression for accessing the _len component, because only\n@@ -5254,11 +5285,17 @@ gfc_trans_allocate (gfc_code * code)\n       if (code->expr3->ts.type == BT_CLASS)\n \t{\n \t  gfc_expr *rhs;\n+\t  tmp = expr3 != NULL_TREE && POINTER_TYPE_P (TREE_TYPE (expr3)) ?\n+\t\tbuild_fold_indirect_ref (expr3): expr3;\n \t  /* Polymorphic SOURCE: VPTR must be determined at run time.\n \t     expr3 may be a temporary array declaration, therefore check for\n \t     GFC_CLASS_TYPE_P before trying to get the _vptr component.  */\n-\t  if (expr3 != NULL_TREE && GFC_CLASS_TYPE_P (TREE_TYPE (expr3))\n-\t      && (VAR_P (expr3) || !code->expr3->ref))\n+\t  if (tmp != NULL_TREE\n+\t      && TREE_CODE (tmp) != POINTER_PLUS_EXPR\n+\t      && (e3_is == E3_DESC\n+\t\t  || (GFC_CLASS_TYPE_P (TREE_TYPE (tmp))\n+\t\t      && (VAR_P (tmp) || !code->expr3->ref))\n+\t\t  || (VAR_P (tmp) && DECL_LANG_SPECIFIC (tmp))))\n \t    tmp = gfc_class_vptr_get (expr3);\n \t  else\n \t    {\n@@ -5709,10 +5746,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Initialization via SOURCE block (or static default initializer).\n \t     Classes need some special handling, so catch them first.  */\n \t  if (expr3 != NULL_TREE\n-\t      && ((POINTER_TYPE_P (TREE_TYPE (expr3))\n-\t\t   && TREE_CODE (expr3) != POINTER_PLUS_EXPR)\n-\t\t  || (VAR_P (expr3) && GFC_CLASS_TYPE_P (\n-\t\t\tTREE_TYPE (expr3))))\n+\t      && TREE_CODE (expr3) != POINTER_PLUS_EXPR\n \t      && code->expr3->ts.type == BT_CLASS\n \t      && (expr->ts.type == BT_CLASS\n \t\t  || expr->ts.type == BT_DERIVED))\n@@ -5731,7 +5765,7 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_expr *ppc;\n \t      gfc_code *ppc_code;\n \t      gfc_ref *ref, *dataref;\n-\t      gfc_expr *rhs = gfc_copy_expr (code->expr3);\n+\t      gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);\n \n \t      /* Do a polymorphic deep copy.  */\n \t      actual = gfc_get_actual_arglist ();\n@@ -5827,7 +5861,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t\t}\n \t      gfc_free_statements (ppc_code);\n-\t      gfc_free_expr (rhs);\n+\t      if (rhs != e3rhs)\n+\t\tgfc_free_expr (rhs);\n \t    }\n \t  else\n \t    {"}, {"sha": "3a23a3cc259e6c456b98365b22c7fb370eb4cd37", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -378,7 +378,7 @@ tree gfc_vptr_final_get (tree);\n void gfc_reset_vptr (stmtblock_t *, gfc_expr *);\n void gfc_reset_len (stmtblock_t *, gfc_expr *);\n tree gfc_get_vptr_from_expr (tree);\n-tree gfc_get_class_array_ref (tree, tree);\n+tree gfc_get_class_array_ref (tree, tree, tree);\n tree gfc_copy_class_to_class (tree, tree, tree, bool);\n bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);"}, {"sha": "ad895f038a625595f8f247128f77ac0baebacbdc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -1,3 +1,13 @@\n+2015-10-25  Andre Vehreschild  <vehre@gmx.de>\n+\n+        PR fortran/66927\n+        PR fortran/67044\n+\t* gfortran.dg/allocate_with_source_10.f08: New test.\n+\t* gfortran.dg/allocate_with_source_11.f08: New test.\n+\t* gfortran.dg/class_array_15.f03: Changed count of expected\n+\t_builtin_frees to 11. One step of temporaries is spared, therefore\n+\tthe allocatable component of that temporary is not to be freeed.\n+\n 2015-10-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68055"}, {"sha": "85716f905cb20e7bd87abcf609d268737a762bea", "filename": "gcc/testsuite/gfortran.dg/class_array_15.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ac4f3b22887143eec7e51497e95ff7301631df/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03?ref=b8ac4f3b22887143eec7e51497e95ff7301631df", "patch": "@@ -115,4 +115,4 @@ subroutine pr54992  ! This test remains as the original.\n   bh => bhGet(b,instance=2)\n   if (loc (b) .ne. loc(bh%hostNode)) call abort\n end\n-! { dg-final { scan-tree-dump-times \"builtin_free\" 12 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 11 \"original\" } }"}]}