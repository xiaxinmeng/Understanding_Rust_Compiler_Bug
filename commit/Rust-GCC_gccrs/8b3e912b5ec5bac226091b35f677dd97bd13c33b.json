{"sha": "8b3e912b5ec5bac226091b35f677dd97bd13c33b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIzZTkxMmI1ZWM1YmFjMjI2MDkxYjM1ZjY3N2RkOTdiZDEzYzMzYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-11T22:25:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-11T22:25:08Z"}, "message": "(reload): When accumulating needs, use nested structures to simplify\nand speed up the code.\n\nFrom-SVN: r7038", "tree": {"sha": "8d421e292ac8dfba9e8bae0335e8b59cc06ff6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d421e292ac8dfba9e8bae0335e8b59cc06ff6cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b3e912b5ec5bac226091b35f677dd97bd13c33b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3e912b5ec5bac226091b35f677dd97bd13c33b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3e912b5ec5bac226091b35f677dd97bd13c33b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3e912b5ec5bac226091b35f677dd97bd13c33b/comments", "author": null, "committer": null, "parents": [{"sha": "1c2bdc600335e005b891b65c98e9c3087fd9c9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c2bdc600335e005b891b65c98e9c3087fd9c9c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c2bdc600335e005b891b65c98e9c3087fd9c9c4"}], "stats": {"total": 414, "additions": 126, "deletions": 288}, "files": [{"sha": "909fd75ed7582c37b7db3ad88c82ec1e88562eea", "filename": "gcc/reload1.c", "status": "modified", "additions": 126, "deletions": 288, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3e912b5ec5bac226091b35f677dd97bd13c33b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3e912b5ec5bac226091b35f677dd97bd13c33b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8b3e912b5ec5bac226091b35f677dd97bd13c33b", "patch": "@@ -441,7 +441,7 @@ reload (first, global, dumpfile)\n      FILE *dumpfile;\n {\n   register int class;\n-  register int i, j;\n+  register int i, j, k;\n   register rtx insn;\n   register struct elim_table *ep;\n \n@@ -907,7 +907,6 @@ reload (first, global, dumpfile)\n \t      int old_code = INSN_CODE (insn);\n  \t      rtx old_notes = REG_NOTES (insn);\n \t      int did_elimination = 0;\n-\t      int max_total_input_groups = 0, max_total_output_groups = 0;\n \n \t      /* To compute the number of reload registers of each class \n \t\t needed for an insn, we must similate what choose_reload_regs\n@@ -927,73 +926,24 @@ reload (first, global, dumpfile)\n \t\t The total number of registers needed is the maximum of the\n \t\t inputs and outputs.  */\n \n-\t      /* These just count RELOAD_OTHER.  */\n-\t      int insn_needs[N_REG_CLASSES];\n-\t      int insn_groups[N_REG_CLASSES];\n-\t      int insn_nongroups[N_REG_CLASSES];\n-\t      int insn_total_groups = 0;\n-\n-\t      /* Count RELOAD_FOR_INPUT reloads.  */\n-\t      int insn_needs_for_inputs[N_REG_CLASSES];\n-\t      int insn_nongroups_for_inputs[N_REG_CLASSES];\n-\t      int insn_groups_for_inputs[N_REG_CLASSES];\n-\t      int insn_total_groups_for_inputs = 0;\n-\n-\t      /* Count RELOAD_FOR_OUTPUT reloads.  */\n-\t      int insn_needs_for_outputs[N_REG_CLASSES];\n-\t      int insn_nongroups_for_outputs[N_REG_CLASSES];\n-\t      int insn_groups_for_outputs[N_REG_CLASSES];\n-\t      int insn_total_groups_for_outputs = 0;\n-\n-\t      /* Count RELOAD_FOR_INSN reloads.  */\n-\t      int insn_needs_for_insn[N_REG_CLASSES];\n-\t      int insn_nongroups_for_insn[N_REG_CLASSES];\n-\t      int insn_groups_for_insn[N_REG_CLASSES];\n-\t      int insn_total_groups_for_insn = 0;\n-\n-\t      /* Count RELOAD_FOR_OTHER_ADDRESS reloads.  */\n-\t      int insn_needs_for_other_addr[N_REG_CLASSES];\n-\t      int insn_nongroups_for_other_addr[N_REG_CLASSES];\n-\t      int insn_groups_for_other_addr[N_REG_CLASSES];\n-\t      int insn_total_groups_for_other_addr = 0;\n-\n-\t      /* Count RELOAD_FOR_INPUT_ADDRESS reloads.  */\n-\t      int insn_needs_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_nongroups_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_groups_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_total_groups_for_in_addr[MAX_RECOG_OPERANDS];\n-\n-\t      /* Count RELOAD_FOR_OUTPUT_ADDRESS reloads.  */\n-\t      int insn_needs_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_nongroups_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_groups_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n-\t      int insn_total_groups_for_out_addr[MAX_RECOG_OPERANDS];\n-\n-\t      /* Count RELOAD_FOR_OPERAND_ADDRESS reloads.  */\n-\t      int insn_needs_for_op_addr[N_REG_CLASSES];\n-\t      int insn_nongroups_for_op_addr[N_REG_CLASSES];\n-\t      int insn_groups_for_op_addr[N_REG_CLASSES];\n-\t      int insn_total_groups_for_op_addr = 0;\n-\n-#if 0  /* This wouldn't work nowadays, since optimize_bit_field\n-\t  looks for non-strict memory addresses.  */\n-\t      /* Optimization: a bit-field instruction whose field\n-\t\t happens to be a byte or halfword in memory\n-\t\t can be changed to a move instruction.  */\n-\n-\t      if (GET_CODE (PATTERN (insn)) == SET)\n+\t      struct needs\n \t\t{\n-\t\t  rtx dest = SET_DEST (PATTERN (insn));\n-\t\t  rtx src = SET_SRC (PATTERN (insn));\n-\n-\t\t  if (GET_CODE (dest) == ZERO_EXTRACT\n-\t\t      || GET_CODE (dest) == SIGN_EXTRACT)\n-\t\t    optimize_bit_field (PATTERN (insn), insn, reg_equiv_mem);\n-\t\t  if (GET_CODE (src) == ZERO_EXTRACT\n-\t\t      || GET_CODE (src) == SIGN_EXTRACT)\n-\t\t    optimize_bit_field (PATTERN (insn), insn, reg_equiv_mem);\n-\t\t}\n-#endif\n+\t\t  /* [0] is normal, [1] is nongroup.  */\n+\t\t  int regs[2][N_REG_CLASSES];\n+\t\t  int groups[N_REG_CLASSES];\n+\t\t};\n+\n+\t      /* Each `struct needs' corresponds to one RELOAD_... type.  */\n+\t      struct {\n+\t\tstruct needs other;\n+\t\tstruct needs input;\n+\t\tstruct needs output;\n+\t\tstruct needs insn;\n+\t\tstruct needs other_addr;\n+\t\tstruct needs op_addr;\n+\t\tstruct needs in_addr[MAX_RECOG_OPERANDS];\n+\t\tstruct needs out_addr[MAX_RECOG_OPERANDS];\n+\t      } insn_needs;\n \n \t      /* If needed, eliminate any eliminable registers.  */\n \t      if (num_eliminable)\n@@ -1065,49 +1015,8 @@ reload (first, global, dumpfile)\n \t\tcontinue;\n \n \t      something_needs_reloads = 1;\n+\t      bzero (&insn_needs, sizeof insn_needs);\n \n-\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t{\n-\t\t  insn_needs[i] = 0, insn_nongroups[i] = 0, \n-\t\t  insn_groups[i] = 0;\n-\n-\t\t  insn_needs_for_inputs[i] = 0, \n-\t\t  insn_nongroups_for_inputs[i] = 0,\n-\t\t  insn_groups_for_inputs[i] = 0;\n-\n-\t\t  insn_needs_for_outputs[i] = 0, \n-\t\t  insn_nongroups_for_outputs[i] = 0,\n-\t\t  insn_groups_for_outputs[i] = 0;\n-\n-\t\t  insn_needs_for_insn[i] = 0, \n-\t\t  insn_nongroups_for_insn[i] = 0,\n-\t\t  insn_groups_for_insn[i] = 0;\n-\n-\t\t  insn_needs_for_op_addr[i] = 0, \n-\t\t  insn_nongroups_for_op_addr[i] = 0,\n-\t\t  insn_groups_for_op_addr[i] = 0;\n-\n-\t\t  insn_needs_for_other_addr[i] = 0, \n-\t\t  insn_nongroups_for_other_addr[i] = 0,\n-\t\t  insn_groups_for_other_addr[i] = 0;\n-\t\t}\n-\n-\t      for (i = 0; i < reload_n_operands; i++)\n-\t\t{\n-\t\t  insn_total_groups_for_in_addr[i] = 0;\n-\t\t  insn_total_groups_for_out_addr[i] = 0;\n-\n-\t\t  for (j = 0; j < N_REG_CLASSES; j++)\n-\t\t    {\n-\t\t      insn_needs_for_in_addr[i][j] = 0;\n-\t\t      insn_needs_for_out_addr[i][j] = 0;\n-\t\t      insn_nongroups_for_in_addr[i][j] = 0;\n-\t\t      insn_nongroups_for_out_addr[i][j] = 0;\n-\t\t      insn_groups_for_in_addr[i][j] = 0;\n-\t\t      insn_groups_for_out_addr[i][j] = 0;\n-\t\t    }\n-\t\t}\n-\t\t    \n \t      /* Count each reload once in every class\n \t\t containing the reload's own class.  */\n \n@@ -1118,9 +1027,7 @@ reload (first, global, dumpfile)\n \t\t  int size;\n \t\t  enum machine_mode mode;\n \t\t  int nongroup_need;\n-\t\t  int *this_groups;\n-\t\t  int *this_needs;\n-\t\t  int *this_total_groups;\n+\t\t  struct needs *this_needs;\n \n \t\t  /* Don't count the dummy reloads, for which one of the\n \t\t     regs mentioned in the insn can be used for reloading.\n@@ -1148,11 +1055,10 @@ reload (first, global, dumpfile)\n \t\t    mode = reload_outmode[i];\n \t\t  size = CLASS_MAX_NREGS (class, mode);\n \n-\t\t  /* If this class doesn't want a group determine if\n-\t\t     we have a nongroup need or a regular need.  We have\n-\t\t     a nongroup need if this reload conflicts with a\n-\t\t     group reload whose class intersects with this reload's\n-\t\t     class.  */\n+\t\t  /* If this class doesn't want a group, determine if we have\n+\t\t     a nongroup need or a regular need.  We have a nongroup\n+\t\t     need if this reload conflicts with a group reload whose\n+\t\t     class intersects with this reload's class.  */\n \n \t\t  nongroup_need = 0;\n \t\t  if (size == 1)\n@@ -1175,77 +1081,28 @@ reload (first, global, dumpfile)\n \t\t  switch (reload_when_needed[i])\n \t\t    {\n \t\t    case RELOAD_OTHER:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs;\n-\t\t      this_groups = insn_groups;\n-\t\t      this_total_groups = &insn_total_groups;\n+\t\t      this_needs = &insn_needs.other;\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_INPUT:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_inputs;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_inputs;\n-\t\t      this_groups = insn_groups_for_inputs;\n-\t\t      this_total_groups = &insn_total_groups_for_inputs;\n+\t\t      this_needs = &insn_needs.input;\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_OUTPUT:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_outputs;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_outputs;\n-\t\t      this_groups = insn_groups_for_outputs;\n-\t\t      this_total_groups = &insn_total_groups_for_outputs;\n+\t\t      this_needs = &insn_needs.output;\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_INSN:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_insn;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_insn;\n-\t\t      this_groups = insn_groups_for_insn;\n-\t\t      this_total_groups = &insn_total_groups_for_insn;\n+\t\t      this_needs = &insn_needs.insn;\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_other_addr;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_other_addr;\n-\t\t      this_groups = insn_groups_for_other_addr;\n-\t\t      this_total_groups = &insn_total_groups_for_other_addr;\n+\t\t      this_needs = &insn_needs.other_addr;\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_in_addr[reload_opnum[i]];\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_in_addr[reload_opnum[i]];\n-\t\t      this_groups = insn_groups_for_in_addr[reload_opnum[i]];\n-\t\t      this_total_groups\n-\t\t\t= &insn_total_groups_for_in_addr[reload_opnum[i]];\n+\t\t      this_needs = &insn_needs.in_addr[reload_opnum[i]];\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_out_addr[reload_opnum[i]];\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_out_addr[reload_opnum[i]];\n-\t\t      this_groups = insn_groups_for_out_addr[reload_opnum[i]];\n-\t\t      this_total_groups\n-\t\t\t= &insn_total_groups_for_out_addr[reload_opnum[i]];\n+\t\t      this_needs = &insn_needs.out_addr[reload_opnum[i]];\n \t\t      break;\n-\n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t      if (nongroup_need)\n-\t\t\tthis_needs = insn_nongroups_for_op_addr;\n-\t\t      else\n-\t\t\tthis_needs = insn_needs_for_op_addr;\n-\t\t      this_groups = insn_groups_for_op_addr;\n-\t\t      this_total_groups = &insn_total_groups_for_op_addr;\n+\t\t      this_needs = &insn_needs.op_addr;\n \t\t      break;\n \t\t    }\n \n@@ -1255,11 +1112,10 @@ reload (first, global, dumpfile)\n \n \t\t      /* Count number of groups needed separately from\n \t\t\t number of individual regs needed.  */\n-\t\t      this_groups[(int) class]++;\n+\t\t      this_needs->groups[(int) class]++;\n \t\t      p = reg_class_superclasses[(int) class];\n \t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tthis_groups[(int) *p++]++;\n-\t\t      (*this_total_groups)++;\n+\t\t\tthis_needs->groups[(int) *p++]++;\n \n \t\t      /* Record size and mode of a group of this class.  */\n \t\t      /* If more than one size group is needed,\n@@ -1281,19 +1137,17 @@ reload (first, global, dumpfile)\n \t\t      /* Crash if two dissimilar machine modes both need\n \t\t\t groups of consecutive regs of the same class.  */\n \n-\t\t      if (other_mode != VOIDmode\n-\t\t\t  && other_mode != allocate_mode\n+\t\t      if (other_mode != VOIDmode && other_mode != allocate_mode\n \t\t\t  && ! modes_equiv_for_class_p (allocate_mode,\n-\t\t\t\t\t\t\tother_mode,\n-\t\t\t\t\t\t\tclass))\n+\t\t\t\t\t\t\tother_mode, class))\n \t\t\tabort ();\n \t\t    }\n \t\t  else if (size == 1)\n \t\t    {\n-\t\t      this_needs[(int) class] += 1;\n+\t\t      this_needs->regs[nongroup_need][(int) class] += 1;\n \t\t      p = reg_class_superclasses[(int) class];\n \t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tthis_needs[(int) *p++] += 1;\n+\t\t\tthis_needs->regs[nongroup_need][(int) *p++] += 1;\n \t\t    }\n \t\t  else\n \t\t    abort ();\n@@ -1308,102 +1162,66 @@ reload (first, global, dumpfile)\n \t\t{\n \t\t  int in_max, out_max;\n \n-\t\t  for (in_max = 0, out_max = 0, j = 0;\n-\t\t       j < reload_n_operands; j++)\n+\t\t  /* Compute normal and nongroup needs.  */\n+\t\t  for (j = 0; j <= 1; j++)\n \t\t    {\n-\t\t      in_max = MAX (in_max, insn_needs_for_in_addr[j][i]);\n-\t\t      out_max = MAX (out_max, insn_needs_for_out_addr[j][i]);\n-\t\t    }\n+\t\t      for (in_max = 0, out_max = 0, k = 0;\n+\t\t\t   k < reload_n_operands; k++)\n+\t\t\t{\n+\t\t\t  in_max\n+\t\t\t    = MAX (in_max, insn_needs.in_addr[k].regs[j][i]);\n+\t\t\t  out_max\n+\t\t\t    = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n+\t\t\t}\n \n-\t\t  /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n-\t\t     and operand addresses but not things used to reload them.\n-\t\t     Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads don't\n-\t\t     conflict with things needed to reload inputs or\n-\t\t     outputs. */\n+\t\t      /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n+\t\t\t and operand addresses but not things used to reload\n+\t\t\t them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads\n+\t\t\t don't conflict with things needed to reload inputs or\n+\t\t\t outputs. */\n \n-\t\t  in_max = MAX (in_max, insn_needs_for_op_addr[i]);\n-\t\t  out_max = MAX (out_max, insn_needs_for_insn[i]);\n+\t\t      in_max = MAX (in_max, insn_needs.op_addr.regs[j][i]);\n+\t\t      out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n \n-\t\t  insn_needs_for_inputs[i]\n-\t\t    = MAX (insn_needs_for_inputs[i]\n-\t\t\t   + insn_needs_for_op_addr[i]\n-\t\t\t   + insn_needs_for_insn[i],\n-\t\t\t   in_max + insn_needs_for_inputs[i]);\n+\t\t      insn_needs.input.regs[j][i]\n+\t\t\t= MAX (insn_needs.input.regs[j][i]\n+\t\t\t       + insn_needs.op_addr.regs[j][i]\n+\t\t\t       + insn_needs.insn.regs[j][i],\n+\t\t\t       in_max + insn_needs.input.regs[j][i]);\n \n-\t\t  insn_needs_for_outputs[i] += out_max;\n-\t\t  insn_needs[i] += MAX (MAX (insn_needs_for_inputs[i],\n-\t\t\t\t\t     insn_needs_for_outputs[i]),\n-\t\t\t\t\tinsn_needs_for_other_addr[i]);\n+\t\t      insn_needs.output.regs[j][i] += out_max;\n+\t\t      insn_needs.other.regs[j][i]\n+\t\t\t+= MAX (MAX (insn_needs.input.regs[j][i],\n+\t\t\t\t     insn_needs.output.regs[j][i]),\n+\t\t\t\tinsn_needs.other_addr.regs[j][i]);\n \n-\t\t  for (in_max = 0, out_max = 0, j = 0;\n-\t\t       j < reload_n_operands; j++)\n-\t\t    {\n-\t\t      in_max = MAX (in_max, insn_nongroups_for_in_addr[j][i]);\n-\t\t      out_max = MAX (out_max, insn_nongroups_for_out_addr[j][i]);\n \t\t    }\n \n-\t\t  in_max = MAX (in_max, insn_nongroups_for_op_addr[i]);\n-\t\t  out_max = MAX (out_max, insn_nongroups_for_insn[i]);\n-\n-\t\t  insn_nongroups_for_inputs[i]\n-\t\t    = MAX (insn_nongroups_for_inputs[i]\n-\t\t\t   + insn_nongroups_for_op_addr[i]\n-\t\t\t   + insn_nongroups_for_insn[i],\n-\t\t\t   in_max + insn_nongroups_for_inputs[i]);\n-\n-\t\t  insn_nongroups_for_outputs[i] += out_max;\n-\t\t  insn_nongroups[i] += MAX (MAX (insn_nongroups_for_inputs[i],\n-\t\t\t\t\t\t insn_nongroups_for_outputs[i]),\n-\t\t\t\t\t    insn_nongroups_for_other_addr[i]);\n-\n+\t\t  /* Now compute group needs.  */\n \t\t  for (in_max = 0, out_max = 0, j = 0;\n \t\t       j < reload_n_operands; j++)\n \t\t    {\n-\t\t      in_max = MAX (in_max, insn_groups_for_in_addr[j][i]);\n-\t\t      out_max = MAX (out_max, insn_groups_for_out_addr[j][i]);\n+\t\t      in_max = MAX (in_max, insn_needs.in_addr[j].groups[i]);\n+\t\t      out_max\n+\t\t\t= MAX (out_max, insn_needs.out_addr[j].groups[i]);\n \t\t    }\n \n-\t\t  in_max = MAX (in_max, insn_groups_for_op_addr[i]);\n-\t\t  out_max = MAX (out_max, insn_groups_for_insn[i]);\n+\t\t  in_max = MAX (in_max, insn_needs.op_addr.groups[i]);\n+\t\t  out_max = MAX (out_max, insn_needs.insn.groups[i]);\n \n-\t\t  insn_groups_for_inputs[i]\n-\t\t    = MAX (insn_groups_for_inputs[i]\n-\t\t\t   + insn_groups_for_op_addr[i]\n-\t\t\t   + insn_groups_for_insn[i],\n-\t\t\t   in_max + insn_groups_for_inputs[i]);\n+\t\t  insn_needs.input.groups[i]\n+\t\t    = MAX (insn_needs.input.groups[i]\n+\t\t\t   + insn_needs.op_addr.groups[i]\n+\t\t\t   + insn_needs.insn.groups[i],\n+\t\t\t   in_max + insn_needs.input.groups[i]);\n \n-\t\t  insn_groups_for_outputs[i] += out_max;\n-\t\t  insn_groups[i] += MAX (MAX (insn_groups_for_inputs[i],\n-\t\t\t\t\t      insn_groups_for_outputs[i]),\n-\t\t\t\t\t insn_groups_for_other_addr[i]);\n+\t\t  insn_needs.output.groups[i] += out_max;\n+\t\t  insn_needs.other.groups[i]\n+\t\t    += MAX (MAX (insn_needs.input.groups[i],\n+\t\t\t\t insn_needs.output.groups[i]),\n+\t\t\t    insn_needs.other_addr.groups[i]);\n \t\t}\n \n-\t      for (i = 0; i < reload_n_operands; i++)\n-\t\t{\n-\t\t  max_total_input_groups\n-\t\t    = MAX (max_total_input_groups,\n-\t\t\t   insn_total_groups_for_in_addr[i]);\n-\t\t  max_total_output_groups\n-\t\t    = MAX (max_total_output_groups,\n-\t\t\t   insn_total_groups_for_out_addr[i]);\n-\t\t}\n-\n-\t      max_total_input_groups = MAX (max_total_input_groups,\n-\t\t\t\t\t    insn_total_groups_for_op_addr);\n-\t      max_total_output_groups = MAX (max_total_output_groups,\n-\t\t\t\t\t     insn_total_groups_for_insn);\n-\n-\t      insn_total_groups_for_inputs\n-\t\t= MAX (max_total_input_groups + insn_total_groups_for_op_addr\n-\t\t       + insn_total_groups_for_insn,\n-\t\t       max_total_input_groups + insn_total_groups_for_inputs);\n-\n-\t      insn_total_groups_for_outputs += max_total_output_groups;\n-\n-\t      insn_total_groups += MAX (MAX (insn_total_groups_for_outputs,\n-\t\t\t\t\t     insn_total_groups_for_inputs),\n-\t\t\t\t\tinsn_total_groups_for_other_addr);\n-\n \t      /* If this is a CALL_INSN and caller-saves will need\n \t\t a spill register, act as if the spill register is\n \t\t needed for this insn.   However, the spill register\n@@ -1423,8 +1241,29 @@ reload (first, global, dumpfile)\n \t      if (GET_CODE (insn) == CALL_INSN\n \t\t  && caller_save_spill_class != NO_REGS)\n \t\t{\n-\t\t  int *caller_save_needs\n-\t\t    = (caller_save_group_size > 1 ? insn_groups : insn_needs);\n+\t\t  /* See if this register would conflict with any reload\n+\t\t     that needs a group.  */\n+\t\t  int nongroup_need = 0;\n+\t\t  int *caller_save_needs;\n+\n+\t\t  for (j = 0; j < n_reloads; j++)\n+\t\t    if ((CLASS_MAX_NREGS (reload_reg_class[j],\n+\t\t\t\t\t  (GET_MODE_SIZE (reload_outmode[j])\n+\t\t\t\t\t   > GET_MODE_SIZE (reload_inmode[j]))\n+\t\t\t\t\t  ? reload_outmode[j]\n+\t\t\t\t\t  : reload_inmode[j])\n+\t\t\t > 1)\n+\t\t\t&& reg_classes_intersect_p (caller_save_spill_class,\n+\t\t\t\t\t\t    reload_reg_class[j]))\n+\t\t      {\n+\t\t\tnongroup_need = 1;\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t  caller_save_needs \n+\t\t    = (caller_save_group_size > 1\n+\t\t       ? insn_needs.other.groups\n+\t\t       : insn_needs.other.regs[nongroup_need]); \n \n \t\t  if (caller_save_needs[(int) caller_save_spill_class] == 0)\n \t\t    {\n@@ -1437,21 +1276,17 @@ reload (first, global, dumpfile)\n \t\t\tcaller_save_needs[(int) *p++] += 1;\n \t\t    }\n \n-\t\t  if (caller_save_group_size > 1)\n-\t\t    insn_total_groups = MAX (insn_total_groups, 1);\n-\n-\n-                /* Show that this basic block will need a register of\n+\t\t  /* Show that this basic block will need a register of\n                    this class.  */\n \n-                if (global\n-                    && ! (basic_block_needs[(int) caller_save_spill_class]\n-                          [this_block]))\n-                  {\n-                    basic_block_needs[(int) caller_save_spill_class]\n-                      [this_block] = 1;\n-                    new_basic_block_needs = 1;\n-                  }\n+\t\t  if (global\n+\t\t      && ! (basic_block_needs[(int) caller_save_spill_class]\n+\t\t\t    [this_block]))\n+\t\t    {\n+\t\t      basic_block_needs[(int) caller_save_spill_class]\n+\t\t\t[this_block] = 1;\n+\t\t      new_basic_block_needs = 1;\n+\t\t    }\n \t\t}\n \n #ifdef SMALL_REGISTER_CLASSES\n@@ -1462,6 +1297,7 @@ reload (first, global, dumpfile)\n \t\t then add add an extra need in that class.\n \t\t This makes sure we have a register available that does\n \t\t not overlap the return value.  */\n+\n \t      if (avoid_return_reg)\n \t\t{\n \t\t  int regno = REGNO (avoid_return_reg);\n@@ -1474,8 +1310,10 @@ reload (first, global, dumpfile)\n \t\t     need only in the smallest class in which it\n \t\t     is required.  */\n \n-\t\t  bcopy (insn_needs, basic_needs, sizeof basic_needs);\n-\t\t  bcopy (insn_groups, basic_groups, sizeof basic_groups);\n+\t\t  bcopy (insn_needs.other.regs[0], basic_needs,\n+\t\t\t sizeof basic_needs);\n+\t\t  bcopy (insn_needs.other.groups, basic_groups,\n+\t\t\t sizeof basic_groups);\n \n \t\t  for (i = 0; i < N_REG_CLASSES; i++)\n \t\t    {\n@@ -1509,10 +1347,10 @@ reload (first, global, dumpfile)\n \t\t\t      {\n \t\t\t\tenum reg_class *p;\n \n-\t\t\t\tinsn_needs[i]++;\n+\t\t\t\tinsn_needs.other.regs[0][i]++;\n \t\t\t\tp = reg_class_superclasses[i];\n \t\t\t\twhile (*p != LIM_REG_CLASSES)\n-\t\t\t\t  insn_needs[(int) *p++]++;\n+\t\t\t\t  insn_needs.other.regs[0][(int) *p++]++;\n \t\t\t      }\n \t\t\t  }\n \t\t}\n@@ -1522,19 +1360,19 @@ reload (first, global, dumpfile)\n \n \t      for (i = 0; i < N_REG_CLASSES; i++)\n \t\t{\n-\t\t  if (max_needs[i] < insn_needs[i])\n+\t\t  if (max_needs[i] < insn_needs.other.regs[0][i])\n \t\t    {\n-\t\t      max_needs[i] = insn_needs[i];\n+\t\t      max_needs[i] = insn_needs.other.regs[0][i];\n \t\t      max_needs_insn[i] = insn;\n \t\t    }\n-\t\t  if (max_groups[i] < insn_groups[i])\n+\t\t  if (max_groups[i] < insn_needs.other.groups[i])\n \t\t    {\n-\t\t      max_groups[i] = insn_groups[i];\n+\t\t      max_groups[i] = insn_needs.other.groups[i];\n \t\t      max_groups_insn[i] = insn;\n \t\t    }\n-\t\t  if (max_nongroups[i] < insn_nongroups[i])\n+\t\t  if (max_nongroups[i] < insn_needs.other.regs[1][i])\n \t\t    {\n-\t\t      max_nongroups[i] = insn_nongroups[i];\n+\t\t      max_nongroups[i] = insn_needs.other.regs[1][i];\n \t\t      max_nongroups_insn[i] = insn;\n \t\t    }\n \t\t}"}]}