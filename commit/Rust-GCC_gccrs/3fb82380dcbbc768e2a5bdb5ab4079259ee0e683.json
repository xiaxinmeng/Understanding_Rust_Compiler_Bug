{"sha": "3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZiODIzODBkY2JiYzc2OGUyYTViZGI1YWI0MDc5MjU5ZWUwZTY4Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-04-12T19:01:17Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-04-12T19:01:17Z"}, "message": "PR c/88383 - ICE calling __builtin_has_attribute on a reference\n\nPR c/88383 - ICE calling __builtin_has_attribute on a reference\nPR c/89288 - ICE in tree_code_size, at tree.c:865\nPR c/89798 - excessive vector_size silently accepted and truncated\nPR c/89797 - ICE on a vector_size (1LU << 33) int variable\n\ngcc/ChangeLog:\n\n\tPR c/89797\n\t* targhooks.c (default_vector_alignment): Avoid assuming\n\targument fits in SHWI.\n\t* tree.h (TYPE_VECTOR_SUBPARTS): Avoid sign overflow in\n\ta shift expression.\n\t* doc/extend.texi (__builtin_has_attribute): Add a clarifying note.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/88383\n\tPR c/89288\n\tPR c/89798\n\tPR c/89797\n\t* c-attribs.c (type_valid_for_vector_size): Detect excessively\n\tlarge sizes.\n\t(validate_attribute): Handle DECLs and expressions.\n\t(has_attribute): Handle types referenced by expressions.\n\tAvoid considering array attributes in ARRAY_REF expressions .\n\ngcc/cp/ChangeLog:\n\n\tPR c/88383\n\tPR c/89288\n\t* parser.c (cp_parser_has_attribute_expression): Handle assignment\n\texpressions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/88383\n\tPR c/89288\n\tPR c/89798\n\tPR c/89797\n\t* c-c++-common/attributes-1.c: Adjust.\n\t* c-c++-common/builtin-has-attribute-6.c: New test.\n\t* c-c++-common/builtin-has-attribute-7.c: New test.\n\t* c-c++-common/builtin-has-attribute-4.c: Adjust expectations.\n\t* c-c++-common/builtin-has-attribute-6.c: New test.\n\t* c-c++-common/pr71574.c: Adjust.\n\t* gcc.dg/pr25559.c: Adjust.\n\t* gcc.dg/attr-vector_size.c: New test.\n\nFrom-SVN: r270326", "tree": {"sha": "65f6424af90d819b32d06be37fadd150069dafa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65f6424af90d819b32d06be37fadd150069dafa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d8695f529a41a639c6cc2a51cbcec7c8b243bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8695f529a41a639c6cc2a51cbcec7c8b243bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d8695f529a41a639c6cc2a51cbcec7c8b243bc1"}], "stats": {"total": 711, "additions": 692, "deletions": 19}, "files": [{"sha": "907c6f38c0568de2217fca499bace25327c4145a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -1,5 +1,17 @@\n+2019-04-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88383\n+\tPR c/89288\n+\tPR c/89798\n+\tPR c/89797\n+\t* targhooks.c (default_vector_alignment): Avoid assuming\n+\targument fits in SHWI.\n+\t* tree.h (TYPE_VECTOR_SUBPARTS): Avoid sign overflow in\n+\ta shift expression.\n+\t* doc/extend.texi (__builtin_has_attribute): Add a clarifying note.\n+\n 2019-04-12  Jakub Jelinek  <jakub@redhat.com>\n-\t\n+\n \tPR rtl-optimization/89965\n \t* dce.c: Include rtl-iter.h.\n \t(struct check_argument_load_data): New type."}, {"sha": "212318e096638d38c716c47ed4a2ec66336a605d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -1,3 +1,10 @@\n+2019-04-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88383\n+\tPR c/89288\n+\t* parser.c (cp_parser_has_attribute_expression): Handle assignment\n+\texpressions.\n+\n 2019-04-12  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (null_member_pointer_value_p): Handle an empty CONSTRUCTOR"}, {"sha": "3d908916ae3f7d4c1daaafc3b4858b4d9a94a74a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -8555,9 +8555,9 @@ cp_parser_has_attribute_expression (cp_parser *parser)\n   cp_parser_parse_definitely (parser);\n \n   /* If the type-id production did not work out, then we must be\n-     looking at the unary-expression production.  */\n+     looking at an expression.  */\n   if (!oper || oper == error_mark_node)\n-    oper = cp_parser_unary_expression (parser);\n+    oper = cp_parser_assignment_expression (parser);\n \n   STRIP_ANY_LOCATION_WRAPPER (oper);\n "}, {"sha": "cfde248dd3db09d908850478ff9c07574803c085", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -1247,14 +1247,18 @@ constant_alignment_word_strings (const_tree exp, HOST_WIDE_INT align)\n   return align;\n }\n \n-/* Default to natural alignment for vector types.  */\n+/* Default to natural alignment for vector types, bounded by\n+   MAX_OFILE_ALIGNMENT.  */\n+\n HOST_WIDE_INT\n default_vector_alignment (const_tree type)\n {\n-  HOST_WIDE_INT align = tree_to_shwi (TYPE_SIZE (type));\n-  if (align > MAX_OFILE_ALIGNMENT)\n-    align = MAX_OFILE_ALIGNMENT;\n-  return align;\n+  unsigned HOST_WIDE_INT align = MAX_OFILE_ALIGNMENT;\n+  tree size = TYPE_SIZE (type);\n+  if (tree_fits_uhwi_p (size))\n+    align = tree_to_uhwi (size);\n+\n+  return align < MAX_OFILE_ALIGNMENT ? align : MAX_OFILE_ALIGNMENT;\n }\n \n /* The default implementation of"}, {"sha": "ed6f731b5b5e9bee2495e74a4f18beb70fb83952", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -1,5 +1,19 @@\n+2019-04-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88383\n+\tPR c/89288\n+\tPR c/89798\n+\tPR c/89797\n+\t* c-c++-common/attributes-1.c: Adjust.\n+\t* c-c++-common/builtin-has-attribute-4.c: Adjust expectations.\n+\t* c-c++-common/builtin-has-attribute-6.c: New test.\n+\t* c-c++-common/builtin-has-attribute-7.c: New test.\n+\t* c-c++-common/pr71574.c: Adjust.\n+\t* gcc.dg/pr25559.c: Adjust.\n+\t* gcc.dg/attr-vector_size.c: New test.\n+\n 2019-04-12  Jakub Jelinek  <jakub@redhat.com>\n-\t\n+\n \tPR rtl-optimization/89965\n \t* gcc.target/i386/pr89965.c: New test.\n "}, {"sha": "b73d31aa5e25f7cca82b0d2e5fd3fa128bea5a0b", "filename": "gcc/testsuite/c-c++-common/attributes-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -4,7 +4,7 @@\n void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,bar))); /* { dg-warning \".alloc_size. attribute argument 2 is invalid\" } */\n void* my_realloc(void*, unsigned) __attribute__((alloc_size(bar))); /* { dg-warning \".alloc_size. attribute argument is invalid\" } */\n \n-typedef char vec __attribute__((vector_size(bar))); /* { dg-warning \"ignored\" } */\n+typedef char vec __attribute__((vector_size(bar)));\n \n void f1(char*) __attribute__((nonnull(bar))); /* { dg-warning \".nonnull. attribute argument is invalid\" } */\n \n@@ -14,7 +14,7 @@ void foo(int);\n void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,foo))); /* { dg-warning \".alloc_size. attribute argument 2 has type .void\\\\\\(int\\\\\\).\" } */\n void* my_realloc(void*, unsigned) __attribute__((alloc_size(foo))); /* { dg-warning \".alloc_size. attribute argument has type .void ?\\\\\\(int\\\\\\)\" } */\n \n-typedef char vec __attribute__((vector_size(foo))); /* { dg-warning \"ignored\" } */\n+typedef char vec __attribute__((vector_size(foo))); /* { dg-error \".vector_size. attribute argument value .foo. is not an integer constant\" } */\n \n void f1(char*) __attribute__((nonnull(foo))); /* { dg-warning \".nonnull. attribute argument has type .void ?\\\\\\(int\\\\\\).\" } */\n void f2(char*) __attribute__((nonnull(1,foo))); /* { dg-warning \".nonnull. attribute argument 2 has type .void ?\\\\\\(int\\\\\\).\" } */"}, {"sha": "ec3127794b523a64699a8f740ac5fb421479f07a", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-4.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -3,7 +3,7 @@\n    { dg-skip-if \"No section attribute\" { { hppa*-*-hpux* } && { ! lp64 } } }\n    { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n    { dg-options \"-Wall -Wno-narrowing -Wno-unused -ftrack-macro-expansion=0\" { target c++ } }\n-   { dg-additional-options \"-DSKIP_ALIAS\" { target *-*-darwin* } } \n+   { dg-additional-options \"-DSKIP_ALIAS\" { target *-*-darwin* } }\n */\n \n #define ATTR(...) __attribute__ ((__VA_ARGS__))\n@@ -155,7 +155,8 @@ void test_packed (struct PackedMember *p)\n   A (0, gpak[0].c, packed);\n   A (0, gpak[1].s, packed);\n   A (1, gpak->a, packed);\n-  A (1, (*gpak).a[0], packed);\n+  /* It's the array that's declared packed but not its elements.  */\n+  A (0, (*gpak).a[0], packed);\n \n   /* The following fails because in C it's represented as\n        INDIRECT_REF (POINTER_PLUS (NOP_EXPR (ADDR_EXPR (gpak)), ...))\n@@ -165,7 +166,8 @@ void test_packed (struct PackedMember *p)\n   A (0, p->c, packed);\n   A (0, p->s, packed);\n   A (1, p->a, packed);\n-  A (1, p->a[0], packed);\n+  /* It's the array that's declared packed but not its elements.  */\n+  A (0, p->a[0], packed);\n   /* Similar to the comment above.\n    A (1, *p->a, packed);  */\n }\n@@ -218,13 +220,68 @@ void test_vector_size (void)\n   A (1, iv16, vector_size (16));\n   A (0, iv16, vector_size (32));\n \n+  /* Verify that the attribute not detected on an array of vectors\n+     but is detected on its elements.  */\n+  typedef ATTR (vector_size (8)) float afv8_t[4];\n+  A (0, afv8_t, vector_size);\n+  A (0, afv8_t, vector_size (1));\n+  A (0, afv8_t, vector_size (2));\n+  A (0, afv8_t, vector_size (4));\n+  A (0, afv8_t, vector_size (8));\n+  A (0, afv8_t, vector_size (16));\n+\n+  A (1, __typeof__ ((*(afv8_t*)0)[0]), vector_size);\n+  A (0, __typeof__ ((*(afv8_t*)0)[1]), vector_size (1));\n+  A (0, __typeof__ ((*(afv8_t*)0)[2]), vector_size (2));\n+  A (0, __typeof__ ((*(afv8_t*)0)[3]), vector_size (4));\n+  A (1, __typeof__ ((*(afv8_t*)0)[0]), vector_size (8));\n+  A (0, __typeof__ ((*(afv8_t*)0)[1]), vector_size (16));\n+\n+  A (1, __typeof__ (**(afv8_t*)0), vector_size);\n+  A (0, __typeof__ (**(afv8_t*)0), vector_size (1));\n+  A (0, __typeof__ (**(afv8_t*)0), vector_size (2));\n+  A (0, __typeof__ (**(afv8_t*)0), vector_size (4));\n+  A (1, __typeof__ (**(afv8_t*)0), vector_size (8));\n+  A (0, __typeof__ (**(afv8_t*)0), vector_size (16));\n+\n   ATTR (vector_size (8)) float afv8[4];\n-  A (1, afv8, vector_size);\n+  A (0, afv8, vector_size);\n   A (0, afv8, vector_size (1));\n   A (0, afv8, vector_size (2));\n   A (0, afv8, vector_size (4));\n-  A (1, afv8, vector_size (8));\n+  A (0, afv8, vector_size (8));\n   A (0, afv8, vector_size (16));\n+\n+  A (1, afv8[0], vector_size);\n+  A (0, afv8[1], vector_size (1));\n+  A (0, afv8[2], vector_size (2));\n+  A (0, afv8[3], vector_size (4));\n+  A (1, afv8[0], vector_size (8));\n+  A (0, afv8[1], vector_size (16));\n+\n+  A (1, *afv8, vector_size);\n+  A (0, *afv8, vector_size (1));\n+  A (0, *afv8, vector_size (2));\n+  A (0, *afv8, vector_size (4));\n+  A (1, *afv8, vector_size (8));\n+  A (0, *afv8, vector_size (16));\n+\n+  /* sizeof (long double) is 12 on i386.  */\n+  enum { VecSize = 8 * sizeof (long double) };\n+  ATTR (vector_size (VecSize)) long double aldv[1][2][3];\n+  A (0, aldv, vector_size);\n+  A (0, aldv[0], vector_size);\n+  A (0, aldv[0][0], vector_size);\n+  A (1, aldv[0][0][0], vector_size);\n+  A (0, aldv[0][0][1], vector_size (VecSize / 2));\n+  A (1, aldv[0][0][2], vector_size (VecSize));\n+\n+  A (0, aldv[0][0][0][0], vector_size);\n+\n+  A (0, *aldv, vector_size);\n+  A (0, **aldv, vector_size);\n+  A (1, ***aldv, vector_size);\n+  A (1, ***aldv, vector_size (VecSize));\n }\n \n "}, {"sha": "89cf4f23d4771004d86f74721b10eb481e3760a6", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-6.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-6.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -0,0 +1,114 @@\n+/* PR c/88383 - ICE calling _builtin_has_attribute(r, aligned(N)))\n+   on an overaligned reference r\n+   PR c/89288 - ICE in tree_code_size, at tree.c:865\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+typedef ATTR (aligned (8)) int Int8;\n+\n+/* The attribute applies to the array, not to the type of its elements.  */\n+extern ATTR (aligned (8)) char i8arr[];\n+\n+/* The attribute applies to the pointer, not to the type it points to.  */\n+extern ATTR (aligned (8)) int *ptr;\n+extern Int8 *i8ptr;\n+\n+#if __cplusplus\n+\n+/* Similarly here, the attribute applies to the reference, not to its type.  */\n+extern ATTR (aligned (8)) int &ref;\n+extern Int8 &i8ref;\n+\n+#else\n+\n+/* Fake references in C.  */\n+extern ATTR (aligned (8)) int ref;\n+Int8 i8ref;\n+\n+#endif\n+\n+void test (void)\n+{\n+  /* Verify that the built-in detects the attribute on the array. */\n+  A (1, i8arr, aligned);\n+  A (0, i8arr, aligned (1));\n+  A (0, i8arr, aligned (2));\n+  A (0, i8arr, aligned (4));\n+  A (1, i8arr, aligned (8));\n+  A (0, i8arr, aligned (16));\n+\n+  A (0, i8arr + 1, aligned);\n+  A (0, i8arr + 2, aligned (1));\n+  A (0, i8arr + 3, aligned (8));\n+\n+  /* Verify the builtin detects the absence of the attribute on\n+     the elements.  */\n+  A (0, i8arr[0], aligned);\n+  A (0, *i8arr,   aligned);\n+\n+  /* Verify that the built-in doesn't confuse the attribute on\n+     the pointer type with that to the pointed to type.  This\n+     also exercises PR c/89288.  */\n+  A (0, (Int8*)0, aligned);\n+  A (0, (int*)0,  aligned);\n+  A (0, (void*)0, aligned);\n+  A (0, 0,        aligned);\n+\n+  /* Verify that the built-in detects the attribute on the pointer\n+     itself. */\n+  A (1, ptr, aligned);\n+  A (0, ptr, aligned (1));\n+  A (0, ptr, aligned (2));\n+  A (0, ptr, aligned (4));\n+  A (1, ptr, aligned (8));\n+  A (0, ptr, aligned (16));\n+\n+  A (0, ptr + 1, aligned);\n+  A (0, ptr + 2, aligned (1));\n+  A (0, ptr + 3, aligned (8));\n+\n+  /* The pointed to type is not declared with attribute aligned.  */\n+  A (0, *ptr, aligned);\n+  A (0, *ptr, aligned (1));\n+  A (0, *ptr, aligned (2));\n+  A (0, *ptr, aligned (4));\n+  A (0, *ptr, aligned (8));\n+  A (0, *ptr, aligned (16));\n+\n+  A (0, *ptr + 1, aligned);\n+  A (0, *ptr + 2, aligned (1));\n+  A (0, *ptr + 3, aligned (8));\n+\n+  /* Verify that the built-in correctly detects the attribute on\n+     the type of the lvalue referenced by the pointer. */\n+  A (0, i8ptr,     aligned);\n+  A (0, i8ptr,     aligned (8));\n+  A (0, i8ptr + 1, aligned);\n+  A (0, i8ptr + 3, aligned (8));\n+  A (1, *i8ptr,    aligned);\n+  A (0, *i8ptr,    aligned (1));\n+  A (0, *i8ptr,    aligned (2));\n+  A (0, *i8ptr,    aligned (4));\n+  A (1, *i8ptr,    aligned (8));\n+  A (0, *i8ptr,    aligned (16));\n+\n+  /* The reference itself is declared aligned, even though the type\n+     it refers to isn't.  But see PR c++/88362.  */\n+  A (1, ref, aligned);\n+  A (0, ref, aligned (1));\n+  A (0, ref, aligned (2));\n+  A (0, ref, aligned (4));\n+  A (1, ref, aligned (8));\n+  A (0, ref, aligned (16));\n+\n+  /* Also verify that assignment expressions are accepted.  */\n+  A (0, ref = 1,  aligned);\n+  A (0, ref += 2, aligned (1));\n+  A (0, ref /= 3, aligned (8));\n+\n+}"}, {"sha": "6ea2e9e71920be223ea85b3fa6779f56681317f8", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-7.c", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-7.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -0,0 +1,396 @@\n+/* Verify that __builtin_has_attribute detects attributes aligned\n+   and packed in various forms of array dereferencing and indirection\n+   expressions correspondingly to __alignof__.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wno-unused -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+#define ALIGN(N)  ATTR (aligned (N))\n+\n+#define Assert(expr) typedef int _Assert [1 - 2 * !(expr)]\n+\n+/* Verify that  __builtin_has_attribute (EXPR, align (ALIGN)) returns\n+   the EXPECTed result.  When EXPECT is true, verify that the EXPression\n+   has the expected ALIGNment.    */\n+#define A3(expect, expr, align) do {\t\t\t\t\t\\\n+    Assert (!expect || __alignof__ (expr) == align);\t\t\t\\\n+    Assert (expect == __builtin_has_attribute (expr, aligned (align))); \\\n+  } while (0)\n+\n+#define A(expect, expr)\t\t\t\t\t\t\t\\\n+  Assert (expect == __builtin_has_attribute (expr, aligned))\t\t\\\n+\n+enum { PA = __alignof__ (void*) };\n+\n+/* Define pointer to pointer types, with different alignments\n+   at each level of indirection.  */\n+typedef struct S8 { char a[8]; }   S8;\n+typedef ALIGN (8)  S8              I8;\n+typedef ALIGN (16) I8             *P16_I8;\n+typedef            P16_I8         *P_P16_I8;\n+typedef ALIGN (32) P_P16_I8       *P32_P_P16_I8;\n+typedef            P32_P_P16_I8   *P_P32_P_P16_I8;\n+typedef ALIGN (64) P_P32_P_P16_I8 *P64_P_P32_P_P16_I8;\n+\n+Assert ( 8 == __alignof__ (I8));\n+Assert (16 == __alignof__ (P16_I8));\n+Assert (PA == __alignof__ (P_P16_I8));\n+Assert (32 == __alignof__ (P32_P_P16_I8));\n+Assert (PA == __alignof__ (P_P32_P_P16_I8));\n+Assert (64 == __alignof__ (P64_P_P32_P_P16_I8));\n+\n+\n+/* Similar to the pointer of pointers above, define array of array\n+   types, with different alignments at each level of indirection.  */\n+typedef struct S64 { char a[64]; } S64;\n+typedef ALIGN (64) S64             I64;\n+typedef ALIGN (32) I64             A32_I64[3];\n+typedef            A32_I64         A_A32_I64[5];\n+typedef ALIGN (16) A_A32_I64       A16_A_A32_I64[7];\n+typedef            A16_A_A32_I64   A_A16_A_A32_I64[11];\n+typedef ALIGN (8)  A_A16_A_A32_I64 A8_A_A16_A_A32_I64[13];\n+\n+Assert (64 == __alignof__ (I64));\n+Assert (32 == __alignof__ (A32_I64));\n+/* With no explicit alignment, an array of overaligned elements\n+   is considered to have the alignment of its elements.  */\n+Assert (32 == __alignof__ (A_A32_I64));\n+Assert (16 == __alignof__ (A16_A_A32_I64));\n+Assert (16 == __alignof__ (A_A16_A_A32_I64));\n+Assert ( 8 == __alignof__ (A8_A_A16_A_A32_I64));\n+\n+\n+void test_arrays (void)\n+{\n+  /* Verify that the aligned attribute on each of the composite types\n+     is detected corresponding to the result of __alignof__.  */\n+  A (1, (*(A8_A_A16_A_A32_I64*)0));\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0), 8);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0], 8);\n+  /* GCC propagates the user-align bit from element types to their\n+     arrays but it doesn't propagate the attribute itself.  The built-in\n+     considers both the  bit and the attribute so it succeeds below even\n+     though the referenced type isn't declared with the attribute.  */\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0], 8);\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0)[0], 16);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0], 32);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1], 8);\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0)[0][1], 16);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1], 32);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2], 16);\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0)[0][1][2], 32);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2], 64);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3], 16);\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3], 32);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3], 64);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3][4], 32);\n+  A3 (1, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3][4], 64);\n+  A3 (0, (*(A8_A_A16_A_A32_I64*)0)[0][1][2][3][4], 128);\n+\n+  A8_A_A16_A_A32_I64 a;\n+  A3 (0, a[0], 8);\n+  A3 (1, a[0], 16);\n+  A3 (0, a[0], 32);\n+  A3 (0, a[0][1], 8);\n+  A3 (1, a[0][1], 16);\n+  A3 (0, a[0][1], 32);\n+  A3 (0, a[0][1][2], 16);\n+  A3 (1, a[0][1][2], 32);\n+  A3 (0, a[0][1][2], 64);\n+  A3 (0, a[0][1][2][3], 16);\n+  A3 (1, a[0][1][2][3], 32);\n+  A3 (0, a[0][1][2][3], 64);\n+  A3 (0, a[0][1][2][3][4], 32);\n+  A3 (1, a[0][1][2][3][4], 64);\n+  A3 (0, a[0][1][2][3][4], 128);\n+}\n+\n+void test_pointers (void)\n+{\n+  /* Verify that the aligned attribute on each of the composite pointer\n+     types is detected corresponding to the result of __alignof__.  */\n+  A (1, I8);\n+  A3 (0, I8, 4);\n+  A3 (1, I8, 8);\n+\n+  A (1, P16_I8);\n+  A3 (0, P16_I8, 8);\n+  A3 (1, P16_I8, 16);\n+\n+  A (0, P_P16_I8);\n+  A3 (0, P_P16_I8, 8);\n+  A3 (0, P_P16_I8, 16);\n+\n+  A (1, P32_P_P16_I8);\n+  A3 (0, P32_P_P16_I8, 8);\n+  A3 (0, P32_P_P16_I8, 16);\n+  A3 (1, P32_P_P16_I8, 32);\n+\n+  A (0, P_P32_P_P16_I8);\n+\n+  A (1, P64_P_P32_P_P16_I8);\n+  A3 (0, P64_P_P32_P_P16_I8, 8);\n+  A3 (0, P64_P_P32_P_P16_I8, 16);\n+  A3 (0, P64_P_P32_P_P16_I8, 32);\n+  A3 (1, P64_P_P32_P_P16_I8, 64);\n+\n+\n+  /* Verify that the attribute on each of the composite types is detected\n+     in the type of each of the indirection expressions.  */\n+  A (1, *(P16_I8)0);\n+  A3 (1, *(P16_I8)0, 8);\n+  A3 (0, *(P16_I8)0, 16);\n+\n+  A (1, *(P_P16_I8)0);\n+  A3 (0, *(P_P16_I8)0, 8);\n+  A3 (1, *(P_P16_I8)0, 16);\n+\n+  A (0, *(P32_P_P16_I8)0);\n+  A3 (0, *(P32_P_P16_I8)0, 8);\n+  A3 (0, *(P32_P_P16_I8)0, 16);\n+  A3 (0, *(P32_P_P16_I8)0, 32);\n+\n+  A (1, *(P_P32_P_P16_I8)0);\n+  A3 (1, *(P_P32_P_P16_I8)0, 32);\n+\n+  A (0, *(P64_P_P32_P_P16_I8)0);\n+\n+  /* Verify that the attribute on each of the composite types is detected\n+     in the type of each of the subscipting expressions.  */\n+  A (1, ((P16_I8)0)[0]);\n+  A3 (1, ((P16_I8)0)[1], 8);\n+  A3 (0, ((P16_I8)0)[2], 16);\n+\n+  A (1, ((P_P16_I8)0)[3]);\n+  A3 (0, ((P_P16_I8)0)[4], 8);\n+  A3 (1, ((P_P16_I8)0)[5], 16);\n+\n+  A (0, ((P32_P_P16_I8)0)[6]);\n+  A3 (0, ((P32_P_P16_I8)0)[7], 8);\n+  A3 (0, ((P32_P_P16_I8)0)[8], 16);\n+  A3 (0, ((P32_P_P16_I8)0)[9], 32);\n+\n+  A (1, ((P_P32_P_P16_I8)0)[10]);\n+  A3 (1, ((P_P32_P_P16_I8)0)[11], 32);\n+\n+  A (0, ((P64_P_P32_P_P16_I8)0)[12]);\n+\n+\n+  /* Verify that the attribute on each of the composite types is detected\n+     in the type of each of the subscipting expression involving variables.  */\n+\n+  I8                   i8;\n+  P16_I8               p16_i8 = &i8;\n+  P_P16_I8             p_p16_i8 = &p16_i8;\n+  P32_P_P16_I8         p32_p_p16_i8 = &p_p16_i8;\n+  P_P32_P_P16_I8       p_p32_p_p16_i8 = &p32_p_p16_i8;\n+  P64_P_P32_P_P16_I8   p64_p_p32_p_p16_i8 = &p_p32_p_p16_i8;\n+\n+  A (1, p16_i8[0]);\n+  A3 (1, p16_i8[1], 8);\n+  A3 (0, p16_i8[2], 16);\n+\n+  A (1, p_p16_i8[3]);\n+  A3 (0, p_p16_i8[4], 8);\n+  A3 (1, p_p16_i8[5], 16);\n+\n+  A (0, p32_p_p16_i8[6]);\n+  A3 (0, p32_p_p16_i8[7], 8);\n+  A3 (0, p32_p_p16_i8[8], 16);\n+  A3 (0, p32_p_p16_i8[9], 32);\n+\n+  A (1, p_p32_p_p16_i8[10]);\n+  A3 (1, p_p32_p_p16_i8[11], 32);\n+\n+\n+  A (1, p_p16_i8[0][1]);\n+  A3 (1, p_p16_i8[1][2], 8);\n+  A3 (0, p_p16_i8[2][3], 16);\n+\n+\n+  A (0, p64_p_p32_p_p16_i8[0]);\n+\n+  A (1, p64_p_p32_p_p16_i8[0][1]);\n+  A3 (0, p64_p_p32_p_p16_i8[0][2], 16);\n+  A3 (1, p64_p_p32_p_p16_i8[0][3], 32);\n+  A3 (0, p64_p_p32_p_p16_i8[0][4], 64);\n+\n+  A (0, p64_p_p32_p_p16_i8[0][1][2]);\n+\n+  A (1, p64_p_p32_p_p16_i8[0][1][2][3]);\n+  A3 (0, p64_p_p32_p_p16_i8[0][1][2][4], 8);\n+  A3 (1, p64_p_p32_p_p16_i8[0][1][2][4], 16);\n+  A3 (0, p64_p_p32_p_p16_i8[0][1][2][4], 32);\n+\n+  A (1, p64_p_p32_p_p16_i8[0][1][2][3][4]);\n+  A3 (1, p64_p_p32_p_p16_i8[0][1][2][3][5], 8);\n+  A3 (0, p64_p_p32_p_p16_i8[0][1][2][4][6], 16);\n+\n+\n+  /* Same as above but using the indirection expression.  */\n+  A (0, *p64_p_p32_p_p16_i8);\n+\n+  A (1, **p64_p_p32_p_p16_i8);\n+  A3 (0, **p64_p_p32_p_p16_i8, 16);\n+  A3 (1, **p64_p_p32_p_p16_i8, 32);\n+  A3 (0, **p64_p_p32_p_p16_i8, 64);\n+\n+  A (0, ***p64_p_p32_p_p16_i8);\n+\n+  A (1, ****p64_p_p32_p_p16_i8);\n+  A3 (0, ****p64_p_p32_p_p16_i8, 8);\n+  A3 (1, ****p64_p_p32_p_p16_i8, 16);\n+  A3 (0, ****p64_p_p32_p_p16_i8, 32);\n+\n+  A (1, *****p64_p_p32_p_p16_i8);\n+  A3 (1, *****p64_p_p32_p_p16_i8, 8);\n+  A3 (0, *****p64_p_p32_p_p16_i8, 16);\n+}\n+\n+\n+S8 f_S8 (void);\n+I8 f_I8 (void);\n+P16_I8 f_P16_I8 (void);\n+P_P16_I8 f_P_P16_I8 (void);\n+P32_P_P16_I8 f_P32_P_P16_I8 (void);\n+P_P32_P_P16_I8 f_P_P32_P_P16_I8 (void);\n+P64_P_P32_P_P16_I8 f_P64_P_P32_P_P16_I8 (void);\n+\n+void test_function_call (void)\n+{\n+  /* Verify that the aligned attribute on each of the composite pointer\n+     types returned by the functions is detected corresponding to\n+     the result of __alignof__.  */\n+\n+  A (0, f_S8 ());\n+\n+  A (1, f_I8 ());\n+  A3 (1, f_I8 (), 8);\n+  A3 (0, f_I8 (), 16);\n+\n+  A (1, f_P16_I8 ());\n+  A3 (0, f_P16_I8 (), 8);\n+  A3 (1, f_P16_I8 (), 16);\n+  A3 (0, f_P16_I8 (), 32);\n+\n+  A (1, *f_P16_I8 ());\n+  A3 (1, *f_P16_I8 (), 8);\n+  A3 (0, *f_P16_I8 (), 16);\n+\n+  A (0, f_P_P16_I8 ());\n+\n+  A (1, *f_P_P16_I8 ());\n+  A3 (0, *f_P_P16_I8 (), 8);\n+  A3 (1, *f_P_P16_I8 (), 16);\n+  A3 (0, *f_P_P16_I8 (), 32);\n+\n+  A (1, **f_P_P16_I8 ());\n+  A3 (1, **f_P_P16_I8 (), 8);\n+  A3 (0, **f_P_P16_I8 (), 16);\n+  A3 (0, **f_P_P16_I8 (), 32);\n+}\n+\n+\n+void test_compound_literal (void)\n+{\n+  A (0, (S8){ });\n+\n+  A (1, (I8){ });\n+  A3 (1, (I8){ }, 8);\n+  A3 (0, (I8){ }, 16);\n+\n+  A (1, (I64){ });\n+  A3 (0, (I64){ }, 8);\n+  A3 (0, (I64){ }, 16);\n+  A3 (0, (I64){ }, 32);\n+  A3 (1, (I64){ }, 64);\n+\n+  A (1, (A32_I64){ 0 });\n+  A3 (0, (A32_I64){ 0 }, 8);\n+  A3 (0, (A32_I64){ 0 }, 16);\n+  A3 (1, (A32_I64){ 0 }, 32);\n+  A3 (0, (A32_I64){ 0 }, 64);\n+\n+  A (1, ((A32_I64){ 0 })[0]);\n+  A3 (0, ((A32_I64){ 0 })[0], 8);\n+  A3 (0, ((A32_I64){ 0 })[0], 16);\n+  A3 (0, ((A32_I64){ 0 })[0], 32);\n+  A3 (1, ((A32_I64){ 0 })[0], 64);\n+}\n+\n+\n+void test_ternary_expression (int i)\n+{\n+  A (0, (0 ? (S8){ } : (S8){ }));\n+\n+  A (1, (1 ? (I8){ } : (I8){ }));\n+  A3 (1, (2 ? (I8){ } : (I8){ }), 8);\n+  A3 (0, (3 ? (I8){ } : (I8){ }), 16);\n+\n+  A (1, (4 ? (I64){ } : (I64){ }));\n+  A3 (0, (5 ? (I64){ } : (I64){ }), 8);\n+  A3 (0, (6 ? (I64){ } : (I64){ }), 16);\n+  A3 (0, (7 ? (I64){ } : (I64){ }), 32);\n+  A3 (1, (8 ? (I64){ } : (I64){ }), 64);\n+\n+#if !__cplusplus\n+  /* Suppress -Wc++-compat warning: converting an array compound literal\n+     to a pointer is ill-formed in C++  */\n+# pragma GCC diagnostic ignored \"-Wc++-compat\"\n+\n+  A (0, (9 ? (A32_I64){ } : (A32_I64){ })); \n+  A3 (0, (i ? (A32_I64){ } : (A32_I64){ }), 8);\n+  A3 (0, (i++ ? (A32_I64){ } : (A32_I64){ }), 16);\n+  A3 (0, (++i ? (A32_I64){ } : (A32_I64){ }), 32);\n+  A3 (0, (!i ? (A32_I64){ } : (A32_I64){ }), 64);\n+\n+  A (1, (0 ? (A32_I64){ } : (A32_I64){ })[0]);\n+  A3 (0, (1 ? (A32_I64){ } : (A32_I64){ })[1], 8);\n+  A3 (0, (2 ? (A32_I64){ } : (A32_I64){ })[2], 16);\n+  A3 (0, (3 ? (A32_I64){ } : (A32_I64){ })[3], 32);\n+  A3 (1, (3 ? (A32_I64){ } : (A32_I64){ })[i], 64);\n+#endif\n+}\n+\n+\n+void test_comma_expression (int i)\n+{\n+#if __cplusplus\n+  /* In C++, the type of the comma expressions whose operand is an array\n+     is the array itself with any attributes it was defined with.  */\n+# define R 1\n+#else\n+  /* In C, the type of the comma expressions whose operand is an array\n+     is a pointer type that does not include any attributes the array\n+     was defined with.  */\n+# define R 0\n+/* Suppress -Wc++-compat warning: converting an array compound literal\n+   to a pointer is ill-formed in C++\n+   G++ accepts the conversion in unevaluated contexts without a warning.  */\n+# pragma GCC diagnostic ignored \"-Wc++-compat\"\n+#endif\n+\n+  A (0, (0, (S8){ }));\n+\n+  A (1, (0, (I8){ }));\n+  A3 (1, (1, (I8){ }), 8);\n+  A3 (0, (2, (I8){ }), 16);\n+\n+  A (1, (3, (I64){ }));\n+  A3 (0, (4, (I64){ }), 8);\n+  A3 (0, (5, (I64){ }), 16);\n+  A3 (0, (6, (I64){ }), 32);\n+  A3 (1, (7, (I64){ }), 64);\n+\n+  A (R, (8, (A32_I64){ }));\n+  A3 (0, (9, (A32_I64){ }), 8);\n+  A3 (0, ((void)0, (A32_I64){ }), 16);\n+  A3 (R, ((I64){ },(A32_I64){ }), 32);\n+  A3 (0, (0, (A32_I64){ }), 64);\n+\n+  A (1, (1, ((A32_I64){ })[0]));\n+  A3 (0, (2, ((A32_I64){ })[0]), 8);\n+  A3 (0, (i++, ((A32_I64){ })[0]), 16);\n+  A3 (0, (++i, ((A32_I64){ })[0]), 32);\n+  A3 (1, (i = 0, ((A32_I64){ })[0]), 64);\n+}"}, {"sha": "31b2795716f808ada87835c27a7c862104eddf8e", "filename": "gcc/testsuite/c-c++-common/pr71574.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -11,5 +11,5 @@ int fn6 (const char *, ...) __attribute__ ((sentinel (fn1))); /* { dg-warning \"n\n void* fn7 (void) __attribute__ ((alloc_align (fn1))); /* { dg-warning \".alloc_align. attribute argument has type .int\\\\\\(int\\\\\\).\" } */\n void* fn8 (void) __attribute__ ((assume_aligned (fn1))); /* { dg-warning \"not an integer constant\" } */\n \n-typedef int __attribute__((vector_size (fn1))) v4si; /* { dg-warning \"attribute ignored\" } */\n+typedef int __attribute__((vector_size (fn1))) v4si; /* { dg-error \"'vector_size' attribute argument value 'fn1' is not an integer constant\" } */\n typedef int T __attribute__((aligned (fn1))); /* { dg-error \"requested alignment is not\" } */"}, {"sha": "00be26accd5673484296738d7af25b880e79762f", "filename": "gcc/testsuite/gcc.dg/attr-vector_size.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-vector_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-vector_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-vector_size.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -0,0 +1,69 @@\n+/* PR middle-end/89797 - ICE on a vector_size (1LU << 33) int variable\n+   PR c/89798 - excessive vector_size silently accepted and truncated\n+   { dg-do compile { target int32plus } }\n+   { dg-options \"-Wall -Wno-unused\" } */\n+\n+#define ASSERT(e)    _Static_assert (e, #e)\n+#define VEC(N)       __attribute__ ((vector_size (N)))\n+#define POW2(N)      (1LLU << N)\n+#define CAT(a, b)    a ## b\n+#define CONCAT(a, b) CAT (a, b)\n+\n+#define DEFVEC(storage, N)\t\t\t\t\\\n+  typedef VEC (POW2 (N)) char CONCAT (Vec, N);\t\t\\\n+  storage CONCAT (Vec, N) CONCAT (v, N);\t\t\\\n+  ASSERT (sizeof (CONCAT (Vec, N)) == POW2 (N));\t\\\n+  ASSERT (sizeof (CONCAT (v, N)) == POW2 (N))\n+\n+DEFVEC (extern, 27);\n+DEFVEC (extern, 28);\n+DEFVEC (extern, 29);\n+DEFVEC (extern, 30);\n+\n+#if __SIZEOF_SIZE_T__ > 4\n+\n+DEFVEC (extern, 31);\n+DEFVEC (extern, 32);\n+DEFVEC (extern, 33);\n+DEFVEC (extern, 34);\n+DEFVEC (extern, 60);\n+DEFVEC (extern, 61);\n+DEFVEC (extern, 62);\n+\n+VEC (POW2 (63)) char v63;     /* { dg-error  \"'vector_size' attribute argument value '9223372036854775808' exceeds 9223372036854775807\" \"LP64\" { target lp64 } } */\n+\n+#else\n+\n+VEC (POW2 (31)) char v31;     /* { dg-error  \"'vector_size' attribute argument value '2147483648' exceeds 2147483647\" \"ILP32\" { target ilp32 } } */\n+\n+VEC (POW2 (32)) char v32;     /* { dg-error  \"'vector_size' attribute argument value '4294967296' exceeds 2147483647\" \"ILP32\" { target ilp32 } } */\n+\n+#endif\n+\n+void test_local_scope (void)\n+{\n+  DEFVEC (auto, 27);\n+  DEFVEC (auto, 28);\n+  DEFVEC (auto, 29);\n+  DEFVEC (auto, 30);\n+\n+#if __SIZEOF_SIZE_T__ > 4\n+\n+  DEFVEC (auto, 31);\n+  DEFVEC (auto, 32);\n+  DEFVEC (auto, 33);\n+  DEFVEC (auto, 34);\n+  DEFVEC (auto, 60);\n+  DEFVEC (auto, 61);\n+  DEFVEC (auto, 62);\n+\n+  VEC (POW2 (63)) char v63;   /* { dg-error  \"'vector_size' attribute argument value '9223372036854775808' exceeds 9223372036854775807\" \"LP64\" { target lp64 } } */\n+\n+#else\n+\n+  VEC (POW2 (31)) char v31;   /* { dg-error  \"'vector_size' attribute argument value '2147483648' exceeds 2147483647\" \"ILP32\" { target ilp32 } } */\n+\n+  VEC (POW2 (32)) char v32;   /* { dg-error  \"'vector_size' attribute argument value '4294967296' exceeds 2147483647\" \"ILP32\" { target ilp32 } } */\n+\n+#endif\n+}"}, {"sha": "a8bce657b1c27caf68c08ed27761c98a8788b2af", "filename": "gcc/testsuite/gcc.dg/pr25559.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25559.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25559.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25559.c?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -2,7 +2,7 @@\n /* { dg-do compile } */\n \n #define vs(n) __attribute__((vector_size (n)))\n-int vs (-1) a;\t\t\t/* { dg-warning \"attribute ignored\" } */\n+int vs (-1) a;\t\t\t/* { dg-error \".vector_size. attribute argument value '-1' is negative\" } */\n int vs (0) b;\t\t\t/* { dg-error \"zero vector size\" } */\n int vs (1) c;\t\t\t/* { dg-error \"multiple of component size\" } */\n int vs (sizeof (int) / 2) d;\t/* { dg-error \"multiple of component size\" } */"}, {"sha": "94a810694a5274536e39e8ebcda2d1cf36451b58", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb82380dcbbc768e2a5bdb5ab4079259ee0e683/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3fb82380dcbbc768e2a5bdb5ab4079259ee0e683", "patch": "@@ -3741,7 +3741,7 @@ TYPE_VECTOR_SUBPARTS (const_tree node)\n       return res;\n     }\n   else\n-    return 1 << precision;\n+    return (unsigned HOST_WIDE_INT)1 << precision;\n }\n \n /* Set the number of elements in VECTOR_TYPE NODE to SUBPARTS, which must"}]}