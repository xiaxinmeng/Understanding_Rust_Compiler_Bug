{"sha": "b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "node_id": "C_kwDOANBUbNoAKGIzZTk4ZWIzMzk2ZTE2YWU4YjIwYzk0OTE2YmMyYmQ3ODYyZDJjOTc", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-03T18:38:50Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-03T18:43:47Z"}, "message": "PR tree-optimization/102950: Improved EVRP for signed BIT_XOR_EXPR.\n\nThis patch fixes PR tree-optimization/102950, which is a P2 regression,\nby providing better range bounds for BIT_XOR_EXPR, BIT_AND_EXPR and\nBIT_IOR_EXPR on signed integer types.  In general terms, any binary\nbitwise operation on sign-extended or zero-extended integer types will\nproduce results that are themselves sign-extended or zero-extended.\nMore precisely, we can derive signed bounds from the number of leading\nredundant sign bit copies, from the equation:\n\tclrsb(X op Y) >= min (clrsb (X), clrsb(Y))\nand from the property that for any (signed or unsigned) range [lb, ub]\nthat clrsb([lb, ub]) >= min (clrsb(lb), clrsb(ub)).\n\nThese can be used to show that [-1, 0] op [-1, 0] is [-1, 0] or that\n[-128, 127] op [-128, 127] is [-128, 127], even when tracking nonzero\nbits would result in VARYING (as every bit can be 0 or 1).  This is\nequivalent to determining the minimum type precision in which the\noperation can be performed then sign extending the result.\n\nOne additional refinement is to observe that X ^ Y can never be\nzero if the ranges of X and Y don't overlap, i.e. X can't be equal\nto Y.\n\nPreviously, the expression \"(int)(char)a ^ 233\" in the PR was considered\nVARYING, but with the above changes now has the range [-256, -1][1, 255],\nwhich is sufficient to optimize away the call to foo.\n\n2022-05-03  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR tree-optimization/102950\n\t* range-op.cc (wi_optimize_signed_bitwise_op): New function to\n\tdetermine bounds of bitwise operations on signed types.\n\t(operator_bitwise_and::wi_fold): Call the above function.\n\t(operator_bitwise_or::wi_fold): Likewise.\n\t(operator_bitwise_xor::wi_fold): Likewise.  Additionally, the\n\tresult can't be zero if the operands can't be equal.\n\ngcc/testsuite/ChangeLog\n\tPR tree-optimization/102950\n\t* gcc.dg/pr102950.c: New test case.\n\t* gcc.dg/tree-ssa/evrp10.c: New test case.", "tree": {"sha": "d1794f08d990312d0a892a0430cc170ec4180796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1794f08d990312d0a892a0430cc170ec4180796"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecd5727c0a662a8fea6b5f8eac6f3f15bf5ef851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd5727c0a662a8fea6b5f8eac6f3f15bf5ef851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd5727c0a662a8fea6b5f8eac6f3f15bf5ef851"}], "stats": {"total": 103, "additions": 102, "deletions": 1}, "files": [{"sha": "47c6dff8f3ee835d816ea72c5a798746284b2451", "filename": "gcc/range-op.cc", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "patch": "@@ -2615,6 +2615,29 @@ operator_bitwise_and::fold_range (irange &r, tree type,\n }\n \n \n+// Optimize BIT_AND_EXPR, BIT_IOR_EXPR and BIT_XOR_EXPR of signed types\n+// by considering the number of leading redundant sign bit copies.\n+// clrsb (X op Y) = min (clrsb (X), clrsb (Y)), so for example\n+// [-1, 0] op [-1, 0] is [-1, 0] (where nonzero_bits doesn't help).\n+static bool\n+wi_optimize_signed_bitwise_op (irange &r, tree type,\n+\t\t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb, const wide_int &rh_ub)\n+{\n+  int lh_clrsb = MIN (wi::clrsb (lh_lb), wi::clrsb (lh_ub));\n+  int rh_clrsb = MIN (wi::clrsb (rh_lb), wi::clrsb (rh_ub));\n+  int new_clrsb = MIN (lh_clrsb, rh_clrsb);\n+  if (new_clrsb == 0)\n+    return false;\n+  int type_prec = TYPE_PRECISION (type);\n+  int rprec = (type_prec - new_clrsb) - 1;\n+  value_range_with_overflow (r, type,\n+\t\t\t     wi::mask (rprec, true, type_prec),\n+\t\t\t     wi::mask (rprec, false, type_prec));\n+  return true;\n+}\n+\n+\n // Optimize BIT_AND_EXPR and BIT_IOR_EXPR in terms of a mask if\n // possible.  Basically, see if we can optimize:\n //\n@@ -2795,7 +2818,14 @@ operator_bitwise_and::wi_fold (irange &r, tree type,\n     }\n   // If the limits got swapped around, return varying.\n   if (wi::gt_p (new_lb, new_ub,sign))\n-    r.set_varying (type);\n+    {\n+      if (sign == SIGNED\n+\t  && wi_optimize_signed_bitwise_op (r, type,\n+\t\t\t\t\t    lh_lb, lh_ub,\n+\t\t\t\t\t    rh_lb, rh_ub))\n+\treturn;\n+      r.set_varying (type);\n+    }\n   else\n     value_range_with_overflow (r, type, new_lb, new_ub);\n }\n@@ -3049,6 +3079,11 @@ operator_bitwise_or::wi_fold (irange &r, tree type,\n \t  || wi::lt_p (lh_ub, 0, sign)\n \t  || wi::lt_p (rh_ub, 0, sign))\n \tr.set_nonzero (type);\n+      else if (sign == SIGNED\n+\t       && wi_optimize_signed_bitwise_op (r, type,\n+\t\t\t\t\t\t lh_lb, lh_ub,\n+\t\t\t\t\t\t rh_lb, rh_ub))\n+\treturn;\n       else\n \tr.set_varying (type);\n       return;\n@@ -3136,8 +3171,23 @@ operator_bitwise_xor::wi_fold (irange &r, tree type,\n   // is better than VARYING.\n   if (wi::lt_p (new_lb, 0, sign) || wi::ge_p (new_ub, 0, sign))\n     value_range_with_overflow (r, type, new_lb, new_ub);\n+  else if (sign == SIGNED\n+\t   && wi_optimize_signed_bitwise_op (r, type,\n+\t\t\t\t\t     lh_lb, lh_ub,\n+\t\t\t\t\t     rh_lb, rh_ub))\n+    ;  /* Do nothing.  */\n   else\n     r.set_varying (type);\n+\n+  /* Furthermore, XOR is non-zero if its arguments can't be equal.  */\n+  if (wi::lt_p (lh_ub, rh_lb, sign)\n+      || wi::lt_p (rh_ub, lh_lb, sign)\n+      || wi::ne_p (result_one_bits, 0))\n+    {\n+      int_range<2> tmp;\n+      tmp.set_nonzero (type);\n+      r.intersect (tmp);\n+    }\n }\n \n bool"}, {"sha": "0ab23bd4dbcbbca50cc3d18e6bafd16f493d58c2", "filename": "gcc/testsuite/gcc.dg/pr102950.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102950.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102950.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102950.c?ref=b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error(void);\n+\n+static char a;\n+static short d(unsigned e) {\n+  char b;\n+  short c;\n+  a = b = e;\n+  if (b)\n+    return 0;\n+  if (1 >= e) {\n+    c = e == 0;\n+    if (c)\n+      link_error();\n+  }\n+  return 0;\n+}\n+int main() { d(a ^ 233); }\n+"}, {"sha": "6ca00e4adaa2af55a981afaa3f22388401622151", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp10.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e98eb3396e16ae8b20c94916bc2bd7862d2c97/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp10.c?ref=b3e98eb3396e16ae8b20c94916bc2bd7862d2c97", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" }*/\n+\n+typedef __INT32_TYPE__ int32_t;\n+\n+int32_t and(int32_t x, int32_t y)\n+{\n+  int32_t tx = x >> 24;\n+  int32_t ty = y >> 24;\n+  int32_t t = tx & ty;\n+  return t;\n+}\n+\n+int32_t ior(int32_t x, int32_t y)\n+{\n+  int32_t tx = x >> 24;\n+  int32_t ty = y >> 24;\n+  int32_t t = tx | ty;\n+  return t;\n+}\n+\n+int32_t xor(int32_t x, int32_t y)\n+{\n+  int32_t tx = x >> 24;\n+  int32_t ty = y >> 24;\n+  int32_t t = tx ^ ty;\n+  return t;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\[-128, 127\\\\\\]\" 9 \"evrp\" } } */"}]}