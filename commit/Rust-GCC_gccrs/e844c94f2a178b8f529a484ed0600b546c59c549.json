{"sha": "e844c94f2a178b8f529a484ed0600b546c59c549", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0NGM5NGYyYTE3OGI4ZjUyOWE0ODRlZDA2MDBiNTQ2YzU5YzU0OQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@st.com", "date": "2019-09-10T07:53:12Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2019-09-10T07:53:12Z"}, "message": "[ARM/FDPIC v6 10/24] [ARM] FDPIC: Implement TLS support.\n\nSupport additional relocations: TLS_GD32_FDPIC, TLS_LDM32_FDPIC, and\nTLS_IE32_FDPIC.\n\nWe do not support the GNU2 TLS dialect.\n\n2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\n\tgcc/\n\t* config/arm/arm.c (tls_reloc): Add TLS_GD32_FDPIC,\n\tTLS_LDM32_FDPIC and TLS_IE32_FDPIC.\n\t(arm_call_tls_get_addr): Add FDPIC support.\n\t(legitimize_tls_address): Likewise.\n\t(arm_emit_tls_decoration): Likewise.\n\n\nCo-Authored-By: Micka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\nFrom-SVN: r275572", "tree": {"sha": "4c79ba55555a25e692520325f04b2158854fb0aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c79ba55555a25e692520325f04b2158854fb0aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e844c94f2a178b8f529a484ed0600b546c59c549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e844c94f2a178b8f529a484ed0600b546c59c549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e844c94f2a178b8f529a484ed0600b546c59c549", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e844c94f2a178b8f529a484ed0600b546c59c549/comments", "author": null, "committer": null, "parents": [{"sha": "bc87cffb13c836cc72b37dfd90544c7c21268702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc87cffb13c836cc72b37dfd90544c7c21268702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc87cffb13c836cc72b37dfd90544c7c21268702"}], "stats": {"total": 108, "additions": 82, "deletions": 26}, "files": [{"sha": "eff014123baa160776b32958a1f7c54b5dfe4387", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e844c94f2a178b8f529a484ed0600b546c59c549/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e844c94f2a178b8f529a484ed0600b546c59c549/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e844c94f2a178b8f529a484ed0600b546c59c549", "patch": "@@ -1,3 +1,13 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\tgcc/\n+\t* config/arm/arm.c (tls_reloc): Add TLS_GD32_FDPIC,\n+\tTLS_LDM32_FDPIC and TLS_IE32_FDPIC.\n+\t(arm_call_tls_get_addr): Add FDPIC support.\n+\t(legitimize_tls_address): Likewise.\n+\t(arm_emit_tls_decoration): Likewise.\n+\n 2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n \tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n "}, {"sha": "5f1d2d41795733339626009f81e79d9ecf0791f4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e844c94f2a178b8f529a484ed0600b546c59c549/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e844c94f2a178b8f529a484ed0600b546c59c549/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e844c94f2a178b8f529a484ed0600b546c59c549", "patch": "@@ -2350,9 +2350,12 @@ char arm_arch_name[] = \"__ARM_ARCH_PROFILE__\";\n \n enum tls_reloc {\n   TLS_GD32,\n+  TLS_GD32_FDPIC,\n   TLS_LDM32,\n+  TLS_LDM32_FDPIC,\n   TLS_LDO32,\n   TLS_IE32,\n+  TLS_IE32_FDPIC,\n   TLS_LE32,\n   TLS_DESCSEQ\t/* GNU scheme */\n };\n@@ -8708,22 +8711,33 @@ load_tls_operand (rtx x, rtx reg)\n static rtx_insn *\n arm_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n {\n-  rtx label, labelno, sum;\n+  rtx label, labelno = NULL_RTX, sum;\n \n   gcc_assert (reloc != TLS_DESCSEQ);\n   start_sequence ();\n \n-  labelno = GEN_INT (pic_labelno++);\n-  label = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n-  label = gen_rtx_CONST (VOIDmode, label);\n+  if (TARGET_FDPIC)\n+    {\n+      sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\t    gen_rtvec (2, x, GEN_INT (reloc)),\n+\t\t\t    UNSPEC_TLS);\n+    }\n+  else\n+    {\n+      labelno = GEN_INT (pic_labelno++);\n+      label = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n+      label = gen_rtx_CONST (VOIDmode, label);\n \n-  sum = gen_rtx_UNSPEC (Pmode,\n-\t\t\tgen_rtvec (4, x, GEN_INT (reloc), label,\n-\t\t\t\t   GEN_INT (TARGET_ARM ? 8 : 4)),\n-\t\t\tUNSPEC_TLS);\n+      sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\t    gen_rtvec (4, x, GEN_INT (reloc), label,\n+\t\t\t\t       GEN_INT (TARGET_ARM ? 8 : 4)),\n+\t\t\t    UNSPEC_TLS);\n+    }\n   reg = load_tls_operand (sum, reg);\n \n-  if (TARGET_ARM)\n+  if (TARGET_FDPIC)\n+      emit_insn (gen_addsi3 (reg, reg, gen_rtx_REG (Pmode, FDPIC_REGNUM)));\n+  else if (TARGET_ARM)\n     emit_insn (gen_pic_add_dot_plus_eight (reg, reg, labelno));\n   else\n     emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n@@ -8761,6 +8775,7 @@ arm_tls_descseq_addr (rtx x, rtx reg)\n   return reg;\n }\n \n+\n rtx\n legitimize_tls_address (rtx x, rtx reg)\n {\n@@ -8773,6 +8788,8 @@ legitimize_tls_address (rtx x, rtx reg)\n     case TLS_MODEL_GLOBAL_DYNAMIC:\n       if (TARGET_GNU2_TLS)\n \t{\n+\t  gcc_assert (!TARGET_FDPIC);\n+\n \t  reg = arm_tls_descseq_addr (x, reg);\n \n \t  tp = arm_load_tp (NULL_RTX);\n@@ -8782,7 +8799,10 @@ legitimize_tls_address (rtx x, rtx reg)\n       else\n \t{\n \t  /* Original scheme */\n-\t  insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32);\n+\t  if (TARGET_FDPIC)\n+\t    insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32_FDPIC);\n+\t  else\n+\t    insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32);\n \t  dest = gen_reg_rtx (Pmode);\n \t  emit_libcall_block (insns, dest, ret, x);\n \t}\n@@ -8791,6 +8811,8 @@ legitimize_tls_address (rtx x, rtx reg)\n     case TLS_MODEL_LOCAL_DYNAMIC:\n       if (TARGET_GNU2_TLS)\n \t{\n+\t  gcc_assert (!TARGET_FDPIC);\n+\n \t  reg = arm_tls_descseq_addr (x, reg);\n \n \t  tp = arm_load_tp (NULL_RTX);\n@@ -8799,7 +8821,10 @@ legitimize_tls_address (rtx x, rtx reg)\n \t}\n       else\n \t{\n-\t  insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);\n+\t  if (TARGET_FDPIC)\n+\t    insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32_FDPIC);\n+\t  else\n+\t    insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);\n \n \t  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n \t     share the LDM result with other LD model accesses.  */\n@@ -8818,23 +8843,35 @@ legitimize_tls_address (rtx x, rtx reg)\n       return dest;\n \n     case TLS_MODEL_INITIAL_EXEC:\n-      labelno = GEN_INT (pic_labelno++);\n-      label = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n-      label = gen_rtx_CONST (VOIDmode, label);\n-      sum = gen_rtx_UNSPEC (Pmode,\n-\t\t\t    gen_rtvec (4, x, GEN_INT (TLS_IE32), label,\n-\t\t\t\t       GEN_INT (TARGET_ARM ? 8 : 4)),\n-\t\t\t    UNSPEC_TLS);\n-      reg = load_tls_operand (sum, reg);\n-\n-      if (TARGET_ARM)\n-\temit_insn (gen_tls_load_dot_plus_eight (reg, reg, labelno));\n-      else if (TARGET_THUMB2)\n-\temit_insn (gen_tls_load_dot_plus_four (reg, NULL, reg, labelno));\n+      if (TARGET_FDPIC)\n+\t{\n+\t  sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\tgen_rtvec (2, x, GEN_INT (TLS_IE32_FDPIC)),\n+\t\t\t\tUNSPEC_TLS);\n+\t  reg = load_tls_operand (sum, reg);\n+\t  emit_insn (gen_addsi3 (reg, reg, gen_rtx_REG (Pmode, FDPIC_REGNUM)));\n+\t  emit_move_insn (reg, gen_rtx_MEM (Pmode, reg));\n+\t}\n       else\n \t{\n-\t  emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n-\t  emit_move_insn (reg, gen_const_mem (SImode, reg));\n+\t  labelno = GEN_INT (pic_labelno++);\n+\t  label = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n+\t  label = gen_rtx_CONST (VOIDmode, label);\n+\t  sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\tgen_rtvec (4, x, GEN_INT (TLS_IE32), label,\n+\t\t\t\t\t   GEN_INT (TARGET_ARM ? 8 : 4)),\n+\t\t\t\tUNSPEC_TLS);\n+\t  reg = load_tls_operand (sum, reg);\n+\n+\t  if (TARGET_ARM)\n+\t    emit_insn (gen_tls_load_dot_plus_eight (reg, reg, labelno));\n+\t  else if (TARGET_THUMB2)\n+\t    emit_insn (gen_tls_load_dot_plus_four (reg, NULL, reg, labelno));\n+\t  else\n+\t    {\n+\t      emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n+\t      emit_move_insn (reg, gen_const_mem (SImode, reg));\n+\t    }\n \t}\n \n       tp = arm_load_tp (NULL_RTX);\n@@ -28158,15 +28195,24 @@ arm_emit_tls_decoration (FILE *fp, rtx x)\n     case TLS_GD32:\n       fputs (\"(tlsgd)\", fp);\n       break;\n+    case TLS_GD32_FDPIC:\n+      fputs (\"(tlsgd_fdpic)\", fp);\n+      break;\n     case TLS_LDM32:\n       fputs (\"(tlsldm)\", fp);\n       break;\n+    case TLS_LDM32_FDPIC:\n+      fputs (\"(tlsldm_fdpic)\", fp);\n+      break;\n     case TLS_LDO32:\n       fputs (\"(tlsldo)\", fp);\n       break;\n     case TLS_IE32:\n       fputs (\"(gottpoff)\", fp);\n       break;\n+    case TLS_IE32_FDPIC:\n+      fputs (\"(gottpoff_fdpic)\", fp);\n+      break;\n     case TLS_LE32:\n       fputs (\"(tpoff)\", fp);\n       break;"}]}