{"sha": "d564a83d14252d7db01381f71900b7a68357803b", "node_id": "C_kwDOANBUbNoAKGQ1NjRhODNkMTQyNTJkN2RiMDEzODFmNzE5MDBiN2E2ODM1NzgwM2I", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-06T16:39:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-06T22:42:05Z"}, "message": "analyzer: make use of may_be_aliased in alias detection [PR103546]\n\nWhilst debugging PR analyzer/103546 (false +ve in flex-generated lexers)\nI noticed that the analyzer was considering that writes through symbolic\npointers could be treated as clobbering static globals such as:\n\n   static YY_BUFFER_STATE * yy_buffer_stack = NULL;\n\neven for such variables that never have their address taken.\n\nThis patch fixes this issue at least, so that the analyzer can preserve\nknowledge of such globals on code paths with writes through symbolic\npointers.\n\nIt does not fix the false +ve in the lexer code.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/103546\n\t* store.cc (store::eval_alias_1): Refactor handling of decl\n\tregions, adding a test for may_be_aliased, rejecting those for\n\twhich it returns false.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/103546\n\t* gcc.dg/analyzer/aliasing-3.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "70e8a2f5584e04aad396bdd87d181f01f123a8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e8a2f5584e04aad396bdd87d181f01f123a8f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d564a83d14252d7db01381f71900b7a68357803b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d564a83d14252d7db01381f71900b7a68357803b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d564a83d14252d7db01381f71900b7a68357803b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d564a83d14252d7db01381f71900b7a68357803b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e2771069ed0c157cca825d6af5792e94c4407c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2771069ed0c157cca825d6af5792e94c4407c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2771069ed0c157cca825d6af5792e94c4407c1"}], "stats": {"total": 93, "additions": 86, "deletions": 7}, "files": [{"sha": "3f91b6107a945976e8b87e0958648dbbf9e9027d", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d564a83d14252d7db01381f71900b7a68357803b/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d564a83d14252d7db01381f71900b7a68357803b/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=d564a83d14252d7db01381f71900b7a68357803b", "patch": "@@ -2456,13 +2456,17 @@ store::eval_alias_1 (const region *base_reg_a,\n       = base_reg_a->dyn_cast_symbolic_region ())\n     {\n       const svalue *sval_a = sym_reg_a->get_pointer ();\n-      if (sval_a->get_kind () == SK_INITIAL)\n-\tif (tree decl_b = base_reg_b->maybe_get_decl ())\n-\t  if (!is_global_var (decl_b))\n-\t    {\n-\t      /* The initial value of a pointer can't point to a local.  */\n-\t      return tristate::TS_FALSE;\n-\t    }\n+      if (tree decl_b = base_reg_b->maybe_get_decl ())\n+\t{\n+\t  if (!may_be_aliased (decl_b))\n+\t    return tristate::TS_FALSE;\n+\t  if (sval_a->get_kind () == SK_INITIAL)\n+\t    if (!is_global_var (decl_b))\n+\t      {\n+\t\t/* The initial value of a pointer can't point to a local.  */\n+\t\treturn tristate::TS_FALSE;\n+\t      }\n+\t}\n       if (sval_a->get_kind () == SK_INITIAL\n \t  && base_reg_b->get_kind () == RK_HEAP_ALLOCATED)\n \t{"}, {"sha": "003077ad5c1a7e8c30b36b79e9574df34e658753", "filename": "gcc/testsuite/gcc.dg/analyzer/aliasing-3.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d564a83d14252d7db01381f71900b7a68357803b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d564a83d14252d7db01381f71900b7a68357803b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-3.c?ref=d564a83d14252d7db01381f71900b7a68357803b", "patch": "@@ -0,0 +1,75 @@\n+#include \"analyzer-decls.h\"\n+\n+#define NULL ((void *)0)\n+\n+struct s1\n+{\n+  int f1;\n+};\n+\n+static struct s1 *p1_glob = NULL;\n+\n+void test_1 (struct s1 **pp1, struct s1 *p1_parm)\n+{\n+  struct s1 *init_p1_glob = p1_glob;\n+\n+  __analyzer_eval (p1_glob == init_p1_glob); /* { dg-warning \"TRUE\" } */\n+\n+  if (!p1_glob)\n+    return;\n+\n+  __analyzer_eval (p1_glob == init_p1_glob); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p1_glob != NULL); /* { dg-warning \"TRUE\" } */\n+\n+  *pp1 = p1_parm;\n+\n+  /* The write through *pp1 can't have changed p1_glob, because\n+     we never take a pointer to p1_glob (and it's static to this TU).  */\n+  __analyzer_eval (p1_glob == init_p1_glob); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p1_glob != NULL); /* { dg-warning \"TRUE\" } */\n+}\n+\n+struct s2\n+{\n+  int f1;\n+};\n+\n+static struct s2 *p2_glob = NULL;\n+\n+void test_2 (struct s2 **pp2, struct s2 *p2_parm)\n+{\n+  /* Ensure that p2_glob is modified.  */\n+  p2_glob = __builtin_malloc (sizeof (struct s2));\n+  if (!p2_glob)\n+    return;\n+\n+  __analyzer_eval (p2_glob != NULL); /* { dg-warning \"TRUE\" } */\n+\n+  *pp2 = p2_parm;\n+\n+  /* The write through *pp2 can't have changed p2_glob, because\n+     we never take a pointer to p2_glob (and it's static to this TU).  */\n+  __analyzer_eval (p2_glob != NULL); /* { dg-warning \"TRUE\" } */\n+}\n+\n+struct s3\n+{\n+  int f1;\n+};\n+\n+struct s3 *p3_glob = NULL;\n+\n+void test_3 (struct s3 **pp3, struct s3 *p3_parm)\n+{\n+  p3_glob = __builtin_malloc (sizeof (struct s3));\n+  if (!p3_glob)\n+    return;\n+\n+  __analyzer_eval (p3_glob != NULL); /* { dg-warning \"TRUE\" } */\n+\n+  *pp3 = p3_parm;\n+\n+  /* The write through *pp3 could have changed p3_glob, because\n+     another TU could take a pointer to p3_glob.  */\n+  __analyzer_eval (p3_glob != NULL); /* { dg-warning \"UNKNOWN\" } */\n+}"}]}