{"sha": "c0c248220bb16284fabcf996fcca87e44cd4a98a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjMjQ4MjIwYmIxNjI4NGZhYmNmOTk2ZmNjYTg3ZTQ0Y2Q0YTk4YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-16T19:20:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-16T19:20:25Z"}, "message": "name-lookup.c (check_local_shadow): New, broke out of ...\n\n\t* name-lookup.c (check_local_shadow): New, broke out of ...\n\t(pushdecl_maybe_friend_1): ... here.  Call it.\n\nFrom-SVN: r248123", "tree": {"sha": "08f0c2278688bcbd735a7db3866ad0c62b4d35a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08f0c2278688bcbd735a7db3866ad0c62b4d35a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0c248220bb16284fabcf996fcca87e44cd4a98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c248220bb16284fabcf996fcca87e44cd4a98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c248220bb16284fabcf996fcca87e44cd4a98a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c248220bb16284fabcf996fcca87e44cd4a98a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3d762eb74026a85de6848f5fe09e4fbdefe19cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d762eb74026a85de6848f5fe09e4fbdefe19cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d762eb74026a85de6848f5fe09e4fbdefe19cc"}], "stats": {"total": 430, "additions": 215, "deletions": 215}, "files": [{"sha": "6ce4bbb4d9fb6df5abbb005133b8f9afa6319bc6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c248220bb16284fabcf996fcca87e44cd4a98a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c248220bb16284fabcf996fcca87e44cd4a98a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c0c248220bb16284fabcf996fcca87e44cd4a98a", "patch": "@@ -1,5 +1,8 @@\n 2017-05-16  Nathan Sidwell  <nathan@acm.org>\n \n+\t* name-lookup.c (check_local_shadow): New, broke out of ...\n+\t(pushdecl_maybe_friend_1): ... here.  Call it.\n+\n \t* cp-tree.h (OVL_NESTED_P, OVL_LOOKUP_P): New.\n \t(ovl_first): Move inline definition to end of file.\n \t(ovl_make, lookup_add): Declare."}, {"sha": "acd8b14c5b77a4e1f870e1fe525bf1f90e00f29b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 212, "deletions": 215, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c248220bb16284fabcf996fcca87e44cd4a98a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c248220bb16284fabcf996fcca87e44cd4a98a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c0c248220bb16284fabcf996fcca87e44cd4a98a", "patch": "@@ -1184,6 +1184,215 @@ supplement_binding (cxx_binding *binding, tree decl)\n   return ret;\n }\n \n+/* DECL is being declared at a local scope.  Emit suitable shadow\n+   warnings.  */\n+\n+static void\n+check_local_shadow (tree decl)\n+{\n+  /* Don't complain about the parms we push and then pop\n+     while tentatively parsing a function declarator.  */\n+  if (TREE_CODE (decl) == PARM_DECL && !DECL_CONTEXT (decl))\n+    return;\n+\n+  /* Inline decls shadow nothing.  */\n+  if (DECL_FROM_INLINE (decl))\n+    return;\n+\n+  /* External decls are something else.  */\n+  if (DECL_EXTERNAL (decl))\n+    return;\n+\n+  tree old = NULL_TREE;\n+  cp_binding_level *old_scope = NULL;\n+  if (cxx_binding *binding = outer_binding (DECL_NAME (decl), NULL, true))\n+    {\n+      old = binding->value;\n+      old_scope = binding->scope;\n+    }\n+  while (old && VAR_P (old) && DECL_DEAD_FOR_LOCAL (old))\n+    old = DECL_SHADOWED_FOR_VAR (old);\n+\n+  tree shadowed = NULL_TREE;\n+  if (old\n+      && (TREE_CODE (old) == PARM_DECL\n+\t  || VAR_P (old)\n+\t  || (TREE_CODE (old) == TYPE_DECL\n+\t      && (!DECL_ARTIFICIAL (old)\n+\t\t  || TREE_CODE (decl) == TYPE_DECL)))\n+      && (!DECL_ARTIFICIAL (decl)\n+\t  || DECL_IMPLICIT_TYPEDEF_P (decl)\n+\t  || (VAR_P (decl) && DECL_ANON_UNION_VAR_P (decl))))\n+    {\n+      /* DECL shadows a local thing possibly of interest.  */\n+\n+      /* Don't complain if it's from an enclosing function.  */\n+      if (DECL_CONTEXT (old) == current_function_decl\n+\t  && TREE_CODE (decl) != PARM_DECL\n+\t  && TREE_CODE (old) == PARM_DECL)\n+\t{\n+\t  /* Go to where the parms should be and see if we find\n+\t     them there.  */\n+\t  cp_binding_level *b = current_binding_level->level_chain;\n+\n+\t  if (FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))\n+\t    /* Skip the ctor/dtor cleanup level.  */\n+\t    b = b->level_chain;\n+\n+\t  /* ARM $8.3 */\n+\t  if (b->kind == sk_function_parms)\n+\t    {\n+\t      error (\"declaration of %q#D shadows a parameter\", decl);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* The local structure or class can't use parameters of\n+\t the containing function anyway.  */\n+      if (DECL_CONTEXT (old) != current_function_decl)\n+\t{\n+\t  for (cp_binding_level *scope = current_binding_level;\n+\t       scope != old_scope; scope = scope->level_chain)\n+\t    if (scope->kind == sk_class\n+\t\t&& !LAMBDA_TYPE_P (scope->this_entity))\n+\t      return;\n+\t}\n+      /* Error if redeclaring a local declared in a\n+\t init-statement or in the condition of an if or\n+\t switch statement when the new declaration is in the\n+\t outermost block of the controlled statement.\n+\t Redeclaring a variable from a for or while condition is\n+\t detected elsewhere.  */\n+      else if (VAR_P (old)\n+\t       && old_scope == current_binding_level->level_chain\n+\t       && (old_scope->kind == sk_cond || old_scope->kind == sk_for))\n+\t{\n+\t  error (\"redeclaration of %q#D\", decl);\n+\t  inform (DECL_SOURCE_LOCATION (old),\n+\t\t  \"%q#D previously declared here\", old);\n+\t  return;\n+\t}\n+      /* C++11:\n+\t 3.3.3/3:  The name declared in an exception-declaration (...)\n+\t shall not be redeclared in the outermost block of the handler.\n+\t 3.3.3/2:  A parameter name shall not be redeclared (...) in\n+\t the outermost block of any handler associated with a\n+\t function-try-block.\n+\t 3.4.1/15: The function parameter names shall not be redeclared\n+\t in the exception-declaration nor in the outermost block of a\n+\t handler for the function-try-block.  */\n+      else if ((TREE_CODE (old) == VAR_DECL\n+\t\t&& old_scope == current_binding_level->level_chain\n+\t\t&& old_scope->kind == sk_catch)\n+\t       || (TREE_CODE (old) == PARM_DECL\n+\t\t   && (current_binding_level->kind == sk_catch\n+\t\t       || current_binding_level->level_chain->kind == sk_catch)\n+\t\t   && in_function_try_handler))\n+\t{\n+\t  if (permerror (input_location, \"redeclaration of %q#D\", decl))\n+\t    inform (DECL_SOURCE_LOCATION (old),\n+\t\t    \"%q#D previously declared here\", old);\n+\t  return;\n+\t}\n+\n+      /* If '-Wshadow=compatible-local' is specified without other\n+\t -Wshadow= flags, we will warn only when the type of the\n+\t shadowing variable (DECL) can be converted to that of the\n+\t shadowed parameter (OLD_LOCAL). The reason why we only check\n+\t if DECL's type can be converted to OLD_LOCAL's type (but not the\n+\t other way around) is because when users accidentally shadow a\n+\t parameter, more than often they would use the variable\n+\t thinking (mistakenly) it's still the parameter. It would be\n+\t rare that users would use the variable in the place that\n+\t expects the parameter but thinking it's a new decl.  */\n+\n+      enum opt_code warning_code;\n+      if (warn_shadow)\n+\twarning_code = OPT_Wshadow;\n+      else if (warn_shadow_local)\n+\twarning_code = OPT_Wshadow_local;\n+      else if (warn_shadow_compatible_local\n+\t       && can_convert (TREE_TYPE (old), TREE_TYPE (decl), tf_none))\n+\twarning_code = OPT_Wshadow_compatible_local;\n+      else\n+\treturn;\n+\n+      const char *msg;\n+      if (TREE_CODE (old) == PARM_DECL)\n+\tmsg = \"declaration of %q#D shadows a parameter\";\n+      else if (is_capture_proxy (old))\n+\tmsg = \"declaration of %qD shadows a lambda capture\";\n+      else\n+\tmsg = \"declaration of %qD shadows a previous local\";\n+\n+      if (warning_at (input_location, warning_code, msg, decl))\n+\t{\n+\t  shadowed = old;\n+\t  goto inform_shadowed;\n+\t}\n+      return;\n+    }\n+\n+  if (!warn_shadow)\n+    return;\n+\n+  /* Don't warn for artificial things that are not implicit typedefs.  */\n+  if (DECL_ARTIFICIAL (decl) && !DECL_IMPLICIT_TYPEDEF_P (decl))\n+    return;\n+  \n+  if (nonlambda_method_basetype ())\n+    if (tree member = lookup_member (current_nonlambda_class_type (),\n+\t\t\t\t     DECL_NAME (decl), /*protect=*/0,\n+\t\t\t\t     /*want_type=*/false, tf_warning_or_error))\n+      {\n+\tmember = MAYBE_BASELINK_FUNCTIONS (member);\n+\n+\t/* Warn if a variable shadows a non-function, or the variable\n+\t   is a function or a pointer-to-function.  */\n+\tif ((TREE_CODE (member) != FUNCTION_DECL\n+\t     && TREE_CODE (member) != OVERLOAD)\n+\t    || TREE_CODE (decl) == FUNCTION_DECL\n+\t    || TYPE_PTRFN_P (TREE_TYPE (decl))\n+\t    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))\n+\t  {\n+\t    if (warning_at (input_location, OPT_Wshadow,\n+\t\t\t    \"declaration of %qD shadows a member of %qT\",\n+\t\t\t    decl, current_nonlambda_class_type ())\n+\t\t&& DECL_P (member))\n+\t      {\n+\t\tshadowed = member;\n+\t\tgoto inform_shadowed;\n+\t      }\n+\t  }\n+\treturn;\n+      }\n+\n+  /* Now look for a namespace shadow.  */\n+  old = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+  if (old\n+      && (VAR_P (old)\n+\t  || (TREE_CODE (old) == TYPE_DECL\n+\t      && (!DECL_ARTIFICIAL (old)\n+\t\t  || TREE_CODE (decl) == TYPE_DECL)))\n+      && !instantiating_current_function_p ())\n+    /* XXX shadow warnings in outer-more namespaces */\n+    {\n+      if (warning_at (input_location, OPT_Wshadow,\n+\t\t      \"declaration of %qD shadows a global declaration\",\n+\t\t      decl))\n+\t{\n+\t  shadowed = old;\n+\t  goto inform_shadowed;\n+\t}\n+      return;\n+    }\n+\n+  return;\n+\n+ inform_shadowed:\n+  inform (DECL_SOURCE_LOCATION (shadowed), \"shadowed declaration is here\");\n+}\n+\n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n    name already seen in the same scope).  IS_FRIEND is true if X is\n@@ -1570,13 +1779,11 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t  /* Here to install a non-global value.  */\n \t  tree oldglobal = get_namespace_binding (current_namespace, name);\n \t  tree oldlocal = NULL_TREE;\n-\t  cp_binding_level *oldscope = NULL;\n \t  cxx_binding *oldbinding = outer_binding (name, NULL, true);\n \t  if (oldbinding)\n-\t    {\n-\t      oldlocal = oldbinding->value;\n-\t      oldscope = oldbinding->scope;\n-\t    }\n+\t    oldlocal = oldbinding->value;\n+\n+\t  check_local_shadow (x);\n \n \t  if (need_new_binding)\n \t    {\n@@ -1637,216 +1844,6 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t      && DECL_EXTERNAL (x)\n \t      && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n-\n-\t  /* Don't complain about the parms we push and then pop\n-\t     while tentatively parsing a function declarator.  */\n-\t  if (TREE_CODE (x) == PARM_DECL && DECL_CONTEXT (x) == NULL_TREE)\n-\t    /* Ignore.  */;\n-\n-\t  /* Warn if shadowing an argument at the top level of the body.  */\n-\t  else if (oldlocal != NULL_TREE && !DECL_EXTERNAL (x)\n-\t\t   /* Inline decls shadow nothing.  */\n-\t\t   && !DECL_FROM_INLINE (x)\n-\t\t   && (TREE_CODE (oldlocal) == PARM_DECL\n-\t\t       || VAR_P (oldlocal)\n-                       /* If the old decl is a type decl, only warn if the\n-                          old decl is an explicit typedef or if both the old\n-                          and new decls are type decls.  */\n-                       || (TREE_CODE (oldlocal) == TYPE_DECL\n-                           && (!DECL_ARTIFICIAL (oldlocal)\n-                               || TREE_CODE (x) == TYPE_DECL)))\n-                   /* Don't check for internally generated vars unless\n-                      it's an implicit typedef (see create_implicit_typedef\n-                      in decl.c) or anonymous union variable.  */\n-\t\t   && (!DECL_ARTIFICIAL (x)\n-\t\t       || DECL_IMPLICIT_TYPEDEF_P (x)\n-\t\t       || (VAR_P (x) && DECL_ANON_UNION_VAR_P (x))))\n-\t    {\n-\t      bool nowarn = false;\n-\n-\t      /* Don't complain if it's from an enclosing function.  */\n-\t      if (DECL_CONTEXT (oldlocal) == current_function_decl\n-\t\t  && TREE_CODE (x) != PARM_DECL\n-\t\t  && TREE_CODE (oldlocal) == PARM_DECL)\n-\t\t{\n-\t\t  /* Go to where the parms should be and see if we find\n-\t\t     them there.  */\n-\t\t  cp_binding_level *b = current_binding_level->level_chain;\n-\n-\t\t  if (FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))\n-\t\t    /* Skip the ctor/dtor cleanup level.  */\n-\t\t    b = b->level_chain;\n-\n-\t\t  /* ARM $8.3 */\n-\t\t  if (b->kind == sk_function_parms)\n-\t\t    {\n-\t\t      error (\"declaration of %q#D shadows a parameter\", x);\n-\t\t      nowarn = true;\n-\t\t    }\n-\t\t}\n-\n-\t      /* The local structure or class can't use parameters of\n-\t\t the containing function anyway.  */\n-\t      if (DECL_CONTEXT (oldlocal) != current_function_decl)\n-\t\t{\n-\t\t  cp_binding_level *scope = current_binding_level;\n-\t\t  tree context = DECL_CONTEXT (oldlocal);\n-\t\t  for (; scope; scope = scope->level_chain)\n-\t\t   {\n-\t\t     if (scope->kind == sk_function_parms\n-\t\t\t && scope->this_entity == context)\n-\t\t      break;\n-\t\t     if (scope->kind == sk_class\n-\t\t\t && !LAMBDA_TYPE_P (scope->this_entity))\n-\t\t       {\n-\t\t\t nowarn = true;\n-\t\t\t break;\n-\t\t       }\n-\t\t   }\n-\t\t}\n-\t      /* Error if redeclaring a local declared in a\n-\t\t init-statement or in the condition of an if or\n-\t\t switch statement when the new declaration is in the\n-\t\t outermost block of the controlled statement.\n-\t\t Redeclaring a variable from a for or while condition is\n-\t\t detected elsewhere.  */\n-\t      else if (VAR_P (oldlocal)\n-\t\t       && oldscope == current_binding_level->level_chain\n-\t\t       && (oldscope->kind == sk_cond\n-\t\t\t   || oldscope->kind == sk_for))\n-\t\t{\n-\t\t  error (\"redeclaration of %q#D\", x);\n-\t\t  inform (DECL_SOURCE_LOCATION (oldlocal),\n-\t\t\t  \"%q#D previously declared here\", oldlocal);\n-\t\t  nowarn = true;\n-\t\t}\n-\t      /* C++11:\n-\t\t 3.3.3/3:  The name declared in an exception-declaration (...)\n-\t\t shall not be redeclared in the outermost block of the handler.\n-\t\t 3.3.3/2:  A parameter name shall not be redeclared (...) in\n-\t\t the outermost block of any handler associated with a\n-\t\t function-try-block.\n-\t\t 3.4.1/15: The function parameter names shall not be redeclared\n-\t\t in the exception-declaration nor in the outermost block of a\n-\t\t handler for the function-try-block.  */\n-\t      else if ((VAR_P (oldlocal)\n-\t\t\t&& oldscope == current_binding_level->level_chain\n-\t\t\t&& oldscope->kind == sk_catch)\n-\t\t       || (TREE_CODE (oldlocal) == PARM_DECL\n-\t\t\t   && (current_binding_level->kind == sk_catch\n-\t\t\t       || (current_binding_level->level_chain->kind\n-\t\t\t\t   == sk_catch))\n-\t\t\t   && in_function_try_handler))\n-\t\t{\n-\t\t  if (permerror (input_location, \"redeclaration of %q#D\", x))\n-\t\t    inform (DECL_SOURCE_LOCATION (oldlocal),\n-\t\t\t    \"%q#D previously declared here\", oldlocal);\n-\t\t  nowarn = true;\n-\t\t}\n-\n-\t      if ((warn_shadow\n-\t\t   || warn_shadow_local\n-\t\t   || warn_shadow_compatible_local)\n-\t\t  && !nowarn)\n-\t\t{\n-\t\t  bool warned;\n-\t\t  enum opt_code warning_code;\n-\t\t  /* If '-Wshadow=compatible-local' is specified without other\n-\t\t     -Wshadow= flags, we will warn only when the type of the\n-\t\t     shadowing variable (i.e. x) can be converted to that of\n-\t\t     the shadowed parameter (oldlocal). The reason why we only\n-\t\t     check if x's type can be converted to oldlocal's type\n-\t\t     (but not the other way around) is because when users\n-\t\t     accidentally shadow a parameter, more than often they\n-\t\t     would use the variable thinking (mistakenly) it's still\n-\t\t     the parameter. It would be rare that users would use the\n-\t\t     variable in the place that expects the parameter but\n-\t\t     thinking it's a new decl.  */\n-\t\t  if (warn_shadow)\n-\t\t    warning_code = OPT_Wshadow;\n-\t\t  else if (can_convert (TREE_TYPE (oldlocal), TREE_TYPE (x),\n-\t\t\t\t\ttf_none))\n-\t\t    warning_code = OPT_Wshadow_compatible_local;\n-\t\t  else\n-\t\t    warning_code = OPT_Wshadow_local;\n-\n-\t\t  if (TREE_CODE (oldlocal) == PARM_DECL)\n-\t\t    warned = warning_at (input_location, warning_code,\n-\t\t\t\t\"declaration of %q#D shadows a parameter\", x);\n-\t\t  else if (is_capture_proxy (oldlocal))\n-\t\t    warned = warning_at (input_location, warning_code,\n-\t\t\t\t\"declaration of %qD shadows a lambda capture\",\n-\t\t\t\tx);\n-\t\t  else\n-\t\t    warned = warning_at (input_location, warning_code,\n-\t\t\t\t\"declaration of %qD shadows a previous local\",\n-\t\t\t\tx);\n-\n-\t\t  if (warned)\n-\t\t    inform (DECL_SOURCE_LOCATION (oldlocal),\n-\t\t\t    \"shadowed declaration is here\");\n-\t\t}\n-\t    }\n-\n-\t  /* Maybe warn if shadowing something else.  */\n-\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n-                   /* No shadow warnings for internally generated vars unless\n-                      it's an implicit typedef (see create_implicit_typedef\n-                      in decl.c).  */\n-                   && (! DECL_ARTIFICIAL (x) || DECL_IMPLICIT_TYPEDEF_P (x))\n-                   /* No shadow warnings for vars made for inlining.  */\n-                   && ! DECL_FROM_INLINE (x))\n-\t    {\n-\t      tree member;\n-\n-\t      if (nonlambda_method_basetype ())\n-\t\tmember = lookup_member (current_nonlambda_class_type (),\n-\t\t\t\t\tname,\n-\t\t\t\t\t/*protect=*/0,\n-\t\t\t\t\t/*want_type=*/false,\n-\t\t\t\t\ttf_warning_or_error);\n-\t      else\n-\t\tmember = NULL_TREE;\n-\n-\t      if (member && !TREE_STATIC (member))\n-\t\t{\n-\t\t  if (BASELINK_P (member))\n-\t\t    member = BASELINK_FUNCTIONS (member);\n-\t\t  member = OVL_CURRENT (member);\n-\t\n-\t\t  /* Do not warn if a variable shadows a function, unless\n-\t\t     the variable is a function or a pointer-to-function.  */\n-\t\t  if (TREE_CODE (member) != FUNCTION_DECL\n-\t\t      || TREE_CODE (x) == FUNCTION_DECL\n-\t\t      || TYPE_PTRFN_P (TREE_TYPE (x))\n-\t\t      || TYPE_PTRMEMFUNC_P (TREE_TYPE (x)))\n-\t\t    {\n-\t\t      if (warning_at (input_location, OPT_Wshadow,\n-\t\t\t\t      \"declaration of %qD shadows a member of %qT\",\n-\t\t\t\t      x, current_nonlambda_class_type ())\n-\t\t\t  && DECL_P (member))\n-\t\t\tinform (DECL_SOURCE_LOCATION (member),\n-\t\t\t\t\"shadowed declaration is here\");\n-\t\t    }\n-\t\t}\n-\t      else if (oldglobal != NULL_TREE\n-\t\t       && (VAR_P (oldglobal)\n-                           /* If the old decl is a type decl, only warn if the\n-                              old decl is an explicit typedef or if both the\n-                              old and new decls are type decls.  */\n-                           || (TREE_CODE (oldglobal) == TYPE_DECL\n-                               && (!DECL_ARTIFICIAL (oldglobal)\n-                                   || TREE_CODE (x) == TYPE_DECL)))\n-\t\t       && !instantiating_current_function_p ())\n-\t\t/* XXX shadow warnings in outer-more namespaces */\n-\t\t{\n-\t\t  if (warning_at (input_location, OPT_Wshadow,\n-\t\t\t\t  \"declaration of %qD shadows a \"\n-\t\t\t\t  \"global declaration\", x))\n-\t\t    inform (DECL_SOURCE_LOCATION (oldglobal),\n-\t\t\t    \"shadowed declaration is here\");\n-\t\t}\n-\t    }\n \t}\n \n       if (VAR_P (x))"}]}