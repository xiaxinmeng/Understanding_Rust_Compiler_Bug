{"sha": "261ba0c8dbb450cc88a56e6869f962964d6e9e91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxYmEwYzhkYmI0NTBjYzg4YTU2ZTY4NjlmOTYyOTY0ZDZlOWU5MQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-01-31T11:51:01Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-01-31T11:51:01Z"}, "message": "tree-vectorizer.c (vect_analyze_offset_expr): Use ssizetype instead sizetype.\n\n2005-01-31  Ira Rosen  <irar@il.ibm.com>\n\n        * tree-vectorizer.c (vect_analyze_offset_expr): Use ssizetype instead\n        sizetype.\n        (vect_get_base_and_offset): Use ssizetype instead sizetype. Remove\n        redundant fold. Fix misalignment for MINUS_EXPR.\n        (vect_compute_data_ref_alignment): Use ssizetype instead sizetype.\n        (vect_analyze_pointer_ref_access): Likewise.\n        (vect_get_memtag_and_dr): Likewise.\n\nFrom-SVN: r94480", "tree": {"sha": "d23bb7ff1284fb23ae8953e563f94d574d4276d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d23bb7ff1284fb23ae8953e563f94d574d4276d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261ba0c8dbb450cc88a56e6869f962964d6e9e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ba0c8dbb450cc88a56e6869f962964d6e9e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261ba0c8dbb450cc88a56e6869f962964d6e9e91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ba0c8dbb450cc88a56e6869f962964d6e9e91/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ae1ac77f26d32ab66cc93dc2c6183e58bd72854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ae1ac77f26d32ab66cc93dc2c6183e58bd72854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ae1ac77f26d32ab66cc93dc2c6183e58bd72854"}], "stats": {"total": 99, "additions": 55, "deletions": 44}, "files": [{"sha": "1a428646ce53e39e6be1df475ef13345f49b0ae0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261ba0c8dbb450cc88a56e6869f962964d6e9e91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261ba0c8dbb450cc88a56e6869f962964d6e9e91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=261ba0c8dbb450cc88a56e6869f962964d6e9e91", "patch": "@@ -1,3 +1,13 @@\n+2005-01-31  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_analyze_offset_expr): Use ssizetype instead\n+\tsizetype.\n+\t(vect_get_base_and_offset): Use ssizetype instead sizetype. Remove\n+\tredundant fold. Fix misalignment for MINUS_EXPR.\n+\t(vect_compute_data_ref_alignment): Use ssizetype instead sizetype.\n+\t(vect_analyze_pointer_ref_access): Likewise.\n+\t(vect_get_memtag_and_dr): Likewise.\n+\n 2005-01-31  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (absnegsf2_mixed): Remove all of the # hackery."}, {"sha": "6e2b91a58c961c5b11900ee9bc7d2b48f21ebce6", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261ba0c8dbb450cc88a56e6869f962964d6e9e91/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261ba0c8dbb450cc88a56e6869f962964d6e9e91/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=261ba0c8dbb450cc88a56e6869f962964d6e9e91", "patch": "@@ -1407,12 +1407,12 @@ vect_analyze_offset_expr (tree expr,\n {\n   tree oprnd0;\n   tree oprnd1;\n-  tree left_offset = size_zero_node;\n-  tree right_offset = size_zero_node;\n-  tree left_misalign = size_zero_node;\n-  tree right_misalign = size_zero_node;\n-  tree left_step = size_zero_node;\n-  tree right_step = size_zero_node;\n+  tree left_offset = ssize_int (0);\n+  tree right_offset = ssize_int (0);\n+  tree left_misalign = ssize_int (0);\n+  tree right_misalign = ssize_int (0);\n+  tree left_step = ssize_int (0);\n+  tree right_step = ssize_int (0);\n   enum tree_code code;\n   tree init, evolution;\n \n@@ -1429,9 +1429,9 @@ vect_analyze_offset_expr (tree expr,\n      1. Constant.  */\n   if (TREE_CODE (expr) == INTEGER_CST)\n     {\n-      *initial_offset = fold_convert (sizetype, expr);\n-      *misalign = fold_convert (sizetype, expr);      \n-      *step = size_zero_node;\n+      *initial_offset = fold_convert (ssizetype, expr);\n+      *misalign = fold_convert (ssizetype, expr);      \n+      *step = ssize_int (0);\n       return true;\n     }\n \n@@ -1459,14 +1459,14 @@ vect_analyze_offset_expr (tree expr,\n \treturn false;\n \n       if (TREE_CODE (init) == INTEGER_CST)\n-\t*misalign = fold_convert (sizetype, init);\n+\t*misalign = fold_convert (ssizetype, init);\n       else\n \t/* Not constant, misalignment cannot be calculated.  */\n \t*misalign = NULL_TREE;\n \n-      *initial_offset = fold_convert (sizetype, init); \n+      *initial_offset = fold_convert (ssizetype, init); \n \n-      *step = evolution ? fold_convert (sizetype, evolution) : size_zero_node;\n+      *step = evolution ? fold_convert (ssizetype, evolution) : ssize_int (0);\n       return true;      \n     }\n \n@@ -1511,8 +1511,8 @@ vect_analyze_offset_expr (tree expr,\n \t  /* If the left side contains variable that cannot be substituted with \n \t     constant, we check if the right side is a multiple of ALIGNMENT.  */\n \t  if (integer_zerop (size_binop (TRUNC_MOD_EXPR, right_offset, \n-\t\t\t\t\t vectype_alignment)))\n-\t    *misalign = size_zero_node;\n+\t\t\t          fold_convert (ssizetype, vectype_alignment))))\n+\t    *misalign = ssize_int (0);\n \t  else\n \t    /* If the remainder is not zero or the right side isn't constant, we \n \t       can't compute  misalignment.  */\n@@ -1551,7 +1551,7 @@ vect_analyze_offset_expr (tree expr,\n     }\n \n   /* Compute offset.  */\n-  *initial_offset = fold_convert (sizetype, \n+  *initial_offset = fold_convert (ssizetype, \n \t\t\t\t  fold (build2 (code, TREE_TYPE (left_offset), \n \t\t\t\t\t\tleft_offset, \n \t\t\t\t\t\tright_offset)));\n@@ -1602,9 +1602,9 @@ vect_get_base_and_offset (struct data_reference *dr,\n \t\t\t  tree *step,\n \t\t\t  bool *base_aligned_p)\n {\n-  tree this_offset = size_zero_node;\n-  tree this_misalign = size_zero_node;\n-  tree this_step = size_zero_node;\n+  tree this_offset = ssize_int (0);\n+  tree this_misalign = ssize_int (0);\n+  tree this_step = ssize_int (0);\n   tree base = NULL_TREE;\n   tree next_ref;\n   tree oprnd0, oprnd1;\n@@ -1624,9 +1624,9 @@ vect_get_base_and_offset (struct data_reference *dr,\n     /* These cases end the recursion:  */\n     case VAR_DECL:\n     case PARM_DECL:\n-      *initial_offset = size_zero_node;\n-      *step = size_zero_node;\n-      *misalign = size_zero_node;\n+      *initial_offset = ssize_int (0);\n+      *step = ssize_int (0);\n+      *misalign = ssize_int (0);\n       if (DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n \t*base_aligned_p = true;\n       return expr;\n@@ -1644,16 +1644,16 @@ vect_get_base_and_offset (struct data_reference *dr,\n       else\n \t{\t  \n \t  *base_aligned_p = true;\n-\t  *misalign = size_zero_node;\n+\t  *misalign = ssize_int (0);\n \t}\n-      *initial_offset = size_zero_node;\n-      *step = size_zero_node;\n+      *initial_offset = ssize_int (0);\n+      *step = ssize_int (0);\n       return expr;\n       \n     case INTEGER_CST:      \n-      *initial_offset = fold_convert (sizetype, expr);\n-      *misalign = fold_convert (sizetype, expr);\n-      *step = size_zero_node;\n+      *initial_offset = fold_convert (ssizetype, expr);\n+      *misalign = fold_convert (ssizetype, expr);\n+      *step = ssize_int (0);\n       return expr;\n \n     /* These cases continue the recursion:  */\n@@ -1679,11 +1679,13 @@ vect_get_base_and_offset (struct data_reference *dr,\n \t\t\t\t       &this_offset, &this_misalign, \n \t\t\t\t       &this_step, base_aligned_p);  \n       /* Offset was already computed in vect_analyze_pointer_ref_access.  */\n-      this_offset = size_zero_node;\n+      this_offset = ssize_int (0);\n \n       if (!base) \n \tthis_misalign = NULL_TREE;\n-\n+      else\n+\tthis_misalign = size_binop (TREE_CODE (expr), ssize_int (0),\n+\t\t\t\t    this_misalign);\n       next_ref = oprnd0;\n       break;\n \n@@ -1712,16 +1714,16 @@ vect_get_base_and_offset (struct data_reference *dr,\n \n       /* Add bit position to OFFSET and MISALIGN.  */\n \n-      bit_pos_in_bytes = size_int (pbitpos/BITS_PER_UNIT);\n+      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n       /* Check that there is no remainder in bits.  */\n       if (pbitpos%BITS_PER_UNIT)\n \t{\n \t  if (vect_debug_details (NULL))\n \t    fprintf (dump_file, \"bit offset alignment.\");\n \t  return NULL_TREE;\n \t}\n-      this_offset = fold (size_binop (PLUS_EXPR, bit_pos_in_bytes, \n-\t\t\t\t      fold_convert (sizetype, this_offset)));     \n+      this_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, \n+\t\t\t\tfold_convert (ssizetype, this_offset));     \n       if (this_misalign) \n \tthis_misalign = size_binop (PLUS_EXPR, this_misalign, bit_pos_in_bytes); \n \n@@ -1743,8 +1745,7 @@ vect_get_base_and_offset (struct data_reference *dr,\n \n       *step = size_binop (PLUS_EXPR, *step, this_step);\n \n-      *initial_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (*initial_offset), \n-\t\t\t\t      *initial_offset, this_offset));\n+      *initial_offset = size_binop (PLUS_EXPR, *initial_offset, this_offset);\n \n       if (vect_debug_details (NULL))\n         {\n@@ -4201,7 +4202,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t\t  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));\n \n   /* Alignment required, in bytes:  */\n-  alignment = size_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n+  alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n \n   /* Modulo alignment.  */\n   misalign = size_binop (TRUNC_MOD_EXPR, misalign, alignment);\n@@ -4667,14 +4668,14 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n       return NULL;\n     }\n \n-  STMT_VINFO_VECT_STEP (stmt_info) = fold_convert (sizetype, step);\n+  STMT_VINFO_VECT_STEP (stmt_info) = fold_convert (ssizetype, step);\n   if (TREE_CODE (init) == PLUS_EXPR \n       || TREE_CODE (init) == MINUS_EXPR)\n     STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n-      fold (size_binop (TREE_CODE (init), size_zero_node, \n-\t\t\tfold_convert (sizetype, TREE_OPERAND (init, 1))));\n+      size_binop (TREE_CODE (init), ssize_int (0),  \n+\t\t  fold_convert (ssizetype, TREE_OPERAND (init, 1)));\n   else\n-    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = size_zero_node;\n+    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = ssize_int (0);\n \n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n@@ -4833,9 +4834,9 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t  return NULL_TREE;\n \t}  \n \n-      offset = size_zero_node;\n-      misalign = size_zero_node;\n-      step = size_zero_node;\n+      offset = ssize_int (0);\n+      misalign = ssize_int (0);\n+      step = ssize_int (0);\n \n       /* Analyze data-ref, find its base, initial offset from the base, step,\n \t and alignment.  */\n@@ -4850,8 +4851,8 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t vect_analyze_pointer_ref_access, we combine the values here. */\n       if (STMT_VINFO_VECT_INIT_OFFSET (stmt_info))\n \tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n-\t  fold (build2 (PLUS_EXPR, TREE_TYPE (offset), offset,\n-\t\t\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info)));\t\t  \n+\t  size_binop (PLUS_EXPR, offset, \n+\t\t      STMT_VINFO_VECT_INIT_OFFSET (stmt_info));\t\t  \n       else\n \tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n "}]}