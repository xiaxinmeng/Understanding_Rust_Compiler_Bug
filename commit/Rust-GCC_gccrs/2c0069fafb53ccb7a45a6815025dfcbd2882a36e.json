{"sha": "2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMwMDY5ZmFmYjUzY2NiN2E0NWE2ODE1MDI1ZGZjYmQyODgyYTM2ZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-06-20T07:42:12Z"}, "committer": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-06-20T07:42:12Z"}, "message": "Record and restore postorder information in breaking alias sccs.\n\ngcc/\n\tPR tree-optimization/95638\n\t* tree-loop-distribution.c (pg_edge_callback_data): New field.\n\t(loop_distribution::break_alias_scc_partitions): Record and restore\n\tpostorder information.  Fix memory leak.\n\ngcc/testsuite/\n\tPR tree-optimization/95638\n\t* g++.dg/tree-ssa/pr95638.C: New test.", "tree": {"sha": "774ce084e4cba18c67ba523b91a6242b4f2ff6f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/774ce084e4cba18c67ba523b91a6242b4f2ff6f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0069fafb53ccb7a45a6815025dfcbd2882a36e/comments", "author": null, "committer": null, "parents": [{"sha": "e37658dffdb5d4707e316180a0d5d5caee843744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37658dffdb5d4707e316180a0d5d5caee843744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37658dffdb5d4707e316180a0d5d5caee843744"}], "stats": {"total": 173, "additions": 167, "deletions": 6}, "files": [{"sha": "d1bea6dffaa953b14d81046b73e91cce751f570d", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr95638.C", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0069fafb53ccb7a45a6815025dfcbd2882a36e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr95638.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0069fafb53ccb7a45a6815025dfcbd2882a36e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr95638.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr95638.C?ref=2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "patch": "@@ -0,0 +1,150 @@\n+// PR tree-optimization/95638\n+// { dg-do run }\n+// { dg-options \"-O2 -std=c++14\" }\n+\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdint>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+\n+template <typename Derived>\n+class intrusive_ref_counter\n+{\n+public:\n+    intrusive_ref_counter() = default;\n+    \n+    intrusive_ref_counter(intrusive_ref_counter const&) :\n+        _counter(0)\n+    {\n+    }\n+\n+    friend void intrusive_ptr_add_ref(const intrusive_ref_counter<Derived>* p)\n+    {\n+        ++p->_counter;\n+    }\n+    \n+    friend void intrusive_ptr_release(const intrusive_ref_counter<Derived>* p)\n+    {\n+        if (--p->_counter == 0)\n+        {\n+            delete static_cast<const Derived*>(p);\n+        }\n+    }\n+    \n+private:\n+    mutable int _counter = 0;\n+};\n+\n+template <typename T>\n+class intrusive_ptr\n+{\n+public:\n+    intrusive_ptr() = default;\n+\n+    intrusive_ptr(T* p): px(p)\n+    {\n+        if (px != 0) intrusive_ptr_add_ref(px);\n+    }\n+\n+    intrusive_ptr(intrusive_ptr const & rhs): px(rhs.px)\n+    {\n+        if (px != 0) intrusive_ptr_add_ref(px);\n+    }\n+\n+    ~intrusive_ptr()\n+    {\n+        if (px != 0) intrusive_ptr_release(px);\n+    }\n+\n+    intrusive_ptr(intrusive_ptr && rhs) : px(rhs.px)\n+    {\n+        rhs.px = 0;\n+    }\n+\n+    explicit operator bool() const\n+    {\n+        return px != 0;\n+    }\n+    \n+private:\n+    T* px = nullptr;\n+};\n+\n+template <typename T, uint32_t MaxSize = 1>\n+class Storage\n+{\n+public:\n+    Storage() = default;\n+\n+    Storage(Storage&& other)\n+    {\n+        for (int i = 0; i < other._size; ++i)\n+        {\n+            new (data() + i) T(std::move(other.data()[i]));\n+            ++_size;\n+        }\n+    }\n+\n+    ~Storage()\n+    {\n+        for (int i = 0; i < _size; ++i)\n+        {\n+            data()[i].~T();\n+        }\n+    }\n+\n+    void push_back(const T& value)\n+    {\n+        assert(_size < MaxSize);\n+\n+        new (data() + _size) T(value);\n+        ++_size;\n+    }\n+    \n+    T& operator[](size_t idx)\n+    {\n+        assert(idx < _size);\n+        return data()[idx];\n+    }\n+\n+private:\n+    T* data()\n+    {\n+        return reinterpret_cast<T*>(&_data);\n+    }\n+\n+private:\n+    uint32_t _size = 0;\n+    std::aligned_storage_t<sizeof(T[MaxSize])> _data;\n+};\n+\n+struct Item: intrusive_ref_counter<Item>\n+{\n+};\n+\n+using Collection = Storage<intrusive_ptr<Item>>;\n+\n+struct Holder\n+{\n+    __attribute__ ((noinline)) Holder(Collection collection) : collection(std::move(collection)) {}\n+\n+    int64_t dummy = 0; // this is needed to reproduce the issue.\n+    Collection collection;\n+};\n+\n+int main()\n+{\n+    Collection collection;\n+    collection.push_back(intrusive_ptr<Item>(new Item()));\n+\n+    Holder holder(std::move(collection));\n+\n+    auto item = holder.collection[0];\n+    \n+    if (!item)\n+      __builtin_abort ();\n+\n+    return 0;\n+}"}, {"sha": "9bc94e56a95aa84dced942efe275a7f07e31e851", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0069fafb53ccb7a45a6815025dfcbd2882a36e/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0069fafb53ccb7a45a6815025dfcbd2882a36e/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=2c0069fafb53ccb7a45a6815025dfcbd2882a36e", "patch": "@@ -2145,6 +2145,8 @@ struct pg_edge_callback_data\n   bitmap sccs_to_merge;\n   /* Array constains component information for all vertices.  */\n   int *vertices_component;\n+  /* Array constains postorder information for all vertices.  */\n+  int *vertices_post;\n   /* Vector to record all data dependence relations which are needed\n      to break strong connected components by runtime alias checks.  */\n   vec<ddr_p> *alias_ddrs;\n@@ -2401,7 +2403,7 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n \t\t\t\t\t       vec<struct partition *> *partitions,\n \t\t\t\t\t       vec<ddr_p> *alias_ddrs)\n {\n-  int i, j, k, num_sccs, num_sccs_no_alias;\n+  int i, j, k, num_sccs, num_sccs_no_alias = 0;\n   /* Build partition dependence graph.  */\n   graph *pg = build_partition_graph (rdg, partitions, false);\n \n@@ -2452,6 +2454,7 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n       cbdata.sccs_to_merge = sccs_to_merge;\n       cbdata.alias_ddrs = alias_ddrs;\n       cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);\n+      cbdata.vertices_post = XNEWVEC (int, pg->n_vertices);\n       /* Record the component information which will be corrupted by next\n \t graph scc finding call.  */\n       for (i = 0; i < pg->n_vertices; ++i)\n@@ -2460,6 +2463,11 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n       /* Collect data dependences for runtime alias checks to break SCCs.  */\n       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)\n \t{\n+\t  /* Record the postorder information which will be corrupted by next\n+\t     graph SCC finding call.  */\n+\t  for (i = 0; i < pg->n_vertices; ++i)\n+\t    cbdata.vertices_post[i] = pg->vertices[i].post;\n+\n \t  /* Run SCC finding algorithm again, with alias dependence edges\n \t     skipped.  This is to topologically sort partitions according to\n \t     compilation time known dependence.  Note the topological order\n@@ -2490,11 +2498,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n \t      if (cbdata.vertices_component[k] != i)\n \t\tcontinue;\n \n-\t      /* Update to the minimal postordeer number of vertices in scc so\n-\t\t that merged partition is sorted correctly against others.  */\n-\t      if (pg->vertices[j].post > pg->vertices[k].post)\n-\t\tpg->vertices[j].post = pg->vertices[k].post;\n-\n \t      partition_merge_into (NULL, first, partition, FUSE_SAME_SCC);\n \t      (*partitions)[k] = NULL;\n \t      partition_free (partition);\n@@ -2505,6 +2508,14 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n \t      first->type = PTYPE_SEQUENTIAL;\n \t    }\n \t}\n+      /* Restore the postorder information if it's corrupted in finding SCC\n+\t with alias dependence edges skipped.  */\n+      if (num_sccs_no_alias > 0)\n+\tfor (i = 0; i < pg->n_vertices; ++i)\n+\t  pg->vertices[i].post = cbdata.vertices_post[i];\n+\n+      free (cbdata.vertices_component);\n+      free (cbdata.vertices_post);\n     }\n \n   sort_partitions_by_post_order (pg, partitions);"}]}