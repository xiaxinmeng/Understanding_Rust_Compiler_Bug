{"sha": "b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMwNmFiM2FhN2IxYWQxMTMyM2QwNzlmZTExYWRhMWQwNDczYzM4YQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-02-15T23:29:17Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-02-15T23:29:17Z"}, "message": "[RS6000] reload_vsx_from_gprsf splitter\n\nThis is PR68973 part 2, caused by the reload_vsx_from_gprsf splitter\nemitting an invalid move.  The patch also fixes uses of TFmode, which\ncannot now be assumed to be IBM double-double.\n\n\tPR target/68973\n\t* config/rs6000/rs6000.md (reload_vsx_from_gprsf): Rewrite splitter.\n\t(p8_mtvsrd_df, p8_mtvsrd_sf): New.\n\t(p8_mtvsrd_1, p8_mtvsrd_2): Delete.\n\t(p8_mtvsrwz): New.\n\t(p8_mtvsrwz_1, p8_mtvsrwz_2): Delete.\n\t(p8_xxpermdi_<mode>): Take two DF inputs rather than one TF.\n\t(p8_fmrgow_<mode>): Likewise.\n\t(reload_vsx_from_gpr<mode>): Make clobber IF.  Adjust for above\n\tchanges.\n\t(reload_fpr_from_gpr<mode>): Similarly. Use \"d\" for op0 constraint.\n\t(reload_vsx_from_gprsf): Use p8_mtvsrd_sf rather than attempting\n\tto use movdi_internal64.  Remove op0_di.\n\t* config/rs6000/vsx.md (vsx_xscvspdpn_directmove): Make op1 SFmode.\n\nFrom-SVN: r233438", "tree": {"sha": "d80ac91a50af226094756fadda7721b277748950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d80ac91a50af226094756fadda7721b277748950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a16bdb4eae09f5f2476998985382de13cb889fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16bdb4eae09f5f2476998985382de13cb889fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16bdb4eae09f5f2476998985382de13cb889fc0"}], "stats": {"total": 114, "additions": 61, "deletions": 53}, "files": [{"sha": "bb8d543a0b011ac79c05c215ed61f9eb63f2065f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "patch": "@@ -1,5 +1,22 @@\n+2016-02-16  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/68973\n+\t* config/rs6000/rs6000.md (reload_vsx_from_gprsf): Rewrite splitter.\n+\t(p8_mtvsrd_df, p8_mtvsrd_sf): New.\n+\t(p8_mtvsrd_1, p8_mtvsrd_2): Delete.\n+\t(p8_mtvsrwz): New.\n+\t(p8_mtvsrwz_1, p8_mtvsrwz_2): Delete.\n+\t(p8_xxpermdi_<mode>): Take two DF inputs rather than one TF.\n+\t(p8_fmrgow_<mode>): Likewise.\n+\t(reload_vsx_from_gpr<mode>): Make clobber IF.  Adjust for above\n+\tchanges.\n+\t(reload_fpr_from_gpr<mode>): Similarly. Use \"d\" for op0 constraint.\n+\t(reload_vsx_from_gprsf): Use p8_mtvsrd_sf rather than attempting\n+\tto use movdi_internal64.  Remove op0_di.\n+\t* config/rs6000/vsx.md (vsx_xscvspdpn_directmove): Make op1 SFmode.\n+\n 2016-02-15  Evandro Menezes  <e.menezes@samsung.com>\n-    \n+\n \tAdd support for the FCCMP insn types\n \n \t* config/aarch64/aarch64.md (fccmp): Change insn type."}, {"sha": "952617c39f0cbe3fde1eccdf69f2ca8810bd791e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "patch": "@@ -7488,106 +7488,94 @@\n ;; value, since it is allocated in reload and not all of the flow information\n ;; is setup for it.  We have two patterns to do the two moves between gprs and\n ;; fprs.  There isn't a dependancy between the two, but we could potentially\n-;; schedule other instructions between the two instructions.  TFmode is\n-;; currently limited to traditional FPR registers.  If/when this is changed, we\n-;; will need to revist %L to make sure it works with VSX registers, or add an\n-;; %x version of %L.\n+;; schedule other instructions between the two instructions.\n \n (define_insn \"p8_fmrgow_<mode>\"\n   [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=d\")\n-\t(unspec:FMOVE64X [(match_operand:TF 1 \"register_operand\" \"d\")]\n+\t(unspec:FMOVE64X [\n+\t\t(match_operand:DF 1 \"register_operand\" \"d\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"d\")]\n \t\t\t UNSPEC_P8V_FMRGOW))]\n   \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"fmrgow %0,%1,%L1\"\n+  \"fmrgow %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"p8_mtvsrwz_1\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=d\")\n-\t(unspec:TF [(match_operand:SI 1 \"register_operand\" \"r\")]\n+(define_insn \"p8_mtvsrwz\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(unspec:DF [(match_operand:SI 1 \"register_operand\" \"r\")]\n \t\t   UNSPEC_P8V_MTVSRWZ))]\n   \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n   \"mtvsrwz %x0,%1\"\n   [(set_attr \"type\" \"mftgpr\")])\n \n-(define_insn \"p8_mtvsrwz_2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"+d\")\n-\t(unspec:TF [(match_dup 0)\n-\t\t    (match_operand:SI 1 \"register_operand\" \"r\")]\n-\t\t   UNSPEC_P8V_MTVSRWZ))]\n-  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mtvsrwz %L0,%1\"\n-  [(set_attr \"type\" \"mftgpr\")])\n-\n (define_insn_and_split \"reload_fpr_from_gpr<mode>\"\n-  [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=ws\")\n+  [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=d\")\n \t(unspec:FMOVE64X [(match_operand:FMOVE64X 1 \"register_operand\" \"r\")]\n \t\t\t UNSPEC_P8V_RELOAD_FROM_GPR))\n-   (clobber (match_operand:TF 2 \"register_operand\" \"=d\"))]\n+   (clobber (match_operand:IF 2 \"register_operand\" \"=d\"))]\n   \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n-  rtx tmp = operands[2];\n+  rtx tmp_hi = simplify_gen_subreg (DFmode, operands[2], IFmode, 0);\n+  rtx tmp_lo = simplify_gen_subreg (DFmode, operands[2], IFmode, 8);\n   rtx gpr_hi_reg = gen_highpart (SImode, src);\n   rtx gpr_lo_reg = gen_lowpart (SImode, src);\n \n-  emit_insn (gen_p8_mtvsrwz_1 (tmp, gpr_hi_reg));\n-  emit_insn (gen_p8_mtvsrwz_2 (tmp, gpr_lo_reg));\n-  emit_insn (gen_p8_fmrgow_<mode> (dest, tmp));\n+  emit_insn (gen_p8_mtvsrwz (tmp_hi, gpr_hi_reg));\n+  emit_insn (gen_p8_mtvsrwz (tmp_lo, gpr_lo_reg));\n+  emit_insn (gen_p8_fmrgow_<mode> (dest, tmp_hi, tmp_lo));\n   DONE;\n }\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"three\")])\n \n ;; Move 128 bit values from GPRs to VSX registers in 64-bit mode\n-(define_insn \"p8_mtvsrd_1\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=ws\")\n-\t(unspec:TF [(match_operand:DI 1 \"register_operand\" \"r\")]\n-\t\t   UNSPEC_P8V_MTVSRD))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mtvsrd %0,%1\"\n-  [(set_attr \"type\" \"mftgpr\")])\n-\n-(define_insn \"p8_mtvsrd_2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"+ws\")\n-\t(unspec:TF [(match_dup 0)\n-\t\t    (match_operand:DI 1 \"register_operand\" \"r\")]\n+(define_insn \"p8_mtvsrd_df\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=wa\")\n+\t(unspec:DF [(match_operand:DI 1 \"register_operand\" \"r\")]\n \t\t   UNSPEC_P8V_MTVSRD))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mtvsrd %L0,%1\"\n+  \"mtvsrd %x0,%1\"\n   [(set_attr \"type\" \"mftgpr\")])\n \n (define_insn \"p8_xxpermdi_<mode>\"\n   [(set (match_operand:FMOVE128_GPR 0 \"register_operand\" \"=wa\")\n-\t(unspec:FMOVE128_GPR [(match_operand:TF 1 \"register_operand\" \"ws\")]\n-\t\t\t     UNSPEC_P8V_XXPERMDI))]\n+\t(unspec:FMOVE128_GPR [\n+\t\t(match_operand:DF 1 \"register_operand\" \"wa\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"wa\")]\n+\t\tUNSPEC_P8V_XXPERMDI))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"xxpermdi %x0,%1,%L1,0\"\n+  \"xxpermdi %x0,%x1,%x2,0\"\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn_and_split \"reload_vsx_from_gpr<mode>\"\n   [(set (match_operand:FMOVE128_GPR 0 \"register_operand\" \"=wa\")\n \t(unspec:FMOVE128_GPR\n \t [(match_operand:FMOVE128_GPR 1 \"register_operand\" \"r\")]\n \t UNSPEC_P8V_RELOAD_FROM_GPR))\n-   (clobber (match_operand:TF 2 \"register_operand\" \"=ws\"))]\n+   (clobber (match_operand:IF 2 \"register_operand\" \"=wa\"))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n-  rtx tmp = operands[2];\n+  /* You might think that we could use op0 as one temp and a DF clobber\n+     as op2, but you'd be wrong.  Secondary reload move patterns don't\n+     check for overlap of the clobber and the destination.  */\n+  rtx tmp_hi = simplify_gen_subreg (DFmode, operands[2], IFmode, 0);\n+  rtx tmp_lo = simplify_gen_subreg (DFmode, operands[2], IFmode, 8);\n   rtx gpr_hi_reg = gen_highpart (DImode, src);\n   rtx gpr_lo_reg = gen_lowpart (DImode, src);\n \n-  emit_insn (gen_p8_mtvsrd_1 (tmp, gpr_hi_reg));\n-  emit_insn (gen_p8_mtvsrd_2 (tmp, gpr_lo_reg));\n-  emit_insn (gen_p8_xxpermdi_<mode> (dest, tmp));\n+  emit_insn (gen_p8_mtvsrd_df (tmp_hi, gpr_hi_reg));\n+  emit_insn (gen_p8_mtvsrd_df (tmp_lo, gpr_lo_reg));\n+  emit_insn (gen_p8_xxpermdi_<mode> (dest, tmp_hi, tmp_lo));\n   DONE;\n }\n   [(set_attr \"length\" \"12\")\n@@ -7608,6 +7596,13 @@\n ;; Move SFmode to a VSX from a GPR register.  Because scalar floating point\n ;; type is stored internally as double precision in the VSX registers, we have\n ;; to convert it from the vector format.\n+(define_insn \"p8_mtvsrd_sf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=wa\")\n+\t(unspec:SF [(match_operand:DI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_MTVSRD))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrd %x0,%1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n \n (define_insn_and_split \"reload_vsx_from_gprsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=wa\")\n@@ -7622,16 +7617,12 @@\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n-  /* Also use the destination register to hold the unconverted DImode value.\n-     This is conceptually a separate value from OP0, so we use gen_rtx_REG\n-     rather than simplify_gen_subreg.  */\n-  rtx op0_di = gen_rtx_REG (DImode, REGNO (op0));\n   rtx op1_di = simplify_gen_subreg (DImode, op1, SFmode, 0);\n \n   /* Move SF value to upper 32-bits for xscvspdpn.  */\n   emit_insn (gen_ashldi3 (op2, op1_di, GEN_INT (32)));\n-  emit_move_insn (op0_di, op2);\n-  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0_di));\n+  emit_insn (gen_p8_mtvsrd_sf (op0, op2));\n+  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0));\n   DONE;\n }\n   [(set_attr \"length\" \"8\")"}, {"sha": "45af23361a799ebec317e4dbb847cb24064681de", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b306ab3aa7b1ad11323d079fe11ada1d0473c38a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=b306ab3aa7b1ad11323d079fe11ada1d0473c38a", "patch": "@@ -1521,7 +1521,7 @@\n ;; Used by direct move to move a SFmode value from GPR to VSX register\n (define_insn \"vsx_xscvspdpn_directmove\"\n   [(set (match_operand:SF 0 \"vsx_register_operand\" \"=wa\")\n-\t(unspec:SF [(match_operand:DI 1 \"vsx_register_operand\" \"wa\")]\n+\t(unspec:SF [(match_operand:SF 1 \"vsx_register_operand\" \"wa\")]\n \t\t   UNSPEC_VSX_CVSPDPN))]\n   \"TARGET_XSCVSPDPN\"\n   \"xscvspdpn %x0,%x1\""}]}