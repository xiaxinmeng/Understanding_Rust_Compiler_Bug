{"sha": "9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0MWQyZTZkMmE3ODNmMmZiZDA3NjBmOWNlNjAwMjE5NGQ2M2QwMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-07-24T12:25:27Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-07-24T12:25:27Z"}, "message": "IPA C++ refactoring 2/N\n\n  * cgraph.h (varpool_node):\n  (availability get_availability (void)):\n    created from cgraph_variable_initializer_availability\n  (inline varpool_node *ultimate_alias_target (availability *availability = NULL)\n    creted from: cgraph_variable_initializer_availability\n  (inline varpool_node *get_alias_target (void)): created from varpool_alias_target\n  (void finalize_named_section_flags (void)):\n    created from varpool_finalize_named_section_flags\n  (bool assemble_decl (void)): created from varpool_assemble_decl\n  (void analyze (void)): created from varpool_analyze_node\n  (bool call_for_node_and_aliases (bool (*callback) (varpool_node *, void *),\n    void *data, bool include_overwritable)): created fromvarpool_for_node_and_aliases\n  (void remove_initializer (void)): created from varpool_remove_initializer\n  (tree get_constructor (void)): created from varpool_get_constructor\n  (bool externally_visible_p (void)): created from varpool_externally_visible_p\n  (bool ctor_useable_for_folding_p (void)): created from varpool_ctor_useable_for_folding_p\n  (inline bool all_refs_explicit_p ()): created from varpool_all_refs_explicit_p\n  (inline bool can_remove_if_no_refs_p (void)): created from varpool_can_remove_if_no_refs\n  (static inline varpool_node *get (const_tree decl)): created from varpool_get_node\n  (static void finalize_decl (tree decl)): created from varpool_finalize_decl\n  (static bool output_variables (void)): created from varpool_output_variables\n  (static varpool_node * create_extra_name_alias (tree alias, tree decl)):\n    created from varpool_extra_name_alias\n  (static varpool_node * create_alias (tree, tree)): created from varpool_create_variable_alias\n  (static void dump_varpool (FILE *f)): created from dump_varpool\n  (static void DEBUG_FUNCTION debug_varpool (void)): created from debug_varpool\n  (static varpool_node *create_empty (void)): created from varpool_create_empty_node\n  (static varpool_node *get_create (tree decl)): created from varpool_node_for_decl\n  (static varpool_node *get_for_asmname (tree asmname)): created from varpool_node_for_asm\n  (void assemble_aliases (void)): created from assemble_aliases\n\nFrom-SVN: r212984", "tree": {"sha": "472ea9046d4a0e5c2441a25416c6e99fb4665350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/472ea9046d4a0e5c2441a25416c6e99fb4665350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a53d6a66043944d9534ceae8182b943f739b8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a53d6a66043944d9534ceae8182b943f739b8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a53d6a66043944d9534ceae8182b943f739b8a7"}], "stats": {"total": 712, "additions": 409, "deletions": 303}, "files": [{"sha": "291ac7b3e037dcab5870bae7182389e00c439381", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -1,3 +1,36 @@\n+2014-07-24  Martin Liska  <mliska@suse.cz>\n+\n+  * cgraph.h (varpool_node):\n+  (availability get_availability (void)):\n+    created from cgraph_variable_initializer_availability\n+  (inline varpool_node *ultimate_alias_target (availability *availability = NULL)\n+    creted from: cgraph_variable_initializer_availability\n+  (inline varpool_node *get_alias_target (void)): created from varpool_alias_target\n+  (void finalize_named_section_flags (void)):\n+    created from varpool_finalize_named_section_flags\n+  (bool assemble_decl (void)): created from varpool_assemble_decl\n+  (void analyze (void)): created from varpool_analyze_node\n+  (bool call_for_node_and_aliases (bool (*callback) (varpool_node *, void *),\n+    void *data, bool include_overwritable)): created fromvarpool_for_node_and_aliases\n+  (void remove_initializer (void)): created from varpool_remove_initializer\n+  (tree get_constructor (void)): created from varpool_get_constructor\n+  (bool externally_visible_p (void)): created from varpool_externally_visible_p\n+  (bool ctor_useable_for_folding_p (void)): created from varpool_ctor_useable_for_folding_p\n+  (inline bool all_refs_explicit_p ()): created from varpool_all_refs_explicit_p\n+  (inline bool can_remove_if_no_refs_p (void)): created from varpool_can_remove_if_no_refs\n+  (static inline varpool_node *get (const_tree decl)): created from varpool_get_node\n+  (static void finalize_decl (tree decl)): created from varpool_finalize_decl\n+  (static bool output_variables (void)): created from varpool_output_variables\n+  (static varpool_node * create_extra_name_alias (tree alias, tree decl)):\n+    created from varpool_extra_name_alias\n+  (static varpool_node * create_alias (tree, tree)): created from varpool_create_variable_alias\n+  (static void dump_varpool (FILE *f)): created from dump_varpool\n+  (static void DEBUG_FUNCTION debug_varpool (void)): created from debug_varpool\n+  (static varpool_node *create_empty (void)): created from varpool_create_empty_node\n+  (static varpool_node *get_create (tree decl)): created from varpool_node_for_decl\n+  (static varpool_node *get_for_asmname (tree asmname)): created from varpool_node_for_asm\n+  (void assemble_aliases (void)): created from assemble_aliases\n+\n 2014-07-24  Martin Liska  <mliska@suse.cz>\n \n   * cgraph.h (symtab_node):"}, {"sha": "59ec904ccc3b56f4ebd3d6b4d5764326c5859aa8", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -1931,7 +1931,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t{\n \t  /* For static vars if they are known not to be dynamically\n \t     initialized, they will be always accessible.  */\n-\t  varpool_node *vnode = varpool_get_node (inner);\n+\t  varpool_node *vnode = varpool_node::get (inner);\n \t  if (vnode && !vnode->dynamically_initialized)\n \t    return;\n \t}\n@@ -2383,7 +2383,7 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n \t\t\t  fold_convert (const_ptr_type_node, str_cst));\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  fold_convert (const_ptr_type_node, module_name_cst));\n-  varpool_node *vnode = varpool_get_node (decl);\n+  varpool_node *vnode = varpool_node::get (decl);\n   int has_dynamic_init = vnode ? vnode->dynamically_initialized : 0;\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  build_int_cst (uptr, has_dynamic_init));\n@@ -2595,7 +2595,7 @@ asan_finish_file (void)\n       TREE_CONSTANT (ctor) = 1;\n       TREE_STATIC (ctor) = 1;\n       DECL_INITIAL (var) = ctor;\n-      varpool_finalize_decl (var);\n+      varpool_node::finalize_decl (var);\n \n       fn = builtin_decl_implicit (BUILT_IN_ASAN_REGISTER_GLOBALS);\n       tree gcount_tree = build_int_cst (pointer_sized_int_node, gcount);"}, {"sha": "f8f76c42d6ca039809a96d7de353f4af888fef4f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 134, "deletions": 64, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -363,8 +363,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* True when symbol corresponds to a definition in current unit.\n      set via cgraph_finalize_function or varpool_finalize_decl  */\n   unsigned definition : 1;\n-  /* True when symbol is an alias.  \n-     Set by assemble_alias.  */\n+  /* True when symbol is an alias.\n+     Set by ssemble_alias.  */\n   unsigned alias : 1;\n   /* True when alias is a weakref.  */\n   unsigned weakref : 1;\n@@ -408,7 +408,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Set when variable is used from other LTRANS partition.  */\n   unsigned used_from_other_partition : 1;\n-  /* Set when function is available in the other LTRANS partition.  \n+  /* Set when function is available in the other LTRANS partition.\n      During WPA output it is used to mark nodes that are present in\n      multiple partitions.  */\n   unsigned in_other_partition : 1;\n@@ -1336,6 +1336,103 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n \n class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n public:\n+  /* Dump given varpool node to F.  */\n+  void dump (FILE *f);\n+\n+  /* Dump given varpool node to stderr.  */\n+  void DEBUG_FUNCTION debug (void);\n+\n+  /* Remove variable from symbol table.  */\n+  void remove (void);\n+\n+  /* Remove node initializer when it is no longer needed.  */\n+  void remove_initializer (void);\n+\n+  void analyze (void);\n+\n+  /* Return variable availability.  */\n+  availability get_availability (void);\n+\n+  /* When doing LTO, read variable's constructor from disk if\n+     it is not already present.  */\n+  tree get_constructor (void);\n+\n+  /* Return true if variable has constructor that can be used for folding.  */\n+  bool ctor_useable_for_folding_p (void);\n+\n+  /* For given variable pool node, walk the alias chain to return the function\n+     the variable is alias of. Do not walk through thunks.\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+  inline varpool_node *ultimate_alias_target\n+    (availability *availability = NULL);\n+\n+  /* Return node that alias is aliasing.  */\n+  inline varpool_node *get_alias_target (void);\n+\n+  /* Output one variable, if necessary.  Return whether we output it.  */\n+  bool assemble_decl (void);\n+\n+  /* For variables in named sections make sure get_variable_section\n+     is called before we switch to those sections.  Then section\n+     conflicts between read-only and read-only requiring relocations\n+     sections can be resolved.  */\n+  void finalize_named_section_flags (void);\n+\n+  /* Call calback on varpool symbol and aliases associated to varpool symbol.\n+     When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+     skipped. */\n+  bool call_for_node_and_aliases (bool (*callback) (varpool_node *, void *),\n+\t\t\t\t  void *data,\n+\t\t\t\t   bool include_overwritable);\n+\n+  /* Return true when variable should be considered externally visible.  */\n+  bool externally_visible_p (void);\n+\n+  /* Return true when all references to variable must be visible\n+     in ipa_ref_list.\n+     i.e. if the variable is not externally visible or not used in some magic\n+     way (asm statement or such).\n+     The magic uses are all summarized in force_output flag.  */\n+  inline bool all_refs_explicit_p ();\n+\n+  /* Return true when variable can be removed from variable pool\n+     if all direct calls are eliminated.  */\n+  inline bool can_remove_if_no_refs_p (void);\n+\n+  /* Return varpool node for given symbol and check it is a function. */\n+  static inline varpool_node *get (const_tree decl);\n+\n+  /* Mark DECL as finalized.  By finalizing the declaration, frontend instruct\n+     the middle end to output the variable to asm file, if needed or externally\n+     visible.  */\n+  static void finalize_decl (tree decl);\n+\n+  /* Output all variables enqueued to be assembled.  */\n+  static bool output_variables (void);\n+\n+  /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+     Extra name aliases are output whenever DECL is output.  */\n+  static varpool_node * create_extra_name_alias (tree alias, tree decl);\n+\n+  /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+     Extra name aliases are output whenever DECL is output.  */\n+  static varpool_node * create_alias (tree, tree);\n+\n+  /* Dump the variable pool to F.  */\n+  static void dump_varpool (FILE *f);\n+\n+  /* Dump the variable pool to stderr.  */\n+  static void DEBUG_FUNCTION debug_varpool (void);\n+\n+  /* Allocate new callgraph node and insert it into basic data structures.  */\n+  static varpool_node *create_empty (void);\n+\n+  /* Return varpool node assigned to DECL.  Create new one when needed.  */\n+  static varpool_node *get_create (tree decl);\n+\n+  /* Given an assembler name, lookup node.  */\n+  static varpool_node *get_for_asmname (tree asmname);\n+\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n \n@@ -1351,11 +1448,9 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n      if we did not do any inter-procedural code movement.  */\n   unsigned used_by_single_function : 1;\n \n-  /* Dump given cgraph node to F.  */\n-  void dump (FILE *f);\n-\n-  /* Remove variable from symbol table.  */\n-  void remove (void);\n+private:\n+  /* Assemble thunks and aliases associated to varpool node.  */\n+  void assemble_aliases (void);\n };\n \n /* Every top level asm statement is put into a asm_node.  */\n@@ -1538,39 +1633,16 @@ void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n-bool varpool_externally_visible_p (varpool_node *);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n \n /* In varpool.c  */\n-varpool_node *varpool_create_empty_node (void);\n-varpool_node *varpool_node_for_decl (tree);\n-varpool_node *varpool_node_for_asm (tree asmname);\n-void varpool_mark_needed_node (varpool_node *);\n-void debug_varpool (void);\n-void dump_varpool (FILE *);\n-\n-void varpool_finalize_decl (tree);\n-enum availability cgraph_variable_initializer_availability (varpool_node *);\n-\n-void varpool_finalize_named_section_flags (varpool_node *node);\n-bool varpool_output_variables (void);\n-bool varpool_assemble_decl (varpool_node *node);\n-void varpool_analyze_node (varpool_node *);\n-varpool_node * varpool_extra_name_alias (tree, tree);\n-varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n-bool varpool_ctor_useable_for_folding_p (varpool_node *);\n tree ctor_for_folding (tree);\n-bool varpool_for_node_and_aliases (varpool_node *,\n-\t\t                   bool (*) (varpool_node *, void *),\n-\t\t\t           void *, bool);\n void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n void symtab_prevail_in_asm_name_hash (symtab_node *node);\n-void varpool_remove_initializer (varpool_node *);\n-tree varpool_get_constructor (struct varpool_node *node);\n \n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);\n@@ -1647,8 +1719,8 @@ symtab_node::next_defined_symbol (void)\n }\n \n /* Return varpool node for given symbol and check it is a function. */\n-static inline varpool_node *\n-varpool_get_node (const_tree decl)\n+inline varpool_node *\n+varpool_node::get (const_tree decl)\n {\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n   return dyn_cast<varpool_node *> (symtab_node::get (decl));\n@@ -2009,34 +2081,34 @@ cgraph_node::only_called_directly_or_aliased_p (void)\n \t  && !externally_visible);\n }\n \n-/* Return true when function NODE can be removed from callgraph\n+/* Return true when variable can be removed from variable pool\n    if all direct calls are eliminated.  */\n \n-static inline bool\n-varpool_can_remove_if_no_refs (varpool_node *node)\n+inline bool\n+varpool_node::can_remove_if_no_refs_p (void)\n {\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (decl))\n     return true;\n-  return (!node->force_output && !node->used_from_other_partition\n-  \t  && ((DECL_COMDAT (node->decl)\n-\t       && !node->forced_by_abi\n-\t       && !node->used_from_object_file_p ())\n-\t      || !node->externally_visible\n-\t      || DECL_HAS_VALUE_EXPR_P (node->decl)));\n+  return (!force_output && !used_from_other_partition\n+\t  && ((DECL_COMDAT (decl)\n+\t       && !forced_by_abi\n+\t       && !used_from_object_file_p ())\n+\t      || !externally_visible\n+\t      || DECL_HAS_VALUE_EXPR_P (decl)));\n }\n \n-/* Return true when all references to VNODE must be visible in ipa_ref_list.\n+/* Return true when all references to variable must be visible in ipa_ref_list.\n    i.e. if the variable is not externally visible or not used in some magic\n    way (asm statement or such).\n    The magic uses are all summarized in force_output flag.  */\n \n-static inline bool\n-varpool_all_refs_explicit_p (varpool_node *vnode)\n+inline bool\n+varpool_node::all_refs_explicit_p ()\n {\n-  return (vnode->definition\n-\t  && !vnode->externally_visible\n-\t  && !vnode->used_from_other_partition\n-\t  && !vnode->force_output);\n+  return (definition\n+\t  && !externally_visible\n+\t  && !used_from_other_partition\n+\t  && !force_output);\n }\n \n /* Constant pool accessor function.  */\n@@ -2050,10 +2122,12 @@ cgraph_node::get_alias_target (void)\n   return dyn_cast <cgraph_node *> (symtab_node::get_alias_target ());\n }\n \n-static inline varpool_node *\n-varpool_alias_target (varpool_node *n)\n+/* Return node that alias is aliasing.  */\n+\n+inline varpool_node *\n+varpool_node::get_alias_target (void)\n {\n-  return dyn_cast <varpool_node *> (n->get_alias_target ());\n+  return dyn_cast <varpool_node *> (symtab_node::get_alias_target ());\n }\n \n /* Given function symbol, walk the alias chain to return the function node\n@@ -2069,20 +2143,16 @@ cgraph_node::ultimate_alias_target (enum availability *availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n }\n-/* Given NODE, walk the alias chain to return the function NODE is alias of.\n-   Do not walk through thunks.\n+\n+/* For given variable pool node, walk the alias chain to return the function\n+   the variable is alias of. Do not walk through thunks.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n-static inline varpool_node *\n-varpool_variable_node (varpool_node *node,\n-\t\t       enum availability *availability = NULL)\n+inline varpool_node *\n+varpool_node::ultimate_alias_target (availability *availability)\n {\n-  varpool_node *n;\n-\n-  if (node)\n-    n = dyn_cast <varpool_node *> (node->ultimate_alias_target (availability));\n-  else\n-    n = NULL;\n+  varpool_node *n = dyn_cast <varpool_node *>\n+    (symtab_node::ultimate_alias_target (availability));\n \n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;"}, {"sha": "91811d7c2fbcf8d24a4b0657fea569a4b150566f", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -87,7 +87,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n-\t  varpool_node *vnode = varpool_node_for_decl (decl);\n+\t  varpool_node *vnode = varpool_node::get_create (decl);\n \t  ctx->varpool_node->add_reference (vnode, IPA_REF_ADDR);\n \t}\n       *walk_subtrees = 0;\n@@ -124,7 +124,7 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  type = TREE_OPERAND (type, 0);\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n-\t      varpool_node *vnode = varpool_node_for_decl (type);\n+\t      varpool_node *vnode = varpool_node::get_create (type);\n \t      node->add_reference (vnode, IPA_REF_ADDR);\n \t    }\n \t}\n@@ -230,7 +230,7 @@ mark_address (gimple stmt, tree addr, tree, void *data)\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n-      varpool_node *vnode = varpool_node_for_decl (addr);\n+      varpool_node *vnode = varpool_node::get_create (addr);\n \n       ((symtab_node *)data)->add_reference (vnode, IPA_REF_ADDR, stmt);\n     }\n@@ -255,7 +255,7 @@ mark_load (gimple stmt, tree t, tree, void *data)\n   else if (t && TREE_CODE (t) == VAR_DECL\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      varpool_node *vnode = varpool_node_for_decl (t);\n+      varpool_node *vnode = varpool_node::get_create (t);\n \n       ((symtab_node *)data)->add_reference (vnode, IPA_REF_LOAD, stmt);\n     }\n@@ -271,7 +271,7 @@ mark_store (gimple stmt, tree t, tree, void *data)\n   if (t && TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      varpool_node *vnode = varpool_node_for_decl (t);\n+      varpool_node *vnode = varpool_node::get_create (t);\n \n       ((symtab_node *)data)->add_reference (vnode, IPA_REF_STORE, stmt);\n      }\n@@ -383,7 +383,7 @@ pass_build_cgraph_edges::execute (function *fun)\n     if (TREE_CODE (decl) == VAR_DECL\n \t&& (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n \t&& !DECL_HAS_VALUE_EXPR_P (decl))\n-      varpool_finalize_decl (decl);\n+      varpool_node::finalize_decl (decl);\n   record_eh_tables (node, fun);\n \n   pointer_set_destroy (visited_nodes);\n@@ -406,7 +406,7 @@ void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  varpool_node *node = varpool_node_for_decl (decl);\n+  varpool_node *node = varpool_node::get_create (decl);\n   struct record_reference_ctx ctx = {false, NULL};\n \n   ctx.varpool_node = node;"}, {"sha": "34f4c81eb84e003cfc63a60ff1ddeaa20c0e45d2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -686,7 +686,7 @@ cgraph_process_same_body_aliases (void)\n     if (node->cpp_implicit_alias && !node->analyzed)\n       node->resolve_alias\n \t(TREE_CODE (node->alias_target) == VAR_DECL\n-\t ? (symtab_node *)varpool_node_for_decl (node->alias_target)\n+\t ? (symtab_node *)varpool_node::get_create (node->alias_target)\n \t : (symtab_node *)cgraph_node::get_create (node->alias_target));\n   cpp_implicit_aliases_done = true;\n }\n@@ -779,7 +779,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       tree decl = vnode->decl;\n       if (DECL_EXTERNAL (decl)\n \t  && DECL_INITIAL (decl))\n-\tvarpool_finalize_decl (decl);\n+\tvarpool_node::finalize_decl (decl);\n       if (DECL_PRESERVE_P (decl))\n \tvnode->force_output = true;\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n@@ -809,9 +809,9 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n    visible.  */\n \n void\n-varpool_finalize_decl (tree decl)\n+varpool_node::finalize_decl (tree decl)\n {\n-  varpool_node *node = varpool_node_for_decl (decl);\n+  varpool_node *node = varpool_node::get_create (decl);\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n@@ -831,12 +831,12 @@ varpool_finalize_decl (tree decl)\n \t  || referred_to_p (node)))\n     enqueue_node (node);\n   if (cgraph_state >= CGRAPH_STATE_IPA_SSA)\n-    varpool_analyze_node (node);\n+    node->analyze ();\n   /* Some frontends produce various interface variables after compilation\n      finished.  */\n   if (cgraph_state == CGRAPH_STATE_FINISHED\n       || (!flag_toplevel_reorder && cgraph_state == CGRAPH_STATE_EXPANSION))\n-    varpool_assemble_decl (node);\n+    node->assemble_decl ();\n }\n \n /* EDGE is an polymorphic call.  Mark all possible targets as reachable\n@@ -1055,7 +1055,7 @@ analyze_functions (void)\n \t    {\n \t      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n \t      if (vnode && vnode->definition && !vnode->analyzed)\n-\t\tvarpool_analyze_node (vnode);\n+\t\tvnode->analyze ();\n \t    }\n \n \t  if (node->same_comdat_group)\n@@ -1198,7 +1198,7 @@ handle_alias_pairs (void)\n       else if (TREE_CODE (p->decl) == VAR_DECL\n \t       && target_node && is_a <varpool_node *> (target_node))\n \t{\n-\t  varpool_create_variable_alias (p->decl, target_node->decl);\n+\t  varpool_node::create_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n       else\n@@ -2004,7 +2004,7 @@ output_in_order (void)\n \n   for (i = 0; i < max; ++i)\n     if (nodes[i].kind == ORDER_VAR)\n-      varpool_finalize_named_section_flags (nodes[i].u.v);\n+      nodes[i].u.v->finalize_named_section_flags ();\n \n   for (i = 0; i < max; ++i)\n     {\n@@ -2016,7 +2016,7 @@ output_in_order (void)\n \t  break;\n \n \tcase ORDER_VAR:\n-\t  varpool_assemble_decl (nodes[i].u.v);\n+\t  nodes[i].u.v->assemble_decl ();\n \t  break;\n \n \tcase ORDER_ASM:\n@@ -2259,7 +2259,7 @@ compile (void)\n       output_asm_statements ();\n \n       expand_all_functions ();\n-      varpool_output_variables ();\n+      varpool_node::output_variables ();\n     }\n \n   cgraph_process_new_functions ();"}, {"sha": "8ac1d5f015f81291a9f52dc08f987db61c3d303a", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -706,7 +706,7 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n \t      TREE_TYPE (var) = array_type;\n \t      DECL_SIZE (var) = TYPE_SIZE (array_type);\n \t      DECL_SIZE_UNIT (var) = TYPE_SIZE_UNIT (array_type);\n-\t      varpool_finalize_decl (var);\n+\t      varpool_node::finalize_decl (var);\n \t    }\n \t  \n \t  fn_b_ctrs[i] = fn_n_ctrs[i] = 0;\n@@ -1121,7 +1121,7 @@ coverage_obj_fn (vec<constructor_elt, va_gc> *ctor, tree fn,\n   tree var = build_var (fn, gcov_fn_info_type, -1);\n   \n   DECL_INITIAL (var) = init;\n-  varpool_finalize_decl (var);\n+  varpool_node::finalize_decl (var);\n       \n   CONSTRUCTOR_APPEND_ELT (ctor, NULL,\n \t\t\t  build1 (ADDR_EXPR, gcov_fn_info_ptr_type, var));\n@@ -1146,11 +1146,11 @@ coverage_obj_finish (vec<constructor_elt, va_gc> *ctor)\n   ASM_GENERATE_INTERNAL_LABEL (name_buf, \"LPBX\", 1);\n   DECL_NAME (fn_info_ary) = get_identifier (name_buf);\n   DECL_INITIAL (fn_info_ary) = build_constructor (fn_info_ary_type, ctor);\n-  varpool_finalize_decl (fn_info_ary);\n+  varpool_node::finalize_decl (fn_info_ary);\n   \n   DECL_INITIAL (gcov_info_var)\n     = build_info (TREE_TYPE (gcov_info_var), fn_info_ary);\n-  varpool_finalize_decl (gcov_info_var);\n+  varpool_node::finalize_decl (gcov_info_var);\n }\n \n /* Perform file-level initialization. Read in data file, generate name"}, {"sha": "aafb91751434683106dea32bf43e5585beebe216", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -2076,7 +2076,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       if (TREE_CODE (olddecl) == FUNCTION_DECL)\n \tsymbol = cgraph_node::get_create (newdecl);\n       else\n-\tsymbol = varpool_node_for_decl (newdecl);\n+\tsymbol = varpool_node::get_create (newdecl);\n       symbol->set_comdat_group (symtab_node::get\n \t(olddecl)->get_comdat_group ());\n     }"}, {"sha": "8fa31451c6064ffdb6cc7d24498a7e4ef4bd7871", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -1804,7 +1804,7 @@ maybe_make_one_only (tree decl)\n \n       if (VAR_P (decl))\n \t{\n-          varpool_node *node = varpool_node_for_decl (decl);\n+\t  varpool_node *node = varpool_node::get_create (decl);\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n           node->forced_by_abi = true;\n@@ -1912,7 +1912,7 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  return varpool_node_for_decl (var)->definition;\n+  return varpool_node::get_create (var)->definition;\n }\n \n /* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,\n@@ -1933,7 +1933,7 @@ mark_needed (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      varpool_node *node = varpool_node_for_decl (decl);\n+      varpool_node *node = varpool_node::get_create (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->forced_by_abi = true;\n@@ -2053,7 +2053,7 @@ maybe_emit_vtables (tree ctype)\n \tTREE_ASM_WRITTEN (vtbl) = 1;\n       else if (DECL_ONE_ONLY (vtbl))\n \t{\n-\t  current = varpool_node_for_decl (vtbl);\n+\t  current = varpool_node::get_create (vtbl);\n \t  if (last)\n \t    current->add_to_same_comdat_group (last);\n \t  last = current;\n@@ -3661,7 +3661,7 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n \t  finish_expr_stmt (init);\n \t  if (flag_sanitize & SANITIZE_ADDRESS)\n \t    {\n-\t      varpool_node *vnode = varpool_get_node (decl);\n+\t      varpool_node *vnode = varpool_node::get (decl);\n \t      if (vnode)\n \t\tvnode->dynamically_initialized = 1;\n \t    }"}, {"sha": "40508ab0cc34bcb29ba2bb2526ad92af5655b18d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -3491,7 +3491,7 @@ mangle_decl (const tree decl)\n \t    n->create_same_body_alias (alias, decl);\n \t}\n       else\n-\tvarpool_extra_name_alias (alias, decl);\n+\tvarpool_node::create_extra_name_alias (alias, decl);\n #endif\n     }\n }"}, {"sha": "2c10fd37086dcaf34b5fb3da30edf9e907eb73e5", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -799,7 +799,7 @@ insert_call_to_register_set (tree class_name,\n   TREE_STATIC (initial) = 1;\n   DECL_INITIAL (array_arg) = initial;\n   relayout_decl (array_arg);\n-  varpool_finalize_decl (array_arg);\n+  varpool_node::finalize_decl (array_arg);\n \n   arg3 = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (array_arg)), array_arg);\n \n@@ -1253,7 +1253,7 @@ vtable_find_or_create_map_decl (tree base_type)\n \n       comdat_linkage (var_decl);\n \n-      varpool_finalize_decl (var_decl);\n+      varpool_node::finalize_decl (var_decl);\n       if (!vtable_map_node)\n         vtable_map_node =\n                    find_or_create_vtbl_map_node (TYPE_MAIN_VARIANT (base_type));"}, {"sha": "fc6b13b904a6d6baabbde4676f420fac4b827e2a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -2429,7 +2429,7 @@ dbxout_expand_expr (tree expr)\n \t  /* If this is a var that might not be actually output,\n \t     return NULL, otherwise stabs might reference an undefined\n \t     symbol.  */\n-\t  varpool_node *node = varpool_get_node (expr);\n+\t  varpool_node *node = varpool_node::get (expr);\n \t  if (!node || !node->definition)\n \t    return NULL;\n \t}"}, {"sha": "8fd1945cf50557d674fbd3292afd427d9baba6ac", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -15360,7 +15360,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n     return *tp;\n   else if (TREE_CODE (*tp) == VAR_DECL)\n     {\n-      varpool_node *node = varpool_get_node (*tp);\n+      varpool_node *node = varpool_node::get (*tp);\n       if (!node || !node->definition)\n \treturn *tp;\n     }\n@@ -18052,7 +18052,7 @@ premark_types_used_by_global_vars_helper (void **slot,\n     {\n       /* Ask cgraph if the global variable really is to be emitted.\n          If yes, then we'll keep the DIE of ENTRY->TYPE.  */\n-      varpool_node *node = varpool_get_node (entry->var_decl);\n+      varpool_node *node = varpool_node::get (entry->var_decl);\n       if (node && node->definition)\n \t{\n \t  die->die_perennial_p = 1;"}, {"sha": "4e8de8235f8ec0437ec086c21e2a5dbb9776717c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -112,10 +112,10 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   if (!from_decl\n       || TREE_CODE (from_decl) != VAR_DECL\n       || (!DECL_EXTERNAL (from_decl)\n-\t  && (vnode = varpool_get_node (from_decl)) != NULL\n+\t  && (vnode = varpool_node::get (from_decl)) != NULL\n \t  && vnode->definition)\n       || (flag_ltrans\n-\t  && (vnode = varpool_get_node (from_decl)) != NULL\n+\t  && (vnode = varpool_node::get (from_decl)) != NULL\n \t  && vnode->in_other_partition))\n     return true;\n   /* We are folding reference from external vtable.  The vtable may reffer"}, {"sha": "7c4151a1857fc8fed67253089281ff2906f7003a", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -241,7 +241,7 @@ type_possibly_instantiated_p (tree t)\n   vtable = BINFO_VTABLE (TYPE_BINFO (t));\n   if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n     vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n-  vnode = varpool_get_node (vtable);\n+  vnode = varpool_node::get (vtable);\n   return vnode && vnode->definition;\n }\n \n@@ -1512,7 +1512,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \n \t  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n \t    vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n-\t  vnode = varpool_get_node (vtable);\n+\t  vnode = varpool_node::get (vtable);\n \t  if (!vnode || !vnode->definition)\n \t    return;\n \t}"}, {"sha": "4720ee9fe27975ce2eb7e04e9482bef9645ab909", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -263,31 +263,31 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n   return false;\n }\n \n-/* Return true when variable VNODE should be considered externally visible.  */\n+/* Return true when variable should be considered externally visible.  */\n \n bool\n-varpool_externally_visible_p (varpool_node *vnode)\n+varpool_node::externally_visible_p (void)\n {\n-  if (DECL_EXTERNAL (vnode->decl))\n+  if (DECL_EXTERNAL (decl))\n     return true;\n \n-  if (!TREE_PUBLIC (vnode->decl))\n+  if (!TREE_PUBLIC (decl))\n     return false;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (vnode->used_from_object_file_p ())\n+  if (used_from_object_file_p ())\n     return true;\n \n-  if (DECL_HARD_REGISTER (vnode->decl))\n+  if (DECL_HARD_REGISTER (decl))\n     return true;\n-  if (DECL_PRESERVE_P (vnode->decl))\n+  if (DECL_PRESERVE_P (decl))\n     return true;\n   if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n+\t\t\tDECL_ATTRIBUTES (decl)))\n     return true;\n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n       && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (vnode->decl)))\n+\t\t\t   DECL_ATTRIBUTES (decl)))\n     return true;\n \n   /* See if we have linker information about symbol not being used or\n@@ -296,9 +296,9 @@ varpool_externally_visible_p (varpool_node *vnode)\n      Even if the linker clams the symbol is unused, never bring internal\n      symbols that are declared by user as used or externally visible.\n      This is needed for i.e. references from asm statements.   */\n-  if (vnode->used_from_object_file_p ())\n+  if (used_from_object_file_p ())\n     return true;\n-  if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n   /* As a special case, the COMDAT virtual tables can be unshared.\n@@ -307,17 +307,17 @@ varpool_externally_visible_p (varpool_node *vnode)\n      is faster for dynamic linking.  Also this match logic hidding vtables\n      from LTO symbol tables.  */\n   if ((in_lto_p || flag_whole_program)\n-      && DECL_COMDAT (vnode->decl)\n-      && comdat_can_be_unshared_p (vnode))\n+      && DECL_COMDAT (decl)\n+      && comdat_can_be_unshared_p (this))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n-      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n+      && (DECL_VISIBILITY (decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n-      && vnode->definition)\n+      && definition)\n     ;\n   else if (!flag_whole_program)\n     return true;\n@@ -329,7 +329,7 @@ varpool_externally_visible_p (varpool_node *vnode)\n      FIXME: We can do so for readonly vars with no address taken and\n      possibly also for vtables since no direct pointer comparsion is done.\n      It might be interesting to do so to reduce linking overhead.  */\n-  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n+  if (DECL_COMDAT (decl) || DECL_WEAK (decl))\n     return true;\n   return false;\n }\n@@ -625,7 +625,7 @@ function_and_variable_visibility (bool whole_program)\n     {\n       if (!vnode->definition)\n         continue;\n-      if (varpool_externally_visible_p (vnode))\n+      if (vnode->externally_visible_p ())\n \tvnode->externally_visible = true;\n       else\n \t{\n@@ -689,7 +689,7 @@ function_and_variable_visibility (bool whole_program)\n \t    {\n \t      struct pointer_set_t *visited_nodes = pointer_set_create ();\n \n-\t      varpool_get_constructor (vnode);\n+\t      vnode->get_constructor ();\n \t      walk_tree (&DECL_INITIAL (vnode->decl),\n \t\t\t update_vtable_references, NULL, visited_nodes);\n \t      pointer_set_destroy (visited_nodes);"}, {"sha": "8198b174920f97cc2388c57e3fefc47d21f5de4c", "filename": "gcc/ipa.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -313,7 +313,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if (!varpool_can_remove_if_no_refs (vnode)\n+    if (!vnode->can_remove_if_no_refs_p()\n \t&& !vnode->in_other_partition)\n       {\n \tpointer_set_insert (reachable, vnode);\n@@ -548,7 +548,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n \t  /* Keep body if it may be useful for constant folding.  */\n \t  if ((init = ctor_for_folding (vnode->decl)) == error_mark_node)\n-\t    varpool_remove_initializer (vnode);\n+\t    vnode->remove_initializer ();\n \t  else\n \t    DECL_INITIAL (vnode->decl) = init;\n \t  vnode->remove_all_references ();\n@@ -611,7 +611,7 @@ process_references (varpool_node *vnode,\n   int i;\n   struct ipa_ref *ref;\n \n-  if (!varpool_all_refs_explicit_p (vnode)\n+  if (!vnode->all_refs_explicit_p ()\n       || TREE_THIS_VOLATILE (vnode->decl))\n     *explicit_refs = false;\n \n@@ -702,7 +702,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t  {\n \t    if (TREE_ADDRESSABLE (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (non-addressable)\", vnode->name ());\n-\t    varpool_for_node_and_aliases (vnode, clear_addressable_bit, NULL, true);\n+\t    vnode->call_for_node_and_aliases (clear_addressable_bit, NULL, true);\n \t  }\n \tif (!address_taken && !written\n \t    /* Making variable in explicit section readonly can cause section\n@@ -712,13 +712,13 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t  {\n \t    if (!TREE_READONLY (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", vnode->name ());\n-\t    varpool_for_node_and_aliases (vnode, set_readonly_bit, NULL, true);\n+\t    vnode->call_for_node_and_aliases (set_readonly_bit, NULL, true);\n \t  }\n \tif (!vnode->writeonly && !read && !address_taken && written)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (write-only)\", vnode->name ());\n-\t    varpool_for_node_and_aliases (vnode, set_writeonly_bit, NULL, true);\n+\t    vnode->call_for_node_and_aliases (set_writeonly_bit, NULL, true);\n \t  }\n       }\n   if (dump_file)\n@@ -1143,7 +1143,7 @@ propagate_single_user (varpool_node *vnode, cgraph_node *function,\n \n   /* If node is an alias, first meet with its target.  */\n   if (vnode->alias)\n-    function = meet (function, varpool_alias_target (vnode), single_user_map);\n+    function = meet (function, vnode->get_alias_target (), single_user_map);\n \n   /* Check all users and see if they correspond to a single function.  */\n   for (i = 0; vnode->iterate_referring (i, ref) && function != BOTTOM; i++)\n@@ -1176,7 +1176,7 @@ ipa_single_use (void)\n   hash_map<varpool_node *, cgraph_node *> single_user_map;\n \n   FOR_EACH_DEFINED_VARIABLE (var)\n-    if (!varpool_all_refs_explicit_p (var))\n+    if (!var->all_refs_explicit_p ())\n       var->aux = BOTTOM;\n     else\n       {"}, {"sha": "8ae7e4269cd14deb57d2cd3c3fced394f465b904", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -79,7 +79,7 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   layout_decl (decl, 0);\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  varpool_finalize_decl (decl);\n+  varpool_node::finalize_decl (decl);\n \n   vec_safe_push (resources, decl);\n }"}, {"sha": "b1fcf67a02584af6ef66f258208c42149662d215", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -853,7 +853,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       if (DECL_ABSTRACT_ORIGIN (vnode->decl))\n \t{\n \t  varpool_node *origin_node\n-\t    = varpool_get_node (DECL_ABSTRACT_ORIGIN (vnode->decl));\n+\t    = varpool_node::get (DECL_ABSTRACT_ORIGIN (vnode->decl));\n \t  lto_set_symtab_encoder_in_partition (encoder, origin_node);\n \t}\n     }\n@@ -867,7 +867,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\tvnode)\n-\t      && varpool_ctor_useable_for_folding_p (vnode))\n+\t      && vnode->ctor_useable_for_folding_p ())\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n \t      add_references (encoder, vnode);\n@@ -1242,7 +1242,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   /* Declaration of functions can be already merged with a declaration\n      from other input file.  We keep cgraph unmerged until after streaming\n      of ipa passes is done.  Alays forcingly create a fresh node.  */\n-  node = varpool_create_empty_node ();\n+  node = varpool_node::create_empty ();\n   node->decl = var_decl;\n   node->register_symbol ();\n "}, {"sha": "75332f94928323f80de7fe7914348575855c5115", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -335,7 +335,7 @@ get_symbol_initial_value (lto_symtab_encoder_t encoder, tree expr)\n       /* Extra section needs about 30 bytes; do not produce it for simple\n \t scalar values.  */\n       if (TREE_CODE (DECL_INITIAL (expr)) == CONSTRUCTOR\n-\t  || !(vnode = varpool_get_node (expr))\n+\t  || !(vnode = varpool_node::get (expr))\n \t  || !lto_symtab_encoder_encode_initializer_p (encoder, vnode))\n         initial = error_mark_node;\n     }\n@@ -2316,7 +2316,7 @@ write_symbol (struct streamer_tree_cache_d *cache,\n \n       /* When something is defined, it should have node attached.  */\n       gcc_assert (alias || TREE_CODE (t) != VAR_DECL\n-\t\t  || varpool_get_node (t)->definition);\n+\t\t  || varpool_node::get (t)->definition);\n       gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n \t\t  || (cgraph_node::get (t)\n \t\t      && cgraph_node::get (t)->definition));"}, {"sha": "cb08a88ad0e2f306917e0eaf156f978e60dc0f89", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -96,8 +96,8 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node *> (ref->referred)\n-\t     && varpool_ctor_useable_for_folding_p\n-\t       (dyn_cast <varpool_node *> (ref->referred))\n+\t     && dyn_cast <varpool_node *> (ref->referred)\n+\t       ->ctor_useable_for_folding_p ()\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)\n@@ -203,7 +203,7 @@ contained_in_symbol (symtab_node *node)\n       return cnode;\n     }\n   else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n-    return varpool_variable_node (vnode, NULL);\n+    return vnode->ultimate_alias_target ();\n   return node;\n }\n \n@@ -622,7 +622,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\t   to be removed.  Coupling with objects they refer to only helps to reduce\n \t\t   number of symbols promoted to hidden.  */\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n-\t\t    && !varpool_can_remove_if_no_refs (vnode)\n+\t\t    && !vnode->can_remove_if_no_refs_p ()\n \t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,"}, {"sha": "b46693b48dc035e910781d65adc974e53e1377d0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -4835,7 +4835,7 @@ expand_omp_taskreg (struct omp_region *region)\n \tif (TREE_CODE (t) == VAR_DECL\n \t    && TREE_STATIC (t)\n \t    && !DECL_EXTERNAL (t))\n-\t  varpool_finalize_decl (t);\n+\t  varpool_node::finalize_decl (t);\n       DECL_SAVED_TREE (child_fn) = NULL;\n       /* We'll create a CFG for child_fn, so no gimple body is needed.  */\n       gimple_set_body (child_fn, NULL);\n@@ -7960,7 +7960,7 @@ expand_omp_target (struct omp_region *region)\n \tif (TREE_CODE (t) == VAR_DECL\n \t    && TREE_STATIC (t)\n \t    && !DECL_EXTERNAL (t))\n-\t  varpool_finalize_decl (t);\n+\t  varpool_node::finalize_decl (t);\n       DECL_SAVED_TREE (child_fn) = NULL;\n       /* We'll create a CFG for child_fn, so no gimple body is needed.  */\n       gimple_set_body (child_fn, NULL);\n@@ -8898,7 +8898,7 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  DECL_COMMON (decl) = 1;\n \t  DECL_ARTIFICIAL (decl) = 1;\n \t  DECL_IGNORED_P (decl) = 1;\n-\t  varpool_finalize_decl (decl);\n+\t  varpool_node::finalize_decl (decl);\n \n \t  splay_tree_insert (critical_name_mutexes, (splay_tree_key) name,\n \t\t\t     (splay_tree_value) decl);"}, {"sha": "38485a75f0c71b359810000458ca2d15fd8e27cb", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -239,7 +239,7 @@ rest_of_decl_compilation (tree decl,\n \t  if (in_lto_p && !at_end)\n \t    ;\n \t  else if (finalize && TREE_CODE (decl) != FUNCTION_DECL)\n-\t    varpool_finalize_decl (decl);\n+\t    varpool_node::finalize_decl (decl);\n \t}\n \n #ifdef ASM_FINISH_DECLARE_OBJECT\n@@ -267,7 +267,7 @@ rest_of_decl_compilation (tree decl,\n     ;\n   else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl)\n \t   && TREE_STATIC (decl))\n-    varpool_node_for_decl (decl);\n+    varpool_node::get_create (decl);\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}, {"sha": "a93c299ec234cea448b721d0486ce40275c698ee", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -1507,8 +1507,7 @@ enum availability symtab_node::get_availability (void)\n   if (is_a <cgraph_node *> (this))\n     return dyn_cast <cgraph_node *> (this)->get_availability ();\n   else\n-    return cgraph_variable_initializer_availability\n-      (dyn_cast <varpool_node *> (this));\n+    return dyn_cast <varpool_node *> (this)->get_availability ();;\n }\n \n \n@@ -1790,7 +1789,7 @@ symtab_node::noninterposable_alias (void)\n     {\n       TREE_READONLY (new_decl) = TREE_READONLY (node->decl);\n       DECL_INITIAL (new_decl) = error_mark_node;\n-      new_node = varpool_create_variable_alias (new_decl, node->decl);\n+      new_node = varpool_node::create_alias (new_decl, node->decl);\n     }\n   new_node->resolve_alias (node);\n   gcc_assert (decl_binds_to_current_def_p (new_decl)"}, {"sha": "2886df71bc05325b2501110d446a4fcbcb4af65b", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -393,7 +393,7 @@ wrapup_global_declaration_2 (tree decl)\n     {\n       varpool_node *node;\n       bool needed = true;\n-      node = varpool_get_node (decl);\n+      node = varpool_node::get (decl);\n \n       if (!node && flag_ltrans)\n \tneeded = false;"}, {"sha": "5633398e96b134dddc259ad15dfcabc70f8cebe0", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -4843,7 +4843,8 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   /* Perform the same remapping to the comdat group.  */\n   if (DECL_ONE_ONLY (new_decl))\n-    varpool_get_node (new_decl)->set_comdat_group (tm_mangle (decl_comdat_group_id (old_decl)));\n+    varpool_node::get (new_decl)->set_comdat_group\n+      (tm_mangle (decl_comdat_group_id (old_decl)));\n \n   new_node = cgraph_node::create_same_body_alias (new_decl, info->new_decl);\n   new_node->tm_clone = true;\n@@ -4883,7 +4884,8 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   /* Perform the same remapping to the comdat group.  */\n   if (DECL_ONE_ONLY (new_decl))\n-    varpool_get_node (new_decl)->set_comdat_group (tm_mangle (DECL_COMDAT_GROUP (old_decl)));\n+    varpool_node::get (new_decl)->set_comdat_group\n+      (tm_mangle (DECL_COMDAT_GROUP (old_decl)));\n \n   gcc_assert (!old_node->ipa_transforms_to_apply.exists ());\n   new_node = old_node->create_version_clone (new_decl, vNULL, NULL);"}, {"sha": "6fee8a48a90416acf4215957ec809e2a47e91fca", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -8500,7 +8500,7 @@ execute_fixup_cfg (void)\n \n \t      if (TREE_CODE (lhs) == VAR_DECL\n \t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n-\t\t  && varpool_get_node (lhs)->writeonly)\n+\t\t  && varpool_node::get (lhs)->writeonly)\n \t\t{\n \t\t  unlink_stmt_vdef (stmt);\n \t\t  gsi_remove (&gsi, true);\n@@ -8518,7 +8518,7 @@ execute_fixup_cfg (void)\n \n \t      if (TREE_CODE (lhs) == VAR_DECL\n \t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n-\t\t  && varpool_get_node (lhs)->writeonly)\n+\t\t  && varpool_node::get (lhs)->writeonly)\n \t\t{\n \t\t  gimple_call_set_lhs (stmt, NULL);\n \t\t  update_stmt (stmt);"}, {"sha": "df9a6fcaf7c8bac47cf7781240c2ab042be4a144", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -2707,7 +2707,7 @@ tree_could_trap_p (tree expr)\n \t  varpool_node *node;\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n-\t  node = varpool_variable_node (varpool_get_node (expr), NULL);\n+\t  node = varpool_node::get (expr)->ultimate_alias_target ();\n \t  if (node && node->in_other_partition)\n \t    return false;\n \t  return true;"}, {"sha": "89197c774aab5d469e1ef26847c42743b6ecf7ce", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -270,7 +270,7 @@ get_emutls_init_templ_addr (tree decl)\n   /* Create varpool node for the new variable and finalize it if it is\n      not external one.  */\n   if (DECL_EXTERNAL (to))\n-    varpool_node_for_decl (to);\n+    varpool_node::get_create (to);\n   else\n     varpool_add_new_variable (to);\n   return build_fold_addr_expr (to);\n@@ -340,13 +340,13 @@ new_emutls_decl (tree decl, tree alias_of)\n   /* Create varpool node for the new variable and finalize it if it is\n      not external one.  */\n   if (DECL_EXTERNAL (to))\n-    varpool_node_for_decl (to);\n+    varpool_node::get_create (to);\n   else if (!alias_of)\n     varpool_add_new_variable (to);\n   else \n-    varpool_create_variable_alias (to,\n-\t\t\t\t   varpool_node_for_asm\n-\t\t\t\t    (DECL_ASSEMBLER_NAME (DECL_VALUE_EXPR (alias_of)))->decl);\n+    varpool_node::create_alias (to,\n+\t\t\t\tvarpool_node::get_for_asmname\n+\t\t\t\t  (DECL_ASSEMBLER_NAME (DECL_VALUE_EXPR (alias_of)))->decl);\n   return to;\n }\n \n@@ -358,7 +358,7 @@ emutls_index (tree decl)\n {\n   varpool_node_set_iterator i;\n   \n-  i = varpool_node_set_find (tls_vars, varpool_get_node (decl));\n+  i = varpool_node_set_find (tls_vars, varpool_node::get (decl));\n   gcc_assert (i.index != ~0u);\n \n   return i.index;\n@@ -709,9 +709,9 @@ create_emultls_var (varpool_node *var, void *data)\n \n   cdecl = new_emutls_decl (var->decl,\n \t\t\t   var->alias && var->analyzed\n-\t\t\t   ? varpool_alias_target (var)->decl : NULL);\n+\t\t\t   ? var->get_alias_target ()->decl : NULL);\n \n-  cvar = varpool_get_node (cdecl);\n+  cvar = varpool_node::get (cdecl);\n   control_vars.quick_push (cvar);\n \n   if (!var->alias)\n@@ -754,7 +754,7 @@ ipa_lower_emutls (void)\n \t\t\t     || DECL_EXTERNAL (var->decl));\n \tvarpool_node_set_add (tls_vars, var);\n \tif (var->alias && var->definition)\n-\t  varpool_node_set_add (tls_vars, varpool_variable_node (var, NULL));\n+\t  varpool_node_set_add (tls_vars, var->ultimate_alias_target ());\n       }\n \n   /* If we found no TLS variables, then there is no further work to do.  */\n@@ -780,7 +780,7 @@ ipa_lower_emutls (void)\n       if (var->alias && !var->analyzed)\n \tany_aliases = true;\n       else if (!var->alias)\n-\tvarpool_for_node_and_aliases (var, create_emultls_var, &ctor_body, true);\n+\tvar->call_for_node_and_aliases (create_emultls_var, &ctor_body, true);\n     }\n \n   /* If there were any aliases, then frob the alias_pairs vector.  */"}, {"sha": "6ab06e69c3f02a895bb286046a323bafbec5ac78", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -112,7 +112,7 @@ init_ic_make_global_vars (void)\n   if (targetm.have_tls)\n     set_decl_tls_model (ic_void_ptr_var, decl_default_tls_model (ic_void_ptr_var));\n \n-  varpool_finalize_decl (ic_void_ptr_var);\n+  varpool_node::finalize_decl (ic_void_ptr_var);\n \n   gcov_type_ptr = build_pointer_type (get_gcov_type ());\n   /* Workaround for binutils bug 14342.  Once it is fixed, remove lto path.  */\n@@ -142,7 +142,7 @@ init_ic_make_global_vars (void)\n   if (targetm.have_tls)\n     set_decl_tls_model (ic_gcov_type_ptr_var, decl_default_tls_model (ic_gcov_type_ptr_var));\n \n-  varpool_finalize_decl (ic_gcov_type_ptr_var);\n+  varpool_node::finalize_decl (ic_gcov_type_ptr_var);\n }\n \n /* Create the type and function decls for the interface with gcov.  */"}, {"sha": "1879fc0b8ff23346bd546e7b854cf2ad2d1767f9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -2931,10 +2931,10 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n   if (TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      varpool_node *node = varpool_get_node (t);\n+      varpool_node *node = varpool_node::get (t);\n       if (node && node->alias && node->analyzed)\n \t{\n-\t  node = varpool_variable_node (node, NULL);\n+\t  node = node->ultimate_alias_target ();\n \t  t = node->decl;\n \t}\n     }\n@@ -5671,7 +5671,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n \t in IPA mode.  Else we'd have to parse arbitrary initializers.  */\n       && !(in_ipa_mode\n \t   && is_global_var (decl)\n-\t   && varpool_get_constructor (varpool_get_node (decl))))\n+\t   && varpool_node::get (decl)->get_constructor ()))\n     {\n       fieldoff_s *fo = NULL;\n       bool notokay = false;\n@@ -5789,29 +5789,29 @@ create_variable_info_for (tree decl, const char *name)\n \t for it.  */\n       else\n \t{\n-\t  varpool_node *vnode = varpool_get_node (decl);\n+\t  varpool_node *vnode = varpool_node::get (decl);\n \n \t  /* For escaped variables initialize them from nonlocal.  */\n-\t  if (!varpool_all_refs_explicit_p (vnode))\n+\t  if (!vnode->all_refs_explicit_p ())\n \t    make_copy_constraint (vi, nonlocal_id);\n \n \t  /* If this is a global variable with an initializer and we are in\n \t     IPA mode generate constraints for it.  */\n-\t  if (varpool_get_constructor (vnode)\n+\t  if (vnode->get_constructor ()\n \t      && vnode->definition)\n \t    {\n \t      auto_vec<ce_s> rhsc;\n \t      struct constraint_expr lhs, *rhsp;\n \t      unsigned i;\n-\t      get_constraint_for_rhs (varpool_get_constructor (vnode), &rhsc);\n+\t      get_constraint_for_rhs (vnode->get_constructor (), &rhsc);\n \t      lhs.var = vi->id;\n \t      lhs.offset = 0;\n \t      lhs.type = SCALAR;\n \t      FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t      /* If this is a variable that escapes from the unit\n \t\t the initializer escapes as well.  */\n-\t      if (!varpool_all_refs_explicit_p (vnode))\n+\t      if (!vnode->all_refs_explicit_p ())\n \t\t{\n \t\t  lhs.var = escaped_id;\n \t\t  lhs.offset = 0;"}, {"sha": "09c668e3415cd3817a31ec0ff055895bed678d3d", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -1074,7 +1074,7 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n       DECL_ARTIFICIAL (decl) = 1;\n       TREE_CONSTANT (decl) = 1;\n       TREE_READONLY (decl) = 1;\n-      varpool_finalize_decl (decl);\n+      varpool_node::finalize_decl (decl);\n \n       fetch = build4 (ARRAY_REF, value_type, decl, tidx, NULL_TREE,\n \t\t      NULL_TREE);"}, {"sha": "51ef63b6bb2fdc307d9db545fbea450286d0f1b9", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -644,7 +644,7 @@ set_decl_section_name (tree node, const char *value)\n \treturn;\n     }\n   else if (TREE_CODE (node) == VAR_DECL)\n-    snode = varpool_node_for_decl (node);\n+    snode = varpool_node::get_create (node);\n   else\n     snode = cgraph_node::get_create (node);\n   snode->set_section (value);\n@@ -654,7 +654,7 @@ set_decl_section_name (tree node, const char *value)\n enum tls_model\n decl_tls_model (const_tree node)\n {\n-  struct varpool_node *snode = varpool_get_node (node);\n+  struct varpool_node *snode = varpool_node::get (node);\n   if (!snode)\n     return TLS_MODEL_NONE;\n   return snode->tls_model;\n@@ -668,12 +668,12 @@ set_decl_tls_model (tree node, enum tls_model model)\n \n   if (model == TLS_MODEL_NONE)\n     {\n-      vnode = varpool_get_node (node);\n+      vnode = varpool_node::get (node);\n       if (!vnode)\n \treturn;\n     }\n   else\n-    vnode = varpool_node_for_decl (node);\n+    vnode = varpool_node::get_create (node);\n   vnode->tls_model = model;\n }\n \n@@ -6523,7 +6523,7 @@ decl_init_priority_insert (tree decl, priority_type priority)\n \treturn;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n-    snode = varpool_node_for_decl (decl);\n+    snode = varpool_node::get_create (decl);\n   else\n     snode = cgraph_node::get_create (decl);\n   snode->set_init_priority (priority);"}, {"sha": "4e7e4878c6683969ece932fa3d65e37b576d78ac", "filename": "gcc/ubsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -295,10 +295,10 @@ ubsan_type_descriptor (tree type, enum ubsan_print_style pstyle)\n \n   tree decl = decl_for_type_lookup (type);\n   /* It is possible that some of the earlier created DECLs were found\n-     unused, in that case they weren't emitted and varpool_get_node\n+     unused, in that case they weren't emitted and varpool_node::get\n      returns NULL node on them.  But now we really need them.  Thus,\n      renew them here.  */\n-  if (decl != NULL_TREE && varpool_get_node (decl))\n+  if (decl != NULL_TREE && varpool_node::get (decl))\n     return build_fold_addr_expr (decl);\n \n   tree dtype = ubsan_type_descriptor_type ();\n@@ -441,7 +441,7 @@ ubsan_type_descriptor (tree type, enum ubsan_print_style pstyle)\n   TREE_CONSTANT (ctor) = 1;\n   TREE_STATIC (ctor) = 1;\n   DECL_INITIAL (decl) = ctor;\n-  varpool_finalize_decl (decl);\n+  varpool_node::finalize_decl (decl);\n \n   /* Save the VAR_DECL into the hash table.  */\n   decl_for_type_insert (type, decl);\n@@ -553,7 +553,7 @@ ubsan_create_data (const char *name, const location_t *ploc,\n   TREE_CONSTANT (ctor) = 1;\n   TREE_STATIC (ctor) = 1;\n   DECL_INITIAL (var) = ctor;\n-  varpool_finalize_decl (var);\n+  varpool_node::finalize_decl (var);\n \n   return var;\n }"}, {"sha": "275b65feeda0b7b4b5393f44cd7cf0644258876a", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -2394,7 +2394,7 @@ mark_decl_referenced (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      varpool_node *node = varpool_node_for_decl (decl);\n+      varpool_node *node = varpool_node::get_create (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->force_output = true;\n@@ -3400,7 +3400,7 @@ tree_output_constant_def (tree exp)\n     }\n \n   decl = SYMBOL_REF_DECL (XEXP (desc->rtl, 0));\n-  varpool_finalize_decl (decl);\n+  varpool_node::finalize_decl (decl);\n   return decl;\n }\n \f\n@@ -5634,7 +5634,7 @@ assemble_alias (tree decl, tree target)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     cgraph_node::get_create (decl)->alias = true;\n   else\n-    varpool_node_for_decl (decl)->alias = true;\n+    varpool_node::get_create (decl)->alias = true;\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n@@ -5878,7 +5878,7 @@ make_decl_one_only (tree decl, tree comdat_group)\n   TREE_PUBLIC (decl) = 1;\n \n   if (TREE_CODE (decl) == VAR_DECL)\n-    symbol = varpool_node_for_decl (decl);\n+    symbol = varpool_node::get_create (decl);\n   else\n     symbol = cgraph_node::get_create (decl);\n \n@@ -6692,7 +6692,7 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n   if (TREE_CODE (exp) == VAR_DECL && TREE_PUBLIC (exp)\n       && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n     {\n-      varpool_node *vnode = varpool_get_node (exp);\n+      varpool_node *vnode = varpool_node::get (exp);\n       if (vnode && (resolution_local_p (vnode->resolution) || vnode->in_other_partition))\n \tresolved_locally = true;\n       if (vnode\n@@ -6785,7 +6785,7 @@ decl_binds_to_current_def_p (const_tree decl)\n   if (TREE_CODE (decl) == VAR_DECL\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     {\n-      varpool_node *vnode = varpool_get_node (decl);\n+      varpool_node *vnode = varpool_node::get (decl);\n       if (vnode\n \t  && vnode->resolution != LDPR_UNKNOWN)\n \treturn resolution_to_local_definition_p (vnode->resolution);"}, {"sha": "74117e2d60bd0c2853eacf163ff9f1eb816c51ca", "filename": "gcc/varpool.c", "status": "modified", "additions": 113, "deletions": 111, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9041d2e6d2a783f2fbd0760f9ce6002194d63d00/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=9041d2e6d2a783f2fbd0760f9ce6002194d63d00", "patch": "@@ -140,7 +140,7 @@ varpool_call_variable_insertion_hooks (varpool_node *node)\n /* Allocate new callgraph node and insert it into basic data structures.  */\n \n varpool_node *\n-varpool_create_empty_node (void)\n+varpool_node::create_empty (void)\n {   \n   varpool_node *node = ggc_cleared_alloc<varpool_node> ();\n   node->type = SYMTAB_VARIABLE;\n@@ -149,14 +149,14 @@ varpool_create_empty_node (void)\n \n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n varpool_node *\n-varpool_node_for_decl (tree decl)\n+varpool_node::get_create (tree decl)\n {\n-  varpool_node *node = varpool_get_node (decl);\n+  varpool_node *node = varpool_node::get (decl);\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n   if (node)\n     return node;\n \n-  node = varpool_create_empty_node ();\n+  node = varpool_node::create_empty ();\n   node->decl = decl;\n   node->register_symbol ();\n   return node;\n@@ -176,37 +176,37 @@ varpool_node::remove (void)\n   /* Keep constructor when it may be used for folding. We remove\n      references to external variables before final compilation.  */\n   else if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node\n-\t   && !varpool_ctor_useable_for_folding_p (this))\n-    varpool_remove_initializer (this);\n+\t   && !ctor_useable_for_folding_p ())\n+    remove_initializer ();\n   ggc_free (this);\n }\n \n-/* Renove node initializer when it is no longer needed.  */\n+/* Remove node initializer when it is no longer needed.  */\n void\n-varpool_remove_initializer (varpool_node *node)\n+varpool_node::remove_initializer (void)\n {\n-  if (DECL_INITIAL (node->decl)\n-      && !DECL_IN_CONSTANT_POOL (node->decl)\n+  if (DECL_INITIAL (decl)\n+      && !DECL_IN_CONSTANT_POOL (decl)\n       /* Keep vtables for BINFO folding.  */\n-      && !DECL_VIRTUAL_P (node->decl)\n+      && !DECL_VIRTUAL_P (decl)\n       /* FIXME: http://gcc.gnu.org/PR55395 */\n       && debug_info_level == DINFO_LEVEL_NONE\n       /* When doing declaration merging we have duplicate\n \t entries for given decl.  Do not attempt to remove\n \t the boides, or we will end up remiving\n \t wrong one.  */\n       && cgraph_state != CGRAPH_LTO_STREAMING)\n-    DECL_INITIAL (node->decl) = error_mark_node;\n+    DECL_INITIAL (decl) = error_mark_node;\n }\n \n-/* Dump given cgraph node.  */\n+/* Dump given varpool node to F.  */\n void\n varpool_node::dump (FILE *f)\n {\n   dump_base (f);\n   fprintf (f, \"  Availability: %s\\n\",\n \t   cgraph_function_flags_ready\n-\t   ? cgraph_availability_names[cgraph_variable_initializer_availability (this)]\n+\t   ? cgraph_availability_names[get_availability ()]\n \t   : \"not-ready\");\n   fprintf (f, \"  Varpool flags:\");\n   if (DECL_INITIAL (decl))\n@@ -217,7 +217,7 @@ varpool_node::dump (FILE *f)\n     fprintf (f, \" used-by-single-function\");\n   if (TREE_READONLY (decl))\n     fprintf (f, \" read-only\");\n-  if (varpool_ctor_useable_for_folding_p (this))\n+  if (ctor_useable_for_folding_p ())\n     fprintf (f, \" const-value-known\");\n   if (writeonly)\n     fprintf (f, \" write-only\");\n@@ -226,9 +226,16 @@ varpool_node::dump (FILE *f)\n   fprintf (f, \"\\n\");\n }\n \n+\n+/* Dump given varpool node to stderr.  */\n+void varpool_node::debug (void)\n+{\n+  varpool_node::dump (stderr);\n+}\n+\n /* Dump the variable pool to F.  */\n void\n-dump_varpool (FILE *f)\n+varpool_node::dump_varpool (FILE *f)\n {\n   varpool_node *node;\n \n@@ -240,38 +247,38 @@ dump_varpool (FILE *f)\n /* Dump the variable pool to stderr.  */\n \n DEBUG_FUNCTION void\n-debug_varpool (void)\n+varpool_node::debug_varpool (void)\n {\n   dump_varpool (stderr);\n }\n \n /* Given an assembler name, lookup node.  */\n varpool_node *\n-varpool_node_for_asm (tree asmname)\n+varpool_node::get_for_asmname (tree asmname)\n {\n   if (symtab_node *node = symtab_node_for_asm (asmname))\n     return dyn_cast <varpool_node *> (node);\n   else\n     return NULL;\n }\n \n-/* When doing LTO, read NODE's constructor from disk if it is not already present.  */\n+/* When doing LTO, read variable's constructor from disk if\n+   it is not already present.  */\n \n tree\n-varpool_get_constructor (struct varpool_node *node)\n+varpool_node::get_constructor (void)\n {\n   struct lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n-  tree decl = node->decl;\n \n-  if (DECL_INITIAL (node->decl) != error_mark_node\n+  if (DECL_INITIAL (decl) != error_mark_node\n       || !in_lto_p)\n-    return DECL_INITIAL (node->decl);\n+    return DECL_INITIAL (decl);\n \n   timevar_push (TV_IPA_LTO_CTORS_IN);\n \n-  file_data = node->lto_file_data;\n+  file_data = lto_file_data;\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n   /* We may have renamed the declaration, e.g., a static function.  */\n@@ -284,29 +291,29 @@ varpool_get_constructor (struct varpool_node *node)\n \t\t file_data->file_name,\n \t\t name);\n \n-  lto_input_variable_constructor (file_data, node, data);\n+  lto_input_variable_constructor (file_data, this, data);\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t data, len);\n-  lto_free_function_in_decl_state_for_node (node);\n+  lto_free_function_in_decl_state_for_node (this);\n   timevar_pop (TV_IPA_LTO_CTORS_IN);\n-  return DECL_INITIAL (node->decl);\n+  return DECL_INITIAL (decl);\n }\n \n-/* Return ture if NODE has constructor that can be used for folding.  */\n+/* Return true if variable has constructor that can be used for folding.  */\n \n bool\n-varpool_ctor_useable_for_folding_p (varpool_node *node)\n+varpool_node::ctor_useable_for_folding_p (void)\n {\n-  varpool_node *real_node = node;\n+  varpool_node *real_node = this;\n \n   if (real_node->alias && real_node->definition)\n-    real_node = varpool_variable_node (node);\n+    real_node = ultimate_alias_target ();\n \n-  if (TREE_CODE (node->decl) == CONST_DECL\n-      || DECL_IN_CONSTANT_POOL (node->decl))\n+  if (TREE_CODE (decl) == CONST_DECL\n+      || DECL_IN_CONSTANT_POOL (decl))\n     return true;\n-  if (TREE_THIS_VOLATILE (node->decl))\n+  if (TREE_THIS_VOLATILE (decl))\n     return false;\n \n   /* If we do not have a constructor, we can't use it.  */\n@@ -316,7 +323,7 @@ varpool_ctor_useable_for_folding_p (varpool_node *node)\n \n   /* Vtables are defined by their types and must match no matter of interposition\n      rules.  */\n-  if (DECL_VIRTUAL_P (node->decl))\n+  if (DECL_VIRTUAL_P (decl))\n     {\n       /* The C++ front end creates VAR_DECLs for vtables of typeinfo\n \t classes not defined in the current TU so that it can refer\n@@ -327,14 +334,14 @@ varpool_ctor_useable_for_folding_p (varpool_node *node)\n   /* Alias of readonly variable is also readonly, since the variable is stored\n      in readonly memory.  We also accept readonly aliases of non-readonly\n      locations assuming that user knows what he is asking for.  */\n-  if (!TREE_READONLY (node->decl) && !TREE_READONLY (real_node->decl))\n+  if (!TREE_READONLY (decl) && !TREE_READONLY (real_node->decl))\n     return false;\n \n   /* Variables declared 'const' without an initializer\n      have zero as the initializer if they may not be\n      overridden at link or run time.  */\n   if (!DECL_INITIAL (real_node->decl)\n-      && (DECL_EXTERNAL (node->decl) || decl_replaceable_p (node->decl)))\n+      && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))\n     return false;\n \n   /* Variables declared `const' with an initializer are considered\n@@ -345,9 +352,9 @@ varpool_ctor_useable_for_folding_p (varpool_node *node)\n   return true;\n }\n \n-/* If DECL is constant variable and its initial value is known (so we can\n-   do constant folding), return its constructor (DECL_INITIAL). This may\n-   be an expression or NULL when DECL is initialized to 0.\n+/* If DECLARATION is constant variable and its initial value is known\n+   (so we can do constant folding), return its constructor (DECL_INITIAL).\n+   This may be an expression or NULL when DECL is initialized to 0.\n    Return ERROR_MARK_NODE otherwise.\n \n    In LTO this may actually trigger reading the constructor from disk.\n@@ -381,10 +388,10 @@ ctor_for_folding (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n-  real_node = node = varpool_get_node (decl);\n+  real_node = node = varpool_node::get (decl);\n   if (node)\n     {\n-      real_node = varpool_variable_node (node);\n+      real_node = node->ultimate_alias_target ();\n       real_decl = real_node->decl;\n     }\n   else\n@@ -401,23 +408,23 @@ ctor_for_folding (tree decl)\n \t\t  || DECL_INITIAL (decl) == error_mark_node);\n       if (node->weakref)\n \t{\n-\t  node = varpool_alias_target (node);\n+\t  node = node->get_alias_target ();\n \t  decl = node->decl;\n \t}\n     }\n \n   if ((!DECL_VIRTUAL_P (real_decl)\n        || DECL_INITIAL (real_decl) == error_mark_node\n        || !DECL_INITIAL (real_decl))\n-      && (!node || !varpool_ctor_useable_for_folding_p (node)))\n+      && (!node || !node->ctor_useable_for_folding_p ()))\n     return error_mark_node;\n \n   /* OK, we can return constructor.  See if we need to fetch it from disk\n      in LTO mode.  */\n   if (DECL_INITIAL (real_decl) != error_mark_node\n       || !in_lto_p)\n     return DECL_INITIAL (real_decl);\n-  return varpool_get_constructor (real_node);\n+  return real_node->get_constructor ();\n }\n \n /* Add the variable DECL to the varpool.\n@@ -428,90 +435,85 @@ void\n varpool_add_new_variable (tree decl)\n {\n   varpool_node *node;\n-  varpool_finalize_decl (decl);\n-  node = varpool_node_for_decl (decl);\n+  varpool_node::finalize_decl (decl);\n+  node = varpool_node::get_create (decl);\n   varpool_call_variable_insertion_hooks (node);\n-  if (varpool_externally_visible_p (node))\n+  if (node->externally_visible_p ())\n     node->externally_visible = true;\n }\n \n /* Return variable availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n-cgraph_variable_initializer_availability (varpool_node *node)\n+varpool_node::get_availability (void)\n {\n-  if (!node->definition)\n+  if (!definition)\n     return AVAIL_NOT_AVAILABLE;\n-  if (!TREE_PUBLIC (node->decl))\n+  if (!TREE_PUBLIC (decl))\n     return AVAIL_AVAILABLE;\n-  if (DECL_IN_CONSTANT_POOL (node->decl)\n-      || DECL_VIRTUAL_P (node->decl))\n+  if (DECL_IN_CONSTANT_POOL (decl)\n+      || DECL_VIRTUAL_P (decl))\n     return AVAIL_AVAILABLE;\n-  if (node->alias && node->weakref)\n+  if (alias && weakref)\n     {\n       enum availability avail;\n \n-      cgraph_variable_initializer_availability\n-\t      (varpool_variable_node (node, &avail));\n+      ultimate_alias_target (&avail)->get_availability ();\n       return avail;\n     }\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (decl_replaceable_p (node->decl)\n-      || DECL_EXTERNAL (node->decl))\n+  if (decl_replaceable_p (decl)\n+      || DECL_EXTERNAL (decl))\n     return AVAIL_INTERPOSABLE;\n   return AVAIL_AVAILABLE;\n }\n \n void\n-varpool_analyze_node (varpool_node *node)\n+varpool_node::analyze (void)\n {\n-  tree decl = node->decl;\n-\n   /* When reading back varpool at LTO time, we re-construct the queue in order\n      to have \"needed\" list right by inserting all needed nodes into varpool.\n      We however don't want to re-analyze already analyzed nodes.  */\n-  if (!node->analyzed)\n+  if (!analyzed)\n     {\n       gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n       /* Compute the alignment early so function body expanders are\n \t already informed about increased alignment.  */\n       align_variable (decl, 0);\n     }\n-  if (node->alias)\n-    node->resolve_alias (varpool_get_node (node->alias_target));\n+  if (alias)\n+    resolve_alias (varpool_node::get (alias_target));\n   else if (DECL_INITIAL (decl))\n-    record_references_in_initializer (decl, node->analyzed);\n-  node->analyzed = true;\n+    record_references_in_initializer (decl, analyzed);\n+  analyzed = true;\n }\n \n-/* Assemble thunks and aliases associated to NODE.  */\n+/* Assemble thunks and aliases associated to varpool node.  */\n \n-static void\n-assemble_aliases (varpool_node *node)\n+void\n+varpool_node::assemble_aliases (void)\n {\n   struct ipa_ref *ref;\n \n-  FOR_EACH_ALIAS (node, ref)\n+  FOR_EACH_ALIAS (this, ref)\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n       do_assemble_alias (alias->decl,\n-\t\t\t DECL_ASSEMBLER_NAME (node->decl));\n-      assemble_aliases (alias);\n+\t\t\t DECL_ASSEMBLER_NAME (decl));\n+      alias->assemble_aliases ();\n     }\n }\n \n /* Output one variable, if necessary.  Return whether we output it.  */\n \n bool\n-varpool_assemble_decl (varpool_node *node)\n+varpool_node::assemble_decl (void)\n {\n-  tree decl = node->decl;\n-\n   /* Aliases are outout when their target is produced or by\n      output_weakrefs.  */\n-  if (node->alias)\n+  if (alias)\n     return false;\n \n   /* Constant pool is output from RTL land when the reference\n@@ -535,14 +537,14 @@ varpool_assemble_decl (varpool_node *node)\n \t\t       && TREE_CODE (decl) == VAR_DECL\n \t\t       && !DECL_HAS_VALUE_EXPR_P (decl));\n \n-  if (!node->in_other_partition\n+  if (!in_other_partition\n       && !DECL_EXTERNAL (decl))\n     {\n-      varpool_get_constructor (node);\n+      get_constructor ();\n       assemble_variable (decl, 0, 1, 0);\n       gcc_assert (TREE_ASM_WRITTEN (decl));\n-      gcc_assert (node->definition);\n-      assemble_aliases (node);\n+      gcc_assert (definition);\n+      assemble_aliases ();\n       return true;\n     }\n \n@@ -584,7 +586,7 @@ varpool_remove_unreferenced_decls (void)\n   FOR_EACH_DEFINED_VARIABLE (node)\n     {\n       if (node->analyzed\n-\t  && (!varpool_can_remove_if_no_refs (node)\n+\t  && (!node->can_remove_if_no_refs_p ()\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n \t      || DECL_RTL_SET_P (node->decl)))\n@@ -634,7 +636,7 @@ varpool_remove_unreferenced_decls (void)\n           if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n \t  if (pointer_set_contains (referenced, node))\n-\t    varpool_remove_initializer (node);\n+\t    node->remove_initializer ();\n \t  else\n \t    node->remove ();\n \t}\n@@ -649,21 +651,21 @@ varpool_remove_unreferenced_decls (void)\n    conflicts between read-only and read-only requiring relocations\n    sections can be resolved.  */\n void\n-varpool_finalize_named_section_flags (varpool_node *node)\n+varpool_node::finalize_named_section_flags (void)\n {\n-  if (!TREE_ASM_WRITTEN (node->decl)\n-      && !node->alias\n-      && !node->in_other_partition\n-      && !DECL_EXTERNAL (node->decl)\n-      && TREE_CODE (node->decl) == VAR_DECL\n-      && !DECL_HAS_VALUE_EXPR_P (node->decl)\n-      && node->get_section ())\n-    get_variable_section (node->decl, false);\n+  if (!TREE_ASM_WRITTEN (decl)\n+      && !alias\n+      && !in_other_partition\n+      && !DECL_EXTERNAL (decl)\n+      && TREE_CODE (decl) == VAR_DECL\n+      && !DECL_HAS_VALUE_EXPR_P (decl)\n+      && get_section ())\n+    get_variable_section (decl, false);\n }\n \n /* Output all variables enqueued to be assembled.  */\n bool\n-varpool_output_variables (void)\n+varpool_node::output_variables (void)\n {\n   bool changed = false;\n   varpool_node *node;\n@@ -676,10 +678,10 @@ varpool_output_variables (void)\n   timevar_push (TV_VAROUT);\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n-    varpool_finalize_named_section_flags (node);\n+    node->finalize_named_section_flags ();\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n-    if (varpool_assemble_decl (node))\n+    if (node->assemble_decl ())\n       changed = true;\n   timevar_pop (TV_VAROUT);\n   return changed;\n@@ -700,8 +702,8 @@ add_new_static_var (tree type)\n   DECL_CONTEXT (new_decl) = NULL_TREE;\n   DECL_ABSTRACT (new_decl) = 0;\n   lang_hooks.dup_lang_specific_decl (new_decl);\n-  new_node = varpool_node_for_decl (new_decl);\n-  varpool_finalize_decl (new_decl);\n+  new_node = varpool_node::get_create (new_decl);\n+  varpool_node::finalize_decl (new_decl);\n \n   return new_node->decl;\n }\n@@ -710,13 +712,13 @@ add_new_static_var (tree type)\n    Extra name aliases are output whenever DECL is output.  */\n \n varpool_node *\n-varpool_create_variable_alias (tree alias, tree decl)\n+varpool_node::create_alias (tree alias, tree decl)\n {\n   varpool_node *alias_node;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n-  alias_node = varpool_node_for_decl (alias);\n+  alias_node = varpool_node::get_create (alias);\n   alias_node->alias = true;\n   alias_node->definition = true;\n   alias_node->alias_target = decl;\n@@ -729,48 +731,48 @@ varpool_create_variable_alias (tree alias, tree decl)\n    Extra name aliases are output whenever DECL is output.  */\n \n varpool_node *\n-varpool_extra_name_alias (tree alias, tree decl)\n+varpool_node::create_extra_name_alias (tree alias, tree decl)\n {\n   varpool_node *alias_node;\n \n #ifndef ASM_OUTPUT_DEF\n   /* If aliases aren't supported by the assembler, fail.  */\n   return NULL;\n #endif\n-  alias_node = varpool_create_variable_alias (alias, decl);\n+  alias_node = varpool_node::create_alias (alias, decl);\n   alias_node->cpp_implicit_alias = true;\n \n   /* Extra name alias mechanizm creates aliases really late\n      via DECL_ASSEMBLER_NAME mechanizm.\n      This is unfortunate because they are not going through the\n      standard channels.  Ensure they get output.  */\n   if (cpp_implicit_aliases_done)\n-    alias_node->resolve_alias (varpool_node_for_decl (decl));\n+    alias_node->resolve_alias (varpool_node::get_create (decl));\n   return alias_node;\n }\n \n-/* Call calback on NODE and aliases associated to NODE. \n+/* Call calback on varpool symbol and aliases associated to varpool symbol.\n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n bool\n-varpool_for_node_and_aliases (varpool_node *node,\n-\t\t\t      bool (*callback) (varpool_node *, void *),\n-\t\t\t      void *data,\n-\t\t\t      bool include_overwritable)\n+varpool_node::call_for_node_and_aliases (bool (*callback) (varpool_node *,\n+\t\t\t\t\t\t\t   void *),\n+\t\t\t\t\t void *data,\n+\t\t\t\t\t bool include_overwritable)\n {\n   struct ipa_ref *ref;\n \n-  if (callback (node, data))\n+  if (callback (this, data))\n     return true;\n \n-  FOR_EACH_ALIAS (node, ref)\n+  FOR_EACH_ALIAS (this, ref)\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n       if (include_overwritable\n-\t  || cgraph_variable_initializer_availability (alias) > AVAIL_INTERPOSABLE)\n-\tif (varpool_for_node_and_aliases (alias, callback, data,\n-\t\t\t\t\t include_overwritable))\n+\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tif (alias->call_for_node_and_aliases (callback, data,\n+\t\t\t\t\t      include_overwritable))\n \t  return true;\n     }\n   return false;"}]}