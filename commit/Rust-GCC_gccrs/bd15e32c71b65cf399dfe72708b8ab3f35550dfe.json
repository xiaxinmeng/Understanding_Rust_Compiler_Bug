{"sha": "bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQxNWUzMmM3MWI2NWNmMzk5ZGZlNzI3MDhiOGFiM2YzNTU1MGRmZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-08-01T15:05:24Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-08-01T15:05:24Z"}, "message": "linux-unwind.h (frob_update_context <__powerpc64__>): Restore for indirect call bcrtl from correct stack slot...\n\nlibgcc/\n\t* config/rs6000/linux-unwind.h (frob_update_context <__powerpc64__>):\n\tRestore for indirect call bcrtl from correct stack slot, and only\n\tif cfa+40 isn't valid.\ngcc/\n\t* config/rs6000/rs6000-protos.h (rs6000_save_toc_in_prologue_p): Delete.\n\t* config/rs6000/rs6000.c (rs6000_save_toc_in_prologue_p): Make static.\n\t(rs6000_emit_prologue): Don't prematurely return when\n\tTARGET_SINGLE_PIC_BASE.  Don't emit eh_frame info in\n\tsave_toc_in_prologue case.\n\t(rs6000_call_indirect_aix): Only disallow save_toc_in_prologue for\n\tcalls_alloca.\n\nFrom-SVN: r177041", "tree": {"sha": "c6bcd1e86393045e79e0942fc18bb2e86285cf56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6bcd1e86393045e79e0942fc18bb2e86285cf56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "607d0635d893d141b3d4fd682b625df70b52a805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/607d0635d893d141b3d4fd682b625df70b52a805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/607d0635d893d141b3d4fd682b625df70b52a805"}], "stats": {"total": 86, "additions": 57, "deletions": 29}, "files": [{"sha": "2556c3a9f61664285aae6510149a8c026154d95d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "patch": "@@ -1,5 +1,15 @@\n+2011-08-02  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_save_toc_in_prologue_p): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_save_toc_in_prologue_p): Make static.\n+\t(rs6000_emit_prologue): Don't prematurely return when\n+\tTARGET_SINGLE_PIC_BASE.  Don't emit eh_frame info in\n+\tsave_toc_in_prologue case.\n+\t(rs6000_call_indirect_aix): Only disallow save_toc_in_prologue for\n+\tcalls_alloca.\n+\n 2011-08-01  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \t* config/avr/avr-devices.c: Delete SVN property svn:executable.\n \t* config/avr/predicates.md: Ditto.\n \t* config/avr/driver-avr.c: Ditto.\n@@ -137,7 +147,7 @@\n \t(loop_carried_phi): Likewise.\n \t(propagate_rank): Likewise.\n \t(get_rank): Add calls to phi_rank and propagate_rank.\n-\t\n+\n 2011-07-31  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/x86-64.h (SIZE_TYPE): Check TARGET_LP64 instead"}, {"sha": "73da0f69f4771e98e32abb9ec5dcfec6119853ba", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "patch": "@@ -172,8 +172,6 @@ extern void rs6000_emit_epilogue (int);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n extern void rs6000_call_indirect_aix (rtx, rtx, rtx);\n-extern bool rs6000_save_toc_in_prologue_p (void);\n-\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n \n /* Declare functions in rs6000-c.c */"}, {"sha": "dcf78567068bcb8df469541a7b0d23e6ad13f5b8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "patch": "@@ -1178,6 +1178,7 @@ static void rs6000_conditional_register_usage (void);\n static void rs6000_trampoline_init (rtx, tree, rtx);\n static bool rs6000_cannot_force_const_mem (enum machine_mode, rtx);\n static bool rs6000_legitimate_constant_p (enum machine_mode, rtx);\n+static bool rs6000_save_toc_in_prologue_p (void);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -20478,14 +20479,12 @@ rs6000_emit_prologue (void)\n       insn = emit_insn (generate_set_vrsave (reg, info, 0));\n     }\n \n-  if (TARGET_SINGLE_PIC_BASE)\n-    return; /* Do not set PIC register */\n-\n   /* If we are using RS6000_PIC_OFFSET_TABLE_REGNUM, we need to set it up.  */\n-  if ((TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n-      || (DEFAULT_ABI == ABI_V4\n-\t  && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))\n-\t  && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM)))\n+  if (!TARGET_SINGLE_PIC_BASE\n+      && ((TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n+\t  || (DEFAULT_ABI == ABI_V4\n+\t      && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))\n+\t      && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))))\n     {\n       /* If emit_load_toc_table will use the link register, we need to save\n \t it.  We use R12 for this purpose because emit_load_toc_table\n@@ -20513,7 +20512,8 @@ rs6000_emit_prologue (void)\n     }\n \n #if TARGET_MACHO\n-  if (DEFAULT_ABI == ABI_DARWIN\n+  if (!TARGET_SINGLE_PIC_BASE\n+      && DEFAULT_ABI == ABI_DARWIN\n       && flag_pic && crtl->uses_pic_offset_table)\n     {\n       rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n@@ -20534,10 +20534,26 @@ rs6000_emit_prologue (void)\n     }\n #endif\n \n-  /* If we need to, save the TOC register after doing the stack setup.  */\n+  /* If we need to, save the TOC register after doing the stack setup.\n+     Do not emit eh frame info for this save.  The unwinder wants info,\n+     conceptually attached to instructions in this function, about\n+     register values in the caller of this function.  This R2 may have\n+     already been changed from the value in the caller.\n+     We don't attempt to write accurate DWARF EH frame info for R2\n+     because code emitted by gcc for a (non-pointer) function call\n+     doesn't save and restore R2.  Instead, R2 is managed out-of-line\n+     by a linker generated plt call stub when the function resides in\n+     a shared library.  This behaviour is costly to describe in DWARF,\n+     both in terms of the size of DWARF info and the time taken in the\n+     unwinder to interpret it.  R2 changes, apart from the\n+     calls_eh_return case earlier in this function, are handled by\n+     linux-unwind.h frob_update_context.  */ \n   if (rs6000_save_toc_in_prologue_p ())\n-    emit_frame_save (sp_reg_rtx, sp_reg_rtx, reg_mode, TOC_REGNUM,\n-\t\t     5 * reg_size, info->total_size);\n+    {\n+      rtx addr = gen_rtx_PLUS (Pmode, sp_reg_rtx, GEN_INT (5 * reg_size));\n+      rtx mem = gen_frame_mem (reg_mode, addr);\n+      emit_move_insn (mem, gen_rtx_REG (reg_mode, TOC_REGNUM));\n+    }\n }\n \n /* Write function prologue.  */\n@@ -27795,10 +27811,7 @@ rs6000_call_indirect_aix (rtx value, rtx func_desc, rtx flag)\n \n   /* Can we optimize saving the TOC in the prologue or do we need to do it at\n      every call?  */\n-  if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca\n-      && !cfun->calls_setjmp && !cfun->has_nonlocal_label\n-      && !cfun->can_throw_non_call_exceptions\n-      && ((flags_from_decl_or_type (cfun->decl) & ECF_NOTHROW) == ECF_NOTHROW))\n+  if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca)\n     cfun->machine->save_toc_in_prologue = true;\n \n   else\n@@ -27834,13 +27847,12 @@ rs6000_call_indirect_aix (rtx value, rtx func_desc, rtx flag)\n     insn = call_func (func_addr, flag, func_toc_mem, stack_toc_mem);\n \n   emit_call_insn (insn);\n-  return;\n }\n \n /* Return whether we need to always update the saved TOC pointer when we update\n    the stack pointer.  */\n \n-bool\n+static bool\n rs6000_save_toc_in_prologue_p (void)\n {\n   return (cfun && cfun->machine && cfun->machine->save_toc_in_prologue);"}, {"sha": "1685c9fa7c3b6ea8736948fe46a41d6e6e68354f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "patch": "@@ -1,3 +1,9 @@\n+2011-08-02  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/linux-unwind.h (frob_update_context <__powerpc64__>):\n+\tRestore for indirect call bcrtl from correct stack slot, and only\n+\tif cfa+40 isn't valid.\n+\n 2011-08-01  Julian Brown  <julian@codesourcery.com>\n \n \t* config.host (arm*-*-linux*, arm*-*-uclinux*, arm*-*-eabi*)"}, {"sha": "20116326c3c863dc8e129e73f98df7dc3b0ac606", "filename": "libgcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd15e32c71b65cf399dfe72708b8ab3f35550dfe/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=bd15e32c71b65cf399dfe72708b8ab3f35550dfe", "patch": "@@ -354,20 +354,22 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs ATT\n \t  /* We are in a plt call stub or r2 adjusting long branch stub,\n \t     before r2 has been saved.  Keep REG_UNSAVED.  */\n \t}\n-      else if (pc[0] == 0x4E800421\n-\t       && pc[1] == 0xE8410028)\n-\t{\n-\t  /* We are at the bctrl instruction in a call via function\n-\t     pointer.  gcc always emits the load of the new r2 just\n-\t     before the bctrl.  */\n-\t  _Unwind_SetGRPtr (context, 2, context->cfa + 40);\n-\t}\n       else\n \t{\n \t  unsigned int *insn\n \t    = (unsigned int *) _Unwind_GetGR (context, R_LR);\n \t  if (insn && *insn == 0xE8410028)\n \t    _Unwind_SetGRPtr (context, 2, context->cfa + 40);\n+\t  else if (pc[0] == 0x4E800421\n+\t\t   && pc[1] == 0xE8410028)\n+\t    {\n+\t      /* We are at the bctrl instruction in a call via function\n+\t\t pointer.  gcc always emits the load of the new R2 just\n+\t\t before the bctrl so this is the first and only place\n+\t\t we need to use the stored R2.  */\n+\t      _Unwind_Word sp = _Unwind_GetGR (context, 1);\n+\t      _Unwind_SetGRPtr (context, 2, sp + 40);\n+\t    }\n \t}\n     }\n #endif"}]}