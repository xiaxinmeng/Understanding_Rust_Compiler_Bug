{"sha": "342fac9537c6a75e65fe62943ba84b81bddede3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQyZmFjOTUzN2M2YTc1ZTY1ZmU2Mjk0M2JhODRiODFiZGRlZGUzZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-04-13T23:26:41Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-04-13T23:26:41Z"}, "message": "PR c++/69517 - [5/6 regression] SEGV on a VLA with excess initializer elements\n\nPR c++/69517 - [5/6 regression] SEGV on a VLA with excess initializer elements\nPR c++/70019 - VLA size overflow not detected\nPR c++/70588 - SIGBUS on a VLA larger than SIZE_MAX / 2\n\ngcc/testsuite/ChangeLog:\n2016-04-13  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/69517\n        PR c++/70019\n        PR c++/70588\n        * c-c++-common/ubsan/vla-1.c (main): Catch exceptions.\n        * g++.dg/cpp1y/vla11.C: New test.\n        * g++.dg/cpp1y/vla12.C: New test.\n        * g++.dg/cpp1y/vla13.C: New test.\n        * g++.dg/cpp1y/vla14.C: New test.\n        * g++.dg/cpp1y/vla3.C: Restore deleted test.\n        * gcc/testsuite/g++.dg/init/array24.C: Fully brace VLA initializer.\n        * g++.dg/ubsan/vla-1.C: Disable exceptions.\n\ngcc/cp/ChangeLog:\n2016-04-13  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/69517\n        PR c++/70019\n        PR c++/70588\n        * cp-tree.h (throw_bad_array_length, build_vla_check): Declare new\n        functions.\n        * decl.c (check_initializer, cp_finish_decl): Call them.\n        (reshape_init_r): Reject incompletely braced intializer-lists\n        for VLAs.\n        * init.c (throw_bad_array_length, build_vla_check)\n        (build_vla_size_check, build_vla_init_check): Define new functions.\n        * typeck2.c (split_nonconstant_init_1): Use variably_modified_type_p()\n        to detect a VLA.\n        (store_init_value): Same.\n\ngcc/doc/ChangeLog:\n2016-04-13  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/69517\n        PR c++/70019\n        PR c++/70588\n        * extend.texi (Variable Length): Document C++ specifics.\n\nlibstdc++-v3/ChangeLog:\n2016-04-13  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/69517\n        * testsuite/25_algorithms/rotate/moveable2.cc: Make sure VLA\n       upper bound is positive.\n\nFrom-SVN: r234966", "tree": {"sha": "1d55385c5ee07d32a08d9279dcb595632d96e73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d55385c5ee07d32a08d9279dcb595632d96e73c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/342fac9537c6a75e65fe62943ba84b81bddede3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/342fac9537c6a75e65fe62943ba84b81bddede3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/342fac9537c6a75e65fe62943ba84b81bddede3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/342fac9537c6a75e65fe62943ba84b81bddede3f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ecc0c837bf2ac1309f41d30b7b30595331a6eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecc0c837bf2ac1309f41d30b7b30595331a6eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ecc0c837bf2ac1309f41d30b7b30595331a6eb6"}], "stats": {"total": 1648, "additions": 1628, "deletions": 20}, "files": [{"sha": "a3c6c12c3883dc8a3292f57b454170b85ac34edc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1,3 +1,10 @@\n+2016-04-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* doc/extend.texi (Variable Length): Document C++ specifics.\n+\n 2016-04-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/70641"}, {"sha": "866b4f2dbba3fbe65ee59f31b1fd58d82cfe539b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1,3 +1,19 @@\n+2016-04-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* cp-tree.h (throw_bad_array_length, build_vla_check): Declare new\n+\tfunctions.\n+\t* decl.c (check_initializer, cp_finish_decl): Call them.\n+\t(reshape_init_r): Reject incompletely braced intializer-lists\n+\tfor VLAs.\n+\t* init.c (throw_bad_array_length, build_vla_check)\n+\t(build_vla_size_check, build_vla_init_check): Define new functions.\n+\t* typeck2.c (split_nonconstant_init_1): Use variably_modified_type_p()\n+\tto detect a VLA.\n+\t(store_init_value): Same.\n+\n 2016-04-13  Jason Merrill  <jason@redhat.com>\n \n \tWarn about empty parameter ABI with -Wabi=9."}, {"sha": "87e3ea0b2ee63ed44656c70312dc5161e6bbdb17", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -5950,6 +5950,7 @@ extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n extern tree get_nsdmi\t\t\t\t(tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree throw_bad_array_length              (void);\n extern tree throw_bad_array_new_length\t\t(void);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n@@ -5971,6 +5972,7 @@ extern tree scalar_constant_value\t\t(tree);\n extern tree decl_really_constant_value\t\t(tree);\n extern int diagnose_uninitialized_cst_or_ref_member (tree, bool, bool);\n extern tree build_vtbl_address                  (tree);\n+extern tree build_vla_check                     (tree, tree = NULL_TREE);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);"}, {"sha": "42e853f21908a19eaaef7b4b722ba30171efe735", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -5896,6 +5896,16 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t    }\n \t}\n \n+      if (variably_modified_type_p (type, NULL_TREE))\n+\t{\n+\t  /* Require VLAs to have their initializers fully braced\n+\t     to avoid initializing the wrong elements.  */\n+\t  if (complain & tf_error)\n+\t    error (\"missing braces around initializer for a variable length \"\n+\t\t   \"array %qT\", type);\n+\t  return error_mark_node;\n+\t}\n+\n       warning (OPT_Wmissing_braces, \"missing braces around initializer for %qT\",\n \t       type);\n     }\n@@ -6048,6 +6058,10 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n     /* There is no way to make a variable-sized class type in GNU C++.  */\n     gcc_assert (TREE_CONSTANT (TYPE_SIZE (type)));\n \n+  /* Initializer exression used to check invalid VLA bounds and excess\n+     initializer elements.  */\n+  tree saved_init_for_vla_check = NULL_TREE;\n+\n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n       int init_len = vec_safe_length (CONSTRUCTOR_ELTS (init));\n@@ -6199,7 +6213,9 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t      && PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))\n \t    warning (0, \"array %qD initialized by parenthesized string literal %qE\",\n \t\t     decl, DECL_INITIAL (decl));\n-\t  init = NULL;\n+\n+\t  saved_init_for_vla_check = init;\n+\t  init = NULL_TREE;\n \t}\n     }\n   else\n@@ -6213,6 +6229,33 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n       check_for_uninitialized_const_var (decl);\n     }\n \n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && variably_modified_type_p (type, NULL_TREE)\n+      && !processing_template_decl)\n+    {\n+      /* Statically check for overflow in VLA bounds and build\n+\t an expression that checks at runtime whether the VLA\n+\t is erroneous due to invalid (runtime) bounds.\n+\t Another expression to check for excess initializers\n+\t is built in build_vec_init.  */\n+      tree check = build_vla_check (TREE_TYPE (decl), saved_init_for_vla_check);\n+\n+      if (flag_exceptions && current_function_decl\n+\t  /* Avoid instrumenting constexpr functions for now.\n+\t     Those must be checked statically, and the (non-\n+\t     constexpr) dynamic instrumentation would cause\n+\t     them to be rejected.  See c++/70507.  */\n+\t  && !DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n+\t{\n+\t  /* Use the runtime check only when exceptions are enabled.\n+\t     Otherwise let bad things happen...  */\n+\t  check = build3 (COND_EXPR, void_type_node, check,\n+\t\t\t  throw_bad_array_length (), void_node);\n+\n+\t  finish_expr_stmt (check);\n+\t}\n+    }\n+\n   if (init && init != error_mark_node)\n     init_code = build2 (INIT_EXPR, type, decl, init);\n "}, {"sha": "ec19d72630206018174d39d8ecd7b4fd5d22d2c1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -2262,6 +2262,20 @@ diagnose_uninitialized_cst_or_ref_member (tree type, bool using_new, bool compla\n   return diagnose_uninitialized_cst_or_ref_member_1 (type, type, using_new, complain);\n }\n \n+/* Call __cxa_throw_bad_array_length to indicate that the size calculation\n+   in the bounds of a variable length array overflowed.  */\n+\n+tree\n+throw_bad_array_length (void)\n+{\n+  tree fn = get_identifier (\"__cxa_throw_bad_array_length\");\n+  if (!get_global_value_if_present (fn, &fn))\n+    fn = push_throw_library_fn (fn, build_function_type_list (void_type_node,\n+                                                             NULL_TREE));\n+\n+  return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n+}\n+\n /* Call __cxa_bad_array_new_length to indicate that the size calculation\n    overflowed.  Pretend it returns sizetype so that it plays nicely in the\n    COND_EXPR.  */\n@@ -4709,3 +4723,304 @@ build_vec_delete (tree base, tree maxindex,\n \n   return rval;\n }\n+\n+\n+/* The implementation of build_vla_check() that recursively builds\n+   an expression to determine whether the VLA TYPE is erroneous due\n+   either to its bounds being invalid or to integer overflow in\n+   the computation of its total size.\n+   CHECK is the boolean expression being built, initialized to\n+   boolean_false_node.\n+   VLASIZE is used internally to pass the incrementally computed\n+   size of the VLA object down to its recursive invocations.\n+   MAX_VLASIZE is the maximum valid size of the VLA in bytes.\n+   CST_SIZE is the product of the VLA's constant dimensions.  */\n+\n+static tree\n+build_vla_size_check (tree check,\n+\t\t      tree type,\n+\t\t      tree vlasize,\n+\t\t      tree max_vlasize,\n+\t\t      offset_int *cst_size)\n+{\n+  tree vmul = builtin_decl_explicit (BUILT_IN_MUL_OVERFLOW);\n+\n+  tree vlasizeaddr = build_unary_op (input_location, ADDR_EXPR, vlasize, 0);\n+\n+  bool overflow = false;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      /* Compute the upper bound of this array type.  */\n+      tree inner_nelts = array_type_nelts_top (type);\n+      tree inner_nelts_cst = maybe_constant_value (inner_nelts);\n+\n+      if (TREE_CODE (inner_nelts_cst) == INTEGER_CST)\n+\t{\n+\t  /* The upper bound is a constant expression.  Compute the product\n+\t     of the constant upper bounds seen so far so that overflow can\n+\t     be diagnosed.  */\n+\t  offset_int result = wi::mul (wi::to_offset (inner_nelts_cst),\n+\t\t\t\t       *cst_size, SIGNED, &overflow);\n+\t  *cst_size = overflow ? 0 : result;\n+\t}\n+\n+      /* Check for overflow in the VLAs (runtime) upper bounds.  */\n+      tree vflowcheck = build_call_expr (vmul, 3, inner_nelts,\n+\t\t\t\t\t vlasize, vlasizeaddr);\n+\n+      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t   check, vflowcheck);\n+\n+      /* Recursively check for overflow in the remaining major bounds.  */\n+      check = build_vla_size_check (check, TREE_TYPE (type),\n+\t\t\t\t    vlasize, max_vlasize,\n+\t\t\t\t    cst_size);\n+    }\n+  else\n+    {\n+      /* Get the size of the VLA element type in bytes.  */\n+      tree typesize = TYPE_SIZE_UNIT (type);\n+\n+      /* See if the size, when multipled by the product of the VLA's\n+\t constant dimensions, is within range of size_t.  If not,\n+\t the VLA is definitely erroneous amd must be diagnosed at\n+\t compile time.  */\n+      offset_int result = wi::mul (wi::to_offset (typesize), *cst_size,\n+\t\t\t\t   SIGNED, &overflow);\n+      *cst_size = overflow ? 0 : result;\n+\n+      /* Multiply the (non-constant) VLA size so far by the element size,\n+\t checking for overflow, and replacing the value of vlasize with\n+\t the product in the absence of overflow.  This size is the total\n+\t runtime size of the VLA in bytes.  */\n+      tree vflowcheck = build_call_expr (vmul, 3, typesize,\n+\t\t\t\t\t vlasize, vlasizeaddr);\n+\n+      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t   check, vflowcheck);\n+\n+      /* Check to see if the final VLA size exceeds the maximum.  */\n+      tree sizecheck = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t    max_vlasize, vlasize);\n+\n+      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t   check, sizecheck);\n+\n+      /* Also check to see if the final array size is zero (the size\n+\t is unsigned so the earlier overflow check detects negative\n+\t values as well.  */\n+      tree zerocheck = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    vlasize, size_zero_node);\n+\n+      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t   check, zerocheck);\n+    }\n+\n+  /* Diagnose overflow determined at compile time.  */\n+  if (overflow)\n+    {\n+      error (\"integer overflow in variable array size\");\n+      /* Reset to suppress any further diagnostics.  */\n+      *cst_size = 0;\n+    }\n+\n+  return check;\n+}\n+\n+/* The implementation of build_vla_check() that recursively builds\n+   an expression to determine whether the VLA initializer-list for\n+   TYPE is erroneous due to excess initializers.\n+   CHECK is the boolean expression being built, initialized to\n+   the result of build_vla_size_check().\n+   INIT is the VLA initializer expression to check against TYPE.\n+   On the first (non-recursive) call, INIT_ELTS is set either to 1,\n+   or to the number of elements in the initializer-list for VLAs\n+   of unspecified (major) bound.  On subsequent (recursive) calls.\n+   it is set to NULL and computed from the number of elements in\n+   the (nested) initializer-list.\n+*/\n+\n+static tree\n+build_vla_init_check (tree check, tree type, tree init, tree init_elts)\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      /* Compute the upper bound of this array type unless it has\n+\t already been computed by the caller for an array of unspecified\n+\t bound, as in 'T a[];'  */\n+      tree inner_nelts = init_elts ? init_elts : array_type_nelts_top (type);\n+\n+      size_t len;\n+\n+      if (TREE_CODE (init) == CONSTRUCTOR)\n+\t{\n+\t  /* The initializer of this array is itself an array.  Build\n+\t     an expression to check if the number of elements in the\n+\t     initializer array exceeds the upper bound of the type\n+\t     of the object being initialized.  */\n+\t  if (vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init))\n+\t    {\n+\t      len = v->length ();\n+\t      tree initelts = build_int_cstu (size_type_node, len);\n+\t      tree initcheck = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t    inner_nelts, initelts);\n+\n+\t      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t   check, initcheck);\n+\n+\t      constructor_elt *ce;\n+\t      HOST_WIDE_INT i;\n+\n+\t      /* Iterate over all non-empty initializers in this array,\n+\t\t recursively building expressions to see if the elements\n+\t\t of each are in excess of the corresponding (runtime)\n+\t\t bound of the array type.  */\n+\t      FOR_EACH_VEC_SAFE_ELT (v, i, ce)\n+\t\tcheck = build_vla_init_check (check, TREE_TYPE (type),\n+\t\t\t\t\t      ce->value, NULL_TREE);\n+\t    }\n+\t}\n+      else if (TREE_CODE (init) == STRING_CST\n+\t       && (len = TREE_STRING_LENGTH (init)))\n+\t{\n+\t  /* The initializer of this array is a string.  */\n+\t  tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n+\t  len /= TYPE_PRECISION (ctype) / BITS_PER_UNIT;\n+\n+\t  /* A C++ string literal initializer must have at most as many\n+\t     characters as there are elements in the array, including\n+\t     the terminating NUL.  */\n+\t  tree initelts = build_int_cstu (size_type_node, len);\n+\t  tree initcheck = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\tinner_nelts, initelts);\n+\t  check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t       check, initcheck);\n+\t}\n+      else if (TREE_CODE (init) == ERROR_MARK)\n+\t{\n+\t  // No checking is possible.\n+\t  check = boolean_false_node;\n+\t}\n+      else\n+\t{\n+\t  /* What's this array initializer?  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return check;\n+}\n+\n+/* Build an expression to determine whether the VLA TYPE is erroneous.\n+   INIT is the VLA initializer expression or NULL_TREE when the VLA is\n+   not initialized.  */\n+\n+tree\n+build_vla_check (tree type, tree init /* = NULL_TREE */)\n+{\n+  tree check = boolean_false_node;\n+\n+  /* The product of all constant dimensions of the VLA, initialized\n+     to either 1 in the common case or to the number of elements in\n+     the VLA's initializer-list for VLAs of unspecified (major)\n+     bound.  */\n+  offset_int cst_size = 1;\n+\n+  /* The initial size of the VLA to start the computation of the total\n+     size with.  Like CST_SIZE above, initialized to 1 or the number\n+     of elements in the VLA's initializer-list for VLAs of unspecified\n+     bound.  */\n+  tree initial_size = size_one_node;\n+\n+  /* For a VLA of unspecified (major) bound, the number of elements\n+     it is initialized with determined from the initializer-list.  */\n+  tree initial_elts = NULL_TREE;\n+\n+  if (init)\n+    {\n+      /* Determine the upper bound of the VLA of unspecified bound,\n+\t as in 'T a[];' if this is such a VLA.  Such a VLA can be\n+\t initialized with any number of elements but the number of\n+\t elements so determined must be used to check the total size\n+\t of the VLA.  */\n+      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+\n+      if (tree dom = TYPE_DOMAIN (type))\n+\tif (tree max = TYPE_MAX_VALUE (dom))\n+\t  if (integer_zerop (max))\n+\t    {\n+\t      if (TREE_CODE (init) == CONSTRUCTOR)\n+\t\t{\n+\t\t  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init);\n+\n+\t\t  /* Since the upper bound of every array must be positive\n+\t\t     a VLA with an unspecified major bound must be initized\n+\t\t     by a non-empty initializer list.  */\n+\t\t  gcc_assert (v != NULL);\n+\n+\t\t  cst_size = v->length ();\n+\t\t}\n+\t      else if (TREE_CODE (init) == STRING_CST)\n+\t\t{\n+\t\t  /* The initializer is a (possibly empty) string consisting\n+\t\t     at a minumum of one character, the terminating NUL.\n+\t\t     This condition implies a definition like\n+\t\t       char s [][N] = \"\";\n+\t\t     which is an error but even though it has been diagnosed\n+\t\t     by this point the initializer still winds up here.  */\n+\t\t  size_t nchars = TREE_STRING_LENGTH (init);\n+\t\t  tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n+\t\t  nchars /= TYPE_PRECISION (ctype) / BITS_PER_UNIT;\n+\n+\t\t  cst_size = nchars + 1;\n+\t\t}\n+\n+\t      initial_elts = wide_int_to_tree (size_type_node, cst_size);\n+\t      initial_size = initial_elts;\n+\t    }\n+    }\n+\n+  /* Build a variable storing the total runtime size of the VLA and\n+     initialize it either to 1 (in the common case) or to the number\n+     of topmost elements in the initializer-list when the VLA is\n+     an array of unspecified (major) bound.  */\n+  tree vlasize = build_decl (input_location,\n+\t\t\t     VAR_DECL, NULL_TREE, sizetype);\n+  DECL_ARTIFICIAL (vlasize) = 1;\n+  DECL_IGNORED_P (vlasize) = 1;\n+  DECL_CONTEXT (vlasize) = current_function_decl;\n+  DECL_INITIAL (vlasize) = initial_size;\n+  vlasize = pushdecl (vlasize);\n+  add_decl_expr (vlasize);\n+\n+  /* Impose a lenient limit on the size of the biggest VLA in bytes.\n+     FIXME: Tighten up the limit to make it more useful and make it\n+     configurable for users with unusual requirements.  */\n+  tree max_vlasize\n+    = fold_build2 (RSHIFT_EXPR, size_type_node,\n+\t\t   build_all_ones_cst (size_type_node),\n+\t\t   integer_one_node);\n+\n+  /* Build an expression that checks the runtime bounds of the VLA\n+     for invalid values and the total size of the VLA for overflow.  */\n+  check = build_vla_size_check (check, type, vlasize, max_vlasize, &cst_size);\n+\n+  if (wi::ltu_p (wi::to_offset (max_vlasize), cst_size))\n+    {\n+      /* Issue the warning only in the \"topmost\" (non-recursive) call\n+\t to avoid duplicating diagnostics.  This is only a warning to\n+\t allow programs to be portable to more permissive environments.  */\n+      warning (OPT_Wvla, \"size of variable length array exceeds maximum \"\n+\t       \"of %qE bytes\",  max_vlasize);\n+    }\n+\n+  if (init)\n+    {\n+      /* Build an expression that checks the VLA initializer expression\n+\t against the type of the VLA for excess elements.  */\n+      check = build_vla_init_check (check, type, init, initial_elts);\n+    }\n+\n+  return check;\n+}"}, {"sha": "eba19ca11acbc943f11d88bd8e17de6e01e07750", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -603,7 +603,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n       array_type_p = true;\n       if ((TREE_SIDE_EFFECTS (init)\n \t   && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t  || array_of_runtime_bound_p (type))\n+\t  || variably_modified_type_p (type, NULL_TREE))\n \t{\n \t  /* For an array, we only need/want a single cleanup region rather\n \t     than one per element.  */\n@@ -845,7 +845,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n      will perform the dynamic initialization.  */\n   if (value != error_mark_node\n       && (TREE_SIDE_EFFECTS (value)\n-\t  || array_of_runtime_bound_p (type)\n+\t  || variably_modified_type_p (type, NULL_TREE)\n \t  || ! reduced_constant_expression_p (value)))\n     return split_nonconstant_init (decl, value);\n   /* If the value is a constant, just put it in DECL_INITIAL.  If DECL"}, {"sha": "6687d595d3cad9d2497367adee66b1a9fa963ce3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1638,14 +1638,48 @@ foo (int n)\n You can use the function @code{alloca} to get an effect much like\n variable-length arrays.  The function @code{alloca} is available in\n many other C implementations (but not in all).  On the other hand,\n-variable-length arrays are more elegant.\n+variable-length arrays are available in GCC for all targets and\n+provide type safety.\n \n There are other differences between these two methods.  Space allocated\n with @code{alloca} exists until the containing @emph{function} returns.\n The space for a variable-length array is deallocated as soon as the array\n name's scope ends, unless you also use @code{alloca} in this scope.\n \n-You can also use variable-length arrays as arguments to functions:\n+Unlike GCC, G++ instruments variable-length arrays (@xref{Variable Length})\n+with checks for erroneous uses: when a variable-length array object is\n+created its runtime bounds are checked to detect non-positive values,\n+integer overflows, sizes in excess of SIZE_MAX / 2 bytes, and excess\n+initializers.  When an erroneous variable-length array is detected\n+the runtime arranges for an exception to be thrown that matches a handler\n+of type @code{std::bad_array_length}.\n+\n+Also unlike GCC, G++ allows variable-length arrays to be initialized.\n+However, unlike initializer lists for ordinary multidimensional arrays,\n+those for multidimensional variable-length arrays must be enclosed in\n+pairs of curly braces delimiting each sequence of values to use to\n+initialize each subarray.  Initializer lists that aren't unambiguously\n+enclosed in braces are rejected with an error.  For example, in the\n+following function, the initializer list for the ordinary @code{array}\n+is accepted even though it isn't fully enclosed in braces.  The same\n+initializer list, however, wouldn't be accepted for a multidimensional\n+variable-length array.  To initialize the variable-length array @code{vla},\n+the elements of the subarray @code{vla[m]} must be enclosed in braces\n+as shown.  As with ordinary arrays, elements that aren't initialized\n+explicitly are default-initialized.\n+\n+@smallexample\n+void\n+foo (int m, int n)\n+@{\n+  int array[2][3] = @{ 1, 2, 4, 5, 6 @};\n+  int vla[m][n] = @{ @{ 1, 2 @}, @{ 4, 5, 6 @} @};\n+@}\n+@end smallexample\n+\n+\n+In C programs (but not in C++) variable-length arrays can also be declared\n+as function arguments:\n \n @smallexample\n struct entry"}, {"sha": "b07b8b24dbd093065914d29c2e9016e34f1fafda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1,3 +1,17 @@\n+2016-04-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* c-c++-common/ubsan/vla-1.c (main): Catch exceptions.\n+\t* g++.dg/cpp1y/vla11.C: New test.\n+\t* g++.dg/cpp1y/vla12.C: New test.\n+\t* g++.dg/cpp1y/vla13.C: New test.\n+\t* g++.dg/cpp1y/vla14.C: New test.\n+\t* g++.dg/cpp1y/vla3.C: Restore deleted test.\n+\t* gcc/testsuite/g++.dg/init/array24.C: Fully brace VLA initializer.\n+\t* g++.dg/ubsan/vla-1.C: Disable exceptions.\n+\n 2016-04-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/70641"}, {"sha": "27ef110f52cf50b24de68f53eebb97430fd46548", "filename": "gcc/testsuite/c-c++-common/ubsan/vla-1.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -87,18 +87,24 @@ fn12 (void)\n int\n main (void)\n {\n-  fn1 ();\n-  fn2 ();\n-  fn3 ();\n-  fn4 ();\n-  fn5 ();\n-  fn6 ();\n-  fn7 ();\n-  fn8 ();\n-  fn9 ();\n-  fn10 ();\n-  fn11 ();\n-  fn12 ();\n+#if __cplusplus\n+#  define TRY(stmt)   do { try { stmt; } catch (...) { } } while (0)\n+#else\n+#  define TRY(stmt)   stmt\n+#endif\n+\n+  TRY (fn1 ());\n+  TRY (fn2 ());\n+  TRY (fn3 ());\n+  TRY (fn4 ());\n+  TRY (fn5 ());\n+  TRY (fn6 ());\n+  TRY (fn7 ());\n+  TRY (fn8 ());\n+  TRY (fn9 ());\n+  TRY (fn10 ());\n+  TRY (fn11 ());\n+  TRY (fn12 ());\n   return 0;\n }\n "}, {"sha": "af9624a404b9fa93a878c640ae0a44800b13aec2", "filename": "gcc/testsuite/g++.dg/cpp1y/vla11.C", "status": "added", "additions": 711, "deletions": 0, "changes": 711, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla11.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -0,0 +1,711 @@\n+// PR c++/69517 - [5/6 regression] SEGV on a VLA with excess initializer\n+//   elements\n+// PR c++/70019 - VLA size overflow not detected\n+//\n+// Runtime test to verify that attempting to either construct a VLA with\n+// erroneous bounds, or initialize one with an initializer-list that\n+// contains more elements than the VLA's non-constant (runtime) bounds\n+// causes an exception to be thrown.  Test also verifies that valid\n+// VLAs and their initializers don't cause such an exception.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-additional-options \"-Wno-vla\" }\n+\n+#pragma GCC diagnostic ignored \"-Wvla\"\n+\n+#define INT_MAX    __INT_MAX__\n+#define LONG_MAX   __LONG_MAX__\n+#define SIZE_MAX   __SIZE_MAX__\n+#define UINT_MAX   (~0U)\n+#define ULONG_MAX  (~0LU)\n+\n+#define INT_MIN    (-__INT_MAX__ - 1)\n+#define LONG_MIN   (-__LONG_MAX__ - 1)\n+\n+// The size of the largest allowed VLA in bytes.  Bigger objects\n+// cause an exception to be thrown.  Unless the maximum size is\n+// obscenely large, smaller objects should be successfully created\n+// provided there's enough stack space.  See TEST_NEAR_VLA_MAX_SIZE\n+// below.\n+#define MAX   (__SIZE_MAX__ / 2)\n+\n+// Define to non-zero to exercise very large VLAs with size just\n+// below the implementation-defined maximum.\n+#define TEST_NEAR_VLA_MAX_SIZE    0\n+\n+// Define to zero to enable tests that cause an ICE due to c++/58646.\n+#define BUG_58646 1\n+\n+// Helper macro to make it possible to pass as one multpile arguments\n+// to another macro.\n+#define Init(...) __VA_ARGS__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+// Incremented for each test failure.\n+int fail;\n+\n+// Used to convert a constant array dimension to a non-constant one.\n+template <class T>\n+T d (T n)\n+{\n+  return n;\n+}\n+\n+// Verify either that an expected exception has been thrown or that\n+// one hasn't been thrown if one isn't expected.\n+int __attribute__ ((noclone, noinline))\n+sink (void *p, int line, bool expect, const char *expr)\n+{\n+  if (!p != expect)\n+    {\n+      __builtin_printf (\"line %i: Assertion failed: '%s': \"\n+                        \"exception unexpectedly %sthrown\\n\",\n+                        line, expr, !p ? \"\" : \"not \");\n+      ++fail;\n+    }\n+  else\n+    {\n+#if defined DEBUG && DEBUG\n+    __builtin_printf (\"line %i: Assertion passed: '%s': \"\n+\t\t      \"exception %sthrown as expected\\n\",\n+\t\t      line, expr, !p ? \"\" : \"not \");\n+#endif\n+    }\n+  return 0;\n+}\n+\n+#define _CAT(name, line) name ## line\n+#define CAT(name, line) _CAT (name, line)\n+\n+#define STR(...) #__VA_ARGS__\n+\n+// Type to exercise VLA with.  TYPESIZE is the size of the type in bytes.\n+// Using a template serves two purposes.  First, it makes it possible to\n+// parameterize the test on VLAs of different size.  Second, it verifies\n+// that the checking code can deal with templates (i.e., completes\n+// the element type of the VLA when necessary).\n+template <unsigned TypeSize>\n+struct alignas (TypeSize) TestType\n+{\n+  char data;\n+};\n+\n+// Test function invoked with a pointer to each test case.  Must\n+// return a value though what value doesn't matter.\n+int __attribute__ ((noclone, noinline))\n+tester (int (*testcase)(const char*),\n+\tconst char *str, int line, bool expect)\n+{\n+  try\n+    {\n+      return testcase (str);\n+    }\n+  catch (...)\n+    {\n+      return sink (0, line, expect, str);\n+    }\n+}\n+\n+// Macro to define a unique specialization of a function template to\n+// exercise a VLA of type T, rank N, with dimensions given by Dims\n+// and initializer Init.  Expect is true when the VLA initialization\n+// is expected to trigger an exception.\n+// The macro creates a unique global dummy int object and initializes\n+// it with the result of the function.  The dummy object servers no\n+// other purpose but to call the function.  The function verifies\n+// the expected postconditions.\n+#define TEST(TypeSize, Dims, Init, Expect)\t\t\t\t\\\n+  static int CAT (testcase, __LINE__)(const char *str)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TestType<TypeSize> vla Dims Init;\t\t\t\t\t\\\n+    static_assert (sizeof (TestType<TypeSize>) == TypeSize,\t\t\\\n+\t\t   \"wrong test type size\");\t\t\t\t\\\n+    return sink (vla, __LINE__, Expect, str);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  const int CAT (dummy, __LINE__)\t\t\t\t\t\\\n+    = tester (CAT (testcase, __LINE__),\t\t\t\t\t\\\n+\t      \"T<\" #TypeSize \"> a\" #Dims \" \" STR (Init) \";\",\t\t\\\n+\t      __LINE__, Expect)\n+\n+\n+// Create and run a test function exercising a VLA definition\n+// of one of the following forms:\n+//    TestType<Size> VLA Dims;        // uninitialized (with Init ())\n+// or:\n+//    TestType<Size> VLA Dims Init;   // initialized (with = Init ({...})\n+//\n+//    +-- Element Size (in Bytes)\n+//    |  +-- VLA Dimensions (constant as in [3], otherwise d(3))\n+//    |  |         +-- VLA Initializer Expression (if any)\n+//    |  |         |                  +-- Expect Exception\n+//    |  |         |                  |\n+//    V  V         V                  V\n+TEST (1, [d(0)],   Init (/* none*/),  true);   // uninitialized\n+\n+#if !BUG_58646\n+// The following causes an ICE due to c++/58646.\n+TEST (1, [d(0)],   Init ({}),         true);\n+#endif\n+TEST (1, [d(0)],   Init ({1}),        true);   // initialized with \" {1}\"\n+TEST (1, [d(0)],   = Init ({1}),      true);   // initialized with \"= {1}\"\n+\n+TEST (1, [d(1)],   Init (),           false);\n+TEST (1, [d(1)],   Init ({}),         false);\n+TEST (1, [d(1)],   = Init ({}),       false);\n+TEST (1, [d(1)],   Init ({1}),        false);\n+TEST (1, [d(1)],   = Init ({1}),      false);\n+TEST (1, [d(1)],   Init ({1, 2}),     true);\n+TEST (1, [d(1)],   = Init ({1, 2}),   true);\n+\n+TEST (1, [d(2)],   Init (),           false);\n+TEST (1, [d(2)],   Init ({}),         false);\n+TEST (1, [d(2)],   Init ({1}),        false);\n+TEST (1, [d(2)],   Init ({1, 2}),     false);\n+TEST (1, [d(2)],   Init ({1, 2, 3}),  true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+// Very large but not erroneous one dimensional VLAs.\n+TEST (1, [d(MAX)], Init (),           false);\n+TEST (1, [d(MAX)], Init ({}),         false);\n+TEST (1, [d(MAX)], Init ({1}),        false);\n+TEST (1, [d(MAX)], Init ({1, 2}),     false);\n+TEST (1, [d(MAX)], Init ({1, 2, 3}),  false);\n+\n+TEST ( 2, [d(MAX / 2)],   Init (),    false);\n+TEST ( 4, [d(MAX / 4)],   Init (),    false);\n+TEST ( 8, [d(MAX / 8)],   Init (),    false);\n+TEST (16, [d(MAX / 16)],  Init (),    false);\n+TEST (32, [d(MAX / 32)],  Init (),    false);\n+TEST (64, [d(MAX / 64)],  Init (),    false);\n+#endif   // TEST_NEAR_VLA_MAX_SIZE\n+\n+// One dimensional VLAs with a negative upper bound.\n+TEST (1, [d(LONG_MIN)],  Init (),       true);\n+TEST (1, [d(INT_MIN)],   Init (),       true);\n+TEST (1, [d(-1234)],     Init (),       true);\n+TEST (1, [d(-1)],        Init (),       true);\n+\n+// Excessively large one dimensional VLAs.\n+TEST ( 1, [d(MAX + 1)],   Init (),      true);\n+TEST ( 2, [d(MAX)],       Init (),      true);\n+TEST ( 4, [d(MAX / 2)],   Init (),      true);\n+TEST ( 4, [d(MAX / 3)],   Init (),      true);\n+TEST ( 8, [d(MAX / 2)],   Init (),      true);\n+TEST ( 8, [d(MAX / 3)],   Init (),      true);\n+TEST ( 8, [d(MAX / 4)],   Init (),      true);\n+TEST ( 8, [d(MAX / 5)],   Init (),      true);\n+TEST ( 8, [d(MAX / 6)],   Init (),      true);\n+TEST ( 8, [d(MAX / 7)],   Init (),      true);\n+TEST (16, [d(MAX / 15)],  Init (),      true);\n+TEST (32, [d(MAX / 31)],  Init (),      true);\n+TEST (64, [d(MAX / 63)],  Init (),      true);\n+TEST ( 1, [d(SIZE_MAX)],  Init (),      true);\n+\n+TEST (1, [d(LONG_MIN)],  Init ({}),     true);\n+TEST (1, [d(INT_MIN)],   Init ({}),     true);\n+TEST (1, [d(-1)],        Init ({}),     true);\n+\n+TEST (1, [d(SIZE_MAX)],  Init ({}),     true);\n+\n+TEST (1, [d(LONG_MIN)],  Init ({0}),    true);\n+TEST (1, [d(INT_MIN)],   Init ({0}),    true);\n+TEST (1, [d(-1)],        Init ({0}),    true);\n+\n+TEST (1, [d(SIZE_MAX)],  Init ({0}),    true);\n+\n+TEST ( 1, [d(SIZE_MAX/2)  + 1], Init (), true);\n+TEST ( 2, [d(SIZE_MAX/4)  + 1], Init (), true);\n+TEST ( 4, [d(SIZE_MAX/8)  + 1], Init (), true);\n+TEST ( 8, [d(SIZE_MAX/16) + 1], Init (), true);\n+TEST (16, [d(SIZE_MAX/32) + 1], Init (), true);\n+\n+TEST ( 1, [d(SIZE_MAX/2)  + 1], Init ({1}),             true);\n+TEST ( 2, [d(SIZE_MAX/4)  + 1], Init ({1, 2}),          true);\n+TEST ( 4, [d(SIZE_MAX/8)  + 1], Init ({1, 2, 3}),       true);\n+TEST ( 8, [d(SIZE_MAX/16) + 1], Init ({1, 2, 3, 4}),    true);\n+TEST (16, [d(SIZE_MAX/32) + 1], Init ({1, 2, 3, 4, 5}), true);\n+\n+// Two dimensional VLAs with one constant bound.\n+\n+TEST (1, [1][d(0)],   Init (),          true);\n+\n+#if !BUG_58646\n+// The following causes an ICE due to c++/58646.\n+TEST (1, [1][d(0)],   Init ({}),        true);\n+#endif\n+TEST (1, [ ][d(0)],   Init ({{1}}),     true);   // unspecified bound\n+TEST (1, [1][d(0)],   Init ({{1}}),     true);\n+\n+TEST (1, [1][d(1)],   Init (),             false);\n+TEST (1, [1][d(1)],   Init ({{1}}),        false);\n+TEST (1, [1][d(1)],   Init ({{1, 2}}),     true);\n+TEST (1, [ ][d(1)],   Init ({{1, 2}}),     true);\n+\n+TEST (1, [1][d(2)],   Init (),             false);\n+TEST (1, [1][d(2)],   Init ({{1}}),        false);\n+TEST (1, [1][d(2)],   Init ({{1, 2}}),     false);\n+TEST (1, [ ][d(2)],   Init ({{1, 2}}),     false);\n+TEST (1, [1][d(2)],   Init ({{1, 2, 3}}),  true);\n+TEST (1, [ ][d(2)],   Init ({{1, 2, 3}}),  true);\n+\n+TEST (1, [2][d(1)],   Init (),                 false);\n+TEST (1, [2][d(1)],   Init ({{1}}),            false);\n+TEST (1, [ ][d(1)],   Init ({{1}}),            false);\n+TEST (1, [2][d(1)],   Init ({{1}, {2}}),       false);\n+TEST (1, [ ][d(1)],   Init ({{1}, {2}}),       false);\n+TEST (1, [2][d(1)],   Init ({{1, 2}}),         true);\n+TEST (1, [ ][d(1)],   Init ({{1, 2}}),         true);\n+TEST (1, [2][d(1)],   Init ({{1}, {2, 3}}),    true);\n+TEST (1, [ ][d(1)],   Init ({{1}, {2, 3}}),    true);\n+TEST (1, [2][d(1)],   Init ({{1, 2, 3}}),      true);\n+TEST (1, [ ][d(1)],   Init ({{1, 2, 3}}),      true);\n+TEST (1, [2][d(1)],   Init ({{1, 2, 3}, {4}}), true);\n+TEST (1, [ ][d(1)],   Init ({{1, 2, 3}, {4}}), true);\n+TEST (1, [2][d(1)],   Init ({{1, 2}, {3, 4}}), true);\n+TEST (1, [ ][d(1)],   Init ({{1, 2}, {3, 4}}), true);\n+\n+TEST (1, [2][d(2)],   Init (),                       false);\n+TEST (1, [2][d(2)],   Init ({{1}}),                  false);\n+TEST (1, [2][d(2)],   Init ({{1, 2}}),               false);\n+TEST (1, [2][d(2)],   Init ({{1, 2}, {3}}),          false);\n+TEST (1, [2][d(2)],   Init ({{1, 2}, {3, 4}}),       false);\n+TEST (1, [2][d(2)],   Init ({{1}, {2, 3, 4}}),       true);\n+TEST (1, [2][d(2)],   Init ({{1}, {2, 3, 4, 5}}),    true);\n+TEST (1, [2][d(2)],   Init ({{1, 2}, {3, 4, 5}}),    true);\n+TEST (1, [2][d(2)],   Init ({{1, 2, 3}, {4, 5}}),    true);\n+TEST (1, [2][d(2)],   Init ({{1, 2, 3}, {4, 5, 6}}), true);\n+\n+TEST (1, [2][d(3)],   Init (),                          false);\n+TEST (1, [2][d(3)],   Init ({{1}}),                     false);\n+TEST (1, [2][d(3)],   Init ({{1, 2}}),                  false);\n+TEST (1, [2][d(3)],   Init ({{1, 2}, {3}}),             false);\n+TEST (1, [2][d(3)],   Init ({{1, 2}, {3, 4}}),          false);\n+TEST (1, [2][d(3)],   Init ({{1}, {2, 3, 4}}),          false);\n+TEST (1, [2][d(3)],   Init ({{1}, {2, 3, 4, 5}}),       true);\n+TEST (1, [2][d(3)],   Init ({{1, 2}, {3, 4, 5}}),       false);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3}, {4, 5}}),       false);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3}, {4, 5, 6}}),    false);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3}, {4, 5, 6, 7}}), true);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3, 4}, {5, 6, 7}}), true);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3, 4, 5}, {6, 7}}), true);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3, 4, 5, 6}, {7}}), true);\n+TEST (1, [2][d(3)],   Init ({{1, 2, 3, 4, 5, 6, 7}}),   true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+TEST (1, [1][d(MAX)], Init (),                 false);\n+#  if !BUG_58646\n+// The following causes an ICE due to c++/58646.\n+TEST (1, [1][d(MAX)], Init ({}),               false);\n+#  endif\n+TEST (1, [1][d(MAX)], Init ({{1}}),            false);\n+TEST (1, [1][d(MAX)], Init ({{1, 2}}),         false);\n+TEST (1, [1][d(MAX)], Init ({{1, 2, 3}}),      false);\n+TEST (1, [1][d(MAX)], Init ({{1, 2, 3, 4}}),   false);\n+\n+TEST (1, [2][d(MAX / 2)], Init (),                       false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1}}),                  false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2}}),               false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2, 3}}),            false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2, 3, 4}}),         false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1}, {2}}),             false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1}, {2, 3}}),          false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2}, {3}}),          false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2}, {3, 4}}),       false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2, 3}, {4}}),       false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2, 3}, {4, 5}}),    false);\n+TEST (1, [2][d(MAX / 2)], Init ({{1, 2, 3}, {4, 5, 6}}), false);\n+#endif   // TEST_NEAR_VLA_MAX_SIZE\n+\n+// Excessively large two dimensional VLAs.\n+TEST (1, [1][d(LONG_MIN)],  Init (),       true);\n+TEST (1, [1][d(INT_MIN)],   Init (),       true);\n+TEST (1, [1][d(-1)],        Init (),       true);\n+\n+TEST (1, [1][d(SIZE_MAX)],  Init (),       true);\n+\n+#if !BUG_58646\n+// The following cause an ICE due to c++/58646.\n+TEST (1, [1][d(LONG_MIN)],  Init ({}),     true);\n+TEST (1, [1][d(INT_MIN)],   Init ({}),     true);\n+TEST (1, [1][d(-1)],        Init ({}),     true);\n+TEST (1, [1][d(SIZE_MAX)],  Init ({}),     true);\n+#endif\n+\n+TEST (1, [1][d(LONG_MIN)],  Init ({{0}}),  true);\n+TEST (1, [1][d(INT_MIN)],   Init ({{0}}),  true);\n+TEST (1, [1][d(-1)],        Init ({{0}}),  true);\n+TEST (1, [1][d(SIZE_MAX)],  Init ({{0}}),  true);\n+\n+TEST (1, [d(LONG_MIN)][1],  Init (),       true);\n+TEST (1, [d(INT_MIN)][1],   Init (),       true);\n+TEST (1, [d(-1)][1],        Init (),       true);\n+TEST (1, [d(SIZE_MAX)][1],  Init (),       true);\n+\n+TEST (1, [d(LONG_MIN)][1],  Init ({}),     true);\n+TEST (1, [d(INT_MIN)][1],   Init ({}),     true);\n+TEST (1, [d(-1)][1],        Init ({}),     true);\n+TEST (1, [d(SIZE_MAX)][1],  Init ({}),     true);\n+\n+TEST (1, [d(LONG_MIN)][1],  Init ({{0}}),  true);\n+TEST (1, [d(INT_MIN)][1],   Init ({{0}}),  true);\n+TEST (1, [d(-1)][1],        Init ({{0}}),  true);\n+TEST (1, [d(SIZE_MAX)][1],  Init ({{0}}),  true);\n+\n+// Two dimensional VLAs with no constant bound.\n+TEST (1, [d(0)][d(0)],   Init (),          true);\n+TEST (1, [d(0)][d(0)],   Init ({}),        true);\n+#if !BUG_58646\n+// The following cause an ICE due to c++/58646.\n+TEST (1, [d(0)][d(0)],   Init ({{}}),      true);\n+TEST (1, [d(0)][d(0)],   Init ({{}, {}}),  true);\n+#endif\n+\n+TEST (1, [d(0)][d(0)],   Init ({{1}}),     true);\n+TEST (1, [d(0)][d(0)],   Init ({{1, 2}}),  true);\n+#if !BUG_58646\n+TEST (1, [d(0)][d(0)],   Init ({{1}, {}}), true);\n+TEST (1, [d(0)][d(0)],   Init ({{}, {1}}), true);\n+#endif\n+\n+TEST (1, [d(1)][d(0)],   Init (),          true);\n+TEST (1, [d(1)][d(0)],   Init ({}),        true);\n+TEST (1, [d(1)][d(0)],   Init ({{1}}),     true);\n+\n+TEST (1, [d(1)][d(1)],   Init (),             false);\n+TEST (1, [d(1)][d(1)],   Init ({{1}}),        false);\n+TEST (1, [d(1)][d(1)],   Init ({{1, 2}}),     true);\n+\n+TEST (1, [d(1)][d(2)],   Init (),             false);\n+TEST (1, [d(1)][d(2)],   Init ({{1}}),        false);\n+TEST (1, [d(1)][d(2)],   Init ({{1, 2}}),     false);\n+TEST (1, [d(1)][d(2)],   Init ({{1, 2, 3}}),  true);\n+\n+TEST (1, [d(2)][d(1)],   Init (),                 false);\n+TEST (1, [d(2)][d(1)],   Init ({{1}}),            false);\n+TEST (1, [d(2)][d(1)],   Init ({{1}, {2}}),       false);\n+TEST (1, [d(2)][d(1)],   Init ({{1, 2}}),         true);\n+TEST (1, [d(2)][d(1)],   Init ({{1}, {2, 3}}),    true);\n+TEST (1, [d(2)][d(1)],   Init ({{1, 2, 3}}),      true);\n+TEST (1, [d(2)][d(1)],   Init ({{1, 2, 3}, {4}}), true);\n+TEST (1, [d(2)][d(1)],   Init ({{1, 2}, {3, 4}}), true);\n+\n+TEST (1, [d(2)][d(2)],   Init (),                       false);\n+TEST (1, [d(2)][d(2)],   Init ({{1}}),                  false);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2}}),               false);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2}, {3}}),          false);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2}, {3, 4}}),       false);\n+TEST (1, [d(2)][d(2)],   Init ({{1}, {2, 3, 4}}),       true);\n+TEST (1, [d(2)][d(2)],   Init ({{1}, {2, 3, 4, 5}}),    true);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2}, {3, 4, 5}}),    true);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2, 3}, {4, 5}}),    true);\n+TEST (1, [d(2)][d(2)],   Init ({{1, 2, 3}, {4, 5, 6}}), true);\n+\n+TEST (1, [d(2)][d(3)],   Init (),                          false);\n+TEST (1, [d(2)][d(3)],   Init ({{1}}),                     false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2}}),                  false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2}, {3}}),             false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2}, {3, 4}}),          false);\n+TEST (1, [d(2)][d(3)],   Init ({{1}, {2, 3, 4}}),          false);\n+TEST (1, [d(2)][d(3)],   Init ({{1}, {2, 3, 4, 5}}),       true);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2}, {3, 4, 5}}),       false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3}, {4, 5}}),       false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3}, {4, 5, 6}}),    false);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3}, {4, 5, 6, 7}}), true);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3, 4}, {5, 6, 7}}), true);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3, 4, 5}, {6, 7}}), true);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3, 4, 5, 6}, {7}}), true);\n+TEST (1, [d(2)][d(3)],   Init ({{1, 2, 3, 4, 5, 6, 7}}),   true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+TEST (1, [d(1)][d(MAX)], Init (),                              false);\n+TEST (1, [d(1)][d(MAX)], Init ({}),                            false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1}}),                         false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2}}),                      false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3}}),                   false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4}}),                false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4, 5}}),             false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4, 5, 6}}),          false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4, 5, 6, 7}}),       false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4, 5, 6, 7, 8}}),    false);\n+TEST (1, [d(1)][d(MAX)], Init ({{1, 2, 3, 4, 5, 6, 7, 8, 9}}), false);\n+\n+TEST (1, [d(2)][d(MAX / 2)], Init (),                              false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1}}),                         false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2}}),                      false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3}}),                   false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4}}),                false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4, 5}}),             false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4, 5, 6}}),          false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4, 5, 6, 7}}),       false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4, 5, 6, 7, 8}}),    false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3, 4, 5, 6, 7, 8, 9}}), false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1}, {2}}),                    false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1}, {2, 3}}),                 false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2}, {3}}),                 false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2}, {3, 4}}),              false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3}, {4}}),              false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3}, {4, 5}}),           false);\n+TEST (1, [d(2)][d(MAX / 2)], Init ({{1, 2, 3}, {4, 5, 6}}),        false);\n+#endif\n+\n+TEST (1, [d(2)][d(MAX)],        Init (),                         true);\n+TEST (1, [d(2)][d(MAX)],        Init ({{1}}),                    true);\n+TEST (1, [d(MAX)][d(MAX)],      Init ({{1, 2}}),                 true);\n+TEST (1, [d(0)][d(MAX)],        Init ({{1}, {2}}),               true);\n+TEST (1, [d(INT_MAX)][d(MAX)],  Init ({{1}, {2, 3}}),            true);\n+TEST (1, [d(SIZE_MAX)][d(MAX)], Init ({{1, 2}, {3, 4}, {5}}),    true);\n+\n+// Erroneous two-dimensional VLAs with size exceeding SIZE_MAX / 2\n+// (those must be rejected because no object can be bigger than that,\n+// otherwise pointer arithmetic breaks).\n+TEST ( 1, [2][d(SIZE_MAX/2)],  Init (), true);\n+TEST ( 2, [2][d(SIZE_MAX/4)],  Init (), true);\n+TEST ( 4, [2][d(SIZE_MAX/8)],  Init (), true);\n+TEST ( 8, [2][d(SIZE_MAX/16)], Init (), true);\n+TEST (16, [2][d(SIZE_MAX/32)], Init (), true);\n+\n+TEST ( 1, [d(SIZE_MAX/2)][2],  Init (), true);\n+TEST ( 2, [d(SIZE_MAX/4)][2],  Init (), true);\n+TEST ( 4, [d(SIZE_MAX/8)][2],  Init (), true);\n+TEST ( 8, [d(SIZE_MAX/16)][2], Init (), true);\n+TEST (16, [d(SIZE_MAX/32)][2], Init (), true);\n+\n+// Verify that the unspecified bound is factored into the computation\n+// of the total size.\n+TEST ( 1, [][d(SIZE_MAX/2)],  Init ({{1}, {2}}),      true);\n+TEST ( 2, [][d(SIZE_MAX/4)],  Init ({{1}, {2}}),      true);\n+TEST ( 4, [][d(SIZE_MAX/8)],  Init ({{1}, {2}}),      true);\n+TEST ( 8, [][d(SIZE_MAX/16)], Init ({{1}, {2}}),      true);\n+TEST (16, [][d(SIZE_MAX/32)], Init ({{1}, {2}}),      true);\n+TEST (16, [][d(SIZE_MAX/64)], Init ({{1}, {2}, {3}}), true);\n+\n+// Three dimensional VLAs with two constant bounds.\n+\n+TEST (1, [1][1][d(-1)], Init (),                    true);\n+TEST (1, [1][1][d(0)], Init (),                     true);\n+\n+#if !BUG_58646\n+// The following causes an ICE due to c++/58646.\n+TEST (1, [1][1][d(0)],  Init ({}),                   true);\n+TEST (1, [1][1][d(-1)], Init ({{}}),                 true);\n+TEST (1, [1][d(-1)][1], Init ({{}}),                 true);\n+TEST (1, [d(-1)][1][1], Init ({{}}),                 true);\n+\n+TEST (1, [1][1][d(0)], Init ({{}}),                  true);\n+TEST (1, [1][d(0)][1], Init ({{}}),                  true);\n+TEST (1, [d(0)][1][1], Init ({{}}),                  true);\n+#endif\n+\n+TEST (1, [1][1][d(1)], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [1][1][d(1)], Init ({{}}),                  false);\n+TEST (1, [1][1][d(1)], Init ({{{}}}),                false);\n+TEST (1, [1][1][d(1)], Init ({{{1}}}),               false);\n+#endif\n+\n+TEST (1, [1][1][d(1)], Init ({{{1, 2}}}),            true);\n+TEST (1, [1][1][d(1)], Init ({{{1, 2, 3}}}),         true);\n+\n+TEST (1, [1][d(1)][1], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [1][d(1)][1], Init ({{}}),                  false);\n+TEST (1, [1][d(1)][1], Init ({{{}}}),                false);\n+#endif\n+\n+TEST (1, [1][d(1)][1], Init ({{{1}}}),               false);\n+TEST (1, [1][d(1)][1], Init ({{{1}, {2}}}),          true);\n+TEST (1, [1][d(1)][1], Init ({{{1}, {2}, {3}}}),     true);\n+\n+TEST (1, [d(1)][1][1], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [d(1)][1][1], Init ({{}}),                  false);\n+TEST (1, [d(1)][1][1], Init ({{{}}}),                false);\n+#endif\n+\n+TEST (1, [d(1)][1][1], Init ({{{1}}}),               false);\n+TEST (1, [d(1)][1][1], Init ({{{1}}, {{2}}}),        true);\n+TEST (1, [d(1)][1][1], Init ({{{1}}, {{2}}, {{3}}}), true);\n+\n+TEST (1, [1][1][d(2)], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [1][1][d(2)], Init ({{}}),                  false);\n+TEST (1, [1][1][d(2)], Init ({{{}}}),                false);\n+#endif\n+\n+TEST (1, [1][1][d(2)], Init ({{{1}}}),               false);\n+TEST (1, [1][1][d(2)], Init ({{{1, 2}}}),            false);\n+TEST (1, [1][1][d(2)], Init ({{{1, 2, 3}}}),         true);\n+\n+TEST (1, [1][d(2)][1], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [1][d(2)][1], Init ({{}}),                  false);\n+TEST (1, [1][d(2)][1], Init ({{{}}}),                false);\n+#endif\n+TEST (1, [1][d(2)][1], Init ({{{1}}}),               false);\n+TEST (1, [1][d(2)][1], Init ({{{1}, {2}}}),          false);\n+TEST (1, [1][d(2)][1], Init ({{{1}, {2}, {3}}}),     true);\n+\n+TEST (1, [d(2)][1][1], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [d(2)][1][1], Init ({{}}),                  false);\n+TEST (1, [d(2)][1][1], Init ({{{}}}),                false);\n+#endif\n+TEST (1, [d(2)][1][1], Init ({{{1}}}),               false);\n+TEST (1, [d(2)][1][1], Init ({{{1}}, {{2}}}),        false);\n+TEST (1, [d(2)][1][1], Init ({{{1}}, {{2}}, {{3}}}), true);\n+\n+TEST (1, [1][2][d(2)], Init (),                      false);\n+\n+#if !BUG_58646\n+TEST (1, [1][2][d(2)], Init ({{}}),                  false);\n+TEST (1, [1][2][d(2)], Init ({{{}}}),                false);\n+#endif\n+\n+TEST (1, [1][2][d(2)], Init ({{{1}}}),               false);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2}}}),            false);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3}}}),         true);\n+\n+TEST (1, [1][2][d(2)], Init ({{{1}, {2}}}),          false);\n+TEST (1, [1][2][d(2)], Init ({{{1}, {2, 3}}}),       false);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2}, {3}}}),       false);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2}, {3, 4}}}),    false);\n+TEST (1, [1][2][d(2)], Init ({{{1}, {2, 3, 4}}}),    true);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3}, {}}}),     true);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3}, {4}}}),    true);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3, 4}}}),      true);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3, 4}, {}}}),  true);\n+TEST (1, [1][2][d(2)], Init ({{{1, 2, 3, 4}, {5}}}), true);\n+\n+TEST (1, [2][2][d(2)], Init ({{{1}, {2}}}),                         false);\n+TEST (1, [2][2][d(2)], Init ({{{1}, {2, 3}}}),                      false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}}}),                           false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3}}}),                      false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}}),                   false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5}}}),            false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}}}),         false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7}}}),    false);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}), false);\n+\n+TEST (1, [2][2][d(2)], Init ({{{1}, {2, 3, 4}}}),                      true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3}, {}}}),                       true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3}, {4}}}),                      true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3, 4}}}),                        true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3, 4}, {}}}),                    true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3, 4}, {5}}}),                   true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7, 8, 9}}}), true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6, 7}, {8, 9}}}), true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2}, {3, 4, 5}}, {{6, 7}, {8, 9}}}), true);\n+TEST (1, [2][2][d(2)], Init ({{{1, 2, 3}, {4, 5}}, {{6, 7}, {8, 9}}}), true);\n+TEST (1, [2][2][d(2)], Init ({{{1}, {2}}, {{3}, {4, 5, 6}}}),          true);\n+TEST (1, [2][2][d(2)], Init ({{{1}}, {{2}, {3, 4, 5, 6}}}),            true);\n+\n+// Three dimensional VLAs with one constant bound.\n+TEST (1, [2][d(-1)][d(-1)], Init (),                                      true);\n+TEST (1, [2][d(-1)][d(0)],  Init (),                                      true);\n+TEST (1, [2][d(0)][d(-1)],  Init (),                                      true);\n+TEST (1, [2][d(1)][d(-1)],  Init (),                                      true);\n+TEST (1, [2][d(1)][d(0)],   Init (),                                      true);\n+TEST (1, [2][d(-1)][d(1)],  Init (),                                      true);\n+TEST (1, [2][d(0)][d(1)],   Init (),                                      true);\n+\n+TEST (1, [2][d(2)][d(2)], Init (),                                        false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}}}),                                 false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1}}}),                                 false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2}}}),                            false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1}, {2}}}),                            false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3}}}),                         false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1}, {2, 3}}}),                         false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3}}}),                         false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2}, {3}}}),                         false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}}),                      false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}}),                      false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}),    false);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}),    false);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3, 4}}}),                      true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1}, {2, 3, 4}}}),                      true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3}, {}}}),                       true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2, 3}, {}}}),                       true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3}, {4}}}),                      true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2, 3}, {4}}}),                      true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}}}),                        true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2, 3, 4}}}),                        true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {}}}),                    true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {}}}),                    true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {5}}}),                   true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {5}}}),                   true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3, 4}}}),                      true);\n+TEST (1, [ ][d(2)][d(2)], Init ({{{1}, {2, 3, 4}}}),                      true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3}, {4}}}),                    true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3}, {}}}),                       true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3}, {4}}}),                      true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}}}),                        true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {}}}),                    true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3, 4}, {5}}}),                   true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6}, {7, 8, 9}}}), true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3, 4}}, {{5, 6, 7}, {8, 9}}}), true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2}, {3, 4, 5}}, {{6, 7}, {8, 9}}}), true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1, 2, 3}, {4, 5}}, {{6, 7}, {8, 9}}}), true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2}}, {{3}, {4, 5, 6}}}),          true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}}, {{2}, {3, 4, 5, 6}}}),            true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2}, {3}}}),                       true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3}, {4}}}),                    true);\n+TEST (1, [2][d(2)][d(2)], Init ({{{1}, {2, 3, 4}, {5}}}),                 true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+// Very large but not erroneous three-dimensional VLAs.\n+TEST ( 1, [2][d(1)][d(MAX/2)], Init (),  false);\n+TEST ( 2, [2][d(1)][d(MAX/4)], Init (),  false);\n+TEST ( 4, [2][d(1)][d(MAX/8)], Init (),  false);\n+TEST ( 8, [2][d(1)][d(MAX/16)], Init (), false);\n+TEST (16, [2][d(1)][d(MAX/32)], Init (), false);\n+\n+TEST ( 1, [2][d(MAX/2)][d(1)], Init (),  false);\n+TEST ( 2, [2][d(MAX/4)][d(1)], Init (),  false);\n+TEST ( 4, [2][d(MAX/8)][d(1)], Init (),  false);\n+TEST ( 8, [2][d(MAX/16)][d(1)], Init (), false);\n+TEST (16, [2][d(MAX/32)][d(1)], Init (), false);\n+\n+TEST ( 1, [d(MAX/2)][2][d(1)], Init (),  false);\n+TEST ( 2, [d(MAX/4)][2][d(1)], Init (),  false);\n+TEST ( 4, [d(MAX/8)][2][d(1)], Init (),  false);\n+TEST ( 8, [d(MAX/16)][2][d(1)], Init (), false);\n+TEST (16, [d(MAX/32)][2][d(1)], Init (), false);\n+#endif   // TEST_NEAR_VLA_MAX_SIZE\n+\n+// Erroneous three-dimensional VLAs with size exceeding SIZE_MAX / 2\n+// (those must be rejected because no object can be bigger than that,\n+// otherwise pointer arithmetic breaks).\n+TEST ( 1, [2][d(1)][d(SIZE_MAX/2)],  Init (), true);\n+TEST ( 2, [2][d(1)][d(SIZE_MAX/4)],  Init (), true);\n+TEST ( 4, [2][d(1)][d(SIZE_MAX/8)],  Init (), true);\n+TEST ( 8, [2][d(1)][d(SIZE_MAX/16)], Init (), true);\n+TEST (16, [2][d(1)][d(SIZE_MAX/32)], Init (), true);\n+\n+TEST ( 1, [2][d(SIZE_MAX/2)][d(1)],  Init (), true);\n+TEST ( 2, [2][d(SIZE_MAX/4)][d(1)],  Init (), true);\n+TEST ( 4, [2][d(SIZE_MAX/8)][d(1)],  Init (), true);\n+TEST ( 8, [2][d(SIZE_MAX/16)][d(1)], Init (), true);\n+TEST (16, [2][d(SIZE_MAX/32)][d(1)], Init (), true);\n+\n+TEST ( 1, [d(SIZE_MAX/2)][2][d(1)],  Init (), true);\n+TEST ( 2, [d(SIZE_MAX/4)][2][d(1)],  Init (), true);\n+TEST ( 4, [d(SIZE_MAX/8)][2][d(1)],  Init (), true);\n+TEST ( 8, [d(SIZE_MAX/16)][2][d(1)], Init (), true);\n+TEST (16, [d(SIZE_MAX/32)][2][d(1)], Init (), true);\n+\n+TEST (16, [3][d(SIZE_MAX)][d(SIZE_MAX)], Init (), true);\n+TEST (32, [d(SIZE_MAX)][5][d(SIZE_MAX)], Init (), true);\n+TEST (64, [d(SIZE_MAX)][d(SIZE_MAX)][7], Init (), true);\n+\n+int main ()\n+{\n+  if (fail)\n+    __builtin_abort ();\n+}"}, {"sha": "f938f3b199e0f0d348868babbfc1fb18c0681a0f", "filename": "gcc/testsuite/g++.dg/cpp1y/vla12.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -0,0 +1,99 @@\n+// Test to verify that variable length arrays the product of whose constant\n+// bounds overflows or exceeds the implementation-defined limit are diagnosed.\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-Wno-error=vla\" }\n+\n+#define INT_MAX    __INT_MAX__\n+#define LONG_MAX   __LONG_MAX__\n+#define SIZE_MAX   __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define MAX (SIZE_MAX / 2)\n+\n+void test (int x)\n+{\n+  const size_t amax = MAX;\n+\n+  // The following are valid and shouldn't elicit a bounds overflow warning.\n+  {\n+    char a [x][amax];         // { dg-warning \"forbids\" }\n+    (void)a;\n+  }\n+\n+  {\n+    char a [amax][x];         // { dg-warning \"forbids\" }\n+    (void)a;\n+  }\n+\n+  // The following is invalid and should be diagnosed.  Unfortunately,\n+  // when the VLA maximum size is (SIZE_MAX / 2), G++ also issues\n+  // a (bogus) -Woverflow because it computes the array bound in\n+  // a signed type (ssize_t) instead of size_t, in addition to\n+  // rejecting the declaration with error: size of array \u2018a\u2019 is too\n+  // large, before the VLA constant bound check has had a chance to\n+  // see it.  So the test is disabled.\n+  // {\n+  //   char a [x][amax + 1];\n+  //   (void)a;\n+  // }\n+\n+  {\n+    char a [x][x][amax];      // { dg-warning \"forbids\" }\n+    (void)a;\n+  }\n+\n+  {\n+    char a [x][amax][x];      // { dg-warning \"forbids\" }\n+    (void)a;\n+  }\n+\n+  {\n+    char a [amax][x][x];      // { dg-warning \"forbids\" }\n+    (void)a;\n+  }\n+\n+  {\n+    char a [2][x][amax];      // { dg-warning \"forbids|exceeds maximum\" }\n+    (void)a;\n+  }\n+\n+  {\n+    // Unfortunately, the following is rejected with a different error\n+    // earlier during parsing and before the VLA checking gets to see\n+    // it: error: size of array \u2018a\u2019 is too large\n+    // Ditto for other multidimensional VLAs where the overflow occurs\n+    // in the computation of the product of adjacent constant bounds.\n+    // char a [x][amax][amax];\n+    // char b [x][2][amax];\n+    // That error above also leads to the following error when using\n+    // the variable below.\n+    //   error:\u2019 was not declared in this scope\n+    // (void)a;\n+  }\n+\n+  {\n+    char a [amax][x][amax];   // { dg-warning \"forbids|exceeds maximum\" }\n+    (void)a;\n+  }\n+\n+  {\n+    char a [amax][amax][x];   // { dg-warning \"forbids|exceeds maximum\" }\n+    (void)a;\n+  }\n+\n+  {\n+    struct A256 { __attribute__ ((aligned (256))) char a; };\n+\n+    enum {\n+      M = 1024,\n+      N = MAX / (sizeof (A256) * M)\n+    };\n+\n+    A256 a [x][M][x][N];      // { dg-warning \"forbids\" }\n+    (void)a;\n+\n+    A256 b [2][x][M][x][N];   // { dg-warning \"forbids|exceeds maximum\" }\n+    (void)b;\n+  }\n+}"}, {"sha": "d473a638dfb2047f62903aee752cba0d42e9c99d", "filename": "gcc/testsuite/g++.dg/cpp1y/vla13.C", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -0,0 +1,260 @@\n+// PR c++/70019 - VLA size overflow not detected\n+// Runtime test to verify that attempting to initialize a VLA with a string\n+// or character array that's longer than the non-constant (runtime) bound\n+// of the VLA causes an exception to be thrown.  For a compile-time version\n+// of the test see vla14.C.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-additional-options \"-Wno-vla\" }\n+\n+#pragma GCC diagnostic ignored \"-Wvla\"\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+\n+// The size of the largest allowed VLA in bytes.  Bigger objects\n+// cause an exception to be thrown.  Unless the maximum size is\n+// obscenely large, smaller objects should be successfully created\n+// provided there's enough stack space.  See TEST_NEAR_VLA_MAX_SIZE\n+// below.\n+#define MAX   (__SIZE_MAX__ / 2)\n+\n+// Define to non-zero to exercise very large VLAs with size just\n+// below the implementation-defined maximum.\n+#define TEST_NEAR_VLA_MAX_SIZE    0\n+\n+// Define to zero to enable tests that cause an ICE due to c++/58646.\n+#define BUG_58646 1\n+\n+// Define to zero to enable tests that cause an ICE due to c++/69487.\n+#define BUG_69487 1\n+\n+// Helper macro to make it possible to pass as one multpile arguments\n+// to another macro.\n+#define Init(...) __VA_ARGS__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+// Incremented for each test failure.\n+int fail;\n+\n+// Used to convert a constant array dimension to a non-constant one.\n+template <class T>\n+T d (T n)\n+{\n+  return n;\n+}\n+\n+// Verify either that an expected exception has been thrown or that\n+// one hasn't been thrown if one isn't expected.\n+int __attribute__ ((noclone, noinline))\n+sink (void *p, int line, bool expect, const char *expr)\n+{\n+  if (!p != expect)\n+    {\n+      __builtin_printf (\"line %i: Assertion failed: '%s': \"\n+                        \"exception unexpectedly %sthrown\\n\",\n+                        line, expr, !p ? \"\" : \"not \");\n+      ++fail;\n+    }\n+  else\n+    {\n+#if defined DEBUG && DEBUG\n+    __builtin_printf (\"line %i: Assertion passed: '%s': \"\n+\t\t      \"exception %sthrown as expected\\n\",\n+\t\t      line, expr, !p ? \"\" : \"not \");\n+#endif\n+    }\n+  return 0;\n+}\n+\n+template <class T, int>\n+int test ();\n+\n+#define _CAT(name, line) name ## line\n+#define CAT(name, line) _CAT (name, line)\n+\n+#define STR(...) #__VA_ARGS__\n+\n+// Macro to define a unique specialization of a function template to\n+// exercise a VLA of type T, rank N, with dimensions given by Dims\n+// and initializer Init.  Expect is true when the VLA initialization\n+// is expected to trigger an exception.\n+// The macro creates a unique global dummy int object and initializes\n+// it with the result of the function.  The dummy object servers no\n+// other purpose but to call the function.  The function verifies\n+// the expected postconditions.\n+#define TEST(T, Dims, Init, Expect)                                     \\\n+  template <>                                                           \\\n+  int test<T, __LINE__>()                                               \\\n+  {                                                                     \\\n+    const char str[] = \"char a\" #Dims \" = { \" STR (Init) \" }\";          \\\n+    try {                                                               \\\n+      T a Dims = { Init };                                              \\\n+      return sink (a, __LINE__, Expect, str);                           \\\n+    }                                                                   \\\n+    catch (...) {                                                       \\\n+      return sink (0, __LINE__, Expect, str);                           \\\n+    }                                                                   \\\n+  }                                                                     \\\n+  const int CAT (dummy, __LINE__) = test<T, __LINE__>()\n+\n+\n+// Create and run a test function exercising a VLA definition\n+//    +-- Element Type\n+//    |     +-- VLA Dimensions\n+//    |     |        +-- VLA Initializer\n+//    |     |        |\n+//    |     |        |             +-- Expect Exception\n+//    |     |        |             |\n+//    V     V        V             V\n+TEST (char, [d(-1)], \"\",           true);\n+\n+TEST (char, [d(0)],  \"\",           true);\n+TEST (char, [d(0)],  (\"\"),         true);\n+\n+TEST (char, [d(1)],  \"\",           false);\n+TEST (char, [d(1)],  (\"\"),         false);\n+\n+TEST (char, [d(1)],  \"1\",          true);\n+TEST (char, [d(1)],  (\"1\"),        true);\n+\n+TEST (char, [d(1)],  \"12\",         true);\n+TEST (char, [d(1)],  \"1234567890\", true);\n+\n+TEST (char, [d(2)], \"\",           false);\n+TEST (char, [d(2)], (\"\"),         false);\n+\n+TEST (char, [d(2)], \"1\",          false);\n+TEST (char, [d(2)], \"12\",         true);\n+TEST (char, [d(2)], \"123\",        true);\n+TEST (char, [d(2)], \"1234567890\", true);\n+\n+TEST (char, [d(3)], \"\",           false);\n+TEST (char, [d(3)], \"1\",          false);\n+TEST (char, [d(3)], \"12\",         false);\n+TEST (char, [d(3)], \"123\",        true);\n+TEST (char, [d(3)], \"1234\",       true);\n+TEST (char, [d(3)], \"1234567890\", true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+\n+#  if !BUG_69487\n+// The following crash due to c++/69487.\n+TEST (char, [d(MAX)], \"\",           false);\n+TEST (char, [d(MAX)], \"1\",          false);\n+TEST (char, [d(MAX)], \"12\",         false);\n+TEST (char, [d(MAX)], \"1234567890\", false);\n+#  endif\n+\n+TEST (char, [d(MAX)], Init (),                             false);\n+TEST (char, [d(MAX)], Init (1),                            false);\n+TEST (char, [d(MAX)], Init (1, 2),                         false);\n+TEST (char, [d(MAX)], Init (1, 2, 3, 4, 5, 6, 7, 8, 9, 0), false);\n+#endif\n+\n+TEST (char, [d(SIZE_MAX / 2 + 1)], \"\", true);\n+TEST (char, [d(SIZE_MAX - 2)],     \"\", true);\n+TEST (char, [d(SIZE_MAX - 1)],     \"\", true);\n+\n+TEST (wchar_t, [d(1)], L\"\",           false);\n+TEST (wchar_t, [d(1)], (L\"\"),         false);\n+TEST (wchar_t, [d(1)], L\"1\",          true);\n+TEST (wchar_t, [d(1)], L\"12\",         true);\n+TEST (wchar_t, [d(1)], L\"1234567890\", true);\n+\n+TEST (wchar_t, [d(2)], L\"\",           false);\n+TEST (wchar_t, [d(2)], L\"1\",          false);\n+TEST (wchar_t, [d(2)], L\"12\",         true);\n+TEST (wchar_t, [d(2)], L\"123\",        true);\n+TEST (wchar_t, [d(2)], L\"1234567890\", true);\n+\n+TEST (char, [d(1)][d(1)], Init (\"\"),        false);\n+TEST (char, [1]   [d(1)], Init (\"\"),        false);\n+TEST (char, [d(1)][1],    Init (\"\"),        false);\n+\n+TEST (char, [d(1)][d(1)], Init (\"1\"),       true);\n+\n+// The following is accepted at compile time but throws an exception\n+// at runtime since in C++ a one-element array cannot be initialized\n+// with a string literal of length one because there isn't room for\n+// the terminating NUL\n+TEST (char, [1][d(1)],    Init (\"1\"),       true);\n+\n+// The following is rejected at compile-time since a one-element array\n+// cannot be initialized with a string literal of length one because\n+// there isn't room for the terminating NUL (see vla14.C).\n+// TEST (char, [d(1)][1],    Init (\"1\"),       false);\n+\n+TEST (char, [d(1)][d(1)], Init (\"12\"),      true);\n+TEST (char, [d(1)][d(1)], Init (\"1\", \"2\"),  true);\n+TEST (char, [d(1)][d(1)], Init (\"1\", \"23\"), true);\n+\n+TEST (char, [d(2)][d(2)], Init (\"\", \"\"),    false);\n+TEST (char, [d(2)][d(2)], Init (\"\", \"1\"),   false);\n+TEST (char, [d(2)][d(2)], Init (\"1\", \"\"),   false);\n+TEST (char, [d(2)][d(2)], Init (\"1\", \"1\"),  false);\n+TEST (char, [2][d(2)],    Init (\"\",  \"1\"),  false);\n+TEST (char, [2][d(2)],    Init (\"1\", \"\"),   false);\n+TEST (char, [2][d(2)],    Init (\"1\", \"1\"),  false);\n+TEST (char, [d(2)][2],    Init (\"\",  \"1\"),  false);\n+TEST (char, [d(2)][2],    Init (\"1\", \"\"),   false);\n+TEST (char, [d(2)][2],    Init (\"1\", \"1\"),  false);\n+\n+TEST (char, [2][d(2)],    Init (\"1\", \"23\"), true);\n+TEST (char, [d(2)][d(2)], Init (\"1\", \"23\"), true);\n+TEST (char, [d(2)][d(2)], Init (\"1\", \"23\"), true);\n+TEST (char, [d(2)][d(2)], Init (\"12\",\"3\"),  true);\n+\n+#if TEST_NEAR_VLA_MAX_SIZE\n+#  if !BUG_69487\n+   // The following crash due to c++/69487.\n+TEST (char, [1][d(MAX)], Init (\"\"),           false);\n+TEST (char, [1][d(MAX)], Init (\"1\"),          false);\n+TEST (char, [1][d(MAX)], Init (\"12\"),         false);\n+TEST (char, [1][d(MAX)], Init (\"1234567890\"), false);\n+#  endif\n+\n+#  if !BUG_58646\n+// The following causes an ICE due to c++/58646.\n+TEST (char, [1][d(MAX)], Init (),                               false);\n+#  endif\n+\n+TEST (char, [1][d(MAX)], Init ({1}),                            false);\n+TEST (char, [1][d(MAX)], Init ({1, 2}),                         false);\n+TEST (char, [1][d(MAX)], Init ({1, 2, 3}),                      false);\n+TEST (char, [1][d(MAX)], Init ({1, 2, 3, 4, 5, 6, 7, 8, 9, 0}), false);\n+\n+TEST (char, [d(MAX)][1], Init ({1}),                            false);\n+TEST (char, [d(MAX)][1], Init ({1}, {2}),                       false);\n+TEST (char, [d(MAX)][1], Init ({1}, {2}, {3}),                  false);\n+TEST (char, [d(MAX)][1], Init ({1}, {2}, {3}, {4}, {5},\n+\t\t\t       {6}, {7}, {8}, {9}, {0}),        false);\n+#endif   // TEST_NEAR_VLA_MAX_SIZE\n+\n+// The following are expected to throw due to excessive size.\n+TEST (char, [2][d(MAX)], Init ({1}),                                 true);\n+TEST (char, [2][d(MAX)], Init ({1, 2}),                              true);\n+TEST (char, [2][d(MAX)], Init ({1}, {2}),                            true);\n+TEST (char, [2][d(MAX)], Init ({1, 2}, {3, 4}),                      true);\n+TEST (char, [2][d(MAX)], Init ({1, 2, 3}, {4, 5, 6}),                true);\n+TEST (char, [2][d(MAX)], Init ({1, 2, 3, 4}, {5, 6, 7, 8}),          true);\n+\n+TEST (char, [d(MAX)][2], Init ({1}),                                 true);\n+TEST (char, [d(MAX)][2], Init ({1, 2}),                              true);\n+TEST (char, [d(MAX)][2], Init ({1}, {2}),                            true);\n+TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}),                      true);\n+TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}, {5, 6}),              true);\n+TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}, {5, 6}, {7, 8}),      true);\n+\n+TEST (char, [d(MAX)][d(MAX)], Init ({1}),                            true);\n+TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}),                         true);\n+TEST (char, [d(MAX)][d(MAX)], Init ({1}, {2}),                       true);\n+TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}),                 true);\n+TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}, {5, 6}),         true);\n+TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}, {5, 6}, {7, 8}), true);\n+\n+int main ()\n+{\n+  if (fail)\n+    __builtin_abort ();\n+}"}, {"sha": "4a0e82774f21314529295318bd741785072a0f9f", "filename": "gcc/testsuite/g++.dg/cpp1y/vla14.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -0,0 +1,48 @@\n+// PR c++/70019 - VLA size overflow not detected\n+// Compile-time test to verify that attempting to initialize a VLA with\n+// a string that's longer than the VLA's constant bound is diagnosed at\n+// compile time.  For a runtime version of the test see vla13.C.\n+\n+// { dg-do run }\n+// { dg-additional-options \"-Wno-vla\" }\n+\n+\n+void test (int n)\n+{\n+  char a1[n][1] = { { \"a\" } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a1;\n+\n+  char a2[1][n] = { { \"a\" } };\n+  (void)a2;\n+\n+  char a3[n][1][1] = { { { \"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a3;\n+\n+  char a4[1][1][n] = { { { \"a\" } } };\n+  (void)a4;\n+\n+  char a5[1][n][1] = { { { \"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a5;\n+\n+  char a6[n][1][n] = { { { \"a\" } } };\n+  (void)a6;\n+\n+\n+  wchar_t a7[n][1] = { { L\"a\" } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a7;\n+\n+  wchar_t a8[1][n] = { { L\"a\" } };\n+  (void)a8;\n+\n+  wchar_t a9[n][1][1] = { { { L\"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a9;\n+\n+  wchar_t a10[1][1][n] = { { { L\"a\" } } };\n+  (void)a10;\n+\n+  wchar_t a11[][n][1] = { { { L\"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n+  (void)a11;\n+\n+  wchar_t a12[n][1][n] = { { { L\"a\" } } };\n+  (void)a12;\n+}"}, {"sha": "9b2d6b3072c41aff694008fc6156e4a92772e255", "filename": "gcc/testsuite/g++.dg/cpp1y/vla3.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -0,0 +1,43 @@\n+// Test for throwing bad_array_length on invalid array length.\n+// { dg-do run { target c++14 } }\n+// { dg-additional-options \"-Wno-vla\" }\n+\n+namespace std\n+{\n+struct exception\n+{\n+  virtual ~exception ();\n+  virtual const char* what () const throw ();\n+};\n+}\n+\n+int f(int i)\n+{\n+  int ar[i]{1,2,3,4};\n+  return ar[i-1];\n+}\n+\n+void g(int i)\n+{\n+  int ar[i];\n+  ar[0] = 42;\n+}\n+\n+int main()\n+{\n+  int ok = 0;\n+  f(4);\t\t\t\t// OK\n+  try {\n+    f(3);\t\t\t// too small\n+  }\n+  catch (std::exception &e) {\n+    ++ok;\n+  }\n+  try { g(-24); }\t\t// negative\n+  catch (std::exception &e) {\n+    ++ok;\n+  }\n+\n+  if (ok != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "fc10c0a7349f280c5062137a02460c47a377e98c", "filename": "gcc/testsuite/g++.dg/init/array24.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -3,5 +3,5 @@\n \n void foo(int i)\n {\n-  int x[][i] = { 0 };\n+  int x[][i] = { { 0 } };\n }"}, {"sha": "374c80ad38413173e179bb24523eff6d5bc25309", "filename": "gcc/testsuite/g++.dg/ubsan/vla-1.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1,5 +1,8 @@\n // { dg-do run }\n-// { dg-options \"-Wno-vla -fsanitize=undefined\" }\n+// Disable exceptions to prevent the erroneous initializer from\n+// throwing before the sanitizer instrumentation has detected\n+// the problem.\n+// { dg-options \"-Wno-vla -fno-exceptions -fsanitize=undefined\" }\n // { dg-output \"index 1 out of bounds\" }\n \n void f(int i) {"}, {"sha": "d31a5d29120fe18e041b187c3f40a2c311ac516b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -1,3 +1,9 @@\n+2016-04-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\t* testsuite/25_algorithms/rotate/moveable2.cc: Make sure VLA\n+\tupper bound is positive.\n+\n 2016-04-13  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/c++config (_GLIBCXX_BEGIN_NAMESPACE_EMPTY_TYPES,"}, {"sha": "f944236f0617c3d80badf6a6d29072f07f7f1d35", "filename": "libstdc++-v3/testsuite/25_algorithms/rotate/moveable2.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/342fac9537c6a75e65fe62943ba84b81bddede3f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fmoveable2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/342fac9537c6a75e65fe62943ba84b81bddede3f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fmoveable2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate%2Fmoveable2.cc?ref=342fac9537c6a75e65fe62943ba84b81bddede3f", "patch": "@@ -44,7 +44,8 @@ template<typename Con>\n   {\n     bool test __attribute__((unused)) = true;\n \n-    rvalstruct array[length];\n+    /* Make sure the VLA upper bound is positive. */\n+    rvalstruct array[length + 1];\n     for(int i = 0; i < length; ++i)\n       array[i] = i;\n     Con con(array, array + length);"}]}