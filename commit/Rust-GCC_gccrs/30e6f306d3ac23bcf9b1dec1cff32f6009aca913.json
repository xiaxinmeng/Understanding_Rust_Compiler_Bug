{"sha": "30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBlNmYzMDZkM2FjMjNiY2Y5YjFkZWMxY2ZmMzJmNjAwOWFjYTkxMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-09-07T07:47:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-09-07T07:47:15Z"}, "message": "function.c (ARG_POINTER_CFA_OFFSET): Move ...\n\n        * function.c (ARG_POINTER_CFA_OFFSET): Move ...\n        * defaults.h (ARG_POINTER_CFA_OFFSET): ... here.\n        (INCOMING_FRAME_SP_OFFSET): Move from dwarf2out.c.\n        * dwarf2out.c (struct cfa_loc): Change reg to unsigned int,\n        rearrange for better packing.\n        (INCOMING_FRAME_SP_OFFSET): Move to defaults.h.\n        (lookup_cfa_1): Remove inline marker.\n        (cfa_equal_p): Split out of ...\n        (def_cfa_1): ... here.  Use INVALID_REGNUM.\n        (build_cfa_loc): Handle !cfa->indirect.\n        (frame_pointer_cfa_offset): New.\n        (dbx_reg_number): Assert register elimination performed; do\n        leaf register remapping.\n        (reg_loc_descriptor): Avoid calling dbx_reg_number when unused.\n        (eliminate_reg_to_offset): New.\n        (based_loc_descr): Remove can_use_fbreg argument.  Use fbreg only\n        for verifiably local stack frame addresses; re-base to CFA.\n        (mem_loc_descriptor): Remove can_use_fbreg argument.\n        (concat_loc_descriptor, loc_descriptor): Likewise.\n        (containing_function_has_frame_base): Remove.\n        (rtl_for_decl_location): Don't do register elimination or\n        leaf register remapping here.\n        (secname_for_decl): Split out from ..\n        (add_location_or_const_value_attribute): ... here.\n        (convert_cfa_to_loc_list): New.\n        (compute_frame_pointer_to_cfa_displacement): New.\n        (gen_subprogram_die): Use them.\n        * tree.h (frame_base_decl): Remove.\n        * var-tracking.c (frame_base_decl, frame_stack_adjust): Remove.\n        (prologue_stack_adjust): Remove.\n        (vt_stack_adjustments): Use INCOMING_FRAME_SP_OFFSET.\n        (adjust_stack_reference): Re-base memories to arg_pointer_rtx.\n        (set_frame_base_location): Remove.\n        (compute_bb_dataflow, emit_notes_in_bb): Don't call it.\n        (dump_attrs_list, dump_dataflow_set): Use string concatenation.\n        (vt_add_function_parameters): Don't eliminate_regs.\n        (vt_initialize): Don't create frame_base_decl.\n\nFrom-SVN: r103983", "tree": {"sha": "8185487e9f35c89d163198116ad501cfa5dad143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8185487e9f35c89d163198116ad501cfa5dad143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/comments", "author": null, "committer": null, "parents": [{"sha": "d1d26ecf9fa4f22c71353c650d85bf3b0fd3b1b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d26ecf9fa4f22c71353c650d85bf3b0fd3b1b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d26ecf9fa4f22c71353c650d85bf3b0fd3b1b5"}], "stats": {"total": 674, "additions": 358, "deletions": 316}, "files": [{"sha": "cac2e62d6a118bbf6a7393da6dcac6433b384d8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -1,3 +1,43 @@\n+2005-09-07  Richard Henderson  <rth@redhat.com>\n+\n+        * function.c (ARG_POINTER_CFA_OFFSET): Move ...\n+        * defaults.h (ARG_POINTER_CFA_OFFSET): ... here.\n+\t(INCOMING_FRAME_SP_OFFSET): Move from dwarf2out.c.\n+        * dwarf2out.c (struct cfa_loc): Change reg to unsigned int,\n+        rearrange for better packing.\n+\t(INCOMING_FRAME_SP_OFFSET): Move to defaults.h.\n+        (lookup_cfa_1): Remove inline marker.\n+        (cfa_equal_p): Split out of ...\n+        (def_cfa_1): ... here.  Use INVALID_REGNUM.\n+        (build_cfa_loc): Handle !cfa->indirect.\n+        (frame_pointer_cfa_offset): New.\n+        (dbx_reg_number): Assert register elimination performed; do\n+        leaf register remapping.\n+        (reg_loc_descriptor): Avoid calling dbx_reg_number when unused.\n+        (eliminate_reg_to_offset): New.\n+        (based_loc_descr): Remove can_use_fbreg argument.  Use fbreg only\n+        for verifiably local stack frame addresses; re-base to CFA.\n+        (mem_loc_descriptor): Remove can_use_fbreg argument.\n+        (concat_loc_descriptor, loc_descriptor): Likewise.\n+        (containing_function_has_frame_base): Remove.\n+        (rtl_for_decl_location): Don't do register elimination or\n+        leaf register remapping here.\n+        (secname_for_decl): Split out from ..\n+        (add_location_or_const_value_attribute): ... here.\n+        (convert_cfa_to_loc_list): New.\n+        (compute_frame_pointer_to_cfa_displacement): New.\n+        (gen_subprogram_die): Use them.\n+        * tree.h (frame_base_decl): Remove.\n+        * var-tracking.c (frame_base_decl, frame_stack_adjust): Remove.\n+        (prologue_stack_adjust): Remove.\n+        (vt_stack_adjustments): Use INCOMING_FRAME_SP_OFFSET.\n+        (adjust_stack_reference): Re-base memories to arg_pointer_rtx.\n+        (set_frame_base_location): Remove.\n+        (compute_bb_dataflow, emit_notes_in_bb): Don't call it.\n+        (dump_attrs_list, dump_dataflow_set): Use string concatenation.\n+        (vt_add_function_parameters): Don't eliminate_regs.\n+        (vt_initialize): Don't create frame_base_decl.\n+\n 2005-09-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* doc/install.texi (*-*-solaris2*): Clarify wording on the recommended"}, {"sha": "9ac1afc6c11543fd9ffe656638618016a36b9da8", "filename": "gcc/defaults.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -835,4 +835,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define FRAME_GROWS_DOWNWARD 0\n #endif\n \n+/* On most machines, the CFA coincides with the first incoming parm.  */\n+#ifndef ARG_POINTER_CFA_OFFSET\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n+#endif\n+\n+/* The offset from the incoming value of %sp to the top of the stack frame\n+   for the current function.  */\n+#ifndef INCOMING_FRAME_SP_OFFSET\n+#define INCOMING_FRAME_SP_OFFSET 0\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "63f2f984bbc29578096d8cdf5bbe008a5693c4b5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 291, "deletions": 182, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -239,9 +239,9 @@ dw_cfi_node;\n    of this structure.  */\n typedef struct cfa_loc GTY(())\n {\n-  unsigned long reg;\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT base_offset;\n+  unsigned int reg;\n   int indirect;            /* 1 if CFA is accessed via a dereference.  */\n } dw_cfa_location;\n \n@@ -436,12 +436,6 @@ static void def_cfa_1 (const char *, dw_cfa_location *);\n #ifndef DWARF_FRAME_REGNUM\n #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n #endif\n-\n-/* The offset from the incoming value of %sp to the top of the stack frame\n-   for the current function.  */\n-#ifndef INCOMING_FRAME_SP_OFFSET\n-#define INCOMING_FRAME_SP_OFFSET 0\n-#endif\n \f\n /* Hook used by __throw.  */\n \n@@ -669,7 +663,7 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \n /* Subroutine of lookup_cfa.  */\n \n-static inline void\n+static void\n lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc)\n {\n   switch (cfi->dw_cfi_opc)\n@@ -699,7 +693,7 @@ lookup_cfa (dw_cfa_location *loc)\n {\n   dw_cfi_ref cfi;\n \n-  loc->reg = (unsigned long) -1;\n+  loc->reg = INVALID_REGNUM;\n   loc->offset = 0;\n   loc->indirect = 0;\n   loc->base_offset = 0;\n@@ -743,6 +737,18 @@ dwarf2out_def_cfa (const char *label, unsigned int reg, HOST_WIDE_INT offset)\n   def_cfa_1 (label, &loc);\n }\n \n+/* Determine if two dw_cfa_location structures define the same data.  */\n+\n+static bool\n+cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n+{\n+  return (loc1->reg == loc2->reg\n+\t  && loc1->offset == loc2->offset\n+\t  && loc1->indirect == loc2->indirect\n+\t  && (loc1->indirect == 0\n+\t      || loc1->base_offset == loc2->base_offset));\n+}\n+\n /* This routine does the actual work.  The CFA is now calculated from\n    the dw_cfa_location structure.  */\n \n@@ -762,9 +768,7 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n   lookup_cfa (&old_cfa);\n \n   /* If nothing changed, no need to issue any call frame instructions.  */\n-  if (loc.reg == old_cfa.reg && loc.offset == old_cfa.offset\n-      && loc.indirect == old_cfa.indirect\n-      && (loc.indirect == 0 || loc.base_offset == old_cfa.base_offset))\n+  if (cfa_equal_p (&loc, &old_cfa))\n     return;\n \n   cfi = new_cfi ();\n@@ -779,7 +783,8 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n     }\n \n #ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n-  else if (loc.offset == old_cfa.offset && old_cfa.reg != (unsigned long) -1\n+  else if (loc.offset == old_cfa.offset\n+\t   && old_cfa.reg != INVALID_REGNUM\n \t   && !loc.indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n@@ -3321,27 +3326,40 @@ build_cfa_loc (dw_cfa_location *cfa)\n {\n   struct dw_loc_descr_struct *head, *tmp;\n \n-  gcc_assert (cfa->indirect);\n-\n-  if (cfa->base_offset)\n+  if (cfa->indirect)\n     {\n-      if (cfa->reg <= 31)\n-\thead = new_loc_descr (DW_OP_breg0 + cfa->reg, cfa->base_offset, 0);\n+      if (cfa->base_offset)\n+\t{\n+\t  if (cfa->reg <= 31)\n+\t    head = new_loc_descr (DW_OP_breg0 + cfa->reg, cfa->base_offset, 0);\n+\t  else\n+\t    head = new_loc_descr (DW_OP_bregx, cfa->reg, cfa->base_offset);\n+\t}\n+      else if (cfa->reg <= 31)\n+\thead = new_loc_descr (DW_OP_reg0 + cfa->reg, 0, 0);\n       else\n-\thead = new_loc_descr (DW_OP_bregx, cfa->reg, cfa->base_offset);\n+\thead = new_loc_descr (DW_OP_regx, cfa->reg, 0);\n+\n+      head->dw_loc_oprnd1.val_class = dw_val_class_const;\n+      tmp = new_loc_descr (DW_OP_deref, 0, 0);\n+      add_loc_descr (&head, tmp);\n+      if (cfa->offset != 0)\n+\t{\n+\t  tmp = new_loc_descr (DW_OP_plus_uconst, cfa->offset, 0);\n+\t  add_loc_descr (&head, tmp);\n+\t}\n     }\n-  else if (cfa->reg <= 31)\n-    head = new_loc_descr (DW_OP_reg0 + cfa->reg, 0, 0);\n   else\n-    head = new_loc_descr (DW_OP_regx, cfa->reg, 0);\n-\n-  head->dw_loc_oprnd1.val_class = dw_val_class_const;\n-  tmp = new_loc_descr (DW_OP_deref, 0, 0);\n-  add_loc_descr (&head, tmp);\n-  if (cfa->offset != 0)\n     {\n-      tmp = new_loc_descr (DW_OP_plus_uconst, cfa->offset, 0);\n-      add_loc_descr (&head, tmp);\n+      if (cfa->offset == 0)\n+\tif (cfa->reg <= 31)\n+\t  head = new_loc_descr (DW_OP_reg0 + cfa->reg, 0, 0);\n+\telse\n+\t  head = new_loc_descr (DW_OP_regx, cfa->reg, 0);\n+      else if (cfa->reg <= 31)\n+\thead = new_loc_descr (DW_OP_breg0 + cfa->reg, cfa->offset, 0);\n+      else\n+\thead = new_loc_descr (DW_OP_bregx, cfa->reg, cfa->offset);\n     }\n \n   return head;\n@@ -3837,6 +3855,10 @@ static GTY(()) int label_num;\n \n #ifdef DWARF2_DEBUGGING_INFO\n \n+/* Offset from the \"steady-state frame pointer\" to the CFA,\n+   within the current function.  */\n+static HOST_WIDE_INT frame_pointer_cfa_offset;\n+\n /* Forward declarations for functions defined in this file.  */\n \n static int is_pseudo_reg (rtx);\n@@ -3979,11 +4001,11 @@ static dw_loc_descr_ref reg_loc_descriptor (rtx);\n static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int);\n static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx);\n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n-static dw_loc_descr_ref based_loc_descr (unsigned, HOST_WIDE_INT, bool);\n+static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT);\n static int is_based_loc (rtx);\n-static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode, bool);\n-static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx, bool);\n-static dw_loc_descr_ref loc_descriptor (rtx, bool);\n+static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode);\n+static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx);\n+static dw_loc_descr_ref loc_descriptor (rtx);\n static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n@@ -8409,8 +8431,18 @@ dbx_reg_number (rtx rtl)\n {\n   unsigned regno = REGNO (rtl);\n \n+  /* We do not want to see registers that should have been eliminated.  */\n+  gcc_assert (HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n+\t      || rtl != arg_pointer_rtx);\n+  gcc_assert (HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n+\t      || rtl != frame_pointer_rtx);\n+\n   gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n+#ifdef LEAF_REG_REMAP\n+  regno = LEAF_REG_REMAP (regno);\n+#endif\n+\n   return DBX_REGISTER_NUMBER (regno);\n }\n \n@@ -8440,20 +8472,17 @@ add_loc_descr_op_piece (dw_loc_descr_ref *list_head, int size)\n static dw_loc_descr_ref\n reg_loc_descriptor (rtx rtl)\n {\n-  unsigned reg;\n   rtx regs;\n \n   if (REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n     return 0;\n \n-  reg = dbx_reg_number (rtl);\n   regs = targetm.dwarf_register_span (rtl);\n \n-  if (hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)] > 1\n-      || regs)\n+  if (hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)] > 1 || regs)\n     return multiple_reg_loc_descriptor (rtl, regs);\n   else\n-    return one_reg_loc_descriptor (reg);\n+    return one_reg_loc_descriptor (dbx_reg_number (rtl));\n }\n \n /* Return a location descriptor that designates a machine register for\n@@ -8557,25 +8586,53 @@ int_loc_descriptor (HOST_WIDE_INT i)\n   return new_loc_descr (op, i, 0);\n }\n \n+/* Return an offset from an eliminable register to the post-prologue\n+   frame pointer.  */\n+\n+static HOST_WIDE_INT\n+eliminate_reg_to_offset (rtx reg)\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n+  reg = eliminate_regs (reg, VOIDmode, NULL_RTX);\n+  if (GET_CODE (reg) == PLUS)\n+    {\n+      offset = INTVAL (XEXP (reg, 1));\n+      reg = XEXP (reg, 0);\n+    }\n+  gcc_assert (reg == (frame_pointer_needed ? hard_frame_pointer_rtx\n+\t\t      : stack_pointer_rtx));\n+\n+  return offset;\n+}\n+\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n-based_loc_descr (unsigned int reg, HOST_WIDE_INT offset, bool can_use_fbreg)\n+based_loc_descr (rtx reg, HOST_WIDE_INT offset)\n {\n   dw_loc_descr_ref loc_result;\n-  /* For the \"frame base\", we use the frame pointer or stack pointer\n-     registers, since the RTL for local variables is relative to one of\n-     them.  */\n-  unsigned fp_reg = DBX_REGISTER_NUMBER (frame_pointer_needed\n-\t\t\t\t\t ? HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t\t : STACK_POINTER_REGNUM);\n-\n-  if (reg == fp_reg && can_use_fbreg)\n-    loc_result = new_loc_descr (DW_OP_fbreg, offset, 0);\n-  else if (reg <= 31)\n-    loc_result = new_loc_descr (DW_OP_breg0 + reg, offset, 0);\n+\n+  /* We only use \"frame base\" when we're sure we're talking about the\n+     post-prologue local stack frame.  We do this by *not* running\n+     register elimination until this point, and recognizing the special\n+     argument pointer and soft frame pointer rtx's.  */\n+  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)\n+    {\n+      offset += eliminate_reg_to_offset (reg);\n+      offset += frame_pointer_cfa_offset;\n+\n+      loc_result = new_loc_descr (DW_OP_fbreg, offset, 0);\n+    }\n   else\n-    loc_result = new_loc_descr (DW_OP_bregx, reg, offset);\n+    {\n+      unsigned int regno = dbx_reg_number (reg);\n+\n+      if (regno <= 31)\n+\tloc_result = new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n+      else\n+\tloc_result = new_loc_descr (DW_OP_bregx, regno, offset);\n+    }\n \n   return loc_result;\n }\n@@ -8604,15 +8661,13 @@ is_based_loc (rtx rtl)\n    MODE is the mode of the memory reference, needed to handle some\n    autoincrement addressing modes.\n \n-   CAN_USE_FBREG is a flag whether we can use DW_AT_frame_base in the location\n-   list for RTL. We can't use it when we are emitting location list for\n-   virtual variable frame_base_decl (i.e. a location list for DW_AT_frame_base)\n-   which describes how frame base changes when !frame_pointer_needed.\n+   CAN_USE_FBREG is a flag whether we can use DW_AT_frame_base in the\n+   location list for RTL.\n \n    Return 0 if we can't represent the location.  */\n \n static dw_loc_descr_ref\n-mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n+mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n   enum dwarf_location_atom op;\n@@ -8659,13 +8714,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n \t memory) so DWARF consumers need to be aware of the subtle\n \t distinction between OP_REG and OP_BASEREG.  */\n       if (REGNO (rtl) < FIRST_PSEUDO_REGISTER)\n-\tmem_loc_result = based_loc_descr (dbx_reg_number (rtl), 0,\n-\t\t\t\t\t  can_use_fbreg);\n+\tmem_loc_result = based_loc_descr (rtl, 0);\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n-\t\t\t\t\t   can_use_fbreg);\n+      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n       if (mem_loc_result != 0)\n \tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n@@ -8731,13 +8784,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n     case PLUS:\n     plus:\n       if (is_based_loc (rtl))\n-\tmem_loc_result = based_loc_descr (dbx_reg_number (XEXP (rtl, 0)),\n-\t\t\t\t\t  INTVAL (XEXP (rtl, 1)),\n-\t\t\t\t\t  can_use_fbreg);\n+\tmem_loc_result = based_loc_descr (XEXP (rtl, 0),\n+\t\t\t\t\t  INTVAL (XEXP (rtl, 1)));\n       else\n \t{\n-\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t\t       can_use_fbreg);\n+\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n \t  if (mem_loc_result == 0)\n \t    break;\n \n@@ -8749,8 +8800,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n \t  else\n \t    {\n \t      add_loc_descr (&mem_loc_result,\n-\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t\t\t can_use_fbreg));\n+\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n \t      add_loc_descr (&mem_loc_result,\n \t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n \t    }\n@@ -8777,10 +8827,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n \n     do_binop:\n       {\n-\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t\t\t   can_use_fbreg);\n-\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t\t\t   can_use_fbreg);\n+\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode);\n \n \tif (op0 == 0 || op1 == 0)\n \t  break;\n@@ -8806,11 +8854,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n    This is typically a complex variable.  */\n \n static dw_loc_descr_ref\n-concat_loc_descriptor (rtx x0, rtx x1, bool can_use_fbreg)\n+concat_loc_descriptor (rtx x0, rtx x1)\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n-  dw_loc_descr_ref x0_ref = loc_descriptor (x0, can_use_fbreg);\n-  dw_loc_descr_ref x1_ref = loc_descriptor (x1, can_use_fbreg);\n+  dw_loc_descr_ref x0_ref = loc_descriptor (x0);\n+  dw_loc_descr_ref x1_ref = loc_descriptor (x1);\n \n   if (x0_ref == 0 || x1_ref == 0)\n     return 0;\n@@ -8824,29 +8872,6 @@ concat_loc_descriptor (rtx x0, rtx x1, bool can_use_fbreg)\n   return cc_loc_result;\n }\n \n-/* Return true if DECL's containing function has a frame base attribute.\n-   Return false otherwise.  */\n-\n-static bool\n-containing_function_has_frame_base (tree decl)\n-{\n-  tree declcontext = decl_function_context (decl);\n-  dw_die_ref context;\n-  dw_attr_ref attr;\n-  \n-  if (!declcontext)\n-    return false;\n-\n-  context = lookup_decl_die (declcontext);\n-  if (!context)\n-    return false;\n-\n-  for (attr = context->die_attr; attr; attr = attr->dw_attr_next)\n-    if (attr->dw_attr == DW_AT_frame_base)\n-      return true;\n-  return false;\n-}\n-\n /* Output a proper Dwarf location descriptor for a variable or parameter\n    which is either allocated in a register or in a memory location.  For a\n    register, we just generate an OP_REG and the register number.  For a\n@@ -8856,7 +8881,7 @@ containing_function_has_frame_base (tree decl)\n    If we don't know how to describe it, return 0.  */\n \n static dw_loc_descr_ref\n-loc_descriptor (rtx rtl, bool can_use_fbreg)\n+loc_descriptor (rtx rtl)\n {\n   dw_loc_descr_ref loc_result = NULL;\n \n@@ -8877,20 +8902,18 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n       break;\n \n     case MEM:\n-      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n-\t\t\t\t       can_use_fbreg);\n+      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n       break;\n \n     case CONCAT:\n-      loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1),\n-\t\t\t\t\t  can_use_fbreg);\n+      loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1));\n       break;\n \n     case VAR_LOCATION:\n       /* Single part.  */\n       if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n \t{\n-\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), can_use_fbreg);\n+\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0));\n \t  break;\n \t}\n \n@@ -8905,16 +8928,14 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n \tint i;\n \n \t/* Create the first one, so we have something to add to.  */\n-\tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n-\t\t\t\t     can_use_fbreg);\n+\tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0));\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n \tadd_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n \tfor (i = 1; i < num_elem; i++)\n \t  {\n \t    dw_loc_descr_ref temp;\n \n-\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n-\t\t\t\t   can_use_fbreg);\n+\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0));\n \t    add_loc_descr (&loc_result, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n \t    add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n@@ -9043,19 +9064,18 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \telse\n \t  {\n \t    enum machine_mode mode;\n-\t    bool can_use_fb = containing_function_has_frame_base (loc);\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n-\t      return loc_descriptor (rtl, can_use_fb);\n+\t      return loc_descriptor (rtl);\n \n \t    mode = GET_MODE (rtl);\n \t    if (MEM_P (rtl))\n \t      {\n \t\trtl = XEXP (rtl, 0);\n \t\thave_address = 1;\n \t      }\n-\t    ret = mem_loc_descriptor (rtl, mode, can_use_fb);\n+\t    ret = mem_loc_descriptor (rtl, mode);\n \t  }\n       }\n       break;\n@@ -9129,14 +9149,12 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t/* Get an RTL for this, if something has been emitted.  */\n \trtx rtl = lookup_constant_def (loc);\n \tenum machine_mode mode;\n-\tbool can_use_fb;\n \n \tif (!rtl || !MEM_P (rtl))\n \t  return 0;\n-\tcan_use_fb = containing_function_has_frame_base (loc);\n \tmode = GET_MODE (rtl);\n \trtl = XEXP (rtl, 0);\n-\tret = mem_loc_descriptor (rtl, mode, can_use_fb);\n+\tret = mem_loc_descriptor (rtl, mode);\n \thave_address = 1;\n \tbreak;\n       }\n@@ -10073,19 +10091,10 @@ rtl_for_decl_location (tree decl)\n \t\t\t   plus_constant (XEXP (rtl, 0), rsize-dsize));\n     }\n \n-  if (rtl != NULL_RTX)\n-    {\n-      rtl = eliminate_regs (rtl, 0, NULL_RTX);\n-#ifdef LEAF_REG_REMAP\n-      if (current_function_uses_only_leaf_regs)\n-\tleaf_renumber_regs_insn (rtl);\n-#endif\n-    }\n-\n   /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,\n      and will have been substituted directly into all expressions that use it.\n      C does not have such a concept, but C++ and other languages do.  */\n-  else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n+  if (!rtl && TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n     rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));\n \n   if (rtl)\n@@ -10100,6 +10109,40 @@ rtl_for_decl_location (tree decl)\n   return rtl;\n }\n \n+/* We need to figure out what section we should use as the base for the\n+   address ranges where a given location is valid.\n+   1. If this particular DECL has a section associated with it, use that.\n+   2. If this function has a section associated with it, use that.\n+   3. Otherwise, use the text section.\n+   XXX: If you split a variable across multiple sections, we won't notice.  */\n+\n+static const char *\n+secname_for_decl (tree decl)\n+{\n+  const char *secname;\n+\n+  if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_SECTION_NAME (decl))\n+    {\n+      tree sectree = DECL_SECTION_NAME (decl);\n+      secname = TREE_STRING_POINTER (sectree);\n+    }\n+  else if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n+    {\n+      tree sectree = DECL_SECTION_NAME (current_function_decl);\n+      secname = TREE_STRING_POINTER (sectree);\n+    }\n+  else if (cfun\n+\t   && (last_text_section == in_unlikely_executed_text\n+\t       || (last_text_section == in_named\n+\t\t   && last_text_section_name\n+\t\t      == cfun->unlikely_text_section_name)))\n+    secname = cfun->cold_section_label;\n+  else\n+    secname = text_section_label;\n+\n+  return secname;\n+}\n+\n /* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value\n    data attribute for a variable or a parameter.  We generate the\n    DW_AT_const_value attribute only in those cases where the given variable\n@@ -10118,58 +10161,24 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   rtx rtl;\n   dw_loc_descr_ref descr;\n   var_loc_list *loc_list;\n-  bool can_use_fb;\n   struct var_loc_node *node;\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n \t     \n-  can_use_fb = containing_function_has_frame_base (decl);\n-\n   /* See if we possibly have multiple locations for this variable.  */\n   loc_list = lookup_decl_loc (decl);\n \n   /* If it truly has multiple locations, the first and last node will\n      differ.  */\n   if (loc_list && loc_list->first != loc_list->last)\n     {\n-      const char *secname;\n-      const char *endname;\n+      const char *endname, *secname;\n       dw_loc_list_ref list;\n       rtx varloc;\n \n-      /* We need to figure out what section we should use as the base\n-\t for the address ranges where a given location is valid.\n-\t 1. If this particular DECL has a section associated with it,\n-\t use that.\n-\t 2. If this function has a section associated with it, use\n-\t that.\n-\t 3. Otherwise, use the text section.\n-\t XXX: If you split a variable across multiple sections, this\n-\t won't notice.  */\n-\n-      if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_SECTION_NAME (decl))\n-\t{\n-\t  tree sectree = DECL_SECTION_NAME (decl);\n-\t  secname = TREE_STRING_POINTER (sectree);\n-\t}\n-      else if (current_function_decl\n-\t       && DECL_SECTION_NAME (current_function_decl))\n-\t{\n-\t  tree sectree = DECL_SECTION_NAME (current_function_decl);\n-\t  secname = TREE_STRING_POINTER (sectree);\n-\t}\n-      else if (cfun\n-\t       && (last_text_section == in_unlikely_executed_text\n-\t\t   || (last_text_section == in_named\n-\t\t       && last_text_section_name == \n-\t\t       cfun->unlikely_text_section_name)))\n-\tsecname = cfun->cold_section_label;\n-      else\n-\tsecname = text_section_label;\n-\n       /* Now that we know what section we are using for a base,\n          actually construct the list of locations.\n \t The first location information is what is passed to the\n@@ -10183,7 +10192,9 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n       node = loc_list->first;\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-      list = new_loc_list (loc_descriptor (varloc, can_use_fb),\n+      secname = secname_for_decl (decl);\n+\n+      list = new_loc_list (loc_descriptor (varloc),\n \t\t\t   node->label, node->next->label, secname, 1);\n       node = node->next;\n \n@@ -10193,9 +10204,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t    /* The variable has a location between NODE->LABEL and\n \t       NODE->NEXT->LABEL.  */\n \t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\t    add_loc_descr_to_loc_list (&list,\n-\t\t\t\t       loc_descriptor (varloc,\n-\t\t\t\t\t\t       can_use_fb),\n+\t    add_loc_descr_to_loc_list (&list, loc_descriptor (varloc),\n \t\t\t\t       node->label, node->next->label, secname);\n \t  }\n \n@@ -10214,9 +10223,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t\t\t\t\t   current_function_funcdef_no);\n \t      endname = ggc_strdup (label_id);\n \t    }\n-\t  add_loc_descr_to_loc_list (&list,\n-\t\t\t\t     loc_descriptor (varloc,\n-\t\t\t\t\t\t     can_use_fb),\n+\t  add_loc_descr_to_loc_list (&list, loc_descriptor (varloc),\n \t\t\t\t     node->label, endname, secname);\n \t}\n \n@@ -10241,8 +10248,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   if (loc_list && loc_list->first)\n     {\n       node = loc_list->first;\n-      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note), \n-\t\t\t      can_use_fb);\n+      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note));\n       if (descr)\n \t{\n \t  add_AT_location_description (die, attr, descr);\n@@ -10281,6 +10287,98 @@ tree_add_const_value_attribute (dw_die_ref var_die, tree decl)\n     add_const_value_attribute (var_die, rtl);\n }\n \n+/* Convert the CFI instructions for the current function into a location\n+   list.  This is used for DW_AT_frame_base when we targeting a dwarf2\n+   consumer that does not support the dwarf3 DW_OP_call_frame_cfa.  */\n+\n+static dw_loc_list_ref\n+convert_cfa_to_loc_list (void)\n+{\n+  dw_fde_ref fde;\n+  dw_loc_list_ref list, *list_tail;\n+  dw_cfi_ref cfi;\n+  dw_cfa_location last_cfa, next_cfa;\n+  const char *start_label, *last_label, *section;\n+\n+  fde = &fde_table[fde_table_in_use - 1];\n+\n+  section = secname_for_decl (current_function_decl);\n+  list_tail = &list;\n+  list = NULL;\n+\n+  next_cfa.reg = INVALID_REGNUM;\n+  next_cfa.offset = 0;\n+  next_cfa.indirect = 0;\n+  next_cfa.base_offset = 0;\n+\n+  start_label = fde->dw_fde_begin;\n+\n+  /* ??? Bald assumption that the CIE opcode list does not contain\n+     advance opcodes.  */\n+  for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n+    lookup_cfa_1 (cfi, &next_cfa);\n+\n+  last_cfa = next_cfa;\n+  last_label = start_label;\n+\n+  for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n+    switch (cfi->dw_cfi_opc)\n+      {\n+      case DW_CFA_advance_loc1:\n+      case DW_CFA_advance_loc2:\n+      case DW_CFA_advance_loc4:\n+\tif (!cfa_equal_p (&last_cfa, &next_cfa))\n+\t  {\n+\t    *list_tail = new_loc_list (build_cfa_loc (&last_cfa), start_label,\n+\t\t\t\t       last_label, section, list == NULL);\n+\n+\t    list_tail = &(*list_tail)->dw_loc_next;\n+\t    last_cfa = next_cfa;\n+\t    start_label = last_label;\n+\t  }\n+\tlast_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\tbreak;\n+\n+      case DW_CFA_advance_loc:\n+\t/* The encoding is complex enough that we should never emit this.  */\n+      case DW_CFA_remember_state:\n+      case DW_CFA_restore_state:\n+\t/* We don't handle these two in this function.  It would be possible\n+\t   if it were to be required.  */\n+\tgcc_unreachable ();\n+\n+      default:\n+\tlookup_cfa_1 (cfi, &next_cfa);\n+\tbreak;\n+      }\n+\n+  if (!cfa_equal_p (&last_cfa, &next_cfa))\n+    {\n+      *list_tail = new_loc_list (build_cfa_loc (&last_cfa), start_label,\n+\t\t\t\t last_label, section, list == NULL);\n+      list_tail = &(*list_tail)->dw_loc_next;\n+      start_label = last_label;\n+    }\n+  *list_tail = new_loc_list (build_cfa_loc (&next_cfa), start_label,\n+\t\t\t     fde->dw_fde_end, section, list == NULL);\n+\n+  return list;\n+}\n+\n+/* Compute a displacement from the \"steady-state frame pointer\" to\n+   the CFA, and store it in frame_pointer_cfa_offset.  */\n+\n+static void\n+compute_frame_pointer_to_cfa_displacement (void)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  offset = eliminate_reg_to_offset (arg_pointer_rtx);\n+  offset += ARG_POINTER_CFA_OFFSET (current_function_decl);\n+\n+  frame_pointer_cfa_offset = -offset;\n+}\n+\n /* Generate a DW_AT_name attribute given some string value to be included as\n    the value of the attribute.  */\n \n@@ -11325,7 +11423,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n   tree origin = decl_ultimate_origin (decl);\n   dw_die_ref subr_die;\n-  rtx fp_reg;\n   tree fn_arg_types;\n   tree outer_scope;\n   dw_die_ref old_die = lookup_decl_die (decl);\n@@ -11506,20 +11603,32 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);\n #endif\n \n-      /* Define the \"frame base\" location for this routine.  We use the\n-\t frame pointer or stack pointer registers, since the RTL for local\n-\t variables is relative to one of them.  */\n-      if (frame_base_decl && lookup_decl_loc (frame_base_decl) != NULL)\n-\t{\n-\t  add_location_or_const_value_attribute (subr_die, frame_base_decl,\n-\t\t\t\t\t\t DW_AT_frame_base);\n-\t}\n-      else\n-\t{\n-\t  fp_reg\n-\t    = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n-\t  add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n-\t}\n+      /* We define the \"frame base\" as the function's CFA.  This is more\n+\t convenient for several reasons: (1) It's stable across the prologue\n+\t and epilogue, which makes it better than just a frame pointer,\n+\t (2) With dwarf3, there exists a one-byte encoding that allows us\n+\t to reference the .debug_frame data by proxy, but failing that,\n+\t (3) We can at least reuse the code inspection and interpretation\n+\t code that determines the CFA position at various points in the\n+\t function.  */\n+      /* ??? Use some command-line or configury switch to enable the use\n+\t of dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf\n+\t consumers that understand it; fall back to \"pure\" dwarf2 and\n+\t convert the CFA data into a location list.  */\n+      {\n+\tdw_loc_list_ref list = convert_cfa_to_loc_list ();\n+\tif (list->dw_loc_next)\n+\t  add_AT_loc_list (subr_die, DW_AT_frame_base, list);\n+\telse\n+\t  add_AT_loc (subr_die, DW_AT_frame_base, list->expr);\n+      }\n+\n+      /* Compute a displacement from the \"steady-state frame pointer\" to\n+\t the CFA.  The former is what all stack slots and argument slots\n+\t will reference in the rtl; the later is what we've told the \n+\t debugger about.  We'll need to adjust all frame_base references\n+\t by this displacement.  */\n+      compute_frame_pointer_to_cfa_displacement ();\n \n       if (cfun->static_chain_decl)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,"}, {"sha": "014b38cf61324583ab67af0483f8228ad9bd57b5", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -1211,12 +1211,6 @@ static int cfa_offset;\n #endif\n #endif\n \n-/* On most machines, the CFA coincides with the first incoming parm.  */\n-\n-#ifndef ARG_POINTER_CFA_OFFSET\n-#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n-#endif\n-\n \f\n /* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX\n    is a virtual register, return the equivalent hard register and set the"}, {"sha": "fb3a6458d6bd6d8a09220639b6877ff149b9c665", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -3036,7 +3036,6 @@ enum ptrmemfunc_vbit_where_t\n \f\n #define NULL_TREE (tree) NULL\n \n-extern GTY(()) tree frame_base_decl;\n extern tree decl_assembler_name (tree);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only"}, {"sha": "ba034f34b475e457ed217f1396c7d24bd419fdde", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 16, "deletions": 127, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e6f306d3ac23bcf9b1dec1cff32f6009aca913/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=30e6f306d3ac23bcf9b1dec1cff32f6009aca913", "patch": "@@ -268,19 +268,12 @@ static htab_t changed_variables;\n /* Shall notes be emitted?  */\n static bool emit_notes;\n \n-/* Fake variable for stack pointer.  */\n-tree frame_base_decl;\n-\n-/* Stack adjust caused by function prologue.  */\n-static HOST_WIDE_INT frame_stack_adjust;\n-\n /* Local function prototypes.  */\n static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t  HOST_WIDE_INT *);\n static void insn_stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t       HOST_WIDE_INT *);\n static void bb_stack_adjust_offset (basic_block);\n-static HOST_WIDE_INT prologue_stack_adjust (void);\n static bool vt_stack_adjustments (void);\n static rtx adjust_stack_reference (rtx, HOST_WIDE_INT);\n static hashval_t variable_htab_hash (const void *);\n@@ -335,7 +328,6 @@ static void dump_dataflow_set (dataflow_set *);\n static void dump_dataflow_sets (void);\n \n static void variable_was_changed (variable, htab_t);\n-static void set_frame_base_location (dataflow_set *, rtx);\n static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n static void delete_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n static int emit_note_insn_var_location (void **, void *);\n@@ -491,38 +483,6 @@ bb_stack_adjust_offset (basic_block bb)\n   VTI (bb)->out.stack_adjust = offset;\n }\n \n-/* Compute stack adjustment caused by function prologue.  */\n-\n-static HOST_WIDE_INT\n-prologue_stack_adjust (void)\n-{\n-  HOST_WIDE_INT offset = 0;\n-  basic_block bb = ENTRY_BLOCK_PTR->next_bb;\n-  rtx insn;\n-  rtx end;\n-\n-  if (!BB_END (bb))\n-    return 0;\n-\n-  end = NEXT_INSN (BB_END (bb));\n-  for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n-    {\n-      if (NOTE_P (insn)\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n-\tbreak;\n-\n-      if (INSN_P (insn))\n-\t{\n-\t  HOST_WIDE_INT tmp;\n-\n-\t  insn_stack_adjust_offset_pre_post (insn, &tmp, &tmp);\n-\t  offset += tmp;\n-\t}\n-    }\n-\n-  return offset;\n-}\n-\n /* Compute stack adjustments for all blocks by traversing DFS tree.\n    Return true when the adjustments on all incoming edges are consistent.\n    Heavily borrowed from flow_depth_first_order_compute.  */\n@@ -535,7 +495,7 @@ vt_stack_adjustments (void)\n \n   /* Initialize entry block.  */\n   VTI (ENTRY_BLOCK_PTR)->visited = true;\n-  VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = frame_stack_adjust;\n+  VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n@@ -589,27 +549,23 @@ vt_stack_adjustments (void)\n   return true;\n }\n \n-/* Adjust stack reference MEM by ADJUSTMENT bytes and return the new rtx.  */\n+/* Adjust stack reference MEM by ADJUSTMENT bytes and make it relative\n+   to the argument pointer.  Return the new rtx.  */\n \n static rtx\n adjust_stack_reference (rtx mem, HOST_WIDE_INT adjustment)\n {\n-  rtx adjusted_mem;\n-  rtx tmp;\n+  rtx addr, cfa, tmp;\n \n-  if (adjustment == 0)\n-    return mem;\n+  adjustment -= ARG_POINTER_CFA_OFFSET (current_function_decl);\n+  cfa = plus_constant (arg_pointer_rtx, adjustment);\n \n-  adjusted_mem = copy_rtx (mem);\n-  XEXP (adjusted_mem, 0) = replace_rtx (XEXP (adjusted_mem, 0),\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tgen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t      GEN_INT (adjustment)));\n-  tmp = simplify_rtx (XEXP (adjusted_mem, 0));\n+  addr = replace_rtx (copy_rtx (XEXP (mem, 0)), stack_pointer_rtx, cfa);\n+  tmp = simplify_rtx (addr);\n   if (tmp)\n-    XEXP (adjusted_mem, 0) = tmp;\n+    addr = tmp;\n \n-  return adjusted_mem;\n+  return replace_equiv_address_nv (mem, addr);\n }\n \n /* The hash function for variable_htab, computes the hash value\n@@ -1652,14 +1608,7 @@ compute_bb_dataflow (basic_block bb)\n \t    break;\n \n \t  case MO_ADJUST:\n-\t    {\n-\t      rtx base;\n-\n-\t      out->stack_adjust += VTI (bb)->mos[i].u.adjust;\n-\t      base = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\tout->stack_adjust));\n-\t      set_frame_base_location (out, base);\n-\t    }\n+\t    out->stack_adjust += VTI (bb)->mos[i].u.adjust;\n \t    break;\n \t}\n     }\n@@ -1782,8 +1731,7 @@ dump_attrs_list (attrs list)\n   for (; list; list = list->next)\n     {\n       print_mem_expr (dump_file, list->decl);\n-      fprintf (dump_file, \"+\");\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC, list->offset);\n+      fprintf (dump_file, \"+\" HOST_WIDE_INT_PRINT_DEC, list->offset);\n     }\n   fprintf (dump_file, \"\\n\");\n }\n@@ -1833,9 +1781,8 @@ dump_dataflow_set (dataflow_set *set)\n {\n   int i;\n \n-  fprintf (dump_file, \"Stack adjustment: \");\n-  fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC, set->stack_adjust);\n-  fprintf (dump_file, \"\\n\");\n+  fprintf (dump_file, \"Stack adjustment: \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t   set->stack_adjust);\n   for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (set->regs[i])\n@@ -1914,31 +1861,6 @@ variable_was_changed (variable var, htab_t htab)\n     }\n }\n \n-/* Set the location of frame_base_decl to LOC in dataflow set SET.  This\n-   function expects that frame_base_decl has already one location for offset 0\n-   in the variable table.  */\n-\n-static void\n-set_frame_base_location (dataflow_set *set, rtx loc)\n-{\n-  variable var;\n-  \n-  var = htab_find_with_hash (set->vars, frame_base_decl,\n-\t\t\t     VARIABLE_HASH_VAL (frame_base_decl));\n-  gcc_assert (var);\n-  gcc_assert (var->n_var_parts == 1);\n-  gcc_assert (!var->var_part[0].offset);\n-  gcc_assert (var->var_part[0].loc_chain);\n-\n-  /* If frame_base_decl is shared unshare it first.  */\n-  if (var->refcount > 1)\n-    var = unshare_variable (set, var);\n-\n-  var->var_part[0].loc_chain->loc = loc;\n-  var->var_part[0].cur_loc = loc;\n-  variable_was_changed (var, set->vars);\n-}\n-\n /* Set the part of variable's location in the dataflow set SET.  The variable\n    part is specified by variable's declaration DECL and offset OFFSET and the\n    part's location by LOC.  */\n@@ -2463,15 +2385,7 @@ emit_notes_in_bb (basic_block bb)\n \t    break;\n \n \t  case MO_ADJUST:\n-\t    {\n-\t      rtx base;\n-\n-\t      set.stack_adjust += VTI (bb)->mos[i].u.adjust;\n-\t      base = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\tset.stack_adjust));\n-\t      set_frame_base_location (&set, base);\n-\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n-\t    }\n+\t    set.stack_adjust += VTI (bb)->mos[i].u.adjust;\n \t    break;\n \t}\n     }\n@@ -2575,7 +2489,6 @@ vt_add_function_parameters (void)\n \n       gcc_assert (parm == decl);\n \n-      incoming = eliminate_regs (incoming, 0, NULL_RTX);\n       out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n       if (REG_P (incoming))\n@@ -2586,9 +2499,7 @@ vt_add_function_parameters (void)\n \t  set_variable_part (out, incoming, parm, offset);\n \t}\n       else if (MEM_P (incoming))\n-\t{\n-\t  set_variable_part (out, incoming, parm, offset);\n-\t}\n+\tset_variable_part (out, incoming, parm, offset);\n     }\n }\n \n@@ -2733,28 +2644,6 @@ vt_initialize (void)\n   changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n \t\t\t\t   NULL);\n   vt_add_function_parameters ();\n-\n-  if (!frame_pointer_needed)\n-    {\n-      rtx base;\n-\n-      /* Create fake variable for tracking stack pointer changes.  */\n-      frame_base_decl = make_node (VAR_DECL);\n-      DECL_NAME (frame_base_decl) = get_identifier (\"___frame_base_decl\");\n-      TREE_TYPE (frame_base_decl) = char_type_node;\n-      DECL_ARTIFICIAL (frame_base_decl) = 1;\n-      DECL_IGNORED_P (frame_base_decl) = 1;\n-\n-      /* Set its initial \"location\".  */\n-      frame_stack_adjust = -prologue_stack_adjust ();\n-      base = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\tframe_stack_adjust));\n-      set_variable_part (&VTI (ENTRY_BLOCK_PTR)->out, base, frame_base_decl, 0);\n-    }\n-  else\n-    {\n-      frame_base_decl = NULL;\n-    }\n }\n \n /* Free the data structures needed for variable tracking.  */"}]}