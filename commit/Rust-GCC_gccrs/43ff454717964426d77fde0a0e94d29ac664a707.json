{"sha": "43ff454717964426d77fde0a0e94d29ac664a707", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmZjQ1NDcxNzk2NDQyNmQ3N2ZkZTBhMGU5NGQyOWFjNjY0YTcwNw==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gnat.com", "date": "2002-03-08T22:49:35Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2002-03-08T22:49:35Z"}, "message": "adadecode.c, [...]: New files.\n\n\t* adadecode.c, adadecode.h, aux-io.c, s-traces.adb, s-traces.ads,\n\ts-tratas.adb, s-tratas.ads, sinput-d.adb, sinput-d.ads,\n\tswitch-b.adb, switch-b.ads, switch-c.adb, switch-c.ads,\n\tswitch-m.adb, switch-m.ads : New files.\n\nFrom-SVN: r50466", "tree": {"sha": "e1966bb24cb5ddb58313cbf62e39a664a3776d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1966bb24cb5ddb58313cbf62e39a664a3776d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ff454717964426d77fde0a0e94d29ac664a707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ff454717964426d77fde0a0e94d29ac664a707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ff454717964426d77fde0a0e94d29ac664a707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ff454717964426d77fde0a0e94d29ac664a707/comments", "author": null, "committer": null, "parents": [{"sha": "4ec59de224960b41e45d957802bc30f46c78418c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec59de224960b41e45d957802bc30f46c78418c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ec59de224960b41e45d957802bc30f46c78418c"}], "stats": {"total": 3115, "additions": 3115, "deletions": 0}, "files": [{"sha": "1e7825ad3a0c61c692ccbd794bed5497b26a8850", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -1,3 +1,10 @@\n+2002-03-07  Geert Bosch  <bosch@gnat.com>\n+\n+\t* adadecode.c, adadecode.h, aux-io.c, s-traces.adb, s-traces.ads, \n+\ts-tratas.adb, s-tratas.ads, sinput-d.adb, sinput-d.ads, \n+\tswitch-b.adb, switch-b.ads, switch-c.adb, switch-c.ads, \n+\tswitch-m.adb, switch-m.ads : New files.\n+\n 2002-03-07  Geert Bosch  <bosch@gnat.com>\n \n \t* 41intnam.ads, 42intnam.ads, 4aintnam.ads, 4cintnam.ads,"}, {"sha": "cafd1c35b09c23d5f6405ededbd6b0fd4570a24d", "filename": "gcc/ada/adadecode.c", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fadadecode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fadadecode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.c?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,325 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             G N A T D E C O                              *\n+ *                                                                          *\n+ *                            $Revision$\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *           Copyright (C) 2001-2002, Free Software Foundation, Inc.        *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#ifdef IN_GCC\n+#include \"config.h\"\n+#include \"system.h\"\n+#else\n+#include <stdio.h>\n+#define PARMS(ARGS) ARGS\n+#endif\n+\n+#include \"ctype.h\"\n+#include \"adadecode.h\"\n+\n+static void add_verbose\tPARAMS ((const char *, char *));\n+static int has_prefix\tPARAMS ((char *, const char *));\n+static int has_suffix\tPARAMS ((char *, const char *));\n+\n+/* Set to nonzero if we have written any verbose info.  */\n+static int verbose_info;\n+\n+/* Add TEXT to end of ADA_NAME, putting a leading \" (\" or \", \", depending\n+   on VERBOSE_INFO.  */\n+\n+static void add_verbose (text, ada_name)\n+     const char *text;\n+     char *ada_name;\n+{\n+  strcat (ada_name, verbose_info ? \", \" : \" (\");\n+  strcat (ada_name, text);\n+\n+  verbose_info = 1;\n+}\n+\n+/* Returns 1 if NAME starts with PREFIX.  */\n+\n+static int\n+has_prefix (name, prefix)\n+     char *name;\n+     const char *prefix;\n+{\n+  return strncmp (name, prefix, strlen (prefix)) == 0;\n+}\n+\n+/* Returns 1 if NAME ends with SUFFIX.  */\n+\n+static int\n+has_suffix (name, suffix)\n+     char *name;\n+     const char *suffix;\n+{\n+  int nlen = strlen (name);\n+  int slen = strlen (suffix);\n+\n+  return nlen > slen && strncmp (name + nlen - slen, suffix, slen) == 0;\n+}\n+\n+/* This function will return the Ada name from the encoded form.\n+   The Ada coding is done in exp_dbug.ads and this is the inverse function.\n+   see exp_dbug.ads for full encoding rules, a short description is added\n+   below. Right now only objects and routines are handled. There is no support\n+   for Ada types.\n+\n+   CODED_NAME is the encoded entity name.\n+\n+   ADA_NAME is a pointer to a buffer, it will receive the Ada name. A safe\n+   size for this buffer is: strlen (coded_name) * 2 + 60. (60 is for the\n+   verbose information).\n+\n+   VERBOSE is nonzero if more information about the entity is to be\n+   added at the end of the Ada name and surrounded by ( and ).\n+\n+     Coded name           Ada name                verbose info\n+  ---------------------------------------------------------------------\n+  _ada_xyz                xyz                     library level\n+  x__y__z                 x.y.z\n+  x__yTKB                 x.y                     task body\n+  x__yB                   x.y                     task body\n+  x__yX                   x.y                     body nested\n+  x__yXb                  x.y                     body nested\n+  xTK__y                  x.y                     in task\n+  x__y$2                  x.y                     overloaded\n+  x__y__3                 x.y                     overloaded\n+  x__Oabs                 \"abs\"\n+  x__Oand                 \"and\"\n+  x__Omod                 \"mod\"\n+  x__Onot                 \"not\"\n+  x__Oor                  \"or\"\n+  x__Orem                 \"rem\"\n+  x__Oxor                 \"xor\"\n+  x__Oeq                  \"=\"\n+  x__One                  \"/=\"\n+  x__Olt                  \"<\"\n+  x__Ole                  \"<=\"\n+  x__Ogt                  \">\"\n+  x__Oge                  \">=\"\n+  x__Oadd                 \"+\"\n+  x__Osubtract            \"-\"\n+  x__Oconcat              \"&\"\n+  x__Omultiply            \"*\"\n+  x__Odivide              \"/\"\n+  x__Oexpon               \"**\"     */\n+\n+void\n+__gnat_decode (coded_name, ada_name, verbose)\n+     const char *coded_name;\n+     char *ada_name;\n+     int verbose;\n+{\n+  int lib_subprog = 0;\n+  int overloaded = 0;\n+  int task_body = 0;\n+  int in_task = 0;\n+  int body_nested = 0;\n+\n+  /* Copy the coded name into the ada name string, the rest of the code will\n+     just replace or add characters into the ada_name.  */\n+  strcpy (ada_name, coded_name);\n+\n+  /* Check for library level subprogram.  */\n+  if (has_prefix (ada_name, \"_ada_\"))\n+    {\n+      strcpy (ada_name, ada_name + 5);\n+      lib_subprog = 1;\n+    }\n+\n+  /* Check for task body.  */\n+  if (has_suffix (ada_name, \"TKB\"))\n+    {\n+      ada_name[strlen (ada_name) - 3] = '\\0';\n+      task_body = 1;\n+    }\n+\n+  if (has_suffix (ada_name, \"B\"))\n+    {\n+      ada_name[strlen (ada_name) - 1] = '\\0';\n+      task_body = 1;\n+    }\n+\n+  /* Check for body-nested entity: X[bn] */\n+  if (has_suffix (ada_name, \"X\"))\n+    {\n+      ada_name[strlen (ada_name) - 1] = '\\0';\n+      body_nested = 1;\n+    }\n+\n+  if (has_suffix (ada_name, \"Xb\"))\n+    {\n+      ada_name[strlen (ada_name) - 2] = '\\0';\n+      body_nested = 1;\n+    }\n+\n+  if (has_suffix (ada_name, \"Xn\"))\n+    {\n+      ada_name[strlen (ada_name) - 2] = '\\0';\n+      body_nested = 1;\n+    }\n+\n+  /* Change instance of TK__ (object declared inside a task) to __.  */\n+  {\n+    char *tktoken;\n+\n+    while ((tktoken = (char *) strstr (ada_name, \"TK__\")) != NULL)\n+      {\n+\tstrcpy (tktoken, tktoken + 2);\n+\tin_task = 1;\n+      }\n+  }\n+\n+  /* Check for overloading: name terminated by $nn or __nn.  */\n+  {\n+    int len = strlen (ada_name);\n+    int n_digits = 0;\n+\n+    if (len > 1)\n+      while (isdigit ((int) ada_name[(int) len - 1 - n_digits]))\n+\tn_digits++;\n+\n+    /* Check if we have $ or __ before digits.  */\n+    if (ada_name[len - 1 - n_digits] == '$')\n+      {\n+\tada_name[len - 1 - n_digits] = '\\0';\n+\toverloaded = 1;\n+      }\n+    else if (ada_name[len - 1 - n_digits] == '_'\n+\t     && ada_name[len - 1 - n_digits - 1] == '_')\n+      {\n+\tada_name[len - 1 - n_digits - 1] = '\\0';\n+\toverloaded = 1;\n+      }\n+  }\n+\n+  /* Change all \"__\" to \".\". */\n+  {\n+    int len = strlen (ada_name);\n+    int k = 0;\n+\n+    while (k < len)\n+      {\n+\tif (ada_name[k] == '_' && ada_name[k+1] == '_')\n+\t  {\n+\t    ada_name[k] = '.';\n+\t    strcpy (ada_name + k + 1, ada_name + k + 2);\n+\t    len = len - 1;\n+\t  }\n+\tk++;\n+      }\n+  }\n+\n+  /* Checks for operator name.  */\n+  {\n+    const char *trans_table[][2]\n+      = {{\"Oabs\", \"\\\"abs\\\"\"},  {\"Oand\", \"\\\"and\\\"\"},    {\"Omod\", \"\\\"mod\\\"\"},\n+\t {\"Onot\", \"\\\"not\\\"\"},  {\"Oor\", \"\\\"or\\\"\"},      {\"Orem\", \"\\\"rem\\\"\"},\n+\t {\"Oxor\", \"\\\"xor\\\"\"},  {\"Oeq\", \"\\\"=\\\"\"},       {\"One\", \"\\\"/=\\\"\"},\n+\t {\"Olt\", \"\\\"<\\\"\"},     {\"Ole\", \"\\\"<=\\\"\"},      {\"Ogt\", \"\\\">\\\"\"},\n+\t {\"Oge\", \"\\\">=\\\"\"},    {\"Oadd\", \"\\\"+\\\"\"},      {\"Osubtract\", \"\\\"-\\\"\"},\n+\t {\"Oconcat\", \"\\\"&\\\"\"}, {\"Omultiply\", \"\\\"*\\\"\"}, {\"Odivide\", \"\\\"/\\\"\"},\n+\t {\"Oexpon\", \"\\\"**\\\"\"}, {NULL, NULL} };\n+    int k = 0;\n+\n+    while (1)\n+      {\n+\tchar *optoken;\n+\n+\tif ((optoken = (char *) strstr (ada_name, trans_table[k][0])) != NULL)\n+\t  {\n+\t    int codedlen = strlen (trans_table[k][0]);\n+\t    int oplen = strlen (trans_table[k][1]);\n+\n+\t    if (codedlen > oplen)\n+\t      /* We shrink the space.  */\n+\t      strcpy (optoken, optoken + codedlen - oplen);\n+\t    else if (oplen > codedlen)\n+\t      {\n+\t\t/* We need more space.  */\n+\t\tint len = strlen (ada_name);\n+\t\tint space = oplen - codedlen;\n+\t\tint num_to_move = &ada_name[len] - optoken;\n+\t\tint t;\n+\n+\t\tfor (t = 0; t < num_to_move; t++)\n+\t\t  ada_name[len + space - t - 1] = ada_name[len - t - 1];\n+\t      }\n+\n+\t    /* Write symbol in the space.  */\n+\t    strncpy (optoken, trans_table[k][1], oplen);\n+\t  }\n+\telse\n+\t  k++;\n+\n+\t/* Check for table's ending.  */\n+\tif (trans_table[k][0] == NULL)\n+\t  break;\n+      }\n+  }\n+\n+  /* If verbose mode is on, we add some information to the Ada name.  */\n+  if (verbose) \n+    {\n+      if (overloaded)\n+\tadd_verbose (\"overloaded\", ada_name);\n+\n+      if (lib_subprog)\n+\tadd_verbose (\"library level\", ada_name);\n+\n+      if (body_nested)\n+\tadd_verbose (\"body nested\", ada_name);\n+\n+      if (in_task)\n+\tadd_verbose (\"in task\", ada_name);\n+\n+      if (task_body)\n+\tadd_verbose (\"task body\", ada_name);\n+\n+      if (verbose_info == 1)\n+\tstrcat (ada_name, \")\");\n+    }\n+}\n+\n+char *\n+ada_demangle (coded_name)\n+     const char *coded_name;\n+{\n+  char ada_name[2048];\n+  char *result;\n+\n+  __gnat_decode (coded_name, ada_name, 0);\n+\n+  result = (char *) xmalloc (strlen (ada_name) + 1);\n+  strcpy (result, ada_name);\n+\n+  return result;\n+}"}, {"sha": "94ac87190be7a82289c8820313ccc1e3b56742bf", "filename": "gcc/ada/adadecode.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fadadecode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fadadecode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.h?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,52 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             G N A T D E C O                              *\n+ *                                                                          *\n+ *                            $Revision$\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *           Copyright (C) 2001-2002, Free Software Foundation, Inc.        *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This function will return the Ada name from the encoded form.\n+   The Ada coding is done in exp_dbug.ads and this is the inverse function.\n+   see exp_dbug.ads for full encoding rules, a short description is added\n+   below. Right now only objects and routines are handled. There is no support\n+   for Ada types.\n+\n+   CODED_NAME is the encoded entity name.\n+   ADA_NAME is a pointer to a buffer, it will receive the Ada name. A safe\n+   size for this buffer is: strlen (coded_name) * 2 + 60. (60 is for the\n+   verbose information).\n+   VERBOSE is nonzero if more information about the entity is to be\n+   added at the end of the Ada name and surrounded by ( and ).  */\n+extern void __gnat_decode PARAMS ((const char *, char *, int));\n+\n+/* ada_demangle is added for COMPATIBILITY ONLY. It has the name of the\n+   function used in the binutils and GDB. Always consider using __gnat_decode\n+   instead of ada_demangle. Caller must free the pointer returned.  */\n+extern char *ada_demangle PARAMS ((const char *));"}, {"sha": "ef4d647c875b442a16434859e4069b2c5243a458", "filename": "gcc/ada/aux-io.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Faux-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Faux-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faux-io.c?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,102 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT RUN-TIME COMPONENTS                         *\n+ *                                                                          *\n+ *                              A - T R A N S                               *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision$\n+ *                                                                          *\n+ *           Copyright (C) 1992-2001 Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#include <stdio.h>\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+/* Function wrappers are needed to access the values from Ada which are\n+   defined as C macros.  */\n+\n+FILE *c_stdin         PARAMS ((void));\n+FILE *c_stdout        PARAMS ((void));\n+FILE *c_stderr        PARAMS ((void));\n+int seek_set_function PARAMS ((void));\n+int seek_end_function PARAMS ((void));\n+void *null_function   PARAMS ((void));\n+int c_fileno          PARAMS ((FILE *));\n+\n+FILE *\n+c_stdin () \n+{ \n+  return stdin; \n+}\n+\n+FILE *\n+c_stdout () \n+{ \n+  return stdout;\n+}\n+\n+FILE *\n+c_stderr () \n+{ \n+  return stderr;\n+}\n+\n+#ifndef SEEK_SET    /* Symbolic constants for the \"fseek\" function: */\n+#define SEEK_SET 0  /* Set file pointer to offset */\n+#define SEEK_CUR 1  /* Set file pointer to its current value plus offset */\n+#define SEEK_END 2  /* Set file pointer to the size of the file plus offset */\n+#endif\n+\n+int   \n+seek_set_function ()  \n+{ \n+  return SEEK_SET; \n+}\n+\n+int   \n+seek_end_function ()  \n+{ \n+  return SEEK_END; \n+}\n+\n+void *null_function ()  \n+{ \n+  return NULL;     \n+}\n+\n+int \n+c_fileno (s) \n+     FILE *s;\n+{ \n+  return fileno (s); \n+}"}, {"sha": "3fbfa5d3d7a68a4eed538d2e3a2cb7ab91c570b4", "filename": "gcc/ada/s-traces.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-traces.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-traces.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traces.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                         S Y S T E M . T R A C E S                        --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Traces is\n+\n+   pragma Warnings (Off); -- kill warnings on unreferenced formals\n+\n+   ---------------------\n+   -- Send_Trace_Info --\n+   ---------------------\n+\n+   procedure Send_Trace_Info (Id : Trace_T) is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   ---------------------\n+   -- Send_Trace_Info --\n+   ---------------------\n+\n+   procedure Send_Trace_Info (Id : Trace_T; Timeout : Duration) is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+end System.Traces;"}, {"sha": "aa7236756194f38015dfc114ee8b060c93dd15f6", "filename": "gcc/ada/s-traces.ads", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-traces.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-traces.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traces.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                         S Y S T E M . T R A C E S                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements functions for traces when tasking is not involved\n+\n+--  Warning : NO dependencies to tasking should be created here\n+\n+--  This package, and all its children are used to implement debug\n+--  informations\n+\n+--  A new primitive, Send_Trace_Info (Id : Trace_T; 'data') is introduced.\n+--  Trace_T is an event identifier, 'data' are the informations to pass\n+--  with the event. Thid procedure is used from within the Runtime to send\n+--  debug informations.\n+\n+--  This primitive is overloaded in System.Traces.Tasking and this package.\n+\n+--  Send_Trace_Info calls Send_Trace, in System.Traces.Send, which is trarget\n+--  dependent, to send the debug informations to a debugger, stream ..\n+\n+--  To add a new event, just add them to the Trace_T type, and write the\n+--  corresponding Send_Trace_Info procedure. It may be required for some\n+--  target to modify Send_Trace (eg. VxWorks).\n+\n+--  To add a new target, just adapt System.Traces.Send to your own purpose.\n+\n+package System.Traces is\n+\n+   type Trace_T is\n+     (\n+      --  Events handled.\n+\n+      --  Messages\n+      --\n+      M_Accept_Complete,\n+      M_Select_Else,\n+      M_RDV_Complete,\n+      M_Call_Complete,\n+      M_Delay,\n+\n+      --  Errors\n+      --\n+      E_Missed,\n+      E_Timeout,\n+      E_Kill,\n+\n+      --  Waiting events\n+      --\n+      W_Call,\n+      W_Accept,\n+      W_Select,\n+      W_Completion,\n+      W_Delay,\n+      WU_Delay,\n+\n+      WT_Call,\n+      WT_Select,\n+      WT_Completion,\n+\n+      --  Protected objects events\n+      --\n+      PO_Call,\n+      POT_Call,\n+      PO_Run,\n+      PO_Lock,\n+      PO_Unlock,\n+      PO_Done,\n+\n+      --  Task handling events\n+      --\n+      T_Create,\n+      T_Activate,\n+      T_Abort,\n+      T_Terminate);\n+\n+   --  Send_Trace_Info procedures\n+\n+   --  They are overloaded, depending on the parameters passed with\n+   --  the event, e.g. Time information, Task name, Accept name ...\n+\n+   procedure Send_Trace_Info (Id : Trace_T);\n+\n+   procedure Send_Trace_Info (Id : Trace_T; Timeout : Duration);\n+\n+end System.Traces;"}, {"sha": "59124eadbffa3140783babdcf23df288245d929a", "filename": "gcc/ada/s-tratas.adb", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-tratas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-tratas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tratas.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,123 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 S Y S T E M . T R A C E S . T A S K I N G                --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Traces.Tasking is\n+\n+   pragma Warnings (Off); -- kill warnings on unreferenced formals\n+\n+   ---------------------\n+   -- Send_Trace_Info --\n+   ---------------------\n+\n+   procedure Send_Trace_Info (Id : Trace_T; Task_Name2 : ST.Task_ID) is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Task_Name2   : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Task_Name    : ST.Task_ID;\n+      Task_Name2   : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id         : Trace_T;\n+      Task_Name  : ST.Task_ID;\n+      Task_Name2 : ST.Task_ID)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Entry_Number : ST.Entry_Index)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Acceptor     : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index;\n+      Timeout      : Duration)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Entry_Number : ST.Entry_Index;\n+      Timeout      : Duration)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id        : Trace_T;\n+      Task_Name : ST.Task_ID;\n+      Number    : Integer)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+   procedure Send_Trace_Info\n+     (Id        : Trace_T;\n+      Task_Name : ST.Task_ID;\n+      Number    : Integer;\n+      Timeout   : Duration)\n+   is\n+   begin\n+      null;\n+   end Send_Trace_Info;\n+\n+end System.Traces.Tasking;"}, {"sha": "4713932b1dbcb3b3b0cc825dac31b3dfc1b57523", "filename": "gcc/ada/s-tratas.ads", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-tratas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fs-tratas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tratas.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,98 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                  S Y S T E M . T R A C E S . T A S K I N G               --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides all procedures used to implement debug traces\n+--  in the case tasking is involved.\n+\n+--  See System.Traces for an overview of the various files involved in Tracing\n+\n+--  If tasking is not involved, refer to System.Traces.General\n+\n+with System.Tasking;\n+\n+package System.Traces.Tasking is\n+\n+   package ST renames System.Tasking;\n+\n+   --  Send_Trace_Info procedures\n+\n+   --  They are overloaded, depending on the parameters passed with the event\n+\n+   procedure Send_Trace_Info\n+     (Id         : Trace_T;\n+      Task_Name2 : ST.Task_ID);\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Task_Name2   : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index);\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Task_Name    : ST.Task_ID;\n+      Task_Name2   : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index);\n+\n+   procedure Send_Trace_Info\n+     (Id         : Trace_T;\n+      Task_Name  : ST.Task_ID;\n+      Task_Name2 : ST.Task_ID);\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Entry_Number : ST.Entry_Index);\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Acceptor     : ST.Task_ID;\n+      Entry_Number : ST.Entry_Index;\n+      Timeout      : Duration);\n+\n+   procedure Send_Trace_Info\n+     (Id           : Trace_T;\n+      Entry_Number : ST.Entry_Index;\n+      Timeout      : Duration);\n+\n+   procedure Send_Trace_Info\n+     (Id         : Trace_T;\n+      Task_Name  : ST.Task_ID;\n+      Number     : Integer);\n+\n+   procedure Send_Trace_Info\n+     (Id         : Trace_T;\n+      Task_Name  : ST.Task_ID;\n+      Number     : Integer;\n+      Timeout    : Duration);\n+end System.Traces.Tasking;"}, {"sha": "6666a0ffa75a48bde75c31c5c84042a4de522573", "filename": "gcc/ada/sinput-d.adb", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fsinput-d.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fsinput-d.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-d.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,113 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S I N P U T . D                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Osint;     use Osint;\n+with Osint.C;   use Osint.C;\n+\n+package body Sinput.D is\n+\n+   Dfile : Source_File_Index;\n+   --  Index of currently active debug source file\n+\n+   ------------------------\n+   -- Close_Debug_Source --\n+   ------------------------\n+\n+   procedure Close_Debug_Source is\n+      S    : Source_File_Record renames Source_File.Table (Dfile);\n+      Src  : Source_Buffer_Ptr;\n+\n+   begin\n+      Trim_Lines_Table (Dfile);\n+      Close_Debug_File;\n+\n+      --  Now we need to read the file that we wrote and store it\n+      --  in memory for subsequent access.\n+\n+      Read_Source_File\n+        (S.Debug_Source_Name, S.Source_First, S.Source_Last, Src);\n+      S.Source_Text := Src;\n+   end Close_Debug_Source;\n+\n+   -------------------------\n+   -- Create_Debug_Source --\n+   -------------------------\n+\n+   procedure Create_Debug_Source\n+     (Source : Source_File_Index;\n+      Loc    : out Source_Ptr)\n+   is\n+   begin\n+      Loc := Source_File.Table (Source_File.Last).Source_Last + 1;\n+      Source_File.Increment_Last;\n+      Dfile := Source_File.Last;\n+\n+      declare\n+         S : Source_File_Record renames Source_File.Table (Dfile);\n+\n+      begin\n+         S := Source_File.Table (Source);\n+         S.Debug_Source_Name := Create_Debug_File (S.File_Name);\n+         S.Source_First      := Loc;\n+         S.Source_Last       := Loc;\n+         S.Lines_Table       := null;\n+         S.Last_Source_Line  := 1;\n+\n+         --  Allocate lines table, guess that it needs to be three times\n+         --  bigger than the original source (in number of lines).\n+\n+         Alloc_Line_Tables\n+           (S, Int (Source_File.Table (Source).Last_Source_Line * 3));\n+         S.Lines_Table (1) := Loc;\n+      end;\n+   end Create_Debug_Source;\n+\n+   ----------------------\n+   -- Write_Debug_Line --\n+   ----------------------\n+\n+   procedure Write_Debug_Line (Str : String; Loc : in out Source_Ptr) is\n+      S : Source_File_Record renames Source_File.Table (Dfile);\n+\n+   begin\n+      --  Ignore write request if null line at start of file\n+\n+      if Str'Length = 0 and then Loc = S.Source_First then\n+         return;\n+\n+      --  Here we write the line, and update the source record entry\n+\n+      else\n+         Write_Debug_Info (Str (Str'First .. Str'Last - 1));\n+         Add_Line_Tables_Entry (S, Loc);\n+         Loc := Loc - 1 + Source_Ptr (Str'Length + Debug_File_Eol_Length);\n+         S.Source_Last := Loc;\n+      end if;\n+   end Write_Debug_Line;\n+\n+end Sinput.D;"}, {"sha": "015b92affa9a6d28eb79cb051b0817eecaee38fc", "filename": "gcc/ada/sinput-d.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fsinput-d.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fsinput-d.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-d.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S I N P U T . D                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This child package contains the routines used to write debug source\n+--  files. These routines are not in Sinput.L, because they are used only\n+--  by the compiler, while Sinput.L is also used by gnatmake.\n+\n+package Sinput.D is\n+\n+   ------------------------------------------------\n+   -- Subprograms for Writing Debug Source Files --\n+   ------------------------------------------------\n+\n+   procedure Create_Debug_Source\n+     (Source : Source_File_Index;\n+      Loc    : out Source_Ptr);\n+   --  Given a source file, creates a new source file table entry to be used\n+   --  for the debug source file output (Debug_Generated_Code switch set).\n+   --  Loc is set to the initial Sloc value for the first line. This call\n+   --  also creates the debug source output file (using Create_Debug_File).\n+\n+   procedure Write_Debug_Line (Str : String; Loc : in out Source_Ptr);\n+   --  This procedure is called to write a line to the debug source file\n+   --  previously created by Create_Debug_Source using Write_Debug_Info.\n+   --  Str is the source line to be written to the file (it does not include\n+   --  an end of line character). On entry Loc is the Sloc value previously\n+   --  returned by Create_Debug_Source or Write_Debug_Line, and on exit,\n+   --  Sloc is updated to point to the start of the next line to be written,\n+   --  taking into account the length of the ternminator that was written by\n+   --  Write_Debug_Info.\n+\n+   procedure Close_Debug_Source;\n+   --  This procedure completes the source table entry for the debug file\n+   --  previously created by Create_Debug_Source, and written using the\n+   --  Write_Debug_Line procedure. It then calls Close_Debug_File to\n+   --  complete the writing of the file itself.\n+\n+end Sinput.D;"}, {"sha": "c442e6aeaae160c312208d2fb69168056d1c0038", "filename": "gcc/ada/switch-b.adb", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,428 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - B                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;    use Debug;\n+with Osint;    use Osint;\n+with Opt;      use Opt;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body Switch.B is\n+\n+   --------------------------\n+   -- Scan_Binder_Switches --\n+   --------------------------\n+\n+   procedure Scan_Binder_Switches (Switch_Chars : String) is\n+      Ptr : Integer := Switch_Chars'First;\n+      Max : Integer := Switch_Chars'Last;\n+      C   : Character := ' ';\n+\n+   begin\n+      --  Skip past the initial character (must be the switch character)\n+\n+      if Ptr = Max then\n+         raise Bad_Switch;\n+      else\n+         Ptr := Ptr + 1;\n+      end if;\n+\n+      --  A little check, \"gnat\" at the start of a switch is not allowed\n+      --  except for the compiler\n+\n+      if Switch_Chars'Last >= Ptr + 3\n+        and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\"\n+      then\n+         Osint.Fail (\"invalid switch: \"\"\", Switch_Chars, \"\"\"\"\n+            & \" (gnat not needed here)\");\n+\n+      end if;\n+\n+      --  Loop to scan through switches given in switch string\n+\n+      while Ptr <= Max loop\n+         C := Switch_Chars (Ptr);\n+\n+         case C is\n+\n+         --  Processing for A switch\n+\n+         when 'A' =>\n+            Ptr := Ptr + 1;\n+\n+            Ada_Bind_File := True;\n+\n+         --  Processing for b switch\n+\n+         when 'b' =>\n+            Ptr := Ptr + 1;\n+            Brief_Output := True;\n+\n+         --  Processing for c switch\n+\n+         when 'c' =>\n+            Ptr := Ptr + 1;\n+\n+            Check_Only := True;\n+\n+         --  Processing for C switch\n+\n+         when 'C' =>\n+            Ptr := Ptr + 1;\n+\n+            Ada_Bind_File := False;\n+\n+         --  Processing for d switch\n+\n+         when 'd' =>\n+\n+            --  Note: for the debug switch, the remaining characters in this\n+            --  switch field must all be debug flags, since all valid switch\n+            --  characters are also valid debug characters. This switch is not\n+            --  documented on purpose because it is only used by the\n+            --  implementors.\n+\n+            --  Loop to scan out debug flags\n+\n+            while Ptr < Max loop\n+               Ptr := Ptr + 1;\n+               C := Switch_Chars (Ptr);\n+               exit when C = ASCII.NUL or else C = '/' or else C = '-';\n+\n+               if C in '1' .. '9' or else\n+                  C in 'a' .. 'z' or else\n+                  C in 'A' .. 'Z'\n+               then\n+                  Set_Debug_Flag (C);\n+               else\n+                  raise Bad_Switch;\n+               end if;\n+            end loop;\n+\n+            --  Make sure Zero_Cost_Exceptions is set if gnatdX set. This\n+            --  is for backwards compatibility with old versions and usage.\n+\n+            if Debug_Flag_XX then\n+               Zero_Cost_Exceptions_Set := True;\n+               Zero_Cost_Exceptions_Val := True;\n+            end if;\n+\n+            return;\n+\n+         --  Processing for e switch\n+\n+         when 'e' =>\n+            Ptr := Ptr + 1;\n+            Elab_Dependency_Output := True;\n+\n+         --  Processing for E switch\n+\n+         when 'E' =>\n+            Ptr := Ptr + 1;\n+            Exception_Tracebacks := True;\n+\n+         --  Processing for f switch\n+\n+         when 'f' =>\n+            Ptr := Ptr + 1;\n+            Force_RM_Elaboration_Order := True;\n+\n+         --  Processing for g switch\n+\n+         when 'g' =>\n+            Ptr := Ptr + 1;\n+\n+            if Ptr <= Max then\n+               C := Switch_Chars (Ptr);\n+\n+               if C in '0' .. '3' then\n+                  Debugger_Level :=\n+                    Character'Pos\n+                      (Switch_Chars (Ptr)) - Character'Pos ('0');\n+                  Ptr := Ptr + 1;\n+               end if;\n+\n+            else\n+               Debugger_Level := 2;\n+            end if;\n+\n+         --  Processing for h switch\n+\n+         when 'h' =>\n+            Ptr := Ptr + 1;\n+            Usage_Requested := True;\n+\n+         --  Processing for i switch\n+\n+         when 'i' =>\n+            if Ptr = Max then\n+               raise Bad_Switch;\n+            end if;\n+\n+            Ptr := Ptr + 1;\n+            C := Switch_Chars (Ptr);\n+\n+            if C in  '1' .. '5'\n+              or else C = '8'\n+              or else C = 'p'\n+              or else C = 'f'\n+              or else C = 'n'\n+              or else C = 'w'\n+            then\n+               Identifier_Character_Set := C;\n+               Ptr := Ptr + 1;\n+            else\n+               raise Bad_Switch;\n+            end if;\n+\n+         --  Processing for K switch\n+\n+         when 'K' =>\n+            Ptr := Ptr + 1;\n+            Output_Linker_Option_List := True;\n+\n+         --  Processing for l switch\n+\n+         when 'l' =>\n+            Ptr := Ptr + 1;\n+            Elab_Order_Output := True;\n+\n+         --  Processing for m switch\n+\n+         when 'm' =>\n+            Ptr := Ptr + 1;\n+            Scan_Pos (Switch_Chars, Max, Ptr, Maximum_Errors);\n+\n+         --  Processing for n switch\n+\n+         when 'n' =>\n+            Ptr := Ptr + 1;\n+            Bind_Main_Program := False;\n+\n+            --  Note: The -L option of the binder also implies -n, so\n+            --  any change here must also be reflected in the processing\n+            --  for -L that is found in Gnatbind.Scan_Bind_Arg.\n+\n+         --  Processing for o switch\n+\n+         when 'o' =>\n+            Ptr := Ptr + 1;\n+\n+            if Output_File_Name_Present then\n+               raise Too_Many_Output_Files;\n+\n+            else\n+               Output_File_Name_Present := True;\n+            end if;\n+\n+         --  Processing for O switch\n+\n+         when 'O' =>\n+            Ptr := Ptr + 1;\n+            Output_Object_List := True;\n+\n+         --  Processing for p switch\n+\n+         when 'p' =>\n+            Ptr := Ptr + 1;\n+            Pessimistic_Elab_Order := True;\n+\n+         --  Processing for q switch\n+\n+         when 'q' =>\n+            Ptr := Ptr + 1;\n+            Quiet_Output := True;\n+\n+         --  Processing for r switch\n+\n+         when 'r' =>\n+            Ptr := Ptr + 1;\n+            List_Restrictions := True;\n+\n+         --  Processing for s switch\n+\n+         when 's' =>\n+            Ptr := Ptr + 1;\n+            All_Sources := True;\n+            Check_Source_Files := True;\n+\n+         --  Processing for t switch\n+\n+         when 't' =>\n+            Ptr := Ptr + 1;\n+            Tolerate_Consistency_Errors := True;\n+\n+         --  Processing for T switch\n+\n+         when 'T' =>\n+            Ptr := Ptr + 1;\n+            Time_Slice_Set := True;\n+            Scan_Nat (Switch_Chars, Max, Ptr, Time_Slice_Value);\n+\n+         --  Processing for v switch\n+\n+         when 'v' =>\n+            Ptr := Ptr + 1;\n+            Verbose_Mode := True;\n+\n+         --  Processing for w switch\n+\n+         when 'w' =>\n+\n+            --  For the binder we only allow suppress/error cases\n+\n+            Ptr := Ptr + 1;\n+\n+            case Switch_Chars (Ptr) is\n+\n+               when 'e' =>\n+                  Warning_Mode  := Treat_As_Error;\n+\n+               when 's' =>\n+                  Warning_Mode  := Suppress;\n+\n+               when others =>\n+                  raise Bad_Switch;\n+            end case;\n+\n+            Ptr := Ptr + 1;\n+\n+         --  Processing for W switch\n+\n+         when 'W' =>\n+            Ptr := Ptr + 1;\n+\n+            for J in WC_Encoding_Method loop\n+               if Switch_Chars (Ptr) = WC_Encoding_Letters (J) then\n+                  Wide_Character_Encoding_Method := J;\n+                  exit;\n+\n+               elsif J = WC_Encoding_Method'Last then\n+                  raise Bad_Switch;\n+               end if;\n+            end loop;\n+\n+            Upper_Half_Encoding :=\n+              Wide_Character_Encoding_Method in\n+                WC_Upper_Half_Encoding_Method;\n+\n+            Ptr := Ptr + 1;\n+\n+         --  Processing for x switch\n+\n+         when 'x' =>\n+            Ptr := Ptr + 1;\n+            All_Sources := False;\n+            Check_Source_Files := False;\n+\n+         --  Processing for z switch\n+\n+         when 'z' =>\n+            Ptr := Ptr + 1;\n+            No_Main_Subprogram := True;\n+\n+         --  Ignore extra switch character\n+\n+         when '/'  =>\n+            Ptr := Ptr + 1;\n+\n+         --  Ignore '-' extra switch caracter, only if it isn't followed by\n+         --  'RTS'. If it is, then we must process the 'RTS' switch\n+\n+         when '-' =>\n+\n+            if Ptr + 3 <= Max and then\n+              Switch_Chars (Ptr + 1 .. Ptr + 3) = \"RTS\"\n+            then\n+               Ptr := Ptr + 1;\n+\n+               if Switch_Chars (Ptr + 3) /= '=' or else\n+                 (Switch_Chars (Ptr + 3) = '='\n+                  and then Ptr + 4 > Max)\n+               then\n+                  Osint.Fail (\"missing path for --RTS\");\n+               else\n+\n+                  --  valid --RTS switch\n+                  Opt.No_Stdinc := True;\n+                  Opt.RTS_Switch := True;\n+\n+                  declare\n+                     Src_Path_Name : String_Ptr := Get_RTS_Search_Dir\n+                       (Switch_Chars (Ptr + 4 .. Switch_Chars'Last), Include);\n+                     Lib_Path_Name : String_Ptr := Get_RTS_Search_Dir\n+                       (Switch_Chars (Ptr + 4 .. Switch_Chars'Last), Objects);\n+                  begin\n+                     if Src_Path_Name /= null and then\n+                       Lib_Path_Name /= null\n+                     then\n+                        Add_Search_Dirs (Src_Path_Name, Include);\n+                        Add_Search_Dirs (Lib_Path_Name, Objects);\n+                        --  we can exit as there can not be another switch\n+                        --  after --RTS\n+                        exit;\n+                     elsif  Src_Path_Name = null\n+                       and Lib_Path_Name = null then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adainclude and adalib directories\");\n+                     elsif Src_Path_Name = null then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adainclude directory\");\n+                     elsif  Lib_Path_Name = null then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adalib directory\");\n+                     end if;\n+                  end;\n+               end if;\n+\n+            else\n+               Ptr := Ptr + 1;\n+            end if;\n+\n+         --  Anything else is an error (illegal switch character)\n+\n+         when others =>\n+            raise Bad_Switch;\n+         end case;\n+      end loop;\n+\n+   exception\n+      when Bad_Switch =>\n+         Osint.Fail (\"invalid switch: \", (1 => C));\n+\n+      when Bad_Switch_Value =>\n+         Osint.Fail (\"numeric value too big for switch: \", (1 => C));\n+\n+      when Missing_Switch_Value =>\n+         Osint.Fail (\"missing numeric value for switch: \", (1 => C));\n+\n+      when Too_Many_Output_Files =>\n+         Osint.Fail (\"duplicate -o switch\");\n+   end Scan_Binder_Switches;\n+\n+end Switch.B;"}, {"sha": "e58c1329da7ca0d87112f976d681a99c181c3efd", "filename": "gcc/ada/switch-b.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-b.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-b.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - B                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package scans binder switches. Note that the body of Usage must be\n+--  coordinated with the switches that are recognized by this package.\n+--  The Usage package also acts as the official documentation for the\n+--  switches that are recognized. In addition, package Debug documents\n+--  the otherwise undocumented debug switches that are also recognized.\n+\n+package Switch.B is\n+\n+   procedure Scan_Binder_Switches (Switch_Chars : String);\n+   --  Procedures to scan out binder switches stored in the given string.\n+   --  The first character is known to be a valid switch character, and there\n+   --  are no blanks or other switch terminator characters in the string, so\n+   --  the entire string should consist of valid switch characters, except that\n+   --  an optional terminating NUL character is allowed. A bad switch causes\n+   --  a fatal error exit and control does not return. The call also sets\n+   --  Usage_Requested to True if a ? switch is encountered.\n+\n+end Switch.B;"}, {"sha": "7f34b1bdd378bf09c8c1b918ea84bb5453a9c88f", "filename": "gcc/ada/switch-c.adb", "status": "added", "additions": 870, "deletions": 0, "changes": 870, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,870 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - C                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;    use Debug;\n+with Lib;      use Lib;\n+with Osint;    use Osint;\n+with Opt;      use Opt;\n+with Types;    use Types;\n+with Validsw;  use Validsw;\n+with Stylesw;  use Stylesw;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body Switch.C is\n+\n+   -----------------------------\n+   -- Scan_Front_End_Switches --\n+   -----------------------------\n+\n+   procedure Scan_Front_End_Switches (Switch_Chars : String) is\n+      Switch_Starts_With_Gnat : Boolean;\n+      --  True if first four switch characters are \"gnat\"\n+\n+      First_Switch : Boolean := True;\n+      --  False for all but first switch\n+\n+      Ptr : Integer := Switch_Chars'First;\n+      Max : constant Integer := Switch_Chars'Last;\n+      C   : Character := ' ';\n+\n+      Store_Switch : Boolean  := True;\n+      First_Char   : Integer  := Ptr;\n+      Storing      : String   := Switch_Chars;\n+      First_Stored : Positive := Ptr + 1;\n+      --  The above need comments ???\n+\n+   begin\n+      --  Skip past the initial character (must be the switch character)\n+\n+      if Ptr = Max then\n+         raise Bad_Switch;\n+      else\n+         Ptr := Ptr + 1;\n+      end if;\n+\n+      --  Remove \"gnat\" from the switch, if present\n+\n+      Switch_Starts_With_Gnat :=\n+        Ptr + 3 <= Max and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\";\n+\n+      if Switch_Starts_With_Gnat then\n+         Ptr := Ptr + 4;\n+         First_Stored := Ptr;\n+      end if;\n+\n+      --  Loop to scan through switches given in switch string\n+\n+      while Ptr <= Max loop\n+         Store_Switch := True;\n+         First_Char := Ptr;\n+         C := Switch_Chars (Ptr);\n+\n+         --  Processing for a switch\n+\n+         case Switch_Starts_With_Gnat is\n+\n+            when False =>\n+            --  There are only two front-end switches that\n+            --  do not start with -gnat, namely -I and --RTS\n+\n+               if Switch_Chars (Ptr) = 'I' then\n+                  Store_Switch := False;\n+\n+                  Ptr := Ptr + 1;\n+\n+                  if Ptr > Max then\n+                     raise Bad_Switch;\n+                  end if;\n+\n+                  --  Find out whether this is a -I- or regular -Ixxx switch\n+\n+                  if Ptr = Max and then Switch_Chars (Ptr) = '-' then\n+                     Look_In_Primary_Dir := False;\n+\n+                  else\n+                     Add_Src_Search_Dir (Switch_Chars (Ptr .. Max));\n+                  end if;\n+\n+                  Ptr := Max + 1;\n+\n+               --  Processing of the --RTS switch. --RTS has been modified by\n+               --  gcc and is now of the form -fRTS\n+               elsif Ptr + 3 <= Max and then\n+                 Switch_Chars (Ptr .. Ptr + 3) = \"fRTS\"\n+               then\n+                  Ptr := Ptr + 1;\n+\n+                  if Ptr + 4 > Max or else Switch_Chars (Ptr + 3) /= '=' then\n+                     Osint.Fail (\"missing path for --RTS\");\n+                  else\n+\n+                     --  valid --RTS switch\n+                     Opt.No_Stdinc := True;\n+                     Opt.RTS_Switch := True;\n+\n+                     declare\n+                        Src_Path_Name : String_Ptr := Get_RTS_Search_Dir\n+                          (Switch_Chars (Ptr + 4 .. Max), Include);\n+                        Lib_Path_Name : String_Ptr := Get_RTS_Search_Dir\n+                          (Switch_Chars (Ptr + 4 .. Max), Objects);\n+                     begin\n+                        if Src_Path_Name /= null and then\n+                          Lib_Path_Name /= null\n+                        then\n+                           Add_Search_Dirs (Src_Path_Name, Include);\n+                           Add_Search_Dirs (Lib_Path_Name, Objects);\n+                           Ptr := Max + 1;\n+                        elsif  Src_Path_Name = null\n+                          and Lib_Path_Name = null then\n+                           Osint.Fail (\"RTS path not valid: missing \" &\n+                                       \"adainclude and adalib directories\");\n+                        elsif Src_Path_Name = null then\n+                           Osint.Fail (\"RTS path not valid: missing \" &\n+                                       \"adainclude directory\");\n+                        elsif  Lib_Path_Name = null then\n+                           Osint.Fail (\"RTS path not valid: missing \" &\n+                                       \"adalib directory\");\n+                        end if;\n+                     end;\n+                  end if;\n+               else\n+                  raise Bad_Switch;\n+               end if;\n+\n+         when True =>\n+            --  Process -gnat* options\n+\n+            case C is\n+\n+            when 'a' =>\n+               Ptr := Ptr + 1;\n+               Assertions_Enabled := True;\n+\n+            --  Processing for A switch\n+\n+            when 'A' =>\n+               Ptr := Ptr + 1;\n+               Config_File := False;\n+\n+            --  Processing for b switch\n+\n+            when 'b' =>\n+               Ptr := Ptr + 1;\n+               Brief_Output := True;\n+\n+            --  Processing for c switch\n+\n+            when 'c' =>\n+               if not First_Switch then\n+                  Osint.Fail\n+                    (\"-gnatc myust be first if combined with other switches\");\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+               Operating_Mode := Check_Semantics;\n+\n+            --  Processing for C switch\n+\n+            when 'C' =>\n+               Ptr := Ptr + 1;\n+               Compress_Debug_Names := True;\n+\n+            --  Processing for d switch\n+\n+            when 'd' =>\n+               Store_Switch := False;\n+               Storing (First_Stored) := 'd';\n+               --  Note: for the debug switch, the remaining characters in this\n+               --  switch field must all be debug flags, since all valid switch\n+               --  characters are also valid debug characters.\n+\n+               --  Loop to scan out debug flags\n+\n+               while Ptr < Max loop\n+                  Ptr := Ptr + 1;\n+                  C := Switch_Chars (Ptr);\n+                  exit when C = ASCII.NUL or else C = '/' or else C = '-';\n+\n+                  if C in '1' .. '9' or else\n+                     C in 'a' .. 'z' or else\n+                     C in 'A' .. 'Z'\n+                  then\n+                     Set_Debug_Flag (C);\n+                     Storing (First_Stored + 1) := C;\n+                     Store_Compilation_Switch\n+                       (Storing (Storing'First .. First_Stored + 1));\n+\n+                  else\n+                     raise Bad_Switch;\n+                  end if;\n+               end loop;\n+\n+               --  Make sure Zero_Cost_Exceptions is set if gnatdX set. This\n+               --  is for backwards compatibility with old versions and usage.\n+\n+               if Debug_Flag_XX then\n+                  Zero_Cost_Exceptions_Set := True;\n+                  Zero_Cost_Exceptions_Val := True;\n+               end if;\n+\n+               return;\n+\n+            --  Processing for D switch\n+\n+            when 'D' =>\n+               Ptr := Ptr + 1;\n+\n+               --  Note: -gnatD also sets -gnatx (to turn off cross-reference\n+               --  generation in the ali file) since otherwise this generation\n+               --  gets confused by the \"wrong\" Sloc values put in the tree.\n+\n+               Debug_Generated_Code := True;\n+               Xref_Active := False;\n+               Set_Debug_Flag ('g');\n+\n+            --  Processing for e switch\n+\n+            when 'e' =>\n+               Ptr := Ptr + 1;\n+\n+               if Ptr > Max then\n+                  raise Bad_Switch;\n+               end if;\n+\n+               case Switch_Chars (Ptr) is\n+\n+                  --  Configuration pragmas\n+\n+                  when 'c' =>\n+                     Store_Switch := False;\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr > Max then\n+                        raise Bad_Switch;\n+                     end if;\n+\n+                     Config_File_Name :=\n+                        new String'(Switch_Chars (Ptr .. Max));\n+\n+                     return;\n+\n+                  --  Mapping file\n+\n+                  when 'm' =>\n+                     Store_Switch := False;\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr > Max then\n+                        raise Bad_Switch;\n+                     end if;\n+\n+                     Mapping_File_Name :=\n+                       new String'(Switch_Chars (Ptr .. Max));\n+                     return;\n+\n+                  when others =>\n+                     raise Bad_Switch;\n+               end case;\n+\n+            --  Processing for E switch\n+\n+            when 'E' =>\n+               Ptr := Ptr + 1;\n+               Dynamic_Elaboration_Checks := True;\n+\n+            --  Processing for f switch\n+\n+            when 'f' =>\n+               Ptr := Ptr + 1;\n+               All_Errors_Mode := True;\n+\n+            --  Processing for F switch\n+\n+            when 'F' =>\n+               Ptr := Ptr + 1;\n+               External_Name_Exp_Casing := Uppercase;\n+               External_Name_Imp_Casing := Uppercase;\n+\n+            --  Processing for g switch\n+\n+            when 'g' =>\n+               Ptr := Ptr + 1;\n+               GNAT_Mode                := True;\n+               Identifier_Character_Set := 'n';\n+               Warning_Mode             := Treat_As_Error;\n+               Check_Unreferenced       := True;\n+               Check_Withs              := True;\n+\n+               Set_Default_Style_Check_Options;\n+\n+            --  Processing for G switch\n+\n+            when 'G' =>\n+               Ptr := Ptr + 1;\n+               Print_Generated_Code := True;\n+\n+            --  Processing for h switch\n+\n+            when 'h' =>\n+               Ptr := Ptr + 1;\n+               Usage_Requested := True;\n+\n+            --  Processing for H switch\n+\n+            when 'H' =>\n+               Ptr := Ptr + 1;\n+               HLO_Active := True;\n+\n+            --  Processing for i switch\n+\n+            when 'i' =>\n+               if Ptr = Max then\n+                  raise Bad_Switch;\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+               C := Switch_Chars (Ptr);\n+\n+               if C in '1' .. '5'\n+                 or else C = '8'\n+                 or else C = '9'\n+                 or else C = 'p'\n+                 or else C = 'f'\n+                 or else C = 'n'\n+                 or else C = 'w'\n+               then\n+                  Identifier_Character_Set := C;\n+                  Ptr := Ptr + 1;\n+\n+               else\n+                  raise Bad_Switch;\n+               end if;\n+\n+            --  Processing for k switch\n+\n+            when 'k' =>\n+               Ptr := Ptr + 1;\n+               Scan_Pos (Switch_Chars, Max, Ptr, Maximum_File_Name_Length);\n+\n+            --  Processing for l switch\n+\n+            when 'l' =>\n+               Ptr := Ptr + 1;\n+               Full_List := True;\n+\n+            --  Processing for L switch\n+\n+            when 'L' =>\n+               Ptr := Ptr + 1;\n+               Zero_Cost_Exceptions_Set := True;\n+               Zero_Cost_Exceptions_Val := False;\n+\n+            --  Processing for m switch\n+\n+            when 'm' =>\n+               Ptr := Ptr + 1;\n+               Scan_Pos (Switch_Chars, Max, Ptr, Maximum_Errors);\n+\n+            --  Processing for n switch\n+\n+            when 'n' =>\n+               Ptr := Ptr + 1;\n+               Inline_Active := True;\n+\n+            --  Processing for N switch\n+\n+            when 'N' =>\n+               Ptr := Ptr + 1;\n+               Inline_Active := True;\n+               Front_End_Inlining := True;\n+\n+            --  Processing for o switch\n+\n+            when 'o' =>\n+               Ptr := Ptr + 1;\n+               Suppress_Options.Overflow_Checks := False;\n+               Opt.Enable_Overflow_Checks := True;\n+\n+            --  Processing for O switch\n+\n+            when 'O' =>\n+               Ptr := Ptr + 1;\n+               Output_File_Name_Present := True;\n+\n+            --  Processing for p switch\n+\n+            when 'p' =>\n+               Ptr := Ptr + 1;\n+               Suppress_Options.Access_Checks        := True;\n+               Suppress_Options.Accessibility_Checks := True;\n+               Suppress_Options.Discriminant_Checks  := True;\n+               Suppress_Options.Division_Checks      := True;\n+               Suppress_Options.Elaboration_Checks   := True;\n+               Suppress_Options.Index_Checks         := True;\n+               Suppress_Options.Length_Checks        := True;\n+               Suppress_Options.Overflow_Checks      := True;\n+               Suppress_Options.Range_Checks         := True;\n+               Suppress_Options.Storage_Checks       := True;\n+               Suppress_Options.Tag_Checks           := True;\n+\n+               Validity_Checks_On := False;\n+               Opt.Suppress_Checks := True;\n+               Opt.Enable_Overflow_Checks := False;\n+\n+            --  Processing for P switch\n+\n+            when 'P' =>\n+               Ptr := Ptr + 1;\n+               Polling_Required := True;\n+\n+            --  Processing for q switch\n+\n+            when 'q' =>\n+               Ptr := Ptr + 1;\n+               Try_Semantics := True;\n+\n+            --  Processing for q switch\n+\n+            when 'Q' =>\n+               Ptr := Ptr + 1;\n+               Force_ALI_Tree_File := True;\n+               Try_Semantics := True;\n+\n+            --  Processing for R switch\n+\n+            when 'R' =>\n+               Ptr := Ptr + 1;\n+               Back_Annotate_Rep_Info := True;\n+\n+               if Ptr <= Max\n+                 and then Switch_Chars (Ptr) in '0' .. '9'\n+               then\n+                  C := Switch_Chars (Ptr);\n+\n+                  if C in '4' .. '9' then\n+                     raise Bad_Switch;\n+                  else\n+                     List_Representation_Info :=\n+                       Character'Pos (C) - Character'Pos ('0');\n+                     Ptr := Ptr + 1;\n+                  end if;\n+\n+                  if Ptr <= Max and then Switch_Chars (Ptr) = 's' then\n+                     Ptr := Ptr + 1;\n+\n+                     if List_Representation_Info /= 0 then\n+                        List_Representation_Info_To_File := True;\n+                     end if;\n+                  end if;\n+\n+               else\n+                  List_Representation_Info := 1;\n+               end if;\n+\n+            --  Processing for s switch\n+\n+            when 's' =>\n+               if not First_Switch then\n+                  Osint.Fail\n+                    (\"-gnats myust be first if combined with other switches\");\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+               Operating_Mode := Check_Syntax;\n+\n+            --  Processing for t switch\n+\n+            when 't' =>\n+               Ptr := Ptr + 1;\n+               Tree_Output := True;\n+               Back_Annotate_Rep_Info := True;\n+\n+            --  Processing for T switch\n+\n+            when 'T' =>\n+               Ptr := Ptr + 1;\n+               Scan_Pos (Switch_Chars, Max, Ptr, Table_Factor);\n+\n+            --  Processing for u switch\n+\n+            when 'u' =>\n+               Ptr := Ptr + 1;\n+               List_Units := True;\n+\n+            --  Processing for U switch\n+\n+            when 'U' =>\n+               Ptr := Ptr + 1;\n+               Unique_Error_Tag := True;\n+\n+            --  Processing for v switch\n+\n+            when 'v' =>\n+               Ptr := Ptr + 1;\n+               Verbose_Mode := True;\n+\n+            --  Processing for V switch\n+\n+            when 'V' =>\n+               Store_Switch := False;\n+               Storing (First_Stored) := 'V';\n+               Ptr := Ptr + 1;\n+\n+               if Ptr > Max then\n+                  raise Bad_Switch;\n+\n+               else\n+                  declare\n+                     OK  : Boolean;\n+\n+                  begin\n+                     Set_Validity_Check_Options\n+                       (Switch_Chars (Ptr .. Max), OK, Ptr);\n+\n+                     if not OK then\n+                        raise Bad_Switch;\n+                     end if;\n+\n+                     for Index in First_Char + 1 .. Max loop\n+                        Storing (First_Stored + 1) :=\n+                          Switch_Chars (Index);\n+                        Store_Compilation_Switch\n+                          (Storing (Storing'First .. First_Stored + 1));\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               Ptr := Max + 1;\n+\n+            --  Processing for w switch\n+\n+            when 'w' =>\n+               Store_Switch := False;\n+               Storing (First_Stored) := 'w';\n+               Ptr := Ptr + 1;\n+\n+               if Ptr > Max then\n+                  raise Bad_Switch;\n+               end if;\n+\n+               while Ptr <= Max loop\n+                  C := Switch_Chars (Ptr);\n+\n+                  case C is\n+\n+                     when 'a' =>\n+                        Constant_Condition_Warnings     := True;\n+                        Elab_Warnings                   := True;\n+                        Check_Unreferenced              := True;\n+                        Check_Withs                     := True;\n+                        Check_Unreferenced_Formals      := True;\n+                        Implementation_Unit_Warnings    := True;\n+                        Ineffective_Inline_Warnings     := True;\n+                        Warn_On_Redundant_Constructs    := True;\n+\n+                     when 'A' =>\n+                        Constant_Condition_Warnings     := False;\n+                        Elab_Warnings                   := False;\n+                        Check_Unreferenced              := False;\n+                        Check_Withs                     := False;\n+                        Check_Unreferenced_Formals      := False;\n+                        Implementation_Unit_Warnings    := False;\n+                        Warn_On_Biased_Rounding         := False;\n+                        Warn_On_Dereference             := False;\n+                        Warn_On_Hiding                  := False;\n+                        Warn_On_Redundant_Constructs    := False;\n+                        Ineffective_Inline_Warnings     := False;\n+\n+                     when 'b' =>\n+                        Warn_On_Biased_Rounding         := True;\n+\n+                     when 'B' =>\n+                        Warn_On_Biased_Rounding         := False;\n+\n+                     when 'c' =>\n+                        Constant_Condition_Warnings     := True;\n+\n+                     when 'C' =>\n+                        Constant_Condition_Warnings     := False;\n+\n+                     when 'd' =>\n+                        Warn_On_Dereference             := True;\n+\n+                     when 'D' =>\n+                        Warn_On_Dereference             := False;\n+\n+                     when 'e' =>\n+                        Warning_Mode                    := Treat_As_Error;\n+\n+                     when 'f' =>\n+                        Check_Unreferenced_Formals      := True;\n+\n+                     when 'F' =>\n+                        Check_Unreferenced_Formals      := False;\n+\n+                     when 'h' =>\n+                        Warn_On_Hiding                  := True;\n+\n+                     when 'H' =>\n+                        Warn_On_Hiding                  := False;\n+\n+                     when 'i' =>\n+                        Implementation_Unit_Warnings    := True;\n+\n+                     when 'I' =>\n+                        Implementation_Unit_Warnings    := False;\n+\n+                     when 'l' =>\n+                        Elab_Warnings                   := True;\n+\n+                     when 'L' =>\n+                        Elab_Warnings                   := False;\n+\n+                     when 'o' =>\n+                        Address_Clause_Overlay_Warnings := True;\n+\n+                     when 'O' =>\n+                        Address_Clause_Overlay_Warnings := False;\n+\n+                     when 'p' =>\n+                        Ineffective_Inline_Warnings     := True;\n+\n+                     when 'P' =>\n+                        Ineffective_Inline_Warnings     := False;\n+\n+                     when 'r' =>\n+                        Warn_On_Redundant_Constructs    := True;\n+\n+                     when 'R' =>\n+                        Warn_On_Redundant_Constructs    := False;\n+\n+                     when 's' =>\n+                        Warning_Mode                    := Suppress;\n+\n+                     when 'u' =>\n+                        Check_Unreferenced              := True;\n+                        Check_Withs                     := True;\n+                        Check_Unreferenced_Formals      := True;\n+\n+                     when 'U' =>\n+                        Check_Unreferenced              := False;\n+                        Check_Withs                     := False;\n+                        Check_Unreferenced_Formals      := False;\n+\n+                        --  Allow and ignore 'w' so that the old\n+                        --  format (e.g. -gnatwuwl) will work.\n+\n+                     when 'w' =>\n+                        null;\n+\n+                     when others =>\n+                        raise Bad_Switch;\n+                  end case;\n+\n+                  if C /= 'w' then\n+                     Storing (First_Stored + 1) := C;\n+                     Store_Compilation_Switch\n+                       (Storing (Storing'First .. First_Stored + 1));\n+                  end if;\n+\n+                  Ptr := Ptr + 1;\n+               end loop;\n+\n+               return;\n+\n+            --  Processing for W switch\n+\n+            when 'W' =>\n+               Ptr := Ptr + 1;\n+\n+               if Ptr > Max then\n+                  raise Bad_Switch;\n+               end if;\n+\n+               for J in WC_Encoding_Method loop\n+                  if Switch_Chars (Ptr) = WC_Encoding_Letters (J) then\n+                     Wide_Character_Encoding_Method := J;\n+                     exit;\n+\n+                  elsif J = WC_Encoding_Method'Last then\n+                     raise Bad_Switch;\n+                  end if;\n+               end loop;\n+\n+               Upper_Half_Encoding :=\n+                 Wide_Character_Encoding_Method in\n+                 WC_Upper_Half_Encoding_Method;\n+\n+               Ptr := Ptr + 1;\n+\n+            --  Processing for x switch\n+\n+            when 'x' =>\n+               Ptr := Ptr + 1;\n+               Xref_Active := False;\n+\n+            --  Processing for X switch\n+\n+            when 'X' =>\n+               Ptr := Ptr + 1;\n+               Extensions_Allowed := True;\n+\n+            --  Processing for y switch\n+\n+            when 'y' =>\n+               Ptr := Ptr + 1;\n+\n+               if Ptr > Max then\n+                  Set_Default_Style_Check_Options;\n+\n+               else\n+                  Store_Switch := False;\n+                  Storing (First_Stored) := 'y';\n+\n+                  declare\n+                     OK  : Boolean;\n+                     Last_Stored : Integer;\n+\n+                  begin\n+                     Set_Style_Check_Options\n+                       (Switch_Chars (Ptr .. Max), OK, Ptr);\n+\n+                     if not OK then\n+                        raise Bad_Switch;\n+                     end if;\n+\n+                     Ptr := First_Char + 1;\n+\n+                     while Ptr <= Max loop\n+                        Last_Stored := First_Stored + 1;\n+                        Storing (Last_Stored) := Switch_Chars (Ptr);\n+\n+                        if Switch_Chars (Ptr) = 'M' then\n+                           loop\n+                              Ptr := Ptr + 1;\n+                              exit when Ptr > Max\n+                                or else Switch_Chars (Ptr) not in '0' .. '9';\n+                              Last_Stored := Last_Stored + 1;\n+                              Storing (Last_Stored) := Switch_Chars (Ptr);\n+                           end loop;\n+\n+                        else\n+                           Ptr := Ptr + 1;\n+                        end if;\n+\n+                        Store_Compilation_Switch\n+                          (Storing (Storing'First .. Last_Stored));\n+                     end loop;\n+                  end;\n+               end if;\n+\n+            --  Processing for z switch\n+\n+            when 'z' =>\n+               Ptr := Ptr + 1;\n+\n+               --  Allowed for compiler, only if this is the only\n+               --  -z switch, we do not allow multiple occurrences\n+\n+               if Distribution_Stub_Mode = No_Stubs then\n+                  case Switch_Chars (Ptr) is\n+                     when 'r' =>\n+                        Distribution_Stub_Mode := Generate_Receiver_Stub_Body;\n+\n+                     when 'c' =>\n+                        Distribution_Stub_Mode := Generate_Caller_Stub_Body;\n+\n+                     when others =>\n+                        raise Bad_Switch;\n+                  end case;\n+\n+                  Ptr := Ptr + 1;\n+\n+               end if;\n+\n+            --  Processing for Z switch\n+\n+            when 'Z' =>\n+               Ptr := Ptr + 1;\n+               Zero_Cost_Exceptions_Set := True;\n+               Zero_Cost_Exceptions_Val := True;\n+\n+            --  Processing for 83 switch\n+\n+            when '8' =>\n+\n+               if Ptr = Max then\n+                  raise Bad_Switch;\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+\n+               if Switch_Chars (Ptr) /= '3' then\n+                  raise Bad_Switch;\n+               else\n+                  Ptr := Ptr + 1;\n+                  Ada_95 := False;\n+                  Ada_83 := True;\n+               end if;\n+\n+            --  Ignore extra switch character\n+\n+            when '/' | '-' =>\n+               Ptr := Ptr + 1;\n+\n+            --  Anything else is an error (illegal switch character)\n+\n+            when others =>\n+               raise Bad_Switch;\n+            end case;\n+         end case;\n+\n+         if Store_Switch then\n+            Storing (First_Stored .. First_Stored + Ptr - First_Char - 1) :=\n+              Switch_Chars (First_Char .. Ptr - 1);\n+            Store_Compilation_Switch\n+              (Storing (Storing'First .. First_Stored + Ptr - First_Char - 1));\n+         end if;\n+\n+         First_Switch := False;\n+      end loop;\n+\n+   exception\n+      when Bad_Switch =>\n+         Osint.Fail (\"invalid switch: \", (1 => C));\n+\n+      when Bad_Switch_Value =>\n+         Osint.Fail (\"numeric value too big for switch: \", (1 => C));\n+\n+      when Missing_Switch_Value =>\n+         Osint.Fail (\"missing numeric value for switch: \", (1 => C));\n+\n+   end Scan_Front_End_Switches;\n+\n+end Switch.C;"}, {"sha": "eec6f11eab58f8ee4d2362245bea68fb8a969696", "filename": "gcc/ada/switch-c.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - C                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package scans front end switches. Note that the body of Usage must be\n+--  coordinated with the switches that are recognized by this package.\n+--  The Usage package also acts as the official documentation for the\n+--  switches that are recognized. In addition, package Debug documents\n+--  the otherwise undocumented debug switches that are also recognized.\n+\n+package Switch.C is\n+\n+   procedure Scan_Front_End_Switches (Switch_Chars : String);\n+   --  Procedures to scan out front end switches stored in the given string.\n+   --  The first character is known to be a valid switch character, and there\n+   --  are no blanks or other switch terminator characters in the string, so\n+   --  the entire string should consist of valid switch characters, except that\n+   --  an optional terminating NUL character is allowed. A bad switch causes\n+   --  a fatal error exit and control does not return. The call also sets\n+   --  Usage_Requested to True if a ? switch is encountered.\n+\n+end Switch.C;"}, {"sha": "ec08a6d8c3183eebc9aadfed6a81be919ebfbff0", "filename": "gcc/ada/switch-m.adb", "status": "added", "additions": 591, "deletions": 0, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,591 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - M                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;    use Debug;\n+with Osint;    use Osint;\n+with Opt;      use Opt;\n+with Table;\n+\n+package body Switch.M is\n+\n+   package Normalized_Switches is new Table.Table\n+     (Table_Component_Type => String_Access,\n+      Table_Index_Type     => Integer,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 20,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Switch.C.Normalized_Switches\");\n+   --  This table is used to keep the normalized switches, so that they may be\n+   --  reused for subsequent invocations of Normalize_Compiler_Switches with\n+   --  similar switches.\n+\n+   Initial_Number_Of_Switches : constant := 10;\n+\n+   Global_Switches : Argument_List_Access := null;\n+   --  Used by function Normalize_Compiler_Switches\n+\n+   ---------------------------------\n+   -- Normalize_Compiler_Switches --\n+   ---------------------------------\n+\n+   procedure Normalize_Compiler_Switches\n+     (Switch_Chars : String;\n+      Switches     : in out Argument_List_Access;\n+      Last         : out Natural)\n+   is\n+      Switch_Starts_With_Gnat : Boolean;\n+\n+      Ptr : Integer := Switch_Chars'First;\n+      Max : constant Integer := Switch_Chars'Last;\n+      C   : Character := ' ';\n+\n+      First_Char   : Integer := Ptr;\n+      Storing      : String := Switch_Chars;\n+      First_Stored : Positive := Ptr + 1;\n+      Last_Stored  : Positive := First_Stored;\n+\n+      procedure Add_Switch_Component (S : String);\n+      --  Add a new String_Access component in Switches. If a string equal\n+      --  to S is already stored in the table Normalized_Switches, use it.\n+      --  Other wise add a new component to the table.\n+\n+      --------------------------\n+      -- Add_Switch_Component --\n+      --------------------------\n+\n+      procedure Add_Switch_Component (S : String) is\n+      begin\n+         --  If Switches is null, allocate a new array\n+\n+         if Switches = null then\n+            Switches := new Argument_List (1 .. Initial_Number_Of_Switches);\n+\n+         --  otherwise, if Switches is full, extend it\n+\n+         elsif Last = Switches'Last then\n+            declare\n+               New_Switches : Argument_List_Access := new Argument_List\n+                 (1 .. Switches'Length + Switches'Length);\n+            begin\n+               New_Switches (1 .. Switches'Length) := Switches.all;\n+               Last := Switches'Length;\n+               Switches := New_Switches;\n+            end;\n+         end if;\n+\n+         --  If this is the first switch, Last designates the first component\n+         if Last = 0 then\n+            Last := Switches'First;\n+\n+         else\n+            Last := Last + 1;\n+         end if;\n+\n+         --  Look into the table Normalized_Switches for a similar string.\n+         --  If one is found, put it at the added component, and return.\n+\n+         for Index in 1 .. Normalized_Switches.Last loop\n+            if S = Normalized_Switches.Table (Index).all then\n+               Switches (Last) := Normalized_Switches.Table (Index);\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  No string equal to S was found in the table Normalized_Switches.\n+         --  Add a new component in the table.\n+\n+         Switches (Last) := new String'(S);\n+         Normalized_Switches.Increment_Last;\n+         Normalized_Switches.Table (Normalized_Switches.Last) :=\n+           Switches (Last);\n+      end Add_Switch_Component;\n+\n+   --  Start of processing for Normalize_Compiler_Switches\n+\n+   begin\n+      Last := 0;\n+\n+      if Ptr = Max or else Switch_Chars (Ptr) /= '-' then\n+         return;\n+      end if;\n+\n+      Ptr := Ptr + 1;\n+\n+      Switch_Starts_With_Gnat :=\n+         Ptr + 3 <= Max and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\";\n+\n+      if Switch_Starts_With_Gnat then\n+         Ptr := Ptr + 4;\n+         First_Stored := Ptr;\n+      end if;\n+\n+      while Ptr <= Max loop\n+         First_Char := Ptr;\n+         C := Switch_Chars (Ptr);\n+\n+         --  Processing for a switch\n+\n+         case Switch_Starts_With_Gnat is\n+\n+            when False =>\n+               --  All switches that don't start with -gnat stay as is\n+\n+               Add_Switch_Component (Switch_Chars);\n+               return;\n+\n+            when True =>\n+\n+               case C is\n+\n+                  --  One-letter switches\n+\n+                  when 'a' | 'A' | 'b' | 'c' | 'C' | 'D' | 'E' | 'f' |\n+                    'F' | 'g' | 'h' | 'H' | 'k' | 'l' | 'L' | 'n' | 'N' |\n+                    'o' | 'O' | 'p' | 'P' | 'q' | 'Q' | 'r' | 's' | 't' |\n+                    'u' | 'U' | 'v' | 'x' | 'X' | 'Z' =>\n+                     Storing (First_Stored) := C;\n+                     Add_Switch_Component\n+                       (Storing (Storing'First .. First_Stored));\n+                     Ptr := Ptr + 1;\n+\n+                  --  One-letter switches followed by a positive number\n+\n+                  when 'm' | 'T' =>\n+                     Storing (First_Stored) := C;\n+                     Last_Stored := First_Stored;\n+\n+                     loop\n+                        Ptr := Ptr + 1;\n+                        exit when Ptr > Max\n+                          or else Switch_Chars (Ptr) not in '0' .. '9';\n+                        Last_Stored := Last_Stored + 1;\n+                        Storing (Last_Stored) := Switch_Chars (Ptr);\n+                     end loop;\n+\n+                     Add_Switch_Component\n+                       (Storing (Storing'First .. Last_Stored));\n+\n+                  when 'd' =>\n+                     Storing (First_Stored) := 'd';\n+\n+                     while Ptr < Max loop\n+                        Ptr := Ptr + 1;\n+                        C := Switch_Chars (Ptr);\n+                        exit when C = ASCII.NUL or else C = '/'\n+                          or else C = '-';\n+\n+                        if C in '1' .. '9' or else\n+                           C in 'a' .. 'z' or else\n+                           C in 'A' .. 'Z'\n+                        then\n+                           Storing (First_Stored + 1) := C;\n+                           Add_Switch_Component\n+                             (Storing (Storing'First .. First_Stored + 1));\n+\n+                        else\n+                           Last := 0;\n+                           return;\n+                        end if;\n+                     end loop;\n+\n+                     return;\n+\n+                  when 'e' =>\n+                     --  None of the -gnate switches (-gnatec and -gnatem)\n+                     --  need to be store in an ALI file.\n+\n+                     return;\n+\n+                  when 'i' =>\n+                     Storing (First_Stored) := 'i';\n+\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr > Max then\n+                        Last := 0;\n+                        return;\n+                     end if;\n+\n+                     C := Switch_Chars (Ptr);\n+\n+                     if C in '1' .. '5'\n+                       or else C = '8'\n+                       or else C = 'p'\n+                       or else C = 'f'\n+                       or else C = 'n'\n+                       or else C = 'w'\n+                     then\n+                        Storing (First_Stored + 1) := C;\n+                        Add_Switch_Component\n+                          (Storing (Storing'First .. First_Stored + 1));\n+                        Ptr := Ptr + 1;\n+\n+                     else\n+                        Last := 0;\n+                        return;\n+                     end if;\n+\n+                  --  -gnatR may be followed by '0', '1', '2' or '3',\n+                  --  then by 's'\n+\n+                  when 'R' =>\n+                     Last_Stored := First_Stored;\n+                     Storing (Last_Stored) := 'R';\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr <= Max\n+                       and then Switch_Chars (Ptr) in '0' .. '9'\n+                     then\n+                        C := Switch_Chars (Ptr);\n+\n+                        if C in '4' .. '9' then\n+                           Last := 0;\n+                           return;\n+\n+                        else\n+                           Last_Stored := Last_Stored + 1;\n+                           Storing (Last_Stored) := C;\n+                           Ptr := Ptr + 1;\n+\n+                           if Ptr <= Max\n+                             and then Switch_Chars (Ptr) = 's' then\n+                              Last_Stored := Last_Stored + 1;\n+                              Storing (Last_Stored) := 's';\n+                              Ptr := Ptr + 1;\n+                           end if;\n+                        end if;\n+                     end if;\n+\n+                     Add_Switch_Component\n+                       (Storing (Storing'First .. Last_Stored));\n+\n+                  --  Multiple switches\n+\n+                  when 'V' | 'w' | 'y' =>\n+                     Storing (First_Stored) := C;\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr > Max then\n+                        if C = 'y' then\n+                           Add_Switch_Component\n+                             (Storing (Storing'First .. First_Stored));\n+\n+                        else\n+                           Last := 0;\n+                           return;\n+                        end if;\n+                     end if;\n+\n+                     while Ptr <= Max loop\n+                        C := Switch_Chars (Ptr);\n+                        Ptr := Ptr + 1;\n+\n+                        --  'w' should be skipped in -gnatw\n+\n+                        if C /= 'w' or else Storing (First_Stored) /= 'w' then\n+\n+                           --  -gnatyMxxx\n+\n+                           if C = 'M'\n+                             and then Storing (First_Stored) = 'y' then\n+                              Last_Stored := First_Stored + 1;\n+                              Storing (Last_Stored) := 'M';\n+\n+                              while Ptr <= Max loop\n+                                 C := Switch_Chars (Ptr);\n+                                 exit when C not in '0' .. '9';\n+                                 Last_Stored := Last_Stored + 1;\n+                                 Storing (Last_Stored) := C;\n+                                 Ptr := Ptr + 1;\n+                              end loop;\n+\n+                              --  If there is no digit after -gnatyM,\n+                              --  the switch is invalid.\n+\n+                              if Last_Stored = First_Stored + 1 then\n+                                 Last := 0;\n+                                 return;\n+\n+                              else\n+                                 Add_Switch_Component\n+                                   (Storing (Storing'First .. Last_Stored));\n+                              end if;\n+\n+                           --  All other switches are -gnatxx\n+\n+                           else\n+                              Storing (First_Stored + 1) := C;\n+                              Add_Switch_Component\n+                                (Storing (Storing'First .. First_Stored + 1));\n+                           end if;\n+                        end if;\n+                     end loop;\n+\n+                  --  Not a valid switch\n+\n+                  when others =>\n+                     Last := 0;\n+                     return;\n+\n+               end case;\n+\n+         end case;\n+      end loop;\n+   end Normalize_Compiler_Switches;\n+\n+   function Normalize_Compiler_Switches\n+     (Switch_Chars : String)\n+      return         Argument_List\n+   is\n+      Last : Natural;\n+\n+   begin\n+      Normalize_Compiler_Switches (Switch_Chars, Global_Switches, Last);\n+\n+      if Last = 0 then\n+         return (1 .. 0 => null);\n+\n+      else\n+         return Global_Switches (Global_Switches'First .. Last);\n+      end if;\n+\n+   end Normalize_Compiler_Switches;\n+\n+   ------------------------\n+   -- Scan_Make_Switches --\n+   ------------------------\n+\n+   procedure Scan_Make_Switches (Switch_Chars : String) is\n+      Ptr : Integer := Switch_Chars'First;\n+      Max : Integer := Switch_Chars'Last;\n+      C   : Character := ' ';\n+\n+   begin\n+      --  Skip past the initial character (must be the switch character)\n+\n+      if Ptr = Max then\n+         raise Bad_Switch;\n+\n+      else\n+         Ptr := Ptr + 1;\n+      end if;\n+\n+      --  A little check, \"gnat\" at the start of a switch is not allowed\n+      --  except for the compiler (where it was already removed)\n+\n+      if Switch_Chars'Length >= Ptr + 3\n+        and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\"\n+      then\n+         Osint.Fail\n+           (\"invalid switch: \"\"\", Switch_Chars, \"\"\" (gnat not needed here)\");\n+      end if;\n+\n+      --  Loop to scan through switches given in switch string\n+\n+      while Ptr <= Max loop\n+         C := Switch_Chars (Ptr);\n+\n+         --  Processing for a switch\n+\n+         case C is\n+\n+         when 'a' =>\n+            Ptr := Ptr + 1;\n+            Check_Readonly_Files := True;\n+\n+         --  Processing for b switch\n+\n+         when 'b' =>\n+            Ptr := Ptr + 1;\n+            Bind_Only := True;\n+\n+         --  Processing for c switch\n+\n+         when 'c' =>\n+            Ptr := Ptr + 1;\n+            Compile_Only := True;\n+\n+         --  Processing for C switch\n+\n+         when 'C' =>\n+            Ptr := Ptr + 1;\n+            Create_Mapping_File := True;\n+\n+         --  Processing for d switch\n+\n+         when 'd' =>\n+\n+            --  Note: for the debug switch, the remaining characters in this\n+            --  switch field must all be debug flags, since all valid switch\n+            --  characters are also valid debug characters. This switch is not\n+            --  documented on purpose because it is only used by the\n+            --  implementors.\n+\n+            --  Loop to scan out debug flags\n+\n+            while Ptr < Max loop\n+               Ptr := Ptr + 1;\n+               C := Switch_Chars (Ptr);\n+               exit when C = ASCII.NUL or else C = '/' or else C = '-';\n+\n+               if C in '1' .. '9' or else\n+                  C in 'a' .. 'z' or else\n+                  C in 'A' .. 'Z'\n+               then\n+                  Set_Debug_Flag (C);\n+               else\n+                  raise Bad_Switch;\n+               end if;\n+            end loop;\n+\n+            --  Make sure Zero_Cost_Exceptions is set if gnatdX set. This\n+            --  is for backwards compatibility with old versions and usage.\n+\n+            if Debug_Flag_XX then\n+               Zero_Cost_Exceptions_Set := True;\n+               Zero_Cost_Exceptions_Val := True;\n+            end if;\n+\n+            return;\n+\n+         --  Processing for f switch\n+\n+         when 'f' =>\n+            Ptr := Ptr + 1;\n+            Force_Compilations := True;\n+\n+         --  Processing for h switch\n+\n+         when 'h' =>\n+            Ptr := Ptr + 1;\n+            Usage_Requested := True;\n+\n+         --  Processing for i switch\n+\n+         when 'i' =>\n+            Ptr := Ptr + 1;\n+            In_Place_Mode := True;\n+\n+         --  Processing for j switch\n+\n+         when 'j' =>\n+            Ptr := Ptr + 1;\n+\n+            declare\n+               Max_Proc : Pos;\n+            begin\n+               Scan_Pos (Switch_Chars, Max, Ptr, Max_Proc);\n+               Maximum_Processes := Positive (Max_Proc);\n+            end;\n+\n+         --  Processing for k switch\n+\n+         when 'k' =>\n+            Ptr := Ptr + 1;\n+            Keep_Going := True;\n+\n+         --  Processing for l switch\n+\n+         when 'l' =>\n+            Ptr := Ptr + 1;\n+            Link_Only := True;\n+\n+         when 'M' =>\n+            Ptr := Ptr + 1;\n+            List_Dependencies := True;\n+\n+         --  Processing for n switch\n+\n+         when 'n' =>\n+            Ptr := Ptr + 1;\n+            Do_Not_Execute := True;\n+\n+         --  Processing for o switch\n+\n+         when 'o' =>\n+            Ptr := Ptr + 1;\n+\n+            if Output_File_Name_Present then\n+               raise Too_Many_Output_Files;\n+            else\n+               Output_File_Name_Present := True;\n+            end if;\n+\n+         --  Processing for q switch\n+\n+         when 'q' =>\n+            Ptr := Ptr + 1;\n+            Quiet_Output := True;\n+\n+         --  Processing for s switch\n+\n+         when 's' =>\n+            Ptr := Ptr + 1;\n+            Check_Switches := True;\n+\n+         --  Processing for v switch\n+\n+         when 'v' =>\n+            Ptr := Ptr + 1;\n+            Verbose_Mode := True;\n+\n+         --  Processing for z switch\n+\n+         when 'z' =>\n+            Ptr := Ptr + 1;\n+            No_Main_Subprogram := True;\n+\n+         --  Ignore extra switch character\n+\n+         when '/' | '-' =>\n+            Ptr := Ptr + 1;\n+\n+         --  Anything else is an error (illegal switch character)\n+\n+         when others =>\n+            raise Bad_Switch;\n+\n+         end case;\n+      end loop;\n+\n+   exception\n+      when Bad_Switch =>\n+         Osint.Fail (\"invalid switch: \", (1 => C));\n+\n+      when Bad_Switch_Value =>\n+         Osint.Fail (\"numeric value too big for switch: \", (1 => C));\n+\n+      when Missing_Switch_Value =>\n+         Osint.Fail (\"missing numeric value for switch: \", (1 => C));\n+\n+      when Too_Many_Output_Files =>\n+         Osint.Fail (\"duplicate -o switch\");\n+\n+   end Scan_Make_Switches;\n+\n+end Switch.M;"}, {"sha": "f142fa40cdbcc6d2947509e3235602b23d9e5411", "filename": "gcc/ada/switch-m.ads", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-m.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ff454717964426d77fde0a0e94d29ac664a707/gcc%2Fada%2Fswitch-m.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.ads?ref=43ff454717964426d77fde0a0e94d29ac664a707", "patch": "@@ -0,0 +1,76 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S W I T C H - M                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package scans make switches. Note that the body of Usage must be\n+--  coordinated with the switches that are recognized by this package.\n+--  The Usage package also acts as the official documentation for the\n+--  switches that are recognized. In addition, package Debug documents\n+--  the otherwise undocumented debug switches that are also recognized.\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package Switch.M is\n+\n+   procedure Scan_Make_Switches (Switch_Chars : String);\n+   --  Procedures to scan out binder switches stored in the given string.\n+   --  The first character is known to be a valid switch character, and there\n+   --  are no blanks or other switch terminator characters in the string, so\n+   --  the entire string should consist of valid switch characters, except that\n+   --  an optional terminating NUL character is allowed. A bad switch causes\n+   --  a fatal error exit and control does not return. The call also sets\n+   --  Usage_Requested to True if a ? switch is encountered.\n+\n+   procedure Normalize_Compiler_Switches\n+     (Switch_Chars : String;\n+      Switches     : in out Argument_List_Access;\n+      Last         : out Natural);\n+   --  Takes a compiler switch which potentially is equivalent to more\n+   --  that one simple switches and returns the equivalent list of simple\n+   --  switches that are stored in an ALI file. Switches will be extended\n+   --  if initially null or too short. Last indicates the index in Switches\n+   --  of the last simple switch. Last is equal to zero, if it has been\n+   --  determined that Switch_Chars is ill-formed or does not contain any\n+   --  switch that should be stored in an ALI file. Otherwise, the list of\n+   --  simple switches is Switches (Switches'First .. Last).\n+   --\n+   --    Example: if Switch_Chars is equal to \"-gnatAwue\", then the list of\n+   --    simple switches will have 3 components: -gnatA, -gnatwu, -gnatwe.\n+   --\n+   --  The String_Access components of Switches should not be deallocated:\n+   --  they are shallow copies of components in a table in the body.\n+\n+   function Normalize_Compiler_Switches\n+     (Switch_Chars : String)\n+      return         Argument_List;\n+   --  Similar to the previous procedure. The return value is the list of\n+   --  simple switches. It may be an empty array if it has been determined\n+   --  that Switch_Chars is ill-formed or does not contain any switch that\n+   --  should be stored in an ALI file. The String_Access components of the\n+   --  returned value should not be deallocated.\n+\n+end Switch.M;"}]}