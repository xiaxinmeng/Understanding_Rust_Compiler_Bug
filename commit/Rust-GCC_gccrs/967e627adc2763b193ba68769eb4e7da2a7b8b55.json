{"sha": "967e627adc2763b193ba68769eb4e7da2a7b8b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3ZTYyN2FkYzI3NjNiMTkzYmE2ODc2OWViNGU3ZGEyYTdiOGI1NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-19T08:36:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-19T08:36:18Z"}, "message": "c-decl.c (grokdeclarator): Special case the creation of an index for a zero-length array.\n\n        * c-decl.c (grokdeclarator): Special case the creation of an\n        index for a zero-length array.\n        * tree.c (build_index_type): Revert Oct 20 change.\n\nFrom-SVN: r37558", "tree": {"sha": "968eb2abfe36e88e8e6ebef7becc08a93f529686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/968eb2abfe36e88e8e6ebef7becc08a93f529686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967e627adc2763b193ba68769eb4e7da2a7b8b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967e627adc2763b193ba68769eb4e7da2a7b8b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967e627adc2763b193ba68769eb4e7da2a7b8b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967e627adc2763b193ba68769eb4e7da2a7b8b55/comments", "author": null, "committer": null, "parents": [{"sha": "e9284adfd06bd4f01bdc8fa4f708d3b9850e82d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9284adfd06bd4f01bdc8fa4f708d3b9850e82d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9284adfd06bd4f01bdc8fa4f708d3b9850e82d2"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "1e26641cb4352041f90e7f9dff2a0af0a707c997", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=967e627adc2763b193ba68769eb4e7da2a7b8b55", "patch": "@@ -1,3 +1,9 @@\n+2000-11-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c (grokdeclarator): Special case the creation of an\n+\tindex for a zero-length array.\n+\t* tree.c (build_index_type): Revert Oct 20 change.\n+\n 2000-11-18  Marek Michalkiewicz  <marekm@linux.org.pl>\n \n \t* config/avr/avr-protos.h (avr_output_addr_vec_elt): Prototype."}, {"sha": "8868a11b39ef26e94ee2321b235f8317d600f8d5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=967e627adc2763b193ba68769eb4e7da2a7b8b55", "patch": "@@ -4494,27 +4494,41 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t    }\n \t\t}\n \n-\t      /* Convert size to index_type, so that if it is a variable\n-\t\t the computations will be done in the proper mode.  */\n-\t      itype = fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t   convert (index_type, size),\n-\t\t\t\t   convert (index_type, size_one_node)));\n-\n-\t      /* If that overflowed, the array is too big.\n-\t\t ??? While a size of INT_MAX+1 technically shouldn't cause\n-\t\t an overflow (because we subtract 1), the overflow is recorded\n-\t\t during the conversion to index_type, before the subtraction.\n-\t\t Handling this case seems like an unnecessary complication.  */\n-\t      if (TREE_OVERFLOW (itype))\n+\t      if (integer_zerop (size))\n \t\t{\n-\t\t  error (\"size of array `%s' is too large\", name);\n-\t\t  type = error_mark_node;\n-\t\t  continue;\n+\t\t  /* A zero-length array cannot be represented with an\n+\t\t     unsigned index type, which is what we'll get with\n+\t\t     build_index_type.  Create a signed range instead.  */\n+\t\t  itype = build_range_type (index_type, size,\n+\t\t\t\t\t    build_int_2 (-1, -1));\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Compute the maximum valid index, that is, size - 1.\n+\t\t     Do the calculation in index_type, so that if it is\n+\t\t     a variable the computations will be done in the\n+\t\t     proper mode.  */\n+\t          itype = fold (build (MINUS_EXPR, index_type,\n+\t\t\t\t       convert (index_type, size),\n+\t\t\t\t       convert (index_type, size_one_node)));\n+\n+\t          /* If that overflowed, the array is too big.\n+\t\t     ??? While a size of INT_MAX+1 technically shouldn't\n+\t\t     cause an overflow (because we subtract 1), the overflow\n+\t\t     is recorded during the conversion to index_type, before\n+\t\t     the subtraction.  Handling this case seems like an\n+\t\t     unnecessary complication.  */\n+\t\t  if (TREE_OVERFLOW (itype))\n+\t\t    {\n+\t\t      error (\"size of array `%s' is too large\", name);\n+\t\t      type = error_mark_node;\n+\t\t      continue;\n+\t\t    }\n \n-\t      if (size_varies)\n-\t\titype = variable_size (itype);\n-\t      itype = build_index_type (itype);\n+\t\t  if (size_varies)\n+\t\t    itype = variable_size (itype);\n+\t\t  itype = build_index_type (itype);\n+\t\t}\n \t    }\n \n #if 0"}, {"sha": "7652052662eeaa574647ab96069d86da4c4c7970", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967e627adc2763b193ba68769eb4e7da2a7b8b55/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=967e627adc2763b193ba68769eb4e7da2a7b8b55", "patch": "@@ -3676,33 +3676,18 @@ build_index_type (maxval)\n      tree maxval;\n {\n   register tree itype = make_node (INTEGER_TYPE);\n-  int no_hash = 0;\n \n   TREE_TYPE (itype) = sizetype;\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n-\n-  /* If sizetype is unsigned and the upper bound is negative, use a\n-     lower bound of one and an upper bound of zero.  */\n-  if (TREE_UNSIGNED (sizetype) && TREE_CODE (maxval) == INTEGER_CST\n-      && tree_int_cst_sgn (maxval) < 0)\n-    {\n-      TYPE_MIN_VALUE (itype) = size_one_node;\n-      TYPE_MAX_VALUE (itype) = size_zero_node;\n-      no_hash = 1;\n-    }\n-  else\n-    {\n-      TYPE_MIN_VALUE (itype) = size_zero_node;\n-      TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n-    }\n-\n+  TYPE_MIN_VALUE (itype) = size_zero_node;\n+  TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n   TYPE_MODE (itype) = TYPE_MODE (sizetype);\n   TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (sizetype);\n   TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n   TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (sizetype);\n \n-  if (!no_hash && host_integerp (maxval, 1))\n+  if (host_integerp (maxval, 1))\n     return type_hash_canon (tree_low_cst (maxval, 1), itype);\n   else\n     return itype;"}]}