{"sha": "dea44e569da296dab34c6f76b259c0844083a919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVhNDRlNTY5ZGEyOTZkYWIzNGM2Zjc2YjI1OWMwODQ0MDgzYTkxOQ==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2010-12-30T11:50:40Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-12-30T11:50:40Z"}, "message": "pdp11.md (movmemhi, movmemhi1): Correct constraints.\n\n* config/pdp11/pdp11.md (movmemhi, movmemhi1): Correct\nconstraints. \n* config/pdp11/pdp11.c (output_block_move): Rewrite.\n\nFrom-SVN: r168338", "tree": {"sha": "bfe07c93e4066d897c0ea26f36be593cf45a4349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe07c93e4066d897c0ea26f36be593cf45a4349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dea44e569da296dab34c6f76b259c0844083a919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea44e569da296dab34c6f76b259c0844083a919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea44e569da296dab34c6f76b259c0844083a919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea44e569da296dab34c6f76b259c0844083a919/comments", "author": null, "committer": null, "parents": [{"sha": "fd3ce292ae5796e7da960d332d50e34b6ab0fe91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3ce292ae5796e7da960d332d50e34b6ab0fe91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd3ce292ae5796e7da960d332d50e34b6ab0fe91"}], "stats": {"total": 327, "additions": 127, "deletions": 200}, "files": [{"sha": "a3e7fae64bc3c1d33c58e710dd71dde850991336", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea44e569da296dab34c6f76b259c0844083a919/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea44e569da296dab34c6f76b259c0844083a919/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dea44e569da296dab34c6f76b259c0844083a919", "patch": "@@ -1,3 +1,9 @@\n+2010-12-30  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/pdp11.md (movmemhi, movmemhi1): Correct\n+\tconstraints. \n+\t* config/pdp11/pdp11.c (output_block_move): Rewrite.\n+\n 2010-12-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47060"}, {"sha": "3a7f9d638e748c12819f1d9e09d4bc263b871154", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 116, "deletions": 195, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea44e569da296dab34c6f76b259c0844083a919/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea44e569da296dab34c6f76b259c0844083a919/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=dea44e569da296dab34c6f76b259c0844083a919", "patch": "@@ -1167,236 +1167,157 @@ output_block_move(rtx *operands)\n {\n     static int count = 0;\n     char buf[200];\n+    int unroll;\n+    int lastbyte = 0;\n     \n-    if (GET_CODE(operands[2]) == CONST_INT\n-\t&& ! optimize_size)\n+    /* Move of zero bytes is a NOP.  */\n+    if (operands[2] == const0_rtx)\n+      return \"\";\n+    \n+    /* Look for moves by small constant byte counts, those we'll\n+       expand to straight line code.  */\n+    if (CONSTANT_P (operands[2]))\n     {\n-\tif (INTVAL(operands[2]) < 16\n-\t    && INTVAL(operands[3]) == 1)\n+\tif (INTVAL (operands[2]) < 16\n+\t    && (!optimize_size || INTVAL (operands[2]) < 5)\n+\t    && INTVAL (operands[3]) == 1)\n \t{\n \t    register int i;\n \t    \n-\t    for (i = 1; i <= INTVAL(operands[2]); i++)\n+\t    for (i = 1; i <= INTVAL (operands[2]); i++)\n \t\toutput_asm_insn(\"movb (%1)+, (%0)+\", operands);\n \n \t    return \"\";\n \t}\n-\telse if (INTVAL(operands[2]) < 32)\n+\telse if (INTVAL(operands[2]) < 32\n+\t\t && (!optimize_size || INTVAL (operands[2]) < 9)\n+\t\t && INTVAL (operands[3]) >= 2)\n \t{\n \t    register int i;\n \t    \n-\t    for (i = 1; i <= INTVAL(operands[2])/2; i++)\n-\t\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\t    for (i = 1; i <= INTVAL (operands[2]) / 2; i++)\n+\t\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\t    if (INTVAL (operands[2]) & 1)\n+\t      output_asm_insn (\"movb (%1), (%0)\", operands);\n \t    \n-\t    /* may I assume that moved quantity is \n-\t       multiple of alignment ???\n-\n-\t       I HOPE SO !\n-\t    */\n-\n \t    return \"\";\n \t}\n-\t\n-\n-\t/* can do other clever things, maybe... */\n     }\n \n-    if (CONSTANT_P(operands[2]) )\n+    /* Ideally we'd look for moves that are multiples of 4 or 8\n+       bytes and handle those by unrolling the move loop.  That\n+       makes for a lot of code if done at run time, but it's ok\n+       for constant counts.  Also, for variable counts we have\n+       to worry about odd byte count with even aligned pointers.\n+       On 11/40 and up we handle that case; on older machines\n+       we don't and just use byte-wise moves all the time.  */\n+\n+    if (CONSTANT_P (operands[2]) )\n     {\n-\t/* just move count to scratch */\n-\toutput_asm_insn(\"mov %2, %4\", operands);\n+      if (INTVAL (operands[3]) < 2)\n+\tunroll = 0;\n+      else\n+\t{\n+\t  lastbyte = INTVAL (operands[2]) & 1;\n+\n+\t  if (optimize_size || INTVAL (operands[2]) & 2)\n+\t    unroll = 1;\n+\t  else if (INTVAL (operands[2]) & 4)\n+\t    unroll = 2;\n+\t  else\n+\t    unroll = 3;\n+\t}\n+      \n+      /* Loop count is byte count scaled by unroll.  */\n+      operands[2] = GEN_INT (INTVAL (operands[2]) >> unroll);\n+      output_asm_insn (\"mov %2, %4\", operands);\n     }\n     else\n     {\n-\t/* just clobber the register */\n+\t/* Variable byte count; use the input register\n+\t   as the scratch.  */\n \toperands[4] = operands[2];\n-    }\n-    \n \n-    /* switch over alignment */\n-    switch (INTVAL(operands[3]))\n-    {\n-      case 1:\n-\t\n-\t/* \n-\t  x:\n-\t  movb (%1)+, (%0)+\n-\t  \n-\t  if (TARGET_45)\n-\t     sob %4,x\n-\t  else\n-\t     dec %4\n-\t     bgt x\n+\t/* Decide whether to move by words, and check\n+\t   the byte count for zero.  */\n+\tif (TARGET_40_PLUS && INTVAL (operands[3]) > 1)\n+\t  {\n+\t    unroll = 1;\n+\t    output_asm_insn (\"asr %4\", operands);\n+\t  }\n+\telse\n+\t  {\n+\t    unroll = 0;\n+\t    output_asm_insn (\"tst %4\", operands);\n+\t  }\n+\tsprintf (buf, \"beq movestrhi%d\", count + 1);\n+\toutput_asm_insn (buf, NULL);\n+    }\n \n-\t*/\n+    /* Output the loop label.  */\n+    sprintf (buf, \"\\nmovestrhi%d:\", count);\n+    output_asm_insn (buf, NULL);\n \n-\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n-\toutput_asm_insn(buf, NULL);\n-\t\n-\toutput_asm_insn(\"movb (%1)+, (%0)+\", operands);\n-\t\n-\tif (TARGET_45)\n-\t{\n-\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n-\t    output_asm_insn(buf, operands);\n-\t}\n-\telse\n-\t{\n-\t    output_asm_insn(\"dec %4\", operands);\n-\t    \n-\t    sprintf(buf, \"bgt movestrhi%d\", count);\n-\t    output_asm_insn(buf, NULL);\n-\t}\n+    /* Output the appropriate move instructions.  */\n+    switch (unroll)\n+    {\n+      case 0:\n+\toutput_asm_insn (\"movb (%1)+, (%0)+\", operands);\n+\tbreak;\n \t\n-\tcount ++;\n+      case 1:\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n \tbreak;\n \t\n       case 2:\n-\t\n-\t/* \n-\t   asr %4\n-\n-\t   x:\n-\n-\t   mov (%1)+, (%0)+\n-\n-\t   if (TARGET_45)\n-\t     sob %4, x\n-\t   else\n-\t     dec %4\n-\t     bgt x\n-\t*/\n-\n-      generate_compact_code:\n-\n-\toutput_asm_insn(\"asr %4\", operands);\n-\n-\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n-\toutput_asm_insn(buf, NULL);\n-\t\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\t\n-\tif (TARGET_45)\n-\t{\n-\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n-\t    output_asm_insn(buf, operands);\n-\t}\n-\telse\n-\t{\n-\t    output_asm_insn(\"dec %4\", operands);\n-\t    \n-\t    sprintf(buf, \"bgt movestrhi%d\", count);\n-\t    output_asm_insn(buf, NULL);\n-\t}\n-\t\n-\tcount ++;\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n \tbreak;\n-\n-      case 4:\n-\t\n-\t/*\n-\n-\t   asr %4\n-\t   asr %4\n-\n-\t   x:\n-\n-\t   mov (%1)+, (%0)+\n-\t   mov (%1)+, (%0)+\n-\n-\t   if (TARGET_45)\n-\t     sob %4, x\n-\t   else\n-\t     dec %4\n-\t     bgt x\n-\t*/\n-\n-\tif (optimize_size)\n-\t    goto generate_compact_code;\n-\t\n-\toutput_asm_insn(\"asr %4\", operands);\n-\toutput_asm_insn(\"asr %4\", operands);\n-\n-\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n-\toutput_asm_insn(buf, NULL);\n \t\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\t\n-\tif (TARGET_45)\n-\t{\n-\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n-\t    output_asm_insn(buf, operands);\n-\t}\n-\telse\n-\t{\n-\t    output_asm_insn(\"dec %4\", operands);\n-\t    \n-\t    sprintf(buf, \"bgt movestrhi%d\", count);\n-\t    output_asm_insn(buf, NULL);\n-\t}\n-\t\n-\tcount ++;\n-\tbreak;\n-       \n       default:\n-\t\n-\t/*\n-\t   \n-\t   asr %4\n-\t   asr %4\n-\t   asr %4\n-\n-\t   x:\n-\n-\t   mov (%1)+, (%0)+\n-\t   mov (%1)+, (%0)+\n-\t   mov (%1)+, (%0)+\n-\t   mov (%1)+, (%0)+\n-\t   \n-\t   if (TARGET_45)\n-\t     sob %4, x\n-\t   else\n-\t     dec %4\n-\t     bgt x\n-\t*/\n-\n-\n-\tif (optimize_size)\n-\t    goto generate_compact_code;\n-\t\n-\toutput_asm_insn(\"asr %4\", operands);\n-\toutput_asm_insn(\"asr %4\", operands);\n-\toutput_asm_insn(\"asr %4\", operands);\n-\n-\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n-\toutput_asm_insn(buf, NULL);\n-\t\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n-\t\n-\tif (TARGET_45)\n-\t{\n-\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n-\t    output_asm_insn(buf, operands);\n-\t}\n-\telse\n-\t{\n-\t    output_asm_insn(\"dec %4\", operands);\n-\t    \n-\t    sprintf(buf, \"bgt movestrhi%d\", count);\n-\t    output_asm_insn(buf, NULL);\n-\t}\n-\t\n-\tcount ++;\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n \tbreak;\n-\t\n-\t;\n-\t\n     }\n+\n+    /* Output the decrement and test.  */\n+    if (TARGET_40_PLUS)\n+      {\n+\tsprintf (buf, \"sob %%4, movestrhi%d\", count);\n+\toutput_asm_insn (buf, operands);\n+      }\n+    else\n+      {\n+\toutput_asm_insn (\"dec %4\", operands);\n+\tsprintf (buf, \"bgt movestrhi%d\", count);\n+\toutput_asm_insn (buf, NULL);\n+      }\n+    count ++;\n+\n+    /* If constant odd byte count, move the last byte.  */\n+    if (lastbyte)\n+      output_asm_insn (\"movb (%1), (%0)\", operands);\n+    else if (!CONSTANT_P (operands[2]))\n+      {\n+\t/* Output the destination label for the zero byte count check.  */\n+\tsprintf (buf, \"\\nmovestrhi%d:\", count);\n+\toutput_asm_insn (buf, NULL);\n+\tcount++;\n     \n+\t/* If we did word moves, check for trailing last byte. */\n+\tif (unroll)\n+\t  {\n+\t    sprintf (buf, \"bcc movestrhi%d\", count);\n+\t    output_asm_insn (buf, NULL);\n+\t    output_asm_insn (\"movb (%1), (%0)\", operands);\n+\t    sprintf (buf, \"\\nmovestrhi%d:\", count);\n+\t    output_asm_insn (buf, NULL);\n+\t    count++;\n+\t  }\n+      }\n+\t     \n     return \"\";\n }\n "}, {"sha": "aa7512bc0632a9695c18b5fe2c088d5edbd1bb1c", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea44e569da296dab34c6f76b259c0844083a919/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea44e569da296dab34c6f76b259c0844083a919/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=dea44e569da296dab34c6f76b259c0844083a919", "patch": "@@ -321,7 +321,7 @@\n (define_expand \"movmemhi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"=g,g\")\n \t\t   (match_operand:BLK 1 \"general_operand\" \"g,g\"))\n-\t      (use (match_operand:HI 2 \"general_operand\" \"n,&mr\"))\n+\t      (use (match_operand:HI 2 \"general_operand\" \"n,mr\"))\n \t      (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n \t      (clobber (match_scratch:HI 4 \"=&r,X\"))\n \t      (clobber (match_dup 5))\n@@ -342,10 +342,10 @@\n }\")\n \n \n-(define_insn \"\" ; \"movmemhi\"\n-  [(set (mem:BLK (match_operand 0 \"pmode_register_operand\" \"+r,r\"))\n-\t(mem:BLK (match_operand 1 \"pmode_register_operand\" \"+r,r\")))\n-   (use (match_operand:HI 2 \"general_operand\" \"+n,&r\"))\n+(define_insn \"movmemhi1\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"r,r\"))\n+\t(mem:BLK (match_operand:HI 1 \"register_operand\" \"r,r\")))\n+   (use (match_operand:HI 2 \"general_operand\" \"n,r\"))\n    (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n    (clobber (match_scratch:HI 4 \"=&r,X\"))\n    (clobber (match_dup 0))"}]}