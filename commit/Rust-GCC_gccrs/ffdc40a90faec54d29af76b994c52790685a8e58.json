{"sha": "ffdc40a90faec54d29af76b994c52790685a8e58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZkYzQwYTkwZmFlYzU0ZDI5YWY3NmI5OTRjNTI3OTA2ODVhOGU1OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-05T08:28:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-07-05T08:28:36Z"}, "message": "tree-cfg.c (gimple_make_forwarder_block): Propagate location info on phi nodes if possible.\n\n\t* tree-cfg.c (gimple_make_forwarder_block): Propagate location info on\n\tphi nodes if possible.\n\t* tree-scalar-evolution.c (final_value_replacement_loop): Propagate\n\tlocation info on the newly created statement.\n\t* tree-ssa-loop-manip.c (create_iv): Propagate location info on the\n\tnewly created increment if needed.\n\nFrom-SVN: r273131", "tree": {"sha": "dfcc27a711785d7ec9afaeb709fc96338e4bb044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfcc27a711785d7ec9afaeb709fc96338e4bb044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffdc40a90faec54d29af76b994c52790685a8e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffdc40a90faec54d29af76b994c52790685a8e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffdc40a90faec54d29af76b994c52790685a8e58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffdc40a90faec54d29af76b994c52790685a8e58/comments", "author": null, "committer": null, "parents": [{"sha": "8d21ff6025652fa67085d94d5101cd699c57cf0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d21ff6025652fa67085d94d5101cd699c57cf0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d21ff6025652fa67085d94d5101cd699c57cf0b"}], "stats": {"total": 34, "additions": 31, "deletions": 3}, "files": [{"sha": "e6740b6b54c985d8d93648974c49524cc727184b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffdc40a90faec54d29af76b994c52790685a8e58", "patch": "@@ -1,3 +1,12 @@\n+2019-07-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-cfg.c (gimple_make_forwarder_block): Propagate location info on\n+\tphi nodes if possible.\n+\t* tree-scalar-evolution.c (final_value_replacement_loop): Propagate\n+\tlocation info on the newly created statement.\n+\t* tree-ssa-loop-manip.c (create_iv): Propagate location info on the\n+\tnewly created increment if needed.\n+\n 2019-07-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/78884"}, {"sha": "0396aa9bdd3e95800177670983831e824e0d66a5", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ffdc40a90faec54d29af76b994c52790685a8e58", "patch": "@@ -5756,13 +5756,17 @@ gimple_make_forwarder_block (edge fallthru)\n   basic_block dummy, bb;\n   tree var;\n   gphi_iterator gsi;\n+  bool forward_location_p;\n \n   dummy = fallthru->src;\n   bb = fallthru->dest;\n \n   if (single_pred_p (bb))\n     return;\n \n+  /* We can forward location info if we have only one predecessor.  */\n+  forward_location_p = single_pred_p (dummy);\n+\n   /* If we redirected a branch we must create new PHI nodes at the\n      start of BB.  */\n   for (gsi = gsi_start_phis (dummy); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -5774,7 +5778,8 @@ gimple_make_forwarder_block (edge fallthru)\n       new_phi = create_phi_node (var, bb);\n       gimple_phi_set_result (phi, copy_ssa_name (var, phi));\n       add_phi_arg (new_phi, gimple_phi_result (phi), fallthru,\n-\t\t   UNKNOWN_LOCATION);\n+\t\t   forward_location_p\n+\t\t   ? gimple_phi_arg_location (phi, 0) : UNKNOWN_LOCATION);\n     }\n \n   /* Add the arguments we have stored on edges.  */"}, {"sha": "b1c15dc11baa560b2dd89330a5eb5f65a4b56e6a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ffdc40a90faec54d29af76b994c52790685a8e58", "patch": "@@ -3680,6 +3680,8 @@ final_value_replacement_loop (struct loop *loop)\n \t\t\t\t\ttrue, GSI_SAME_STMT);\n \n       gassign *ass = gimple_build_assign (rslt, def);\n+      gimple_set_location (ass,\n+\t\t\t   gimple_phi_arg_location (phi, exit->dest_idx));\n       gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n       if (dump_file)\n \t{"}, {"sha": "f072418909bd08a0782037f14dd21615d2c01525", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffdc40a90faec54d29af76b994c52790685a8e58/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=ffdc40a90faec54d29af76b994c52790685a8e58", "patch": "@@ -126,10 +126,22 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n     gsi_insert_seq_on_edge_immediate (pe, stmts);\n \n   stmt = gimple_build_assign (va, incr_op, vb, step);\n+  /* Prevent the increment from inheriting a bogus location if it is not put\n+     immediately after a statement whose location is known.  */\n   if (after)\n-    gsi_insert_after (incr_pos, stmt, GSI_NEW_STMT);\n+    {\n+      if (gsi_end_p (*incr_pos))\n+\t{\n+\t  edge e = single_succ_edge (gsi_bb (*incr_pos));\n+\t  gimple_set_location (stmt, e->goto_locus);\n+\t}\n+      gsi_insert_after (incr_pos, stmt, GSI_NEW_STMT);\n+    }\n   else\n-    gsi_insert_before (incr_pos, stmt, GSI_NEW_STMT);\n+    {\n+      gimple_set_location (stmt, gimple_location (gsi_stmt (*incr_pos)));\n+      gsi_insert_before (incr_pos, stmt, GSI_NEW_STMT);\n+    }\n \n   initial = force_gimple_operand (base, &stmts, true, var);\n   if (stmts)"}]}