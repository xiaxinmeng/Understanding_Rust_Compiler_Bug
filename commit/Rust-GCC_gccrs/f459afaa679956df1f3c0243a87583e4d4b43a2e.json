{"sha": "f459afaa679956df1f3c0243a87583e4d4b43a2e", "node_id": "C_kwDOANBUbNoAKGY0NTlhZmFhNjc5OTU2ZGYxZjNjMDI0M2E4NzU4M2U0ZDRiNDNhMmU", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2022-11-17T15:34:57Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-12-06T13:58:48Z"}, "message": "ada: Accessibility code reorganization and bug fixes\n\nThis patch performs a large reorganization of accessibility related sources,\nand also corrects some latent issues with accessibility checks - namely the\ncalculation of accessibility levels for expanded iterators and type\nconversions.\n\ngcc/ada/\n\t* accessibility.adb, accessibility.ads\n\t(Accessibility_Message): Moved from sem_attr.\n\t(Apply_Accessibility_Check): Moved from checks.\n\t(Apply_Accessibility_Check_For_Allocator): Moved from exp_ch4 and\n\trenamed\n\t(Check_Return_Construct_Accessibility): Moved from sem_ch6.\n\t(Innermost_Master_Scope_Depth): Moved from sem_util. Add condition\n\tto detect expanded iterators.\n\t(Prefix_With_Safe_Accessibility_Level): Moved from sem_attr.\n\t(Static_Accessibility_Level): Moved from sem_util.\n\t(Has_Unconstrained_Access_Discriminants): Likewise.\n\t(Has_Anonymous_Access_Discriminant): Likewise.\n\t(Is_Anonymous_Access_Actual): Likewise.\n\t(Is_Special_Aliased_Formal_Access): Likewise.\n\t(Needs_Result_Accessibility_Level): Likewise.\n\t(Subprogram_Access_Level): Likewise.\n\t(Type_Access_Level): Likewise.\n\t(Deepest_Type_Access_Level): Likewise.\n\t(Effective_Extra_Accessibility): Likewise.\n\t(Get_Dynamic_Accessibility): Likewise.\n\t(Has_Access_Values): Likewise.\n\t(Accessibility_Level): Likewise.\n\t* exp_attr.adb (Access_Cases): Obtain the proper enclosing object\n\twhich applies to a given 'Access by looking through type\n\tconversions.\n\t* exp_ch4.adb (Apply_Accessibility_Check): Moved to accessibility.\n\t* exp_ch5.adb: Likewise.\n\t* exp_ch6.adb: Likewise.\n\t* exp_ch9.adb: Likewise.\n\t* exp_disp.adb: Likewise.\n\t* gen_il-fields.ads: Add new flag Comes_From_Iterator.\n\t* gen_il-gen-gen_nodes.adb: Add new flag Comes_From_Iterator for\n\tN_Object_Renaming_Declaration.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Mark object\n\trenamings resulting from iterator expansion with the new flag\n\tComes_From_Iterator.\n\t* sem_aggr.adb (Resolve_Container_Aggregate): Refine test.\n\t* sem_ch13.adb: Add dependence on the accessibility package.\n\t* sem_ch3.adb: Likewise.\n\t* sem_ch4.adb: Likewise.\n\t* sem_ch9.adb: Likewise.\n\t* sem_res.adb: Likewise.\n\t* sem_warn.adb: Likewise.\n\t* exp_ch3.adb: Likewise.\n\t* sem_attr.adb (Accessibility_Message): Moved to accessibility.\n\t(Prefix_With_Safe_Accessibility_Level): Likewise.\n\t* checks.adb, checks.ads (Apply_Accessibility_Check): Likewise.\n\t* sem_ch6.adb (Check_Return_Construct_Accessibility): Likewise.\n\t* sem_util.adb, sem_util.ads\n\t(Accessibility_Level): Likewise.\n\t(Deepest_Type_Access_Level): Likewise.\n\t(Effective_Extra_Accessibility): Likewise.\n\t(Get_Dynamic_Accessibility): Likewise.\n\t(Has_Access_Values): Likewise.\n\t(Has_Anonymous_Access_Discriminant): Likewise.\n\t(Static_Accessibility_Level): Likewise.\n\t(Has_Unconstrained_Access_Discriminants): Likewise.\n\t(Is_Anonymous_Access_Actual): Likewise.\n\t(Is_Special_Aliased_Formal_Access): Likewise.\n\t(Needs_Result_Accessibility_Level): Likewise.\n\t(Subprogram_Access_Level): Likewise.\n\t(Type_Access_Level): Likewise.\n\t* sinfo.ads: Document new flag Comes_From_Iterator.\n\t* gcc-interface/Make-lang.in: Add entry for new Accessibility package.", "tree": {"sha": "a94e0a86c619a30b2465ea1c941b3fcb3554d180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a94e0a86c619a30b2465ea1c941b3fcb3554d180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f459afaa679956df1f3c0243a87583e4d4b43a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f459afaa679956df1f3c0243a87583e4d4b43a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f459afaa679956df1f3c0243a87583e4d4b43a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f459afaa679956df1f3c0243a87583e4d4b43a2e/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c690f116b64be820cd47a554bffeadd9907fed2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c690f116b64be820cd47a554bffeadd9907fed2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c690f116b64be820cd47a554bffeadd9907fed2a"}], "stats": {"total": 5007, "additions": 2585, "deletions": 2422}, "files": [{"sha": "3162806c38f25d033a6286989549bc36ab96e36e", "filename": "gcc/ada/accessibility.adb", "status": "added", "additions": 2305, "deletions": 0, "changes": 2305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Faccessibility.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Faccessibility.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faccessibility.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -0,0 +1,2305 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        A C C E S S I B I L I T Y                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;          use Atree;\n+with Checks;         use Checks;\n+with Debug;          use Debug;\n+with Einfo;          use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Elists;         use Elists;\n+with Errout;         use Errout;\n+with Einfo.Utils;    use Einfo.Utils;\n+with Exp_Atag;       use Exp_Atag;\n+with Exp_Ch3;        use Exp_Ch3;\n+with Exp_Ch7;        use Exp_Ch7;\n+with Exp_Tss;        use Exp_Tss;\n+with Exp_Util;       use Exp_Util;\n+with Namet;          use Namet;\n+with Nlists;         use Nlists;\n+with Nmake;          use Nmake;\n+with Opt;            use Opt;\n+with Restrict;       use Restrict;\n+with Rtsfind;        use Rtsfind;\n+with Sem;            use Sem;\n+with Sem_Aux;        use Sem_Aux;\n+with Sem_Ch8;        use Sem_Ch8;\n+with Sem_Res;        use Sem_Res;\n+with Sem_Util;       use Sem_Util;\n+with Sinfo;          use Sinfo;\n+with Sinfo.Nodes;    use Sinfo.Nodes;\n+with Sinfo.Utils;    use Sinfo.Utils;\n+with Snames;         use Snames;\n+with Stand;          use Stand;\n+with Tbuild;         use Tbuild;\n+\n+package body Accessibility is\n+\n+   ---------------------------\n+   -- Accessibility_Message --\n+   ---------------------------\n+\n+   procedure Accessibility_Message (N : Node_Id; Typ : Entity_Id) is\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      P     : constant Node_Id    := Prefix (N);\n+      Indic : Node_Id             := Parent (Parent (N));\n+\n+   begin\n+      --  In an instance, this is a runtime check, but one we know will fail,\n+      --  so generate an appropriate warning.\n+\n+      if In_Instance_Body then\n+         Error_Msg_Warn := SPARK_Mode /= On;\n+         Error_Msg_F\n+           (\"non-local pointer cannot point to local object<<\", P);\n+         Error_Msg_F (\"\\Program_Error [<<\", P);\n+         Rewrite (N,\n+           Make_Raise_Program_Error (Loc,\n+             Reason => PE_Accessibility_Check_Failed));\n+         Set_Etype (N, Typ);\n+         return;\n+\n+      else\n+         Error_Msg_F (\"non-local pointer cannot point to local object\", P);\n+\n+         --  Check for case where we have a missing access definition\n+\n+         if Is_Record_Type (Current_Scope)\n+           and then\n+             Nkind (Parent (N)) in N_Discriminant_Association\n+                                 | N_Index_Or_Discriminant_Constraint\n+         then\n+            Indic := Parent (Parent (N));\n+            while Present (Indic)\n+              and then Nkind (Indic) /= N_Subtype_Indication\n+            loop\n+               Indic := Parent (Indic);\n+            end loop;\n+\n+            if Present (Indic) then\n+               Error_Msg_NE\n+                 (\"\\use an access definition for\" &\n+                  \" the access discriminant of&\",\n+                  N, Entity (Subtype_Mark (Indic)));\n+            end if;\n+         end if;\n+      end if;\n+   end Accessibility_Message;\n+\n+   -------------------------\n+   -- Accessibility_Level --\n+   -------------------------\n+\n+   function Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False;\n+      Allow_Alt_Model   : Boolean := True) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+\n+      function Accessibility_Level (Expr : Node_Id) return Node_Id\n+        is (Accessibility_Level (Expr, Level, In_Return_Context));\n+      --  Renaming of the enclosing function to facilitate recursive calls\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id;\n+      --  Construct an integer literal representing an accessibility level with\n+      --  its type set to Natural.\n+\n+      function Innermost_Master_Scope_Depth (N : Node_Id) return Uint;\n+      --  Returns the scope depth of the given node's innermost enclosing scope\n+      --  (effectively the accessibility level of the innermost enclosing\n+      --  master).\n+\n+      function Function_Call_Or_Allocator_Level (N : Node_Id) return Node_Id;\n+      --  Centralized processing of subprogram calls which may appear in prefix\n+      --  notation.\n+\n+      function Typ_Access_Level (Typ : Entity_Id) return Uint\n+        is (Type_Access_Level (Typ, Allow_Alt_Model));\n+      --  Renaming of Type_Access_Level with Allow_Alt_Model specified to avoid\n+      --  passing the parameter specifically in every call.\n+\n+      ----------------------------------\n+      -- Innermost_Master_Scope_Depth --\n+      ----------------------------------\n+\n+      function Innermost_Master_Scope_Depth (N : Node_Id) return Uint is\n+         Encl_Scop           : Entity_Id;\n+         Ent                 : Entity_Id;\n+         Node_Par            : Node_Id := Parent (N);\n+         Master_Lvl_Modifier : Int     := 0;\n+\n+      begin\n+         --  Locate the nearest enclosing node (by traversing Parents)\n+         --  that Defining_Entity can be applied to, and return the\n+         --  depth of that entity's nearest enclosing scope.\n+\n+         --  The RM 7.6.1(3) definition of \"master\" includes statements\n+         --  and conditions for loops among other things. Are these cases\n+         --  detected properly ???\n+\n+         while Present (Node_Par) loop\n+            Ent := Defining_Entity_Or_Empty (Node_Par);\n+\n+            if Present (Ent) then\n+               Encl_Scop := Find_Enclosing_Scope (Ent);\n+\n+               --  Ignore transient scopes made during expansion while also\n+               --  taking into account certain expansions - like iterators\n+               --  which get expanded into renamings and thus not marked\n+               --  as coming from source.\n+\n+               if Comes_From_Source (Node_Par)\n+                 or else (Nkind (Node_Par) = N_Object_Renaming_Declaration\n+                           and then Comes_From_Iterator (Node_Par))\n+               then\n+                  --  Note that in some rare cases the scope depth may not be\n+                  --  set, for example, when we are in the middle of analyzing\n+                  --  a type and the enclosing scope is said type. So, instead,\n+                  --  continue to move up the parent chain since the scope\n+                  --  depth of the type's parent is the same as that of the\n+                  --  type.\n+\n+                  if not Scope_Depth_Set (Encl_Scop) then\n+                     pragma Assert (Nkind (Parent (Encl_Scop))\n+                                     = N_Full_Type_Declaration);\n+                  else\n+                     return\n+                       Scope_Depth (Encl_Scop) + Master_Lvl_Modifier;\n+                  end if;\n+               end if;\n+\n+            --  For a return statement within a function, return\n+            --  the depth of the function itself. This is not just\n+            --  a small optimization, but matters when analyzing\n+            --  the expression in an expression function before\n+            --  the body is created.\n+\n+            elsif Nkind (Node_Par) in N_Extended_Return_Statement\n+                                    | N_Simple_Return_Statement\n+            then\n+               return Scope_Depth (Enclosing_Subprogram (Node_Par));\n+\n+            --  Statements are counted as masters\n+\n+            elsif Is_Master (Node_Par) then\n+               Master_Lvl_Modifier := Master_Lvl_Modifier + 1;\n+\n+            end if;\n+\n+            Node_Par := Parent (Node_Par);\n+         end loop;\n+\n+         --  Should never reach the following return\n+\n+         pragma Assert (False);\n+\n+         return Scope_Depth (Current_Scope) + 1;\n+      end Innermost_Master_Scope_Depth;\n+\n+      ------------------------\n+      -- Make_Level_Literal --\n+      ------------------------\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id is\n+         Result : constant Node_Id := Make_Integer_Literal (Loc, Level);\n+\n+      begin\n+         Set_Etype (Result, Standard_Natural);\n+         return Result;\n+      end Make_Level_Literal;\n+\n+      --------------------------------------\n+      -- Function_Call_Or_Allocator_Level --\n+      --------------------------------------\n+\n+      function Function_Call_Or_Allocator_Level (N : Node_Id) return Node_Id is\n+         Par      : Node_Id;\n+         Prev_Par : Node_Id;\n+      begin\n+         --  Results of functions are objects, so we either get the\n+         --  accessibility of the function or, in case of a call which is\n+         --  indirect, the level of the access-to-subprogram type.\n+\n+         --  This code looks wrong ???\n+\n+         if Nkind (N) = N_Function_Call\n+           and then Ada_Version < Ada_2005\n+         then\n+            if Is_Entity_Name (Name (N)) then\n+               return Make_Level_Literal\n+                        (Subprogram_Access_Level (Entity (Name (N))));\n+            else\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (Prefix (Name (N)))));\n+            end if;\n+\n+         --  We ignore coextensions as they cannot be implemented under the\n+         --  \"small-integer\" model.\n+\n+         elsif Nkind (N) = N_Allocator\n+           and then (Is_Static_Coextension (N)\n+                      or else Is_Dynamic_Coextension (N))\n+         then\n+            return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+         end if;\n+\n+         --  Named access types have a designated level\n+\n+         if Is_Named_Access_Type (Etype (N)) then\n+            return Make_Level_Literal (Typ_Access_Level (Etype (N)));\n+\n+         --  Otherwise, the level is dictated by RM 3.10.2 (10.7/3)\n+\n+         else\n+            --  Check No_Dynamic_Accessibility_Checks restriction override for\n+            --  alternative accessibility model.\n+\n+            if Allow_Alt_Model\n+              and then No_Dynamic_Accessibility_Checks_Enabled (N)\n+              and then Is_Anonymous_Access_Type (Etype (N))\n+            then\n+               --  In the alternative model the level is that of the\n+               --  designated type.\n+\n+               if Debug_Flag_Underscore_B then\n+                  return Make_Level_Literal (Typ_Access_Level (Etype (N)));\n+\n+               --  For function calls the level is that of the innermost\n+               --  master, otherwise (for allocators etc.) we get the level\n+               --  of the corresponding anonymous access type, which is\n+               --  calculated through the normal path of execution.\n+\n+               elsif Nkind (N) = N_Function_Call then\n+                  return Make_Level_Literal\n+                           (Innermost_Master_Scope_Depth (Expr));\n+               end if;\n+            end if;\n+\n+            if Nkind (N) = N_Function_Call then\n+               --  Dynamic checks are generated when we are within a return\n+               --  value or we are in a function call within an anonymous\n+               --  access discriminant constraint of a return object (signified\n+               --  by In_Return_Context) on the side of the callee.\n+\n+               --  So, in this case, return accessibility level of the\n+               --  enclosing subprogram.\n+\n+               if In_Return_Value (N)\n+                 or else In_Return_Context\n+               then\n+                  return Make_Level_Literal\n+                           (Subprogram_Access_Level (Current_Subprogram));\n+               end if;\n+            end if;\n+\n+            --  When the call is being dereferenced the level is that of the\n+            --  enclosing master of the dereferenced call.\n+\n+            if Nkind (Parent (N)) in N_Explicit_Dereference\n+                                   | N_Indexed_Component\n+                                   | N_Selected_Component\n+            then\n+               return Make_Level_Literal\n+                        (Innermost_Master_Scope_Depth (Expr));\n+            end if;\n+\n+            --  Find any relevant enclosing parent nodes that designate an\n+            --  object being initialized.\n+\n+            --  Note: The above is only relevant if the result is used \"in its\n+            --  entirety\" as RM 3.10.2 (10.2/3) states. However, this is\n+            --  accounted for in the case statement in the main body of\n+            --  Accessibility_Level for N_Selected_Component.\n+\n+            Par      := Parent (Expr);\n+            Prev_Par := Empty;\n+            while Present (Par) loop\n+               --  Detect an expanded implicit conversion, typically this\n+               --  occurs on implicitly converted actuals in calls.\n+\n+               --  Does this catch all implicit conversions ???\n+\n+               if Nkind (Par) = N_Type_Conversion\n+                 and then Is_Named_Access_Type (Etype (Par))\n+               then\n+                  return Make_Level_Literal\n+                           (Typ_Access_Level (Etype (Par)));\n+               end if;\n+\n+               --  Jump out when we hit an object declaration or the right-hand\n+               --  side of an assignment, or a construct such as an aggregate\n+               --  subtype indication which would be the result is not used\n+               --  \"in its entirety.\"\n+\n+               exit when Nkind (Par) in N_Object_Declaration\n+                           or else (Nkind (Par) = N_Assignment_Statement\n+                                     and then Name (Par) /= Prev_Par);\n+\n+               Prev_Par := Par;\n+               Par      := Parent (Par);\n+            end loop;\n+\n+            --  Assignment statements are handled in a similar way in\n+            --  accordance to the left-hand part. However, strictly speaking,\n+            --  this is illegal according to the RM, but this change is needed\n+            --  to pass an ACATS C-test and is useful in general ???\n+\n+            case Nkind (Par) is\n+               when N_Object_Declaration =>\n+                  return Make_Level_Literal\n+                           (Scope_Depth\n+                             (Scope (Defining_Identifier (Par))));\n+\n+               when N_Assignment_Statement =>\n+                  --  Return the accessibility level of the left-hand part\n+\n+                  return Accessibility_Level\n+                           (Expr              => Name (Par),\n+                            Level             => Object_Decl_Level,\n+                            In_Return_Context => In_Return_Context);\n+\n+               when others =>\n+                  return Make_Level_Literal\n+                           (Innermost_Master_Scope_Depth (Expr));\n+            end case;\n+         end if;\n+      end Function_Call_Or_Allocator_Level;\n+\n+      --  Local variables\n+\n+      E   : Node_Id := Original_Node (Expr);\n+      Pre : Node_Id;\n+\n+   --  Start of processing for Accessibility_Level\n+\n+   begin\n+      --  We could be looking at a reference to a formal due to the expansion\n+      --  of entries and other cases, so obtain the renaming if necessary.\n+\n+      if Present (Param_Entity (Expr)) then\n+         E := Param_Entity (Expr);\n+      end if;\n+\n+      --  Extract the entity\n+\n+      if Nkind (E) in N_Has_Entity and then Present (Entity (E)) then\n+         E := Entity (E);\n+\n+         --  Deal with a possible renaming of a private protected component\n+\n+         if Ekind (E) in E_Constant | E_Variable and then Is_Prival (E) then\n+            E := Prival_Link (E);\n+         end if;\n+      end if;\n+\n+      --  Perform the processing on the expression\n+\n+      case Nkind (E) is\n+         --  The level of an aggregate is that of the innermost master that\n+         --  evaluates it as defined in RM 3.10.2 (10/4).\n+\n+         when N_Aggregate =>\n+            return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n+\n+         --  The accessibility level is that of the access type, except for an\n+         --  anonymous allocators which have special rules defined in RM 3.10.2\n+         --  (14/3).\n+\n+         when N_Allocator =>\n+            return Function_Call_Or_Allocator_Level (E);\n+\n+         --  We could reach this point for two reasons. Either the expression\n+         --  applies to a special attribute ('Loop_Entry, 'Result, or 'Old), or\n+         --  we are looking at the access attributes directly ('Access,\n+         --  'Address, or 'Unchecked_Access).\n+\n+         when N_Attribute_Reference =>\n+            Pre := Original_Node (Prefix (E));\n+\n+            --  Regular 'Access attribute presence means we have to look at the\n+            --  prefix.\n+\n+            if Attribute_Name (E) = Name_Access then\n+               return Accessibility_Level (Prefix (E));\n+\n+            --  Unchecked or unrestricted attributes have unlimited depth\n+\n+            elsif Attribute_Name (E) in Name_Address\n+                                      | Name_Unchecked_Access\n+                                      | Name_Unrestricted_Access\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  'Access can be taken further against other special attributes,\n+            --  so handle these cases explicitly.\n+\n+            elsif Attribute_Name (E)\n+                    in Name_Old | Name_Loop_Entry | Name_Result\n+            then\n+               --  Named access types\n+\n+               if Is_Named_Access_Type (Etype (Pre)) then\n+                  return Make_Level_Literal\n+                           (Typ_Access_Level (Etype (Pre)));\n+\n+               --  Anonymous access types\n+\n+               elsif Nkind (Pre) in N_Has_Entity\n+                 and then Ekind (Entity (Pre)) not in Subprogram_Kind\n+                 and then Present (Get_Dynamic_Accessibility (Entity (Pre)))\n+                 and then Level = Dynamic_Level\n+               then\n+                  return New_Occurrence_Of\n+                           (Get_Dynamic_Accessibility (Entity (Pre)), Loc);\n+\n+               --  Otherwise the level is treated in a similar way as\n+               --  aggregates according to RM 6.1.1 (35.1/4) which concerns\n+               --  an implicit constant declaration - in turn defining the\n+               --  accessibility level to be that of the implicit constant\n+               --  declaration.\n+\n+               else\n+                  return Make_Level_Literal\n+                           (Innermost_Master_Scope_Depth (Expr));\n+               end if;\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+         --  This is the \"base case\" for accessibility level calculations which\n+         --  means we are near the end of our recursive traversal.\n+\n+         when N_Defining_Identifier =>\n+            --  A dynamic check is performed on the side of the callee when we\n+            --  are within a return statement, so return a library-level\n+            --  accessibility level to null out checks on the side of the\n+            --  caller.\n+\n+            if Is_Explicitly_Aliased (E)\n+              and then (In_Return_Context\n+                         or else (Level /= Dynamic_Level\n+                                   and then In_Return_Value (Expr)))\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  Something went wrong and an extra accessibility formal has not\n+            --  been generated when one should have ???\n+\n+            elsif Is_Formal (E)\n+              and then No (Get_Dynamic_Accessibility (E))\n+              and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  Stand-alone object of an anonymous access type \"SAOAAT\"\n+\n+            elsif (Is_Formal (E)\n+                    or else Ekind (E) in E_Variable\n+                                       | E_Constant)\n+              and then Present (Get_Dynamic_Accessibility (E))\n+              and then (Level = Dynamic_Level\n+                         or else Level = Zero_On_Dynamic_Level)\n+            then\n+               if Level = Zero_On_Dynamic_Level then\n+                  return Make_Level_Literal\n+                           (Scope_Depth (Standard_Standard));\n+               end if;\n+\n+               --  No_Dynamic_Accessibility_Checks restriction override for\n+               --  alternative accessibility model.\n+\n+               if Allow_Alt_Model\n+                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n+               then\n+                  --  In the alternative model the level is that of the\n+                  --  designated type entity's context.\n+\n+                  if Debug_Flag_Underscore_B then\n+                     return Make_Level_Literal (Typ_Access_Level (Etype (E)));\n+\n+                  --  Otherwise the level depends on the entity's context\n+\n+                  elsif Is_Formal (E) then\n+                     return Make_Level_Literal\n+                              (Subprogram_Access_Level\n+                                (Enclosing_Subprogram (E)));\n+                  else\n+                     return Make_Level_Literal\n+                              (Scope_Depth (Enclosing_Dynamic_Scope (E)));\n+                  end if;\n+               end if;\n+\n+               --  Return the dynamic level in the normal case\n+\n+               return New_Occurrence_Of\n+                        (Get_Dynamic_Accessibility (E), Loc);\n+\n+            --  Initialization procedures have a special extra accessibility\n+            --  parameter associated with the level at which the object\n+            --  being initialized exists\n+\n+            elsif Ekind (E) = E_Record_Type\n+              and then Is_Limited_Record (E)\n+              and then Current_Scope = Init_Proc (E)\n+              and then Present (Init_Proc_Level_Formal (Current_Scope))\n+            then\n+               return New_Occurrence_Of\n+                        (Init_Proc_Level_Formal (Current_Scope), Loc);\n+\n+            --  Current instance of the type is deeper than that of the type\n+            --  according to RM 3.10.2 (21).\n+\n+            elsif Is_Type (E) then\n+               --  When restriction No_Dynamic_Accessibility_Checks is active\n+               --  along with -gnatd_b.\n+\n+               if Allow_Alt_Model\n+                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n+                 and then Debug_Flag_Underscore_B\n+               then\n+                  return Make_Level_Literal (Typ_Access_Level (E));\n+               end if;\n+\n+               --  Normal path\n+\n+               return Make_Level_Literal (Typ_Access_Level (E) + 1);\n+\n+            --  Move up the renamed entity or object if it came from source\n+            --  since expansion may have created a dummy renaming under\n+            --  certain circumstances.\n+\n+            --  Note: We check if the original node of the renaming comes\n+            --  from source because the node may have been rewritten.\n+\n+            elsif Present (Renamed_Entity_Or_Object (E))\n+              and then Comes_From_Source\n+                (Original_Node (Renamed_Entity_Or_Object (E)))\n+            then\n+               return Accessibility_Level (Renamed_Entity_Or_Object (E));\n+\n+            --  Named access types get their level from their associated type\n+\n+            elsif Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (E)));\n+\n+            --  Check if E is an expansion-generated renaming of an iterator\n+            --  by examining Related_Expression. If so, determine the\n+            --  accessibility level based on the original expression.\n+\n+            elsif Ekind (E) in E_Constant | E_Variable\n+              and then Present (Related_Expression (E))\n+            then\n+               return Accessibility_Level (Related_Expression (E));\n+\n+            elsif Level = Dynamic_Level\n+               and then Ekind (E) in E_In_Parameter | E_In_Out_Parameter\n+               and then Present (Init_Proc_Level_Formal (Scope (E)))\n+            then\n+               return New_Occurrence_Of\n+                        (Init_Proc_Level_Formal (Scope (E)), Loc);\n+\n+            --  Normal object - get the level of the enclosing scope\n+\n+            else\n+               return Make_Level_Literal\n+                        (Scope_Depth (Enclosing_Dynamic_Scope (E)));\n+            end if;\n+\n+         --  Handle indexed and selected components including the special cases\n+         --  whereby there is an implicit dereference, a component of a\n+         --  composite type, or a function call in prefix notation.\n+\n+         --  We don't handle function calls in prefix notation correctly ???\n+\n+         when N_Indexed_Component | N_Selected_Component | N_Slice =>\n+            Pre := Prefix (E);\n+\n+            --  Fetch the original node when the prefix comes from the result\n+            --  of expanding a function call since we want to find the level\n+            --  of the original source call.\n+\n+            if not Comes_From_Source (Pre)\n+              and then Nkind (Original_Node (Pre)) = N_Function_Call\n+            then\n+               Pre := Original_Node (Pre);\n+            end if;\n+\n+            --  When E is an indexed component or selected component and\n+            --  the current Expr is a function call, we know that we are\n+            --  looking at an expanded call in prefix notation.\n+\n+            if Nkind (Expr) = N_Function_Call then\n+               return Function_Call_Or_Allocator_Level (Expr);\n+\n+            --  If the prefix is a named access type, then we are dealing\n+            --  with an implicit deferences. In that case the level is that\n+            --  of the named access type in the prefix.\n+\n+            elsif Is_Named_Access_Type (Etype (Pre)) then\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (Pre)));\n+\n+            --  The current expression is a named access type, so there is no\n+            --  reason to look at the prefix. Instead obtain the level of E's\n+            --  named access type.\n+\n+            elsif Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (E)));\n+\n+            --  A nondiscriminant selected component where the component\n+            --  is an anonymous access type means that its associated\n+            --  level is that of the containing type - see RM 3.10.2 (16).\n+\n+            --  Note that when restriction No_Dynamic_Accessibility_Checks is\n+            --  in effect we treat discriminant components as regular\n+            --  components.\n+\n+            elsif\n+              (Nkind (E) = N_Selected_Component\n+                and then Ekind (Etype (E))   =  E_Anonymous_Access_Type\n+                and then Ekind (Etype (Pre)) /= E_Anonymous_Access_Type\n+                and then (not (Nkind (Selector_Name (E)) in N_Has_Entity\n+                                and then Ekind (Entity (Selector_Name (E)))\n+                                           = E_Discriminant)\n+\n+                           --  The alternative accessibility models both treat\n+                           --  discriminants as regular components.\n+\n+                           or else (No_Dynamic_Accessibility_Checks_Enabled (E)\n+                                     and then Allow_Alt_Model)))\n+\n+              --  Arrays featuring components of anonymous access components\n+              --  get their corresponding level from their containing type's\n+              --  declaration.\n+\n+              or else\n+                (Nkind (E) = N_Indexed_Component\n+                  and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n+                  and then Ekind (Etype (Pre)) in Array_Kind\n+                  and then Ekind (Component_Type (Base_Type (Etype (Pre))))\n+                             = E_Anonymous_Access_Type)\n+            then\n+               --  When restriction No_Dynamic_Accessibility_Checks is active\n+               --  and -gnatd_b set, the level is that of the designated type.\n+\n+               if Allow_Alt_Model\n+                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n+                 and then Debug_Flag_Underscore_B\n+               then\n+                  return Make_Level_Literal\n+                           (Typ_Access_Level (Etype (E)));\n+               end if;\n+\n+               --  Otherwise proceed normally\n+\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (Prefix (E))));\n+\n+            --  The accessibility calculation routine that handles function\n+            --  calls (Function_Call_Level) assumes, in the case the\n+            --  result is of an anonymous access type, that the result will be\n+            --  used \"in its entirety\" when the call is present within an\n+            --  assignment or object declaration.\n+\n+            --  To properly handle cases where the result is not used in its\n+            --  entirety, we test if the prefix of the component in question is\n+            --  a function call, which tells us that one of its components has\n+            --  been identified and is being accessed. Therefore we can\n+            --  conclude that the result is not used \"in its entirety\"\n+            --  according to RM 3.10.2 (10.2/3).\n+\n+            elsif Nkind (Pre) = N_Function_Call\n+              and then not Is_Named_Access_Type (Etype (Pre))\n+            then\n+               --  Dynamic checks are generated when we are within a return\n+               --  value or we are in a function call within an anonymous\n+               --  access discriminant constraint of a return object (signified\n+               --  by In_Return_Context) on the side of the callee.\n+\n+               --  So, in this case, return a library accessibility level to\n+               --  null out the check on the side of the caller.\n+\n+               if (In_Return_Value (E)\n+                    or else In_Return_Context)\n+                 and then Level /= Dynamic_Level\n+               then\n+                  return Make_Level_Literal\n+                           (Scope_Depth (Standard_Standard));\n+               end if;\n+\n+               return Make_Level_Literal\n+                        (Innermost_Master_Scope_Depth (Expr));\n+\n+            --  Otherwise, continue recursing over the expression prefixes\n+\n+            else\n+               return Accessibility_Level (Prefix (E));\n+            end if;\n+\n+         --  Qualified expressions\n+\n+         when N_Qualified_Expression =>\n+            if Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (E)));\n+            else\n+               return Accessibility_Level (Expression (E));\n+            end if;\n+\n+         --  Handle function calls\n+\n+         when N_Function_Call =>\n+            return Function_Call_Or_Allocator_Level (E);\n+\n+         --  Explicit dereference accessibility level calculation\n+\n+         when N_Explicit_Dereference =>\n+            Pre := Original_Node (Prefix (E));\n+\n+            --  The prefix is a named access type so the level is taken from\n+            --  its type.\n+\n+            if Is_Named_Access_Type (Etype (Pre)) then\n+               return Make_Level_Literal (Typ_Access_Level (Etype (Pre)));\n+\n+            --  Otherwise, recurse deeper\n+\n+            else\n+               return Accessibility_Level (Prefix (E));\n+            end if;\n+\n+         --  Type conversions\n+\n+         when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+            --  View conversions are special in that they require use to\n+            --  inspect the expression of the type conversion.\n+\n+            --  Allocators of anonymous access types are internally generated,\n+            --  so recurse deeper in that case as well.\n+\n+            if Is_View_Conversion (E)\n+              or else Ekind (Etype (E)) = E_Anonymous_Access_Type\n+            then\n+               return Accessibility_Level (Expression (E));\n+\n+            --  We don't care about the master if we are looking at a named\n+            --  access type.\n+\n+            elsif Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Typ_Access_Level (Etype (E)));\n+\n+            --  In section RM 3.10.2 (10/4) the accessibility rules for\n+            --  aggregates and value conversions are outlined. Are these\n+            --  followed in the case of initialization of an object ???\n+\n+            --  Should use Innermost_Master_Scope_Depth ???\n+\n+            else\n+               return Accessibility_Level (Current_Scope);\n+            end if;\n+\n+         --  Default to the type accessibility level for the type of the\n+         --  expression's entity.\n+\n+         when others =>\n+            return Make_Level_Literal (Typ_Access_Level (Etype (E)));\n+      end case;\n+   end Accessibility_Level;\n+\n+   -------------------------------\n+   -- Apply_Accessibility_Check --\n+   -------------------------------\n+\n+   procedure Apply_Accessibility_Check\n+     (N           : Node_Id;\n+      Typ         : Entity_Id;\n+      Insert_Node : Node_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Check_Cond  : Node_Id;\n+      Param_Ent   : Entity_Id := Param_Entity (N);\n+      Param_Level : Node_Id;\n+      Type_Level  : Node_Id;\n+\n+   begin\n+      --  Verify we haven't tried to add a dynamic accessibility check when we\n+      --  shouldn't.\n+\n+      pragma Assert (not No_Dynamic_Accessibility_Checks_Enabled (N));\n+\n+      if Ada_Version >= Ada_2012\n+         and then No (Param_Ent)\n+         and then Is_Entity_Name (N)\n+         and then Ekind (Entity (N)) in E_Constant | E_Variable\n+         and then Present (Effective_Extra_Accessibility (Entity (N)))\n+      then\n+         Param_Ent := Entity (N);\n+         while Present (Renamed_Object (Param_Ent)) loop\n+            --  Renamed_Object must return an Entity_Name here\n+            --  because of preceding \"Present (E_E_A (...))\" test.\n+\n+            Param_Ent := Entity (Renamed_Object (Param_Ent));\n+         end loop;\n+      end if;\n+\n+      if Inside_A_Generic then\n+         return;\n+\n+      --  Only apply the run-time check if the access parameter has an\n+      --  associated extra access level parameter and when accessibility checks\n+      --  are enabled.\n+\n+      elsif Present (Param_Ent)\n+         and then Present (Get_Dynamic_Accessibility (Param_Ent))\n+         and then not Accessibility_Checks_Suppressed (Param_Ent)\n+         and then not Accessibility_Checks_Suppressed (Typ)\n+      then\n+         --  Obtain the parameter's accessibility level\n+\n+         Param_Level :=\n+           New_Occurrence_Of (Get_Dynamic_Accessibility (Param_Ent), Loc);\n+\n+         --  Use the dynamic accessibility parameter for the function's result\n+         --  when one has been created instead of statically referring to the\n+         --  deepest type level so as to appropriatly handle the rules for\n+         --  RM 3.10.2 (10.1/3).\n+\n+         if Ekind (Scope (Param_Ent)) = E_Function\n+           and then In_Return_Value (N)\n+           and then Ekind (Typ) = E_Anonymous_Access_Type\n+         then\n+            --  Associate the level of the result type to the extra result\n+            --  accessibility parameter belonging to the current function.\n+\n+            if Present (Extra_Accessibility_Of_Result (Scope (Param_Ent))) then\n+               Type_Level :=\n+                 New_Occurrence_Of\n+                   (Extra_Accessibility_Of_Result (Scope (Param_Ent)), Loc);\n+\n+            --  In Ada 2005 and earlier modes, a result extra accessibility\n+            --  parameter is not generated and no dynamic check is performed.\n+\n+            else\n+               return;\n+            end if;\n+\n+         --  Otherwise get the type's accessibility level normally\n+\n+         else\n+            Type_Level :=\n+              Make_Integer_Literal (Loc, Deepest_Type_Access_Level (Typ));\n+         end if;\n+\n+         --  Raise Program_Error if the accessibility level of the access\n+         --  parameter is deeper than the level of the target access type.\n+\n+         Check_Cond :=\n+           Make_Op_Gt (Loc,\n+             Left_Opnd  => Param_Level,\n+             Right_Opnd => Type_Level);\n+\n+         Insert_Action (Insert_Node,\n+           Make_Raise_Program_Error (Loc,\n+             Condition => Check_Cond,\n+             Reason    => PE_Accessibility_Check_Failed));\n+\n+         Analyze_And_Resolve (N);\n+\n+         --  If constant folding has happened on the condition for the\n+         --  generated error, then warn about it being unconditional.\n+\n+         if Nkind (Check_Cond) = N_Identifier\n+           and then Entity (Check_Cond) = Standard_True\n+         then\n+            Error_Msg_Warn := SPARK_Mode /= On;\n+            Error_Msg_N (\"accessibility check fails<<\", N);\n+            Error_Msg_N (\"\\Program_Error [<<\", N);\n+         end if;\n+      end if;\n+   end Apply_Accessibility_Check;\n+\n+   ---------------------------------------------\n+   -- Apply_Accessibility_Check_For_Allocator --\n+   ---------------------------------------------\n+\n+   procedure Apply_Accessibility_Check_For_Allocator\n+     (N              : Node_Id;\n+      Exp            : Node_Id;\n+      Ref            : Node_Id;\n+      Built_In_Place : Boolean := False)\n+   is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      PtrT      : constant Entity_Id  := Etype (N);\n+      DesigT    : constant Entity_Id  := Designated_Type (PtrT);\n+      Pool_Id   : constant Entity_Id  := Associated_Storage_Pool (PtrT);\n+      Cond      : Node_Id;\n+      Fin_Call  : Node_Id;\n+      Free_Stmt : Node_Id;\n+      Obj_Ref   : Node_Id;\n+      Stmts     : List_Id;\n+\n+   begin\n+      if Ada_Version >= Ada_2005\n+        and then Is_Class_Wide_Type (DesigT)\n+        and then Tagged_Type_Expansion\n+        and then not Scope_Suppress.Suppress (Accessibility_Check)\n+        and then not No_Dynamic_Accessibility_Checks_Enabled (Ref)\n+        and then\n+          (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n+            or else\n+              (Is_Class_Wide_Type (Etype (Exp))\n+                and then Scope (PtrT) /= Current_Scope))\n+      then\n+         --  If the allocator was built in place, Ref is already a reference\n+         --  to the access object initialized to the result of the allocator\n+         --  (see Exp_Ch6.Make_Build_In_Place_Call_In_Allocator). We call\n+         --  Remove_Side_Effects for cases where the build-in-place call may\n+         --  still be the prefix of the reference (to avoid generating\n+         --  duplicate calls). Otherwise, it is the entity associated with\n+         --  the object containing the address of the allocated object.\n+\n+         if Built_In_Place then\n+            Remove_Side_Effects (Ref);\n+            Obj_Ref := New_Copy_Tree (Ref);\n+         else\n+            Obj_Ref := New_Occurrence_Of (Ref, Loc);\n+         end if;\n+\n+         --  For access to interface types we must generate code to displace\n+         --  the pointer to the base of the object since the subsequent code\n+         --  references components located in the TSD of the object (which\n+         --  is associated with the primary dispatch table --see a-tags.ads)\n+         --  and also generates code invoking Free, which requires also a\n+         --  reference to the base of the unallocated object.\n+\n+         if Is_Interface (DesigT) and then Tagged_Type_Expansion then\n+            Obj_Ref :=\n+              Unchecked_Convert_To (Etype (Obj_Ref),\n+                Make_Function_Call (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                  Parameter_Associations => New_List (\n+                    Unchecked_Convert_To (RTE (RE_Address),\n+                      New_Copy_Tree (Obj_Ref)))));\n+         end if;\n+\n+         --  Step 1: Create the object clean up code\n+\n+         Stmts := New_List;\n+\n+         --  Deallocate the object if the accessibility check fails. This is\n+         --  done only on targets or profiles that support deallocation.\n+\n+         --    Free (Obj_Ref);\n+\n+         if RTE_Available (RE_Free) then\n+            Free_Stmt := Make_Free_Statement (Loc, New_Copy_Tree (Obj_Ref));\n+            Set_Storage_Pool (Free_Stmt, Pool_Id);\n+\n+            Append_To (Stmts, Free_Stmt);\n+\n+         --  The target or profile cannot deallocate objects\n+\n+         else\n+            Free_Stmt := Empty;\n+         end if;\n+\n+         --  Finalize the object if applicable. Generate:\n+\n+         --    [Deep_]Finalize (Obj_Ref.all);\n+\n+         if Needs_Finalization (DesigT)\n+           and then not No_Heap_Finalization (PtrT)\n+         then\n+            Fin_Call :=\n+              Make_Final_Call\n+                (Obj_Ref =>\n+                   Make_Explicit_Dereference (Loc, New_Copy (Obj_Ref)),\n+                 Typ     => DesigT);\n+\n+            --  Guard against a missing [Deep_]Finalize when the designated\n+            --  type was not properly frozen.\n+\n+            if No (Fin_Call) then\n+               Fin_Call := Make_Null_Statement (Loc);\n+            end if;\n+\n+            --  When the target or profile supports deallocation, wrap the\n+            --  finalization call in a block to ensure proper deallocation even\n+            --  if finalization fails. Generate:\n+\n+            --    begin\n+            --       <Fin_Call>\n+            --    exception\n+            --       when others =>\n+            --          <Free_Stmt>\n+            --          raise;\n+            --    end;\n+\n+            if Present (Free_Stmt) then\n+               Fin_Call :=\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (Fin_Call),\n+\n+                     Exception_Handlers => New_List (\n+                       Make_Exception_Handler (Loc,\n+                         Exception_Choices => New_List (\n+                           Make_Others_Choice (Loc)),\n+                         Statements        => New_List (\n+                           New_Copy_Tree (Free_Stmt),\n+                           Make_Raise_Statement (Loc))))));\n+            end if;\n+\n+            Prepend_To (Stmts, Fin_Call);\n+         end if;\n+\n+         --  Signal the accessibility failure through a Program_Error\n+\n+         Append_To (Stmts,\n+           Make_Raise_Program_Error (Loc,\n+             Reason => PE_Accessibility_Check_Failed));\n+\n+         --  Step 2: Create the accessibility comparison\n+\n+         --  Generate:\n+         --    Ref'Tag\n+\n+         Obj_Ref :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Obj_Ref,\n+             Attribute_Name => Name_Tag);\n+\n+         --  For tagged types, determine the accessibility level by looking at\n+         --  the type specific data of the dispatch table. Generate:\n+\n+         --    Type_Specific_Data (Address (Ref'Tag)).Access_Level\n+\n+         if Tagged_Type_Expansion then\n+            Cond := Build_Get_Access_Level (Loc, Obj_Ref);\n+\n+         --  Use a runtime call to determine the accessibility level when\n+         --  compiling on virtual machine targets. Generate:\n+\n+         --    Get_Access_Level (Ref'Tag)\n+\n+         else\n+            Cond :=\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (RTE (RE_Get_Access_Level), Loc),\n+                Parameter_Associations => New_List (Obj_Ref));\n+         end if;\n+\n+         Cond :=\n+           Make_Op_Gt (Loc,\n+             Left_Opnd  => Cond,\n+             Right_Opnd => Accessibility_Level (N, Dynamic_Level));\n+\n+         --  Due to the complexity and side effects of the check, utilize an if\n+         --  statement instead of the regular Program_Error circuitry.\n+\n+         Insert_Action (N,\n+           Make_Implicit_If_Statement (N,\n+             Condition       => Cond,\n+             Then_Statements => Stmts));\n+      end if;\n+   end Apply_Accessibility_Check_For_Allocator;\n+\n+   ------------------------------------------\n+   -- Check_Return_Construct_Accessibility --\n+   ------------------------------------------\n+\n+   procedure Check_Return_Construct_Accessibility\n+     (Return_Stmt : Node_Id;\n+      Stm_Entity  : Entity_Id)\n+   is\n+      Loc      : constant Source_Ptr := Sloc (Return_Stmt);\n+      Scope_Id : constant Entity_Id  := Return_Applies_To (Stm_Entity);\n+\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n+      --  Function result subtype\n+\n+      function First_Selector (Assoc : Node_Id) return Node_Id;\n+      --  Obtain the first selector or choice from a given association\n+\n+      function Is_Formal_Of_Current_Function\n+        (Assoc_Expr : Entity_Id) return Boolean;\n+      --  Predicate to test if a given expression associated with a\n+      --  discriminant is a formal parameter to the function in which the\n+      --  return construct we checking applies to.\n+\n+      --------------------\n+      -- First_Selector --\n+      --------------------\n+\n+      function First_Selector (Assoc : Node_Id) return Node_Id is\n+      begin\n+         if Nkind (Assoc) = N_Component_Association then\n+            return First (Choices (Assoc));\n+\n+         elsif Nkind (Assoc) = N_Discriminant_Association then\n+            return (First (Selector_Names (Assoc)));\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end First_Selector;\n+\n+      -----------------------------------\n+      -- Is_Formal_Of_Current_Function --\n+      -----------------------------------\n+\n+      function Is_Formal_Of_Current_Function\n+        (Assoc_Expr : Entity_Id) return Boolean is\n+      begin\n+         return Is_Entity_Name (Assoc_Expr)\n+                  and then Enclosing_Subprogram\n+                             (Entity (Assoc_Expr)) = Scope_Id\n+                  and then Is_Formal (Entity (Assoc_Expr));\n+      end Is_Formal_Of_Current_Function;\n+\n+      --  Local declarations\n+\n+      Assoc : Node_Id := Empty;\n+      --  Assoc should perhaps be renamed and declared as a\n+      --  Node_Or_Entity_Id since it encompasses not only component and\n+      --  discriminant associations, but also discriminant components within\n+      --  a type declaration or subtype indication ???\n+\n+      Assoc_Expr    : Node_Id;\n+      Assoc_Present : Boolean := False;\n+\n+      Check_Cond        : Node_Id;\n+      Unseen_Disc_Count : Nat := 0;\n+      Seen_Discs        : Elist_Id;\n+      Disc              : Entity_Id;\n+      First_Disc        : Entity_Id;\n+\n+      Obj_Decl   : Node_Id;\n+      Return_Con : Node_Id;\n+      Unqual     : Node_Id;\n+\n+   --  Start of processing for Check_Return_Construct_Accessibility\n+\n+   begin\n+      --  Only perform checks on record types with access discriminants and\n+      --  non-internally generated functions.\n+\n+      if not Is_Record_Type (R_Type)\n+        or else not Has_Anonymous_Access_Discriminant (R_Type)\n+        or else not Comes_From_Source (Return_Stmt)\n+      then\n+         return;\n+      end if;\n+\n+      --  We are only interested in return statements\n+\n+      if Nkind (Return_Stmt) not in\n+           N_Extended_Return_Statement | N_Simple_Return_Statement\n+      then\n+         return;\n+      end if;\n+\n+      --  Fetch the object from the return statement, in the case of a\n+      --  simple return statement the expression is part of the node.\n+\n+      if Nkind (Return_Stmt) = N_Extended_Return_Statement then\n+         --  Obtain the object definition from the expanded extended return\n+\n+         Return_Con := First (Return_Object_Declarations (Return_Stmt));\n+         while Present (Return_Con) loop\n+            --  Inspect the original node to avoid object declarations\n+            --  expanded into renamings.\n+\n+            if Nkind (Original_Node (Return_Con)) = N_Object_Declaration\n+              and then Comes_From_Source (Original_Node (Return_Con))\n+            then\n+               exit;\n+            end if;\n+\n+            Nlists.Next (Return_Con);\n+         end loop;\n+\n+         pragma Assert (Present (Return_Con));\n+\n+         --  Could be dealing with a renaming\n+\n+         Return_Con := Original_Node (Return_Con);\n+      else\n+         Return_Con := Expression (Return_Stmt);\n+      end if;\n+\n+      --  Obtain the accessibility levels of the expressions associated\n+      --  with all anonymous access discriminants, then generate a\n+      --  dynamic check or static error when relevant.\n+\n+      --  Note the repeated use of Original_Node to avoid checking\n+      --  expanded code.\n+\n+      Unqual := Original_Node (Unqualify (Original_Node (Return_Con)));\n+\n+      --  Get the corresponding declaration based on the return object's\n+      --  identifier.\n+\n+      if Nkind (Unqual) = N_Identifier\n+        and then Nkind (Parent (Entity (Unqual)))\n+                   in N_Object_Declaration\n+                    | N_Object_Renaming_Declaration\n+      then\n+         Obj_Decl := Original_Node (Parent (Entity (Unqual)));\n+\n+      --  We were passed the object declaration directly, so use it\n+\n+      elsif Nkind (Unqual) in N_Object_Declaration\n+                            | N_Object_Renaming_Declaration\n+      then\n+         Obj_Decl := Unqual;\n+\n+      --  Otherwise, we are looking at something else\n+\n+      else\n+         Obj_Decl := Empty;\n+\n+      end if;\n+\n+      --  Hop up object renamings when present\n+\n+      if Present (Obj_Decl)\n+        and then Nkind (Obj_Decl) = N_Object_Renaming_Declaration\n+      then\n+         while Nkind (Obj_Decl) = N_Object_Renaming_Declaration loop\n+\n+            if Nkind (Name (Obj_Decl)) not in N_Entity then\n+               --  We may be looking at the expansion of iterators or\n+               --  some other internally generated construct, so it is safe\n+               --  to ignore checks ???\n+\n+               if not Comes_From_Source (Obj_Decl) then\n+                  return;\n+               end if;\n+\n+               Obj_Decl := Original_Node\n+                             (Declaration_Node\n+                               (Ultimate_Prefix (Name (Obj_Decl))));\n+\n+            --  Move up to the next declaration based on the object's name\n+\n+            else\n+               Obj_Decl := Original_Node\n+                             (Declaration_Node (Name (Obj_Decl)));\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Obtain the discriminant values from the return aggregate\n+\n+      --  Do we cover extension aggregates correctly ???\n+\n+      if Nkind (Unqual) = N_Aggregate then\n+         if Present (Expressions (Unqual)) then\n+            Assoc := First (Expressions (Unqual));\n+         else\n+            Assoc := First (Component_Associations (Unqual));\n+         end if;\n+\n+      --  There is an object declaration for the return object\n+\n+      elsif Present (Obj_Decl) then\n+         --  When a subtype indication is present in an object declaration\n+         --  it must contain the object's discriminants.\n+\n+         if Nkind (Object_Definition (Obj_Decl)) = N_Subtype_Indication then\n+            Assoc := First\n+                       (Constraints\n+                         (Constraint\n+                           (Object_Definition (Obj_Decl))));\n+\n+         --  The object declaration contains an aggregate\n+\n+         elsif Present (Expression (Obj_Decl)) then\n+\n+            if Nkind (Unqualify (Expression (Obj_Decl))) = N_Aggregate then\n+               --  Grab the first associated discriminant expresion\n+\n+               if Present\n+                    (Expressions (Unqualify (Expression (Obj_Decl))))\n+               then\n+                  Assoc := First\n+                             (Expressions\n+                               (Unqualify (Expression (Obj_Decl))));\n+               else\n+                  Assoc := First\n+                             (Component_Associations\n+                               (Unqualify (Expression (Obj_Decl))));\n+               end if;\n+\n+            --  Otherwise, this is something else\n+\n+            else\n+               return;\n+            end if;\n+\n+         --  There are no supplied discriminants in the object declaration,\n+         --  so get them from the type definition since they must be default\n+         --  initialized.\n+\n+         --  Do we handle constrained subtypes correctly ???\n+\n+         elsif Nkind (Unqual) = N_Object_Declaration then\n+            Assoc := First_Discriminant\n+                       (Etype (Object_Definition (Obj_Decl)));\n+\n+         else\n+            Assoc := First_Discriminant (Etype (Unqual));\n+         end if;\n+\n+      --  When we are not looking at an aggregate or an identifier, return\n+      --  since any other construct (like a function call) is not\n+      --  applicable since checks will be performed on the side of the\n+      --  callee.\n+\n+      else\n+         return;\n+      end if;\n+\n+      --  Obtain the discriminants so we know the actual type in case the\n+      --  value of their associated expression gets implicitly converted.\n+\n+      if No (Obj_Decl) then\n+         pragma Assert (Nkind (Unqual) = N_Aggregate);\n+\n+         Disc := First_Discriminant (Etype (Unqual));\n+\n+      else\n+         Disc := First_Discriminant\n+                   (Etype (Defining_Identifier (Obj_Decl)));\n+      end if;\n+\n+      --  Preserve the first discriminant for checking named associations\n+\n+      First_Disc := Disc;\n+\n+      --  Count the number of discriminants for processing an aggregate\n+      --  which includes an others.\n+\n+      Disc := First_Disc;\n+      while Present (Disc) loop\n+         Unseen_Disc_Count := Unseen_Disc_Count + 1;\n+\n+         Next_Discriminant (Disc);\n+      end loop;\n+\n+      Seen_Discs := New_Elmt_List;\n+\n+      --  Loop through each of the discriminants and check each expression\n+      --  associated with an anonymous access discriminant.\n+\n+      --  When named associations occur in the return aggregate then\n+      --  discriminants can be in any order, so we need to ensure we do\n+      --  not continue to loop when all discriminants have been seen.\n+\n+      Disc := First_Disc;\n+      while Present (Assoc)\n+        and then (Present (Disc) or else Assoc_Present)\n+        and then Unseen_Disc_Count > 0\n+      loop\n+         --  Handle named associations by searching through the names of\n+         --  the relevant discriminant components.\n+\n+         if Nkind (Assoc)\n+              in N_Component_Association | N_Discriminant_Association\n+         then\n+            Assoc_Expr    := Expression (Assoc);\n+            Assoc_Present := True;\n+\n+            --  We currently don't handle box initialized discriminants,\n+            --  however, since default initialized anonymous access\n+            --  discriminants are a corner case, this is ok for now ???\n+\n+            if Nkind (Assoc) = N_Component_Association\n+              and then Box_Present (Assoc)\n+            then\n+               if Nkind (First_Selector (Assoc)) = N_Others_Choice then\n+                  Unseen_Disc_Count := 0;\n+               end if;\n+\n+            --  When others is present we must identify a discriminant we\n+            --  haven't already seen so as to get the appropriate type for\n+            --  the static accessibility check.\n+\n+            --  This works because all components within an others clause\n+            --  must have the same type.\n+\n+            elsif Nkind (First_Selector (Assoc)) = N_Others_Choice then\n+\n+               Disc := First_Disc;\n+               Outer : while Present (Disc) loop\n+                  declare\n+                     Current_Seen_Disc : Elmt_Id;\n+                  begin\n+                     --  Move through the list of identified discriminants\n+\n+                     Current_Seen_Disc := First_Elmt (Seen_Discs);\n+                     while Present (Current_Seen_Disc) loop\n+                        --  Exit the loop when we found a match\n+\n+                        exit when\n+                          Chars (Node (Current_Seen_Disc)) = Chars (Disc);\n+\n+                        Next_Elmt (Current_Seen_Disc);\n+                     end loop;\n+\n+                     --  When we have exited the above loop without finding\n+                     --  a match then we know that Disc has not been seen.\n+\n+                     exit Outer when No (Current_Seen_Disc);\n+                  end;\n+\n+                  Next_Discriminant (Disc);\n+               end loop Outer;\n+\n+               --  If we got to an others clause with a non-zero\n+               --  discriminant count there must be a discriminant left to\n+               --  check.\n+\n+               pragma Assert (Present (Disc));\n+\n+               --  Set the unseen discriminant count to zero because we know\n+               --  an others clause sets all remaining components of an\n+               --  aggregate.\n+\n+               Unseen_Disc_Count := 0;\n+\n+            --  Move through each of the selectors in the named association\n+            --  and obtain a discriminant for accessibility checking if one\n+            --  is referenced in the list. Also track which discriminants\n+            --  are referenced for the purpose of handling an others clause.\n+\n+            else\n+               declare\n+                  Assoc_Choice : Node_Id;\n+                  Curr_Disc    : Node_Id;\n+               begin\n+\n+                  Disc      := Empty;\n+                  Curr_Disc := First_Disc;\n+                  while Present (Curr_Disc) loop\n+                     --  Check each of the choices in the associations for a\n+                     --  match to the name of the current discriminant.\n+\n+                     Assoc_Choice := First_Selector (Assoc);\n+                     while Present (Assoc_Choice) loop\n+                        --  When the name matches we track that we have seen\n+                        --  the discriminant, but instead of exiting the\n+                        --  loop we continue iterating to make sure all the\n+                        --  discriminants within the named association get\n+                        --  tracked.\n+\n+                        if Chars (Assoc_Choice) = Chars (Curr_Disc) then\n+                           Append_Elmt (Curr_Disc, Seen_Discs);\n+\n+                           Disc              := Curr_Disc;\n+                           Unseen_Disc_Count := Unseen_Disc_Count - 1;\n+                        end if;\n+\n+                        Next (Assoc_Choice);\n+                     end loop;\n+\n+                     Next_Discriminant (Curr_Disc);\n+                  end loop;\n+               end;\n+            end if;\n+\n+         --  Unwrap the associated expression if we are looking at a default\n+         --  initialized type declaration. In this case Assoc is not really\n+         --  an association, but a component declaration. Should Assoc be\n+         --  renamed in some way to be more clear ???\n+\n+         --  This occurs when the return object does not initialize\n+         --  discriminant and instead relies on the type declaration for\n+         --  their supplied values.\n+\n+         elsif Nkind (Assoc) in N_Entity\n+           and then Ekind (Assoc) = E_Discriminant\n+         then\n+            Append_Elmt (Disc, Seen_Discs);\n+\n+            Assoc_Expr        := Discriminant_Default_Value (Assoc);\n+            Unseen_Disc_Count := Unseen_Disc_Count - 1;\n+\n+         --  Otherwise, there is nothing to do because Assoc is an\n+         --  expression within the return aggregate itself.\n+\n+         else\n+            Append_Elmt (Disc, Seen_Discs);\n+\n+            Assoc_Expr        := Assoc;\n+            Unseen_Disc_Count := Unseen_Disc_Count - 1;\n+         end if;\n+\n+         --  Check the accessibility level of the expression when the\n+         --  discriminant is of an anonymous access type.\n+\n+         if Present (Assoc_Expr)\n+           and then Present (Disc)\n+           and then Ekind (Etype (Disc)) = E_Anonymous_Access_Type\n+\n+           --  We disable the check when we have a tagged return type and\n+           --  the associated expression for the discriminant is a formal\n+           --  parameter since the check would require us to compare the\n+           --  accessibility level of Assoc_Expr to the level of the\n+           --  Extra_Accessibility_Of_Result of the function - which is\n+           --  currently disabled for functions with tagged return types.\n+           --  This may change in the future ???\n+\n+           --  See Needs_Result_Accessibility_Level for details.\n+\n+           and then not\n+             (No (Extra_Accessibility_Of_Result (Scope_Id))\n+               and then Is_Formal_Of_Current_Function (Assoc_Expr)\n+               and then Is_Tagged_Type (Etype (Scope_Id)))\n+         then\n+            --  Generate a dynamic check based on the extra accessibility of\n+            --  the result or the scope of the current function.\n+\n+            Check_Cond :=\n+              Make_Op_Gt (Loc,\n+                Left_Opnd  => Accessibility_Level\n+                                (Expr              => Assoc_Expr,\n+                                 Level             => Dynamic_Level,\n+                                 In_Return_Context => True),\n+                Right_Opnd =>\n+                  (if Present (Extra_Accessibility_Of_Result (Scope_Id))\n+\n+                     --  When Assoc_Expr is a formal we have to look at the\n+                     --  extra accessibility-level formal associated with\n+                     --  the result.\n+\n+                     and then Is_Formal_Of_Current_Function (Assoc_Expr)\n+                   then\n+                      New_Occurrence_Of\n+                        (Extra_Accessibility_Of_Result (Scope_Id), Loc)\n+\n+                   --  Otherwise, we compare the level of Assoc_Expr to the\n+                   --  scope of the current function.\n+\n+                   else\n+                      Make_Integer_Literal\n+                        (Loc, Scope_Depth (Scope (Scope_Id)))));\n+\n+            Insert_Before_And_Analyze (Return_Stmt,\n+              Make_Raise_Program_Error (Loc,\n+                Condition => Check_Cond,\n+                Reason    => PE_Accessibility_Check_Failed));\n+\n+            --  If constant folding has happened on the condition for the\n+            --  generated error, then warn about it being unconditional when\n+            --  we know an error will be raised.\n+\n+            if Nkind (Check_Cond) = N_Identifier\n+              and then Entity (Check_Cond) = Standard_True\n+            then\n+               Error_Msg_N\n+                 (\"access discriminant in return object would be a dangling\"\n+                  & \" reference\", Return_Stmt);\n+            end if;\n+         end if;\n+\n+         --  Iterate over the discriminants, except when we have encountered\n+         --  a named association since the discriminant order becomes\n+         --  irrelevant in that case.\n+\n+         if not Assoc_Present then\n+            Next_Discriminant (Disc);\n+         end if;\n+\n+         --  Iterate over associations\n+\n+         if not Is_List_Member (Assoc) then\n+            exit;\n+         else\n+            Nlists.Next (Assoc);\n+         end if;\n+      end loop;\n+   end Check_Return_Construct_Accessibility;\n+\n+   -------------------------------\n+   -- Deepest_Type_Access_Level --\n+   -------------------------------\n+\n+   function Deepest_Type_Access_Level\n+     (Typ             : Entity_Id;\n+      Allow_Alt_Model : Boolean := True) return Uint\n+   is\n+   begin\n+      if Ekind (Typ) = E_Anonymous_Access_Type\n+        and then not Is_Local_Anonymous_Access (Typ)\n+        and then Nkind (Associated_Node_For_Itype (Typ)) = N_Object_Declaration\n+      then\n+         --  No_Dynamic_Accessibility_Checks override for alternative\n+         --  accessibility model.\n+\n+         if Allow_Alt_Model\n+           and then No_Dynamic_Accessibility_Checks_Enabled (Typ)\n+         then\n+            return Type_Access_Level (Typ, Allow_Alt_Model);\n+         end if;\n+\n+         --  Typ is the type of an Ada 2012 stand-alone object of an anonymous\n+         --  access type.\n+\n+         return\n+           Scope_Depth (Enclosing_Dynamic_Scope\n+                         (Defining_Identifier\n+                           (Associated_Node_For_Itype (Typ))));\n+\n+      --  For generic formal type, return Int'Last (infinite).\n+      --  See comment preceding Is_Generic_Type call in Type_Access_Level.\n+\n+      elsif Is_Generic_Type (Root_Type (Typ)) then\n+         return UI_From_Int (Int'Last);\n+\n+      else\n+         return Type_Access_Level (Typ, Allow_Alt_Model);\n+      end if;\n+   end Deepest_Type_Access_Level;\n+\n+   -----------------------------------\n+   -- Effective_Extra_Accessibility --\n+   -----------------------------------\n+\n+   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id is\n+   begin\n+      if Present (Renamed_Object (Id))\n+        and then Is_Entity_Name (Renamed_Object (Id))\n+      then\n+         return Effective_Extra_Accessibility (Entity (Renamed_Object (Id)));\n+      else\n+         return Extra_Accessibility (Id);\n+      end if;\n+   end Effective_Extra_Accessibility;\n+\n+   -------------------------------\n+   -- Get_Dynamic_Accessibility --\n+   -------------------------------\n+\n+   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id is\n+   begin\n+      --  When minimum accessibility is set for E then we utilize it - except\n+      --  in a few edge cases like the expansion of select statements where\n+      --  generated subprogram may attempt to unnecessarily use a minimum\n+      --  accessibility object declared outside of scope.\n+\n+      --  To avoid these situations where expansion may get complex we verify\n+      --  that the minimum accessibility object is within scope.\n+\n+      if Is_Formal (E)\n+        and then Present (Minimum_Accessibility (E))\n+        and then In_Open_Scopes (Scope (Minimum_Accessibility (E)))\n+      then\n+         return Minimum_Accessibility (E);\n+      end if;\n+\n+      return Extra_Accessibility (E);\n+   end Get_Dynamic_Accessibility;\n+\n+   -----------------------\n+   -- Has_Access_Values --\n+   -----------------------\n+\n+   function Has_Access_Values (T : Entity_Id) return Boolean\n+   is\n+      Typ : constant Entity_Id := Underlying_Type (T);\n+\n+   begin\n+      --  Case of a private type which is not completed yet. This can only\n+      --  happen in the case of a generic formal type appearing directly, or\n+      --  as a component of the type to which this function is being applied\n+      --  at the top level. Return False in this case, since we certainly do\n+      --  not know that the type contains access types.\n+\n+      if No (Typ) then\n+         return False;\n+\n+      elsif Is_Access_Type (Typ) then\n+         return True;\n+\n+      elsif Is_Array_Type (Typ) then\n+         return Has_Access_Values (Component_Type (Typ));\n+\n+      elsif Is_Record_Type (Typ) then\n+         declare\n+            Comp : Entity_Id;\n+\n+         begin\n+            --  Loop to check components\n+\n+            Comp := First_Component_Or_Discriminant (Typ);\n+            while Present (Comp) loop\n+\n+               --  Check for access component, tag field does not count, even\n+               --  though it is implemented internally using an access type.\n+\n+               if Has_Access_Values (Etype (Comp))\n+                 and then Chars (Comp) /= Name_uTag\n+               then\n+                  return True;\n+               end if;\n+\n+               Next_Component_Or_Discriminant (Comp);\n+            end loop;\n+         end;\n+\n+         return False;\n+\n+      else\n+         return False;\n+      end if;\n+   end Has_Access_Values;\n+\n+   ---------------------------------------\n+   -- Has_Anonymous_Access_Discriminant --\n+   ---------------------------------------\n+\n+   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean\n+   is\n+      Disc : Node_Id;\n+\n+   begin\n+      if not Has_Discriminants (Typ) then\n+         return False;\n+      end if;\n+\n+      Disc := First_Discriminant (Typ);\n+      while Present (Disc) loop\n+         if Ekind (Etype (Disc)) = E_Anonymous_Access_Type then\n+            return True;\n+         end if;\n+\n+         Next_Discriminant (Disc);\n+      end loop;\n+\n+      return False;\n+   end Has_Anonymous_Access_Discriminant;\n+\n+   --------------------------------------------\n+   -- Has_Unconstrained_Access_Discriminants --\n+   --------------------------------------------\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+      Discr : Entity_Id;\n+\n+   begin\n+      if Has_Discriminants (Subtyp)\n+        and then not Is_Constrained (Subtyp)\n+      then\n+         Discr := First_Discriminant (Subtyp);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Unconstrained_Access_Discriminants;\n+\n+   --------------------------------\n+   -- Is_Anonymous_Access_Actual --\n+   --------------------------------\n+\n+   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+   begin\n+      if Ekind (Etype (N)) /= E_Anonymous_Access_Type then\n+         return False;\n+      end if;\n+\n+      Par := Parent (N);\n+      while Present (Par)\n+        and then Nkind (Par) in N_Case_Expression\n+                              | N_If_Expression\n+                              | N_Parameter_Association\n+      loop\n+         Par := Parent (Par);\n+      end loop;\n+      return Nkind (Par) in N_Subprogram_Call;\n+   end Is_Anonymous_Access_Actual;\n+\n+   --------------------------------------\n+   -- Is_Special_Aliased_Formal_Access --\n+   --------------------------------------\n+\n+   function Is_Special_Aliased_Formal_Access\n+     (Exp               : Node_Id;\n+      In_Return_Context : Boolean := False) return Boolean\n+   is\n+      Scop : constant Entity_Id := Current_Subprogram;\n+   begin\n+      --  Verify the expression is an access reference to 'Access within a\n+      --  return statement as this is the only time an explicitly aliased\n+      --  formal has different semantics.\n+\n+      if Nkind (Exp) /= N_Attribute_Reference\n+        or else Get_Attribute_Id (Attribute_Name (Exp)) /= Attribute_Access\n+        or else not (In_Return_Value (Exp)\n+                      or else In_Return_Context)\n+        or else not Needs_Result_Accessibility_Level (Scop)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Check if the prefix of the reference is indeed an explicitly aliased\n+      --  formal parameter for the function Scop. Additionally, we must check\n+      --  that Scop returns an anonymous access type, otherwise the special\n+      --  rules dictating a need for a dynamic check are not in effect.\n+\n+      return Is_Entity_Name (Prefix (Exp))\n+               and then Is_Explicitly_Aliased (Entity (Prefix (Exp)));\n+   end Is_Special_Aliased_Formal_Access;\n+\n+   --------------------------------------\n+   -- Needs_Result_Accessibility_Level --\n+   --------------------------------------\n+\n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean\n+   is\n+      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ : Entity_Id) return Boolean;\n+      --  Returns True if any component of the type has an unconstrained access\n+      --  discriminant.\n+\n+      -----------------------------------------------------\n+      -- Has_Unconstrained_Access_Discriminant_Component --\n+      -----------------------------------------------------\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ :  Entity_Id) return Boolean\n+      is\n+      begin\n+         if not Is_Limited_Type (Comp_Typ) then\n+            return False;\n+\n+         --  Only limited types can have access discriminants with\n+         --  defaults.\n+\n+         elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n+            return True;\n+\n+         elsif Is_Array_Type (Comp_Typ) then\n+            return Has_Unconstrained_Access_Discriminant_Component\n+                     (Underlying_Type (Component_Type (Comp_Typ)));\n+\n+         elsif Is_Record_Type (Comp_Typ) then\n+            declare\n+               Comp : Entity_Id;\n+\n+            begin\n+               Comp := First_Component (Comp_Typ);\n+               while Present (Comp) loop\n+                  if Has_Unconstrained_Access_Discriminant_Component\n+                       (Underlying_Type (Etype (Comp)))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Has_Unconstrained_Access_Discriminant_Component;\n+\n+      Disable_Tagged_Cases : constant Boolean := True;\n+      --  Flag used to temporarily disable a \"True\" result for tagged types.\n+      --  See comments further below for details.\n+\n+   --  Start of processing for Needs_Result_Accessibility_Level\n+\n+   begin\n+      --  False if completion unavailable, which can happen when we are\n+      --  analyzing an abstract subprogram or if the subprogram has\n+      --  delayed freezing.\n+\n+      if No (Func_Typ) then\n+         return False;\n+\n+      --  False if not a function, also handle enum-lit renames case\n+\n+      elsif Func_Typ = Standard_Void_Type\n+        or else Is_Scalar_Type (Func_Typ)\n+      then\n+         return False;\n+\n+      --  Handle a corner case, a cross-dialect subp renaming. For example,\n+      --  an Ada 2012 renaming of an Ada 2005 subprogram. This can occur when\n+      --  an Ada 2005 (or earlier) unit references predefined run-time units.\n+\n+      elsif Present (Alias (Func_Id)) then\n+\n+         --  Unimplemented: a cross-dialect subp renaming which does not set\n+         --  the Alias attribute (e.g., a rename of a dereference of an access\n+         --  to subprogram value). ???\n+\n+         return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n+\n+      --  Remaining cases require Ada 2012 mode, unless they are dispatching\n+      --  operations, since they may be overridden by Ada_2012 primitives.\n+\n+      elsif Ada_Version < Ada_2012\n+        and then not Is_Dispatching_Operation (Func_Id)\n+      then\n+         return False;\n+\n+      --  Handle the situation where a result is an anonymous access type\n+      --  RM 3.10.2 (10.3/3).\n+\n+      elsif Ekind (Func_Typ) = E_Anonymous_Access_Type then\n+         return True;\n+\n+      --  In the case of, say, a null tagged record result type, the need for\n+      --  this extra parameter might not be obvious so this function returns\n+      --  True for all tagged types for compatibility reasons.\n+\n+      --  A function with, say, a tagged null controlling result type might\n+      --  be overridden by a primitive of an extension having an access\n+      --  discriminant and the overrider and overridden must have compatible\n+      --  calling conventions (including implicitly declared parameters).\n+\n+      --  Similarly, values of one access-to-subprogram type might designate\n+      --  both a primitive subprogram of a given type and a function which is,\n+      --  for example, not a primitive subprogram of any type. Again, this\n+      --  requires calling convention compatibility. It might be possible to\n+      --  solve these issues by introducing wrappers, but that is not the\n+      --  approach that was chosen.\n+\n+      --  Note: Despite the reasoning noted above, the extra accessibility\n+      --  parameter for tagged types is disabled for performance reasons.\n+\n+      elsif Is_Tagged_Type (Func_Typ) then\n+         return not Disable_Tagged_Cases;\n+\n+      elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n+         return True;\n+\n+      elsif Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n+         return True;\n+\n+      --  False for all other cases\n+\n+      else\n+         return False;\n+      end if;\n+   end Needs_Result_Accessibility_Level;\n+\n+   ------------------------------------------\n+   -- Prefix_With_Safe_Accessibility_Level --\n+   ------------------------------------------\n+\n+   function Prefix_With_Safe_Accessibility_Level\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n+      P        : constant Node_Id      := Prefix (N);\n+      Aname    : constant Name_Id      := Attribute_Name (N);\n+      Attr_Id  : constant Attribute_Id := Get_Attribute_Id (Aname);\n+      Btyp     : constant Entity_Id    := Base_Type (Typ);\n+\n+      function Safe_Value_Conversions return Boolean;\n+      --  Return False if the prefix has a value conversion of an array type\n+\n+      ----------------------------\n+      -- Safe_Value_Conversions --\n+      ----------------------------\n+\n+      function Safe_Value_Conversions return Boolean is\n+         PP : Node_Id := P;\n+\n+      begin\n+         loop\n+            if Nkind (PP) in N_Selected_Component | N_Indexed_Component then\n+               PP := Prefix (PP);\n+\n+            elsif Comes_From_Source (PP)\n+              and then Nkind (PP) in N_Type_Conversion\n+                                   | N_Unchecked_Type_Conversion\n+              and then Is_Array_Type (Etype (PP))\n+            then\n+               return False;\n+\n+            elsif Comes_From_Source (PP)\n+              and then Nkind (PP) = N_Qualified_Expression\n+              and then Is_Array_Type (Etype (PP))\n+              and then Nkind (Original_Node (Expression (PP))) in\n+                         N_Aggregate | N_Extension_Aggregate\n+            then\n+               return False;\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Safe_Value_Conversions;\n+\n+   --  Start of processing for Prefix_With_Safe_Accessibility_Level\n+\n+   begin\n+      --  No check required for unchecked and unrestricted access\n+\n+      if Attr_Id = Attribute_Unchecked_Access\n+        or else Attr_Id = Attribute_Unrestricted_Access\n+      then\n+         return True;\n+\n+      --  Check value conversions\n+\n+      elsif Ekind (Btyp) = E_General_Access_Type\n+        and then not Safe_Value_Conversions\n+      then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Prefix_With_Safe_Accessibility_Level;\n+\n+   -----------------------------\n+   -- Subprogram_Access_Level --\n+   -----------------------------\n+\n+   function Subprogram_Access_Level (Subp : Entity_Id) return Uint is\n+   begin\n+      if Present (Alias (Subp)) then\n+         return Subprogram_Access_Level (Alias (Subp));\n+      else\n+         return Scope_Depth (Enclosing_Dynamic_Scope (Subp));\n+      end if;\n+   end Subprogram_Access_Level;\n+\n+   --------------------------------\n+   -- Static_Accessibility_Level --\n+   --------------------------------\n+\n+   function Static_Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Static_Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Uint\n+   is\n+   begin\n+      return Intval\n+               (Accessibility_Level (Expr, Level, In_Return_Context));\n+   end Static_Accessibility_Level;\n+\n+   -----------------------\n+   -- Type_Access_Level --\n+   -----------------------\n+\n+   function Type_Access_Level\n+     (Typ             : Entity_Id;\n+      Allow_Alt_Model : Boolean   := True;\n+      Assoc_Ent       : Entity_Id := Empty) return Uint\n+   is\n+      Btyp    : Entity_Id := Base_Type (Typ);\n+      Def_Ent : Entity_Id;\n+\n+   begin\n+      --  Ada 2005 (AI-230): For most cases of anonymous access types, we\n+      --  simply use the level where the type is declared. This is true for\n+      --  stand-alone object declarations, and for anonymous access types\n+      --  associated with components the level is the same as that of the\n+      --  enclosing composite type. However, special treatment is needed for\n+      --  the cases of access parameters, return objects of an anonymous access\n+      --  type, and, in Ada 95, access discriminants of limited types.\n+\n+      if Is_Access_Type (Btyp) then\n+         if Ekind (Btyp) = E_Anonymous_Access_Type then\n+            --  No_Dynamic_Accessibility_Checks restriction override for\n+            --  alternative accessibility model.\n+\n+            if Allow_Alt_Model\n+              and then No_Dynamic_Accessibility_Checks_Enabled (Btyp)\n+            then\n+               --  In the -gnatd_b model, the level of an anonymous access\n+               --  type is always that of the designated type.\n+\n+               if Debug_Flag_Underscore_B then\n+                  return Type_Access_Level\n+                           (Designated_Type (Btyp), Allow_Alt_Model);\n+               end if;\n+\n+               --  When an anonymous access type's Assoc_Ent is specified,\n+               --  calculate the result based on the general accessibility\n+               --  level routine.\n+\n+               --  We would like to use Associated_Node_For_Itype here instead,\n+               --  but in some cases it is not fine grained enough ???\n+\n+               if Present (Assoc_Ent) then\n+                  return Static_Accessibility_Level\n+                           (Assoc_Ent, Object_Decl_Level);\n+               end if;\n+\n+               --  Otherwise take the context of the anonymous access type into\n+               --  account.\n+\n+               --  Obtain the defining entity for the internally generated\n+               --  anonymous access type.\n+\n+               Def_Ent := Defining_Entity_Or_Empty\n+                            (Associated_Node_For_Itype (Typ));\n+\n+               if Present (Def_Ent) then\n+                  --  When the defining entity is a subprogram then we know the\n+                  --  anonymous access type Typ has been generated to either\n+                  --  describe an anonymous access type formal or an anonymous\n+                  --  access result type.\n+\n+                  --  Since we are only interested in the formal case, avoid\n+                  --  the anonymous access result type.\n+\n+                  if Is_Subprogram (Def_Ent)\n+                    and then not (Ekind (Def_Ent) = E_Function\n+                                   and then Etype (Def_Ent) = Typ)\n+                  then\n+                     --  When the type comes from an anonymous access\n+                     --  parameter, the level is that of the subprogram\n+                     --  declaration.\n+\n+                     return Scope_Depth (Def_Ent);\n+\n+                  --  When the type is an access discriminant, the level is\n+                  --  that of the type.\n+\n+                  elsif Ekind (Def_Ent) = E_Discriminant then\n+                     return Scope_Depth (Scope (Def_Ent));\n+                  end if;\n+               end if;\n+\n+            --  If the type is a nonlocal anonymous access type (such as for\n+            --  an access parameter) we treat it as being declared at the\n+            --  library level to ensure that names such as X.all'access don't\n+            --  fail static accessibility checks.\n+\n+            elsif not Is_Local_Anonymous_Access (Typ) then\n+               return Scope_Depth (Standard_Standard);\n+\n+            --  If this is a return object, the accessibility level is that of\n+            --  the result subtype of the enclosing function. The test here is\n+            --  little complicated, because we have to account for extended\n+            --  return statements that have been rewritten as blocks, in which\n+            --  case we have to find and the Is_Return_Object attribute of the\n+            --  itype's associated object. It would be nice to find a way to\n+            --  simplify this test, but it doesn't seem worthwhile to add a new\n+            --  flag just for purposes of this test. ???\n+\n+            elsif Ekind (Scope (Btyp)) = E_Return_Statement\n+              or else\n+                (Is_Itype (Btyp)\n+                  and then Nkind (Associated_Node_For_Itype (Btyp)) =\n+                                                         N_Object_Declaration\n+                  and then Is_Return_Object\n+                             (Defining_Identifier\n+                                (Associated_Node_For_Itype (Btyp))))\n+            then\n+               declare\n+                  Scop : Entity_Id;\n+\n+               begin\n+                  Scop := Scope (Scope (Btyp));\n+                  while Present (Scop) loop\n+                     exit when Ekind (Scop) = E_Function;\n+                     Scop := Scope (Scop);\n+                  end loop;\n+\n+                  --  Treat the return object's type as having the level of the\n+                  --  function's result subtype (as per RM05-6.5(5.3/2)).\n+\n+                  return Type_Access_Level (Etype (Scop), Allow_Alt_Model);\n+               end;\n+            end if;\n+         end if;\n+\n+         Btyp := Root_Type (Btyp);\n+\n+         --  The accessibility level of anonymous access types associated with\n+         --  discriminants is that of the current instance of the type, and\n+         --  that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n+\n+         --  AI-402: access discriminants have accessibility based on the\n+         --  object rather than the type in Ada 2005, so the above paragraph\n+         --  doesn't apply.\n+\n+         --  ??? Needs completion with rules from AI-416\n+\n+         if Ada_Version <= Ada_95\n+           and then Ekind (Typ) = E_Anonymous_Access_Type\n+           and then Present (Associated_Node_For_Itype (Typ))\n+           and then Nkind (Associated_Node_For_Itype (Typ)) =\n+                                                 N_Discriminant_Specification\n+         then\n+            return Scope_Depth (Enclosing_Dynamic_Scope (Btyp)) + 1;\n+         end if;\n+      end if;\n+\n+      --  Return library level for a generic formal type. This is done because\n+      --  RM(10.3.2) says that \"The statically deeper relationship does not\n+      --  apply to ... a descendant of a generic formal type\". Rather than\n+      --  checking at each point where a static accessibility check is\n+      --  performed to see if we are dealing with a formal type, this rule is\n+      --  implemented by having Type_Access_Level and Deepest_Type_Access_Level\n+      --  return extreme values for a formal type; Deepest_Type_Access_Level\n+      --  returns Int'Last. By calling the appropriate function from among the\n+      --  two, we ensure that the static accessibility check will pass if we\n+      --  happen to run into a formal type. More specifically, we should call\n+      --  Deepest_Type_Access_Level instead of Type_Access_Level whenever the\n+      --  call occurs as part of a static accessibility check and the error\n+      --  case is the case where the type's level is too shallow (as opposed\n+      --  to too deep).\n+\n+      if Is_Generic_Type (Root_Type (Btyp)) then\n+         return Scope_Depth (Standard_Standard);\n+      end if;\n+\n+      return Scope_Depth (Enclosing_Dynamic_Scope (Btyp));\n+   end Type_Access_Level;\n+\n+end Accessibility;"}, {"sha": "454ad759ec4d6ea5e44962cdf4b48ca33a2b927b", "filename": "gcc/ada/accessibility.ads", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Faccessibility.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Faccessibility.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faccessibility.ads?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -0,0 +1,222 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        A C C E S S I B I L I T Y                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Accessibility level and check generation routines\n+\n+with Types; use Types;\n+with Uintp; use Uintp;\n+\n+package Accessibility is\n+\n+   procedure Accessibility_Message (N : Node_Id; Typ : Entity_Id);\n+   --  Error, or warning within an instance, if the static accessibility\n+   --  rules of 3.10.2 are violated.\n+\n+   type Accessibility_Level_Kind is\n+     (Dynamic_Level,\n+      Object_Decl_Level,\n+      Zero_On_Dynamic_Level);\n+   --  Accessibility_Level_Kind is an enumerated type which captures the\n+   --  different modes in which an accessibility level could be obtained for\n+   --  a given expression.\n+\n+   --  When in the context of the function Accessibility_Level,\n+   --  Accessibility_Level_Kind signals what type of accessibility level to\n+   --  obtain. For example, when Level is Dynamic_Level, a defining identifier\n+   --  associated with a SAOOAAT may be returned or an N_Integer_Literal node.\n+   --  When the level is Object_Decl_Level, an N_Integer_Literal node is\n+   --  returned containing the level of the declaration of the object if\n+   --  relevant (be it a SAOOAAT or otherwise). Finally, Zero_On_Dynamic_Level\n+   --  returns library level for all cases where the accessibility level is\n+   --  dynamic (used to bypass static accessibility checks in dynamic cases).\n+\n+   function Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False;\n+      Allow_Alt_Model   : Boolean := True) return Node_Id;\n+   --  Centralized accessibility level calculation routine for finding the\n+   --  accessibility level of a given expression Expr.\n+\n+   --  In_Return_Context forces the Accessibility_Level calculations to be\n+   --  carried out \"as if\" Expr existed in a return value. This is useful for\n+   --  calculating the accessibility levels for discriminant associations\n+   --  and return aggregates.\n+\n+   --  The Allow_Alt_Model parameter allows the alternative level calculation\n+   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n+\n+   procedure Apply_Accessibility_Check\n+     (N           : Node_Id;\n+      Typ         : Entity_Id;\n+      Insert_Node : Node_Id);\n+   --  Given a name N denoting an access parameter, emits a run-time\n+   --  accessibility check (if necessary), checking that the level of\n+   --  the object denoted by the access parameter is not deeper than the\n+   --  level of the type Typ. Program_Error is raised if the check fails.\n+   --  Insert_Node indicates the node where the check should be inserted.\n+\n+   procedure Apply_Accessibility_Check_For_Allocator\n+     (N              : Node_Id;\n+      Exp            : Node_Id;\n+      Ref            : Node_Id;\n+      Built_In_Place : Boolean := False);\n+   --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n+   --  type, generate an accessibility check to verify that the level of the\n+   --  type of the created object is not deeper than the level of the access\n+   --  type. If the type of the qualified expression is class-wide, then\n+   --  always generate the check (except in the case where it is known to be\n+   --  unnecessary, see comment below). Otherwise, only generate the check\n+   --  if the level of the qualified expression type is statically deeper\n+   --  than the access type.\n+   --\n+   --  Although the static accessibility will generally have been performed\n+   --  as a legality check, it won't have been done in cases where the\n+   --  allocator appears in generic body, so a run-time check is needed in\n+   --  general. One special case is when the access type is declared in the\n+   --  same scope as the class-wide allocator, in which case the check can\n+   --  never fail, so it need not be generated.\n+   --\n+   --  As an open issue, there seem to be cases where the static level\n+   --  associated with the class-wide object's underlying type is not\n+   --  sufficient to perform the proper accessibility check, such as for\n+   --  allocators in nested subprograms or accept statements initialized by\n+   --  class-wide formals when the actual originates outside at a deeper\n+   --  static level. The nested subprogram case might require passing\n+   --  accessibility levels along with class-wide parameters, and the task\n+   --  case seems to be an actual gap in the language rules that needs to\n+   --  be fixed by the ARG. ???\n+\n+   procedure Check_Return_Construct_Accessibility\n+     (Return_Stmt : Node_Id;\n+      Stm_Entity  : Entity_Id);\n+   --  Apply legality rule of 6.5 (5.9) to the access discriminants of an\n+   --  aggregate in a return statement.\n+\n+   function Deepest_Type_Access_Level\n+     (Typ             : Entity_Id;\n+      Allow_Alt_Model : Boolean := True) return Uint;\n+   --  Same as Type_Access_Level, except that if the type is the type of an Ada\n+   --  2012 stand-alone object of an anonymous access type, then return the\n+   --  static accessibility level of the object. In that case, the dynamic\n+   --  accessibility level of the object may take on values in a range. The low\n+   --  bound of that range is returned by Type_Access_Level; this function\n+   --  yields the high bound of that range. Also differs from Type_Access_Level\n+   --  in the case of a descendant of a generic formal type (returns Int'Last\n+   --  instead of 0).\n+\n+   --  The Allow_Alt_Model parameter allows the alternative level calculation\n+   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n+\n+   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id;\n+   --  Same as Einfo.Extra_Accessibility except thtat object renames\n+   --  are looked through.\n+\n+   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id;\n+   --  Obtain the accessibility level for a given entity formal taking into\n+   --  account both extra and minimum accessibility.\n+\n+   function Has_Access_Values (T : Entity_Id) return Boolean;\n+   --  Returns true if the underlying type of T is an access type, or has a\n+   --  component (at any recursive level) that is an access type. This is a\n+   --  conservative predicate, if it is not known whether or not T contains\n+   --  access values (happens for generic formals in some cases), then False is\n+   --  returned.  Note that tagged types return False. Even though the tag is\n+   --  implemented as an access type internally, this function tests only for\n+   --  access types known to the programmer. See also Has_Tagged_Component.\n+\n+   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean;\n+   --  Returns True if Typ has one or more anonymous access discriminants\n+\n+   function Prefix_With_Safe_Accessibility_Level\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   --  Return True if the prefix does not have a value conversion of an\n+   --  array because a value conversion is like an aggregate with respect\n+   --  to determining accessibility level (RM 3.10.2); even if evaluation\n+   --  of a value conversion is guaranteed to not create a new object,\n+   --  accessibility rules are defined as if it might.\n+\n+   subtype Static_Accessibility_Level_Kind\n+     is Accessibility_Level_Kind range Object_Decl_Level\n+                                         .. Zero_On_Dynamic_Level;\n+   --  Restrict the reange of Accessibility_Level_Kind to be non-dynamic for\n+   --  use in the static version of Accessibility_Level below.\n+\n+   function Static_Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Static_Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Uint;\n+   --  Overloaded version of Accessibility_Level which returns a universal\n+   --  integer for use in compile-time checking. Note: Level is restricted to\n+   --  be non-dynamic.\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean;\n+   --  Returns True if the given subtype is unconstrained and has one or more\n+   --  access discriminants.\n+\n+   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean;\n+   --  Determine if N is used as an actual for a call whose corresponding\n+   --  formal is of an anonymous access type.\n+\n+   function Is_Special_Aliased_Formal_Access\n+     (Exp               : Node_Id;\n+      In_Return_Context : Boolean := False) return Boolean;\n+   --  Determines whether a dynamic check must be generated for explicitly\n+   --  aliased formals within a function Scop for the expression Exp.\n+\n+   --  In_Return_Context forces Is_Special_Aliased_Formal_Access to assume\n+   --  that Exp is within a return value which is useful for checking\n+   --  expressions within discriminant associations of return objects.\n+\n+   --  More specially, Is_Special_Aliased_Formal_Access checks that Exp is a\n+   --  'Access attribute reference within a return statement where the ultimate\n+   --  prefix is an aliased formal of Scop and that Scop returns an anonymous\n+   --  access type. See RM 3.10.2 for more details.\n+\n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean;\n+   --  Ada 2012 (AI05-0234): Return True if the function needs an implicit\n+   --  parameter to identify the accessibility level of the function result\n+   --  \"determined by the point of call\".\n+\n+   function Subprogram_Access_Level (Subp : Entity_Id) return Uint;\n+   --  Return the accessibility level of the view denoted by Subp\n+\n+   function Type_Access_Level\n+     (Typ             : Entity_Id;\n+      Allow_Alt_Model : Boolean   := True;\n+      Assoc_Ent       : Entity_Id := Empty) return Uint;\n+   --  Return the accessibility level of Typ\n+\n+   --  The Allow_Alt_Model parameter allows the alternative level calculation\n+   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n+\n+   --  Assoc_Ent allows for the optional specification of the entity associated\n+   --  with Typ. This gets utilized mostly for anonymous access type\n+   --  processing, where context matters in interpreting Typ's level.\n+\n+end Accessibility;"}, {"sha": "5833be3a5de5abea56d427561f75f05694988702", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -570,119 +570,6 @@ package body Checks is\n       Install_Null_Excluding_Check (P);\n    end Apply_Access_Check;\n \n-   -------------------------------\n-   -- Apply_Accessibility_Check --\n-   -------------------------------\n-\n-   procedure Apply_Accessibility_Check\n-     (N           : Node_Id;\n-      Typ         : Entity_Id;\n-      Insert_Node : Node_Id)\n-   is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      Check_Cond  : Node_Id;\n-      Param_Ent   : Entity_Id := Param_Entity (N);\n-      Param_Level : Node_Id;\n-      Type_Level  : Node_Id;\n-\n-   begin\n-      --  Verify we haven't tried to add a dynamic accessibility check when we\n-      --  shouldn't.\n-\n-      pragma Assert (not No_Dynamic_Accessibility_Checks_Enabled (N));\n-\n-      if Ada_Version >= Ada_2012\n-         and then No (Param_Ent)\n-         and then Is_Entity_Name (N)\n-         and then Ekind (Entity (N)) in E_Constant | E_Variable\n-         and then Present (Effective_Extra_Accessibility (Entity (N)))\n-      then\n-         Param_Ent := Entity (N);\n-         while Present (Renamed_Object (Param_Ent)) loop\n-            --  Renamed_Object must return an Entity_Name here\n-            --  because of preceding \"Present (E_E_A (...))\" test.\n-\n-            Param_Ent := Entity (Renamed_Object (Param_Ent));\n-         end loop;\n-      end if;\n-\n-      if Inside_A_Generic then\n-         return;\n-\n-      --  Only apply the run-time check if the access parameter has an\n-      --  associated extra access level parameter and when accessibility checks\n-      --  are enabled.\n-\n-      elsif Present (Param_Ent)\n-         and then Present (Get_Dynamic_Accessibility (Param_Ent))\n-         and then not Accessibility_Checks_Suppressed (Param_Ent)\n-         and then not Accessibility_Checks_Suppressed (Typ)\n-      then\n-         --  Obtain the parameter's accessibility level\n-\n-         Param_Level :=\n-           New_Occurrence_Of (Get_Dynamic_Accessibility (Param_Ent), Loc);\n-\n-         --  Use the dynamic accessibility parameter for the function's result\n-         --  when one has been created instead of statically referring to the\n-         --  deepest type level so as to appropriatly handle the rules for\n-         --  RM 3.10.2 (10.1/3).\n-\n-         if Ekind (Scope (Param_Ent)) = E_Function\n-           and then In_Return_Value (N)\n-           and then Ekind (Typ) = E_Anonymous_Access_Type\n-         then\n-            --  Associate the level of the result type to the extra result\n-            --  accessibility parameter belonging to the current function.\n-\n-            if Present (Extra_Accessibility_Of_Result (Scope (Param_Ent))) then\n-               Type_Level :=\n-                 New_Occurrence_Of\n-                   (Extra_Accessibility_Of_Result (Scope (Param_Ent)), Loc);\n-\n-            --  In Ada 2005 and earlier modes, a result extra accessibility\n-            --  parameter is not generated and no dynamic check is performed.\n-\n-            else\n-               return;\n-            end if;\n-\n-         --  Otherwise get the type's accessibility level normally\n-\n-         else\n-            Type_Level :=\n-              Make_Integer_Literal (Loc, Deepest_Type_Access_Level (Typ));\n-         end if;\n-\n-         --  Raise Program_Error if the accessibility level of the access\n-         --  parameter is deeper than the level of the target access type.\n-\n-         Check_Cond :=\n-           Make_Op_Gt (Loc,\n-             Left_Opnd  => Param_Level,\n-             Right_Opnd => Type_Level);\n-\n-         Insert_Action (Insert_Node,\n-           Make_Raise_Program_Error (Loc,\n-             Condition => Check_Cond,\n-             Reason    => PE_Accessibility_Check_Failed));\n-\n-         Analyze_And_Resolve (N);\n-\n-         --  If constant folding has happened on the condition for the\n-         --  generated error, then warn about it being unconditional.\n-\n-         if Nkind (Check_Cond) = N_Identifier\n-           and then Entity (Check_Cond) = Standard_True\n-         then\n-            Error_Msg_Warn := SPARK_Mode /= On;\n-            Error_Msg_N (\"accessibility check fails<<\", N);\n-            Error_Msg_N (\"\\Program_Error [<<\", N);\n-         end if;\n-      end if;\n-   end Apply_Accessibility_Check;\n-\n    --------------------------------\n    -- Apply_Address_Clause_Check --\n    --------------------------------"}, {"sha": "772adf00afa4be2650c693ee0c6661b017a90f43", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -189,16 +189,6 @@ package Checks is\n    --  Determines whether an expression node requires a run-time access\n    --  check and if so inserts the appropriate run-time check.\n \n-   procedure Apply_Accessibility_Check\n-     (N           : Node_Id;\n-      Typ         : Entity_Id;\n-      Insert_Node : Node_Id);\n-   --  Given a name N denoting an access parameter, emits a run-time\n-   --  accessibility check (if necessary), checking that the level of\n-   --  the object denoted by the access parameter is not deeper than the\n-   --  level of the type Typ. Program_Error is raised if the check fails.\n-   --  Insert_Node indicates the node where the check should be inserted.\n-\n    procedure Apply_Address_Clause_Check (E : Entity_Id; N : Node_Id);\n    --  E is the entity for an object which has an address clause. If checks\n    --  are enabled, then this procedure generates a check that the specified"}, {"sha": "b7554e05f7785c1a845b2f7cb766fcd0a05b53bc", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n@@ -2215,13 +2216,25 @@ package body Exp_Attr is\n \n             --  Local declarations\n \n-            Enc_Object : constant Node_Id := Enclosing_Object (Ref_Object);\n+            Enc_Object : Node_Id := Enclosing_Object (Ref_Object);\n \n          --  Start of processing for Access_Cases\n \n          begin\n             Btyp_DDT := Designated_Type (Btyp);\n \n+            --  When Enc_Object is a view conversion then RM 3.10.2 (9)\n+            --  applies and we obtain the expression being converted.\n+            --  Otherwise we do not dig any deeper since a conversion\n+            --  might generate a copy and we can't assume it will be as\n+            --  long-lived as the original.\n+\n+            while Nkind (Enc_Object) = N_Type_Conversion\n+              and then Is_View_Conversion (Enc_Object)\n+            loop\n+               Enc_Object := Expression (Enc_Object);\n+            end loop;\n+\n             --  Handle designated types that come from the limited view\n \n             if From_Limited_With (Btyp_DDT)"}, {"sha": "5050ec6eab52c0b9cca5f37083365318d939c0e5", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;"}, {"sha": "00d19e765a6a6c15318a79c38a13e99de9ed18c1", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 217, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n@@ -33,7 +34,6 @@ with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n with Exp_Aggr;       use Exp_Aggr;\n-with Exp_Atag;       use Exp_Atag;\n with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch7;        use Exp_Ch7;\n@@ -560,219 +560,6 @@ package body Exp_Ch4 is\n       PtrT   : constant Entity_Id  := Etype (N);\n       DesigT : constant Entity_Id  := Designated_Type (PtrT);\n \n-      procedure Apply_Accessibility_Check\n-        (Ref            : Node_Id;\n-         Built_In_Place : Boolean := False);\n-      --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n-      --  type, generate an accessibility check to verify that the level of the\n-      --  type of the created object is not deeper than the level of the access\n-      --  type. If the type of the qualified expression is class-wide, then\n-      --  always generate the check (except in the case where it is known to be\n-      --  unnecessary, see comment below). Otherwise, only generate the check\n-      --  if the level of the qualified expression type is statically deeper\n-      --  than the access type.\n-      --\n-      --  Although the static accessibility will generally have been performed\n-      --  as a legality check, it won't have been done in cases where the\n-      --  allocator appears in generic body, so a run-time check is needed in\n-      --  general. One special case is when the access type is declared in the\n-      --  same scope as the class-wide allocator, in which case the check can\n-      --  never fail, so it need not be generated.\n-      --\n-      --  As an open issue, there seem to be cases where the static level\n-      --  associated with the class-wide object's underlying type is not\n-      --  sufficient to perform the proper accessibility check, such as for\n-      --  allocators in nested subprograms or accept statements initialized by\n-      --  class-wide formals when the actual originates outside at a deeper\n-      --  static level. The nested subprogram case might require passing\n-      --  accessibility levels along with class-wide parameters, and the task\n-      --  case seems to be an actual gap in the language rules that needs to\n-      --  be fixed by the ARG. ???\n-\n-      -------------------------------\n-      -- Apply_Accessibility_Check --\n-      -------------------------------\n-\n-      procedure Apply_Accessibility_Check\n-        (Ref            : Node_Id;\n-         Built_In_Place : Boolean := False)\n-      is\n-         Pool_Id   : constant Entity_Id := Associated_Storage_Pool (PtrT);\n-         Cond      : Node_Id;\n-         Fin_Call  : Node_Id;\n-         Free_Stmt : Node_Id;\n-         Obj_Ref   : Node_Id;\n-         Stmts     : List_Id;\n-\n-      begin\n-         if Ada_Version >= Ada_2005\n-           and then Is_Class_Wide_Type (DesigT)\n-           and then Tagged_Type_Expansion\n-           and then not Scope_Suppress.Suppress (Accessibility_Check)\n-           and then not No_Dynamic_Accessibility_Checks_Enabled (Ref)\n-           and then\n-             (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n-               or else\n-                 (Is_Class_Wide_Type (Etype (Exp))\n-                   and then Scope (PtrT) /= Current_Scope))\n-         then\n-            --  If the allocator was built in place, Ref is already a reference\n-            --  to the access object initialized to the result of the allocator\n-            --  (see Exp_Ch6.Make_Build_In_Place_Call_In_Allocator). We call\n-            --  Remove_Side_Effects for cases where the build-in-place call may\n-            --  still be the prefix of the reference (to avoid generating\n-            --  duplicate calls). Otherwise, it is the entity associated with\n-            --  the object containing the address of the allocated object.\n-\n-            if Built_In_Place then\n-               Remove_Side_Effects (Ref);\n-               Obj_Ref := New_Copy_Tree (Ref);\n-            else\n-               Obj_Ref := New_Occurrence_Of (Ref, Loc);\n-            end if;\n-\n-            --  For access to interface types we must generate code to displace\n-            --  the pointer to the base of the object since the subsequent code\n-            --  references components located in the TSD of the object (which\n-            --  is associated with the primary dispatch table --see a-tags.ads)\n-            --  and also generates code invoking Free, which requires also a\n-            --  reference to the base of the unallocated object.\n-\n-            if Is_Interface (DesigT) and then Tagged_Type_Expansion then\n-               Obj_Ref :=\n-                 Unchecked_Convert_To (Etype (Obj_Ref),\n-                   Make_Function_Call (Loc,\n-                     Name                   =>\n-                       New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n-                     Parameter_Associations => New_List (\n-                       Unchecked_Convert_To (RTE (RE_Address),\n-                         New_Copy_Tree (Obj_Ref)))));\n-            end if;\n-\n-            --  Step 1: Create the object clean up code\n-\n-            Stmts := New_List;\n-\n-            --  Deallocate the object if the accessibility check fails. This\n-            --  is done only on targets or profiles that support deallocation.\n-\n-            --    Free (Obj_Ref);\n-\n-            if RTE_Available (RE_Free) then\n-               Free_Stmt := Make_Free_Statement (Loc, New_Copy_Tree (Obj_Ref));\n-               Set_Storage_Pool (Free_Stmt, Pool_Id);\n-\n-               Append_To (Stmts, Free_Stmt);\n-\n-            --  The target or profile cannot deallocate objects\n-\n-            else\n-               Free_Stmt := Empty;\n-            end if;\n-\n-            --  Finalize the object if applicable. Generate:\n-\n-            --    [Deep_]Finalize (Obj_Ref.all);\n-\n-            if Needs_Finalization (DesigT)\n-              and then not No_Heap_Finalization (PtrT)\n-            then\n-               Fin_Call :=\n-                 Make_Final_Call\n-                   (Obj_Ref =>\n-                      Make_Explicit_Dereference (Loc, New_Copy (Obj_Ref)),\n-                    Typ     => DesigT);\n-\n-               --  Guard against a missing [Deep_]Finalize when the designated\n-               --  type was not properly frozen.\n-\n-               if No (Fin_Call) then\n-                  Fin_Call := Make_Null_Statement (Loc);\n-               end if;\n-\n-               --  When the target or profile supports deallocation, wrap the\n-               --  finalization call in a block to ensure proper deallocation\n-               --  even if finalization fails. Generate:\n-\n-               --    begin\n-               --       <Fin_Call>\n-               --    exception\n-               --       when others =>\n-               --          <Free_Stmt>\n-               --          raise;\n-               --    end;\n-\n-               if Present (Free_Stmt) then\n-                  Fin_Call :=\n-                    Make_Block_Statement (Loc,\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                          Statements => New_List (Fin_Call),\n-\n-                        Exception_Handlers => New_List (\n-                          Make_Exception_Handler (Loc,\n-                            Exception_Choices => New_List (\n-                              Make_Others_Choice (Loc)),\n-                            Statements        => New_List (\n-                              New_Copy_Tree (Free_Stmt),\n-                              Make_Raise_Statement (Loc))))));\n-               end if;\n-\n-               Prepend_To (Stmts, Fin_Call);\n-            end if;\n-\n-            --  Signal the accessibility failure through a Program_Error\n-\n-            Append_To (Stmts,\n-              Make_Raise_Program_Error (Loc,\n-                Reason => PE_Accessibility_Check_Failed));\n-\n-            --  Step 2: Create the accessibility comparison\n-\n-            --  Generate:\n-            --    Ref'Tag\n-\n-            Obj_Ref :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => Obj_Ref,\n-                Attribute_Name => Name_Tag);\n-\n-            --  For tagged types, determine the accessibility level by looking\n-            --  at the type specific data of the dispatch table. Generate:\n-\n-            --    Type_Specific_Data (Address (Ref'Tag)).Access_Level\n-\n-            if Tagged_Type_Expansion then\n-               Cond := Build_Get_Access_Level (Loc, Obj_Ref);\n-\n-            --  Use a runtime call to determine the accessibility level when\n-            --  compiling on virtual machine targets. Generate:\n-\n-            --    Get_Access_Level (Ref'Tag)\n-\n-            else\n-               Cond :=\n-                 Make_Function_Call (Loc,\n-                   Name                   =>\n-                     New_Occurrence_Of (RTE (RE_Get_Access_Level), Loc),\n-                   Parameter_Associations => New_List (Obj_Ref));\n-            end if;\n-\n-            Cond :=\n-              Make_Op_Gt (Loc,\n-                Left_Opnd  => Cond,\n-                Right_Opnd => Accessibility_Level (N, Dynamic_Level));\n-\n-            --  Due to the complexity and side effects of the check, utilize an\n-            --  if statement instead of the regular Program_Error circuitry.\n-\n-            Insert_Action (N,\n-              Make_Implicit_If_Statement (N,\n-                Condition       => Cond,\n-                Then_Statements => Stmts));\n-         end if;\n-      end Apply_Accessibility_Check;\n-\n       --  Local variables\n \n       Indic         : constant Node_Id   := Subtype_Mark (Expression (N));\n@@ -884,7 +671,8 @@ package body Exp_Ch4 is\n \n          if Is_Build_In_Place_Function_Call (Exp) then\n             Make_Build_In_Place_Call_In_Allocator (N, Exp);\n-            Apply_Accessibility_Check (N, Built_In_Place => True);\n+            Apply_Accessibility_Check_For_Allocator\n+              (N, Exp, N, Built_In_Place => True);\n             return;\n \n          --  Ada 2005 (AI-318-02): Specialization of the previous case for\n@@ -896,7 +684,8 @@ package body Exp_Ch4 is\n \n          elsif Present (Unqual_BIP_Iface_Function_Call (Exp)) then\n             Make_Build_In_Place_Iface_Call_In_Allocator (N, Exp);\n-            Apply_Accessibility_Check (N, Built_In_Place => True);\n+            Apply_Accessibility_Check_For_Allocator\n+              (N, Exp, N, Built_In_Place => True);\n             return;\n          end if;\n \n@@ -1191,7 +980,7 @@ package body Exp_Ch4 is\n          --  Note: the accessibility check must be inserted after the call to\n          --  [Deep_]Adjust to ensure proper completion of the assignment.\n \n-         Apply_Accessibility_Check (Temp);\n+         Apply_Accessibility_Check_For_Allocator (N, Exp, Temp);\n \n          Rewrite (N, New_Occurrence_Of (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);"}, {"sha": "d67f788ab7830d216c57b114f8df7b0208faa2e8", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;"}, {"sha": "ae59ad7017d1f7abb016e06f6643c9758a713363", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;"}, {"sha": "7d76144ceff0c2f82f752a49a7a7338aa6c7ddd0", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;"}, {"sha": "e0ad27e0677cbc6033a65efa4e200623301b42b4", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Atree;          use Atree;\n with Checks;         use Checks;\n with Debug;          use Debug;"}, {"sha": "2acd195017ea0746c236899b9d694d9823a739fc", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -399,6 +399,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/sem_ch12.o\t\\\n  ada/sem_ch13.o\t\\\n  ada/sem_ch2.o\t\\\n+ ada/accessibility.o\t\\\n  ada/sem_ch3.o\t\\\n  ada/sem_ch4.o\t\\\n  ada/sem_ch5.o\t\\"}, {"sha": "e0dba9e6a5c7f48bb445261aa5be253e080e1edc", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -98,6 +98,7 @@ package Gen_IL.Fields is\n       Cleanup_Actions,\n       Comes_From_Check_Or_Contract,\n       Comes_From_Extended_Return_Statement,\n+      Comes_From_Iterator,\n       Compile_Time_Known_Aggregate,\n       Component_Associations,\n       Component_Clauses,"}, {"sha": "ba4539140fedcdc110f496a62ebeffdac4401488", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -906,6 +906,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Subtype_Mark, Node_Id, Default_Empty),\n         Sy (Access_Definition, Node_Id, Default_Empty),\n         Sy (Name, Node_Id, Default_Empty),\n+        Sm (Comes_From_Iterator, Flag),\n         Sm (Corresponding_Generic_Association, Node_Id)));\n \n    Cc (N_Package_Renaming_Declaration, N_Renaming_Declaration,"}, {"sha": "433f1ac84ca3ad4f7a351c42e65d1c0220225937", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -3242,7 +3242,7 @@ package body Sem_Aggr is\n             end loop;\n          end;\n \n-      else\n+      elsif Present (Assign_Indexed_Subp) then\n          --  Indexed Aggregate. Positional or indexed component\n          --  can be present, but not both. Choices must be static\n          --  values or ranges with static bounds."}, {"sha": "7c76f0fef0aeb14cbcd90320b493f56a1de54c1e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 128, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -25,6 +25,7 @@\n \n with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Casing;         use Casing;\n@@ -10936,72 +10937,12 @@ package body Sem_Attr is\n       It       : Interp;\n       Nom_Subt : Entity_Id;\n \n-      procedure Accessibility_Message;\n-      --  Error, or warning within an instance, if the static accessibility\n-      --  rules of 3.10.2 are violated.\n-\n       function Declared_Within_Generic_Unit\n         (Entity       : Entity_Id;\n          Generic_Unit : Node_Id) return Boolean;\n       --  Returns True if Declared_Entity is declared within the declarative\n       --  region of Generic_Unit; otherwise returns False.\n \n-      function Prefix_With_Safe_Accessibility_Level return Boolean;\n-      --  Return True if the prefix does not have a value conversion of an\n-      --  array because a value conversion is like an aggregate with respect\n-      --  to determining accessibility level (RM 3.10.2); even if evaluation\n-      --  of a value conversion is guaranteed to not create a new object,\n-      --  accessibility rules are defined as if it might.\n-\n-      ---------------------------\n-      -- Accessibility_Message --\n-      ---------------------------\n-\n-      procedure Accessibility_Message is\n-         Indic : Node_Id := Parent (Parent (N));\n-\n-      begin\n-         --  In an instance, this is a runtime check, but one we\n-         --  know will fail, so generate an appropriate warning.\n-\n-         if In_Instance_Body then\n-            Error_Msg_Warn := SPARK_Mode /= On;\n-            Error_Msg_F\n-              (\"non-local pointer cannot point to local object<<\", P);\n-            Error_Msg_F (\"\\Program_Error [<<\", P);\n-            Rewrite (N,\n-              Make_Raise_Program_Error (Loc,\n-                Reason => PE_Accessibility_Check_Failed));\n-            Set_Etype (N, Typ);\n-            return;\n-\n-         else\n-            Error_Msg_F (\"non-local pointer cannot point to local object\", P);\n-\n-            --  Check for case where we have a missing access definition\n-\n-            if Is_Record_Type (Current_Scope)\n-              and then\n-                Nkind (Parent (N)) in N_Discriminant_Association\n-                                    | N_Index_Or_Discriminant_Constraint\n-            then\n-               Indic := Parent (Parent (N));\n-               while Present (Indic)\n-                 and then Nkind (Indic) /= N_Subtype_Indication\n-               loop\n-                  Indic := Parent (Indic);\n-               end loop;\n-\n-               if Present (Indic) then\n-                  Error_Msg_NE\n-                    (\"\\use an access definition for\" &\n-                     \" the access discriminant of&\",\n-                     N, Entity (Subtype_Mark (Indic)));\n-               end if;\n-            end if;\n-         end if;\n-      end Accessibility_Message;\n-\n       ----------------------------------\n       -- Declared_Within_Generic_Unit --\n       ----------------------------------\n@@ -11029,70 +10970,6 @@ package body Sem_Attr is\n          return False;\n       end Declared_Within_Generic_Unit;\n \n-      ------------------------------------------\n-      -- Prefix_With_Safe_Accessibility_Level --\n-      ------------------------------------------\n-\n-      function Prefix_With_Safe_Accessibility_Level return Boolean is\n-         function Safe_Value_Conversions return Boolean;\n-         --  Return False if the prefix has a value conversion of an array type\n-\n-         ----------------------------\n-         -- Safe_Value_Conversions --\n-         ----------------------------\n-\n-         function Safe_Value_Conversions return Boolean is\n-            PP : Node_Id := P;\n-\n-         begin\n-            loop\n-               if Nkind (PP) in N_Selected_Component | N_Indexed_Component then\n-                  PP := Prefix (PP);\n-\n-               elsif Comes_From_Source (PP)\n-                 and then Nkind (PP) in N_Type_Conversion\n-                                      | N_Unchecked_Type_Conversion\n-                 and then Is_Array_Type (Etype (PP))\n-               then\n-                  return False;\n-\n-               elsif Comes_From_Source (PP)\n-                 and then Nkind (PP) = N_Qualified_Expression\n-                 and then Is_Array_Type (Etype (PP))\n-                 and then Nkind (Original_Node (Expression (PP))) in\n-                            N_Aggregate | N_Extension_Aggregate\n-               then\n-                  return False;\n-\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            return True;\n-         end Safe_Value_Conversions;\n-\n-      --  Start of processing for Prefix_With_Safe_Accessibility_Level\n-\n-      begin\n-         --  No check required for unchecked and unrestricted access\n-\n-         if Attr_Id = Attribute_Unchecked_Access\n-           or else Attr_Id = Attribute_Unrestricted_Access\n-         then\n-            return True;\n-\n-         --  Check value conversions\n-\n-         elsif Ekind (Btyp) = E_General_Access_Type\n-           and then not Safe_Value_Conversions\n-         then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end Prefix_With_Safe_Accessibility_Level;\n-\n    --  Start of processing for Resolve_Attribute\n \n    begin\n@@ -11778,7 +11655,7 @@ package body Sem_Attr is\n                       Intval (Accessibility_Level (P, Dynamic_Level))\n                         > Deepest_Type_Access_Level (Btyp)\n                   then\n-                     Accessibility_Message;\n+                     Accessibility_Message (N, Typ);\n                      return;\n                   end if;\n                end;\n@@ -11804,7 +11681,7 @@ package body Sem_Attr is\n                  and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n                  and then Attr_Id /= Attribute_Unrestricted_Access\n                then\n-                  Accessibility_Message;\n+                  Accessibility_Message (N, Typ);\n                   return;\n \n                --  AI05-0225: If the context is not an access to protected\n@@ -11963,8 +11840,8 @@ package body Sem_Attr is\n             --  array type since a value conversion is like an aggregate with\n             --  respect to determining accessibility level (RM 3.10.2).\n \n-            if not Prefix_With_Safe_Accessibility_Level then\n-               Accessibility_Message;\n+            if not Prefix_With_Safe_Accessibility_Level (N, Typ) then\n+               Accessibility_Message (N, Typ);\n                return;\n             end if;\n "}, {"sha": "618f935e4fe1ebee68f851a3848626dc22da4143", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;    use Accessibility;\n with Aspects;          use Aspects;\n with Atree;            use Atree;\n with Checks;           use Checks;"}, {"sha": "abee91f27fd7e13d8c4e69589e311c9ff106de6c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;"}, {"sha": "c8c0d80ffcdf033c0bca4363b19dd27d12eed956", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Debug;          use Debug;"}, {"sha": "c1523ae11e2ede385a3e243c97689e74188d8a1a", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -2523,6 +2523,7 @@ package body Sem_Ch5 is\n                 Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n                 Name                =>\n                   New_Copy_Tree (Iter_Name, New_Sloc => Loc));\n+            Set_Comes_From_Iterator (Decl);\n \n             Insert_Actions (Parent (Parent (N)), New_List (Decl));\n             Rewrite (Name (N), New_Occurrence_Of (Id, Loc));"}, {"sha": "d567f79b27e65adecf7ec9551cae46249ccde2a5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 516, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n@@ -745,10 +746,6 @@ package body Sem_Ch6 is\n       --  Ada 2022: Check that the return expression in a No_Return function\n       --  meets the conditions specified by RM 6.5.1(5.1/5).\n \n-      procedure Check_Return_Construct_Accessibility (Return_Stmt : Node_Id);\n-      --  Apply legality rule of 6.5 (5.9) to the access discriminants of an\n-      --  aggregate in a return statement.\n-\n       procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id);\n       --  Check that the return_subtype_indication properly matches the result\n       --  subtype of the function, as required by RM-6.5(5.1/2-5.3/2).\n@@ -781,516 +778,6 @@ package body Sem_Ch6 is\n             Return_Expr);\n       end Check_No_Return_Expression;\n \n-      ------------------------------------------\n-      -- Check_Return_Construct_Accessibility --\n-      ------------------------------------------\n-\n-      procedure Check_Return_Construct_Accessibility (Return_Stmt : Node_Id) is\n-\n-         function First_Selector (Assoc : Node_Id) return Node_Id;\n-         --  Obtain the first selector or choice from a given association\n-\n-         function Is_Formal_Of_Current_Function\n-           (Assoc_Expr : Entity_Id) return Boolean;\n-         --  Predicate to test if a given expression associated with a\n-         --  discriminant is a formal parameter to the function in which the\n-         --  return construct we checking applies to.\n-\n-         --------------------\n-         -- First_Selector --\n-         --------------------\n-\n-         function First_Selector (Assoc : Node_Id) return Node_Id is\n-         begin\n-            if Nkind (Assoc) = N_Component_Association then\n-               return First (Choices (Assoc));\n-\n-            elsif Nkind (Assoc) = N_Discriminant_Association then\n-               return (First (Selector_Names (Assoc)));\n-\n-            else\n-               raise Program_Error;\n-            end if;\n-         end First_Selector;\n-\n-         -----------------------------------\n-         -- Is_Formal_Of_Current_Function --\n-         -----------------------------------\n-\n-         function Is_Formal_Of_Current_Function\n-           (Assoc_Expr : Entity_Id) return Boolean is\n-         begin\n-            return Is_Entity_Name (Assoc_Expr)\n-                     and then Enclosing_Subprogram\n-                                (Entity (Assoc_Expr)) = Scope_Id\n-                     and then Is_Formal (Entity (Assoc_Expr));\n-         end Is_Formal_Of_Current_Function;\n-\n-         --  Local declarations\n-\n-         Assoc : Node_Id := Empty;\n-         --  Assoc should perhaps be renamed and declared as a\n-         --  Node_Or_Entity_Id since it encompasses not only component and\n-         --  discriminant associations, but also discriminant components within\n-         --  a type declaration or subtype indication ???\n-\n-         Assoc_Expr    : Node_Id;\n-         Assoc_Present : Boolean := False;\n-\n-         Check_Cond        : Node_Id;\n-         Unseen_Disc_Count : Nat := 0;\n-         Seen_Discs        : Elist_Id;\n-         Disc              : Entity_Id;\n-         First_Disc        : Entity_Id;\n-\n-         Obj_Decl   : Node_Id;\n-         Return_Con : Node_Id;\n-         Unqual     : Node_Id;\n-\n-      --  Start of processing for Check_Return_Construct_Accessibility\n-\n-      begin\n-         --  Only perform checks on record types with access discriminants and\n-         --  non-internally generated functions.\n-\n-         if not Is_Record_Type (R_Type)\n-           or else not Has_Anonymous_Access_Discriminant (R_Type)\n-           or else not Comes_From_Source (Return_Stmt)\n-         then\n-            return;\n-         end if;\n-\n-         --  We are only interested in return statements\n-\n-         if Nkind (Return_Stmt) not in\n-              N_Extended_Return_Statement | N_Simple_Return_Statement\n-         then\n-            return;\n-         end if;\n-\n-         --  Fetch the object from the return statement, in the case of a\n-         --  simple return statement the expression is part of the node.\n-\n-         if Nkind (Return_Stmt) = N_Extended_Return_Statement then\n-            --  Obtain the object definition from the expanded extended return\n-\n-            Return_Con := First (Return_Object_Declarations (Return_Stmt));\n-            while Present (Return_Con) loop\n-               --  Inspect the original node to avoid object declarations\n-               --  expanded into renamings.\n-\n-               if Nkind (Original_Node (Return_Con)) = N_Object_Declaration\n-                 and then Comes_From_Source (Original_Node (Return_Con))\n-               then\n-                  exit;\n-               end if;\n-\n-               Nlists.Next (Return_Con);\n-            end loop;\n-\n-            pragma Assert (Present (Return_Con));\n-\n-            --  Could be dealing with a renaming\n-\n-            Return_Con := Original_Node (Return_Con);\n-         else\n-            Return_Con := Expression (Return_Stmt);\n-         end if;\n-\n-         --  Obtain the accessibility levels of the expressions associated\n-         --  with all anonymous access discriminants, then generate a\n-         --  dynamic check or static error when relevant.\n-\n-         --  Note the repeated use of Original_Node to avoid checking\n-         --  expanded code.\n-\n-         Unqual := Original_Node (Unqualify (Original_Node (Return_Con)));\n-\n-         --  Get the corresponding declaration based on the return object's\n-         --  identifier.\n-\n-         if Nkind (Unqual) = N_Identifier\n-           and then Nkind (Parent (Entity (Unqual)))\n-                      in N_Object_Declaration\n-                       | N_Object_Renaming_Declaration\n-         then\n-            Obj_Decl := Original_Node (Parent (Entity (Unqual)));\n-\n-         --  We were passed the object declaration directly, so use it\n-\n-         elsif Nkind (Unqual) in N_Object_Declaration\n-                               | N_Object_Renaming_Declaration\n-         then\n-            Obj_Decl := Unqual;\n-\n-         --  Otherwise, we are looking at something else\n-\n-         else\n-            Obj_Decl := Empty;\n-\n-         end if;\n-\n-         --  Hop up object renamings when present\n-\n-         if Present (Obj_Decl)\n-           and then Nkind (Obj_Decl) = N_Object_Renaming_Declaration\n-         then\n-            while Nkind (Obj_Decl) = N_Object_Renaming_Declaration loop\n-\n-               if Nkind (Name (Obj_Decl)) not in N_Entity then\n-                  --  We may be looking at the expansion of iterators or\n-                  --  some other internally generated construct, so it is safe\n-                  --  to ignore checks ???\n-\n-                  if not Comes_From_Source (Obj_Decl) then\n-                     return;\n-                  end if;\n-\n-                  Obj_Decl := Original_Node\n-                                (Declaration_Node\n-                                  (Ultimate_Prefix (Name (Obj_Decl))));\n-\n-               --  Move up to the next declaration based on the object's name\n-\n-               else\n-                  Obj_Decl := Original_Node\n-                                (Declaration_Node (Name (Obj_Decl)));\n-               end if;\n-            end loop;\n-         end if;\n-\n-         --  Obtain the discriminant values from the return aggregate\n-\n-         --  Do we cover extension aggregates correctly ???\n-\n-         if Nkind (Unqual) = N_Aggregate then\n-            if Present (Expressions (Unqual)) then\n-               Assoc := First (Expressions (Unqual));\n-            else\n-               Assoc := First (Component_Associations (Unqual));\n-            end if;\n-\n-         --  There is an object declaration for the return object\n-\n-         elsif Present (Obj_Decl) then\n-            --  When a subtype indication is present in an object declaration\n-            --  it must contain the object's discriminants.\n-\n-            if Nkind (Object_Definition (Obj_Decl)) = N_Subtype_Indication then\n-               Assoc := First\n-                          (Constraints\n-                            (Constraint\n-                              (Object_Definition (Obj_Decl))));\n-\n-            --  The object declaration contains an aggregate\n-\n-            elsif Present (Expression (Obj_Decl)) then\n-\n-               if Nkind (Unqualify (Expression (Obj_Decl))) = N_Aggregate then\n-                  --  Grab the first associated discriminant expresion\n-\n-                  if Present\n-                       (Expressions (Unqualify (Expression (Obj_Decl))))\n-                  then\n-                     Assoc := First\n-                                (Expressions\n-                                  (Unqualify (Expression (Obj_Decl))));\n-                  else\n-                     Assoc := First\n-                                (Component_Associations\n-                                  (Unqualify (Expression (Obj_Decl))));\n-                  end if;\n-\n-               --  Otherwise, this is something else\n-\n-               else\n-                  return;\n-               end if;\n-\n-            --  There are no supplied discriminants in the object declaration,\n-            --  so get them from the type definition since they must be default\n-            --  initialized.\n-\n-            --  Do we handle constrained subtypes correctly ???\n-\n-            elsif Nkind (Unqual) = N_Object_Declaration then\n-               Assoc := First_Discriminant\n-                          (Etype (Object_Definition (Obj_Decl)));\n-\n-            else\n-               Assoc := First_Discriminant (Etype (Unqual));\n-            end if;\n-\n-         --  When we are not looking at an aggregate or an identifier, return\n-         --  since any other construct (like a function call) is not\n-         --  applicable since checks will be performed on the side of the\n-         --  callee.\n-\n-         else\n-            return;\n-         end if;\n-\n-         --  Obtain the discriminants so we know the actual type in case the\n-         --  value of their associated expression gets implicitly converted.\n-\n-         if No (Obj_Decl) then\n-            pragma Assert (Nkind (Unqual) = N_Aggregate);\n-\n-            Disc := First_Discriminant (Etype (Unqual));\n-\n-         else\n-            Disc := First_Discriminant\n-                      (Etype (Defining_Identifier (Obj_Decl)));\n-         end if;\n-\n-         --  Preserve the first discriminant for checking named associations\n-\n-         First_Disc := Disc;\n-\n-         --  Count the number of discriminants for processing an aggregate\n-         --  which includes an others.\n-\n-         Disc := First_Disc;\n-         while Present (Disc) loop\n-            Unseen_Disc_Count := Unseen_Disc_Count + 1;\n-\n-            Next_Discriminant (Disc);\n-         end loop;\n-\n-         Seen_Discs := New_Elmt_List;\n-\n-         --  Loop through each of the discriminants and check each expression\n-         --  associated with an anonymous access discriminant.\n-\n-         --  When named associations occur in the return aggregate then\n-         --  discriminants can be in any order, so we need to ensure we do\n-         --  not continue to loop when all discriminants have been seen.\n-\n-         Disc := First_Disc;\n-         while Present (Assoc)\n-           and then (Present (Disc) or else Assoc_Present)\n-           and then Unseen_Disc_Count > 0\n-         loop\n-            --  Handle named associations by searching through the names of\n-            --  the relevant discriminant components.\n-\n-            if Nkind (Assoc)\n-                 in N_Component_Association | N_Discriminant_Association\n-            then\n-               Assoc_Expr    := Expression (Assoc);\n-               Assoc_Present := True;\n-\n-               --  We currently don't handle box initialized discriminants,\n-               --  however, since default initialized anonymous access\n-               --  discriminants are a corner case, this is ok for now ???\n-\n-               if Nkind (Assoc) = N_Component_Association\n-                 and then Box_Present (Assoc)\n-               then\n-                  if Nkind (First_Selector (Assoc)) = N_Others_Choice then\n-                     Unseen_Disc_Count := 0;\n-                  end if;\n-\n-               --  When others is present we must identify a discriminant we\n-               --  haven't already seen so as to get the appropriate type for\n-               --  the static accessibility check.\n-\n-               --  This works because all components within an others clause\n-               --  must have the same type.\n-\n-               elsif Nkind (First_Selector (Assoc)) = N_Others_Choice then\n-\n-                  Disc := First_Disc;\n-                  Outer : while Present (Disc) loop\n-                     declare\n-                        Current_Seen_Disc : Elmt_Id;\n-                     begin\n-                        --  Move through the list of identified discriminants\n-\n-                        Current_Seen_Disc := First_Elmt (Seen_Discs);\n-                        while Present (Current_Seen_Disc) loop\n-                           --  Exit the loop when we found a match\n-\n-                           exit when\n-                             Chars (Node (Current_Seen_Disc)) = Chars (Disc);\n-\n-                           Next_Elmt (Current_Seen_Disc);\n-                        end loop;\n-\n-                        --  When we have exited the above loop without finding\n-                        --  a match then we know that Disc has not been seen.\n-\n-                        exit Outer when No (Current_Seen_Disc);\n-                     end;\n-\n-                     Next_Discriminant (Disc);\n-                  end loop Outer;\n-\n-                  --  If we got to an others clause with a non-zero\n-                  --  discriminant count there must be a discriminant left to\n-                  --  check.\n-\n-                  pragma Assert (Present (Disc));\n-\n-                  --  Set the unseen discriminant count to zero because we know\n-                  --  an others clause sets all remaining components of an\n-                  --  aggregate.\n-\n-                  Unseen_Disc_Count := 0;\n-\n-               --  Move through each of the selectors in the named association\n-               --  and obtain a discriminant for accessibility checking if one\n-               --  is referenced in the list. Also track which discriminants\n-               --  are referenced for the purpose of handling an others clause.\n-\n-               else\n-                  declare\n-                     Assoc_Choice : Node_Id;\n-                     Curr_Disc    : Node_Id;\n-                  begin\n-\n-                     Disc      := Empty;\n-                     Curr_Disc := First_Disc;\n-                     while Present (Curr_Disc) loop\n-                        --  Check each of the choices in the associations for a\n-                        --  match to the name of the current discriminant.\n-\n-                        Assoc_Choice := First_Selector (Assoc);\n-                        while Present (Assoc_Choice) loop\n-                           --  When the name matches we track that we have seen\n-                           --  the discriminant, but instead of exiting the\n-                           --  loop we continue iterating to make sure all the\n-                           --  discriminants within the named association get\n-                           --  tracked.\n-\n-                           if Chars (Assoc_Choice) = Chars (Curr_Disc) then\n-                              Append_Elmt (Curr_Disc, Seen_Discs);\n-\n-                              Disc              := Curr_Disc;\n-                              Unseen_Disc_Count := Unseen_Disc_Count - 1;\n-                           end if;\n-\n-                           Next (Assoc_Choice);\n-                        end loop;\n-\n-                        Next_Discriminant (Curr_Disc);\n-                     end loop;\n-                  end;\n-               end if;\n-\n-            --  Unwrap the associated expression if we are looking at a default\n-            --  initialized type declaration. In this case Assoc is not really\n-            --  an association, but a component declaration. Should Assoc be\n-            --  renamed in some way to be more clear ???\n-\n-            --  This occurs when the return object does not initialize\n-            --  discriminant and instead relies on the type declaration for\n-            --  their supplied values.\n-\n-            elsif Nkind (Assoc) in N_Entity\n-              and then Ekind (Assoc) = E_Discriminant\n-            then\n-               Append_Elmt (Disc, Seen_Discs);\n-\n-               Assoc_Expr        := Discriminant_Default_Value (Assoc);\n-               Unseen_Disc_Count := Unseen_Disc_Count - 1;\n-\n-            --  Otherwise, there is nothing to do because Assoc is an\n-            --  expression within the return aggregate itself.\n-\n-            else\n-               Append_Elmt (Disc, Seen_Discs);\n-\n-               Assoc_Expr        := Assoc;\n-               Unseen_Disc_Count := Unseen_Disc_Count - 1;\n-            end if;\n-\n-            --  Check the accessibility level of the expression when the\n-            --  discriminant is of an anonymous access type.\n-\n-            if Present (Assoc_Expr)\n-              and then Present (Disc)\n-              and then Ekind (Etype (Disc)) = E_Anonymous_Access_Type\n-\n-              --  We disable the check when we have a tagged return type and\n-              --  the associated expression for the discriminant is a formal\n-              --  parameter since the check would require us to compare the\n-              --  accessibility level of Assoc_Expr to the level of the\n-              --  Extra_Accessibility_Of_Result of the function - which is\n-              --  currently disabled for functions with tagged return types.\n-              --  This may change in the future ???\n-\n-              --  See Needs_Result_Accessibility_Level for details.\n-\n-              and then not\n-                (No (Extra_Accessibility_Of_Result (Scope_Id))\n-                  and then Is_Formal_Of_Current_Function (Assoc_Expr)\n-                  and then Is_Tagged_Type (Etype (Scope_Id)))\n-            then\n-               --  Generate a dynamic check based on the extra accessibility of\n-               --  the result or the scope of the current function.\n-\n-               Check_Cond :=\n-                 Make_Op_Gt (Loc,\n-                   Left_Opnd  => Accessibility_Level\n-                                   (Expr              => Assoc_Expr,\n-                                    Level             => Dynamic_Level,\n-                                    In_Return_Context => True),\n-                   Right_Opnd =>\n-                     (if Present (Extra_Accessibility_Of_Result (Scope_Id))\n-\n-                        --  When Assoc_Expr is a formal we have to look at the\n-                        --  extra accessibility-level formal associated with\n-                        --  the result.\n-\n-                        and then Is_Formal_Of_Current_Function (Assoc_Expr)\n-                      then\n-                         New_Occurrence_Of\n-                           (Extra_Accessibility_Of_Result (Scope_Id), Loc)\n-\n-                      --  Otherwise, we compare the level of Assoc_Expr to the\n-                      --  scope of the current function.\n-\n-                      else\n-                         Make_Integer_Literal\n-                           (Loc, Scope_Depth (Scope (Scope_Id)))));\n-\n-               Insert_Before_And_Analyze (Return_Stmt,\n-                 Make_Raise_Program_Error (Loc,\n-                   Condition => Check_Cond,\n-                   Reason    => PE_Accessibility_Check_Failed));\n-\n-               --  If constant folding has happened on the condition for the\n-               --  generated error, then warn about it being unconditional when\n-               --  we know an error will be raised.\n-\n-               if Nkind (Check_Cond) = N_Identifier\n-                 and then Entity (Check_Cond) = Standard_True\n-               then\n-                  Error_Msg_N\n-                    (\"access discriminant in return object would be a dangling\"\n-                     & \" reference\", Return_Stmt);\n-               end if;\n-            end if;\n-\n-            --  Iterate over the discriminants, except when we have encountered\n-            --  a named association since the discriminant order becomes\n-            --  irrelevant in that case.\n-\n-            if not Assoc_Present then\n-               Next_Discriminant (Disc);\n-            end if;\n-\n-            --  Iterate over associations\n-\n-            if not Is_List_Member (Assoc) then\n-               exit;\n-            else\n-               Nlists.Next (Assoc);\n-            end if;\n-         end loop;\n-      end Check_Return_Construct_Accessibility;\n-\n       -------------------------------------\n       -- Check_Return_Subtype_Indication --\n       -------------------------------------\n@@ -1495,7 +982,7 @@ package body Sem_Ch6 is\n             Resolve (Expr, R_Type);\n             Check_Limited_Return (N, Expr, R_Type);\n \n-            Check_Return_Construct_Accessibility (N);\n+            Check_Return_Construct_Accessibility (N, Stm_Entity);\n \n             --  Ada 2022 (AI12-0269): Any return statement that applies to a\n             --  nonreturning function shall be a simple_return_statement with\n@@ -1551,7 +1038,7 @@ package body Sem_Ch6 is\n \n             Check_References (Stm_Entity);\n \n-            Check_Return_Construct_Accessibility (N);\n+            Check_Return_Construct_Accessibility (N, Stm_Entity);\n \n             --  Check RM 6.5 (5.9/3)\n "}, {"sha": "aad86fab3281c4fdd82f30c02b3ba2ae7bbf1d36", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;"}, {"sha": "70c7c7cc9d5761738db604bde63dbbe88796e888", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;"}, {"sha": "1fef8475c053ee7d19b9c008a161e6e8c97e097b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 1306, "changes": 1315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,14 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Casing;         use Casing;\n with Checks;         use Checks;\n with Debug;          use Debug;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n with Erroutc;        use Erroutc;\n-with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch11;       use Exp_Ch11;\n with Exp_Util;       use Exp_Util;\n@@ -255,740 +255,6 @@ package body Sem_Util is\n       return Interface_List (Nod);\n    end Abstract_Interface_List;\n \n-   -------------------------\n-   -- Accessibility_Level --\n-   -------------------------\n-\n-   function Accessibility_Level\n-     (Expr              : Node_Id;\n-      Level             : Accessibility_Level_Kind;\n-      In_Return_Context : Boolean := False;\n-      Allow_Alt_Model   : Boolean := True) return Node_Id\n-   is\n-      Loc : constant Source_Ptr := Sloc (Expr);\n-\n-      function Accessibility_Level (Expr : Node_Id) return Node_Id\n-        is (Accessibility_Level (Expr, Level, In_Return_Context));\n-      --  Renaming of the enclosing function to facilitate recursive calls\n-\n-      function Make_Level_Literal (Level : Uint) return Node_Id;\n-      --  Construct an integer literal representing an accessibility level\n-      --  with its type set to Natural.\n-\n-      function Innermost_Master_Scope_Depth (N : Node_Id) return Uint;\n-      --  Returns the scope depth of the given node's innermost enclosing\n-      --  scope (effectively the accessibility level of the innermost\n-      --  enclosing master).\n-\n-      function Function_Call_Or_Allocator_Level (N : Node_Id) return Node_Id;\n-      --  Centralized processing of subprogram calls which may appear in\n-      --  prefix notation.\n-\n-      function Typ_Access_Level (Typ : Entity_Id) return Uint\n-        is (Type_Access_Level (Typ, Allow_Alt_Model));\n-      --  Renaming of Type_Access_Level with Allow_Alt_Model specified to avoid\n-      --  passing the parameter specifically in every call.\n-\n-      ----------------------------------\n-      -- Innermost_Master_Scope_Depth --\n-      ----------------------------------\n-\n-      function Innermost_Master_Scope_Depth (N : Node_Id) return Uint is\n-         Encl_Scop           : Entity_Id;\n-         Ent                 : Entity_Id;\n-         Node_Par            : Node_Id := Parent (N);\n-         Master_Lvl_Modifier : Int     := 0;\n-\n-      begin\n-         --  Locate the nearest enclosing node (by traversing Parents)\n-         --  that Defining_Entity can be applied to, and return the\n-         --  depth of that entity's nearest enclosing scope.\n-\n-         --  The rules that define what a master are defined in\n-         --  RM 7.6.1 (3), and include statements and conditions for loops\n-         --  among other things. These cases are detected properly ???\n-\n-         while Present (Node_Par) loop\n-            Ent := Defining_Entity_Or_Empty (Node_Par);\n-\n-            if Present (Ent) then\n-               Encl_Scop := Find_Enclosing_Scope (Ent);\n-\n-               --  Ignore transient scopes made during expansion\n-\n-               if Comes_From_Source (Node_Par) then\n-                  --  Note that in some rare cases the scope depth may not be\n-                  --  set, for example, when we are in the middle of analyzing\n-                  --  a type and the enclosing scope is said type. So, instead,\n-                  --  continue to move up the parent chain since the scope\n-                  --  depth of the type's parent is the same as that of the\n-                  --  type.\n-\n-                  if not Scope_Depth_Set (Encl_Scop) then\n-                     pragma Assert (Nkind (Parent (Encl_Scop))\n-                                     = N_Full_Type_Declaration);\n-                  else\n-                     return\n-                       Scope_Depth (Encl_Scop) + Master_Lvl_Modifier;\n-                  end if;\n-               end if;\n-\n-            --  For a return statement within a function, return\n-            --  the depth of the function itself. This is not just\n-            --  a small optimization, but matters when analyzing\n-            --  the expression in an expression function before\n-            --  the body is created.\n-\n-            elsif Nkind (Node_Par) in N_Extended_Return_Statement\n-                                    | N_Simple_Return_Statement\n-            then\n-               return Scope_Depth (Enclosing_Subprogram (Node_Par));\n-\n-            --  Statements are counted as masters\n-\n-            elsif Is_Master (Node_Par) then\n-               Master_Lvl_Modifier := Master_Lvl_Modifier + 1;\n-\n-            end if;\n-\n-            Node_Par := Parent (Node_Par);\n-         end loop;\n-\n-         --  Should never reach the following return\n-\n-         pragma Assert (False);\n-\n-         return Scope_Depth (Current_Scope) + 1;\n-      end Innermost_Master_Scope_Depth;\n-\n-      ------------------------\n-      -- Make_Level_Literal --\n-      ------------------------\n-\n-      function Make_Level_Literal (Level : Uint) return Node_Id is\n-         Result : constant Node_Id := Make_Integer_Literal (Loc, Level);\n-\n-      begin\n-         Set_Etype (Result, Standard_Natural);\n-         return Result;\n-      end Make_Level_Literal;\n-\n-      --------------------------------------\n-      -- Function_Call_Or_Allocator_Level --\n-      --------------------------------------\n-\n-      function Function_Call_Or_Allocator_Level (N : Node_Id) return Node_Id is\n-         Par      : Node_Id;\n-         Prev_Par : Node_Id;\n-      begin\n-         --  Results of functions are objects, so we either get the\n-         --  accessibility of the function or, in case of a call which is\n-         --  indirect, the level of the access-to-subprogram type.\n-\n-         --  This code looks wrong ???\n-\n-         if Nkind (N) = N_Function_Call\n-           and then Ada_Version < Ada_2005\n-         then\n-            if Is_Entity_Name (Name (N)) then\n-               return Make_Level_Literal\n-                        (Subprogram_Access_Level (Entity (Name (N))));\n-            else\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (Prefix (Name (N)))));\n-            end if;\n-\n-         --  We ignore coextensions as they cannot be implemented under the\n-         --  \"small-integer\" model.\n-\n-         elsif Nkind (N) = N_Allocator\n-           and then (Is_Static_Coextension (N)\n-                      or else Is_Dynamic_Coextension (N))\n-         then\n-            return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-         end if;\n-\n-         --  Named access types have a designated level\n-\n-         if Is_Named_Access_Type (Etype (N)) then\n-            return Make_Level_Literal (Typ_Access_Level (Etype (N)));\n-\n-         --  Otherwise, the level is dictated by RM 3.10.2 (10.7/3)\n-\n-         else\n-            --  Check No_Dynamic_Accessibility_Checks restriction override for\n-            --  alternative accessibility model.\n-\n-            if Allow_Alt_Model\n-              and then No_Dynamic_Accessibility_Checks_Enabled (N)\n-              and then Is_Anonymous_Access_Type (Etype (N))\n-            then\n-               --  In the alternative model the level is that of the\n-               --  designated type.\n-\n-               if Debug_Flag_Underscore_B then\n-                  return Make_Level_Literal (Typ_Access_Level (Etype (N)));\n-\n-               --  For function calls the level is that of the innermost\n-               --  master, otherwise (for allocators etc.) we get the level\n-               --  of the corresponding anonymous access type, which is\n-               --  calculated through the normal path of execution.\n-\n-               elsif Nkind (N) = N_Function_Call then\n-                  return Make_Level_Literal\n-                           (Innermost_Master_Scope_Depth (Expr));\n-               end if;\n-            end if;\n-\n-            if Nkind (N) = N_Function_Call then\n-               --  Dynamic checks are generated when we are within a return\n-               --  value or we are in a function call within an anonymous\n-               --  access discriminant constraint of a return object (signified\n-               --  by In_Return_Context) on the side of the callee.\n-\n-               --  So, in this case, return accessibility level of the\n-               --  enclosing subprogram.\n-\n-               if In_Return_Value (N)\n-                 or else In_Return_Context\n-               then\n-                  return Make_Level_Literal\n-                           (Subprogram_Access_Level (Current_Subprogram));\n-               end if;\n-            end if;\n-\n-            --  When the call is being dereferenced the level is that of the\n-            --  enclosing master of the dereferenced call.\n-\n-            if Nkind (Parent (N)) in N_Explicit_Dereference\n-                                   | N_Indexed_Component\n-                                   | N_Selected_Component\n-            then\n-               return Make_Level_Literal\n-                        (Innermost_Master_Scope_Depth (Expr));\n-            end if;\n-\n-            --  Find any relevant enclosing parent nodes that designate an\n-            --  object being initialized.\n-\n-            --  Note: The above is only relevant if the result is used \"in its\n-            --  entirety\" as RM 3.10.2 (10.2/3) states. However, this is\n-            --  accounted for in the case statement in the main body of\n-            --  Accessibility_Level for N_Selected_Component.\n-\n-            Par      := Parent (Expr);\n-            Prev_Par := Empty;\n-            while Present (Par) loop\n-               --  Detect an expanded implicit conversion, typically this\n-               --  occurs on implicitly converted actuals in calls.\n-\n-               --  Does this catch all implicit conversions ???\n-\n-               if Nkind (Par) = N_Type_Conversion\n-                 and then Is_Named_Access_Type (Etype (Par))\n-               then\n-                  return Make_Level_Literal\n-                           (Typ_Access_Level (Etype (Par)));\n-               end if;\n-\n-               --  Jump out when we hit an object declaration or the right-hand\n-               --  side of an assignment, or a construct such as an aggregate\n-               --  subtype indication which would be the result is not used\n-               --  \"in its entirety.\"\n-\n-               exit when Nkind (Par) in N_Object_Declaration\n-                           or else (Nkind (Par) = N_Assignment_Statement\n-                                     and then Name (Par) /= Prev_Par);\n-\n-               Prev_Par := Par;\n-               Par      := Parent (Par);\n-            end loop;\n-\n-            --  Assignment statements are handled in a similar way in\n-            --  accordance to the left-hand part. However, strictly speaking,\n-            --  this is illegal according to the RM, but this change is needed\n-            --  to pass an ACATS C-test and is useful in general ???\n-\n-            case Nkind (Par) is\n-               when N_Object_Declaration =>\n-                  return Make_Level_Literal\n-                           (Scope_Depth\n-                             (Scope (Defining_Identifier (Par))));\n-\n-               when N_Assignment_Statement =>\n-                  --  Return the accessibility level of the left-hand part\n-\n-                  return Accessibility_Level\n-                           (Expr              => Name (Par),\n-                            Level             => Object_Decl_Level,\n-                            In_Return_Context => In_Return_Context);\n-\n-               when others =>\n-                  return Make_Level_Literal\n-                           (Innermost_Master_Scope_Depth (Expr));\n-            end case;\n-         end if;\n-      end Function_Call_Or_Allocator_Level;\n-\n-      --  Local variables\n-\n-      E   : Node_Id := Original_Node (Expr);\n-      Pre : Node_Id;\n-\n-   --  Start of processing for Accessibility_Level\n-\n-   begin\n-      --  We could be looking at a reference to a formal due to the expansion\n-      --  of entries and other cases, so obtain the renaming if necessary.\n-\n-      if Present (Param_Entity (Expr)) then\n-         E := Param_Entity (Expr);\n-      end if;\n-\n-      --  Extract the entity\n-\n-      if Nkind (E) in N_Has_Entity and then Present (Entity (E)) then\n-         E := Entity (E);\n-\n-         --  Deal with a possible renaming of a private protected component\n-\n-         if Ekind (E) in E_Constant | E_Variable and then Is_Prival (E) then\n-            E := Prival_Link (E);\n-         end if;\n-      end if;\n-\n-      --  Perform the processing on the expression\n-\n-      case Nkind (E) is\n-         --  The level of an aggregate is that of the innermost master that\n-         --  evaluates it as defined in RM 3.10.2 (10/4).\n-\n-         when N_Aggregate =>\n-            return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n-\n-         --  The accessibility level is that of the access type, except for an\n-         --  anonymous allocators which have special rules defined in RM 3.10.2\n-         --  (14/3).\n-\n-         when N_Allocator =>\n-            return Function_Call_Or_Allocator_Level (E);\n-\n-         --  We could reach this point for two reasons. Either the expression\n-         --  applies to a special attribute ('Loop_Entry, 'Result, or 'Old), or\n-         --  we are looking at the access attributes directly ('Access,\n-         --  'Address, or 'Unchecked_Access).\n-\n-         when N_Attribute_Reference =>\n-            Pre := Original_Node (Prefix (E));\n-\n-            --  Regular 'Access attribute presence means we have to look at the\n-            --  prefix.\n-\n-            if Attribute_Name (E) = Name_Access then\n-               return Accessibility_Level (Prefix (E));\n-\n-            --  Unchecked or unrestricted attributes have unlimited depth\n-\n-            elsif Attribute_Name (E) in Name_Address\n-                                      | Name_Unchecked_Access\n-                                      | Name_Unrestricted_Access\n-            then\n-               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-\n-            --  'Access can be taken further against other special attributes,\n-            --  so handle these cases explicitly.\n-\n-            elsif Attribute_Name (E)\n-                    in Name_Old | Name_Loop_Entry | Name_Result\n-            then\n-               --  Named access types\n-\n-               if Is_Named_Access_Type (Etype (Pre)) then\n-                  return Make_Level_Literal\n-                           (Typ_Access_Level (Etype (Pre)));\n-\n-               --  Anonymous access types\n-\n-               elsif Nkind (Pre) in N_Has_Entity\n-                 and then Ekind (Entity (Pre)) not in Subprogram_Kind\n-                 and then Present (Get_Dynamic_Accessibility (Entity (Pre)))\n-                 and then Level = Dynamic_Level\n-               then\n-                  return New_Occurrence_Of\n-                           (Get_Dynamic_Accessibility (Entity (Pre)), Loc);\n-\n-               --  Otherwise the level is treated in a similar way as\n-               --  aggregates according to RM 6.1.1 (35.1/4) which concerns\n-               --  an implicit constant declaration - in turn defining the\n-               --  accessibility level to be that of the implicit constant\n-               --  declaration.\n-\n-               else\n-                  return Make_Level_Literal\n-                           (Innermost_Master_Scope_Depth (Expr));\n-               end if;\n-\n-            else\n-               raise Program_Error;\n-            end if;\n-\n-         --  This is the \"base case\" for accessibility level calculations which\n-         --  means we are near the end of our recursive traversal.\n-\n-         when N_Defining_Identifier =>\n-            --  A dynamic check is performed on the side of the callee when we\n-            --  are within a return statement, so return a library-level\n-            --  accessibility level to null out checks on the side of the\n-            --  caller.\n-\n-            if Is_Explicitly_Aliased (E)\n-              and then (In_Return_Context\n-                         or else (Level /= Dynamic_Level\n-                                   and then In_Return_Value (Expr)))\n-            then\n-               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-\n-            --  Something went wrong and an extra accessibility formal has not\n-            --  been generated when one should have ???\n-\n-            elsif Is_Formal (E)\n-              and then No (Get_Dynamic_Accessibility (E))\n-              and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n-            then\n-               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-\n-            --  Stand-alone object of an anonymous access type \"SAOAAT\"\n-\n-            elsif (Is_Formal (E)\n-                    or else Ekind (E) in E_Variable\n-                                       | E_Constant)\n-              and then Present (Get_Dynamic_Accessibility (E))\n-              and then (Level = Dynamic_Level\n-                         or else Level = Zero_On_Dynamic_Level)\n-            then\n-               if Level = Zero_On_Dynamic_Level then\n-                  return Make_Level_Literal\n-                           (Scope_Depth (Standard_Standard));\n-               end if;\n-\n-               --  No_Dynamic_Accessibility_Checks restriction override for\n-               --  alternative accessibility model.\n-\n-               if Allow_Alt_Model\n-                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n-               then\n-                  --  In the alternative model the level is that of the\n-                  --  designated type entity's context.\n-\n-                  if Debug_Flag_Underscore_B then\n-                     return Make_Level_Literal (Typ_Access_Level (Etype (E)));\n-\n-                  --  Otherwise the level depends on the entity's context\n-\n-                  elsif Is_Formal (E) then\n-                     return Make_Level_Literal\n-                              (Subprogram_Access_Level\n-                                (Enclosing_Subprogram (E)));\n-                  else\n-                     return Make_Level_Literal\n-                              (Scope_Depth (Enclosing_Dynamic_Scope (E)));\n-                  end if;\n-               end if;\n-\n-               --  Return the dynamic level in the normal case\n-\n-               return New_Occurrence_Of\n-                        (Get_Dynamic_Accessibility (E), Loc);\n-\n-            --  Initialization procedures have a special extra accessibility\n-            --  parameter associated with the level at which the object\n-            --  being initialized exists\n-\n-            elsif Ekind (E) = E_Record_Type\n-              and then Is_Limited_Record (E)\n-              and then Current_Scope = Init_Proc (E)\n-              and then Present (Init_Proc_Level_Formal (Current_Scope))\n-            then\n-               return New_Occurrence_Of\n-                        (Init_Proc_Level_Formal (Current_Scope), Loc);\n-\n-            --  Current instance of the type is deeper than that of the type\n-            --  according to RM 3.10.2 (21).\n-\n-            elsif Is_Type (E) then\n-               --  When restriction No_Dynamic_Accessibility_Checks is active\n-               --  along with -gnatd_b.\n-\n-               if Allow_Alt_Model\n-                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n-                 and then Debug_Flag_Underscore_B\n-               then\n-                  return Make_Level_Literal (Typ_Access_Level (E));\n-               end if;\n-\n-               --  Normal path\n-\n-               return Make_Level_Literal (Typ_Access_Level (E) + 1);\n-\n-            --  Move up the renamed entity or object if it came from source\n-            --  since expansion may have created a dummy renaming under\n-            --  certain circumstances.\n-\n-            --  Note: We check if the original node of the renaming comes\n-            --  from source because the node may have been rewritten.\n-\n-            elsif Present (Renamed_Entity_Or_Object (E))\n-              and then Comes_From_Source\n-                (Original_Node (Renamed_Entity_Or_Object (E)))\n-            then\n-               return Accessibility_Level (Renamed_Entity_Or_Object (E));\n-\n-            --  Named access types get their level from their associated type\n-\n-            elsif Is_Named_Access_Type (Etype (E)) then\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (E)));\n-\n-            --  Check if E is an expansion-generated renaming of an iterator\n-            --  by examining Related_Expression. If so, determine the\n-            --  accessibility level based on the original expression.\n-\n-            elsif Ekind (E) in E_Constant | E_Variable\n-              and then Present (Related_Expression (E))\n-            then\n-               return Accessibility_Level (Related_Expression (E));\n-\n-            elsif Level = Dynamic_Level\n-               and then Ekind (E) in E_In_Parameter | E_In_Out_Parameter\n-               and then Present (Init_Proc_Level_Formal (Scope (E)))\n-            then\n-               return New_Occurrence_Of\n-                        (Init_Proc_Level_Formal (Scope (E)), Loc);\n-\n-            --  Normal object - get the level of the enclosing scope\n-\n-            else\n-               return Make_Level_Literal\n-                        (Scope_Depth (Enclosing_Dynamic_Scope (E)));\n-            end if;\n-\n-         --  Handle indexed and selected components including the special cases\n-         --  whereby there is an implicit dereference, a component of a\n-         --  composite type, or a function call in prefix notation.\n-\n-         --  We don't handle function calls in prefix notation correctly ???\n-\n-         when N_Indexed_Component | N_Selected_Component | N_Slice =>\n-            Pre := Prefix (E);\n-\n-            --  Fetch the original node when the prefix comes from the result\n-            --  of expanding a function call since we want to find the level\n-            --  of the original source call.\n-\n-            if not Comes_From_Source (Pre)\n-              and then Nkind (Original_Node (Pre)) = N_Function_Call\n-            then\n-               Pre := Original_Node (Pre);\n-            end if;\n-\n-            --  When E is an indexed component or selected component and\n-            --  the current Expr is a function call, we know that we are\n-            --  looking at an expanded call in prefix notation.\n-\n-            if Nkind (Expr) = N_Function_Call then\n-               return Function_Call_Or_Allocator_Level (Expr);\n-\n-            --  If the prefix is a named access type, then we are dealing\n-            --  with an implicit deferences. In that case the level is that\n-            --  of the named access type in the prefix.\n-\n-            elsif Is_Named_Access_Type (Etype (Pre)) then\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (Pre)));\n-\n-            --  The current expression is a named access type, so there is no\n-            --  reason to look at the prefix. Instead obtain the level of E's\n-            --  named access type.\n-\n-            elsif Is_Named_Access_Type (Etype (E)) then\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (E)));\n-\n-            --  A nondiscriminant selected component where the component\n-            --  is an anonymous access type means that its associated\n-            --  level is that of the containing type - see RM 3.10.2 (16).\n-\n-            --  Note that when restriction No_Dynamic_Accessibility_Checks is\n-            --  in effect we treat discriminant components as regular\n-            --  components.\n-\n-            elsif\n-              (Nkind (E) = N_Selected_Component\n-                and then Ekind (Etype (E))   =  E_Anonymous_Access_Type\n-                and then Ekind (Etype (Pre)) /= E_Anonymous_Access_Type\n-                and then (not (Nkind (Selector_Name (E)) in N_Has_Entity\n-                                and then Ekind (Entity (Selector_Name (E)))\n-                                           = E_Discriminant)\n-\n-                           --  The alternative accessibility models both treat\n-                           --  discriminants as regular components.\n-\n-                           or else (No_Dynamic_Accessibility_Checks_Enabled (E)\n-                                     and then Allow_Alt_Model)))\n-\n-              --  Arrays featuring components of anonymous access components\n-              --  get their corresponding level from their containing type's\n-              --  declaration.\n-\n-              or else\n-                (Nkind (E) = N_Indexed_Component\n-                  and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n-                  and then Ekind (Etype (Pre)) in Array_Kind\n-                  and then Ekind (Component_Type (Base_Type (Etype (Pre))))\n-                             = E_Anonymous_Access_Type)\n-            then\n-               --  When restriction No_Dynamic_Accessibility_Checks is active\n-               --  and -gnatd_b set, the level is that of the designated type.\n-\n-               if Allow_Alt_Model\n-                 and then No_Dynamic_Accessibility_Checks_Enabled (E)\n-                 and then Debug_Flag_Underscore_B\n-               then\n-                  return Make_Level_Literal\n-                           (Typ_Access_Level (Etype (E)));\n-               end if;\n-\n-               --  Otherwise proceed normally\n-\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (Prefix (E))));\n-\n-            --  The accessibility calculation routine that handles function\n-            --  calls (Function_Call_Level) assumes, in the case the\n-            --  result is of an anonymous access type, that the result will be\n-            --  used \"in its entirety\" when the call is present within an\n-            --  assignment or object declaration.\n-\n-            --  To properly handle cases where the result is not used in its\n-            --  entirety, we test if the prefix of the component in question is\n-            --  a function call, which tells us that one of its components has\n-            --  been identified and is being accessed. Therefore we can\n-            --  conclude that the result is not used \"in its entirety\"\n-            --  according to RM 3.10.2 (10.2/3).\n-\n-            elsif Nkind (Pre) = N_Function_Call\n-              and then not Is_Named_Access_Type (Etype (Pre))\n-            then\n-               --  Dynamic checks are generated when we are within a return\n-               --  value or we are in a function call within an anonymous\n-               --  access discriminant constraint of a return object (signified\n-               --  by In_Return_Context) on the side of the callee.\n-\n-               --  So, in this case, return a library accessibility level to\n-               --  null out the check on the side of the caller.\n-\n-               if (In_Return_Value (E)\n-                    or else In_Return_Context)\n-                 and then Level /= Dynamic_Level\n-               then\n-                  return Make_Level_Literal\n-                           (Scope_Depth (Standard_Standard));\n-               end if;\n-\n-               return Make_Level_Literal\n-                        (Innermost_Master_Scope_Depth (Expr));\n-\n-            --  Otherwise, continue recursing over the expression prefixes\n-\n-            else\n-               return Accessibility_Level (Prefix (E));\n-            end if;\n-\n-         --  Qualified expressions\n-\n-         when N_Qualified_Expression =>\n-            if Is_Named_Access_Type (Etype (E)) then\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (E)));\n-            else\n-               return Accessibility_Level (Expression (E));\n-            end if;\n-\n-         --  Handle function calls\n-\n-         when N_Function_Call =>\n-            return Function_Call_Or_Allocator_Level (E);\n-\n-         --  Explicit dereference accessibility level calculation\n-\n-         when N_Explicit_Dereference =>\n-            Pre := Original_Node (Prefix (E));\n-\n-            --  The prefix is a named access type so the level is taken from\n-            --  its type.\n-\n-            if Is_Named_Access_Type (Etype (Pre)) then\n-               return Make_Level_Literal (Typ_Access_Level (Etype (Pre)));\n-\n-            --  Otherwise, recurse deeper\n-\n-            else\n-               return Accessibility_Level (Prefix (E));\n-            end if;\n-\n-         --  Type conversions\n-\n-         when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n-            --  View conversions are special in that they require use to\n-            --  inspect the expression of the type conversion.\n-\n-            --  Allocators of anonymous access types are internally generated,\n-            --  so recurse deeper in that case as well.\n-\n-            if Is_View_Conversion (E)\n-              or else Ekind (Etype (E)) = E_Anonymous_Access_Type\n-            then\n-               return Accessibility_Level (Expression (E));\n-\n-            --  We don't care about the master if we are looking at a named\n-            --  access type.\n-\n-            elsif Is_Named_Access_Type (Etype (E)) then\n-               return Make_Level_Literal\n-                        (Typ_Access_Level (Etype (E)));\n-\n-            --  In section RM 3.10.2 (10/4) the accessibility rules for\n-            --  aggregates and value conversions are outlined. Are these\n-            --  followed in the case of initialization of an object ???\n-\n-            --  Should use Innermost_Master_Scope_Depth ???\n-\n-            else\n-               return Accessibility_Level (Current_Scope);\n-            end if;\n-\n-         --  Default to the type accessibility level for the type of the\n-         --  expression's entity.\n-\n-         when others =>\n-            return Make_Level_Literal (Typ_Access_Level (Etype (E)));\n-      end case;\n-   end Accessibility_Level;\n-\n-   --------------------------------\n-   -- Static_Accessibility_Level --\n-   --------------------------------\n-\n-   function Static_Accessibility_Level\n-     (Expr              : Node_Id;\n-      Level             : Static_Accessibility_Level_Kind;\n-      In_Return_Context : Boolean := False) return Uint\n-   is\n-   begin\n-      return Intval\n-               (Accessibility_Level (Expr, Level, In_Return_Context));\n-   end Static_Accessibility_Level;\n-\n    ----------------------------------\n    -- Acquire_Warning_Match_String --\n    ----------------------------------\n@@ -7420,57 +6686,16 @@ package body Sem_Util is\n       else\n          return Enclosing_Subprogram (Scop);\n       end if;\n-   end Current_Subprogram;\n-\n-   ------------------------------\n-   -- CW_Or_Needs_Finalization --\n-   ------------------------------\n-\n-   function CW_Or_Needs_Finalization (Typ : Entity_Id) return Boolean is\n-   begin\n-      return Is_Class_Wide_Type (Typ) or else Needs_Finalization (Typ);\n-   end CW_Or_Needs_Finalization;\n-\n-   -------------------------------\n-   -- Deepest_Type_Access_Level --\n-   -------------------------------\n-\n-   function Deepest_Type_Access_Level\n-     (Typ             : Entity_Id;\n-      Allow_Alt_Model : Boolean := True) return Uint\n-   is\n-   begin\n-      if Ekind (Typ) = E_Anonymous_Access_Type\n-        and then not Is_Local_Anonymous_Access (Typ)\n-        and then Nkind (Associated_Node_For_Itype (Typ)) = N_Object_Declaration\n-      then\n-         --  No_Dynamic_Accessibility_Checks override for alternative\n-         --  accessibility model.\n-\n-         if Allow_Alt_Model\n-           and then No_Dynamic_Accessibility_Checks_Enabled (Typ)\n-         then\n-            return Type_Access_Level (Typ, Allow_Alt_Model);\n-         end if;\n-\n-         --  Typ is the type of an Ada 2012 stand-alone object of an anonymous\n-         --  access type.\n-\n-         return\n-           Scope_Depth (Enclosing_Dynamic_Scope\n-                         (Defining_Identifier\n-                           (Associated_Node_For_Itype (Typ))));\n-\n-      --  For generic formal type, return Int'Last (infinite).\n-      --  See comment preceding Is_Generic_Type call in Type_Access_Level.\n+   end Current_Subprogram;\n \n-      elsif Is_Generic_Type (Root_Type (Typ)) then\n-         return UI_From_Int (Int'Last);\n+   ------------------------------\n+   -- CW_Or_Needs_Finalization --\n+   ------------------------------\n \n-      else\n-         return Type_Access_Level (Typ, Allow_Alt_Model);\n-      end if;\n-   end Deepest_Type_Access_Level;\n+   function CW_Or_Needs_Finalization (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Is_Class_Wide_Type (Typ) or else Needs_Finalization (Typ);\n+   end CW_Or_Needs_Finalization;\n \n    ---------------------\n    -- Defining_Entity --\n@@ -8182,21 +7407,6 @@ package body Sem_Util is\n       return False;\n    end Discriminated_Size;\n \n-   -----------------------------------\n-   -- Effective_Extra_Accessibility --\n-   -----------------------------------\n-\n-   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id is\n-   begin\n-      if Present (Renamed_Object (Id))\n-        and then Is_Entity_Name (Renamed_Object (Id))\n-      then\n-         return Effective_Extra_Accessibility (Entity (Renamed_Object (Id)));\n-      else\n-         return Extra_Accessibility (Id);\n-      end if;\n-   end Effective_Extra_Accessibility;\n-\n    -----------------------------\n    -- Effective_Reads_Enabled --\n    -----------------------------\n@@ -10776,30 +9986,6 @@ package body Sem_Util is\n       end if;\n    end Gather_Components;\n \n-   -------------------------------\n-   -- Get_Dynamic_Accessibility --\n-   -------------------------------\n-\n-   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id is\n-   begin\n-      --  When minimum accessibility is set for E then we utilize it - except\n-      --  in a few edge cases like the expansion of select statements where\n-      --  generated subprogram may attempt to unnecessarily use a minimum\n-      --  accessibility object declared outside of scope.\n-\n-      --  To avoid these situations where expansion may get complex we verify\n-      --  that the minimum accessibility object is within scope.\n-\n-      if Is_Formal (E)\n-        and then Present (Minimum_Accessibility (E))\n-        and then In_Open_Scopes (Scope (Minimum_Accessibility (E)))\n-      then\n-         return Minimum_Accessibility (E);\n-      end if;\n-\n-      return Extra_Accessibility (E);\n-   end Get_Dynamic_Accessibility;\n-\n    ------------------------\n    -- Get_Actual_Subtype --\n    ------------------------\n@@ -12006,85 +11192,6 @@ package body Sem_Util is\n       end if;\n    end Get_Views;\n \n-   -----------------------\n-   -- Has_Access_Values --\n-   -----------------------\n-\n-   function Has_Access_Values (T : Entity_Id) return Boolean\n-   is\n-      Typ : constant Entity_Id := Underlying_Type (T);\n-\n-   begin\n-      --  Case of a private type which is not completed yet. This can only\n-      --  happen in the case of a generic formal type appearing directly, or\n-      --  as a component of the type to which this function is being applied\n-      --  at the top level. Return False in this case, since we certainly do\n-      --  not know that the type contains access types.\n-\n-      if No (Typ) then\n-         return False;\n-\n-      elsif Is_Access_Type (Typ) then\n-         return True;\n-\n-      elsif Is_Array_Type (Typ) then\n-         return Has_Access_Values (Component_Type (Typ));\n-\n-      elsif Is_Record_Type (Typ) then\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            --  Loop to check components\n-\n-            Comp := First_Component_Or_Discriminant (Typ);\n-            while Present (Comp) loop\n-\n-               --  Check for access component, tag field does not count, even\n-               --  though it is implemented internally using an access type.\n-\n-               if Has_Access_Values (Etype (Comp))\n-                 and then Chars (Comp) /= Name_uTag\n-               then\n-                  return True;\n-               end if;\n-\n-               Next_Component_Or_Discriminant (Comp);\n-            end loop;\n-         end;\n-\n-         return False;\n-\n-      else\n-         return False;\n-      end if;\n-   end Has_Access_Values;\n-\n-   ---------------------------------------\n-   -- Has_Anonymous_Access_Discriminant --\n-   ---------------------------------------\n-\n-   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean\n-   is\n-      Disc : Node_Id;\n-\n-   begin\n-      if not Has_Discriminants (Typ) then\n-         return False;\n-      end if;\n-\n-      Disc := First_Discriminant (Typ);\n-      while Present (Disc) loop\n-         if Ekind (Etype (Disc)) = E_Anonymous_Access_Type then\n-            return True;\n-         end if;\n-\n-         Next_Discriminant (Disc);\n-      end loop;\n-\n-      return False;\n-   end Has_Anonymous_Access_Discriminant;\n-\n    ------------------------------\n    -- Has_Compatible_Alignment --\n    ------------------------------\n@@ -14382,32 +13489,6 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n-   --------------------------------------------\n-   -- Has_Unconstrained_Access_Discriminants --\n-   --------------------------------------------\n-\n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean\n-   is\n-      Discr : Entity_Id;\n-\n-   begin\n-      if Has_Discriminants (Subtyp)\n-        and then not Is_Constrained (Subtyp)\n-      then\n-         Discr := First_Discriminant (Subtyp);\n-         while Present (Discr) loop\n-            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n-               return True;\n-            end if;\n-\n-            Next_Discriminant (Discr);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Has_Unconstrained_Access_Discriminants;\n-\n    -----------------------------\n    -- Has_Undefined_Reference --\n    -----------------------------\n@@ -15989,28 +15070,6 @@ package body Sem_Util is\n       end if;\n    end Invalid_Scalar_Value;\n \n-   --------------------------------\n-   -- Is_Anonymous_Access_Actual --\n-   --------------------------------\n-\n-   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean is\n-      Par : Node_Id;\n-   begin\n-      if Ekind (Etype (N)) /= E_Anonymous_Access_Type then\n-         return False;\n-      end if;\n-\n-      Par := Parent (N);\n-      while Present (Par)\n-        and then Nkind (Par) in N_Case_Expression\n-                              | N_If_Expression\n-                              | N_Parameter_Association\n-      loop\n-         Par := Parent (Par);\n-      end loop;\n-      return Nkind (Par) in N_Subprogram_Call;\n-   end Is_Anonymous_Access_Actual;\n-\n    ------------------------\n    -- Is_Access_Variable --\n    ------------------------\n@@ -21224,38 +20283,6 @@ package body Sem_Util is\n           and then Is_Single_Concurrent_Type (Etype (Id));\n    end Is_Single_Task_Object;\n \n-   --------------------------------------\n-   -- Is_Special_Aliased_Formal_Access --\n-   --------------------------------------\n-\n-   function Is_Special_Aliased_Formal_Access\n-     (Exp               : Node_Id;\n-      In_Return_Context : Boolean := False) return Boolean\n-   is\n-      Scop : constant Entity_Id := Current_Subprogram;\n-   begin\n-      --  Verify the expression is an access reference to 'Access within a\n-      --  return statement as this is the only time an explicitly aliased\n-      --  formal has different semantics.\n-\n-      if Nkind (Exp) /= N_Attribute_Reference\n-        or else Get_Attribute_Id (Attribute_Name (Exp)) /= Attribute_Access\n-        or else not (In_Return_Value (Exp)\n-                      or else In_Return_Context)\n-        or else not Needs_Result_Accessibility_Level (Scop)\n-      then\n-         return False;\n-      end if;\n-\n-      --  Check if the prefix of the reference is indeed an explicitly aliased\n-      --  formal parameter for the function Scop. Additionally, we must check\n-      --  that Scop returns an anonymous access type, otherwise the special\n-      --  rules dictating a need for a dynamic check are not in effect.\n-\n-      return Is_Entity_Name (Prefix (Exp))\n-               and then Is_Explicitly_Aliased (Entity (Prefix (Exp)));\n-   end Is_Special_Aliased_Formal_Access;\n-\n    -----------------------------\n    -- Is_Specific_Tagged_Type --\n    -----------------------------\n@@ -23228,144 +22255,6 @@ package body Sem_Util is\n       end if;\n    end Needs_One_Actual;\n \n-   --------------------------------------\n-   -- Needs_Result_Accessibility_Level --\n-   --------------------------------------\n-\n-   function Needs_Result_Accessibility_Level\n-     (Func_Id : Entity_Id) return Boolean\n-   is\n-      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n-\n-      function Has_Unconstrained_Access_Discriminant_Component\n-        (Comp_Typ : Entity_Id) return Boolean;\n-      --  Returns True if any component of the type has an unconstrained access\n-      --  discriminant.\n-\n-      -----------------------------------------------------\n-      -- Has_Unconstrained_Access_Discriminant_Component --\n-      -----------------------------------------------------\n-\n-      function Has_Unconstrained_Access_Discriminant_Component\n-        (Comp_Typ :  Entity_Id) return Boolean\n-      is\n-      begin\n-         if not Is_Limited_Type (Comp_Typ) then\n-            return False;\n-\n-         --  Only limited types can have access discriminants with\n-         --  defaults.\n-\n-         elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n-            return True;\n-\n-         elsif Is_Array_Type (Comp_Typ) then\n-            return Has_Unconstrained_Access_Discriminant_Component\n-                     (Underlying_Type (Component_Type (Comp_Typ)));\n-\n-         elsif Is_Record_Type (Comp_Typ) then\n-            declare\n-               Comp : Entity_Id;\n-\n-            begin\n-               Comp := First_Component (Comp_Typ);\n-               while Present (Comp) loop\n-                  if Has_Unconstrained_Access_Discriminant_Component\n-                       (Underlying_Type (Etype (Comp)))\n-                  then\n-                     return True;\n-                  end if;\n-\n-                  Next_Component (Comp);\n-               end loop;\n-            end;\n-         end if;\n-\n-         return False;\n-      end Has_Unconstrained_Access_Discriminant_Component;\n-\n-      Disable_Tagged_Cases : constant Boolean := True;\n-      --  Flag used to temporarily disable a \"True\" result for tagged types.\n-      --  See comments further below for details.\n-\n-   --  Start of processing for Needs_Result_Accessibility_Level\n-\n-   begin\n-      --  False if completion unavailable, which can happen when we are\n-      --  analyzing an abstract subprogram or if the subprogram has\n-      --  delayed freezing.\n-\n-      if No (Func_Typ) then\n-         return False;\n-\n-      --  False if not a function, also handle enum-lit renames case\n-\n-      elsif Func_Typ = Standard_Void_Type\n-        or else Is_Scalar_Type (Func_Typ)\n-      then\n-         return False;\n-\n-      --  Handle a corner case, a cross-dialect subp renaming. For example,\n-      --  an Ada 2012 renaming of an Ada 2005 subprogram. This can occur when\n-      --  an Ada 2005 (or earlier) unit references predefined run-time units.\n-\n-      elsif Present (Alias (Func_Id)) then\n-\n-         --  Unimplemented: a cross-dialect subp renaming which does not set\n-         --  the Alias attribute (e.g., a rename of a dereference of an access\n-         --  to subprogram value). ???\n-\n-         return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n-\n-      --  Remaining cases require Ada 2012 mode, unless they are dispatching\n-      --  operations, since they may be overridden by Ada_2012 primitives.\n-\n-      elsif Ada_Version < Ada_2012\n-        and then not Is_Dispatching_Operation (Func_Id)\n-      then\n-         return False;\n-\n-      --  Handle the situation where a result is an anonymous access type\n-      --  RM 3.10.2 (10.3/3).\n-\n-      elsif Ekind (Func_Typ) = E_Anonymous_Access_Type then\n-         return True;\n-\n-      --  In the case of, say, a null tagged record result type, the need for\n-      --  this extra parameter might not be obvious so this function returns\n-      --  True for all tagged types for compatibility reasons.\n-\n-      --  A function with, say, a tagged null controlling result type might\n-      --  be overridden by a primitive of an extension having an access\n-      --  discriminant and the overrider and overridden must have compatible\n-      --  calling conventions (including implicitly declared parameters).\n-\n-      --  Similarly, values of one access-to-subprogram type might designate\n-      --  both a primitive subprogram of a given type and a function which is,\n-      --  for example, not a primitive subprogram of any type. Again, this\n-      --  requires calling convention compatibility. It might be possible to\n-      --  solve these issues by introducing wrappers, but that is not the\n-      --  approach that was chosen.\n-\n-      --  Note: Despite the reasoning noted above, the extra accessibility\n-      --  parameter for tagged types is disabled for performance reasons.\n-\n-      elsif Is_Tagged_Type (Func_Typ) then\n-         return not Disable_Tagged_Cases;\n-\n-      elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n-         return True;\n-\n-      elsif Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n-         return True;\n-\n-      --  False for all other cases\n-\n-      else\n-         return False;\n-      end if;\n-   end Needs_Result_Accessibility_Level;\n-\n    ----------------------------\n    --  Needs_Secondary_Stack --\n    ----------------------------\n@@ -29179,19 +28068,6 @@ package body Sem_Util is\n           and then Has_Loop_Entry_Attributes (Entity (Identifier (Stmt)));\n    end Subject_To_Loop_Entry_Attributes;\n \n-   -----------------------------\n-   -- Subprogram_Access_Level --\n-   -----------------------------\n-\n-   function Subprogram_Access_Level (Subp : Entity_Id) return Uint is\n-   begin\n-      if Present (Alias (Subp)) then\n-         return Subprogram_Access_Level (Alias (Subp));\n-      else\n-         return Scope_Depth (Enclosing_Dynamic_Scope (Subp));\n-      end if;\n-   end Subprogram_Access_Level;\n-\n    ---------------------\n    -- Subprogram_Name --\n    ---------------------\n@@ -29651,179 +28527,6 @@ package body Sem_Util is\n       Discard := Traverse (Node);\n    end Traverse_More_Proc;\n \n-   -----------------------\n-   -- Type_Access_Level --\n-   -----------------------\n-\n-   function Type_Access_Level\n-     (Typ             : Entity_Id;\n-      Allow_Alt_Model : Boolean   := True;\n-      Assoc_Ent       : Entity_Id := Empty) return Uint\n-   is\n-      Btyp    : Entity_Id := Base_Type (Typ);\n-      Def_Ent : Entity_Id;\n-\n-   begin\n-      --  Ada 2005 (AI-230): For most cases of anonymous access types, we\n-      --  simply use the level where the type is declared. This is true for\n-      --  stand-alone object declarations, and for anonymous access types\n-      --  associated with components the level is the same as that of the\n-      --  enclosing composite type. However, special treatment is needed for\n-      --  the cases of access parameters, return objects of an anonymous access\n-      --  type, and, in Ada 95, access discriminants of limited types.\n-\n-      if Is_Access_Type (Btyp) then\n-         if Ekind (Btyp) = E_Anonymous_Access_Type then\n-            --  No_Dynamic_Accessibility_Checks restriction override for\n-            --  alternative accessibility model.\n-\n-            if Allow_Alt_Model\n-              and then No_Dynamic_Accessibility_Checks_Enabled (Btyp)\n-            then\n-               --  In the -gnatd_b model, the level of an anonymous access\n-               --  type is always that of the designated type.\n-\n-               if Debug_Flag_Underscore_B then\n-                  return Type_Access_Level\n-                           (Designated_Type (Btyp), Allow_Alt_Model);\n-               end if;\n-\n-               --  When an anonymous access type's Assoc_Ent is specified,\n-               --  calculate the result based on the general accessibility\n-               --  level routine.\n-\n-               --  We would like to use Associated_Node_For_Itype here instead,\n-               --  but in some cases it is not fine grained enough ???\n-\n-               if Present (Assoc_Ent) then\n-                  return Static_Accessibility_Level\n-                           (Assoc_Ent, Object_Decl_Level);\n-               end if;\n-\n-               --  Otherwise take the context of the anonymous access type into\n-               --  account.\n-\n-               --  Obtain the defining entity for the internally generated\n-               --  anonymous access type.\n-\n-               Def_Ent := Defining_Entity_Or_Empty\n-                            (Associated_Node_For_Itype (Typ));\n-\n-               if Present (Def_Ent) then\n-                  --  When the defining entity is a subprogram then we know the\n-                  --  anonymous access type Typ has been generated to either\n-                  --  describe an anonymous access type formal or an anonymous\n-                  --  access result type.\n-\n-                  --  Since we are only interested in the formal case, avoid\n-                  --  the anonymous access result type.\n-\n-                  if Is_Subprogram (Def_Ent)\n-                    and then not (Ekind (Def_Ent) = E_Function\n-                                   and then Etype (Def_Ent) = Typ)\n-                  then\n-                     --  When the type comes from an anonymous access\n-                     --  parameter, the level is that of the subprogram\n-                     --  declaration.\n-\n-                     return Scope_Depth (Def_Ent);\n-\n-                  --  When the type is an access discriminant, the level is\n-                  --  that of the type.\n-\n-                  elsif Ekind (Def_Ent) = E_Discriminant then\n-                     return Scope_Depth (Scope (Def_Ent));\n-                  end if;\n-               end if;\n-\n-            --  If the type is a nonlocal anonymous access type (such as for\n-            --  an access parameter) we treat it as being declared at the\n-            --  library level to ensure that names such as X.all'access don't\n-            --  fail static accessibility checks.\n-\n-            elsif not Is_Local_Anonymous_Access (Typ) then\n-               return Scope_Depth (Standard_Standard);\n-\n-            --  If this is a return object, the accessibility level is that of\n-            --  the result subtype of the enclosing function. The test here is\n-            --  little complicated, because we have to account for extended\n-            --  return statements that have been rewritten as blocks, in which\n-            --  case we have to find and the Is_Return_Object attribute of the\n-            --  itype's associated object. It would be nice to find a way to\n-            --  simplify this test, but it doesn't seem worthwhile to add a new\n-            --  flag just for purposes of this test. ???\n-\n-            elsif Ekind (Scope (Btyp)) = E_Return_Statement\n-              or else\n-                (Is_Itype (Btyp)\n-                  and then Nkind (Associated_Node_For_Itype (Btyp)) =\n-                                                         N_Object_Declaration\n-                  and then Is_Return_Object\n-                             (Defining_Identifier\n-                                (Associated_Node_For_Itype (Btyp))))\n-            then\n-               declare\n-                  Scop : Entity_Id;\n-\n-               begin\n-                  Scop := Scope (Scope (Btyp));\n-                  while Present (Scop) loop\n-                     exit when Ekind (Scop) = E_Function;\n-                     Scop := Scope (Scop);\n-                  end loop;\n-\n-                  --  Treat the return object's type as having the level of the\n-                  --  function's result subtype (as per RM05-6.5(5.3/2)).\n-\n-                  return Type_Access_Level (Etype (Scop), Allow_Alt_Model);\n-               end;\n-            end if;\n-         end if;\n-\n-         Btyp := Root_Type (Btyp);\n-\n-         --  The accessibility level of anonymous access types associated with\n-         --  discriminants is that of the current instance of the type, and\n-         --  that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n-\n-         --  AI-402: access discriminants have accessibility based on the\n-         --  object rather than the type in Ada 2005, so the above paragraph\n-         --  doesn't apply.\n-\n-         --  ??? Needs completion with rules from AI-416\n-\n-         if Ada_Version <= Ada_95\n-           and then Ekind (Typ) = E_Anonymous_Access_Type\n-           and then Present (Associated_Node_For_Itype (Typ))\n-           and then Nkind (Associated_Node_For_Itype (Typ)) =\n-                                                 N_Discriminant_Specification\n-         then\n-            return Scope_Depth (Enclosing_Dynamic_Scope (Btyp)) + 1;\n-         end if;\n-      end if;\n-\n-      --  Return library level for a generic formal type. This is done because\n-      --  RM(10.3.2) says that \"The statically deeper relationship does not\n-      --  apply to ... a descendant of a generic formal type\". Rather than\n-      --  checking at each point where a static accessibility check is\n-      --  performed to see if we are dealing with a formal type, this rule is\n-      --  implemented by having Type_Access_Level and Deepest_Type_Access_Level\n-      --  return extreme values for a formal type; Deepest_Type_Access_Level\n-      --  returns Int'Last. By calling the appropriate function from among the\n-      --  two, we ensure that the static accessibility check will pass if we\n-      --  happen to run into a formal type. More specifically, we should call\n-      --  Deepest_Type_Access_Level instead of Type_Access_Level whenever the\n-      --  call occurs as part of a static accessibility check and the error\n-      --  case is the case where the type's level is too shallow (as opposed\n-      --  to too deep).\n-\n-      if Is_Generic_Type (Root_Type (Btyp)) then\n-         return Scope_Depth (Standard_Standard);\n-      end if;\n-\n-      return Scope_Depth (Enclosing_Dynamic_Scope (Btyp));\n-   end Type_Access_Level;\n-\n    ------------------------------------\n    -- Type_Without_Stream_Operation  --\n    ------------------------------------"}, {"sha": "34aaa9a932fce542538cd4a93afa32cac3089803", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -44,40 +44,6 @@ package Sem_Util is\n    --  including the cases where there can't be any because e.g. the type is\n    --  not tagged.\n \n-   type Accessibility_Level_Kind is\n-     (Dynamic_Level,\n-      Object_Decl_Level,\n-      Zero_On_Dynamic_Level);\n-   --  Accessibility_Level_Kind is an enumerated type which captures the\n-   --  different modes in which an accessibility level could be obtained for\n-   --  a given expression.\n-\n-   --  When in the context of the function Accessibility_Level,\n-   --  Accessibility_Level_Kind signals what type of accessibility level to\n-   --  obtain. For example, when Level is Dynamic_Level, a defining identifier\n-   --  associated with a SAOOAAT may be returned or an N_Integer_Literal node.\n-   --  When the level is Object_Decl_Level, an N_Integer_Literal node is\n-   --  returned containing the level of the declaration of the object if\n-   --  relevant (be it a SAOOAAT or otherwise). Finally, Zero_On_Dynamic_Level\n-   --  returns library level for all cases where the accessibility level is\n-   --  dynamic (used to bypass static accessibility checks in dynamic cases).\n-\n-   function Accessibility_Level\n-     (Expr              : Node_Id;\n-      Level             : Accessibility_Level_Kind;\n-      In_Return_Context : Boolean := False;\n-      Allow_Alt_Model   : Boolean := True) return Node_Id;\n-   --  Centralized accessibility level calculation routine for finding the\n-   --  accessibility level of a given expression Expr.\n-\n-   --  In_Return_Context forces the Accessibility_Level calculations to be\n-   --  carried out \"as if\" Expr existed in a return value. This is useful for\n-   --  calculating the accessibility levels for discriminant associations\n-   --  and return aggregates.\n-\n-   --  The Allow_Alt_Model parameter allows the alternative level calculation\n-   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n-\n    function Acquire_Warning_Match_String (Str_Lit : Node_Id) return String;\n    --  Used by pragma Warnings (Off, string), and Warn_As_Error (string) to get\n    --  the given string argument, adding leading and trailing asterisks if they\n@@ -696,22 +662,6 @@ package Sem_Util is\n    --  as Needs_Finalization except with pragma Restrictions (No_Finalization),\n    --  in which case we know that class-wide objects do not need finalization.\n \n-   function Deepest_Type_Access_Level\n-     (Typ             : Entity_Id;\n-      Allow_Alt_Model : Boolean := True) return Uint;\n-\n-   --  Same as Type_Access_Level, except that if the type is the type of an Ada\n-   --  2012 stand-alone object of an anonymous access type, then return the\n-   --  static accessibility level of the object. In that case, the dynamic\n-   --  accessibility level of the object may take on values in a range. The low\n-   --  bound of that range is returned by Type_Access_Level; this function\n-   --  yields the high bound of that range. Also differs from Type_Access_Level\n-   --  in the case of a descendant of a generic formal type (returns Int'Last\n-   --  instead of 0).\n-\n-   --  The Allow_Alt_Model parameter allows the alternative level calculation\n-   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n-\n    function Defining_Entity (N : Node_Id) return Entity_Id;\n    --  Given a declaration N, returns the associated defining entity. If the\n    --  declaration has a specification, the entity is obtained from the\n@@ -786,10 +736,6 @@ package Sem_Util is\n    --  private components of protected objects, but is generally useful when\n    --  restriction No_Implicit_Heap_Allocation is active.\n \n-   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id;\n-   --  Same as Einfo.Extra_Accessibility except thtat object renames\n-   --  are looked through.\n-\n    function Effective_Reads_Enabled (Id : Entity_Id) return Boolean;\n    --  Id should be the entity of a state abstraction, an object, or a type.\n    --  Returns True iff Id is subject to external property Effective_Reads.\n@@ -1146,10 +1092,6 @@ package Sem_Util is\n    --  discriminants. Otherwise all components of the parent must be included\n    --  in the subtype for semantic analysis.\n \n-   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id;\n-   --  Obtain the accessibility level for a given entity formal taking into\n-   --  account both extra and minimum accessibility.\n-\n    function Get_Actual_Subtype (N : Node_Id) return Entity_Id;\n    --  Given a node for an expression, obtain the actual subtype of the\n    --  expression. In the case of a parameter where the formal is an\n@@ -1393,18 +1335,6 @@ package Sem_Util is\n    --  don't look inside packed array types. If Recurse is False, just\n    --  go down one level (so it's no longer the \"fullest\" view).\n \n-   function Has_Access_Values (T : Entity_Id) return Boolean;\n-   --  Returns true if the underlying type of T is an access type, or has a\n-   --  component (at any recursive level) that is an access type. This is a\n-   --  conservative predicate, if it is not known whether or not T contains\n-   --  access values (happens for generic formals in some cases), then False is\n-   --  returned.  Note that tagged types return False. Even though the tag is\n-   --  implemented as an access type internally, this function tests only for\n-   --  access types known to the programmer. See also Has_Tagged_Component.\n-\n-   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean;\n-   --  Returns True if Typ has one or more anonymous access discriminants\n-\n    type Alignment_Result is (Known_Compatible, Unknown, Known_Incompatible);\n    --  Result of Has_Compatible_Alignment test, description found below. Note\n    --  that the values are arranged in increasing order of problematicness.\n@@ -1544,20 +1474,6 @@ package Sem_Util is\n    --  Return True if the loop has no side effect and can therefore be\n    --  marked for removal. Return False if N is not a N_Loop_Statement.\n \n-   subtype Static_Accessibility_Level_Kind\n-     is Accessibility_Level_Kind range Object_Decl_Level\n-                                         .. Zero_On_Dynamic_Level;\n-   --  Restrict the reange of Accessibility_Level_Kind to be non-dynamic for\n-   --  use in the static version of Accessibility_Level below.\n-\n-   function Static_Accessibility_Level\n-     (Expr              : Node_Id;\n-      Level             : Static_Accessibility_Level_Kind;\n-      In_Return_Context : Boolean := False) return Uint;\n-   --  Overloaded version of Accessibility_Level which returns a universal\n-   --  integer for use in compile-time checking. Note: Level is restricted to\n-   --  be non-dynamic.\n-\n    function Is_Newly_Constructed\n      (Exp : Node_Id; Context_Requires_NC : Boolean) return Boolean;\n    --  Indicates whether a given expression is \"newly constructed\" (RM 4.4).\n@@ -1644,11 +1560,6 @@ package Sem_Util is\n    --  a tagged type or has a subcomponent that is tagged. Returns False for a\n    --  noncomposite type, or if no tagged subcomponents are present.\n \n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean;\n-   --  Returns True if the given subtype is unconstrained and has one or more\n-   --  access discriminants.\n-\n    function Has_Undefined_Reference (Expr : Node_Id) return Boolean;\n    --  Given arbitrary expression Expr, determine whether it contains at\n    --  least one name whose entity is Any_Id.\n@@ -1822,10 +1733,6 @@ package Sem_Util is\n    --  pragma Initialize_Scalars or by the binder. Return an expression created\n    --  at source location Loc, which denotes the invalid value.\n \n-   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean;\n-   --  Determine if N is used as an actual for a call whose corresponding\n-   --  formal is of an anonymous access type.\n-\n    function Is_Access_Subprogram_Wrapper (E : Entity_Id) return Boolean;\n    --  True if E is the constructed wrapper for an access_to_subprogram\n    --  type with Pre/Postconditions.\n@@ -2400,21 +2307,6 @@ package Sem_Util is\n    --  Determine whether arbitrary entity Id denotes the anonymous object\n    --  created for a single task type.\n \n-   function Is_Special_Aliased_Formal_Access\n-     (Exp               : Node_Id;\n-      In_Return_Context : Boolean := False) return Boolean;\n-   --  Determines whether a dynamic check must be generated for explicitly\n-   --  aliased formals within a function Scop for the expression Exp.\n-\n-   --  In_Return_Context forces Is_Special_Aliased_Formal_Access to assume\n-   --  that Exp is within a return value which is useful for checking\n-   --  expressions within discriminant associations of return objects.\n-\n-   --  More specially, Is_Special_Aliased_Formal_Access checks that Exp is a\n-   --  'Access attribute reference within a return statement where the ultimate\n-   --  prefix is an aliased formal of Scop and that Scop returns an anonymous\n-   --  access type. See RM 3.10.2 for more details.\n-\n    function Is_Specific_Tagged_Type (Typ : Entity_Id) return Boolean;\n    --  Determine whether an arbitrary [private] type is specifically tagged\n \n@@ -2692,12 +2584,6 @@ package Sem_Util is\n    --  syntactic ambiguity that results from an indexing of a function call\n    --  that returns an array, so that Obj.F (X, Y) may mean F (Ob) (X, Y).\n \n-   function Needs_Result_Accessibility_Level\n-     (Func_Id : Entity_Id) return Boolean;\n-   --  Ada 2012 (AI05-0234): Return True if the function needs an implicit\n-   --  parameter to identify the accessibility level of the function result\n-   --  \"determined by the point of call\".\n-\n    function Needs_Secondary_Stack (Id : Entity_Id) return Boolean;\n    --  Return true if functions whose result type is Id must return on the\n    --  secondary stack, i.e. allocate the return object on this stack.\n@@ -3340,9 +3226,6 @@ package Sem_Util is\n    --  Determine whether node N is a loop statement subject to at least one\n    --  'Loop_Entry attribute.\n \n-   function Subprogram_Access_Level (Subp : Entity_Id) return Uint;\n-   --  Return the accessibility level of the view denoted by Subp\n-\n    function Support_Atomic_Primitives (Typ : Entity_Id) return Boolean;\n    --  Return True if Typ supports the GCC built-in atomic operations (i.e. if\n    --  Typ is properly sized and aligned).\n@@ -3373,19 +3256,6 @@ package Sem_Util is\n    --  returned, i.e. Traverse_More_Func is called and the result is simply\n    --  discarded.\n \n-   function Type_Access_Level\n-     (Typ             : Entity_Id;\n-      Allow_Alt_Model : Boolean   := True;\n-      Assoc_Ent       : Entity_Id := Empty) return Uint;\n-   --  Return the accessibility level of Typ\n-\n-   --  The Allow_Alt_Model parameter allows the alternative level calculation\n-   --  under the restriction No_Dynamic_Accessibility_Checks to be performed.\n-\n-   --  Assoc_Ent allows for the optional specification of the entity associated\n-   --  with Typ. This gets utilized mostly for anonymous access type\n-   --  processing, where context matters in interpreting Typ's level.\n-\n    function Type_Without_Stream_Operation\n      (T  : Entity_Id;\n       Op : TSS_Name_Type := TSS_Null) return Entity_Id;"}, {"sha": "1311916f19cf4e2225bef3859bc3946357a4de28", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Accessibility;  use Accessibility;\n with Atree;          use Atree;\n with Debug;          use Debug;\n with Einfo;          use Einfo;"}, {"sha": "7accb018a694720342141316113cd819fc47f036", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f459afaa679956df1f3c0243a87583e4d4b43a2e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f459afaa679956df1f3c0243a87583e4d4b43a2e", "patch": "@@ -953,6 +953,11 @@ package Sinfo is\n    --    Present in N_Simple_Return_Statement nodes. True if this node was\n    --    constructed as part of the N_Extended_Return_Statement expansion.\n \n+   --  Comes_From_Iterator\n+   --    Present in N_Object_Renaming_Declaration nodes. True if this node was\n+   --    was constructed as part of the expansion of an iterator\n+   --    specification.\n+\n    --  Compile_Time_Known_Aggregate\n    --    Present in N_Aggregate nodes. Set for aggregates which can be fully\n    --    evaluated at compile time without raising constraint error. Such"}]}