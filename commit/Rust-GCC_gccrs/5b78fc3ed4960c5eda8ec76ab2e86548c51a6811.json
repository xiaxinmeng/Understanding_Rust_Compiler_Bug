{"sha": "5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3OGZjM2VkNDk2MGM1ZWRhOGVjNzZhYjJlODY1NDhjNTFhNjgxMQ==", "commit": {"author": {"name": "Jan Sjodin", "email": "jan.sjodin@amd.com", "date": "2008-05-20T16:05:09Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-05-20T16:05:09Z"}, "message": "re PR middle-end/36206 (ice for legal code with -O3)\n\n2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n\t    Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/36206\n\t* tree-scalar-evolution.c: Remove enum INSERT_SUPERLOOP_CHRECS,\n\tFOLD_CONVERSIONS.\n\t(instantiate_scev_1): Rename flags to fold_conversions.\n\tDo not check for INSERT_SUPERLOOP_CHRECS, keep SSA_NAMEs defined\n\touteside instantiation_loop.\n\t* tree-chrec.h (evolution_function_is_affine_in_loop): New.\n\t(evolution_function_is_affine_or_constant_p): Removed.\n\t* tree-data-ref.c (dr_analyze_indices): Replace resolve_mixers with\n\tinstantiate_scev.\n\t(analyze_siv_subscript): Pass in the loop nest number.\n\tCall evolution_function_is_affine_in_loop instead of \n\tevolution_function_is_affine_p.\n\t(analyze_overlapping_iterations): Pass in the loop nest number.\n\n\t* tree-chrec.h (chrec_fold_op): New.\n\t* tree-data-ref.c (initialize_matrix_A): Traverse NOP_EXPR, PLUS_EXPR, and\n\tother trees.\n\n\t* testsuite/gfortran.dg/pr36206.f: New.\n\n\nCo-Authored-By: Sebastian Pop <sebastian.pop@amd.com>\n\nFrom-SVN: r135663", "tree": {"sha": "2902a57624deca0a3f73d473a68bf502bf697f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2902a57624deca0a3f73d473a68bf502bf697f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498f1c824b2db85994e7cbd5f5b064061ef7e687", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498f1c824b2db85994e7cbd5f5b064061ef7e687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498f1c824b2db85994e7cbd5f5b064061ef7e687"}], "stats": {"total": 305, "additions": 243, "deletions": 62}, "files": [{"sha": "f7d2ff13fafb7a6fb979afe38efbba22a0647640", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -1,3 +1,29 @@\n+2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/36206\n+\t* tree-scalar-evolution.c: Remove enum INSERT_SUPERLOOP_CHRECS,\n+\tFOLD_CONVERSIONS.\n+\t(instantiate_scev_1): Rename flags to fold_conversions.\n+\tDo not check for INSERT_SUPERLOOP_CHRECS, keep SSA_NAMEs defined\n+\touteside instantiation_loop.\n+\t* tree-chrec.h (evolution_function_is_affine_in_loop): New.\n+\t(evolution_function_is_affine_or_constant_p): Removed.\n+\t* tree-data-ref.c (dr_analyze_indices): Replace resolve_mixers with\n+\tinstantiate_scev.\n+\t(analyze_siv_subscript): Pass in the loop nest number.\n+\tCall evolution_function_is_affine_in_loop instead of \n+\tevolution_function_is_affine_p.\n+\t(analyze_overlapping_iterations): Pass in the loop nest number.\n+\n+2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/36206\n+\t* tree-chrec.h (chrec_fold_op): New.\n+\t* tree-data-ref.c (initialize_matrix_A): Traverse NOP_EXPR, PLUS_EXPR, and\n+\tother trees.\n+\n 2008-05-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-incpath.c (INO_T_EQ): Do not define on non-inode systems."}, {"sha": "e712f051739af5d2d086b231778f34f9ef02fcaf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -1,3 +1,9 @@\n+2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/36206\n+\t* testsuite/gfortran.dg/pr36206.f: New.\n+\n 2008-05-20  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat.dg/testint.adb: New test."}, {"sha": "7b0b56639dde42e105082b1509dcf130d2ec80fb", "filename": "gcc/testsuite/gfortran.dg/pr36206.f", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr36206.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr36206.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr36206.f?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do compile }\n+! { dg-options \"-O3\" }\n+! PR fortran/36206\n+\n+      SUBROUTINE SSPR(UPLO,N,ALPHA,X,INCX,AP)\n+      REAL ALPHA\n+      INTEGER INCX,N\n+      CHARACTER UPLO\n+      REAL AP(*),X(*)\n+      REAL ZERO\n+      PARAMETER (ZERO=0.0E+0)\n+      REAL TEMP\n+      INTEGER I,INFO,IX,J,JX,K,KK,KX\n+      LOGICAL LSAME\n+      EXTERNAL LSAME\n+      EXTERNAL XERBLA\n+\n+      INFO = 0\n+      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN\n+          INFO = 1\n+      ELSE IF (N.LT.0) THEN\n+          INFO = 2\n+      ELSE IF (INCX.EQ.0) THEN\n+          INFO = 5\n+      END IF\n+      IF (INFO.NE.0) THEN\n+          CALL XERBLA('SSPR  ',INFO)\n+          RETURN\n+      END IF\n+      IF ((N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN\n+      IF (INCX.LE.0) THEN\n+          KX = 1 - (N-1)*INCX\n+      ELSE IF (INCX.NE.1) THEN\n+          KX = 1\n+      END IF\n+      KK = 1\n+      IF (LSAME(UPLO,'U')) THEN\n+          IF (INCX.EQ.1) THEN\n+              DO 20 J = 1,N\n+                  IF (X(J).NE.ZERO) THEN\n+                      TEMP = ALPHA*X(J)\n+                      K = KK\n+                      DO 10 I = 1,J\n+                          AP(K) = AP(K) + X(I)*TEMP\n+                          K = K + 1\n+   10                 CONTINUE\n+                  END IF\n+                  KK = KK + J\n+   20         CONTINUE\n+          ELSE\n+              JX = KX\n+              DO 40 J = 1,N\n+                  IF (X(JX).NE.ZERO) THEN\n+                      TEMP = ALPHA*X(JX)\n+                      IX = KX\n+                      DO 30 K = KK,KK + J - 1\n+                          AP(K) = AP(K) + X(IX)*TEMP\n+                          IX = IX + INCX\n+   30                 CONTINUE\n+                  END IF\n+                  JX = JX + INCX\n+                  KK = KK + J\n+   40         CONTINUE\n+          END IF\n+      ELSE\n+          IF (INCX.EQ.1) THEN\n+              DO 60 J = 1,N\n+                  IF (X(J).NE.ZERO) THEN\n+                      TEMP = ALPHA*X(J)\n+                      K = KK\n+                      DO 50 I = J,N\n+                          AP(K) = AP(K) + X(I)*TEMP\n+                          K = K + 1\n+   50                 CONTINUE\n+                  END IF\n+                  KK = KK + N - J + 1\n+   60         CONTINUE\n+          ELSE\n+              JX = KX\n+              DO 80 J = 1,N\n+                  IF (X(JX).NE.ZERO) THEN\n+                      TEMP = ALPHA*X(JX)\n+                      IX = JX\n+                      DO 70 K = KK,KK + N - J\n+                          AP(K) = AP(K) + X(IX)*TEMP\n+                          IX = IX + INCX\n+   70                 CONTINUE\n+                  END IF\n+                  JX = JX + INCX\n+                  KK = KK + N - J + 1\n+   80         CONTINUE\n+          END IF\n+      END IF\n+      RETURN\n+      END"}, {"sha": "a92469298161c074d5dcb7ef79583a13f5180d59", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -168,21 +168,19 @@ evolution_function_is_constant_p (const_tree chrec)\n     }\n }\n \n-/* Determine whether the given tree is an affine evolution function or not.  */\n+/* Determine whether CHREC is an affine evolution function in LOOPNUM.  */\n \n static inline bool \n-evolution_function_is_affine_p (const_tree chrec)\n+evolution_function_is_affine_in_loop (const_tree chrec, int loopnum)\n {\n   if (chrec == NULL_TREE)\n     return false;\n   \n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec), \n-\t\t\t\t\t     CHREC_VARIABLE (chrec))\n-\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec),\n-\t\t\t\t\t\tCHREC_VARIABLE (chrec)))\n+      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec), loopnum)\n+\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec), loopnum))\n \treturn true;\n       else\n \treturn false;\n@@ -192,14 +190,26 @@ evolution_function_is_affine_p (const_tree chrec)\n     }\n }\n \n-/* Determine whether the given tree is an affine or constant evolution\n-   function.  */\n+/* Determine whether CHREC is an affine evolution function or not.  */\n \n static inline bool \n-evolution_function_is_affine_or_constant_p (const_tree chrec)\n+evolution_function_is_affine_p (const_tree chrec)\n {\n-  return evolution_function_is_affine_p (chrec) \n-    || evolution_function_is_constant_p (chrec);\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec), CHREC_VARIABLE (chrec))\n+\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec), CHREC_VARIABLE (chrec)))\n+\treturn true;\n+      else\n+\treturn false;\n+      \n+    default:\n+      return false;\n+    }\n }\n \n /* Determines whether EXPR does not contains chrec expressions.  */\n@@ -221,5 +231,24 @@ chrec_type (const_tree chrec)\n   return TREE_TYPE (chrec);\n }\n \n+static inline tree\n+chrec_fold_op (enum tree_code code, tree type, tree op0, tree op1)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      return chrec_fold_plus (type, op0, op1);\n+\n+    case MINUS_EXPR:\n+      return chrec_fold_minus (type, op0, op1);\n+\n+    case MULT_EXPR:\n+      return chrec_fold_multiply (type, op0, op1);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+}\n \n #endif  /* GCC_TREE_CHREC_H  */"}, {"sha": "75545496a1773ec3151ac6b18efe9a4cf9d9b833", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -754,7 +754,7 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n     {\n       op = TREE_OPERAND (aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n-      access_fn = resolve_mixers (nest, access_fn);\n+      access_fn = instantiate_scev (nest, loop, access_fn);\n       base = initial_condition (access_fn);\n       split_constant_offset (base, &base, &off);\n       access_fn = chrec_replace_initial_condition (access_fn,\n@@ -1849,16 +1849,42 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n /* Helper recursive function for initializing the matrix A.  Returns\n    the initial value of CHREC.  */\n \n-static HOST_WIDE_INT\n+static tree\n initialize_matrix_A (lambda_matrix A, tree chrec, unsigned index, int mult)\n {\n   gcc_assert (chrec);\n \n-  if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n-    return int_cst_value (chrec);\n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      gcc_assert (TREE_CODE (CHREC_RIGHT (chrec)) == INTEGER_CST);\n+\n+      A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));\n+      return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);\n+\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case MINUS_EXPR:\n+      {\n+\ttree op0 = initialize_matrix_A (A, TREE_OPERAND (chrec, 0), index, mult);\n+\ttree op1 = initialize_matrix_A (A, TREE_OPERAND (chrec, 1), index, mult);\n+\n+\treturn chrec_fold_op (TREE_CODE (chrec), chrec_type (chrec), op0, op1);\n+      }\n \n-  A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));\n-  return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);\n+    case NOP_EXPR:\n+      {\n+\ttree op = initialize_matrix_A (A, TREE_OPERAND (chrec, 0), index, mult);\n+\treturn chrec_convert (chrec_type (chrec), op, NULL_TREE);\n+      }\n+\n+    case INTEGER_CST:\n+      return chrec;\n+\n+    default:\n+      gcc_unreachable ();\n+      return NULL_TREE;\n+    }\n }\n \n #define FLOOR_DIV(x,y) ((x) / (y))\n@@ -2090,8 +2116,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n   A = lambda_matrix_new (dim, 1);\n   S = lambda_matrix_new (dim, 1);\n \n-  init_a = initialize_matrix_A (A, chrec_a, 0, 1);\n-  init_b = initialize_matrix_A (A, chrec_b, nb_vars_a, -1);\n+  init_a = int_cst_value (initialize_matrix_A (A, chrec_a, 0, 1));\n+  init_b = int_cst_value (initialize_matrix_A (A, chrec_b, nb_vars_a, -1));\n   gamma = init_b - init_a;\n \n   /* Don't do all the hard work of solving the Diophantine equation\n@@ -2369,25 +2395,26 @@ analyze_siv_subscript (tree chrec_a,\n \t\t       tree chrec_b,\n \t\t       conflict_function **overlaps_a, \n \t\t       conflict_function **overlaps_b, \n-\t\t       tree *last_conflicts)\n+\t\t       tree *last_conflicts,\n+\t\t       int loop_nest_num)\n {\n   dependence_stats.num_siv++;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_siv_subscript \\n\");\n   \n   if (evolution_function_is_constant_p (chrec_a)\n-      && evolution_function_is_affine_p (chrec_b))\n+      && evolution_function_is_affine_in_loop (chrec_b, loop_nest_num))\n     analyze_siv_subscript_cst_affine (chrec_a, chrec_b, \n \t\t\t\t      overlaps_a, overlaps_b, last_conflicts);\n   \n-  else if (evolution_function_is_affine_p (chrec_a)\n+  else if (evolution_function_is_affine_in_loop (chrec_a, loop_nest_num)\n \t   && evolution_function_is_constant_p (chrec_b))\n     analyze_siv_subscript_cst_affine (chrec_b, chrec_a, \n \t\t\t\t      overlaps_b, overlaps_a, last_conflicts);\n   \n-  else if (evolution_function_is_affine_p (chrec_a)\n-\t   && evolution_function_is_affine_p (chrec_b))\n+  else if (evolution_function_is_affine_in_loop (chrec_a, loop_nest_num)\n+\t   && evolution_function_is_affine_in_loop (chrec_b, loop_nest_num))\n     {\n       if (!chrec_contains_symbols (chrec_a)\n \t  && !chrec_contains_symbols (chrec_b))\n@@ -2649,7 +2676,7 @@ analyze_overlapping_iterations (tree chrec_a,\n   else if (siv_subscript_p (chrec_a, chrec_b))\n     analyze_siv_subscript (chrec_a, chrec_b, \n \t\t\t   overlap_iterations_a, overlap_iterations_b, \n-\t\t\t   last_conflicts);\n+\t\t\t   last_conflicts, lnn);\n   \n   else\n     analyze_miv_subscript (chrec_a, chrec_b, "}, {"sha": "7c9736a3b0245074c085b4f0de2d3d70a30db7b1", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b78fc3ed4960c5eda8ec76ab2e86548c51a6811/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=5b78fc3ed4960c5eda8ec76ab2e86548c51a6811", "patch": "@@ -1952,26 +1952,23 @@ loop_closed_phi_def (tree var)\n }\n \n /* Analyze all the parameters of the chrec, between INSTANTIATION_LOOP\n-   and EVOLUTION_LOOP, that were left under a symbolic form.  CHREC is\n-   the scalar evolution to instantiate.  CACHE is the cache of already\n-   instantiated values.  FLAGS modify the way chrecs are instantiated.\n+   and EVOLUTION_LOOP, that were left under a symbolic form.  \n+\n+   CHREC is the scalar evolution to instantiate.\n+\n+   CACHE is the cache of already instantiated values.\n+\n+   FOLD_CONVERSIONS should be set to true when the conversions that\n+   may wrap in signed/pointer type are folded, as long as the value of\n+   the chrec is preserved.\n+\n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n-\n-/* Values for FLAGS.  */\n-enum\n-{\n-  INSERT_SUPERLOOP_CHRECS = 1,  /* Loop invariants are replaced with chrecs\n-\t\t\t\t   in outer loops.  */\n-  FOLD_CONVERSIONS = 2\t\t/* The conversions that may wrap in\n-\t\t\t\t   signed/pointer type are folded, as long as the\n-\t\t\t\t   value of the chrec is preserved.  */\n-};\n   \n static tree\n instantiate_scev_1 (struct loop *instantiation_loop,\n \t\t    struct loop *evolution_loop, tree chrec,\n-\t\t    int flags, htab_t cache, int size_expr)\n+\t\t    bool fold_conversions, htab_t cache, int size_expr)\n {\n   tree res, op0, op1, op2;\n   basic_block def_bb;\n@@ -1995,8 +1992,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \t evolutions in outer loops), nothing to do.  */\n       if (!def_bb\n \t  || loop_depth (def_bb->loop_father) == 0\n-\t  || (!(flags & INSERT_SUPERLOOP_CHRECS)\n-\t      && !flow_bb_inside_loop_p (instantiation_loop, def_bb)))\n+\t  || !flow_bb_inside_loop_p (instantiation_loop, def_bb))\n \treturn chrec;\n \n       /* We cache the value of instantiated variable to avoid exponential\n@@ -2052,7 +2048,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \n       else if (res != chrec_dont_know)\n \tres = instantiate_scev_1 (instantiation_loop, evolution_loop, res,\n-\t\t\t\t  flags, cache, size_expr);\n+\t\t\t\t  fold_conversions, cache, size_expr);\n \n       bitmap_clear_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n \n@@ -2062,12 +2058,14 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \n     case POLYNOMIAL_CHREC:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n-\t\t\t\tCHREC_LEFT (chrec), flags, cache, size_expr);\n+\t\t\t\tCHREC_LEFT (chrec), fold_conversions, cache,\n+\t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n-\t\t\t\tCHREC_RIGHT (chrec), flags, cache, size_expr);\n+\t\t\t\tCHREC_RIGHT (chrec), fold_conversions, cache,\n+\t\t\t\tsize_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2082,13 +2080,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n-\t\t\t\tTREE_OPERAND (chrec, 0), flags, cache,\n+\t\t\t\tTREE_OPERAND (chrec, 0), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n-\t\t\t\tTREE_OPERAND (chrec, 1), flags, cache,\n+\t\t\t\tTREE_OPERAND (chrec, 1), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n@@ -2104,14 +2102,14 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \n     case MINUS_EXPR:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n-\t\t\t\tTREE_OPERAND (chrec, 0), flags, cache,\n+\t\t\t\tTREE_OPERAND (chrec, 0), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2127,13 +2125,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     case MULT_EXPR:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2149,11 +2147,11 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     CASE_CONVERT:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n         return chrec_dont_know;\n \n-      if (flags & FOLD_CONVERSIONS)\n+      if (fold_conversions)\n \t{\n \t  tree tmp = chrec_convert_aggressive (TREE_TYPE (chrec), op0);\n \t  if (tmp)\n@@ -2166,7 +2164,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n       /* If we used chrec_convert_aggressive, we can no longer assume that\n \t signed chrecs do not overflow, as chrec_convert does, so avoid\n          calling it in that case.  */\n-      if (flags & FOLD_CONVERSIONS)\n+      if (fold_conversions)\n \treturn fold_convert (TREE_TYPE (chrec), op0);\n \n       return chrec_convert (TREE_TYPE (chrec), op0, NULL_TREE);\n@@ -2187,19 +2185,19 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     case 3:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op2 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 2),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op2 == chrec_dont_know)\n         return chrec_dont_know;\n \n@@ -2214,13 +2212,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     case 2:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n       op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n         return chrec_dont_know;\n \n@@ -2232,7 +2230,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n     case 1:\n       op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n-\t\t\t\tflags, cache, size_expr);\n+\t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n         return chrec_dont_know;\n       if (op0 == TREE_OPERAND (chrec, 0))\n@@ -2272,8 +2270,8 @@ instantiate_scev (struct loop *instantiation_loop, struct loop *evolution_loop,\n       fprintf (dump_file, \")\\n\");\n     }\n  \n-  res = instantiate_scev_1 (instantiation_loop, evolution_loop, chrec, \n-\t\t\t    INSERT_SUPERLOOP_CHRECS, cache, 0);\n+  res = instantiate_scev_1 (instantiation_loop, evolution_loop, chrec, false,\n+\t\t\t    cache, 0);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2296,7 +2294,7 @@ tree\n resolve_mixers (struct loop *loop, tree chrec)\n {\n   htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n-  tree ret = instantiate_scev_1 (loop, loop, chrec, FOLD_CONVERSIONS, cache, 0);\n+  tree ret = instantiate_scev_1 (loop, loop, chrec, true, cache, 0);\n   htab_delete (cache);\n   return ret;\n }"}]}