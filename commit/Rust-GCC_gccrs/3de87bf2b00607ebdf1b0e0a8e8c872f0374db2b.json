{"sha": "3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RlODdiZjJiMDA2MDdlYmRmMWIwZTBhOGU4Yzg3MmYwMzc0ZGIyYg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2001-08-20T17:08:14Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-08-20T17:08:14Z"}, "message": "invoke.texi (Profiling options): Clarify the interactions between -fprofile-arcs and -ftest-coverage, -fprofile-arcs.\n\n\t* doc/invoke.texi (Profiling options): Clarify the interactions\n\tbetween -fprofile-arcs and -ftest-coverage, -fprofile-arcs.\n\nFrom-SVN: r45053", "tree": {"sha": "13e8d71faaad13beb326ca9115d2ff78071e37e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13e8d71faaad13beb326ca9115d2ff78071e37e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b/comments", "author": null, "committer": null, "parents": [{"sha": "0ff95153a1cd4850cf97e7c1f9ff7b2c84624478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff95153a1cd4850cf97e7c1f9ff7b2c84624478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff95153a1cd4850cf97e7c1f9ff7b2c84624478"}], "stats": {"total": 93, "additions": 64, "deletions": 29}, "files": [{"sha": "8e7eeebb0d6c90672d26a31948b3c3d6b2d57950", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "patch": "@@ -1,3 +1,8 @@\n+2001-08-20  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* doc/invoke.texi (Profiling options): Clarify the interactions\n+\tbetween -fprofile-arcs and -ftest-coverage, -fprofile-arcs.\n+\n 2001-08-20  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* crtstuff.c (__do_global_ctors): Fix typo in preprocessing"}, {"sha": "2e517e5b441487e12667d1608b76159553475b52", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3de87bf2b00607ebdf1b0e0a8e8c872f0374db2b", "patch": "@@ -2756,33 +2756,46 @@ frequencies.\n \n @item -fprofile-arcs\n @opindex fprofile-arcs\n-Instrument @dfn{arcs} during compilation.  For each function of your\n-program, GCC creates a program flow graph, then finds a spanning tree\n-for the graph.  Only arcs that are not on the spanning tree have to be\n-instrumented: the compiler adds code to count the number of times that these\n-arcs are executed.  When an arc is the only exit or only entrance to a\n-block, the instrumentation code can be added to the block; otherwise, a\n-new basic block must be created to hold the instrumentation code.\n-\n-Since not every arc in the program must be instrumented, programs\n-compiled with this option run faster than programs compiled with\n-@option{-a}, which adds instrumentation code to every basic block in the\n-program.  The tradeoff: since @code{gcov} does not have\n-execution counts for all branches, it must start with the execution\n-counts for the instrumented branches, and then iterate over the program\n-flow graph until the entire graph has been solved.  Hence, @code{gcov}\n-runs a little more slowly than a program which uses information from\n-@option{-a}.\n-\n-@option{-fprofile-arcs} also makes it possible to estimate branch\n-probabilities, and to calculate basic block execution counts.  In\n-general, basic block execution counts do not give enough information to\n-estimate all branch probabilities.  When the compiled program exits, it\n-saves the arc execution counts to a file called\n-@file{@var{sourcename}.da}.  Use the compiler option\n+Instrument @dfn{arcs} during compilation to generate coverage data\n+or for profile-directed block ordering.  During execution the program\n+records how many times each branch is executed and how many times it is\n+taken.  When the compiled program exits it saves this data to a file\n+called @file{@var{sourcename}.da} for each source file.\n+\n+For profile-directed block ordering, compile the program with\n+@option{-fprofile-arcs} plus optimization and code generation options,\n+generate the arc profile information by running the program on a\n+selected workload, and then compile the program again with the same\n+optimization and code generation options plus\n @option{-fbranch-probabilities} (@pxref{Optimize Options,,Options that\n-Control Optimization}) when recompiling, to optimize using estimated\n-branch probabilities.\n+Control Optimization}).\n+\n+The other use of @option{-fprofile-arcs} is for use with @code{gcov},\n+when it is used with the @option{-ftest-coverage} option.  GCC\n+supports two methods of determining code coverage: the options that\n+support @code{gcov}, and options @option{-a} and @option{-ax}, which\n+write information to text files.  The options that support @code{gcov}\n+do not need to instrument every arc in the program, so a program compiled\n+with them runs faster than a program compiled with @option{-a}, which\n+adds instrumentation code to every basic block in the program.  The\n+tradeoff: since @code{gcov} does not have execution counts for all\n+branches, it must start with the execution counts for the instrumented\n+branches, and then iterate over the program flow graph until the entire\n+graph has been solved.  Hence, @code{gcov} runs a little more slowly than\n+a program which uses information from @option{-a} and @option{-ax}.\n+\n+With @option{-fprofile-arcs}, for each function of your program GCC\n+creates a program flow graph, then finds a spanning tree for the graph.\n+Only arcs that are not on the spanning tree have to be instrumented: the\n+compiler adds code to count the number of times that these arcs are\n+executed.  When an arc is the only exit or only entrance to a block, the\n+instrumentation code can be added to the block; otherwise, a new basic\n+block must be created to hold the instrumentation code.\n+\n+This option makes it possible to estimate branch probabilities and to\n+calculate basic block execution counts.  In general, basic block\n+execution counts as provided by @option{-a} do not give enough\n+information to estimate all branch probabilities.\n \n @need 2000\n @item -ftest-coverage\n@@ -2800,10 +2813,22 @@ associate basic block execution counts with line numbers.\n A list of all arcs in the program flow graph.  This allows @code{gcov}\n to reconstruct the program flow graph, so that it can compute all basic\n block and arc execution counts from the information in the\n-@code{@var{sourcename}.da} file (this last file is the output from\n-@option{-fprofile-arcs}).\n+@code{@var{sourcename}.da} file.\n @end table\n \n+Use @option{-ftest-coverage} with @option{-fprofile-arcs}; the latter\n+option adds instrumentation to the program, which then writes\n+execution counts to another data file:\n+\n+@table @gcctabopt\n+@item @var{sourcename}.da\n+Runtime arc execution counts, used in conjunction with the arc\n+information in the file @code{@var{sourcename}.bbg}.\n+@end table\n+\n+Coverage data will map better to the source files if\n+@option{-ftest-coverage} is used without optimization.\n+\n @item -d@var{letters}\n @opindex d\n Says to make debugging dumps during compilation at times specified by\n@@ -3571,7 +3596,12 @@ After running a program compiled with @option{-fprofile-arcs}\n (@pxref{Debugging Options,, Options for Debugging Your Program or\n @command{gcc}}), you can compile it a second time using\n @option{-fbranch-probabilities}, to improve optimizations based on\n-guessing the path a branch might take.\n+the number of times each branch was taken.  When the program\n+compiled with @option{-fprofile-arcs} exits it saves arc execution\n+counts to a file called @file{@var{sourcename}.da} for each source\n+file  The information in this data file is very dependent on the\n+structure of the generated code, so you must use the same source code\n+and the same optimization options for both compilations.\n \n @ifset INTERNALS\n With @option{-fbranch-probabilities}, GCC puts a @samp{REG_EXEC_COUNT}"}]}