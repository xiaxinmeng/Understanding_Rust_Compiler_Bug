{"sha": "2927ca4b24666f947b0c91c42fabc41a98593a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkyN2NhNGIyNDY2NmY5NDdiMGM5MWM0MmZhYmM0MWE5ODU5M2EzYQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-19T22:56:42Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-19T22:56:42Z"}, "message": "fix PR68341: correctly compute the insertion point for close phi nodes\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r230631", "tree": {"sha": "d2892d8349a8d1b1e38ac14f3c388447d14e8be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2892d8349a8d1b1e38ac14f3c388447d14e8be5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2927ca4b24666f947b0c91c42fabc41a98593a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2927ca4b24666f947b0c91c42fabc41a98593a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2927ca4b24666f947b0c91c42fabc41a98593a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2927ca4b24666f947b0c91c42fabc41a98593a3a/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deca2146136cdd6cadfe4d36b0abfddf82214ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deca2146136cdd6cadfe4d36b0abfddf82214ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deca2146136cdd6cadfe4d36b0abfddf82214ce1"}], "stats": {"total": 109, "additions": 74, "deletions": 35}, "files": [{"sha": "4b8bd47919c910f6de6bdd8a32f1c7b00efde065", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2927ca4b24666f947b0c91c42fabc41a98593a3a", "patch": "@@ -1,3 +1,14 @@\n+2015-11-19  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68341\n+\t* graphite-isl-ast-to-gimple.c (get_rename_from_scev): Remove\n+\tgcc_unreachable and safely fail codegen.\n+\t(copy_loop_close_phi_args): Do not insert merge phis in a basic\n+\tblock with loop phi nodes.\n+\t(edge_for_new_close_phis): New.\n+\t(copy_bb_and_scalar_dependences): Call edge_for_new_close_phis.\n+\n 2015-11-19  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.h (SUPPORTS_WEAK): Define."}, {"sha": "557c44cf10bd8eaf6e3747683009809b3c53fbab", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=2927ca4b24666f947b0c91c42fabc41a98593a3a", "patch": "@@ -399,6 +399,11 @@ class translate_isl_ast_to_gimple\n   edge copy_bb_and_scalar_dependences (basic_block bb, edge next_e,\n \t\t\t\t       vec<tree> iv_map);\n \n+  /* Given a basic block containing close-phi it returns the new basic block\n+     where to insert a copy of the close-phi nodes.  All the uses in close phis\n+     should come from a single loop otherwise it returns NULL.  */\n+  edge edge_for_new_close_phis (basic_block bb);\n+\n   /* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n      DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates\n      the other pred of OLD_BB as well.  If no such basic block exists then it is\n@@ -1628,8 +1633,8 @@ translate_isl_ast_to_gimple::rename_all_uses (tree new_expr, basic_block new_bb,\n   return new_expr;\n }\n \n-/* For ops which are scev_analyzeable, we can regenerate a new name from\n-its scalar evolution around LOOP.  */\n+/* For ops which are scev_analyzeable, we can regenerate a new name from its\n+   scalar evolution around LOOP.  */\n \n tree\n translate_isl_ast_to_gimple::\n@@ -1670,9 +1675,7 @@ get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n       basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n       if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n \t{\n-\t  /* FIXME: Remove if bootstrap passes.  */\n \t  codegen_error = true;\n-\t  gcc_unreachable ();\n \t  return build_zero_cst (TREE_TYPE (old_name));\n \t}\n     }\n@@ -1685,9 +1688,7 @@ get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n       basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n       if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n \t{\n-\t  /* FIXME: Remove if bootstrap passes.  */\n \t  codegen_error = true;\n-\t  gcc_unreachable ();\n \t  return build_zero_cst (TREE_TYPE (old_name));\n \t}\n     }\n@@ -2047,7 +2048,7 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n {\n   /* The successor of bb having close phi should be a merge of the diamond\n      inserted to guard the loop during codegen.  */\n-  basic_block close_phi_merge_bb = single_succ (new_bb);\n+  basic_block succ_new_bb = single_succ (new_bb);\n \n   for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n        gsi_next (&psi))\n@@ -2087,10 +2088,11 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n \n       /* When there is no loop guard around this codegenerated loop, there is no\n \t need to collect the close-phi arg.  */\n-      if (2 != EDGE_COUNT (close_phi_merge_bb->preds))\n+      if (2 != EDGE_COUNT (succ_new_bb->preds)\n+\t  || bb_contains_loop_phi_nodes (succ_new_bb))\n \tcontinue;\n \n-      /* Add a PHI in the close_phi_merge_bb for each close phi of the loop.  */\n+      /* Add a PHI in the succ_new_bb for each close phi of the loop.  */\n       tree init = find_init_value_close_phi (new_phi);\n \n       /* A close phi must come from a loop-phi having an init value.  */\n@@ -2108,8 +2110,7 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n \t  continue;\n \t}\n \n-      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res),\n-\t\t\t  \t\t close_phi_merge_bb);\n+      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res), succ_new_bb);\n       tree merge_res = create_new_def_for (res, merge_phi,\n \t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n       set_rename (res, merge_res);\n@@ -2118,8 +2119,8 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n       add_phi_arg (merge_phi, new_res, from_loop, get_loc (old_name));\n \n       /* The edge coming from loop guard.  */\n-      edge other = from_loop == (*close_phi_merge_bb->preds)[0]\n-\t? (*close_phi_merge_bb->preds)[1] : (*close_phi_merge_bb->preds)[0];\n+      edge other = from_loop == (*succ_new_bb->preds)[0]\n+\t? (*succ_new_bb->preds)[1] : (*succ_new_bb->preds)[0];\n \n       add_phi_arg (merge_phi, init, other, get_loc (old_name));\n       if (dump_file)\n@@ -2573,6 +2574,47 @@ translate_isl_ast_to_gimple::graphite_copy_stmts_from_block (basic_block bb,\n   return true;\n }\n \n+\n+/* Given a basic block containing close-phi it returns the new basic block where\n+   to insert a copy of the close-phi nodes.  All the uses in close phis should\n+   come from a single loop otherwise it returns NULL.  */\n+\n+edge\n+translate_isl_ast_to_gimple::edge_for_new_close_phis (basic_block bb)\n+{\n+  /* Make sure that NEW_BB is the new_loop->exit->dest.  We find the definition\n+     of close phi in the original code and then find the mapping of basic block\n+     defining that variable.  If there are multiple close-phis and they are\n+     defined in different loops (in the original or in the new code) because of\n+     loop splitting, then we bail out.  */\n+  loop_p new_loop = NULL;\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree name = gimple_phi_arg_def (phi, 0);\n+      basic_block old_loop_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n+\n+      vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n+      if (!bbs || bbs->length () != 1)\n+\t/* This is one of the places which shows preserving original structure\n+\t   is not always possible, as we may need to insert close PHI for a loop\n+\t   where the latch does not have any mapping, or the mapping is\n+\t   ambiguous.  */\n+\treturn NULL;\n+\n+      if (!new_loop)\n+\tnew_loop = (*bbs)[0]->loop_father;\n+      else if (new_loop != (*bbs)[0]->loop_father)\n+\treturn NULL;\n+    }\n+\n+  if (!new_loop)\n+    return NULL;\n+\n+  return single_exit (new_loop);\n+}\n+\n /* Copies BB and includes in the copied BB all the statements that can\n    be reached following the use-def chains from the memory accesses,\n    and returns the next edge following this new block.  codegen_error is\n@@ -2626,30 +2668,16 @@ translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n \tfprintf (dump_file, \"\\n[codegen] bb_%d contains close phi nodes\",\n \t\t bb->index);\n \n-      /* Make sure that NEW_BB is the loop->exit->dest.  */\n-      edge e = single_pred_edge (new_bb);\n-      basic_block phi_bb = new_bb;\n-      if (e->src->loop_father == e->dest->loop_father)\n+      edge e = edge_for_new_close_phis (bb);\n+      if (!e)\n \t{\n-\t  /* This is one of the places which shows preserving original structure\n-\t     is not always possible, as we may need to insert close PHI for a\n-\t     loop where the latch does not have any mapping, or the mapping is\n-\t     ambiguous.  */\n-\t  basic_block old_loop_bb = single_pred_edge (bb)->src;\n-\t  vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n-\t  if (!bbs || bbs->length () != 1)\n-\t    {\n-\t      codegen_error = true;\n-\t      return NULL;\n-\t    }\n-\n-\t  basic_block new_loop_bb = (*bbs)[0];\n-\t  loop_p new_loop = new_loop_bb->loop_father;\n-\t  phi_bb = single_exit (new_loop)->dest;\n-\t  e = single_pred_edge (phi_bb);\n+\t  codegen_error = true;\n+\t  return NULL;\n \t}\n \n-      gcc_assert (e->src->loop_father != e->dest->loop_father);\n+      basic_block phi_bb = split_edge (e);\n+      gcc_assert (single_pred_edge (phi_bb)->src->loop_father\n+\t\t  != single_pred_edge (phi_bb)->dest->loop_father);\n \n       if (!copy_loop_close_phi_nodes (bb, phi_bb))\n \t{"}, {"sha": "1290aa0f47e3365589a5e0c78f9d2186ad593c3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2927ca4b24666f947b0c91c42fabc41a98593a3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2927ca4b24666f947b0c91c42fabc41a98593a3a", "patch": "@@ -1,4 +1,4 @@\n-2015-11-06  Aditya Kumar  <aditya.k7@samsung.com>\n+2015-11-19  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \n \tPR tree-optimization/68335"}]}