{"sha": "c959db3d3b344fa2e21fdd79768e2349d7c2db25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1OWRiM2QzYjM0NGZhMmUyMWZkZDc5NzY4ZTIzNDlkN2MyZGIyNQ==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2016-05-13T09:32:29Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2016-05-13T09:32:29Z"}, "message": "Fix PR target/53440 - handle generic thunks better for TARGET_32BIT.\n\n\nThis partially fixes PR target/53440 atleast in ARM and\nThumb2 state. I haven't yet managed to get my head around\nrewriting the Thumb1 support yet.\n\nTested on armhf with a bootstrap and regression test\nwith no regressions.\n\nQueued for stage1 now as it isn't technically a regression.\n\nregards\nRamana\n\n\n2016-05-13  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n        PR target/53440\n        * config/arm/arm.c (arm32_output_mi_thunk): New.\n        (arm_output_mi_thunk): Rename to arm_thumb1_mi_thunk. Rework\n        to split Thumb1 vs TARGET_32BIT functionality.\n        (arm_thumb1_mi_thunk): New.\n\n\n        * g++.dg/inherit/thunk1.C: Support arm / aarch64.\n\nFrom-SVN: r236198", "tree": {"sha": "d5453fb8781fd3155de6a7028b49ec1db7df0b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5453fb8781fd3155de6a7028b49ec1db7df0b3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c959db3d3b344fa2e21fdd79768e2349d7c2db25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c959db3d3b344fa2e21fdd79768e2349d7c2db25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c959db3d3b344fa2e21fdd79768e2349d7c2db25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c959db3d3b344fa2e21fdd79768e2349d7c2db25/comments", "author": null, "committer": null, "parents": [{"sha": "43203dea1afa87140a0f045f2c2182943247065f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43203dea1afa87140a0f045f2c2182943247065f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43203dea1afa87140a0f045f2c2182943247065f"}], "stats": {"total": 112, "additions": 106, "deletions": 6}, "files": [{"sha": "27deda6cc1423b233c05a28641754402685fb59e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c959db3d3b344fa2e21fdd79768e2349d7c2db25", "patch": "@@ -1,3 +1,11 @@\n+2016-05-13  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+        PR target/53440\n+        * config/arm/arm.c (arm32_output_mi_thunk): New.\n+        (arm_output_mi_thunk): Rename to arm_thumb1_mi_thunk. Rework\n+        to split Thumb1 vs TARGET_32BIT functionality.\n+        (arm_thumb1_mi_thunk): New.\n+\n 2016-05-13  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/aarch64/aarch64.c (TARGET_OMIT_STRUCT_RETURN_REG): Set"}, {"sha": "fbae1bcf5ea4d07735104a1841cf64a2664d6b0b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 91, "deletions": 5, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c959db3d3b344fa2e21fdd79768e2349d7c2db25", "patch": "@@ -300,6 +300,9 @@ static void arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n static unsigned HOST_WIDE_INT arm_asan_shadow_offset (void);\n \n static void arm_sched_fusion_priority (rtx_insn *, int, int *, int*);\n+static bool arm_can_output_mi_thunk (const_tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t     const_tree);\n+\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -463,7 +466,7 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK arm_output_mi_thunk\n #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK arm_can_output_mi_thunk\n \n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS arm_rtx_costs\n@@ -26132,11 +26135,10 @@ arm_internal_label (FILE *stream, const char *prefix, unsigned long labelno)\n \n /* Output code to add DELTA to the first argument, and then jump\n    to FUNCTION.  Used for C++ multiple inheritance.  */\n+\n static void\n-arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n-\t\t     HOST_WIDE_INT delta,\n-\t\t     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n-\t\t     tree function)\n+arm_thumb1_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,\n+\t\t     HOST_WIDE_INT, tree function)\n {\n   static int thunk_label = 0;\n   char label[256];\n@@ -26277,6 +26279,76 @@ arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   final_end_function ();\n }\n \n+/* MI thunk handling for TARGET_32BIT.  */\n+\n+static void\n+arm32_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,\n+\t\t       HOST_WIDE_INT vcall_offset, tree function)\n+{\n+  /* On ARM, this_regno is R0 or R1 depending on\n+     whether the function returns an aggregate or not.\n+  */\n+  int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t\t       function)\n+\t\t    ? R1_REGNUM : R0_REGNUM);\n+\n+  rtx temp = gen_rtx_REG (Pmode, IP_REGNUM);\n+  rtx this_rtx = gen_rtx_REG (Pmode, this_regno);\n+  reload_completed = 1;\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* Add DELTA to THIS_RTX.  */\n+  if (delta != 0)\n+    arm_split_constant (PLUS, Pmode, NULL_RTX,\n+\t\t\tdelta, this_rtx, this_rtx, false);\n+\n+  /* Add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n+  if (vcall_offset != 0)\n+    {\n+      /* Load *THIS_RTX.  */\n+      emit_move_insn (temp, gen_rtx_MEM (Pmode, this_rtx));\n+      /* Compute *THIS_RTX + VCALL_OFFSET.  */\n+      arm_split_constant (PLUS, Pmode, NULL_RTX, vcall_offset, temp, temp,\n+\t\t\t  false);\n+      /* Compute *(*THIS_RTX + VCALL_OFFSET).  */\n+      emit_move_insn (temp, gen_rtx_MEM (Pmode, temp));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp));\n+    }\n+\n+  /* Generate a tail call to the target function.  */\n+  if (!TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+  rtx funexp = XEXP (DECL_RTL (function), 0);\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+  rtx_insn * insn = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  insn = get_insns ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Stop pretending this is a post-reload pass.  */\n+  reload_completed = 0;\n+}\n+\n+/* Output code to add DELTA to the first argument, and then jump\n+   to FUNCTION.  Used for C++ multiple inheritance.  */\n+\n+static void\n+arm_output_mi_thunk (FILE *file, tree thunk, HOST_WIDE_INT delta,\n+\t\t     HOST_WIDE_INT vcall_offset, tree function)\n+{\n+  if (TARGET_32BIT)\n+    arm32_output_mi_thunk (file, thunk, delta, vcall_offset, function);\n+  else\n+    arm_thumb1_mi_thunk (file, thunk, delta, vcall_offset, function);\n+}\n+\n int\n arm_emit_vector_const (FILE *file, rtx x)\n {\n@@ -30381,4 +30453,18 @@ arm_simd_check_vect_par_cnst_half_p (rtx op, machine_mode mode,\n   return true;\n }\n \n+/* Can output mi_thunk for all cases except for non-zero vcall_offset\n+   in Thumb1.  */\n+static bool\n+arm_can_output_mi_thunk (const_tree, HOST_WIDE_INT, HOST_WIDE_INT vcall_offset,\n+\t\t\t const_tree)\n+{\n+  /* For now, we punt and not handle this for TARGET_THUMB1.  */\n+  if (vcall_offset && TARGET_THUMB1)\n+    return false;\n+\n+  /* Otherwise ok.  */\n+  return true;\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "e3b0280a35d9b8622b57e1a6700c5a2a56b41da0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c959db3d3b344fa2e21fdd79768e2349d7c2db25", "patch": "@@ -1,3 +1,8 @@\n+2016-05-13  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+        PR target/53440\n+        * g++.dg/inherit/thunk1.C: Support arm / aarch64.\n+\n 2016-05-13  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* gcc.target/aarch64/struct_return.c: New test."}, {"sha": "e59586a14bdb993dd4adc12f7f82a61867233057", "filename": "gcc/testsuite/g++.dg/inherit/thunk1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c959db3d3b344fa2e21fdd79768e2349d7c2db25/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk1.C?ref=c959db3d3b344fa2e21fdd79768e2349d7c2db25", "patch": "@@ -1,4 +1,5 @@\n-// { dg-do run { target i?86-*-* x86_64-*-* s390*-*-* alpha*-*-* ia64-*-* sparc*-*-* } }\n+// { dg-skip-if \"\" { arm_thumb1_ok } }\n+// { dg-do run { target arm*-*-* aarch64*-*-* i?86-*-* x86_64-*-* s390*-*-* alpha*-*-* ia64-*-* sparc*-*-* } }\n \n #include <stdarg.h>\n "}]}