{"sha": "f658ad3002a0afc8aa86d5646ee704921d969ebe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1OGFkMzAwMmEwYWZjOGFhODZkNTY0NmVlNzA0OTIxZDk2OWViZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-24T22:19:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-24T22:19:09Z"}, "message": "cgraphunit.c (symbol_table::process_new_functions): Call ipa_free_size_summary.\n\n\n\t* cgraphunit.c (symbol_table::process_new_functions): Call\n\tipa_free_size_summary.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Update.\n\t(devirtualization_time_bonus): Update.\n\t(ipcp_propagate_stage): Update.\n\t* ipa-fnsummary.c (ipa_size_summaries): New.\n\t(ipa_fn_summary_alloc): Alloc size summary.\n\t(dump_ipa_call_summary): Update.\n\t(ipa_dump_fn_summary): Update.\n\t(analyze_function_body): Update.\n\t(compute_fn_summary): Likewise.\n\t(ipa_get_stack_frame_offset): New function.\n\t(inline_update_callee_summaries): Do not update frame offsets.\n\t(ipa_merge_fn_summary_after_inlining): Update frame offsets here;\n\tremove call and function summary.\n\t(ipa_update_overall_fn_summary): Update.\n\t(inline_read_section): Update.\n\t(ipa_fn_summary_write): Update.\n\t(ipa_free_fn_summary): Do not remove summaries.\n\t(ipa_free_size_summary): New.\n\t(release summary pass): Also run at WPA.\n\t* ipa-fnsummary.h (ipa_size_summary): Declare.\n\t(ipa_fn_summary): Remove size, self_size, stack_frame_offset,\n\testimated_self_stack_size.\n\t(ipa_size_summary_t): New type.\n\t(ipa_size_summaries): Declare.\n\t(ipa_free_size_summary): Declare.\n\t(ipa_get_stack_frame_offset): Declare.\n\t* ipa-icf.c (sem_function::merge): Update.\n\t* ipa-inline-analysis.c (estimate_size_after_inlining): Update.\n\t(estimate_growth): Update.\n\t(growth_likely_positive): Update.\n\t(clone_inlined_nodes): Update.\n\t(inline_call): Update.\n\t* ipa-inline.c (caller_growth_limits): Update.\n\t(edge_badness): Update.\n\t(recursive_inlining): Update.\n\t(inline_small_functions): Update.\n\t(inline_to_all_callers_1): Update.\n\t* ipa-prop.h (ipa_edge_args_sum_t): Update comment.\n\t* lto-partition.c (add_symbol_to_partition_1): Update.\n\t(undo_parittion): Update.\n\nFrom-SVN: r277424", "tree": {"sha": "4d446ea9851921b972691441855d8a4d8dd6b567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d446ea9851921b972691441855d8a4d8dd6b567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f658ad3002a0afc8aa86d5646ee704921d969ebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f658ad3002a0afc8aa86d5646ee704921d969ebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f658ad3002a0afc8aa86d5646ee704921d969ebe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f658ad3002a0afc8aa86d5646ee704921d969ebe/comments", "author": null, "committer": null, "parents": [{"sha": "90a158075a6b4e26c2e1204c71aa7f49548c5bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a158075a6b4e26c2e1204c71aa7f49548c5bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a158075a6b4e26c2e1204c71aa7f49548c5bd7"}], "stats": {"total": 366, "additions": 243, "deletions": 123}, "files": [{"sha": "a4b32508b5b32f54cc73830a21e31474bb8e15c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -1,3 +1,46 @@\n+2019-10-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraphunit.c (symbol_table::process_new_functions): Call\n+\tipa_free_size_summary.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Update.\n+\t(devirtualization_time_bonus): Update.\n+\t(ipcp_propagate_stage): Update.\n+\t* ipa-fnsummary.c (ipa_size_summaries): New.\n+\t(ipa_fn_summary_alloc): Alloc size summary.\n+\t(dump_ipa_call_summary): Update.\n+\t(ipa_dump_fn_summary): Update.\n+\t(analyze_function_body): Update.\n+\t(compute_fn_summary): Likewise.\n+\t(ipa_get_stack_frame_offset): New function.\n+\t(inline_update_callee_summaries): Do not update frame offsets.\n+\t(ipa_merge_fn_summary_after_inlining): Update frame offsets here;\n+\tremove call and function summary.\n+\t(ipa_update_overall_fn_summary): Update.\n+\t(inline_read_section): Update.\n+\t(ipa_fn_summary_write): Update.\n+\t(ipa_free_fn_summary): Do not remove summaries.\n+\t(ipa_free_size_summary): New.\n+\t(release summary pass): Also run at WPA.\n+\t* ipa-fnsummary.h (ipa_size_summary): Declare.\n+\t(ipa_fn_summary): Remove size, self_size, stack_frame_offset,\n+\testimated_self_stack_size.\n+\t(ipa_size_summary_t): New type.\n+\t(ipa_size_summaries): Declare.\n+\t(ipa_free_size_summary): Declare.\n+\t(ipa_get_stack_frame_offset): Declare.\n+\t* ipa-icf.c (sem_function::merge): Update.\n+\t* ipa-inline-analysis.c (estimate_size_after_inlining): Update.\n+\t(estimate_growth): Update.\n+\t(growth_likely_positive): Update.\n+\t(clone_inlined_nodes): Update.\n+\t(inline_call): Update.\n+\t* ipa-inline.c (caller_growth_limits): Update.\n+\t(edge_badness): Update.\n+\t(recursive_inlining): Update.\n+\t(inline_small_functions): Update.\n+\t(inline_to_all_callers_1): Update.\n+\t* ipa-prop.h (ipa_edge_args_sum_t): Update comment.\n+\n 2019-10-24  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/altivec.md (altivec_vavgu<VI_char>): Rename to..."}, {"sha": "3f751fa1044358de7e45dd2809cc585386a28604", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -340,7 +340,10 @@ symbol_table::process_new_functions (void)\n \t\t and splitting.  This is redundant for functions added late.\n \t\t Just throw away whatever it did.  */\n \t      if (!summaried_computed)\n-\t\tipa_free_fn_summary ();\n+\t\t{\n+\t\t  ipa_free_fn_summary ();\n+\t\t  ipa_free_size_summary ();\n+\t\t}\n \t    }\n \t  else if (ipa_fn_summaries != NULL)\n \t    compute_fn_summary (node, true);"}, {"sha": "f5852dcca8edd6876124fe948640127e1512fa6d", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -731,7 +731,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   init_caller_stats (&stats);\n   node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n-  if (ipa_fn_summaries->get (node)->self_size < stats.n_calls)\n+  if (ipa_size_summaries->get (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n@@ -2629,13 +2629,14 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       if (!isummary->inlinable)\n \tcontinue;\n \n+      int size = ipa_size_summaries->get (callee)->size;\n       /* FIXME: The values below need re-considering and perhaps also\n \t integrating into the cost metrics, at lest in some very basic way.  */\n-      if (isummary->size <= MAX_INLINE_INSNS_AUTO / 4)\n+      if (size <= MAX_INLINE_INSNS_AUTO / 4)\n \tres += 31 / ((int)speculative + 1);\n-      else if (isummary->size <= MAX_INLINE_INSNS_AUTO / 2)\n+      else if (size <= MAX_INLINE_INSNS_AUTO / 2)\n \tres += 15 / ((int)speculative + 1);\n-      else if (isummary->size <= MAX_INLINE_INSNS_AUTO\n+      else if (size <= MAX_INLINE_INSNS_AUTO\n \t       || DECL_DECLARED_INLINE_P (callee->decl))\n \tres += 7 / ((int)speculative + 1);\n     }\n@@ -3334,7 +3335,7 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n-    ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+    ipa_size_summary *s = ipa_size_summaries->get (node);\n     if (node->definition && !node->alias && s != NULL)\n       overall_size += s->self_size;\n     max_count = max_count.max (node->count.ipa ());"}, {"sha": "d6b6319c5f6f4a01c49297fb2b498b6e8d8daafc", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 90, "deletions": 61, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Summaries.  */\n fast_function_summary <ipa_fn_summary *, va_gc> *ipa_fn_summaries;\n+fast_function_summary <ipa_size_summary *, va_heap> *ipa_size_summaries;\n fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n \n /* Edge predicates goes here.  */\n@@ -552,6 +553,8 @@ ipa_fn_summary_alloc (void)\n {\n   gcc_checking_assert (!ipa_fn_summaries);\n   ipa_fn_summaries = ipa_fn_summary_t::create_ggc (symtab);\n+  ipa_size_summaries = new fast_function_summary <ipa_size_summary *, va_heap>\n+\t\t\t\t\t\t\t (symtab);\n   ipa_call_summaries = new ipa_call_summary_t (symtab);\n }\n \n@@ -791,9 +794,10 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       es->call_stmt_size, es->call_stmt_time);\n \n       ipa_fn_summary *s = ipa_fn_summaries->get (callee);\n+      ipa_size_summary *ss = ipa_size_summaries->get (callee);\n       if (s != NULL)\n-\tfprintf (f, \"callee size:%2i stack:%2i\",\n-\t\t (int) (s->size / ipa_fn_summary::size_scale),\n+\tfprintf (f, \" callee size:%2i stack:%2i\",\n+\t\t (int) (ss->size / ipa_fn_summary::size_scale),\n \t\t (int) s->estimated_stack_size);\n \n       if (es->predicate)\n@@ -817,13 +821,11 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t  }\n       if (!edge->inline_failed)\n \t{\n-\t  ipa_fn_summary *s = ipa_fn_summaries->get (callee);\n-\t  fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n-\t\t   \" callee size %i\\n\",\n+\t  ipa_size_summary *ss = ipa_size_summaries->get (callee);\n+\t  fprintf (f, \"%*sStack frame offset %i, callee self size %i\\n\",\n \t\t   indent + 2, \"\",\n-\t\t   (int) s->stack_frame_offset,\n-\t\t   (int) s->estimated_self_stack_size,\n-\t\t   (int) s->estimated_stack_size);\n+\t\t   (int) ipa_get_stack_frame_offset (callee),\n+\t\t   (int) ss->estimated_self_stack_size);\n \t  dump_ipa_call_summary (f, indent + 2, callee, info);\n \t}\n     }\n@@ -853,6 +855,7 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n   if (node->definition)\n     {\n       class ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+      class ipa_size_summary *ss = ipa_size_summaries->get (node);\n       if (s != NULL)\n \t{\n \t  size_time_entry *e;\n@@ -865,11 +868,11 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t  if (s->fp_expressions)\n \t    fprintf (f, \" fp_expression\");\n \t  fprintf (f, \"\\n  global time:     %f\\n\", s->time.to_double ());\n-\t  fprintf (f, \"  self size:       %i\\n\", s->self_size);\n-\t  fprintf (f, \"  global size:     %i\\n\", s->size);\n+\t  fprintf (f, \"  self size:       %i\\n\", ss->self_size);\n+\t  fprintf (f, \"  global size:     %i\\n\", ss->size);\n \t  fprintf (f, \"  min size:       %i\\n\", s->min_size);\n \t  fprintf (f, \"  self stack:      %i\\n\",\n-\t\t   (int) s->estimated_self_stack_size);\n+\t\t   (int) ss->estimated_self_stack_size);\n \t  fprintf (f, \"  global stack:    %i\\n\", (int) s->estimated_stack_size);\n \t  if (s->growth)\n \t    fprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n@@ -2655,8 +2658,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t}\n     }\n   ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+  ipa_size_summary *ss = ipa_size_summaries->get (node);\n   s->time = time;\n-  s->self_size = size;\n+  ss->self_size = size;\n   nonconstant_names.release ();\n   ipa_release_body_info (&fbi);\n   if (opt_for_fn (node->decl, optimize))\n@@ -2684,7 +2688,6 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n {\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n-  class ipa_fn_summary *info;\n \n   gcc_assert (!node->global.inlined_to);\n \n@@ -2694,14 +2697,14 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   /* Create a new ipa_fn_summary.  */\n   ((ipa_fn_summary_t *)ipa_fn_summaries)->remove_callees (node);\n   ipa_fn_summaries->remove (node);\n-  info = ipa_fn_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_size_summary *size_info = ipa_size_summaries->get_create (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize && !node->thunk.thunk_p\n \t\t    ? estimated_stack_frame_size (node) : 0;\n-  info->estimated_self_stack_size = self_stack_size;\n+  size_info->estimated_self_stack_size = self_stack_size;\n   info->estimated_stack_size = self_stack_size;\n-  info->stack_frame_offset = 0;\n \n   if (node->thunk.thunk_p)\n     {\n@@ -2719,7 +2722,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n       t = predicate::not_inlined ();\n       info->account_size_time (2 * ipa_fn_summary::size_scale, 0, t, t);\n       ipa_update_overall_fn_summary (node);\n-      info->self_size = info->size;\n+      size_info->self_size = size_info->size;\n       if (stdarg_p (TREE_TYPE (node->decl)))\n \t{\n \t  info->inlinable = false;\n@@ -2775,16 +2778,15 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   node->calls_comdat_local = (e != NULL);\n \n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n-  info->size = info->self_size;\n-  info->stack_frame_offset = 0;\n-  info->estimated_stack_size = info->estimated_self_stack_size;\n+  size_info->size = size_info->self_size;\n+  info->estimated_stack_size = size_info->estimated_self_stack_size;\n \n   /* Code above should compute exactly the same result as\n      ipa_update_overall_fn_summary but because computation happens in\n      different order the roundoff errors result in slight changes.  */\n   ipa_update_overall_fn_summary (node);\n   /* In LTO mode we may have speculative edges set.  */\n-  gcc_assert (in_lto_p || info->size == info->self_size);\n+  gcc_assert (in_lto_p || size_info->size == size_info->self_size);\n }\n \n \n@@ -3104,6 +3106,26 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t       ret_nonspec_time, hints, vNULL);\n }\n \n+/* Return stack frame offset where frame of NODE is supposed to start inside\n+   of the function it is inlined to.\n+   Return 0 for functions that are not inlined.  */\n+\n+HOST_WIDE_INT\n+ipa_get_stack_frame_offset (struct cgraph_node *node)\n+{\n+  HOST_WIDE_INT offset = 0;\n+  if (!node->global.inlined_to)\n+    return 0;\n+  node = node->callers->caller;\n+  while (true)\n+    {\n+      offset += ipa_size_summaries->get (node)->estimated_self_stack_size;\n+      if (!node->global.inlined_to)\n+\treturn offset;\n+      node = node->callers->caller;\n+    }\n+}\n+\n \n /* Update summary information of inline clones after inlining.\n    Compute peak stack usage.  */\n@@ -3112,19 +3134,7 @@ static void\n inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n-  ipa_fn_summary *callee_info = ipa_fn_summaries->get (node);\n-  ipa_fn_summary *caller_info = ipa_fn_summaries->get (node->callers->caller);\n-  HOST_WIDE_INT peak;\n-\n-  callee_info->stack_frame_offset\n-    = caller_info->stack_frame_offset\n-    + caller_info->estimated_self_stack_size;\n-  peak = callee_info->stack_frame_offset\n-    + callee_info->estimated_self_stack_size;\n-\n-  ipa_fn_summary *s = ipa_fn_summaries->get (node->global.inlined_to);\n-  if (s->estimated_stack_size < peak)\n-    s->estimated_stack_size = peak;\n+\n   ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -3284,11 +3294,10 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   class ipa_fn_summary *info = ipa_fn_summaries->get (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n-  vec<int> operand_map = vNULL;\n-  vec<int> offset_map = vNULL;\n+  auto_vec<int, 8> operand_map;\n+  auto_vec<int, 8> offset_map;\n   int i;\n   predicate toplev_predicate;\n-  predicate true_p = true;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \n   if (es->predicate)\n@@ -3375,39 +3384,43 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t\t\t&callee_info->loop_stride,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n-  ipa_call_summary *s = ipa_call_summaries->get (edge);\n-  inline_update_callee_summaries (edge->callee, s->loop_depth);\n+  HOST_WIDE_INT stack_frame_offset = ipa_get_stack_frame_offset (edge->callee);\n+  HOST_WIDE_INT peak = stack_frame_offset + callee_info->estimated_stack_size;\n \n-  /* We do not maintain predicates of inlined edges, free it.  */\n-  edge_set_predicate (edge, &true_p);\n-  /* Similarly remove param summaries.  */\n-  es->param.release ();\n-  operand_map.release ();\n-  offset_map.release ();\n+  if (info->estimated_stack_size < peak)\n+    info->estimated_stack_size = peak;\n+\n+  inline_update_callee_summaries (edge->callee, es->loop_depth);\n+\n+  /* Free summaries that are not maintained for inline clones/edges.  */\n+  ipa_call_summaries->remove (edge);\n+  ipa_fn_summaries->remove (edge->callee);\n }\n \n-/* For performance reasons ipa_merge_fn_summary_after_inlining is not updating overall size\n-   and time.  Recompute it.  */\n+/* For performance reasons ipa_merge_fn_summary_after_inlining is not updating\n+   overall size and time.  Recompute it.  */\n \n void\n ipa_update_overall_fn_summary (struct cgraph_node *node)\n {\n   class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_size_summary *size_info = ipa_size_summaries->get_create (node);\n   size_time_entry *e;\n   int i;\n \n-  info->size = 0;\n+  size_info->size = 0;\n   info->time = 0;\n   for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n     {\n-      info->size += e->size;\n+      size_info->size += e->size;\n       info->time += e->time;\n     }\n-  estimate_calls_size_and_time (node, &info->size, &info->min_size,\n+  estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n \t\t\t\t&info->time, NULL,\n \t\t\t\t~(clause_t) (1 << predicate::false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n-  info->size = (info->size + ipa_fn_summary::size_scale / 2) / ipa_fn_summary::size_scale;\n+  size_info->size = (size_info->size + ipa_fn_summary::size_scale / 2)\n+\t\t    / ipa_fn_summary::size_scale;\n }\n \n \n@@ -3558,6 +3571,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       unsigned int index;\n       struct cgraph_node *node;\n       class ipa_fn_summary *info;\n+      class ipa_size_summary *size_info;\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n@@ -3568,6 +3582,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n       info = node->prevailing_p () ? ipa_fn_summaries->get_create (node) : NULL;\n+      size_info = node->prevailing_p ()\n+\t\t  ? ipa_size_summaries->get_create (node) : NULL;\n \n       int stack_size = streamer_read_uhwi (&ib);\n       int size = streamer_read_uhwi (&ib);\n@@ -3576,8 +3592,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       if (info)\n \t{\n \t  info->estimated_stack_size\n-\t    = info->estimated_self_stack_size = stack_size;\n-\t  info->size = info->self_size = size;\n+\t    = size_info->estimated_self_stack_size = stack_size;\n+\t  size_info->size = size_info->self_size = size;\n \t  info->time = time;\n \t}\n \n@@ -3768,15 +3784,16 @@ ipa_fn_summary_write (void)\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n \t  class ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n+\t  class ipa_size_summary *size_info = ipa_size_summaries->get (cnode);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n \t  size_time_entry *e;\n \t  struct condition *c;\n \n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n-\t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n-\t  streamer_write_hwi (ob, info->self_size);\n+\t  streamer_write_hwi (ob, size_info->estimated_self_stack_size);\n+\t  streamer_write_hwi (ob, size_info->self_size);\n \t  info->time.stream_out (ob);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n@@ -3846,23 +3863,33 @@ ipa_fn_summary_write (void)\n }\n \n \n-/* Release inline summary.  */\n+/* Release function summary.  */\n \n void\n ipa_free_fn_summary (void)\n {\n-  struct cgraph_node *node;\n   if (!ipa_call_summaries)\n     return;\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->alias)\n-      ipa_fn_summaries->remove (node);\n   ipa_fn_summaries->release ();\n   ipa_fn_summaries = NULL;\n   ipa_call_summaries->release ();\n   delete ipa_call_summaries;\n   ipa_call_summaries = NULL;\n   edge_predicate_pool.release ();\n+  /* During IPA this is one of largest datastructures to release.  */\n+  if (flag_wpa)\n+    ggc_trim ();\n+}\n+\n+/* Release function summary.  */\n+\n+void\n+ipa_free_size_summary (void)\n+{\n+  if (!ipa_size_summaries)\n+    return;\n+  ipa_size_summaries->release ();\n+  ipa_size_summaries = NULL;\n }\n \n namespace {\n@@ -3937,10 +3964,12 @@ class pass_ipa_free_fn_summary : public simple_ipa_opt_pass\n       gcc_assert (n == 0);\n       small_p = param;\n     }\n-  virtual bool gate (function *) { return small_p || !flag_wpa; }\n+  virtual bool gate (function *) { return true; }\n   virtual unsigned int execute (function *)\n     {\n       ipa_free_fn_summary ();\n+      if (!flag_wpa)\n+\tipa_free_size_summary ();\n       return 0;\n     }\n "}, {"sha": "f6457303689d7d5330e108a6931fb400513c2703", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -82,31 +82,53 @@ class GTY(()) size_time_entry\n   sreal GTY((skip)) time;\n };\n \n+/* Summary about function and stack frame sizes.  We keep this info \n+   for inline clones and also for WPA streaming. For this reason this is not\n+   part of ipa_fn_summary which exists only for offline functions.  */\n+class ipa_size_summary\n+{\n+public:\n+  /* Estimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_self_stack_size;\n+  /* Size of the function body.  */\n+  int self_size;\n+  /* Estimated size of the function after inlining.  */\n+  int size;\n+\n+  ipa_size_summary ()\n+  : estimated_self_stack_size (0), self_size (0), size (0)\n+  {\n+  }\n+  /* Copy constructor.  */\n+  ipa_size_summary (const ipa_size_summary &s)\n+  : estimated_self_stack_size (0), self_size (s.self_size), size (s.size)\n+  {\n+  }\n+};\n+\n /* Function inlining information.  */\n class GTY(()) ipa_fn_summary\n {\n public:\n   /* Keep all field empty so summary dumping works during its computation.\n      This is useful for debugging.  */\n   ipa_fn_summary ()\n-    : estimated_self_stack_size (0), self_size (0), min_size (0),\n+    : min_size (0),\n       inlinable (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n-      stack_frame_offset (false), time (0), size (0), conds (NULL),\n+      time (0), conds (NULL),\n       size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n       growth (0), scc_no (0)\n   {\n   }\n \n   /* Copy constructor.  */\n   ipa_fn_summary (const ipa_fn_summary &s)\n-    : estimated_self_stack_size (s.estimated_self_stack_size),\n-    self_size (s.self_size), min_size (s.min_size),\n+    : min_size (s.min_size),\n     inlinable (s.inlinable), single_caller (s.single_caller),\n     fp_expressions (s.fp_expressions),\n     estimated_stack_size (s.estimated_stack_size),\n-    stack_frame_offset (s.stack_frame_offset), time (s.time), size (s.size),\n-    conds (s.conds), size_time_table (s.size_time_table),\n+    time (s.time), conds (s.conds), size_time_table (s.size_time_table),\n     loop_iterations (s.loop_iterations), loop_stride (s.loop_stride),\n     growth (s.growth), scc_no (s.scc_no)\n   {}\n@@ -116,10 +138,6 @@ class GTY(()) ipa_fn_summary\n \n   /* Information about the function body itself.  */\n \n-  /* Estimated stack frame consumption by the function.  */\n-  HOST_WIDE_INT estimated_self_stack_size;\n-  /* Size of the function body.  */\n-  int self_size;\n   /* Minimal size increase after inlining.  */\n   int min_size;\n \n@@ -137,11 +155,8 @@ class GTY(()) ipa_fn_summary\n \n   /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_stack_size;\n-  /* Expected offset of the stack frame of function.  */\n-  HOST_WIDE_INT stack_frame_offset;\n-  /* Estimated size of the function after inlining.  */\n+  /* Estimated runtime of function after inlining.  */\n   sreal GTY((skip)) time;\n-  int size;\n \n   /* Conditional size/time information.  The summaries are being\n      merged during inlining.  */\n@@ -201,6 +216,24 @@ class GTY((user)) ipa_fn_summary_t:\n extern GTY(()) fast_function_summary <ipa_fn_summary *, va_gc>\n   *ipa_fn_summaries;\n \n+class ipa_size_summary_t:\n+  public fast_function_summary <ipa_size_summary *, va_gc>\n+{\n+public:\n+  ipa_size_summary_t (symbol_table *symtab):\n+    fast_function_summary <ipa_size_summary *, va_gc> (symtab) {}\n+\n+  static ipa_size_summary_t *create_ggc (symbol_table *symtab)\n+  {\n+    class ipa_size_summary_t *summary = new (ggc_alloc <ipa_size_summary_t> ())\n+      ipa_size_summary_t (symtab);\n+    summary->disable_insertion_hook ();\n+    return summary;\n+  }\n+};\n+extern fast_function_summary <ipa_size_summary *, va_heap>\n+  *ipa_size_summaries;\n+\n /* Information kept about callgraph edges.  */\n class ipa_call_summary\n {\n@@ -256,6 +289,7 @@ void ipa_dump_fn_summaries (FILE *f);\n void ipa_dump_fn_summary (FILE *f, struct cgraph_node *node);\n void ipa_dump_hints (FILE *f, ipa_hints);\n void ipa_free_fn_summary (void);\n+void ipa_free_size_summary (void);\n void inline_analyze_function (struct cgraph_node *node);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<tree>,\n@@ -289,5 +323,6 @@ void estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t  inline_param_summary);\n \n void ipa_fnsummary_c_finalize (void);\n+HOST_WIDE_INT ipa_get_stack_frame_offset (struct cgraph_node *node);\n \n #endif /* GCC_IPA_FNSUMMARY_H */"}, {"sha": "bcfed2b08686537a31820df5a45af1e5e61bbbb1", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -1142,8 +1142,8 @@ sem_function::merge (sem_item *alias_item)\n \t\t\t \"cannot create wrapper of stdarg function.\\n\");\n \t}\n       else if (ipa_fn_summaries\n-\t       && ipa_fn_summaries->get (alias) != NULL\n-\t       && ipa_fn_summaries->get (alias)->self_size <= 2)\n+\t       && ipa_size_summaries->get (alias) != NULL\n+\t       && ipa_size_summaries->get (alias)->self_size <= 2)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf (MSG_MISSED_OPTIMIZATION, \"Wrapper creation is not \""}, {"sha": "8b572a4538633ae1172b908fa9e5049789dc352a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -161,7 +161,8 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache != NULL)\n     {\n-      ipa_fn_summaries->get_create (edge->callee)->min_size = min_size;\n+      ipa_fn_summaries->get (edge->callee->function_symbol ())->min_size\n+\t = min_size;\n       edge_growth_cache_entry *entry\n \t= edge_growth_cache->get_create (edge);\n       entry->time = time;\n@@ -265,7 +266,7 @@ estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n-  ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+  ipa_size_summary *s = ipa_size_summaries->get (node);\n   if (!es->predicate || *es->predicate != false)\n     {\n       int size = s->size + estimate_edge_growth (edge);\n@@ -321,7 +322,7 @@ int\n estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, false, false, 0 };\n-  class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  class ipa_size_summary *info = ipa_size_summaries->get (node);\n \n   node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n \n@@ -396,7 +397,7 @@ growth_likely_positive (struct cgraph_node *node,\n       || node->address_taken)\n     return true;\n \n-  max_callers = ipa_fn_summaries->get (node)->size * 4 / edge_growth + 2;\n+  max_callers = ipa_size_summaries->get (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {"}, {"sha": "14e684e08fd318dffcfaa3ddb9620bd68a4f1fd0", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -200,7 +200,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    {\n \t      gcc_assert (!e->callee->alias);\n \t      if (overall_size)\n-\t\t*overall_size -= ipa_fn_summaries->get (e->callee)->size;\n+\t\t*overall_size -= ipa_size_summaries->get (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -478,7 +478,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n \n-  old_size = ipa_fn_summaries->get (to)->size;\n+  old_size = ipa_size_summaries->get (to)->size;\n   ipa_merge_fn_summary_after_inlining (e);\n   if (e->in_polymorphic_cdtor)\n     mark_all_inlined_calls_cdtor (e->callee);\n@@ -492,8 +492,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n        work for further inlining into this function.  Before inlining\n        the function we inlined to again we expect the caller to update\n        the overall summary.  */\n-    ipa_fn_summaries->get (to)->size += estimated_growth;\n-  new_size = ipa_fn_summaries->get (to)->size;\n+    ipa_size_summaries->get (to)->size += estimated_growth;\n+  new_size = ipa_size_summaries->get (to)->size;\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;"}, {"sha": "a7ef7faa3a07845564b79beac189144cd7acccaf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -150,8 +150,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n-  ipa_fn_summary *info, *what_info;\n-  ipa_fn_summary *outer_info = ipa_fn_summaries->get (to);\n+  ipa_size_summary *outer_info = ipa_size_summaries->get (to);\n \n   /* Look for function e->caller is inlined to.  While doing\n      so work out the largest function body on the way.  As\n@@ -163,28 +162,29 @@ caller_growth_limits (struct cgraph_edge *e)\n      too much in order to prevent compiler from exploding\".  */\n   while (true)\n     {\n-      info = ipa_fn_summaries->get (to);\n-      if (limit < info->self_size)\n-\tlimit = info->self_size;\n-      if (stack_size_limit < info->estimated_self_stack_size)\n-\tstack_size_limit = info->estimated_self_stack_size;\n+      ipa_size_summary *size_info = ipa_size_summaries->get (to);\n+      if (limit < size_info->self_size)\n+\tlimit = size_info->self_size;\n+      if (stack_size_limit < size_info->estimated_self_stack_size)\n+\tstack_size_limit = size_info->estimated_self_stack_size;\n       if (to->global.inlined_to)\n         to = to->callers->caller;\n       else\n \tbreak;\n     }\n \n-  what_info = ipa_fn_summaries->get (what);\n+  ipa_fn_summary *what_info = ipa_fn_summaries->get (what);\n+  ipa_size_summary *what_size_info = ipa_size_summaries->get (what);\n \n-  if (limit < what_info->self_size)\n-    limit = what_info->self_size;\n+  if (limit < what_size_info->self_size)\n+    limit = what_size_info->self_size;\n \n   limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = estimate_size_after_inlining (to, e);\n-  if (newsize >= info->size\n+  if (newsize >= ipa_size_summaries->get (what)->size\n       && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n     {\n@@ -203,7 +203,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   stack_size_limit += ((gcov_type)stack_size_limit\n \t\t       * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100);\n \n-  inlined_stack = (outer_info->stack_frame_offset\n+  inlined_stack = (ipa_get_stack_frame_offset (to)\n \t\t   + outer_info->estimated_self_stack_size\n \t\t   + what_info->estimated_stack_size);\n   /* Check new stack consumption with stack consumption at the place\n@@ -213,7 +213,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \t inline call, we can inline, too.\n \t This bit overoptimistically assume that we are good at stack\n \t packing.  */\n-      && inlined_stack > info->estimated_stack_size\n+      && inlined_stack > ipa_fn_summaries->get (to)->estimated_stack_size\n       && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n     {\n       e->inline_failed = CIF_LARGE_STACK_FRAME_GROWTH_LIMIT;\n@@ -1115,7 +1115,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   gcc_checking_assert ((edge_time * 100\n \t\t\t- callee_info->time * 101).to_int () <= 0\n \t\t\t|| callee->count.ipa ().initialized_p ());\n-  gcc_checking_assert (growth <= callee_info->size);\n+  gcc_checking_assert (growth <= ipa_size_summaries->get (callee)->size);\n \n   if (dump)\n     {\n@@ -1219,7 +1219,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t     and it is not called once.  */\n \t  if (!caller_info->single_caller && overall_growth < caller_growth\n \t      && caller_info->inlinable\n-\t      && caller_info->size\n+\t      && ipa_size_summaries->get (caller)->size\n \t\t < (DECL_DECLARED_INLINE_P (caller->decl)\n \t\t    ? inline_insns_single (caller, false)\n \t\t    : inline_insns_auto (caller, false)))\n@@ -1243,7 +1243,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t    overall_growth += 256 * 256 - 256;\n \t  denominator *= overall_growth;\n         }\n-      denominator *= ipa_fn_summaries->get (caller)->size + growth;\n+      denominator *= ipa_size_summaries->get (caller)->size + growth;\n \n       badness = - numerator / denominator;\n \n@@ -1646,8 +1646,8 @@ recursive_inlining (struct cgraph_edge *edge,\n     dump_printf_loc (MSG_NOTE, edge->call_stmt,\n \t\t     \"\\n   Inlined %i times, \"\n \t\t     \"body grown from size %i to %i, time %f to %f\\n\", n,\n-\t\t     ipa_fn_summaries->get (master_clone)->size,\n-\t\t     ipa_fn_summaries->get (node)->size,\n+\t\t     ipa_size_summaries->get (master_clone)->size,\n+\t\t     ipa_size_summaries->get (node)->size,\n \t\t     ipa_fn_summaries->get (master_clone)->time.to_double (),\n \t\t     ipa_fn_summaries->get (node)->time.to_double ());\n \n@@ -1871,7 +1871,7 @@ inline_small_functions (void)\n \t    /* Do not account external functions, they will be optimized out\n \t       if not inlined.  Also only count the non-cold portion of program.  */\n \t    if (inline_account_function_p (node))\n-\t      initial_size += info->size;\n+\t      initial_size += ipa_size_summaries->get (node)->size;\n \t    info->growth = estimate_growth (node);\n \n \t    int num_calls = 0;\n@@ -1887,7 +1887,8 @@ inline_small_functions (void)\n \t\t     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)\n \t\t  if (opt_for_fn (n2->decl, optimize))\n \t\t    {\n-\t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n+\t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get\n+\t\t\t (n2->global.inlined_to ? n2->global.inlined_to : n2);\n \t\t      if (info2->scc_no)\n \t\t\tbreak;\n \t\t      info2->scc_no = id;\n@@ -2048,7 +2049,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   callee->dump_name (),\n-\t\t   ipa_fn_summaries->get (callee)->size);\n+\t\t   ipa_size_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n@@ -2174,7 +2175,7 @@ inline_small_functions (void)\n \n       if (dump_enabled_p ())\n \t{\n-\t  ipa_fn_summary *s = ipa_fn_summaries->get (edge->caller);\n+\t  ipa_fn_summary *s = ipa_fn_summaries->get (where);\n \n \t  /* dump_printf can't handle %+i.  */\n \t  char buf_net_change[100];\n@@ -2185,7 +2186,9 @@ inline_small_functions (void)\n \t\t\t   \" Inlined %C into %C which now has time %f and \"\n \t\t\t   \"size %i, net change of %s.\\n\",\n \t\t\t   edge->callee, edge->caller,\n-\t\t\t   s->time.to_double (), s->size, buf_net_change);\n+\t\t\t   s->time.to_double (),\n+\t\t\t   ipa_size_summaries->get (edge->caller)->size,\n+\t\t\t   buf_net_change);\n \t}\n       if (min_size > overall_size)\n \t{\n@@ -2322,11 +2325,11 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n \t\t   ultimate->name (),\n-\t\t   ipa_fn_summaries->get (ultimate)->size);\n+\t\t   ipa_size_summaries->get (ultimate)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n \t\t   node->callers->caller->name (),\n-\t\t   ipa_fn_summaries->get (node->callers->caller)->size);\n+\t\t   ipa_size_summaries->get (node->callers->caller)->size);\n \t}\n \n       /* Remember which callers we inlined to, delaying updating the\n@@ -2337,7 +2340,7 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n \t\t caller->name (),\n-\t\t ipa_fn_summaries->get (caller)->size);\n+\t\t ipa_size_summaries->get (caller)->size);\n       if (!(*num_calls)--)\n \t{\n \t  if (dump_file)"}, {"sha": "24a69c18f6e5142b93faaec0630056438612015b", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -641,7 +641,7 @@ class GTY((user)) ipa_edge_args_sum_t : public call_summary <ipa_edge_args *>\n   ipa_edge_args_sum_t (symbol_table *table, bool ggc)\n     : call_summary<ipa_edge_args *> (table, ggc) { }\n \n-  /* Hook that is called by summary when an edge is duplicated.  */\n+  /* Hook that is called by summary when an edge is removed.  */\n   virtual void remove (cgraph_edge *cs, ipa_edge_args *args);\n   /* Hook that is called by summary when an edge is duplicated.  */\n   virtual void duplicate (cgraph_edge *src,"}, {"sha": "5d26f6a19799be3587c9bc8bf504e6623f382edf", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -1,3 +1,8 @@\n+2019-10-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-partition.c (add_symbol_to_partition_1): Update.\n+\t(undo_parittion): Update.\n+\n 2019-10-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-common.c (lto_file_finalize): Add order attribute."}, {"sha": "1492833bc06c4b36f9cd2973096fb1eab65f0924", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -171,7 +171,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     {\n       struct cgraph_edge *e;\n       if (!node->alias && c == SYMBOL_PARTITION)\n-\tpart->insns += ipa_fn_summaries->get (cnode)->size;\n+\tpart->insns += ipa_size_summaries->get (cnode)->size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -291,7 +291,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node))\n           && node->get_partitioning_class () == SYMBOL_PARTITION)\n-\tpartition->insns -= ipa_fn_summaries->get (cnode)->size;\n+\tpartition->insns -= ipa_size_summaries->get (cnode)->size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -528,7 +528,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \telse\n \t  order.safe_push (node);\n \tif (!node->alias)\n-\t  total_size += ipa_fn_summaries->get (node)->size;\n+\t  total_size += ipa_size_summaries->get (node)->size;\n       }\n \n   original_total_size = total_size;"}, {"sha": "9b8c3272977a7e0174b092e4a6d1615af1d44df8", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f658ad3002a0afc8aa86d5646ee704921d969ebe/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=f658ad3002a0afc8aa86d5646ee704921d969ebe", "patch": "@@ -498,9 +498,9 @@ do_whole_program_analysis (void)\n   else\n     gcc_unreachable ();\n \n-  /* Inline summaries are needed for balanced partitioning.  Free them now so\n+  /* Size summaries are needed for balanced partitioning.  Free them now so\n      the memory can be used for streamer caches.  */\n-  ipa_free_fn_summary ();\n+  ipa_free_size_summary ();\n \n   /* AUX pointers are used by partitioning code to bookkeep number of\n      partitions symbol is in.  This is no longer needed.  */"}]}