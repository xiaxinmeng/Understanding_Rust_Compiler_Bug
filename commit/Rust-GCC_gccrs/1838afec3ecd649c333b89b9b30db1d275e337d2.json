{"sha": "1838afec3ecd649c333b89b9b30db1d275e337d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgzOGFmZWMzZWNkNjQ5YzMzM2I4OWI5YjMwZGIxZDI3NWUzMzdkMg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T22:21:36Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T22:21:36Z"}, "message": "trans.h (struct gfc_ss, [...]): Move field gfc_ss::data::info into gfc_ss_info::data and remove empty union...\n\n\t* trans.h (struct gfc_ss, struct gfc_ss_info): Move field\n\tgfc_ss::data::info into gfc_ss_info::data and remove empty union\n\tgfc_ss::data.\n\t* trans-array.c (gfc_free_ss, gfc_trans_create_temp_array,\n\tgfc_trans_constant_array_constructor, gfc_trans_array_constructor,\n\tgfc_set_vector_loop_bounds, gfc_add_loop_ss_code,\n\tgfc_conv_ss_descriptor, gfc_trans_array_bound_check,\n\tgfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n\tadd_array_offset, gfc_trans_preloop_setup,\n\tgfc_trans_scalarized_boundary, gfc_conv_section_startstride,\n\tgfc_conv_ss_startstride, gfc_could_be_alias,\n\tgfc_conv_loop_setup, gfc_conv_expr_descriptor,\n\tgfc_alloc_allocatable_for_assignment, gfc_walk_array_ref):\n\tUpdate reference chains and factor them where possible.\n\t* trans-expr.c (gfc_conv_variable, gfc_conv_subref_array_arg,\n\tgfc_conv_procedure_call, gfc_trans_subarray_assign): Updata reference\n\tchains.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_transfer): Ditto.\n\t* trans-io.c (transfer_array_component): Ditto.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies,\n\tgfc_trans_pointer_assign_need_temp): Ditto.\n\nFrom-SVN: r180873", "tree": {"sha": "c3c34dd5f923feb88d5de358a7ba30eaa8566b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3c34dd5f923feb88d5de358a7ba30eaa8566b5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1838afec3ecd649c333b89b9b30db1d275e337d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1838afec3ecd649c333b89b9b30db1d275e337d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1838afec3ecd649c333b89b9b30db1d275e337d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1838afec3ecd649c333b89b9b30db1d275e337d2/comments", "author": null, "committer": null, "parents": [{"sha": "961e73ace25da06b5909b2b48e64447bea15963d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961e73ace25da06b5909b2b48e64447bea15963d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961e73ace25da06b5909b2b48e64447bea15963d"}], "stats": {"total": 184, "additions": 108, "deletions": 76}, "files": [{"sha": "2767e32c32a455389bac27e08266522a65ad056f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -1,3 +1,27 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans.h (struct gfc_ss, struct gfc_ss_info): Move field\n+\tgfc_ss::data::info into gfc_ss_info::data and remove empty union\n+\tgfc_ss::data.\n+\t* trans-array.c (gfc_free_ss, gfc_trans_create_temp_array,\n+\tgfc_trans_constant_array_constructor, gfc_trans_array_constructor,\n+\tgfc_set_vector_loop_bounds, gfc_add_loop_ss_code,\n+\tgfc_conv_ss_descriptor, gfc_trans_array_bound_check,\n+\tgfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n+\tadd_array_offset, gfc_trans_preloop_setup,\n+\tgfc_trans_scalarized_boundary, gfc_conv_section_startstride,\n+\tgfc_conv_ss_startstride, gfc_could_be_alias,\n+\tgfc_conv_loop_setup, gfc_conv_expr_descriptor,\n+\tgfc_alloc_allocatable_for_assignment, gfc_walk_array_ref):\n+\tUpdate reference chains and factor them where possible.\n+\t* trans-expr.c (gfc_conv_variable, gfc_conv_subref_array_arg,\n+\tgfc_conv_procedure_call, gfc_trans_subarray_assign): Updata reference\n+\tchains.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_transfer): Ditto.\n+\t* trans-io.c (transfer_array_component): Ditto.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies,\n+\tgfc_trans_pointer_assign_need_temp): Ditto.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss, struct gfc_ss_info): Move member struct"}, {"sha": "78e1443fecf7e7cebfb2056f2d82ea4223fef820", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 71, "deletions": 59, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -508,8 +508,8 @@ gfc_free_ss (gfc_ss * ss)\n     case GFC_SS_SECTION:\n       for (n = 0; n < ss->dimen; n++)\n \t{\n-\t  if (ss->data.info.subscript[ss->dim[n]])\n-\t    gfc_free_ss_chain (ss->data.info.subscript[ss->dim[n]]);\n+\t  if (ss_info->data.array.subscript[ss->dim[n]])\n+\t    gfc_free_ss_chain (ss_info->data.array.subscript[ss->dim[n]]);\n \t}\n       break;\n \n@@ -880,7 +880,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n   memset (from, 0, sizeof (from));\n   memset (to, 0, sizeof (to));\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n \n   gcc_assert (ss->dimen > 0);\n   gcc_assert (loop->dimen == ss->dimen);\n@@ -1884,7 +1884,7 @@ trans_constant_array_constructor (gfc_ss * ss, tree type)\n \n   tmp = gfc_build_constant_array_constructor (ss->info->expr, type);\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n \n   info->descriptor = tmp;\n   info->data = gfc_build_addr_expr (NULL_TREE, tmp);\n@@ -2073,7 +2073,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, ss,\n \t\t\t       type, NULL_TREE, dynamic, true, false, where);\n \n-  desc = ss->data.info.descriptor;\n+  desc = ss_info->data.array.descriptor;\n   offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n   TREE_NO_WARNING (offsetvar) = 1;\n@@ -2133,7 +2133,7 @@ set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss * ss)\n   int n;\n   int dim;\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n \n   for (n = 0; n < loop->dimen; n++)\n     {\n@@ -2149,7 +2149,7 @@ set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss * ss)\n \t\t      && info->subscript[dim]->info->type == GFC_SS_VECTOR);\n \n \t  gfc_init_se (&se, NULL);\n-\t  desc = info->subscript[dim]->data.info.descriptor;\n+\t  desc = info->subscript[dim]->info->data.array.descriptor;\n \t  zero = gfc_rank_cst[0];\n \t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type,\n@@ -2172,6 +2172,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n {\n   gfc_se se;\n   gfc_ss_info *ss_info;\n+  gfc_array_info *info;\n   gfc_expr *expr;\n   int n;\n \n@@ -2185,6 +2186,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \n       ss_info = ss->info;\n       expr = ss_info->expr;\n+      info = &ss_info->data.array;\n \n       switch (ss_info->type)\n \t{\n@@ -2227,9 +2229,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_SECTION:\n \t  /* Add the expressions for scalar and vector subscripts.  */\n \t  for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n-\t    if (ss->data.info.subscript[n])\n-\t      gfc_add_loop_ss_code (loop, ss->data.info.subscript[n], true,\n-\t\t\t\t    where);\n+\t    if (info->subscript[n])\n+\t      gfc_add_loop_ss_code (loop, info->subscript[n], true, where);\n \n \t  set_vector_loop_bounds (loop, ss);\n \t  break;\n@@ -2240,7 +2241,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_conv_expr_descriptor (&se, expr, gfc_walk_expr (expr));\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n-\t  ss->data.info.descriptor = se.expr;\n+\t  info->descriptor = se.expr;\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -2295,17 +2296,19 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n {\n   gfc_se se;\n   gfc_ss_info *ss_info;\n+  gfc_array_info *info;\n   tree tmp;\n \n   ss_info = ss->info;\n+  info = &ss_info->data.array;\n \n   /* Get the descriptor for the array to be scalarized.  */\n   gcc_assert (ss_info->expr->expr_type == EXPR_VARIABLE);\n   gfc_init_se (&se, NULL);\n   se.descriptor_only = 1;\n   gfc_conv_expr_lhs (&se, ss_info->expr);\n   gfc_add_block_to_block (block, &se.pre);\n-  ss->data.info.descriptor = se.expr;\n+  info->descriptor = se.expr;\n   ss_info->string_length = se.string_length;\n \n   if (base)\n@@ -2320,15 +2323,15 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n \t    || (TREE_CODE (tmp) == ADDR_EXPR\n \t\t&& DECL_P (TREE_OPERAND (tmp, 0)))))\n \ttmp = gfc_evaluate_now (tmp, block);\n-      ss->data.info.data = tmp;\n+      info->data = tmp;\n \n       tmp = gfc_conv_array_offset (se.expr);\n-      ss->data.info.offset = gfc_evaluate_now (tmp, block);\n+      info->offset = gfc_evaluate_now (tmp, block);\n \n       /* Make absolutely sure that the saved_offset is indeed saved\n \t so that the variable is still accessible after the loops\n \t are translated.  */\n-      ss->data.info.saved_offset = ss->data.info.offset;\n+      info->saved_offset = info->offset;\n     }\n }\n \n@@ -2481,7 +2484,7 @@ trans_array_bound_check (gfc_se * se, gfc_ss *ss, tree index, int n,\n   if (!(gfc_option.rtcheck & GFC_RTCHECK_BOUNDS))\n     return index;\n \n-  descriptor = ss->data.info.descriptor;\n+  descriptor = ss->info->data.array.descriptor;\n \n   index = gfc_evaluate_now (index, &se->pre);\n \n@@ -2555,7 +2558,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n   tree desc;\n   tree data;\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n \n   /* Get the index into the array for this dimension.  */\n   if (ar)\n@@ -2582,7 +2585,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n \t  gcc_assert (info && se->loop);\n \t  gcc_assert (info->subscript[dim]\n \t\t      && info->subscript[dim]->info->type == GFC_SS_VECTOR);\n-\t  desc = info->subscript[dim]->data.info.descriptor;\n+\t  desc = info->subscript[dim]->info->data.array.descriptor;\n \n \t  /* Get a zero-based index into the vector.  */\n \t  index = fold_build2_loc (input_location, MINUS_EXPR,\n@@ -2673,7 +2676,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \n   ss = se->ss;\n   expr = ss->info->expr;\n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n   if (ar)\n     n = se->loop->order[0];\n   else\n@@ -2866,7 +2869,7 @@ add_array_offset (stmtblock_t *pblock, gfc_loopinfo *loop, gfc_ss *ss,\n   gfc_array_info *info;\n   tree stride, index;\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n \n   gfc_init_se (&se, NULL);\n   se.loop = loop;\n@@ -2890,6 +2893,7 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t\t\t stmtblock_t * pblock)\n {\n   tree stride;\n+  gfc_ss_info *ss_info;\n   gfc_array_info *info;\n   gfc_ss_type ss_type;\n   gfc_ss *ss;\n@@ -2900,17 +2904,19 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n      for this dimension.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n+      ss_info = ss->info;\n+\n       if ((ss->useflags & flag) == 0)\n \tcontinue;\n \n-      ss_type = ss->info->type;\n+      ss_type = ss_info->type;\n       if (ss_type != GFC_SS_SECTION\n \t  && ss_type != GFC_SS_FUNCTION\n \t  && ss_type != GFC_SS_CONSTRUCTOR\n \t  && ss_type != GFC_SS_COMPONENT)\n \tcontinue;\n \n-      info = &ss->data.info;\n+      info = &ss_info->data.array;\n \n       gcc_assert (dim < ss->dimen);\n       gcc_assert (ss->dimen == loop->dimen);\n@@ -3175,18 +3181,21 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n       gfc_ss_type ss_type;\n+      gfc_ss_info *ss_info;\n+\n+      ss_info = ss->info;\n \n       if ((ss->useflags & 2) == 0)\n \tcontinue;\n \n-      ss_type = ss->info->type;\n+      ss_type = ss_info->type;\n       if (ss_type != GFC_SS_SECTION\n \t  && ss_type != GFC_SS_FUNCTION\n \t  && ss_type != GFC_SS_CONSTRUCTOR\n \t  && ss_type != GFC_SS_COMPONENT)\n \tcontinue;\n \n-      ss->data.info.offset = ss->data.info.saved_offset;\n+      ss_info->data.array.offset = ss_info->data.array.saved_offset;\n     }\n \n   /* Restart all the inner loops we just finished.  */\n@@ -3253,7 +3262,7 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n \n   gcc_assert (ss->info->type == GFC_SS_SECTION);\n \n-  info = &ss->data.info;\n+  info = &ss->info->data.array;\n   ar = &info->ref->u.ar;\n \n   if (ar->dimen_type[dim] == DIMEN_VECTOR)\n@@ -3352,7 +3361,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n       ss_info = ss->info;\n       expr = ss_info->expr;\n-      info = &ss->data.info;\n+      info = &ss_info->data.array;\n \n       if (expr && expr->shape && !info->shape)\n \tinfo->shape = expr->shape;\n@@ -3388,9 +3397,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    {\n \t      int dim = ss->dim[n];\n \n-\t      ss->data.info.start[dim]  = gfc_index_zero_node;\n-\t      ss->data.info.end[dim]    = gfc_index_zero_node;\n-\t      ss->data.info.stride[dim] = gfc_index_one_node;\n+\t      info->start[dim]  = gfc_index_zero_node;\n+\t      info->end[dim]    = gfc_index_zero_node;\n+\t      info->stride[dim] = gfc_index_one_node;\n \t    }\n \t  break;\n \n@@ -3439,7 +3448,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  gfc_start_block (&inner);\n \n \t  /* TODO: range checking for mapped dimensions.  */\n-\t  info = &ss->data.info;\n+\t  info = &ss_info->data.array;\n \n \t  /* This code only checks ranges.  Elemental and vector\n \t     dimensions are checked later.  */\n@@ -3466,7 +3475,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t       expr_loc, msg);\n \t      free (msg);\n \n-\t      desc = ss->data.info.descriptor;\n+\t      desc = info->descriptor;\n \n \t      /* This is the run-time equivalent of resolve.c's\n \t\t check_dimension().  The logical is more readable there\n@@ -3720,7 +3729,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n   /* For derived types we must check all the component types.  We can ignore\n      array references as these will have the same base type as the previous\n      component ref.  */\n-  for (lref = lexpr->ref; lref != lss->data.info.ref; lref = lref->next)\n+  for (lref = lexpr->ref; lref != lss->info->data.array.ref; lref = lref->next)\n     {\n       if (lref->type != REF_COMPONENT)\n \tcontinue;\n@@ -3740,7 +3749,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n \t    return 1;\n \t}\n \n-      for (rref = rexpr->ref; rref != rss->data.info.ref;\n+      for (rref = rexpr->ref; rref != rss->info->data.array.ref;\n \t   rref = rref->next)\n \t{\n \t  if (rref->type != REF_COMPONENT)\n@@ -3775,7 +3784,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n   lsym_pointer = lsym->attr.pointer;\n   lsym_target = lsym->attr.target;\n \n-  for (rref = rexpr->ref; rref != rss->data.info.ref; rref = rref->next)\n+  for (rref = rexpr->ref; rref != rss->info->data.array.ref; rref = rref->next)\n     {\n       if (rref->type != REF_COMPONENT)\n \tbreak;\n@@ -3946,12 +3955,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t      || ss_type == GFC_SS_REFERENCE)\n \t    continue;\n \n-\t  info = &ss->data.info;\n+\t  info = &ss->info->data.array;\n \t  dim = ss->dim[n];\n \n \t  if (loopspec[n] != NULL)\n \t    {\n-\t      specinfo = &loopspec[n]->data.info;\n+\t      specinfo = &loopspec[n]->info->data.array;\n \t      spec_dim = loopspec[n]->dim[n];\n \t    }\n \t  else\n@@ -4039,7 +4048,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t that's bad news.  */\n       gcc_assert (loopspec[n]);\n \n-      info = &loopspec[n]->data.info;\n+      info = &loopspec[n]->info->data.array;\n       dim = loopspec[n]->dim[n];\n \n       /* Set the extents of this range.  */\n@@ -4133,7 +4142,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t\t\t tmp_ss_info->string_length);\n \n       tmp = tmp_ss_info->data.temp.type;\n-      memset (&loop->temp_ss->data.info, 0, sizeof (gfc_array_info));\n+      memset (&tmp_ss_info->data.array, 0, sizeof (gfc_array_info));\n       tmp_ss_info->type = GFC_SS_SECTION;\n \n       gcc_assert (tmp_ss->dimen != 0);\n@@ -4164,7 +4173,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t  && ss_type != GFC_SS_CONSTRUCTOR)\n \tcontinue;\n \n-      info = &ss->data.info;\n+      info = &ss->info->data.array;\n \n       for (n = 0; n < ss->dimen; n++)\n \t{\n@@ -5805,7 +5814,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       gcc_assert (ss_type == GFC_SS_SECTION);\n       gcc_assert (ss_expr == expr);\n-      info = &ss->data.info;\n+      info = &ss_info->data.array;\n \n       /* Get the descriptor for the array.  */\n       gfc_conv_ss_descriptor (&se->pre, ss, 0);\n@@ -5915,7 +5924,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else\n \t{\n \t  /* Transformational function.  */\n-\t  info = &ss->data.info;\n+\t  info = &ss_info->data.array;\n \t  need_tmp = 0;\n \t}\n       break;\n@@ -5927,7 +5936,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  && gfc_constant_array_constructor_p (expr->value.constructor))\n \t{\n \t  need_tmp = 0;\n-\t  info = &ss->data.info;\n+\t  info = &ss_info->data.array;\n \t}\n       else\n \t{\n@@ -6027,7 +6036,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       /* Finish the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop, &block);\n \n-      desc = loop.temp_ss->data.info.descriptor;\n+      desc = loop.temp_ss->info->data.array.descriptor;\n     }\n   else if (expr->expr_type == EXPR_FUNCTION && !transposed_dims (ss))\n     {\n@@ -7220,6 +7229,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   stmtblock_t fblock;\n   gfc_ss *rss;\n   gfc_ss *lss;\n+  gfc_array_info *linfo;\n   tree realloc_expr;\n   tree alloc_expr;\n   tree size1;\n@@ -7271,6 +7281,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   if (lss == gfc_ss_terminator)\n     return NULL_TREE;\n \n+  linfo = &lss->info->data.array;\n+\n   /* Find an ss for the rhs. For operator expressions, we see the\n      ss's for the operands. Any one of these will do.  */\n   rss = loop->ss;\n@@ -7285,7 +7297,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n   /* Since the lhs is allocatable, this must be a descriptor type.\n      Get the data and array size.  */\n-  desc = lss->data.info.descriptor;\n+  desc = linfo->descriptor;\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));\n   array1 = gfc_conv_descriptor_data_get (desc);\n \n@@ -7355,7 +7367,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n   /* Get the rhs size.  Fix both sizes.  */\n   if (expr2)\n-    desc2 = rss->data.info.descriptor;\n+    desc2 = rss->info->data.array.descriptor;\n   else\n     desc2 = NULL_TREE;\n   size2 = gfc_index_one_node;\n@@ -7445,9 +7457,9 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n      running offset.  Use the saved_offset instead.  */\n   tmp = gfc_conv_descriptor_offset (desc);\n   gfc_add_modify (&fblock, tmp, offset);\n-  if (lss->data.info.saved_offset\n-\t&& TREE_CODE (lss->data.info.saved_offset) == VAR_DECL)\n-      gfc_add_modify (&fblock, lss->data.info.saved_offset, tmp);\n+  if (linfo->saved_offset\n+      && TREE_CODE (linfo->saved_offset) == VAR_DECL)\n+    gfc_add_modify (&fblock, linfo->saved_offset, tmp);\n \n   /* Now set the deltas for the lhs.  */\n   for (n = 0; n < expr1->rank; n++)\n@@ -7457,9 +7469,9 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type, tmp,\n \t\t\t     loop->from[dim]);\n-      if (lss->data.info.delta[dim]\n-\t    && TREE_CODE (lss->data.info.delta[dim]) == VAR_DECL)\n-\tgfc_add_modify (&fblock, lss->data.info.delta[dim], tmp);\n+      if (linfo->delta[dim]\n+\t  && TREE_CODE (linfo->delta[dim]) == VAR_DECL)\n+\tgfc_add_modify (&fblock, linfo->delta[dim], tmp);\n     }\n \n   /* Get the new lhs size in bytes.  */\n@@ -7523,11 +7535,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   gfc_add_expr_to_block (&fblock, tmp);\n \n   /* Make sure that the scalarizer data pointer is updated.  */\n-  if (lss->data.info.data\n-\t&& TREE_CODE (lss->data.info.data) == VAR_DECL)\n+  if (linfo->data\n+      && TREE_CODE (linfo->data) == VAR_DECL)\n     {\n       tmp = gfc_conv_descriptor_data_get (desc);\n-      gfc_add_modify (&fblock, lss->data.info.data, tmp);\n+      gfc_add_modify (&fblock, linfo->data, tmp);\n     }\n \n   /* Add the exit label.  */\n@@ -7717,7 +7729,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \n \tcase AR_FULL:\n \t  newss = gfc_get_array_ss (ss, expr, ar->as->rank, GFC_SS_SECTION);\n-\t  newss->data.info.ref = ref;\n+\t  newss->info->data.array.ref = ref;\n \n \t  /* Make sure array is the same as array(:,:), this way\n \t     we don't need to special case all the time.  */\n@@ -7735,7 +7747,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \n \tcase AR_SECTION:\n \t  newss = gfc_get_array_ss (ss, expr, 0, GFC_SS_SECTION);\n-\t  newss->data.info.ref = ref;\n+\t  newss->info->data.array.ref = ref;\n \n \t  /* We add SS chains for all the subscripts in the section.  */\n \t  for (n = 0; n < ar->dimen; n++)\n@@ -7749,7 +7761,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t\t  gcc_assert (ar->start[n]);\n \t\t  indexss = gfc_get_scalar_ss (gfc_ss_terminator, ar->start[n]);\n \t\t  indexss->loop_chain = gfc_ss_terminator;\n-\t\t  newss->data.info.subscript[n] = indexss;\n+\t\t  newss->info->data.array.subscript[n] = indexss;\n \t\t  break;\n \n \t\tcase DIMEN_RANGE:\n@@ -7765,7 +7777,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t\t  indexss = gfc_get_array_ss (gfc_ss_terminator, ar->start[n],\n \t\t\t\t\t      1, GFC_SS_VECTOR);\n \t\t  indexss->loop_chain = gfc_ss_terminator;\n-\t\t  newss->data.info.subscript[n] = indexss;\n+\t\t  newss->info->data.array.subscript[n] = indexss;\n \t\t  newss->dim[newss->dimen] = n;\n \t\t  newss->dimen++;\n \t\t  break;\n@@ -7778,7 +7790,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t  /* We should have at least one non-elemental dimension,\n \t     unless we are creating a descriptor for a (scalar) coarray.  */\n \t  gcc_assert (newss->dimen > 0\n-\t\t      || newss->data.info.ref->u.ar.as->corank > 0);\n+\t\t      || newss->info->data.array.ref->u.ar.as->corank > 0);\n \t  ss = newss;\n \t  break;\n "}, {"sha": "b175b62c49fa62fa778dfb626a0c081b600f2730", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -633,9 +633,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       gcc_assert (ss_info->expr == expr);\n \n       /* A scalarized term.  We already know the descriptor.  */\n-      se->expr = se->ss->data.info.descriptor;\n+      se->expr = ss_info->data.array.descriptor;\n       se->string_length = ss_info->string_length;\n-      for (ref = se->ss->data.info.ref; ref; ref = ref->next)\n+      for (ref = ss_info->data.array.ref; ref; ref = ref->next)\n \tif (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n \t  break;\n     }\n@@ -2413,7 +2413,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   gfc_conv_loop_setup (&loop, &expr->where);\n \n   /* Pass the temporary descriptor back to the caller.  */\n-  info = &loop.temp_ss->data.info;\n+  info = &loop.temp_ss->info->data.array;\n   parmse->expr = info->descriptor;\n \n   /* Setup the gfc_se structures.  */\n@@ -2492,7 +2492,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n      dimensions, so this is very simple.  The offset is only computed\n      outside the innermost loop, so the overall transfer could be\n      optimized further.  */\n-  info = &rse.ss->data.info;\n+  info = &rse.ss->info->data.array;\n   dimen = rse.ss->dimen;\n \n   tmp_index = gfc_index_zero_node;\n@@ -2910,7 +2910,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      return 0;\n \t    }\n \t}\n-      info = &se->ss->data.info;\n+      info = &se->ss->info->data.array;\n     }\n   else\n     info = NULL;\n@@ -4375,7 +4375,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n   /* Create a SS for the destination.  */\n   lss = gfc_get_array_ss (gfc_ss_terminator, NULL, cm->as->rank,\n \t\t\t  GFC_SS_COMPONENT);\n-  lss_array = &lss->data.info;\n+  lss_array = &lss->info->data.array;\n   lss_array->shape = gfc_get_shape (cm->as->rank);\n   lss_array->descriptor = dest;\n   lss_array->data = gfc_conv_array_data (dest);"}, {"sha": "a3b73832c3562490e06209b0769fdad3a574e73b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -5276,7 +5276,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n   info = NULL;\n   if (se->loop)\n-    info = &se->ss->data.info;\n+    info = &se->ss->info->data.array;\n \n   /* Convert SOURCE.  The output from this stage is:-\n \tsource_bytes = length of the source in bytes"}, {"sha": "12dfcf82333ab69ab3b6ae3cf861aeb8b5bc8b17", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -1949,7 +1949,7 @@ transfer_array_component (tree expr, gfc_component * cm, locus * where)\n \n   ss = gfc_get_array_ss (gfc_ss_terminator, NULL, cm->as->rank,\n \t\t\t GFC_SS_COMPONENT);\n-  ss_array = &ss->data.info;\n+  ss_array = &ss->info->data.array;\n   ss_array->shape = gfc_get_shape (cm->as->rank);\n   ss_array->descriptor = expr;\n   ss_array->data = gfc_conv_array_data (expr);"}, {"sha": "101a6513ed9e6abd2f7830c5b7dc119ab3e22771", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -222,7 +222,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t{\n \t  if (ss->info->expr != e)\n \t    continue;\n-\t  info = &ss->data.info;\n+\t  info = &ss->info->data.array;\n \t  break;\n \t}\n \n@@ -3388,7 +3388,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       gfc_conv_loop_setup (&loop, &expr2->where);\n \n-      info = &rss->data.info;\n+      info = &rss->info->data.array;\n       desc = info->descriptor;\n \n       /* Make a new descriptor.  */"}, {"sha": "e74da4139ad6e988f8f6b417630f277710f201a7", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1838afec3ecd649c333b89b9b30db1d275e337d2/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1838afec3ecd649c333b89b9b30db1d275e337d2", "patch": "@@ -204,6 +204,9 @@ typedef struct gfc_ss_info\n       tree type;\n     }\n     temp;\n+\n+    /* All other types.  */\n+    gfc_array_info array;\n   }\n   data;\n }\n@@ -224,13 +227,6 @@ typedef struct gfc_ss\n {\n   gfc_ss_info *info;\n \n-  union\n-  {\n-    /* All other types.  */\n-    gfc_array_info info;\n-  }\n-  data;\n-\n   int dimen;\n   /* Translation from loop dimensions to actual array dimensions.\n      actual_dim = dim[loop_dim]  */"}]}