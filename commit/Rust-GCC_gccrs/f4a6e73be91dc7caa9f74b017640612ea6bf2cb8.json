{"sha": "f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRhNmU3M2JlOTFkYzdjYWE5Zjc0YjAxNzY0MDYxMmVhNmJmMmNiOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-16T23:17:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-16T23:17:21Z"}, "message": "(print_operand): 'x' and 'y' mode letters only if SUPPORT_SUN_FPA.\n\n(print_operand_address): If (new) ASM_OUTPUT_CASE_FETCH defined, use it to\nemit the address for the insn before a tablejump.\n\nFrom-SVN: r7051", "tree": {"sha": "5e71e4ca3b30592d2fd7410a4a2a14518d91b977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e71e4ca3b30592d2fd7410a4a2a14518d91b977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8/comments", "author": null, "committer": null, "parents": [{"sha": "ba85b2e482c6f63fc49b799701e5a8cc4a93f09f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba85b2e482c6f63fc49b799701e5a8cc4a93f09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba85b2e482c6f63fc49b799701e5a8cc4a93f09f"}], "stats": {"total": 89, "additions": 28, "deletions": 61}, "files": [{"sha": "821ef657ed5022b72bae7d363088afa6eddf330d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 28, "deletions": 61, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "patch": "@@ -1863,6 +1863,7 @@ print_operand (file, op, letter)\n     }\n   else if (GET_CODE (op) == REG)\n     {\n+#ifdef SUPPORT_SUN_FPA\n       if (REGNO (op) < 16\n \t  && (letter == 'y' || letter == 'x')\n \t  && GET_MODE (op) == DFmode)\n@@ -1871,6 +1872,7 @@ print_operand (file, op, letter)\n \t\t   reg_names[REGNO (op)+1]);\n \t}\n       else\n+#endif\n \t{\n \t  fprintf (file, \"%s\", reg_names[REGNO (op)]);\n \t}\n@@ -1938,6 +1940,9 @@ print_operand (file, op, letter)\n    define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n    string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n    macro.  See m68k/sgs.h for an example; for versions without the bug.\n+   Some assemblers refuse all the above solutions.  The workaround is to\n+   emit \"K(pc,d0.l*2)\" with K being a small constant known to give the\n+   right behaviour.\n \n    They also do not like things like \"pea 1.w\", so we simple leave off\n    the .w on small constants. \n@@ -1947,6 +1952,21 @@ print_operand (file, op, letter)\n    offset is output in word mode (eg movel a5@(_foo:w), a0).  When generating\n    -fPIC code the offset is output in long mode (eg movel a5@(_foo:l), a0) */\n \n+#ifndef ASM_OUTPUT_CASE_FETCH\n+#ifdef MOTOROLA\n+#ifdef SGS\n+#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.\", labelno, regname)\n+#else\n+#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n+#endif\n+#else\n+#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:\", labelno, labelno, regname)\n+#endif\n+#endif /* ASM_OUTPUT_CASE_FETCH */\n+\n void\n print_operand_address (file, addr)\n      FILE *file;\n@@ -2083,43 +2103,17 @@ print_operand_address (file, addr)\n \t      }\n \t    if (GET_CODE (ireg) == SIGN_EXTEND)\n \t      {\n-#ifdef MOTOROLA\n-#ifdef SGS\n-\t\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.w\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n-#else\n-\t\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.w\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\tASM_OUTPUT_CASE_FETCH (file,\n \t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n \t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n-#endif\n-#else\n-\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:w\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n-#endif\n+\t\tfprintf (file, \"w\");\n \t      }\n \t    else\n \t      {\n-#ifdef MOTOROLA\n-#ifdef SGS\n-\t\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.l\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (ireg)]);\n-#else\n-\t\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.l\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (ireg)]);\n-#endif\n-#else\n-\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l\",\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\tASM_OUTPUT_CASE_FETCH (file,\n \t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n \t\t\t     reg_names[REGNO (ireg)]);\n-#endif\n+\t\tfprintf (file, \"l\");\n \t      }\n \t    if (scale != 1)\n \t      {\n@@ -2135,24 +2129,10 @@ print_operand_address (file, addr)\n \tif (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF\n \t    && ! (flag_pic && breg == pic_offset_table_rtx))\n \t  {\n-#ifdef MOTOROLA\n-#ifdef SGS\n-\t    asm_fprintf (file, \"%LLD%d(%Rpc,%s.l\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (breg)]);\n-#else\n-\t    asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.l\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (breg)]);\n-#endif\n-#else\n-\t    asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t    ASM_OUTPUT_CASE_FETCH (file,\n \t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n \t\t\t reg_names[REGNO (breg)]);\n-#endif\n-\t    putc (')', file);\n+\t    fprintf (file, \"l)\");\n \t    break;\n \t  }\n \tif (ireg != 0 || breg != 0)\n@@ -2228,23 +2208,10 @@ print_operand_address (file, addr)\n \telse if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n \t\t && ! (flag_pic && reg1 == pic_offset_table_rtx))\t\n \t  {\n-#ifdef MOTOROLA\n-#ifdef SGS\n-\t    asm_fprintf (file, \"%LLD%d(%Rpc,%s.l)\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (reg1)]);\n-#else\n-\t    asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.l)\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t    ASM_OUTPUT_CASE_FETCH (file,\n \t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n \t\t\t reg_names[REGNO (reg1)]);\n-#endif\n-#else\n-\t    asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l)\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (reg1)]);\n-#endif\n+\t    fprintf (file, \"l)\");\n \t    break;\n \t  }\n \t/* FALL-THROUGH (is this really what we want? */"}]}