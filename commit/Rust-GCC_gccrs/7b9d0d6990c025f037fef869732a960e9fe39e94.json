{"sha": "7b9d0d6990c025f037fef869732a960e9fe39e94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5ZDBkNjk5MGMwMjVmMDM3ZmVmODY5NzMyYTk2MGU5ZmUzOWU5NA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-11-15T13:56:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:56:39Z"}, "message": "exp_aggr.adb (Build_Record_Aggr_Code): Do not create master entity for task component, in the case of a limited aggregate.\n\n2005-11-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Cyrille Comar  <comar@adacore.com>\n\n\t* exp_aggr.adb (Build_Record_Aggr_Code): Do not create master entity\n\tfor task component, in the case of a limited aggregate. The enclosed\n\tobject declaration will create it earlier. Otherwise, in the case of a\n\tnested aggregate, the object may appear in the wrong scope.\n\t(Convert_Aggr_In_Object_Decl): Create a transient scope when needed.\n\t(Gen_Assign): If the component being assigned is an array type and the\n\texpression is itself an aggregate, wrap the assignment in a block to\n\tforce finalization actions on the temporary created for each row of the\n\tenclosing object.\n\t(Build_Record_Aggr_Code): Significant rewrite insuring that ctrl\n\tstructures are initialized after all discriminants are set so that\n\tthey can be accessed even when their offset is dynamic.\n\nFrom-SVN: r106969", "tree": {"sha": "5e2497d8d05377d363ee8231c23022eff05ab331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e2497d8d05377d363ee8231c23022eff05ab331"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b9d0d6990c025f037fef869732a960e9fe39e94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9d0d6990c025f037fef869732a960e9fe39e94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b9d0d6990c025f037fef869732a960e9fe39e94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9d0d6990c025f037fef869732a960e9fe39e94/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bde33286bde09e4a8fbb16d876a073207066e31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde33286bde09e4a8fbb16d876a073207066e31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde33286bde09e4a8fbb16d876a073207066e31e"}], "stats": {"total": 566, "additions": 311, "deletions": 255}, "files": [{"sha": "6699b422c24f2bfa4dbedd224983b64adab30ea5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 311, "deletions": 255, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b9d0d6990c025f037fef869732a960e9fe39e94/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b9d0d6990c025f037fef869732a960e9fe39e94/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7b9d0d6990c025f037fef869732a960e9fe39e94", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1045,6 +1045,26 @@ package body Exp_Aggr is\n \n             if Present (Comp_Type) and then Controlled_Type (Comp_Type) then\n                Set_No_Ctrl_Actions (A);\n+\n+               --  If this is an aggregate for an array of arrays, each\n+               --  subaggregate will be expanded as well, and even with\n+               --  No_Ctrl_Actions the assignments of inner components will\n+               --  require attachment in their assignments to temporaries.\n+               --  These temporaries must be finalized for each subaggregate,\n+               --  to prevent multiple attachments of the same temporary\n+               --  location to same finalization chain (and consequently\n+               --  circular lists). To ensure that finalization takes place\n+               --  for each subaggregate we wrap the assignment in a block.\n+\n+               if Is_Array_Type (Comp_Type)\n+                 and then Nkind (Expr) = N_Aggregate\n+               then\n+                  A :=\n+                    Make_Block_Statement (Loc,\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => New_List (A)));\n+               end if;\n             end if;\n \n             Append_To (L, A);\n@@ -1574,7 +1594,6 @@ package body Exp_Aggr is\n    is\n       Loc     : constant Source_Ptr := Sloc (N);\n       L       : constant List_Id    := New_List;\n-      Start_L : constant List_Id    := New_List;\n       N_Typ   : constant Entity_Id  := Etype (N);\n \n       Comp      : Node_Id;\n@@ -1600,6 +1619,7 @@ package body Exp_Aggr is\n \n       Init_Typ : Entity_Id := Empty;\n       Attach   : Node_Id;\n+      Ctrl_Stuff_Done : Boolean := False;\n \n       function Get_Constraint_Association (T : Entity_Id) return Node_Id;\n       --  Returns the first discriminant association in the constraint\n@@ -1627,6 +1647,10 @@ package body Exp_Aggr is\n       --  it to finalization list F. Init_Pr conditions the call to the\n       --  init proc since it may already be done due to ancestor initialization\n \n+      procedure Gen_Ctrl_Actions_For_Aggr;\n+      --  Deal with the various controlled type data structure\n+      --  initializations\n+\n       ---------------------------------\n       -- Ancestor_Discriminant_Value --\n       ---------------------------------\n@@ -1821,6 +1845,7 @@ package body Exp_Aggr is\n       is\n          L   : constant List_Id := New_List;\n          Ref : Node_Id;\n+         RC  : RE_Id;\n \n       begin\n          --  Generate:\n@@ -1854,51 +1879,233 @@ package body Exp_Aggr is\n               and then Present (Etype (Prefix (Expression (Target))))\n               and then Is_Limited_Type (Etype (Prefix (Expression (Target)))))\n          then\n-            if Init_Pr then\n-               Append_List_To (L,\n-                 Build_Initialization_Call (Loc,\n-                   Id_Ref       => Ref,\n-                   Typ          => RTE (RE_Limited_Record_Controller),\n-                   In_Init_Proc => Within_Init_Proc));\n-            end if;\n-\n-            Append_To (L,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To\n-                    (Find_Prim_Op\n-                       (RTE (RE_Limited_Record_Controller), Name_Initialize),\n-                     Loc),\n-                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n-\n+            RC := RE_Limited_Record_Controller;\n          else\n-            if Init_Pr then\n-               Append_List_To (L,\n-                 Build_Initialization_Call (Loc,\n-                   Id_Ref       => Ref,\n-                   Typ          => RTE (RE_Record_Controller),\n-                   In_Init_Proc => Within_Init_Proc));\n-            end if;\n-\n-            Append_To (L,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To\n-                    (Find_Prim_Op\n-                       (RTE (RE_Record_Controller), Name_Initialize),\n-                     Loc),\n-                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+            RC := RE_Record_Controller;\n+         end if;\n \n+         if Init_Pr then\n+            Append_List_To (L,\n+              Build_Initialization_Call (Loc,\n+                Id_Ref       => Ref,\n+                Typ          => RTE (RC),\n+                In_Init_Proc => Within_Init_Proc));\n          end if;\n \n+         Append_To (L,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               New_Reference_To (\n+                 Find_Prim_Op (RTE (RC), Name_Initialize), Loc),\n+             Parameter_Associations =>\n+               New_List (New_Copy_Tree (Ref))));\n+\n          Append_To (L,\n            Make_Attach_Call (\n              Obj_Ref     => New_Copy_Tree (Ref),\n              Flist_Ref   => F,\n              With_Attach => Attach));\n+\n          return L;\n       end Init_Controller;\n \n+      -------------------------------\n+      -- Gen_Ctrl_Actions_For_Aggr --\n+      -------------------------------\n+\n+      procedure Gen_Ctrl_Actions_For_Aggr is\n+      begin\n+         if Present (Obj)\n+          and then Finalize_Storage_Only (Typ)\n+          and then (Is_Library_Level_Entity (Obj)\n+            or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n+                                                              Standard_True)\n+         then\n+            Attach := Make_Integer_Literal (Loc, 0);\n+\n+         elsif Nkind (Parent (N)) = N_Qualified_Expression\n+           and then Nkind (Parent (Parent (N))) = N_Allocator\n+         then\n+            Attach := Make_Integer_Literal (Loc, 2);\n+\n+         else\n+            Attach := Make_Integer_Literal (Loc, 1);\n+         end if;\n+\n+         --  Determine the external finalization list. It is either the\n+         --  finalization list of the outer-scope or the one coming from\n+         --  an outer aggregate.  When the target is not a temporary, the\n+         --  proper scope is the scope of the target rather than the\n+         --  potentially transient current scope.\n+\n+         if Controlled_Type (Typ) then\n+            if Present (Flist) then\n+               External_Final_List := New_Copy_Tree (Flist);\n+\n+            elsif Is_Entity_Name (Target)\n+              and then Present (Scope (Entity (Target)))\n+            then\n+               External_Final_List\n+                 := Find_Final_List (Scope (Entity (Target)));\n+\n+            else\n+               External_Final_List := Find_Final_List (Current_Scope);\n+            end if;\n+\n+         else\n+            External_Final_List := Empty;\n+         end if;\n+\n+         --  Initialize and attach the outer object in the is_controlled case\n+\n+         if Is_Controlled (Typ) then\n+            if Ancestor_Is_Subtype_Mark then\n+               Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n+               Set_Assignment_OK (Ref);\n+               Append_To (L,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To\n+                       (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n+                   Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+            end if;\n+\n+            if not Has_Controlled_Component (Typ) then\n+               Ref := New_Copy_Tree (Target);\n+               Set_Assignment_OK (Ref);\n+               Append_To (L,\n+                 Make_Attach_Call (\n+                   Obj_Ref     => Ref,\n+                   Flist_Ref   => New_Copy_Tree (External_Final_List),\n+                   With_Attach => Attach));\n+            end if;\n+         end if;\n+\n+         --  In the Has_Controlled component case, all the intermediate\n+         --  controllers must be initialized\n+\n+         if Has_Controlled_Component (Typ)\n+           and not Is_Limited_Ancestor_Expansion\n+         then\n+            declare\n+               Inner_Typ : Entity_Id;\n+               Outer_Typ : Entity_Id;\n+               At_Root   : Boolean;\n+\n+            begin\n+\n+               Outer_Typ := Base_Type (Typ);\n+\n+               --  Find outer type with a controller\n+\n+               while Outer_Typ /= Init_Typ\n+                 and then not Has_New_Controlled_Component (Outer_Typ)\n+               loop\n+                  Outer_Typ := Etype (Outer_Typ);\n+               end loop;\n+\n+               --  Attach it to the outer record controller to the\n+               --  external final list\n+\n+               if Outer_Typ = Init_Typ then\n+                  Append_List_To (L,\n+                    Init_Controller (\n+                      Target  => Target,\n+                      Typ     => Outer_Typ,\n+                      F       => External_Final_List,\n+                      Attach  => Attach,\n+                      Init_Pr => False));\n+\n+                  At_Root   := True;\n+                  Inner_Typ := Init_Typ;\n+\n+               else\n+                  Append_List_To (L,\n+                    Init_Controller (\n+                      Target  => Target,\n+                      Typ     => Outer_Typ,\n+                      F       => External_Final_List,\n+                      Attach  => Attach,\n+                      Init_Pr => True));\n+\n+                  Inner_Typ := Etype (Outer_Typ);\n+                  At_Root   :=\n+                    not Is_Tagged_Type (Typ) or else Inner_Typ = Outer_Typ;\n+               end if;\n+\n+               --  The outer object has to be attached as well\n+\n+               if Is_Controlled (Typ) then\n+                  Ref := New_Copy_Tree (Target);\n+                  Set_Assignment_OK (Ref);\n+                  Append_To (L,\n+                    Make_Attach_Call (\n+                      Obj_Ref     => Ref,\n+                      Flist_Ref   => New_Copy_Tree (External_Final_List),\n+                      With_Attach => New_Copy_Tree (Attach)));\n+               end if;\n+\n+               --  Initialize the internal controllers for tagged types with\n+               --  more than one controller.\n+\n+               while not At_Root and then Inner_Typ /= Init_Typ loop\n+                  if Has_New_Controlled_Component (Inner_Typ) then\n+                     F :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix =>\n+                           Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n+                         Selector_Name =>\n+                           Make_Identifier (Loc, Name_uController));\n+                     F :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix => F,\n+                         Selector_Name => Make_Identifier (Loc, Name_F));\n+\n+                     Append_List_To (L,\n+                       Init_Controller (\n+                         Target  => Target,\n+                         Typ     => Inner_Typ,\n+                         F       => F,\n+                         Attach  => Make_Integer_Literal (Loc, 1),\n+                         Init_Pr => True));\n+                     Outer_Typ := Inner_Typ;\n+                  end if;\n+\n+                  --  Stop at the root\n+\n+                  At_Root := Inner_Typ = Etype (Inner_Typ);\n+                  Inner_Typ := Etype (Inner_Typ);\n+               end loop;\n+\n+               --  If not done yet attach the controller of the ancestor part\n+\n+               if Outer_Typ /= Init_Typ\n+                 and then Inner_Typ = Init_Typ\n+                 and then Has_Controlled_Component (Init_Typ)\n+               then\n+                  F :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix => Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Name_uController));\n+                  F :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix => F,\n+                      Selector_Name => Make_Identifier (Loc, Name_F));\n+\n+                  Attach := Make_Integer_Literal (Loc, 1);\n+                  Append_List_To (L,\n+                    Init_Controller (\n+                      Target  => Target,\n+                      Typ     => Init_Typ,\n+                      F       => F,\n+                      Attach  => Attach,\n+                      Init_Pr => Ancestor_Is_Expression));\n+               end if;\n+            end;\n+         end if;\n+      end Gen_Ctrl_Actions_For_Aggr;\n+\n    --  Start of processing for Build_Record_Aggr_Code\n \n    begin\n@@ -1908,6 +2115,7 @@ package body Exp_Aggr is\n       if Nkind (N) = N_Extension_Aggregate then\n          declare\n             A : constant Node_Id := Ancestor_Part (N);\n+            Assign : List_Id;\n \n          begin\n             --  If the ancestor part is a subtype mark \"T\", we generate\n@@ -1975,14 +2183,14 @@ package body Exp_Aggr is\n                if Has_Default_Init_Comps (N)\n                  or else Has_Task (Base_Type (Init_Typ))\n                then\n-                  Append_List_To (Start_L,\n+                  Append_List_To (L,\n                     Build_Initialization_Call (Loc,\n                       Id_Ref       => Ref,\n                       Typ          => Init_Typ,\n                       In_Init_Proc => Within_Init_Proc,\n                       With_Default_Init => True));\n                else\n-                  Append_List_To (Start_L,\n+                  Append_List_To (L,\n                     Build_Initialization_Call (Loc,\n                       Id_Ref       => Ref,\n                       Typ          => Init_Typ,\n@@ -2001,7 +2209,7 @@ package body Exp_Aggr is\n             elsif Is_Limited_Type (Etype (A)) then\n                Ancestor_Is_Expression := True;\n \n-               Append_List_To (Start_L,\n+               Append_List_To (L,\n                   Build_Record_Aggr_Code (\n                     N                             => Expression (A),\n                     Typ                           => Etype (Expression (A)),\n@@ -2017,9 +2225,34 @@ package body Exp_Aggr is\n                Ancestor_Is_Expression := True;\n                Init_Typ := Etype (A);\n \n-               --  Assign the tag before doing the assignment to make sure\n-               --  that the dispatching call in the subsequent deep_adjust\n-               --  works properly (unless Java_VM, where tags are implicit).\n+               --  If the ancestor part is an aggregate, force its full\n+               --  expansion, which was delayed.\n+\n+               if Nkind (A) = N_Qualified_Expression\n+                 and then (Nkind (Expression (A)) = N_Aggregate\n+                             or else\n+                           Nkind (Expression (A)) = N_Extension_Aggregate)\n+               then\n+                  Set_Analyzed (A, False);\n+                  Set_Analyzed (Expression (A), False);\n+               end if;\n+\n+               Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n+               Set_Assignment_OK (Ref);\n+\n+               --  Make the assignment without usual controlled actions since\n+               --  we only want the post adjust but not the pre finalize here\n+               --  Add manual adjust when necessary\n+\n+               Assign := New_List (\n+                 Make_OK_Assignment_Statement (Loc,\n+                   Name       => Ref,\n+                   Expression => A));\n+               Set_No_Ctrl_Actions (First (Assign));\n+\n+               --  Assign the tag now to make sure that the dispatching call in\n+               --  the subsequent deep_adjust works properly (unless Java_VM,\n+               --  where tags are implicit).\n \n                if not Java_VM then\n                   Instr :=\n@@ -2039,30 +2272,23 @@ package body Exp_Aggr is\n                              Loc)));\n \n                   Set_Assignment_OK (Name (Instr));\n-                  Append_To (L, Instr);\n+                  Append_To (Assign, Instr);\n                end if;\n \n-               --  If the ancestor part is an aggregate, force its full\n-               --  expansion, which was delayed.\n+               --  Call Adjust manually\n \n-               if Nkind (A) = N_Qualified_Expression\n-                 and then (Nkind (Expression (A)) = N_Aggregate\n-                             or else\n-                           Nkind (Expression (A)) = N_Extension_Aggregate)\n-               then\n-                  Set_Analyzed (A, False);\n-                  Set_Analyzed (Expression (A), False);\n+               if Controlled_Type (Etype (A)) then\n+                  Append_List_To (Assign,\n+                    Make_Adjust_Call (\n+                      Ref         => New_Copy_Tree (Ref),\n+                      Typ         => Etype (A),\n+                      Flist_Ref   => New_Reference_To (\n+                        RTE (RE_Global_Final_List), Loc),\n+                      With_Attach => Make_Integer_Literal (Loc, 0)));\n                end if;\n \n-               Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n-               Set_Assignment_OK (Ref);\n                Append_To (L,\n-                 Make_Unsuppress_Block (Loc,\n-                   Name_Discriminant_Check,\n-                   New_List (\n-                     Make_OK_Assignment_Statement (Loc,\n-                       Name       => Ref,\n-                       Expression => A))));\n+                 Make_Unsuppress_Block (Loc, Name_Discriminant_Check, Assign));\n \n                if Has_Discriminants (Init_Typ) then\n                   Check_Ancestor_Discriminants (Init_Typ);\n@@ -2160,10 +2386,6 @@ package body Exp_Aggr is\n \n                   if not Inside_Init_Proc and not Inside_Allocator then\n                      Build_Activation_Chain_Entity (N);\n-\n-                     if not Has_Master_Entity (Current_Scope) then\n-                        Build_Master_Entity (Etype (N));\n-                     end if;\n                   end if;\n                end if;\n             end;\n@@ -2180,11 +2402,23 @@ package body Exp_Aggr is\n             goto Next_Comp;\n          end if;\n \n-         --  ???\n+         --  Prepare for component assignment\n \n          if Ekind (Selector) /= E_Discriminant\n            or else Nkind (N) = N_Extension_Aggregate\n          then\n+\n+            --  All the discriminants have now been assigned\n+            --  This is now a good moment to initialize and attach all the\n+            --  controllers. Their position may depend on the discriminants.\n+\n+            if Ekind (Selector) /= E_Discriminant\n+              and then not Ctrl_Stuff_Done\n+            then\n+               Gen_Ctrl_Actions_For_Aggr;\n+               Ctrl_Stuff_Done := True;\n+            end if;\n+\n             Comp_Type := Etype (Selector);\n             Comp_Expr :=\n               Make_Selected_Component (Loc,\n@@ -2222,7 +2456,8 @@ package body Exp_Aggr is\n                Internal_Final_List := Empty;\n             end if;\n \n-            --  ???\n+            --  Now either create the assignment or generate the code for the\n+            --  inner aggregate top-down.\n \n             if Is_Delayed_Aggregate (Expr_Q) then\n                Append_List_To (L,\n@@ -2347,199 +2582,15 @@ package body Exp_Aggr is\n          Append_To (L, Instr);\n       end if;\n \n-      --  Now deal with the various controlled type data structure\n-      --  initializations\n-\n-      if Present (Obj)\n-        and then Finalize_Storage_Only (Typ)\n-        and then\n-          (Is_Library_Level_Entity (Obj)\n-             or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n-                                                              Standard_True)\n-      then\n-         Attach := Make_Integer_Literal (Loc, 0);\n-\n-      elsif Nkind (Parent (N)) = N_Qualified_Expression\n-        and then Nkind (Parent (Parent (N))) = N_Allocator\n-      then\n-         Attach := Make_Integer_Literal (Loc, 2);\n-\n-      else\n-         Attach := Make_Integer_Literal (Loc, 1);\n-      end if;\n-\n-      --  Determine the external finalization list. It is either the\n-      --  finalization list of the outer-scope or the one coming from\n-      --  an outer aggregate.  When the target is not a temporary, the\n-      --  proper scope is the scope of the target rather than the\n-      --  potentially transient current scope.\n-\n-      if Controlled_Type (Typ) then\n-         if Present (Flist) then\n-            External_Final_List := New_Copy_Tree (Flist);\n-\n-         elsif Is_Entity_Name (Target)\n-           and then Present (Scope (Entity (Target)))\n-         then\n-            External_Final_List := Find_Final_List (Scope (Entity (Target)));\n-\n-         else\n-            External_Final_List := Find_Final_List (Current_Scope);\n-         end if;\n-\n-      else\n-         External_Final_List := Empty;\n-      end if;\n-\n-      --  Initialize and attach the outer object in the is_controlled case\n-\n-      if Is_Controlled (Typ) then\n-         if Ancestor_Is_Subtype_Mark then\n-            Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n-            Set_Assignment_OK (Ref);\n-            Append_To (L,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To\n-                    (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n-                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n-         end if;\n+      --  If the controllers have not been initialized yet (by lack of non-\n+      --  discriminant components), let's do it now.\n \n-         if not Has_Controlled_Component (Typ) then\n-            Ref := New_Copy_Tree (Target);\n-            Set_Assignment_OK (Ref);\n-            Append_To (Start_L,\n-              Make_Attach_Call (\n-                Obj_Ref     => Ref,\n-                Flist_Ref   => New_Copy_Tree (External_Final_List),\n-                With_Attach => Attach));\n-         end if;\n+      if not Ctrl_Stuff_Done then\n+         Gen_Ctrl_Actions_For_Aggr;\n+         Ctrl_Stuff_Done := True;\n       end if;\n \n-      --  In the Has_Controlled component case, all the intermediate\n-      --  controllers must be initialized\n-\n-      if Has_Controlled_Component (Typ)\n-        and not Is_Limited_Ancestor_Expansion\n-      then\n-         declare\n-            Inner_Typ : Entity_Id;\n-            Outer_Typ : Entity_Id;\n-            At_Root   : Boolean;\n-\n-         begin\n-\n-            Outer_Typ := Base_Type (Typ);\n-\n-            --  Find outer type with a controller\n-\n-            while Outer_Typ /= Init_Typ\n-              and then not Has_New_Controlled_Component (Outer_Typ)\n-            loop\n-               Outer_Typ := Etype (Outer_Typ);\n-            end loop;\n-\n-            --  Attach it to the outer record controller to the\n-            --  external final list\n-\n-            if Outer_Typ = Init_Typ then\n-               Append_List_To (Start_L,\n-                 Init_Controller (\n-                   Target  => Target,\n-                   Typ     => Outer_Typ,\n-                   F       => External_Final_List,\n-                   Attach  => Attach,\n-                   Init_Pr => Ancestor_Is_Expression));\n-\n-               At_Root   := True;\n-               Inner_Typ := Init_Typ;\n-\n-            else\n-               Append_List_To (Start_L,\n-                 Init_Controller (\n-                   Target  => Target,\n-                   Typ     => Outer_Typ,\n-                   F       => External_Final_List,\n-                   Attach  => Attach,\n-                   Init_Pr => True));\n-\n-               Inner_Typ := Etype (Outer_Typ);\n-               At_Root   :=\n-                 not Is_Tagged_Type (Typ) or else Inner_Typ = Outer_Typ;\n-            end if;\n-\n-            --  The outer object has to be attached as well\n-\n-            if Is_Controlled (Typ) then\n-               Ref := New_Copy_Tree (Target);\n-               Set_Assignment_OK (Ref);\n-               Append_To (Start_L,\n-                  Make_Attach_Call (\n-                    Obj_Ref     => Ref,\n-                    Flist_Ref   => New_Copy_Tree (External_Final_List),\n-                    With_Attach => New_Copy_Tree (Attach)));\n-            end if;\n-\n-            --  Initialize the internal controllers for tagged types with\n-            --  more than one controller.\n-\n-            while not At_Root and then Inner_Typ /= Init_Typ loop\n-               if Has_New_Controlled_Component (Inner_Typ) then\n-                  F :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix => Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n-                      Selector_Name =>\n-                        Make_Identifier (Loc, Name_uController));\n-                  F :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix => F,\n-                      Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-                  Append_List_To (Start_L,\n-                    Init_Controller (\n-                      Target  => Target,\n-                      Typ     => Inner_Typ,\n-                      F       => F,\n-                      Attach  => Make_Integer_Literal (Loc, 1),\n-                      Init_Pr => True));\n-                  Outer_Typ := Inner_Typ;\n-               end if;\n-\n-               --  Stop at the root\n-\n-               At_Root := Inner_Typ = Etype (Inner_Typ);\n-               Inner_Typ := Etype (Inner_Typ);\n-            end loop;\n-\n-            --  If not done yet attach the controller of the ancestor part\n-\n-            if Outer_Typ /= Init_Typ\n-              and then Inner_Typ = Init_Typ\n-              and then Has_Controlled_Component (Init_Typ)\n-            then\n-               F :=\n-                  Make_Selected_Component (Loc,\n-                    Prefix => Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n-                    Selector_Name => Make_Identifier (Loc, Name_uController));\n-               F :=\n-                  Make_Selected_Component (Loc,\n-                    Prefix => F,\n-                    Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-               Attach := Make_Integer_Literal (Loc, 1);\n-               Append_List_To (Start_L,\n-                 Init_Controller (\n-                   Target  => Target,\n-                   Typ     => Init_Typ,\n-                   F       => F,\n-                   Attach  => Attach,\n-                   Init_Pr => Ancestor_Is_Expression));\n-            end if;\n-         end;\n-      end if;\n-\n-      Append_List_To (Start_L, L);\n-      return Start_L;\n+      return L;\n    end Build_Record_Aggr_Code;\n \n    -------------------------------\n@@ -2700,6 +2751,11 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n+      if Requires_Transient_Scope (Typ) then\n+         Establish_Transient_Scope (Aggr, Sec_Stack =>\n+           Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n+      end if;\n+\n       Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ, Obj => Obj));\n       Set_No_Initialization (N);\n       Initialize_Discriminants (N, Typ);"}]}