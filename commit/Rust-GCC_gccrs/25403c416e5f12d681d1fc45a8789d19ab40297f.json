{"sha": "25403c416e5f12d681d1fc45a8789d19ab40297f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU0MDNjNDE2ZTVmMTJkNjgxZDFmYzQ1YTg3ODlkMTlhYjQwMjk3Zg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-06-19T12:52:43Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-06-19T12:52:43Z"}, "message": "Simplify setjmp and non-local goto implementation (PR84521)\n\nThis fixes and simplifies the setjmp and non-local goto implementation.\nCurrently the virtual frame pointer is saved when using __builtin_setjmp or\na non-local goto.  Depending on whether a frame pointer is used, this may\neither save SP or FP with an immediate offset.  However the goto or longjmp\nalways updates the hard frame pointer.\n\nA receiver veneer in the original function then assigns the hard frame pointer\nto the virtual frame pointer, which should, if it works correctly, again assign\nSP or FP.  However the special elimination code in eliminate_regs_in_insn\ndoesn't do this correctly unless the frame pointer is used, and even if it\nworked by writing SP, the frame pointer would still be corrupted.\n\nA much simpler implementation is to always save and restore the hard frame\npointer.  This avoids 2 redundant instructions which add/subtract the virtual\nframe offset.  A large amount of code can be removed as a result, including all\nimplementations of TARGET_BUILTIN_SETJMP_FRAME_VALUE (all of which already use\nthe hard frame pointer).  The expansion of nonlocal_goto on PA can be simplied\nto just restore the hard frame pointer. \n\nThis fixes the most obvious issues, however there are still issues on targets\nwhich define HARD_FRAME_POINTER_IS_FRAME_POINTER (arm, mips).\nEach function could have a different hard frame pointer, so a non-local goto\nmay restore the wrong frame pointer (TARGET_BUILTIN_SETJMP_FRAME_VALUE could\nbe useful for this).\n\nThe i386 TARGET_BUILTIN_SETJMP_FRAME_VALUE was incorrect: if stack_realign_fp\nis true, it would save the hard frame pointer value but restore the virtual\nframe pointer which according to ix86_initial_elimination_offset can have a\nnon-zero offset from the hard frame pointer.\n\nThe ia64 implementation of nonlocal_goto seems incorrect since the helper\nfunction moves the the frame pointer value into the static chain register\n(so this patch does nothing to make it better or worse).\n\nAArch64 + x86-64 bootstrap OK, new test passes on AArch64, x86-64 and Arm.\n\ngcc/\n\tPR middle-end/84521\n\t* builtins.c (expand_builtin_setjmp_setup): Save\n\thard_frame_pointer_rtx.\n\t(expand_builtin_setjmp_receiver): Do not emit sfp = fp move since we\n\trestore fp.\n\t* function.c (expand_function_start): Save hard_frame_pointer_rtx for\n\tnon-local goto.\n\t* lra-eliminations.c (eliminate_regs_in_insn): Remove sfp = fp\n\telimination code.\n\t(remove_reg_equal_offset_note): Remove unused function.\n\t* reload1.c (eliminate_regs_in_insn): Remove sfp = hfp elimination\n\tcode.\n\t* config/arc/arc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n\t(arc_builtin_setjmp_frame_value): Remove function.\n\t* config/avr/avr.c  (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n\t(avr_builtin_setjmp_frame_value): Remove function.\n\t* config/i386/i386.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n\t(ix86_builtin_setjmp_frame_value): Remove function.\n\t* config/pa/pa.md (nonlocal_goto): Remove FP adjustment.\n\t* config/sparc/sparc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n\t(sparc_builtin_setjmp_frame_value): Remove function.\n\t* config/vax/vax.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n\t(vax_builtin_setjmp_frame_value): Remove function.\n\t* config/xtensa/xtensa.c (xtensa_frame_pointer_required): Force frame\n\tpointer\tif has_nonlocal_label.\n\ntestsuite/\n\tPR middle-end/84521\n\t* gcc.c-torture/execute/pr84521.c: New test.\n\nFrom-SVN: r272473", "tree": {"sha": "6474f549d25800480316cfea891569617209bd25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6474f549d25800480316cfea891569617209bd25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25403c416e5f12d681d1fc45a8789d19ab40297f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25403c416e5f12d681d1fc45a8789d19ab40297f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25403c416e5f12d681d1fc45a8789d19ab40297f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25403c416e5f12d681d1fc45a8789d19ab40297f/comments", "author": null, "committer": null, "parents": [{"sha": "2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8"}], "stats": {"total": 382, "additions": 91, "deletions": 291}, "files": [{"sha": "b39712f673878956bace1a5244e09c4e2eaa6d2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -1,3 +1,31 @@\n+2019-06-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR middle-end/84521\n+\t* builtins.c (expand_builtin_setjmp_setup): Save\n+\thard_frame_pointer_rtx.\n+\t(expand_builtin_setjmp_receiver): Do not emit sfp = fp move since we\n+\trestore fp.\n+\t* function.c (expand_function_start): Save hard_frame_pointer_rtx for\n+\tnon-local goto.\n+\t* lra-eliminations.c (eliminate_regs_in_insn): Remove sfp = fp\n+\telimination code.\n+\t(remove_reg_equal_offset_note): Remove unused function.\n+\t* reload1.c (eliminate_regs_in_insn): Remove sfp = hfp elimination\n+\tcode.\n+\t* config/arc/arc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n+\t(arc_builtin_setjmp_frame_value): Remove function.\n+\t* config/avr/avr.c  (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n+\t(avr_builtin_setjmp_frame_value): Remove function.\n+\t* config/i386/i386.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n+\t(ix86_builtin_setjmp_frame_value): Remove function.\n+\t* config/pa/pa.md (nonlocal_goto): Remove FP adjustment.\n+\t* config/sparc/sparc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n+\t(sparc_builtin_setjmp_frame_value): Remove function.\n+\t* config/vax/vax.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Remove.\n+\t(vax_builtin_setjmp_frame_value): Remove function.\n+\t* config/xtensa/xtensa.c (xtensa_frame_pointer_required): Force frame\n+\tpointer\tif has_nonlocal_label.\n+\n 2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* doc/md.texi: Document vec_shl_<mode> pattern."}, {"sha": "4ecfd49d03cb34600e7ac7afb0bf0511ff7ec1fa", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -981,7 +981,7 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n \n   mem = gen_rtx_MEM (Pmode, buf_addr);\n   set_mem_alias_set (mem, setjmp_alias_set);\n-  emit_move_insn (mem, targetm.builtin_setjmp_frame_value ());\n+  emit_move_insn (mem, hard_frame_pointer_rtx);\n \n   mem = gen_rtx_MEM (Pmode, plus_constant (Pmode, buf_addr,\n \t\t\t\t\t   GET_MODE_SIZE (Pmode))),\n@@ -1023,31 +1023,6 @@ expand_builtin_setjmp_receiver (rtx receiver_label)\n   if (chain && REG_P (chain))\n     emit_clobber (chain);\n \n-  /* Now put in the code to restore the frame pointer, and argument\n-     pointer, if needed.  */\n-  if (! targetm.have_nonlocal_goto ())\n-    {\n-      /* First adjust our frame pointer to its actual value.  It was\n-\t previously set to the start of the virtual area corresponding to\n-\t the stacked variables when we branched here and now needs to be\n-\t adjusted to the actual hardware fp value.\n-\n-\t Assignments to virtual registers are converted by\n-\t instantiate_virtual_regs into the corresponding assignment\n-\t to the underlying register (fp in this case) that makes\n-\t the original assignment true.\n-\t So the following insn will actually be decrementing fp by\n-\t TARGET_STARTING_FRAME_OFFSET.  */\n-      emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-      /* Restoring the frame pointer also modifies the hard frame pointer.\n-\t Mark it used (so that the previous assignment remains live once\n-\t the frame pointer is eliminated) and clobbered (to represent the\n-\t implicit update from the assignment).  */\n-      emit_use (hard_frame_pointer_rtx);\n-      emit_clobber (hard_frame_pointer_rtx);\n-    }\n-\n   if (!HARD_FRAME_POINTER_IS_ARG_POINTER && fixed_regs[ARG_POINTER_REGNUM])\n     {\n       /* If the argument pointer can be eliminated in favor of the"}, {"sha": "89f69c79cd98b8ec67ee0be1a78cef4240854dda", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -689,8 +689,6 @@ static rtx arc_legitimize_address_0 (rtx, rtx, machine_mode mode);\n \n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P arc_modes_tieable_p\n-#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n-#define TARGET_BUILTIN_SETJMP_FRAME_VALUE arc_builtin_setjmp_frame_value\n \n /* Try to keep the (mov:DF _, reg) as early as possible so\n    that the d<add/sub/mul>h-lr insns appear together and can\n@@ -10960,28 +10958,6 @@ compact_memory_operand_p (rtx op, machine_mode mode,\n   return false;\n }\n \n-/* Return the frame pointer value to be backed up in the setjmp buffer.  */\n-\n-static rtx\n-arc_builtin_setjmp_frame_value (void)\n-{\n-  /* We always want to preserve whatever value is currently in the frame\n-     pointer register.  For frames that are using the frame pointer the new\n-     value of the frame pointer register will have already been computed\n-     (as part of the prologue).  For frames that are not using the frame\n-     pointer it is important that we backup whatever value is in the frame\n-     pointer register, as earlier (more outer) frames may have placed a\n-     value into the frame pointer register.  It might be tempting to try\n-     and use `frame_pointer_rtx` here, however, this is not what we want.\n-     For frames that are using the frame pointer this will give the\n-     correct value.  However, for frames that are not using the frame\n-     pointer this will still give the value that _would_ have been the\n-     frame pointer value for this frame (if the use of the frame pointer\n-     had not been removed).  We really do want the raw frame pointer\n-     register value.  */\n-  return gen_raw_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n-}\n-\n /* Return nonzero if a jli call should be generated for a call from\n    the current function to DECL.  */\n "}, {"sha": "f3896f79cd16e67503bd831aebfaff2efa6d02a3", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -1302,22 +1302,6 @@ avr_build_builtin_va_list (void)\n }\n \n \n-/* Implement `TARGET_BUILTIN_SETJMP_FRAME_VALUE'.  */\n-/* Actual start of frame is virtual_stack_vars_rtx this is offset from\n-   frame pointer by +TARGET_STARTING_FRAME_OFFSET.\n-   Using saved frame = virtual_stack_vars_rtx - TARGET_STARTING_FRAME_OFFSET\n-   avoids creating add/sub of offset in nonlocal goto and setjmp.  */\n-\n-static rtx\n-avr_builtin_setjmp_frame_value (void)\n-{\n-  rtx xval = gen_reg_rtx (Pmode);\n-  emit_insn (gen_subhi3 (xval, virtual_stack_vars_rtx,\n-                         gen_int_mode (avr_starting_frame_offset (), Pmode)));\n-  return xval;\n-}\n-\n-\n /* Return contents of MEM at frame pointer + stack size + 1 (+2 if 3-byte PC).\n    This is return address of function.  */\n "}, {"sha": "649a7e40af4197666405f76fc252837c53c3320a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -5788,17 +5788,6 @@ ix86_initial_elimination_offset (int from, int to)\n     }\n }\n \n-/* In a dynamically-aligned function, we can't know the offset from\n-   stack pointer to frame pointer, so we must ensure that setjmp\n-   eliminates fp against the hard fp (%ebp) rather than trying to\n-   index from %esp up to the top of the frame across a gap that is\n-   of unknown (at compile-time) size.  */\n-static rtx\n-ix86_builtin_setjmp_frame_value (void)\n-{\n-  return stack_realign_fp ? hard_frame_pointer_rtx : virtual_stack_vars_rtx;\n-}\n-\n /* Emits a warning for unsupported msabi to sysv pro/epilogues.  */\n void warn_once_call_ms2sysv_xlogues (const char *feature)\n {\n@@ -22767,9 +22756,6 @@ ix86_run_selftests (void)\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG ix86_reorg\n \n-#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n-#define TARGET_BUILTIN_SETJMP_FRAME_VALUE ix86_builtin_setjmp_frame_value\n-\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n "}, {"sha": "a568e7968a782142f3d2777aa1169c2bd3b2d112", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -6909,18 +6909,15 @@\n \n   lab = copy_to_reg (lab);\n \n-  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx\n-     is saved instead of the hard_frame_pointer_rtx in the save area.\n-     As a result, an extra instruction is needed to adjust for the offset\n-     of the virtual stack variables and the hard frame pointer.  */\n+  /* Restore the stack and frame pointers.  */\n   fp = copy_to_reg (fp);\n   emit_stack_restore (SAVE_NONLOCAL, stack);\n \n   /* Ensure the frame pointer move is not optimized.  */\n   emit_insn (gen_blockage ());\n   emit_clobber (hard_frame_pointer_rtx);\n   emit_clobber (frame_pointer_rtx);\n-  emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));\n+  emit_move_insn (hard_frame_pointer_rtx, fp);\n \n   emit_use (hard_frame_pointer_rtx);\n   emit_use (stack_pointer_rtx);"}, {"sha": "0227a53861fb4dc820e183db7e7687317d4e711d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -679,7 +679,6 @@ static void sparc_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void sparc_file_end (void);\n static bool sparc_frame_pointer_required (void);\n static bool sparc_can_eliminate (const int, const int);\n-static rtx sparc_builtin_setjmp_frame_value (void);\n static void sparc_conditional_register_usage (void);\n static bool sparc_use_pseudo_pic_reg (void);\n static void sparc_init_pic_reg (void);\n@@ -878,9 +877,6 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED sparc_frame_pointer_required\n \n-#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n-#define TARGET_BUILTIN_SETJMP_FRAME_VALUE sparc_builtin_setjmp_frame_value\n-\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE sparc_can_eliminate\n \n@@ -13003,14 +12999,6 @@ sparc_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n   return to == HARD_FRAME_POINTER_REGNUM || !sparc_frame_pointer_required ();\n }\n \n-/* Return the hard frame pointer directly to bypass the stack bias.  */\n-\n-static rtx\n-sparc_builtin_setjmp_frame_value (void)\n-{\n-  return hard_frame_pointer_rtx;\n-}\n-\n /* If !TARGET_FPU, then make the fp registers and fp cc regs fixed so that\n    they won't be allocated.  */\n "}, {"sha": "9559ffb9bb44185adc9b9a124f8cffdb69ba5959", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -59,7 +59,6 @@ static rtx vax_function_arg (cumulative_args_t, machine_mode,\n static void vax_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n static rtx vax_struct_value_rtx (tree, int);\n-static rtx vax_builtin_setjmp_frame_value (void);\n static void vax_asm_trampoline_template (FILE *);\n static void vax_trampoline_init (rtx, tree, rtx);\n static poly_int64 vax_return_pops_args (tree, tree, poly_int64);\n@@ -99,9 +98,6 @@ static HOST_WIDE_INT vax_starting_frame_offset (void);\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX vax_struct_value_rtx\n \n-#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n-#define TARGET_BUILTIN_SETJMP_FRAME_VALUE vax_builtin_setjmp_frame_value\n-\n #undef TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n \n@@ -1067,12 +1063,6 @@ vax_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (Pmode, VAX_STRUCT_VALUE_REGNUM);\n }\n \n-static rtx\n-vax_builtin_setjmp_frame_value (void)\n-{\n-  return hard_frame_pointer_rtx;\n-}\n-\n /* Worker function for NOTICE_UPDATE_CC.  */\n \n void"}, {"sha": "2b97fa2e270255de0892a1c58ed56e1df2cb467d", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -2739,7 +2739,7 @@ xtensa_frame_pointer_required (void)\n      This seems wrong but maybe it's necessary for other architectures.\n      This function is derived from the i386 code.  */\n \n-  if (cfun->machine->accesses_prev_frame)\n+  if (cfun->machine->accesses_prev_frame || cfun->has_nonlocal_label)\n     return true;\n \n   return false;"}, {"sha": "a9576797701992a3b580cf519dca5fd7567db443", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -5135,7 +5135,7 @@ expand_function_start (tree subr)\n       r_save = expand_expr (t_save, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       gcc_assert (GET_MODE (r_save) == Pmode);\n \n-      emit_move_insn (r_save, targetm.builtin_setjmp_frame_value ());\n+      emit_move_insn (r_save, hard_frame_pointer_rtx);\n       update_nonlocal_goto_save_area ();\n     }\n "}, {"sha": "fa0ebcd8ed9b7bdff460957ecba5b50250c796b8", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -876,32 +876,6 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \n \f\n \n-#ifdef HARD_FRAME_POINTER_REGNUM\n-\n-/* Search INSN's reg notes to see whether the destination is equal to\n-   WHAT + C for some constant C.  Return true if so, storing C in\n-   *OFFSET_OUT and removing the reg note.  */\n-static bool\n-remove_reg_equal_offset_note (rtx_insn *insn, rtx what, poly_int64 *offset_out)\n-{\n-  rtx link, *link_loc;\n-\n-  for (link_loc = &REG_NOTES (insn);\n-       (link = *link_loc) != NULL_RTX;\n-       link_loc = &XEXP (link, 1))\n-    if (REG_NOTE_KIND (link) == REG_EQUAL\n-\t&& GET_CODE (XEXP (link, 0)) == PLUS\n-\t&& XEXP (XEXP (link, 0), 0) == what\n-\t&& poly_int_rtx_p (XEXP (XEXP (link, 0), 1), offset_out))\n-      {\n-\t*link_loc = XEXP (link, 1);\n-\treturn true;\n-      }\n-  return false;\n-}\n-\n-#endif\n-\n /* Scan INSN and eliminate all eliminable hard registers in it.\n \n    If REPLACE_P is true, do the replacement destructively.  Also\n@@ -939,72 +913,6 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n       return;\n     }\n \n-  /* Check for setting an eliminable register.\t*/\n-  if (old_set != 0 && REG_P (SET_DEST (old_set))\n-      && (ep = get_elimination (SET_DEST (old_set))) != NULL)\n-    {\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->from_rtx == SET_DEST (old_set) && ep->can_eliminate)\n-\t  {\n-\t    bool delete_p = replace_p;\n-\t    \n-#ifdef HARD_FRAME_POINTER_REGNUM\n-\t    if (ep->from == FRAME_POINTER_REGNUM\n-\t\t&& ep->to == HARD_FRAME_POINTER_REGNUM)\n-\t      /* If this is setting the frame pointer register to the\n-\t\t hardware frame pointer register and this is an\n-\t\t elimination that will be done (tested above), this\n-\t\t insn is really adjusting the frame pointer downward\n-\t\t to compensate for the adjustment done before a\n-\t\t nonlocal goto.  */\n-\t      {\n-\t\trtx src = SET_SRC (old_set);\n-\t\tpoly_int64 offset = 0;\n-\n-\t\t/* We should never process such insn with non-zero\n-\t\t   UPDATE_SP_OFFSET.  */\n-\t\tlra_assert (known_eq (update_sp_offset, 0));\n-\t\t\n-\t\tif (remove_reg_equal_offset_note (insn, ep->to_rtx, &offset)\n-\t\t    || strip_offset (src, &offset) == ep->to_rtx)\n-\t\t  {\n-\t\t    if (replace_p)\n-\t\t      {\n-\t\t\tSET_DEST (old_set) = ep->to_rtx;\n-\t\t\tlra_update_insn_recog_data (insn);\n-\t\t\treturn;\n-\t\t      }\n-\t\t    offset -= (ep->offset - ep->previous_offset);\n-\t\t    src = plus_constant (Pmode, ep->to_rtx, offset);\n-\t\t    \n-\t\t    /* First see if this insn remains valid when we\n-\t\t       make the change.  If not, keep the INSN_CODE\n-\t\t       the same and let the constraint pass fit it\n-\t\t       up.  */\n-\t\t    validate_change (insn, &SET_SRC (old_set), src, 1);\n-\t\t    validate_change (insn, &SET_DEST (old_set),\n-\t\t\t\t     ep->from_rtx, 1);\n-\t\t    if (! apply_change_group ())\n-\t\t      {\n-\t\t\tSET_SRC (old_set) = src;\n-\t\t\tSET_DEST (old_set) = ep->from_rtx;\n-\t\t      }\n-\t\t    lra_update_insn_recog_data (insn);\n-\t\t    /* Add offset note for future updates.  */\n-\t\t    add_reg_note (insn, REG_EQUAL, copy_rtx (src));\n-\t\t    return;\n-\t\t  }\n-\t      }\n-#endif\n-\t    \n-\t    /* This insn isn't serving a useful purpose.  We delete it\n-\t       when REPLACE is set.  */\n-\t    if (delete_p)\n-\t      lra_delete_dead_insn (insn);\n-\t    return;\n-\t  }\n-    }\n-\n   /* We allow one special case which happens to work on all machines we\n      currently support: a single set with the source or a REG_EQUAL\n      note being a PLUS of an eliminable register and a constant.  */"}, {"sha": "3ad6f1d9c1f7a72c4c39ddbaa3e3caf3e903557e", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -3234,96 +3234,6 @@ eliminate_regs_in_insn (rtx_insn *insn, int replace)\n       return 0;\n     }\n \n-  if (old_set != 0 && REG_P (SET_DEST (old_set))\n-      && REGNO (SET_DEST (old_set)) < FIRST_PSEUDO_REGISTER)\n-    {\n-      /* Check for setting an eliminable register.  */\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->from_rtx == SET_DEST (old_set) && ep->can_eliminate)\n-\t  {\n-\t    /* If this is setting the frame pointer register to the\n-\t       hardware frame pointer register and this is an elimination\n-\t       that will be done (tested above), this insn is really\n-\t       adjusting the frame pointer downward to compensate for\n-\t       the adjustment done before a nonlocal goto.  */\n-\t    if (!HARD_FRAME_POINTER_IS_FRAME_POINTER\n-\t\t&& ep->from == FRAME_POINTER_REGNUM\n-\t\t&& ep->to == HARD_FRAME_POINTER_REGNUM)\n-\t      {\n-\t\trtx base = SET_SRC (old_set);\n-\t\trtx_insn *base_insn = insn;\n-\t\tHOST_WIDE_INT offset = 0;\n-\n-\t\twhile (base != ep->to_rtx)\n-\t\t  {\n-\t\t    rtx_insn *prev_insn;\n-\t\t    rtx prev_set;\n-\n-\t\t    if (GET_CODE (base) == PLUS\n-\t\t        && CONST_INT_P (XEXP (base, 1)))\n-\t\t      {\n-\t\t        offset += INTVAL (XEXP (base, 1));\n-\t\t        base = XEXP (base, 0);\n-\t\t      }\n-\t\t    else if ((prev_insn = prev_nonnote_insn (base_insn)) != 0\n-\t\t\t     && (prev_set = single_set (prev_insn)) != 0\n-\t\t\t     && rtx_equal_p (SET_DEST (prev_set), base))\n-\t\t      {\n-\t\t        base = SET_SRC (prev_set);\n-\t\t        base_insn = prev_insn;\n-\t\t      }\n-\t\t    else\n-\t\t      break;\n-\t\t  }\n-\n-\t\tif (base == ep->to_rtx)\n-\t\t  {\n-\t\t    rtx src = plus_constant (Pmode, ep->to_rtx,\n-\t\t\t\t\t     offset - ep->offset);\n-\n-\t\t    new_body = old_body;\n-\t\t    if (! replace)\n-\t\t      {\n-\t\t\tnew_body = copy_insn (old_body);\n-\t\t\tif (REG_NOTES (insn))\n-\t\t\t  REG_NOTES (insn) = copy_insn_1 (REG_NOTES (insn));\n-\t\t      }\n-\t\t    PATTERN (insn) = new_body;\n-\t\t    old_set = single_set (insn);\n-\n-\t\t    /* First see if this insn remains valid when we\n-\t\t       make the change.  If not, keep the INSN_CODE\n-\t\t       the same and let reload fit it up.  */\n-\t\t    validate_change (insn, &SET_SRC (old_set), src, 1);\n-\t\t    validate_change (insn, &SET_DEST (old_set),\n-\t\t\t\t     ep->to_rtx, 1);\n-\t\t    if (! apply_change_group ())\n-\t\t      {\n-\t\t\tSET_SRC (old_set) = src;\n-\t\t\tSET_DEST (old_set) = ep->to_rtx;\n-\t\t      }\n-\n-\t\t    val = 1;\n-\t\t    goto done;\n-\t\t  }\n-\t      }\n-\n-\t    /* In this case this insn isn't serving a useful purpose.  We\n-\t       will delete it in reload_as_needed once we know that this\n-\t       elimination is, in fact, being done.\n-\n-\t       If REPLACE isn't set, we can't delete this insn, but needn't\n-\t       process it since it won't be used unless something changes.  */\n-\t    if (replace)\n-\t      {\n-\t\tdelete_dead_insn (insn);\n-\t\treturn 1;\n-\t      }\n-\t    val = 1;\n-\t    goto done;\n-\t  }\n-    }\n-\n   /* We allow one special case which happens to work on all machines we\n      currently support: a single set with the source or a REG_EQUAL\n      note being a PLUS of an eliminable register and a constant.  */"}, {"sha": "4247335a6b102a81a12f33114aeec24d83fbead1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -1,3 +1,8 @@\n+2019-06-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR middle-end/84521\n+\t* gcc.c-torture/execute/pr84521.c: New test.\n+\n 2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vect/vect-simd-8.c: If main is defined, don't include"}, {"sha": "08d1a9e73af0b7b5769602afd1b671735f50df55", "filename": "gcc/testsuite/gcc.c-torture/execute/pr84521.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84521.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25403c416e5f12d681d1fc45a8789d19ab40297f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84521.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84521.c?ref=25403c416e5f12d681d1fc45a8789d19ab40297f", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target indirect_jumps } */\n+/* { dg-additional-options \"-fomit-frame-pointer -fno-inline\" }  */\n+\n+extern void abort (void);\n+\n+void\n+broken_longjmp (void *p)\n+{\n+  __builtin_longjmp (p, 1);\n+}\n+\n+volatile int x = 256;\n+void *volatile p = (void*)&x;\n+void *volatile p1;\n+\n+void\n+test (void)\n+{\n+  void *buf[5];\n+  void *volatile q = p;\n+\n+  if (!__builtin_setjmp (buf))\n+    broken_longjmp (buf);\n+\n+  /* Fails if stack pointer corrupted.  */\n+  if (p != q)\n+    abort ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  void *volatile q = p;\n+  p1 = __builtin_alloca (x);\n+  test ();\n+\n+  /* Fails if frame pointer corrupted.  */\n+  if (p != q)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  void *volatile q = p;\n+  test ();\n+  test2 ();\n+  /* Fails if stack pointer corrupted.  */\n+  if (p != q)\n+    abort ();\n+\n+  return 0;\n+}"}]}