{"sha": "1707bafaa50737e92d6d374b69a4de4d02ab4476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwN2JhZmFhNTA3MzdlOTJkNmQzNzRiNjlhNGRlNGQwMmFiNDQ3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-03-23T09:33:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-03-23T09:33:30Z"}, "message": "gcse.c (can_assign_to_reg_p): New function, split out from...\n\n\t* gcse.c (can_assign_to_reg_p): New function, split out from...\n\t(want_to_gcse_p): ...here.\n\t(compute_ld_motion_mems): Use can_assign_to_reg_p to validate\n\tthe rhs of a store.\n\nFrom-SVN: r79856", "tree": {"sha": "fb7805eaa3dd4f5f9578071423db5c11ddeef1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7805eaa3dd4f5f9578071423db5c11ddeef1e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1707bafaa50737e92d6d374b69a4de4d02ab4476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1707bafaa50737e92d6d374b69a4de4d02ab4476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1707bafaa50737e92d6d374b69a4de4d02ab4476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1707bafaa50737e92d6d374b69a4de4d02ab4476/comments", "author": null, "committer": null, "parents": [{"sha": "63185fabbac3d69f62a463c5d1dc18c9a92c9cac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63185fabbac3d69f62a463c5d1dc18c9a92c9cac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63185fabbac3d69f62a463c5d1dc18c9a92c9cac"}], "stats": {"total": 29, "additions": 23, "deletions": 6}, "files": [{"sha": "d0c063c8e2205139b525230b566a88b9830262bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1707bafaa50737e92d6d374b69a4de4d02ab4476/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1707bafaa50737e92d6d374b69a4de4d02ab4476/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1707bafaa50737e92d6d374b69a4de4d02ab4476", "patch": "@@ -1,3 +1,10 @@\n+2004-03-23  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcse.c (can_assign_to_reg_p): New function, split out from...\n+\t(want_to_gcse_p): ...here.\n+\t(compute_ld_motion_mems): Use can_assign_to_reg_p to validate\n+\tthe rhs of a store.\n+\n 2004-03-22  Diego Novillo  <dnovillo@redhat.com>\n \n \t* c-typeck.c (same_translation_unit_p): Fix pasto."}, {"sha": "88f94f6802e1620438716863c059d7a3ac4eb2fa", "filename": "gcc/gcse.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1707bafaa50737e92d6d374b69a4de4d02ab4476/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1707bafaa50737e92d6d374b69a4de4d02ab4476/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1707bafaa50737e92d6d374b69a4de4d02ab4476", "patch": "@@ -568,6 +568,7 @@ static void hash_scan_set (rtx, rtx, struct hash_table *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n static void hash_scan_call (rtx, rtx, struct hash_table *);\n static int want_to_gcse_p (rtx);\n+static bool can_assign_to_reg_p (rtx);\n static bool gcse_constant_p (rtx);\n static int oprs_unchanged_p (rtx, rtx, int);\n static int oprs_anticipatable_p (rtx, rtx);\n@@ -1269,13 +1270,9 @@ static basic_block current_bb;\n /* See whether X, the source of a set, is something we want to consider for\n    GCSE.  */\n \n-static GTY(()) rtx test_insn;\n static int\n want_to_gcse_p (rtx x)\n {\n-  int num_clobbers = 0;\n-  int icode;\n-\n   switch (GET_CODE (x))\n     {\n     case REG:\n@@ -1288,8 +1285,21 @@ want_to_gcse_p (rtx x)\n       return 0;\n \n     default:\n-      break;\n+      return can_assign_to_reg_p (x);\n     }\n+}\n+\n+/* Used internally by can_assign_to_reg_p.  */\n+\n+static GTY(()) rtx test_insn;\n+\n+/* Return true if we can assign X to a pseudo register.  */\n+\n+static bool\n+can_assign_to_reg_p (rtx x)\n+{\n+  int num_clobbers = 0;\n+  int icode;\n \n   /* If this is a valid operand, we are OK.  If it's VOIDmode, we aren't.  */\n   if (general_operand (x, GET_MODE (x)))\n@@ -6838,7 +6848,7 @@ compute_ld_motion_mems (void)\n \t\t\t  && GET_CODE (src) != ASM_OPERANDS\n \t\t\t  /* Check for REG manually since want_to_gcse_p\n \t\t\t     returns 0 for all REGs.  */\n-\t\t\t  && (REG_P (src) || want_to_gcse_p (src)))\n+\t\t\t  && can_assign_to_reg_p (src))\n \t\t\tptr->stores = alloc_INSN_LIST (insn, ptr->stores);\n \t\t      else\n \t\t\tptr->invalid = 1;"}]}