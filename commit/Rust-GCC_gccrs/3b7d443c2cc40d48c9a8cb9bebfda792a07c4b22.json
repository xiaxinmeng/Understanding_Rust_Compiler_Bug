{"sha": "3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I3ZDQ0M2MyY2M0MGQ0OGM5YThjYjliZWJmZGE3OTJhMDdjNGIyMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-13T06:37:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-13T06:37:29Z"}, "message": "h8300.md: Add more comments about things which seem wrong...\n\n        * h8300.md: Add more comments about things which seem\n        wrong, stupid, or just don't make any sense yet.\n\n        * h8300.c (adds_subs_operand): New function.\n        (output_adds_subs): New function.\n        * h8300.md (addhi3): Turn into a define_expand.\n        (addhi3 using adds_subs): New pattern.\n        (H8300 addhi): Derived from old addhi pattern.  Simplified.\n        (H8300H addhi): Likewise.\n        (addsi using adds_subs): New pattern.  Only used on H8300H.\n        (addsi_h8300): Allow \"a\" registers as destination.\n        (addsi_h8300h):  Simplify.  Allow \"a\" registers as destination.\n\n        * h8300.md (bcs): New attribute type.\n        (default_length): Compute correct length for bcs insns.\n        (bcs_qiqi, bcs_hihi, bs_hiqi): Use new type and update\n        to account for correct length computation.\n\n        * h8300.md (movhi_internal): Demand at least one operand to\n        be a register.\n        (movsi_h8300): Optimize loading certain constants.\n        (movsi_h8300h): Likewise.\n\n        * h8300.h (NO_FUNCTION_CSE): Comment out.\n        (FUNCTION_ARG_REGNO_P): Properly define for TARGET_QUICKCALL.\n        (RETURN_IN_MEMORY): Don't return small structs in regs.\n\nFrom-SVN: r11751", "tree": {"sha": "5b90be234951b6d64f687c60bed87b17b1000245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b90be234951b6d64f687c60bed87b17b1000245"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/comments", "author": null, "committer": null, "parents": [{"sha": "2ca96cdfebda96a7a10b7df909251a75b7552b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca96cdfebda96a7a10b7df909251a75b7552b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca96cdfebda96a7a10b7df909251a75b7552b7e"}], "stats": {"total": 305, "additions": 252, "deletions": 53}, "files": [{"sha": "af452f95eff2e47310f7ca1841e48c6dcc5af108", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "patch": "@@ -431,6 +431,89 @@ call_insn_operand (op, mode)\n   return 0;\n }\n \n+int\n+adds_subs_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (INTVAL (op) <= 4 && INTVAL (op) >= 0)\n+\treturn 1;\n+      if (INTVAL (op) >= -4 && INTVAL (op) <= 0)\n+\treturn 1;\n+      if (TARGET_H8300H\n+\t  && INTVAL (op) != 7\n+\t  && (INTVAL (op) <= 8 || INTVAL (op) >= 0))\n+\treturn 1;\n+      if (TARGET_H8300H\n+\t  && INTVAL (op) != -7\n+\t  && (INTVAL (op) >= -8 || INTVAL (op) <= 0))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+char *\n+output_adds_subs (operands)\n+     rtx *operands;\n+{\n+  int val = INTVAL (operands[2]);\n+\n+  /* First get the value into the range -4..4 inclusive.\n+\n+     The only way it can be out of this range is when TARGET_H8300H\n+     is true, thus it is safe to use adds #4 and subs #4.  */\n+  if (val > 4)\n+    {\n+      output_asm_insn (\"adds #4,%A0\", operands);\n+      val -= 4;\n+    }\n+\n+  if (val < -4)\n+    {\n+      output_asm_insn (\"subs #4,%A0\", operands);\n+      val += 4;\n+    }\n+\n+  /* Handle case were val == 4 or val == -4 and we're compiling\n+     for TARGET_H8300H.  */\n+  if (TARGET_H8300H && val == 4)\n+    return \"adds #4,%A0\";\n+\n+  if (TARGET_H8300H && val == -4)\n+    return \"subs #4,%A0\";\n+\n+  if (val > 2)\n+    {\n+      output_asm_insn (\"adds #2,%A0\", operands);\n+      val -= 2;\n+    }\n+\n+  if (val < -2)\n+    {\n+      output_asm_insn (\"subs #2,%A0\", operands);\n+      val += 2;\n+    }\n+\n+  /* val should be one or two now.  */\n+  if (val == 2)\n+    return \"adds #2,%A0\";\n+\n+  if (val == -2)\n+    return \"subs #2,%A0\";\n+\n+  /* val should be one now.  */\n+  if (val == 1)\n+    return \"adds #1,%A0\";\n+\n+  if (val == -1)\n+    return \"subs #1,%A0\";\n+\n+  /* In theory, this can't happen.  */\n+  abort ();\n+}\n+\n /* Return true if OP is a valid call operand, and OP represents\n    an operand for a small call (4 bytes instead of 6 bytes).  */\n "}, {"sha": "40768c45296c3fcb822d33f6d18d9b7aa7422a03", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "patch": "@@ -126,7 +126,7 @@ do {\t\t\t\t\\\n    shouldn't be put through pseudo regs where they can be cse'd.\n    Desirable on machines where ordinary constants are expensive\n    but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n+/* #define NO_FUNCTION_CSE */\n \f\n /* Target machine storage layout */\n \n@@ -541,18 +541,17 @@ enum reg_class {\n \n /* 1 if N is a possible register number for function argument passing.\n    On the H8, no registers are used in this way.  */\n-/* ??? What about TARGET_QUICKCALL? */\n \n-#define FUNCTION_ARG_REGNO_P(N) 0\n+#define FUNCTION_ARG_REGNO_P(N) (TARGET_QUICKCALL ? N < 3 : 0)\n \n /* Register in which address to store a structure value\n    is passed to a function.  */\n \n #define STRUCT_VALUE 0\n \n /* Return true if X should be returned in memory.  */\n-/* ??? This will return small structs in regs.  */\n-#define RETURN_IN_MEMORY(X) (GET_MODE_SIZE (TYPE_MODE (X)) > 4)\n+#define RETURN_IN_MEMORY(X) \\\n+  (TYPE_MODE (X) == BLKmode || GET_MODE_SIZE (TYPE_MODE (X)) > 4)\n \n /* When defined, the compiler allows registers explicitly used in the\n    rtl to be used as spill registers but prevents the compiler from\n@@ -1342,3 +1341,4 @@ do { char dstr[30];\t\t\t\t\t\\\n /* Declarations for functions used in insn-output.c.  */\n char *emit_a_shift ();\n int h8300_funcvec_function_p ();\n+char *output_adds_subs();"}, {"sha": "833264cea70c9db40e0bcf2ce9954f96b0765af1", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 164, "deletions": 48, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=3b7d443c2cc40d48c9a8cb9bebfda792a07c4b22", "patch": "@@ -31,6 +31,10 @@\n \n ;; ??? If we can remove the operand type on all the insns, do it.\n ;; ??? Otherwise, try to have the operand type on all the insns.\n+;; ??? Many patterns have overly conservative lengths.  In particular:\n+;;\n+;;\t* movXX insns using register indirect addressing.\n+;; \t* insns referencing the 8-bit area with an 8-bit address.\n \n ;; Some move patterns have conditions which check that one operand\n ;; is a register.  Shouldn't all of them have such a condition?\n@@ -42,7 +46,7 @@\n ;; can be found using bit-set insns dec, etc\n \n \n-(define_attr \"type\" \"branch,return,call,arith,move,float,multi\"\n+(define_attr \"type\" \"branch,bcs,return,call,arith,move,float,multi\"\n   (const_string \"arith\"))\n \n ;; The size of instructions in bytes.\n@@ -61,6 +65,28 @@\n \t\t\t\t\t\t   (const_int 32000))))\n \t\t\t\t     (const_int 4)\n \t\t\t\t     (const_int 6)))\n+         (eq_attr \"type\" \"bcs\")\n+\t (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int -120))\n+\t\t\t    (le (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int 120)))\n+\t\t       (if_then_else\n+\t\t\t (match_operand 2 \"register_operand\" \"\")\n+\t\t\t (const_int 4)\n+\t\t\t (const_int 6))\n+\t\t       (if_then_else (and (eq_attr \"cpu\" \"h8300h\")\n+\t\t\t\t\t  (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t\t   (const_int -32000))\n+\t\t\t\t\t       (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t\t   (const_int 32000))))\n+\t\t\t\t     (if_then_else\n+\t\t\t\t       (match_operand 2 \"register_operand\" \"\")\n+\t\t\t\t       (const_int 6)\n+\t\t\t\t       (const_int 8))\n+\t\t\t\t     (if_then_else\n+\t\t\t\t       (match_operand 2 \"register_operand\" \"\")\n+\t\t\t\t       (const_int 8)\n+\t\t\t\t       (const_int 10))))\n \t (eq_attr \"type\" \"move\")\t(const_int 4)\n \t (eq_attr \"type\" \"return\")\t(const_int 2)\n \t (eq_attr \"type\" \"float\")\t(const_int 12)\n@@ -150,6 +176,8 @@\n    \n ;; movhi\n \n+;; ??? We use push.l on the h8300h to push a 16bit value?!?  We have\n+;; 16bit push insns!\n (define_insn \"movhi_push\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n \t(match_operand:HI 1 \"register_operand\" \"ra\"))]\n@@ -168,7 +196,8 @@\n (define_insn \"movhi_internal\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"=ra,ra,<,ra,o\")\n \t(match_operand:HI 1 \"general_operand_src\" \"I,ra>,ra,ion,ra\"))]\n-  \"\"\n+  \"register_operand (operands[0],HImode)\n+   || register_operand (operands[1], HImode)\"\n   \"@\n    sub.w\t%T0,%T0\n    mov.w\t%T1,%T0\n@@ -299,11 +328,19 @@\n \t}\n       else \n \t{\n-\t  return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t  /* See if either half is zero.  If so, use sub.w to clear\n+\t     that half.  */\n+\tif (GET_CODE (operands[1]) == CONST_INT)\n+\t  {\n+\t    if ((INTVAL (operands[1]) & 0xffff) == 0)\n+\t      return \\\"mov.w\t%e1,%e0\\;sub.w\t%f0,%f0\\\";\n+\t    if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)\n+\t      return \\\"sub.w\t%e0,%e0\\;mov.w\t%f1,%f0\\\";\n+\t  }\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n \t}\n-    \n     case 3:\n-      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n     case 4:\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n     case 5:\n@@ -380,13 +417,38 @@\n   \"TARGET_H8300H\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n-  \"@\n-   sub.l\t%S0,%S0\n-   mov.l\t%S1,%S0\n-   mov.l\t%S1,%S0\n-   mov.l\t%S1,%S0\n-   mov.l\t%S1,%S0\n-   mov.l\t%S1,%S0\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"sub.l\t%S0,%S0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int val = INTVAL (operands[1]);\n+\n+      /* Look for constants which can be made by adding an 8-bit\n+\t number to zero in one of the two low bytes.  */\n+      if (val == (val & 0xff))\n+\t{\n+\t  operands[1] = GEN_INT ((char)val & 0xff);\n+\t  return \\\"sub.l %S0,%S0\\;add.b %1,%w0\\\";\n+\t}\n+     \n+      if (val == (val & 0xff00))\n+\t{\n+\t  operands[1] = GEN_INT ((char)(val >> 8) & 0xff);\n+\t  return \\\"sub.l %S0,%S0\\;add.b %1,%x0\\\";\n+\t}\n+\n+      /* Now look for small negative numbers.  We can subtract them\n+\t from zero to get the desired constant.  */\n+      if (val == -4 || val == -2 || val == -1)\n+\t{\n+\t  operands[1] = GEN_INT (-INTVAL (operands[1]));\n+\t  return \\\"sub.l %S0,%S0\\;subs %1,%S0\\\";\n+\t}\n+    }\n+   return \\\"mov.l\t%S1,%S0\\\";\n+}\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"2,2,10,10,4,4\")\n    (set_attr \"cc\" \"set_zn_c0,set,set,set,set,set\")])\n@@ -514,23 +576,49 @@\n \n ;; h8300h: adds operates on the 32bit register.  We can use it because we don't\n ;; use the e0-7 registers.\n-;; ??? 4 can be handled in one insn on the 300h.\n \n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n+(define_expand \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+;; Specialized version using adds/subs.  This must come before\n+;; the more general patterns below.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ra\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"adds_subs_operand\" \"i\")))]\n   \"\"\n+  \"* return output_adds_subs (operands);\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&ra,ra\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"n,ra\")))]\n+  \"TARGET_H8300\"\n   \"@\n-   adds\t%T2,%A0\n-   adds\t#2,%A0\\;adds\t%C2,%A0\n-   subs\t%M2,%A0\n-   subs\t#2,%A0\\;subs\t%M2,%A0\n    add.b\t%s2,%s0\\;addx\t%t2,%t0 \n    add.w\t%T2,%T0\"\n-  [(set_attr \"type\" \"arith,multi,arith,multi,multi,arith\")\n-   (set_attr \"length\" \"2,4,2,4,4,2\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,set_zn_c0\")])\n+  [(set_attr \"type\" \"multi,arith\")\n+   (set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"clobber,set_zn_c0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"i,ra\")))]\n+  \"TARGET_H8300H\"\n+  \"@\n+   add.w\t%T2,%T0\n+   add.w\t%T2,%T0\"\n+  [(set_attr \"type\" \"arith,arith\")\n+   (set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"set_zn_c0,set_zn_c0\")])\n \n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -539,8 +627,20 @@\n   \"\"\n   \"\")\n \n+;; Specialized version using adds/subs.  This must come before\n+;; the more general patterns below.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ra\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"adds_subs_operand\" \"i\")))]\n+  \"TARGET_H8300H\"\n+  \"* return output_adds_subs (operands);\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n (define_insn \"addsi_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,&r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra,&ra\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r,r\")))]\n   \"TARGET_H8300\"\n@@ -552,25 +652,17 @@\n    (set_attr \"length\" \"8,6,20\")\n    (set_attr \"cc\" \"clobber\")])\n \n-;; ??? 4 can be handled in one insn on the 300h.\n-;; ??? Should the 'n' constraint be 'i' here?\n-;; ??? We don't handle (reg + symbol_ref) which the 300h can handle.\n-\n (define_insn \"addsi_h8300h\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"i,ra\")))]\n   \"TARGET_H8300H\"\n   \"@\n-   adds\t%S2,%S0\n-   adds\t#2,%S0\\;adds\t%C2,%S0\n-   subs\t%M2,%S0\n-   subs\t#2,%S0\\;subs\t%M2,%S0\n    add.l\t%S2,%S0\n    add.l\t%S2,%S0\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,arith,arith\")\n-   (set_attr \"length\" \"2,4,2,4,6,2\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,set_zn_c0,set_zn_c0\")])\n+  [(set_attr \"type\" \"arith,arith\")\n+   (set_attr \"length\" \"6,2\")\n+   (set_attr \"cc\" \"set_zn_c0,set_zn_c0\")])\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n@@ -1676,15 +1768,23 @@\n   \"\"\n   \"*\n {\n+  /* The length of this insn includes the bld insn below.  We\n+     compute the length of the branch without the bld so we\n+     can easily choose the right branch length.  */\n+  int branch_length = get_attr_length (insn);\n+\n+  if (! register_operand (operands[2], QImode))\n+    branch_length -= 2;\n+\n   output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n-  if (get_attr_length (insn) == 2) \n+  if (branch_length == 2) \n     return \\\"b%d1\t%l0\\\";\n-  else if (get_attr_length (insn) == 4) \n+  else if (branch_length == 4) \n     return \\\"b%d1\t%l0:16\\\";\n   else\n     return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n-  [(set_attr \"type\" \"branch\")\n+  [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"bcs_hihi\"\n@@ -1700,15 +1800,23 @@\n   \"\"\n   \"*\n {\n+  /* The length of this insn includes the bld insn below.  We\n+     compute the length of the branch without the bld so we\n+     can easily choose the right branch length.  */\n+  int branch_length = get_attr_length (insn);\n+\n+  if (! register_operand (operands[2], QImode))\n+    branch_length -= 2;\n+\n   output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n-  if (get_attr_length (insn) == 2) \n+  if (branch_length == 2) \n     return \\\"b%d1\t%l0\\\";\n-  else if (get_attr_length (insn) == 4) \n+  else if (branch_length == 4) \n     return \\\"b%d1\t%l0:16\\\";\n   else\n     return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n-  [(set_attr \"type\" \"branch\")\n+  [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"bcs_hiqi\"\n@@ -1724,15 +1832,23 @@\n   \"\"\n   \"*\n {\n+  /* The length of this insn includes the bld insn below.  We\n+     compute the length of the branch without the bld so we\n+     can easily choose the right branch length.  */\n+  int branch_length = get_attr_length (insn);\n+\n+  if (! register_operand (operands[2], QImode))\n+    branch_length -= 2;\n+\n   output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n-  if (get_attr_length (insn) == 2) \n+  if (branch_length == 2) \n     return \\\"b%d1\t%l0\\\";\n-  else if (get_attr_length (insn) == 4) \n+  else if (branch_length == 4) \n     return \\\"b%d1\t%l0:16\\\";\n   else\n     return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n-  [(set_attr \"type\" \"branch\")\n+  [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n ;; BLD and BST patterns"}]}