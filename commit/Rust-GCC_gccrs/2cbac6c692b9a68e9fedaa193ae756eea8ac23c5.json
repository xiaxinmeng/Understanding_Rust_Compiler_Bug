{"sha": "2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNiYWM2YzY5MmI5YTY4ZTlmZWRhYTE5M2FlNzU2ZWVhOGFjMjNjNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T08:15:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T08:15:25Z"}, "message": "[multiple changes]\n\n2013-07-08  Robert Dewar  <dewar@adacore.com>\n\n\t* sem.ads: Minor comment updates.\n\t* s-restri.ads, exp_ch6.adb, lib-load.ads, exp_ch3.adb, sem_ch10.adb:\n\tMinor reformatting.\n\n2013-07-08  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Add dummy entry\n\tfor Restriction_Set.\n\t* gnat_rm.texi: Add missing menu entry for Attribute Ref Add\n\tdocumentation for attribute Restriction_Set.\n\t* lib-writ.adb (Write_With_Lines): Generate special W lines\n\tfor Restriction_Set.\n\t* lib-writ.ads: Document special use of W lines for\n\tRestriction_Set.\n\t* lib.ads (Restriction_Set_Dependences): New table.\n\t* par-ch4.adb (Is_Parameterless_Attribute): Add Loop_Entry to\n\tlist (Scan_Name_Extension_Apostrophe): Remove kludge test for\n\tLoop_Entry (Scan_Name_Extension_Apostrophe): Handle No_Dependence\n\tfor Restricton_Set.\n\t* restrict.adb (Check_SPARK_Restriction): Put in Alfa order\n\t(OK_No_Dependence_Unit_Name): New function.\n\t* restrict.ads (OK_No_Dependence_Unit_Name): New function.\n\t* rtsfind.adb: Minor reformatting Minor code reorganization.\n\t* sem_attr.adb (Analyze_Attribute): Add processing for\n\tRestriction_Set.\n\t* sem_prag.adb (Process_Restrictions_Or_Restriction_Warnings):\n\tRemove Check_Unit_Name and use new function\n\tOK_No_Dependence_Unit_Name instead.\n\t* sinfo.ads: Minor comment updates.\n\t* snames.ads-tmpl: Add entry for Restriction_Set attribute.\n\n2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Remove local constant\n\tPool_Id and local variable Free_Stmt. Do not deallocate the faulty\n\tobject as \"free\" is not available on all targets/profiles.\n\n2013-07-08  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Handle\n\tStorage_Size aspect for task type in case discriminant is\n\treferenced.\n\t(Analyze_Attribute_Definition_Clause): Do not flag Storage_Size\n\tattribute definition clause as obsolescent if from aspect.\n\nFrom-SVN: r200771", "tree": {"sha": "50c5674f4b0dc7891f7116f7ee46b8a75f9b73f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50c5674f4b0dc7891f7116f7ee46b8a75f9b73f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/comments", "author": null, "committer": null, "parents": [{"sha": "d7a3e18ca87744c3bd293396952a7ff36412d1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a3e18ca87744c3bd293396952a7ff36412d1ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a3e18ca87744c3bd293396952a7ff36412d1ce"}], "stats": {"total": 846, "additions": 608, "deletions": 238}, "files": [{"sha": "ac3876e47d4541822713a00a7cc9a2943c89f9a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -1,3 +1,50 @@\n+2013-07-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem.ads: Minor comment updates.\n+\t* s-restri.ads, exp_ch6.adb, lib-load.ads, exp_ch3.adb, sem_ch10.adb:\n+\tMinor reformatting.\n+\n+2013-07-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Add dummy entry\n+\tfor Restriction_Set.\n+\t* gnat_rm.texi: Add missing menu entry for Attribute Ref Add\n+\tdocumentation for attribute Restriction_Set.\n+\t* lib-writ.adb (Write_With_Lines): Generate special W lines\n+\tfor Restriction_Set.\n+\t* lib-writ.ads: Document special use of W lines for\n+\tRestriction_Set.\n+\t* lib.ads (Restriction_Set_Dependences): New table.\n+\t* par-ch4.adb (Is_Parameterless_Attribute): Add Loop_Entry to\n+\tlist (Scan_Name_Extension_Apostrophe): Remove kludge test for\n+\tLoop_Entry (Scan_Name_Extension_Apostrophe): Handle No_Dependence\n+\tfor Restricton_Set.\n+\t* restrict.adb (Check_SPARK_Restriction): Put in Alfa order\n+\t(OK_No_Dependence_Unit_Name): New function.\n+\t* restrict.ads (OK_No_Dependence_Unit_Name): New function.\n+\t* rtsfind.adb: Minor reformatting Minor code reorganization.\n+\t* sem_attr.adb (Analyze_Attribute): Add processing for\n+\tRestriction_Set.\n+\t* sem_prag.adb (Process_Restrictions_Or_Restriction_Warnings):\n+\tRemove Check_Unit_Name and use new function\n+\tOK_No_Dependence_Unit_Name instead.\n+\t* sinfo.ads: Minor comment updates.\n+\t* snames.ads-tmpl: Add entry for Restriction_Set attribute.\n+\n+2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Remove local constant\n+\tPool_Id and local variable Free_Stmt. Do not deallocate the faulty\n+\tobject as \"free\" is not available on all targets/profiles.\n+\n+2013-07-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Handle\n+\tStorage_Size aspect for task type in case discriminant is\n+\treferenced.\n+\t(Analyze_Attribute_Definition_Clause): Do not flag Storage_Size\n+\tattribute definition clause as obsolescent if from aspect.\n+\n 2013-07-08  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Add documentation for Img returning a function."}, {"sha": "0034767251171da938cf5b6d9aaa78051f9cd9a8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -6500,6 +6500,7 @@ package body Exp_Attr is\n            Attribute_Modulus                      |\n            Attribute_Partition_ID                 |\n            Attribute_Range                        |\n+           Attribute_Restriction_Set              |\n            Attribute_Safe_Emax                    |\n            Attribute_Safe_First                   |\n            Attribute_Safe_Large                   |"}, {"sha": "a21de7edb16c10a8c27c468aa2b793d569b556ac", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -8609,8 +8609,8 @@ package body Exp_Ch3 is\n    --  end case;\n \n    function Make_Eq_Case\n-     (E     : Entity_Id;\n-      CL    : Node_Id;\n+     (E      : Entity_Id;\n+      CL     : Node_Id;\n       Discrs : Elist_Id := New_Elmt_List) return List_Id\n    is\n       Loc      : constant Source_Ptr := Sloc (E);\n@@ -8661,6 +8661,8 @@ package body Exp_Ch3 is\n          return Name_Find;\n       end External_Name;\n \n+   --  Start of processing for Make_Eq_Case\n+\n    begin\n       Append_To (Result, Make_Eq_If (E, Component_Items (CL)));\n "}, {"sha": "6fec955113cefc095b05c7f738b10fc0065ff05a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 62, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -725,11 +725,9 @@ package body Exp_Ch4 is\n         (Ref            : Node_Id;\n          Built_In_Place : Boolean := False)\n       is\n-         Pool_Id   : constant Entity_Id := Associated_Storage_Pool (PtrT);\n-         Cond      : Node_Id;\n-         Free_Stmt : Node_Id;\n-         Obj_Ref   : Node_Id;\n-         Stmts     : List_Id;\n+         Cond    : Node_Id;\n+         Obj_Ref : Node_Id;\n+         Stmts   : List_Id;\n \n       begin\n          if Ada_Version >= Ada_2005\n@@ -761,70 +759,27 @@ package body Exp_Ch4 is\n \n             Stmts := New_List;\n \n-            --  If the target does not support allocation/deallocation, simply\n-            --  finalize the object (if applicable). Generate:\n+            --  Why don't we free the object ??? discussion and explanation\n+            --  needed of why old approach did not work ???\n \n+            --  Generate:\n             --    [Deep_]Finalize (Obj_Ref.all);\n \n-            if Restriction_Active (No_Implicit_Heap_Allocations) then\n-               if Needs_Finalization (DesigT) then\n-                  Append_To (Stmts,\n-                    Make_Final_Call (\n-                      Obj_Ref =>\n-                        Make_Explicit_Dereference (Loc, New_Copy (Obj_Ref)),\n-                      Typ     => DesigT));\n-               end if;\n-\n-            --  Finalize (if applicable) and deallocate the object in case the\n-            --  accessibility check fails.\n-\n-            else\n-               --  Create an explicit free statement to clean up the allocated\n-               --  object in case the accessibility check fails. Generate:\n-\n-               --    Free (Obj_Ref);\n-\n-               Free_Stmt := Make_Free_Statement (Loc, New_Copy (Obj_Ref));\n-               Set_Storage_Pool (Free_Stmt, Pool_Id);\n-\n-               Append_To (Stmts, Free_Stmt);\n-\n-               --  Finalize the object (if applicable), but wrap the call\n-               --  inside a block to ensure that the object would still be\n-               --  deallocated in case the finalization fails. Generate:\n-\n-               --    begin\n-               --       [Deep_]Finalize (Obj_Ref.all);\n-               --    exception\n-               --       when others =>\n-               --          Free (Obj_Ref);\n-               --          raise;\n-               --    end;\n-\n-               if Needs_Finalization (DesigT) then\n-                  Prepend_To (Stmts,\n-                    Make_Block_Statement (Loc,\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                          Statements => New_List (\n-                            Make_Final_Call (\n-                              Obj_Ref =>\n-                                Make_Explicit_Dereference (Loc,\n-                                  Prefix => New_Copy (Obj_Ref)),\n-                              Typ     => DesigT)),\n-\n-                        Exception_Handlers => New_List (\n-                          Make_Exception_Handler (Loc,\n-                            Exception_Choices => New_List (\n-                              Make_Others_Choice (Loc)),\n-                            Statements        => New_List (\n-                              New_Copy_Tree (Free_Stmt),\n-                              Make_Raise_Statement (Loc)))))));\n-               end if;\n+            if Needs_Finalization (DesigT) then\n+               Append_To (Stmts,\n+                 Make_Final_Call (\n+                   Obj_Ref =>\n+                     Make_Explicit_Dereference (Loc, New_Copy (Obj_Ref)),\n+                   Typ     => DesigT));\n             end if;\n \n             --  Signal the accessibility failure through a Program_Error\n \n+            --  Since we may have a storage leak, I would be inclined to\n+            --  define a new PE_ code that warns of this possibility where\n+            --  the message would be Accessibility_Check_Failed (causing\n+            --  storage leak) ???\n+\n             Append_To (Stmts,\n               Make_Raise_Program_Error (Loc,\n                 Condition => New_Reference_To (Standard_True, Loc),"}, {"sha": "d944ac9ca08ee80ccc4cf723e82eb14f991e6c0f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -3782,7 +3782,7 @@ package body Exp_Ch6 is\n \n          --  We perform these optimization regardless of whether we are in the\n          --  main unit or in a unit in the context of the main unit, to ensure\n-         --  that tree generated is the same in both cases, for Inspector use.\n+         --  that tree generated is the same in both cases, for CodePeer use.\n \n          if Is_RTE (Subp, RE_To_Address) then\n             Rewrite (Call_Node,"}, {"sha": "03bf61191a255b47d8136f8800e03e8db757511b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -343,6 +343,8 @@ Implementation Defined Attributes\n * Attribute Passed_By_Reference::\n * Attribute Pool_Address::\n * Attribute Range_Length::\n+* Attribute Ref::\n+* Attribute Restriction_Set::\n * Attribute Result::\n * Attribute Safe_Emax::\n * Attribute Safe_Large::\n@@ -7645,6 +7647,7 @@ consideration, you should minimize the use of these attributes.\n * Attribute Pool_Address::\n * Attribute Range_Length::\n * Attribute Ref::\n+* Attribute Restriction_Set::\n * Attribute Result::\n * Attribute Safe_Emax::\n * Attribute Safe_Large::\n@@ -8332,11 +8335,75 @@ same result as @code{Length} applied to the array itself.\n @unnumberedsec Attribute Ref\n @findex Ref\n @noindent\n-The @code{System.Address'Ref}\n-(@code{System.Address} is the only permissible prefix)\n-denotes a function identical to\n-@code{System.Storage_Elements.To_Address} except that\n-it is a static attribute.  See @ref{Attribute To_Address} for more details.\n+\n+\n+@node Attribute Restriction_Set\n+@unnumberedsec Attribute Restriction_Set\n+@findex Restriction_Set\n+@cindex Restrictions\n+@noindent\n+This attribute allows compile time testing of restrictions that\n+are currently in effect. It is primarily intended for specializing\n+code in the run-time based on restrictions that are active (e.g.\n+don't need to save fpt registers if restriction No_Floating_Point\n+is known to be in effect), but can be used anywhere.\n+\n+There are two forms:\n+\n+@smallexample @c ada\n+System'Restriction_Set (partition_boolean_restriction_NAME)\n+System'Restriction_Set (No_Dependence => library_unit_NAME);\n+@end smallexample\n+\n+@noindent\n+In the case of the first form, the only restriction names\n+allowed are parameterless restrictions that are checked\n+for consistency at bind time. For a complete list see the\n+subtype @code{System.Rident.Partition_Boolean_Restrictions}.\n+\n+The result returned is True if the restriction is known to\n+be in effect, and False if the restriction is known not to\n+be in effect. An important guarantee is that the value of\n+a Restriction_Set attribute is known to be consistent throughout\n+all the code of a partition.\n+\n+This is trivially achieved if the entire partition is compiled\n+with a consistent set of restriction pragmas. However, the\n+compilation model does not require this. It is possible to\n+compile one set of units with one set of pragmas, and another\n+set of units with another set of pragmas. It is even possible\n+to compile a spec with one set of pragmas, and then WITH the\n+same spec with a different set of pragmas. Inconsistencies\n+in the actual use of the restriction are checked at bind time.\n+\n+In order to achieve the guarantee of consistency for the\n+Restriction_Set pragma, we consider that a use of the pragma\n+that yields False is equivalent to a violation of the\n+restriction.\n+\n+So for example if you write\n+\n+@smallexample @c ada\n+if System'Restriction_Set (No_Floating_Point) then\n+   ...\n+else\n+   ...\n+end if;\n+@end smallexample\n+\n+@noindent\n+And the result is False, so that the else branch is executed,\n+you can assume that this restriction is not set for any unit\n+in the partition. This is checked by considering this use of\n+the restriction pragma to be a violation of the restriction\n+No_Floating_Point. This means that no other unit can attempt\n+to set this restriction (if some unit does attempt to set it,\n+the binder will refuse to bind the partition).\n+\n+Technical note: The restriction name and the unit name are\n+intepreted entirely syntactically, as in the corresponding\n+Restrictions pragma, they are not analyzed semantically,\n+so they do not have a type.\n \n @node Attribute Result\n @unnumberedsec Attribute Result"}, {"sha": "3ae9ccaf1aa5a9f20446c668cbeb50fa2c0ffd21", "filename": "gcc/ada/lib-load.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-load.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-load.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -193,7 +193,7 @@ package Lib.Load is\n    --  generate a compilation unit node for it, and we need to make an entry\n    --  for it in the units table, so as to maintain a one-to-one mapping\n    --  between table and nodes. The table entry is used among other things to\n-   --  provide a canonical traversal order for context units for Inspector.\n+   --  provide a canonical traversal order for context units for CodePeer.\n    --  The flag In_Main indicates whether the instance is the main unit.\n \n    procedure Version_Update (U : Node_Id; From : Node_Id);"}, {"sha": "c95b9dc4f837c535596b6498f34de5078f9766ab", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -882,6 +882,38 @@ package body Lib.Writ is\n \n             Write_Info_EOL;\n          end loop;\n+\n+         --  Finally generate the special lines for cases of Restriction_Set\n+         --  with No_Dependence and no restriction present.\n+\n+         declare\n+            Unam : Unit_Name_Type;\n+\n+         begin\n+            for J in Restriction_Set_Dependences.First ..\n+                     Restriction_Set_Dependences.Last\n+            loop\n+               Unam := Restriction_Set_Dependences.Table (J);\n+\n+               --  Don't need an entry if already in the unit table\n+\n+               for U in 0 .. Last_Unit loop\n+                  if Unit_Name (U) = Unam then\n+                     goto Continue;\n+                  end if;\n+               end loop;\n+\n+               --  Otherwise generate the entry\n+\n+               Write_Info_Initiate ('W');\n+               Write_Info_Char (' ');\n+               Write_Info_Name (Unam);\n+               Write_Info_EOL;\n+\n+            <<Continue>>\n+               null;\n+            end loop;\n+         end;\n       end Write_With_Lines;\n \n    --  Start of processing for Write_ALI"}, {"sha": "b9d69c2c99c9372845a64beb52a824c0601fc701", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -402,7 +402,9 @@ package Lib.Writ is\n \n    --    No restriction pragma is present for the named boolean restriction.\n    --    However, the compiler did detect one or more violations of this\n-   --    restriction, which may require a binder consistency check.\n+   --    restriction, which may require a binder consistency check. Note that\n+   --    one case of a violation is the use of a Restriction_Set attribute for\n+   --    the restriction that yielded False.\n \n    --  For the case of restrictions that take a parameter, we need both the\n    --  information from pragma if present, and the actual information about\n@@ -618,9 +620,9 @@ package Lib.Writ is\n    --  Following each U line, is a series of lines of the form\n \n    --    W unit-name [source-name lib-name] [E] [EA] [ED] [AD]\n-   --    or\n+   --      or\n    --    Y unit-name [source-name lib-name] [E] [EA] [ED] [AD]\n-   --    or\n+   --      or\n    --    Z unit-name [source-name lib-name] [E] [EA] [ED] [AD]\n    --\n    --      One W line is present for each unit that is mentioned in an explicit\n@@ -655,6 +657,14 @@ package Lib.Writ is\n    --      The parameter source-name and lib-name are omitted for the case of a\n    --      generic unit compiled with earlier versions of GNAT which did not\n    --      generate object or ali files for generics.\n+   --\n+   --      The parameter source-name and lib-name are also omitted for the W\n+   --      lines that result from use of a Restriction_Set attribute which gets\n+   --      a result of False from a No_Dependence check, in the case where the\n+   --      unit is not in the semantic closure. In such a case, the bare W\n+   --      line is generated, but no D (dependency) line. This will make the\n+   --      binder do the consistency check, but not include the unit in the\n+   --      partition closure (unless it is properly With'ed somewhere).\n \n    --  -----------------------\n    --  -- L  Linker_Options --"}, {"sha": "5370e4ad9075917bd44fb292336d6d5b03bf0b07", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -688,6 +688,42 @@ package Lib is\n    --  of the printout. If Withs is True, we print out units with'ed by this\n    --  unit (not counting limited withs).\n \n+   ---------------------------------------------------------------\n+   -- Special Handling for Restriction_Set (No_Dependence) Case --\n+   ---------------------------------------------------------------\n+\n+   --  If we have a Restriction_Set attribute for No_Dependence => unit,\n+   --  and the unit is not given in a No_Dependence restriction that we\n+   --  can see, the attribute will return False.\n+\n+   --  We have to ensure in this case that the binder will reject any attempt\n+   --  to set a No_Dependence restriction in some other unit in the partition.\n+\n+   --  If the unit is in the semantic closure, then of course it is properly\n+   --  WITH'ed by someone, and the binder will do this job automatically as\n+   --  part of its normal processing.\n+\n+   --  But if the unit is not in the semantic closure, we must make sure the\n+   --  binder knows about it. The use of the Restriction_Set attribute giving\n+   --  a result of False does not mean of itself that we have to include the\n+   --  unit in the partition. So what we do is to generate a with (W) line in\n+   --  the ali file (with no file name information), but no corresponding D\n+   --  (dependency) line. This is recognized by the binder as meaning \"Don't\n+   --  let anyone specify No_Dependence for this unit, but you don't have to\n+   --  include it if there is no real W line for the unit\".\n+\n+   --  The following table keeps track of relevant units. It is used in the\n+   --  Lib.Writ circuit for outputting With lines to output the special with\n+   --  line with RA if the unit is not in the semantic closure.\n+\n+   package Restriction_Set_Dependences is new Table.Table (\n+     Table_Component_Type => Unit_Name_Type,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 10,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Restriction_Attribute_Dependences\");\n+\n private\n    pragma Inline (Cunit);\n    pragma Inline (Cunit_Entity);"}, {"sha": "38fd00e1fbb3166435ed6f0d4631f21b4e9bd1a1", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -40,6 +40,7 @@ package body Ch4 is\n       Attribute_Class        => True,\n       Attribute_External_Tag => True,\n       Attribute_Img          => True,\n+      Attribute_Loop_Entry   => True,\n       Attribute_Stub_Type    => True,\n       Attribute_Version      => True,\n       Attribute_Type_Key     => True,\n@@ -50,6 +51,13 @@ package body Ch4 is\n    --  list because it may denote a slice operation (X'Img (1 .. 2)) or\n    --  a type conversion (X'Class (Y)).\n \n+   --  Note: Loop_Entry is in this list because, although it can take an\n+   --  optional argument (the loop name), we can't distinguish that at parse\n+   --  time from the case where no loop name is given and a legitimate index\n+   --  expression is present. So we parse the argument as an indexed component\n+   --  and the semantic analysis sorts out this syntactic ambiguity based on\n+   --  the type and form of the expression.\n+\n    --  Note that this map designates the minimum set of attributes where a\n    --  construct in parentheses that is not an argument can appear right\n    --  after the attribute. For attributes like 'Size, we do not put them\n@@ -503,42 +511,65 @@ package body Ch4 is\n             Set_Attribute_Name (Name_Node, Attr_Name);\n \n             --  Scan attribute arguments/designator. We skip this if we know\n-            --  that the attribute cannot have an argument.\n+            --  that the attribute cannot have an argument (see documentation\n+            --  of Is_Parameterless_Attribute for further details).\n \n             if Token = Tok_Left_Paren\n               and then not\n                 Is_Parameterless_Attribute (Get_Attribute_Id (Attr_Name))\n             then\n-               --  Attribute Loop_Entry has no effect on the name extension\n-               --  parsing logic, as if the attribute never existed in the\n-               --  source. Continue parsing the subsequent expressions or\n-               --  ranges.\n-\n-               if Attr_Name = Name_Loop_Entry then\n-                  Scan; -- past left paren\n-                  goto Scan_Name_Extension_Left_Paren;\n-\n                --  Attribute Update contains an array or record association\n                --  list which provides new values for various components or\n-               --  elements. The list is parsed as an aggregate.\n+               --  elements. The list is parsed as an aggregate, and we get\n+               --  better error handling by knowing that in the parser.\n \n-               elsif Attr_Name = Name_Update then\n+               if Attr_Name = Name_Update then\n                   Set_Expressions (Name_Node, New_List);\n                   Append (P_Aggregate, Expressions (Name_Node));\n \n+               --  All other cases of parsing attribute arguments\n+\n                else\n                   Set_Expressions (Name_Node, New_List);\n                   Scan; -- past left paren\n \n                   loop\n                      declare\n                         Expr : constant Node_Id := P_Expression_If_OK;\n+                        Rnam : Node_Id;\n \n                      begin\n+                        --  Case of => for named notation\n+\n                         if Token = Tok_Arrow then\n-                           Error_Msg_SC\n-                             (\"named parameters not permitted for attributes\");\n-                           Scan; -- past junk arrow\n+\n+                           --  Named notation allowed only for the special\n+                           --  case of System'Restriction_Set (No_Dependence =>\n+                           --  unit_NAME), in which case construct a parameter\n+                           --  assocation node and append to the arguments.\n+\n+                           if Attr_Name = Name_Restriction_Set\n+                             and then Nkind (Expr) = N_Identifier\n+                             and then Chars (Expr) = Name_No_Dependence\n+                           then\n+                              Scan; -- past arrow\n+                              Rnam := P_Name;\n+                              Append_To (Expressions (Name_Node),\n+                                Make_Parameter_Association (Sloc (Rnam),\n+                                  Selector_Name             => Expr,\n+                                  Explicit_Actual_Parameter => Rnam));\n+                              exit;\n+\n+                           --  For all other cases named notation is illegal\n+\n+                           else\n+                              Error_Msg_SC\n+                                (\"named parameters not permitted \"\n+                                 & \"for attributes\");\n+                              Scan; -- past junk arrow\n+                           end if;\n+\n+                        --  Here for normal case (not => for named parameter)\n \n                         else\n                            Append (Expr, Expressions (Name_Node));"}, {"sha": "ea0f89c43bce2555916eca052c27984439265f0f", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 84, "deletions": 63, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -184,69 +184,6 @@ package body Restrict is\n       Check_Restriction (No_Elaboration_Code, N);\n    end Check_Elaboration_Code_Allowed;\n \n-   -----------------------------\n-   -- Check_SPARK_Restriction --\n-   -----------------------------\n-\n-   procedure Check_SPARK_Restriction\n-     (Msg   : String;\n-      N     : Node_Id;\n-      Force : Boolean := False)\n-   is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-\n-   begin\n-      if Force or else Comes_From_Source (Original_Node (N)) then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_Restriction;\n-\n-   procedure Check_SPARK_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-\n-   begin\n-      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n-\n-      if Comes_From_Source (Original_Node (N)) then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg1, N);\n-            Error_Msg_F (Msg2, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_Restriction;\n-\n    --------------------------------\n    -- Check_No_Implicit_Aliasing --\n    --------------------------------\n@@ -883,6 +820,27 @@ package body Restrict is\n         and then Restriction_Active (No_Exception_Propagation);\n    end No_Exception_Propagation_Active;\n \n+   --------------------------------\n+   -- OK_No_Dependence_Unit_Name --\n+   --------------------------------\n+\n+   function OK_No_Dependence_Unit_Name (N : Node_Id) return Boolean is\n+   begin\n+      if Nkind (N) = N_Selected_Component then\n+         return\n+           OK_No_Dependence_Unit_Name (Prefix (N))\n+             and then\n+           OK_No_Dependence_Unit_Name (Selector_Name (N));\n+\n+      elsif Nkind (N) = N_Identifier then\n+         return True;\n+\n+      else\n+         Error_Msg_N (\"wrong form for unit name for No_Dependence\", N);\n+         return False;\n+      end if;\n+   end OK_No_Dependence_Unit_Name;\n+\n    ----------------------------------\n    -- Process_Restriction_Synonyms --\n    ----------------------------------\n@@ -1437,6 +1395,69 @@ package body Restrict is\n       end if;\n    end Set_Restriction_No_Use_Of_Pragma;\n \n+   -----------------------------\n+   -- Check_SPARK_Restriction --\n+   -----------------------------\n+\n+   procedure Check_SPARK_Restriction\n+     (Msg   : String;\n+      N     : Node_Id;\n+      Force : Boolean := False)\n+   is\n+      Msg_Issued          : Boolean;\n+      Save_Error_Msg_Sloc : Source_Ptr;\n+\n+   begin\n+      if Force or else Comes_From_Source (Original_Node (N)) then\n+         if Restriction_Check_Required (SPARK_05)\n+           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n+         then\n+            return;\n+         end if;\n+\n+         --  Since the call to Restriction_Msg from Check_Restriction may set\n+         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n+         --  restore the previous value of the global variable around the call.\n+\n+         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n+         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n+         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n+\n+         if Msg_Issued then\n+            Error_Msg_F (\"\\\\| \" & Msg, N);\n+         end if;\n+      end if;\n+   end Check_SPARK_Restriction;\n+\n+   procedure Check_SPARK_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n+      Msg_Issued          : Boolean;\n+      Save_Error_Msg_Sloc : Source_Ptr;\n+\n+   begin\n+      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n+\n+      if Comes_From_Source (Original_Node (N)) then\n+         if Restriction_Check_Required (SPARK_05)\n+           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n+         then\n+            return;\n+         end if;\n+\n+         --  Since the call to Restriction_Msg from Check_Restriction may set\n+         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n+         --  restore the previous value of the global variable around the call.\n+\n+         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n+         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n+         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n+\n+         if Msg_Issued then\n+            Error_Msg_F (\"\\\\| \" & Msg1, N);\n+            Error_Msg_F (Msg2, N);\n+         end if;\n+      end if;\n+   end Check_SPARK_Restriction;\n+\n    ----------------------------------\n    -- Suppress_Restriction_Message --\n    ----------------------------------"}, {"sha": "19439731a37faad5e54b467a2c2f9fd5b8844ab1", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -302,6 +302,11 @@ package Restrict is\n    --  identifier, and if so returns the corresponding Restriction_Id value,\n    --  otherwise returns Not_A_Restriction_Id.\n \n+   function OK_No_Dependence_Unit_Name (N : Node_Id) return Boolean;\n+   --  Used in checking No_Dependence argument of pragma Restrictions or\n+   --  pragma Restrictions_Warning, or attribute Restriction_Set. Returns\n+   --  True if N has the proper form for a unit name, False otherwise.\n+\n    function Is_In_Hidden_Part_In_SPARK (Loc : Source_Ptr) return Boolean;\n    --  Determine if given location is covered by a hidden region range in the\n    --  SPARK hides table."}, {"sha": "ecd1cd6b4e8a998527cf031e2d31934c90236eef", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -82,7 +82,7 @@ package body Rtsfind is\n \n    --  A unit retrieved through rtsfind  may end up in the context of several\n    --  other units, in addition to the main unit. These additional with_clauses\n-   --  are needed to generate a proper traversal order for Inspector. To\n+   --  are needed to generate a proper traversal order for CodePeer. To\n    --  minimize somewhat the redundancy created by numerous calls to rtsfind\n    --  from different units, we keep track of the list of implicit with_clauses\n    --  already created for the current loaded unit.\n@@ -123,7 +123,7 @@ package body Rtsfind is\n    --  with_clauses to the extended main unit if needed, and also to whatever\n    --  unit needs them, which is not necessarily the main unit. The former\n    --  ensures that the object is correctly loaded by the binder. The latter\n-   --  is necessary for SofCheck Inspector.\n+   --  is necessary for CodePeer.\n \n    --  The field First_Implicit_With in the unit table record are used to\n    --  avoid creating duplicate with_clauses.\n@@ -827,10 +827,9 @@ package body Rtsfind is\n       --  We do not need to generate a with_clause for a call issued from\n       --  RTE_Component_Available. However, for CodePeer, we need these\n       --  additional with's, because for a sequence like \"if RTE_Available (X)\n-      --  then ... RTE (X)\" the RTE call fails to create some necessary\n-      --  with's.\n+      --  then ... RTE (X)\" the RTE call fails to create some necessary with's.\n \n-      if RTE_Available_Call and then not Generate_SCIL then\n+      if RTE_Available_Call and not Generate_SCIL then\n          return;\n       end if;\n \n@@ -840,8 +839,8 @@ package body Rtsfind is\n          return;\n       end if;\n \n-      --  Add the with_clause, if not already in the context of the\n-      --  current compilation unit.\n+      --  Add the with_clause, if not already in the context of the current\n+      --  compilation unit.\n \n       declare\n          LibUnit : constant Node_Id := Unit (Cunit (U.Unum));"}, {"sha": "a0cb1e9d2ccd1fbb5995b39dce29b9bc2ca03df3", "filename": "gcc/ada/s-restri.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fs-restri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fs-restri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-restri.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,15 +47,16 @@ package System.Restrictions is\n \n    pragma Discard_Names;\n    package Rident is new System.Rident;\n+   --  Instantiate a copy of System.Rident without enumeration image names\n \n    Run_Time_Restrictions : Rident.Restrictions_Info;\n    --  Restrictions as set by the user, or detected by the binder. See details\n    --  in package System.Rident for what restrictions are included in the list\n    --  and the format of the information.\n    --\n    --  Note that a restriction which is both Set and Violated at run-time means\n-   --  that the violation was detected as part of the Ada run-time and not\n-   --  as part of user code.\n+   --  that the violation was detected as part of the Ada run-time and not as\n+   --  part of user code.\n \n    ------------------\n    -- Subprograms --\n@@ -64,13 +65,13 @@ package System.Restrictions is\n    function Abort_Allowed return Boolean;\n    pragma Inline (Abort_Allowed);\n    --  Tests to see if abort is allowed by the current restrictions settings.\n-   --  For abort to be allowed, either No_Abort_Statements must be False,\n-   --  or Max_Asynchronous_Select_Nesting must be non-zero.\n+   --  For abort to be allowed, either No_Abort_Statements must be False, or\n+   --  Max_Asynchronous_Select_Nesting must be non-zero.\n \n    function Tasking_Allowed return Boolean;\n    pragma Inline (Tasking_Allowed);\n    --  Tests to see if tasking operations are allowed by the current\n-   --  restrictions settings. For tasking to be allowed, No_Tasking\n-   --  must be False, and Max_Tasks must not be set to zero.\n+   --  restrictions settings. For tasking to be allowed, No_Tasking must\n+   --  be False, and Max_Tasks must not be set to zero.\n \n end System.Restrictions;"}, {"sha": "9bc7ff757bc9bc5462b659878018b0571057de89", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -654,20 +654,22 @@ package Sem is\n    generic\n       with procedure Action (Item : Node_Id);\n    procedure Walk_Library_Items;\n-   --  Primarily for use by SofCheck Inspector. Must be called after semantic\n-   --  analysis (and expansion) are complete. Walks each relevant library item,\n-   --  calling Action for each, in an order such that one will not run across\n-   --  forward references. Each Item passed to Action is the declaration or\n-   --  body of a library unit, including generics and renamings. The first item\n-   --  is the N_Package_Declaration node for package Standard. Bodies are not\n+   --  Primarily for use by CodePeer. Must be called after semantic analysis\n+   --  (and expansion) are complete. Walks each relevant library item, calling\n+   --  Action for each, in an order such that one will not run across forward\n+   --  references. Each Item passed to Action is the declaration or body of\n+   --  a library unit, including generics and renamings. The first item is\n+   --  the N_Package_Declaration node for package Standard. Bodies are not\n    --  included, except for the main unit itself, which always comes last.\n    --\n    --  Item is never a subunit\n    --\n    --  Item is never an instantiation. Instead, the instance declaration is\n    --  passed, and (if the instantiation is the main unit), the instance body.\n \n-   --  Debugging:\n+   ------------------------\n+   -- Debugging Routines --\n+   ------------------------\n \n    function ss (Index : Int) return Scope_Stack_Entry;\n    pragma Export (Ada, ss);"}, {"sha": "f5d12ed1c7b2451dd8338ad67badbfdf72c7a87f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 148, "deletions": 26, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -72,6 +72,7 @@ with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n+with Uname;    use Uname;\n with Urealp;   use Urealp;\n \n package body Sem_Attr is\n@@ -1642,9 +1643,7 @@ package body Sem_Attr is\n       begin\n          Check_E0;\n \n-         if Nkind (P) /= N_Identifier\n-           or else Chars (P) /= Name_Standard\n-         then\n+         if Nkind (P) /= N_Identifier or else Chars (P) /= Name_Standard then\n             Error_Attr (\"only allowed prefix for % attribute is Standard\", P);\n          end if;\n       end Check_Standard_Prefix;\n@@ -1658,12 +1657,11 @@ package body Sem_Attr is\n          Btyp : Entity_Id;\n \n          In_Shared_Var_Procs : Boolean;\n-         --  True when compiling the body of System.Shared_Storage.\n-         --  Shared_Var_Procs. For this runtime package (always compiled in\n-         --  GNAT mode), we allow stream attributes references for limited\n-         --  types for the case where shared passive objects are implemented\n-         --  using stream attributes, which is the default in GNAT's persistent\n-         --  storage implementation.\n+         --  True when compiling System.Shared_Storage.Shared_Var_Procs body.\n+         --  For this runtime package (always compiled in GNAT mode), we allow\n+         --  stream attributes references for limited types for the case where\n+         --  shared passive objects are implemented using stream attributes,\n+         --  which is the default in GNAT's persistent storage implementation.\n \n       begin\n          Validate_Non_Static_Attribute_Function_Call;\n@@ -2049,16 +2047,11 @@ package body Sem_Attr is\n       --  some attributes for which we do not analyze the prefix, since the\n       --  prefix is not a normal name, or else needs special handling.\n \n-      if Aname /= Name_Elab_Body\n-           and then\n-         Aname /= Name_Elab_Spec\n-           and then\n-         Aname /= Name_Elab_Subp_Body\n-           and then\n-         Aname /= Name_UET_Address\n-           and then\n-         Aname /= Name_Enabled\n-           and then\n+      if Aname /= Name_Elab_Body       and then\n+         Aname /= Name_Elab_Spec       and then\n+         Aname /= Name_Elab_Subp_Body  and then\n+         Aname /= Name_UET_Address     and then\n+         Aname /= Name_Enabled         and then\n          Aname /= Name_Old\n       then\n          Analyze (P);\n@@ -2122,12 +2115,18 @@ package body Sem_Attr is\n \n       else\n          E1 := First (Exprs);\n-         Analyze (E1);\n \n-         --  Check for missing/bad expression (result of previous error)\n+         --  Skip analysis for case of Restriction_Set, we do not expect\n+         --  the argument to be analyzed in this case.\n \n-         if No (E1) or else Etype (E1) = Any_Type then\n-            raise Bad_Attribute;\n+         if Aname /= Name_Restriction_Set then\n+            Analyze (E1);\n+\n+            --  Check for missing/bad expression (result of previous error)\n+\n+            if No (E1) or else Etype (E1) = Any_Type then\n+               raise Bad_Attribute;\n+            end if;\n          end if;\n \n          E2 := Next (E1);\n@@ -4832,6 +4831,121 @@ package body Sem_Attr is\n          Resolve (E1, P_Base_Type);\n          Resolve (E2, P_Base_Type);\n \n+      ---------------------\n+      -- Restriction_Set --\n+      ---------------------\n+\n+      when Attribute_Restriction_Set => Restriction_Set : declare\n+         R    : Restriction_Id;\n+         U    : Node_Id;\n+         Unam : Unit_Name_Type;\n+\n+         procedure Set_Result (B : Boolean);\n+         --  Replace restriction node by static constant False or True,\n+         --  depending on the value of B.\n+\n+         ----------------\n+         -- Set_Result --\n+         ----------------\n+\n+         procedure Set_Result (B : Boolean) is\n+         begin\n+            if B then\n+               Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n+            else\n+               Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n+            end if;\n+\n+            Set_Is_Static_Expression (N);\n+         end Set_Result;\n+\n+      --  Start of processing for Restriction_Set\n+\n+      begin\n+         Check_E1;\n+         Analyze (P);\n+\n+         if Nkind (P) /= N_Identifier or else Chars (P) /= Name_System then\n+            Set_Result (False);\n+            Error_Attr_P (\"prefix of % attribute must be System\");\n+         end if;\n+\n+         --  No_Dependence case\n+\n+         if Nkind (E1) = N_Parameter_Association then\n+            pragma Assert (Chars (Selector_Name (E1)) = Name_No_Dependence);\n+            U := Explicit_Actual_Parameter (E1);\n+\n+            if not OK_No_Dependence_Unit_Name (U) then\n+               Set_Result (False);\n+               Error_Attr;\n+            end if;\n+\n+            --  See if there is an entry already in the table. That's the\n+            --  case in which we can return True.\n+\n+            for J in No_Dependences.First .. No_Dependences.Last loop\n+               if Designate_Same_Unit (U, No_Dependences.Table (J).Unit)\n+                 and then No_Dependences.Table (J).Warn = False\n+               then\n+                  Set_Result (True);\n+                  return;\n+               end if;\n+            end loop;\n+\n+            --  If not in the No_Dependence table, result is False\n+\n+            Set_Result (False);\n+\n+            --  In this case, we must ensure that the binder will reject any\n+            --  other unit in the partition that sets No_Dependence for this\n+            --  unit. We do that by making an entry in the special table kept\n+            --  for this purpose (if the entry is not there already).\n+\n+            Unam := Get_Spec_Name (Get_Unit_Name (U));\n+\n+            for J in Restriction_Set_Dependences.First ..\n+                     Restriction_Set_Dependences.Last\n+            loop\n+               if Restriction_Set_Dependences.Table (J) = Unam then\n+                  return;\n+               end if;\n+            end loop;\n+\n+            Restriction_Set_Dependences.Append (Unam);\n+\n+         --  Normal restriction case\n+\n+         else\n+            if Nkind (E1) /= N_Identifier then\n+               Set_Result (False);\n+               Error_Attr (\"attribute % requires restriction identifier\", E1);\n+\n+            else\n+               R := Get_Restriction_Id (Process_Restriction_Synonyms (E1));\n+\n+               if R = Not_A_Restriction_Id then\n+                  Set_Result (False);\n+                  Error_Msg_Node_1 := E1;\n+                  Error_Attr (\"invalid restriction identifier &\", E1);\n+\n+               elsif R not in Partition_Boolean_Restrictions then\n+                  Set_Result (False);\n+                  Error_Msg_Node_1 := E1;\n+                  Error_Attr\n+                    (\"& is not a boolean partition-wide restriction\", E1);\n+               end if;\n+\n+               if Restriction_Active (R) then\n+                  Set_Result (True);\n+               else\n+                  Check_Restriction (R, N);\n+                  Set_Result (False);\n+               end if;\n+            end if;\n+         end if;\n+      end Restriction_Set;\n+\n       -----------\n       -- Round --\n       -----------\n@@ -5334,9 +5448,7 @@ package body Sem_Attr is\n          Check_E1;\n          Analyze (P);\n \n-         if Nkind (P) /= N_Identifier\n-           or else Chars (P) /= Name_System\n-         then\n+         if Nkind (P) /= N_Identifier or else Chars (P) /= Name_System then\n             Error_Attr_P (\"prefix of % attribute must be System\");\n          end if;\n \n@@ -8072,6 +8184,16 @@ package body Sem_Attr is\n          Fold_Ureal (N, Eval_Fat.Remainder (P_Base_Type, X, Y), Static);\n       end Remainder;\n \n+      -----------------\n+      -- Restriction --\n+      -----------------\n+\n+      when Attribute_Restriction_Set => Restriction_Set : declare\n+      begin\n+         Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n+         Set_Is_Static_Expression (N);\n+      end Restriction_Set;\n+\n       -----------\n       -- Round --\n       -----------"}, {"sha": "87d2ab3c2595a8b513d189b2be4d52eacc3ab21e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -3000,7 +3000,7 @@ package body Sem_Ch10 is\n       Set_First_Name         (Withn, True);\n       Set_Implicit_With      (Withn, True);\n \n-      --  If the unit is a package or generic package  declaration, a private_\n+      --  If the unit is a package or generic package declaration, a private_\n       --  with_clause on a child unit implies that the implicit with on the\n       --  parent is also private.\n "}, {"sha": "37fd72253d6501f03e5d28e14d153ba2eedaeab9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -1310,7 +1310,6 @@ package body Sem_Ch13 is\n                     Aspect_Small                |\n                     Aspect_Simple_Storage_Pool  |\n                     Aspect_Storage_Pool         |\n-                    Aspect_Storage_Size         |\n                     Aspect_Stream_Size          |\n                     Aspect_Value_Size           |\n                     Aspect_Variable_Indexing    |\n@@ -1751,7 +1750,7 @@ package body Sem_Ch13 is\n                   Analyze_Aspect_Dimension_System (N, Id, Expr);\n                   goto Continue;\n \n-               --  Case 4: Special handling for aspects\n+               --  Case 4: Aspects requiring special handling\n \n                --  Pre/Post/Test_Case/Contract_Cases whose corresponding\n                --  pragmas take care of the delay.\n@@ -2028,6 +2027,62 @@ package body Sem_Ch13 is\n                   else\n                      Aitem := Empty;\n                   end if;\n+\n+               --  Storage_Size\n+\n+               --  This is special because for access types we need to generate\n+               --  an attribute definition clause. This also works for single\n+               --  task declarations, but it does not work for task type\n+               --  declarations, because we have the case where the expression\n+               --  references a discriminant of the task type. That can't use\n+               --  an attribute definition clause because we would not have\n+               --  visibility on the discriminant. For that case we must\n+               --  generate a pragma in the task definition.\n+\n+               when Aspect_Storage_Size =>\n+\n+                  --  Task type case\n+\n+                  if Ekind (E) = E_Task_Type then\n+                     declare\n+                        Decl : constant Node_Id := Declaration_Node (E);\n+\n+                     begin\n+                        pragma Assert (Nkind (Decl) = N_Task_Type_Declaration);\n+\n+                        --  If no task definition, create one\n+\n+                        if No (Task_Definition (Decl)) then\n+                           Set_Task_Definition (Decl,\n+                             Make_Task_Definition (Loc,\n+                               Visible_Declarations => Empty_List,\n+                               End_Label            => Empty));\n+                        end if;\n+\n+                        --  Create a pragma and put it at the start of the\n+                        --  task definition for the task type declaration.\n+\n+                        Make_Aitem_Pragma\n+                          (Pragma_Argument_Associations => New_List (\n+                             Make_Pragma_Argument_Association (Loc,\n+                               Expression => Relocate_Node (Expr))),\n+                           Pragma_Name                  => Name_Storage_Size);\n+\n+                        Prepend\n+                          (Aitem,\n+                           Visible_Declarations (Task_Definition (Decl)));\n+                        goto Continue;\n+                     end;\n+\n+                  --  All other cases, generate attribute definition\n+\n+                  else\n+                     Aitem :=\n+                       Make_Attribute_Definition_Clause (Loc,\n+                         Name       => Ent,\n+                         Chars      => Chars (Id),\n+                         Expression => Relocate_Node (Expr));\n+                  end if;\n             end case;\n \n             --  Attach the corresponding pragma/attribute definition clause to\n@@ -4067,13 +4122,18 @@ package body Sem_Ch13 is\n \n          begin\n             if Is_Task_Type (U_Ent) then\n-               Check_Restriction (No_Obsolescent_Features, N);\n \n-               if Warn_On_Obsolescent_Feature then\n-                  Error_Msg_N\n-                    (\"?j?storage size clause for task is an \" &\n-                     \"obsolescent feature (RM J.9)\", N);\n-                  Error_Msg_N (\"\\?j?use Storage_Size pragma instead\", N);\n+               --  Check obsolescent (but never obsolescent if from aspect!)\n+\n+               if not From_Aspect_Specification (N) then\n+                  Check_Restriction (No_Obsolescent_Features, N);\n+\n+                  if Warn_On_Obsolescent_Feature then\n+                     Error_Msg_N\n+                       (\"?j?storage size clause for task is an \" &\n+                        \"obsolescent feature (RM J.9)\", N);\n+                     Error_Msg_N (\"\\?j?use Storage_Size pragma instead\", N);\n+                  end if;\n                end if;\n \n                FOnly := True;"}, {"sha": "a18b874fbe1136496558cd8791f31e1284de8cea", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -6990,31 +6990,6 @@ package body Sem_Prag is\n          Expr  : Node_Id;\n          Val   : Uint;\n \n-         procedure Check_Unit_Name (N : Node_Id);\n-         --  Checks unit name parameter for No_Dependence. Returns if it has\n-         --  an appropriate form, otherwise raises pragma argument error.\n-\n-         ---------------------\n-         -- Check_Unit_Name --\n-         ---------------------\n-\n-         procedure Check_Unit_Name (N : Node_Id) is\n-         begin\n-            if Nkind (N) = N_Selected_Component then\n-               Check_Unit_Name (Prefix (N));\n-               Check_Unit_Name (Selector_Name (N));\n-\n-            elsif Nkind (N) = N_Identifier then\n-               return;\n-\n-            else\n-               Error_Pragma_Arg\n-                 (\"wrong form for unit name for No_Dependence\", N);\n-            end if;\n-         end Check_Unit_Name;\n-\n-      --  Start of processing for Process_Restrictions_Or_Restriction_Warnings\n-\n       begin\n          --  Ignore all Restrictions pragmas in CodePeer mode\n \n@@ -7174,7 +7149,9 @@ package body Sem_Prag is\n             --  already made the necessary entry in the No_Dependence table.\n \n             elsif Id = Name_No_Dependence then\n-               Check_Unit_Name (Expr);\n+               if not OK_No_Dependence_Unit_Name (Expr) then\n+                  raise Pragma_Exit;\n+               end if;\n \n             --  Case of No_Specification_Of_Aspect => Identifier.\n "}, {"sha": "e8c9805cc315f8205b21791a1aec4cdaae455817", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -1516,14 +1516,14 @@ package Sinfo is\n    --    in rtsfind to indicate implicit dependencies on predefined units. Used\n    --    to prevent multiple with_clauses for the same unit in a given context.\n    --    A postorder traversal of the tree whose nodes are units and whose\n-   --    links are with_clauses defines the order in which Inspector must\n+   --    links are with_clauses defines the order in which CodePeer must\n    --    examine a compiled unit and its full context. This ordering ensures\n    --    that any subprogram call is examined after the subprogram declaration\n    --    has been seen.\n \n    --  Next_Named_Actual (Node4-Sem)\n-   --    Present in parameter association node. Set during semantic analysis to\n-   --    point to the next named parameter, where parameters are ordered by\n+   --    Present in parameter association nodes. Set during semantic analysis\n+   --    to point to the next named parameter, where parameters are ordered by\n    --    declaration order (as opposed to the actual order in the call, which\n    --    may be different due to named associations). Not that this field\n    --    points to the explicit actual parameter itself, not to the"}, {"sha": "70afdb7011094fc5651a20d86288a01879f87b20", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbac6c692b9a68e9fedaa193ae756eea8ac23c5/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=2cbac6c692b9a68e9fedaa193ae756eea8ac23c5", "patch": "@@ -903,6 +903,7 @@ package Snames is\n    Name_Range                          : constant Name_Id := N + $;\n    Name_Range_Length                   : constant Name_Id := N + $; -- GNAT\n    Name_Ref                            : constant Name_Id := N + $; -- GNAT\n+   Name_Restriction_Set                : constant Name_Id := N + $; -- GNAT\n    Name_Result                         : constant Name_Id := N + $; -- GNAT\n    Name_Round                          : constant Name_Id := N + $;\n    Name_Safe_Emax                      : constant Name_Id := N + $; -- Ada 83\n@@ -1519,6 +1520,7 @@ package Snames is\n       Attribute_Range,\n       Attribute_Range_Length,\n       Attribute_Ref,\n+      Attribute_Restriction_Set,\n       Attribute_Result,\n       Attribute_Round,\n       Attribute_Safe_Emax,"}]}