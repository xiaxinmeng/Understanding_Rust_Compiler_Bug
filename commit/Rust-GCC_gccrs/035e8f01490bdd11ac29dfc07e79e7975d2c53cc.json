{"sha": "035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1ZThmMDE0OTBiZGQxMWFjMjlkZmMwN2U3OWU3OTc1ZDJjNTNjYw==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2004-12-16T01:10:38Z"}, "committer": {"name": "Ziemowit Laski", "email": "zlaski@gcc.gnu.org", "date": "2004-12-16T01:10:38Z"}, "message": "objc-act.c (build_private_template): Change to return 'void'...\n\n[gcc/objc/ChangeLog]\n2004-12-15  Ziemowit Laski  <zlaski@apple.com>\n\n\t* objc-act.c (build_private_template): Change to return 'void'; do\n\tnot set ivar_context, uprivate_record or objc_instance_type.\n\t(objc_comptypes, gen_type_name_0): For types 'id' and 'Class',\n\tretrieve protocol list from the pointee rather than the pointer itself;\n\tcheck TYPE_HAS_OBJC_INFO(...) precondition before accessing\n\tTYPE_OBJC_PROTOCOL_LIST.\n\t(objc_get_protocol_qualified_type): For types 'id' and 'Class',\n\tconstruct a variant of the pointee as well as the pointer, and\n\tstore protocol information in the former.  When creating variants\n\tof RECORD_TYPEs, clone their TYPE_LANG_SPECIFIC fields and propagate\n\tTYPE_OBJC_INTERFACE information.\n\t(objc_declare_class): If a TYPE_DECL is looked up, retrieve the\n\tunderlying RECORD_TYPE to check for presence of TYPE_OBJC_INTERFACE;\n\tfor newly-created RECORD_TYPEs, create a tentative TYPE_OBJC_INTERFACE\n\tholding an IDENTIFIER_NODE.\n\t(objc_finish_message_expr): Check TYPE_HAS_OBJC_INFO(...) before\n\taccessing TYPE_OBJC_PROTOCOL_LIST; Use TYPE_OBJC_INTERFACE instead\n\tof calling lookup_interface(); allow for TYPE_OBJC_INTERFACE holding\n\tan IDENTIFIER_NODE (meaning a @class forward-declaration only).\n\t(objc_is_public): Check TYPE_OBJC_INTERFACE instead of calling\n\tlookup_interface().\n\t(continue_class): For @implementations, set ivar_context,\n\tuprivate_record and objc_instance_type, for @interfaces, call\n\tbuild_private_template().\n\t(encode_pointer): Check TYPE_HAS_OBJC_INFO(...) before accessing\n\tTYPE_OBJC_INTERFACE.\n\t(objc_types_are_equivalent): Check TYPE_HAS_OBJC_INFO(...) before\n\taccessing TYPE_OBJC_PROTOCOL_LIST.\n\t* objc-act.h (OBJC_INFO_SLOT_ELTS, TYPE_OBJC_INFO, INIT_TYPE_OBJC_INFO,\n\tDUP_TYPE_OBJC_INFO, ALLOC_OBJC_TYPE_LANG_SPECIFIC,\n\tSIZEOF_OBJC_TYPE_LANG_SPECIFIC): New macros.\n\t(TYPE_OBJC_INTERFACE): Replaces TREE_STATIC_INSTANCE and now points\n\tto an actual @interface; stored in TYPE_LANG_SPECIFIC(...).\n\t(TYPE_OBJC_PROTOCOL_LIST): Replaces TYPE_PROTOCOL_LIST; stored in\n\tTYPE_LANG_SPECIFIC(...).\n\t(TREE_STATIC_INSTANCE, TYPE_PROTOCOL_LIST): Delete.\n\t(IS_ID, IS_CLASS, IS_PROTOCOL_QUALIFIED_UNTYPED, IS_SUPER,\n\tTYPED_OBJECT): Check for POINTER_TYPE rather than POINTER_TYPE_P;\n\tadjust for use of TYPE_OBJC_INTERFACE and TYPE_OBJC_PROTOCOL_LIST\n\tinstead of TREE_STATIC_INSTANCE and TYPE_PROTOCOL_LIST.\n\nFrom-SVN: r92239", "tree": {"sha": "a3a7db25ede93c8e5aeb13d64bd697265fcaeed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3a7db25ede93c8e5aeb13d64bd697265fcaeed9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/comments", "author": null, "committer": null, "parents": [{"sha": "6591c4a79d52bd310cd425b558be4326c321b5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6591c4a79d52bd310cd425b558be4326c321b5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6591c4a79d52bd310cd425b558be4326c321b5f4"}], "stats": {"total": 278, "additions": 190, "deletions": 88}, "files": [{"sha": "b0216ae81d05c6b8dd111bdb20831083b28e57f1", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "patch": "@@ -1,3 +1,46 @@\n+2004-12-15  Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* objc-act.c (build_private_template): Change to return 'void'; do\n+\tnot set ivar_context, uprivate_record or objc_instance_type.\n+\t(objc_comptypes, gen_type_name_0): For types 'id' and 'Class',\n+\tretrieve protocol list from the pointee rather than the pointer itself;\n+\tcheck TYPE_HAS_OBJC_INFO(...) precondition before accessing\n+\tTYPE_OBJC_PROTOCOL_LIST.\n+\t(objc_get_protocol_qualified_type): For types 'id' and 'Class',\n+\tconstruct a variant of the pointee as well as the pointer, and\n+\tstore protocol information in the former.  When creating variants\n+\tof RECORD_TYPEs, clone their TYPE_LANG_SPECIFIC fields and propagate\n+\tTYPE_OBJC_INTERFACE information.\n+\t(objc_declare_class): If a TYPE_DECL is looked up, retrieve the\n+\tunderlying RECORD_TYPE to check for presence of TYPE_OBJC_INTERFACE;\n+\tfor newly-created RECORD_TYPEs, create a tentative TYPE_OBJC_INTERFACE\n+\tholding an IDENTIFIER_NODE.\n+\t(objc_finish_message_expr): Check TYPE_HAS_OBJC_INFO(...) before\n+\taccessing TYPE_OBJC_PROTOCOL_LIST; Use TYPE_OBJC_INTERFACE instead\n+\tof calling lookup_interface(); allow for TYPE_OBJC_INTERFACE holding\n+\tan IDENTIFIER_NODE (meaning a @class forward-declaration only).\n+\t(objc_is_public): Check TYPE_OBJC_INTERFACE instead of calling\n+\tlookup_interface().\n+\t(continue_class): For @implementations, set ivar_context,\n+\tuprivate_record and objc_instance_type, for @interfaces, call\n+\tbuild_private_template().\n+\t(encode_pointer): Check TYPE_HAS_OBJC_INFO(...) before accessing\n+\tTYPE_OBJC_INTERFACE.\n+\t(objc_types_are_equivalent): Check TYPE_HAS_OBJC_INFO(...) before\n+\taccessing TYPE_OBJC_PROTOCOL_LIST.\n+\t* objc-act.h (OBJC_INFO_SLOT_ELTS, TYPE_OBJC_INFO, INIT_TYPE_OBJC_INFO,\n+\tDUP_TYPE_OBJC_INFO, ALLOC_OBJC_TYPE_LANG_SPECIFIC, \n+\tSIZEOF_OBJC_TYPE_LANG_SPECIFIC): New macros.\n+\t(TYPE_OBJC_INTERFACE): Replaces TREE_STATIC_INSTANCE and now points\n+\tto an actual @interface; stored in TYPE_LANG_SPECIFIC(...).\n+\t(TYPE_OBJC_PROTOCOL_LIST): Replaces TYPE_PROTOCOL_LIST; stored in\n+\tTYPE_LANG_SPECIFIC(...).\n+\t(TREE_STATIC_INSTANCE, TYPE_PROTOCOL_LIST): Delete.\n+\t(IS_ID, IS_CLASS, IS_PROTOCOL_QUALIFIED_UNTYPED, IS_SUPER,\n+\tTYPED_OBJECT): Check for POINTER_TYPE rather than POINTER_TYPE_P;\n+\tadjust for use of TYPE_OBJC_INTERFACE and TYPE_OBJC_PROTOCOL_LIST\n+\tinstead of TREE_STATIC_INSTANCE and TYPE_PROTOCOL_LIST.\n+\n 2004-11-29  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/7544"}, {"sha": "b77e44145824691cce8ece59201c81a28ee6bb3c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 86, "deletions": 67, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "patch": "@@ -176,7 +176,7 @@ static void build_next_objc_exception_stuff (void);\n \n static tree build_ivar_template (void);\n static tree build_method_template (void);\n-static tree build_private_template (tree);\n+static void build_private_template (tree);\n static void build_class_template (void);\n static void build_selector_template (void);\n static void build_category_template (void);\n@@ -874,7 +874,7 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \n       if (lhs_is_proto)\n         {\n-\t  tree lproto, lproto_list = TYPE_PROTOCOL_LIST (lhs);\n+\t  tree lproto, lproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (lhs));\n \t  tree rproto, rproto_list;\n \t  tree p;\n \n@@ -886,7 +886,7 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t      if (IS_ID (lhs) != IS_ID (rhs))\n \t\treturn 0;\n \n-\t      rproto_list = TYPE_PROTOCOL_LIST (rhs);\n+\t      rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n \n \t      if (!reflexive)\n \t\t{\n@@ -972,9 +972,9 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t\t\t the protocol we're looking for, check for \"one-off\"\n \t\t\t protocols (e.g., `NSObject<MyProt> *foo;') attached\n \t\t\t to the rhs.  */\n-\t\t      if (!rproto)\n+\t\t      if (!rproto && TYPE_HAS_OBJC_INFO (TREE_TYPE (rhs)))\n \t\t\t{\n-\t\t\t  rproto_list = TYPE_PROTOCOL_LIST (TREE_TYPE (rhs));\n+\t\t\t  rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n \t\t\t  rproto = lookup_protocol_in_reflist (rproto_list, p);\n \t\t\t}\n \n@@ -1023,7 +1023,7 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t\t{\n \t\t  tree rname = OBJC_TYPE_NAME (TREE_TYPE (lhs));\n \t\t  tree rinter;\n-\t\t  tree rproto, rproto_list = TYPE_PROTOCOL_LIST (rhs);\n+\t\t  tree rproto, rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n \n \t\t  /* Make sure the protocol is supported by the object on\n \t\t     the lhs.  */\n@@ -1045,9 +1045,9 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t\t\t     check for \"one-off\" protocols (e.g.,\n \t\t\t     `NSObject<MyProt> *foo;') attached to the\n \t\t\t     lhs.  */\n-\t\t\t  if (!lproto)\n+\t\t\t  if (!lproto && TYPE_HAS_OBJC_INFO (TREE_TYPE (lhs)))\n \t\t\t    {\n-\t\t\t      lproto_list = TYPE_PROTOCOL_LIST\n+\t\t\t      lproto_list = TYPE_OBJC_PROTOCOL_LIST\n \t\t\t\t(TREE_TYPE (lhs));\n \t\t\t      lproto = lookup_protocol_in_reflist\n \t\t\t\t(lproto_list, p);\n@@ -1185,11 +1185,11 @@ objc_check_decl (tree decl)\n tree\n objc_get_protocol_qualified_type (tree interface, tree protocols)\n {\n-  tree type;\n+  /* If INTERFACE is not provided, default to 'id'.  */\n+  tree type = (interface ? objc_is_id (interface) : objc_object_type);\n+  bool is_ptr = (type != NULL_TREE);\n \n-  if (!interface)\n-    type = objc_object_type;\n-  else if (!(type = objc_is_id (interface)))\n+  if (!is_ptr)\n     {\n       type = objc_is_class_name (interface);\n \n@@ -1202,13 +1202,27 @@ objc_get_protocol_qualified_type (tree interface, tree protocols)\n   if (protocols)\n     {\n       type = build_variant_type_copy (type);\n-      /* Look up protocols and install in lang specific list.  Note\n-\t that the protocol list can have a different lifetime than T!  */\n-      SET_TYPE_PROTOCOL_LIST (type, lookup_and_install_protocols (protocols));\n \n-      /* Establish the ObjC-ness of this record.  */\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\tTREE_STATIC_TEMPLATE (type) = 1;\n+      /* For pointers (i.e., 'id' or 'Class'), attach the protocol(s)\n+\t to the pointee.  */\n+      if (is_ptr)\n+\t{\n+\t  TREE_TYPE (type) = build_variant_type_copy (TREE_TYPE (type));\n+\t  TYPE_POINTER_TO (TREE_TYPE (type)) = type;\n+\t  type = TREE_TYPE (type);\n+\t}\n+\n+      /* Look up protocols and install in lang specific list.  */\n+      DUP_TYPE_OBJC_INFO (type, TYPE_MAIN_VARIANT (type));\n+      TYPE_OBJC_PROTOCOL_LIST (type) = lookup_and_install_protocols (protocols);\n+\n+      /* For RECORD_TYPEs, point to the @interface; for 'id' and 'Class',\n+\t return the pointer to the new pointee variant.  */\n+      if (is_ptr)\n+\ttype = TYPE_POINTER_TO (type);\n+      else\n+\tTYPE_OBJC_INTERFACE (type)\n+\t  = TYPE_OBJC_INTERFACE (TYPE_MAIN_VARIANT (type));\n     }\n \n   return type;\n@@ -2661,18 +2675,26 @@ objc_declare_class (tree ident_list)\n \n       if (! objc_is_class_name (ident))\n \t{\n-\t  tree record = lookup_name (ident);\n-\t\n-\t  if (record && ! TREE_STATIC_TEMPLATE (record))\n+\t  tree record = lookup_name (ident), type = record;\n+\n+\t  if (record)\n \t    {\n-\t      error (\"%qs redeclared as different kind of symbol\",\n-\t\t     IDENTIFIER_POINTER (ident));\n-\t      error (\"%Jprevious declaration of '%D'\",\n-\t\t     record, record);\n+\t      if (TREE_CODE (record) == TYPE_DECL)\n+\t\ttype = DECL_ORIGINAL_TYPE (record);\n+\n+\t      if (!TYPE_HAS_OBJC_INFO (type)\n+\t\t  || !TYPE_OBJC_INTERFACE (type))\n+\t\t{\n+\t\t  error (\"%qs redeclared as different kind of symbol\",\n+\t\t\t IDENTIFIER_POINTER (ident));\n+\t\t  error (\"%Jprevious declaration of '%D'\",\n+\t\t\t record, record);\n+\t\t}\n \t    }\n \n \t  record = xref_tag (RECORD_TYPE, ident);\n-\t  TREE_STATIC_TEMPLATE (record) = 1;\n+\t  INIT_TYPE_OBJC_INFO (record);\n+\t  TYPE_OBJC_INTERFACE (record) = ident;\n \t  class_chain = tree_cons (NULL_TREE, ident, class_chain);\n \t}\n     }\n@@ -3484,38 +3506,27 @@ build_objc_exception_stuff (void)\n \t\t\tNULL, nothrow_list);\n }\n \n+/* Construct a C struct corresponding to ObjC class CLASS, with the same\n+   name as the class:\n \n-/* struct <classname> {\n+   struct <classname> {\n      struct _objc_class *isa;\n      ...\n    };  */\n \n-static tree\n+static void\n build_private_template (tree class)\n {\n-  tree ivar_context;\n-\n-  if (CLASS_STATIC_TEMPLATE (class))\n+  if (!CLASS_STATIC_TEMPLATE (class))\n     {\n-      uprivate_record = CLASS_STATIC_TEMPLATE (class);\n-      ivar_context = TYPE_FIELDS (CLASS_STATIC_TEMPLATE (class));\n-    }\n-  else\n-    {\n-      uprivate_record = start_struct (RECORD_TYPE, CLASS_NAME (class));\n-      ivar_context = get_class_ivars (class);\n-\n-      finish_struct (uprivate_record, ivar_context, NULL_TREE);\n-\n-      CLASS_STATIC_TEMPLATE (class) = uprivate_record;\n+      tree record = start_struct (RECORD_TYPE, CLASS_NAME (class));\n \n+      finish_struct (record, get_class_ivars (class), NULL_TREE);\n       /* mark this record as class template - for class type checking */\n-      TREE_STATIC_TEMPLATE (uprivate_record) = 1;\n+      INIT_TYPE_OBJC_INFO (record);\n+      TYPE_OBJC_INTERFACE (record) = class;\n+      CLASS_STATIC_TEMPLATE (class) = record;\n     }\n-\n-  objc_instance_type = build_pointer_type (uprivate_record);\n-\n-  return ivar_context;\n }\n \f\n /* Begin code generation for protocols...  */\n@@ -5574,7 +5585,9 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n       else\n \t{\n \t  class_tree = (IS_CLASS (rtype) ? objc_class_name : NULL_TREE);\n-\t  rprotos = TYPE_PROTOCOL_LIST (rtype);\n+\t  rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n+\t\t     ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n+\t\t     : NULL_TREE);\n \t  rtype = NULL_TREE;\n \t}\n \n@@ -5615,14 +5628,14 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n       saved_rtype = rtype;\n       if (TYPED_OBJECT (rtype))\n \t{\n-\t  rprotos = TYPE_PROTOCOL_LIST (rtype);\n-\t  rtype = lookup_interface (OBJC_TYPE_NAME (rtype));\n+\t  rprotos = TYPE_OBJC_PROTOCOL_LIST (rtype);\n+\t  rtype = TYPE_OBJC_INTERFACE (rtype);\n \t}\n       /* If we could not find an @interface declaration, we must have\n \t only seen a @class declaration; so, we cannot say anything\n \t more intelligent about which methods the receiver will\n \t understand. */\n-      if (!rtype)\n+      if (!rtype || TREE_CODE (rtype) == IDENTIFIER_NODE)\n \trtype = saved_rtype;\n       else if (TREE_CODE (rtype) == CLASS_INTERFACE_TYPE\n \t  || TREE_CODE (rtype) == CLASS_IMPLEMENTATION_TYPE)\n@@ -6355,9 +6368,9 @@ objc_is_public (tree expr, tree identifier)\n \n   if (code == RECORD_TYPE)\n     {\n-      if (TREE_STATIC_TEMPLATE (basetype))\n+      if (TYPE_HAS_OBJC_INFO (basetype) && TYPE_OBJC_INTERFACE (basetype))\n \t{\n-\t  if (!lookup_interface (OBJC_TYPE_NAME (basetype)))\n+\t  if (TREE_CODE (TYPE_OBJC_INTERFACE (basetype)) == IDENTIFIER_NODE)\n \t    {\n \t      error (\"cannot find interface declaration for %qs\",\n \t\t     IDENTIFIER_POINTER (OBJC_TYPE_NAME (basetype)));\n@@ -6791,7 +6804,10 @@ continue_class (tree class)\n       push_lang_context (lang_name_c);\n #endif\n \n-      ivar_context = build_private_template (implementation_template);\n+      build_private_template (implementation_template);\n+      uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);\n+      ivar_context = TYPE_FIELDS (uprivate_record);\n+      objc_instance_type = build_pointer_type (uprivate_record);\n \n       imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));\n \n@@ -6823,15 +6839,7 @@ continue_class (tree class)\n       push_lang_context (lang_name_c);\n #endif /* OBJCPLUS */\n \n-      if (!CLASS_STATIC_TEMPLATE (class))\n-\t{\n-\t  tree record = start_struct (RECORD_TYPE, CLASS_NAME (class));\n-\t  finish_struct (record, get_class_ivars (class), NULL_TREE);\n-\t  CLASS_STATIC_TEMPLATE (class) = record;\n-\n-\t  /* Mark this record as a class template for static typing.  */\n-\t  TREE_STATIC_TEMPLATE (record) = 1;\n-\t}\n+      build_private_template (class);\n \n #ifdef OBJCPLUS\n       pop_lang_context ();\n@@ -7028,7 +7036,8 @@ encode_pointer (tree type, int curtype, int format)\n \t      obstack_1grow (&util_obstack, '@');\n \t      return;\n \t    }\n-\t  else if (TREE_STATIC_TEMPLATE (pointer_to))\n+\t  else if (TYPE_HAS_OBJC_INFO (pointer_to)\n+\t\t   && TYPE_OBJC_INTERFACE (pointer_to))\n \t    {\n               if (generating_instance_variables)\n \t        {\n@@ -7514,8 +7523,13 @@ objc_types_are_equivalent (tree type1, tree type2)\n   if (TYPE_MAIN_VARIANT (type1) != TYPE_MAIN_VARIANT (type2))\n     return 0;\n \n-  type1 = TYPE_PROTOCOL_LIST (type1);\n-  type2 = TYPE_PROTOCOL_LIST (type2);\n+  type1 = (TYPE_HAS_OBJC_INFO (type1)\n+\t   ? TYPE_OBJC_PROTOCOL_LIST (type1)\n+\t   : NULL_TREE);\n+  type2 = (TYPE_HAS_OBJC_INFO (type2)\n+\t   ? TYPE_OBJC_PROTOCOL_LIST (type2)\n+\t   : NULL_TREE);\n+\n   if (list_length (type1) == list_length (type2))\n     {\n       for (; type2; type2 = TREE_CHAIN (type2))\n@@ -7942,7 +7956,12 @@ gen_type_name_0 (tree type)\n     type = DECL_NAME (type);\n \n   strcat (errbuf, IDENTIFIER_POINTER (type));\n-  proto = TYPE_PROTOCOL_LIST (orig);\n+\n+  /* For 'id' and 'Class', adopted protocols are stored in the pointee.  */\n+  if (objc_is_id (orig))\n+    orig = TREE_TYPE (orig);\n+  \n+  proto = TYPE_HAS_OBJC_INFO (orig) ? TYPE_OBJC_PROTOCOL_LIST (orig) : NULL_TREE;\n \n   if (proto)\n     {"}, {"sha": "e52e0f003fbeb415081417fa182fc97b4335fa07", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035e8f01490bdd11ac29dfc07e79e7975d2c53cc/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=035e8f01490bdd11ac29dfc07e79e7975d2c53cc", "patch": "@@ -36,6 +36,7 @@ tree objc_fold_obj_type_ref (tree, tree);\n \n #define CLASS_LANG_SLOT_ELTS\t\t5\n #define PROTOCOL_LANG_SLOT_ELTS\t\t2\n+#define OBJC_INFO_SLOT_ELTS\t\t2\n \n /* KEYWORD_DECL */\n #define KEYWORD_KEY_NAME(DECL) ((DECL)->decl.name)\n@@ -67,19 +68,51 @@ tree objc_fold_obj_type_ref (tree, tree);\n #define PROTOCOL_FORWARD_DECL(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 1)\n #define PROTOCOL_DEFINED(CLASS) TREE_USED (CLASS)\n \n-/* We need to distinguish TYPE_PROTOCOL_LISTs from TYPE_CONTEXTs, both of which\n-   are stored in the same accessor slot.  */\n-#define TYPE_PROTOCOL_LIST(TYPE)\t\t\t\t\\\n-\t((TYPE_CHECK (TYPE)->type.context\t\t\t\\\n-\t  && TREE_CODE ((TYPE)->type.context) == TREE_LIST)\t\\\n-\t ? (TYPE)->type.context : NULL_TREE)\n-#define SET_TYPE_PROTOCOL_LIST(TYPE, P) (TYPE_CHECK (TYPE)->type.context = (P))\n-\n-#define TREE_STATIC_TEMPLATE(record_type) (TREE_PUBLIC (record_type))\n-#define TYPED_OBJECT(type) \\\n-       (TREE_CODE (type) == RECORD_TYPE && TREE_STATIC_TEMPLATE (type))\n-#define OBJC_TYPE_NAME(type) TYPE_NAME(type)\n-#define OBJC_SET_TYPE_NAME(type, name) (TYPE_NAME (type) = name)\n+/* ObjC-specific information pertaining to RECORD_TYPEs are stored in\n+   the LANG_SPECIFIC structures, which may itself need allocating first.  */\n+#define TYPE_OBJC_INFO(TYPE) TYPE_LANG_SPECIFIC (TYPE)->objc_info\n+#define TYPE_HAS_OBJC_INFO(TYPE)\t\t\t\t\\\n+\t(TYPE_LANG_SPECIFIC (TYPE)\t\t\t\t\\\n+\t && TYPE_LANG_SPECIFIC (TYPE)->objc_info)\n+#define TYPE_OBJC_INTERFACE(TYPE) TREE_VEC_ELT (TYPE_OBJC_INFO (TYPE), 0)\n+#define TYPE_OBJC_PROTOCOL_LIST(TYPE) TREE_VEC_ELT (TYPE_OBJC_INFO (TYPE), 1)\n+\n+#define INIT_TYPE_OBJC_INFO(TYPE)\t\t\t\t\\\n+\tdo\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    if (!TYPE_LANG_SPECIFIC (TYPE))\t\t\t\\\n+\t      TYPE_LANG_SPECIFIC (TYPE)\t\t\t\t\\\n+\t\t= ALLOC_OBJC_TYPE_LANG_SPECIFIC;\t\t\t\\\n+\t    if (!TYPE_LANG_SPECIFIC (TYPE)->objc_info)\t\t\\\n+\t      TYPE_LANG_SPECIFIC (TYPE)->objc_info\t\t\\\n+\t\t= make_tree_vec (OBJC_INFO_SLOT_ELTS);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\twhile (0)\n+#define DUP_TYPE_OBJC_INFO(DST, SRC)\t\t\t\t\\\n+\tdo\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    TYPE_LANG_SPECIFIC (DST)\t\t\t\t\\\n+\t      = ALLOC_OBJC_TYPE_LANG_SPECIFIC;\t\t\t\\\n+\t    if (TYPE_LANG_SPECIFIC (SRC))\t\t\t\\\n+\t      memcpy (TYPE_LANG_SPECIFIC (DST),\t\t\t\\\n+\t\t      TYPE_LANG_SPECIFIC (SRC),\t\t\t\\\n+\t\t      SIZEOF_OBJC_TYPE_LANG_SPECIFIC);\t\t\\\n+\t    TYPE_LANG_SPECIFIC (DST)->objc_info\t\t\t\\\n+\t      = make_tree_vec (OBJC_INFO_SLOT_ELTS);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\twhile (0)\n+\n+/* The following two macros must be overridden (in objcp/objcp-decl.h)\n+   for Objective-C++.  */\n+#define ALLOC_OBJC_TYPE_LANG_SPECIFIC\tGGC_CNEW (struct lang_type)\n+#define SIZEOF_OBJC_TYPE_LANG_SPECIFIC\tsizeof (struct lang_type)\n+\n+#define TYPED_OBJECT(TYPE)\t\t\t\t\t\\\n+\t(TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\\\n+\t && TYPE_HAS_OBJC_INFO (TYPE)\t\t\t\t\\\n+\t && TYPE_OBJC_INTERFACE (TYPE))\n+#define OBJC_TYPE_NAME(TYPE) TYPE_NAME(TYPE)\n+#define OBJC_SET_TYPE_NAME(TYPE, NAME) (TYPE_NAME (TYPE) = NAME)\n \n /* Define the Objective-C or Objective-C++ language-specific tree codes.  */\n \n@@ -273,14 +306,21 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \n /* Type checking macros.  */\n \n-#define IS_ID(TYPE) \\\n-  (POINTER_TYPE_P (TYPE) && TREE_TYPE (TYPE) == TREE_TYPE (objc_object_type))\n-#define IS_CLASS(TYPE) \\\n-  (POINTER_TYPE_P (TYPE) && TREE_TYPE (TYPE) == TREE_TYPE (objc_class_type))\n-#define IS_PROTOCOL_QUALIFIED_UNTYPED(TYPE) \\\n-  ((IS_ID (TYPE) || IS_CLASS (TYPE)) && TYPE_PROTOCOL_LIST (TYPE))\n-#define IS_SUPER(TYPE) \\\n-  (POINTER_TYPE_P (TYPE) && TREE_TYPE (TYPE) == objc_super_template)\n+#define IS_ID(TYPE)\t\t\t\t\t\t\t\\\n+\t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n+\t && (TYPE_MAIN_VARIANT (TREE_TYPE (TYPE))\t\t\t\\\n+\t     == TREE_TYPE (objc_object_type)))\n+#define IS_CLASS(TYPE)\t\t\t\t\t\t\t\\\n+\t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n+\t && (TYPE_MAIN_VARIANT (TREE_TYPE (TYPE))\t\t\t\\\n+\t     == TREE_TYPE (objc_class_type)))\n+#define IS_PROTOCOL_QUALIFIED_UNTYPED(TYPE)\t\t\t\t\\\n+\t((IS_ID (TYPE) || IS_CLASS (TYPE))\t\t\t\t\\\n+\t && TYPE_HAS_OBJC_INFO (TREE_TYPE (TYPE))\t\t\t\\\n+\t && TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (TYPE)))\n+#define IS_SUPER(TYPE)\t\t\t\t\t\t\t\\\n+\t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n+\t && TREE_TYPE (TYPE) == objc_super_template)\n \n #define class_chain\t\tobjc_global_trees[OCTI_CLS_CHAIN]\n #define alias_chain\t\tobjc_global_trees[OCTI_ALIAS_CHAIN]"}]}