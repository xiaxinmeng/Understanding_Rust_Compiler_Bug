{"sha": "9cdcebf971e71e69a773d729b97cfb55652cca31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkY2ViZjk3MWU3MWU2OWE3NzNkNzI5Yjk3Y2ZiNTU2NTJjY2EzMQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-11-20T14:20:08Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-11-20T14:20:08Z"}, "message": "tree-predcom.c: Add general comment on Store-Store chains.\n\n\t* tree-predcom.c: Add general comment on Store-Store chains.\n\t(split_data_refs_to_components): Postpone clearing eliminate_store_p\n\tflag in component.\n\t(get_chain_last_ref_at): Rename into...\n\t(get_chain_last_write_at): ...this.\n\t(get_chain_last_write_before_load): New function.\n\t(add_ref_to_chain): Promote type of chain from CT_STORE_LOAD to\n\tCT_STORE_STORE when write reference is added.\n\t(determine_roots_comp): Support load ref in CT_STORE_STORE chains.\n\t(is_inv_store_elimination_chain): Update get_chain_last_write_at call.\n\t(initialize_root_vars_store_elim_1): Ditto.\n\t(initialize_root_vars_store_elim_2): Ditto.  Replace rhs once default\n\tdefinition is created.\n\t(execute_pred_commoning_chain): Support load ref in CT_STORE_STORE\n\tchain by replacing it with dominant stored value.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/predcom-dse-12.c: New test.\n\nFrom-SVN: r254956", "tree": {"sha": "9ce904293837925904cc45a82747acaecf2be5be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ce904293837925904cc45a82747acaecf2be5be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cdcebf971e71e69a773d729b97cfb55652cca31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cdcebf971e71e69a773d729b97cfb55652cca31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cdcebf971e71e69a773d729b97cfb55652cca31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cdcebf971e71e69a773d729b97cfb55652cca31/comments", "author": null, "committer": null, "parents": [{"sha": "90ef577378e880769532ef1f68d7d3da4c2661e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ef577378e880769532ef1f68d7d3da4c2661e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ef577378e880769532ef1f68d7d3da4c2661e7"}], "stats": {"total": 200, "additions": 177, "deletions": 23}, "files": [{"sha": "adba88722611b912add3605e488283b9ee494c8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cdcebf971e71e69a773d729b97cfb55652cca31", "patch": "@@ -1,3 +1,21 @@\n+2017-11-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-predcom.c: Add general comment on Store-Store chains.\n+\t(split_data_refs_to_components): Postpone clearing eliminate_store_p\n+\tflag in component.\n+\t(get_chain_last_ref_at): Rename into...\n+\t(get_chain_last_write_at): ...this.\n+\t(get_chain_last_write_before_load): New function.\n+\t(add_ref_to_chain): Promote type of chain from CT_STORE_LOAD to\n+\tCT_STORE_STORE when write reference is added.\n+\t(determine_roots_comp): Support load ref in CT_STORE_STORE chains.\n+\t(is_inv_store_elimination_chain): Update get_chain_last_write_at call.\n+\t(initialize_root_vars_store_elim_1): Ditto.\n+\t(initialize_root_vars_store_elim_2): Ditto.  Replace rhs once default\n+\tdefinition is created.\n+\t(execute_pred_commoning_chain): Support load ref in CT_STORE_STORE\n+\tchain by replacing it with dominant stored value.\n+\n 2017-11-20  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-predcom.c (add_ref_to_chain): Remove check on distance."}, {"sha": "85e4c71e8b5480d91c8bee28da61768ce48bf087", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9cdcebf971e71e69a773d729b97cfb55652cca31", "patch": "@@ -1,3 +1,7 @@\n+2017-11-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/predcom-dse-12.c: New test.\n+\n 2017-11-20  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR testsuite/82951"}, {"sha": "510c600f574acff266f9aee546a04fa659dd64c3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-12.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-12.c?ref=9cdcebf971e71e69a773d729b97cfb55652cca31", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, -1, 5, -2, 11, 0};\n+int result2[10] = {0, 0, -1, -2, -2, 0};\n+int result3[10] = {0, 0, 0, -1, -2, -2, 0};\n+int result4[10] = {0, 0, 0, 0, -1, -2, -2, 0};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -2, 0};\n+\n+extern void abort (void);\n+int sum;\n+\n+void __attribute__((noinline)) foo (int * restrict a, int len, int t1, int t2)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = t1;\n+      a[i + 3] = t2;\n+      a[i + 1] = -1;\n+      sum = sum + a[i] + a[i + 3];\n+    }\n+}\n+\n+void check (int *a, int *res, int len, int sval)\n+{\n+  int i;\n+\n+  if (sum != sval)\n+    abort ();\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0, 0, -2);\n+  check (arr, result0, 10, 0);\n+\n+  foo (arr, 1, 0, -2);\n+  check (arr, result1, 10, -2);\n+\n+  foo (arr, 2, 0, -2);\n+  check (arr, result2, 10, -6);\n+\n+  foo (arr, 3, 0, -2);\n+  check (arr, result3, 10, -12);\n+\n+  foo (arr, 4, 0, -2);\n+  check (arr, result4, 10, -20);\n+\n+  foo (arr, 100, 0, -2);\n+  check (arr, result100, 105, -220);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "dde903794fd547716b23bad8133b8810f4eda955", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 88, "deletions": 23, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cdcebf971e71e69a773d729b97cfb55652cca31/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=9cdcebf971e71e69a773d729b97cfb55652cca31", "patch": "@@ -192,6 +192,10 @@ along with GCC; see the file COPYING3.  If not see\n    The interesting part is this can be viewed either as general store motion\n    or general dead store elimination in either intra/inter-iterations way.\n \n+   With trivial effort, we also support load inside Store-Store chains if the\n+   load is dominated by a store statement in the same iteration of loop.  You\n+   can see this as a restricted Store-Mixed-Load-Store chain.\n+\n    TODO: For now, we don't support store-store chains in multi-exit loops.  We\n    force to not unroll in case of store-store chain even if other chains might\n    ask for unroll.\n@@ -902,8 +906,6 @@ split_data_refs_to_components (struct loop *loop,\n \t\t\t\tgimple_bb (dataref->stmt));\n       dataref->pos = comp->refs.length ();\n       comp->refs.quick_push (dataref);\n-      if (DR_IS_READ (dr))\n-\tcomp->eliminate_store_p = false;\n     }\n \n   for (i = 0; i < n; i++)\n@@ -1039,19 +1041,36 @@ get_chain_root (chain_p chain)\n   return chain->refs[0];\n }\n \n-/* Given CHAIN, returns the last ref at DISTANCE, or NULL if it doesn't\n+/* Given CHAIN, returns the last write ref at DISTANCE, or NULL if it doesn't\n    exist.  */\n \n static inline dref\n-get_chain_last_ref_at (chain_p chain, unsigned distance)\n+get_chain_last_write_at (chain_p chain, unsigned distance)\n {\n-  unsigned i;\n+  for (unsigned i = chain->refs.length (); i > 0; i--)\n+    if (DR_IS_WRITE (chain->refs[i - 1]->ref)\n+\t&& distance == chain->refs[i - 1]->distance)\n+      return chain->refs[i - 1];\n \n-  for (i = chain->refs.length (); i > 0; i--)\n-    if (distance == chain->refs[i - 1]->distance)\n-      break;\n+  return NULL;\n+}\n+\n+/* Given CHAIN, returns the last write ref with the same distance before load\n+   at index LOAD_IDX, or NULL if it doesn't exist.  */\n+\n+static inline dref\n+get_chain_last_write_before_load (chain_p chain, unsigned load_idx)\n+{\n+  gcc_assert (load_idx < chain->refs.length ());\n \n-  return (i > 0) ? chain->refs[i - 1] : NULL;\n+  unsigned distance = chain->refs[load_idx]->distance;\n+\n+  for (unsigned i = load_idx; i > 0; i--)\n+    if (DR_IS_WRITE (chain->refs[i - 1]->ref)\n+\t&& distance == chain->refs[i - 1]->distance)\n+      return chain->refs[i - 1];\n+\n+  return NULL;\n }\n \n /* Adds REF to the chain CHAIN.  */\n@@ -1075,6 +1094,10 @@ add_ref_to_chain (chain_p chain, dref ref)\n       chain->has_max_use_after = false;\n     }\n \n+  /* Promote this chain to CT_STORE_STORE if it has multiple stores.  */\n+  if (DR_IS_WRITE (ref->ref))\n+    chain->type = CT_STORE_STORE;\n+\n   /* Don't set the flag for store-store chain since there is no use.  */\n   if (chain->type != CT_STORE_STORE\n       && ref->distance == chain->length\n@@ -1347,9 +1370,29 @@ determine_roots_comp (struct loop *loop,\n     }\n \n   comp->refs.qsort (order_drefs);\n+\n+  /* For Store-Store chain, we only support load if it is dominated by a\n+     store statement in the same iteration of loop.  */\n+  if (comp->eliminate_store_p)\n+    for (a = NULL, i = 0; i < comp->refs.length (); i++)\n+      {\n+\tif (DR_IS_WRITE (comp->refs[i]->ref))\n+\t  a = comp->refs[i];\n+\telse if (a == NULL || a->offset != comp->refs[i]->offset)\n+\t  {\n+\t    /* If there is load that is not dominated by a store in the\n+\t       same iteration of loop, clear the flag so no Store-Store\n+\t       chain is generated for this component.  */\n+\t    comp->eliminate_store_p = false;\n+\t    break;\n+\t  }\n+      }\n+\n+  /* Determine roots and create chains for components.  */\n   FOR_EACH_VEC_ELT (comp->refs, i, a)\n     {\n       if (!chain\n+\t  || (chain->type == CT_LOAD && DR_IS_WRITE (a->ref))\n \t  || (!comp->eliminate_store_p && DR_IS_WRITE (a->ref))\n \t  || wi::leu_p (MAX_DISTANCE, a->offset - last_ofs))\n \t{\n@@ -1361,11 +1404,11 @@ determine_roots_comp (struct loop *loop,\n \t  else\n \t    release_chain (chain);\n \n-\t  if (DR_IS_READ (a->ref))\n-\t    type = CT_LOAD;\n-\t  else\n-\t    type = comp->eliminate_store_p ? CT_STORE_STORE : CT_STORE_LOAD;\n-\n+\t  /* Determine type of the chain.  If the root reference is a load,\n+\t     this can only be a CT_LOAD chain; other chains are intialized\n+\t     to CT_STORE_LOAD and might be promoted to CT_STORE_STORE when\n+\t     new reference is added.  */\n+\t  type = DR_IS_READ (a->ref) ? CT_LOAD : CT_STORE_LOAD;\n \t  chain = make_rooted_chain (a, type);\n \t  last_ofs = a->offset;\n \t  continue;\n@@ -1676,7 +1719,7 @@ is_inv_store_elimination_chain (struct loop *loop, chain_p chain)\n      values.  */\n   for (unsigned i = 0; i < chain->length; i++)\n     {\n-      dref a = get_chain_last_ref_at (chain, i);\n+      dref a = get_chain_last_write_at (chain, i);\n       if (a == NULL)\n \tcontinue;\n \n@@ -1720,7 +1763,7 @@ initialize_root_vars_store_elim_1 (chain_p chain)\n   /* Initialize root value for eliminated stores at each distance.  */\n   for (i = 0; i < n; i++)\n     {\n-      dref a = get_chain_last_ref_at (chain, i);\n+      dref a = get_chain_last_write_at (chain, i);\n       if (a == NULL)\n \tcontinue;\n \n@@ -1783,10 +1826,13 @@ initialize_root_vars_store_elim_2 (struct loop *loop,\n \t{\n \t  /* Root value is rhs operand of the store to be eliminated if\n \t     it isn't loaded from memory before loop.  */\n-\t  dref a = get_chain_last_ref_at (chain, i);\n+\t  dref a = get_chain_last_write_at (chain, i);\n \t  val = gimple_assign_rhs1 (a->stmt);\n \t  if (TREE_CLOBBER_P (val))\n-\t    val = get_or_create_ssa_default_def (cfun, SSA_NAME_VAR (var));\n+\t    {\n+\t      val = get_or_create_ssa_default_def (cfun, SSA_NAME_VAR (var));\n+\t      gimple_assign_set_rhs1 (a->stmt, val);\n+\t    }\n \n \t  vtemps[n - i - 1] = val;\n \t}\n@@ -2054,7 +2100,7 @@ static void\n execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n \t\t\t      bitmap tmp_vars)\n {\n-  unsigned i, n;\n+  unsigned i;\n   dref a;\n   tree var;\n   bool in_lhs;\n@@ -2091,10 +2137,29 @@ execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n \t  finalize_eliminated_stores (loop, chain);\n \t}\n \n-      /* Eliminate the stores killed by following store.  */\n-      n = chain->refs.length ();\n-      for (i = 0; i < n - 1; i++)\n-\tremove_stmt (chain->refs[i]->stmt);\n+      bool last_store_p = true;\n+      for (i = chain->refs.length (); i > 0; i--)\n+\t{\n+\t  a = chain->refs[i - 1];\n+\t  /* Preserve the last store of the chain.  Eliminate other stores\n+\t     which are killed by the last one.  */\n+\t  if (DR_IS_WRITE (a->ref))\n+\t    {\n+\t      if (last_store_p)\n+\t\tlast_store_p = false;\n+\t      else\n+\t\tremove_stmt (a->stmt);\n+\n+\t      continue;\n+\t    }\n+\n+\t  /* Any load in Store-Store chain must be dominated by a previous\n+\t     store, we replace the load reference with rhs of the store.  */\n+\t  dref b = get_chain_last_write_before_load (chain, i - 1);\n+\t  gcc_assert (b != NULL);\n+\t  var = gimple_assign_rhs1 (b->stmt);\n+\t  replace_ref_with (a->stmt, var, false, false);\n+\t}\n     }\n   else\n     {"}]}