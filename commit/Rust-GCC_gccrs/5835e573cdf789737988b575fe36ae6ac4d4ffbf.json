{"sha": "5835e573cdf789737988b575fe36ae6ac4d4ffbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzNWU1NzNjZGY3ODk3Mzc5ODhiNTc1ZmUzNmFlNmFjNGQ0ZmZiZg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1998-02-17T21:35:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-17T21:35:43Z"}, "message": "haifa-sched.c: Include \"system.h\" to get <stdlib.h> and <stdio.h>.\n\n        * haifa-sched.c: Include \"system.h\" to get <stdlib.h> and <stdio.h>.\n        (BLOCKAGE_RANGE): Add parentheses around arithmetic in operand of |.\n        (sched_note_set): Remove unused parameter `b', all callers changed.\n        (schedule_block): Likewise for `rgn'.\n        (split_hard_reg_notes): Likewise for `orig_insn'.\n        (check_live): Likewise for `trg'.\n        (update_live): Likewise.\n        (check_live_1): Explcitly declare variable `i' as int.\n        (update_live_1): Likewise.\n        (insn_issue_delay): Remove unused variable `link'.\n        (sched_analyze_2): Add default case in enumeration switch.\n        (schedule_insns): Remove unused variable `i'.\n\t* Makefile.in ($(SCHED_PREFIX)sched.o): Depend on system.h.\n\nFrom-SVN: r18048", "tree": {"sha": "4cac9ec70867d97625a9642d8825a9345a5213c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cac9ec70867d97625a9642d8825a9345a5213c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5835e573cdf789737988b575fe36ae6ac4d4ffbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5835e573cdf789737988b575fe36ae6ac4d4ffbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5835e573cdf789737988b575fe36ae6ac4d4ffbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5835e573cdf789737988b575fe36ae6ac4d4ffbf/comments", "author": null, "committer": null, "parents": [{"sha": "b1a0c81697656f8d454c20fd996e627e0e4d5399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a0c81697656f8d454c20fd996e627e0e4d5399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1a0c81697656f8d454c20fd996e627e0e4d5399"}], "stats": {"total": 84, "additions": 50, "deletions": 34}, "files": [{"sha": "0fe0f0778a4d9de429653eae1628cc84837f8203", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5835e573cdf789737988b575fe36ae6ac4d4ffbf", "patch": "@@ -1,3 +1,20 @@\n+Tue Feb 17 22:37:22 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* haifa-sched.c: Include \"system.h\" to get <stdlib.h> and <stdio.h>.\n+\t(BLOCKAGE_RANGE): Add parentheses around arithmetic in operand of |.\n+\t(sched_note_set): Remove unused parameter `b', all callers changed.\n+\t(schedule_block): Likewise for `rgn'.\n+\t(split_hard_reg_notes): Likewise for `orig_insn'.\n+\t(check_live): Likewise for `trg'.\n+\t(update_live): Likewise.\n+\t(check_live_1): Explcitly declare variable `i' as int.\n+\t(update_live_1): Likewise.\n+\t(insn_issue_delay): Remove unused variable `link'.\n+\t(sched_analyze_2): Add default case in enumeration switch.\n+\t(schedule_insns): Remove unused variable `i'.\n+\n+\t* Makefile.in ($(SCHED_PREFIX)sched.o): Depend on system.h.\n+\n Tue Feb 17 22:31:04 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* loop.c (rtx_equal_for_loop_p): Add some braces to disambiguate"}, {"sha": "49454108fe36cc82afebe19942320eb98ef1927a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5835e573cdf789737988b575fe36ae6ac4d4ffbf", "patch": "@@ -1415,8 +1415,9 @@ alias.o : alias.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \\\n    insn-codes.h\n regmove.o : regmove.c $(CONFIG_H) $(RTL_H) insn-config.h insn-codes.h \\\n    recog.h output.h reload.h regs.h hard-reg-set.h flags.h expr.h insn-flags.h\n-$(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) $(RTL_H) $(BASIC_BLOCK_H) regs.h hard-reg-set.h \\\n-   flags.h insn-config.h insn-attr.h\n+$(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) $(RTL_H) \\\n+\t$(BASIC_BLOCK_H) regs.h hard-reg-set.h flags.h insn-config.h \\\n+\tinsn-attr.h system.h\n final.o : final.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h regs.h \\\n    $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h output.h \\\n    hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h defaults.h"}, {"sha": "3864270eceacc6fd517cf2450267f931f5b444d9", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5835e573cdf789737988b575fe36ae6ac4d4ffbf/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5835e573cdf789737988b575fe36ae6ac4d4ffbf", "patch": "@@ -154,8 +154,8 @@\n    priorities are computed, and (3) block level: insns in the block\n    are actually scheduled.  */\n \f\n-#include <stdio.h>\n #include \"config.h\"\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n@@ -320,7 +320,7 @@ static unsigned int *insn_blockage;\n #define UNIT_BLOCKED(B) ((B) >> (2 * BLOCKAGE_BITS))\n #define BLOCKAGE_RANGE(B)                                                \\\n   (((((B) >> BLOCKAGE_BITS) & BLOCKAGE_MASK) << (HOST_BITS_PER_INT / 2)) \\\n-   | (B) & BLOCKAGE_MASK)\n+   | ((B) & BLOCKAGE_MASK))\n \n /* Encodings of the `<name>_unit_blockage_range' function.  */\n #define MIN_BLOCKAGE_COST(R) ((R) >> (HOST_BITS_PER_INT / 2))\n@@ -457,7 +457,7 @@ static void sched_analyze_1 PROTO ((rtx, rtx));\n static void sched_analyze_2 PROTO ((rtx, rtx));\n static void sched_analyze_insn PROTO ((rtx, rtx, rtx));\n static void sched_analyze PROTO ((rtx, rtx));\n-static void sched_note_set PROTO ((int, rtx, int));\n+static void sched_note_set PROTO ((rtx, int));\n static int rank_for_schedule PROTO ((rtx *, rtx *));\n static void swap_sort PROTO ((rtx *, int));\n static void queue_insn PROTO ((rtx, int));\n@@ -467,9 +467,9 @@ static void attach_deaths PROTO ((rtx, rtx, int));\n static void attach_deaths_insn PROTO ((rtx));\n static int new_sometimes_live PROTO ((struct sometimes *, int, int));\n static void finish_sometimes_live PROTO ((struct sometimes *, int));\n-static int schedule_block PROTO ((int, int, int));\n+static int schedule_block PROTO ((int, int));\n static rtx regno_use_in PROTO ((int, rtx));\n-static void split_hard_reg_notes PROTO ((rtx, rtx, rtx, rtx));\n+static void split_hard_reg_notes PROTO ((rtx, rtx, rtx));\n static void new_insn_dead_notes PROTO ((rtx, rtx, rtx, rtx));\n static void update_n_sets PROTO ((rtx, int));\n static void update_flow_info PROTO ((rtx, rtx, rtx, rtx));\n@@ -707,8 +707,8 @@ static void compute_dom_prob_ps PROTO ((int));\n /* speculative scheduling functions */\n static int check_live_1 PROTO ((int, rtx));\n static void update_live_1 PROTO ((int, rtx));\n-static int check_live PROTO ((rtx, int, int));\n-static void update_live PROTO ((rtx, int, int));\n+static int check_live PROTO ((rtx, int));\n+static void update_live PROTO ((rtx, int));\n static void set_spec_fed PROTO ((rtx));\n static int is_pfree PROTO ((rtx, int, int));\n static int find_conditional_protection PROTO ((rtx, int));\n@@ -2166,7 +2166,7 @@ check_live_1 (src, x)\n      int src;\n      rtx x;\n {\n-  register i;\n+  register int i;\n   register int regno;\n   register rtx reg = SET_DEST (x);\n \n@@ -2234,7 +2234,7 @@ update_live_1 (src, x)\n      int src;\n      rtx x;\n {\n-  register i;\n+  register int i;\n   register int regno;\n   register rtx reg = SET_DEST (x);\n \n@@ -2287,10 +2287,9 @@ update_live_1 (src, x)\n    ready-list or before the scheduling.  */\n \n static int\n-check_live (insn, src, trg)\n+check_live (insn, src)\n      rtx insn;\n      int src;\n-     int trg;\n {\n   /* find the registers set by instruction */\n   if (GET_CODE (PATTERN (insn)) == SET\n@@ -2316,9 +2315,9 @@ check_live (insn, src, trg)\n    block src to trg.  */\n \n static void\n-update_live (insn, src, trg)\n+update_live (insn, src)\n      rtx insn;\n-     int src, trg;\n+     int src;\n {\n   /* find the registers set by instruction */\n   if (GET_CODE (PATTERN (insn)) == SET\n@@ -2936,7 +2935,6 @@ __inline static int\n insn_issue_delay (insn)\n      rtx insn;\n {\n-  rtx link;\n   int i, delay = 0;\n   int unit = insn_unit (insn);\n \n@@ -3725,6 +3723,9 @@ sched_analyze_2 (x, insn)\n       sched_analyze_2 (XEXP (x, 0), insn);\n       sched_analyze_1 (x, insn);\n       return;\n+\n+    default:\n+      break;\n     }\n \n   /* Other cases: walk the insn.  */\n@@ -4026,8 +4027,7 @@ sched_analyze (head, tail)\n    are scanning forwards.  Mark that register as being born.  */\n \n static void\n-sched_note_set (b, x, death)\n-     int b;\n+sched_note_set (x, death)\n      rtx x;\n      int death;\n {\n@@ -4388,7 +4388,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t\t  || CANT_MOVE (next)\n \t\t  || (IS_SPECULATIVE_INSN (next)\n \t\t      && (insn_issue_delay (next) > 3\n-\t\t\t  || !check_live (next, INSN_BB (next), target_bb)\n+\t\t\t  || !check_live (next, INSN_BB (next))\n \t\t || !is_exception_free (next, INSN_BB (next), target_bb)))))\n \t    continue;\n \n@@ -5178,7 +5178,7 @@ find_pre_sched_live (bb)\n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n \t    {\n-\t      sched_note_set (b, PATTERN (insn), 0);\n+\t      sched_note_set (PATTERN (insn), 0);\n \t      reg_weight++;\n \t    }\n \n@@ -5189,15 +5189,15 @@ find_pre_sched_live (bb)\n \t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n \t\t    || GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n \t\t  {\n-\t\t    sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t    sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \t\t    reg_weight++;\n \t\t  }\n \n \t      /* ??? This code is obsolete and should be deleted.  It\n \t         is harmless though, so we will leave it in for now.  */\n \t      for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == USE)\n-\t\t  sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t  sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \t    }\n \n \t  /* Each call cobbers (makes live) all call-clobbered regs\n@@ -5360,13 +5360,13 @@ find_post_sched_live (bb)\n \n       if (GET_CODE (PATTERN (insn)) == SET\n \t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\tsched_note_set (b, PATTERN (insn), 1);\n+\tsched_note_set (PATTERN (insn), 1);\n       else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t{\n \t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n \t\t|| GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t      sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 1);\n+\t      sched_note_set (XVECEXP (PATTERN (insn), 0, j), 1);\n \t}\n \n       /* This code keeps life analysis information up to date.  */\n@@ -6573,9 +6573,8 @@ group_leader (insn)\n    Return number of insns scheduled.  */\n \n static int\n-schedule_block (bb, rgn, rgn_n_insns)\n+schedule_block (bb, rgn_n_insns)\n      int bb;\n-     int rgn;\n      int rgn_n_insns;\n {\n   /* Local variables.  */\n@@ -6744,7 +6743,7 @@ schedule_block (bb, rgn, rgn_n_insns)\n \t    if (!CANT_MOVE (insn)\n \t\t&& (!IS_SPECULATIVE_INSN (insn)\n \t\t    || (insn_issue_delay (insn) <= 3\n-\t\t\t&& check_live (insn, bb_src, target_bb)\n+\t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n \n \t      {\n@@ -6850,14 +6849,14 @@ schedule_block (bb, rgn, rgn_n_insns)\n \t\t  if (IS_SPECULATIVE_INSN (insn))\n \t\t    {\n \n-\t\t      if (!check_live (insn, INSN_BB (insn), target_bb))\n+\t\t      if (!check_live (insn, INSN_BB (insn)))\n \t\t\t{\n \t\t\t  /* speculative motion, live check failed, remove\n \t\t\t     insn from ready list */\n \t\t\t  ready[i] = ready[--n_ready];\n \t\t\t  continue;\n \t\t\t}\n-\t\t      update_live (insn, INSN_BB (insn), target_bb);\n+\t\t      update_live (insn, INSN_BB (insn));\n \n \t\t      /* for speculative load, mark insns fed by it.  */\n \t\t      if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))\n@@ -7623,7 +7622,7 @@ schedule_region (rgn)\n   /* now we can schedule all blocks */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n-      sched_rgn_n_insns += schedule_block (bb, rgn, rgn_n_insns);\n+      sched_rgn_n_insns += schedule_block (bb, rgn_n_insns);\n \n #ifdef USE_C_ALLOCA\n       alloca (0);\n@@ -7704,8 +7703,8 @@ regno_use_in (regno, x)\n    several smaller hard register references in the split insns.  */\n \n static void\n-split_hard_reg_notes (note, first, last, orig_insn)\n-     rtx note, first, last, orig_insn;\n+split_hard_reg_notes (note, first, last)\n+     rtx note, first, last;\n {\n   rtx reg, temp, link;\n   int n_regs, i, new_reg;\n@@ -7927,7 +7926,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t\t      && GET_CODE (temp) == REG\n \t\t      && REGNO (temp) < FIRST_PSEUDO_REGISTER\n \t\t      && HARD_REGNO_NREGS (REGNO (temp), GET_MODE (temp)) > 1)\n-\t\t    split_hard_reg_notes (note, first, last, orig_insn);\n+\t\t    split_hard_reg_notes (note, first, last);\n \t\t  else\n \t\t    {\n \t\t      XEXP (note, 1) = REG_NOTES (insn);\n@@ -8457,7 +8456,6 @@ schedule_insns (dump_file)\n \n   int max_uid;\n   int b;\n-  int i;\n   rtx insn;\n   int rgn;\n "}]}