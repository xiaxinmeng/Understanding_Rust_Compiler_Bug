{"sha": "f1eea13514caf90ee0ee14816e52adc7ba73a616", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlZWExMzUxNGNhZjkwZWUwZWUxNDgxNmU1MmFkYzdiYTczYTYxNg==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-04-22T12:45:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T12:45:39Z"}, "message": "prj-nmsc.adb (Check_Naming_Ada_Only): Properly initialize the separate_suffix to the same value as the body_suffix.\n\n2009-04-22  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Check_Naming_Ada_Only): Properly initialize the\n\tseparate_suffix to the same value as the body_suffix.\n\nFrom-SVN: r146574", "tree": {"sha": "ea074a306823b235797fec962fbcd8fa4b59c01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea074a306823b235797fec962fbcd8fa4b59c01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1eea13514caf90ee0ee14816e52adc7ba73a616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eea13514caf90ee0ee14816e52adc7ba73a616", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1eea13514caf90ee0ee14816e52adc7ba73a616", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eea13514caf90ee0ee14816e52adc7ba73a616/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9c0e0578aba733b7b336f8090efe957acc9509d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c0e0578aba733b7b336f8090efe957acc9509d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c0e0578aba733b7b336f8090efe957acc9509d"}], "stats": {"total": 114, "additions": 64, "deletions": 50}, "files": [{"sha": "bfa7e7526112b8387678c595ce8be6b84d6acdd3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1eea13514caf90ee0ee14816e52adc7ba73a616/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1eea13514caf90ee0ee14816e52adc7ba73a616/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f1eea13514caf90ee0ee14816e52adc7ba73a616", "patch": "@@ -1,3 +1,8 @@\n+2009-04-22  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Naming_Ada_Only): Properly initialize the\n+\tseparate_suffix to the same value as the body_suffix.\n+\n 2009-04-22  Robert Dewar  <dewar@adacore.com>\n \n \t* prj.adb: Minor code reorganization"}, {"sha": "0c7165d3fc99dd5ac2e838467b2941edc8cd1c9a", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1eea13514caf90ee0ee14816e52adc7ba73a616/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1eea13514caf90ee0ee14816e52adc7ba73a616/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=f1eea13514caf90ee0ee14816e52adc7ba73a616", "patch": "@@ -3247,10 +3247,10 @@ package body Prj.Nmsc is\n       ---------------------------\n \n       procedure Check_Naming_Ada_Only is\n-         Casing_Defined  : Boolean;\n-         Spec_Suffix     : File_Name_Type;\n-         Body_Suffix     : File_Name_Type;\n-         Sep_Suffix_Loc  : Source_Ptr;\n+         Casing_Defined : Boolean;\n+         Spec_Suffix    : File_Name_Type;\n+         Body_Suffix    : File_Name_Type;\n+         Sep_Suffix_Loc : Source_Ptr;\n \n          Ada_Spec_Suffix : constant Variable_Value :=\n            Prj.Util.Value_Of\n@@ -3267,7 +3267,26 @@ package body Prj.Nmsc is\n               In_Tree   => In_Tree);\n \n       begin\n-         --  We'll need the dot replacement below, so compute it first\n+         --  The default value of separate suffix should be the same as the\n+         --  body suffix, so we need to compute that first.\n+\n+         if Ada_Body_Suffix.Kind = Single\n+           and then Length_Of_Name (Ada_Body_Suffix.Value) /= 0\n+         then\n+            Body_Suffix := Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n+            Data.Naming.Separate_Suffix := Body_Suffix;\n+            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n+\n+         else\n+            Body_Suffix := Default_Ada_Body_Suffix;\n+            Data.Naming.Separate_Suffix := Body_Suffix;\n+            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n+         end if;\n+\n+         Write_Attr (\"Body_Suffix\", Get_Name_String (Body_Suffix));\n+\n+         --  We'll need the dot replacement below, so compute it now.\n+\n          Check_Common\n            (Dot_Replacement => Data.Naming.Dot_Replacement,\n             Casing          => Data.Naming.Casing,\n@@ -3300,7 +3319,7 @@ package body Prj.Nmsc is\n             Set_Spec_Suffix (In_Tree, \"ada\", Data.Naming, Spec_Suffix);\n \n             if Is_Illegal_Suffix\n-              (Spec_Suffix, Data.Naming.Dot_Replacement)\n+                 (Spec_Suffix, Data.Naming.Dot_Replacement)\n             then\n                Err_Vars.Error_Msg_File_1 := Spec_Suffix;\n                Error_Msg\n@@ -3318,36 +3337,19 @@ package body Prj.Nmsc is\n \n          --  Check Body_Suffix\n \n-         if Ada_Body_Suffix.Kind = Single\n-           and then Get_Name_String (Ada_Body_Suffix.Value) /= \"\"\n-         then\n-            Body_Suffix := Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n-            Data.Naming.Separate_Suffix := Body_Suffix;\n-            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n-\n-            if Is_Illegal_Suffix\n-              (Body_Suffix, Data.Naming.Dot_Replacement)\n-            then\n-               Err_Vars.Error_Msg_File_1 := Body_Suffix;\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is illegal for Body_Suffix\",\n-                  Ada_Body_Suffix.Location);\n-            end if;\n-\n-         else\n-            Body_Suffix := Default_Ada_Body_Suffix;\n-            Data.Naming.Separate_Suffix := Body_Suffix;\n-            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n+         if Is_Illegal_Suffix (Body_Suffix, Data.Naming.Dot_Replacement) then\n+            Err_Vars.Error_Msg_File_1 := Body_Suffix;\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"{ is illegal for Body_Suffix\",\n+               Ada_Body_Suffix.Location);\n          end if;\n \n-         Write_Attr (\"Body_Suffix\", Get_Name_String (Body_Suffix));\n-\n          --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n-         --  since that would cause a clear ambiguity. Note that we do\n-         --  allow a Spec_Suffix to have the same termination as one of\n-         --  these, which causes a potential ambiguity, but we resolve\n-         --  that my matching the longest possible suffix.\n+         --  since that would cause a clear ambiguity. Note that we do allow a\n+         --  Spec_Suffix to have the same termination as one of these, which\n+         --  causes a potential ambiguity, but we resolve that my matching the\n+         --  longest possible suffix.\n \n          if Spec_Suffix = Body_Suffix then\n             Error_Msg\n@@ -3376,13 +3378,12 @@ package body Prj.Nmsc is\n \n       procedure Check_Naming_Multi_Lang is\n       begin\n-         --  We are now checking if attribute Dot_Replacement, Casing,\n-         --  and/or Separate_Suffix exist.\n+         --  We are now checking if attribute Dot_Replacement, Casing, and/or\n+         --  Separate_Suffix exist.\n \n-         --  For each attribute, if it does not exist, we do nothing,\n-         --  because we already have the default.\n-         --  Otherwise, for all unit-based languages, we put the declared\n-         --  value in the language config.\n+         --  For each attribute, if it does not exist, we do nothing, because\n+         --  we already have the default. Otherwise, for all unit-based\n+         --  languages, we put the declared value in the language config.\n \n          declare\n             Dot_Replacement : File_Name_Type := No_File;\n@@ -3400,8 +3401,8 @@ package body Prj.Nmsc is\n                Separate_Suffix => Separate_Suffix,\n                Sep_Suffix_Loc  => Sep_Suffix_Loc);\n \n-            --  For all unit based languages, if any, set the specified\n-            --  value of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n+            --  For all unit based languages, if any, set the specified value\n+            --  of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n             --  systematically overwrite, since the defaults come from the\n             --  configuration file\n \n@@ -3541,10 +3542,10 @@ package body Prj.Nmsc is\n    ------------------------------\n \n    procedure Check_Library_Attributes\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref;\n+     (Project     : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n       Current_Dir : String;\n-      Data    : in out Project_Data)\n+      Data        : in out Project_Data)\n    is\n       Attributes   : constant Prj.Variable_Id := Data.Decl.Attributes;\n \n@@ -6812,10 +6813,12 @@ package body Prj.Nmsc is\n \n          if Kind = Spec then\n             Masked := Unit_Except.Spec /= No_File\n-              and then Unit_Except.Spec /= File_Name;\n+                        and then\n+                      Unit_Except.Spec /= File_Name;\n          else\n             Masked := Unit_Except.Impl /= No_File\n-              and then Unit_Except.Impl /= File_Name;\n+                        and then\n+                      Unit_Except.Impl /= File_Name;\n          end if;\n \n          if Masked then\n@@ -6926,6 +6929,7 @@ package body Prj.Nmsc is\n       Dot_Replacement : File_Name_Type) return Boolean\n    is\n       Suffix_Str : constant String := Get_Name_String (Suffix);\n+\n    begin\n       if Suffix_Str'Length = 0 or else Index (Suffix_Str, \".\") = 0 then\n          return True;\n@@ -7686,10 +7690,10 @@ package body Prj.Nmsc is\n       Lang_Kind             : out Language_Kind;\n       Kind                  : out Source_Kind)\n    is\n-      Filename       : constant String := Get_Name_String (File_Name);\n-      Config         : Language_Config;\n-      Lang           : Name_List_Index := Data.Languages;\n-      Tmp_Lang       : Language_Index;\n+      Filename : constant String := Get_Name_String (File_Name);\n+      Config   : Language_Config;\n+      Lang     : Name_List_Index;\n+      Tmp_Lang : Language_Index;\n \n       Header_File : Boolean := False;\n       --  True if we found at least one language for which the file is a header\n@@ -7749,6 +7753,8 @@ package body Prj.Nmsc is\n          end if;\n       end Check_File_Based_Lang;\n \n+   --  Start of processing for Check_File_Naming_Schemes\n+\n    begin\n       Language              := No_Language_Index;\n       Alternate_Languages   := No_Alternate_Language;\n@@ -7757,6 +7763,7 @@ package body Prj.Nmsc is\n       Lang_Kind             := File_Based;\n       Kind                  := Spec;\n \n+      Lang := Data.Languages;\n       while Lang /= No_Name_List loop\n          Language_Name := In_Tree.Name_Lists.Table (Lang).Name;\n          Tmp_Lang := Get_Language_Processing_From_Lang (In_Tree, Data, Lang);\n@@ -7780,8 +7787,10 @@ package body Prj.Nmsc is\n                   exit when Kind = Impl;\n \n                when Unit_Based =>\n+\n                   --  We know it belongs to a least a file_based language, no\n                   --  need to check unit-based ones.\n+\n                   if not Header_File then\n                      Compute_Unit_Name\n                        (File_Name       => File_Name,"}]}