{"sha": "ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4MGI0MTY1NTRkM2Y0MWI1ZmQyM2NjODYyODdhZjliOWE3ZDJkMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-01-06T14:27:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-05T08:18:58Z"}, "message": "[Ada] Implement tiered support for floating-point output operations\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-dourea, s-imager,\n\ts-imgflt, s-imglfl and s-imgllf.\n\t(LIBGNAT_TARGET_PAIRS) [PowerPC/VxWorks]: Use s-dorepr__fma.adb.\n\t(LIBGNAT_TARGET_PAIRS) [PowerPC/VxWorksAE]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [Aarch64/VxWorks]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [Aarch64/QNX]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [Aarch64/FreeBSD]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [PowerPC/Linux]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [Aarch64/Linux]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [IA-64/Linux]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [IA-64/HP-UX]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [RISC-V/Linux]: Likewise.\n\t(LIBGNAT_TARGET_PAIRS) [PowerPC/Darwin]: Likewise.\n\t* exp_attr.adb (Expand_N_Attribute_Reference) [Attribute_Fore]: Use\n\tFixed suffix and Long_Float type.\n\t* exp_imgv.adb (Expand_Image_Attribute): For floating-point types,\n\tuse the routine of the corresponding root type.  For ordinary fixed\n\tpoint types, use Fixed suffix and Long_Float type.\n\t(Expand_Value_Attribute): Revert latest change for Long_Long_Float.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Remove libgnat units\n\tg-hesora.o and s-imgenu.o, add g-heasor.o, g-table.o and s-pehage.o.\n\t(GNATBIND_OBJS): Remove libgnat unit s-imgenu.o.\n\t* rtsfind.ads (RTU_Id): Add System_Img_Flt, System_Img_LFlt and\n\tSystem_Img_LLF.  Remove System_Img_Real.\n\t(RE_Id): Rename RE_Fore_Real to RE_Fore_Fixed.  Add RE_Image_Float,\n\tRE_Image_Long_Float and RE_Image_Long_Long_Float.  Rename\n\tRE_Image_Ordinary_Fixed_Point to RE_Image_Fixed.\n\t(RE_Unit_Table): Adjust to above changes.\n\t* libgnat/a-nbnbre.adb (Fixed_Conversions): Use Long_Float instead\n\tof Long_Long_Float.\n\t* libgnat/a-textio.ads (Field): Remove obsolete comment.\n\t* libgnat/a-ticoau.ads (Aux): Adjust ancestor package.\n\t* libgnat/a-ticoau.adb: Remove with/use clause for System.Img_Real.\n\t(Puts): Call Aux.Set_Image instead of Set_Image_Real.\n\t* libgnat/a-ticoio.adb: Add with/use clauses for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Scalar_Float): Add third actual parameter.\n\t(Scalar_Long_Float): Likewise.\n\t(Scalar_Long_Long_Float): Likewise.\n\t* libgnat/a-tifiio.adb: Add with/use clauses for System.Img_LFlt\n\tand System.Val_LFlt.  Remove the one for System.Val_LLF.  Replace\n\tLong_Long_Float with Long_Float throughout.\n\t* libgnat/a-tifiio__128.adb: Likewise.\n\t* libgnat/a-tiflau.ads: Add Set_Image formal parameter.\n\t* libgnat/a-tiflau.adb: Add with/use clause for System.Img_Util,\n\tremove the one for System.Img_Real.\n\t(Put): Call Set_Image instead of Set_Image_Real.\n\t(Puts): Likewise.\n\t* libgnat/a-tiflio.adb: Add with/use clause for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Aux_Float): Add third actual parameter.\n\t(Aux_Long_Float): Likewise.\n\t(Aux_Long_Long_Float): Likewise.\n\t* libgnat/a-witeio.ads (Field): Remove obsolete comment.\n\t* libgnat/a-wtcoau.ads (Aux): Adjust ancestor package.\n\t* libgnat/a-wtcoau.adb: Remove with/use clause for System.Img_Real.\n\t(Puts): Call Aux.Set_Image instead of Set_Image_Real.\n\t* libgnat/a-wtcoio.adb: Add with/use clauses for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Scalar_Float): Add third actual parameter.\n\t(Scalar_Long_Float): Likewise.\n\t(Scalar_Long_Long_Float): Likewise.\n\t* libgnat/a-wtfiio.adb: Add with/use clauses for System.Img_LFlt\n\tand System.Val_LFlt.  Remove the one for System.Val_LLF.  Replace\n\tLong_Long_Float with Long_Float throughout.\n\t* libgnat/a-wtfiio__128.adb: Likewise.\n\t* libgnat/a-wtflau.ads: Add Set_Image formal parameter.\n\t* libgnat/a-wtflau.adb: Add with/use clause for System.Img_Util,\n\tremove the one for System.Img_Real.\n\t(Put): Call Set_Image instead of Set_Image_Real.\n\t(Puts): Likewise.\n\t* libgnat/a-wtflio.adb: Add with/use clause for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Aux_Float): Add third actual parameter.\n\t(Aux_Long_Float): Likewise.\n\t(Aux_Long_Long_Float): Likewise.\n\t* libgnat/a-ztexio.ads (Field): Remove obsolete comment.\n\t* libgnat/a-ztcoau.ads (Aux): Adjust ancestor package.\n\t* libgnat/a-ztcoau.adb: Remove with/use clause for System.Img_Real.\n\t(Puts): Call Aux.Set_Image instead of Set_Image_Real.\n\t* libgnat/a-ztcoio.adb: Add with/use clauses for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Scalar_Float): Add third actual parameter.\n\t(Scalar_Long_Float): Likewise.\n\t(Scalar_Long_Long_Float): Likewise.\n\t* libgnat/a-ztfiio.adb: Add with/use clauses for System.Img_LFlt\n\tand System.Val_LFlt.  Remove the one for System.Val_LLF.  Replace\n\tLong_Long_Float with Long_Float throughout.\n\t* libgnat/a-ztfiio__128.adb: Likewise.\n\t* libgnat/a-ztflau.ads: Add Set_Image formal parameter.\n\t* libgnat/a-ztflau.adb: Add with/use clause for System.Img_Util,\n\tremove the one for System.Img_Real.\n\t(Put): Call Set_Image instead of Set_Image_Real.\n\t(Puts): Likewise.\n\t* libgnat/a-ztflio.adb: Add with/use clause for System.Img_Flt,\n\tSystem.Img_LFlt and System.Img_LLF.\n\t(Aux_Float): Add third actual parameter.\n\t(Aux_Long_Float): Likewise.\n\t(Aux_Long_Long_Float): Likewise.\n\t* libgnat/s-dorepr.adb: New file.\n\t* libgnat/s-dorepr__fma.adb: Likewise.\n\t* libgnat/s-dourea.ads: Likewise.\n\t* libgnat/s-dourea.adb: Likewise.\n\t* libgnat/s-forrea.ads (Fore_Real): Rename into...\n\t(Fore_Fixed): ...this and take Long_Float parameters.\n\t* libgnat/s-forrea.adb (Fore_Real): Likewise.\n\t(Fore_Fixed): Likewise.\n\t* libgnat/s-imgrea.ads: Move to...\n\t(Set_Image_Real): Turn into mere renaming.\n\t* libgnat/s-imager.ads: ...here.\n\t(Image_Ordinary_Fixed_Point): Turn into...\n\t(Image_Fixed_Point): ...this.\n\t* libgnat/s-imgrea.adb: Add pragma No_Body.  Move to...\n\t* libgnat/s-imager.adb: ...here.\n\t(Image_Ordinary_Fixed_Point): Turn into...\n\t(Image_Fixed_Point): ...this.\n\t(Is_Negative): Replace Long_Long_Float with Num.\n\t(Set_Image_Real): Likewise.  Use Double_T instead of single Num\n\tthroughout the algorithm.\n\t* libgnat/s-imgflt.ads: New file.\n\t* libgnat/s-imglfl.ads: Likewise.\n\t* libgnat/s-imgllf.ads: Likewise.\n\t* libgnat/s-imagef.ads: Adjust comment.\n\t* libgnat/s-imguti.ads (Max_Real_Image_Length): New named number.\n\t* libgnat/s-powflt.ads (Maxpow): Adjust.\n\t(Powten): Turn into an exact table of double Float.\n\t* libgnat/s-powlfl.ads (Maxpow): Adjust.\n\t(Powten): Turn into an exact table of double Long_Float.\n\t* libgnat/s-powllf.ads (Maxpow): Adjust.\n\t(Powten): Turn into an exact table of double Long_Long_Float.\n\t* libgnat/s-valrea.ads: Change order of formal parameters.\n\t* libgnat/s-valrea.adb: Add with clause for System.Double_Real.\n\t(Double_Real): New instantiation.\n\t(Fast2Sum): Delete.\n\t(Large_Powten): New function.\n\t(Integer_to_Real): Use Quick_Two_Sum instead of Fast2Sum.  Convert\n\tthe value to Double_T.  Do the scaling in Double_T for base 10.\n\t* libgnat/s-valflt.ads: Remove with/use clasue for Interfaces,\n\tadd it for System.Unsigned_Types.  Use Unsigned.\n\t* libgnat/s-vallfl.ads: Remove with/use clasue for Interfaces,\n\tadd it for System.Unsigned_Types.  Use Long_Unsigned.\n\t* libgnat/s-valllf.ads: Remove with/use clasue for Interfaces,\n\tadd it for System.Unsigned_Types.  Use Long_Long_Unsigned.", "tree": {"sha": "8b008ec1205194f2b3f53bf43f6bf2dbf5cb6a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b008ec1205194f2b3f53bf43f6bf2dbf5cb6a30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab3de94f09bbaec63da85cdd872f61da2a98e01f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3de94f09bbaec63da85cdd872f61da2a98e01f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3de94f09bbaec63da85cdd872f61da2a98e01f"}], "stats": {"total": 3025, "additions": 1935, "deletions": 1090}, "files": [{"sha": "d42579d5f0d191b48dc410d1b804c84ee2578aea", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -575,6 +575,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-dlmkio$(objext) \\\n   s-dlmopr$(objext) \\\n   s-dmotpr$(objext) \\\n+  s-dourea$(objext) \\\n   s-dsaser$(objext) \\\n   s-elaall$(objext) \\\n   s-excdeb$(objext) \\\n@@ -618,6 +619,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-imaged$(objext) \\\n   s-imagef$(objext) \\\n   s-imagei$(objext) \\\n+  s-imager$(objext) \\\n   s-imageu$(objext) \\\n   s-imagew$(objext) \\\n   s-imde32$(objext) \\\n@@ -629,7 +631,10 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-imgboo$(objext) \\\n   s-imgcha$(objext) \\\n   s-imgenu$(objext) \\\n+  s-imgflt$(objext) \\\n   s-imgint$(objext) \\\n+  s-imglfl$(objext) \\\n+  s-imgllf$(objext) \\\n   s-imgllb$(objext) \\\n   s-imglli$(objext) \\\n   s-imgllu$(objext) \\\n@@ -1069,6 +1074,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks vxworksspe vxworks7% vxworks7spe\n   a-naliop.ads<libgnat/a-naliop__nolibm.ads \\\n   a-nuaufl.ads<libgnat/a-nuaufl__wraplf.ads \\\n   a-nashfl.ads<libgnat/a-nashfl__wraplf.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__vxworks.adb \\\n   s-intman.ads<libgnarl/s-intman__vxworks.ads \\\n   s-intman.adb<libgnarl/s-intman__vxworks.adb \\\n@@ -1202,6 +1208,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae vxworksaespe,$(target_cpu) $(t\n   a-nuaufl.ads<libgnat/a-nuaufl__wraplf.ads \\\n   a-nashfl.ads<libgnat/a-nashfl__wraplf.ads \\\n   g-io.adb<hie/g-io__vxworks-cert.adb \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__vxworks.adb \\\n   s-interr.adb<libgnarl/s-interr__vxworks.adb \\\n   s-intman.ads<libgnarl/s-intman__vxworks.ads \\\n@@ -1218,9 +1225,9 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae vxworksaespe,$(target_cpu) $(t\n   s-vxwext.adb<libgnarl/s-vxwext__noints.adb \\\n   s-vxwext.ads<libgnarl/s-vxwext__vthreads.ads \\\n   s-vxwork.ads<libgnarl/s-vxwork__ppc.ads \\\n-  system.ads<libgnat/system-vxworks-$(ARCH_STR)-vthread.ads \\\n   $(ATOMICS_TARGET_PAIRS) \\\n-  $(ATOMICS_BUILTINS_TARGET_PAIRS)\n+  $(ATOMICS_BUILTINS_TARGET_PAIRS) \\\n+  system.ads<libgnat/system-vxworks-$(ARCH_STR)-vthread.ads\n \n   EH_MECHANISM=-gcc\n \n@@ -1490,7 +1497,8 @@ ifeq ($(strip $(filter-out aarch64 arm% coff wrs vx%,$(target_cpu) $(target_vend\n     EH_MECHANISM=-gcc\n     SIGTRAMP_OBJ=sigtramp-vxworks.o\n     LIBGNAT_TARGET_PAIRS += $(GNATRTL_128BIT_PAIRS) \\\n-      a-nallfl.ads<libgnat/a-nallfl__wraplf.ads\n+      a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n+      s-dorepr.adb<libgnat/s-dorepr__fma.adb\n     EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n   else\n     ifeq ($(strip $(filter-out arm%, $(target_cpu))),)\n@@ -1611,6 +1619,7 @@ ifeq ($(strip $(filter-out aarch64 %qnx,$(target_cpu) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<libgnarl/a-intnam__qnx.ads \\\n   a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__qnx.adb \\\n   s-osinte.adb<libgnarl/s-osinte__qnx.adb \\\n@@ -1878,6 +1887,7 @@ ifeq ($(strip $(filter-out %aarch64 freebsd%,$(target_cpu) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<libgnarl/a-intnam__freebsd.ads \\\n   a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-mudido.adb<libgnarl/s-mudido__affinity.adb \\\n@@ -2342,6 +2352,7 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(target_cpu) $(target_os))),)\n   a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n   a-synbar.adb<libgnarl/a-synbar__posix.adb \\\n   a-synbar.ads<libgnarl/a-synbar__posix.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-linux.ads<libgnarl/s-linux.ads \\\n@@ -2425,6 +2436,7 @@ ifeq ($(strip $(filter-out aarch64% linux%,$(target_cpu) $(target_os))),)\n   a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n   a-synbar.adb<libgnarl/a-synbar__posix.adb \\\n   a-synbar.ads<libgnarl/a-synbar__posix.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-linux.ads<libgnarl/s-linux.ads \\\n@@ -2584,6 +2596,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(target_cpu) $(target_os))),)\n   a-nuauco.ads<libgnat/a-nuauco__x86.ads \\\n   a-synbar.adb<libgnarl/a-synbar__posix.adb \\\n   a-synbar.ads<libgnarl/a-synbar__posix.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-linux.ads<libgnarl/s-linux.ads \\\n@@ -2620,6 +2633,7 @@ endif\n ifeq ($(strip $(filter-out ia64% hp hpux%,$(target_cpu) $(target_vendor) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<libgnarl/a-intnam__hpux.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-osinte.adb<libgnarl/s-osinte__posix.adb \\\n@@ -2761,6 +2775,7 @@ ifeq ($(strip $(filter-out riscv% linux%,$(target_cpu) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<libgnarl/a-intnam__linux.ads \\\n   a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n+  s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-linux.ads<libgnarl/s-linux__riscv.ads \\\n@@ -2890,6 +2905,7 @@ ifeq ($(strip $(filter-out darwin%,$(target_os))),)\n     LIBGNAT_TARGET_PAIRS += \\\n       a-nallfl.ads<libgnat/a-nallfl__wraplf.ads \\\n       s-intman.adb<libgnarl/s-intman__susv3.adb \\\n+      s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n       s-osprim.adb<libgnat/s-osprim__darwin.adb \\\n       $(ATOMICS_TARGET_PAIRS) \\\n       $(ATOMICS_BUILTINS_TARGET_PAIRS) \\"}, {"sha": "c5c6b6dd2da75f77a18514a7106c7f31ebc772e0", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -3631,8 +3631,8 @@ package body Exp_Attr is\n       --             min (scale of Typ'Small, 0)\n \n       --    For other ordinary fixed-point types\n-      --      xx   = Real\n-      --      ftyp = Universal_Real\n+      --      xx   = Fixed\n+      --      ftyp = Long_Float\n       --      pm   = none\n \n       --  Note that we know that the type is a nonstatic subtype, or Fore would\n@@ -3691,8 +3691,8 @@ package body Exp_Attr is\n                      Fid  := RE_Fore_Fixed128;\n                      Ftyp := RTE (RE_Integer_128);\n                   else\n-                     Fid  := RE_Fore_Real;\n-                     Ftyp := Universal_Real;\n+                     Fid  := RE_Fore_Fixed;\n+                     Ftyp := Standard_Long_Float;\n                   end if;\n                end;\n             end if;\n@@ -3721,7 +3721,7 @@ package body Exp_Attr is\n             --  For ordinary fixed-point types, append Num, Den and Scale\n             --  parameters and also set to do literal conversion\n \n-            elsif Fid /= RE_Fore_Real then\n+            elsif Fid /= RE_Fore_Fixed then\n                Set_Conversion_OK (First (Arg_List));\n                Set_Conversion_OK (Next (First (Arg_List)));\n "}, {"sha": "da98af7bcaec82ca6b02beca41b3c244b951d442", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -233,7 +233,7 @@ package body Exp_Imgv is\n \n    --    For floating-point types\n    --      xx = Floating_Point\n-   --      tv = Long_Long_Float (Expr)\n+   --      tv = [Long_[Long_]]Float (Expr)\n    --      pm = typ'Digits (typ = subtype of expression)\n \n    --    For decimal fixed-point types\n@@ -250,8 +250,8 @@ package body Exp_Imgv is\n    --           typ'Aft\n \n    --    For other ordinary fixed-point types\n-   --      xx = Ordinary_Fixed_Point\n-   --      tv = Long_Long_Float (Expr)\n+   --      xx = Fixed\n+   --      tv = Long_Float (Expr)\n    --      pm = typ'Aft (typ = subtype of expression)\n \n    --  For enumeration types other than those declared in package Standard\n@@ -471,11 +471,11 @@ package body Exp_Imgv is\n \n       --  Ada 2020 allows 'Image on private types, so fetch the underlying\n       --  type to obtain the structure of the type. We use the base type,\n-      --  not the root type, to handle properly derived types, but we use\n-      --  the root type for enumeration types, because the literal map is\n-      --  attached to the root. Should be inherited ???\n+      --  not the root type for discrete types, to handle properly derived\n+      --  types, but we use the root type for enumeration types, because the\n+      --  literal map is attached to the root. Should be inherited ???\n \n-      if Is_Enumeration_Type (Ptyp) then\n+      if Is_Real_Type (Ptyp) or else Is_Enumeration_Type (Ptyp) then\n          Rtyp := Underlying_Type (Root_Type (Ptyp));\n       else\n          Rtyp := Underlying_Type (Base_Type (Ptyp));\n@@ -631,14 +631,26 @@ package body Exp_Imgv is\n                Imid := RE_Image_Fixed128;\n                Tent := RTE (RE_Integer_128);\n             else\n-               Imid := RE_Image_Ordinary_Fixed_Point;\n-               Tent := Standard_Long_Long_Float;\n+               Imid := RE_Image_Fixed;\n+               Tent := Standard_Long_Float;\n             end if;\n          end;\n \n       elsif Is_Floating_Point_Type (Rtyp) then\n-         Imid := RE_Image_Floating_Point;\n-         Tent := Standard_Long_Long_Float;\n+         --  Short_Float and Float are the same type for GNAT\n+\n+         if Rtyp = Standard_Short_Float or else Rtyp = Standard_Float then\n+            Imid := RE_Image_Float;\n+            Tent := Standard_Float;\n+\n+         elsif Rtyp = Standard_Long_Float then\n+            Imid := RE_Image_Long_Float;\n+            Tent := Standard_Long_Float;\n+\n+         else\n+            Imid := RE_Image_Long_Long_Float;\n+            Tent := Standard_Long_Long_Float;\n+         end if;\n \n       --  Only other possibility is user-defined enumeration type\n \n@@ -787,7 +799,7 @@ package body Exp_Imgv is\n       --  and also set to do literal conversion.\n \n       elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n-         if Imid /= RE_Image_Ordinary_Fixed_Point then\n+         if Imid /= RE_Image_Fixed then\n             Set_Conversion_OK (First (Arg_List));\n \n             Append_To (Arg_List,\n@@ -886,12 +898,16 @@ package body Exp_Imgv is\n \n    --    btyp?(Value_Decimal{32,64,128} (X, typ'Scale));\n \n-   --  For the most common ordinary fixed-point types\n+   --  For the most common ordinary fixed-point types, it expands into\n \n    --    btyp?(Value_Fixed{32,64,128} (X, numerator of S, denominator of S));\n    --    where S = typ'Small\n \n-   --  For Wide_[Wide_]Character types, typ'Value (X) expands into:\n+   --  For other ordinary fixed-point types, it expands into\n+\n+   --    btyp (Value_Long_Float (X))\n+\n+   --  For Wide_[Wide_]Character types, typ'Value (X) expands into\n \n    --    btyp (Value_xx (X, EM))\n \n@@ -1036,21 +1052,11 @@ package body Exp_Imgv is\n          if Rtyp = Standard_Short_Float or else Rtyp = Standard_Float then\n             Vid := RE_Value_Float;\n \n-         --  If Long_Float and Long_Long_Float are the same type, then use the\n-         --  implementation of the former, which is faster and more accurate.\n-\n-         elsif Rtyp = Standard_Long_Float\n-           or else (Rtyp = Standard_Long_Long_Float\n-                     and then\n-                    Standard_Long_Long_Float_Size = Standard_Long_Float_Size)\n-         then\n+         elsif Rtyp = Standard_Long_Float then\n             Vid := RE_Value_Long_Float;\n \n-         elsif Rtyp = Standard_Long_Long_Float then\n-            Vid := RE_Value_Long_Long_Float;\n-\n          else\n-            raise Program_Error;\n+            Vid := RE_Value_Long_Long_Float;\n          end if;\n \n       --  Only other possibility is user-defined enumeration type"}, {"sha": "6c27239436125cca24adf72300eb10d143b8b3f5", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -319,12 +319,13 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-byorma.o\t\\\n  ada/libgnat/g-dynhta.o\t\\\n  ada/libgnat/g-graphs.o \\\n- ada/libgnat/g-hesora.o\t\\\n+ ada/libgnat/g-heasor.o\t\\\n  ada/libgnat/g-htable.o\t\\\n  ada/libgnat/g-lists.o\t\\\n  ada/libgnat/g-sets.o\t\\\n  ada/libgnat/g-spchge.o\t\\\n  ada/libgnat/g-speche.o\t\\\n+ ada/libgnat/g-table.o\t\\\n  ada/libgnat/g-u3spch.o\t\\\n  ada/get_targ.o\t\\\n  ada/ghost.o\t\\\n@@ -380,12 +381,11 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/s-crtl.o\t\\\n  ada/libgnat/s-excdeb.o\t\\\n  ada/libgnat/s-except.o\t\\\n+ ada/libgnat/s-excmac.o\t\\\n  ada/libgnat/s-exctab.o\t\\\n- ada/libgnat/s-excmac.o \\\n  ada/libgnat/s-htable.o\t\\\n  ada/libgnat/s-imenne.o\t\\\n- ada/libgnat/s-imgenu.o\t\\\n- ada/libgnat/s-imgint.o \\\n+ ada/libgnat/s-imgint.o\t\\\n  ada/libgnat/s-mastop.o\t\\\n  ada/libgnat/s-memory.o\t\\\n  ada/libgnat/s-os_lib.o\t\\"}, {"sha": "794e918a81ce836cb73ebe6181595ad01723cdfe", "filename": "gcc/ada/libgnat/a-nbnbre.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -307,7 +307,7 @@ package body Ada.Numerics.Big_Numbers.Big_Reals is\n \n    package body Fixed_Conversions is\n \n-      package Float_Aux is new Float_Conversions (Long_Long_Float);\n+      package Float_Aux is new Float_Conversions (Long_Float);\n \n       subtype LLLI is Long_Long_Long_Integer;\n       subtype LLLU is Long_Long_Long_Unsigned;\n@@ -316,7 +316,7 @@ package body Ada.Numerics.Big_Numbers.Big_Reals is\n                     Num'Small_Numerator > LLLU'Last\n                       or else Num'Small_Denominator > LLLU'Last;\n       --  True if the Small is too large for Long_Long_Long_Unsigned, in which\n-      --  case we convert to/from Long_Long_Float as an intermediate step.\n+      --  case we convert to/from Long_Float as an intermediate step.\n \n       package Conv_I is new Big_Integers.Signed_Conversions (LLLI);\n       package Conv_U is new Big_Integers.Unsigned_Conversions (LLLU);\n@@ -334,7 +334,7 @@ package body Ada.Numerics.Big_Numbers.Big_Reals is\n \n       begin\n          if Too_Large then\n-            return Float_Aux.To_Big_Real (Long_Long_Float (Arg));\n+            return Float_Aux.To_Big_Real (Long_Float (Arg));\n          end if;\n \n          N := Conv_U.To_Big_Integer (Num'Small_Numerator);"}, {"sha": "f6c0a8aec65e4154489335e8c643bdff24a9531b", "filename": "gcc/ada/libgnat/a-textio.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-textio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-textio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-textio.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -85,9 +85,6 @@ is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value, then it\n-   --  will be necessary to change the corresponding value in System.Img_Real\n-   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "1fa9364d12a0cfde95cfc71cd50cdd631394bc78", "filename": "gcc/ada/libgnat/a-ticoau.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ticoau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,8 +31,6 @@\n \n with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n-\n package body Ada.Text_IO.Complex_Aux is\n \n    ---------\n@@ -171,9 +169,9 @@ package body Ada.Text_IO.Complex_Aux is\n       --  Both parts are initially converted with a Fore of 0\n \n       Rptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemR), R_String, Rptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemR, R_String, Rptr, 0, Aft, Exp);\n       Iptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemI), I_String, Iptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemI, I_String, Iptr, 0, Aft, Exp);\n \n       --  Check room for both parts plus parens plus comma (RM G.1.3(34))\n "}, {"sha": "2b5ea66f992af0b9a14ee7682bb510839af61a2a", "filename": "gcc/ada/libgnat/a-ticoau.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ticoau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -42,7 +42,7 @@ private generic\n \n    type Num is digits <>;\n \n-   with package Aux is new Ada.Text_IO.Float_Aux (Num, <>);\n+   with package Aux is new Ada.Text_IO.Float_Aux (Num, <>, <>);\n \n package Ada.Text_IO.Complex_Aux is\n "}, {"sha": "a94c82689ea6f8f110d0b7a46d80e0f20d1728d6", "filename": "gcc/ada/libgnat/a-ticoio.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ticoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ticoio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,6 +31,9 @@\n \n with Ada.Text_IO.Complex_Aux;\n with Ada.Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n@@ -40,22 +43,24 @@ package body Ada.Text_IO.Complex_IO is\n    use Complex_Types;\n \n    package Scalar_Float is new\n-      Ada.Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Scalar_Long_Float is new\n-      Ada.Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Scalar_Long_Long_Float is new\n-      Ada.Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    package Aux_Float is new\n-      Ada.Text_IO.Complex_Aux (Float, Scalar_Float);\n+     Ada.Text_IO.Complex_Aux (Float, Scalar_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n+     Ada.Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Text_IO.Complex_Aux (Long_Long_Float, Scalar_Long_Long_Float);\n+     Ada.Text_IO.Complex_Aux (Long_Long_Float, Scalar_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "d51abb4b38fb7b909a8206aabf1cf31a0d135bd4", "filename": "gcc/ada/libgnat/a-tifiio.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -158,16 +158,17 @@ with Ada.Text_IO.Fixed_Aux;\n with Ada.Text_IO.Float_Aux;\n with System.Img_Fixed_32; use System.Img_Fixed_32;\n with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Img_LFlt;     use System.Img_LFlt;\n with System.Val_Fixed_32; use System.Val_Fixed_32;\n with System.Val_Fixed_64; use System.Val_Fixed_64;\n-with System.Val_LLF;      use System.Val_LLF;\n+with System.Val_LFlt;     use System.Val_LFlt;\n \n package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32 is Interfaces.Integer_32; use type Int32;\n    subtype Int64 is Interfaces.Integer_64; use type Int64;\n@@ -178,8 +179,8 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n    package Aux64 is new\n      Ada.Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Text_IO.Float_Aux (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n@@ -283,7 +284,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                                -Num'Small_Numerator,\n                                -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -317,7 +318,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (From, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (From, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -345,8 +346,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                     -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -376,7 +376,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (To, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (To, Long_Float (Item), Aft, Exp);\n       end if;\n    end Put;\n "}, {"sha": "b161e89f712d1479e57dce3e81abbb1ff152ba6d", "filename": "gcc/ada/libgnat/a-tifiio__128.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -159,17 +159,18 @@ with Ada.Text_IO.Float_Aux;\n with System.Img_Fixed_32;  use System.Img_Fixed_32;\n with System.Img_Fixed_64;  use System.Img_Fixed_64;\n with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Img_LFlt;      use System.Img_LFlt;\n with System.Val_Fixed_32;  use System.Val_Fixed_32;\n with System.Val_Fixed_64;  use System.Val_Fixed_64;\n with System.Val_Fixed_128; use System.Val_Fixed_128;\n-with System.Val_LLF;       use System.Val_LLF;\n+with System.Val_LFlt;      use System.Val_LFlt;\n \n package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32  is Interfaces.Integer_32;  use type Int32;\n    subtype Int64  is Interfaces.Integer_64;  use type Int64;\n@@ -184,8 +185,8 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n    package Aux128 is new\n      Ada.Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Text_IO.Float_Aux (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n@@ -323,7 +324,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -362,7 +363,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                                  -Num'Small_Numerator,\n                                  -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (From, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (From, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -394,8 +395,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -429,7 +429,7 @@ package body Ada.Text_IO.Fixed_IO with SPARK_Mode => Off is\n                       -Num'Small_Numerator, -Num'Small_Denominator,\n                       For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (To, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (To, Long_Float (Item), Aft, Exp);\n       end if;\n    end Put;\n "}, {"sha": "fa10f3fa5e08520cb932ba47344e52011a815991", "filename": "gcc/ada/libgnat/a-tiflau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,7 +31,7 @@\n \n with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n+with System.Img_Util; use System.Img_Util;\n \n package body Ada.Text_IO.Float_Aux is\n \n@@ -96,7 +96,7 @@ package body Ada.Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real (Long_Long_Float (Item), Buf, Ptr, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n    end Put;\n \n@@ -114,8 +114,7 @@ package body Ada.Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real\n-        (Long_Long_Float (Item), Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n+      Set_Image (Item, Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;"}, {"sha": "a095846e3cd0c42e8f4d1a879e6b5b5ad391952e", "filename": "gcc/ada/libgnat/a-tiflau.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiflau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -45,6 +45,14 @@ private generic\n       Ptr : not null access Integer;\n       Max : Integer) return Num;\n \n+   with procedure Set_Image\n+     (V    : Num;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n package Ada.Text_IO.Float_Aux is\n \n    procedure Get"}, {"sha": "1df359058d0d7ae8be660fd3b88107a8b15793bf", "filename": "gcc/ada/libgnat/a-tiflio.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-tiflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiflio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -30,20 +30,25 @@\n ------------------------------------------------------------------------------\n \n with Ada.Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n \n package body Ada.Text_IO.Float_IO with SPARK_Mode => Off is\n \n    package Aux_Float is new\n-      Ada.Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "910154d6e6f11f81406fe971d87b1e715b44c70d", "filename": "gcc/ada/libgnat/a-witeio.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-witeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-witeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-witeio.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -73,9 +73,6 @@ package Ada.Wide_Text_IO is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value, then it\n-   --  will be necessary to change the corresponding value in System.Img_Real\n-   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "d8dd79f8342adbdf6af75ef00aa9c37f147325da", "filename": "gcc/ada/libgnat/a-wtcoau.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtcoau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,8 +31,6 @@\n \n with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n-\n package body Ada.Wide_Text_IO.Complex_Aux is\n \n    ---------\n@@ -171,9 +169,9 @@ package body Ada.Wide_Text_IO.Complex_Aux is\n       --  Both parts are initially converted with a Fore of 0\n \n       Rptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemR), R_String, Rptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemR, R_String, Rptr, 0, Aft, Exp);\n       Iptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemI), I_String, Iptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemI, I_String, Iptr, 0, Aft, Exp);\n \n       --  Check room for both parts plus parens plus comma (RM G.1.3(34))\n "}, {"sha": "5541983611ab022fb977bfa34149f37e93dc3616", "filename": "gcc/ada/libgnat/a-wtcoau.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtcoau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -42,7 +42,7 @@ private generic\n \n    type Num is digits <>;\n \n-   with package Aux is new Ada.Wide_Text_IO.Float_Aux (Num, <>);\n+   with package Aux is new Ada.Wide_Text_IO.Float_Aux (Num, <>, <>);\n \n package Ada.Wide_Text_IO.Complex_Aux is\n "}, {"sha": "fcca1bb7a71b850ea1fb7f7b8d2935342472398f", "filename": "gcc/ada/libgnat/a-wtcoio.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtcoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtcoio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,6 +31,9 @@\n \n with Ada.Wide_Text_IO.Complex_Aux;\n with Ada.Wide_Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n@@ -42,22 +45,24 @@ package body Ada.Wide_Text_IO.Complex_IO is\n    use Complex_Types;\n \n    package Scalar_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Wide_Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Scalar_Long_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Scalar_Long_Long_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    package Aux_Float is new\n-      Ada.Wide_Text_IO.Complex_Aux (Float, Scalar_Float);\n+     Ada.Wide_Text_IO.Complex_Aux (Float, Scalar_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Wide_Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n+     Ada.Wide_Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Wide_Text_IO.Complex_Aux (Long_Long_Float, Scalar_Long_Long_Float);\n+     Ada.Wide_Text_IO.Complex_Aux (Long_Long_Float, Scalar_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "954ab959808f93556739406af800a72f29e6cc83", "filename": "gcc/ada/libgnat/a-wtfiio.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,9 +34,10 @@ with Ada.Wide_Text_IO.Fixed_Aux;\n with Ada.Wide_Text_IO.Float_Aux;\n with System.Img_Fixed_32; use System.Img_Fixed_32;\n with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Img_LFlt;     use System.Img_LFlt;\n with System.Val_Fixed_32; use System.Val_Fixed_32;\n with System.Val_Fixed_64; use System.Val_Fixed_64;\n-with System.Val_LLF;       use System.Val_LLF;\n+with System.Val_LFlt;     use System.Val_LFlt;\n with System.WCh_Con;      use System.WCh_Con;\n with System.WCh_WtS;      use System.WCh_WtS;\n \n@@ -45,7 +46,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32 is Interfaces.Integer_32; use type Int32;\n    subtype Int64 is Interfaces.Integer_64; use type Int64;\n@@ -56,8 +57,9 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n    package Aux64 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n@@ -161,7 +163,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                                -Num'Small_Numerator,\n                                -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -201,7 +203,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (S, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (S, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -229,8 +231,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                     -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -262,7 +263,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (S, Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "d74902e8b30bc4550ea2b5d4d9e79df80e9b7fa0", "filename": "gcc/ada/libgnat/a-wtfiio__128.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -35,10 +35,11 @@ with Ada.Wide_Text_IO.Float_Aux;\n with System.Img_Fixed_32;  use System.Img_Fixed_32;\n with System.Img_Fixed_64;  use System.Img_Fixed_64;\n with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Img_LFlt;      use System.Img_LFlt;\n with System.Val_Fixed_32;  use System.Val_Fixed_32;\n with System.Val_Fixed_64;  use System.Val_Fixed_64;\n with System.Val_Fixed_128; use System.Val_Fixed_128;\n-with System.Val_LLF;       use System.Val_LLF;\n+with System.Val_LFlt;      use System.Val_LFlt;\n with System.WCh_Con;       use System.WCh_Con;\n with System.WCh_WtS;       use System.WCh_WtS;\n \n@@ -47,7 +48,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32  is Interfaces.Integer_32;  use type Int32;\n    subtype Int64  is Interfaces.Integer_64;  use type Int64;\n@@ -62,8 +63,9 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n    package Aux128 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n@@ -201,7 +203,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -246,7 +248,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                                  -Num'Small_Numerator,\n                                  -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (S, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (S, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -278,8 +280,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -315,7 +316,7 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n                       -Num'Small_Numerator, -Num'Small_Denominator,\n                       For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (S, Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "6f486b700316e5f16861415a62ff442266feef02", "filename": "gcc/ada/libgnat/a-wtflau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtflau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,7 +31,7 @@\n \n with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n+with System.Img_Util; use System.Img_Util;\n \n package body Ada.Wide_Text_IO.Float_Aux is\n \n@@ -96,7 +96,7 @@ package body Ada.Wide_Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real (Long_Long_Float (Item), Buf, Ptr, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n    end Put;\n \n@@ -114,8 +114,7 @@ package body Ada.Wide_Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real\n-        (Long_Long_Float (Item), Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n+      Set_Image (Item, Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;"}, {"sha": "0303b6323b27d0fb7d1291520e4038147e35ac53", "filename": "gcc/ada/libgnat/a-wtflau.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtflau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -45,6 +45,14 @@ private generic\n       Ptr : not null access Integer;\n       Max : Integer) return Num;\n \n+   with procedure Set_Image\n+     (V    : Num;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n package Ada.Wide_Text_IO.Float_Aux is\n \n    procedure Get"}, {"sha": "acbe1f526598b484437036eea584a89e8034ac11", "filename": "gcc/ada/libgnat/a-wtflio.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-wtflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtflio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -30,6 +30,9 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n@@ -39,13 +42,15 @@ with System.WCh_WtS;  use System.WCh_WtS;\n package body Ada.Wide_Text_IO.Float_IO is\n \n    package Aux_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Wide_Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Wide_Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "a36782787d4c9c8a8164ca77cbb2d9e489269b4f", "filename": "gcc/ada/libgnat/a-ztcoau.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztcoau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,8 +31,6 @@\n \n with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n-\n package body Ada.Wide_Wide_Text_IO.Complex_Aux is\n \n    ---------\n@@ -171,9 +169,9 @@ package body Ada.Wide_Wide_Text_IO.Complex_Aux is\n       --  Both parts are initially converted with a Fore of 0\n \n       Rptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemR), R_String, Rptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemR, R_String, Rptr, 0, Aft, Exp);\n       Iptr := 0;\n-      Set_Image_Real (Long_Long_Float (ItemI), I_String, Iptr, 0, Aft, Exp);\n+      Aux.Set_Image (ItemI, I_String, Iptr, 0, Aft, Exp);\n \n       --  Check room for both parts plus parens plus comma (RM G.1.3(34))\n "}, {"sha": "953ed5d9a184302d7d4d6066b6ac83c65b00c748", "filename": "gcc/ada/libgnat/a-ztcoau.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztcoau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -26,7 +26,7 @@ private generic\n \n    type Num is digits <>;\n \n-   with package Aux is new Ada.Wide_Wide_Text_IO.Float_Aux (Num, <>);\n+   with package Aux is new Ada.Wide_Wide_Text_IO.Float_Aux (Num, <>, <>);\n \n package Ada.Wide_Wide_Text_IO.Complex_Aux is\n "}, {"sha": "9ec590a9423b4e4761716c9177816c5dc114d471", "filename": "gcc/ada/libgnat/a-ztcoio.adb", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztcoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztcoio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,6 +31,9 @@\n \n with Ada.Wide_Wide_Text_IO.Complex_Aux;\n with Ada.Wide_Wide_Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n@@ -42,23 +45,25 @@ package body Ada.Wide_Wide_Text_IO.Complex_IO is\n    use Complex_Types;\n \n    package Scalar_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Scalar_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Scalar_Long_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    package Aux_Float is new\n-      Ada.Wide_Wide_Text_IO.Complex_Aux (Float, Scalar_Float);\n+     Ada.Wide_Wide_Text_IO.Complex_Aux (Float, Scalar_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Complex_Aux (Long_Float, Scalar_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Complex_Aux\n-        (Long_Long_Float, Scalar_Long_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Complex_Aux\n+       (Long_Long_Float, Scalar_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "5983e0ed6b16887ed52cfe304b1a1777d1e35845", "filename": "gcc/ada/libgnat/a-ztexio.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztexio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztexio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztexio.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -73,9 +73,6 @@ package Ada.Wide_Wide_Text_IO is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value, then it\n-   --  will be necessary to change the corresponding value in System.Img_Real\n-   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "5c12e2a0768cb2ef0e8387e35612534a224e55b3", "filename": "gcc/ada/libgnat/a-ztfiio.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,9 +34,10 @@ with Ada.Wide_Wide_Text_IO.Fixed_Aux;\n with Ada.Wide_Wide_Text_IO.Float_Aux;\n with System.Img_Fixed_32; use System.Img_Fixed_32;\n with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Img_LFlt;     use System.Img_LFlt;\n with System.Val_Fixed_32; use System.Val_Fixed_32;\n with System.Val_Fixed_64; use System.Val_Fixed_64;\n-with System.Val_LLF;      use System.Val_LLF;\n+with System.Val_LFlt;     use System.Val_LFlt;\n with System.WCh_Con;      use System.WCh_Con;\n with System.WCh_WtS;      use System.WCh_WtS;\n \n@@ -45,7 +46,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32 is Interfaces.Integer_32; use type Int32;\n    subtype Int64 is Interfaces.Integer_64; use type Int64;\n@@ -56,8 +57,9 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n    package Aux64 is new\n      Ada.Wide_Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Wide_Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n@@ -161,7 +163,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                                -Num'Small_Numerator,\n                                -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -201,7 +203,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (S, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (S, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -229,8 +231,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                     -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -262,7 +263,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (S, Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "f089fd64922fb5e5fd3596b830b12e08e2cfa325", "filename": "gcc/ada/libgnat/a-ztfiio__128.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -35,10 +35,11 @@ with Ada.Wide_Wide_Text_IO.Float_Aux;\n with System.Img_Fixed_32;  use System.Img_Fixed_32;\n with System.Img_Fixed_64;  use System.Img_Fixed_64;\n with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Img_LFlt;      use System.Img_LFlt;\n with System.Val_Fixed_32;  use System.Val_Fixed_32;\n with System.Val_Fixed_64;  use System.Val_Fixed_64;\n with System.Val_Fixed_128; use System.Val_Fixed_128;\n-with System.Val_LLF;       use System.Val_LLF;\n+with System.Val_LFlt;      use System.Val_LFlt;\n with System.WCh_Con;       use System.WCh_Con;\n with System.WCh_WtS;       use System.WCh_WtS;\n \n@@ -47,7 +48,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n    --  Note: we still use the floating-point I/O routines for types whose small\n    --  is not the ratio of two sufficiently small integers. This will result in\n    --  inaccuracies for fixed point types that require more precision than is\n-   --  available in Long_Long_Float.\n+   --  available in Long_Float.\n \n    subtype Int32  is Interfaces.Integer_32;  use type Int32;\n    subtype Int64  is Interfaces.Integer_64;  use type Int64;\n@@ -63,8 +64,9 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n      Ada.Wide_Wide_Text_IO.Fixed_Aux\n       (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   package Aux_Long_Long_Float is new\n-     Ada.Wide_Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+   package Aux_Long_Float is new\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n@@ -202,7 +204,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                                 -Num'Small_Numerator,\n                                 -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Get (File, Long_Long_Float (Item), Width);\n+         Aux_Long_Float.Get (File, Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -247,7 +249,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                                  -Num'Small_Numerator,\n                                  -Num'Small_Denominator));\n       else\n-         Aux_Long_Long_Float.Gets (S, Long_Long_Float (Item), Last);\n+         Aux_Long_Float.Gets (S, Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -279,8 +281,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                      -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Put\n-           (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+         Aux_Long_Float.Put (File, Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -316,7 +317,7 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n                       -Num'Small_Numerator, -Num'Small_Denominator,\n                       For0, Num'Aft);\n       else\n-         Aux_Long_Long_Float.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+         Aux_Long_Float.Puts (S, Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "d7dd9e22319eab69ba7dfb1c9495b65bbf065547", "filename": "gcc/ada/libgnat/a-ztflau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztflau.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,7 +31,7 @@\n \n with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n \n-with System.Img_Real; use System.Img_Real;\n+with System.Img_Util; use System.Img_Util;\n \n package body Ada.Wide_Wide_Text_IO.Float_Aux is\n \n@@ -96,7 +96,7 @@ package body Ada.Wide_Wide_Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real (Long_Long_Float (Item), Buf, Ptr, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n    end Put;\n \n@@ -114,8 +114,7 @@ package body Ada.Wide_Wide_Text_IO.Float_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Real\n-        (Long_Long_Float (Item), Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n+      Set_Image (Item, Buf, Ptr, Fore => 1, Aft => Aft, Exp => Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;"}, {"sha": "769e20ec55781dd18a9d221a2d393d4ec50f00fa", "filename": "gcc/ada/libgnat/a-ztflau.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztflau.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -45,6 +45,14 @@ private generic\n       Ptr : not null access Integer;\n       Max : Integer) return Num;\n \n+   with procedure Set_Image\n+     (V    : Num;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n package Ada.Wide_Wide_Text_IO.Float_Aux is\n \n    procedure Get"}, {"sha": "755069569e7cd2f85442d0de0dcc311463a901d1", "filename": "gcc/ada/libgnat/a-ztflio.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fa-ztflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztflio.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -30,6 +30,9 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Wide_Text_IO.Float_Aux;\n+with System.Img_Flt;  use System.Img_Flt;\n+with System.Img_LFlt; use System.Img_LFlt;\n+with System.Img_LLF;  use System.Img_LLF;\n with System.Val_Flt;  use System.Val_Flt;\n with System.Val_LFlt; use System.Val_LFlt;\n with System.Val_LLF;  use System.Val_LLF;\n@@ -39,13 +42,15 @@ with System.WCh_WtS;  use System.WCh_WtS;\n package body Ada.Wide_Wide_Text_IO.Float_IO is\n \n    package Aux_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Float, Scan_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux (Float, Scan_Float, Set_Image_Float);\n \n    package Aux_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Long_Float, Scan_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Float, Scan_Long_Float, Set_Image_Long_Float);\n \n    package Aux_Long_Long_Float is new\n-      Ada.Wide_Wide_Text_IO.Float_Aux (Long_Long_Float, Scan_Long_Long_Float);\n+     Ada.Wide_Wide_Text_IO.Float_Aux\n+       (Long_Long_Float, Scan_Long_Long_Float, Set_Image_Long_Long_Float);\n \n    --  Throughout this generic body, we distinguish between the case where type\n    --  Float is OK, where type Long_Float is OK and where type Long_Long_Float"}, {"sha": "6ae163219894cd860348391998f7a6511f6e8e08", "filename": "gcc/ada/libgnat/s-dorepr.adb", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dorepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dorepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dorepr.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,154 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            S Y S T E M . D O U B L E _ R E A L . P R O D U C T           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default version of the separate package body\n+\n+with Interfaces; use Interfaces;\n+\n+separate (System.Double_Real)\n+\n+package body Product is\n+\n+   procedure Split (N : Num; Hi : out Num; Lo : out Num);\n+   --  Compute high word and low word of N\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   --  We use a bit manipulation algorithm instead of Veltkamp's splitting\n+   --  because it is faster and has the property that the magnitude of the\n+   --  high part is never larger than that of the input number, which will\n+   --  avoid spurious overflows in the Two_Prod algorithm.\n+\n+   --  See the recent paper by Claude-Pierre Jeannerod, Jean-Michel Muller\n+   --  and Paul Zimmermann: On various ways to split a floating-point number\n+   --  ARITH 2018 - 25th IEEE Symposium on Computer Arithmetic, Jun 2018,\n+   --  Amherst (MA), United States. pp.53-60.\n+\n+   procedure Split (N : Num; Hi : out Num; Lo : out Num) is\n+      M : constant Positive := Num'Machine_Mantissa;\n+\n+      Rep32 : Interfaces.Unsigned_32;\n+      Rep64 : Interfaces.Unsigned_64;\n+      Rep80 : array (1 .. 2) of Interfaces.Unsigned_64;\n+\n+      X : Num;\n+      for X'Address use (case M is when 24 => Rep32'Address,\n+                                   when 53 => Rep64'Address,\n+                                   when 64 => Rep80'Address,\n+                                   when others => raise Program_Error);\n+\n+   begin\n+      X := N;\n+\n+      case M is\n+         when 24 =>\n+            --  Mask out the low 12 bits\n+\n+            Rep32 := Rep32 and 16#FFFFF000#;\n+\n+         when 53 =>\n+            --  Mask out the low 27 bits\n+\n+            Rep64 := Rep64 and 16#FFFFFFFFF8000000#;\n+\n+         when 64 =>\n+            --  Mask out the low 32 bits\n+\n+            if System.Default_Bit_Order = High_Order_First then\n+               Rep80 (1) := Rep80 (1) and 16#FFFFFFFFFFFF0000#;\n+               Rep80 (2) := Rep80 (2) and 16#0000FFFFFFFFFFFF#;\n+            else\n+               Rep80 (1) := Rep80 (1) and 16#FFFFFFFF00000000#;\n+            end if;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+      --  Deal with denormalized numbers\n+\n+      if X = 0.0 then\n+         Hi := N;\n+         Lo := 0.0;\n+      else\n+         Hi := X;\n+         Lo := N - X;\n+      end if;\n+   end Split;\n+\n+   --------------\n+   -- Two_Prod --\n+   --------------\n+\n+   function Two_Prod (A, B : Num) return Double_T is\n+      P : constant Num := A * B;\n+\n+      Ahi, Alo, Bhi, Blo, E : Num;\n+\n+   begin\n+      if Is_Infinity (P) or else Is_Zero (P) then\n+         return (P, 0.0);\n+\n+      else\n+         Split (A, Ahi, Alo);\n+         Split (B, Bhi, Blo);\n+\n+         E := ((Ahi * Bhi - P) + Ahi * Blo + Alo * Bhi) + Alo * Blo;\n+\n+         return (P, E);\n+      end if;\n+   end Two_Prod;\n+\n+   -------------\n+   -- Two_Sqr --\n+   -------------\n+\n+   function Two_Sqr (A : Num) return Double_T is\n+      Q : constant Num := A * A;\n+\n+      Hi, Lo, E : Num;\n+\n+   begin\n+      if Is_Infinity (Q) or else Is_Zero (Q) then\n+         return (Q, 0.0);\n+\n+      else\n+         Split (A, Hi, Lo);\n+\n+         E := ((Hi * Hi - Q) + 2.0 * Hi * Lo) + Lo * Lo;\n+\n+         return (Q, E);\n+      end if;\n+   end Two_Sqr;\n+\n+end Product;"}, {"sha": "56d4dbb8285998a5cda1123b742148942d22105b", "filename": "gcc/ada/libgnat/s-dorepr__fma.adb", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dorepr__fma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dorepr__fma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dorepr__fma.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            S Y S T E M . D O U B L E _ R E A L . P R O D U C T           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version of the separate package body for targets with an FMA\n+\n+separate (System.Double_Real)\n+\n+package body Product is\n+\n+   function Fused_Multiply_Add (A, B, C : Num) return Num;\n+   --  Return the result of A * B + C without intermediate rounding\n+\n+   ------------------------\n+   -- Fused_Multiply_Add --\n+   ------------------------\n+\n+   function Fused_Multiply_Add (A, B, C : Num) return Num is\n+   begin\n+      case Num'Size is\n+         when 32 =>\n+            declare\n+               function Do_FMA (A, B, C : Num) return Num;\n+               pragma Import (Intrinsic, Do_FMA, \"__builtin_fmaf\");\n+\n+            begin\n+               return Do_FMA (A, B, C);\n+            end;\n+\n+         when 64 =>\n+            declare\n+               function Do_FMA (A, B, C : Num) return Num;\n+               pragma Import (Intrinsic, Do_FMA, \"__builtin_fma\");\n+\n+            begin\n+               return Do_FMA (A, B, C);\n+            end;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Fused_Multiply_Add;\n+\n+   --------------\n+   -- Two_Prod --\n+   --------------\n+\n+   function Two_Prod (A, B : Num) return Double_T is\n+      P : constant Num := A * B;\n+\n+      E : Num;\n+\n+   begin\n+      if Is_Infinity (P) or else Is_Zero (P) then\n+         return (P, 0.0);\n+\n+      else\n+         E := Fused_Multiply_Add (A, B, -P);\n+\n+         return (P, E);\n+      end if;\n+   end Two_Prod;\n+\n+   -------------\n+   -- Two_Sqr --\n+   -------------\n+\n+   function Two_Sqr (A : Num) return Double_T is (Two_Prod (A, A));\n+\n+end Product;"}, {"sha": "53bed1db4b39f08c4ad28a6dfe95b4bbc3bcdcc2", "filename": "gcc/ada/libgnat/s-dourea.adb", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dourea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dourea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dourea.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,258 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . D O U B L E _ R E A L                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Double_Real is\n+\n+   function Is_NaN (N : Num) return Boolean is (N /= N);\n+   --  Return True if N is a NaN\n+\n+   function Is_Infinity (N : Num) return Boolean is (Is_NaN (N - N));\n+   --  Return True if N is an infinity. Used to avoid propagating meaningless\n+   --  errors when the result of a product is an infinity.\n+\n+   function Is_Zero (N : Num) return Boolean is (N = -N);\n+   --  Return True if N is a Zero. Used to preserve the sign when the result of\n+   --  a product is a zero.\n+\n+   package Product is\n+      function Two_Prod (A, B : Num) return Double_T;\n+      function Two_Sqr (A : Num) return Double_T;\n+   end Product;\n+   --  The low-level implementation of multiplicative operations\n+\n+   package body Product is separate;\n+   --  This is a separate body because the implementation depends on whether a\n+   --  Fused Multiply-Add instruction is available on the target.\n+\n+   -------------------\n+   -- Quick_Two_Sum --\n+   -------------------\n+\n+   function Quick_Two_Sum (A, B : Num) return Double_T is\n+      S : constant Num := A + B;\n+      V : constant Num := S - A;\n+      E : constant Num := B - V;\n+\n+   begin\n+      return (S, E);\n+   end Quick_Two_Sum;\n+\n+   -------------\n+   -- Two_Sum --\n+   -------------\n+\n+   function Two_Sum (A, B : Num) return Double_T is\n+      S : constant Num := A + B;\n+      V : constant Num := S - A;\n+      E : constant Num := (A - (S - V)) + (B - V);\n+\n+   begin\n+      return (S, E);\n+   end Two_Sum;\n+\n+   --------------\n+   -- Two_Diff --\n+   --------------\n+\n+   function Two_Diff (A, B : Num) return Double_T is\n+      S : constant Num := A - B;\n+      V : constant Num := S - A;\n+      E : constant Num := (A - (S - V)) - (B + V);\n+\n+   begin\n+      return (S, E);\n+   end Two_Diff;\n+\n+   --------------\n+   -- Two_Prod --\n+   --------------\n+\n+   function Two_Prod (A, B : Num) return Double_T renames Product.Two_Prod;\n+\n+   -------------\n+   -- Two_Sqr --\n+   -------------\n+\n+   function Two_Sqr (A : Num) return Double_T renames Product.Two_Sqr;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (A : Double_T; B : Num) return Double_T is\n+      S : constant Double_T := Two_Sum (A.Hi, B);\n+\n+   begin\n+      return Quick_Two_Sum (S.Hi, S.Lo + A.Lo);\n+   end \"+\";\n+\n+   function \"+\" (A, B : Double_T) return Double_T is\n+      S1 : constant Double_T := Two_Sum (A.Hi, B.Hi);\n+      S2 : constant Double_T := Two_Sum (A.Lo, B.Lo);\n+      S3 : constant Double_T := Quick_Two_Sum (S1.Hi, S1.Lo + S2.Hi);\n+\n+   begin\n+      return Quick_Two_Sum (S3.Hi, S3.Lo + S2.Lo);\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (A : Double_T; B : Num) return Double_T is\n+      D : constant Double_T := Two_Diff (A.Hi, B);\n+\n+   begin\n+      return Quick_Two_Sum (D.Hi, D.Lo + A.Lo);\n+   end \"-\";\n+\n+   function \"-\" (A, B : Double_T) return Double_T is\n+      D1 : constant Double_T := Two_Diff (A.Hi, B.Hi);\n+      D2 : constant Double_T := Two_Diff (A.Lo, B.Lo);\n+      D3 : constant Double_T := Quick_Two_Sum (D1.Hi, D1.Lo + D2.Hi);\n+\n+   begin\n+      return Quick_Two_Sum (D3.Hi, D3.Lo + D2.Lo);\n+   end \"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (A : Double_T; B : Num) return Double_T is\n+      P : constant Double_T := Two_Prod (A.Hi, B);\n+\n+   begin\n+      if Is_Infinity (P.Hi) or else Is_Zero (P.Hi) then\n+         return (P.Hi, 0.0);\n+      else\n+         return Quick_Two_Sum (P.Hi, P.Lo + A.Lo * B);\n+      end if;\n+   end \"*\";\n+\n+   function \"*\" (A, B : Double_T) return Double_T is\n+      P : constant Double_T := Two_Prod (A.Hi, B.Hi);\n+\n+   begin\n+      if Is_Infinity (P.Hi) or else Is_Zero (P.Hi) then\n+         return (P.Hi, 0.0);\n+      else\n+         return Quick_Two_Sum (P.Hi, P.Lo + A.Hi * B.Lo + A.Lo * B.Hi);\n+      end if;\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (A : Double_T; B : Num) return Double_T is\n+      Q1, Q2 : Num;\n+      P, R   : Double_T;\n+\n+   begin\n+      Q1 := A.Hi / B;\n+\n+      --  Compute R = A - B * Q1\n+\n+      P := Two_Prod (B, Q1);\n+      R := Two_Diff (A.Hi, P.Hi);\n+      R.Lo := (R.Lo + A.Lo) - P.Lo;\n+\n+      Q2 := (R.Hi + R.Lo) / B;\n+\n+      return Quick_Two_Sum (Q1, Q2);\n+   end \"/\";\n+\n+   function \"/\" (A, B : Double_T) return Double_T is\n+      Q1, Q2, Q3 : Num;\n+      R, S       : Double_T;\n+\n+   begin\n+      Q1 := A.Hi / B.Hi;\n+      R := A - B * Q1;\n+\n+      Q2 := R.Hi / B.Hi;\n+      R := R - B * Q2;\n+\n+      Q3 := R.Hi / B.Hi;\n+\n+      S := Quick_Two_Sum (Q1, Q2);\n+      return Quick_Two_Sum (S.Hi, S.Lo + Q3);\n+   end \"/\";\n+\n+   ---------\n+   -- Sqr --\n+   ---------\n+\n+   function Sqr (A : Double_T) return Double_T is\n+      Q : constant Double_T := Two_Sqr (A.Hi);\n+\n+   begin\n+      if Is_Infinity (Q.Hi) or else Is_Zero (Q.Hi) then\n+         return (Q.Hi, 0.0);\n+      else\n+         return Quick_Two_Sum (Q.Hi, Q.Lo + 2.0 * A.Hi * A.Lo + A.Lo * A.Lo);\n+      end if;\n+   end Sqr;\n+\n+   -------------------\n+   -- From_Unsigned --\n+   -------------------\n+\n+   function From_Unsigned (U : Uns) return Double_T is\n+   begin\n+      return To_Double (Num (U));\n+   end From_Unsigned;\n+\n+   -----------------\n+   -- To_Unsigned --\n+   -----------------\n+\n+   function To_Unsigned (D : Double_T) return Uns is\n+      Hi : constant Num := Num'Truncation (D.Hi);\n+\n+   begin\n+      --  If the high part is already an integer, add Floor of the low part,\n+      --  which means subtract Ceiling of its opposite if it is negative.\n+\n+      if Hi = D.Hi then\n+         if D.Lo < 0.0 then\n+            return Uns (Hi) - Uns (Num'Ceiling (-D.Lo));\n+         else\n+            return Uns (Hi) + Uns (Num'Floor (D.Lo));\n+         end if;\n+\n+      else\n+         return Uns (Hi);\n+      end if;\n+   end To_Unsigned;\n+\n+end System.Double_Real;"}, {"sha": "0c97f346bbd040f15ee30858da23e35f8002333b", "filename": "gcc/ada/libgnat/s-dourea.ads", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dourea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-dourea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dourea.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,123 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . D O U B L E _ R E A L                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for supporting floating-point computations\n+--  in double precision, i.e. using a second number to estimate the error due\n+--  to rounding and more generally performing computations with twice as many\n+--  bits of mantissa. It is based on the Double-Double library available at\n+--  https://www.davidhbailey.com/dhbsoftware written by David H.Bailey et al.\n+\n+generic\n+\n+   type Num is digits <>;\n+\n+package System.Double_Real is\n+   pragma Pure;\n+\n+   type Double_T is record\n+     Hi, Lo : Num;\n+   end record;\n+\n+   function To_Double (N : Num) return Double_T is ((Hi => N, Lo => 0.0));\n+   --  Convert a single to a double real\n+\n+   function To_Single (D : Double_T) return Num is (D.Hi);\n+   --  Convert a double to a single real\n+\n+   function Quick_Two_Sum (A, B : Num) return Double_T\n+     with Pre => A = 0.0 or else abs (A) >= abs (B);\n+   --  Compute A + B and its rounding error exactly, but assume |A| >= |B|\n+\n+   function Two_Sum (A, B : Num) return Double_T;\n+   --  Compute A + B and its rounding error exactly\n+\n+   function Two_Diff (A, B : Num) return Double_T;\n+   --  Compute A - B and its rounding error exactly\n+\n+   function Two_Prod (A, B : Num) return Double_T;\n+   --  Compute A * B and its rounding error exactly\n+\n+   function Two_Sqr (A : Num) return Double_T;\n+   --  Compute A * A and its rounding error exactly\n+\n+   function \"+\" (A : Double_T; B : Num) return Double_T;\n+   function \"-\" (A : Double_T; B : Num) return Double_T;\n+   function \"*\" (A : Double_T; B : Num) return Double_T;\n+   function \"/\" (A : Double_T; B : Num) return Double_T\n+     with Pre => B /= 0.0;\n+   --  Mixed precision arithmetic operations\n+\n+   function \"+\" (A, B : Double_T) return Double_T;\n+   function \"-\" (A, B : Double_T) return Double_T;\n+   function \"*\" (A, B : Double_T) return Double_T;\n+   function \"/\" (A, B : Double_T) return Double_T\n+     with Pre => B.Hi /= 0.0;\n+   --  Double precision arithmetic operations\n+\n+   function Sqr (A : Double_T) return Double_T;\n+   --  Faster version of A * A\n+\n+   function \"=\" (A : Double_T; B : Num) return Boolean is\n+     (A.Hi = B and then A.Lo = 0.0);\n+   function \"<\" (A : Double_T; B : Num) return Boolean is\n+     (A.Hi < B or else (A.Hi = B and then A.Lo < 0.0));\n+   function \"<=\" (A : Double_T; B : Num) return Boolean is\n+     (A.Hi < B or else (A.Hi = B and then A.Lo <= 0.0));\n+   function \">\" (A : Double_T; B : Num) return Boolean is\n+     (A.Hi > B or else (A.Hi = B and then A.Lo > 0.0));\n+   function \">=\" (A : Double_T; B : Num) return Boolean is\n+     (A.Hi > B or else (A.Hi = B and then A.Lo >= 0.0));\n+   --  Mixed precision comparisons\n+\n+   function \"=\" (A, B : Double_T) return Boolean is\n+     (A.Hi = B.Hi and then A.Lo = B.Lo);\n+   function \"<\" (A, B : Double_T) return Boolean is\n+     (A.Hi < B.Hi or else (A.Hi = B.Hi and then A.Lo < B.Lo));\n+   function \"<=\" (A, B : Double_T) return Boolean is\n+     (A.Hi < B.Hi or else (A.Hi = B.Hi and then A.Lo <= B.Lo));\n+   function \">\" (A, B : Double_T) return Boolean is\n+     (A.Hi > B.Hi or else (A.Hi = B.Hi and then A.Lo > B.Lo));\n+   function \">=\" (A, B : Double_T) return Boolean is\n+     (A.Hi > B.Hi or else (A.Hi = B.Hi and then A.Lo >= B.Lo));\n+   --  Double precision comparisons\n+\n+   generic\n+      type Uns is mod <>;\n+   function From_Unsigned (U : Uns) return Double_T;\n+   --  Convert Uns to Double_T\n+\n+   generic\n+      type Uns is mod <>;\n+   function To_Unsigned (D : Double_T) return Uns\n+     with Pre => D >= 0.0;\n+   --  Convert Double_T to Uns with truncation\n+\n+end System.Double_Real;"}, {"sha": "739ac921302bca6c552d96147bf18bf7fb424239", "filename": "gcc/ada/libgnat/s-forrea.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-forrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-forrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-forrea.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -31,12 +31,12 @@\n \n package body System.Fore_Real is\n \n-   ---------------\n-   -- Fore_Real --\n-   ---------------\n+   ----------------\n+   -- Fore_Fixed --\n+   ----------------\n \n-   function Fore_Real (Lo, Hi : Long_Long_Float) return Natural is\n-      T : Long_Long_Float := Long_Long_Float'Max (abs Lo, abs Hi);\n+   function Fore_Fixed (Lo, Hi : Long_Float) return Natural is\n+      T : Long_Float := Long_Float'Max (abs Lo, abs Hi);\n       F : Natural;\n \n    begin\n@@ -52,6 +52,6 @@ package body System.Fore_Real is\n       end loop;\n \n       return F;\n-   end Fore_Real;\n+   end Fore_Fixed;\n \n end System.Fore_Real;"}, {"sha": "73784c0a93aa9279f150ea2e92ea24f4bd902d75", "filename": "gcc/ada/libgnat/s-forrea.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-forrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-forrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-forrea.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -29,14 +29,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for the Fore attribute of ordinary\n---  fixed point types whose Small is neither an integer nor its reciprocal.\n+--  This package contains the routine for the Fore attribute of ordinary fixed\n+--  point types whose Small is not a ratio of two sufficiently small integers.\n \n package System.Fore_Real is\n    pragma Pure;\n \n-   function Fore_Real (Lo, Hi : Long_Long_Float) return Natural;\n+   function Fore_Fixed (Lo, Hi : Long_Float) return Natural;\n    --  Compute Fore attribute value for a fixed point type. The parameters\n-   --  are the low and high bounds, converted to Long_Long_Float.\n+   --  are the low and high bounds, converted to Long_Float.\n \n end System.Fore_Real;"}, {"sha": "cac268a753ddc837a0617fb9f8d6f580192ca0e7", "filename": "gcc/ada/libgnat/s-imagef.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -60,7 +60,7 @@ package System.Image_F is\n    --  For0 and Aft0 are the values of the Fore and Aft attributes for the\n    --  fixed point type whose mantissa type is Int and whose small is Num/Den.\n    --  This function is used only for fixed point whose Small is an integer or\n-   --  its reciprocal (see package System.Img_Real for the handling of other\n+   --  its reciprocal (see package System.Image_R for the handling of other\n    --  ordinary fixed-point types). The caller guarantees that S is long enough\n    --  to hold the result and has a lower bound of 1.\n "}, {"sha": "882bb27a60c7310be9ab7fabde33617d962d5275", "filename": "gcc/ada/libgnat/s-imager.adb", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imager.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imager.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imager.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,464 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ R                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Double_Real;\n+with System.Float_Control;\n+with System.Img_Util; use System.Img_Util;\n+\n+package body System.Image_R is\n+\n+   --  The following defines the maximum number of digits that we can convert\n+   --  accurately. This is limited by the precision of the Num type, and also\n+   --  by the number of digits that can be held in the Uns type, which is the\n+   --  integer type we use as an intermediate in the computation. But, in both\n+   --  cases, we can work with a double value in these types.\n+\n+   --  Note that in the following, the \"-2\" accounts for the space and one\n+   --  extra digit, since we need the maximum number of 9's that can be\n+   --  represented, e.g. for the 64-bit case, Long_Long_Unsigned'Width is\n+   --  21, since the maximum value (approx 1.8E+19) has 20 digits, but the\n+   --  maximum number of 9's that can be represented is only 19.\n+\n+   Maxdigs : constant Natural := 2 * Natural'Min (Uns'Width - 2, Num'Digits);\n+\n+   Maxscaling : constant := 5000;\n+   --  Max decimal scaling required during conversion of floating-point\n+   --  numbers to decimal. This is used to defend against infinite\n+   --  looping in the conversion, as can be caused by erroneous executions.\n+   --  The largest exponent used on any current system is 2**16383, which\n+   --  is approximately 10**4932, and the highest number of decimal digits\n+   --  is about 35 for 128-bit floating-point formats, so 5000 leaves\n+   --  enough room for scaling such values\n+\n+   package Double_Real is new System.Double_Real (Num);\n+   use type Double_Real.Double_T;\n+\n+   subtype Double_T is Double_Real.Double_T;\n+   --  The double floating-point type\n+\n+   function From_Unsigned is new Double_Real.From_Unsigned (Uns);\n+   function To_Unsigned is new Double_Real.To_Unsigned (Uns);\n+   --  Convert betwwen a double Num and a single Uns\n+\n+   function Is_Negative (V : Num) return Boolean;\n+   --  Return True if V is negative for the purpose of the output, i.e. return\n+   --  True for negative zeros only if Signed_Zeros is True.\n+\n+   -----------------------\n+   -- Image_Fixed_Point --\n+   -----------------------\n+\n+   procedure Image_Fixed_Point\n+     (V   : Num;\n+      S   : in out String;\n+      P   : out Natural;\n+      Aft : Natural)\n+   is\n+      pragma Assert (S'First = 1);\n+\n+   begin\n+      --  Output space at start if non-negative\n+\n+      if V >= 0.0 then\n+         S (1) := ' ';\n+         P := 1;\n+      else\n+         P := 0;\n+      end if;\n+\n+      Set_Image_Real (V, S, P, 1, Aft, 0);\n+   end Image_Fixed_Point;\n+\n+   --------------------------\n+   -- Image_Floating_Point --\n+   --------------------------\n+\n+   procedure Image_Floating_Point\n+     (V    : Num;\n+      S    : in out String;\n+      P    : out Natural;\n+      Digs : Natural)\n+   is\n+      pragma Assert (S'First = 1);\n+\n+   begin\n+      --  Decide whether a blank should be prepended before the call to\n+      --  Set_Image_Real. We generate a blank for positive values, and\n+      --  also for positive zeros. For negative zeros, we generate a\n+      --  blank only if Signed_Zeros is False (the RM only permits the\n+      --  output of -0.0 when Signed_Zeros is True). We do not generate\n+      --  a blank for positive infinity, since we output an explicit +.\n+\n+      if not Is_Negative (V) and then V <= Num'Last then\n+         pragma Annotate (CodePeer, False_Positive, \"condition predetermined\",\n+                          \"CodePeer analysis ignores NaN and Inf values\");\n+         pragma Assert (S'Last > 1);\n+         --  The caller is responsible for S to be large enough for all\n+         --  Image_Floating_Point operation.\n+         S (1) := ' ';\n+         P := 1;\n+      else\n+         P := 0;\n+      end if;\n+\n+      Set_Image_Real (V, S, P, 1, Digs - 1, 3);\n+   end Image_Floating_Point;\n+\n+   -----------------\n+   -- Is_Negative --\n+   -----------------\n+\n+   function Is_Negative (V : Num) return Boolean is\n+   begin\n+      if V < 0.0 then\n+         return True;\n+\n+      elsif V > 0.0 then\n+         return False;\n+\n+      elsif not Num'Signed_Zeros then\n+         return False;\n+\n+      else\n+         return Num'Copy_Sign (1.0, V) < 0.0;\n+      end if;\n+   end Is_Negative;\n+\n+   --------------------\n+   -- Set_Image_Real --\n+   --------------------\n+\n+   procedure Set_Image_Real\n+     (V    : Num;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+   is\n+      Powten : constant array (0 .. Maxpow) of Double_T;\n+      pragma Import (Ada, Powten);\n+      for Powten'Address use Powten_Address;\n+\n+      NFrac : constant Natural := Natural'Max (Aft, 1);\n+      --  Number of digits after the decimal point\n+\n+      Digs : String (1 .. 3 + Maxdigs);\n+      --  Array used to hold digits of converted integer value\n+\n+      Ndigs : Natural;\n+      --  Number of digits stored in Digs (and also subscript of last digit)\n+\n+      Scale : Integer := 0;\n+      --  Exponent such that the result is Digs (1 .. NDigs) * 10**(-Scale)\n+\n+      X : Double_T;\n+      --  Current absolute value of the input after scaling\n+\n+      procedure Adjust_Scale (S : Natural);\n+      --  Adjusts the value in X by multiplying or dividing by a power of\n+      --  ten so that it is in the range 10**(S-1) <= X < 10**S. Scale is\n+      --  adjusted to reflect the power of ten used to divide the result,\n+      --  i.e. one is added to the scale value for each multiplication by\n+      --  10.0 and one is subtracted for each division by 10.0.\n+\n+      ------------------\n+      -- Adjust_Scale --\n+      ------------------\n+\n+      procedure Adjust_Scale (S : Natural) is\n+         Lo, Mid, Hi : Natural;\n+         XP : Double_T;\n+\n+      begin\n+         --  Cases where scaling up is required\n+\n+         if X < Powten (S - 1) then\n+\n+            --  What we are looking for is a power of ten to multiply X by\n+            --  so that the result lies within the required range.\n+\n+            loop\n+               XP := X * Powten (Maxpow);\n+               exit when XP >= Powten (S - 1) or else Scale > Maxscaling;\n+               X := XP;\n+               Scale := Scale + Maxpow;\n+            end loop;\n+\n+            --  The following exception is only raised in case of erroneous\n+            --  execution, where a number was considered valid but still\n+            --  fails to scale up. One situation where this can happen is\n+            --  when a system which is supposed to be IEEE-compliant, but\n+            --  has been reconfigured to flush denormals to zero.\n+\n+            if Scale > Maxscaling then\n+               raise Constraint_Error;\n+            end if;\n+\n+            --  Here we know that we must multiply by at least 10**1 and that\n+            --  10**Maxpow takes us too far: binary search to find right one.\n+\n+            --  Because of roundoff errors, it is possible for the value\n+            --  of XP to be just outside of the interval when Lo >= Hi. In\n+            --  that case we adjust explicitly by a factor of 10. This\n+            --  can only happen with a value that is very close to an\n+            --  exact power of 10.\n+\n+            Lo := 1;\n+            Hi := Maxpow;\n+\n+            loop\n+               Mid := (Lo + Hi) / 2;\n+               XP := X * Powten (Mid);\n+\n+               if XP < Powten (S - 1) then\n+\n+                  if Lo >= Hi then\n+                     Mid := Mid + 1;\n+                     XP := XP * 10.0;\n+                     exit;\n+\n+                  else\n+                     Lo := Mid + 1;\n+                  end if;\n+\n+               elsif XP >= Powten (S) then\n+\n+                  if Lo >= Hi then\n+                     Mid := Mid - 1;\n+                     XP := XP / 10.0;\n+                     exit;\n+\n+                  else\n+                     Hi := Mid - 1;\n+                  end if;\n+\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            X := XP;\n+            Scale := Scale + Mid;\n+\n+         --  Cases where scaling down is required\n+\n+         elsif X >= Powten (S) then\n+\n+            --  What we are looking for is a power of ten to divide X by\n+            --  so that the result lies within the required range.\n+\n+            loop\n+               XP := X / Powten (Maxpow);\n+               exit when XP < Powten (S) or else Scale < -Maxscaling;\n+               X := XP;\n+               Scale := Scale - Maxpow;\n+            end loop;\n+\n+            --  The following exception is only raised in case of erroneous\n+            --  execution, where a number was considered valid but still\n+            --  fails to scale up. One situation where this can happen is\n+            --  when a system which is supposed to be IEEE-compliant, but\n+            --  has been reconfigured to flush denormals to zero.\n+\n+            if Scale < -Maxscaling then\n+               raise Constraint_Error;\n+            end if;\n+\n+            --  Here we know that we must divide by at least 10**1 and that\n+            --  10**Maxpow takes us too far, binary search to find right one.\n+\n+            Lo := 1;\n+            Hi := Maxpow;\n+\n+            loop\n+               Mid := (Lo + Hi) / 2;\n+               XP := X / Powten (Mid);\n+\n+               if XP < Powten (S - 1) then\n+\n+                  if Lo >= Hi then\n+                     XP := XP * 10.0;\n+                     Mid := Mid - 1;\n+                     exit;\n+\n+                  else\n+                     Hi := Mid - 1;\n+                  end if;\n+\n+               elsif XP >= Powten (S) then\n+\n+                  if Lo >= Hi then\n+                     XP := XP / 10.0;\n+                     Mid := Mid + 1;\n+                     exit;\n+\n+                  else\n+                     Lo := Mid + 1;\n+                  end if;\n+\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            X := XP;\n+            Scale := Scale - Mid;\n+\n+         --  Here we are already scaled right\n+\n+         else\n+            null;\n+         end if;\n+      end Adjust_Scale;\n+\n+   --  Start of processing for Set_Image_Real\n+\n+   begin\n+      --  We call the floating-point processor reset routine so we can be sure\n+      --  that the processor is properly set for conversions. This is notably\n+      --  needed on Windows, where calls to the operating system randomly reset\n+      --  the processor into 64-bit mode.\n+\n+      if Num'Machine_Mantissa = 64 then\n+         System.Float_Control.Reset;\n+      end if;\n+\n+      --  Deal with invalid values first\n+\n+      if not V'Valid then\n+\n+         --  Note that we're taking our chances here, as V might be\n+         --  an invalid bit pattern resulting from erroneous execution\n+         --  (caused by using uninitialized variables for example).\n+\n+         --  No matter what, we'll at least get reasonable behavior,\n+         --  converting to infinity or some other value, or causing an\n+         --  exception to be raised is fine.\n+\n+         --  If the following two tests succeed, then we definitely have\n+         --  an infinite value, so we print +Inf or -Inf.\n+\n+         if V > Num'Last then\n+            pragma Annotate (CodePeer, False_Positive, \"dead code\",\n+                             \"CodePeer analysis ignores NaN and Inf values\");\n+            pragma Annotate (CodePeer, False_Positive, \"test always true\",\n+                             \"CodePeer analysis ignores NaN and Inf values\");\n+\n+            Set_Floating_Invalid_Value (Infinity, S, P, Fore, Aft, Exp);\n+\n+         elsif V < Num'First then\n+            Set_Floating_Invalid_Value (Minus_Infinity, S, P, Fore, Aft, Exp);\n+\n+         --  In all other cases we print NaN\n+\n+         else\n+            Set_Floating_Invalid_Value (Not_A_Number, S, P, Fore, Aft, Exp);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  Set the first character like Image\n+\n+      Digs (1) := (if Is_Negative (V) then '-' else ' ');\n+      Ndigs := 1;\n+\n+      X := Double_Real.To_Double (abs (V));\n+\n+      --  If X is zero, we are done\n+\n+      if X = 0.0 then\n+         Digs (2) := '0';\n+         Ndigs := 2;\n+\n+      --  Otherwise, scale X and convert it to an integer\n+\n+      else\n+         --  In exponent notation, we need exactly NFrac + 1 digits and always\n+         --  round the last one.\n+\n+         if Exp > 0 then\n+            Adjust_Scale (Natural'Min (NFrac + 1, Maxdigs));\n+            X := X + 0.5;\n+\n+         --  In straight notation, we compute the maximum number of digits and\n+         --  compare how many of them will be put after the decimal point with\n+         --  Nfrac, in order to find out whether we need to round the last one\n+         --  here or whether the rounding is performed by Set_Decimal_Digits.\n+\n+         else\n+            Adjust_Scale (Maxdigs);\n+            if Scale <= NFrac then\n+               X := X + 0.5;\n+            end if;\n+         end if;\n+\n+         --  If X fits in an Uns, do the conversion directly. Note that this is\n+         --  always the case for the Image attribute.\n+\n+         if X <= Num (Uns'Last) then\n+            Set_Image_Unsigned (To_Unsigned (X), Digs, Ndigs);\n+\n+         --  Otherwise, do the conversion in two steps\n+\n+         else pragma Assert (X <= 10.0 ** Num'Digits * Num (Uns'Last));\n+            declare\n+               Y : constant Uns := To_Unsigned (X / Powten (Num'Digits));\n+\n+               Buf : String (1 .. Num'Digits);\n+               Len : Natural;\n+\n+            begin\n+               Set_Image_Unsigned (Y, Digs, Ndigs);\n+\n+               X := X - From_Unsigned (Y) * Powten (Num'Digits);\n+\n+               Len := 0;\n+               Set_Image_Unsigned (To_Unsigned (X), Buf, Len);\n+\n+               for J in 1 .. Num'Digits - Len loop\n+                  Digs (Ndigs + J) := '0';\n+               end loop;\n+\n+               for J in 1 .. Len loop\n+                  Digs (Ndigs + Num'Digits - Len + J) := Buf (J);\n+               end loop;\n+\n+               Ndigs := Ndigs + Num'Digits;\n+            end;\n+         end if;\n+      end if;\n+\n+      Set_Decimal_Digits (Digs, Ndigs, S, P, Scale, Fore, Aft, Exp);\n+   end Set_Image_Real;\n+\n+end System.Image_R;"}, {"sha": "1aa86877560448a0a0d6504bf4b934ba01452762", "filename": "gcc/ada/libgnat/s-imager.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imager.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imager.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imager.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,92 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ R                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for the Image attribute of real types, and\n+--  is also for Float_IO/Fixed_IO output.\n+\n+generic\n+\n+   type Num is digits <>;\n+\n+   Maxpow : Positive;\n+\n+   Powten_Address : System.Address;\n+\n+   type Uns is mod <>;\n+\n+   with procedure Set_Image_Unsigned\n+     (V : Uns;\n+      S : in out String;\n+      P : in out Natural);\n+\n+package System.Image_R is\n+   pragma Pure;\n+\n+   procedure Image_Fixed_Point\n+     (V   : Num;\n+      S   : in out String;\n+      P   : out Natural;\n+      Aft : Natural);\n+   --  Computes fixed_type'Image (V) and returns the result in S (1 .. P)\n+   --  updating P on return. The result is computed according to the rules for\n+   --  image for fixed-point types (RM 3.5(34)), where Aft is the value of the\n+   --  Aft attribute for the fixed-point type. The caller guarantees that S is\n+   --  long enough to hold the result and has a lower bound of 1.\n+   --\n+   --  Note: this procedure should NOT be called with V = -0.0 or V = +/-Inf.\n+\n+   procedure Image_Floating_Point\n+     (V    : Num;\n+      S    : in out String;\n+      P    : out Natural;\n+      Digs : Natural);\n+   --  Computes Uns'Image (V) and returns the result in S (1 .. P) updating P\n+   --  on return. The result is computed according to the rules for image for\n+   --  floating-point types (RM 3.5(33)), where Digs is the value of the Digits\n+   --  attribute for the floating-point type. The caller guarantees that S is\n+   --  long enough to hold the result and has a lower bound of 1.\n+\n+   procedure Set_Image_Real\n+     (V    : Num;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+   --  Sets the image of V starting at S (P + 1), updating P to point to the\n+   --  last character stored, the caller promises that the buffer is large\n+   --  enough and no check is made for this. Constraint_Error will not\n+   --  necessarily be raised if this is violated, since it is perfectly valid\n+   --  to compile this unit with checks off). The Fore, Aft and Exp values\n+   --  can be set to any valid values for the case of use from Text_IO. Note\n+   --  that no space is stored at the start for non-negative values.\n+\n+end System.Image_R;"}, {"sha": "44f00b8283832d90ae8b6e8e55e65ad7bba7d130", "filename": "gcc/ada/libgnat/s-imgflt.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,66 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M G _ F L T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for the Image attribute of floating point\n+--  types based on Float, also used for Float_IO output.\n+\n+with System.Image_R;\n+with System.Img_Uns;\n+with System.Powten_Flt;\n+with System.Unsigned_Types;\n+\n+package System.Img_Flt is\n+   pragma Pure;\n+\n+   package Impl is new Image_R\n+     (Float,\n+      System.Powten_Flt.Maxpow,\n+      System.Powten_Flt.Powten'Address,\n+      Unsigned_Types.Unsigned,\n+      System.Img_Uns.Set_Image_Unsigned);\n+\n+   procedure Image_Float\n+     (V    : Float;\n+      S    : in out String;\n+      P    : out Natural;\n+      Digs : Natural)\n+     renames Impl.Image_Floating_Point;\n+\n+   procedure Set_Image_Float\n+     (V    : Float;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Real;\n+\n+end System.Img_Flt;"}, {"sha": "48f7fc05a12b9328d26af90fd49b1d121c16c0a3", "filename": "gcc/ada/libgnat/s-imglfl.ads", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,80 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . I M G _ L F L T                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for the Image attribute of fixed or floating\n+--  point types based on Long_Float, also used for Float_IO/Fixed_IO output.\n+\n+with System.Img_LLU;\n+with System.Image_R;\n+with System.Powten_LFlt;\n+with System.Unsigned_Types;\n+\n+package System.Img_LFlt is\n+   pragma Pure;\n+\n+   --  Note that the following instantiation is really for a 32-bit target,\n+   --  where 128-bit integer types are not available. For a 64-bit targaet,\n+   --  it is possible to use Long_Long_Unsigned and Long_Long_Long_Unsigned\n+   --  instead of Unsigned and Long_Long_Unsigned, in order to double the\n+   --  number of significant digits. But we do not do it by default to avoid\n+   --  dragging 128-bit integer types for the sake of backward compatibility.\n+\n+   package Impl is new Image_R\n+     (Long_Float,\n+      System.Powten_LFlt.Maxpow,\n+      System.Powten_LFlt.Powten'Address,\n+      Unsigned_Types.Long_Long_Unsigned,\n+      System.Img_LLU.Set_Image_Long_Long_Unsigned);\n+\n+   procedure Image_Fixed\n+     (V   : Long_Float;\n+      S   : in out String;\n+      P   : out Natural;\n+      Aft : Natural)\n+     renames Impl.Image_Fixed_Point;\n+\n+   procedure Image_Long_Float\n+     (V    : Long_Float;\n+      S    : in out String;\n+      P    : out Natural;\n+      Digs : Natural)\n+     renames Impl.Image_Floating_Point;\n+\n+   procedure Set_Image_Long_Float\n+     (V    : Long_Float;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Real;\n+\n+end System.Img_LFlt;"}, {"sha": "2a5a3e2847752869f5b3757796e55ba96b435ddd", "filename": "gcc/ada/libgnat/s-imgllf.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M G _ L L F                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for the Image attribute of floating point\n+--  types based on Long_Long_Float, also used for Float_IO output.\n+\n+with System.Img_LLU;\n+with System.Image_R;\n+with System.Powten_LLF;\n+with System.Unsigned_Types;\n+\n+package System.Img_LLF is\n+   pragma Pure;\n+\n+   --  Note that the following instantiation is really for a 32-bit target,\n+   --  where 128-bit integer types are not available. For a 64-bit targaet,\n+   --  it is possible to use Long_Long_Unsigned and Long_Long_Long_Unsigned\n+   --  instead of Unsigned and Long_Long_Unsigned, in order to double the\n+   --  number of significant digits. But we do not do it by default to avoid\n+   --  dragging 128-bit integer types for the sake of backward compatibility.\n+\n+   package Impl is new Image_R\n+     (Long_Long_Float,\n+      System.Powten_LLF.Maxpow,\n+      System.Powten_LLF.Powten'Address,\n+      Unsigned_Types.Long_Long_Unsigned,\n+      System.Img_LLU.Set_Image_Long_Long_Unsigned);\n+\n+   procedure Image_Long_Long_Float\n+     (V    : Long_Long_Float;\n+      S    : in out String;\n+      P    : out Natural;\n+      Digs : Natural)\n+     renames Impl.Image_Floating_Point;\n+\n+   procedure Set_Image_Long_Long_Float\n+     (V    : Long_Long_Float;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Real;\n+\n+end System.Img_LLF;"}, {"sha": "255e65906f09eda237ff32f1833a91b5e1b17a37", "filename": "gcc/ada/libgnat/s-imgrea.adb", "status": "modified", "additions": 4, "deletions": 414, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -29,418 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Img_LLU;    use System.Img_LLU;\n-with System.Img_Uns;    use System.Img_Uns;\n-with System.Img_Util;   use System.Img_Util;\n-with System.Powten_LLF; use System.Powten_LLF;\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-with System.Float_Control;\n-\n-package body System.Img_Real is\n-\n-   subtype LLU is Long_Long_Unsigned;\n-\n-   --  The following defines the maximum number of digits that we can convert\n-   --  accurately. This is limited by the precision of Long_Long_Float, and\n-   --  also by the number of digits we can hold in Long_Long_Unsigned, which\n-   --  is the integer type we use as an intermediate for the result.\n-\n-   --  We assume that in practice, the limitation will come from the digits\n-   --  value, rather than the integer value. This is true for typical IEEE\n-   --  implementations, and at worst, the only loss is for some precision\n-   --  in very high precision floating-point output.\n-\n-   --  Note that in the following, the \"-2\" accounts for the space and one\n-   --  extra digit, since we need the maximum number of 9's that can be\n-   --  represented, e.g. for the 64-bit case, Long_Long_Unsigned'Width is\n-   --  21, since the maximum value (approx 1.8E+19) has 20 digits, but the\n-   --  maximum number of 9's that can be represented is only 19.\n-\n-   Maxdigs : constant := Natural'Min (LLU'Width - 2, Long_Long_Float'Digits);\n-\n-   Maxscaling : constant := 5000;\n-   --  Max decimal scaling required during conversion of floating-point\n-   --  numbers to decimal. This is used to defend against infinite\n-   --  looping in the conversion, as can be caused by erroneous executions.\n-   --  The largest exponent used on any current system is 2**16383, which\n-   --  is approximately 10**4932, and the highest number of decimal digits\n-   --  is about 35 for 128-bit floating-point formats, so 5000 leaves\n-   --  enough room for scaling such values\n-\n-   function Is_Negative (V : Long_Long_Float) return Boolean;\n-   --  Return True if V is negative for the purpose of the output, i.e. return\n-   --  True for negative zeros only if Signed_Zeros is True.\n-\n-   --------------------------\n-   -- Image_Floating_Point --\n-   --------------------------\n-\n-   procedure Image_Floating_Point\n-     (V    : Long_Long_Float;\n-      S    : in out String;\n-      P    : out Natural;\n-      Digs : Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-\n-   begin\n-      --  Decide whether a blank should be prepended before the call to\n-      --  Set_Image_Real. We generate a blank for positive values, and\n-      --  also for positive zeros. For negative zeros, we generate a\n-      --  blank only if Signed_Zeros is False (the RM only permits the\n-      --  output of -0.0 when Signed_Zeros is True). We do not generate\n-      --  a blank for positive infinity, since we output an explicit +.\n-\n-      if not Is_Negative (V) and then V <= Long_Long_Float'Last then\n-         pragma Annotate (CodePeer, False_Positive, \"condition predetermined\",\n-                          \"CodePeer analysis ignores NaN and Inf values\");\n-         pragma Assert (S'Last > 1);\n-         --  The caller is responsible for S to be large enough for all\n-         --  Image_Floating_Point operation.\n-         S (1) := ' ';\n-         P := 1;\n-      else\n-         P := 0;\n-      end if;\n-\n-      Set_Image_Real (V, S, P, 1, Digs - 1, 3);\n-   end Image_Floating_Point;\n-\n-   --------------------------------\n-   -- Image_Ordinary_Fixed_Point --\n-   --------------------------------\n-\n-   procedure Image_Ordinary_Fixed_Point\n-     (V   : Long_Long_Float;\n-      S   : in out String;\n-      P   : out Natural;\n-      Aft : Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-\n-   begin\n-      --  Output space at start if non-negative\n-\n-      if V >= 0.0 then\n-         S (1) := ' ';\n-         P := 1;\n-      else\n-         P := 0;\n-      end if;\n-\n-      Set_Image_Real (V, S, P, 1, Aft, 0);\n-   end Image_Ordinary_Fixed_Point;\n-\n-   -----------------\n-   -- Is_Negative --\n-   -----------------\n-\n-   function Is_Negative (V : Long_Long_Float) return Boolean is\n-   begin\n-      if V < 0.0 then\n-         return True;\n-\n-      elsif V > 0.0 then\n-         return False;\n-\n-      elsif not Long_Long_Float'Signed_Zeros then\n-         return False;\n-\n-      else\n-         return Long_Long_Float'Copy_Sign (1.0, V) < 0.0;\n-      end if;\n-   end Is_Negative;\n-\n-   --------------------\n-   -- Set_Image_Real --\n-   --------------------\n-\n-   procedure Set_Image_Real\n-     (V    : Long_Long_Float;\n-      S    : in out String;\n-      P    : in out Natural;\n-      Fore : Natural;\n-      Aft  : Natural;\n-      Exp  : Natural)\n-   is\n-      NFrac : constant Natural := Natural'Max (Aft, 1);\n-      --  Number of digits after the decimal point\n-\n-      Digs : String (1 .. 3 + Maxdigs);\n-      --  Array used to hold digits of converted integer value\n-\n-      Ndigs : Natural;\n-      --  Number of digits stored in Digs (and also subscript of last digit)\n-\n-      Scale : Integer := 0;\n-      --  Exponent such that the result is Digs (1 .. NDigs) * 10**(-Scale)\n-\n-      X : Long_Long_Float;\n-      --  Current absolute value of the input after scaling\n-\n-      procedure Adjust_Scale (S : Natural);\n-      --  Adjusts the value in X by multiplying or dividing by a power of\n-      --  ten so that it is in the range 10**(S-1) <= X < 10**S. Scale is\n-      --  adjusted to reflect the power of ten used to divide the result,\n-      --  i.e. one is added to the scale value for each multiplication by\n-      --  10.0 and one is subtracted for each division by 10.0.\n-\n-      ------------------\n-      -- Adjust_Scale --\n-      ------------------\n-\n-      procedure Adjust_Scale (S : Natural) is\n-         Lo  : Natural;\n-         Hi  : Natural;\n-         Mid : Natural;\n-         XP  : Long_Long_Float;\n-\n-      begin\n-         --  Cases where scaling up is required\n-\n-         if X < Powten (S - 1) then\n-\n-            --  What we are looking for is a power of ten to multiply X by\n-            --  so that the result lies within the required range.\n-\n-            loop\n-               XP := X * Powten (Maxpow);\n-               exit when XP >= Powten (S - 1) or else Scale > Maxscaling;\n-               X := XP;\n-               Scale := Scale + Maxpow;\n-            end loop;\n-\n-            --  The following exception is only raised in case of erroneous\n-            --  execution, where a number was considered valid but still\n-            --  fails to scale up. One situation where this can happen is\n-            --  when a system which is supposed to be IEEE-compliant, but\n-            --  has been reconfigured to flush denormals to zero.\n-\n-            if Scale > Maxscaling then\n-               raise Constraint_Error;\n-            end if;\n-\n-            --  Here we know that we must multiply by at least 10**1 and that\n-            --  10**Maxpow takes us too far: binary search to find right one.\n-\n-            --  Because of roundoff errors, it is possible for the value\n-            --  of XP to be just outside of the interval when Lo >= Hi. In\n-            --  that case we adjust explicitly by a factor of 10. This\n-            --  can only happen with a value that is very close to an\n-            --  exact power of 10.\n-\n-            Lo := 1;\n-            Hi := Maxpow;\n-\n-            loop\n-               Mid := (Lo + Hi) / 2;\n-               XP := X * Powten (Mid);\n-\n-               if XP < Powten (S - 1) then\n-\n-                  if Lo >= Hi then\n-                     Mid := Mid + 1;\n-                     XP := XP * 10.0;\n-                     exit;\n-\n-                  else\n-                     Lo := Mid + 1;\n-                  end if;\n-\n-               elsif XP >= Powten (S) then\n-\n-                  if Lo >= Hi then\n-                     Mid := Mid - 1;\n-                     XP := XP / 10.0;\n-                     exit;\n-\n-                  else\n-                     Hi := Mid - 1;\n-                  end if;\n-\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            X := XP;\n-            Scale := Scale + Mid;\n-\n-         --  Cases where scaling down is required\n-\n-         elsif X >= Powten (S) then\n-\n-            --  What we are looking for is a power of ten to divide X by\n-            --  so that the result lies within the required range.\n-\n-            pragma Assert (Powten (Maxpow) /= 0.0);\n-\n-            loop\n-               XP := X / Powten (Maxpow);\n-               exit when XP < Powten (S) or else Scale < -Maxscaling;\n-               X := XP;\n-               Scale := Scale - Maxpow;\n-            end loop;\n-\n-            --  The following exception is only raised in case of erroneous\n-            --  execution, where a number was considered valid but still\n-            --  fails to scale up. One situation where this can happen is\n-            --  when a system which is supposed to be IEEE-compliant, but\n-            --  has been reconfigured to flush denormals to zero.\n-\n-            if Scale < -Maxscaling then\n-               raise Constraint_Error;\n-            end if;\n-\n-            --  Here we know that we must divide by at least 10**1 and that\n-            --  10**Maxpow takes us too far, binary search to find right one.\n-\n-            Lo := 1;\n-            Hi := Maxpow;\n-\n-            loop\n-               Mid := (Lo + Hi) / 2;\n-               XP := X / Powten (Mid);\n-\n-               if XP < Powten (S - 1) then\n-\n-                  if Lo >= Hi then\n-                     XP := XP * 10.0;\n-                     Mid := Mid - 1;\n-                     exit;\n-\n-                  else\n-                     Hi := Mid - 1;\n-                  end if;\n-\n-               elsif XP >= Powten (S) then\n-\n-                  if Lo >= Hi then\n-                     XP := XP / 10.0;\n-                     Mid := Mid + 1;\n-                     exit;\n-\n-                  else\n-                     Lo := Mid + 1;\n-                  end if;\n-\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            X := XP;\n-            Scale := Scale - Mid;\n-\n-         --  Here we are already scaled right\n-\n-         else\n-            null;\n-         end if;\n-      end Adjust_Scale;\n-\n-   --  Start of processing for Set_Image_Real\n-\n-   begin\n-      --  We call the floating-point processor reset routine so we can be sure\n-      --  that the processor is properly set for conversions. This is notably\n-      --  needed on Windows, where calls to the operating system randomly reset\n-      --  the processor into 64-bit mode.\n-\n-      System.Float_Control.Reset;\n-\n-      --  Deal with invalid values first\n-\n-      if not V'Valid then\n-\n-         --  Note that we're taking our chances here, as V might be\n-         --  an invalid bit pattern resulting from erroneous execution\n-         --  (caused by using uninitialized variables for example).\n-\n-         --  No matter what, we'll at least get reasonable behavior,\n-         --  converting to infinity or some other value, or causing an\n-         --  exception to be raised is fine.\n-\n-         --  If the following two tests succeed, then we definitely have\n-         --  an infinite value, so we print +Inf or -Inf.\n-\n-         if V > Long_Long_Float'Last then\n-            pragma Annotate (CodePeer, False_Positive, \"dead code\",\n-                             \"CodePeer analysis ignores NaN and Inf values\");\n-            pragma Annotate (CodePeer, False_Positive, \"test always true\",\n-                             \"CodePeer analysis ignores NaN and Inf values\");\n-\n-            Set_Floating_Invalid_Value (Infinity, S, P, Fore, Aft, Exp);\n-\n-         elsif V < Long_Long_Float'First then\n-            Set_Floating_Invalid_Value (Minus_Infinity, S, P, Fore, Aft, Exp);\n-\n-         --  In all other cases we print NaN\n-\n-         else\n-            Set_Floating_Invalid_Value (Not_A_Number, S, P, Fore, Aft, Exp);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      --  Set the first character like Image\n-\n-      Digs (1) := (if Is_Negative (V) then '-' else ' ');\n-      Ndigs := 1;\n-\n-      X := abs (V);\n-\n-      --  If X is zero, we are done\n-\n-      if X = 0.0 then\n-         Digs (2) := '0';\n-         Ndigs := 2;\n-\n-      --  Otherwise, scale X and convert it to an integer\n-\n-      else\n-         --  In exponent notation, we need exactly NFrac + 1 digits and always\n-         --  round the last one.\n-\n-         if Exp > 0 then\n-            Adjust_Scale (Natural'Min (NFrac + 1, Maxdigs));\n-            X := X + 0.5;\n-\n-         --  In straight notation, we compute the maximum number of digits and\n-         --  compare how many of them will be put after the decimal point with\n-         --  Nfrac, in order to find out whether we need to round the last one\n-         --  here or whether the rounding is performed by Set_Decimal_Digits.\n-\n-         else\n-            Adjust_Scale (Maxdigs);\n-            if Scale <= NFrac then\n-               X := X + 0.5;\n-            end if;\n-         end if;\n-\n-         --  Use Unsigned routine if possible, since on 32-bit machines it will\n-         --  be significantly more efficient than the Long_Long_Unsigned one.\n-\n-         if X <= Long_Long_Float (Unsigned'Last) then\n-            declare\n-               I : constant Unsigned :=\n-                     Unsigned (Long_Long_Float'Truncation (X));\n-            begin\n-               Set_Image_Unsigned (I, Digs, Ndigs);\n-            end;\n-\n-         else pragma Assert (X <= Long_Long_Float (LLU'Last));\n-            declare\n-               I : constant LLU :=\n-                     LLU (Long_Long_Float'Truncation (X));\n-            begin\n-               Set_Image_Long_Long_Unsigned (I, Digs, Ndigs);\n-            end;\n-         end if;\n-      end if;\n-\n-      Set_Decimal_Digits (Digs, Ndigs, S, P, Scale, Fore, Aft, Exp);\n-   end Set_Image_Real;\n-\n-end System.Img_Real;\n+pragma No_Body;"}, {"sha": "45abac1fd4b433ecb2009118295be596265f5dec", "filename": "gcc/ada/libgnat/s-imgrea.ads", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -29,56 +29,20 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Image for fixed and float types (also used for Float_IO/Fixed_IO output)\n+--  This obsolete package is preserved for the sake of backward compatibility\n+\n+with System.Img_LLF;\n \n package System.Img_Real is\n    pragma Pure;\n \n-   procedure Image_Ordinary_Fixed_Point\n-     (V   : Long_Long_Float;\n-      S   : in out String;\n-      P   : out Natural;\n-      Aft : Natural);\n-   --  Computes fixed_type'Image (V) and returns the result in S (1 .. P)\n-   --  updating P on return. The result is computed according to the rules for\n-   --  image for fixed-point types (RM 3.5(34)), where Aft is the value of the\n-   --  Aft attribute for the fixed-point type. This function is used only for\n-   --  ordinary fixed point (see package System.Img_Dec for handling of decimal\n-   --  fixed point). The caller guarantees that S is long enough to hold the\n-   --  result and has a lower bound of 1.\n-   --\n-   --  Remark: This procedure should NOT be called with V = -0.0 or V = +/-Inf,\n-   --          The result is irrelevant.\n-\n-   procedure Image_Floating_Point\n-     (V    : Long_Long_Float;\n-      S    : in out String;\n-      P    : out Natural;\n-      Digs : Natural);\n-   --  Computes float_type'Image (V) and returns the result in S (1 .. P)\n-   --  updating P on return. The result is computed according to the rules for\n-   --  image for floating-point types (RM 3.5(33)), where Digs is the value of\n-   --  the Digits attribute for the floating-point type. The caller guarantees\n-   --  that S is long enough to hold the result and has a lower bound of 1.\n-\n    procedure Set_Image_Real\n      (V    : Long_Long_Float;\n       S    : in out String;\n       P    : in out Natural;\n       Fore : Natural;\n       Aft  : Natural;\n-      Exp  : Natural);\n-   --  Sets the image of V starting at S (P + 1), updating P to point to the\n-   --  last character stored, the caller promises that the buffer is large\n-   --  enough and no check is made for this. Constraint_Error will not\n-   --  necessarily be raised if this is violated, since it is perfectly valid\n-   --  to compile this unit with checks off). The Fore, Aft and Exp values\n-   --  can be set to any valid values for the case of use from Text_IO. Note\n-   --  that no space is stored at the start for non-negative values.\n-\n-   Max_Real_Image_Length : constant := 5200;\n-   --   If Exp is set to zero and Aft is set to Text_IO.Field'Last (i.e., 255)\n-   --   then Long_Long_Float'Last generates an image whose length is\n-   --   slightly less than 5200.\n+      Exp  : Natural)\n+     renames System.Img_LLF.Set_Image_Long_Long_Float;\n \n end System.Img_Real;"}, {"sha": "68e8e2a611ba805b0fff4b741efcc3bfedae43e5", "filename": "gcc/ada/libgnat/s-imguti.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,6 +34,11 @@\n package System.Img_Util is\n    pragma Pure;\n \n+   Max_Real_Image_Length : constant := 5200;\n+   --  If Exp is set to zero and Aft is set to Text_IO.Field'Last (i.e., 255)\n+   --  then Long_Long_Float'Last generates an image whose length is slightly\n+   --  less than 5200.\n+\n    procedure Set_Decimal_Digits\n      (Digs  : in out String;\n       NDigs : Natural;"}, {"sha": "0967403a9739c546ecd6876b1a63f70e3465b9a2", "filename": "gcc/ada/libgnat/s-powflt.ads", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powflt.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,52 +34,34 @@\n package System.Powten_Flt is\n    pragma Pure;\n \n-   Maxpow : constant := 38;\n-   --  Largest power of ten representable with Float\n-\n    Maxpow_Exact : constant := 10;\n    --  Largest power of ten exactly representable with Float. It is equal to\n    --  floor (M * log 2 / log 5), when M is the size of the mantissa (24).\n \n-   Powten : constant array (0 .. Maxpow) of Float :=\n-      (00 => 1.0E+00,\n-       01 => 1.0E+01,\n-       02 => 1.0E+02,\n-       03 => 1.0E+03,\n-       04 => 1.0E+04,\n-       05 => 1.0E+05,\n-       06 => 1.0E+06,\n-       07 => 1.0E+07,\n-       08 => 1.0E+08,\n-       09 => 1.0E+09,\n-       10 => 1.0E+10,\n-       11 => 1.0E+11,\n-       12 => 1.0E+12,\n-       13 => 1.0E+13,\n-       14 => 1.0E+14,\n-       15 => 1.0E+15,\n-       16 => 1.0E+16,\n-       17 => 1.0E+17,\n-       18 => 1.0E+18,\n-       19 => 1.0E+19,\n-       20 => 1.0E+20,\n-       21 => 1.0E+21,\n-       22 => 1.0E+22,\n-       23 => 1.0E+23,\n-       24 => 1.0E+24,\n-       25 => 1.0E+25,\n-       26 => 1.0E+26,\n-       27 => 1.0E+27,\n-       28 => 1.0E+28,\n-       29 => 1.0E+29,\n-       30 => 1.0E+30,\n-       31 => 1.0E+31,\n-       32 => 1.0E+32,\n-       33 => 1.0E+33,\n-       34 => 1.0E+34,\n-       35 => 1.0E+35,\n-       36 => 1.0E+36,\n-       37 => 1.0E+37,\n-       38 => 1.0E+38);\n+   Maxpow : constant := Maxpow_Exact * 2;\n+   --  Largest power of ten exactly representable with a double Float\n+\n+   Powten : constant array (0 .. Maxpow, 1 .. 2) of Float :=\n+     (00 => (1.0E+00, 0.0),\n+      01 => (1.0E+01, 0.0),\n+      02 => (1.0E+02, 0.0),\n+      03 => (1.0E+03, 0.0),\n+      04 => (1.0E+04, 0.0),\n+      05 => (1.0E+05, 0.0),\n+      06 => (1.0E+06, 0.0),\n+      07 => (1.0E+07, 0.0),\n+      08 => (1.0E+08, 0.0),\n+      09 => (1.0E+09, 0.0),\n+      10 => (1.0E+10, 0.0),\n+      11 => (1.0E+11, 1.0E+11 - Float'Machine (1.0E+11)),\n+      12 => (1.0E+12, 1.0E+12 - Float'Machine (1.0E+12)),\n+      13 => (1.0E+13, 1.0E+13 - Float'Machine (1.0E+13)),\n+      14 => (1.0E+14, 1.0E+14 - Float'Machine (1.0E+14)),\n+      15 => (1.0E+15, 1.0E+15 - Float'Machine (1.0E+15)),\n+      16 => (1.0E+16, 1.0E+16 - Float'Machine (1.0E+16)),\n+      17 => (1.0E+17, 1.0E+17 - Float'Machine (1.0E+17)),\n+      18 => (1.0E+18, 1.0E+18 - Float'Machine (1.0E+18)),\n+      19 => (1.0E+19, 1.0E+19 - Float'Machine (1.0E+19)),\n+      20 => (1.0E+20, 1.0E+20 - Float'Machine (1.0E+20)));\n \n end System.Powten_Flt;"}, {"sha": "7800f2ff57aa939ca7a3627b1e5d06a87fd6626e", "filename": "gcc/ada/libgnat/s-powlfl.ads", "status": "modified", "additions": 49, "deletions": 313, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,322 +34,58 @@\n package System.Powten_LFlt is\n    pragma Pure;\n \n-   Maxpow : constant := 308;\n-   --  Largest power of ten representable with Long_Float\n-\n    Maxpow_Exact : constant := 22;\n    --  Largest power of ten exactly representable with Long_Float. It is equal\n    --  to floor (M * log 2 / log 5), when M is the size of the mantissa (53).\n \n-   Powten : constant array (0 .. Maxpow) of Long_Float :=\n-      (00 => 1.0E+00,\n-       01 => 1.0E+01,\n-       02 => 1.0E+02,\n-       03 => 1.0E+03,\n-       04 => 1.0E+04,\n-       05 => 1.0E+05,\n-       06 => 1.0E+06,\n-       07 => 1.0E+07,\n-       08 => 1.0E+08,\n-       09 => 1.0E+09,\n-       10 => 1.0E+10,\n-       11 => 1.0E+11,\n-       12 => 1.0E+12,\n-       13 => 1.0E+13,\n-       14 => 1.0E+14,\n-       15 => 1.0E+15,\n-       16 => 1.0E+16,\n-       17 => 1.0E+17,\n-       18 => 1.0E+18,\n-       19 => 1.0E+19,\n-       20 => 1.0E+20,\n-       21 => 1.0E+21,\n-       22 => 1.0E+22,\n-       23 => 1.0E+23,\n-       24 => 1.0E+24,\n-       25 => 1.0E+25,\n-       26 => 1.0E+26,\n-       27 => 1.0E+27,\n-       28 => 1.0E+28,\n-       29 => 1.0E+29,\n-       30 => 1.0E+30,\n-       31 => 1.0E+31,\n-       32 => 1.0E+32,\n-       33 => 1.0E+33,\n-       34 => 1.0E+34,\n-       35 => 1.0E+35,\n-       36 => 1.0E+36,\n-       37 => 1.0E+37,\n-       38 => 1.0E+38,\n-       39 => 1.0E+39,\n-       40 => 1.0E+40,\n-       41 => 1.0E+41,\n-       42 => 1.0E+42,\n-       43 => 1.0E+43,\n-       44 => 1.0E+44,\n-       45 => 1.0E+45,\n-       46 => 1.0E+46,\n-       47 => 1.0E+47,\n-       48 => 1.0E+48,\n-       49 => 1.0E+49,\n-       50 => 1.0E+50,\n-       51 => 1.0E+51,\n-       52 => 1.0E+52,\n-       53 => 1.0E+53,\n-       54 => 1.0E+54,\n-       55 => 1.0E+55,\n-       56 => 1.0E+56,\n-       57 => 1.0E+57,\n-       58 => 1.0E+58,\n-       59 => 1.0E+59,\n-       60 => 1.0E+60,\n-       61 => 1.0E+61,\n-       62 => 1.0E+62,\n-       63 => 1.0E+63,\n-       64 => 1.0E+64,\n-       65 => 1.0E+65,\n-       66 => 1.0E+66,\n-       67 => 1.0E+67,\n-       68 => 1.0E+68,\n-       69 => 1.0E+69,\n-       70 => 1.0E+70,\n-       71 => 1.0E+71,\n-       72 => 1.0E+72,\n-       73 => 1.0E+73,\n-       74 => 1.0E+74,\n-       75 => 1.0E+75,\n-       76 => 1.0E+76,\n-       77 => 1.0E+77,\n-       78 => 1.0E+78,\n-       79 => 1.0E+79,\n-       80 => 1.0E+80,\n-       81 => 1.0E+81,\n-       82 => 1.0E+82,\n-       83 => 1.0E+83,\n-       84 => 1.0E+84,\n-       85 => 1.0E+85,\n-       86 => 1.0E+86,\n-       87 => 1.0E+87,\n-       88 => 1.0E+88,\n-       89 => 1.0E+89,\n-       90 => 1.0E+90,\n-       91 => 1.0E+91,\n-       92 => 1.0E+92,\n-       93 => 1.0E+93,\n-       94 => 1.0E+94,\n-       95 => 1.0E+95,\n-       96 => 1.0E+96,\n-       97 => 1.0E+97,\n-       98 => 1.0E+98,\n-       99 => 1.0E+99,\n-       100 => 1.0E+100,\n-       101 => 1.0E+101,\n-       102 => 1.0E+102,\n-       103 => 1.0E+103,\n-       104 => 1.0E+104,\n-       105 => 1.0E+105,\n-       106 => 1.0E+106,\n-       107 => 1.0E+107,\n-       108 => 1.0E+108,\n-       109 => 1.0E+109,\n-       110 => 1.0E+110,\n-       111 => 1.0E+111,\n-       112 => 1.0E+112,\n-       113 => 1.0E+113,\n-       114 => 1.0E+114,\n-       115 => 1.0E+115,\n-       116 => 1.0E+116,\n-       117 => 1.0E+117,\n-       118 => 1.0E+118,\n-       119 => 1.0E+119,\n-       120 => 1.0E+120,\n-       121 => 1.0E+121,\n-       122 => 1.0E+122,\n-       123 => 1.0E+123,\n-       124 => 1.0E+124,\n-       125 => 1.0E+125,\n-       126 => 1.0E+126,\n-       127 => 1.0E+127,\n-       128 => 1.0E+128,\n-       129 => 1.0E+129,\n-       130 => 1.0E+130,\n-       131 => 1.0E+131,\n-       132 => 1.0E+132,\n-       133 => 1.0E+133,\n-       134 => 1.0E+134,\n-       135 => 1.0E+135,\n-       136 => 1.0E+136,\n-       137 => 1.0E+137,\n-       138 => 1.0E+138,\n-       139 => 1.0E+139,\n-       140 => 1.0E+140,\n-       141 => 1.0E+141,\n-       142 => 1.0E+142,\n-       143 => 1.0E+143,\n-       144 => 1.0E+144,\n-       145 => 1.0E+145,\n-       146 => 1.0E+146,\n-       147 => 1.0E+147,\n-       148 => 1.0E+148,\n-       149 => 1.0E+149,\n-       150 => 1.0E+150,\n-       151 => 1.0E+151,\n-       152 => 1.0E+152,\n-       153 => 1.0E+153,\n-       154 => 1.0E+154,\n-       155 => 1.0E+155,\n-       156 => 1.0E+156,\n-       157 => 1.0E+157,\n-       158 => 1.0E+158,\n-       159 => 1.0E+159,\n-       160 => 1.0E+160,\n-       161 => 1.0E+161,\n-       162 => 1.0E+162,\n-       163 => 1.0E+163,\n-       164 => 1.0E+164,\n-       165 => 1.0E+165,\n-       166 => 1.0E+166,\n-       167 => 1.0E+167,\n-       168 => 1.0E+168,\n-       169 => 1.0E+169,\n-       170 => 1.0E+170,\n-       171 => 1.0E+171,\n-       172 => 1.0E+172,\n-       173 => 1.0E+173,\n-       174 => 1.0E+174,\n-       175 => 1.0E+175,\n-       176 => 1.0E+176,\n-       177 => 1.0E+177,\n-       178 => 1.0E+178,\n-       179 => 1.0E+179,\n-       180 => 1.0E+180,\n-       181 => 1.0E+181,\n-       182 => 1.0E+182,\n-       183 => 1.0E+183,\n-       184 => 1.0E+184,\n-       185 => 1.0E+185,\n-       186 => 1.0E+186,\n-       187 => 1.0E+187,\n-       188 => 1.0E+188,\n-       189 => 1.0E+189,\n-       190 => 1.0E+190,\n-       191 => 1.0E+191,\n-       192 => 1.0E+192,\n-       193 => 1.0E+193,\n-       194 => 1.0E+194,\n-       195 => 1.0E+195,\n-       196 => 1.0E+196,\n-       197 => 1.0E+197,\n-       198 => 1.0E+198,\n-       199 => 1.0E+199,\n-       200 => 1.0E+200,\n-       201 => 1.0E+201,\n-       202 => 1.0E+202,\n-       203 => 1.0E+203,\n-       204 => 1.0E+204,\n-       205 => 1.0E+205,\n-       206 => 1.0E+206,\n-       207 => 1.0E+207,\n-       208 => 1.0E+208,\n-       209 => 1.0E+209,\n-       210 => 1.0E+210,\n-       211 => 1.0E+211,\n-       212 => 1.0E+212,\n-       213 => 1.0E+213,\n-       214 => 1.0E+214,\n-       215 => 1.0E+215,\n-       216 => 1.0E+216,\n-       217 => 1.0E+217,\n-       218 => 1.0E+218,\n-       219 => 1.0E+219,\n-       220 => 1.0E+220,\n-       221 => 1.0E+221,\n-       222 => 1.0E+222,\n-       223 => 1.0E+223,\n-       224 => 1.0E+224,\n-       225 => 1.0E+225,\n-       226 => 1.0E+226,\n-       227 => 1.0E+227,\n-       228 => 1.0E+228,\n-       229 => 1.0E+229,\n-       230 => 1.0E+230,\n-       231 => 1.0E+231,\n-       232 => 1.0E+232,\n-       233 => 1.0E+233,\n-       234 => 1.0E+234,\n-       235 => 1.0E+235,\n-       236 => 1.0E+236,\n-       237 => 1.0E+237,\n-       238 => 1.0E+238,\n-       239 => 1.0E+239,\n-       240 => 1.0E+240,\n-       241 => 1.0E+241,\n-       242 => 1.0E+242,\n-       243 => 1.0E+243,\n-       244 => 1.0E+244,\n-       245 => 1.0E+245,\n-       246 => 1.0E+246,\n-       247 => 1.0E+247,\n-       248 => 1.0E+248,\n-       249 => 1.0E+249,\n-       250 => 1.0E+250,\n-       251 => 1.0E+251,\n-       252 => 1.0E+252,\n-       253 => 1.0E+253,\n-       254 => 1.0E+254,\n-       255 => 1.0E+255,\n-       256 => 1.0E+256,\n-       257 => 1.0E+257,\n-       258 => 1.0E+258,\n-       259 => 1.0E+259,\n-       260 => 1.0E+260,\n-       261 => 1.0E+261,\n-       262 => 1.0E+262,\n-       263 => 1.0E+263,\n-       264 => 1.0E+264,\n-       265 => 1.0E+265,\n-       266 => 1.0E+266,\n-       267 => 1.0E+267,\n-       268 => 1.0E+268,\n-       269 => 1.0E+269,\n-       270 => 1.0E+270,\n-       271 => 1.0E+271,\n-       272 => 1.0E+272,\n-       273 => 1.0E+273,\n-       274 => 1.0E+274,\n-       275 => 1.0E+275,\n-       276 => 1.0E+276,\n-       277 => 1.0E+277,\n-       278 => 1.0E+278,\n-       279 => 1.0E+279,\n-       280 => 1.0E+280,\n-       281 => 1.0E+281,\n-       282 => 1.0E+282,\n-       283 => 1.0E+283,\n-       284 => 1.0E+284,\n-       285 => 1.0E+285,\n-       286 => 1.0E+286,\n-       287 => 1.0E+287,\n-       288 => 1.0E+288,\n-       289 => 1.0E+289,\n-       290 => 1.0E+290,\n-       291 => 1.0E+291,\n-       292 => 1.0E+292,\n-       293 => 1.0E+293,\n-       294 => 1.0E+294,\n-       295 => 1.0E+295,\n-       296 => 1.0E+296,\n-       297 => 1.0E+297,\n-       298 => 1.0E+298,\n-       299 => 1.0E+299,\n-       300 => 1.0E+300,\n-       301 => 1.0E+301,\n-       302 => 1.0E+302,\n-       303 => 1.0E+303,\n-       304 => 1.0E+304,\n-       305 => 1.0E+305,\n-       306 => 1.0E+306,\n-       307 => 1.0E+307,\n-       308 => 1.0E+308);\n+   Maxpow : constant := Maxpow_Exact * 2;\n+   --  Largest power of ten exactly representable with a double Long_Float\n+\n+   Powten : constant array (0 .. Maxpow, 1 .. 2) of Long_Float :=\n+     (00 => (1.0E+00, 0.0),\n+      01 => (1.0E+01, 0.0),\n+      02 => (1.0E+02, 0.0),\n+      03 => (1.0E+03, 0.0),\n+      04 => (1.0E+04, 0.0),\n+      05 => (1.0E+05, 0.0),\n+      06 => (1.0E+06, 0.0),\n+      07 => (1.0E+07, 0.0),\n+      08 => (1.0E+08, 0.0),\n+      09 => (1.0E+09, 0.0),\n+      10 => (1.0E+10, 0.0),\n+      11 => (1.0E+11, 0.0),\n+      12 => (1.0E+12, 0.0),\n+      13 => (1.0E+13, 0.0),\n+      14 => (1.0E+14, 0.0),\n+      15 => (1.0E+15, 0.0),\n+      16 => (1.0E+16, 0.0),\n+      17 => (1.0E+17, 0.0),\n+      18 => (1.0E+18, 0.0),\n+      19 => (1.0E+19, 0.0),\n+      20 => (1.0E+20, 0.0),\n+      21 => (1.0E+21, 0.0),\n+      22 => (1.0E+22, 0.0),\n+      23 => (1.0E+23, 1.0E+23 - Long_Float'Machine (1.0E+23)),\n+      24 => (1.0E+24, 1.0E+24 - Long_Float'Machine (1.0E+24)),\n+      25 => (1.0E+25, 1.0E+25 - Long_Float'Machine (1.0E+25)),\n+      26 => (1.0E+26, 1.0E+26 - Long_Float'Machine (1.0E+26)),\n+      27 => (1.0E+27, 1.0E+27 - Long_Float'Machine (1.0E+27)),\n+      28 => (1.0E+28, 1.0E+28 - Long_Float'Machine (1.0E+28)),\n+      29 => (1.0E+29, 1.0E+29 - Long_Float'Machine (1.0E+29)),\n+      30 => (1.0E+30, 1.0E+30 - Long_Float'Machine (1.0E+30)),\n+      31 => (1.0E+31, 1.0E+31 - Long_Float'Machine (1.0E+31)),\n+      32 => (1.0E+32, 1.0E+32 - Long_Float'Machine (1.0E+32)),\n+      33 => (1.0E+33, 1.0E+33 - Long_Float'Machine (1.0E+33)),\n+      34 => (1.0E+34, 1.0E+34 - Long_Float'Machine (1.0E+34)),\n+      35 => (1.0E+35, 1.0E+35 - Long_Float'Machine (1.0E+35)),\n+      36 => (1.0E+36, 1.0E+36 - Long_Float'Machine (1.0E+36)),\n+      37 => (1.0E+37, 1.0E+37 - Long_Float'Machine (1.0E+37)),\n+      38 => (1.0E+38, 1.0E+38 - Long_Float'Machine (1.0E+38)),\n+      39 => (1.0E+39, 1.0E+39 - Long_Float'Machine (1.0E+39)),\n+      40 => (1.0E+40, 1.0E+40 - Long_Float'Machine (1.0E+40)),\n+      41 => (1.0E+41, 1.0E+41 - Long_Float'Machine (1.0E+41)),\n+      42 => (1.0E+42, 1.0E+42 - Long_Float'Machine (1.0E+42)),\n+      43 => (1.0E+43, 1.0E+43 - Long_Float'Machine (1.0E+43)),\n+      44 => (1.0E+44, 1.0E+44 - Long_Float'Machine (1.0E+44)));\n \n end System.Powten_LFlt;"}, {"sha": "b1f8ae995acc9a9a0685537137708b1745615f6c", "filename": "gcc/ada/libgnat/s-powllf.ads", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-powllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powllf.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -34,37 +34,70 @@\n package System.Powten_LLF is\n    pragma Pure;\n \n-   Maxpow : constant := 22;\n-   --  The number of entries in this table is chosen to include powers of ten\n-   --  that are exactly representable with Long_Long_Float. Assuming that on\n-   --  all targets we have 53 bits of mantissa for the type, the upper bound\n-   --  is given by 53 * log 2 / log 5. If the scaling factor is greater than\n-   --  Maxpow, it can be obtained by several multiplications, which is less\n-   --  efficient than with a bigger table, but avoids anomalies at end points.\n+   Maxpow_Exact : constant :=\n+     (if Long_Long_Float'Machine_Mantissa = 64 then 27 else 22);\n+   --  Largest power of ten exactly representable with Long_Long_Float. It is\n+   --  equal to floor (M * log 2 / log 5), when M is the size of the mantissa\n+   --  assumed to be either 64 for IEEE Extended or 53 for IEEE Double.\n \n-   Powten : constant array (0 .. Maxpow) of Long_Long_Float :=\n-      (00 => 1.0E+00,\n-       01 => 1.0E+01,\n-       02 => 1.0E+02,\n-       03 => 1.0E+03,\n-       04 => 1.0E+04,\n-       05 => 1.0E+05,\n-       06 => 1.0E+06,\n-       07 => 1.0E+07,\n-       08 => 1.0E+08,\n-       09 => 1.0E+09,\n-       10 => 1.0E+10,\n-       11 => 1.0E+11,\n-       12 => 1.0E+12,\n-       13 => 1.0E+13,\n-       14 => 1.0E+14,\n-       15 => 1.0E+15,\n-       16 => 1.0E+16,\n-       17 => 1.0E+17,\n-       18 => 1.0E+18,\n-       19 => 1.0E+19,\n-       20 => 1.0E+20,\n-       21 => 1.0E+21,\n-       22 => 1.0E+22);\n+   Maxpow : constant := Maxpow_Exact * 2;\n+   --  Largest power of ten exactly representable with a double Long_Long_Float\n+\n+   Powten : constant array (0 .. 54, 1 .. 2) of Long_Long_Float :=\n+     (00 => (1.0E+00, 0.0),\n+      01 => (1.0E+01, 0.0),\n+      02 => (1.0E+02, 0.0),\n+      03 => (1.0E+03, 0.0),\n+      04 => (1.0E+04, 0.0),\n+      05 => (1.0E+05, 0.0),\n+      06 => (1.0E+06, 0.0),\n+      07 => (1.0E+07, 0.0),\n+      08 => (1.0E+08, 0.0),\n+      09 => (1.0E+09, 0.0),\n+      10 => (1.0E+10, 0.0),\n+      11 => (1.0E+11, 0.0),\n+      12 => (1.0E+12, 0.0),\n+      13 => (1.0E+13, 0.0),\n+      14 => (1.0E+14, 0.0),\n+      15 => (1.0E+15, 0.0),\n+      16 => (1.0E+16, 0.0),\n+      17 => (1.0E+17, 0.0),\n+      18 => (1.0E+18, 0.0),\n+      19 => (1.0E+19, 0.0),\n+      20 => (1.0E+20, 0.0),\n+      21 => (1.0E+21, 0.0),\n+      22 => (1.0E+22, 0.0),\n+      23 => (1.0E+23, 1.0E+23 - Long_Long_Float'Machine (1.0E+23)),\n+      24 => (1.0E+24, 1.0E+24 - Long_Long_Float'Machine (1.0E+24)),\n+      25 => (1.0E+25, 1.0E+25 - Long_Long_Float'Machine (1.0E+25)),\n+      26 => (1.0E+26, 1.0E+26 - Long_Long_Float'Machine (1.0E+26)),\n+      27 => (1.0E+27, 1.0E+27 - Long_Long_Float'Machine (1.0E+27)),\n+      28 => (1.0E+28, 1.0E+28 - Long_Long_Float'Machine (1.0E+28)),\n+      29 => (1.0E+29, 1.0E+29 - Long_Long_Float'Machine (1.0E+29)),\n+      30 => (1.0E+30, 1.0E+30 - Long_Long_Float'Machine (1.0E+30)),\n+      31 => (1.0E+31, 1.0E+31 - Long_Long_Float'Machine (1.0E+31)),\n+      32 => (1.0E+32, 1.0E+32 - Long_Long_Float'Machine (1.0E+32)),\n+      33 => (1.0E+33, 1.0E+33 - Long_Long_Float'Machine (1.0E+33)),\n+      34 => (1.0E+34, 1.0E+34 - Long_Long_Float'Machine (1.0E+34)),\n+      35 => (1.0E+35, 1.0E+35 - Long_Long_Float'Machine (1.0E+35)),\n+      36 => (1.0E+36, 1.0E+36 - Long_Long_Float'Machine (1.0E+36)),\n+      37 => (1.0E+37, 1.0E+37 - Long_Long_Float'Machine (1.0E+37)),\n+      38 => (1.0E+38, 1.0E+38 - Long_Long_Float'Machine (1.0E+38)),\n+      39 => (1.0E+39, 1.0E+39 - Long_Long_Float'Machine (1.0E+39)),\n+      40 => (1.0E+40, 1.0E+40 - Long_Long_Float'Machine (1.0E+40)),\n+      41 => (1.0E+41, 1.0E+41 - Long_Long_Float'Machine (1.0E+41)),\n+      42 => (1.0E+42, 1.0E+42 - Long_Long_Float'Machine (1.0E+42)),\n+      43 => (1.0E+43, 1.0E+43 - Long_Long_Float'Machine (1.0E+43)),\n+      44 => (1.0E+44, 1.0E+44 - Long_Long_Float'Machine (1.0E+44)),\n+      45 => (1.0E+45, 1.0E+45 - Long_Long_Float'Machine (1.0E+45)),\n+      46 => (1.0E+46, 1.0E+46 - Long_Long_Float'Machine (1.0E+46)),\n+      47 => (1.0E+47, 1.0E+47 - Long_Long_Float'Machine (1.0E+47)),\n+      48 => (1.0E+48, 1.0E+48 - Long_Long_Float'Machine (1.0E+48)),\n+      49 => (1.0E+49, 1.0E+49 - Long_Long_Float'Machine (1.0E+49)),\n+      50 => (1.0E+50, 1.0E+50 - Long_Long_Float'Machine (1.0E+50)),\n+      51 => (1.0E+51, 1.0E+51 - Long_Long_Float'Machine (1.0E+51)),\n+      52 => (1.0E+52, 1.0E+52 - Long_Long_Float'Machine (1.0E+52)),\n+      53 => (1.0E+53, 1.0E+53 - Long_Long_Float'Machine (1.0E+53)),\n+      54 => (1.0E+54, 1.0E+54 - Long_Long_Float'Machine (1.0E+54)));\n \n end System.Powten_LLF;"}, {"sha": "04ffb7117eafcece926563d2dea852a94f663335", "filename": "gcc/ada/libgnat/s-valflt.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valflt.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -32,18 +32,18 @@\n --  This package contains routines for scanning real values for floating point\n --  type Float, for use in Text_IO.Float_IO and the Value attribute.\n \n-with Interfaces;\n with System.Powten_Flt;\n+with System.Unsigned_Types;\n with System.Val_Real;\n \n package System.Val_Flt is\n    pragma Preelaborate;\n \n    package Impl is new Val_Real\n      (Float,\n-      Interfaces.Unsigned_32,\n       System.Powten_Flt.Maxpow,\n-      System.Powten_Flt.Powten'Address);\n+      System.Powten_Flt.Powten'Address,\n+      Unsigned_Types.Unsigned);\n \n    function Scan_Float\n      (Str : String;"}, {"sha": "71da12ab97a56ae867d3599fb9412dcb9fb5d176", "filename": "gcc/ada/libgnat/s-vallfl.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -32,18 +32,18 @@\n --  This package contains routines for scanning real values for floating point\n --  type Long_Float, for use in Text_IO.Float_IO and the Value attribute.\n \n-with Interfaces;\n with System.Powten_LFlt;\n+with System.Unsigned_Types;\n with System.Val_Real;\n \n package System.Val_LFlt is\n    pragma Preelaborate;\n \n    package Impl is new Val_Real\n      (Long_Float,\n-      Interfaces.Unsigned_64,\n       System.Powten_LFlt.Maxpow,\n-      System.Powten_LFlt.Powten'Address);\n+      System.Powten_LFlt.Powten'Address,\n+      Unsigned_Types.Long_Long_Unsigned);\n \n    function Scan_Long_Float\n      (Str : String;"}, {"sha": "477ed4ed8d01248d762488ce634344593d4b8cf1", "filename": "gcc/ada/libgnat/s-valllf.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllf.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -32,18 +32,18 @@\n --  This package contains routines for scanning real values for floating point\n --  type Long_Long_Float, for use in Text_IO.Float_IO and the Value attribute.\n \n-with Interfaces;\n with System.Powten_LLF;\n+with System.Unsigned_Types;\n with System.Val_Real;\n \n package System.Val_LLF is\n    pragma Preelaborate;\n \n    package Impl is new Val_Real\n      (Long_Long_Float,\n-      Interfaces.Unsigned_64,\n       System.Powten_LLF.Maxpow,\n-      System.Powten_LLF.Powten'Address);\n+      System.Powten_LLF.Powten'Address,\n+      System.Unsigned_Types.Long_Long_Unsigned);\n \n    function Scan_Long_Long_Float\n      (Str : String;"}, {"sha": "bc5465cf4b9f2506ef3de184af5d7451702234f3", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 106, "deletions": 56, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with System.Double_Real;\n with System.Float_Control;\n with System.Unsigned_Types; use System.Unsigned_Types;\n with System.Val_Util;       use System.Val_Util;\n@@ -76,9 +77,11 @@ package body System.Val_Real is\n       7  => 5836,  8 => 5461,  9 => 5168, 10 => 4932, 11 => 4736,\n       12 => 4570, 13 => 4427, 14 => 4303, 15 => 4193, 16 => 4095);\n \n-   function Fast2Sum (A, B : Num; Err : in out Num) return Num;\n-   --  This is the classical Fast2Sum function assuming round to nearest,\n-   --  with the error accumulated into Err.\n+   package Double_Real is new System.Double_Real (Num);\n+   use type Double_Real.Double_T;\n+\n+   subtype Double_T is Double_Real.Double_T;\n+   --  The double floating-point type\n \n    function Integer_to_Real\n      (Str   : String;\n@@ -89,24 +92,8 @@ package body System.Val_Real is\n       Minus : Boolean) return Num;\n    --  Convert the real value from integer to real representation\n \n-   --------------\n-   -- Fast2Sum --\n-   --------------\n-\n-   function Fast2Sum (A, B : Num; Err : in out Num) return Num is\n-      S, Z : Num;\n-\n-   begin\n-      pragma Assert (abs (A) >= abs (B));\n-\n-      S := A + B;\n-      Z := S - A;\n-      Z := B - Z;\n-\n-      Err := Err + Z;\n-\n-      return S;\n-   end Fast2Sum;\n+   function Large_Powten (Exp : Natural) return Double_T;\n+   --  Return 10.0**Exp as a double number, where Exp > Maxpow\n \n    ---------------------\n    -- Integer_to_Real --\n@@ -134,6 +121,7 @@ package body System.Val_Real is\n       --  Maximum exponent of the base that can fit in Num\n \n       R_Val : Num;\n+      D_Val : Double_T;\n       S     : Integer := Scale;\n \n    begin\n@@ -146,10 +134,6 @@ package body System.Val_Real is\n          System.Float_Control.Reset;\n       end if;\n \n-      --  Do the conversion\n-\n-      R_Val := Num (Val);\n-\n       --  Take into account the extra digit, i.e. do the two computations\n \n       --    (1)  R_Val := R_Val * Num (B) + Num (Extra)\n@@ -163,11 +147,11 @@ package body System.Val_Real is\n \n       if Need_Extra and then Extra > 0 then\n          declare\n-            B : Unsigned := Base;\n-\n-            Acc : Num := 0.0;\n-            Err : Num := 0.0;\n-            Fac : Num := R_Val;\n+            B   : Unsigned := Base;\n+            Acc : Num      := 0.0;\n+            Err : Num      := 0.0;\n+            Fac : Num      := Num (Val);\n+            DS  : Double_T;\n \n          begin\n             loop\n@@ -176,7 +160,13 @@ package body System.Val_Real is\n                --  never larger than the factor minus the initial value).\n \n                if B rem 2 /= 0 then\n-                  Acc := (if Acc = 0.0 then Fac else Fast2Sum (Fac, Acc, Err));\n+                  if Acc = 0.0 then\n+                     Acc := Fac;\n+                  else\n+                     DS  := Double_Real.Quick_Two_Sum (Fac, Acc);\n+                     Acc := DS.Hi;\n+                     Err := Err + DS.Lo;\n+                  end if;\n                   exit when B = 1;\n                end if;\n \n@@ -189,75 +179,106 @@ package body System.Val_Real is\n \n             --  Add Extra to the error, which are both small integers\n \n-            Err := Err + Num (Extra);\n+            D_Val := Double_Real.Quick_Two_Sum (Acc, Err + Num (Extra));\n+\n+            S := S - 1;\n+         end;\n+\n+      --  Or else, if the Extra digit is zero, do the exact conversion\n \n-            --  Acc + Err is the exact result before rounding\n+      elsif Need_Extra then\n+         D_Val := Double_Real.To_Double (Num (Val));\n \n-            R_Val := Acc + Err;\n+      --  Otherwise, the value contains more bits than the mantissa so do the\n+      --  conversion in two steps.\n \n-            S := S - 1;\n+      else\n+         declare\n+            Mask : constant Uns := 2**(Uns'Size - Num'Machine_Mantissa) - 1;\n+            Hi   : constant Uns := Val and not Mask;\n+            Lo   : constant Uns := Val and Mask;\n+\n+         begin\n+            if Hi = 0 then\n+               D_Val := Double_Real.To_Double (Num (Lo));\n+            else\n+               D_Val := Double_Real.Quick_Two_Sum (Num (Hi), Num (Lo));\n+            end if;\n          end;\n       end if;\n \n-      --  Compute the final value\n+      --  Compute the final value by applying the scaling, if any\n \n-      if R_Val /= 0.0 and then S /= 0 then\n+      if Val = 0 or else S = 0 then\n+         R_Val := Double_Real.To_Single (D_Val);\n+\n+      else\n          case Base is\n             --  If the base is a power of two, we use the efficient Scaling\n             --  attribute with an overflow check, if it is not 2, to catch\n             --  ludicrous exponents that would result in an infinity or zero.\n \n             when 2 =>\n-               R_Val := Num'Scaling (R_Val, S);\n+               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n \n             when 4 =>\n                if Integer'First / 2 <= S and then S <= Integer'Last / 2 then\n                   S := S * 2;\n                end if;\n \n-               R_Val := Num'Scaling (R_Val, S);\n+               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n \n             when 8 =>\n                if Integer'First / 3 <= S and then S <= Integer'Last / 3 then\n                   S := S * 3;\n                end if;\n \n-               R_Val := Num'Scaling (R_Val, S);\n+               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n \n             when 16 =>\n                if Integer'First / 4 <= S and then S <= Integer'Last / 4 then\n                   S := S * 4;\n                end if;\n \n-               R_Val := Num'Scaling (R_Val, S);\n+               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n+\n+            --  If the base is 10, use a double implementation for the sake\n+            --  of accuracy, to be removed when exponentiation is improved.\n \n-            --  If the base is 10, we use a table of powers for accuracy's sake\n+            --  When the exponent is positive, we can do the computation\n+            --  directly because, if the exponentiation overflows, then\n+            --  the final value overflows as well. But when the exponent\n+            --  is negative, we may need to do it in two steps to avoid\n+            --  an artificial underflow.\n \n             when 10 =>\n                declare\n-                  subtype Pow_Num is Num range 1.0 .. Num'Last;\n-\n-                  Powten : constant array (0 .. Maxpow) of Pow_Num;\n+                  Powten : constant array (0 .. Maxpow) of Double_T;\n                   pragma Import (Ada, Powten);\n                   for Powten'Address use Powten_Address;\n \n                begin\n                   if S > 0 then\n-                     while S > Maxpow loop\n-                        R_Val := R_Val * Powten (Maxpow);\n-                        S := S - Maxpow;\n-                     end loop;\n-\n-                     R_Val := R_Val * Powten (S);\n+                     if S <= Maxpow then\n+                        D_Val := D_Val * Powten (S);\n+                     else\n+                        D_Val := D_Val * Large_Powten (S);\n+                     end if;\n \n                   else\n-                     while S < -Maxpow loop\n-                        R_Val := R_Val / Powten (Maxpow);\n-                        S := S + Maxpow;\n-                     end loop;\n+                     if S < -Maxexp then\n+                        D_Val := D_Val / Large_Powten (Maxexp);\n+                        S := S + Maxexp;\n+                     end if;\n \n-                     R_Val := R_Val / Powten (-S);\n+                     if S >= -Maxpow then\n+                        D_Val := D_Val / Powten (-S);\n+                     else\n+                        D_Val := D_Val / Large_Powten (-S);\n+                     end if;\n                   end if;\n+\n+                  R_Val := Double_Real.To_Single (D_Val);\n                end;\n \n             --  Implementation for other bases with exponentiation\n@@ -273,6 +294,7 @@ package body System.Val_Real is\n                   B : constant Num := Num (Base);\n \n                begin\n+                  R_Val := Double_Real.To_Single (D_Val);\n \n                   if S > 0 then\n                      R_Val := R_Val * B ** S;\n@@ -298,6 +320,34 @@ package body System.Val_Real is\n       when Constraint_Error => Bad_Value (Str);\n    end Integer_to_Real;\n \n+   ------------------\n+   -- Large_Powten --\n+   ------------------\n+\n+   function Large_Powten (Exp : Natural) return Double_T is\n+      Powten : constant array (0 .. Maxpow) of Double_T;\n+      pragma Import (Ada, Powten);\n+      for Powten'Address use Powten_Address;\n+\n+      R : Double_T;\n+      E : Natural;\n+\n+   begin\n+      pragma Assert (Exp > Maxpow);\n+\n+      R := Powten (Maxpow);\n+      E := Exp - Maxpow;\n+\n+      while E > Maxpow loop\n+         R := R * Powten (Maxpow);\n+         E := E - Maxpow;\n+      end loop;\n+\n+      R := R * Powten (E);\n+\n+      return R;\n+   end Large_Powten;\n+\n    ---------------\n    -- Scan_Real --\n    ---------------"}, {"sha": "e2613e030613f78ff242877a4485604aaead8fb7", "filename": "gcc/ada/libgnat/s-valrea.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Flibgnat%2Fs-valrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -36,12 +36,12 @@ generic\n \n    type Num is digits <>;\n \n-   type Uns is mod <>;\n-\n    Maxpow : Positive;\n \n    Powten_Address : System.Address;\n \n+   type Uns is mod <>;\n+\n package System.Val_Real is\n    pragma Preelaborate;\n "}, {"sha": "07820dba88aa5bb363f88723ae7ab17fd8631119", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec80b416554d3f41b5fd23cc86287af9b9a7d2d2/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=ec80b416554d3f41b5fd23cc86287af9b9a7d2d2", "patch": "@@ -264,13 +264,15 @@ package Rtsfind is\n       System_Img_Fixed_32,\n       System_Img_Fixed_64,\n       System_Img_Fixed_128,\n+      System_Img_Flt,\n       System_Img_Int,\n+      System_Img_LFlt,\n+      System_Img_LLF,\n       System_Img_LLI,\n       System_Img_LLLI,\n       System_Img_LLU,\n       System_Img_LLLU,\n       System_Img_Name,\n-      System_Img_Real,\n       System_Img_Uns,\n       System_Img_WChar,\n       System_Interrupts,\n@@ -956,14 +958,14 @@ package Rtsfind is\n \n      RE_Fore_Decimal128,                 -- System.Fore_Decimal_128\n \n+     RE_Fore_Fixed,                      -- System.Fore_Real\n+\n      RE_Fore_Fixed32,                    -- System.Fore_Fixed_32\n \n      RE_Fore_Fixed64,                    -- System.Fore_Fixed_64\n \n      RE_Fore_Fixed128,                   -- System.Fore_Fixed_128\n \n-     RE_Fore_Real,                       -- System.Fore_Real\n-\n      RE_Image_Boolean,                   -- System.Img_Bool\n \n      RE_Image_Character,                 -- System.Img_Char\n@@ -979,8 +981,14 @@ package Rtsfind is\n      RE_Image_Enumeration_16,            -- System.Img_Enum_New\n      RE_Image_Enumeration_32,            -- System.Img_Enum_New\n \n+     RE_Image_Float,                     -- System_Img_Flt\n+\n      RE_Image_Integer,                   -- System.Img_Int\n \n+     RE_Image_Long_Float,                -- System_Img_LFlt\n+\n+     RE_Image_Long_Long_Float,           -- System_Img_LLF\n+\n      RE_Image_Long_Long_Integer,         -- System.Img_LLI\n \n      RE_Image_Long_Long_Long_Integer,    -- System.Img_LLLI\n@@ -989,12 +997,13 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Long_Unsigned,   -- System.Img_LLLU\n \n+     RE_Image_Fixed,                     -- System.Img_LFlt\n+\n      RE_Image_Fixed32,                   -- System.Img_Fixed_32\n+\n      RE_Image_Fixed64,                   -- System.Img_Fixed_64\n-     RE_Image_Fixed128,                  -- System.Img_Fixed_128\n \n-     RE_Image_Ordinary_Fixed_Point,      -- System.Img_Real\n-     RE_Image_Floating_Point,            -- System.Img_Real\n+     RE_Image_Fixed128,                  -- System.Img_Fixed_128\n \n      RE_Image_Unsigned,                  -- System.Img_Uns\n \n@@ -2635,14 +2644,14 @@ package Rtsfind is\n \n      RE_Fore_Decimal128                  => System_Fore_Decimal_128,\n \n+     RE_Fore_Fixed                       => System_Fore_Real,\n+\n      RE_Fore_Fixed32                     => System_Fore_Fixed_32,\n \n      RE_Fore_Fixed64                     => System_Fore_Fixed_64,\n \n      RE_Fore_Fixed128                    => System_Fore_Fixed_128,\n \n-     RE_Fore_Real                        => System_Fore_Real,\n-\n      RE_Image_Boolean                    => System_Img_Bool,\n \n      RE_Image_Character                  => System_Img_Char,\n@@ -2658,8 +2667,14 @@ package Rtsfind is\n      RE_Image_Enumeration_16             => System_Img_Enum_New,\n      RE_Image_Enumeration_32             => System_Img_Enum_New,\n \n+     RE_Image_Float                      => System_Img_Flt,\n+\n      RE_Image_Integer                    => System_Img_Int,\n \n+     RE_Image_Long_Float                 => System_Img_LFlt,\n+\n+     RE_Image_Long_Long_Float            => System_Img_LLF,\n+\n      RE_Image_Long_Long_Integer          => System_Img_LLI,\n \n      RE_Image_Long_Long_Long_Integer     => System_Img_LLLI,\n@@ -2668,12 +2683,13 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Long_Unsigned    => System_Img_LLLU,\n \n+     RE_Image_Fixed                      => System_Img_LFlt,\n+\n      RE_Image_Fixed32                    => System_Img_Fixed_32,\n+\n      RE_Image_Fixed64                    => System_Img_Fixed_64,\n-     RE_Image_Fixed128                   => System_Img_Fixed_128,\n \n-     RE_Image_Ordinary_Fixed_Point       => System_Img_Real,\n-     RE_Image_Floating_Point             => System_Img_Real,\n+     RE_Image_Fixed128                   => System_Img_Fixed_128,\n \n      RE_Image_Unsigned                   => System_Img_Uns,\n "}]}