{"sha": "f48b51496d08de2aabc5ed1deb45e5517333662c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4YjUxNDk2ZDA4ZGUyYWFiYzVlZDFkZWI0NWU1NTE3MzMzNjYyYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:05Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:05Z"}, "message": "simplify-rtx: Put simplify routines into a class\n\nOne of the recurring warts of RTL is that multiplication by a power\nof 2 is represented as a MULT inside a MEM but as an ASHIFT outside\na MEM.  It would obviously be better if we didn't have this kind of\ncontext sensitivity, but it would be difficult to remove.\n\nCurrently the simplify-rtx.c routines are hard-coded for the\nASHIFT form.  This means that some callers have to convert the\nASHIFTs \u201cback\u201d into MULTs after calling the simplify-rtx.c\nroutines; see fwprop.c:canonicalize_address for an example.\n\nI think we can relieve some of the pain by wrapping the simplify-rtx.c\nroutines in a simple class that tracks whether the expression occurs\nin a MEM or not, so that no post-processing is needed.\n\nAn obvious concern is whether passing the \u201cthis\u201d pointer around\nwill slow things down or bloat the code.  I can't measure any\nincrease in compile time after applying the patch.  Sizewise,\nsimplify-rtx.o text increases by 2.3% in default-checking builds\nand 4.1% in release-checking builds.\n\nI realise the MULT/ASHIFT thing isn't the most palatable\nreason for doing this, but I think it might be useful for\nother things in future, such as using local nonzero_bits\nhooks/virtual functions instead of the global hooks.\n\nThe obvious alternative would be to add a static variable\nand hope that it is always updated correctly.\n\nLater patches make use of this.\n\ngcc/\n\t* rtl.h (simplify_context): New class.\n\t(simplify_unary_operation, simplify_binary_operation): Use it.\n\t(simplify_ternary_operation, simplify_relational_operation): Likewise.\n\t(simplify_subreg, simplify_gen_unary, simplify_gen_binary): Likewise.\n\t(simplify_gen_ternary, simplify_gen_relational): Likewise.\n\t(simplify_gen_subreg, lowpart_subreg): Likewise.\n\t* simplify-rtx.c (simplify_gen_binary): Turn into a member function\n\tof simplify_context.\n\t(simplify_gen_unary, simplify_gen_ternary, simplify_gen_relational)\n\t(simplify_truncation, simplify_unary_operation): Likewise.\n\t(simplify_unary_operation_1, simplify_byte_swapping_operation)\n\t(simplify_associative_operation, simplify_logical_relational_operation)\n\t(simplify_binary_operation, simplify_binary_operation_series)\n\t(simplify_distributive_operation, simplify_plus_minus): Likewise.\n\t(simplify_relational_operation, simplify_relational_operation_1)\n\t(simplify_cond_clz_ctz, simplify_merge_mask): Likewise.\n\t(simplify_ternary_operation, simplify_subreg, simplify_gen_subreg)\n\t(lowpart_subreg): Likewise.\n\t(simplify_binary_operation_1): Likewise.  Test mem_depth when\n\tdeciding whether the ASHIFT or MULT form is canonical.\n\t(simplify_merge_mask): Use simplify_context.", "tree": {"sha": "9fa3b070c0356997a49224e484e4d3cf9b8f7f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa3b070c0356997a49224e484e4d3cf9b8f7f7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f48b51496d08de2aabc5ed1deb45e5517333662c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48b51496d08de2aabc5ed1deb45e5517333662c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48b51496d08de2aabc5ed1deb45e5517333662c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48b51496d08de2aabc5ed1deb45e5517333662c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b665081f577d875903570ad64f40278faf0f79a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b665081f577d875903570ad64f40278faf0f79a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b665081f577d875903570ad64f40278faf0f79a0"}], "stats": {"total": 301, "additions": 220, "deletions": 81}, "files": [{"sha": "e9df95b02c44e2b795c666c9a71ff5808d0e8095", "filename": "gcc/rtl.h", "status": "modified", "additions": 131, "deletions": 18, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48b51496d08de2aabc5ed1deb45e5517333662c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48b51496d08de2aabc5ed1deb45e5517333662c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f48b51496d08de2aabc5ed1deb45e5517333662c", "patch": "@@ -3375,30 +3375,143 @@ extern rtx_insn *try_split (rtx, rtx_insn *, int);\n extern rtx_insn *split_insns (rtx, rtx_insn *);\n \n /* In simplify-rtx.c  */\n+\n+/* A class that records the context in which a simplification\n+   is being mode.  */\n+class simplify_context\n+{\n+public:\n+  rtx simplify_unary_operation (rtx_code, machine_mode, rtx, machine_mode);\n+  rtx simplify_binary_operation (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_ternary_operation (rtx_code, machine_mode, machine_mode,\n+\t\t\t\t  rtx, rtx, rtx);\n+  rtx simplify_relational_operation (rtx_code, machine_mode, machine_mode,\n+\t\t\t\t     rtx, rtx);\n+  rtx simplify_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n+\n+  rtx lowpart_subreg (machine_mode, rtx, machine_mode);\n+\n+  rtx simplify_merge_mask (rtx, rtx, int);\n+\n+  rtx simplify_gen_unary (rtx_code, machine_mode, rtx, machine_mode);\n+  rtx simplify_gen_binary (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_gen_ternary (rtx_code, machine_mode, machine_mode,\n+\t\t\t    rtx, rtx, rtx);\n+  rtx simplify_gen_relational (rtx_code, machine_mode, machine_mode, rtx, rtx);\n+  rtx simplify_gen_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n+\n+  /* Tracks the level of MEM nesting for the value being simplified:\n+     0 means the value is not in a MEM, >0 means it is.  This is needed\n+     because the canonical representation of multiplication is different\n+     inside a MEM than outside.  */\n+  unsigned int mem_depth = 0;\n+\n+private:\n+  rtx simplify_truncation (machine_mode, rtx, machine_mode);\n+  rtx simplify_byte_swapping_operation (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_associative_operation (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_distributive_operation (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_logical_relational_operation (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_binary_operation_series (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_distribute_over_subregs (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_shift_const_int (rtx_code, machine_mode, rtx, unsigned int);\n+  rtx simplify_plus_minus (rtx_code, machine_mode, rtx, rtx);\n+  rtx simplify_cond_clz_ctz (rtx, rtx_code, rtx, rtx);\n+\n+  rtx simplify_unary_operation_1 (rtx_code, machine_mode, rtx);\n+  rtx simplify_binary_operation_1 (rtx_code, machine_mode, rtx, rtx, rtx, rtx);\n+  rtx simplify_ternary_operation_1 (rtx_code, machine_mode, machine_mode,\n+\t\t\t\t    rtx, rtx, rtx);\n+  rtx simplify_relational_operation_1 (rtx_code, machine_mode, machine_mode,\n+\t\t\t\t       rtx, rtx);\n+};\n+\n+inline rtx\n+simplify_unary_operation (rtx_code code, machine_mode mode, rtx op,\n+\t\t\t  machine_mode op_mode)\n+{\n+  return simplify_context ().simplify_unary_operation (code, mode, op,\n+\t\t\t\t\t\t       op_mode);\n+}\n+\n+inline rtx\n+simplify_binary_operation (rtx_code code, machine_mode mode, rtx op0, rtx op1)\n+{\n+  return simplify_context ().simplify_binary_operation (code, mode, op0, op1);\n+}\n+\n+inline rtx\n+simplify_ternary_operation (rtx_code code, machine_mode mode,\n+\t\t\t    machine_mode op0_mode, rtx op0, rtx op1, rtx op2)\n+{\n+  return simplify_context ().simplify_ternary_operation (code, mode, op0_mode,\n+\t\t\t\t\t\t\t op0, op1, op2);\n+}\n+\n+inline rtx\n+simplify_relational_operation (rtx_code code, machine_mode mode,\n+\t\t\t       machine_mode op_mode, rtx op0, rtx op1)\n+{\n+  return simplify_context ().simplify_relational_operation (code, mode,\n+\t\t\t\t\t\t\t    op_mode, op0, op1);\n+}\n+\n+inline rtx\n+simplify_subreg (machine_mode outermode, rtx op, machine_mode innermode,\n+\t\t poly_uint64 byte)\n+{\n+  return simplify_context ().simplify_subreg (outermode, op, innermode, byte);\n+}\n+\n+inline rtx\n+simplify_gen_unary (rtx_code code, machine_mode mode, rtx op,\n+\t\t    machine_mode op_mode)\n+{\n+  return simplify_context ().simplify_gen_unary (code, mode, op, op_mode);\n+}\n+\n+inline rtx\n+simplify_gen_binary (rtx_code code, machine_mode mode, rtx op0, rtx op1)\n+{\n+  return simplify_context ().simplify_gen_binary (code, mode, op0, op1);\n+}\n+\n+inline rtx\n+simplify_gen_ternary (rtx_code code, machine_mode mode, machine_mode op0_mode,\n+\t\t      rtx op0, rtx op1, rtx op2)\n+{\n+  return simplify_context ().simplify_gen_ternary (code, mode, op0_mode,\n+\t\t\t\t\t\t   op0, op1, op2);\n+}\n+\n+inline rtx\n+simplify_gen_relational (rtx_code code, machine_mode mode,\n+\t\t\t machine_mode op_mode, rtx op0, rtx op1)\n+{\n+  return simplify_context ().simplify_gen_relational (code, mode, op_mode,\n+\t\t\t\t\t\t      op0, op1);\n+}\n+\n+inline rtx\n+simplify_gen_subreg (machine_mode outermode, rtx op, machine_mode innermode,\n+\t\t     poly_uint64 byte)\n+{\n+  return simplify_context ().simplify_gen_subreg (outermode, op,\n+\t\t\t\t\t\t  innermode, byte);\n+}\n+\n+inline rtx\n+lowpart_subreg (machine_mode outermode, rtx op, machine_mode innermode)\n+{\n+  return simplify_context ().lowpart_subreg (outermode, op, innermode);\n+}\n+\n extern rtx simplify_const_unary_operation (enum rtx_code, machine_mode,\n \t\t\t\t\t   rtx, machine_mode);\n-extern rtx simplify_unary_operation (enum rtx_code, machine_mode, rtx,\n-\t\t\t\t     machine_mode);\n extern rtx simplify_const_binary_operation (enum rtx_code, machine_mode,\n \t\t\t\t\t    rtx, rtx);\n-extern rtx simplify_binary_operation (enum rtx_code, machine_mode, rtx,\n-\t\t\t\t      rtx);\n-extern rtx simplify_ternary_operation (enum rtx_code, machine_mode,\n-\t\t\t\t       machine_mode, rtx, rtx, rtx);\n extern rtx simplify_const_relational_operation (enum rtx_code,\n \t\t\t\t\t\tmachine_mode, rtx, rtx);\n-extern rtx simplify_relational_operation (enum rtx_code, machine_mode,\n-\t\t\t\t\t  machine_mode, rtx, rtx);\n-extern rtx simplify_gen_binary (enum rtx_code, machine_mode, rtx, rtx);\n-extern rtx simplify_gen_unary (enum rtx_code, machine_mode, rtx,\n-\t\t\t       machine_mode);\n-extern rtx simplify_gen_ternary (enum rtx_code, machine_mode,\n-\t\t\t\t machine_mode, rtx, rtx, rtx);\n-extern rtx simplify_gen_relational (enum rtx_code, machine_mode,\n-\t\t\t\t    machine_mode, rtx, rtx);\n-extern rtx simplify_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n-extern rtx simplify_gen_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n-extern rtx lowpart_subreg (machine_mode, rtx, machine_mode);\n extern rtx simplify_replace_fn_rtx (rtx, const_rtx,\n \t\t\t\t    rtx (*fn) (rtx, const_rtx, void *), void *);\n extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);"}, {"sha": "ff331e1a17f070ca3f7ecf5f80755b879884c05b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 89, "deletions": 63, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48b51496d08de2aabc5ed1deb45e5517333662c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48b51496d08de2aabc5ed1deb45e5517333662c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f48b51496d08de2aabc5ed1deb45e5517333662c", "patch": "@@ -47,14 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n   ((((HOST_WIDE_INT) low) < 0) ? HOST_WIDE_INT_M1 : HOST_WIDE_INT_0)\n \n static bool plus_minus_operand_p (const_rtx);\n-static rtx simplify_plus_minus (enum rtx_code, machine_mode, rtx, rtx);\n-static rtx simplify_associative_operation (enum rtx_code, machine_mode,\n-\t\t\t\t\t   rtx, rtx);\n-static rtx simplify_relational_operation_1 (enum rtx_code, machine_mode,\n-\t\t\t\t\t    machine_mode, rtx, rtx);\n-static rtx simplify_unary_operation_1 (enum rtx_code, machine_mode, rtx);\n-static rtx simplify_binary_operation_1 (enum rtx_code, machine_mode,\n-\t\t\t\t\trtx, rtx, rtx, rtx);\n \f\n /* Negate I, which satisfies poly_int_rtx_p.  MODE is the mode of I.  */\n \n@@ -180,8 +172,8 @@ val_signbit_known_clear_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n    seeing if the expression folds.  */\n \n rtx\n-simplify_gen_binary (enum rtx_code code, machine_mode mode, rtx op0,\n-\t\t     rtx op1)\n+simplify_context::simplify_gen_binary (rtx_code code, machine_mode mode,\n+\t\t\t\t       rtx op0, rtx op1)\n {\n   rtx tem;\n \n@@ -358,8 +350,8 @@ delegitimize_mem_from_attrs (rtx x)\n    the specified operation.  */\n \n rtx\n-simplify_gen_unary (enum rtx_code code, machine_mode mode, rtx op,\n-\t\t    machine_mode op_mode)\n+simplify_context::simplify_gen_unary (rtx_code code, machine_mode mode, rtx op,\n+\t\t\t\t      machine_mode op_mode)\n {\n   rtx tem;\n \n@@ -373,8 +365,9 @@ simplify_gen_unary (enum rtx_code code, machine_mode mode, rtx op,\n /* Likewise for ternary operations.  */\n \n rtx\n-simplify_gen_ternary (enum rtx_code code, machine_mode mode,\n-\t\t      machine_mode op0_mode, rtx op0, rtx op1, rtx op2)\n+simplify_context::simplify_gen_ternary (rtx_code code, machine_mode mode,\n+\t\t\t\t\tmachine_mode op0_mode,\n+\t\t\t\t\trtx op0, rtx op1, rtx op2)\n {\n   rtx tem;\n \n@@ -390,8 +383,9 @@ simplify_gen_ternary (enum rtx_code code, machine_mode mode,\n    CMP_MODE specifies mode comparison is done in.  */\n \n rtx\n-simplify_gen_relational (enum rtx_code code, machine_mode mode,\n-\t\t\t machine_mode cmp_mode, rtx op0, rtx op1)\n+simplify_context::simplify_gen_relational (rtx_code code, machine_mode mode,\n+\t\t\t\t\t   machine_mode cmp_mode,\n+\t\t\t\t\t   rtx op0, rtx op1)\n {\n   rtx tem;\n \n@@ -614,9 +608,9 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n    However, X is still an arbitrary 64-bit number and so we cannot\n    assume that truncating it too is a no-op.  */\n \n-static rtx\n-simplify_truncation (machine_mode mode, rtx op,\n-\t\t     machine_mode op_mode)\n+rtx\n+simplify_context::simplify_truncation (machine_mode mode, rtx op,\n+\t\t\t\t       machine_mode op_mode)\n {\n   unsigned int precision = GET_MODE_UNIT_PRECISION (mode);\n   unsigned int op_precision = GET_MODE_UNIT_PRECISION (op_mode);\n@@ -858,8 +852,8 @@ simplify_truncation (machine_mode mode, rtx op,\n    MODE with input operand OP whose mode was originally OP_MODE.\n    Return zero if no simplification can be made.  */\n rtx\n-simplify_unary_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t  rtx op, machine_mode op_mode)\n+simplify_context::simplify_unary_operation (rtx_code code, machine_mode mode,\n+\t\t\t\t\t    rtx op, machine_mode op_mode)\n {\n   rtx trueop, tem;\n \n@@ -900,8 +894,9 @@ exact_int_to_float_conversion_p (const_rtx op)\n \n /* Perform some simplifications we can do even if the operands\n    aren't constant.  */\n-static rtx\n-simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n+rtx\n+simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n+\t\t\t\t\t      rtx op)\n {\n   enum rtx_code reversed;\n   rtx temp, elt, base, step;\n@@ -2091,9 +2086,10 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n    operating on OP0 and OP1.  CODE is currently one of AND, IOR or XOR.\n    Return zero if no simplification or canonicalization is possible.  */\n \n-static rtx\n-simplify_byte_swapping_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t\t  rtx op0, rtx op1)\n+rtx\n+simplify_context::simplify_byte_swapping_operation (rtx_code code,\n+\t\t\t\t\t\t    machine_mode mode,\n+\t\t\t\t\t\t    rtx op0, rtx op1)\n {\n   rtx tem;\n \n@@ -2121,9 +2117,10 @@ simplify_byte_swapping_operation (enum rtx_code code, machine_mode mode,\n    SMIN, SMAX, UMIN or UMAX.  Return zero if no simplification or\n    canonicalization is possible.  */\n \n-static rtx\n-simplify_associative_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t\trtx op0, rtx op1)\n+rtx\n+simplify_context::simplify_associative_operation (rtx_code code,\n+\t\t\t\t\t\t  machine_mode mode,\n+\t\t\t\t\t\t  rtx op0, rtx op1)\n {\n   rtx tem;\n \n@@ -2302,8 +2299,9 @@ comparison_code_valid_for_mode (enum rtx_code code, enum machine_mode mode)\n    and OP1, which should be both relational operations.  Return 0 if no such\n    simplification is possible.  */\n rtx\n-simplify_logical_relational_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t\t       rtx op0, rtx op1)\n+simplify_context::simplify_logical_relational_operation (rtx_code code,\n+\t\t\t\t\t\t\t machine_mode mode,\n+\t\t\t\t\t\t\t rtx op0, rtx op1)\n {\n   /* We only handle IOR of two relational operations.  */\n   if (code != IOR)\n@@ -2351,8 +2349,8 @@ simplify_logical_relational_operation (enum rtx_code code, machine_mode mode,\n    Don't use this for relational operations such as EQ or LT.\n    Use simplify_relational_operation instead.  */\n rtx\n-simplify_binary_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t   rtx op0, rtx op1)\n+simplify_context::simplify_binary_operation (rtx_code code, machine_mode mode,\n+\t\t\t\t\t     rtx op0, rtx op1)\n {\n   rtx trueop0, trueop1;\n   rtx tem;\n@@ -2397,9 +2395,10 @@ simplify_binary_operation (enum rtx_code code, machine_mode mode,\n    MODE is the mode of the operation and is known to be a vector\n    integer mode.  */\n \n-static rtx\n-simplify_binary_operation_series (rtx_code code, machine_mode mode,\n-\t\t\t\t  rtx op0, rtx op1)\n+rtx\n+simplify_context::simplify_binary_operation_series (rtx_code code,\n+\t\t\t\t\t\t    machine_mode mode,\n+\t\t\t\t\t\t    rtx op0, rtx op1)\n {\n   rtx base0, step0;\n   if (vec_duplicate_p (op0, &base0))\n@@ -2433,9 +2432,10 @@ simplify_binary_operation_series (rtx_code code, machine_mode mode,\n    e.g. simplify (xor (and A C) (and (B C)) to (and (xor (A B) C).\n    Returns NULL_RTX if no simplification is possible.  */\n \n-static rtx\n-simplify_distributive_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t\t rtx op0, rtx op1)\n+rtx\n+simplify_context::simplify_distributive_operation (rtx_code code,\n+\t\t\t\t\t\t   machine_mode mode,\n+\t\t\t\t\t\t   rtx op0, rtx op1)\n {\n   enum rtx_code op = GET_CODE (op0);\n   gcc_assert (GET_CODE (op1) == op);\n@@ -2481,9 +2481,11 @@ simplify_distributive_operation (enum rtx_code code, machine_mode mode,\n    OP1 are constant pool references, TRUEOP0 and TRUEOP1 represent the\n    actual constants.  */\n \n-static rtx\n-simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n-\t\t\t     rtx op0, rtx op1, rtx trueop0, rtx trueop1)\n+rtx\n+simplify_context::simplify_binary_operation_1 (rtx_code code,\n+\t\t\t\t\t       machine_mode mode,\n+\t\t\t\t\t       rtx op0, rtx op1,\n+\t\t\t\t\t       rtx trueop0, rtx trueop1)\n {\n   rtx tem, reversed, opleft, opright, elt0, elt1;\n   HOST_WIDE_INT val;\n@@ -2948,7 +2950,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \treturn op0;\n \n       /* Convert multiply by constant power of two into shift.  */\n-      if (CONST_SCALAR_INT_P (trueop1))\n+      if (mem_depth == 0 && CONST_SCALAR_INT_P (trueop1))\n \t{\n \t  val = wi::exact_log2 (rtx_mode_t (trueop1, mode));\n \t  if (val >= 0)\n@@ -3863,6 +3865,18 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \treturn op0;\n       if (trueop0 == CONST0_RTX (mode) && ! side_effects_p (op1))\n \treturn op0;\n+      if (mem_depth\n+\t  && code == ASHIFT\n+\t  && CONST_INT_P (trueop1)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && IN_RANGE (UINTVAL (trueop1),\n+\t\t       1, GET_MODE_PRECISION (int_mode) - 1))\n+\t{\n+\t  auto c = (wi::one (GET_MODE_PRECISION (int_mode))\n+\t\t    << UINTVAL (trueop1));\n+\t  rtx new_op1 = immed_wide_int_const (c, int_mode);\n+\t  return simplify_gen_binary (MULT, int_mode, op0, new_op1);\n+\t}\n       goto canonicalize_shift;\n \n     case LSHIFTRT:\n@@ -4887,9 +4901,9 @@ simplify_plus_minus_op_data_cmp (rtx x, rtx y)\n \n    May return NULL_RTX when no changes were made.  */\n \n-static rtx\n-simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n-\t\t     rtx op1)\n+rtx\n+simplify_context::simplify_plus_minus (rtx_code code, machine_mode mode,\n+\t\t\t\t       rtx op0, rtx op1)\n {\n   struct simplify_plus_minus_op_data\n   {\n@@ -5234,8 +5248,10 @@ plus_minus_operand_p (const_rtx x)\n    the operands or, if both are VOIDmode, the operands are compared in\n    \"infinite precision\".  */\n rtx\n-simplify_relational_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t       machine_mode cmp_mode, rtx op0, rtx op1)\n+simplify_context::simplify_relational_operation (rtx_code code,\n+\t\t\t\t\t\t machine_mode mode,\n+\t\t\t\t\t\t machine_mode cmp_mode,\n+\t\t\t\t\t\t rtx op0, rtx op1)\n {\n   rtx tem, trueop0, trueop1;\n \n@@ -5318,9 +5334,11 @@ simplify_relational_operation (enum rtx_code code, machine_mode mode,\n    MODE is the mode of the result, while CMP_MODE specifies in which\n    mode the comparison is done in, so it is the mode of the operands.  */\n \n-static rtx\n-simplify_relational_operation_1 (enum rtx_code code, machine_mode mode,\n-\t\t\t\t machine_mode cmp_mode, rtx op0, rtx op1)\n+rtx\n+simplify_context::simplify_relational_operation_1 (rtx_code code,\n+\t\t\t\t\t\t   machine_mode mode,\n+\t\t\t\t\t\t   machine_mode cmp_mode,\n+\t\t\t\t\t\t   rtx op0, rtx op1)\n {\n   enum rtx_code op0code = GET_CODE (op0);\n \n@@ -5988,8 +6006,9 @@ simplify_const_relational_operation (enum rtx_code code,\n    Assume X is compared against zero with CMP_CODE and the true\n    arm is TRUE_VAL and the false arm is FALSE_VAL.  */\n \n-static rtx\n-simplify_cond_clz_ctz (rtx x, rtx_code cmp_code, rtx true_val, rtx false_val)\n+rtx\n+simplify_context::simplify_cond_clz_ctz (rtx x, rtx_code cmp_code,\n+\t\t\t\t\t rtx true_val, rtx false_val)\n {\n   if (cmp_code != EQ && cmp_code != NE)\n     return NULL_RTX;\n@@ -6032,7 +6051,7 @@ simplify_cond_clz_ctz (rtx x, rtx_code cmp_code, rtx true_val, rtx false_val)\n    Return the simplified X on success, otherwise return NULL_RTX.  */\n \n rtx\n-simplify_merge_mask (rtx x, rtx mask, int op)\n+simplify_context::simplify_merge_mask (rtx x, rtx mask, int op)\n {\n   gcc_assert (VECTOR_MODE_P (GET_MODE (x)));\n   poly_uint64 nunits = GET_MODE_NUNITS (GET_MODE (x));\n@@ -6102,9 +6121,9 @@ simplify_merge_mask (rtx x, rtx mask, int op)\n    a constant.  Return 0 if no simplifications is possible.  */\n \n rtx\n-simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n-\t\t\t    machine_mode op0_mode, rtx op0, rtx op1,\n-\t\t\t    rtx op2)\n+simplify_context::simplify_ternary_operation (rtx_code code, machine_mode mode,\n+\t\t\t\t\t      machine_mode op0_mode,\n+\t\t\t\t\t      rtx op0, rtx op1, rtx op2)\n {\n   bool any_change = false;\n   rtx tem, trueop2;\n@@ -6971,8 +6990,8 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx x,\n /* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)\n    Return 0 if no simplifications are possible.  */\n rtx\n-simplify_subreg (machine_mode outermode, rtx op,\n-\t\t machine_mode innermode, poly_uint64 byte)\n+simplify_context::simplify_subreg (machine_mode outermode, rtx op,\n+\t\t\t\t   machine_mode innermode, poly_uint64 byte)\n {\n   /* Little bit of sanity checking.  */\n   gcc_assert (innermode != VOIDmode);\n@@ -7246,8 +7265,9 @@ simplify_subreg (machine_mode outermode, rtx op,\n /* Make a SUBREG operation or equivalent if it folds.  */\n \n rtx\n-simplify_gen_subreg (machine_mode outermode, rtx op,\n-\t\t     machine_mode innermode, poly_uint64 byte)\n+simplify_context::simplify_gen_subreg (machine_mode outermode, rtx op,\n+\t\t\t\t       machine_mode innermode,\n+\t\t\t\t       poly_uint64 byte)\n {\n   rtx newx;\n \n@@ -7270,8 +7290,8 @@ simplify_gen_subreg (machine_mode outermode, rtx op,\n    INNER_MODE) to OUTER_MODE.  */\n \n rtx\n-lowpart_subreg (machine_mode outer_mode, rtx expr,\n-\t\t\t     machine_mode inner_mode)\n+simplify_context::lowpart_subreg (machine_mode outer_mode, rtx expr,\n+\t\t\t\t  machine_mode inner_mode)\n {\n   return simplify_gen_subreg (outer_mode, expr, inner_mode,\n \t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n@@ -7685,6 +7705,12 @@ test_vector_ops_series (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t     series_0_1));\n }\n \n+static rtx\n+simplify_merge_mask (rtx x, rtx mask, int op)\n+{\n+  return simplify_context ().simplify_merge_mask (x, mask, op);\n+}\n+\n /* Verify simplify_merge_mask works correctly.  */\n \n static void"}]}