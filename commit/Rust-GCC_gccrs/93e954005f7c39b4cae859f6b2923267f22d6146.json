{"sha": "93e954005f7c39b4cae859f6b2923267f22d6146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNlOTU0MDA1ZjdjMzliNGNhZTg1OWY2YjI5MjMyNjdmMjJkNjE0Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-10-25T00:00:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-10-25T00:00:54Z"}, "message": "Implement C++17 std::invoke and LWG DR 2219\n\n\t* include/std/functional (__invoke_impl): New overloads.\n\t(__invoke): Replace with a single function calling __invoke_impl.\n\t(invoke): Add C++17 std::invoke.\n\t(reference_wrapper::operator()): Qualify call to __invoke.\n\t(_Mem_fn_traits_base, _Mem_fn_traits): Remove unused typedefs.\n\t(_Mem_fn_base): Remove unused typedefs and implement call operator in\n\tterms of __invoke.\n\t* include/std/future (__future_base::_Async_state_commonV2): Do not\n\tpass reference_wrapper as object argument to call_once.\n\t* include/std/type_traits (result_of): Define nested __invoke_type.\n\tHandle reference_wrapper as per LWG 2219.\n\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error directives.\n\t* testsuite/20_util/function_objects/mem_fn/55463.cc: Remove tests\n\tusing member functions of reference_wrapper.\n\nFrom-SVN: r229290", "tree": {"sha": "7872cf44a758569951ffa9af6f4e8e4f7f4956b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7872cf44a758569951ffa9af6f4e8e4f7f4956b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93e954005f7c39b4cae859f6b2923267f22d6146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e954005f7c39b4cae859f6b2923267f22d6146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93e954005f7c39b4cae859f6b2923267f22d6146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e954005f7c39b4cae859f6b2923267f22d6146/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fbd5984000d529e88e83d2472d53218fc5e49b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fbd5984000d529e88e83d2472d53218fc5e49b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fbd5984000d529e88e83d2472d53218fc5e49b4"}], "stats": {"total": 389, "additions": 175, "deletions": 214}, "files": [{"sha": "7c88b8f7161b83f949bf8a5a4eced5fd26c31670", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -1,3 +1,20 @@\n+2015-10-24  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/functional (__invoke_impl): New overloads.\n+\t(__invoke): Replace with a single function calling __invoke_impl.\n+\t(invoke): Add C++17 std::invoke.\n+\t(reference_wrapper::operator()): Qualify call to __invoke.\n+\t(_Mem_fn_traits_base, _Mem_fn_traits): Remove unused typedefs.\n+\t(_Mem_fn_base): Remove unused typedefs and implement call operator in\n+\tterms of __invoke.\n+\t* include/std/future (__future_base::_Async_state_commonV2): Do not\n+\tpass reference_wrapper as object argument to call_once.\n+\t* include/std/type_traits (result_of): Define nested __invoke_type.\n+\tHandle reference_wrapper as per LWG 2219.\n+\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error directives.\n+\t* testsuite/20_util/function_objects/mem_fn/55463.cc: Remove tests\n+\tusing member functions of reference_wrapper.\n+\n 2015-10-24  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/std/future (async): Use deferred function on exception."}, {"sha": "f1dc8393af879e85348d80e2c105a9be6e30823c", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 86, "deletions": 187, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -184,48 +184,77 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n     { };\n \n-  /**\n-   * Invoke a function object, which may be either a member pointer or a\n-   * function object. The first parameter will tell which.\n-   */\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename enable_if<\n-\t     (!is_member_pointer<_Functor>::value\n-\t      && !is_function<_Functor>::value\n-\t      && !is_function<typename remove_pointer<_Functor>::type>::value),\n-\t     typename result_of<_Functor&(_Args&&...)>::type\n-\t   >::type\n-    __invoke(_Functor& __f, _Args&&... __args)\n+  template<typename _Res, typename _Fn, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)\n+    noexcept(noexcept(std::forward<_Fn>(__f)(std::forward<_Args>(__args)...)))\n+    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,\n+\t\t  _Args&&... __args)\n+    noexcept(noexcept((forward<_Tp>(__t).*__f)(forward<_Args>(__args)...)))\n+    { return (forward<_Tp>(__t).*__f)(forward<_Args>(__args)...); }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f,\n+\t\t  reference_wrapper<_Tp> __t, _Args&&... __args)\n+    noexcept(noexcept((__t.get().*__f)(forward<_Args>(__args)...)))\n+    { return (__t.get().*__f)(forward<_Args>(__args)...); }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,\n+\t\t  _Args&&... __args)\n+    noexcept(noexcept(((*forward<_Tp>(__t)).*__f)(forward<_Args>(__args)...)))\n+    { return ((*forward<_Tp>(__t)).*__f)(forward<_Args>(__args)...); }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memobj_ref, _MemFun&& __f, _Tp&& __t)\n+    noexcept(noexcept(forward<_Tp>(__t).*__f))\n+    { return forward<_Tp>(__t).*__f; }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memobj_ref, _MemFun&& __f,\n+\t\t  reference_wrapper<_Tp> __t)\n+    noexcept(noexcept(__t.get().*__f))\n+    { return __t.get().*__f; }\n+\n+  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>\n+    inline _Res\n+    __invoke_impl(__invoke_memobj_deref, _MemFun&& __f, _Tp&& __t,\n+\t\t  _Args&&... __args)\n+    noexcept(noexcept((*forward<_Tp>(__t)).*__f))\n+    { return (*forward<_Tp>(__t)).*__f; }\n+\n+  /// Invoke a callable object.\n+  template<typename _Callable, typename... _Args>\n+    inline typename result_of<_Callable&&(_Args&&...)>::type\n+    __invoke(_Callable&& __fn, _Args&&... __args)\n     {\n-      return __f(std::forward<_Args>(__args)...);\n+      using __result_of = result_of<_Callable&&(_Args&&...)>;\n+      using __type = typename __result_of::type;\n+      using __tag = typename __result_of::__invoke_type;\n+      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n     }\n \n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename enable_if<\n-             (is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args&&...)>::type\n-           >::type\n-    __invoke(_Functor& __f, _Args&&... __args)\n-    {\n-      return std::mem_fn(__f)(std::forward<_Args>(__args)...);\n-    }\n+#if __cplusplus > 201402L\n+# define __cpp_lib_invoke 201411\n \n-  // To pick up function references (that will become function pointers)\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename enable_if<\n-\t     (is_pointer<_Functor>::value\n-\t      && is_function<typename remove_pointer<_Functor>::type>::value),\n-\t     typename result_of<_Functor(_Args&&...)>::type\n-\t   >::type\n-    __invoke(_Functor __f, _Args&&... __args)\n+  /// Invoke a callable object.\n+  template<typename _Callable, typename... _Args>\n+    inline result_of_t<_Callable&&(_Args&&...)>\n+    invoke(_Callable&& __fn, _Args&&... __args)\n     {\n-      return __f(std::forward<_Args>(__args)...);\n+      return std::__invoke(std::forward<_Callable>(__fn),\n+\t\t\t   std::forward<_Args>(__args)...);\n     }\n+#endif\n \n   /**\n    *  Knowing which of unary_function and binary_function _Tp derives\n@@ -425,7 +454,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttypename result_of<_Tp&(_Args&&...)>::type\n \toperator()(_Args&&... __args) const\n \t{\n-\t  return __invoke(get(), std::forward<_Args>(__args)...);\n+\t  return std::__invoke(get(), std::forward<_Args>(__args)...);\n \t}\n     };\n \n@@ -504,8 +533,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Mem_fn_traits_base\n     {\n       using __result_type = _Res;\n-      using __class_type =  _Class;\n-      using __arg_types = _Pack<_ArgTypes...>;\n       using __maybe_type\n \t= _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;\n       using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;\n@@ -516,18 +543,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF>\t\\\n     : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) _CV _REF;\t\\\n-      using __lvalue = _LVAL;\t\t\t\t\t\t\\\n-      using __rvalue = _RVAL;\t\t\t\t\t\t\\\n       using __vararg = false_type;\t\t\t\t\t\\\n     };\t\t\t\t\t\t\t\t\t\\\n   template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n     struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF>\t\\\n     : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes... ...) _CV _REF;\t\\\n-      using __lvalue = _LVAL;\t\t\t\t\t\t\\\n-      using __rvalue = _RVAL;\t\t\t\t\t\t\\\n       using __vararg = true_type;\t\t\t\t\t\\\n     };\n \n@@ -551,173 +572,51 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     {\n       using _Traits = _Mem_fn_traits<_MemFunPtr>;\n \n-      using _Class = typename _Traits::__class_type;\n-      using _ArgTypes = typename _Traits::__arg_types;\n-      using _Pmf = typename _Traits::__pmf_type;\n-\n       using _Arity = typename _Traits::__arity;\n       using _Varargs = typename _Traits::__vararg;\n \n       template<typename _Func, typename... _BoundArgs>\n \tfriend struct _Bind_check_arity;\n \n-      // for varargs functions we just check the number of arguments,\n-      // otherwise we also check they are convertible.\n-      template<typename _Args>\n-\tusing _CheckArgs = typename conditional<_Varargs::value,\n-\t  __bool_constant<(_Args::value >= _ArgTypes::value)>,\n-\t  _AllConvertible<_Args, _ArgTypes>\n-\t>::type;\n+      _MemFunPtr _M_pmf;\n \n     public:\n-      using result_type = typename _Traits::__result_type;\n-\n-      explicit constexpr _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { }\n-\n-      // Handle objects\n-      template<typename... _Args, typename _Req\n-               = _Require<typename _Traits::__lvalue,\n-                          _CheckArgs<_Pack<_Args...>>>>\n-\tresult_type\n-\toperator()(_Class& __object, _Args&&... __args) const\n-\t{ return (__object.*_M_pmf)(std::forward<_Args>(__args)...); }\n \n-      template<typename... _Args, typename _Req\n-               = _Require<typename _Traits::__rvalue,\n-                          _CheckArgs<_Pack<_Args...>>>>\n-\tresult_type\n-\toperator()(_Class&& __object, _Args&&... __args) const\n-\t{\n-\t  return (std::move(__object).*_M_pmf)(std::forward<_Args>(__args)...);\n-\t}\n-\n-      // Handle pointers\n-      template<typename... _Args, typename _Req\n-               = _Require<typename _Traits::__lvalue,\n-                          _CheckArgs<_Pack<_Args...>>>>\n-\tresult_type\n-\toperator()(_Class* __object, _Args&&... __args) const\n-\t{ return (__object->*_M_pmf)(std::forward<_Args>(__args)...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp, typename... _Args, typename _Req\n-               = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n-                          _CheckArgs<_Pack<_Args...>>>>\n-\tresult_type\n-\toperator()(_Tp&& __object, _Args&&... __args) const\n-\t{\n-\t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_Args>(__args)...);\n-\t}\n-\n-      // Handle reference wrappers\n-      template<typename _Tp, typename... _Args, typename _Req\n-               = _Require<is_base_of<_Class, _Tp>, typename _Traits::__lvalue,\n-                          _CheckArgs<_Pack<_Args...>>>>\n-\tresult_type\n-\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n-\n-    private:\n-      template<typename _Tp, typename... _Args>\n-\tresult_type\n-\t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_Args&&... __args) const\n-\t{\n-\t  return (std::forward<_Tp>(__object).*_M_pmf)\n-\t    (std::forward<_Args>(__args)...);\n-\t}\n+      using result_type = typename _Traits::__result_type;\n \n-      template<typename _Tp, typename... _Args>\n-\tresult_type\n-\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }\n+      explicit constexpr\n+      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }\n \n-      _Pmf _M_pmf;\n+      template<typename... _Args>\n+\tauto\n+\toperator()(_Args&&... __args) const\n+\tnoexcept(noexcept(std::__invoke(_M_pmf, forward<_Args>(__args)...)))\n+\t-> decltype(std::__invoke(_M_pmf, forward<_Args>(__args)...))\n+\t{ return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }\n     };\n \n   // Partial specialization for member object pointers.\n-  template<typename _Res, typename _Class>\n-    class _Mem_fn_base<_Res _Class::*, false>\n+  template<typename _MemObjPtr>\n+    class _Mem_fn_base<_MemObjPtr, false>\n     {\n-      using __pm_type = _Res _Class::*;\n-\n-      // This bit of genius is due to Peter Dimov, improved slightly by\n-      // Douglas Gregor.\n-      // Made less elegant to support perfect forwarding and noexcept.\n-      template<typename _Tp>\n-\tauto\n-\t_M_call(_Tp&& __object, const _Class *) const noexcept\n-\t-> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())\n-\t{ return std::forward<_Tp>(__object).*_M_pm; }\n-\n-      template<typename _Tp, typename _Up>\n-\tauto\n-\t_M_call(_Tp&& __object, _Up * const *) const noexcept\n-\t-> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())\n-\t{ return (*std::forward<_Tp>(__object)).*_M_pm; }\n-\n-      template<typename _Tp>\n-\tauto\n-\t_M_call(_Tp&& __ptr, const volatile void*) const\n-\tnoexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))\n-\t-> decltype((*__ptr).*std::declval<__pm_type&>())\n-\t{ return (*__ptr).*_M_pm; }\n-\n       using _Arity = integral_constant<size_t, 0>;\n       using _Varargs = false_type;\n \n       template<typename _Func, typename... _BoundArgs>\n \tfriend struct _Bind_check_arity;\n \n+      _MemObjPtr _M_pm;\n+\n     public:\n       explicit constexpr\n-      _Mem_fn_base(_Res _Class::*__pm) noexcept : _M_pm(__pm) { }\n-\n-      // Handle objects\n-      _Res&\n-      operator()(_Class& __object) const noexcept\n-      { return __object.*_M_pm; }\n-\n-      const _Res&\n-      operator()(const _Class& __object) const noexcept\n-      { return __object.*_M_pm; }\n-\n-      _Res&&\n-      operator()(_Class&& __object) const noexcept\n-      { return std::forward<_Class>(__object).*_M_pm; }\n-\n-      const _Res&&\n-      operator()(const _Class&& __object) const noexcept\n-      { return std::forward<const _Class>(__object).*_M_pm; }\n+      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }\n \n-      // Handle pointers\n-      _Res&\n-      operator()(_Class* __object) const noexcept\n-      { return __object->*_M_pm; }\n-\n-      const _Res&\n-      operator()(const _Class* __object) const noexcept\n-      { return __object->*_M_pm; }\n-\n-      // Handle smart pointers and derived\n-      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>\n-\tauto\n-\toperator()(_Tp&& __unknown) const\n-\tnoexcept(noexcept(std::declval<_Mem_fn_base*>()->_M_call\n-\t\t\t  (std::forward<_Tp>(__unknown), &__unknown)))\n-\t-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))\n-\t{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }\n-\n-      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>\n+      template<typename _Tp>\n \tauto\n-\toperator()(reference_wrapper<_Tp> __ref) const\n-\tnoexcept(noexcept(std::declval<_Mem_fn_base&>()(__ref.get())))\n-\t-> decltype((*this)(__ref.get()))\n-\t{ return (*this)(__ref.get()); }\n-\n-    private:\n-      _Res _Class::*_M_pm;\n+\toperator()(_Tp&& __obj) const\n+\tnoexcept(noexcept(std::__invoke(_M_pm, forward<_Tp>(__obj))))\n+\t-> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))\n+\t{ return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }\n     };\n \n   template<typename _Res, typename _Class>"}, {"sha": "014658f8db8854d3087230237e3be77c346d265a", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -1641,7 +1641,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     // the shared state, whichever happens first.\n     virtual void _M_complete_async() { _M_join(); }\n \n-    void _M_join() { std::call_once(_M_once, &thread::join, ref(_M_thread)); }\n+    void _M_join() { std::call_once(_M_once, &thread::join, &_M_thread); }\n \n     thread _M_thread;\n     once_flag _M_once;"}, {"sha": "e08131b2c6db47a40da7b052feaa40ac949fa792", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -2219,13 +2219,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #define __cpp_lib_result_of_sfinae 201210\n \n+  struct __invoke_memfun_ref { };\n+  struct __invoke_memfun_deref { };\n+  struct __invoke_memobj_ref { };\n+  struct __invoke_memobj_deref { };\n+  struct __invoke_other { };\n+\n+  // Associate a tag type with a specialization of __success_type.\n+  template<typename _Tp, typename _Tag>\n+    struct __result_of_success : __success_type<_Tp>\n+    { using __invoke_type = _Tag; };\n+\n   // [func.require] paragraph 1 bullet 1:\n   struct __result_of_memfun_ref_impl\n   {\n     template<typename _Fp, typename _Tp1, typename... _Args>\n-      static __success_type<decltype(\n+      static __result_of_success<decltype(\n       (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)\n-      )> _S_test(int);\n+      ), __invoke_memfun_ref> _S_test(int);\n \n     template<typename...>\n       static __failure_type _S_test(...);\n@@ -2242,9 +2253,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct __result_of_memfun_deref_impl\n   {\n     template<typename _Fp, typename _Tp1, typename... _Args>\n-      static __success_type<decltype(\n+      static __result_of_success<decltype(\n       ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)\n-      )> _S_test(int);\n+      ), __invoke_memfun_deref> _S_test(int);\n \n     template<typename...>\n       static __failure_type _S_test(...);\n@@ -2261,9 +2272,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct __result_of_memobj_ref_impl\n   {\n     template<typename _Fp, typename _Tp1>\n-      static __success_type<decltype(\n+      static __result_of_success<decltype(\n       std::declval<_Tp1>().*std::declval<_Fp>()\n-      )> _S_test(int);\n+      ), __invoke_memobj_ref> _S_test(int);\n \n     template<typename, typename>\n       static __failure_type _S_test(...);\n@@ -2280,9 +2291,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct __result_of_memobj_deref_impl\n   {\n     template<typename _Fp, typename _Tp1>\n-      static __success_type<decltype(\n+      static __result_of_success<decltype(\n       (*std::declval<_Tp1>()).*std::declval<_Fp>()\n-      )> _S_test(int);\n+      ), __invoke_memobj_deref> _S_test(int);\n \n     template<typename, typename>\n       static __failure_type _S_test(...);\n@@ -2327,6 +2338,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       >::type::type type;\n     };\n \n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2219.  INVOKE-ing a pointer to member with a reference_wrapper\n+  //        as the object expression\n+  template<typename> struct reference_wrapper;\n+\n+  template<typename _Res, typename _Class, typename _Arg>\n+    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>\n+    : __result_of_memobj<_Res _Class::*, _Arg>\n+    {\n+      typedef typename\n+\t__result_of_memobj_ref<_Res _Class::*, _Arg&>::type type;\n+    };\n+\n+  template<typename _Res, typename _Class, typename _Arg>\n+    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>\n+    : __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>\n+    { };\n+\n+  template<typename _Res, typename _Class, typename _Arg>\n+    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>\n+    : __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>\n+    { };\n+\n+  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n+    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>\n+    : __result_of_memfun<_Res _Class::*, _Arg&, _Args...>\n+    {\n+      typedef typename\n+\t__result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>::type type;\n+    };\n+\n+  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n+    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,\n+\t\t\t      _Args...>\n+    : __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>\n+    { };\n+\n+  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n+    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,\n+\t\t\t      _Args...>\n+    : __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>\n+    { };\n+\n   template<bool, bool, typename _Functor, typename... _ArgTypes>\n     struct __result_of_impl\n     {\n@@ -2347,9 +2401,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct __result_of_other_impl\n   {\n     template<typename _Fn, typename... _Args>\n-      static __success_type<decltype(\n+      static __result_of_success<decltype(\n       std::declval<_Fn>()(std::declval<_Args>()...)\n-      )> _S_test(int);\n+      ), __invoke_other> _S_test(int);\n \n     template<typename...>\n       static __failure_type _S_test(...);"}, {"sha": "a09788a29e026bba31390054d6bf0c9bd22ba4d1", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -30,10 +30,6 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1125 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1139 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1153 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1167 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n \n@@ -50,8 +46,15 @@ void test02()\n   const int dummy = 0;\n   std::bind(Inc(), _1)(dummy);                  // { dg-error  \"no match\" }\n   std::bind(&Inc::f, Inc(), std::ref(dummy))(); // { dg-error  \"no match\" }\n+  // { dg-error \"no match\" \"\" { target *-*-* } 594 }\n+  // { dg-error \"no type\" \"\" { target *-*-* } 237 }\n }\n \n+// { dg-error \"rvalue|const\" \"\" { target *-*-* } 1024 }\n+// { dg-error \"rvalue|const\" \"\" { target *-*-* } 1038 }\n+// { dg-error \"rvalue|const\" \"\" { target *-*-* } 1052 }\n+// { dg-error \"rvalue|const\" \"\" { target *-*-* } 1066 }\n+\n int main()\n {\n   test01();"}, {"sha": "c67731ae2bc61d3ec560c928807f411949157740", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/55463.cc", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e954005f7c39b4cae859f6b2923267f22d6146/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc?ref=93e954005f7c39b4cae859f6b2923267f22d6146", "patch": "@@ -98,15 +98,3 @@ void test01()\n   int& pval __attribute__((unused)) = std::mem_fn( &X::data )( X_ptr() );\n   int& sval __attribute__((unused)) = std::mem_fn( &X::data )( smart_ptr() );\n }\n-\n-void test02()\n-{\n-  std::reference_wrapper<X> r = ref();\n-  X& x1 __attribute__((unused))\n-    = std::mem_fn( &std::reference_wrapper<X>::get )( r );\n-  const std::reference_wrapper<X> cr = ref();\n-  const X& x3 __attribute__((unused))\n-    = std::mem_fn( &std::reference_wrapper<X>::get )( cr );\n-  X& x2 __attribute__((unused))\n-    = std::mem_fn( &std::reference_wrapper<X>::get )( ref() );\n-}"}]}