{"sha": "dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM5ZTBiNjZiMjJmYTczZjM5NjY0NWQ3ZWZkOGI3MzY0OWYyZmU2Yg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-16T13:45:29Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-16T13:45:29Z"}, "message": "re PR fortran/78356 ([OOP] segfault allocating polymorphic variable with polymorphic component with allocatable component)\n\ngcc/fortran/ChangeLog:\n\n2016-11-16  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/78356\n\t* class.c (gfc_is_class_scalar_expr): Prevent taking an array ref for\n\ta component ref.\n\t* trans-expr.c (gfc_trans_assignment_1): Ensure a reference to the\n\tobject to copy is generated, when assigning class objects.\n\ngcc/testsuite/ChangeLog:\n\n2016-11-16  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/78356\n\t* gfortran.dg/class_allocate_23.f08: New test.\n\nFrom-SVN: r242490", "tree": {"sha": "e7b4f5f3869d8e0b144aa416e4efbff8d47e19d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7b4f5f3869d8e0b144aa416e4efbff8d47e19d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/comments", "author": null, "committer": null, "parents": [{"sha": "45a9968b378d54ced8f742e1ff8b01c9378b339c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a9968b378d54ced8f742e1ff8b01c9378b339c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a9968b378d54ced8f742e1ff8b01c9378b339c"}], "stats": {"total": 77, "additions": 67, "deletions": 10}, "files": [{"sha": "4dad588c3d2e84266ceb1d0f3b8416d8260623c4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "patch": "@@ -1,3 +1,11 @@\n+2016-11-16  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/78356\n+\t* class.c (gfc_is_class_scalar_expr): Prevent taking an array ref for\n+\ta component ref.\n+\t* trans-expr.c (gfc_trans_assignment_1): Ensure a reference to the\n+\tobject to copy is generated, when assigning class objects.\n+\n 2016-11-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* dump-parse-tree.c (show_code):  Add prototype."}, {"sha": "9db86b409b5709fa18cadebee45c7848e6f4ad26", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "patch": "@@ -378,7 +378,8 @@ gfc_is_class_scalar_expr (gfc_expr *e)\n \t&& CLASS_DATA (e->symtree->n.sym)\n \t&& !CLASS_DATA (e->symtree->n.sym)->attr.dimension\n \t&& (e->ref == NULL\n-\t    || (strcmp (e->ref->u.c.component->name, \"_data\") == 0\n+\t    || (e->ref->type == REF_COMPONENT\n+\t\t&& strcmp (e->ref->u.c.component->name, \"_data\") == 0\n \t\t&& e->ref->next == NULL)))\n     return true;\n \n@@ -390,7 +391,8 @@ gfc_is_class_scalar_expr (gfc_expr *e)\n \t    && CLASS_DATA (ref->u.c.component)\n \t    && !CLASS_DATA (ref->u.c.component)->attr.dimension\n \t    && (ref->next == NULL\n-\t\t|| (strcmp (ref->next->u.c.component->name, \"_data\") == 0\n+\t\t|| (ref->next->type == REF_COMPONENT\n+\t\t    && strcmp (ref->next->u.c.component->name, \"_data\") == 0\n \t\t    && ref->next->next == NULL)))\n \treturn true;\n     }"}, {"sha": "1331b07a2380f4fa354158d3295ce3d05a3d575a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "patch": "@@ -9628,6 +9628,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   int n;\n   bool maybe_workshare = false;\n   symbol_attribute lhs_caf_attr, rhs_caf_attr, lhs_attr;\n+  bool is_poly_assign;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -9648,6 +9649,19 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  || gfc_is_alloc_class_scalar_function (expr2)))\n     expr2->must_finalize = 1;\n \n+  /* Checking whether a class assignment is desired is quite complicated and\n+     needed at two locations, so do it once only before the information is\n+     needed.  */\n+  lhs_attr = gfc_expr_attr (expr1);\n+  is_poly_assign = (use_vptr_copy || lhs_attr.pointer\n+\t\t    || (lhs_attr.allocatable && !lhs_attr.dimension))\n+\t\t   && (expr1->ts.type == BT_CLASS\n+\t\t       || gfc_is_class_array_ref (expr1, NULL)\n+\t\t       || gfc_is_class_scalar_expr (expr1)\n+\t\t       || gfc_is_class_array_ref (expr2, NULL)\n+\t\t       || gfc_is_class_scalar_expr (expr2));\n+\n+\n   /* Only analyze the expressions for coarray properties, when in coarray-lib\n      mode.  */\n   if (flag_coarray == GFC_FCOARRAY_LIB)\n@@ -9676,6 +9690,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       if (rss == gfc_ss_terminator)\n \t/* The rhs is scalar.  Add a ss for the expression.  */\n \trss = gfc_get_scalar_ss (gfc_ss_terminator, expr2);\n+      /* When doing a class assign, then the handle to the rhs needs to be a\n+\t pointer to allow for polymorphism.  */\n+      if (is_poly_assign && expr2->rank == 0 && !UNLIMITED_POLY (expr2))\n+\trss->info->type = GFC_SS_REFERENCE;\n \n       /* Associate the SS with the loop.  */\n       gfc_add_ss_to_loop (&loop, lss);\n@@ -9835,14 +9853,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \tgfc_add_block_to_block (&loop.post, &rse.post);\n     }\n \n-  lhs_attr = gfc_expr_attr (expr1);\n-  if ((use_vptr_copy || lhs_attr.pointer\n-       || (lhs_attr.allocatable && !lhs_attr.dimension))\n-      && (expr1->ts.type == BT_CLASS\n-\t  || (gfc_is_class_array_ref (expr1, NULL)\n-\t      || gfc_is_class_scalar_expr (expr1))\n-\t  || (gfc_is_class_array_ref (expr2, NULL)\n-\t      || gfc_is_class_scalar_expr (expr2))))\n+  if (is_poly_assign)\n     {\n       tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n \t\t\t\t    use_vptr_copy || (lhs_attr.allocatable"}, {"sha": "4f6d853c468c6ae879537e6785042f38e7ba84c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "patch": "@@ -1,3 +1,8 @@\n+2016-11-16  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/78356\n+\t* gfortran.dg/class_allocate_23.f08: New test.\n+\n 2016-11-16  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/78333"}, {"sha": "5c83fbe96180f5df87f661fbef1b9426dba8daed", "filename": "gcc/testsuite/gfortran.dg/class_allocate_23.f08", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_23.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9e0b66b22fa73f396645d7efd8b73649f2fe6b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_23.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_23.f08?ref=dc9e0b66b22fa73f396645d7efd8b73649f2fe6b", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+!\n+! Test that pr78356 is fixed.\n+! Contributed by Janus Weil and Andrew Benson\n+\n+program p\n+  implicit none\n+  type ac\n+  end type\n+  type, extends(ac) :: a\n+     integer, allocatable :: b\n+  end type\n+  type n\n+     class(ac), allocatable :: acr(:)\n+  end type\n+  type(n) :: s,t\n+  allocate(a :: s%acr(1))\n+  call nncp(s,t)\n+  select type (cl => t%acr(1))\n+    class is (a)\n+      if (allocated(cl%b)) error stop\n+    class default\n+      error stop\n+  end select\n+contains\n+  subroutine nncp(self,tg)\n+    type(n) :: self, tg\n+    allocate(tg%acr(1),source=self%acr(1))\n+  end\n+end\n+"}]}