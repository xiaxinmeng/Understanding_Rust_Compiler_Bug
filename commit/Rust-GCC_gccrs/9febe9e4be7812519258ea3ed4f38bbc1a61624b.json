{"sha": "9febe9e4be7812519258ea3ed4f38bbc1a61624b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlYmU5ZTRiZTc4MTI1MTkyNThlYTNlZDRmMzhiYmMxYTYxNjI0Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-11T09:34:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-11T09:34:07Z"}, "message": "widening_mul: Pattern recognize also signed multiplication with overflow check [PR95852]\n\nOn top of the previous widening_mul patch, this one recognizes also\n(non-perfect) signed multiplication with overflow, like:\nint\nf5 (int x, int y, int *res)\n{\n  *res = (unsigned) x * y;\n  return x && (*res / x) != y;\n}\nThe problem with such checks is that they invoke UB if x is -1 and\ny is INT_MIN during the division, but perhaps the code knows that\nthose values won't appear.  As that case is UB, we can do for that\ncase whatever we want and handling that case as signed overflow\nis the best option.  If x is a constant not equal to -1, then the checks\nare 100% correct though.\nHaven't tried to pattern match bullet-proof checks, because I really don't\nknow if users would write it in real-world code like that,\nperhaps\n  *res = (unsigned) x * y;\n  return x && (x == -1 ? (*res / y) != x : (*res / x) != y);\n?\n\nhttps://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\nsuggests to use twice as wide multiplication (perhaps we should handle that\ntoo, for both signed and unsigned), or some very large code\nwith 4 different divisions nested in many conditionals, no way one can\nmatch all the possible variants thereof.\n\n2021-01-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95852\n\t* tree-ssa-math-opts.c (maybe_optimize_guarding_check): Change\n\tmul_stmts parameter type to vec<gimple *> &.  Before cond_stmt\n\tallow in the bb any of the stmts in that vector, div_stmt and\n\tup to 3 cast stmts.\n\t(arith_cast_equal_p): New function.\n\t(arith_overflow_check_p): Add cast_stmt argument, handle signed\n\tmultiply overflow checks.\n\t(match_arith_overflow): Adjust caller.  Handle signed multiply\n\toverflow checks.\n\n\t* gcc.target/i386/pr95852-3.c: New test.\n\t* gcc.target/i386/pr95852-4.c: New test.", "tree": {"sha": "063f74db6a370df91ec700c58fe8f5f54227aafe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/063f74db6a370df91ec700c58fe8f5f54227aafe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9febe9e4be7812519258ea3ed4f38bbc1a61624b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9febe9e4be7812519258ea3ed4f38bbc1a61624b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9febe9e4be7812519258ea3ed4f38bbc1a61624b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9febe9e4be7812519258ea3ed4f38bbc1a61624b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2106317cd6673e110b347c70f21e25fbb23379e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2106317cd6673e110b347c70f21e25fbb23379e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2106317cd6673e110b347c70f21e25fbb23379e"}], "stats": {"total": 736, "additions": 692, "deletions": 44}, "files": [{"sha": "19e39117d077f3e49a25c1d859f8ed68c416f4d6", "filename": "gcc/testsuite/gcc.target/i386/pr95852-3.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-3.c?ref=9febe9e4be7812519258ea3ed4f38bbc1a61624b", "patch": "@@ -0,0 +1,266 @@\n+/* PR tree-optimization/95852 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -masm=att\" } */\n+/* { dg-final { scan-tree-dump-times \" = \\.MUL_OVERFLOW \" 32 \"optimized\" } } */\n+/* { dg-final { scan-assembler-times \"\\timull\\t\" 32 } } */\n+/* { dg-final { scan-assembler-times \"\\tseto\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tsetno\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tjn\\?o\\t\" 16 } } */\n+\n+unsigned fn (void);\n+\n+int\n+f1 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return x && ((int) *res / (int) x) != (int) y;\n+}\n+\n+unsigned\n+f2 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (x && ((int) r / (int) x) != (int) y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f3 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return !x || ((int) *res / (int) x) == (int) y;\n+}\n+\n+unsigned\n+f4 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!x || ((int) r / (int) x) == (int) y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f5 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return x && (*res / x) != y;\n+}\n+\n+int\n+f6 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (x && (r / x) != y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f7 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return !x || (*res / x) == y;\n+}\n+\n+int\n+f8 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!x || (r / x) == y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f9 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return y && ((int) *res / (int) y) != (int) x;\n+}\n+\n+unsigned\n+f10 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (y && ((int) r / (int) y) != (int) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f11 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return !y || ((int) *res / (int) y) == (int) x;\n+}\n+\n+unsigned\n+f12 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!y || ((int) r / (int) y) == (int) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f13 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return y && (*res / y) != x;\n+}\n+\n+int\n+f14 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (y && (r / y) != x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f15 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return !y || (*res / y) == x;\n+}\n+\n+int\n+f16 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!y || (r / y) == x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f17 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return x && ((int) *res / (int) x) != 35;\n+}\n+\n+unsigned\n+f18 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (x && ((int) r / (int) x) != 35)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f19 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return !x || ((int) *res / (int) x) == 35;\n+}\n+\n+unsigned\n+f20 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (!x || ((int) r / (int) x) == 35)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f21 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return x && (*res / x) != 35;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (x && (r / x) != 35)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f23 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return !x || (*res / x) == 35;\n+}\n+\n+int\n+f24 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (!x || (r / x) == 35)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f25 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return ((int) *res / 35) != (int) x;\n+}\n+\n+unsigned\n+f26 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (((int) r / 35) != (int) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f27 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return ((int) *res / 35) == (int) x;\n+}\n+\n+unsigned\n+f28 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (((int) r / 35) == (int) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f29 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return 35 && (*res / 35) != x;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if ((r / 35) != x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f31 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return (*res / 35) == x;\n+}\n+\n+int\n+f32 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if ((r / 35) == x)\n+    return fn ();\n+  return r;\n+}"}, {"sha": "f8b46564baa39c7a081b971e03c0c1b99d16a822", "filename": "gcc/testsuite/gcc.target/i386/pr95852-4.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-4.c?ref=9febe9e4be7812519258ea3ed4f38bbc1a61624b", "patch": "@@ -0,0 +1,266 @@\n+/* PR tree-optimization/95852 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -masm=att\" } */\n+/* { dg-final { scan-tree-dump-times \" = \\.MUL_OVERFLOW \" 32 \"optimized\" } } */\n+/* { dg-final { scan-assembler-times \"\\timull\\t\" 32 } } */\n+/* { dg-final { scan-assembler-times \"\\tseto\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tsetno\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tjn\\?o\\t\" 16 } } */\n+\n+unsigned fn (void);\n+\n+int\n+f1 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  return x && ((int) r / (int) x) != (int) y;\n+}\n+\n+unsigned\n+f2 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (x && ((int) r / (int) x) != (int) y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f3 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  return !x || ((int) r / (int) x) == (int) y;\n+}\n+\n+unsigned\n+f4 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!x || ((int) r / (int) x) == (int) y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f5 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return x && (r / x) != y;\n+}\n+\n+int\n+f6 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (x && (r / x) != y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f7 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return !x || (r / x) == y;\n+}\n+\n+int\n+f8 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!x || (r / x) == y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f9 (unsigned x, unsigned y)\n+{\n+  unsigned r = x * y;\n+  return y && ((int) r / (int) y) != (int) x;\n+}\n+\n+unsigned\n+f10 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (y && ((int) r / (int) y) != (int) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f11 (unsigned x, unsigned y)\n+{\n+  unsigned r = x * y;\n+  return !y || ((int) r / (int) y) == (int) x;\n+}\n+\n+unsigned\n+f12 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!y || ((int) r / (int) y) == (int) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f13 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return y && (r / y) != x;\n+}\n+\n+int\n+f14 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (y && (r / y) != x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f15 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return !y || (r / y) == x;\n+}\n+\n+int\n+f16 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!y || (r / y) == x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f17 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return x && ((int) r / (int) x) != 35;\n+}\n+\n+unsigned\n+f18 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (x && ((int) r / (int) x) != 35)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f19 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return !x || ((int) r / (int) x) == 35;\n+}\n+\n+unsigned\n+f20 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (!x || ((int) r / (int) x) == 35)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f21 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return x && (r / x) != 35;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (x && (r / x) != 35)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f23 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return !x || (r / x) == 35;\n+}\n+\n+int\n+f24 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (!x || (r / x) == 35)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f25 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return ((int) r / 35) != (int) x;\n+}\n+\n+unsigned\n+f26 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (((int) r / 35) != (int) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f27 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return !35 || ((int) r / 35) == (int) x;\n+}\n+\n+unsigned\n+f28 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (((int) r / 35) == (int) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f29 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return 35 && (r / 35) != x;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if ((r / 35) != x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f31 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return (r / 35) == x;\n+}\n+\n+int\n+f32 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if ((r / 35) == x)\n+    return fn ();\n+  return 0;\n+}"}, {"sha": "91ec0f6fe8328acb2ce7fb151841348f0b13f7f6", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 160, "deletions": 44, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9febe9e4be7812519258ea3ed4f38bbc1a61624b/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=9febe9e4be7812519258ea3ed4f38bbc1a61624b", "patch": "@@ -3471,7 +3471,7 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n    optimize the x_4(D) != 0 condition to 1.  */\n \n static void\n-maybe_optimize_guarding_check (gimple **mul_stmts, gimple *cond_stmt,\n+maybe_optimize_guarding_check (vec<gimple *> &mul_stmts, gimple *cond_stmt,\n \t\t\t       gimple *div_stmt, bool *cfg_changed)\n {\n   basic_block bb = gimple_bb (cond_stmt);\n@@ -3525,37 +3525,34 @@ maybe_optimize_guarding_check (gimple **mul_stmts, gimple *cond_stmt,\n \t      != TYPE_PRECISION (TREE_TYPE (rhs2))))\n \treturn;\n     }\n-  gimple_stmt_iterator gsi = gsi_for_stmt (div_stmt);\n-  gsi_prev_nondebug (&gsi);\n-  if (!gsi_end_p (gsi))\n+  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+  mul_stmts.quick_push (div_stmt);\n+  if (is_gimple_debug (gsi_stmt (gsi)))\n+    gsi_next_nondebug (&gsi);\n+  unsigned cast_count = 0;\n+  while (gsi_stmt (gsi) != cond_stmt)\n     {\n       /* If original mul_stmt has a single use, allow it in the same bb,\n \t we are looking then just at __builtin_mul_overflow_p.\n \t Though, in that case the original mul_stmt will be replaced\n \t by .MUL_OVERFLOW, REALPART_EXPR and IMAGPART_EXPR stmts.  */\n-      for (int i = 2; i >= 0; --i)\n-\t{\n-\t  if (gsi_stmt (gsi) != mul_stmts[i])\n-\t    return;\n-\t  gsi_prev_nondebug (&gsi);\n-\t}\n-      /* Allow up to 2 extra casts.  Given the way we check PHIs,\n-\t nothing from this bb should be consumed by any other bb\n-\t anyway.  */\n-      for (int i = 0; i < 2 && !gsi_end_p (gsi); i++)\n+      gimple *mul_stmt;\n+      unsigned int i;\n+      bool ok = false;\n+      FOR_EACH_VEC_ELT (mul_stmts, i, mul_stmt)\n \t{\n-\t  gimple *g = gsi_stmt (gsi);\n-\t  if (!gimple_assign_cast_p (g))\n-\t    return;\n-\t  gsi_prev_nondebug (&gsi);\n+\t  if (gsi_stmt (gsi) == mul_stmt)\n+\t    {\n+\t      ok = true;\n+\t      break;\n+\t    }\n \t}\n-      if (!gsi_end_p (gsi))\n+      if (!ok && gimple_assign_cast_p (gsi_stmt (gsi)) && ++cast_count < 4)\n+\tok = true;\n+      if (!ok)\n \treturn;\n+      gsi_next_nondebug (&gsi);\n     }\n-  gsi = gsi_for_stmt (div_stmt);\n-  gsi_next_nondebug (&gsi);\n-  if (gsi_stmt (gsi) != cond_stmt)\n-    return;\n   if (gimple_code (cond_stmt) == GIMPLE_COND)\n     {\n       basic_block succ_bb = other_edge->dest;\n@@ -3633,19 +3630,39 @@ maybe_optimize_guarding_check (gimple **mul_stmts, gimple *cond_stmt,\n   *cfg_changed = true;\n }\n \n+/* Helper function for arith_overflow_check_p.  Return true\n+   if VAL1 is equal to VAL2 cast to corresponding integral type\n+   with other signedness or vice versa.  */\n+\n+static bool\n+arith_cast_equal_p (tree val1, tree val2)\n+{\n+  if (TREE_CODE (val1) == INTEGER_CST && TREE_CODE (val2) == INTEGER_CST)\n+    return wi::eq_p (wi::to_wide (val1), wi::to_wide (val2));\n+  else if (TREE_CODE (val1) != SSA_NAME || TREE_CODE (val2) != SSA_NAME)\n+    return false;\n+  if (gimple_assign_cast_p (SSA_NAME_DEF_STMT (val1))\n+      && gimple_assign_rhs1 (SSA_NAME_DEF_STMT (val1)) == val2)\n+    return true;\n+  if (gimple_assign_cast_p (SSA_NAME_DEF_STMT (val2))\n+      && gimple_assign_rhs1 (SSA_NAME_DEF_STMT (val2)) == val1)\n+    return true;\n+  return false;\n+}\n+\n /* Helper function of match_arith_overflow.  Return 1\n    if USE_STMT is unsigned overflow check ovf != 0 for\n    STMT, -1 if USE_STMT is unsigned overflow check ovf == 0\n    and 0 otherwise.  */\n \n static int\n-arith_overflow_check_p (gimple *stmt, gimple *&use_stmt, tree maxval,\n-\t\t\ttree *other)\n+arith_overflow_check_p (gimple *stmt, gimple *cast_stmt, gimple *&use_stmt,\n+\t\t\ttree maxval, tree *other)\n {\n   enum tree_code ccode = ERROR_MARK;\n   tree crhs1 = NULL_TREE, crhs2 = NULL_TREE;\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs = gimple_assign_lhs (cast_stmt ? cast_stmt : stmt);\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n   tree multop = NULL_TREE, divlhs = NULL_TREE;\n@@ -3658,7 +3675,16 @@ arith_overflow_check_p (gimple *stmt, gimple *&use_stmt, tree maxval,\n \treturn 0;\n       if (gimple_assign_rhs1 (use_stmt) != lhs)\n \treturn 0;\n-      if (gimple_assign_rhs2 (use_stmt) == rhs1)\n+      if (cast_stmt)\n+\t{\n+\t  if (arith_cast_equal_p (gimple_assign_rhs2 (use_stmt), rhs1))\n+\t    multop = rhs2;\n+\t  else if (arith_cast_equal_p (gimple_assign_rhs2 (use_stmt), rhs2))\n+\t    multop = rhs1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (gimple_assign_rhs2 (use_stmt) == rhs1)\n \tmultop = rhs2;\n       else if (operand_equal_p (gimple_assign_rhs2 (use_stmt), rhs2, 0))\n \tmultop = rhs1;\n@@ -3759,10 +3785,18 @@ arith_overflow_check_p (gimple *stmt, gimple *&use_stmt, tree maxval,\n \t r = a * b; _1 = r / b; _1 == a\n \t r = a * b; _1 = r / a; _1 != b\n \t r = a * b; _1 = r / b; _1 != a.  */\n-      if (code == MULT_EXPR\n-\t  && ((crhs1 == divlhs && operand_equal_p (crhs2, multop, 0))\n-\t      || (crhs2 == divlhs && crhs1 == multop)))\n-\treturn ccode == NE_EXPR ? 1 : -1;\n+      if (code == MULT_EXPR)\n+\t{\n+\t  if (cast_stmt)\n+\t    {\n+\t      if ((crhs1 == divlhs && arith_cast_equal_p (crhs2, multop))\n+\t\t  || (crhs2 == divlhs && arith_cast_equal_p (crhs1, multop)))\n+\t\treturn ccode == NE_EXPR ? 1 : -1;\n+\t    }\n+\t  else if ((crhs1 == divlhs && operand_equal_p (crhs2, multop, 0))\n+\t\t   || (crhs2 == divlhs && crhs1 == multop))\n+\t    return ccode == NE_EXPR ? 1 : -1;\n+\t}\n       break;\n     default:\n       break;\n@@ -3837,6 +3871,8 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   gimple *add_stmt = NULL;\n   bool add_first = false;\n   gimple *cond_stmt = NULL;\n+  gimple *cast_stmt = NULL;\n+  tree cast_lhs = NULL_TREE;\n \n   gcc_checking_assert (code == PLUS_EXPR\n \t\t       || code == MINUS_EXPR\n@@ -3860,7 +3896,7 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \tcontinue;\n \n       tree other = NULL_TREE;\n-      if (arith_overflow_check_p (stmt, use_stmt, NULL_TREE, &other))\n+      if (arith_overflow_check_p (stmt, NULL, use_stmt, NULL_TREE, &other))\n \t{\n \t  if (code == BIT_NOT_EXPR)\n \t    {\n@@ -3875,20 +3911,59 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t    }\n \t  ovf_use_seen = true;\n \t}\n-      else\n-\tuse_seen = true;\n+      else \n+\t{\n+\t  use_seen = true;\n+\t  if (code == MULT_EXPR\n+\t      && cast_stmt == NULL\n+\t      && gimple_assign_cast_p (use_stmt))\n+\t    {\n+\t      cast_lhs = gimple_assign_lhs (use_stmt);\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (cast_lhs))\n+\t\t  && !TYPE_UNSIGNED (TREE_TYPE (cast_lhs))\n+\t\t  && (TYPE_PRECISION (TREE_TYPE (cast_lhs))\n+\t\t      == TYPE_PRECISION (TREE_TYPE (lhs))))\n+\t\tcast_stmt = use_stmt;\n+\t      else\n+\t\tcast_lhs = NULL_TREE;\n+\t    }\n+\t}\n       if (ovf_use_seen && use_seen)\n \tbreak;\n     }\n \n+  if (!ovf_use_seen\n+      && code == MULT_EXPR\n+      && cast_stmt)\n+    {\n+      if (TREE_CODE (rhs1) != SSA_NAME\n+\t  || (TREE_CODE (rhs2) != SSA_NAME && TREE_CODE (rhs2) != INTEGER_CST))\n+\treturn false;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, cast_lhs)\n+\t{\n+\t  use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\n+\t  if (arith_overflow_check_p (stmt, cast_stmt, use_stmt,\n+\t\t\t\t      NULL_TREE, NULL))\n+\t    ovf_use_seen = true;\n+\t}\n+    }\n+  else\n+    {\n+      cast_stmt = NULL;\n+      cast_lhs = NULL_TREE;\n+    }\n+\n   tree maxval = NULL_TREE;\n   if (!ovf_use_seen\n       || (code != MULT_EXPR && (code == BIT_NOT_EXPR ? use_seen : !use_seen))\n       || (code == PLUS_EXPR\n \t  && optab_handler (uaddv4_optab,\n \t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing)\n       || (code == MULT_EXPR\n-\t  && optab_handler (umulv4_optab,\n+\t  && optab_handler (cast_stmt ? mulv4_optab : umulv4_optab,\n \t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing))\n     {\n       if (code != PLUS_EXPR)\n@@ -3947,7 +4022,7 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t  if (is_gimple_debug (use_stmt))\n \t    continue;\n \n-\t  if (arith_overflow_check_p (stmt, use_stmt, maxval, NULL))\n+\t  if (arith_overflow_check_p (stmt, NULL, use_stmt, maxval, NULL))\n \t    {\n \t      ovf_use_seen = true;\n \t      use_bb = gimple_bb (use_stmt);\n@@ -4066,6 +4141,41 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   if (code == BIT_NOT_EXPR)\n     *gsi = gsi_for_stmt (cond_stmt);\n \n+  auto_vec<gimple *, 8> mul_stmts;\n+  if (code == MULT_EXPR && cast_stmt)\n+    {\n+      type = TREE_TYPE (cast_lhs);\n+      gimple *g = SSA_NAME_DEF_STMT (rhs1);\n+      if (gimple_assign_cast_p (g)\n+\t  && useless_type_conversion_p (type,\n+\t\t\t\t\tTREE_TYPE (gimple_assign_rhs1 (g)))\n+\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (g)))\n+\trhs1 = gimple_assign_rhs1 (g);\n+      else\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (type), NOP_EXPR, rhs1);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  rhs1 = gimple_assign_lhs (g);\n+\t  mul_stmts.quick_push (g);\n+\t}\n+      if (TREE_CODE (rhs2) == INTEGER_CST)\n+\trhs2 = fold_convert (type, rhs2);\n+      else\n+\t{\n+\t  if (gimple_assign_cast_p (g)\n+\t      && useless_type_conversion_p (type,\n+\t\t\t\t\t    TREE_TYPE (gimple_assign_rhs1 (g)))\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (g)))\n+\t    rhs2 = gimple_assign_rhs1 (g);\n+\t  else\n+\t    {\n+\t      g = gimple_build_assign (make_ssa_name (type), NOP_EXPR, rhs2);\n+\t      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t      rhs2 = gimple_assign_lhs (g);\n+\t      mul_stmts.quick_push (g);\n+\t    }\n+\t}\n+    }\n   tree ctype = build_complex_type (type);\n   gcall *g = gimple_build_call_internal (code == MULT_EXPR\n \t\t\t\t\t ? IFN_MUL_OVERFLOW\n@@ -4075,14 +4185,13 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   tree ctmp = make_ssa_name (ctype);\n   gimple_call_set_lhs (g, ctmp);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n-  tree new_lhs = maxval ? make_ssa_name (type) : lhs;\n-  gimple *mul_stmts[3] = { NULL, NULL, NULL };\n+  tree new_lhs = (maxval || cast_stmt) ? make_ssa_name (type) : lhs;\n   gassign *g2;\n   if (code != BIT_NOT_EXPR)\n     {\n       g2 = gimple_build_assign (new_lhs, REALPART_EXPR,\n \t\t\t\tbuild1 (REALPART_EXPR, type, ctmp));\n-      if (maxval)\n+      if (maxval || cast_stmt)\n \t{\n \t  gsi_insert_before (gsi, g2, GSI_SAME_STMT);\n \t  if (add_first)\n@@ -4092,8 +4201,14 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \tgsi_replace (gsi, g2, true);\n       if (code == MULT_EXPR)\n \t{\n-\t  mul_stmts[0] = g;\n-\t  mul_stmts[1] = g2;\n+\t  mul_stmts.quick_push (g);\n+\t  mul_stmts.quick_push (g2);\n+\t  if (cast_stmt)\n+\t    {\n+\t      g2 = gimple_build_assign (lhs, NOP_EXPR, new_lhs);\n+\t      gsi_replace (gsi, g2, true);\n+\t      mul_stmts.quick_push (g2);\n+\t    }\n \t}\n     }\n   tree ovf = make_ssa_name (type);\n@@ -4104,15 +4219,16 @@ match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   else\n     gsi_insert_before (gsi, g2, GSI_SAME_STMT);\n   if (code == MULT_EXPR)\n-    mul_stmts[2] = g2;\n+    mul_stmts.quick_push (g2);\n \n-  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+  FOR_EACH_IMM_USE_STMT (use_stmt, iter, cast_lhs ? cast_lhs : lhs)\n     {\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n       gimple *orig_use_stmt = use_stmt;\n-      int ovf_use = arith_overflow_check_p (stmt, use_stmt, maxval, NULL);\n+      int ovf_use = arith_overflow_check_p (stmt, cast_stmt, use_stmt,\n+\t\t\t\t\t    maxval, NULL);\n       if (ovf_use == 0)\n \t{\n \t  gcc_assert (code != BIT_NOT_EXPR);"}]}