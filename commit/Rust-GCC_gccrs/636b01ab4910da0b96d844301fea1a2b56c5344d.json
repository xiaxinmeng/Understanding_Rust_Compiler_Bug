{"sha": "636b01ab4910da0b96d844301fea1a2b56c5344d", "node_id": "C_kwDOANBUbNoAKDYzNmIwMWFiNDkxMGRhMGI5NmQ4NDQzMDFmZWExYTJiNTZjNTM0NGQ", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-15T17:44:36Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-15T18:11:04Z"}, "message": "d: Add `@visibility' and `@hidden' attributes.\n\nThe `@visibility' attribute is functionality the same as\n`__attribute__((visibility))', and `@hidden' is a convenience alias to\n`@visibility(\"hidden\")' defined in the `gcc.attributes' module.\n\nAs the visibility of a symbol is also indirectly controlled by the\n`export' keyword, the handling of this in the code generation pass has\nbeen improved so that conflicts will be appropriately diagnosed.\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc (d_langhook_attribute_table): Add visibility.\n\t(insert_type_attribute): Use decl_attributes instead of\n\tmerge_attributes.\n\t(insert_decl_attribute): Likewise.\n\t(apply_user_attributes): Do nothing when no UDAs applied.\n\t(d_handle_visibility_attribute): New function.\n\t* d-gimplify.cc (d_gimplify_binary_expr): Adjust.\n\t* d-tree.h (set_visibility_for_decl): Declare.\n\t* decl.cc (get_symbol_decl): Move setting of visibility flags to...\n\t(set_visibility_for_decl): ... here.  New function.\n\t* types.cc (TypeVisitor::visit (TypeStruct *)): Call\n\tset_visibility_for_decl().\n\t(TypeVisitor::visit (TypeClass *)): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/attr_visibility1.d: New test.\n\t* gdc.dg/attr_visibility2.d: New test.\n\t* gdc.dg/attr_visibility3.d: New test.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/gcc/attributes.d (visibility): Define.\n\t(hidden): Define.", "tree": {"sha": "480d97c9a670995fe519be3a7f8b86c5e97e50cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/480d97c9a670995fe519be3a7f8b86c5e97e50cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636b01ab4910da0b96d844301fea1a2b56c5344d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b01ab4910da0b96d844301fea1a2b56c5344d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b01ab4910da0b96d844301fea1a2b56c5344d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b01ab4910da0b96d844301fea1a2b56c5344d/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d14a841fd9a798fe6d68ae49c6fbb753d21032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d14a841fd9a798fe6d68ae49c6fbb753d21032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d14a841fd9a798fe6d68ae49c6fbb753d21032"}], "stats": {"total": 273, "additions": 241, "deletions": 32}, "files": [{"sha": "4c6e7a7a4bd9af403c6e040e423ba359e24a0602", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -77,6 +77,7 @@ static tree d_handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_cold_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_restrict_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_used_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_visibility_attribute (tree *, tree, tree, int, bool *);\n \n /* Helper to define attribute exclusions.  */\n #define ATTR_EXCL(name, function, type, variable)\t\\\n@@ -223,6 +224,8 @@ const attribute_spec d_langhook_attribute_table[] =\n \t     d_handle_restrict_attribute, NULL),\n   ATTR_SPEC (\"used\", 0, 0, true, false, false, false,\n \t     d_handle_used_attribute, NULL),\n+  ATTR_SPEC (\"visibility\", 1, 1, false, false, false, false,\n+\t     d_handle_visibility_attribute, NULL),\n   ATTR_SPEC (NULL, 0, 0, false, false, false, false, NULL, NULL),\n };\n \n@@ -238,10 +241,9 @@ insert_type_attribute (tree type, const char *attrname, tree value)\n   if (value)\n     value = tree_cons (NULL_TREE, value, NULL_TREE);\n \n-  tree attribs = merge_attributes (TYPE_ATTRIBUTES (type),\n-\t\t\t\t   tree_cons (ident, value, NULL_TREE));\n-\n-  return build_type_attribute_variant (type, attribs);\n+  decl_attributes (&type, build_tree_list (ident, value),\n+\t\t   ATTR_FLAG_TYPE_IN_PLACE);\n+  return type;\n }\n \n /* Insert the decl attribute ATTRNAME with value VALUE into DECL.  */\n@@ -254,10 +256,9 @@ insert_decl_attribute (tree decl, const char *attrname, tree value)\n   if (value)\n     value = tree_cons (NULL_TREE, value, NULL_TREE);\n \n-  tree attribs = merge_attributes (DECL_ATTRIBUTES (decl),\n-\t\t\t\t   tree_cons (ident, value, NULL_TREE));\n+  decl_attributes (&decl, build_tree_list (ident, value), 0);\n \n-  return build_decl_attribute_variant (decl, attribs);\n+  return decl;\n }\n \n /* Returns TRUE if NAME is an attribute recognized as being handled by\n@@ -414,12 +415,7 @@ void\n apply_user_attributes (Dsymbol *sym, tree node)\n {\n   if (!sym->userAttribDecl)\n-    {\n-      if (DECL_P (node) && DECL_ATTRIBUTES (node) != NULL)\n-\tdecl_attributes (&node, DECL_ATTRIBUTES (node), 0);\n-\n-      return;\n-    }\n+    return;\n \n   location_t saved_location = input_location;\n   input_location = make_location_t (sym->loc);\n@@ -1412,3 +1408,79 @@ d_handle_used_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n \n   return NULL_TREE;\n }\n+\n+/* Handle an \"visibility\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_visibility_attribute (tree *node, tree name, tree args,\n+\t\t\t       int, bool *)\n+{\n+  /*  If this is a type, set the visibility on the type decl.  */\n+  tree decl = *node;\n+  if (TYPE_P (decl))\n+    {\n+      decl = TYPE_NAME (decl);\n+      if (decl == NULL_TREE || TREE_CODE (decl) != TYPE_DECL)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qE attribute ignored on types\", name);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  if (decl_function_context (decl) != 0 || !TREE_PUBLIC (decl))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      return NULL_TREE;\n+    }\n+\n+  tree id = TREE_VALUE (args);\n+  if (TREE_CODE (id) != STRING_CST)\n+    {\n+      error (\"visibility argument not a string\");\n+      return NULL_TREE;\n+    }\n+\n+  enum symbol_visibility vis;\n+  if (strcmp (TREE_STRING_POINTER (id), \"default\") == 0)\n+    vis = VISIBILITY_DEFAULT;\n+  else if (strcmp (TREE_STRING_POINTER (id), \"internal\") == 0)\n+    vis = VISIBILITY_INTERNAL;\n+  else if (strcmp (TREE_STRING_POINTER (id), \"hidden\") == 0)\n+    vis = VISIBILITY_HIDDEN;\n+  else if (strcmp (TREE_STRING_POINTER (id), \"protected\") == 0)\n+    vis = VISIBILITY_PROTECTED;\n+  else\n+    {\n+      error (\"attribute %qE argument must be one of %qs, %qs, %qs, or %qs\",\n+\t     name, \"default\", \"hidden\", \"protected\", \"internal\");\n+      vis = VISIBILITY_DEFAULT;\n+    }\n+\n+  if (DECL_VISIBILITY_SPECIFIED (decl) && vis != DECL_VISIBILITY (decl))\n+    {\n+      tree attributes = (TYPE_P (*node)\n+\t\t\t ? TYPE_ATTRIBUTES (*node)\n+\t\t\t : DECL_ATTRIBUTES (decl));\n+      if (lookup_attribute (\"visibility\", attributes))\n+\terror (\"%qD redeclared with different visibility\", decl);\n+      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t       && lookup_attribute (\"dllimport\", attributes))\n+\terror (\"%qD was declared %qs which implies default visibility\",\n+\t       decl, \"export\");\n+      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t       && lookup_attribute (\"dllexport\", attributes))\n+\terror (\"%qD was declared %qs which implies default visibility\",\n+\t       decl, \"export\");\n+    }\n+\n+  DECL_VISIBILITY (decl) = vis;\n+  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+\n+  /* Go ahead and attach the attribute to the node as well.  This is needed\n+     so we can determine whether we have VISIBILITY_DEFAULT because the\n+     visibility was not specified, or because it was explicitly overridden\n+     from the containing scope.  */\n+\n+  return NULL_TREE;\n+}"}, {"sha": "33fe65c346610fb74353861b3494f8afebb75b12", "filename": "gcc/d/d-gimplify.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-gimplify.cc?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -235,10 +235,10 @@ d_gimplify_binary_expr (tree *expr_p)\n   if (bit_field_ref (op0) || bit_field_ref (op1))\n     {\n       if (TREE_TYPE (op0) != TREE_TYPE (*expr_p))\n-    \tTREE_OPERAND (*expr_p, 0) = convert (TREE_TYPE (*expr_p), op0);\n+\tTREE_OPERAND (*expr_p, 0) = convert (TREE_TYPE (*expr_p), op0);\n \n       if (TREE_TYPE (op1) != TREE_TYPE (*expr_p))\n-    \tTREE_OPERAND (*expr_p, 1) = convert (TREE_TYPE (*expr_p), op1);\n+\tTREE_OPERAND (*expr_p, 1) = convert (TREE_TYPE (*expr_p), op1);\n \n       return GS_OK;\n     }"}, {"sha": "751746395e6cfc1fa13914d85a107fa651b8dc1f", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -654,6 +654,7 @@ extern tree build_artificial_decl (tree, tree, const char * = NULL);\n extern tree create_field_decl (tree, const char *, int, int);\n extern void build_type_decl (tree, Dsymbol *);\n extern void set_linkage_for_decl (tree);\n+extern void set_visibility_for_decl (tree, Dsymbol *);\n \n /* In expr.cc.  */\n extern tree build_expr (Expression *, bool = false, bool = false);"}, {"sha": "8676a1b588bea90e1fd2ff202977f015209b2d06", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -1343,27 +1343,10 @@ get_symbol_decl (Declaration *decl)\n   if (decl->storage_class & STCvolatile)\n     TREE_THIS_VOLATILE (decl->csym) = 1;\n \n-  /* Visibility attributes are used by the debugger.  */\n-  if (decl->visibility.kind == Visibility::private_)\n-    TREE_PRIVATE (decl->csym) = 1;\n-  else if (decl->visibility.kind == Visibility::protected_)\n-    TREE_PROTECTED (decl->csym) = 1;\n-\n   /* Likewise, so could the deprecated attribute.  */\n   if (decl->storage_class & STCdeprecated)\n     TREE_DEPRECATED (decl->csym) = 1;\n \n-#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-  /* Have to test for import first.  */\n-  if (decl->isImportedSymbol ())\n-    {\n-      insert_decl_attribute (decl->csym, \"dllimport\");\n-      DECL_DLLIMPORT_P (decl->csym) = 1;\n-    }\n-  else if (decl->isExport ())\n-    insert_decl_attribute (decl->csym, \"dllexport\");\n-#endif\n-\n   if (decl->isDataseg () || decl->isCodeseg () || decl->isThreadlocal ())\n     {\n       /* Set TREE_PUBLIC by default, but allow private template to override.  */\n@@ -1374,6 +1357,9 @@ get_symbol_decl (Declaration *decl)\n       /* The decl has not been defined -- yet.  */\n       DECL_EXTERNAL (decl->csym) = 1;\n \n+      /* Visibility attributes are used by the debugger.  */\n+      set_visibility_for_decl (decl->csym, decl);\n+\n       DECL_INSTANTIATED (decl->csym) = (decl->isInstantiated () != NULL);\n       set_linkage_for_decl (decl->csym);\n     }\n@@ -2447,3 +2433,37 @@ set_linkage_for_decl (tree decl)\n   if (DECL_ARTIFICIAL (decl))\n     return d_weak_linkage (decl);\n }\n+\n+/* NODE is a FUNCTION_DECL, VAR_DECL or RECORD_TYPE for the declaration SYM.\n+   Set flags to reflect visibility that NODE will get in the object file.  */\n+\n+void\n+set_visibility_for_decl (tree node, Dsymbol *sym)\n+{\n+  Visibility visibility = sym->visible ();\n+  if (visibility.kind == Visibility::private_)\n+    TREE_PRIVATE (node) = 1;\n+  else if (visibility.kind == Visibility::protected_)\n+    TREE_PROTECTED (node) = 1;\n+\n+  /* If the declaration was declared `export', append either the dllimport\n+     or dllexport attribute.  */\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n+    {\n+      const char *attrname = NULL;\n+\n+      /* Have to test for import first.  */\n+      if (sym->isImportedSymbol ())\n+\tattrname = \"dllimport\";\n+      else if (sym->isExport ())\n+\tattrname = \"dllexport\";\n+\n+      if (attrname != NULL)\n+\t{\n+\t  if (DECL_P (node))\n+\t    insert_decl_attribute (node, attrname);\n+\t  else if (TYPE_P (node))\n+\t    insert_type_attribute (node, attrname);\n+\t}\n+    }\n+}"}, {"sha": "b706c91560e380d484b33d991e182334b6a6fbaa", "filename": "gcc/d/types.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -1180,6 +1180,7 @@ class TypeVisitor : public Visitor\n \t/* Put out all fields.  */\n \tlayout_aggregate_type (t->sym, t->ctype, t->sym);\n \tbuild_type_decl (t->ctype, t->sym);\n+\tset_visibility_for_decl (t->ctype, t->sym);\n \tapply_user_attributes (t->sym, t->ctype);\n \tfinish_aggregate_type (structsize, alignsize, t->ctype);\n       }\n@@ -1224,6 +1225,7 @@ class TypeVisitor : public Visitor\n     /* Put out all fields, including from each base class.  */\n     layout_aggregate_type (t->sym, basetype, t->sym);\n     build_type_decl (basetype, t->sym);\n+    set_visibility_for_decl (basetype, t->sym);\n     apply_user_attributes (t->sym, basetype);\n     finish_aggregate_type (t->sym->structsize, t->sym->alignsize, basetype);\n "}, {"sha": "a7ed4065605ea5b1031bcd4849bded7095cfa532", "filename": "gcc/testsuite/gdc.dg/attr_visibility1.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility1.d?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+// { dg-require-visibility \"\" }\n+\n+import gcc.attributes;\n+\n+void nested()\n+{\n+    @attribute(\"visibility\", \"default\")\n+    struct nested_struct { } // { dg-warning \".visibility. attribute ignored\" }\n+\n+    @attribute(\"visibility\", \"default\")\n+    void nested_func() { } // { dg-warning \".visibility. attribute ignored\" }\n+}\n+\n+@attribute(\"visibility\", 123)\n+int not_a_string(); // { dg-error \"visibility argument not a string\" }\n+\n+@attribute(\"visibility\", \"invalid argument\")\n+int invalid_argument(); // { dg-error \".visibility. argument must be one of\" }\n+\n+@attribute(\"visibility\", \"default\")\n+int redeclared_visibility();\n+\n+@attribute(\"visibility\", \"internal\")\n+int redeclared_visibility(); // { dg-error \"redeclared with different visibility\" }"}, {"sha": "a3398822647db44094eb76b5cee2f8d59e565973", "filename": "gcc/testsuite/gdc.dg/attr_visibility2.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility2.d?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-require-visibility \"\" }\n+\n+module attr_visibility2;\n+\n+import gcc.attributes;\n+\n+// { dg-final { scan-hidden \"_D16attr_visibility25func1FZv\" } }\n+\n+@hidden void func1() { }\n+\n+// { dg-final { scan-hidden \"_D16attr_visibility25func2FZv\" } }\n+\n+@hidden void func2();\n+\n+void func2() { }\n+\n+// { dg-final { scan-hidden \"_D16attr_visibility25func3FZv\" } }\n+\n+void func3();\n+\n+@hidden void func3() { }\n+\n+// { dg-final { scan-hidden \"_D16attr_visibility210globalvar1i\" } }\n+\n+@hidden __gshared int globalvar1 = 5;"}, {"sha": "32984287d89c8ed8c1a40d479dabb85d67cb1c47", "filename": "gcc/testsuite/gdc.dg/attr_visibility3.d", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_visibility3.d?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-require-visibility \"\" }\n+// { dg-require-dll \"\" }\n+\n+import gcc.attributes;\n+\n+@visibility(\"hidden\")\n+export void func1(); // { dg-error \".func1. was declared .export.\" }\n+\n+@visibility(\"hidden\")\n+export void func2() { } // { dg-error \".func2. was declared .export.\" }\n+\n+@visibility(\"default\")\n+export void func3();\n+\n+@visibility(\"default\")\n+export void func4() { };\n+\n+@visibility(\"hidden\")\n+export struct type1 { } // { dg-error \".type1. was declared .export.\" }\n+\n+@visibility(\"default\")\n+export struct type2 { }\n+\n+@visibility(\"hidden\")\n+export class type3 { } // { dg-error \".type3. was declared .export.\" }\n+\n+@visibility(\"default\")\n+export class type4 { }"}, {"sha": "ca066cef822a5afb8316837b2a9171b893999b34", "filename": "libphobos/libdruntime/gcc/attributes.d", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b01ab4910da0b96d844301fea1a2b56c5344d/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b01ab4910da0b96d844301fea1a2b56c5344d/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d?ref=636b01ab4910da0b96d844301fea1a2b56c5344d", "patch": "@@ -424,6 +424,30 @@ auto target_clones(A...)(A arguments)\n  */\n enum used = attribute(\"used\");\n \n+/**\n+ * The `@visibility` attribute affects the linkage of the declaration to which\n+ * it is attached. It can be applied to variables, types, and functions.\n+ *\n+ * There are four supported visibility_type values: `default`, `hidden`,\n+ * `protected`, or `internal` visibility.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @visibility(\"protected\") void func() {  }\n+ * ---\n+ */\n+auto visibility(string visibilityName)\n+{\n+    return attribute(\"visibility\", visibilityName);\n+}\n+\n+auto visibility(A...)(A arguments)\n+{\n+    assert(false, \"visibility attribute argument not a string constant\");\n+}\n+\n /**\n  * The `@weak` attribute causes a declaration of an external symbol to be\n  * emitted as a weak symbol rather than a global.  This is primarily useful in\n@@ -542,6 +566,16 @@ enum dynamicCompileEmit = false;\n  */\n enum fastmath = optimize(\"Ofast\");\n \n+/**\n+ * Sets the visibility of a function or global variable to \"hidden\".\n+ * Such symbols aren't directly accessible from outside the DSO\n+ * (executable or DLL/.so/.dylib) and are resolved inside the DSO\n+ * during linking. If unreferenced within the DSO, the linker can\n+ * strip a hidden symbol.\n+ * An `export` visibility overrides this attribute.\n+ */\n+enum hidden = visibility(\"hidden\");\n+\n /**\n  * Adds GCC's \"naked\" attribute to a function, disabling function prologue /\n  * epilogue emission."}]}