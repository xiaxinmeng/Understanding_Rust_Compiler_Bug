{"sha": "0776059ee03d0974e3f953917ceffc2ea4681a14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc3NjA1OWVlMDNkMDk3NGUzZjk1MzkxN2NlZmZjMmVhNDY4MWExNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-12-12T05:15:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-12T05:15:30Z"}, "message": "except.c (use_eh_context): Don't copy_rtx a REG.\n\n\t* except.c (use_eh_context): Don't copy_rtx a REG.\n\t(emit_throw): Lose old unwinder support.\n\t(expand_internal_throw): Likewise.\n\t* libgcc2.c (struct eh_context): Likewise.\n\t(new_eh_context): Likewise.\n\t(__get_eh_info): Lose redundant cast.\n\t(__get_dynamic_handler_chain): Likewise.\n\t(__get_saved_pc): Lose.\n\tLose all old unwinder support code.\n\n\t* decl2.c (finish_file): Lose call to expand_builtin_throw.\n\t* except.c (expand_builtin_throw): Remove.\n\t* cp-tree.h: Remove ptr_ptr_type_node.\n\t* decl.c: Likewise.\n\nFrom-SVN: r17054", "tree": {"sha": "15fddd8589e7b848e33c703a1eea6abf0f98396c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15fddd8589e7b848e33c703a1eea6abf0f98396c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0776059ee03d0974e3f953917ceffc2ea4681a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0776059ee03d0974e3f953917ceffc2ea4681a14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0776059ee03d0974e3f953917ceffc2ea4681a14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0776059ee03d0974e3f953917ceffc2ea4681a14/comments", "author": null, "committer": null, "parents": [{"sha": "c404fea2260f6bd4eacecdcf3642da6fd67dae89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c404fea2260f6bd4eacecdcf3642da6fd67dae89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c404fea2260f6bd4eacecdcf3642da6fd67dae89"}], "stats": {"total": 445, "additions": 26, "deletions": 419}, "files": [{"sha": "d871668bd96f7de2b0062572c87f68de35c9bb56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -1,3 +1,15 @@\n+Thu Dec 11 21:08:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (use_eh_context): Don't copy_rtx a REG.\n+\t(emit_throw): Lose old unwinder support.\n+\t(expand_internal_throw): Likewise.\n+\t* libgcc2.c (struct eh_context): Likewise.\n+\t(new_eh_context): Likewise.\n+\t(__get_eh_info): Lose redundant cast.\n+\t(__get_dynamic_handler_chain): Likewise.\n+\t(__get_saved_pc): Lose.\n+\tLose all old unwinder support code.\n+\n Thu Dec 11 20:42:18 1997  Teemu Torma  <tot@trema.com>\n \n \tThread-safe EH support for pthreads, DCE threads and Solaris threads."}, {"sha": "6c17bd1aee4c49d888951c2485d509b1ddb2d0dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -1,3 +1,10 @@\n+Thu Dec 11 21:12:09 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_file): Lose call to expand_builtin_throw.\n+\t* except.c (expand_builtin_throw): Remove.\n+\t* cp-tree.h: Remove ptr_ptr_type_node.\n+\t* decl.c: Likewise.\n+\n Thu Dec 11 20:43:33 1997  Teemu Torma  <tot@trema.com>\n \t\n \t* decl.c (ptr_ptr_type_node): Define."}, {"sha": "e1653020194cccea7170650eb318b4a5ac3365c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -1511,7 +1511,7 @@ extern tree vt_off_identifier;\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n-extern tree ptr_type_node, ptr_ptr_type_node;\n+extern tree ptr_type_node;\n extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;"}, {"sha": "7ece1d33d38d82f5cb1ade17206cf5d871e33159", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -241,10 +241,6 @@ tree void_zero_node;\n tree ptr_type_node;\n tree const_ptr_type_node;\n \n-/* Node for type `void **'. */\n-\n-tree ptr_ptr_type_node;\n-\n /* Nodes for types `char *' and `const char *'.  */\n \n tree string_type_node, const_string_type_node;\n@@ -5069,7 +5065,6 @@ init_decl_processing ()\n   ptr_type_node = build_pointer_type (void_type_node);\n   const_ptr_type_node\n     = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n-  ptr_ptr_type_node = build_pointer_type (ptr_type_node);\n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);\n #endif"}, {"sha": "5e54f49ed2fc87f00b2d633e3a50a29ccdcbd027", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -3166,8 +3166,6 @@ finish_file ()\n       assemble_constructor (IDENTIFIER_POINTER (fnname));\n     }\n \n-  expand_builtin_throw ();\n-\n   permanent_allocation (1);\n \n   /* Done with C language context needs.  */"}, {"sha": "0c66074888fd98b8ea6e5b596bcd0509a9f2d7aa", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -185,10 +185,6 @@ static tree Unwind;\n \n    ========================================================================= */\n \n-#ifndef DWARF2_UNWIND_INFO\n-extern int throw_used;\n-#endif\n-\n extern rtx catch_clauses;\n extern tree const_ptr_type_node;\n \n@@ -734,224 +730,6 @@ do_unwind (inner_throw_label)\n }\n \n \n-/* Is called from expand_exception_blocks to generate the code in a function\n-   to \"throw\" if anything in the function needs to perform a throw.\n-\n-   expands \"throw\" as the following pseudo code:\n-\n-\tthrow:\n-\t\teh = find_first_exception_match (saved_pc);\n-\t    if (!eh) goto gotta_rethrow_it;\n-\t\tgoto eh;\n-\n-\tgotta_rethrow_it:\n-\t\tsaved_pc = __builtin_return_address (0);\n-\t\tpop_to_previous_level ();\n-\t\tgoto throw;  */\n-\n-void\n-expand_builtin_throw ()\n-{\n-#ifndef DWARF2_UNWIND_INFO\n-  tree fcall;\n-  tree params;\n-  rtx handler;\n-  rtx saved_pcnthrow;\n-  rtx next_pc;\n-  rtx gotta_rethrow_it;\n-  rtx gotta_call_terminate;\n-  rtx after_unwind;\n-  rtx top_of_loop;\n-  tree t;\n-  rtx x;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  if (! throw_used)\n-    return;\n-\n-  params = void_list_node;\n-  t = make_call_declarator (get_identifier (\"__throw\"), params, NULL_TREE,\n-\t\t\t    NULL_TREE);\n-  start_function (decl_tree_cons (NULL_TREE,\n-\t\t\t\t  get_identifier (\"void\"),\n-\t\t\t\t  decl_tree_cons (NULL_TREE,\n-\t\t\t\t\t\t  get_identifier (\"static\"),\n-\t\t\t\t\t\t  NULL_TREE)),\n-\t\t  t, NULL_TREE, 0);\n-  store_parm_decls ();\n-  pushlevel (0);\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-\n-  gotta_rethrow_it = gen_label_rtx ();\n-  gotta_call_terminate = gen_label_rtx ();\n-\n-  /* These two can be frontend specific.  If wanted, they can go in\n-     expand_throw.  */\n-  /* Do we have a valid object we are throwing? */\n-  t = call_eh_info ();\n-  emit_cmp_insn (expand_expr (t, NULL_RTX, Pmode, 0),\n-\t\t const0_rtx, EQ, NULL_RTX,\n-\t\t GET_MODE (DECL_RTL (t)), 0, 0);\n-  emit_jump_insn (gen_beq (gotta_call_terminate));\n-\n-  /* search for an exception handler for the saved_pc */\n-  handler = do_function_call (FirstExceptionMatch,\n-\t\t\t      expr_tree_cons (NULL_TREE,\n-\t\t\t\t\t      make_tree (ptr_ptr_type_node,\n-\t\t\t\t\t\t\t get_saved_pc_ref ()),\n-\t\t\t\t\t      NULL_TREE),\n-\t\t\t      ptr_type_node);\n-\n-  /* did we find one? */\n-  emit_cmp_insn (handler, const0_rtx, EQ, NULL_RTX,\n-\t\t GET_MODE (handler), 0, 0);\n-\n-  /* if not, jump to gotta_rethrow_it */\n-  emit_jump_insn (gen_beq (gotta_rethrow_it));\n-\n-  {\n-    rtx ret_val, x;\n-    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n-\t\t\t\t\t  0, hard_frame_pointer_rtx);\n-\n-    /* Set it up so that we continue at the handler.  */\n-    emit_move_insn (ret_val, handler);\n-#ifdef RETURN_ADDR_OFFSET\n-    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n-    if (x != ret_val)\n-      emit_move_insn (ret_val, x);\n-#endif\n-\n-    expand_null_return ();\n-  }\n-\n-  top_of_loop = gen_label_rtx ();\n-  emit_label (top_of_loop);\n-  \n-#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n-  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n-    {\n-      saved_pcnthrow = gen_reg_rtx (Pmode);\n-      emit_move_insn (saved_pcnthrow, hard_function_value (ptr_type_node,\n-\t\t\t\t\t\t\t   NULL_TREE));\n-    }\n-#endif\n-      \n-  /* Call to  __builtin_return_address.  */\n-#if defined (ARM_FRAME_RTX)  /* was __arm */\n-  /* This should be moved into arm.h:RETURN_ADDR_RTX */\n-  /* This replaces a 'call' to __builtin_return_address */\n-  next_pc = gen_reg_rtx (Pmode);\n-  emit_move_insn (next_pc,\n-\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n-#else\n-  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  fcall = build_function_call (builtin_return_address_fndecl, params);\n-  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n-#endif\n-\n-  /* Did __builtin_return_address return a valid address?  */\n-  emit_cmp_insn (next_pc, const0_rtx, EQ, NULL_RTX,\n-\t\t GET_MODE (next_pc), 0, 0);\n-\n-  emit_jump_insn (gen_beq (gotta_call_terminate));\n-\n-  next_pc = eh_outer_context (next_pc);\n-\n-  /* Yes it did.  */\n-#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n-  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n-    {\n-      rtx x;\n-\n-      x = validize_mem (gen_rtx (MEM, Pmode, saved_pcnthrow));\n-      emit_move_insn (validize_mem (gen_rtx (MEM, Pmode, x)),\n-\t\t      next_pc);\n-#ifdef FUNCTION_OUTGOING_VALUE\t\n-      emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),\n-\t\t      validize_mem (gen_rtx (MEM, Pmode,\n-\t\t\t\t\t     plus_constant (saved_pcnthrow,\n-\t\t\t\t\t\t\t    GET_MODE_SIZE (Pmode)))));\n-      emit_insn (gen_rtx (USE, VOIDmode,\n-\t\t\t  FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));\n-#endif\n-    }\n-  else\n-#endif\n-    emit_move_insn (get_saved_pc_ref (), next_pc);\n-\n-  after_unwind = gen_label_rtx ();\n-  do_unwind (gen_rtx (LABEL_REF, Pmode, after_unwind));\n-\n-  emit_label (after_unwind);\n-\n-#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n-  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n-    {\n-      t = build_function_type (void_type_node, void_list_node);\n-      t = make_tree (build_pointer_type (t),\n-\t\t     hard_function_value (ptr_type_node,\n-\t\t\t\t\t  NULL_TREE));\n-      t = build_function_call (t, NULL_TREE);\n-      expand_expr (t, const0_rtx, VOIDmode, 0);\n-    }\n-  else\n-#endif\n-    emit_throw ();\n-\n-  /* no it didn't --> therefore we need to call terminate */\n-  emit_label (gotta_call_terminate);\n-  do_function_call (Terminate, NULL_TREE, NULL_TREE);\n-\n-  {\n-    rtx ret_val, x;\n-    /* code to deal with unwinding and looking for it again */\n-    emit_label (gotta_rethrow_it);\n-    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n-\t\t\t\t\t  0, hard_frame_pointer_rtx);\n-\n-    /* Set it up so that we continue inside, at the top of the loop.  */\n-    emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, top_of_loop));\n-#ifdef RETURN_ADDR_OFFSET\n-    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n-    if (x != ret_val)\n-      emit_move_insn (ret_val, x);\n-#endif\n-\n-#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n-    if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n-      {\n-\trtx x = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\t\t\t  \"__eh_pcnthrow\"),\n-\t\t\t\t\t NULL_RTX, 1,\n-\t\t\t\t\t Pmode, 0);\n-\t/* This is to get a version of throw that will throw properly.  */\n-\temit_move_insn (validize_mem (gen_rtx (MEM, Pmode,\n-\t\t\t\t\t       plus_constant (x, GET_MODE_SIZE (Pmode)))),\n-\t\t\tthrow_libfunc);\n-#ifdef FUNCTION_OUTGOING_VALUE\t\n-\temit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),\n-\t\t\tx);\n-\temit_insn (gen_rtx (USE, VOIDmode, FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));\n-#endif\n-      }\n-#endif\n-\n-    /* Fall into epilogue to unwind prologue.  */\n-  }\n-\n-  expand_end_bindings (getdecls (), 1, 0);\n-  poplevel (1, 0, 0);\n-  pop_momentary ();\n-\n-  finish_function (lineno, 0, 0);\n-#endif /* DWARF2_UNWIND_INFO */\n-}\n-\n /* An exception spec is implemented more or less like:\n \n    try {"}, {"sha": "6853859c0eed7c1ab9b8d0071151810de3d20d67", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -774,12 +774,12 @@ use_eh_context ()\n       \n       insn = gen_rtx (USE,\n \t\t      GET_MODE (current_function_ehc),\n-\t\t      copy_rtx (current_function_ehc));\n+\t\t      current_function_ehc);\n       insn = emit_insn_before (insn, get_first_nonparm_insn ());\n \n       REG_NOTES (insn)\n \t= gen_rtx (EXPR_LIST, \n-\t\t   REG_EH_CONTEXT, copy_rtx (current_function_ehc),\n+\t\t   REG_EH_CONTEXT, current_function_ehc,\n \t\t   REG_NOTES (insn));\n     }\n   return current_function_ehc;\n@@ -1272,10 +1272,6 @@ emit_throw ()\n #ifdef JUMP_TO_THROW\n       emit_indirect_jump (throw_libfunc);\n #else\n-#ifndef DWARF2_UNWIND_INFO\n-      /* Prevent assemble_external from doing anything with this symbol.  */\n-      SYMBOL_REF_USED (throw_libfunc) = 1;\n-#endif\n       emit_library_call (throw_libfunc, 0, VOIDmode, 0);\n #endif\n       throw_used = 1;\n@@ -1289,15 +1285,6 @@ emit_throw ()\n void\n expand_internal_throw ()\n {\n-#ifndef DWARF2_UNWIND_INFO\n-  if (! exceptions_via_longjmp)\n-    {\n-      rtx label = gen_label_rtx ();\n-      emit_label (label);\n-      label = gen_rtx (LABEL_REF, Pmode, label);\n-      emit_move_insn (get_saved_pc_ref (), label);\n-    }\n-#endif\n   emit_throw ();\n }\n "}, {"sha": "7474263c4009614ed0b32ffe47da0d469e081d96", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 4, "deletions": 174, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0776059ee03d0974e3f953917ceffc2ea4681a14/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=0776059ee03d0974e3f953917ceffc2ea4681a14", "patch": "@@ -3002,10 +3002,6 @@ __empty ()\n struct eh_context\n {\n   void **dynamic_handler_chain;\n-  void *saved_pc;\n-#ifndef DWARF2_UNWIND_INFO\n-  void *buf[2];\n-#endif\n   /* This is language dependent part of the eh context. */\n   void *info;\n };\n@@ -3028,10 +3024,6 @@ new_eh_context ()\n   memset (eh, 0, sizeof *eh);\n \n   eh->dynamic_handler_chain = top_elt;\n-#ifndef DWARF2_UNWIND_INFO\n-  eh->buf[0] = &eh->saved_pc;\n-  eh->buf[1] = &__throw;\n-#endif  \n \n   return eh;\n }\n@@ -3073,7 +3065,7 @@ void **\n __get_eh_info ()\n {\n   struct eh_context *eh = (*get_eh_context) ();\n-  return (void **) &eh->info;\n+  return &eh->info;\n }\n \f\n #if __GTHREADS\n@@ -3158,14 +3150,7 @@ void ***\n __get_dynamic_handler_chain ()\n {\n   struct eh_context *eh = (*get_eh_context) ();\n-  return (void ***) &eh->dynamic_handler_chain;\n-}\n-\n-void **\n-__get_saved_pc ()\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  return (void **) &eh->saved_pc;\n+  return &eh->dynamic_handler_chain;\n }\n \n /* This is used to throw an exception when the setjmp/longjmp codegen\n@@ -3364,162 +3349,7 @@ find_exception_handler (void *pc, exception_table *table)\n }\n #endif /* EH_TABLE_LOOKUP */\n \f\n-#ifndef DWARF2_UNWIND_INFO\n-/* Support code for exception handling using inline unwinders or\n-   __unwind_function.  */\n-\n-void *__eh_pc;\n-\n-#ifndef EH_TABLE_LOOKUP\n-typedef struct exception_table_node {\n-  exception_table *table;\n-  void *start;\n-  void *end;\n-  struct exception_table_node *next;\n-} exception_table_node;\n-\n-static struct exception_table_node *exception_table_list;\n-\n-void *\n-__find_first_exception_table_match (void *pc)\n-{\n-  register exception_table_node *tnp;\n-\n-  for (tnp = exception_table_list; tnp != 0; tnp = tnp->next)\n-    {\n-      if (tnp->start <= pc && tnp->end >= pc)\n-\treturn find_exception_handler (pc, tnp->table);\n-    }\n-\n-  return (void *) 0;\n-}\n-\n-void\n-__register_exceptions (exception_table *table)\n-{\n-  exception_table_node *node;\n-  exception_table *range = table + 1;\n-\n-  if (range->start == (void *) -1)\n-    return;\n-\n-  node = (exception_table_node *) malloc (sizeof (exception_table_node));\n-  node->table = table;\n-\n-  /* This look can be optimized away either if the table\n-     is sorted, or if we pass in extra parameters.  */\n-  node->start = range->start;\n-  node->end = range->end;\n-  for (range++ ; range->start != (void *) (-1); range++)\n-    {\n-      if (range->start < node->start)\n-\tnode->start = range->start;\n-      if (range->end > node->end)\n-\tnode->end = range->end;\n-    }\n-\n-  node->next = exception_table_list;\n-  exception_table_list = node;\n-}\n-#endif /* !EH_TABLE_LOOKUP */\n-\n-/* Throw stub routine.\n-\n-   This is work in progress, but not completed yet.  */\n-\n-void\n-__throw ()\n-{\n-  abort ();\n-}\n-\n-/* See expand_builtin_throw for details.  */\n-\n-void **__eh_pcnthrow () {\n-  struct eh_context *eh = (*get_eh_context) ();\n-  return &eh->buf[0];\n-}\n-\n-#if #machine(i386)\n-void\n-__unwind_function(void *ptr)\n-{\n-  asm(\"movl 8(%esp),%ecx\");\n-  /* Undo current frame */\n-  asm(\"movl %ebp,%esp\");\n-  asm(\"popl %ebp\");\n-  /* like ret, but stay here */\n-  asm(\"addl $4,%esp\");\n-  \n-  /* Now, undo previous frame.  */\n-  /* This is a test routine, as we have to dynamically probe to find out\n-     what to pop for certain, this is just a guess.  */\n-  asm(\"leal -16(%ebp),%esp\");\n-  asm(\"pop %ebx\");\n-  asm(\"pop %esi\");\n-  asm(\"pop %edi\");\n-  asm(\"movl %ebp,%esp\");\n-  asm(\"popl %ebp\");\n-\n-  asm(\"movl %ecx,0(%esp)\");\n-  asm(\"ret\");\n-}\n-#elif #machine(rs6000) && !defined _ARCH_PPC\n-__unwind_function(void *ptr)\n-{\n-  asm(\"mr 31,1\");\n-  asm(\"l 1,0(1)\");\n-  asm(\"l 31,-4(1)\");\n-  asm(\"# br\");\n-\n-  asm(\"mr 31,1\");\n-  asm(\"l 1,0(1)\");\n-  /* use 31 as a scratch register to restore the link register.  */\n-  asm(\"l 31, 8(1);mtlr 31 # l lr,8(1)\");\n-  asm(\"l 31,-4(1)\");\n-  asm(\"# br\");\n-  asm(\"mtctr 3;bctr # b 3\");\n-}\n-#elif (#machine(rs6000) || #machine(powerpc)) && defined _ARCH_PPC\n-__unwind_function(void *ptr)\n-{\n-  asm(\"mr 31,1\");\n-  asm(\"lwz 1,0(1)\");\n-  asm(\"lwz 31,-4(1)\");\n-  asm(\"# br\");\n-\n-  asm(\"mr 31,1\");\n-  asm(\"lwz 1,0(1)\");\n-  /* use 31 as a scratch register to restore the link register.  */\n-  asm(\"lwz 31, 8(1);mtlr 31 # l lr,8(1)\");\n-  asm(\"lwz 31,-4(1)\");\n-  asm(\"# br\");\n-  asm(\"mtctr 3;bctr # b 3\");\n-}\n-#elif #machine(vax)\n-__unwind_function(void *ptr)\n-{\n-  __label__ return_again;\n-\n-  /* Replace our frame's return address with the label below.\n-     During execution, we will first return here instead of to\n-     caller, then second return takes caller's frame off the stack.\n-     Two returns matches two actual calls, so is less likely to\n-     confuse debuggers.  `16' corresponds to RETURN_ADDRESS_OFFSET.  */\n-  __asm (\"movl %0,16(fp)\" : : \"p\" (&& return_again));\n-  return;\n-\n- return_again:\n-  return;\n-}\n-#else\n-__unwind_function(void *ptr)\n-{\n-  abort ();\n-}\n-#endif /* powerpc */\n-\f\n-#else /* DWARF2_UNWIND_INFO */\n+#ifdef DWARF2_UNWIND_INFO\n /* Support code for exception handling using static unwind information.  */\n \n #include \"frame.h\"\n@@ -3793,7 +3623,7 @@ __throw ()\n   /* Epilogue:  restore the handler frame's register values and return\n      to the stub.  */\n }\n-#endif /* !DWARF2_UNWIND_INFO */\n+#endif /* DWARF2_UNWIND_INFO */\n \n #endif /* L_eh */\n \f"}]}