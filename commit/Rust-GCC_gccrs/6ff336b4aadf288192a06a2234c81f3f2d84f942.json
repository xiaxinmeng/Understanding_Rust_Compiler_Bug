{"sha": "6ff336b4aadf288192a06a2234c81f3f2d84f942", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmMzM2YjRhYWRmMjg4MTkyYTA2YTIyMzRjODFmM2YyZDg0Zjk0Mg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2011-11-07T20:10:03Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2011-11-07T20:10:03Z"}, "message": "optabs.c (get_atomic_op_for_code): Fill in optab table at runtime so SWITCHABLE_TARGET can change the valuies...\n\n\n\n2011-11-07  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* optabs.c (get_atomic_op_for_code): Fill in optab table at runtime so\n\tSWITCHABLE_TARGET can change the valuies during compilation.\n\t(expand_atomic_fetch_op): handle parameter changes ripples for \n\tget_atomic_op_for_code call.\n\nFrom-SVN: r181112", "tree": {"sha": "29ab1b545dad980846a9d15d08cff157a0de68bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29ab1b545dad980846a9d15d08cff157a0de68bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff336b4aadf288192a06a2234c81f3f2d84f942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff336b4aadf288192a06a2234c81f3f2d84f942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff336b4aadf288192a06a2234c81f3f2d84f942", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff336b4aadf288192a06a2234c81f3f2d84f942/comments", "author": null, "committer": null, "parents": [{"sha": "0669295b1e7991bb5465267d4bd06576883e648b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0669295b1e7991bb5465267d4bd06576883e648b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0669295b1e7991bb5465267d4bd06576883e648b"}], "stats": {"total": 114, "additions": 76, "deletions": 38}, "files": [{"sha": "33b268495f025afc17ac861bc9d44fc2e2396464", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff336b4aadf288192a06a2234c81f3f2d84f942/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff336b4aadf288192a06a2234c81f3f2d84f942/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ff336b4aadf288192a06a2234c81f3f2d84f942", "patch": "@@ -1,3 +1,10 @@\n+2011-11-07  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* optabs.c (get_atomic_op_for_code): Fill in optab table at runtime so\n+\tSWITCHABLE_TARGET can change the values during compilation.\n+\t(expand_atomic_fetch_op): Handle parameter change ripples for \n+\tget_atomic_op_for_code call.\n+\n 2011-11-07  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* doc/extend.texi: Docuemnt behaviour change for __atomic_exchange and"}, {"sha": "a466e56fc680648efb4d046c1f50cc887325e9d0", "filename": "gcc/optabs.c", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff336b4aadf288192a06a2234c81f3f2d84f942/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff336b4aadf288192a06a2234c81f3f2d84f942/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6ff336b4aadf288192a06a2234c81f3f2d84f942", "patch": "@@ -7579,43 +7579,74 @@ struct atomic_op_functions\n   enum rtx_code reverse_code;\n };\n \n-static const struct atomic_op_functions *\n-get_atomic_op_for_code (enum rtx_code code)\n-{\n-  static const struct atomic_op_functions add_op = {\n-    atomic_fetch_add_optab, atomic_add_fetch_optab, atomic_add_optab,\n-    sync_old_add_optab, sync_new_add_optab, sync_add_optab, MINUS\n-  }, sub_op = {\n-    atomic_fetch_sub_optab, atomic_sub_fetch_optab, atomic_sub_optab,\n-    sync_old_sub_optab, sync_new_sub_optab, sync_sub_optab, PLUS\n-  }, xor_op = {\n-    atomic_fetch_xor_optab, atomic_xor_fetch_optab, atomic_xor_optab,\n-    sync_old_xor_optab, sync_new_xor_optab, sync_xor_optab, XOR\n-  }, and_op = {\n-    atomic_fetch_and_optab, atomic_and_fetch_optab, atomic_and_optab,\n-    sync_old_and_optab, sync_new_and_optab, sync_and_optab, UNKNOWN\n-  }, nand_op = {\n-    atomic_fetch_nand_optab, atomic_nand_fetch_optab, atomic_nand_optab,\n-    sync_old_nand_optab, sync_new_nand_optab, sync_nand_optab, UNKNOWN\n-  }, ior_op = {\n-    atomic_fetch_or_optab, atomic_or_fetch_optab, atomic_or_optab,\n-    sync_old_ior_optab, sync_new_ior_optab, sync_ior_optab, UNKNOWN\n-  };\n \n+/* Fill in structure pointed to by OP with the various optab entries for an \n+   operation of type CODE.  */\n+\n+static void\n+get_atomic_op_for_code (struct atomic_op_functions *op, enum rtx_code code)\n+{\n+  gcc_assert (op!= NULL);\n+\n+  /* If SWITCHABLE_TARGET is defined, then subtargets can be switched\n+     in the source code during compilation, and the optab entries are not\n+     computable until runtime.  Fill in the values at runtime.  */\n   switch (code)\n     {\n     case PLUS:\n-      return &add_op;\n+      op->mem_fetch_before = atomic_fetch_add_optab;\n+      op->mem_fetch_after = atomic_add_fetch_optab;\n+      op->mem_no_result = atomic_add_optab;\n+      op->fetch_before = sync_old_add_optab;\n+      op->fetch_after = sync_new_add_optab;\n+      op->no_result = sync_add_optab;\n+      op->reverse_code = MINUS;\n+      break;\n     case MINUS:\n-      return &sub_op;\n+      op->mem_fetch_before = atomic_fetch_sub_optab;\n+      op->mem_fetch_after = atomic_sub_fetch_optab;\n+      op->mem_no_result = atomic_sub_optab;\n+      op->fetch_before = sync_old_sub_optab;\n+      op->fetch_after = sync_new_sub_optab;\n+      op->no_result = sync_sub_optab;\n+      op->reverse_code = PLUS;\n+      break;\n     case XOR:\n-      return &xor_op;\n+      op->mem_fetch_before = atomic_fetch_xor_optab;\n+      op->mem_fetch_after = atomic_xor_fetch_optab;\n+      op->mem_no_result = atomic_xor_optab;\n+      op->fetch_before = sync_old_xor_optab;\n+      op->fetch_after = sync_new_xor_optab;\n+      op->no_result = sync_xor_optab;\n+      op->reverse_code = XOR;\n+      break;\n     case AND:\n-      return &and_op;\n+      op->mem_fetch_before = atomic_fetch_and_optab;\n+      op->mem_fetch_after = atomic_and_fetch_optab;\n+      op->mem_no_result = atomic_and_optab;\n+      op->fetch_before = sync_old_and_optab;\n+      op->fetch_after = sync_new_and_optab;\n+      op->no_result = sync_and_optab;\n+      op->reverse_code = UNKNOWN;\n+      break;\n     case IOR:\n-      return &ior_op;\n+      op->mem_fetch_before = atomic_fetch_or_optab;\n+      op->mem_fetch_after = atomic_or_fetch_optab;\n+      op->mem_no_result = atomic_or_optab;\n+      op->fetch_before = sync_old_ior_optab;\n+      op->fetch_after = sync_new_ior_optab;\n+      op->no_result = sync_ior_optab;\n+      op->reverse_code = UNKNOWN;\n+      break;\n     case NOT:\n-      return &nand_op;\n+      op->mem_fetch_before = atomic_fetch_nand_optab;\n+      op->mem_fetch_after = atomic_nand_fetch_optab;\n+      op->mem_no_result = atomic_nand_optab;\n+      op->fetch_before = sync_old_nand_optab;\n+      op->fetch_after = sync_new_nand_optab;\n+      op->no_result = sync_nand_optab;\n+      op->reverse_code = UNKNOWN;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -7701,22 +7732,22 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t\t\tenum memmodel model, bool after)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  const struct atomic_op_functions *optab;\n+  struct atomic_op_functions optab;\n   rtx result;\n   bool unused_result = (target == const0_rtx);\n \n-  optab = get_atomic_op_for_code (code);\n+  get_atomic_op_for_code (&optab, code);\n \n   /* Check for the case where the result isn't used and try those patterns.  */\n   if (unused_result)\n     {\n       /* Try the memory model variant first.  */\n-      result = maybe_emit_op (optab, target, mem, val, true, model, true);\n+      result = maybe_emit_op (&optab, target, mem, val, true, model, true);\n       if (result)\n         return result;\n \n       /* Next try the old style withuot a memory model.  */\n-      result = maybe_emit_op (optab, target, mem, val, false, model, true);\n+      result = maybe_emit_op (&optab, target, mem, val, false, model, true);\n       if (result)\n         return result;\n \n@@ -7725,23 +7756,23 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n     }\n \n   /* Try the __atomic version.  */\n-  result = maybe_emit_op (optab, target, mem, val, true, model, after);\n+  result = maybe_emit_op (&optab, target, mem, val, true, model, after);\n   if (result)\n     return result;\n \n   /* Try the older __sync version.  */\n-  result = maybe_emit_op (optab, target, mem, val, false, model, after);\n+  result = maybe_emit_op (&optab, target, mem, val, false, model, after);\n   if (result)\n     return result;\n \n   /* If the fetch value can be calculated from the other variation of fetch,\n      try that operation.  */\n-  if (after || optab->reverse_code != UNKNOWN || target == const0_rtx) \n+  if (after || optab.reverse_code != UNKNOWN || target == const0_rtx) \n     {\n       /* Try the __atomic version, then the older __sync version.  */\n-      result = maybe_emit_op (optab, target, mem, val, true, model, !after);\n+      result = maybe_emit_op (&optab, target, mem, val, true, model, !after);\n       if (!result)\n-\tresult = maybe_emit_op (optab, target, mem, val, false, model, !after);\n+\tresult = maybe_emit_op (&optab, target, mem, val, false, model, !after);\n \n       if (result)\n \t{\n@@ -7752,7 +7783,7 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t  /* Issue compensation code.  Fetch_after  == fetch_before OP val.\n \t     Fetch_before == after REVERSE_OP val.  */\n \t  if (!after)\n-\t    code = optab->reverse_code;\n+\t    code = optab.reverse_code;\n \t  result = expand_simple_binop (mode, code, result, val, NULL_RTX, true,\n \t\t\t\t\tOPTAB_LIB_WIDEN);\n \t  return result;"}]}