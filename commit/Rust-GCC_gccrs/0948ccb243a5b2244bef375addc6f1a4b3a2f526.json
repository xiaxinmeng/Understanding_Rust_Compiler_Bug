{"sha": "0948ccb243a5b2244bef375addc6f1a4b3a2f526", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk0OGNjYjI0M2E1YjIyNDRiZWYzNzVhZGRjNmYxYTRiM2EyZjUyNg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-28T17:06:11Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-28T17:06:11Z"}, "message": "i386.h (enum ix86_fpcmp_strategy): New.\n\n2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n\n        * config/i386/i386.h (enum ix86_fpcmp_strategy): New.\n        * config/i386/i386.md (cbranchxf4, cstorexf4, cbranch<MODEF>4,\n        cstore<MODEF>4, mov<X87MODEF>cc): Change predicate to\n        ix86_fp_comparison_operator.\n        (*fp_jcc_1_mixed, *fp_jcc_1_sse, *fp_jcc_1_387, *fp_jcc_2_mixed,\n        *fp_jcc_2_sse, *fp_jcc_2_387): Delete\n        (*fp_jcc_3_387, *fp_jcc_4_387, *fp_jcc_5_387, *fp_jcc_6_387,\n        *fp_jcc_7_387, *fp_jcc_8<MODEF>_387): Eliminate call to\n        !ix86_use_fcomi_compare, change ix86_fp_jump_nontrivial_p call\n        to !TARGET_CMOVE, change predicate to ix86_fp_comparison_operator.\n        (related splits): Change predicate to ix86_fp_comparison_operator.\n        * config/i386/predicates.md: Use ix86_trivial_fp_comparison_operator\n        instead of ix86_fp_comparison_codes.\n        (ix86_trivial_fp_comparison_operator,\n        ix86_fp_comparison_operator): New.\n        * config/i386/i386-protos.h (ix86_fp_comparison_strategy): New.\n        (ix86_expand_compare): Eliminate last two parameters.\n        (ix86_fp_jump_nontrivial_p): Kill.\n        * config/i386/i386.c (put_condition_code): Eliminate call to\n        ix86_fp_comparison_codes and subsequent assertion.\n        (ix86_fp_comparison_codes): Eliminate.\n        (ix86_fp_swap_condition): New.\n        (ix86_fp_comparison_arithmetics_cost, ix86_fp_comparison_fcomi_cost,\n        ix86_fp_comparison_sahf_cost, ix86_use_fcomi_compare): Consolidate\n        into ix86_fp_comparison_cost and ix86_fp_comparison_strategy.\n        (ix86_prepare_fp_compare_args): Use ix86_fp_comparison_strategy\n        and ix86_fp_swap_condition.\n        (ix86_expand_fp_compare): Eliminate code for second jump/bypass jump.\n        Use ix86_fp_comparison_strategy.\n        (ix86_expand_compare): Likewise.  Eliminate last two arguments.\n        (ix86_fp_jump_nontrivial_p): Eliminate.\n        (ix86_expand_branch): Treat SFmode/DFmode/XFmode as simple.  Adjust\n        call to ix86_expand_compare.\n        (ix86_split_fp_branch, ix86_expand_setcc,\n        ix86_expand_carry_flag_compare, ix86_expand_int_movcc,\n        ix86_expand_fp_movcc): Eliminate code for second jump/bypass jump.\n\nFrom-SVN: r149035", "tree": {"sha": "6c2efbe4264d6844ad652c064def3e3644438024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2efbe4264d6844ad652c064def3e3644438024"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0948ccb243a5b2244bef375addc6f1a4b3a2f526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0948ccb243a5b2244bef375addc6f1a4b3a2f526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0948ccb243a5b2244bef375addc6f1a4b3a2f526", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0948ccb243a5b2244bef375addc6f1a4b3a2f526/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "accbd1518f6afdadb59649585197f8a7928555b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accbd1518f6afdadb59649585197f8a7928555b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/accbd1518f6afdadb59649585197f8a7928555b5"}], "stats": {"total": 687, "additions": 179, "deletions": 508}, "files": [{"sha": "436ea0dca727981b3d35d835eda605f0fc9aa68f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -1,3 +1,42 @@\n+2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * config/i386/i386.h (enum ix86_fpcmp_strategy): New.\n+        * config/i386/i386.md (cbranchxf4, cstorexf4, cbranch<MODEF>4,\n+        cstore<MODEF>4, mov<X87MODEF>cc): Change predicate to\n+        ix86_fp_comparison_operator.\n+        (*fp_jcc_1_mixed, *fp_jcc_1_sse, *fp_jcc_1_387, *fp_jcc_2_mixed,\n+        *fp_jcc_2_sse, *fp_jcc_2_387): Delete\n+        (*fp_jcc_3_387, *fp_jcc_4_387, *fp_jcc_5_387, *fp_jcc_6_387,\n+        *fp_jcc_7_387, *fp_jcc_8<MODEF>_387): Eliminate call to\n+        !ix86_use_fcomi_compare, change ix86_fp_jump_nontrivial_p call\n+        to !TARGET_CMOVE, change predicate to ix86_fp_comparison_operator.\n+        (related splits): Change predicate to ix86_fp_comparison_operator.\n+        * config/i386/predicates.md: Use ix86_trivial_fp_comparison_operator\n+        instead of ix86_fp_comparison_codes.\n+        (ix86_trivial_fp_comparison_operator,\n+        ix86_fp_comparison_operator): New.\n+        * config/i386/i386-protos.h (ix86_fp_comparison_strategy): New.\n+        (ix86_expand_compare): Eliminate last two parameters.\n+        (ix86_fp_jump_nontrivial_p): Kill.\n+        * config/i386/i386.c (put_condition_code): Eliminate call to\n+        ix86_fp_comparison_codes and subsequent assertion.\n+        (ix86_fp_comparison_codes): Eliminate.\n+        (ix86_fp_swap_condition): New.\n+        (ix86_fp_comparison_arithmetics_cost, ix86_fp_comparison_fcomi_cost,\n+        ix86_fp_comparison_sahf_cost, ix86_use_fcomi_compare): Consolidate\n+        into ix86_fp_comparison_cost and ix86_fp_comparison_strategy.\n+        (ix86_prepare_fp_compare_args): Use ix86_fp_comparison_strategy\n+        and ix86_fp_swap_condition.\n+        (ix86_expand_fp_compare): Eliminate code for second jump/bypass jump.\n+        Use ix86_fp_comparison_strategy.\n+        (ix86_expand_compare): Likewise.  Eliminate last two arguments.\n+        (ix86_fp_jump_nontrivial_p): Eliminate.\n+        (ix86_expand_branch): Treat SFmode/DFmode/XFmode as simple.  Adjust\n+        call to ix86_expand_compare.\n+        (ix86_split_fp_branch, ix86_expand_setcc,\n+        ix86_expand_carry_flag_compare, ix86_expand_int_movcc,\n+        ix86_expand_fp_movcc): Eliminate code for second jump/bypass jump.\n+\n 2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n \n         * config/arm/arm.c (arm_final_prescan_ins): Eliminate code"}, {"sha": "663b4bffaccebc4a16da70f81c4c615c2f5dbe5b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -95,14 +95,15 @@ extern void ix86_expand_convert_uns_sixf_sse (rtx, rtx);\n extern void ix86_expand_convert_uns_sidf_sse (rtx, rtx);\n extern void ix86_expand_convert_uns_sisf_sse (rtx, rtx);\n extern void ix86_expand_convert_sign_didf_sse (rtx, rtx);\n+extern enum ix86_fpcmp_strategy ix86_fp_comparison_strategy (enum rtx_code);\n extern void ix86_expand_fp_absneg_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\t    rtx[]);\n extern void ix86_expand_copysign (rtx []);\n extern void ix86_split_copysign_const (rtx []);\n extern void ix86_split_copysign_var (rtx []);\n extern int ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern int ix86_match_ccmode (rtx, enum machine_mode);\n-extern rtx ix86_expand_compare (enum rtx_code, rtx *, rtx *);\n+extern rtx ix86_expand_compare (enum rtx_code);\n extern int ix86_use_fcomi_compare (enum rtx_code);\n extern void ix86_expand_branch (enum rtx_code, rtx);\n extern void ix86_expand_setcc (enum rtx_code, rtx);\n@@ -162,7 +163,6 @@ extern enum reg_class ix86_preferred_output_reload_class (rtx, enum reg_class);\n extern int ix86_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern int ix86_mode_needed (int, rtx);\n extern void emit_i387_cw_initialization (int);\n-extern bool ix86_fp_jump_nontrivial_p (enum rtx_code);\n extern void x86_order_regs_for_local_alloc (void);\n extern void x86_function_profiler (FILE *, int);\n extern void x86_emit_floatuns (rtx [2]);"}, {"sha": "81f3b9eb44b97a204079604e22771b58b212280f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 92, "deletions": 377, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -10838,9 +10838,6 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n \n   if (mode == CCFPmode || mode == CCFPUmode)\n     {\n-      enum rtx_code second_code, bypass_code;\n-      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      gcc_assert (bypass_code == UNKNOWN && second_code == UNKNOWN);\n       code = ix86_fp_compare_code_to_integer (code);\n       mode = CCmode;\n     }\n@@ -14465,84 +14462,41 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n     }\n }\n \n-/* Split comparison code CODE into comparisons we can do using branch\n-   instructions.  BYPASS_CODE is comparison code for branch that will\n-   branch around FIRST_CODE and SECOND_CODE.  If some of branches\n-   is not required, set value to UNKNOWN.\n-   We never require more than two branches.  */\n \n-void\n-ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *bypass_code,\n-\t\t\t  enum rtx_code *first_code,\n-\t\t\t  enum rtx_code *second_code)\n-{\n-  *first_code = code;\n-  *bypass_code = UNKNOWN;\n-  *second_code = UNKNOWN;\n-\n-  /* The fcomi comparison sets flags as follows:\n-\n-     cmp    ZF PF CF\n-     >      0  0  0\n-     <      0  0  1\n-     =      1  0  0\n-     un     1  1  1 */\n+/* Return a comparison we can do and that it is equivalent to \n+   swap_condition (code) apart possibly from orderedness.\n+   But, never change orderedness if TARGET_IEEE_FP, returning\n+   UNKNOWN in that case if necessary.  */\n \n+static enum rtx_code\n+ix86_fp_swap_condition (enum rtx_code code)\n+{\n   switch (code)\n     {\n-    case GT:\t\t\t/* GTU - CF=0 & ZF=0 */\n-    case GE:\t\t\t/* GEU - CF=0 */\n-    case ORDERED:\t\t/* PF=0 */\n-    case UNORDERED:\t\t/* PF=1 */\n-    case UNEQ:\t\t\t/* EQ - ZF=1 */\n-    case UNLT:\t\t\t/* LTU - CF=1 */\n-    case UNLE:\t\t\t/* LEU - CF=1 | ZF=1 */\n-    case LTGT:\t\t\t/* EQ - ZF=0 */\n-      break;\n-    case LT:\t\t\t/* LTU - CF=1 - fails on unordered */\n-      *first_code = UNLT;\n-      *bypass_code = UNORDERED;\n-      break;\n-    case LE:\t\t\t/* LEU - CF=1 | ZF=1 - fails on unordered */\n-      *first_code = UNLE;\n-      *bypass_code = UNORDERED;\n-      break;\n-    case EQ:\t\t\t/* EQ - ZF=1 - fails on unordered */\n-      *first_code = UNEQ;\n-      *bypass_code = UNORDERED;\n-      break;\n-    case NE:\t\t\t/* NE - ZF=0 - fails on unordered */\n-      *first_code = LTGT;\n-      *second_code = UNORDERED;\n-      break;\n-    case UNGE:\t\t\t/* GEU - CF=0 - fails on unordered */\n-      *first_code = GE;\n-      *second_code = UNORDERED;\n-      break;\n-    case UNGT:\t\t\t/* GTU - CF=0 & ZF=0 - fails on unordered */\n-      *first_code = GT;\n-      *second_code = UNORDERED;\n-      break;\n+    case GT:                   /* GTU - CF=0 & ZF=0 */\n+      return TARGET_IEEE_FP ? UNKNOWN : UNLT;\n+    case GE:                   /* GEU - CF=0 */\n+      return TARGET_IEEE_FP ? UNKNOWN : UNLE;\n+    case UNLT:                 /* LTU - CF=1 */\n+      return TARGET_IEEE_FP ? UNKNOWN : GT;\n+    case UNLE:                 /* LEU - CF=1 | ZF=1 */\n+      return TARGET_IEEE_FP ? UNKNOWN : GE;\n     default:\n-      gcc_unreachable ();\n-    }\n-  if (!TARGET_IEEE_FP)\n-    {\n-      *second_code = UNKNOWN;\n-      *bypass_code = UNKNOWN;\n+      return swap_condition (code);\n     }\n }\n \n-/* Return cost of comparison done fcom + arithmetics operations on AX.\n+/* Return cost of comparison CODE using the best strategy for performance.\n    All following functions do use number of instructions as a cost metrics.\n    In future this should be tweaked to compute bytes for optimize_size and\n    take into account performance of various instructions on various CPUs.  */\n+\n static int\n-ix86_fp_comparison_arithmetics_cost (enum rtx_code code)\n+ix86_fp_comparison_cost (enum rtx_code code)\n {\n-  if (!TARGET_IEEE_FP)\n-    return 4;\n-  /* The cost of code output by ix86_expand_fp_compare.  */\n+  int arith_cost;\n+\n+  /* The cost of code using bit-twiddling on %ah.  */\n   switch (code)\n     {\n     case UNLE:\n@@ -14553,82 +14507,49 @@ ix86_fp_comparison_arithmetics_cost (enum rtx_code code)\n     case UNORDERED:\n     case ORDERED:\n     case UNEQ:\n-      return 4;\n+      arith_cost = 4;\n       break;\n     case LT:\n     case NE:\n     case EQ:\n     case UNGE:\n-      return 5;\n+      arith_cost = TARGET_IEEE_FP ? 5 : 4;\n       break;\n     case LE:\n     case UNGT:\n-      return 6;\n+      arith_cost = TARGET_IEEE_FP ? 6 : 4;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n-}\n \n-/* Return cost of comparison done using fcomi operation.\n-   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n-static int\n-ix86_fp_comparison_fcomi_cost (enum rtx_code code)\n-{\n-  enum rtx_code bypass_code, first_code, second_code;\n-  /* Return arbitrarily high cost when instruction is not supported - this\n-     prevents gcc from using it.  */\n-  if (!TARGET_CMOVE)\n-    return 1024;\n-  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return (bypass_code != UNKNOWN || second_code != UNKNOWN) + 2;\n+  switch (ix86_fp_comparison_strategy (code))\n+    {\n+    case IX86_FPCMP_COMI:\n+      return arith_cost > 4 ? 3 : 2;\n+    case IX86_FPCMP_SAHF:\n+      return arith_cost > 4 ? 4 : 3;\n+    default:\n+      return arith_cost;\n+    }\n }\n \n-/* Return cost of comparison done using sahf operation.\n-   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n-static int\n-ix86_fp_comparison_sahf_cost (enum rtx_code code)\n-{\n-  enum rtx_code bypass_code, first_code, second_code;\n-  /* Return arbitrarily high cost when instruction is not preferred - this\n-     avoids gcc from using it.  */\n-  if (!(TARGET_SAHF && (TARGET_USE_SAHF || optimize_insn_for_size_p ())))\n-    return 1024;\n-  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return (bypass_code != UNKNOWN || second_code != UNKNOWN) + 3;\n-}\n+/* Return strategy to use for floating-point.  We assume that fcomi is always\n+   preferrable where available, since that is also true when looking at size\n+   (2 bytes, vs. 3 for fnstsw+sahf and at least 5 for fnstsw+test).  */\n \n-/* Compute cost of the comparison done using any method.\n-   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n-static int\n-ix86_fp_comparison_cost (enum rtx_code code)\n+enum ix86_fpcmp_strategy\n+ix86_fp_comparison_strategy (enum rtx_code code ATTRIBUTE_UNUSED)\n {\n-  int fcomi_cost, sahf_cost, arithmetics_cost = 1024;\n-  int min;\n-\n-  fcomi_cost = ix86_fp_comparison_fcomi_cost (code);\n-  sahf_cost = ix86_fp_comparison_sahf_cost (code);\n-\n-  min = arithmetics_cost = ix86_fp_comparison_arithmetics_cost (code);\n-  if (min > sahf_cost)\n-    min = sahf_cost;\n-  if (min > fcomi_cost)\n-    min = fcomi_cost;\n-  return min;\n-}\n+  /* Do fcomi/sahf based test when profitable.  */\n \n-/* Return true if we should use an FCOMI instruction for this\n-   fp comparison.  */\n+  if (TARGET_CMOVE)\n+    return IX86_FPCMP_COMI;\n \n-int\n-ix86_use_fcomi_compare (enum rtx_code code ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code swapped_code = swap_condition (code);\n+  if (TARGET_SAHF && (TARGET_USE_SAHF || optimize_insn_for_size_p ()))\n+    return IX86_FPCMP_SAHF;\n \n-  return ((ix86_fp_comparison_cost (code)\n-\t   == ix86_fp_comparison_fcomi_cost (code))\n-\t  || (ix86_fp_comparison_cost (swapped_code)\n-\t      == ix86_fp_comparison_fcomi_cost (swapped_code)));\n+  return IX86_FPCMP_ARITH;\n }\n \n /* Swap, force into registers, or otherwise massage the two operands\n@@ -14655,7 +14576,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && ! (standard_80387_constant_p (op0) == 1\n \t\t    || standard_80387_constant_p (op1) == 1)\n \t      && GET_CODE (op1) != FLOAT)\n-\t  || ix86_use_fcomi_compare (code)))\n+\t  || ix86_fp_comparison_strategy (code) == IX86_FPCMP_COMI))\n     {\n       op0 = force_reg (op_mode, op0);\n       op1 = force_reg (op_mode, op1);\n@@ -14671,9 +14592,13 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && ! (standard_80387_constant_p (op1) == 0\n \t\t    || MEM_P (op1))))\n \t{\n-\t  rtx tmp;\n-\t  tmp = op0, op0 = op1, op1 = tmp;\n-\t  code = swap_condition (code);\n+\t  enum rtx_code new_code = ix86_fp_swap_condition (code);\n+\t  if (new_code != UNKNOWN)\n+\t    {\n+\t      rtx tmp;\n+\t      tmp = op0, op0 = op1, op1 = tmp;\n+\t      code = new_code;\n+\t    }\n \t}\n \n       if (!REG_P (op0))\n@@ -14748,59 +14673,38 @@ ix86_fp_compare_code_to_integer (enum rtx_code code)\n /* Generate insn patterns to do a floating point compare of OPERANDS.  */\n \n static rtx\n-ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n-\t\t\trtx *second_test, rtx *bypass_test)\n+ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n {\n   enum machine_mode fpcmp_mode, intcmp_mode;\n   rtx tmp, tmp2;\n-  int cost = ix86_fp_comparison_cost (code);\n-  enum rtx_code bypass_code, first_code, second_code;\n \n   fpcmp_mode = ix86_fp_compare_mode (code);\n   code = ix86_prepare_fp_compare_args (code, &op0, &op1);\n \n-  if (second_test)\n-    *second_test = NULL_RTX;\n-  if (bypass_test)\n-    *bypass_test = NULL_RTX;\n-\n-  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-\n   /* Do fcomi/sahf based test when profitable.  */\n-  if (ix86_fp_comparison_arithmetics_cost (code) > cost\n-      && (bypass_code == UNKNOWN || bypass_test)\n-      && (second_code == UNKNOWN || second_test))\n+  switch (ix86_fp_comparison_strategy (code))\n     {\n+    case IX86_FPCMP_COMI:\n+      intcmp_mode = fpcmp_mode;\n       tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n       tmp = gen_rtx_SET (VOIDmode, gen_rtx_REG (fpcmp_mode, FLAGS_REG),\n \t\t\t tmp);\n-      if (TARGET_CMOVE)\n-\temit_insn (tmp);\n-      else\n-\t{\n-\t  gcc_assert (TARGET_SAHF);\n+      emit_insn (tmp);\n+      break;\n \n-\t  if (!scratch)\n-\t    scratch = gen_reg_rtx (HImode);\n-\t  tmp2 = gen_rtx_CLOBBER (VOIDmode, scratch);\n+    case IX86_FPCMP_SAHF:\n+      intcmp_mode = fpcmp_mode;\n+      tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n+      tmp = gen_rtx_SET (VOIDmode, gen_rtx_REG (fpcmp_mode, FLAGS_REG),\n+\t\t\t tmp);\n \n-\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, tmp2)));\n-\t}\n+      if (!scratch)\n+\tscratch = gen_reg_rtx (HImode);\n+      tmp2 = gen_rtx_CLOBBER (VOIDmode, scratch);\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, tmp2)));\n+      break;\n \n-      /* The FP codes work out to act like unsigned.  */\n-      intcmp_mode = fpcmp_mode;\n-      code = first_code;\n-      if (bypass_code != UNKNOWN)\n-\t*bypass_test = gen_rtx_fmt_ee (bypass_code, VOIDmode,\n-\t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n-\t\t\t\t       const0_rtx);\n-      if (second_code != UNKNOWN)\n-\t*second_test = gen_rtx_fmt_ee (second_code, VOIDmode,\n-\t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n-\t\t\t\t       const0_rtx);\n-    }\n-  else\n-    {\n+    case IX86_FPCMP_ARITH:\n       /* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */\n       tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n       tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), UNSPEC_FNSTSW);\n@@ -14922,6 +14826,10 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+\tbreak;\n+\n+    default:\n+      gcc_unreachable();\n     }\n \n   /* Return the test that should be put into the flags user, i.e.\n@@ -14932,108 +14840,47 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n }\n \n rtx\n-ix86_expand_compare (enum rtx_code code, rtx *second_test, rtx *bypass_test)\n+ix86_expand_compare (enum rtx_code code)\n {\n   rtx op0, op1, ret;\n   op0 = ix86_compare_op0;\n   op1 = ix86_compare_op1;\n \n-  if (second_test)\n-    *second_test = NULL_RTX;\n-  if (bypass_test)\n-    *bypass_test = NULL_RTX;\n-\n   if (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_CC)\n     ret = gen_rtx_fmt_ee (code, VOIDmode, ix86_compare_op0, ix86_compare_op1);\n \n   else if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n     {\n       gcc_assert (!DECIMAL_FLOAT_MODE_P (GET_MODE (op0)));\n-      ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n-\t\t\t\t    second_test, bypass_test);\n+      ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX);\n     }\n   else\n     ret = ix86_expand_int_compare (code, op0, op1);\n \n   return ret;\n }\n \n-/* Return true if the CODE will result in nontrivial jump sequence.  */\n-bool\n-ix86_fp_jump_nontrivial_p (enum rtx_code code)\n-{\n-  enum rtx_code bypass_code, first_code, second_code;\n-  if (!TARGET_CMOVE)\n-    return true;\n-  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return bypass_code != UNKNOWN || second_code != UNKNOWN;\n-}\n-\n void\n ix86_expand_branch (enum rtx_code code, rtx label)\n {\n   rtx tmp;\n \n   switch (GET_MODE (ix86_compare_op0))\n     {\n+    case SFmode:\n+    case DFmode:\n+    case XFmode:\n     case QImode:\n     case HImode:\n     case SImode:\n       simple:\n-      tmp = ix86_expand_compare (code, NULL, NULL);\n+      tmp = ix86_expand_compare (code);\n       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t  pc_rtx);\n       emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n       return;\n \n-    case SFmode:\n-    case DFmode:\n-    case XFmode:\n-      {\n-\trtvec vec;\n-\tint use_fcomi;\n-\tenum rtx_code bypass_code, first_code, second_code;\n-\n-\tcode = ix86_prepare_fp_compare_args (code, &ix86_compare_op0,\n-\t\t\t\t\t     &ix86_compare_op1);\n-\n-\tix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-\n-\t/* Check whether we will use the natural sequence with one jump.  If\n-\t   so, we can expand jump early.  Otherwise delay expansion by\n-\t   creating compound insn to not confuse optimizers.  */\n-\tif (bypass_code == UNKNOWN && second_code == UNKNOWN)\n-\t  {\n-\t    ix86_split_fp_branch (code, ix86_compare_op0, ix86_compare_op1,\n-\t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t\t  pc_rtx, NULL_RTX, NULL_RTX);\n-\t  }\n-\telse\n-\t  {\n-\t    tmp = gen_rtx_fmt_ee (code, VOIDmode,\n-\t\t\t\t  ix86_compare_op0, ix86_compare_op1);\n-\t    tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t\t\tgen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t\t\tpc_rtx);\n-\t    tmp = gen_rtx_SET (VOIDmode, pc_rtx, tmp);\n-\n-\t    use_fcomi = ix86_use_fcomi_compare (code);\n-\t    vec = rtvec_alloc (3 + !use_fcomi);\n-\t    RTVEC_ELT (vec, 0) = tmp;\n-\t    RTVEC_ELT (vec, 1)\n-\t      = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, FPSR_REG));\n-\t    RTVEC_ELT (vec, 2)\n-\t      = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, FLAGS_REG));\n-\t    if (! use_fcomi)\n-\t      RTVEC_ELT (vec, 3)\n-\t\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (HImode));\n-\n-\t    emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n-\t  }\n-\treturn;\n-      }\n-\n     case DImode:\n       if (TARGET_64BIT)\n \tgoto simple;\n@@ -15187,10 +15034,7 @@ void\n ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n \t\t      rtx target1, rtx target2, rtx tmp, rtx pushed)\n {\n-  rtx second, bypass;\n-  rtx label = NULL_RTX;\n   rtx condition;\n-  int bypass_probability = -1, second_probability = -1, probability = -1;\n   rtx i;\n \n   if (target2 != pc_rtx)\n@@ -15202,103 +15046,30 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n     }\n \n   condition = ix86_expand_fp_compare (code, op1, op2,\n-\t\t\t\t      tmp, &second, &bypass);\n+\t\t\t\t      tmp);\n \n   /* Remove pushed operand from stack.  */\n   if (pushed)\n     ix86_free_from_memory (GET_MODE (pushed));\n \n-  if (split_branch_probability >= 0)\n-    {\n-      /* Distribute the probabilities across the jumps.\n-\t Assume the BYPASS and SECOND to be always test\n-\t for UNORDERED.  */\n-      probability = split_branch_probability;\n-\n-      /* Value of 1 is low enough to make no need for probability\n-\t to be updated.  Later we may run some experiments and see\n-\t if unordered values are more frequent in practice.  */\n-      if (bypass)\n-\tbypass_probability = 1;\n-      if (second)\n-\tsecond_probability = 1;\n-    }\n-  if (bypass != NULL_RTX)\n-    {\n-      label = gen_label_rtx ();\n-      i = emit_jump_insn (gen_rtx_SET\n-\t\t\t  (VOIDmode, pc_rtx,\n-\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t\t bypass,\n-\t\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t    label),\n-\t\t\t\t\t\t pc_rtx)));\n-      if (bypass_probability >= 0)\n-\tadd_reg_note (i, REG_BR_PROB, GEN_INT (bypass_probability));\n-    }\n   i = emit_jump_insn (gen_rtx_SET\n \t\t      (VOIDmode, pc_rtx,\n \t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n \t\t\t\t\t     condition, target1, target2)));\n-  if (probability >= 0)\n-    add_reg_note (i, REG_BR_PROB, GEN_INT (probability));\n-  if (second != NULL_RTX)\n-    {\n-      i = emit_jump_insn (gen_rtx_SET\n-\t\t\t  (VOIDmode, pc_rtx,\n-\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode, second, target1,\n-\t\t\t\t\t\t target2)));\n-      if (second_probability >= 0)\n-\tadd_reg_note (i, REG_BR_PROB, GEN_INT (second_probability));\n-    }\n-  if (label != NULL_RTX)\n-    emit_label (label);\n+  if (split_branch_probability >= 0)\n+    add_reg_note (i, REG_BR_PROB, GEN_INT (split_branch_probability));\n }\n \n void\n ix86_expand_setcc (enum rtx_code code, rtx dest)\n {\n-  rtx ret, tmp, tmpreg, equiv;\n-  rtx second_test, bypass_test;\n+  rtx ret;\n \n   gcc_assert (GET_MODE (dest) == QImode);\n \n-  ret = ix86_expand_compare (code, &second_test, &bypass_test);\n+  ret = ix86_expand_compare (code);\n   PUT_MODE (ret, QImode);\n-\n-  tmp = dest;\n-  tmpreg = dest;\n-\n-  emit_insn (gen_rtx_SET (VOIDmode, tmp, ret));\n-  if (bypass_test || second_test)\n-    {\n-      rtx test = second_test;\n-      int bypass = 0;\n-      rtx tmp2 = gen_reg_rtx (QImode);\n-      if (bypass_test)\n-\t{\n-\t  gcc_assert (!second_test);\n-\t  test = bypass_test;\n-\t  bypass = 1;\n-\t  PUT_CODE (test, reverse_condition_maybe_unordered (GET_CODE (test)));\n-\t}\n-      PUT_MODE (test, QImode);\n-      emit_insn (gen_rtx_SET (VOIDmode, tmp2, test));\n-\n-      if (bypass)\n-\temit_insn (gen_andqi3 (tmp, tmpreg, tmp2));\n-      else\n-\temit_insn (gen_iorqi3 (tmp, tmpreg, tmp2));\n-    }\n-\n-  /* Attach a REG_EQUAL note describing the comparison result.  */\n-  if (ix86_compare_op0 && ix86_compare_op1)\n-    {\n-      equiv = simplify_gen_relational (code, QImode,\n-\t\t\t\t       GET_MODE (ix86_compare_op0),\n-\t\t\t\t       ix86_compare_op0, ix86_compare_op1);\n-      set_unique_reg_note (get_last_insn (), REG_EQUAL, equiv);\n-    }\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, ret));\n }\n \n /* Expand comparison setting or clearing carry flag.  Return true when\n@@ -15315,7 +15086,6 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \n   if (SCALAR_FLOAT_MODE_P (mode))\n     {\n-      rtx second_test = NULL, bypass_test = NULL;\n       rtx compare_op, compare_seq;\n \n       gcc_assert (!DECIMAL_FLOAT_MODE_P (mode));\n@@ -15341,14 +15111,10 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \t we decide to expand comparison using arithmetic that is not\n \t too common scenario.  */\n       start_sequence ();\n-      compare_op = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n-\t\t\t\t\t   &second_test, &bypass_test);\n+      compare_op = ix86_expand_fp_compare (code, op0, op1, NULL_RTX);\n       compare_seq = get_insns ();\n       end_sequence ();\n \n-      if (second_test || bypass_test)\n-\treturn false;\n-\n       if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode\n \t  || GET_MODE (XEXP (compare_op, 0)) == CCFPUmode)\n         code = ix86_fp_compare_code_to_integer (GET_CODE (compare_op));\n@@ -15431,7 +15197,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n     }\n   ix86_compare_op0 = op0;\n   ix86_compare_op1 = op1;\n-  *pop = ix86_expand_compare (code, NULL, NULL);\n+  *pop = ix86_expand_compare (code);\n   gcc_assert (GET_CODE (*pop) == LTU || GET_CODE (*pop) == GEU);\n   return true;\n }\n@@ -15441,14 +15207,13 @@ ix86_expand_int_movcc (rtx operands[])\n {\n   enum rtx_code code = GET_CODE (operands[1]), compare_code;\n   rtx compare_seq, compare_op;\n-  rtx second_test, bypass_test;\n   enum machine_mode mode = GET_MODE (operands[0]);\n   bool sign_bit_compare_p = false;;\n \n   start_sequence ();\n   ix86_compare_op0 = XEXP (operands[1], 0);\n   ix86_compare_op1 = XEXP (operands[1], 1);\n-  compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n+  compare_op = ix86_expand_compare (code);\n   compare_seq = get_insns ();\n   end_sequence ();\n \n@@ -15920,19 +15685,6 @@ ix86_expand_int_movcc (rtx operands[])\n   if (! nonimmediate_operand (operands[3], mode))\n     operands[3] = force_reg (mode, operands[3]);\n \n-  if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n-    {\n-      rtx tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, operands[3]);\n-      operands[3] = tmp;\n-    }\n-  if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n-    {\n-      rtx tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, operands[2]);\n-      operands[2] = tmp;\n-    }\n-\n   if (! register_operand (operands[2], VOIDmode)\n       && (mode == QImode\n           || ! register_operand (operands[3], VOIDmode)))\n@@ -15947,18 +15699,6 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t\t  gen_rtx_IF_THEN_ELSE (mode,\n \t\t\t\t\t\tcompare_op, operands[2],\n \t\t\t\t\t\toperands[3])));\n-  if (bypass_test)\n-    emit_insn (gen_rtx_SET (VOIDmode, copy_rtx (operands[0]),\n-\t\t\t    gen_rtx_IF_THEN_ELSE (mode,\n-\t\t\t\t  bypass_test,\n-\t\t\t\t  copy_rtx (operands[3]),\n-\t\t\t\t  copy_rtx (operands[0]))));\n-  if (second_test)\n-    emit_insn (gen_rtx_SET (VOIDmode, copy_rtx (operands[0]),\n-\t\t\t    gen_rtx_IF_THEN_ELSE (mode,\n-\t\t\t\t  second_test,\n-\t\t\t\t  copy_rtx (operands[2]),\n-\t\t\t\t  copy_rtx (operands[0]))));\n \n   return 1; /* DONE */\n }\n@@ -16163,7 +15903,7 @@ ix86_expand_fp_movcc (rtx operands[])\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx tmp, compare_op, second_test, bypass_test;\n+  rtx tmp, compare_op;\n \n   ix86_compare_op0 = XEXP (operands[1], 0);\n   ix86_compare_op1 = XEXP (operands[1], 1);\n@@ -16200,45 +15940,20 @@ ix86_expand_fp_movcc (rtx operands[])\n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n \n-  compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n-\n-  /* The floating point conditional move instructions don't directly\n-     support signed integer comparisons.  */\n-\n+  compare_op = ix86_expand_compare (code);\n   if (!fcmov_comparison_operator (compare_op, VOIDmode))\n     {\n-      gcc_assert (!second_test && !bypass_test);\n       tmp = gen_reg_rtx (QImode);\n       ix86_expand_setcc (code, tmp);\n       code = NE;\n       ix86_compare_op0 = tmp;\n       ix86_compare_op1 = const0_rtx;\n-      compare_op = ix86_expand_compare (code,  &second_test, &bypass_test);\n-    }\n-  if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n-    {\n-      tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, operands[3]);\n-      operands[3] = tmp;\n-    }\n-  if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n-    {\n-      tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, operands[2]);\n-      operands[2] = tmp;\n+      compare_op = ix86_expand_compare (code);\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (mode, compare_op,\n \t\t\t\t\t\toperands[2], operands[3])));\n-  if (bypass_test)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (mode, bypass_test,\n-\t\t\t\t\t\t  operands[3], operands[0])));\n-  if (second_test)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (mode, second_test,\n-\t\t\t\t\t\t  operands[2], operands[0])));\n \n   return 1;\n }"}, {"sha": "d762c29df94f00d1b2a1d54fee2044a2936b78e5", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -2308,6 +2308,12 @@ extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];\n \n extern rtx ix86_compare_op0;\t/* operand 0 for comparisons */\n extern rtx ix86_compare_op1;\t/* operand 1 for comparisons */\n+\n+enum ix86_fpcmp_strategy {\n+  IX86_FPCMP_SAHF,\n+  IX86_FPCMP_COMI,\n+  IX86_FPCMP_ARITH\n+};\n \f\n /* To properly truncate FP values into integers, we need to set i387 control\n    word.  We can't emit proper mode switching code before reload, as spills"}, {"sha": "33ff7a5fd76ce2012195dbfc161f999e5a6056f3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 23, "deletions": 118, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -1222,7 +1222,7 @@\n \t(compare:CC (match_operand:XF 1 \"nonmemory_operand\" \"\")\n \t\t    (match_operand:XF 2 \"nonmemory_operand\" \"\")))\n    (set (pc) (if_then_else\n-              (match_operator 0 \"comparison_operator\"\n+              (match_operator 0 \"ix86_fp_comparison_operator\"\n                [(reg:CC FLAGS_REG)\n                 (const_int 0)])\n               (label_ref (match_operand 3 \"\" \"\"))\n@@ -1240,7 +1240,7 @@\n \t(compare:CC (match_operand:XF 2 \"nonmemory_operand\" \"\")\n \t\t    (match_operand:XF 3 \"nonmemory_operand\" \"\")))\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n-              (match_operator 1 \"comparison_operator\"\n+              (match_operator 1 \"ix86_fp_comparison_operator\"\n                [(reg:CC FLAGS_REG)\n                 (const_int 0)]))]\n   \"TARGET_80387\"\n@@ -1256,7 +1256,7 @@\n \t(compare:CC (match_operand:MODEF 1 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:MODEF 2 \"cmp_fp_expander_operand\" \"\")))\n    (set (pc) (if_then_else\n-              (match_operator 0 \"comparison_operator\"\n+              (match_operator 0 \"ix86_fp_comparison_operator\"\n                [(reg:CC FLAGS_REG)\n                 (const_int 0)])\n               (label_ref (match_operand 3 \"\" \"\"))\n@@ -1274,7 +1274,7 @@\n \t(compare:CC (match_operand:MODEF 2 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:MODEF 3 \"cmp_fp_expander_operand\" \"\")))\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n-              (match_operator 1 \"comparison_operator\"\n+              (match_operator 1 \"ix86_fp_comparison_operator\"\n                [(reg:CC FLAGS_REG)\n                 (const_int 0)]))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n@@ -15131,103 +15131,12 @@\n \t\t      (pc)))]\n   \"PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));\")\n \n-;; Define combination compare-and-branch fp compare instructions to use\n-;; during early optimization.  Splitting the operation apart early makes\n-;; for bad code when we want to reverse the operation.\n-\n-(define_insn \"*fp_jcc_1_mixed\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f,x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f,xm\")])\n-\t  (label_ref (match_operand 3 \"\" \"\"))\n-\t  (pc)))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_MIX_SSE_I387\n-   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n-\n-(define_insn \"*fp_jcc_1_sse\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n-\t  (label_ref (match_operand 3 \"\" \"\"))\n-\t  (pc)))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_SSE_MATH\n-   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n-\n-(define_insn \"*fp_jcc_1_387\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n-\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n-\t  (label_ref (match_operand 3 \"\" \"\"))\n-\t  (pc)))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && TARGET_CMOVE\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n-\n-(define_insn \"*fp_jcc_2_mixed\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f,x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f,xm\")])\n-\t  (pc)\n-\t  (label_ref (match_operand 3 \"\" \"\"))))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_MIX_SSE_I387\n-   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n-\n-(define_insn \"*fp_jcc_2_sse\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n-\t  (pc)\n-\t  (label_ref (match_operand 3 \"\" \"\"))))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_SSE_MATH\n-   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n-\n-(define_insn \"*fp_jcc_2_387\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n-\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n-\t  (pc)\n-\t  (label_ref (match_operand 3 \"\" \"\"))))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))]\n-  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && TARGET_CMOVE\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n-  \"#\")\n+;; Define combination compare-and-branch fp compare instructions to help\n+;; combine.\n \n (define_insn \"*fp_jcc_3_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n@@ -15238,15 +15147,14 @@\n   \"TARGET_80387\n    && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n \t\t      operands[1], operands[2]) == CCFPmode\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n (define_insn \"*fp_jcc_4_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n \t  (pc)\n@@ -15257,15 +15165,14 @@\n   \"TARGET_80387\n    && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n \t\t      operands[1], operands[2]) == CCFPmode\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n (define_insn \"*fp_jcc_5_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"register_operand\" \"f\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n@@ -15275,12 +15182,12 @@\n    (clobber (match_scratch:HI 4 \"=a\"))]\n   \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n (define_insn \"*fp_jcc_6_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"register_operand\" \"f\")])\n \t  (pc)\n@@ -15290,12 +15197,12 @@\n    (clobber (match_scratch:HI 4 \"=a\"))]\n   \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n (define_insn \"*fp_jcc_7_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"const0_operand\" \"\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n@@ -15305,10 +15212,9 @@\n    (clobber (match_scratch:HI 4 \"=a\"))]\n   \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n \t\t      operands[1], operands[2]) == CCFPmode\n-   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n ;; The order of operands in *fp_jcc_8_387 is forced by combine in\n@@ -15318,7 +15224,7 @@\n \n (define_insn \"*fp_jcc_8<mode>_387\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operator 1 \"float_operator\"\n \t\t\t   [(match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\")])\n \t\t\t   (match_operand 3 \"register_operand\" \"f,f\")])\n@@ -15330,14 +15236,13 @@\n   \"X87_FLOAT_MODE_P (GET_MODE (operands[3]))\n    && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\n    && GET_MODE (operands[1]) == GET_MODE (operands[3])\n-   && !ix86_use_fcomi_compare (swap_condition (GET_CODE (operands[0])))\n    && ix86_fp_compare_mode (swap_condition (GET_CODE (operands[0]))) == CCFPmode\n-   && ix86_fp_jump_nontrivial_p (swap_condition (GET_CODE (operands[0])))\"\n+   && !TARGET_CMOVE\"\n   \"#\")\n \n (define_split\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"\")\n \t\t\t (match_operand 2 \"nonimmediate_operand\" \"\")])\n \t  (match_operand 3 \"\" \"\")\n@@ -15354,7 +15259,7 @@\n \n (define_split\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"\")\n \t\t\t (match_operand 2 \"general_operand\" \"\")])\n \t  (match_operand 3 \"\" \"\")\n@@ -15372,7 +15277,7 @@\n \n (define_split\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operator 1 \"float_operator\"\n \t\t\t   [(match_operand:X87MODEI12 2 \"memory_operand\" \"\")])\n \t\t\t   (match_operand 3 \"register_operand\" \"\")])\n@@ -15394,7 +15299,7 @@\n ;; %%% Kill this when reload knows how to do it.\n (define_split\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ix86_fp_comparison_operator\"\n \t\t\t[(match_operator 1 \"float_operator\"\n \t\t\t   [(match_operand:X87MODEI12 2 \"register_operand\" \"\")])\n \t\t\t   (match_operand 3 \"register_operand\" \"\")])\n@@ -20657,7 +20562,7 @@\n (define_expand \"mov<mode>cc\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"\")\n \t(if_then_else:X87MODEF\n-\t  (match_operand 1 \"comparison_operator\" \"\")\n+\t  (match_operand 1 \"ix86_fp_comparison_operator\" \"\")\n \t  (match_operand:X87MODEF 2 \"register_operand\" \"\")\n \t  (match_operand:X87MODEF 3 \"register_operand\" \"\")))]\n   \"(TARGET_80387 && TARGET_CMOVE)"}, {"sha": "196599bbe2142f5615934144bb6818d5cedc58cc", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0948ccb243a5b2244bef375addc6f1a4b3a2f526/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=0948ccb243a5b2244bef375addc6f1a4b3a2f526", "patch": "@@ -952,9 +952,7 @@\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)\n     {\n-      enum rtx_code second_code, bypass_code;\n-      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n+      if (!ix86_trivial_fp_comparison_operator (op, mode))\n \treturn 0;\n       code = ix86_fp_compare_code_to_integer (code);\n     }\n@@ -1014,11 +1012,8 @@\n   enum rtx_code code = GET_CODE (op);\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)\n-    {\n-      enum rtx_code second_code, bypass_code;\n-      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      return (bypass_code == UNKNOWN && second_code == UNKNOWN);\n-    }\n+    return ix86_trivial_fp_comparison_operator (op, mode);\n+\n   switch (code)\n     {\n     case EQ: case NE:\n@@ -1059,9 +1054,7 @@\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)\n     {\n-      enum rtx_code second_code, bypass_code;\n-      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n+      if (!ix86_trivial_fp_comparison_operator (op, mode))\n \treturn 0;\n       code = ix86_fp_compare_code_to_integer (code);\n     }\n@@ -1073,6 +1066,19 @@\n   return code == LTU;\n })\n \n+;; Return 1 if this comparison only requires testing one flag bit.\n+(define_predicate \"ix86_trivial_fp_comparison_operator\"\n+  (match_code \"gt,ge,unlt,unle,uneq,ltgt,ordered,unordered\"))\n+\n+;; Return 1 if we know how to do this comparison.  Others require\n+;; testing more than one flag bit, and we let the generic middle-end\n+;; code do that.\n+(define_predicate \"ix86_fp_comparison_operator\"\n+  (if_then_else (match_test \"ix86_fp_comparison_strategy (GET_CODE (op))\n+                             == IX86_FPCMP_ARITH\")\n+               (match_operand 0 \"comparison_operator\")\n+               (match_operand 0 \"ix86_trivial_fp_comparison_operator\")))\n+\n ;; Nearly general operand, but accept any const_double, since we wish\n ;; to be able to drop them into memory rather than have them get pulled\n ;; into registers."}]}