{"sha": "30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmN2EzNzg2Y2IzODRiOTRjYWFmODdjYjIzMWYzZDhjOGY4YWNiYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-08-08T22:06:48Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-08-08T22:06:48Z"}, "message": "dbxout.c: Fix comment formatting.\n\n\t* dbxout.c: Fix comment formatting.\n\t* dependence.c: Likewise.\n\t* df.c: Likewise.\n\t* diagnostic.c: Likewise.\n\t* dominance.c: Likewise.\n\t* doprint.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarfout.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* except.c: Likewise.\n\t* explow.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* flow.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\nFrom-SVN: r44729", "tree": {"sha": "77dd07a40f045e97f39b2d3535ca6f4cc0a8e9a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77dd07a40f045e97f39b2d3535ca6f4cc0a8e9a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/comments", "author": null, "committer": null, "parents": [{"sha": "35e17f7e33498b9b9a152758dc621ee7638fdb52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e17f7e33498b9b9a152758dc621ee7638fdb52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e17f7e33498b9b9a152758dc621ee7638fdb52"}], "stats": {"total": 201, "additions": 110, "deletions": 91}, "files": [{"sha": "7ca9c06088166d17ca983cd77b8e0efdd9b189a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -1,3 +1,22 @@\n+2001-08-08  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* dbxout.c: Fix comment formatting.\n+\t* dependence.c: Likewise.\n+\t* df.c: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* doprint.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarfout.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* except.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* flow.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\n 2001-08-08  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* global.c (retry_global_alloc): Avoid shadowing allocno."}, {"sha": "18ea19694d789e420c35a2853b183e70c2bce5a5", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -2737,7 +2737,7 @@ dbxout_block (block, depth, args)\n \t  did_output = 1;\n #else\n \t  /* In dbx format, the syms of a block come before the N_LBRAC.\n-\t     If nothing is output, we don't need the N_LBRAC, either. */\n+\t     If nothing is output, we don't need the N_LBRAC, either.  */\n \t  did_output = 0;\n \t  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)\n \t    did_output = dbxout_syms (BLOCK_VARS (block));"}, {"sha": "9a54ac6251f09ff26c72de3051f010675e9b3b19", "filename": "gcc/dependence.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -79,7 +79,7 @@ enum complexity_type {ziv, strong_siv, weak_siv, weak_zero_siv,\n \n /* Given a def/use one can chase the next chain to follow the def/use\n    for that variable.  Alternately one can sequentially follow each\n-   element of def_use_chain. */\n+   element of def_use_chain.  */\n \n typedef struct def_use\n {\n@@ -104,7 +104,7 @@ typedef struct def_use\n /* Given a loop* one can chase the next_nest chain to follow the nested\n    loops for that loop.  Alternately one can sequentially follow each\n    element of loop_chain and check outer_loop to get all loops\n-   contained within a certain loop. */\n+   contained within a certain loop.  */\n \n typedef struct loop\n {\n@@ -118,11 +118,11 @@ typedef struct loop\n   enum loop_status_type status;\n   /* loop* for loop contained in this loop */\n   struct loop *next_nest;\n-  /* induction variables for this loop.  Currently only the index variable. */\n+  /* induction variables for this loop.  Currently only the index variable.  */\n   struct induction *ind;\n } loop;\n \n-/* Pointed to by loop. One per induction variable. */\n+/* Pointed to by loop. One per induction variable.  */\n \n typedef struct induction\n {\n@@ -134,11 +134,11 @@ typedef struct induction\n   int  low_bound;\n   /* upper bound */\n   int  high_bound;\n-  /* next induction variable for this loop.  Currently null. */\n+  /* next induction variable for this loop.  Currently null.  */\n   struct induction *next;\n } induction;\n \n-/* Pointed to by def/use.  One per dependence. */\n+/* Pointed to by def/use.  One per dependence.  */\n \n typedef struct dependence\n {\n@@ -163,11 +163,11 @@ typedef struct subscript\n   int offset;\n   /* our name */\n   const char *variable;\n-  /* next subscript term.  Currently null. */\n+  /* next subscript term.  Currently null.  */\n   struct subscript *next;\n } subscript;\n \n-/* Remember the destination the front end encountered. */\n+/* Remember the destination the front end encountered.  */\n \n static tree dest_to_remember;\n \n@@ -221,7 +221,7 @@ int have_dependence_p PARAMS ((rtx, rtx, enum direction_type[], int[]));\n void end_dependence_analysis PARAMS ((void));\n \n /* Build dependence chain 'dep_chain', which is used by have_dependence_p,\n-   for the function given by EXP. */\n+   for the function given by EXP.  */\n \n void\n init_dependence_analysis (exp)\n@@ -433,7 +433,7 @@ add_loop (loop_node, outer_loop, nloop)\n }\n \n /* Update LOOP_DEF if for loop's COND_NODE and INCR_NODE define an index that\n-   is a normalized induction variable. */\n+   is a normalized induction variable.  */\n \n static int\n find_induction_variable (init_node, cond_node, incr_node, loop_def)\n@@ -579,7 +579,7 @@ get_low_bound (node, variable)\n \n \n /* Return the ordinal subscript position for IND_VAR if it is an induction\n-   variable contained in OUTER_LOOP, otherwise return -1. */\n+   variable contained in OUTER_LOOP, otherwise return -1.  */\n \n static int\n have_induction_variable (outer_loop, ind_var)\n@@ -605,7 +605,7 @@ have_induction_variable (outer_loop, ind_var)\n   return -1;\n }\n \n-/* Chain the nodes of 'loop_chain'. */\n+/* Chain the nodes of 'loop_chain'.  */\n \n static void\n link_loops ()\n@@ -627,7 +627,7 @@ link_loops ()\n     }\n }\n \n-/* Check the dependence for each member of 'def_use_chain'. */\n+/* Check the dependence for each member of 'def_use_chain'.  */\n \n static void\n get_node_dependence ()\n@@ -645,7 +645,7 @@ get_node_dependence ()\n     }\n }\n \n-/* Check the dependence for definition DU. */\n+/* Check the dependence for definition DU.  */\n \n static void\n check_node_dependence (du)\n@@ -807,7 +807,7 @@ check_node_dependence (du)\n     }\n }\n \n-/* Get the COEFFICIENTS and offset for def/use DU. */\n+/* Get the COEFFICIENTS and offset for def/use DU.  */\n \n static int\n get_coefficients (du, coefficients)\n@@ -851,7 +851,7 @@ get_coefficients (du, coefficients)\n   return array_count;\n }\n \n-/* Get the COEFFICIENTS and offset for NODE having TYPE and defined in DU. */\n+/* Get the COEFFICIENTS and offset for NODE having TYPE and defined in DU.  */\n \n static int\n get_one_coefficient (node, coefficients, du, type)\n@@ -940,7 +940,7 @@ get_one_coefficient (node, coefficients, du, type)\n   return 0;\n }\n \n-/* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0. */\n+/* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0.  */\n \n static void\n normalize_coefficients (coefficients, loop_ptr, count)\n@@ -1091,7 +1091,7 @@ siv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n   coef_diff = icoefficients[sub].offset - ocoefficients[sub].offset;\n   /* strong_siv requires equal coefficients.  weak_crossing_siv requires\n      coefficients to have equal absolute value.  weak_zero_siv uses the\n-     nonzero coefficient. */\n+     nonzero coefficient.  */\n \n   if (ocoefficients[sub].coefficient == INT_MIN)\n     coef = icoefficients[sub].coefficient;\n@@ -1180,7 +1180,7 @@ gcd_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n \t}\n     }\n   /* ?? gcd does not yield direction and distance.  Wolfe's direction\n-     vector hierarchy can be used to give this. */\n+     vector hierarchy can be used to give this.  */\n }     \n \n /* Find the gcd of X and Y using Euclid's algorithm */\n@@ -1263,7 +1263,7 @@ merge_dependencies (direction, distance, loop_count, subscript_count)\n     }\n }\n \n-/* Dump ARRAY_REF NODE. */\n+/* Dump ARRAY_REF NODE.  */\n \n static void\n dump_array_ref (node)\n@@ -1299,7 +1299,7 @@ dump_array_ref (node)\n     }\n }\n \n-/* Dump def/use DU. */\n+/* Dump def/use DU.  */\n \n #if 0\n static void\n@@ -1346,7 +1346,7 @@ dump_one_node (du, seen)\n     }\n }\n \n-/* Dump dependence info. */\n+/* Dump dependence info.  */\n \n static void\n dump_node_dependence (void)\n@@ -1373,7 +1373,7 @@ dump_node_dependence (void)\n \n /* Return the index into 'dep_chain' if there is a dependency for destination\n    dest_to_remember (set by remember_dest_for_dependence) and source node.\n-   Called by the front end, which adds the index onto a MEM rtx. */\n+   Called by the front end, which adds the index onto a MEM rtx.  */\n \n int\n search_dependence (node)\n@@ -1402,7 +1402,7 @@ search_dependence (node)\n   return 0;\n }\n \n-/* Remember a destination NODE for search_dependence. */\n+/* Remember a destination NODE for search_dependence.  */\n \n void\n remember_dest_for_dependence (node)\n@@ -1422,7 +1422,7 @@ remember_dest_for_dependence (node)\n #endif\n \n /* Return 1 along with the dependence DIRECTION and DISTANCE if there is a \n-   dependence from dest_rtx to src_rtx. */\n+   dependence from dest_rtx to src_rtx.  */\n \n int\n have_dependence_p (dest_rtx, src_rtx, direction, distance)\n@@ -1461,7 +1461,7 @@ have_dependence_p (dest_rtx, src_rtx, direction, distance)\n   return 0;\n }\n \n-/* Cleanup when dependency analysis is complete. */\n+/* Cleanup when dependency analysis is complete.  */\n \n void\n end_dependence_analysis ()"}, {"sha": "505ed7b2ec54a8b83799b8ef6118efcc62e6361d", "filename": "gcc/df.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -1176,7 +1176,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n       /* Catch the def of the register being modified.  */\n       df_ref_record (df, XEXP (x, 0), &XEXP (x, 0), bb, insn, DF_REF_REG_DEF);\n \n-      /* ... Fall through to handle uses ... */\n+      /* ... Fall through to handle uses ...  */\n \n     default:\n       break;\n@@ -1600,7 +1600,7 @@ df_ud_chain_create (df, blocks)\n \f\n \n /* Use depth first order, and the worklist, to figure out what block\n-   to look at next. */\n+   to look at next.  */\n \n static int\n df_visit_next (df, blocks)"}, {"sha": "0efcfd6b58b718fe879c93d863cb4a03f98c316b", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -58,7 +58,7 @@ Boston, MA 02111-1307, USA.  */\n #define diagnostic_args output_buffer_ptr_to_format_args (diagnostic_buffer)\n #define diagnostic_msg output_buffer_text_cursor (diagnostic_buffer)\n \n-/* Prototypes. */\n+/* Prototypes.  */\n static void diagnostic_finish PARAMS ((output_buffer *));\n static void output_do_verbatim PARAMS ((output_buffer *,\n                                         const char *, va_list *));\n@@ -1125,7 +1125,7 @@ pedwarn_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n   va_end (ap);\n }\n \n-/* Same as above but within the context FILE and LINE. */\n+/* Same as above but within the context FILE and LINE.  */\n \n void\n pedwarn_with_file_and_line VPARAMS ((const char *file, int line,"}, {"sha": "3c35268dc5cbf0a860837c9b017c8443072cec44", "filename": "gcc/dominance.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -95,7 +95,7 @@ struct dom_info\n      is true for every basic block bb, but not the opposite.  */\n   basic_block *dfs_to_bb;\n \n-  /* This is the next free DFS number when creating the DFS tree or forest. */\n+  /* This is the next free DFS number when creating the DFS tree or forest.  */\n   unsigned int dfsnum;\n   /* The number of nodes in the DFS tree (==dfsnum-1).  */\n   unsigned int nodes;\n@@ -193,7 +193,7 @@ calc_dfs_tree_nonrec (di, bb, reverse)\n      basic_block bb;\n      enum cdi_direction reverse;\n {\n-  /* We never call this with bb==EXIT_BLOCK_PTR (ENTRY_BLOCK_PTR if REVERSE). */\n+  /* We never call this with bb==EXIT_BLOCK_PTR (ENTRY_BLOCK_PTR if REVERSE).  */\n   /* We call this _only_ if bb is not already visited.  */\n   edge e;\n   TBB child_i, my_i = 0;"}, {"sha": "114dcb7f77e22114f5ecf58be69c7e6044f3c966", "filename": "gcc/doprint.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdoprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdoprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoprint.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -20,16 +20,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #undef _doprnt\n \n-#ifdef TEST /* Make sure to use the internal one. */\n+#ifdef TEST /* Make sure to use the internal one.  */\n #define _doprnt my_doprnt\n #endif\n \n #define COPY_VA_INT \\\n   do { \\\n \t const int value = abs (va_arg (ap, int)); \\\n \t char buf[32]; \\\n-\t ptr++; /* Go past the asterisk. */ \\\n-\t *sptr = '\\0'; /* NULL terminate sptr. */ \\\n+\t ptr++; /* Go past the asterisk.  */ \\\n+\t *sptr = '\\0'; /* NULL terminate sptr.  */ \\\n \t sprintf(buf, \"%d\", value); \\\n \t strcat(sptr, buf); \\\n \t while (*sptr) sptr++; \\\n@@ -47,8 +47,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n   do { \\\n \tint result; \\\n \tTYPE value = va_arg (ap, TYPE); \\\n-\t*sptr++ = *ptr++; /* Copy the type specifier. */ \\\n-\t*sptr = '\\0'; /* NULL terminate sptr. */ \\\n+\t*sptr++ = *ptr++; /* Copy the type specifier.  */ \\\n+\t*sptr = '\\0'; /* NULL terminate sptr.  */ \\\n \tresult = fprintf(stream, specifier, value); \\\n \tif (result == -1) \\\n \t  return -1; \\\n@@ -71,31 +71,31 @@ _doprnt (format, ap, stream)\n   \n   while (*ptr != '\\0')\n     {\n-      if (*ptr != '%') /* While we have regular characters, print them. */\n+      if (*ptr != '%') /* While we have regular characters, print them.  */\n \tPRINT_CHAR(*ptr);\n       else /* We got a format specifier! */\n \t{\n \t  char * sptr = specifier;\n \t  int wide_width = 0, short_width = 0;\n \t  \n-\t  *sptr++ = *ptr++; /* Copy the % and move forward. */\n+\t  *sptr++ = *ptr++; /* Copy the % and move forward.  */\n \n-\t  while (strchr (\"-+ #0\", *ptr)) /* Move past flags. */\n+\t  while (strchr (\"-+ #0\", *ptr)) /* Move past flags.  */\n \t    *sptr++ = *ptr++;\n \n \t  if (*ptr == '*')\n \t    COPY_VA_INT;\n \t  else\n-\t    while (ISDIGIT(*ptr)) /* Handle explicit numeric value. */\n+\t    while (ISDIGIT(*ptr)) /* Handle explicit numeric value.  */\n \t      *sptr++ = *ptr++;\n \t  \n \t  if (*ptr == '.')\n \t    {\n-\t      *sptr++ = *ptr++; /* Copy and go past the period. */\n+\t      *sptr++ = *ptr++; /* Copy and go past the period.  */\n \t      if (*ptr == '*')\n \t\tCOPY_VA_INT;\n \t      else\n-\t\twhile (ISDIGIT(*ptr)) /* Handle explicit numeric value. */\n+\t\twhile (ISDIGIT(*ptr)) /* Handle explicit numeric value.  */\n \t\t  *sptr++ = *ptr++;\n \t    }\n \t  while (strchr (\"hlL\", *ptr))\n@@ -129,7 +129,7 @@ _doprnt (format, ap, stream)\n \t      {\n \t\t/* Short values are promoted to int, so just copy it\n                    as an int and trust the C library printf to cast it\n-                   to the right width. */\n+                   to the right width.  */\n \t\tif (short_width)\n \t\t  PRINT_TYPE(int);\n \t\telse\n@@ -147,7 +147,7 @@ _doprnt (format, ap, stream)\n #if defined(__GNUC__) || defined(HAVE_LONG_LONG)\n \t\t\tPRINT_TYPE(long long);\n #else\n-\t\t\tPRINT_TYPE(long); /* Fake it and hope for the best. */\n+\t\t\tPRINT_TYPE(long); /* Fake it and hope for the best.  */\n #endif\n \t\t\tbreak;\n \t\t      } /* End of switch (wide_width) */\n@@ -167,7 +167,7 @@ _doprnt (format, ap, stream)\n #if defined(__GNUC__) || defined(HAVE_LONG_DOUBLE)\n \t\t    PRINT_TYPE(long double);\n #else\n-\t\t    PRINT_TYPE(double); /* Fake it and hope for the best. */\n+\t\t    PRINT_TYPE(double); /* Fake it and hope for the best.  */\n #endif\n \t\t  }\n \t      }"}, {"sha": "f940dda4ca8197ad99aef2137280e22d354dfa9f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -877,7 +877,7 @@ initial_return_save (rtl)\n }\n \n /* Given a SET, calculate the amount of stack adjustment it\n-   contains. */\n+   contains.  */\n \n static long\n stack_adjust_offset (pattern)\n@@ -981,7 +981,7 @@ dwarf2out_stack_adjust (insn)\n \t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n       /* There may be stack adjustments inside compound insns.  Search\n-         for them. */\n+         for them.  */\n       int j;\n \n       offset = 0;\n@@ -2201,7 +2201,7 @@ dw_loc_descr_node;\n \n /* Location lists are ranges + location descriptions for that range,\n    so you can track variables that are in different places over\n-   their entire life. */\n+   their entire life.  */\n typedef struct dw_loc_list_struct\n {\n   dw_loc_list_ref dw_loc_next;\n@@ -6030,7 +6030,7 @@ output_die_symbol (die)\n /* Return a new location list, given the begin and end range, and the\n    expression. gensym tells us whether to generate a new internal\n    symbol for this location list node, which is done for the head of\n-   the list only. */ \n+   the list only.  */ \n static inline dw_loc_list_ref\n new_loc_list (expr, begin, end, section, gensym)\n      register dw_loc_descr_ref expr;\n@@ -6061,7 +6061,7 @@ add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n {\n   register dw_loc_list_ref *d;\n   \n-  /* Find the end of the chain. */\n+  /* Find the end of the chain.  */\n   for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n     ;\n   /* Add a new location list node to the list */\n@@ -11543,7 +11543,7 @@ dwarf2out_source_line (line, filename)\n     }\n }\n \n-/* Record the beginning of a new source file. */\n+/* Record the beginning of a new source file.  */\n \n static void\n dwarf2out_start_source_file (lineno, filename)\n@@ -11833,7 +11833,7 @@ dwarf2out_finish (input_filename)\n   /* Output location list section if necessary.  */\n   if (have_location_lists)\n     {\n-      /* Output the location lists info. */\n+      /* Output the location lists info.  */\n       named_section_flags (DEBUG_LOC_SECTION, SECTION_DEBUG, 1);\n       output_location_lists (die);\n       have_location_lists = 0;\n@@ -11846,7 +11846,7 @@ dwarf2out_finish (input_filename)\n       output_ranges ();\n     }\n \n-  /* Have to end the primary source file. */\n+  /* Have to end the primary source file.  */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     { \n       named_section_flags (DEBUG_MACINFO_SECTION, SECTION_DEBUG, 1);"}, {"sha": "057dee29d8246956cc6643aafcb232722e2484d2", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -2382,7 +2382,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \t   comprehend that a missing upper bound specification in a\n \t   array type used for a storage class `auto' local array variable\n \t   indicates that the upper bound is both unknown (at compile-\n-\t   time) and unknowable (at run-time) due to optimization. */\n+\t   time) and unknowable (at run-time) due to optimization.  */\n \n \tif (! optimize)\n \t  {\n@@ -2584,7 +2584,7 @@ field_byte_offset (decl)\n \n      The value we deduce is then used (by the callers of this routine) to\n      generate AT_location and AT_bit_offset attributes for fields (both\n-     bit-fields and, in the case of AT_location, regular fields as well). */\n+     bit-fields and, in the case of AT_location, regular fields as well).  */\n \n   /* Figure out the bit-distance from the start of the structure to the\n      \"deepest\" bit of the bit-field.  */"}, {"sha": "c3ba4525a3eeb88b09f1da701d102b6fa8c371bc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -379,7 +379,7 @@ gen_rtx_SUBREG (mode, reg, offset)\n \n /* Generate a SUBREG representing the least-significant part\n  * of REG if MODE is smaller than mode of REG, otherwise\n- * paradoxical SUBREG. */\n+ * paradoxical SUBREG.  */\n rtx\n gen_lowpart_SUBREG (mode, reg)\n      enum machine_mode mode;\n@@ -1483,12 +1483,12 @@ operand_subword (op, offset, validate_address, mode)\n   if (mode == VOIDmode)\n     abort ();\n \n-  /* If OP is narrower than a word, fail. */\n+  /* If OP is narrower than a word, fail.  */\n   if (mode != BLKmode\n       && (GET_MODE_SIZE (mode) < UNITS_PER_WORD))\n     return 0;\n \n-  /* If we want a word outside OP, return zero. */\n+  /* If we want a word outside OP, return zero.  */\n   if (mode != BLKmode\n       && (offset + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode))\n     return const0_rtx;\n@@ -1886,7 +1886,7 @@ unshare_all_decls (blk)\n }\n \n /* Go through all virtual stack slots of a function and mark them as\n-   not shared. */\n+   not shared.  */\n static void\n reset_used_decls (blk)\n      tree blk;\n@@ -3606,7 +3606,7 @@ force_next_line_note ()\n }\n \n /* Place a note of KIND on insn INSN with DATUM as the datum. If a\n-   note of this type already exists, remove it first. */\n+   note of this type already exists, remove it first.  */\n \n void\n set_unique_reg_note (insn, kind, datum)\n@@ -3867,7 +3867,7 @@ gen_sequence ()\n   if (len == 1\n       && ! RTX_FRAME_RELATED_P (first_insn)\n       && GET_CODE (first_insn) == INSN\n-      /* Don't throw away any reg notes. */\n+      /* Don't throw away any reg notes.  */\n       && REG_NOTES (first_insn) == 0)\n     return PATTERN (first_insn);\n "}, {"sha": "3058e10f8f11fbdec7d592a07341449188ba95ab", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -2865,7 +2865,7 @@ void\n expand_builtin_unwind_init ()\n {\n   /* Set this so all the registers get saved in our frame; we need to be\n-     able to copy the saved values for any registers from frames we unwind. */\n+     able to copy the saved values for any registers from frames we unwind.  */\n   current_function_has_nonlocal_label = 1;\n \n #ifdef SETUP_FRAME_ADDRESSES"}, {"sha": "9f2357aff443aea244b99b0e5c5de1318fd664fc", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -678,7 +678,7 @@ set_mem_attributes (ref, t, objectp)\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n \n   /* If we are making an object of this type, we know that it is a scalar if\n-     the type is not an aggregate. */\n+     the type is not an aggregate.  */\n   if (objectp && ! AGGREGATE_TYPE_P (type))\n     MEM_SCALAR_P (ref) = 1;\n \n@@ -1663,7 +1663,7 @@ probe_stack_range (first, size)\n    otherwise 0.\n    OUTGOING is 1 if on a machine with register windows this function\n    should return the register in which the function will put its result\n-   and 0 otherwise. */\n+   and 0 otherwise.  */\n \n rtx\n hard_function_value (valtype, func, outgoing)"}, {"sha": "68efa79a85141d76a7a17ad5443014595ceef91f", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -4557,7 +4557,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \n       /* Note that ABS doesn't yield a positive number for INT_MIN, but \n \t that is compensated by the subsequent overflow when subtracting \n-\t one / negating. */\n+\t one / negating.  */\n \n       if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, abs_optab, op0, subtarget, 1);"}, {"sha": "11aa3dce538e4d1311febd3cb92be035076816b6", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -6647,7 +6647,7 @@ expand_expr (exp, target, tmode, modifier)\n     case LABELED_BLOCK_EXPR:\n       if (LABELED_BLOCK_BODY (exp))\n \texpand_expr_stmt (LABELED_BLOCK_BODY (exp));\n-      /* Should perhaps use expand_label, but this is simpler and safer. */\n+      /* Should perhaps use expand_label, but this is simpler and safer.  */\n       do_pending_stack_adjust ();\n       emit_label (label_rtx (LABELED_BLOCK_LABEL (exp)));\n       return const0_rtx;"}, {"sha": "f7d32196a86e6de1a636d02ed34a01a31fc306ae", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -3822,7 +3822,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (e1->flags & EDGE_COMPLEX)\n     return false;\n \n-  /* Look for the common insn sequence, part the first ... */\n+  /* Look for the common insn sequence, part the first ...  */\n   if (!outgoing_edges_match (src1, src2))\n     return false;\n \n@@ -5802,7 +5802,7 @@ insn_dead_p (pbi, x, call_ok, notes)\n \t     If so, this memory write is dead (remember, we're walking\n \t     backwards from the end of the block to the start).  Since\n \t     rtx_equal_p does not check the alias set or flags, we also\n-\t     must have the potential for them to conflict (anti_dependence). */\n+\t     must have the potential for them to conflict (anti_dependence).  */\n \t  for (temp = pbi->mem_set_list; temp != 0; temp = XEXP (temp, 1))\n \t    if (anti_dependence (r, XEXP (temp, 0)))\n \t      {\n@@ -8385,7 +8385,7 @@ verify_flow_info ()\n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n-      /* Check correctness of edge lists. */\n+      /* Check correctness of edge lists.  */\n       edge e;\n       int has_fallthru = 0;\n \n@@ -9676,7 +9676,7 @@ flow_loop_pre_header_scan (loop)\n \n       /* Count number of edges along trace from loop header to\n \t root of pre-header extended basic block.  Usually this is\n-\t only one or two edges. */\n+\t only one or two edges.  */\n       num++;\n       while (ebb->pred->src != ENTRY_BLOCK_PTR && ! ebb->pred->pred_next)\n \t{"}, {"sha": "5ffaf1057420f8be0cd52bcad4044eb6c8ce744c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -1354,7 +1354,7 @@ split_tree (in, code, conp, litp, negate_p)\n   *conp = 0;\n   *litp = 0;\n \n-  /* Strip any conversions that don't change the machine mode or signedness. */\n+  /* Strip any conversions that don't change the machine mode or signedness.  */\n   STRIP_SIGN_NOPS (in);\n \n   if (TREE_CODE (in) == INTEGER_CST || TREE_CODE (in) == REAL_CST)\n@@ -1385,7 +1385,7 @@ split_tree (in, code, conp, litp, negate_p)\n \t*conp = op1, neg_conp_p = neg1_p, op1 = 0;\n \n       /* If we haven't dealt with either operand, this is not a case we can\n-\t decompose.  Otherwise, VAR is either of the ones remaining, if any. */\n+\t decompose.  Otherwise, VAR is either of the ones remaining, if any.  */\n       if (op0 != 0 && op1 != 0)\n \tvar = in;\n       else if (op0 != 0)\n@@ -1546,7 +1546,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \t  break;\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case ROUND_DIV_EXPR:\n       if (int2h == 0 && int2l == 1)\n@@ -1579,7 +1579,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \t  break;\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case ROUND_MOD_EXPR:\n       overflow = div_and_round_double (code, uns,\n@@ -1745,11 +1745,11 @@ const_binop (code, arg1, arg2, notrunc)\n       args.code = code;\n \n       if (do_float_handler (const_binop_1, (PTR) &args))\n-\t/* Receive output from const_binop_1. */\n+\t/* Receive output from const_binop_1.  */\n \tt = args.t;\n       else\n \t{\n-\t  /* We got an exception from const_binop_1. */\n+\t  /* We got an exception from const_binop_1.  */\n \t  t = copy_node (arg1);\n \t  overflow = 1;\n \t}\n@@ -1980,9 +1980,9 @@ size_diffop (arg0, arg1)\n /* This structure is used to communicate arguments to fold_convert_1.  */\n struct fc_args\n {\n-  tree arg1;\t\t\t/* Input: value to convert. */\n-  tree type;\t\t\t/* Input: type to convert value to. */\n-  tree t;\t\t\t/* Ouput: result of conversion. */\n+  tree arg1;\t\t\t/* Input: value to convert.  */\n+  tree type;\t\t\t/* Input: type to convert value to.  */\n+  tree t;\t\t\t/* Ouput: result of conversion.  */\n };\n \n /* Function to convert floating-point constants, protected by floating\n@@ -2383,7 +2383,7 @@ operand_equal_p (arg0, arg1, only_const)\n \n     case 'r':\n       /* If either of the pointer (or reference) expressions we are dereferencing\n-\t contain a side effect, these cannot be equal. */\n+\t contain a side effect, these cannot be equal.  */\n       if (TREE_SIDE_EFFECTS (arg0)\n \t  || TREE_SIDE_EFFECTS (arg1))\n \treturn 0;\n@@ -3265,7 +3265,7 @@ range_binop (code, type, arg0, upper0_p, arg1, upper1_p)\n      the same. But, this is computer arithmetic, where numbers are finite.\n      We can therefore make the transformation of any unbounded range with\n      the value Z, Z being greater than any representable number. This permits\n-     us to treat unbounded ranges as equal. */\n+     us to treat unbounded ranges as equal.  */\n   sgn0 = arg0 != 0 ? 0 : (upper0_p ? 1 : -1);\n   sgn1 = arg1 != 0 ? 0 : (upper1_p ? 1 : -1);\n   switch (code)\n@@ -4552,7 +4552,7 @@ extract_muldiv (t, c, code, wide_type)\n \n       /* The last case is if we are a multiply.  In that case, we can\n \t apply the distributive law to commute the multiply and addition\n-\t if the multiplication of the constants doesn't overflow. */\n+\t if the multiplication of the constants doesn't overflow.  */\n       if (code == MULT_EXPR)\n \treturn fold (build (tcode, ctype, fold (build (code, ctype,\n \t\t\t\t\t\t       convert (ctype, op0),\n@@ -4570,7 +4570,7 @@ extract_muldiv (t, c, code, wide_type)\n \t  && integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n \treturn omit_one_operand (type, integer_zero_node, op0);\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case TRUNC_DIV_EXPR:  case CEIL_DIV_EXPR:  case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:  case EXACT_DIV_EXPR:\n@@ -5564,7 +5564,7 @@ fold (expr)\n \t     associate each group together, the constants with literals,\n \t     then the result with variables.  This increases the chances of\n \t     literals being recombined later and of generating relocatable\n-\t     expressions for the sum of a constant and literal. */\n+\t     expressions for the sum of a constant and literal.  */\n \t  var0 = split_tree (arg0, code, &con0, &lit0, 0);\n \t  var1 = split_tree (arg1, code, &con1, &lit1, code == MINUS_EXPR);\n \n@@ -5854,7 +5854,7 @@ fold (expr)\n \t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n \t\t\t\t\t  arg1, 0)))\n \t    return fold (build (MULT_EXPR, type, arg0, tem));\n-\t  /* Find the reciprocal if optimizing and the result is exact. */\n+\t  /* Find the reciprocal if optimizing and the result is exact.  */\n \t  else if (optimize)\n \t    {\n \t      REAL_VALUE_TYPE r;\n@@ -6045,7 +6045,7 @@ fold (expr)\n \t truth and/or operations and the transformation will still be\n \t valid.   Also note that we only care about order for the\n \t ANDIF and ORIF operators.  If B contains side effects, this\n-\t might change the truth-value of A. */\n+\t might change the truth-value of A.  */\n       if (TREE_CODE (arg0) == TREE_CODE (arg1)\n \t  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n \t      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n@@ -7342,7 +7342,7 @@ multiple_of_p (type, top, bottom)\n \t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (top, 0)))))\n \treturn 0;\n \n-      /* .. fall through ... */\n+      /* .. fall through ...  */\n \n     case SAVE_EXPR:\n       return multiple_of_p (type, TREE_OPERAND (top, 0), bottom);"}, {"sha": "f344cb53fdb70c06f73296eb27ae1c738e630851", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7a3786cb384b94caaf87cb231f3d8c8f8acbc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=30f7a3786cb384b94caaf87cb231f3d8c8f8acbc", "patch": "@@ -811,7 +811,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n      alias set for the memory.  */\n   set_mem_alias_set (p->slot, type ? get_alias_set (type) : 0);\n \n-  /* If a type is specified, set the relevant flags. */\n+  /* If a type is specified, set the relevant flags.  */\n   if (type != 0)\n     {\n       RTX_UNCHANGING_P (p->slot) = TYPE_READONLY (type);\n@@ -5703,7 +5703,7 @@ round_trampoline_addr (tramp)\n \n /* Given a trampoline address, round it then apply any\n    platform-specific adjustments so that the result can be used for a\n-   function call . */\n+   function call .  */\n \n static rtx\n adjust_trampoline_addr (tramp)"}]}