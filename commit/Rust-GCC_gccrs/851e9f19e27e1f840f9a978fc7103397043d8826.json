{"sha": "851e9f19e27e1f840f9a978fc7103397043d8826", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxZTlmMTllMjdlMWY4NDBmOWE5NzhmYzcxMDMzOTcwNDNkODgyNg==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T10:07:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T10:07:11Z"}, "message": "[multiple changes]\n\n2017-09-25  Justin Squirek  <squirek@adacore.com>\n\n\t* aspects.adb, bindgen.adb, clean.adb, erroutc.adb, exp_ch13.adb,\n\texp_dbug.adb, exp_unst.adb, exp_util.adb, frontend.adb, gnat1drv.adb,\n\tgnatdll.adb, gnatlink.adb, gnatls.adb, gnatname.adb, gnatxref.adb,\n\tgnatfind.adb, libgnat/a-cfhama.ads, libgnat/a-exetim__mingw.adb,\n\tlibgnat/a-strmap.adb, libgnat/a-teioed.adb, libgnat/g-alvety.ads,\n\tlibgnat/g-expect.adb, libgnat/g-regist.adb, libgnat/g-socket.adb,\n\tlibgnat/g-socthi__mingw.ads, libgnat/s-stausa.adb,\n\tlibgnat/s-tsmona__linux.adb, libgnat/s-tsmona__mingw.adb,\n\tlibgnarl/s-taenca.adb, libgnarl/s-tassta.adb, libgnarl/s-tarest.adb,\n\tlibgnarl/s-tpobop.adb, make.adb, makeusg.adb, namet.adb, output.ads,\n\tput_scos.adb, repinfo.adb, rtsfind.adb, scn.ads, sem_attr.adb,\n\tsem_aux.ads, sem_warn.ads, targparm.adb, xr_tabls.adb, xref_lib.adb:\n\tRemoval of ineffective use-clauses.\n\t* exp_ch9.adb (Is_Simple_Barrier_Name): Check for false positives with\n\tconstant folded barriers.\n\t* ghost.adb, sprint.adb, sem_ch10.adb, sem_warn.adb: Change access to\n\tSubtype_Marks and Names list in use-clause nodes to their new singular\n\tcounterparts (e.g. Subtype_Mark, Name).\n\t* par.adb, par-ch8.adb (Append_Use_Clause): Created to set\n\tPrev_Ids and More_Ids in use-clause nodes.\n\t(P_Use_Clause): Modify to take a list as a parameter.\n\t(P_Use_Package_Clause, P_Use_Type_Clause): Divide names and\n\tsubtype_marks within an aggregate use-clauses into individual clauses.\n\t* par-ch3.adb, par-ch10.adb, par-ch12.adb: Trivally modify call to\n\tP_Use_Clause to match its new behavior.\n\t* sem.adb (Analyze): Mark use clauses for non-overloaded entities.\n\t* sem_ch4.adb (Try_One_Interp): Add sanity check to handle previous\n\terrors.\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body,\n\tAnalyze_Subprogram_Body_Helper): Update use clause chain at the end of\n\tthe declarative region.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Update use clause chain\n\tafter analysis (Analyze_Package_Specification): Update use clause chain\n\twhen there is no body.\n\t* sem_ch8.ads, sem_ch8.adb (Analyze_Use_Package, Analyze_Use_Type): Add\n\tparameter to determine weither the installation of scopes should also\n\tpropagate on the use-clause \"chain\".\n\t(Mark_Use_Clauses): Created to traverse use-clause chains and determine\n\twhat constitutes a valid \"use\" of a clause.\n\t(Update_Use_Clause_Chain): Created to aggregate common machinary used\n\tto clean up use-clause chains (and warn on ineffectiveness) at the end\n\tof declaritive regions.\n\t* sem_ch8.adb (Analyze_Package_Name): Created to perform analysis on a\n\tpackage name from a use-package clause.\n\t(Analyze_Package_Name_List): Created to perform analysis on a list of\n\tpackage names (similar to Analyze_Package_Name).\n\t(Find_Most_Prev): Created to traverse to the beginning of a given\n\tuse-clause chain.\n\t(Most_Decendant_Use_Clause): Create to identify which clause from a\n\tgiven set is highest in scope (not always the most prev).\n\t(Use_One_Package, Use_One_Type): Major cleanup and reorganization to\n\thandle the new chaining algorithm, also many changes related to\n\tredundant clauses. A new parameter has also been added to force\n\tinstallation to handle certain cases.\n\t* sem_ch9.adb (Analyze_Entry_Body, Analyze_Protected_Body,\n\tAnalyze_Task_Body): Mark use clauses on relevant entities.\n\t* sem_ch10.adb, sem_ch10.ads (Install_Context_Clauses,\n\tInstall_Parents): Add parameter to determine weither the installation\n\tof scopes should also propagate on the use-clause \"chain\".\n\t* sem_ch12.adb (Inline_Instance_Body): Add flag in call to\n\tInstall_Context to avoid redundant chaining of use-clauses.\n\t* sem_ch13.adb: Minor reformatting.\n\t* sem_res.adb (Resolve): Mark use clauses on operators.\n\t(Resolve_Call, Resolve_Entity_Name): Mark use clauses on relevant\n\tentities.\n\t* sinfo.adb, sinfo.ads (Is_Effective_Use_Clause,\n\tSet_Is_Effective_Use_Clause): Add new flag to N_Use_Clause nodes to\n\trepresent any given clause's usage/reference/necessity.\n\t(Prev_Use_Clause, Set_Prev_Use_Clause): Add new field to N_Use_Clause\n\tnodes to allow loose chaining of redundant clauses.\n\t(Set_Used_Operations, Set_Subtype_Mark, Set_Prev_Ids, Set_Names,\n\tSet_More_Ids, Set_Name): Modify set procedure calls to reflect\n\treorganization in node fields.\n\t* types.ads (Source_File_Index): Adjust index bounds.\n\t(No_Access_To_Source_File): New constant.\n\n2017-09-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_One_Aspect): In ASIS mode make a full copy of\n\tthe expression to be used in the generated attribute specification\n\t(rather than relocating it) to avoid resolving a potentially malformed\n\ttree when the expression is resolved through an ASIS-specific call to\n\tResolve_Aspect_Expressions.  This manifests itself as a crash on a\n\tfunction with parameter associations.\n\nFrom-SVN: r253144", "tree": {"sha": "bbf6e9f5960f6e784986aa1c87d0fa80e3ccf36c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbf6e9f5960f6e784986aa1c87d0fa80e3ccf36c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/851e9f19e27e1f840f9a978fc7103397043d8826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851e9f19e27e1f840f9a978fc7103397043d8826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851e9f19e27e1f840f9a978fc7103397043d8826", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851e9f19e27e1f840f9a978fc7103397043d8826/comments", "author": null, "committer": null, "parents": [{"sha": "61b1489667e08d7b1ef6672682906072df7bc369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b1489667e08d7b1ef6672682906072df7bc369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b1489667e08d7b1ef6672682906072df7bc369"}], "stats": {"total": 2563, "additions": 1660, "deletions": 903}, "files": [{"sha": "2657531cf36630c6d8f1590426db9c82671519a1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1,3 +1,90 @@\n+2017-09-25  Justin Squirek  <squirek@adacore.com>\n+\n+\t* aspects.adb, bindgen.adb, clean.adb, erroutc.adb, exp_ch13.adb,\n+\texp_dbug.adb, exp_unst.adb, exp_util.adb, frontend.adb, gnat1drv.adb,\n+\tgnatdll.adb, gnatlink.adb, gnatls.adb, gnatname.adb, gnatxref.adb,\n+\tgnatfind.adb, libgnat/a-cfhama.ads, libgnat/a-exetim__mingw.adb,\n+\tlibgnat/a-strmap.adb, libgnat/a-teioed.adb, libgnat/g-alvety.ads,\n+\tlibgnat/g-expect.adb, libgnat/g-regist.adb, libgnat/g-socket.adb,\n+\tlibgnat/g-socthi__mingw.ads, libgnat/s-stausa.adb,\n+\tlibgnat/s-tsmona__linux.adb, libgnat/s-tsmona__mingw.adb,\n+\tlibgnarl/s-taenca.adb, libgnarl/s-tassta.adb, libgnarl/s-tarest.adb,\n+\tlibgnarl/s-tpobop.adb, make.adb, makeusg.adb, namet.adb, output.ads,\n+\tput_scos.adb, repinfo.adb, rtsfind.adb, scn.ads, sem_attr.adb,\n+\tsem_aux.ads, sem_warn.ads, targparm.adb, xr_tabls.adb, xref_lib.adb:\n+\tRemoval of ineffective use-clauses.\n+\t* exp_ch9.adb (Is_Simple_Barrier_Name): Check for false positives with\n+\tconstant folded barriers.\n+\t* ghost.adb, sprint.adb, sem_ch10.adb, sem_warn.adb: Change access to\n+\tSubtype_Marks and Names list in use-clause nodes to their new singular\n+\tcounterparts (e.g. Subtype_Mark, Name).\n+\t* par.adb, par-ch8.adb (Append_Use_Clause): Created to set\n+\tPrev_Ids and More_Ids in use-clause nodes.\n+\t(P_Use_Clause): Modify to take a list as a parameter.\n+\t(P_Use_Package_Clause, P_Use_Type_Clause): Divide names and\n+\tsubtype_marks within an aggregate use-clauses into individual clauses.\n+\t* par-ch3.adb, par-ch10.adb, par-ch12.adb: Trivally modify call to\n+\tP_Use_Clause to match its new behavior.\n+\t* sem.adb (Analyze): Mark use clauses for non-overloaded entities.\n+\t* sem_ch4.adb (Try_One_Interp): Add sanity check to handle previous\n+\terrors.\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body,\n+\tAnalyze_Subprogram_Body_Helper): Update use clause chain at the end of\n+\tthe declarative region.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Update use clause chain\n+\tafter analysis (Analyze_Package_Specification): Update use clause chain\n+\twhen there is no body.\n+\t* sem_ch8.ads, sem_ch8.adb (Analyze_Use_Package, Analyze_Use_Type): Add\n+\tparameter to determine weither the installation of scopes should also\n+\tpropagate on the use-clause \"chain\".\n+\t(Mark_Use_Clauses): Created to traverse use-clause chains and determine\n+\twhat constitutes a valid \"use\" of a clause.\n+\t(Update_Use_Clause_Chain): Created to aggregate common machinary used\n+\tto clean up use-clause chains (and warn on ineffectiveness) at the end\n+\tof declaritive regions.\n+\t* sem_ch8.adb (Analyze_Package_Name): Created to perform analysis on a\n+\tpackage name from a use-package clause.\n+\t(Analyze_Package_Name_List): Created to perform analysis on a list of\n+\tpackage names (similar to Analyze_Package_Name).\n+\t(Find_Most_Prev): Created to traverse to the beginning of a given\n+\tuse-clause chain.\n+\t(Most_Decendant_Use_Clause): Create to identify which clause from a\n+\tgiven set is highest in scope (not always the most prev).\n+\t(Use_One_Package, Use_One_Type): Major cleanup and reorganization to\n+\thandle the new chaining algorithm, also many changes related to\n+\tredundant clauses. A new parameter has also been added to force\n+\tinstallation to handle certain cases.\n+\t* sem_ch9.adb (Analyze_Entry_Body, Analyze_Protected_Body,\n+\tAnalyze_Task_Body): Mark use clauses on relevant entities.\n+\t* sem_ch10.adb, sem_ch10.ads (Install_Context_Clauses,\n+\tInstall_Parents): Add parameter to determine weither the installation\n+\tof scopes should also propagate on the use-clause \"chain\".\n+\t* sem_ch12.adb (Inline_Instance_Body): Add flag in call to\n+\tInstall_Context to avoid redundant chaining of use-clauses.\n+\t* sem_ch13.adb: Minor reformatting.\n+\t* sem_res.adb (Resolve): Mark use clauses on operators.\n+\t(Resolve_Call, Resolve_Entity_Name): Mark use clauses on relevant\n+\tentities.\n+\t* sinfo.adb, sinfo.ads (Is_Effective_Use_Clause,\n+\tSet_Is_Effective_Use_Clause): Add new flag to N_Use_Clause nodes to\n+\trepresent any given clause's usage/reference/necessity.\n+\t(Prev_Use_Clause, Set_Prev_Use_Clause): Add new field to N_Use_Clause\n+\tnodes to allow loose chaining of redundant clauses.\n+\t(Set_Used_Operations, Set_Subtype_Mark, Set_Prev_Ids, Set_Names,\n+\tSet_More_Ids, Set_Name): Modify set procedure calls to reflect\n+\treorganization in node fields.\n+\t* types.ads (Source_File_Index): Adjust index bounds.\n+\t(No_Access_To_Source_File): New constant.\n+\n+2017-09-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_One_Aspect): In ASIS mode make a full copy of\n+\tthe expression to be used in the generated attribute specification\n+\t(rather than relocating it) to avoid resolving a potentially malformed\n+\ttree when the expression is resolved through an ASIS-specific call to\n+\tResolve_Aspect_Expressions.  This manifests itself as a crash on a\n+\tfunction with parameter associations.\n+\n 2017-09-25  Yannick Moy  <moy@adacore.com>\n \n \t* exp_spark.adb (Expand_SPARK_Indexed_Component,"}, {"sha": "821f4b5598488bd90105fd9066fcc586a8fe9625", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -35,7 +35,7 @@ with Nlists;   use Nlists;\n with Sinfo;    use Sinfo;\n with Tree_IO;  use Tree_IO;\n \n-with GNAT.HTable;           use GNAT.HTable;\n+with GNAT.HTable;\n \n package body Aspects is\n "}, {"sha": "a9ea20ebd9bd06ac4f62e9b986e300f75a6e177f", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -35,19 +35,17 @@ with Osint.B;  use Osint.B;\n with Output;   use Output;\n with Rident;   use Rident;\n with Stringt;  use Stringt;\n-with Table;    use Table;\n+with Table;\n with Targparm; use Targparm;\n with Types;    use Types;\n \n-with System.OS_Lib;  use System.OS_Lib;\n+with System.OS_Lib;\n with System.WCh_Con; use System.WCh_Con;\n \n with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n with GNAT.HTable;\n \n package body Bindgen is\n-   use Binde.Unit_Id_Tables;\n-\n    Statement_Buffer : String (1 .. 1000);\n    --  Buffer used for constructing output statements\n "}, {"sha": "891575ea9d39fe402b6565b9b692d7d9f4a498a0", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -31,7 +31,7 @@ with Osint;     use Osint;\n with Osint.M;   use Osint.M;\n with Switch;    use Switch;\n with Table;\n-with Targparm;  use Targparm;\n+with Targparm;\n with Types;     use Types;\n \n with Ada.Command_Line;          use Ada.Command_Line;"}, {"sha": "b77d53d7e61abfe08acdfe20dbe6b6363ed34ab4", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -41,7 +41,7 @@ with Output;   use Output;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n-with Targparm; use Targparm;\n+with Targparm;\n with Uintp;    use Uintp;\n with Widechar; use Widechar;\n "}, {"sha": "4637d04ed9874399e05a3cd8acff8cfef1f96bda", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,7 +27,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Ch6;\n with Exp_Imgv; use Exp_Imgv;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;"}, {"sha": "37399adf98b9404d0e1efb17792b2a5e3f83de1e", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6006,6 +6006,14 @@ package body Exp_Ch9 is\n          --  reference will have been rewritten.\n \n          if Expander_Active then\n+            --  The expanded name may have been constant folded in which case\n+            --  the original node is not necessarily an entity name (e.g. an\n+            --  indexed component).\n+\n+            if not Is_Entity_Name (Original_Node (N)) then\n+               return False;\n+            end if;\n+\n             Renamed := Renamed_Object (Entity (Original_Node (N)));\n \n             return"}, {"sha": "70c21c00a437d72f46907c12e07d3eff93f67626", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Alloc;    use Alloc;\n+with Alloc;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;"}, {"sha": "063b60f93548126b407083dcb5acdce9693e60cb", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2014-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2014-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@ with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n-with Opt;      use Opt;\n+with Opt;\n with Output;   use Output;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;"}, {"sha": "c9650ce10a4a31cbd1bc1bc038eca9634d5f7a6d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -65,8 +65,7 @@ with Ttypes;   use Ttypes;\n with Urealp;   use Urealp;\n with Validsw;  use Validsw;\n \n-with GNAT.HTable; use GNAT.HTable;\n-\n+with GNAT.HTable;\n package body Exp_Util is\n \n    ---------------------------------------------------------"}, {"sha": "c55085856c0456beb0e93aa880e5addb1c6138a0", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -38,7 +38,7 @@ with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n-with Lib.Xref; use Lib.Xref;\n+with Lib.Xref;\n with Live;     use Live;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -49,21 +49,21 @@ with Prep;\n with Prepcomp;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n+with Rtsfind;\n with Snames;   use Snames;\n with Sprint;\n with Scn;      use Scn;\n with Sem;      use Sem;\n with Sem_Aux;\n-with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch8;\n with Sem_SCIL;\n with Sem_Elab; use Sem_Elab;\n with Sem_Prag; use Sem_Prag;\n-with Sem_Warn; use Sem_Warn;\n+with Sem_Warn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n-with SCIL_LL;  use SCIL_LL;\n+with SCIL_LL;\n with Tbuild;   use Tbuild;\n with Types;    use Types;\n \n@@ -168,7 +168,6 @@ begin\n          --  Case of gnat.adc file present\n \n          if Source_gnat_adc /= No_Source_File then\n-\n             --  Parse the gnat.adc file for configuration pragmas\n \n             Initialize_Scanner (No_Unit, Source_gnat_adc);"}, {"sha": "e7ca3bfcf374294904171333543d2b103560d464", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Alloc;    use Alloc;\n+with Alloc;\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n@@ -1477,10 +1477,10 @@ package body Ghost is\n \n    begin\n       if Nkind (N) = N_Use_Package_Clause then\n-         Nam := First (Names (N));\n+         Nam := Name (N);\n \n       elsif Nkind (N) = N_Use_Type_Clause then\n-         Nam := First (Subtype_Marks (N));\n+         Nam := Subtype_Mark (N);\n \n       elsif Nkind (N) = N_With_Clause then\n          Nam := Name (N);"}, {"sha": "0e3bc27becbc9acea354b9b6ab5afb8dd79192d7", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -27,7 +27,7 @@ with Atree;     use Atree;\n with Back_End;  use Back_End;\n with Checks;\n with Comperr;\n-with Csets;     use Csets;\n+with Csets;\n with Debug;     use Debug;\n with Elists;\n with Errout;    use Errout;\n@@ -76,7 +76,7 @@ with Tree_Gen;\n with Treepr;    use Treepr;\n with Ttypes;\n with Types;     use Types;\n-with Uintp;     use Uintp;\n+with Uintp;\n with Uname;     use Uname;\n with Urealp;\n with Usage;"}, {"sha": "736979a2c665a33a68b042007d5e373f77408020", "filename": "gcc/ada/gnatdll.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatdll.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,7 +28,7 @@\n \n with Gnatvsn;\n with MDLL.Fil; use MDLL.Fil;\n-with MDLL.Utl; use MDLL.Utl;\n+with MDLL.Utl;\n with Switch;   use Switch;\n \n with Ada.Text_IO;           use Ada.Text_IO;\n@@ -41,8 +41,6 @@ with GNAT.Command_Line; use GNAT.Command_Line;\n \n procedure Gnatdll is\n \n-   use type GNAT.OS_Lib.Argument_List;\n-\n    procedure Syntax;\n    --  Print out usage\n "}, {"sha": "9e427baad1b1741979e4f11d757463ad63baba45", "filename": "gcc/ada/gnatfind.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatfind.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,7 +27,7 @@ with Opt;\n with Osint;    use Osint;\n with Switch;   use Switch;\n with Types;    use Types;\n-with Xr_Tabls; use Xr_Tabls;\n+with Xr_Tabls;\n with Xref_Lib; use Xref_Lib;\n \n with Ada.Command_Line;  use Ada.Command_Line;"}, {"sha": "5e290eb639f77274871b3c22cb818af914ace4ac", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,7 +37,7 @@ with Snames;\n with Switch;   use Switch;\n with System;   use System;\n with Table;\n-with Targparm; use Targparm;\n+with Targparm;\n with Types;\n \n with Ada.Command_Line; use Ada.Command_Line;"}, {"sha": "925ae2c7836b002e9df9d2bdd7a06e9072e009b6", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -29,7 +29,7 @@ with ALI;         use ALI;\n with ALI.Util;    use ALI.Util;\n with Binderr;     use Binderr;\n with Butil;       use Butil;\n-with Csets;       use Csets;\n+with Csets;\n with Fname;       use Fname;\n with Gnatvsn;     use Gnatvsn;\n with Make_Util;   use Make_Util;"}, {"sha": "4a9973f5dfdd4eae2ba1b1ebb9bcfca915142ddc", "filename": "gcc/ada/gnatname.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -36,7 +36,7 @@ with Make_Util; use Make_Util;\n with Namet;     use Namet;\n with Opt;\n with Osint;     use Osint;\n-with Output;    use Output;\n+with Output;\n with Switch;    use Switch;\n with Table;\n with Tempdir;"}, {"sha": "e458d035a0d9a8ca5285427e044b4b363481f2fd", "filename": "gcc/ada/gnatxref.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,11 +27,11 @@ with Opt;\n with Osint;    use Osint;\n with Types;    use Types;\n with Switch;   use Switch;\n-with Xr_Tabls; use Xr_Tabls;\n+with Xr_Tabls;\n with Xref_Lib; use Xref_Lib;\n \n with Ada.Command_Line;  use Ada.Command_Line;\n-with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n+with Ada.Strings.Fixed;\n with Ada.Text_IO;       use Ada.Text_IO;\n \n with GNAT.Command_Line; use GNAT.Command_Line;"}, {"sha": "825a5373ddfe91575414581dbec00b04cc5a2e62", "filename": "gcc/ada/gprep.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fgprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprep.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -249,6 +249,10 @@ package body GPrep is\n                Fail (\"unable to find definition file \"\"\"\n                      & Get_Name_String (Deffile_Name)\n                      & \"\"\"\");\n+            elsif Deffile = No_Access_To_Source_File then\n+               Fail (\"unabled to read definition file \"\"\"\n+                     & Get_Name_String (Deffile_Name)\n+                     & \"\"\"\");\n             end if;\n \n             Scanner.Initialize_Scanner (Deffile);\n@@ -514,6 +518,10 @@ package body GPrep is\n             Fail (\"unable to find input file \"\"\"\n                   & Get_Name_String (Infile_Name)\n                   & \"\"\"\");\n+         elsif Infile = No_Access_To_Source_File then\n+            Fail (\"unable to read input file \"\"\"\n+                  & Get_Name_String (Infile_Name)\n+                  & \"\"\"\");\n          end if;\n \n          --  Set Main_Source_File to the input file for the benefit of"}, {"sha": "7555b16b191d7f67bfd72dd01d2db22df607e9f9", "filename": "gcc/ada/libgnarl/a-exetim__mingw.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fa-exetim__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fa-exetim__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-exetim__mingw.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -153,7 +153,6 @@ is\n       SC : out Ada.Real_Time.Seconds_Count;\n       TS : out Ada.Real_Time.Time_Span)\n    is\n-      use type Ada.Real_Time.Time;\n    begin\n       Ada.Real_Time.Split (Ada.Real_Time.Time (T), SC, TS);\n    end Split;"}, {"sha": "dc5dcf0e8fca9a7c4d8a709cc2597ea70f8869aa", "filename": "gcc/ada/libgnarl/s-taenca.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -42,7 +42,6 @@ package body System.Tasking.Entry_Calls is\n    package STPO renames System.Task_Primitives.Operations;\n \n    use Parameters;\n-   use Task_Primitives;\n    use Protected_Objects.Entries;\n    use Protected_Objects.Operations;\n "}, {"sha": "daff5c1c3ae27a2d86e1f7ed78fa9dd17eae43e1", "filename": "gcc/ada/libgnarl/s-tarest.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -72,7 +72,6 @@ package body System.Tasking.Restricted.Stages is\n \n    use Parameters;\n    use Task_Primitives.Operations;\n-   use Task_Info;\n \n    Tasks_Activation_Chain : Task_Id;\n    --  Chain of all the tasks to activate"}, {"sha": "44c054fec3ecfe0e043ad691246d778ff5582359", "filename": "gcc/ada/libgnarl/s-tassta.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -78,7 +78,6 @@ package body System.Tasking.Stages is\n    use Parameters;\n    use Task_Primitives;\n    use Task_Primitives.Operations;\n-   use Task_Info;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -1045,7 +1044,6 @@ package body System.Tasking.Stages is\n \n       function Secondary_Stack_Size return Storage_Elements.Storage_Offset is\n          use System.Storage_Elements;\n-         use System.Secondary_Stack;\n \n       begin\n          if Parameters.Sec_Stack_Dynamic then\n@@ -1539,7 +1537,6 @@ package body System.Tasking.Stages is\n       pragma Import (Ada, To_Stderr, \"__gnat_to_stderr\");\n \n       use System.Soft_Links;\n-      use System.Standard_Library;\n \n       function To_Address is new\n         Ada.Unchecked_Conversion"}, {"sha": "251ae87b91d2255bb13f249a654de910c2765c41", "filename": "gcc/ada/libgnarl/s-tpobop.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -60,7 +60,6 @@ package body System.Tasking.Protected_Objects.Operations is\n    package STPO renames System.Task_Primitives.Operations;\n \n    use Parameters;\n-   use Task_Primitives;\n    use Ada.Exceptions;\n    use Entries;\n "}, {"sha": "feaa3b141bf13fa8e7a62d955ee4fcebaca4f4e6", "filename": "gcc/ada/libgnat/a-cfhama.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -808,8 +808,6 @@ private\n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is\n      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n-   use HT_Types;\n-\n    Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n \n end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "0f68f183f3bd0eabf259134d99aaed8c5c894432", "filename": "gcc/ada/libgnat/a-strmap.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strmap.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -37,8 +37,6 @@\n \n package body Ada.Strings.Maps is\n \n-   use Ada.Characters.Latin_1;\n-\n    ---------\n    -- \"-\" --\n    ---------"}, {"sha": "4260682b69d7f61ed110c6a736cb8035177fe11c", "filename": "gcc/ada/libgnat/a-teioed.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-teioed.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fa-teioed.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-teioed.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1019,7 +1019,6 @@ package body Ada.Text_IO.Editing is\n       -------------------\n \n       procedure Debug_Integer (Value : Integer; S : String) is\n-         use Ada.Text_IO; --  needed for >\n \n       begin\n          if Debug and then Value > 0 then"}, {"sha": "a697e627d9979b5caea6e397e855a0c444c80f12", "filename": "gcc/ada/libgnat/g-alvety.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-alvety.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-alvety.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-alvety.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -36,8 +36,6 @@ with GNAT.Altivec.Low_Level_Vectors;\n \n package GNAT.Altivec.Vector_Types is\n \n-   use GNAT.Altivec.Low_Level_Vectors;\n-\n    ---------------------------------------------------\n    -- Vector type declarations [PIM-2.1 Data Types] --\n    ---------------------------------------------------"}, {"sha": "554660163b071b0a38b590a0e4a3c44314888a01", "filename": "gcc/ada/libgnat/g-expect.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-expect.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -907,8 +907,6 @@ package body GNAT.Expect is\n       Status     : not null access Integer;\n       Err_To_Out : Boolean := False) return String\n    is\n-      use GNAT.Expect;\n-\n       Process : Process_Descriptor;\n \n       Output : String_Access := new String (1 .. 1024);"}, {"sha": "02e07fd5f456d5be6831439f08620b46e8071376", "filename": "gcc/ada/libgnat/g-regist.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-regist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-regist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-regist.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -184,9 +184,6 @@ package body GNAT.Registry is\n       Sub_Key  : String;\n       Mode     : Key_Mode := Read_Write) return HKEY\n    is\n-      use type REGSAM;\n-      use type DWORD;\n-\n       REG_OPTION_NON_VOLATILE : constant := 16#0#;\n \n       C_Sub_Key : constant String := Sub_Key & ASCII.NUL;\n@@ -425,8 +422,6 @@ package body GNAT.Registry is\n       Sub_Key  : String;\n       Mode     : Key_Mode := Read_Only) return HKEY\n    is\n-      use type REGSAM;\n-\n       C_Sub_Key : constant String := Sub_Key & ASCII.NUL;\n       C_Mode    : constant REGSAM := To_C_Mode (Mode);\n \n@@ -456,7 +451,6 @@ package body GNAT.Registry is\n       Expand   : Boolean := False) return String\n    is\n       use GNAT.Directory_Operations;\n-      use type LONG;\n       use type ULONG;\n \n       Value : String (1 .. Max_Value_Size);"}, {"sha": "519776e0ad3fb89a0913da8f8abfbd37771b5590", "filename": "gcc/ada/libgnat/g-socket.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -2175,7 +2175,6 @@ package body GNAT.Sockets is\n       Count  : out Ada.Streams.Stream_Element_Count;\n       Flags  : Request_Flag_Type := No_Request_Flag)\n    is\n-      use SOSC;\n       use Interfaces.C;\n \n       Res            : ssize_t;"}, {"sha": "fa7617288a1c83299c1ba8949ebe800dda01e2d6", "filename": "gcc/ada/libgnat/g-socthi__mingw.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -48,8 +48,6 @@ package GNAT.Sockets.Thin is\n \n    package C renames Interfaces.C;\n \n-   use type System.CRTL.ssize_t;\n-\n    function Socket_Errno return Integer;\n    --  Returns last socket error number\n "}, {"sha": "da5db75552a5a8e4940481957894b1a314bdb5af", "filename": "gcc/ada/libgnat/s-stausa.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-stausa.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -35,7 +35,6 @@ with System.IO;\n \n package body System.Stack_Usage is\n    use System.Storage_Elements;\n-   use System;\n    use System.IO;\n    use Interfaces;\n "}, {"sha": "49b73b680a9e6484d1cae65c27bf2657e5edc09d", "filename": "gcc/ada/libgnat/s-tsmona__linux.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -38,8 +38,6 @@ separate (System.Traceback.Symbolic)\n \n package body Module_Name is\n \n-   use System;\n-\n    pragma Linker_Options (\"-ldl\");\n \n    function Is_Shared_Lib (Base : Address) return Boolean;"}, {"sha": "3205c0a83fecdbe5fdda405a0c095606c829da1c", "filename": "gcc/ada/libgnat/s-tsmona__mingw.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -37,8 +37,6 @@ separate (System.Traceback.Symbolic)\n \n package body Module_Name is\n \n-   use System;\n-\n    ---------------------------------\n    -- Build_Cache_For_All_Modules --\n    ---------------------------------"}, {"sha": "75048d24e5e6d436f39e40fc648257678144549c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -23,26 +23,26 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with ALI;      use ALI;\n-with ALI.Util; use ALI.Util;\n+with ALI;       use ALI;\n+with ALI.Util;  use ALI.Util;\n with Csets;\n with Debug;\n with Fmap;\n with Fname;     use Fname;\n-with Fname.SF;  use Fname.SF;\n+with Fname.SF;\n with Fname.UF;  use Fname.UF;\n with Gnatvsn;   use Gnatvsn;\n with Hostparm;  use Hostparm;\n with Makeusg;\n with Make_Util; use Make_Util;\n-with Namet;    use Namet;\n-with Opt;      use Opt;\n-with Osint.M;  use Osint.M;\n-with Osint;    use Osint;\n-with Output;   use Output;\n+with Namet;     use Namet;\n+with Opt;       use Opt;\n+with Osint.M;   use Osint.M;\n+with Osint;     use Osint;\n+with Output;    use Output;\n with SFN_Scan;\n with Sinput;\n-with Snames;   use Snames;\n+with Snames;\n with Stringt;\n \n pragma Warnings (Off);\n@@ -52,7 +52,7 @@ pragma Warnings (On);\n with Switch;   use Switch;\n with Switch.M; use Switch.M;\n with Table;\n-with Targparm; use Targparm;\n+with Targparm;\n with Tempdir;\n with Types;    use Types;\n "}, {"sha": "e596f32a44eefb9b1e497655327252250d5bc2f6", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -24,7 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Make_Util;\n-with Osint;   use Osint;\n+with Osint;\n with Output;  use Output;\n with Switch;  use Switch;\n with Usage;"}, {"sha": "2dcbe1a677cfe4da38dd117b11c4506062047944", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -38,7 +38,7 @@ with Opt;      use Opt;\n with Output;   use Output;\n with System;   use System;\n with Tree_IO;  use Tree_IO;\n-with Widechar; use Widechar;\n+with Widechar;\n \n with Interfaces; use Interfaces;\n "}, {"sha": "21f69dd01be814bb01b88b3b8aa68bd0cc7d5f94", "filename": "gcc/ada/output.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Foutput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Foutput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@\n --  writing error messages and informational output. It is also used by the\n --  debug source file output routines (see Sprint.Print_Debug_Line).\n \n-with Hostparm; use Hostparm;\n+with Hostparm;\n with Types;    use Types;\n \n pragma Warnings (Off);"}, {"sha": "1dd3b762564f206aadb8159d01cbe126c84907ec", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -970,7 +970,7 @@ package body Ch10 is\n          --  Processing for USE clause\n \n          elsif Token = Tok_Use then\n-            Append (P_Use_Clause, Item_List);\n+            P_Use_Clause (Item_List);\n \n          --  Anything else is end of context clause\n "}, {"sha": "e603d9c57fd9a3f6761d3cb6b418be6b192f318b", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -167,7 +167,7 @@ package body Ch12 is\n          end if;\n \n          if Token = Tok_Use then\n-            Append (P_Use_Clause, Decls);\n+            P_Use_Clause (Decls);\n \n          else\n             --  Parse a generic parameter declaration"}, {"sha": "54dd5621fd81cd21ba32900b3f91003d738b6ca4", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -4411,7 +4411,7 @@ package body Ch3 is\n \n          when Tok_Use =>\n             Check_Bad_Layout;\n-            Append (P_Use_Clause, Decls);\n+            P_Use_Clause (Decls);\n             Done := False;\n \n          when Tok_With =>"}, {"sha": "456c86358be77750988bf239b262a2ef1da855c7", "filename": "gcc/ada/par-ch8.adb", "status": "modified", "additions": 87, "deletions": 31, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar-ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch8.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,50 @@ package body Ch8 is\n    -- Local Subprograms --\n    -----------------------\n \n-   function P_Use_Package_Clause                           return Node_Id;\n-   function P_Use_Type_Clause                              return Node_Id;\n+   procedure Append_Use_Clause\n+     (Item_List : List_Id;\n+      Use_Node  : Node_Id;\n+      Is_First  : in out Boolean;\n+      Is_Last   : in out Boolean);\n+   --  Append a use_clause to the Item_List, appropriately setting the Prev_Ids\n+   --  and More_Ids flags for each split use node. The flags Is_First and\n+   --  Is_Last track position of subtype_marks or names within the original\n+   --  use_clause.\n+\n+   procedure P_Use_Package_Clause (Item_List : List_Id);\n+   procedure P_Use_Type_Clause    (Item_List : List_Id);\n+\n+   -----------------------\n+   -- Append_Use_Clause --\n+   -----------------------\n+\n+   procedure Append_Use_Clause\n+     (Item_List : List_Id;\n+      Use_Node  : Node_Id;\n+      Is_First  : in out Boolean;\n+      Is_Last   : in out Boolean)\n+   is\n+   begin\n+      if Token /= Tok_Comma then\n+         if not Is_First then\n+            Set_Prev_Ids (Use_Node);\n+         end if;\n+\n+         Append (Use_Node, Item_List);\n+         Is_Last := True;\n+      else\n+         Set_More_Ids (Use_Node);\n+\n+         if not Is_First then\n+            Set_Prev_Ids (Use_Node);\n+         else\n+            Is_First := False;\n+         end if;\n+\n+         Append (Use_Node, Item_List);\n+         Scan; --  Past comma\n+      end if;\n+   end Append_Use_Clause;\n \n    ---------------------\n    -- 8.4  Use Clause --\n@@ -47,14 +89,14 @@ package body Ch8 is\n \n    --  Error recovery: cannot raise Error_Resync\n \n-   function P_Use_Clause return Node_Id is\n+   procedure P_Use_Clause (Item_List : List_Id) is\n    begin\n       Scan; -- past USE\n \n       if Token = Tok_Type or else Token = Tok_All then\n-         return P_Use_Type_Clause;\n+         P_Use_Type_Clause (Item_List);\n       else\n-         return P_Use_Package_Clause;\n+         P_Use_Package_Clause (Item_List);\n       end if;\n    end P_Use_Clause;\n \n@@ -68,26 +110,32 @@ package body Ch8 is\n \n    --  Error recovery: cannot raise Error_Resync\n \n-   function P_Use_Package_Clause return Node_Id is\n+   procedure P_Use_Package_Clause (Item_List : List_Id) is\n+      Is_First : Boolean := True;\n+      Is_Last  : Boolean := False;\n       Use_Node : Node_Id;\n+      Use_Sloc : constant Source_Ptr := Prev_Token_Ptr;\n \n    begin\n-      Use_Node := New_Node (N_Use_Package_Clause, Prev_Token_Ptr);\n-      Set_Names (Use_Node, New_List);\n-\n       if Token = Tok_Package then\n          Error_Msg_SC (\"PACKAGE should not appear here\");\n-         Scan; -- past PACKAGE\n+         Scan; --  Past PACKAGE\n       end if;\n \n+      --  Loop through names in a single use_package_clause, generating an\n+      --  N_Use_Package_Clause node for each name encountered.\n+\n       loop\n-         Append (P_Qualified_Simple_Name, Names (Use_Node));\n-         exit when Token /= Tok_Comma;\n-         Scan; -- past comma\n+         Use_Node := New_Node (N_Use_Package_Clause, Use_Sloc);\n+         Set_Name (Use_Node, P_Qualified_Simple_Name);\n+\n+         --  Locally chain each name's use-package node\n+\n+         Append_Use_Clause (Item_List, Use_Node, Is_First, Is_Last);\n+         exit when Is_Last;\n       end loop;\n \n       TF_Semicolon;\n-      return Use_Node;\n    end P_Use_Package_Clause;\n \n    --------------------------\n@@ -103,45 +151,53 @@ package body Ch8 is\n \n    --  Error recovery: cannot raise Error_Resync\n \n-   function P_Use_Type_Clause return Node_Id is\n-      Use_Node    : Node_Id;\n+   procedure P_Use_Type_Clause (Item_List : List_Id) is\n       All_Present : Boolean;\n+      Is_First    : Boolean := True;\n+      Is_Last     : Boolean := False;\n+      Use_Node    : Node_Id;\n       Use_Sloc    : constant Source_Ptr := Prev_Token_Ptr;\n \n    begin\n       if Token = Tok_All then\n          Error_Msg_Ada_2012_Feature (\"|`USE ALL TYPE`\", Token_Ptr);\n          All_Present := True;\n-         Scan; -- past ALL\n+         Scan; --  Past ALL\n \n          if Token /= Tok_Type then\n             Error_Msg_SC (\"TYPE expected\");\n          end if;\n \n-      else pragma Assert (Token = Tok_Type);\n+      else\n+         pragma Assert (Token = Tok_Type);\n          All_Present := False;\n       end if;\n \n-      Use_Node := New_Node (N_Use_Type_Clause, Use_Sloc);\n-      Set_All_Present (Use_Node, All_Present);\n-      Set_Subtype_Marks (Use_Node, New_List);\n-      Set_Used_Operations (Use_Node, No_Elist);\n-\n       if Ada_Version = Ada_83 then\n          Error_Msg_SC (\"(Ada 83) use type not allowed!\");\n       end if;\n \n-      Scan; -- past TYPE\n+      Scan; --  Past TYPE\n+\n+      --  Loop through subtype_marks in one use_type_clause, generating a\n+      --  separate N_Use_Type_Clause node for each subtype_mark encountered.\n \n       loop\n-         Append (P_Subtype_Mark, Subtype_Marks (Use_Node));\n+         Use_Node := New_Node (N_Use_Type_Clause, Use_Sloc);\n+         Set_All_Present (Use_Node, All_Present);\n+         Set_Used_Operations (Use_Node, No_Elist);\n+\n+         Set_Subtype_Mark (Use_Node, P_Subtype_Mark);\n+\n          No_Constraint;\n-         exit when Token /= Tok_Comma;\n-         Scan; -- past comma\n+\n+         --  Locally chain each subtype_mark's use-type node\n+\n+         Append_Use_Clause (Item_List, Use_Node, Is_First, Is_Last);\n+         exit when Is_Last;\n       end loop;\n \n       TF_Semicolon;\n-      return Use_Node;\n    end P_Use_Type_Clause;\n \n    -------------------------------\n@@ -163,9 +219,9 @@ package body Ch8 is\n \n    --  Parsed by P_Identifier_Declarations (3.3.1)\n \n-   ----------------------------------------\n+   -------------------------------------------\n    -- 8.5.2  Exception Renaming Declaration --\n-   ----------------------------------------\n+   -------------------------------------------\n \n    --  Parsed by P_Identifier_Declarations (3.3.1)\n "}, {"sha": "280d8a1d1c0a5c50e8dfc32fdfda2edbd98edbff", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -867,7 +867,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    -------------\n \n    package Ch8 is\n-      function P_Use_Clause                           return Node_Id;\n+      procedure P_Use_Clause (Item_List : List_Id);\n    end Ch8;\n \n    -------------"}, {"sha": "fa8a7a868c81eb809b7280141304d83f635d0f1b", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,9 +23,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Namet; use Namet;\n-with Opt;   use Opt;\n-with SCOs;  use SCOs;\n+with Namet;\n+with Opt;\n+with SCOs; use SCOs;\n \n procedure Put_SCOs is\n    Current_SCO_Unit : SCO_Unit_Index := 0;"}, {"sha": "630d592f2be885e0c246131a1e860a7ca0bb752e", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Alloc;   use Alloc;\n+with Alloc;\n with Atree;   use Atree;\n with Casing;  use Casing;\n with Debug;   use Debug;\n@@ -45,7 +45,7 @@ with Sinput;  use Sinput;\n with Snames;  use Snames;\n with Stand;   use Stand;\n with Stringt; use Stringt;\n-with Table;   use Table;\n+with Table;\n with Uname;   use Uname;\n with Urealp;  use Urealp;\n "}, {"sha": "e3af27d31f4b61a55e9364469e9d189aad4948c1", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -30,7 +30,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Exp_Dist; use Exp_Dist;\n+with Exp_Dist;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Ghost;    use Ghost;"}, {"sha": "10e4ad3cc89be13a6198d1b58e6f75bae5e08404", "filename": "gcc/ada/scn.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fscn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fscn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -29,7 +29,7 @@\n with Casing; use Casing;\n with Errout; use Errout;\n with Scng;\n-with Style;  use Style;\n+with Style;  --  use Style;\n with Types;  use Types;\n \n package Scn is"}, {"sha": "e121e5969130f1b86bf59ab9639d2fb36295190c", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -732,6 +732,18 @@ package body Sem is\n \n       Debug_A_Exit (\"analyzing  \", N, \"  (done)\");\n \n+      --  Mark relevant use-type and use-package clauses as effective using the\n+      --  original node, because constant folding may have occurred and removed\n+      --  references that need to be examined. If the node in question is\n+      --  overloaded then this is deferred until resolution.\n+\n+      if Nkind (Original_Node (N)) in N_Op\n+        and then Present (Entity (Original_Node (N)))\n+        and then not Is_Overloaded (Original_Node (N))\n+      then\n+         Mark_Use_Clauses (Original_Node (N));\n+      end if;\n+\n       --  Now that we have analyzed the node, we call the expander to perform\n       --  possible expansion. We skip this for subexpressions, because we don't\n       --  have the type yet, and the expander will need to know the type before"}, {"sha": "5bedc6c8c128ef6b6fd85c9b8f9dba8276b92f9c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -47,7 +47,7 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n-with Sdefault; use Sdefault;\n+with Sdefault;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n@@ -11797,6 +11797,15 @@ package body Sem_Attr is\n             end if;\n       end case;\n \n+      --  Mark use clauses of the original prefix if the attribute is applied\n+      --  to an entity.\n+\n+      if Nkind (Original_Node (P)) in N_Has_Entity\n+        and then Present (Entity (Original_Node (P)))\n+      then\n+         Mark_Use_Clauses (Original_Node (P));\n+      end if;\n+\n       --  Normally the Freezing is done by Resolve but sometimes the Prefix\n       --  is not resolved, in which case the freezing must be done now.\n "}, {"sha": "7da7b41985c121ecb0eebcac757b918596630d5e", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -38,7 +38,7 @@\n --  content of entities in the tree, so this package is used for routines that\n --  require more than minimal semantic knowledge.\n \n-with Alloc; use Alloc;\n+with Alloc;\n with Namet; use Namet;\n with Table;\n with Types; use Types;"}, {"sha": "b89d8d32008f4880f4e7aada9cb038c66aab9c76", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 78, "deletions": 101, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -138,9 +138,12 @@ package body Sem_Ch10 is\n    --  Check that the shadow entity is not already in the homonym chain, for\n    --  example through a limited_with clause in a parent unit.\n \n-   procedure Install_Context_Clauses (N : Node_Id);\n+   procedure Install_Context_Clauses (N : Node_Id; Chain : Boolean := True);\n    --  Subsidiary to Install_Context and Install_Parents. Process all with\n-   --  and use clauses for current unit and its library unit if any.\n+   --  and use clauses for current unit and its library unit if any. The flag\n+   --  Chain is used to control the \"chaining\" or linking together of use-type\n+   --  and use-package clauses to avoid circularities with reinstalling\n+   --  clauses.\n \n    procedure Install_Limited_Context_Clauses (N : Node_Id);\n    --  Subsidiary to Install_Context. Process only limited with_clauses for\n@@ -159,7 +162,8 @@ package body Sem_Ch10 is\n    --  is called when compiling the private part of a package, or installing\n    --  the private declarations of a parent unit.\n \n-   procedure Install_Parents (Lib_Unit : Node_Id; Is_Private : Boolean);\n+   procedure Install_Parents\n+     (Lib_Unit : Node_Id; Is_Private : Boolean; Chain : Boolean := True);\n    --  This procedure establishes the context for the compilation of a child\n    --  unit. If Lib_Unit is a child library spec then the context of the parent\n    --  is installed, and the parent itself made immediately visible, so that\n@@ -168,7 +172,9 @@ package body Sem_Ch10 is\n    --  parents are loaded in the nested case. If Lib_Unit is a library body,\n    --  the only effect of Install_Parents is to install the private decls of\n    --  the parents, because the visible parent declarations will have been\n-   --  installed as part of the context of the corresponding spec.\n+   --  installed as part of the context of the corresponding spec. The flag\n+   --  Chain is used to control the \"chaining\" or linking of use-type and\n+   --  use-package clauses to avoid circularities when installing context.\n \n    procedure Install_Siblings (U_Name : Entity_Id; N : Node_Id);\n    --  In the compilation of a child unit, a child of any of the  ancestor\n@@ -342,53 +348,45 @@ package body Sem_Ch10 is\n                then\n                   --  Search through use clauses\n \n-                  Use_Item := First (Names (Cont_Item));\n-                  while Present (Use_Item) and then not Used loop\n+                  Use_Item := Name (Cont_Item);\n \n-                     --  Case of a direct use of the one we are looking for\n+                  --  Case of a direct use of the one we are looking for\n \n-                     if Entity (Use_Item) = Nam_Ent then\n-                        Used := True;\n+                  if Entity (Use_Item) = Nam_Ent then\n+                     Used := True;\n \n-                     --  Handle nested case, as in \"with P; use P.Q.R\"\n+                  --  Handle nested case, as in \"with P; use P.Q.R\"\n \n-                     else\n-                        declare\n-                           UE : Node_Id;\n-\n-                        begin\n-                           --  Loop through prefixes looking for match\n+                  else\n+                     declare\n+                        UE : Node_Id;\n \n-                           UE := Use_Item;\n-                           while Nkind (UE) = N_Expanded_Name loop\n-                              if Same_Unit (Prefix (UE), Nam_Ent) then\n-                                 Used := True;\n-                                 exit;\n-                              end if;\n+                     begin\n+                        --  Loop through prefixes looking for match\n \n-                              UE := Prefix (UE);\n-                           end loop;\n-                        end;\n-                     end if;\n+                        UE := Use_Item;\n+                        while Nkind (UE) = N_Expanded_Name loop\n+                           if Same_Unit (Prefix (UE), Nam_Ent) then\n+                              Used := True;\n+                              exit;\n+                           end if;\n \n-                     Next (Use_Item);\n-                  end loop;\n+                           UE := Prefix (UE);\n+                        end loop;\n+                     end;\n+                  end if;\n \n                --  USE TYPE clause\n \n                elsif Nkind (Cont_Item) = N_Use_Type_Clause\n                  and then not Used_Type_Or_Elab\n                then\n-                  Subt_Mark := First (Subtype_Marks (Cont_Item));\n-                  while Present (Subt_Mark)\n-                    and then not Used_Type_Or_Elab\n-                  loop\n-                     if Same_Unit (Prefix (Subt_Mark), Nam_Ent) then\n-                        Used_Type_Or_Elab := True;\n-                     end if;\n-\n-                     Next (Subt_Mark);\n-                  end loop;\n+                  Subt_Mark := Subtype_Mark (Cont_Item);\n+                  if not Used_Type_Or_Elab\n+                    and then Same_Unit (Prefix (Subt_Mark), Nam_Ent)\n+                  then\n+                     Used_Type_Or_Elab := True;\n+                  end if;\n \n                --  Pragma Elaborate or Elaborate_All\n \n@@ -426,7 +424,6 @@ package body Sem_Ch10 is\n          is\n             Nam_Ent   : constant Entity_Id := Entity (Name (Clause));\n             Cont_Item : Node_Id;\n-            Use_Item  : Node_Id;\n \n          begin\n             Used := False;\n@@ -450,14 +447,9 @@ package body Sem_Ch10 is\n                if Nkind (Cont_Item) = N_Use_Package_Clause\n                  and then not Used\n                then\n-                  Use_Item := First (Names (Cont_Item));\n-                  while Present (Use_Item) and then not Used loop\n-                     if Entity (Use_Item) = Nam_Ent then\n-                        Used := True;\n-                     end if;\n-\n-                     Next (Use_Item);\n-                  end loop;\n+                  if Entity (Name (Cont_Item)) = Nam_Ent then\n+                     Used := True;\n+                  end if;\n \n                --  Package with clause. Avoid processing self, implicitly\n                --  generated with clauses or limited with clauses. Note that\n@@ -2103,7 +2095,6 @@ package body Sem_Ch10 is\n \n       procedure Analyze_Subunit_Context is\n          Item      :  Node_Id;\n-         Nam       :  Node_Id;\n          Unit_Name : Entity_Id;\n \n       begin\n@@ -2154,18 +2145,10 @@ package body Sem_Ch10 is\n                end if;\n \n             elsif Nkind (Item) = N_Use_Package_Clause then\n-               Nam := First (Names (Item));\n-               while Present (Nam) loop\n-                  Analyze (Nam);\n-                  Next (Nam);\n-               end loop;\n+               Analyze (Name (Item));\n \n             elsif Nkind (Item) = N_Use_Type_Clause then\n-               Nam := First (Subtype_Marks (Item));\n-               while Present (Nam) loop\n-                  Analyze (Nam);\n-                  Next (Nam);\n-               end loop;\n+               Analyze (Subtype_Mark (Item));\n             end if;\n \n             Next (Item);\n@@ -2212,7 +2195,7 @@ package body Sem_Ch10 is\n             Re_Install_Parents (Library_Unit (L), Scope (Scop));\n          end if;\n \n-         Install_Context (L);\n+         Install_Context (L, False);\n \n          --  If the subunit occurs within a child unit, we must restore the\n          --  immediate visibility of any siblings that may occur in context.\n@@ -2259,7 +2242,7 @@ package body Sem_Ch10 is\n          for J in reverse 1 .. Num_Scopes loop\n             U := Use_Clauses (J);\n             Scope_Stack.Table (Scope_Stack.Last - J + 1).First_Use_Clause := U;\n-            Install_Use_Clauses (U, Force_Installation => True);\n+            Install_Use_Clauses (U);\n          end loop;\n       end Re_Install_Use_Clauses;\n \n@@ -2383,7 +2366,7 @@ package body Sem_Ch10 is\n          end if;\n \n          Re_Install_Use_Clauses;\n-         Install_Context (N);\n+         Install_Context (N, Chain => False);\n \n          --  Restore state of suppress flags for current body\n \n@@ -3399,14 +3382,15 @@ package body Sem_Ch10 is\n    -- Install_Context --\n    ---------------------\n \n-   procedure Install_Context (N : Node_Id) is\n+   procedure Install_Context (N : Node_Id; Chain : Boolean := True) is\n       Lib_Unit : constant Node_Id := Unit (N);\n \n    begin\n-      Install_Context_Clauses (N);\n+      Install_Context_Clauses (N, Chain);\n \n       if Is_Child_Spec (Lib_Unit) then\n-         Install_Parents (Lib_Unit, Private_Present (Parent (Lib_Unit)));\n+         Install_Parents\n+           (Lib_Unit, Private_Present (Parent (Lib_Unit)), Chain);\n       end if;\n \n       Install_Limited_Context_Clauses (N);\n@@ -3416,7 +3400,7 @@ package body Sem_Ch10 is\n    -- Install_Context_Clauses --\n    -----------------------------\n \n-   procedure Install_Context_Clauses (N : Node_Id) is\n+   procedure Install_Context_Clauses (N : Node_Id; Chain : Boolean := True) is\n       Lib_Unit      : constant Node_Id := Unit (N);\n       Item          : Node_Id;\n       Uname_Node    : Entity_Id;\n@@ -3567,12 +3551,12 @@ package body Sem_Ch10 is\n          --  Case of USE PACKAGE clause\n \n          elsif Nkind (Item) = N_Use_Package_Clause then\n-            Analyze_Use_Package (Item);\n+            Analyze_Use_Package (Item, Chain);\n \n          --  Case of USE TYPE clause\n \n          elsif Nkind (Item) = N_Use_Type_Clause then\n-            Analyze_Use_Type (Item);\n+            Analyze_Use_Type (Item, Chain);\n \n          --  case of PRAGMA\n \n@@ -3602,7 +3586,7 @@ package body Sem_Ch10 is\n         or else (Nkind (Lib_Unit) = N_Subprogram_Body\n                   and then not Acts_As_Spec (N))\n       then\n-         Install_Context (Library_Unit (N));\n+         Install_Context (Library_Unit (N), Chain);\n \n          --  Only install private with-clauses of a spec that comes from\n          --  source, excluding specs created for a subprogram body that is\n@@ -3716,7 +3700,6 @@ package body Sem_Ch10 is\n          Item   : Node_Id;\n          Spec   : Node_Id;\n          WEnt   : Entity_Id;\n-         Nam    : Node_Id;\n          E      : Entity_Id;\n          E2     : Entity_Id;\n \n@@ -3749,43 +3732,36 @@ package body Sem_Ch10 is\n \n             if Nkind (Item) = N_Use_Package_Clause then\n \n-               --  Traverse the list of packages\n+               E := Entity (Name (Item));\n \n-               Nam := First (Names (Item));\n-               while Present (Nam) loop\n-                  E := Entity (Nam);\n+               pragma Assert (Present (Parent (E)));\n \n-                  pragma Assert (Present (Parent (E)));\n-\n-                  if Nkind (Parent (E)) = N_Package_Renaming_Declaration\n-                    and then Renamed_Entity (E) = WEnt\n-                  then\n-                     --  The unlimited view is visible through use clause and\n-                     --  renamings. There is no need to generate the error\n-                     --  message here because Is_Visible_Through_Renamings\n-                     --  takes care of generating the precise error message.\n+               if Nkind (Parent (E)) = N_Package_Renaming_Declaration\n+                 and then Renamed_Entity (E) = WEnt\n+               then\n+                  --  The unlimited view is visible through use clause and\n+                  --  renamings. There is no need to generate the error\n+                  --  message here because Is_Visible_Through_Renamings\n+                  --  takes care of generating the precise error message.\n \n-                     return;\n+                  return;\n \n-                  elsif Nkind (Parent (E)) = N_Package_Specification then\n+               elsif Nkind (Parent (E)) = N_Package_Specification then\n \n-                     --  The use clause may refer to a local package.\n-                     --  Check all the enclosing scopes.\n+                  --  The use clause may refer to a local package.\n+                  --  Check all the enclosing scopes.\n \n-                     E2 := E;\n-                     while E2 /= Standard_Standard and then E2 /= WEnt loop\n-                        E2 := Scope (E2);\n-                     end loop;\n+                  E2 := E;\n+                  while E2 /= Standard_Standard and then E2 /= WEnt loop\n+                     E2 := Scope (E2);\n+                  end loop;\n \n-                     if E2 = WEnt then\n-                        Error_Msg_N\n-                          (\"unlimited view visible through use clause \", W);\n-                        return;\n-                     end if;\n+                  if E2 = WEnt then\n+                     Error_Msg_N\n+                       (\"unlimited view visible through use clause \", W);\n+                     return;\n                   end if;\n-\n-                  Next (Nam);\n-               end loop;\n+               end if;\n             end if;\n \n             Next (Item);\n@@ -4088,7 +4064,8 @@ package body Sem_Ch10 is\n    -- Install_Parents --\n    ---------------------\n \n-   procedure Install_Parents (Lib_Unit : Node_Id; Is_Private : Boolean) is\n+   procedure Install_Parents\n+     (Lib_Unit : Node_Id; Is_Private : Boolean; Chain : Boolean := True) is\n       P      : Node_Id;\n       E_Name : Entity_Id;\n       P_Name : Entity_Id;\n@@ -4145,12 +4122,12 @@ package body Sem_Ch10 is\n \n       if Is_Child_Spec (P) then\n          Install_Parents (P,\n-           Is_Private or else Private_Present (Parent (Lib_Unit)));\n+           Is_Private or else Private_Present (Parent (Lib_Unit)), Chain);\n       end if;\n \n       --  Now we can install the context for this parent\n \n-      Install_Context_Clauses (Parent_Spec (Lib_Unit));\n+      Install_Context_Clauses (Parent_Spec (Lib_Unit), Chain);\n       Install_Limited_Context_Clauses (Parent_Spec (Lib_Unit));\n       Install_Siblings (P_Name, Parent (Lib_Unit));\n "}, {"sha": "2843d9e52fb83b754e3788ff0ede42bc195ce26e", "filename": "gcc/ada/sem_ch10.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,10 +34,12 @@ package Sem_Ch10 is\n    procedure Analyze_Protected_Body_Stub                (N : Node_Id);\n    procedure Analyze_Subunit                            (N : Node_Id);\n \n-   procedure Install_Context (N : Node_Id);\n+   procedure Install_Context (N : Node_Id; Chain : Boolean := True);\n    --  Installs the entities from the context clause of the given compilation\n    --  unit into the visibility chains. This is done before analyzing a unit.\n-   --  For a child unit, install context of parents as well.\n+   --  For a child unit, install context of parents as well. The flag Chain is\n+   --  used to control the \"chaining\" or linking of use-type and use-package\n+   --  clauses to avoid circularities when reinstalling context clauses.\n \n    procedure Install_Private_With_Clauses (P : Entity_Id);\n    --  Install the private with_clauses of a compilation unit, when compiling"}, {"sha": "ec270f3ad1925e017011f696cc6f18815a9dba89", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -4840,7 +4840,7 @@ package body Sem_Ch12 is\n          end loop;\n \n          if Removed then\n-            Install_Context (Curr_Comp);\n+            Install_Context (Curr_Comp, Chain => False);\n \n             if Present (Curr_Scope)\n               and then Is_Child_Unit (Curr_Scope)"}, {"sha": "79b22cd54b5d03ec974cad3cee46398386ff5386", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -2264,13 +2264,29 @@ package body Sem_Ch13 is\n                      end if;\n                   end if;\n \n-                  --  Construct the attribute definition clause\n-\n-                  Aitem :=\n-                    Make_Attribute_Definition_Clause (Loc,\n-                      Name       => Ent,\n-                      Chars      => Chars (Id),\n-                      Expression => Relocate_Node (Expr));\n+                  --  Construct the attribute_definition_clause. The expression\n+                  --  in the aspect specification is simply shared with the\n+                  --  constructed attribute, because it will be fully analyzed\n+                  --  when the attribute is processed. However, in ASIS mode\n+                  --  the aspect expression itself is preanalyzed and resolved\n+                  --  to catch visibility errors that are otherwise caught\n+                  --  later, and we create a separate copy of the expression\n+                  --  to prevent analysis of a malformed tree (e.g. a function\n+                  --  call with parameter associations).\n+\n+                  if ASIS_Mode then\n+                     Aitem :=\n+                       Make_Attribute_Definition_Clause (Loc,\n+                         Name       => Ent,\n+                         Chars      => Chars (Id),\n+                         Expression => New_Copy_Tree (Expr));\n+                  else\n+                     Aitem :=\n+                       Make_Attribute_Definition_Clause (Loc,\n+                         Name       => Ent,\n+                         Chars      => Chars (Id),\n+                         Expression => Relocate_Node (Expr));\n+                  end if;\n \n                   --  If the address is specified, then we treat the entity as\n                   --  referenced, to avoid spurious warnings. This is analogous"}, {"sha": "8801fb750bad15b54eb0600d40686c7b204035d7", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6477,9 +6477,17 @@ package body Sem_Ch4 is\n       --------------------\n \n       procedure Try_One_Interp (T1 : Entity_Id) is\n-         Bas : constant Entity_Id := Base_Type (T1);\n+         Bas : Entity_Id;\n \n       begin\n+         --  Perform a sanity check in case of previous errors\n+\n+         if No (T1) then\n+            return;\n+         end if;\n+\n+         Bas := Base_Type (T1);\n+\n          --  If the operator is an expanded name, then the type of the operand\n          --  must be defined in the corresponding scope. If the type is\n          --  universal, the context will impose the correct type. An anonymous"}, {"sha": "e3aa50b2ddd2f0aa363bdd10feb77ef03d503039", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1132,6 +1132,7 @@ package body Sem_Ch5 is\n          end if;\n \n          Check_References (Ent);\n+         Update_Use_Clause_Chain;\n          End_Scope;\n \n          if Unblocked_Exit_Count = 0 then"}, {"sha": "9ef0acaaf498229ba7ec4e23e2ca5e42d56dd48d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1498,6 +1498,7 @@ package body Sem_Ch6 is\n       end;\n \n       Process_End_Label (Handled_Statement_Sequence (N), 't', Current_Scope);\n+      Update_Use_Clause_Chain;\n       End_Scope;\n       Check_Subprogram_Order (N);\n \n@@ -4357,6 +4358,7 @@ package body Sem_Ch6 is\n       --  Deal with end of scope processing for the body\n \n       Process_End_Label (HSS, 't', Current_Scope);\n+      Update_Use_Clause_Chain;\n       End_Scope;\n \n       --  If we are compiling an entry wrapper, remove the enclosing"}, {"sha": "ba7ff3c848cd3ad1bc4cc05269e54d032a395d87", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -945,6 +945,7 @@ package body Sem_Ch7 is\n          Set_Last_Entity  (Spec_Id, Empty);\n       end if;\n \n+      Update_Use_Clause_Chain;\n       End_Package_Scope (Spec_Id);\n \n       --  All entities declared in body are not visible\n@@ -1796,6 +1797,18 @@ package body Sem_Ch7 is\n       then\n          Unit_Requires_Body_Info (Id);\n       end if;\n+\n+      --  Nested package specs that do not require bodies are not checked for\n+      --  ineffective use clauses due to the possbility of subunits. This is\n+      --  because at this stage it is impossible to tell whether there will be\n+      --  a separate body.\n+\n+      if not Unit_Requires_Body (Id)\n+        and then Is_Compilation_Unit (Id)\n+        and then not Is_Private_Descendant (Id)\n+      then\n+         Update_Use_Clause_Chain;\n+      end if;\n    end Analyze_Package_Specification;\n \n    --------------------------------------"}, {"sha": "d86818abd490c0adebc794ded8291328a93a2eee", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1073, "deletions": 587, "changes": 1660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -65,7 +65,7 @@ with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinfo.CN; use Sinfo.CN;\n with Snames;   use Snames;\n-with Style;    use Style;\n+with Style;\n with Table;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -402,11 +402,6 @@ package body Sem_Ch8 is\n    --  The renaming operation is intrinsic because the compiler must in\n    --  fact generate a wrapper for it (6.3.1 (10 1/2)).\n \n-   function Applicable_Use (Pack_Name : Node_Id) return Boolean;\n-   --  Common code to Use_One_Package and Set_Use, to determine whether use\n-   --  clause must be processed. Pack_Name is an entity name that references\n-   --  the package in question.\n-\n    procedure Attribute_Renaming (N : Node_Id);\n    --  Analyze renaming of attribute as subprogram. The renaming declaration N\n    --  is rewritten as a subprogram body that returns the attribute reference\n@@ -469,19 +464,21 @@ package body Sem_Ch8 is\n    --  but is a reasonable heuristic on the use of nested generics. The\n    --  proper solution requires a full renaming model.\n \n-   function Has_Implicit_Character_Literal (N : Node_Id) return Boolean;\n-   --  Find a type derived from Character or Wide_Character in the prefix of N.\n-   --  Used to resolved qualified names whose selector is a character literal.\n-\n-   function Has_Private_With (E : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-262): Determines if the current compilation unit has a\n-   --  private with on E.\n+   function Entity_Of_Unit (U : Node_Id) return Entity_Id;\n+   --  Return the appropriate entity for determining which unit has a deeper\n+   --  scope: the defining entity for U, unless U is a package instance, in\n+   --  which case we retrieve the entity of the instance spec.\n \n    procedure Find_Expanded_Name (N : Node_Id);\n    --  The input is a selected component known to be an expanded name. Verify\n    --  legality of selector given the scope denoted by prefix, and change node\n    --  N into a expanded name with a properly set Entity field.\n \n+   function Find_Most_Prev (Use_Clause : Node_Id) return Node_Id;\n+   --  Find the most previous use clause (that is, the first one to appear in\n+   --  the source) by traversing the previous clause chain that exists in both\n+   --  N_Use_Package_Clause nodes and N_Use_Type_Clause nodes.\n+\n    function Find_Renamed_Entity\n      (N         : Node_Id;\n       Nam       : Node_Id;\n@@ -493,6 +490,14 @@ package body Sem_Ch8 is\n    --  indicates that the renaming is the one generated for an actual subpro-\n    --  gram in an instance, for which special visibility checks apply.\n \n+   function Has_Implicit_Character_Literal (N : Node_Id) return Boolean;\n+   --  Find a type derived from Character or Wide_Character in the prefix of N.\n+   --  Used to resolved qualified names whose selector is a character literal.\n+\n+   function Has_Private_With (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-262): Determines if the current compilation unit has a\n+   --  private with on E.\n+\n    function Has_Implicit_Operator (N : Node_Id) return Boolean;\n    --  N is an expanded name whose selector is an operator name (e.g. P.\"+\").\n    --  declarative part contains an implicit declaration of an operator if it\n@@ -507,30 +512,33 @@ package body Sem_Ch8 is\n    --  specification are discarded and replaced with those of the renamed\n    --  subprogram, which are then used to recheck the default values.\n \n-   function Is_Appropriate_For_Record (T : Entity_Id) return Boolean;\n-   --  Prefix is appropriate for record if it is of a record type, or an access\n-   --  to such.\n-\n    function Is_Appropriate_For_Entry_Prefix (T : Entity_Id) return Boolean;\n    --  True if it is of a task type, a protected type, or else an access to one\n    --  of these types.\n \n-   procedure Note_Redundant_Use (Clause : Node_Id);\n-   --  Mark the name in a use clause as redundant if the corresponding entity\n-   --  is already use-visible. Emit a warning if the use clause comes from\n-   --  source and the proper warnings are enabled.\n+   function Is_Appropriate_For_Record (T : Entity_Id) return Boolean;\n+   --  Prefix is appropriate for record if it is of a record type, or an access\n+   --  to such.\n+\n+   function Most_Descendant_Use_Clause\n+     (Clause1 : Entity_Id;\n+      Clause2 : Entity_Id) return Entity_Id;\n+   --  Determine which use clause parameter is the most descendant in terms of\n+   --  scope.\n \n    procedure Premature_Usage (N : Node_Id);\n    --  Diagnose usage of an entity before it is visible\n \n-   procedure Use_One_Package (P : Entity_Id; N : Node_Id);\n+   procedure Use_One_Package\n+     (N : Node_Id; Pack_Name : Entity_Id := Empty; Force : Boolean := False);\n    --  Make visible entities declared in package P potentially use-visible\n    --  in the current context. Also used in the analysis of subunits, when\n    --  re-installing use clauses of parent units. N is the use_clause that\n    --  names P (and possibly other packages).\n \n-   procedure Use_One_Type (Id : Node_Id; Installed : Boolean := False);\n-   --  Id is the subtype mark from a use type clause. This procedure makes\n+   procedure Use_One_Type\n+     (Id : Node_Id; Installed : Boolean := False; Force : Boolean := False);\n+   --  Id is the subtype mark from a use_type_clause. This procedure makes\n    --  the primitive operators of the type potentially use-visible. The\n    --  boolean flag Installed indicates that the clause is being reinstalled\n    --  after previous analysis, and primitive operations are already chained\n@@ -3437,7 +3445,7 @@ package body Sem_Ch8 is\n          --  addition the renamed entity may depend on the generic formals of\n          --  the enclosing generic.\n \n-         if Is_Actual and then not Inside_A_Generic then\n+         if Is_Actual and not Inside_A_Generic then\n             Freeze_Before (N, Old_S);\n             Freeze_Actual_Profile;\n             Set_Has_Delayed_Freeze (New_S, False);\n@@ -3624,6 +3632,25 @@ package body Sem_Ch8 is\n             Analyze (N);\n          end if;\n       end if;\n+\n+      --  Check if we are looking at an Ada 2012 defaulted formal subprogram\n+      --  and mark any use_package_clauses that affect the visibility of the\n+      --  implicit generic actual.\n+\n+      if From_Default (N)\n+           and then Is_Generic_Actual_Subprogram (New_S)\n+           and then Present (Alias (New_S))\n+      then\n+         Mark_Use_Clauses (Alias (New_S));\n+\n+      --  Check intrinsic operators used as generic actuals since they may\n+      --  make a use_type_clause effective.\n+\n+      elsif Is_Generic_Actual_Subprogram (New_S)\n+        and then Is_Intrinsic_Subprogram (New_S)\n+      then\n+         Mark_Use_Clauses (New_S);\n+      end if;\n    end Analyze_Subprogram_Renaming;\n \n    -------------------------\n@@ -3637,11 +3664,78 @@ package body Sem_Ch8 is\n    --  use. If the package is an open scope, i.e. if the use clause occurs\n    --  within the package itself, ignore it.\n \n-   procedure Analyze_Use_Package (N : Node_Id) is\n+   procedure Analyze_Use_Package (N : Node_Id; Chain : Boolean := True) is\n+\n+      procedure Analyze_Package_Name (Clause : Node_Id);\n+      --  Perform analysis on a package name from a use_package_clause\n+\n+      procedure Analyze_Package_Name_List (Head_Clause : Node_Id);\n+      --  Similar to Analyze_Package_Name but iterates over all the names\n+      --  in a use clause.\n+\n+      --------------------------\n+      -- Analyze_Package_Name --\n+      --------------------------\n+\n+      procedure Analyze_Package_Name (Clause : Node_Id) is\n+         Pack : constant Node_Id := Name (Clause);\n+         Pref : Node_Id;\n+\n+      begin\n+         pragma Assert (Nkind (Clause) = N_Use_Package_Clause);\n+         Analyze (Pack);\n+\n+         --  Verify that the package standard is not directly named in a\n+         --  use_package_clause.\n+\n+         if Nkind (Parent (Clause)) = N_Compilation_Unit\n+           and then Nkind (Pack) = N_Expanded_Name\n+         then\n+            Pref := Prefix (Pack);\n+\n+            while Nkind (Pref) = N_Expanded_Name loop\n+               Pref := Prefix (Pref);\n+            end loop;\n+\n+            if Entity (Pref) = Standard_Standard then\n+               Error_Msg_N\n+                 (\"predefined package Standard cannot appear in a \"\n+                  & \"context clause\", Pref);\n+            end if;\n+         end if;\n+      end Analyze_Package_Name;\n+\n+      -------------------------------\n+      -- Analyze_Package_Name_List --\n+      -------------------------------\n+\n+      procedure Analyze_Package_Name_List (Head_Clause : Node_Id) is\n+         Curr : Node_Id;\n+\n+      begin\n+         --  Due to the way source use clauses are split during parsing we are\n+         --  forced to simply iterate through all entities in scope until the\n+         --  clause representing the last name in the list is found.\n+\n+         Curr := Head_Clause;\n+         while Present (Curr) loop\n+            Analyze_Package_Name (Curr);\n+\n+            --  Stop iterating over the names in the use clause when we are at\n+            --  the last one.\n+\n+            exit when not More_Ids (Curr) and then Prev_Ids (Curr);\n+            Next (Curr);\n+         end loop;\n+      end Analyze_Package_Name_List;\n+\n+      --  Local variables\n+\n       Ghost_Id  : Entity_Id := Empty;\n       Living_Id : Entity_Id := Empty;\n       Pack      : Entity_Id;\n-      Pack_Name : Node_Id;\n+\n+   --  Start of processing for Analyze_Use_Package\n \n    begin\n       Check_SPARK_05_Restriction (\"use clause is not allowed\", N);\n@@ -3661,107 +3755,89 @@ package body Sem_Ch8 is\n          Error_Msg_N (\"use clause not allowed in predefined spec\", N);\n       end if;\n \n-      --  Chain clause to list of use clauses in current scope\n+      --  Loop through all package names from the original use clause in\n+      --  order to analyze referenced packages. A use_package_clause with only\n+      --  one name does not have More_Ids or Prev_Ids set, while a clause with\n+      --  More_Ids only starts the chain produced by the parser.\n \n-      if Nkind (Parent (N)) /= N_Compilation_Unit then\n-         Chain_Use_Clause (N);\n+      if not More_Ids (N) and then not Prev_Ids (N) then\n+         Analyze_Package_Name (N);\n+      elsif More_Ids (N) and then not Prev_Ids (N) then\n+         Analyze_Package_Name_List (N);\n       end if;\n \n-      --  Loop through package names to identify referenced packages\n-\n-      Pack_Name := First (Names (N));\n-      while Present (Pack_Name) loop\n-         Analyze (Pack_Name);\n-\n-         if Nkind (Parent (N)) = N_Compilation_Unit\n-           and then Nkind (Pack_Name) = N_Expanded_Name\n-         then\n-            declare\n-               Pref : Node_Id;\n-\n-            begin\n-               Pref := Prefix (Pack_Name);\n-               while Nkind (Pref) = N_Expanded_Name loop\n-                  Pref := Prefix (Pref);\n-               end loop;\n+      if not Is_Entity_Name (Name (N)) then\n+         Error_Msg_N (\"& is not a package\", Name (N));\n \n-               if Entity (Pref) = Standard_Standard then\n-                  Error_Msg_N\n-                    (\"predefined package Standard cannot appear in a context \"\n-                     & \"clause\", Pref);\n-               end if;\n-            end;\n-         end if;\n+         return;\n+      end if;\n+      Pack := Entity (Name (N));\n \n-         Next (Pack_Name);\n-      end loop;\n+      if Chain then\n+         Chain_Use_Clause (N);\n+      end if;\n \n-      --  Loop through package names to mark all entities as potentially use\n-      --  visible.\n+      --  There are many cases where scopes are manipulated during analysis, so\n+      --  check that Pack's current use clause has not already been chained\n+      --  before setting its previous use clause.\n \n-      Pack_Name := First (Names (N));\n-      while Present (Pack_Name) loop\n-         if Is_Entity_Name (Pack_Name) then\n-            Pack := Entity (Pack_Name);\n+      if Ekind (Pack) = E_Package\n+         and then Present (Current_Use_Clause (Pack))\n+         and then Current_Use_Clause (Pack) /= N\n+         and then No (Prev_Use_Clause (N))\n+      then\n+         Set_Prev_Use_Clause (N, Current_Use_Clause (Pack));\n+      end if;\n \n-            if Ekind (Pack) /= E_Package and then Etype (Pack) /= Any_Type then\n-               if Ekind (Pack) = E_Generic_Package then\n-                  Error_Msg_N  -- CODEFIX\n-                    (\"a generic package is not allowed in a use clause\",\n-                     Pack_Name);\n+      --  Mark all entities as potentially use visible.\n \n-               elsif Ekind_In (Pack, E_Generic_Function, E_Generic_Package)\n-               then\n-                  Error_Msg_N  -- CODEFIX\n-                    (\"a generic subprogram is not allowed in a use clause\",\n-                     Pack_Name);\n+      if Ekind (Pack) /= E_Package and then Etype (Pack) /= Any_Type then\n+         if Ekind (Pack) = E_Generic_Package then\n+            Error_Msg_N  -- CODEFIX\n+              (\"a generic package is not allowed in a use clause\",\n+               Name (N));\n \n-               elsif Ekind_In (Pack, E_Function, E_Procedure, E_Operator) then\n-                  Error_Msg_N  -- CODEFIX\n-                    (\"a subprogram is not allowed in a use clause\",\n-                     Pack_Name);\n+         elsif Ekind_In (Pack, E_Generic_Function, E_Generic_Package)\n+         then\n+            Error_Msg_N  -- CODEFIX\n+              (\"a generic subprogram is not allowed in a use clause\",\n+               Name (N));\n \n-               else\n-                  Error_Msg_N (\"& is not allowed in a use clause\", Pack_Name);\n-               end if;\n+         elsif Ekind_In (Pack, E_Function, E_Procedure, E_Operator) then\n+            Error_Msg_N  -- CODEFIX\n+              (\"a subprogram is not allowed in a use clause\",\n+               Name (N));\n \n-            else\n-               if Nkind (Parent (N)) = N_Compilation_Unit then\n-                  Check_In_Previous_With_Clause (N, Pack_Name);\n-               end if;\n+         else\n+            Error_Msg_N (\"& is not allowed in a use clause\", Name (N));\n+         end if;\n \n-               if Applicable_Use (Pack_Name) then\n-                  Use_One_Package (Pack, N);\n-               end if;\n+      else\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            Check_In_Previous_With_Clause (N, Name (N));\n+         end if;\n \n-               --  Capture the first Ghost package and the first living package\n+         Use_One_Package (N, Name (N));\n \n-               if Is_Entity_Name (Pack_Name) then\n-                  Pack := Entity (Pack_Name);\n+         --  Capture the first Ghost package and the first living package\n \n-                  if Is_Ghost_Entity (Pack) then\n-                     if No (Ghost_Id) then\n-                        Ghost_Id := Pack;\n-                     end if;\n+         if Is_Entity_Name (Name (N)) then\n+            Pack := Entity (Name (N));\n \n-                  elsif No (Living_Id) then\n-                     Living_Id := Pack;\n-                  end if;\n+            if Is_Ghost_Entity (Pack) then\n+               if No (Ghost_Id) then\n+                  Ghost_Id := Pack;\n                end if;\n-            end if;\n \n-         --  Report error because name denotes something other than a package\n-\n-         else\n-            Error_Msg_N (\"& is not a package\", Pack_Name);\n+            elsif No (Living_Id) then\n+               Living_Id := Pack;\n+            end if;\n          end if;\n-\n-         Next (Pack_Name);\n-      end loop;\n+      end if;\n \n       --  Detect a mixture of Ghost packages and living packages within the\n-      --  same use package clause. Ideally one would split a use package clause\n-      --  with multiple names into multiple use package clauses with a single\n+      --  same use_package_clause. Ideally one would split a use_package_clause\n+      --  with multiple names into multiple use_package_clauses with a single\n       --  name, however clients of the front end would have to adapt to this\n       --  change.\n \n@@ -3783,21 +3859,39 @@ package body Sem_Ch8 is\n    -- Analyze_Use_Type --\n    ----------------------\n \n-   procedure Analyze_Use_Type (N : Node_Id) is\n-      E         : Entity_Id;\n-      Ghost_Id  : Entity_Id := Empty;\n-      Id        : Node_Id;\n-      Living_Id : Entity_Id := Empty;\n+   procedure Analyze_Use_Type (N : Node_Id; Chain : Boolean := True) is\n+      E  : Entity_Id;\n+      Id : Node_Id;\n \n    begin\n       Set_Hidden_By_Use_Clause (N, No_Elist);\n \n-      --  Chain clause to list of use clauses in current scope\n+      --  Chain clause to list of use clauses in current scope when flagged\n \n-      if Nkind (Parent (N)) /= N_Compilation_Unit then\n+      if Chain then\n          Chain_Use_Clause (N);\n       end if;\n \n+      --  Obtain the base type of the type denoted within the use_type_clause's\n+      --  subtype mark.\n+\n+      Id := Subtype_Mark (N);\n+      Find_Type (Id);\n+      E := Base_Type (Entity (Id));\n+\n+      --  There are many cases where a use_type_clause may be reanalyzed due to\n+      --  manipulation of the scope stack so we much guard against those cases\n+      --  here, otherwise, we must add the new use_type_clause to the previous\n+      --  use_type_clause chain in order to mark redundant use_type_clauses as\n+      --  used.\n+\n+      if Present (Current_Use_Clause (E))\n+        and then Current_Use_Clause (E) /= N\n+        and then No (Prev_Use_Clause (N))\n+      then\n+         Set_Prev_Use_Clause (N, Current_Use_Clause (E));\n+      end if;\n+\n       --  If the Used_Operations list is already initialized, the clause has\n       --  been analyzed previously, and it is being reinstalled, for example\n       --  when the clause appears in a package spec and we are compiling the\n@@ -3806,15 +3900,10 @@ package body Sem_Ch8 is\n \n       if Present (Used_Operations (N)) then\n          declare\n-            Mark : Node_Id;\n             Elmt : Elmt_Id;\n \n          begin\n-            Mark := First (Subtype_Marks (N));\n-            while Present (Mark) loop\n-               Use_One_Type (Mark, Installed => True);\n-               Next (Mark);\n-            end loop;\n+            Use_One_Type (Subtype_Mark (N), Installed => True);\n \n             Elmt := First_Elmt (Used_Operations (N));\n             while Present (Elmt) loop\n@@ -3830,133 +3919,69 @@ package body Sem_Ch8 is\n       --  made use-visible by the clause.\n \n       Set_Used_Operations (N, New_Elmt_List);\n-      Id := First (Subtype_Marks (N));\n-      while Present (Id) loop\n-         Find_Type (Id);\n-         E := Entity (Id);\n-\n-         if E /= Any_Type then\n-            Use_One_Type (Id);\n+      E := Entity (Id);\n \n-            if Nkind (Parent (N)) = N_Compilation_Unit then\n-               if Nkind (Id) = N_Identifier then\n-                  Error_Msg_N (\"type is not directly visible\", Id);\n+      if E /= Any_Type then\n+         Use_One_Type (Id);\n \n-               elsif Is_Child_Unit (Scope (E))\n-                 and then Scope (E) /= System_Aux_Id\n-               then\n-                  Check_In_Previous_With_Clause (N, Prefix (Id));\n-               end if;\n-            end if;\n-\n-         else\n-            --  If the use_type_clause appears in a compilation unit context,\n-            --  check whether it comes from a unit that may appear in a\n-            --  limited_with_clause, for a better error message.\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            if Nkind (Id) = N_Identifier then\n+               Error_Msg_N (\"type is not directly visible\", Id);\n \n-            if Nkind (Parent (N)) = N_Compilation_Unit\n-              and then Nkind (Id) /= N_Identifier\n+            elsif Is_Child_Unit (Scope (E))\n+              and then Scope (E) /= System_Aux_Id\n             then\n-               declare\n-                  Item : Node_Id;\n-                  Pref : Node_Id;\n-\n-                  function Mentioned (Nam : Node_Id) return Boolean;\n-                  --  Check whether the prefix of expanded name for the type\n-                  --  appears in the prefix of some limited_with_clause.\n-\n-                  ---------------\n-                  -- Mentioned --\n-                  ---------------\n-\n-                  function Mentioned (Nam : Node_Id) return Boolean is\n-                  begin\n-                     return Nkind (Name (Item)) = N_Selected_Component\n-                       and then Chars (Prefix (Name (Item))) = Chars (Nam);\n-                  end Mentioned;\n-\n-               begin\n-                  Pref := Prefix (Id);\n-                  Item := First (Context_Items (Parent (N)));\n-                  while Present (Item) and then Item /= N loop\n-                     if Nkind (Item) = N_With_Clause\n-                       and then Limited_Present (Item)\n-                       and then Mentioned (Pref)\n-                     then\n-                        Change_Error_Text\n-                          (Get_Msg_Id, \"premature usage of incomplete type\");\n-                     end if;\n-\n-                     Next (Item);\n-                  end loop;\n-               end;\n+               Check_In_Previous_With_Clause (N, Prefix (Id));\n             end if;\n          end if;\n \n-         --  Capture the first Ghost type and the first living type\n-\n-         if Is_Ghost_Entity (E) then\n-            if No (Ghost_Id) then\n-               Ghost_Id := E;\n-            end if;\n+      else\n+         --  If the use_type_clause appears in a compilation unit context,\n+         --  check whether it comes from a unit that may appear in a\n+         --  limited_with_clause, for a better error message.\n \n-         elsif No (Living_Id) then\n-            Living_Id := E;\n-         end if;\n+         if Nkind (Parent (N)) = N_Compilation_Unit\n+           and then Nkind (Id) /= N_Identifier\n+         then\n+            declare\n+               Item : Node_Id;\n+               Pref : Node_Id;\n \n-         Next (Id);\n-      end loop;\n+               function Mentioned (Nam : Node_Id) return Boolean;\n+               --  Check whether the prefix of expanded name for the type\n+               --  appears in the prefix of some limited_with_clause.\n \n-      --  Detect a mixture of Ghost types and living types within the same use\n-      --  type clause. Ideally one would split a use type clause with multiple\n-      --  marks into multiple use type clauses with a single mark, however\n-      --  clients of the front end will have to adapt to this change.\n+               ---------------\n+               -- Mentioned --\n+               ---------------\n \n-      if Present (Ghost_Id) and then Present (Living_Id) then\n-         Error_Msg_N\n-           (\"use clause cannot mention ghost and non-ghost ghost types\", N);\n+               function Mentioned (Nam : Node_Id) return Boolean is\n+               begin\n+                  return Nkind (Name (Item)) = N_Selected_Component\n+                    and then Chars (Prefix (Name (Item))) = Chars (Nam);\n+               end Mentioned;\n \n-         Error_Msg_Sloc := Sloc (Ghost_Id);\n-         Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+            begin\n+               Pref := Prefix (Id);\n+               Item := First (Context_Items (Parent (N)));\n+               while Present (Item) and then Item /= N loop\n+                  if Nkind (Item) = N_With_Clause\n+                    and then Limited_Present (Item)\n+                    and then Mentioned (Pref)\n+                  then\n+                     Change_Error_Text\n+                       (Get_Msg_Id, \"premature usage of incomplete type\");\n+                  end if;\n \n-         Error_Msg_Sloc := Sloc (Living_Id);\n-         Error_Msg_NE (\"\\& # declared as non-ghost\", N, Living_Id);\n+                  Next (Item);\n+               end loop;\n+            end;\n+         end if;\n       end if;\n \n       Mark_Ghost_Clause (N);\n    end Analyze_Use_Type;\n \n-   --------------------\n-   -- Applicable_Use --\n-   --------------------\n-\n-   function Applicable_Use (Pack_Name : Node_Id) return Boolean is\n-      Pack : constant Entity_Id := Entity (Pack_Name);\n-\n-   begin\n-      if In_Open_Scopes (Pack) then\n-         if Warn_On_Redundant_Constructs and then Pack = Current_Scope then\n-            Error_Msg_NE -- CODEFIX\n-              (\"& is already use-visible within itself?r?\", Pack_Name, Pack);\n-         end if;\n-\n-         return False;\n-\n-      elsif In_Use (Pack) then\n-         Note_Redundant_Use (Pack_Name);\n-         return False;\n-\n-      elsif Present (Renamed_Object (Pack))\n-        and then In_Use (Renamed_Object (Pack))\n-      then\n-         Note_Redundant_Use (Pack_Name);\n-         return False;\n-\n-      else\n-         return True;\n-      end if;\n-   end Applicable_Use;\n-\n    ------------------------\n    -- Attribute_Renaming --\n    ------------------------\n@@ -4186,21 +4211,27 @@ package body Sem_Ch8 is\n       Level : Int := Scope_Stack.Last;\n \n    begin\n+      --  Common case\n+\n       if not Is_Compilation_Unit (Current_Scope)\n         or else not Is_Child_Unit (Current_Scope)\n       then\n-         null;   --  Common case\n+         null;\n \n-      elsif Defining_Entity (Parent (N)) = Current_Scope then\n-         null;   --  Common case for compilation unit\n+      --  Common case for compilation unit\n+\n+      elsif Defining_Entity (N               => Parent (N),\n+                             Empty_On_Errors => True) = Current_Scope\n+      then\n+         null;\n \n       else\n          --  If declaration appears in some other scope, it must be in some\n          --  parent unit when compiling a child.\n \n-         Pack := Defining_Entity (Parent (N));\n+         Pack := Defining_Entity (Parent (N), Empty_On_Errors => True);\n          if not In_Open_Scopes (Pack) then\n-            null;  --  default as well\n+            null;\n \n          --  If the use clause appears in an ancestor and we are in the\n          --  private part of the immediate parent, the use clauses are\n@@ -4547,11 +4578,11 @@ package body Sem_Ch8 is\n    ---------------------\n \n    procedure End_Use_Clauses (Clause : Node_Id) is\n-      U   : Node_Id;\n+      U : Node_Id;\n \n    begin\n-      --  Remove Use_Type clauses first, because they affect the\n-      --  visibility of operators in subsequent used packages.\n+      --  Remove use_type_clauses first, because they affect the visibility of\n+      --  operators in subsequent used packages.\n \n       U := Clause;\n       while Present (U) loop\n@@ -4577,8 +4608,8 @@ package body Sem_Ch8 is\n    ---------------------\n \n    procedure End_Use_Package (N : Node_Id) is\n-      Pack_Name : Node_Id;\n       Pack      : Entity_Id;\n+      Pack_Name : Node_Id;\n       Id        : Entity_Id;\n       Elmt      : Elmt_Id;\n \n@@ -4603,43 +4634,64 @@ package body Sem_Ch8 is\n    --  Start of processing for End_Use_Package\n \n    begin\n-      Pack_Name := First (Names (N));\n-      while Present (Pack_Name) loop\n+      Pack_Name := Name (N);\n \n-         --  Test that Pack_Name actually denotes a package before processing\n+      --  Test that Pack_Name actually denotes a package before processing\n \n-         if Is_Entity_Name (Pack_Name)\n-           and then Ekind (Entity (Pack_Name)) = E_Package\n-         then\n-            Pack := Entity (Pack_Name);\n+      if Is_Entity_Name (Pack_Name)\n+        and then Ekind (Entity (Pack_Name)) = E_Package\n+      then\n+         Pack := Entity (Pack_Name);\n \n-            if In_Open_Scopes (Pack) then\n-               null;\n+         if In_Open_Scopes (Pack) then\n+            null;\n \n-            elsif not Redundant_Use (Pack_Name) then\n-               Set_In_Use (Pack, False);\n-               Set_Current_Use_Clause (Pack, Empty);\n+         elsif not Redundant_Use (Pack_Name) then\n+            Set_In_Use (Pack, False);\n+            Set_Current_Use_Clause (Pack, Empty);\n \n-               Id := First_Entity (Pack);\n-               while Present (Id) loop\n+            Id := First_Entity (Pack);\n+            while Present (Id) loop\n \n-                  --  Preserve use-visibility of operators that are primitive\n-                  --  operators of a type that is use-visible through an active\n-                  --  use_type clause.\n+               --  Preserve use-visibility of operators that are primitive\n+               --  operators of a type that is use-visible through an active\n+               --  use_type_clause.\n \n-                  if Nkind (Id) = N_Defining_Operator_Symbol\n-                    and then\n-                      (Is_Primitive_Operator_In_Use (Id, First_Formal (Id))\n-                        or else\n-                          (Present (Next_Formal (First_Formal (Id)))\n-                            and then\n-                              Is_Primitive_Operator_In_Use\n-                                (Id, Next_Formal (First_Formal (Id)))))\n-                  then\n-                     null;\n-                  else\n-                     Set_Is_Potentially_Use_Visible (Id, False);\n-                  end if;\n+               if Nkind (Id) = N_Defining_Operator_Symbol\n+                 and then\n+                   (Is_Primitive_Operator_In_Use (Id, First_Formal (Id))\n+                     or else\n+                       (Present (Next_Formal (First_Formal (Id)))\n+                         and then\n+                           Is_Primitive_Operator_In_Use\n+                             (Id, Next_Formal (First_Formal (Id)))))\n+               then\n+                  null;\n+               else\n+                  Set_Is_Potentially_Use_Visible (Id, False);\n+               end if;\n+\n+               if Is_Private_Type (Id)\n+                 and then Present (Full_View (Id))\n+               then\n+                  Set_Is_Potentially_Use_Visible (Full_View (Id), False);\n+               end if;\n+\n+               Next_Entity (Id);\n+            end loop;\n+\n+            if Present (Renamed_Object (Pack)) then\n+               Set_In_Use (Renamed_Object (Pack), False);\n+               Set_Current_Use_Clause (Renamed_Object (Pack), Empty);\n+            end if;\n+\n+            if Chars (Pack) = Name_System\n+              and then Scope (Pack) = Standard_Standard\n+              and then Present_System_Aux\n+            then\n+               Id := First_Entity (System_Aux_Id);\n+               while Present (Id) loop\n+                  Set_Is_Potentially_Use_Visible (Id, False);\n \n                   if Is_Private_Type (Id)\n                     and then Present (Full_View (Id))\n@@ -4650,38 +4702,12 @@ package body Sem_Ch8 is\n                   Next_Entity (Id);\n                end loop;\n \n-               if Present (Renamed_Object (Pack)) then\n-                  Set_In_Use (Renamed_Object (Pack), False);\n-                  Set_Current_Use_Clause (Renamed_Object (Pack), Empty);\n-               end if;\n-\n-               if Chars (Pack) = Name_System\n-                 and then Scope (Pack) = Standard_Standard\n-                 and then Present_System_Aux\n-               then\n-                  Id := First_Entity (System_Aux_Id);\n-                  while Present (Id) loop\n-                     Set_Is_Potentially_Use_Visible (Id, False);\n-\n-                     if Is_Private_Type (Id)\n-                       and then Present (Full_View (Id))\n-                     then\n-                        Set_Is_Potentially_Use_Visible (Full_View (Id), False);\n-                     end if;\n-\n-                     Next_Entity (Id);\n-                  end loop;\n-\n-                  Set_In_Use (System_Aux_Id, False);\n-               end if;\n-\n-            else\n-               Set_Redundant_Use (Pack_Name, False);\n+               Set_In_Use (System_Aux_Id, False);\n             end if;\n+         else\n+            Set_Redundant_Use (Pack_Name, False);\n          end if;\n-\n-         Next (Pack_Name);\n-      end loop;\n+      end if;\n \n       if Present (Hidden_By_Use_Clause (N)) then\n          Elmt := First_Elmt (Hidden_By_Use_Clause (N));\n@@ -4714,30 +4740,26 @@ package body Sem_Ch8 is\n    ------------------\n \n    procedure End_Use_Type (N : Node_Id) is\n-      Elmt    : Elmt_Id;\n-      Id      : Entity_Id;\n-      T       : Entity_Id;\n+      Elmt : Elmt_Id;\n+      Id   : Entity_Id;\n+      T    : Entity_Id;\n \n    --  Start of processing for End_Use_Type\n \n    begin\n-      Id := First (Subtype_Marks (N));\n-      while Present (Id) loop\n+      Id := Subtype_Mark (N);\n \n-         --  A call to Rtsfind may occur while analyzing a use_type clause,\n-         --  in which case the type marks are not resolved yet, and there is\n-         --  nothing to remove.\n-\n-         if not Is_Entity_Name (Id) or else No (Entity (Id)) then\n-            goto Continue;\n-         end if;\n+      --  A call to Rtsfind may occur while analyzing a use_type_clause, in\n+      --  which case the type marks are not resolved yet, so guard against that\n+      --  here.\n \n+      if Is_Entity_Name (Id) and then Present (Entity (Id)) then\n          T := Entity (Id);\n \n          if T = Any_Type or else From_Limited_With (T) then\n             null;\n \n-         --  Note that the use_type clause may mention a subtype of the type\n+         --  Note that the use_type_clause may mention a subtype of the type\n          --  whose primitive operations have been made visible. Here as\n          --  elsewhere, it is the base type that matters for visibility.\n \n@@ -4750,10 +4772,7 @@ package body Sem_Ch8 is\n             Set_Current_Use_Clause (T, Empty);\n             Set_Current_Use_Clause (Base_Type (T), Empty);\n          end if;\n-\n-         <<Continue>>\n-            Next (Id);\n-      end loop;\n+      end if;\n \n       if Is_Empty_Elmt_List (Used_Operations (N)) then\n          return;\n@@ -4767,6 +4786,21 @@ package body Sem_Ch8 is\n       end if;\n    end End_Use_Type;\n \n+   --------------------\n+   -- Entity_Of_Unit --\n+   --------------------\n+\n+   function Entity_Of_Unit (U : Node_Id) return Entity_Id is\n+   begin\n+      if Nkind (U) = N_Package_Instantiation\n+        and then Analyzed (U)\n+      then\n+         return Defining_Entity (Instance_Spec (U));\n+      else\n+         return Defining_Entity (U);\n+      end if;\n+   end Entity_Of_Unit;\n+\n    ----------------------\n    -- Find_Direct_Name --\n    ----------------------\n@@ -5384,6 +5418,17 @@ package body Sem_Ch8 is\n             end;\n          end if;\n \n+         --  Although the marking of use clauses happens at the end of\n+         --  Find_Direct_Name, a certain case where a generic actual satisfies\n+         --  a use clause must be checked here due to how the generic machinery\n+         --  handles the analysis of said actuals.\n+\n+         if In_Instance\n+           and then Nkind (Parent (N)) = N_Generic_Association\n+         then\n+            Mark_Use_Clauses (Entity (N));\n+         end if;\n+\n          return;\n       end if;\n \n@@ -5561,7 +5606,7 @@ package body Sem_Ch8 is\n                goto Done;\n \n             elsif Is_Predefined_Unit (Current_Sem_Unit) then\n-               --  A use-clause in the body of a system file creates conflict\n+               --  A use clause in the body of a system file creates conflict\n                --  with some entity in a user scope, while rtsfind is active.\n                --  Keep only the entity coming from another predefined unit.\n \n@@ -5843,6 +5888,20 @@ package body Sem_Ch8 is\n          end if;\n       end;\n \n+      --  Mark relevant use-type and use-package clauses as effective if the\n+      --  node in question is not overloaded and therefore does not require\n+      --  resolution.\n+      --\n+      --  Note: Generic actual subprograms do not follow the normal resolution\n+      --  path, so ignore the fact that they are overloaded and mark them\n+      --  anyway.\n+\n+      if Nkind (N) not in N_Subexpr\n+        or else not Is_Overloaded (N)\n+      then\n+         Mark_Use_Clauses (N);\n+      end if;\n+\n    --  Come here with entity set\n \n    <<Done>>\n@@ -6460,9 +6519,34 @@ package body Sem_Ch8 is\n          Generate_Reference (Id, N);\n       end if;\n \n+      --  Mark relevant use-type and use-package clauses as effective if the\n+      --  node in question is not overloaded and therefore does not require\n+      --  resolution.\n+\n+      if Nkind (N) not in N_Subexpr or else not Is_Overloaded (N) then\n+         Mark_Use_Clauses (N);\n+      end if;\n+\n       Check_Restriction_No_Use_Of_Entity (N);\n    end Find_Expanded_Name;\n \n+   --------------------\n+   -- Find_Most_Prev --\n+   --------------------\n+\n+   function Find_Most_Prev (Use_Clause : Node_Id) return Node_Id is\n+      Curr : Node_Id;\n+   begin\n+      --  Loop through the Prev_Use_Clause chain\n+\n+      Curr := Use_Clause;\n+      while Present (Prev_Use_Clause (Curr)) loop\n+         Curr := Prev_Use_Clause (Curr);\n+      end loop;\n+\n+      return Curr;\n+   end Find_Most_Prev;\n+\n    -------------------------\n    -- Find_Renamed_Entity --\n    -------------------------\n@@ -8039,9 +8123,7 @@ package body Sem_Ch8 is\n      (Clause             : Node_Id;\n       Force_Installation : Boolean := False)\n    is\n-      U  : Node_Id;\n-      P  : Node_Id;\n-      Id : Entity_Id;\n+      U : Node_Id;\n \n    begin\n       U := Clause;\n@@ -8050,44 +8132,13 @@ package body Sem_Ch8 is\n          --  Case of USE package\n \n          if Nkind (U) = N_Use_Package_Clause then\n-            P := First (Names (U));\n-            while Present (P) loop\n-               Id := Entity (P);\n-\n-               if Ekind (Id) = E_Package then\n-                  if In_Use (Id) then\n-                     Note_Redundant_Use (P);\n-\n-                  elsif Present (Renamed_Object (Id))\n-                    and then In_Use (Renamed_Object (Id))\n-                  then\n-                     Note_Redundant_Use (P);\n-\n-                  elsif Force_Installation or else Applicable_Use (P) then\n-                     Use_One_Package (Id, U);\n-\n-                  end if;\n-               end if;\n-\n-               Next (P);\n-            end loop;\n+            Use_One_Package (U, Name (U), True);\n \n          --  Case of USE TYPE\n \n          else\n-            P := First (Subtype_Marks (U));\n-            while Present (P) loop\n-               if not Is_Entity_Name (P)\n-                 or else No (Entity (P))\n-               then\n-                  null;\n+            Use_One_Type (Subtype_Mark (U), Force => Force_Installation);\n \n-               elsif Entity (P) /= Any_Type then\n-                  Use_One_Type (P);\n-               end if;\n-\n-               Next (P);\n-            end loop;\n          end if;\n \n          Next_Use_Clause (U);\n@@ -8145,196 +8196,268 @@ package body Sem_Ch8 is\n                                and then Has_Components (Designated_Type (T))));\n    end Is_Appropriate_For_Record;\n \n-   ------------------------\n-   -- Note_Redundant_Use --\n-   ------------------------\n+   ----------------------\n+   -- Mark_Use_Clauses --\n+   ----------------------\n \n-   procedure Note_Redundant_Use (Clause : Node_Id) is\n-      Pack_Name : constant Entity_Id := Entity (Clause);\n-      Cur_Use   : constant Node_Id   := Current_Use_Clause (Pack_Name);\n-      Decl      : constant Node_Id   := Parent (Clause);\n+   procedure Mark_Use_Clauses (Id : Node_Or_Entity_Id) is\n \n-      Prev_Use   : Node_Id := Empty;\n-      Redundant  : Node_Id := Empty;\n-      --  The Use_Clause which is actually redundant. In the simplest case it\n-      --  is Pack itself, but when we compile a body we install its context\n-      --  before that of its spec, in which case it is the use_clause in the\n-      --  spec that will appear to be redundant, and we want the warning to be\n-      --  placed on the body. Similar complications appear when the redundancy\n-      --  is between a child unit and one of its ancestors.\n+      procedure Mark_Parameters (Call : Entity_Id);\n+      --  Perform use_type_clause marking for all parameters in a subprogram\n+      --  or operator call.\n \n-   begin\n-      Set_Redundant_Use (Clause, True);\n+      procedure Mark_Use_Package (Pak : Entity_Id);\n+      --  Move up the Prev_Use_Clause chain for packages denoted by Pak -\n+      --  marking each clause in the chain as effective in the process.\n \n-      if not Comes_From_Source (Clause)\n-        or else In_Instance\n-        or else not Warn_On_Redundant_Constructs\n-      then\n-         return;\n-      end if;\n+      procedure Mark_Use_Type (E : Entity_Id);\n+      --  Similar to Do_Use_Package_Marking except we move up the\n+      --  Prev_Use_Clause chain for the type denoted by E.\n \n-      if not Is_Compilation_Unit (Current_Scope) then\n+      ---------------------\n+      -- Mark_Parameters --\n+      ---------------------\n \n-         --  If the use_clause is in an inner scope, it is made redundant by\n-         --  some clause in the current context, with one exception: If we're\n-         --  compiling a nested package body, and the use_clause comes from the\n-         --  corresponding spec, the clause is not necessarily fully redundant,\n-         --  so we should not warn. If a warning was warranted, it would have\n-         --  been given when the spec was processed.\n+      procedure Mark_Parameters (Call : Entity_Id) is\n+         Curr : Node_Id;\n \n-         if Nkind (Parent (Decl)) = N_Package_Specification then\n-            declare\n-               Package_Spec_Entity : constant Entity_Id :=\n-                                       Defining_Unit_Name (Parent (Decl));\n-            begin\n-               if In_Package_Body (Package_Spec_Entity) then\n-                  return;\n-               end if;\n-            end;\n-         end if;\n+      begin\n+         --  Move through all of the formals\n \n-         Redundant := Clause;\n-         Prev_Use  := Cur_Use;\n+         Curr := First_Formal (Call);\n+         while Present (Curr) loop\n+            Mark_Use_Type (Curr);\n \n-      elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Body then\n-         declare\n-            Cur_Unit : constant Unit_Number_Type := Get_Source_Unit (Cur_Use);\n-            New_Unit : constant Unit_Number_Type := Get_Source_Unit (Clause);\n-            Scop     : Entity_Id;\n+            Curr := Next_Formal (Curr);\n+         end loop;\n \n-         begin\n-            if Cur_Unit = New_Unit then\n+         --  Handle the return type\n \n-               --  Redundant clause in same body\n+         Mark_Use_Type (Call);\n+      end Mark_Parameters;\n \n-               Redundant := Clause;\n-               Prev_Use  := Cur_Use;\n+      ----------------------\n+      -- Mark_Use_Package --\n+      ----------------------\n \n-            elsif Cur_Unit = Current_Sem_Unit then\n+      procedure Mark_Use_Package (Pak : Entity_Id) is\n+         Curr : Node_Id;\n \n-               --  If the new clause is not in the current unit it has been\n-               --  analyzed first, and it makes the other one redundant.\n-               --  However, if the new clause appears in a subunit, Cur_Unit\n-               --  is still the parent, and in that case the redundant one\n-               --  is the one appearing in the subunit.\n+      begin\n+         --  Ignore cases where the scope of the type is not a package\n+         --  (e.g. Standard_Standard).\n \n-               if Nkind (Unit (Cunit (New_Unit))) = N_Subunit then\n-                  Redundant := Clause;\n-                  Prev_Use  := Cur_Use;\n+         if Ekind (Pak) /= E_Package then\n+            return;\n+         end if;\n \n-               --  Most common case: redundant clause in body,\n-               --  original clause in spec. Current scope is spec entity.\n+         Curr := Current_Use_Clause (Pak);\n+         while Present (Curr)\n+            and then not Is_Effective_Use_Clause (Curr)\n+         loop\n+            --  We need to mark the previous use clauses as effective, but each\n+            --  use clause may in turn render other use_package_clauses\n+            --  effective. Additionally, it is possible to have a parent\n+            --  package renamed as a child of itself so we must check the\n+            --  prefix entity is not the same as the package we are marking.\n+\n+            if Nkind (Name (Curr)) /= N_Identifier\n+              and then Present (Prefix (Name (Curr)))\n+              and then Entity (Prefix (Name (Curr))) /= Pak\n+            then\n+               Mark_Use_Package (Entity (Prefix (Name (Curr))));\n \n-               elsif\n-                 Current_Scope =\n-                   Defining_Entity (\n-                     Unit (Library_Unit (Cunit (Current_Sem_Unit))))\n-               then\n-                  Redundant := Cur_Use;\n-                  Prev_Use  := Clause;\n+            --  It is also possible to have a child package without a prefix\n+            --  that relies on a previous use_package_clause.\n \n-               else\n-                  --  The new clause may appear in an unrelated unit, when\n-                  --  the parents of a generic are being installed prior to\n-                  --  instantiation. In this case there must be no warning.\n-                  --  We detect this case by checking whether the current top\n-                  --  of the stack is related to the current compilation.\n-\n-                  Scop := Current_Scope;\n-                  while Present (Scop) and then Scop /= Standard_Standard loop\n-                     if Is_Compilation_Unit (Scop)\n-                       and then not Is_Child_Unit (Scop)\n-                     then\n-                        return;\n+            elsif Nkind (Name (Curr)) = N_Identifier\n+              and then Is_Child_Unit (Entity (Name (Curr)))\n+            then\n+               Mark_Use_Package (Scope (Entity (Name (Curr))));\n+            end if;\n \n-                     elsif Scop = Cunit_Entity (Current_Sem_Unit) then\n-                        exit;\n-                     end if;\n+            --  Mark the use_package_clause as effective and move up the chain\n \n-                     Scop := Scope (Scop);\n-                  end loop;\n+            Set_Is_Effective_Use_Clause (Curr);\n \n-                  Redundant := Cur_Use;\n-                  Prev_Use  := Clause;\n-               end if;\n+            Curr := Prev_Use_Clause (Curr);\n+         end loop;\n+      end Mark_Use_Package;\n \n-            elsif New_Unit = Current_Sem_Unit then\n-               Redundant := Clause;\n-               Prev_Use  := Cur_Use;\n+      -------------------\n+      -- Mark_Use_Type --\n+      -------------------\n \n-            else\n-               --  Neither is the current unit, so they appear in parent or\n-               --  sibling units. Warning will be emitted elsewhere.\n+      procedure Mark_Use_Type (E : Entity_Id) is\n+         Curr : Node_Id;\n \n-               return;\n+      begin\n+         --  Ignore void types and unresolved string literals and primitives\n+\n+         if Nkind (E) = N_String_Literal\n+           or else Nkind (Etype (E)) not in N_Entity\n+           or else not Is_Type (Etype (E))\n+         then\n+            return;\n+         end if;\n+\n+         --  The package containing the type or operator function being used\n+         --  may be in use as well, so mark any use_package_clauses for it as\n+         --  effective. There are also additional sanity checks performed here\n+         --  for ignoring previous errors.\n+\n+         Mark_Use_Package (Scope (Base_Type (Etype (E))));\n+         if Nkind (E) in N_Op\n+           and then Present (Entity (E))\n+           and then Present (Scope (Entity (E)))\n+         then\n+            Mark_Use_Package (Scope (Entity (E)));\n+         end if;\n+\n+         Curr := Current_Use_Clause (Base_Type (Etype (E)));\n+         while Present (Curr)\n+            and then not Is_Effective_Use_Clause (Curr)\n+         loop\n+            --  Current use_type_clause may render other use_package_clauses\n+            --  effective.\n+\n+            if Nkind (Subtype_Mark (Curr)) /= N_Identifier\n+              and then Present (Prefix (Subtype_Mark (Curr)))\n+            then\n+               Mark_Use_Package (Entity (Prefix (Subtype_Mark (Curr))));\n             end if;\n-         end;\n \n-      elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Declaration\n-        and then Present (Parent_Spec (Unit (Cunit (Current_Sem_Unit))))\n-      then\n-         --  Use_clause is in child unit of current unit, and the child unit\n-         --  appears in the context of the body of the parent, so it has been\n-         --  installed first, even though it is the redundant one. Depending on\n-         --  their placement in the context, the visible or the private parts\n-         --  of the two units, either might appear as redundant, but the\n-         --  message has to be on the current unit.\n-\n-         if Get_Source_Unit (Cur_Use) = Current_Sem_Unit then\n-            Redundant := Cur_Use;\n-            Prev_Use  := Clause;\n-         else\n-            Redundant := Clause;\n-            Prev_Use  := Cur_Use;\n+            --  Mark the use_type_clause as effective and move up the chain\n+\n+            Set_Is_Effective_Use_Clause (Curr);\n+\n+            Curr := Prev_Use_Clause (Curr);\n+         end loop;\n+      end Mark_Use_Type;\n+\n+   --  Start of processing for Mark_Use_Clauses\n+\n+   begin\n+      --  Use clauses in and of themselves do not count as a \"use\" of a\n+      --  package.\n+\n+      if Nkind_In (Parent (Id), N_Use_Type_Clause, N_Use_Package_Clause) then\n+         return;\n+      end if;\n+\n+      --  Handle entities\n+\n+      if Nkind (Id) in N_Entity then\n+\n+         --  Mark the entity's package\n+\n+         if Is_Potentially_Use_Visible (Id) then\n+            Mark_Use_Package (Scope (Id));\n          end if;\n \n-         --  If the new use clause appears in the private part of a parent unit\n-         --  it may appear to be redundant w.r.t. a use clause in a child unit,\n-         --  but the previous use clause was needed in the visible part of the\n-         --  child, and no warning should be emitted.\n+         --  Mark enumeration literals\n \n-         if Nkind (Parent (Decl)) = N_Package_Specification\n-           and then\n-             List_Containing (Decl) = Private_Declarations (Parent (Decl))\n+         if Ekind (Id) = E_Enumeration_Literal then\n+            Mark_Use_Type (Id);\n+\n+         --  Mark primitives\n+\n+         elsif (Ekind (Id) in Overloadable_Kind\n+                 or else Ekind_In\n+                   (Ekind (Id), E_Generic_Function, E_Generic_Procedure))\n+           and then (Is_Potentially_Use_Visible (Id)\n+                      or else Is_Intrinsic_Subprogram (Id))\n          then\n-            declare\n-               Par : constant Entity_Id := Defining_Entity (Parent (Decl));\n-               Spec : constant Node_Id  :=\n-                        Specification (Unit (Cunit (Current_Sem_Unit)));\n+            Mark_Parameters (Id);\n+         end if;\n \n-            begin\n-               if Is_Compilation_Unit (Par)\n-                 and then Par /= Cunit_Entity (Current_Sem_Unit)\n-                 and then Parent (Cur_Use) = Spec\n-                 and then\n-                   List_Containing (Cur_Use) = Visible_Declarations (Spec)\n-               then\n-                  return;\n+      --  Handle nodes\n+\n+      else\n+         --  Mark operators\n+\n+         if Nkind (Id) in N_Op then\n+\n+            --  At this point the left operand may not be resolved if we are\n+            --  encountering multiple operators next to eachother in an\n+            --  expression.\n+\n+            if Nkind (Id) in N_Binary_Op\n+               and then not (Nkind (Left_Opnd (Id)) in N_Op)\n+            then\n+               Mark_Use_Type (Left_Opnd (Id));\n+            end if;\n+\n+            Mark_Use_Type (Right_Opnd (Id));\n+            Mark_Use_Type (Id);\n+\n+         --  Mark entity identifiers\n+\n+         elsif Nkind (Id) in N_Has_Entity\n+           and then (Is_Potentially_Use_Visible (Entity (Id))\n+                      or else (Is_Generic_Instance (Entity (Id))\n+                                and then Is_Immediately_Visible (Entity (Id))))\n+         then\n+            --  Ignore fully qualified names as they do not count as a \"use\" of\n+            --  a package.\n+\n+            if Nkind_In (Id, N_Identifier, N_Operator_Symbol)\n+              or else (Present (Prefix (Id))\n+                         and then Scope (Entity (Id)) /= Entity (Prefix (Id)))\n+            then\n+               --  There is a case whereby a unary operator is used within a\n+               --  qualified expression, so mark the parameters as well as the\n+               --  entity.\n+\n+               if Nkind (Entity (Id)) = N_Defining_Operator_Symbol then\n+                  Mark_Parameters (Entity (Id));\n                end if;\n-            end;\n+\n+               Mark_Use_Package (Scope (Entity (Id)));\n+            end if;\n          end if;\n+      end if;\n+   end Mark_Use_Clauses;\n \n-      --  Finally, if the current use clause is in the context then\n-      --  the clause is redundant when it is nested within the unit.\n+   --------------------------------\n+   -- Most_Descendant_Use_Clause --\n+   --------------------------------\n \n-      elsif Nkind (Parent (Cur_Use)) = N_Compilation_Unit\n-        and then Nkind (Parent (Parent (Clause))) /= N_Compilation_Unit\n-        and then Get_Source_Unit (Cur_Use) = Get_Source_Unit (Clause)\n-      then\n-         Redundant := Clause;\n-         Prev_Use  := Cur_Use;\n+   function Most_Descendant_Use_Clause\n+     (Clause1 : Entity_Id;\n+      Clause2 : Entity_Id) return Entity_Id\n+   is\n+      Scope1, Scope2 : Entity_Id;\n \n-      else\n-         null;\n+   begin\n+      if Clause1 = Clause2 then\n+         return Clause1;\n       end if;\n \n-      if Present (Redundant) then\n-         Error_Msg_Sloc := Sloc (Prev_Use);\n-         Error_Msg_NE -- CODEFIX\n-           (\"& is already use-visible through previous use clause #??\",\n-            Redundant, Pack_Name);\n+      --  We determine which one is the most descendant by the scope distance\n+      --  to the ultimate parent unit.\n+\n+      Scope1 := Entity_Of_Unit (Unit (Parent (Clause1)));\n+      Scope2 := Entity_Of_Unit (Unit (Parent (Clause2)));\n+      while Scope1 /= Standard_Standard\n+        and then Scope2 /= Standard_Standard\n+      loop\n+         Scope1 := Scope (Scope1);\n+         Scope2 := Scope (Scope2);\n+\n+         if not Present (Scope1) then\n+            return Clause1;\n+         elsif not Present (Scope2) then\n+            return Clause2;\n+         end if;\n+      end loop;\n+\n+      if Scope1 = Standard_Standard then\n+         return Clause1;\n       end if;\n-   end Note_Redundant_Use;\n+\n+      return Clause2;\n+   end Most_Descendant_Use_Clause;\n \n    ---------------\n    -- Pop_Scope --\n@@ -8400,9 +8523,9 @@ package body Sem_Ch8 is\n       Scope_Stack.Decrement_Last;\n    end Pop_Scope;\n \n-   ---------------\n+   ----------------\n    -- Push_Scope --\n-   ---------------\n+   ----------------\n \n    procedure Push_Scope (S : Entity_Id) is\n       E : constant Entity_Id := Scope (S);\n@@ -8776,7 +8899,8 @@ package body Sem_Ch8 is\n         and then Scope_Stack.Table (SS_Last).Entity /= Standard_Standard\n         and then Handle_Use\n       then\n-         Install_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause);\n+         Install_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause,\n+                               Force_Installation => True);\n       end if;\n    end Restore_Scope_Stack;\n \n@@ -8873,63 +8997,420 @@ package body Sem_Ch8 is\n    -------------\n \n    procedure Set_Use (L : List_Id) is\n-      Decl      : Node_Id;\n-      Pack_Name : Node_Id;\n-      Pack      : Entity_Id;\n-      Id        : Entity_Id;\n+      Decl : Node_Id;\n \n    begin\n       if Present (L) then\n          Decl := First (L);\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Use_Package_Clause then\n                Chain_Use_Clause (Decl);\n+               Use_One_Package (Decl, Name (Decl));\n+\n+            elsif Nkind (Decl) = N_Use_Type_Clause then\n+               Chain_Use_Clause (Decl);\n+               Use_One_Type (Subtype_Mark (Decl));\n+\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end if;\n+   end Set_Use;\n+\n+   -----------------------------\n+   -- Update_Use_Clause_Chain --\n+   -----------------------------\n+\n+   procedure Update_Use_Clause_Chain is\n+\n+      procedure Update_Chain_In_Scope (Level : Int);\n+      --  Iterate through one level in the scope stack verifying each use-type\n+      --  clause within said level is used then reset the Current_Use_Clause\n+      --  to a redundant use clause outside of the current ending scope if such\n+      --  a clause exists.\n+\n+      ---------------------------\n+      -- Update_Chain_In_Scope --\n+      ---------------------------\n+\n+      procedure Update_Chain_In_Scope (Level : Int) is\n+         Curr : Node_Id;\n+         N    : Node_Id;\n+\n+      begin\n+         --  Loop through all use clauses within the scope dictated by Level\n+\n+         Curr := Scope_Stack.Table (Level).First_Use_Clause;\n+         while Present (Curr) loop\n+\n+            --  Retrieve the subtype mark or name within the current current\n+            --  use clause.\n+\n+            if Nkind (Curr) = N_Use_Type_Clause then\n+               N := Subtype_Mark (Curr);\n+            else\n+               N := Name (Curr);\n+            end if;\n+\n+            --  If warnings for unreferenced entities are enabled and the\n+            --  current use clause has not been marked effective.\n \n-               Pack_Name := First (Names (Decl));\n-               while Present (Pack_Name) loop\n-                  Pack := Entity (Pack_Name);\n+            if Check_Unreferenced\n+              and then Comes_From_Source (Curr)\n+              and then not Is_Effective_Use_Clause (Curr)\n+              and then not In_Instance\n+            then\n+\n+               --  We are dealing with a potentially unused use_package_clause\n+\n+               if Nkind (Curr) = N_Use_Package_Clause then\n \n-                  if Ekind (Pack) = E_Package\n-                    and then Applicable_Use (Pack_Name)\n+                  --  Renamings and formal subprograms may cause the associated\n+                  --  to be marked as effective instead of the original.\n+\n+                  if not (Present (Associated_Node (N))\n+                           and then Present\n+                             (Current_Use_Clause (Associated_Node (N)))\n+                           and then Is_Effective_Use_Clause\n+                             (Current_Use_Clause (Associated_Node (N))))\n                   then\n-                     Use_One_Package (Pack, Decl);\n+                     Error_Msg_Node_1 := Entity (N);\n+                     Error_Msg_NE (\"ineffective use clause for package &?\",\n+                                   Curr, Entity (N));\n                   end if;\n \n-                  Next (Pack_Name);\n-               end loop;\n+               --  We are dealing with an unused use_type_clause\n \n-            elsif Nkind (Decl) = N_Use_Type_Clause then\n-               Chain_Use_Clause (Decl);\n+               else\n+                  Error_Msg_Node_1 := Etype (N);\n+                  Error_Msg_NE (\"ineffective use clause for }?\",\n+                                 Curr, Etype (N));\n+               end if;\n+            end if;\n \n-               Id := First (Subtype_Marks (Decl));\n-               while Present (Id) loop\n-                  if Entity (Id) /= Any_Type then\n-                     Use_One_Type (Id);\n-                  end if;\n+            --  Verify that we haven't already processed a redundant\n+            --  use_type_clause within the same scope before we move the\n+            --  current use clause up to a previous one for type T.\n \n-                  Next (Id);\n-               end loop;\n+            if Present (Prev_Use_Clause (Curr)) then\n+               Set_Current_Use_Clause (Entity (N), Prev_Use_Clause (Curr));\n             end if;\n \n-            Next (Decl);\n+            Curr := Next_Use_Clause (Curr);\n          end loop;\n+      end Update_Chain_In_Scope;\n+\n+   --  Start of processing for Update_Use_Clause_Chain\n+\n+   begin\n+      Update_Chain_In_Scope (Scope_Stack.Last);\n+\n+      --  Deal with use clauses within the context area if the current\n+      --  scope is a compilation unit.\n+\n+      if Is_Compilation_Unit (Current_Scope) then\n+\n+         pragma Assert (Scope_Stack.Last /= Scope_Stack.First);\n+\n+         Update_Chain_In_Scope (Scope_Stack.Last - 1);\n       end if;\n-   end Set_Use;\n+   end Update_Use_Clause_Chain;\n \n    ---------------------\n    -- Use_One_Package --\n    ---------------------\n \n-   procedure Use_One_Package (P : Entity_Id; N : Node_Id) is\n+   procedure Use_One_Package\n+     (N         : Node_Id;\n+      Pack_Name : Entity_Id := Empty;\n+      Force     : Boolean   := False)\n+   is\n+\n+      procedure Note_Redundant_Use (Clause : Node_Id);\n+      --  Mark the name in a use clause as redundant if the corresponding\n+      --  entity is already use-visible. Emit a warning if the use clause comes\n+      --  from source and the proper warnings are enabled.\n+\n+      ------------------------\n+      -- Note_Redundant_Use --\n+      ------------------------\n+\n+      procedure Note_Redundant_Use (Clause : Node_Id) is\n+         Pack_Name : constant Entity_Id := Entity (Clause);\n+         Decl      : constant Node_Id   := Parent (Clause);\n+\n+         Cur_Use    : Node_Id := Current_Use_Clause (Pack_Name);\n+         Prev_Use   : Node_Id := Empty;\n+         Redundant  : Node_Id := Empty;\n+         --  The Use_Clause which is actually redundant. In the simplest case\n+         --  it is Pack itself, but when we compile a body we install its\n+         --  context before that of its spec, in which case it is the\n+         --  use_clause in the spec that will appear to be redundant, and we\n+         --  want the warning to be placed on the body. Similar complications\n+         --  appear when the redundancy is between a child unit and one of its\n+         --  ancestors.\n+\n+      begin\n+         --  Could be renamed...\n+\n+         if No (Cur_Use) then\n+            Cur_Use := Current_Use_Clause (Renamed_Entity (Pack_Name));\n+         end if;\n+\n+         Set_Redundant_Use (Clause, True);\n+\n+         if not Comes_From_Source (Clause)\n+           or else In_Instance\n+           or else not Warn_On_Redundant_Constructs\n+         then\n+            return;\n+         end if;\n+\n+         if not Is_Compilation_Unit (Current_Scope) then\n+\n+            --  If the use_clause is in an inner scope, it is made redundant by\n+            --  some clause in the current context, with one exception: If we\n+            --  are compiling a nested package body, and the use_clause comes\n+            --  from then corresponding spec, the clause is not necessarily\n+            --  fully redundant, so we should not warn. If a warning was\n+            --  warranted, it would have been given when the spec was\n+            --  processed.\n+\n+            if Nkind (Parent (Decl)) = N_Package_Specification then\n+               declare\n+                  Package_Spec_Entity : constant Entity_Id :=\n+                                          Defining_Unit_Name (Parent (Decl));\n+               begin\n+                  if In_Package_Body (Package_Spec_Entity) then\n+                     return;\n+                  end if;\n+               end;\n+            end if;\n+\n+            Redundant := Clause;\n+            Prev_Use  := Cur_Use;\n+\n+         elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Body then\n+            declare\n+               Cur_Unit : constant Unit_Number_Type :=\n+                 Get_Source_Unit (Cur_Use);\n+               New_Unit : constant Unit_Number_Type :=\n+                 Get_Source_Unit (Clause);\n+               Scop     : Entity_Id;\n+\n+            begin\n+               if Cur_Unit = New_Unit then\n+\n+                  --  Redundant clause in same body\n+\n+                  Redundant := Clause;\n+                  Prev_Use  := Cur_Use;\n+\n+               elsif Cur_Unit = Current_Sem_Unit then\n+\n+                  --  If the new clause is not in the current unit it has been\n+                  --  analyzed first, and it makes the other one redundant.\n+                  --  However, if the new clause appears in a subunit, Cur_Unit\n+                  --  is still the parent, and in that case the redundant one\n+                  --  is the one appearing in the subunit.\n+\n+                  if Nkind (Unit (Cunit (New_Unit))) = N_Subunit then\n+                     Redundant := Clause;\n+                     Prev_Use  := Cur_Use;\n+\n+                  --  Most common case: redundant clause in body,\n+                  --  original clause in spec. Current scope is spec entity.\n+\n+                  elsif Current_Scope = Cunit_Entity (Current_Sem_Unit) then\n+                     Redundant := Cur_Use;\n+                     Prev_Use  := Clause;\n+\n+                  else\n+                     --  The new clause may appear in an unrelated unit, when\n+                     --  the parents of a generic are being installed prior to\n+                     --  instantiation. In this case there must be no warning.\n+                     --  We detect this case by checking whether the current\n+                     --  top of the stack is related to the current\n+                     --  compilation.\n+\n+                     Scop := Current_Scope;\n+                     while Present (Scop)\n+                       and then Scop /= Standard_Standard\n+                     loop\n+                        if Is_Compilation_Unit (Scop)\n+                          and then not Is_Child_Unit (Scop)\n+                        then\n+                           return;\n+\n+                        elsif Scop = Cunit_Entity (Current_Sem_Unit) then\n+                           exit;\n+                        end if;\n+\n+                        Scop := Scope (Scop);\n+                     end loop;\n+\n+                     Redundant := Cur_Use;\n+                     Prev_Use  := Clause;\n+                  end if;\n+\n+               elsif New_Unit = Current_Sem_Unit then\n+                  Redundant := Clause;\n+                  Prev_Use  := Cur_Use;\n+\n+               else\n+                  --  Neither is the current unit, so they appear in parent or\n+                  --  sibling units. Warning will be emitted elsewhere.\n+\n+                  return;\n+               end if;\n+            end;\n+\n+         elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Declaration\n+           and then Present (Parent_Spec (Unit (Cunit (Current_Sem_Unit))))\n+         then\n+            --  Use_clause is in child unit of current unit, and the child unit\n+            --  appears in the context of the body of the parent, so it has\n+            --  been installed first, even though it is the redundant one.\n+            --  Depending on their placement in the context, the visible or the\n+            --  private parts of the two units, either might appear as\n+            --  redundant, but the message has to be on the current unit.\n+\n+            if Get_Source_Unit (Cur_Use) = Current_Sem_Unit then\n+               Redundant := Cur_Use;\n+               Prev_Use  := Clause;\n+            else\n+               Redundant := Clause;\n+               Prev_Use  := Cur_Use;\n+            end if;\n+\n+            --  If the new use clause appears in the private part of a parent\n+            --  unit it may appear to be redundant w.r.t. a use clause in a\n+            --  child unit, but the previous use clause was needed in the\n+            --  visible part of the child, and no warning should be emitted.\n+\n+            if Nkind (Parent (Decl)) = N_Package_Specification\n+              and then\n+                List_Containing (Decl) = Private_Declarations (Parent (Decl))\n+            then\n+               declare\n+                  Par : constant Entity_Id := Defining_Entity (Parent (Decl));\n+                  Spec : constant Node_Id  :=\n+                           Specification (Unit (Cunit (Current_Sem_Unit)));\n+\n+               begin\n+                  if Is_Compilation_Unit (Par)\n+                    and then Par /= Cunit_Entity (Current_Sem_Unit)\n+                    and then Parent (Cur_Use) = Spec\n+                    and then\n+                      List_Containing (Cur_Use) = Visible_Declarations (Spec)\n+                  then\n+                     return;\n+                  end if;\n+               end;\n+            end if;\n+\n+         --  Finally, if the current use clause is in the context then\n+         --  the clause is redundant when it is nested within the unit.\n+\n+         elsif Nkind (Parent (Cur_Use)) = N_Compilation_Unit\n+           and then Nkind (Parent (Parent (Clause))) /= N_Compilation_Unit\n+           and then Get_Source_Unit (Cur_Use) = Get_Source_Unit (Clause)\n+         then\n+            Redundant := Clause;\n+            Prev_Use  := Cur_Use;\n+\n+         end if;\n+\n+         if Present (Redundant) then\n+            --  Make sure we are looking at most-descendant use_package_clause\n+            --  by traversing the chain with Find_Most_Prev and then verifying\n+            --  there is no scope manipulation via Most_Descendant_Use_Clause.\n+\n+            if Nkind (Prev_Use) = N_Use_Package_Clause\n+              and then\n+                (Nkind (Parent (Prev_Use)) /= N_Compilation_Unit\n+                  or else Most_Descendant_Use_Clause\n+                    (Prev_Use, Find_Most_Prev (Prev_Use)) /= Prev_Use)\n+            then\n+               Prev_Use := Find_Most_Prev (Prev_Use);\n+            end if;\n+\n+            Error_Msg_Sloc := Sloc (Prev_Use);\n+            Error_Msg_NE -- CODEFIX\n+              (\"& is already use-visible through previous use clause #??\",\n+               Redundant, Pack_Name);\n+         end if;\n+      end Note_Redundant_Use;\n+\n+      --  Local variables\n+\n       Id               : Entity_Id;\n       Prev             : Entity_Id;\n       Current_Instance : Entity_Id := Empty;\n       Real_P           : Entity_Id;\n       Private_With_OK  : Boolean   := False;\n+      P                : Entity_Id;\n+\n+   --  Start of processing for Use_One_Package\n \n    begin\n-      if Ekind (P) /= E_Package then\n-         return;\n+      --  Use_One_Package may have been called recursively to handle an\n+      --  implicit use for a auxiliary system package, so set P accordingly\n+      --  and skip redundancy checks.\n+\n+      if No (Pack_Name) and then Present_System_Aux (N) then\n+         P := System_Aux_Id;\n+\n+      --  Check for redundant use_package_clauses\n+\n+      else\n+         --  Ignore cases where we are dealing with a non user defined package\n+         --  like Standard_Standard or something other than a valid package.\n+\n+         if not Is_Entity_Name (Pack_Name)\n+           or else No (Entity (Pack_Name))\n+           or else Ekind (Entity (Pack_Name)) /= E_Package\n+         then\n+            return;\n+         end if;\n+\n+         --  When a renaming exists we must check it for redundancy. The\n+         --  original package would have already been seen at this point.\n+\n+         if Present (Renamed_Object (Entity (Pack_Name))) then\n+            P := Renamed_Object (Entity (Pack_Name));\n+         else\n+            P := Entity (Pack_Name);\n+         end if;\n+\n+         --  Check for redundant clauses then set the current use clause for\n+         --  P if were are not \"forcing\" an installation from a scope\n+         --  reinstallation that is done throughout analysis for various\n+         --  reasons.\n+\n+         if In_Use (P) then\n+            Note_Redundant_Use (Pack_Name);\n+            if not Force then\n+               Set_Current_Use_Clause (P, N);\n+            end if;\n+            return;\n+\n+         --  Warn about detected redundant clauses\n+\n+         elsif In_Open_Scopes (P) and not Force then\n+            if Warn_On_Redundant_Constructs and then P = Current_Scope then\n+               Error_Msg_NE -- CODEFIX\n+                 (\"& is already use-visible within itself?r?\",\n+                   Pack_Name, P);\n+            end if;\n+            return;\n+         end if;\n+\n+         --  Set P back to the non-renamed package so that visiblilty of the\n+         --  entities within the package can be properly set below.\n+\n+         P := Entity (Pack_Name);\n       end if;\n \n       Set_In_Use (P);\n@@ -9113,16 +9594,17 @@ package body Sem_Ch8 is\n         and then Scope (Real_P) = Standard_Standard\n         and then Present_System_Aux (N)\n       then\n-         Use_One_Package (System_Aux_Id, N);\n+         Use_One_Package (N);\n       end if;\n-\n    end Use_One_Package;\n \n    ------------------\n    -- Use_One_Type --\n    ------------------\n \n-   procedure Use_One_Type (Id : Node_Id; Installed : Boolean := False) is\n+   procedure Use_One_Type\n+     (Id : Node_Id; Installed : Boolean := False; Force : Boolean := False)\n+   is\n       Elmt          : Elmt_Id;\n       Is_Known_Used : Boolean;\n       Op_List       : Elist_Id;\n@@ -9174,8 +9656,8 @@ package body Sem_Ch8 is\n          Ent  : Entity_Id;\n \n          function Is_Class_Wide_Operation_Of\n-        (Op  : Entity_Id;\n-         T   : Entity_Id) return Boolean;\n+           (Op : Entity_Id;\n+            T  : Entity_Id) return Boolean;\n          --  Determine whether a subprogram has a class-wide parameter or\n          --  result that is T'Class.\n \n@@ -9232,19 +9714,26 @@ package body Sem_Ch8 is\n    --  Start of processing for Use_One_Type\n \n    begin\n+      if Entity (Id) = Any_Type then\n+         return;\n+      end if;\n+\n       --  It is the type determined by the subtype mark (8.4(8)) whose\n       --  operations become potentially use-visible.\n \n       T := Base_Type (Entity (Id));\n \n-      --  Either the type itself is used, the package where it is declared\n-      --  is in use or the entity is declared in the current package, thus\n+      --  Either the type itself is used, the package where it is declared is\n+      --  in use or the entity is declared in the current package, thus\n       --  use-visible.\n \n-      Is_Known_Used :=\n-        In_Use (T)\n-          or else In_Use (Scope (T))\n-          or else Scope (T) = Current_Scope;\n+      Is_Known_Used := (In_Use (T)\n+                         and then ((Present (Current_Use_Clause (T))\n+                                     and then All_Present\n+                                                (Current_Use_Clause (T)))\n+                                    or else not All_Present (Parent (Id))))\n+                         or else In_Use (Scope (T))\n+                         or else Scope (T) = Current_Scope;\n \n       Set_Redundant_Use (Id,\n         Is_Known_Used or else Is_Potentially_Use_Visible (T));\n@@ -9255,7 +9744,7 @@ package body Sem_Ch8 is\n       elsif In_Open_Scopes (Scope (T)) then\n          null;\n \n-      --  A limited view cannot appear in a use_type clause. However, an access\n+      --  A limited view cannot appear in a use_type_clause. However, an access\n       --  type whose designated type is limited has the flag but is not itself\n       --  a limited view unless we only have a limited view of its enclosing\n       --  package.\n@@ -9274,13 +9763,28 @@ package body Sem_Ch8 is\n       --  even if it is redundant at the place of the instantiation.\n \n       elsif Redundant_Use (Id) then\n+\n+         --  We must avoid incorrectly setting the Current_Use_Clause when we\n+         --  are working with a redundant clause that has already been linked\n+         --  in the Prev_Use_Clause chain, otherwise the chain will break.\n+\n+         if Present (Current_Use_Clause (T))\n+           and then Present (Prev_Use_Clause (Current_Use_Clause (T)))\n+           and then Parent (Id) = Prev_Use_Clause (Current_Use_Clause (T))\n+         then\n+            null;\n+         else\n+            Set_Current_Use_Clause (T, Parent (Id));\n+         end if;\n+\n          Set_Used_Operations (Parent (Id), New_Elmt_List);\n \n       --  If the subtype mark designates a subtype in a different package,\n       --  we have to check that the parent type is visible, otherwise the\n-      --  use type clause is a noop. Not clear how to do that???\n+      --  use_type_clause is a no-op. Not clear how to do that???\n \n       else\n+         Set_Current_Use_Clause (T, Parent (Id));\n          Set_In_Use (T);\n \n          --  If T is tagged, primitive operators on class-wide operands\n@@ -9290,8 +9794,6 @@ package body Sem_Ch8 is\n             Set_In_Use (Class_Wide_Type (T));\n          end if;\n \n-         Set_Current_Use_Clause (T, Parent (Id));\n-\n          --  Iterate over primitive operations of the type. If an operation is\n          --  already use_visible, it is the result of a previous use_clause,\n          --  and already appears on the corresponding entity chain. If the\n@@ -9335,7 +9837,8 @@ package body Sem_Ch8 is\n \n       --  If warning on redundant constructs, check for unnecessary WITH\n \n-      if Warn_On_Redundant_Constructs\n+      if not Force\n+        and then Warn_On_Redundant_Constructs\n         and then Is_Known_Used\n \n         --                     with P;         with P; use P;\n@@ -9362,39 +9865,19 @@ package body Sem_Ch8 is\n \n             if Present (Current_Use_Clause (T)) then\n                Use_Clause_Known : declare\n-                  Clause1 : constant Node_Id := Parent (Id);\n-                  Clause2 : constant Node_Id := Current_Use_Clause (T);\n+                  Clause1 : constant Node_Id := Find_Most_Prev\n+                                                  (Current_Use_Clause (T));\n+                  Clause2 : constant Node_Id := Parent (Id);\n                   Ent1    : Entity_Id;\n                   Ent2    : Entity_Id;\n                   Err_No  : Node_Id;\n                   Unit1   : Node_Id;\n                   Unit2   : Node_Id;\n \n-                  function Entity_Of_Unit (U : Node_Id) return Entity_Id;\n-                  --  Return the appropriate entity for determining which unit\n-                  --  has a deeper scope: the defining entity for U, unless U\n-                  --  is a package instance, in which case we retrieve the\n-                  --  entity of the instance spec.\n-\n-                  --------------------\n-                  -- Entity_Of_Unit --\n-                  --------------------\n-\n-                  function Entity_Of_Unit (U : Node_Id) return Entity_Id is\n-                  begin\n-                     if Nkind (U) = N_Package_Instantiation\n-                       and then Analyzed (U)\n-                     then\n-                        return Defining_Entity (Instance_Spec (U));\n-                     else\n-                        return Defining_Entity (U);\n-                     end if;\n-                  end Entity_Of_Unit;\n-\n                --  Start of processing for Use_Clause_Known\n \n                begin\n-                  --  If both current use type clause and the use type clause\n+                  --  If both current use_type_clause and the use_type_clause\n                   --  for the type are at the compilation unit level, one of\n                   --  the units must be an ancestor of the other, and the\n                   --  warning belongs on the descendant.\n@@ -9418,14 +9901,7 @@ package body Sem_Ch8 is\n                      --  of the other, or one of them is in a subunit, report\n                      --  redundancy on the later one.\n \n-                     if Unit1 = Unit2 then\n-                        Error_Msg_Sloc := Sloc (Current_Use_Clause (T));\n-                        Error_Msg_NE -- CODEFIX\n-                          (\"& is already use-visible through previous \"\n-                           & \"use_type_clause #??\", Clause1, T);\n-                        return;\n-\n-                     elsif Nkind (Unit1) = N_Subunit then\n+                     if Unit1 = Unit2 or else Nkind (Unit1) = N_Subunit then\n                         Error_Msg_Sloc := Sloc (Current_Use_Clause (T));\n                         Error_Msg_NE -- CODEFIX\n                           (\"& is already use-visible through previous \"\n@@ -9443,7 +9919,7 @@ package body Sem_Ch8 is\n                         return;\n                      end if;\n \n-                     --  There is a redundant use type clause in a child unit.\n+                     --  There is a redundant use_type_clause in a child unit.\n                      --  Determine which of the units is more deeply nested.\n                      --  If a unit is a package instance, retrieve the entity\n                      --  and its scope from the instance spec.\n@@ -9489,13 +9965,22 @@ package body Sem_Ch8 is\n                         end;\n                      end if;\n \n-                     Error_Msg_NE -- CODEFIX\n-                       (\"& is already use-visible through previous \"\n-                        & \"use_type_clause #??\", Err_No, Id);\n+                     if Parent (Id) /= Err_No then\n+                        if Most_Descendant_Use_Clause\n+                             (Err_No, Parent (Id)) = Parent (Id)\n+                        then\n+                           Error_Msg_Sloc := Sloc (Err_No);\n+                           Err_No := Parent (Id);\n+                        end if;\n+\n+                        Error_Msg_NE -- CODEFIX\n+                          (\"& is already use-visible through previous \"\n+                           & \"use_type_clause #??\", Err_No, Id);\n+                     end if;\n \n-                  --  Case where current use type clause and the use type\n-                  --  clause for the type are not both at the compilation unit\n-                  --  level. In this case we don't have location information.\n+                  --  Case where current use_type_clause and use_type_clause\n+                  --  for the type are not both at the compilation unit level.\n+                  --  In this case we don't have location information.\n \n                   else\n                      Error_Msg_NE -- CODEFIX\n@@ -9516,7 +10001,8 @@ package body Sem_Ch8 is\n          --  The package where T is declared is already used\n \n          elsif In_Use (Scope (T)) then\n-            Error_Msg_Sloc := Sloc (Current_Use_Clause (Scope (T)));\n+            Error_Msg_Sloc := Sloc (Find_Most_Prev\n+                                     (Current_Use_Clause (Scope (T))));\n             Error_Msg_NE -- CODEFIX\n               (\"& is already use-visible through package use clause #??\",\n                Id, T);"}, {"sha": "e87f5aafd5162113a86a689345cd4cbf866cb1b6", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,8 +52,18 @@ package Sem_Ch8 is\n    procedure Analyze_Object_Renaming            (N : Node_Id);\n    procedure Analyze_Package_Renaming           (N : Node_Id);\n    procedure Analyze_Subprogram_Renaming        (N : Node_Id);\n-   procedure Analyze_Use_Package                (N : Node_Id);\n-   procedure Analyze_Use_Type                   (N : Node_Id);\n+\n+   procedure Analyze_Use_Package (N     : Node_Id;\n+                                  Chain : Boolean := True);\n+   --  Analyze a use package clause and control (through the Chain\n+   --  parameter) whether to add N to the use clause chain for the name\n+   --  denoted within use clause N in case we are reanalyzing a use clause\n+   --  because of stack manipulation.\n+\n+   procedure Analyze_Use_Type (N     : Node_Id;\n+                               Chain : Boolean := True);\n+   --  Similar to Analyze_Use_Package except the Chain parameter applies\n+   --  to the type within N's subtype mark Current_Use_Clause.\n \n    procedure End_Scope;\n    --  Called at end of scope. On exit from blocks and bodies (subprogram,\n@@ -131,6 +141,10 @@ package Sem_Ch8 is\n    --  Analyze_Subunit.Re_Install_Use_Clauses to insure that, after the\n    --  analysis of the subunit, the parent's environment is again identical.\n \n+   procedure Mark_Use_Clauses (Id : Node_Or_Entity_Id);\n+   --  Mark a given entity or node Id's relevant use clauses as effective,\n+   --  including redundant ones and ones outside of the current scope.\n+\n    procedure Push_Scope (S : Entity_Id);\n    --  Make new scope stack entry, pushing S, the entity for a scope onto the\n    --  top of the scope table. The current setting of the scope suppress flags\n@@ -174,6 +188,10 @@ package Sem_Ch8 is\n    --  and set the potentially use-visible flags of imported entities before\n    --  analyzing the corresponding package body.\n \n+   procedure Update_Use_Clause_Chain;\n+   --  Called at the end of a declarative region to detect unused use type\n+   --  clauses and maintain the Current_Use_Clause for type entities.\n+\n    procedure ws;\n    --  Debugging routine for use in gdb: dump all entities on scope stack\n "}, {"sha": "cbebe2601d2bbf714cfe9ea0e978dfa3730be1b3", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1447,6 +1447,7 @@ package body Sem_Ch9 is\n       --  Process the end label, and terminate the scope\n \n       Process_End_Label (Handled_Statement_Sequence (N), 't', Entry_Name);\n+      Update_Use_Clause_Chain;\n       End_Scope;\n \n       --  If this is an entry family, remove the loop created to provide\n@@ -1851,6 +1852,7 @@ package body Sem_Ch9 is\n       Check_Completion (Body_Id);\n       Check_References (Spec_Id);\n       Process_End_Label (N, 't', Ref_Id);\n+      Update_Use_Clause_Chain;\n       End_Scope;\n \n       --  When a Lock_Free aspect specification/pragma forces the lock-free\n@@ -2991,6 +2993,7 @@ package body Sem_Ch9 is\n       end;\n \n       Process_End_Label (HSS, 't', Ref_Id);\n+      Update_Use_Clause_Chain;\n       End_Scope;\n    end Analyze_Task_Body;\n "}, {"sha": "803ad0eb0aeb72bc27bfe2ce804977fcddf07e6f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -3010,6 +3010,14 @@ package body Sem_Res is\n                Resolve_Unchecked_Type_Conversion (N, Ctx_Type);\n          end case;\n \n+         --  Mark relevant use-type and use-package clauses as effective using\n+         --  the original node because constant folding may have occured and\n+         --  removed references that need to be examined.\n+\n+         if Nkind (Original_Node (N)) in N_Op then\n+            Mark_Use_Clauses (Original_Node (N));\n+         end if;\n+\n          --  Ada 2012 (AI05-0149): Apply an (implicit) conversion to an\n          --  expression of an anonymous access type that occurs in the context\n          --  of a named general access type, except when the expression is that\n@@ -6724,6 +6732,8 @@ package body Sem_Res is\n          end if;\n       end if;\n \n+      Mark_Use_Clauses (Subp);\n+\n       Warn_On_Overlapping_Actuals (Nam, N);\n    end Resolve_Call;\n \n@@ -7279,6 +7289,8 @@ package body Sem_Res is\n             Check_Ghost_Context (E, N);\n          end if;\n       end if;\n+\n+      Mark_Use_Clauses (E);\n    end Resolve_Entity_Name;\n \n    -------------------"}, {"sha": "f20d9df5a9dad0b7c78042d84250383ee4f28483", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -2225,29 +2225,21 @@ package body Sem_Warn is\n             ----------------------\n \n             function Check_Use_Clause (N : Node_Id) return Traverse_Result is\n-               Nam  : Node_Id;\n-\n             begin\n-               if Nkind (N) = N_Use_Package_Clause then\n-                  Nam := First (Names (N));\n-                  while Present (Nam) loop\n-                     if Entity (Nam) = Pack then\n-\n-                        --  Suppress message if any serious errors detected\n-                        --  that turn off expansion, and thus result in false\n-                        --  positives for this warning.\n-\n-                        if Serious_Errors_Detected = 0 then\n-                           Error_Msg_Qual_Level := 1;\n-                           Error_Msg_NE -- CODEFIX\n-                             (\"?u?no entities of package& are referenced!\",\n-                                Nam, Pack);\n-                           Error_Msg_Qual_Level := 0;\n-                        end if;\n-                     end if;\n-\n-                     Next (Nam);\n-                  end loop;\n+               if Nkind (N) = N_Use_Package_Clause\n+                 and then Entity (Name (N)) = Pack\n+               then\n+                  --  Suppress message if any serious errors detected that turn\n+                  --  off expansion, and thus result in false positives for\n+                  --  this warning.\n+\n+                  if Serious_Errors_Detected = 0 then\n+                     Error_Msg_Qual_Level := 1;\n+                     Error_Msg_NE -- CODEFIX\n+                       (\"?u?no entities of package& are referenced!\",\n+                          Name (N), Pack);\n+                     Error_Msg_Qual_Level := 0;\n+                  end if;\n                end if;\n \n                return OK;"}, {"sha": "de43c2907b1ae13331a29a3f785ca93c51523065", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -27,7 +27,7 @@\n --  about uses of uninitialized variables and unused with's. It also has\n --  some unrelated routines related to the generation of warnings.\n \n-with Alloc; use Alloc;\n+with Alloc;\n with Table;\n with Types; use Types;\n "}, {"sha": "4eb1c8c6f476a888b520bf674b81e48401856082", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -298,7 +298,8 @@ package body Sinfo is\n         or else NT (N).Nkind in N_Has_Entity\n         or else NT (N).Nkind = N_Aggregate\n         or else NT (N).Nkind = N_Extension_Aggregate\n-        or else NT (N).Nkind = N_Selected_Component);\n+        or else NT (N).Nkind = N_Selected_Component\n+        or else NT (N).Nkind = N_Use_Package_Clause);\n       return Node4 (N);\n    end Associated_Node;\n \n@@ -1646,7 +1647,7 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind = N_Use_Package_Clause\n         or else NT (N).Nkind = N_Use_Type_Clause);\n-      return Elist4 (N);\n+      return Elist5 (N);\n    end Hidden_By_Use_Clause;\n \n    function High_Bound\n@@ -1882,6 +1883,15 @@ package body Sinfo is\n       return Flag18 (N);\n    end Is_Dynamic_Coextension;\n \n+   function Is_Effective_Use_Clause\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n+      return Flag1 (N);\n+   end Is_Effective_Use_Clause;\n+\n    function Is_Elsif\n      (N : Node_Id) return Boolean is\n    begin\n@@ -2254,7 +2264,9 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Formal_Object_Declaration\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n-        or else NT (N).Nkind = N_Parameter_Specification);\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       return Flag5 (N);\n    end More_Ids;\n \n@@ -2328,6 +2340,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Requeue_Statement\n         or else NT (N).Nkind = N_Subprogram_Renaming_Declaration\n         or else NT (N).Nkind = N_Subunit\n+        or else NT (N).Nkind = N_Use_Package_Clause\n         or else NT (N).Nkind = N_Variant_Part\n         or else NT (N).Nkind = N_With_Clause);\n       return Node2 (N);\n@@ -2337,8 +2350,7 @@ package body Sinfo is\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Abort_Statement\n-        or else NT (N).Nkind = N_Use_Package_Clause);\n+        or else NT (N).Nkind = N_Abort_Statement);\n       return List2 (N);\n    end Names;\n \n@@ -2723,10 +2735,21 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Formal_Object_Declaration\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n-        or else NT (N).Nkind = N_Parameter_Specification);\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       return Flag6 (N);\n    end Prev_Ids;\n \n+   function Prev_Use_Clause\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n+      return Node1 (N);\n+   end Prev_Use_Clause;\n+\n    function Print_In_Hex\n       (N : Node_Id) return Boolean is\n    begin\n@@ -3133,16 +3156,16 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Qualified_Expression\n         or else NT (N).Nkind = N_Subtype_Indication\n         or else NT (N).Nkind = N_Type_Conversion\n-        or else NT (N).Nkind = N_Unchecked_Type_Conversion);\n+        or else NT (N).Nkind = N_Unchecked_Type_Conversion\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       return Node4 (N);\n    end Subtype_Mark;\n \n    function Subtype_Marks\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Unconstrained_Array_Definition\n-        or else NT (N).Nkind = N_Use_Type_Clause);\n+        or else NT (N).Nkind = N_Unconstrained_Array_Definition);\n       return List2 (N);\n    end Subtype_Marks;\n \n@@ -3338,7 +3361,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Use_Type_Clause);\n-      return Elist5 (N);\n+      return Elist2 (N);\n    end Used_Operations;\n \n    function Was_Expression_Function\n@@ -3609,7 +3632,8 @@ package body Sinfo is\n         or else NT (N).Nkind in N_Has_Entity\n         or else NT (N).Nkind = N_Aggregate\n         or else NT (N).Nkind = N_Extension_Aggregate\n-        or else NT (N).Nkind = N_Selected_Component);\n+        or else NT (N).Nkind = N_Selected_Component\n+        or else NT (N).Nkind = N_Use_Package_Clause);\n       Set_Node4 (N, Val); -- semantic field, no parent set\n    end Set_Associated_Node;\n \n@@ -4948,7 +4972,7 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind = N_Use_Package_Clause\n         or else NT (N).Nkind = N_Use_Type_Clause);\n-      Set_Elist4 (N, Val);\n+      Set_Elist5 (N, Val);\n    end Set_Hidden_By_Use_Clause;\n \n    procedure Set_High_Bound\n@@ -5184,6 +5208,15 @@ package body Sinfo is\n       Set_Flag18 (N, Val);\n    end Set_Is_Dynamic_Coextension;\n \n+   procedure Set_Is_Effective_Use_Clause\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Effective_Use_Clause;\n+\n    procedure Set_Is_Elsif\n      (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5556,7 +5589,9 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Formal_Object_Declaration\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n-        or else NT (N).Nkind = N_Parameter_Specification);\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       Set_Flag5 (N, Val);\n    end Set_More_Ids;\n \n@@ -5630,6 +5665,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Requeue_Statement\n         or else NT (N).Nkind = N_Subprogram_Renaming_Declaration\n         or else NT (N).Nkind = N_Subunit\n+        or else NT (N).Nkind = N_Use_Package_Clause\n         or else NT (N).Nkind = N_Variant_Part\n         or else NT (N).Nkind = N_With_Clause);\n       Set_Node2_With_Parent (N, Val);\n@@ -5639,8 +5675,7 @@ package body Sinfo is\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Abort_Statement\n-        or else NT (N).Nkind = N_Use_Package_Clause);\n+        or else NT (N).Nkind = N_Abort_Statement);\n       Set_List2_With_Parent (N, Val);\n    end Set_Names;\n \n@@ -6025,10 +6060,21 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Formal_Object_Declaration\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n-        or else NT (N).Nkind = N_Parameter_Specification);\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       Set_Flag6 (N, Val);\n    end Set_Prev_Ids;\n \n+   procedure Set_Prev_Use_Clause\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Use_Package_Clause\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n+   end Set_Prev_Use_Clause;\n+\n    procedure Set_Print_In_Hex\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -6418,16 +6464,16 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Qualified_Expression\n         or else NT (N).Nkind = N_Subtype_Indication\n         or else NT (N).Nkind = N_Type_Conversion\n-        or else NT (N).Nkind = N_Unchecked_Type_Conversion);\n+        or else NT (N).Nkind = N_Unchecked_Type_Conversion\n+        or else NT (N).Nkind = N_Use_Type_Clause);\n       Set_Node4_With_Parent (N, Val);\n    end Set_Subtype_Mark;\n \n    procedure Set_Subtype_Marks\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Unconstrained_Array_Definition\n-        or else NT (N).Nkind = N_Use_Type_Clause);\n+        or else NT (N).Nkind = N_Unconstrained_Array_Definition);\n       Set_List2_With_Parent (N, Val);\n    end Set_Subtype_Marks;\n \n@@ -6640,7 +6686,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Use_Type_Clause);\n-      Set_Elist5 (N, Val);\n+      Set_Elist2 (N, Val);\n    end Set_Used_Operations;\n \n    procedure Set_Was_Expression_Function"}, {"sha": "87b65424f4d26692b367233e0ea246308f248288", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -1596,7 +1596,7 @@ package Sinfo is\n    --    added to the size of the prefix. The flag also prevents the infinite\n    --    expansion of the same attribute in the said context.\n \n-   --  Hidden_By_Use_Clause (Elist4-Sem)\n+   --  Hidden_By_Use_Clause (Elist5-Sem)\n    --     An entity list present in use clauses that appear within\n    --     instantiations. For the resolution of local entities, entities\n    --     introduced by these use clauses have priority over global ones, and\n@@ -1721,6 +1721,10 @@ package Sinfo is\n    --    coextension must be deallocated and finalized at the same time as\n    --    the enclosing object.\n \n+   --  Is_Effective_Use_Clause (Flag1-Sem)\n+   --    Present in both N_Use_Type_Clause and N_Use_Package_Clause to indicate\n+   --    a use clause is \"used\" in the current source.\n+\n    --  Is_Entry_Barrier_Function (Flag8-Sem)\n    --    This flag is set on N_Subprogram_Declaration and N_Subprogram_Body\n    --    nodes which emulate the barrier function of a protected entry body.\n@@ -2137,6 +2141,11 @@ package Sinfo is\n    --    ASIS processing (data decomposition annex) to determine if a field is\n    --    present or not.\n \n+   --  Prev_Use_Clause (Node1-Sem)\n+   --    Present in both N_Use_Package_Clause and N_Use_Type_Clause. Used in\n+   --    detection of ineffective use clauses by allowing a chain of related\n+   --    clauses together to avoid traversing the current scope stack.\n+\n    --  Print_In_Hex (Flag13-Sem)\n    --    Set on an N_Integer_Literal node to indicate that the value should be\n    --    printed in hexadecimal in the sprint listing. Has no effect on\n@@ -2338,7 +2347,7 @@ package Sinfo is\n    --    initialized. Used to warn if the corresponding actual type is not\n    --    a fully initialized type.\n \n-   --  Used_Operations (Elist5-Sem)\n+   --  Used_Operations (Elist2-Sem)\n    --    Present in N_Use_Type_Clause nodes. Holds the list of operations that\n    --    are made potentially use-visible by the clause. Simplifies processing\n    --    on exit from the scope of the use_type_clause, in particular in the\n@@ -5687,9 +5696,14 @@ package Sinfo is\n \n       --  N_Use_Package_Clause\n       --  Sloc points to USE\n-      --  Names (List2)\n+      --  Prev_Use_Clause (Node1-Sem)\n+      --  Name (Node2)\n       --  Next_Use_Clause (Node3-Sem)\n-      --  Hidden_By_Use_Clause (Elist4-Sem)\n+      --  Associated_Node (Node4-Sem)\n+      --  Hidden_By_Use_Clause (Elist5-Sem)\n+      --  Is_Effective_Use_Clause (Flag1)\n+      --  More_Ids (Flag5) (set to False if no more identifiers in list)\n+      --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n \n       --------------------------\n       -- 8.4  Use Type Clause --\n@@ -5703,10 +5717,14 @@ package Sinfo is\n \n       --  N_Use_Type_Clause\n       --  Sloc points to USE\n-      --  Subtype_Marks (List2)\n+      --  Prev_Use_Clause (Node1-Sem)\n+      --  Used_Operations (Elist2-Sem)\n       --  Next_Use_Clause (Node3-Sem)\n-      --  Hidden_By_Use_Clause (Elist4-Sem)\n-      --  Used_Operations (Elist5-Sem)\n+      --  Subtype_Mark (Node4)\n+      --  Hidden_By_Use_Clause (Elist5-Sem)\n+      --  Is_Effective_Use_Clause (Flag1)\n+      --  More_Ids (Flag5) (set to False if no more identifiers in list)\n+      --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n       --  All_Present (Flag15)\n \n       -------------------------------\n@@ -9455,7 +9473,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag11\n \n    function Hidden_By_Use_Clause\n-     (N : Node_Id) return Elist_Id;   -- Elist4\n+     (N : Node_Id) return Elist_Id;   -- Elist5\n \n    function High_Bound\n      (N : Node_Id) return Node_Id;    -- Node2\n@@ -9535,6 +9553,9 @@ package Sinfo is\n    function Is_Dynamic_Coextension\n      (N : Node_Id) return Boolean;    -- Flag18\n \n+   function Is_Effective_Use_Clause\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function Is_Elsif\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -9802,6 +9823,9 @@ package Sinfo is\n    function Prev_Ids\n      (N : Node_Id) return Boolean;    -- Flag6\n \n+   function Prev_Use_Clause\n+     (N : Node_Id) return Node_Id;    -- Node1\n+\n    function Print_In_Hex\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -9995,7 +10019,7 @@ package Sinfo is\n      (N : Node_Id) return Node_Id;    -- Node3\n \n    function Used_Operations\n-     (N : Node_Id) return Elist_Id;   -- Elist5\n+     (N : Node_Id) return Elist_Id;   -- Elist2\n \n    function Was_Expression_Function\n      (N : Node_Id) return Boolean;    -- Flag18\n@@ -10511,7 +10535,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n    procedure Set_Hidden_By_Use_Clause\n-     (N : Node_Id; Val : Elist_Id);           -- Elist4\n+     (N : Node_Id; Val : Elist_Id);           -- Elist5\n \n    procedure Set_High_Bound\n      (N : Node_Id; Val : Node_Id);            -- Node2\n@@ -10591,6 +10615,9 @@ package Sinfo is\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n+   procedure Set_Is_Effective_Use_Clause\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_Is_Elsif\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -10858,6 +10885,9 @@ package Sinfo is\n    procedure Set_Prev_Ids\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n+   procedure Set_Prev_Use_Clause\n+     (N : Node_Id; Val : Node_Id);            -- Node1\n+\n    procedure Set_Print_In_Hex\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -11051,7 +11081,7 @@ package Sinfo is\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n    procedure Set_Used_Operations\n-     (N : Node_Id; Val : Elist_Id);           -- Elist5\n+     (N : Node_Id; Val : Elist_Id);           -- Elist2\n \n    procedure Set_Was_Expression_Function\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n@@ -12053,18 +12083,18 @@ package Sinfo is\n         5 => True),   --  Subtype_Indication (Node5)\n \n      N_Use_Package_Clause =>\n-       (1 => False,   --  unused\n-        2 => True,    --  Names (List2)\n+       (1 => False,   --  Prev_Use_Clause (Node1-Sem)\n+        2 => True,    --  Name (Node2)\n         3 => False,   --  Next_Use_Clause (Node3-Sem)\n-        4 => False,   --  Hidden_By_Use_Clause (Elist4-Sem)\n-        5 => False),  --  unused\n+        4 => False,   --  Associated_Node (Node4-Sem)\n+        5 => False),  --  Hidden_By_Use_Clause (Elist5-Sem)\n \n      N_Use_Type_Clause =>\n-       (1 => False,   --  unused\n-        2 => True,    --  Subtype_Marks (List2)\n+       (1 => False,   --  Prev_Use_Clause (Node1-Sem)\n+        2 => False,   --  Used_Operations (Elist2-Sem)\n         3 => False,   --  Next_Use_Clause (Node3-Sem)\n-        4 => False,   --  Hidden_By_Use_Clause (Elist4-Sem)\n-        5 => False),  --  unused\n+        4 => True,    --  Subtype_Mark (Node4)\n+        5 => False),  --  Hidden_By_Use_Clause (Elist5-Sem)\n \n      N_Object_Renaming_Declaration =>\n        (1 => True,    --  Defining_Identifier (Node1)\n@@ -13053,6 +13083,7 @@ package Sinfo is\n    pragma Inline (Is_Delayed_Aspect);\n    pragma Inline (Is_Disabled);\n    pragma Inline (Is_Dynamic_Coextension);\n+   pragma Inline (Is_Effective_Use_Clause);\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n@@ -13141,6 +13172,7 @@ package Sinfo is\n    pragma Inline (Premature_Use);\n    pragma Inline (Present_Expr);\n    pragma Inline (Prev_Ids);\n+   pragma Inline (Prev_Use_Clause);\n    pragma Inline (Print_In_Hex);\n    pragma Inline (Private_Declarations);\n    pragma Inline (Private_Present);\n@@ -13400,6 +13432,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Delayed_Aspect);\n    pragma Inline (Set_Is_Disabled);\n    pragma Inline (Set_Is_Dynamic_Coextension);\n+   pragma Inline (Set_Is_Effective_Use_Clause);\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n@@ -13489,6 +13522,7 @@ package Sinfo is\n    pragma Inline (Set_Premature_Use);\n    pragma Inline (Set_Present_Expr);\n    pragma Inline (Set_Prev_Ids);\n+   pragma Inline (Set_Prev_Use_Clause);\n    pragma Inline (Set_Print_In_Hex);\n    pragma Inline (Set_Private_Declarations);\n    pragma Inline (Set_Private_Present);"}, {"sha": "6e2931093791521b62993e63115c781f8c60d0c6", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -3435,12 +3435,12 @@ package body Sprint is\n \n          when N_Use_Package_Clause =>\n             Write_Indent_Str_Sloc (\"use \");\n-            Sprint_Comma_List (Names (Node));\n+            Sprint_Node_Sloc (Name (Node));\n             Write_Char (';');\n \n          when N_Use_Type_Clause =>\n             Write_Indent_Str_Sloc (\"use type \");\n-            Sprint_Comma_List (Subtype_Marks (Node));\n+            Sprint_Node_Sloc (Subtype_Mark (Node));\n             Write_Char (';');\n \n          when N_Validate_Unchecked_Conversion =>"}, {"sha": "4855db50b15f4dab6e420fab9b3fd22a2f51f77e", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -24,7 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Csets;    use Csets;\n-with Opt;      use Opt;\n+with Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n "}, {"sha": "0d8eb06c715ef80a2f62380b269eb6c16376a214", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -572,12 +572,15 @@ package Types is\n    No_Unit : constant Unit_Number_Type := -1;\n    --  Special value used to signal no unit\n \n-   type Source_File_Index is new Int range 0 .. Int'Last;\n+   type Source_File_Index is new Int range -1 .. Int'Last;\n    --  Type used to index the source file table (see package Sinput)\n \n    No_Source_File : constant Source_File_Index := 0;\n    --  Value used to indicate no source file present\n \n+   No_Access_To_Source_File : constant Source_File_Index := -1;\n+   --  Value used to indicate a source file is present but unreadable\n+\n    -----------------------------------\n    -- Representation of Time Stamps --\n    -----------------------------------"}, {"sha": "8ae9e6d1b32662e5121c3d6387e83a7525cc3487", "filename": "gcc/ada/xr_tabls.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fxr_tabls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fxr_tabls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxr_tabls.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@ with Ada.Strings.Unbounded;     use Ada.Strings.Unbounded;\n \n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.HTable;               use GNAT.HTable;\n+with GNAT.HTable;\n with GNAT.Heap_Sort_G;\n \n package body Xr_Tabls is"}, {"sha": "b860978d774e879d5532929d5c5ed6fe9ac2f7c9", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851e9f19e27e1f840f9a978fc7103397043d8826/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=851e9f19e27e1f840f9a978fc7103397043d8826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@ with Types;  use Types;\n with Unchecked_Deallocation;\n \n with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n-with Ada.Text_IO;       use Ada.Text_IO;\n+with Ada.Text_IO;\n \n with GNAT.Command_Line; use GNAT.Command_Line;\n with GNAT.IO_Aux;       use GNAT.IO_Aux;"}]}