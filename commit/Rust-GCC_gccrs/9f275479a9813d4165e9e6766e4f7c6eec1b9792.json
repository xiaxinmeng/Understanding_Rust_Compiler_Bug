{"sha": "9f275479a9813d4165e9e6766e4f7c6eec1b9792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYyNzU0NzlhOTgxM2Q0MTY1ZTllNjc2NmU0ZjdjNmVlYzFiOTc5Mg==", "commit": {"author": {"name": "Jan Sjodin", "email": "jan.sjodin@amd.com", "date": "2008-05-20T19:11:56Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-05-20T19:11:56Z"}, "message": "tree-loop-linear.c (gather_interchange_stats): Look in the access matrix...\n\n2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n\t    Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-loop-linear.c (gather_interchange_stats): Look in the access matrix,\n\tand never look at the tree representation of the memory accesses.\n\t(linear_transform_loops): Computes parameters and access matrices.\n\t* tree-data-ref.c (compute_data_dependences_for_loop): Returns false when fails.\n\t(access_matrix_get_index_for_parameter): New.\n\t* tree-data-ref.h (struct access_matrix): New.\n\t(AM_LOOP_NEST_NUM, AM_NB_INDUCTION_VARS, AM_PARAMETERS, AM_MATRIX,\n\tAM_NB_PARAMETERS, AM_CONST_COLUMN_INDEX, AM_NB_COLUMNS,\n\tAM_GET_SUBSCRIPT_ACCESS_VECTOR, AM_GET_ACCESS_MATRIX_ELEMENT,\n\tam_vector_index_for_loop): New.\n\t(struct data_reference): Add field access_matrix.\n\t(DR_ACCESS_MATRIX): New.\n\t(compute_data_dependences_for_loop): Update declaration.\n\t(lambda_collect_parameters, lambda_compute_access_matrices): Declared.\n\t* lambda.h (lambda_vector_vec_p): Declared.\n\t* lambda-code.c: Depend on pointer-set.h.\n\t(lambda_collect_parameters_from_af, lambda_collect_parameters,\n\tav_for_af_base, av_for_af, build_access_matrix,\n\tlambda_compute_access_matrices): New.\n\t* Makefile.in (lambda-code.o): Depend on pointer-set.h.\n\n\nCo-Authored-By: Sebastian Pop <sebastian.pop@amd.com>\n\nFrom-SVN: r135672", "tree": {"sha": "ea4cf8fac1c14940e25a8a624cebe081009b766c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea4cf8fac1c14940e25a8a624cebe081009b766c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f275479a9813d4165e9e6766e4f7c6eec1b9792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f275479a9813d4165e9e6766e4f7c6eec1b9792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f275479a9813d4165e9e6766e4f7c6eec1b9792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f275479a9813d4165e9e6766e4f7c6eec1b9792/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f620f482ec35b18c419368a8cae2218bd4cacf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f620f482ec35b18c419368a8cae2218bd4cacf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f620f482ec35b18c419368a8cae2218bd4cacf5"}], "stats": {"total": 363, "additions": 341, "deletions": 22}, "files": [{"sha": "ba15ab570147298a97e70e5d1b5f5bb3d8b5de6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -1,3 +1,27 @@\n+2008-05-20  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-loop-linear.c (gather_interchange_stats): Look in the access matrix,\n+\tand never look at the tree representation of the memory accesses.\n+\t(linear_transform_loops): Computes parameters and access matrices.\n+\t* tree-data-ref.c (compute_data_dependences_for_loop): Returns false when fails.\n+\t(access_matrix_get_index_for_parameter): New.\n+\t* tree-data-ref.h (struct access_matrix): New.\n+\t(AM_LOOP_NEST_NUM, AM_NB_INDUCTION_VARS, AM_PARAMETERS, AM_MATRIX,\n+\tAM_NB_PARAMETERS, AM_CONST_COLUMN_INDEX, AM_NB_COLUMNS,\n+\tAM_GET_SUBSCRIPT_ACCESS_VECTOR, AM_GET_ACCESS_MATRIX_ELEMENT,\n+\tam_vector_index_for_loop): New.\n+\t(struct data_reference): Add field access_matrix.\n+\t(DR_ACCESS_MATRIX): New.\n+\t(compute_data_dependences_for_loop): Update declaration.\n+\t(lambda_collect_parameters, lambda_compute_access_matrices): Declared.\n+\t* lambda.h (lambda_vector_vec_p): Declared.\n+\t* lambda-code.c: Depend on pointer-set.h.\n+\t(lambda_collect_parameters_from_af, lambda_collect_parameters,\n+\tav_for_af_base, av_for_af, build_access_matrix,\n+\tlambda_compute_access_matrices): New.\n+\t* Makefile.in (lambda-code.o): Depend on pointer-set.h.\n+\n 2008-05-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/install.texi2html: Generate gcc-vers.texi in $DESTDIR not"}, {"sha": "0d88228f99c995e8fd0c381672f47daf740a97e1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -2885,7 +2885,7 @@ lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) coretypes.h $(TARGET_H) \\\n-   tree-chrec.h tree-pass.h vec.h vecprim.h $(OBSTACK_H)\n+   tree-chrec.h tree-pass.h vec.h vecprim.h $(OBSTACK_H) pointer-set.h\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h\n pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)"}, {"sha": "707591154e168a18447e2cec46ba29ea2aee8280", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -42,6 +42,7 @@\n #include \"vec.h\"\n #include \"lambda.h\"\n #include \"vecprim.h\"\n+#include \"pointer-set.h\"\n \n /* This loop nest code generation is based on non-singular matrix\n    math.\n@@ -2641,3 +2642,198 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n     }\n   return true;\n }\n+\n+\n+/* Collects parameters from affine function ACCESS_FUNCTION, and push\n+   them in PARAMETERS.  */\n+\n+static void\n+lambda_collect_parameters_from_af (tree access_function,\n+\t\t\t\t   struct pointer_set_t *param_set,\n+\t\t\t\t   VEC (tree, heap) **parameters)\n+{\n+  if (access_function == NULL)\n+    return;\n+\n+  if (TREE_CODE (access_function) == SSA_NAME\n+      && pointer_set_contains (param_set, access_function) == 0)\n+    {\n+      pointer_set_insert (param_set, access_function);\n+      VEC_safe_push (tree, heap, *parameters, access_function);\n+    }\n+  else\n+    {\n+      int i, num_operands = tree_operand_length (access_function);\n+\n+      for (i = 0; i < num_operands; i++)\n+\tlambda_collect_parameters_from_af (TREE_OPERAND (access_function, i),\n+\t\t\t\t\t   param_set, parameters);\n+    }\n+}\n+\n+/* Collects parameters from DATAREFS, and push them in PARAMETERS.  */\n+\n+void\n+lambda_collect_parameters (VEC (data_reference_p, heap) *datarefs,\n+\t\t\t   VEC (tree, heap) **parameters)\n+{\n+  unsigned i, j;\n+  struct pointer_set_t *parameter_set = pointer_set_create ();\n+  data_reference_p data_reference;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, data_reference); i++)\n+    for (j = 0; j < DR_NUM_DIMENSIONS (data_reference); j++)\n+      lambda_collect_parameters_from_af (DR_ACCESS_FN (data_reference, j),\n+\t\t\t\t\t parameter_set, parameters);\n+}\n+\n+/* Translates BASE_EXPR to vector CY.  AM is needed for inferring\n+   indexing positions in the data access vector.  CST is the analyzed\n+   integer constant.  */\n+\n+static bool\n+av_for_af_base (tree base_expr, lambda_vector cy, struct access_matrix *am,\n+\t\tint cst)\n+{\n+  bool result = true;\n+\n+  switch (TREE_CODE (base_expr))\n+    {\n+    case INTEGER_CST:\n+      /* Constant part.  */\n+      cy[AM_CONST_COLUMN_INDEX (am)] += int_cst_value (base_expr) * cst;\n+      return true;\n+\n+    case SSA_NAME:\n+      {\n+\tint param_index =\n+\t  access_matrix_get_index_for_parameter (base_expr, am);\n+\n+\tif (param_index >= 0)\n+\t  {\n+\t    cy[param_index] = cst + cy[param_index];\n+\t    return true;\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case PLUS_EXPR:\n+      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, cst)\n+\t&& av_for_af_base (TREE_OPERAND (base_expr, 1), cy, am, cst);\n+\n+    case MINUS_EXPR:\n+      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, cst)\n+\t&& av_for_af_base (TREE_OPERAND (base_expr, 1), cy, am, -1 * cst);\n+\n+    case MULT_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (base_expr, 0)) == INTEGER_CST)\n+\tresult = av_for_af_base (TREE_OPERAND (base_expr, 1), \n+\t\t\t\t cy, am, cst *\n+\t\t\t\t int_cst_value (TREE_OPERAND (base_expr, 0)));\n+      else if (TREE_CODE (TREE_OPERAND (base_expr, 1)) == INTEGER_CST)\n+\tresult = av_for_af_base (TREE_OPERAND (base_expr, 0),\n+\t\t\t\t cy, am, cst *\n+\t\t\t\t int_cst_value (TREE_OPERAND (base_expr, 1)));\n+      else\n+\tresult = false;\n+\n+      return result;\n+\n+    case NEGATE_EXPR:\n+      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, -1 * cst);\n+\n+    default:\n+      return false;\n+    }\n+\n+  return result;\n+}\n+\n+/* Translates ACCESS_FUN to vector CY.  AM is needed for inferring\n+   indexing positions in the data access vector.  */\n+\n+static bool\n+av_for_af (tree access_fun, lambda_vector cy, struct access_matrix *am)\n+{\n+  switch (TREE_CODE (access_fun))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      {\n+\ttree left = CHREC_LEFT (access_fun);\n+\ttree right = CHREC_RIGHT (access_fun);\n+\tunsigned var;\n+\n+\tif (TREE_CODE (right) != INTEGER_CST)\n+\t  return false;\n+\n+\tvar = am_vector_index_for_loop (am, CHREC_VARIABLE (access_fun));\n+\tcy[var] = int_cst_value (right);\n+\n+\tif (TREE_CODE (left) == POLYNOMIAL_CHREC)\n+\t  return av_for_af (left, cy, am);\n+\telse\n+\t  return av_for_af_base (left, cy, am, 1);\n+      }\n+\n+    case INTEGER_CST:\n+      /* Constant part.  */\n+      return av_for_af_base (access_fun, cy, am, 1);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Initializes the access matrix for DATA_REFERENCE.  */\n+\n+static bool\n+build_access_matrix (data_reference_p data_reference,\n+\t\t     VEC (tree, heap) *parameters, int loop_nest_num)\n+{\n+  struct access_matrix *am = GGC_NEW (struct access_matrix);\n+  unsigned i, ndim = DR_NUM_DIMENSIONS (data_reference);\n+  struct loop *loop = bb_for_stmt (DR_STMT (data_reference))->loop_father;\n+  unsigned nb_induction_vars = loop_depth (loop) - loop_nest_num + 1;\n+  unsigned lambda_nb_columns;\n+  lambda_vector_vec_p matrix;\n+\n+  AM_LOOP_NEST_NUM (am) = loop_nest_num;\n+  AM_NB_INDUCTION_VARS (am) = nb_induction_vars;\n+  AM_PARAMETERS (am) = parameters;\n+\n+  lambda_nb_columns = AM_NB_COLUMNS (am);\n+  matrix = VEC_alloc (lambda_vector, heap, lambda_nb_columns);\n+  AM_MATRIX (am) = matrix;\n+\n+  for (i = 0; i < ndim; i++)\n+    {\n+      lambda_vector access_vector = lambda_vector_new (lambda_nb_columns);\n+      tree access_function = DR_ACCESS_FN (data_reference, i);\n+\n+      if (!av_for_af (access_function, access_vector, am))\n+\treturn false;\n+\n+      VEC_safe_push (lambda_vector, heap, matrix, access_vector);\n+    }\n+\n+  DR_ACCESS_MATRIX (data_reference) = am;\n+  return true;\n+}\n+\n+/* Returns false when one of the access matrices cannot be built.  */\n+\n+bool\n+lambda_compute_access_matrices (VEC (data_reference_p, heap) *datarefs,\n+\t\t\t\tVEC (tree, heap) *parameters,\n+\t\t\t\tint loop_nest_num)\n+{\n+  data_reference_p dataref;\n+  unsigned ix;\n+\n+  for (ix = 0; VEC_iterate (data_reference_p, datarefs, ix, dataref); ix++)\n+    if (!build_access_matrix (dataref, parameters, loop_nest_num))\n+      return false;\n+\n+  return true;\n+}"}, {"sha": "40e8502973cbd018777525ee93aa6dfe56ec64e5", "filename": "gcc/lambda.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -28,10 +28,13 @@ along with GCC; see the file COPYING3.  If not see\n    and scalar multiplication.  In this vector space, an element is a list of\n    integers.  */\n typedef int *lambda_vector;\n-\n DEF_VEC_P(lambda_vector);\n DEF_VEC_ALLOC_P(lambda_vector,heap);\n \n+typedef VEC(lambda_vector, heap) *lambda_vector_vec_p;\n+DEF_VEC_P (lambda_vector_vec_p);\n+DEF_VEC_ALLOC_P (lambda_vector_vec_p, heap);\n+\n /* An integer matrix.  A matrix consists of m vectors of length n (IE\n    all vectors are the same length).  */\n typedef lambda_vector *lambda_matrix;\n@@ -487,4 +490,3 @@ dependence_level (lambda_vector dist_vect, int length)\n }\n \n #endif /* LAMBDA_H  */\n-"}, {"sha": "7f240c6c739e62b6feebdcb9b8603dd0def1ab70", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -201,8 +201,10 @@ evolution_function_is_affine_p (const_tree chrec)\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec), CHREC_VARIABLE (chrec))\n-\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec), CHREC_VARIABLE (chrec)))\n+      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec),\n+\t\t\t\t\t     CHREC_VARIABLE (chrec))\n+\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec),\n+\t\t\t\t\t\tCHREC_VARIABLE (chrec)))\n \treturn true;\n       else\n \treturn false;"}, {"sha": "bf9516cd6724a0a2000a63ea566c04019ba4aaca", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -4180,18 +4180,20 @@ find_loop_nest (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n   return true;\n }\n \n-/* Given a loop nest LOOP, the following vectors are returned:\n+/* Returns true when the data dependences have been computed, false otherwise.\n+   Given a loop nest LOOP, the following vectors are returned:\n    DATAREFS is initialized to all the array elements contained in this loop, \n    DEPENDENCE_RELATIONS contains the relations between the data references.  \n    Compute read-read and self relations if \n    COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n \n-void\n+bool\n compute_data_dependences_for_loop (struct loop *loop, \n \t\t\t\t   bool compute_self_and_read_read_dependences,\n \t\t\t\t   VEC (data_reference_p, heap) **datarefs,\n \t\t\t\t   VEC (ddr_p, heap) **dependence_relations)\n {\n+  bool res = true;\n   VEC (loop_p, heap) *vloops = VEC_alloc (loop_p, heap, 3);\n \n   memset (&dependence_stats, 0, sizeof (dependence_stats));\n@@ -4209,6 +4211,7 @@ compute_data_dependences_for_loop (struct loop *loop,\n \t chrec_dont_know.  */\n       ddr = initialize_data_dependence_relation (NULL, NULL, vloops);\n       VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n+      res = false;\n     }\n   else\n     compute_all_dependences (*datarefs, dependence_relations, vloops,\n@@ -4260,7 +4263,9 @@ compute_data_dependences_for_loop (struct loop *loop,\n \t       dependence_stats.num_miv_independent);\n       fprintf (dump_file, \"Number of miv tests unimplemented: %d\\n\",\n \t       dependence_stats.num_miv_unimplemented);\n-    }    \n+    }\n+\n+  return res;\n }\n \n /* Entry point (for testing only).  Analyze all the data references\n@@ -5032,3 +5037,20 @@ remove_similar_memory_refs (VEC (tree, heap) **stmts)\n   htab_delete (seen);\n }\n \n+/* Returns the index of PARAMETER in the parameters vector of the\n+   ACCESS_MATRIX.  If PARAMETER does not exist return -1.  */\n+\n+int \n+access_matrix_get_index_for_parameter (tree parameter, \n+\t\t\t\t       struct access_matrix *access_matrix)\n+{\n+  int i;\n+  VEC (tree,heap) *lambda_parameters = AM_PARAMETERS (access_matrix);\n+  tree lambda_parameter;\n+\n+  for (i = 0; VEC_iterate (tree, lambda_parameters, i, lambda_parameter); i++)\n+    if (lambda_parameter == parameter)\n+      return i + AM_NB_INDUCTION_VARS (access_matrix);\n+\n+  return -1;\n+}"}, {"sha": "c1672eb3d53f53d655a1d9f24d629a5f76092546", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -96,6 +96,63 @@ struct dr_alias\n   bitmap vops;\n };\n \n+/* Each vector of the access matrix represents a linear access\n+   function for a subscript.  First elements correspond to the\n+   leftmost indices, ie. for a[i][j] the first vector corresponds to\n+   the subscript in \"i\".  The elements of a vector are relative to\n+   the loop nests in which the data reference is considered,\n+   i.e. the vector is relative to the SCoP that provides the context\n+   in which this data reference occurs.\n+\n+   For example, in\n+\n+   | loop_1\n+   |    loop_2\n+   |      a[i+3][2*j+n-1]\n+\n+   if \"i\" varies in loop_1 and \"j\" varies in loop_2, the access \n+   matrix with respect to the loop nest {loop_1, loop_2} is:\n+\n+   | loop_1  loop_2  param_n  cst\n+   |   1       0        0      3\n+   |   0       2        1     -1\n+\n+   whereas the access matrix with respect to loop_2 considers \"i\" as\n+   a parameter:\n+\n+   | loop_2  param_i  param_n  cst\n+   |   0       1         0      3\n+   |   2       0         1     -1\n+*/\n+struct access_matrix\n+{\n+  int loop_nest_num;\n+  int nb_induction_vars;\n+  VEC (tree, heap) *parameters;\n+  VEC (lambda_vector, heap) *matrix;\n+};\n+\n+#define AM_LOOP_NEST_NUM(M) (M)->loop_nest_num\n+#define AM_NB_INDUCTION_VARS(M) (M)->nb_induction_vars\n+#define AM_PARAMETERS(M) (M)->parameters\n+#define AM_MATRIX(M) (M)->matrix\n+#define AM_NB_PARAMETERS(M) (VEC_length (tree, AM_PARAMETERS(M)))\n+#define AM_CONST_COLUMN_INDEX(M) (AM_NB_INDUCTION_VARS (M) + AM_NB_PARAMETERS (M))\n+#define AM_NB_COLUMNS(M) (AM_NB_INDUCTION_VARS (M) + AM_NB_PARAMETERS (M) + 1)\n+#define AM_GET_SUBSCRIPT_ACCESS_VECTOR(M, I) VEC_index (lambda_vector, AM_MATRIX (M), I)\n+#define AM_GET_ACCESS_MATRIX_ELEMENT(M, I, J) AM_GET_SUBSCRIPT_ACCESS_VECTOR (M, I)[J]\n+\n+/* Return the column in the access matrix of LOOP_NUM.  */\n+\n+static inline int\n+am_vector_index_for_loop (struct access_matrix *access_matrix, int loop_num)\n+{\n+  gcc_assert (loop_num >= AM_LOOP_NEST_NUM (access_matrix));\n+  return loop_num - AM_LOOP_NEST_NUM (access_matrix);\n+}\n+\n+int access_matrix_get_index_for_parameter (tree, struct access_matrix *);\n+\n struct data_reference\n {\n   /* A pointer to the statement that contains this DR.  */\n@@ -118,11 +175,10 @@ struct data_reference\n \n   /* Alias information for the data reference.  */\n   struct dr_alias alias;\n-};\n \n-typedef struct data_reference *data_reference_p;\n-DEF_VEC_P(data_reference_p);\n-DEF_VEC_ALLOC_P (data_reference_p, heap);\n+  /* Matrix representation for the data access functions.  */\n+  struct access_matrix *access_matrix;\n+};\n \n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n@@ -139,6 +195,11 @@ DEF_VEC_ALLOC_P (data_reference_p, heap);\n #define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n #define DR_VOPS(DR)\t\t   (DR)->alias.vops\n #define DR_ALIGNED_TO(DR)          (DR)->innermost.aligned_to\n+#define DR_ACCESS_MATRIX(DR)       (DR)->access_matrix\n+\n+typedef struct data_reference *data_reference_p;\n+DEF_VEC_P(data_reference_p);\n+DEF_VEC_ALLOC_P (data_reference_p, heap);\n \n enum data_dependence_direction {\n   dir_positive, \n@@ -309,7 +370,7 @@ DEF_VEC_ALLOC_O (data_ref_loc, heap);\n \n bool get_references_in_stmt (tree, VEC (data_ref_loc, heap) **);\n void dr_analyze_innermost (struct data_reference *);\n-extern void compute_data_dependences_for_loop (struct loop *, bool,\n+extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);\n extern void print_direction_vector (FILE *, lambda_vector, int);\n@@ -493,7 +554,12 @@ rdg_has_similar_memory_accesses (struct graph *rdg, int v1, int v2)\n }\n \n /* In lambda-code.c  */\n-bool lambda_transform_legal_p (lambda_trans_matrix, int, VEC (ddr_p, heap) *);\n+bool lambda_transform_legal_p (lambda_trans_matrix, int,\n+\t\t\t       VEC (ddr_p, heap) *);\n+void lambda_collect_parameters (VEC (data_reference_p, heap) *,\n+\t\t\t\tVEC (tree, heap) **);\n+bool lambda_compute_access_matrices (VEC (data_reference_p, heap) *,\n+\t\t\t\t     VEC (tree, heap) *, int);\n \n /* In tree-data-refs.c  */\n void split_constant_offset (tree , tree *, tree *);"}, {"sha": "f58bd11b7fb1e96c9aaf9895adcbcab920a6046c", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f275479a9813d4165e9e6766e4f7c6eec1b9792/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=9f275479a9813d4165e9e6766e4f7c6eec1b9792", "patch": "@@ -146,19 +146,17 @@ gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations,\n       for (it = 0; it < DR_NUM_DIMENSIONS (dr); \n \t   it++, ref = TREE_OPERAND (ref, 0))\n \t{\n-\t  tree chrec = DR_ACCESS_FN (dr, it);\n-\t  tree tstride = evolution_part_in_loop_num (chrec, loop->num);\n+\t  int num = am_vector_index_for_loop (DR_ACCESS_MATRIX (dr), loop->num);\n+\t  int istride = AM_GET_ACCESS_MATRIX_ELEMENT (DR_ACCESS_MATRIX (dr), it, num);\n \t  tree array_size = TYPE_SIZE (TREE_TYPE (ref));\n \t  double_int dstride;\n \n-\t  if (tstride == NULL_TREE\n-\t      || array_size == NULL_TREE \n-\t      || TREE_CODE (tstride) != INTEGER_CST\n+\t  if (array_size == NULL_TREE \n \t      || TREE_CODE (array_size) != INTEGER_CST)\n \t    continue;\n \n \t  dstride = double_int_mul (tree_to_double_int (array_size), \n-\t\t\t\t    tree_to_double_int (tstride));\n+\t\t\t\t    shwi_to_double_int (istride));\n \t  (*access_strides) = double_int_add (*access_strides, dstride);\n \t}\n     }\n@@ -320,6 +318,7 @@ linear_transform_loops (void)\n   loop_iterator li;\n   VEC(tree,heap) *oldivs = NULL;\n   VEC(tree,heap) *invariants = NULL;\n+  VEC(tree,heap) *lambda_parameters = NULL;\n   VEC(tree,heap) *remove_ivs = VEC_alloc (tree, heap, 3);\n   struct loop *loop_nest;\n   tree oldiv_stmt;\n@@ -330,6 +329,7 @@ linear_transform_loops (void)\n       unsigned int depth = 0;\n       VEC (ddr_p, heap) *dependence_relations;\n       VEC (data_reference_p, heap) *datarefs;\n+      \n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       struct obstack lambda_obstack;\n@@ -341,11 +341,18 @@ linear_transform_loops (void)\n \n       VEC_truncate (tree, oldivs, 0);\n       VEC_truncate (tree, invariants, 0);\n+      VEC_truncate (tree, lambda_parameters, 0);\n \n       datarefs = VEC_alloc (data_reference_p, heap, 10);\n       dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n-      compute_data_dependences_for_loop (loop_nest, true, &datarefs,\n-\t\t\t\t\t &dependence_relations);\n+      if (!compute_data_dependences_for_loop (loop_nest, true, &datarefs,\n+\t\t\t\t\t      &dependence_relations))\n+\tcontinue;\n+      \n+      lambda_collect_parameters (datarefs, &lambda_parameters);\n+      if (!lambda_compute_access_matrices (datarefs, lambda_parameters,\n+\t\t\t\t\t   loop_nest->num))\n+\tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tdump_ddrs (dump_file, dependence_relations);"}]}