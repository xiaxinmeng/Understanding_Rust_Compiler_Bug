{"sha": "1e0598e25c07970f830bb52f2ae75c7007dea4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwNTk4ZTI1YzA3OTcwZjgzMGJiNTJmMmFlNzVjNzAwN2RlYTRiNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-23T07:58:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-23T07:58:41Z"}, "message": "optabs.h (OTI_movmisalign, [...]): New.\n\n        * optabs.h (OTI_movmisalign, movmisalign_optab): New.\n        * optabs.c (init_optabs): Create it.\n        * genopinit.c (optabs): Initialize it.\n        * expr.c (expand_expr_real_1) <MISALIGNED_INDIRECT_REF>: Use it.\n        * tree-vectorizer.c (vect_supportable_dr_alignment): Likewise.\n        * target-def.h (TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n        * target.h (vectorize.misaligned_mem_ok): Remove.\n        * targhooks.c (default_vect_misaligned_mem_ok): Remove.\n        * doc/md.texi (movmisalign): New.\n        * doc/tm.texi (TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n\nFrom-SVN: r92537", "tree": {"sha": "82224c10b6b040c1b09d8cc1ee0b14eb54d26e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82224c10b6b040c1b09d8cc1ee0b14eb54d26e72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e0598e25c07970f830bb52f2ae75c7007dea4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0598e25c07970f830bb52f2ae75c7007dea4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e0598e25c07970f830bb52f2ae75c7007dea4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0598e25c07970f830bb52f2ae75c7007dea4b4/comments", "author": null, "committer": null, "parents": [{"sha": "1c47af84a30650b28b6d1957f1689e2107396a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c47af84a30650b28b6d1957f1689e2107396a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c47af84a30650b28b6d1957f1689e2107396a2e"}], "stats": {"total": 93, "additions": 59, "deletions": 34}, "files": [{"sha": "0d959dccedbde2b7efd29a65364af7317a5fa8d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -1,3 +1,16 @@\n+2004-12-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.h (OTI_movmisalign, movmisalign_optab): New.\n+\t* optabs.c (init_optabs): Create it.\n+\t* genopinit.c (optabs): Initialize it.\n+\t* expr.c (expand_expr_real_1) <MISALIGNED_INDIRECT_REF>: Use it.\n+\t* tree-vectorizer.c (vect_supportable_dr_alignment): Likewise.\n+\t* target-def.h (TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n+\t* target.h (vectorize.misaligned_mem_ok): Remove.\n+\t* targhooks.c (default_vect_misaligned_mem_ok): Remove.\n+\t* doc/md.texi (movmisalign): New.\n+\t* doc/tm.texi (TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n+\n 2004-12-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/emmintrin.h (_mm_loadh_pd): Don't cast pointer arg"}, {"sha": "2c41bc41c598d101e4bc3633f5ab4224e6fed1f3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -2758,6 +2758,17 @@ with mode @var{m} of a register whose natural mode is wider,\n the @samp{movstrict@var{m}} instruction is guaranteed not to alter\n any of the register except the part which belongs to mode @var{m}.\n \n+@cindex @code{movmisalign@var{m}} instruction pattern\n+@item @samp{movmisalign@var{m}}\n+This variant of a move pattern is designed to load or store a value\n+from a memory address that is not naturally aligned for its mode.\n+For a store, the memory will be in operand 0; for a load, the memory\n+will be in operand 1.  The other operand is guaranteed not to be a\n+memory, so that it's easy to tell whether this is a load or store.\n+\n+This pattern is used by the autovectorizer, and when expanding a\n+@code{MISALIGNED_INDIRECT_REF} expression.\n+\n @cindex @code{load_multiple} instruction pattern\n @item @samp{load_multiple}\n Load several consecutive memory locations into consecutive registers."}, {"sha": "fb45a6c8ea3d6b8d29094222a2fedfb72869c039", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -5184,16 +5184,6 @@ holding the constant.  This restriction is often true of addresses\n of TLS symbols for various targets.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VECTORIZE_MISALIGNED_MEM_OK (@var{mode})\n-This hook should return true if a move* pattern to/from memory\n-can be generated for machine_mode @var{mode} even if the memory location \n-is unaligned.\n-If a move* of data to/from unaligned memory locations is not supported for\n-machine_mode @var{mode}, the hook should return false.  \n-This hook is used by the autovectorizer, and when expanding a \n-@code{MISALIGNED_INDIRECT_REF} expression.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)\n This hook should return the DECL of a function @var{f} that given an\n address @var{addr} as an argument returns a mask @var{m} that can be"}, {"sha": "d69a8dff07e7f51ef2b3509055ee5dad440fac24", "filename": "gcc/expr.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -6697,10 +6697,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree exp1 = TREE_OPERAND (exp, 0);\n \ttree orig;\n \n-\tif (code == MISALIGNED_INDIRECT_REF\n-\t    && !targetm.vectorize.misaligned_mem_ok (mode))\n-\t  abort ();\n-\n \tif (modifier != EXPAND_WRITE)\n \t  {\n \t    tree t;\n@@ -6727,6 +6723,33 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  orig = exp;\n \tset_mem_attributes (temp, orig, 0);\n \n+\t/* Resolve the misalignment now, so that we don't have to remember\n+\t   to resolve it later.  Of course, this only works for reads.  */\n+\t/* ??? When we get around to supporting writes, we'll have to handle\n+\t   this in store_expr directly.  The vectorizer isn't generating\n+\t   those yet, however.  */\n+\tif (code == MISALIGNED_INDIRECT_REF)\n+\t  {\n+\t    int icode;\n+\t    rtx reg, insn;\n+\n+\t    gcc_assert (modifier == EXPAND_NORMAL);\n+\n+\t    /* The vectorizer should have already checked the mode.  */\n+\t    icode = movmisalign_optab->handlers[mode].insn_code;\n+\t    gcc_assert (icode != CODE_FOR_nothing);\n+\n+\t    /* We've already validated the memory, and we're creating a\n+\t       new pseudo destination.  The predicates really can't fail.  */\n+\t    reg = gen_reg_rtx (mode);\n+\n+\t    /* Nor can the insn generator.  */\n+\t    insn = GEN_FCN (icode) (reg, temp);\n+\t    emit_insn (insn);\n+\n+\t    return reg;\n+\t  }\n+\n \treturn temp;\n       }\n "}, {"sha": "72593a62ede94992ba9daa95c0cf8d6055945008", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -151,6 +151,7 @@ static const char * const optabs[] =\n   \"parity_optab->handlers[$A].insn_code = CODE_FOR_$(parity$a2$)\",\n   \"mov_optab->handlers[$A].insn_code = CODE_FOR_$(mov$a$)\",\n   \"movstrict_optab->handlers[$A].insn_code = CODE_FOR_$(movstrict$a$)\",\n+  \"movmisalign_optab->handlers[$A].insn_code = CODE_FOR_$(movmisalign$a$)\",\n   \"cmp_optab->handlers[$A].insn_code = CODE_FOR_$(cmp$a$)\",\n   \"tst_optab->handlers[$A].insn_code = CODE_FOR_$(tst$a$)\",\n   \"addcc_optab->handlers[$A].insn_code = CODE_FOR_$(add$acc$)\","}, {"sha": "e18b42bf75fe14c89750ac9ec947b4c533211b15", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -4786,6 +4786,7 @@ init_optabs (void)\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);\n   vec_realign_load_optab = init_optab (UNKNOWN);\n+  movmisalign_optab = init_optab (UNKNOWN);\n \n   /* Conversions.  */\n   sext_optab = init_convert_optab (SIGN_EXTEND);"}, {"sha": "a5942da7cd679c89c1f100d7f021b252bce5aaa6", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -133,6 +133,8 @@ enum optab_index\n   OTI_mov,\n   /* Move, preserving high part of register.  */\n   OTI_movstrict,\n+  /* Move, with a misaligned memory.  */\n+  OTI_movmisalign,\n \n   /* Unary operations */\n   /* Negation */\n@@ -273,6 +275,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n \n #define mov_optab (optab_table[OTI_mov])\n #define movstrict_optab (optab_table[OTI_movstrict])\n+#define movmisalign_optab (optab_table[OTI_movmisalign])\n \n #define neg_optab (optab_table[OTI_neg])\n #define negv_optab (optab_table[OTI_negv])"}, {"sha": "75c949e9e2973bd81c7d193ed5a913ae2b46ade4", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -273,14 +273,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n    TARGET_SCHED_IS_COSTLY_DEPENDENCE}\n \n-#ifndef TARGET_VECTORIZE_MISALIGNED_MEM_OK\n-#define TARGET_VECTORIZE_MISALIGNED_MEM_OK default_vect_misaligned_mem_ok\n-#endif\n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n \n #define TARGET_VECTORIZE                                                \\\n-  {TARGET_VECTORIZE_MISALIGNED_MEM_OK,                                  \\\n-   TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD}\n+  {TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD}\n \n /* In except.c */\n #define TARGET_EH_RETURN_FILTER_MODE  default_eh_return_filter_mode"}, {"sha": "4f4b49ebb51265bb9c48ce1c9eea81192880e978", "filename": "gcc/target.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -285,13 +285,6 @@ struct gcc_target\n   /* Functions relating to vectorization.  */\n   struct vectorize\n   {\n-    /* The following member value is a pointer to a function called\n-       by te vectorizer, and when expanding a MISALIGNED_INDIRECT_REF\n-       expression.  If the hook returns true (false) then a move* pattern\n-       to/from memory can (cannot) be generated for this mode even if the\n-       memory location is unaligned.  */\n-    bool (* misaligned_mem_ok) (enum machine_mode);\n-\n     /* The following member value is a pointer to a function called\n        by the vectorizer, and return the decl of the target builtin\n        function.  */"}, {"sha": "dbb59cf9b46dcfb89e7bb62e09a6b767d763f9d0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -262,12 +262,6 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n     }\n }\n \n-bool\n-default_vect_misaligned_mem_ok (enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return !STRICT_ALIGNMENT;\n-}\n-\n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n \tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,"}, {"sha": "9a7ee12d3fc822e515a88e02613c4b77b46d8e24", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0598e25c07970f830bb52f2ae75c7007dea4b4/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1e0598e25c07970f830bb52f2ae75c7007dea4b4", "patch": "@@ -2704,8 +2704,8 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n \treturn dr_unaligned_software_pipeline;\n \n-      if (targetm.vectorize.misaligned_mem_ok (mode))\n-\t/* Can't software pipeline the loads.  */\n+      if (movmisalign_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+\t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n "}]}