{"sha": "405f63da1c335254a9f4c27bde94d7be7340524c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1ZjYzZGExYzMzNTI1NGE5ZjRjMjdiZGU5NGQ3YmU3MzQwNTI0Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1999-09-22T21:37:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1999-09-22T21:37:20Z"}, "message": "Fix complex-5.c problem\n\nFrom-SVN: r29604", "tree": {"sha": "57b94d994167c688cb82c4a1fe633296abed1717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57b94d994167c688cb82c4a1fe633296abed1717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/405f63da1c335254a9f4c27bde94d7be7340524c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405f63da1c335254a9f4c27bde94d7be7340524c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405f63da1c335254a9f4c27bde94d7be7340524c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405f63da1c335254a9f4c27bde94d7be7340524c/comments", "author": null, "committer": null, "parents": [{"sha": "f9bd8d8e45377edd96155bc38295f483c67a973a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bd8d8e45377edd96155bc38295f483c67a973a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9bd8d8e45377edd96155bc38295f483c67a973a"}], "stats": {"total": 118, "additions": 114, "deletions": 4}, "files": [{"sha": "da95ab576bbb3321b7f30e37fc2129fc9a5e4065", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=405f63da1c335254a9f4c27bde94d7be7340524c", "patch": "@@ -1,3 +1,19 @@\n+Wed Sep 22 17:35:55 1999  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* dwarf2out.c (base_type_die): Use the name __unknown__ if there\n+\tis no name for the base type, rather than segfault.  If we are\n+\twriting out a complex integer type, use DW_ATE_lo_user.\n+\n+\t* expr.c (emit_move_insn_1): If we are copying a complex that fits\n+\tin one word or less (complex char, complex short, or on 64 bit\n+\tsystems complex float) to/from a hard register, copy it through\n+\tmemory instead of dying in gen_{real,imag}part.  If we have a\n+\tshort complex type, prevent inlining since it allocates stack\n+\tmemory.\n+\n+\t* tree.c (build_complex_type): If we are writing dwarf2 output,\n+\tgenerate a name for complex integer types.\n+\n Wed Sep 22 11:34:08 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* basic-block.h (add_noreturn_fake_exit_edges): Use correct name."}, {"sha": "43d1eaa762488776d1c639e22a7ed70a98447c26", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=405f63da1c335254a9f4c27bde94d7be7340524c", "patch": "@@ -6248,9 +6248,15 @@ base_type_die (type)\n       || TREE_CODE (type) == VOID_TYPE)\n     return 0;\n \n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  type_name = IDENTIFIER_POINTER (name);\n+  if (name)\n+    {\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\tname = DECL_NAME (name);\n+\n+      type_name = IDENTIFIER_POINTER (name);\n+    }\n+  else\n+    type_name = \"__unknown__\";\n \n   switch (TREE_CODE (type))\n     {\n@@ -6284,8 +6290,13 @@ base_type_die (type)\n       encoding = DW_ATE_float;\n       break;\n \n+      /* Dwarf2 doesn't know anything about complex ints, so use\n+\t a user defined type for it.  */\n     case COMPLEX_TYPE:\n-      encoding = DW_ATE_complex_float;\n+      if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n+\tencoding = DW_ATE_complex_float;\n+      else\n+\tencoding = DW_ATE_lo_user;\n       break;\n \n     case BOOLEAN_TYPE:"}, {"sha": "fc08068e5aa4fc817516ff13fecbb6c261dc425e", "filename": "gcc/expr.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=405f63da1c335254a9f4c27bde94d7be7340524c", "patch": "@@ -2630,6 +2630,55 @@ emit_move_insn_1 (x, y)\n \t}\n       else\n \t{\n+\t  /* If this is a complex value with each part being smaller than a\n+\t     word, the usual calling sequence will likely pack the pieces into\n+\t     a single register.  Unfortunately, SUBREG of hard registers only\n+\t     deals in terms of words, so we have a problem converting input\n+\t     arguments to the CONCAT of two registers that is used elsewhere\n+\t     for complex values.  If this is before reload, we can copy it into\n+\t     memory and reload.  FIXME, we should see about using extract and\n+\t     insert on integer registers, but complex short and complex char\n+\t     variables should be rarely used.  */\n+\t  if (GET_MODE_BITSIZE (mode) < 2*BITS_PER_WORD\n+\t      && (reload_in_progress | reload_completed) == 0)\n+\t    {\n+\t      int packed_dest_p = (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER);\n+\t      int packed_src_p  = (REG_P (y) && REGNO (y) < FIRST_PSEUDO_REGISTER);\n+\n+\t      if (packed_dest_p || packed_src_p)\n+\t\t{\n+\t\t  enum mode_class reg_class = ((class == MODE_COMPLEX_FLOAT)\n+\t\t\t\t\t       ? MODE_FLOAT : MODE_INT);\n+\n+\t\t  enum machine_mode reg_mode = \n+\t\t    mode_for_size (GET_MODE_BITSIZE (mode), reg_class, 1);\n+\n+\t\t  if (reg_mode != BLKmode)\n+\t\t    {\n+\t\t      rtx mem = assign_stack_temp (reg_mode,\n+\t\t\t\t\t\t   GET_MODE_SIZE (mode), 0);\n+\n+\t\t      rtx cmem = change_address (mem, mode, NULL_RTX);\n+\n+\t\t      current_function->cannot_inline\n+\t\t\t= \"function uses short complex types\";\n+\n+\t\t      if (packed_dest_p)\n+\t\t\t{\n+\t\t\t  rtx sreg = gen_rtx_SUBREG (reg_mode, x, 0);\n+\t\t\t  emit_move_insn_1 (cmem, y);\n+\t\t\t  return emit_move_insn_1 (sreg, mem);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  rtx sreg = gen_rtx_SUBREG (reg_mode, y, 0);\n+\t\t\t  emit_move_insn_1 (mem, sreg);\n+\t\t\t  return emit_move_insn_1 (x, cmem);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  /* Show the output dies here.  This is necessary for pseudos;\n \t     hard regs shouldn't appear here except as return values.\n \t     We never want to emit such a clobber after reload.  */"}, {"sha": "ec85e926b6c7ca46b0edba95a984188dbd62110b", "filename": "gcc/tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405f63da1c335254a9f4c27bde94d7be7340524c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=405f63da1c335254a9f4c27bde94d7be7340524c", "patch": "@@ -4449,6 +4449,40 @@ build_complex_type (component_type)\n   if (TYPE_SIZE (t) == 0)\n     layout_type (t);\n \n+  /* If we are writing Dwarf2 output we need to create a name,\n+     since complex is a fundamental type.  */\n+  if (write_symbols == DWARF2_DEBUG && ! TYPE_NAME (t))\n+    {\n+      char *name;\n+      if (component_type == char_type_node)\n+\tname = \"complex char\";\n+      else if (component_type == signed_char_type_node)\n+\tname = \"complex signed char\";\n+      else if (component_type == unsigned_char_type_node)\n+\tname = \"complex unsigned char\";\n+      else if (component_type == short_integer_type_node)\n+\tname = \"complex short int\";\n+      else if (component_type == short_unsigned_type_node)\n+\tname = \"complex short unsigned int\";\n+      else if (component_type == integer_type_node)\n+\tname = \"complex int\";\n+      else if (component_type == unsigned_type_node)\n+\tname = \"complex unsigned int\";\n+      else if (component_type == long_integer_type_node)\n+\tname = \"complex long int\";\n+      else if (component_type == long_unsigned_type_node)\n+\tname = \"complex long unsigned int\";\n+      else if (component_type == long_long_integer_type_node)\n+\tname = \"complex long long int\";\n+      else if (component_type == long_long_unsigned_type_node)\n+\tname = \"complex long long unsigned int\";\n+      else\n+\tname = (char *)0;\n+\n+      if (name)\n+\tTYPE_NAME (t) = get_identifier (name);\n+    }\n+\n   return t;\n }\n \f"}]}