{"sha": "a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4NDJjMzdhZjZhYjg1YTgxZDU1Njg2MWYzM2MyZjM4Y2U4YjhmNg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2019-05-31T00:38:35Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2019-05-31T00:38:35Z"}, "message": "predicates.md (pcrel_address): New define_predicate.\n\n2019-05-30  Bill Schmidt  <wschmidt@linux.ibm.com>\n\t    Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/predicates.md (pcrel_address): New define_predicate.\n\t(prefixed_mem_operand): Likewise.\n\t(non_prefixed_mem_operand): Likewise.\n\t* config/rs6000/rs6000-protos.h (rs6000_prefixed_address): New\n\tprototype.\n\t* config/rs6000/rs6000.c (print_operand_address): Handle\n\tPC-relative addresses.\n\t(mode_supports_prefixed_address_p): New function.\n\t(rs6000_prefixed_address): New function.\n\t* config/rs6000/rs6000.h (SYMBOL_FLAG_PCREL): New #define.\n\t(SYMBOL_REF_PCREL_P): Likewise.\n\n\nCo-Authored-By: Michael Meissner <meissner@linux.ibm.com>\n\nFrom-SVN: r271798", "tree": {"sha": "6efeb0c55b16fbda09311ff54cff8e30fb6baaa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6efeb0c55b16fbda09311ff54cff8e30fb6baaa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/comments", "author": null, "committer": null, "parents": [{"sha": "47a665af3bc5bc14bff95f66b3a051a0c8d14fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a665af3bc5bc14bff95f66b3a051a0c8d14fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a665af3bc5bc14bff95f66b3a051a0c8d14fe1"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "293744ea0910a8e68a7ab61efe06b4db54783921", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "patch": "@@ -1,3 +1,18 @@\n+2019-05-30  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\t    Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/predicates.md (pcrel_address): New define_predicate.\n+\t(prefixed_mem_operand): Likewise.\n+\t(non_prefixed_mem_operand): Likewise.\n+\t* config/rs6000/rs6000-protos.h (rs6000_prefixed_address): New\n+\tprototype.\n+\t* config/rs6000/rs6000.c (print_operand_address): Handle\n+\tPC-relative addresses.\n+\t(mode_supports_prefixed_address_p): New function.\n+\t(rs6000_prefixed_address): New function.\n+\t* config/rs6000/rs6000.h (SYMBOL_FLAG_PCREL): New #define.\n+\t(SYMBOL_REF_PCREL_P): Likewise.\n+\n 2019-05-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_CONDTEMP."}, {"sha": "8ca98299950424b54dca539d10118ea2615bbbb8", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "patch": "@@ -1622,6 +1622,45 @@\n   return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n })\n \n+;; Return true if the operand is a pc-relative address.\n+(define_predicate \"pcrel_address\"\n+  (match_code \"label_ref,symbol_ref,const\")\n+{\n+  if (!TARGET_PCREL)\n+    return false;\n+\n+  /* Discard any CONST's.  */\n+  if (GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+\n+  /* Validate offset.  */\n+  if (GET_CODE (op) == PLUS)\n+    {\n+      rtx op0 = XEXP (op, 0);\n+      rtx op1 = XEXP (op, 1);\n+\n+      if (!CONST_INT_P (op1) || !SIGNED_34BIT_OFFSET_P (INTVAL (op1), 0))\n+\treturn false;\n+\n+      op = op0;\n+    }\n+\n+  return LABEL_REF_P (op) || SYMBOL_REF_PCREL_P (op);\n+})\n+\n+;; Return 1 if op is a prefixed memory operand\n+(define_predicate \"prefixed_mem_operand\"\n+  (match_code \"mem\")\n+{\n+  return rs6000_prefixed_address (XEXP (op, 0), GET_MODE (op));\n+})\n+\n+;; Return 1 if op is a memory operand that is not a prefixed memory\n+;; operand.\n+(define_predicate \"non_prefixed_mem_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (not (match_operand 0 \"prefixed_mem_operand\"))))\n+\n ;; Match the first insn (addis) in fusing the combination of addis and loads to\n ;; GPR registers on power8.\n (define_predicate \"fusion_gpr_addis\""}, {"sha": "feb1250fb8b222878739bba1085da263ab0e2af4", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "patch": "@@ -154,6 +154,7 @@ extern align_flags rs6000_loop_align (rtx);\n extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool);\n extern bool rs6000_pcrel_p (struct function *);\n extern bool rs6000_fndecl_pcrel_p (const_tree);\n+extern bool rs6000_prefixed_address (rtx, machine_mode);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "94795bec1d4dd6ff2bd4b93a72cc782b69d53327", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "patch": "@@ -21085,6 +21085,30 @@ print_operand_address (FILE *file, rtx x)\n {\n   if (REG_P (x))\n     fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n+\n+  /* Is it a pc-relative address?  */\n+  else if (pcrel_address (x, Pmode))\n+    {\n+      HOST_WIDE_INT offset;\n+\n+      if (GET_CODE (x) == CONST)\n+\tx = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  offset = INTVAL (XEXP (x, 1));\n+\t  x = XEXP (x, 0);\n+\t}\n+      else\n+\toffset = 0;\n+\n+      output_addr_const (file, x);\n+\n+      if (offset)\n+\tfprintf (file, \"%+\" PRId64, offset);\n+\n+      fputs (\"@pcrel\", file);\n+    }\n   else if (SYMBOL_REF_P (x) || GET_CODE (x) == CONST\n \t   || GET_CODE (x) == LABEL_REF)\n     {\n@@ -21569,6 +21593,71 @@ rs6000_pltseq_template (rtx *operands, int which)\n }\n #endif\n \n+/* Helper function to return whether a MODE can do prefixed loads/stores.\n+   VOIDmode is used when we are loading the pc-relative address into a base\n+   register, but we are not using it as part of a memory operation.  As modes\n+   add support for prefixed memory, they will be added here.  */\n+\n+static bool\n+mode_supports_prefixed_address_p (machine_mode mode)\n+{\n+  return mode == VOIDmode;\n+}\n+\n+/* Function to return true if ADDR is a valid prefixed memory address that uses\n+   mode MODE.  */\n+\n+bool\n+rs6000_prefixed_address (rtx addr, machine_mode mode)\n+{\n+  if (!TARGET_PREFIXED_ADDR || !mode_supports_prefixed_address_p (mode))\n+    return false;\n+\n+  /* Check for PC-relative addresses.  */\n+  if (pcrel_address (addr, Pmode))\n+    return true;\n+\n+  /* Check for prefixed memory addresses that have a large numeric offset,\n+     or an offset that can't be used for a DS/DQ-form memory operation.  */\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+\n+      if (!base_reg_operand (op0, Pmode) || !CONST_INT_P (op1))\n+\treturn false;\n+\n+      HOST_WIDE_INT value = INTVAL (op1);\n+      if (!SIGNED_34BIT_OFFSET_P (value, 0))\n+\treturn false;\n+\n+      /* Offset larger than 16-bits?  */\n+      if (!SIGNED_16BIT_OFFSET_P (value, 0))\n+\treturn true;\n+\n+      /* DQ instruction (bottom 4 bits must be 0) for vectors.  */\n+      HOST_WIDE_INT mask;\n+      if (GET_MODE_SIZE (mode) >= 16)\n+\tmask = 15;\n+\n+      /* DS instruction (bottom 2 bits must be 0).  For 32-bit integers, we\n+\t need to use DS instructions if we are sign-extending the value with\n+\t LWA.  For 32-bit floating point, we need DS instructions to load and\n+\t store values to the traditional Altivec registers.  */\n+      else if (GET_MODE_SIZE (mode) >= 4)\n+\tmask = 3;\n+\n+      /* QImode/HImode has no restrictions.  */\n+      else\n+\treturn true;\n+\n+      /* Return true if we must use a prefixed instruction.  */\n+      return (value & mask) != 0;\n+    }\n+\n+  return false;\n+}\n+\f\n #if defined (HAVE_GAS_HIDDEN) && !TARGET_MACHO\n /* Emit an assembler directive to set symbol visibility for DECL to\n    VISIBILITY_TYPE.  */"}, {"sha": "34fa36b6ed9faa35da5a8b1d0253707e3163256d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1842c37af6ab85a81d556861f33c2f38ce8b8f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a1842c37af6ab85a81d556861f33c2f38ce8b8f6", "patch": "@@ -2516,3 +2516,10 @@ extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n   IN_RANGE (VALUE,\t\t\t\t\t\t\t\\\n \t    -(HOST_WIDE_INT_1 << 33),\t\t\t\t\t\\\n \t    (HOST_WIDE_INT_1 << 33) - 1 - (EXTRA))\n+\n+/* Flag to mark SYMBOL_REF objects to say they are local addresses and are used\n+   in pc-relative addresses.  */\n+#define SYMBOL_FLAG_PCREL\tSYMBOL_FLAG_MACH_DEP\n+\n+#define SYMBOL_REF_PCREL_P(X)\t\t\t\t\t\t\\\n+  (SYMBOL_REF_P (X) && SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_PCREL)"}]}