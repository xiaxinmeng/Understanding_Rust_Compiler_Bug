{"sha": "edd954e6204fd9a4177696e580bb35a80593a365", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRkOTU0ZTYyMDRmZDlhNDE3NzY5NmU1ODBiYjM1YTgwNTkzYTM2NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-30T15:01:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-30T15:01:47Z"}, "message": "loop-invariant.c (invariants, [...]): Use VEC instead of VARRAY.\n\n\t* loop-invariant.c (invariants, create_new_invariant,\n\tget_inv_cost, best_gain_for_invariant,\n\tfind_invariants_to_move, move_invariants,\n\tinit_inv_motion_data, free_inv_motion_data): Use VEC instead\n\tof VARRAY.\n\nFrom-SVN: r99035", "tree": {"sha": "f8e7800af33ed02c5b891a155f6702ad02e1d1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8e7800af33ed02c5b891a155f6702ad02e1d1c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edd954e6204fd9a4177696e580bb35a80593a365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd954e6204fd9a4177696e580bb35a80593a365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edd954e6204fd9a4177696e580bb35a80593a365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd954e6204fd9a4177696e580bb35a80593a365/comments", "author": null, "committer": null, "parents": [{"sha": "544f9440ab0b02d0971a148d63957f1b4232c261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544f9440ab0b02d0971a148d63957f1b4232c261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544f9440ab0b02d0971a148d63957f1b4232c261"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "28514cd3358ca99dc45fbaf8b906ba4bc3bddbd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd954e6204fd9a4177696e580bb35a80593a365/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd954e6204fd9a4177696e580bb35a80593a365/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edd954e6204fd9a4177696e580bb35a80593a365", "patch": "@@ -1,3 +1,11 @@\n+2005-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* loop-invariant.c (invariants, create_new_invariant,\n+\tget_inv_cost, best_gain_for_invariant,\n+\tfind_invariants_to_move, move_invariants,\n+\tinit_inv_motion_data, free_inv_motion_data): Use VEC instead\n+\tof VARRAY.\n+\n 2005-04-29  Richard Henderson  <rth@redhat.com>\n \n \t* function.c (instantiate_decls): Remove valid_only argument."}, {"sha": "34140ef34f93a931a1f00c8e0ab020796141e5a1", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd954e6204fd9a4177696e580bb35a80593a365/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd954e6204fd9a4177696e580bb35a80593a365/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=edd954e6204fd9a4177696e580bb35a80593a365", "patch": "@@ -118,9 +118,14 @@ struct invariant\n \n static unsigned actual_stamp;\n \n+typedef struct invariant *invariant_p;\n+\n+DEF_VEC_P(invariant_p);\n+DEF_VEC_ALLOC_P(invariant_p, heap);\n+\n /* The invariants.  */\n \n-static varray_type invariants;\n+static VEC(invariant_p,heap) *invariants;\n \n /* Test for possibility of invariantness of X.  */\n \n@@ -332,10 +337,10 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n   inv->stamp = 0;\n   inv->insn = insn;\n \n-  inv->invno = VARRAY_ACTIVE_SIZE (invariants);\n+  inv->invno = VEC_length (invariant_p, invariants);\n   if (def)\n     def->invno = inv->invno;\n-  VARRAY_PUSH_GENERIC_PTR_NOGC (invariants, inv);\n+  VEC_safe_push (invariant_p, heap, invariants, inv);\n \n   if (dump_file)\n     {\n@@ -614,7 +619,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n   EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n     {\n-      dep = VARRAY_GENERIC_PTR_NOGC (invariants, depno);\n+      dep = VEC_index (invariant_p, invariants, depno);\n \n       get_inv_cost (dep, &acomp_cost, &aregs_needed);\n \n@@ -673,9 +678,8 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n   int gain = 0, again;\n   unsigned aregs_needed, invno;\n \n-  for (invno = 0; invno < VARRAY_ACTIVE_SIZE (invariants); invno++)\n+  for (invno = 0; VEC_iterate (invariant_p, invariants, invno, inv); invno++)\n     {\n-      inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n       if (inv->move)\n \tcontinue;\n \n@@ -697,7 +701,7 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n static void\n set_move_mark (unsigned invno)\n {\n-  struct invariant *inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+  struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   bitmap_iterator bi;\n \n   if (inv->move)\n@@ -721,7 +725,7 @@ find_invariants_to_move (struct df *df)\n   unsigned i, regs_used, n_inv_uses, regs_needed = 0, new_regs;\n   struct invariant *inv = NULL;\n \n-  if (!VARRAY_ACTIVE_SIZE (invariants))\n+  if (!VEC_length (invariant_p, invariants))\n     return;\n \n   /* Now something slightly more involved.  First estimate the number of used\n@@ -741,9 +745,8 @@ find_invariants_to_move (struct df *df)\n \t}\n     }\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n     {\n-      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n       if (inv->def)\n \tn_inv_uses += inv->def->n_uses;\n     }\n@@ -762,7 +765,7 @@ find_invariants_to_move (struct df *df)\n static void\n move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n {\n-  struct invariant *inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+  struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   unsigned i;\n   basic_block preheader = loop_preheader_edge (loop)->src;\n   rtx reg, set;\n@@ -816,9 +819,8 @@ move_invariants (struct loop *loop, struct df *df)\n   struct invariant *inv;\n   unsigned i;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n     {\n-      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n       if (inv->move)\n \tmove_invariant_reg (loop, i, df);\n     }\n@@ -831,8 +833,7 @@ init_inv_motion_data (void)\n {\n   actual_stamp = 1;\n \n-  if (!invariants)\n-    VARRAY_GENERIC_PTR_NOGC_INIT (invariants, 100, \"invariants\");\n+  invariants = VEC_alloc (invariant_p, heap, 100);\n }\n \n /* Frees the data allocated by invariant motion.  DF is the dataflow\n@@ -859,13 +860,12 @@ free_inv_motion_data (struct df *df)\n       DF_REF_DATA (df->defs[i]) = NULL;\n     }\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n     {\n-      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n       BITMAP_FREE (inv->depends_on);\n       free (inv);\n     }\n-  VARRAY_POP_ALL (invariants);\n+  VEC_free (invariant_p, heap, invariants);\n }\n \n /* Move the invariants out of the LOOP.  DF is the dataflow object.  */"}]}