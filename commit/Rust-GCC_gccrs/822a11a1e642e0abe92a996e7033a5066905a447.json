{"sha": "822a11a1e642e0abe92a996e7033a5066905a447", "node_id": "C_kwDOANBUbNoAKDgyMmExMWExZTY0MmUwYWJlOTJhOTk2ZTcwMzNhNTA2NjkwNWE0NDc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-02-25T14:28:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-02-28T09:49:11Z"}, "message": "libstdc++: Do not use memmove for 1-element ranges [PR108846]\n\nThis avoids overwriting tail padding when algorithms like std::copy are\nused to write a single value through a pointer to a base subobject.\n\nThe pointer arithmetic on a Base* is valid for N==1, but the copy/move\noperation needs to be done using assignment, not a memmove or memcpy of\nsizeof(Base) bytes.\n\nInstead of putting a check for N==1 in all of copy, copy_n, move etc.\nthis adds it to the __copy_move and __copy_move_backward partial\nspecializations used for trivially copyable types. When N==1 those\npartial specializations dispatch to new static member functions of the\npartial specializations for non-trivial types, so that a copy/move\nassignment is done appropriately for the _IsMove constant.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/108846\n\t* include/bits/stl_algobase.h (__copy_move<false, false, RA>)\n\tAdd __assign_one static member function.\n\t(__copy_move<true, false, RA>): Likewise.\n\t(__copy_move<IsMove, true, RA>): Do not use memmove for a single\n\tvalue.\n\t(__copy_move_backward<IsMove, true, RA>): Likewise.\n\t* testsuite/25_algorithms/copy/108846.cc: New test.\n\t* testsuite/25_algorithms/copy_backward/108846.cc: New test.\n\t* testsuite/25_algorithms/copy_n/108846.cc: New test.\n\t* testsuite/25_algorithms/move/108846.cc: New test.\n\t* testsuite/25_algorithms/move_backward/108846.cc: New test.", "tree": {"sha": "123c11aa9575f6e123ba010b3737568aff8ec4d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/123c11aa9575f6e123ba010b3737568aff8ec4d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/822a11a1e642e0abe92a996e7033a5066905a447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822a11a1e642e0abe92a996e7033a5066905a447", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822a11a1e642e0abe92a996e7033a5066905a447", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822a11a1e642e0abe92a996e7033a5066905a447/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a41a56dee5c2d48337739d60c43cab5074bcc8e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41a56dee5c2d48337739d60c43cab5074bcc8e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41a56dee5c2d48337739d60c43cab5074bcc8e7"}], "stats": {"total": 336, "additions": 314, "deletions": 22}, "files": [{"sha": "4a6f8195d989582b325070f9c670a6e9c3e6f955", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -391,6 +391,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  return __result;\n \t}\n+\n+      template<typename _Tp, typename _Up>\n+\tstatic void\n+\t__assign_one(_Tp* __to, _Up* __from)\n+\t{ *__to = *__from; }\n     };\n \n #if __cplusplus >= 201103L\n@@ -411,27 +416,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  return __result;\n \t}\n+\n+      template<typename _Tp, typename _Up>\n+\tstatic void\n+\t__assign_one(_Tp* __to, _Up* __from)\n+\t{ *__to = std::move(*__from); }\n     };\n #endif\n \n   template<bool _IsMove>\n     struct __copy_move<_IsMove, true, random_access_iterator_tag>\n     {\n-      template<typename _Tp>\n+      template<typename _Tp, typename _Up>\n \t_GLIBCXX20_CONSTEXPR\n-\tstatic _Tp*\n-\t__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+\tstatic _Up*\n+\t__copy_m(_Tp* __first, _Tp* __last, _Up* __result)\n \t{\n-#if __cplusplus >= 201103L\n-\t  using __assignable = __conditional_t<_IsMove,\n-\t\t\t\t\t       is_move_assignable<_Tp>,\n-\t\t\t\t\t       is_copy_assignable<_Tp>>;\n-\t  // trivial types can have deleted assignment\n-\t  static_assert( __assignable::value, \"type must be assignable\" );\n-#endif\n \t  const ptrdiff_t _Num = __last - __first;\n-\t  if (_Num)\n+\t  if (__builtin_expect(_Num > 1, true))\n \t    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);\n+\t  else if (_Num == 1)\n+\t    std::__copy_move<_IsMove, false, random_access_iterator_tag>::\n+\t      __assign_one(__result, __first);\n \t  return __result + _Num;\n \t}\n     };\n@@ -732,21 +738,17 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n   template<bool _IsMove>\n     struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>\n     {\n-      template<typename _Tp>\n+      template<typename _Tp, typename _Up>\n \t_GLIBCXX20_CONSTEXPR\n-\tstatic _Tp*\n-\t__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+\tstatic _Up*\n+\t__copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)\n \t{\n-#if __cplusplus >= 201103L\n-\t  using __assignable = __conditional_t<_IsMove,\n-\t\t\t\t\t       is_move_assignable<_Tp>,\n-\t\t\t\t\t       is_copy_assignable<_Tp>>;\n-\t  // trivial types can have deleted assignment\n-\t  static_assert( __assignable::value, \"type must be assignable\" );\n-#endif\n \t  const ptrdiff_t _Num = __last - __first;\n-\t  if (_Num)\n+\t  if (__builtin_expect(_Num > 1, true))\n \t    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n+\t  else if (_Num == 1)\n+\t    std::__copy_move<_IsMove, false, random_access_iterator_tag>::\n+\t      __assign_one(__result - 1, __first);\n \t  return __result - _Num;\n \t}\n     };"}, {"sha": "964028901b8ef85fc12b7bf243d06d057caaa513", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/108846.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F108846.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F108846.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F108846.cc?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/108846 std::copy, std::copy_n and std::copy_backward\n+// on potentially overlapping subobjects\n+\n+struct B {\n+    B(int i, short j) : i(i), j(j) {}\n+    int i;\n+    short j;\n+};\n+struct D : B {\n+    D(int i, short j, short x) : B(i, j), x(x) {}\n+    short x; // Stored in tail padding of B\n+};\n+\n+void\n+test_pr108846()\n+{\n+    D ddst(1, 2, 3);\n+    D dsrc(4, 5, 6);\n+    B *dst = &ddst;\n+    B *src = &dsrc;\n+    // If this is optimized to memmove it will overwrite tail padding.\n+    std::copy(src, src+1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+struct B2 {\n+    B2(int i, short j) : i(i), j(j) {}\n+    B2& operator=(B2& b) { i = b.i; j = b.j; return *this; }\n+    int i;\n+    short j;\n+};\n+struct D2 : B2 {\n+    D2(int i, short j, short x) : B2(i, j), x(x) {}\n+    short x; // Stored in tail padding of B2\n+};\n+\n+void\n+test_non_const_copy_assign()\n+{\n+    D2 ddst(1, 2, 3);\n+    D2 dsrc(4, 5, 6);\n+    B2 *dst = &ddst;\n+    B2 *src = &dsrc;\n+    // Ensure the not-taken trivial copy path works for this type.\n+    std::copy(src, src+1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+int main()\n+{\n+  test_pr108846();\n+  test_non_const_copy_assign();\n+}"}, {"sha": "84b3d5a285b0f6f654800a4e83d19e9392ef9e92", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_backward/108846.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F108846.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F108846.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F108846.cc?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/108846 std::copy, std::copy_n and std::copy_backward\n+// on potentially overlapping subobjects\n+\n+struct B {\n+    B(int i, short j) : i(i), j(j) {}\n+    int i;\n+    short j;\n+};\n+struct D : B {\n+    D(int i, short j, short x) : B(i, j), x(x) {}\n+    short x; // Stored in tail padding of B\n+};\n+\n+void\n+test_pr108846()\n+{\n+    D ddst(1, 2, 3);\n+    D dsrc(4, 5, 6);\n+    B *dst = &ddst;\n+    B *src = &dsrc;\n+    // If this is optimized to memmove it will overwrite tail padding.\n+    std::copy_backward(src, src+1, dst+1);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+struct B2 {\n+    B2(int i, short j) : i(i), j(j) {}\n+    B2& operator=(B2& b) { i = b.i; j = b.j; return *this; }\n+    int i;\n+    short j;\n+};\n+struct D2 : B2 {\n+    D2(int i, short j, short x) : B2(i, j), x(x) {}\n+    short x; // Stored in tail padding of B2\n+};\n+\n+void\n+test_non_const_copy_assign()\n+{\n+    D2 ddst(1, 2, 3);\n+    D2 dsrc(4, 5, 6);\n+    B2 *dst = &ddst;\n+    B2 *src = &dsrc;\n+    // Ensure the not-taken trivial copy path works for this type.\n+    std::copy_backward(src, src+1, dst+1);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+int main()\n+{\n+  test_pr108846();\n+  test_non_const_copy_assign();\n+}"}, {"sha": "9ed43e154b7caf67fb966a2600765d9d3a6a553b", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_n/108846.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2F108846.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2F108846.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_n%2F108846.cc?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/108846 std::copy, std::copy_n and std::copy_backward\n+// on potentially overlapping subobjects\n+\n+struct B {\n+    B(int i, short j) : i(i), j(j) {}\n+    int i;\n+    short j;\n+};\n+struct D : B {\n+    D(int i, short j, short x) : B(i, j), x(x) {}\n+    short x; // Stored in tail padding of B\n+};\n+\n+void\n+test_pr108846()\n+{\n+    D ddst(1, 2, 3);\n+    D dsrc(4, 5, 6);\n+    B *dst = &ddst;\n+    B *src = &dsrc;\n+    // If this is optimized to memmove it will overwrite tail padding.\n+    std::copy_n(src, 1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+struct B2 {\n+    B2(int i, short j) : i(i), j(j) {}\n+    B2& operator=(B2&) = default;\n+    int i;\n+    short j;\n+};\n+struct D2 : B2 {\n+    D2(int i, short j, short x) : B2(i, j), x(x) {}\n+    short x; // Stored in tail padding of B2\n+};\n+\n+void\n+test_non_const_copy_assign()\n+{\n+    D2 ddst(1, 2, 3);\n+    D2 dsrc(4, 5, 6);\n+    B2 *dst = &ddst;\n+    B2 *src = &dsrc;\n+    // Ensure the not-taken trivial copy path works for this type.\n+    std::copy_n(src, 1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+int main()\n+{\n+  test_pr108846();\n+  test_non_const_copy_assign();\n+}"}, {"sha": "8248b87d5e22e0e79d1f7daf63d5a7972bc6d057", "filename": "libstdc++-v3/testsuite/25_algorithms/move/108846.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F108846.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F108846.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F108846.cc?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/108846 std::copy, std::copy_n and std::copy_backward\n+// on potentially overlapping subobjects\n+\n+struct B {\n+    B(int i, short j) : i(i), j(j) {}\n+    int i;\n+    short j;\n+};\n+struct D : B {\n+    D(int i, short j, short x) : B(i, j), x(x) {}\n+    short x; // Stored in tail padding of B\n+};\n+\n+void\n+test_pr108846()\n+{\n+    D ddst(1, 2, 3);\n+    D dsrc(4, 5, 6);\n+    B *dst = &ddst;\n+    B *src = &dsrc;\n+    // If this is optimized to memmove it will overwrite tail padding.\n+    std::move(src, src+1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+struct B3 {\n+    B3(int i, short j) : i(i), j(j) {}\n+    B3& operator=(B3&&) = default;\n+    int i;\n+    short j;\n+};\n+struct D3 : B3 {\n+    D3(int i, short j, short x) : B3(i, j), x(x) {}\n+    short x; // Stored in tail padding of B3\n+};\n+\n+void\n+test_move_only()\n+{\n+    D3 ddst(1, 2, 3);\n+    D3 dsrc(4, 5, 6);\n+    B3 *dst = &ddst;\n+    B3 *src = &dsrc;\n+    // Ensure the not-taken trivial copy path works for this type.\n+    std::move(src, src+1, dst);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+int main()\n+{\n+  test_pr108846();\n+  test_move_only();\n+}"}, {"sha": "035743560e0a4326c4098497cf312fbf90bf7c97", "filename": "libstdc++-v3/testsuite/25_algorithms/move_backward/108846.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F108846.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822a11a1e642e0abe92a996e7033a5066905a447/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F108846.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F108846.cc?ref=822a11a1e642e0abe92a996e7033a5066905a447", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/108846 std::copy, std::copy_n and std::copy_backward\n+// on potentially overlapping subobjects\n+\n+struct B {\n+    B(int i, short j) : i(i), j(j) {}\n+    int i;\n+    short j;\n+};\n+struct D : B {\n+    D(int i, short j, short x) : B(i, j), x(x) {}\n+    short x; // Stored in tail padding of B\n+};\n+\n+void\n+test_pr108846()\n+{\n+    D ddst(1, 2, 3);\n+    D dsrc(4, 5, 6);\n+    B *dst = &ddst;\n+    B *src = &dsrc;\n+    // If this is optimized to memmove it will overwrite tail padding.\n+    std::move_backward(src, src+1, dst+1);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+struct B3 {\n+    B3(int i, short j) : i(i), j(j) {}\n+    B3& operator=(B3&&) = default;\n+    int i;\n+    short j;\n+};\n+struct D3 : B3 {\n+    D3(int i, short j, short x) : B3(i, j), x(x) {}\n+    short x; // Stored in tail padding of B3\n+};\n+\n+void\n+test_move_only()\n+{\n+    D3 ddst(1, 2, 3);\n+    D3 dsrc(4, 5, 6);\n+    B3 *dst = &ddst;\n+    B3 *src = &dsrc;\n+    // Ensure the not-taken trivial copy path works for this type.\n+    std::move_backward(src, src+1, dst+1);\n+    VERIFY(ddst.x == 3);\n+}\n+\n+int main()\n+{\n+  test_pr108846();\n+  test_move_only();\n+}"}]}