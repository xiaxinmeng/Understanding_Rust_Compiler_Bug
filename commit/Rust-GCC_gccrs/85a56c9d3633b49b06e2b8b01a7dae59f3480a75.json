{"sha": "85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVhNTZjOWQzNjMzYjQ5YjA2ZTJiOGIwMWE3ZGFlNTlmMzQ4MGE3NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-05T15:59:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-05T15:59:31Z"}, "message": "re PR c++/21440 (ICE with statement-as-expression)\n\n\tPR c++/21440\n\t* semantics.c (finish_stmt_expr_expr): Add an explicit\n\tinitialization to the last statement in the statement-expression.\n\t* (finish_stmt_expr): Adjust accordingly.\n\n\tPR c++/21440\n\t* g++.dg/ext/stmtexpr5.C: New test.\n\t* g++.dg/ext/stmtexpr6.C: Likewise.\n\nFrom-SVN: r103911", "tree": {"sha": "e475c6fabc15570d2c4c92a201ccf7c95ee23b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e475c6fabc15570d2c4c92a201ccf7c95ee23b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/comments", "author": null, "committer": null, "parents": [{"sha": "3b4fb454b1755ba6bafee42255ba907ebe86bd80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4fb454b1755ba6bafee42255ba907ebe86bd80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b4fb454b1755ba6bafee42255ba907ebe86bd80"}], "stats": {"total": 229, "additions": 111, "deletions": 118}, "files": [{"sha": "d4975c570a03707c02e7d7241b33a31e5822fc69", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "patch": "@@ -1,3 +1,10 @@\n+2005-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/21440\n+\t* semantics.c (finish_stmt_expr_expr): Add an explicit\n+\tinitialization to the last statement in the statement-expression.\n+\t* (finish_stmt_expr): Adjust accordingly.\n+\n 2005-09-03  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23699"}, {"sha": "11552db6f012a8f8f26fde970b143441f0ba7b97", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 72, "deletions": 118, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "patch": "@@ -1540,67 +1540,85 @@ begin_stmt_expr (void)\n }\n \n /* Process the final expression of a statement expression. EXPR can be\n-   NULL, if the final expression is empty.  Build up a TARGET_EXPR so\n-   that the result value can be safely returned to the enclosing\n-   expression.  */\n+   NULL, if the final expression is empty.  Return a STATEMENT_LIST\n+   containing all the statements in the statement-expression, or\n+   ERROR_MARK_NODE if there was an error.  */\n \n tree\n finish_stmt_expr_expr (tree expr, tree stmt_expr)\n {\n-  tree result = NULL_TREE;\n-\n   if (error_operand_p (expr))\n     return error_mark_node;\n \n+  /* If the last statement does not have \"void\" type, then the value\n+     of the last statement is the value of the entire expression.  */ \n   if (expr)\n     {\n-      if (!processing_template_decl && !VOID_TYPE_P (TREE_TYPE (expr)))\n+      tree type;\n+      type = TREE_TYPE (expr);\n+      if (!dependent_type_p (type) && !VOID_TYPE_P (type))\n \t{\n-\t  tree type = TREE_TYPE (expr);\n-\n-\t  if (TREE_CODE (type) == ARRAY_TYPE\n-\t      || TREE_CODE (type) == FUNCTION_TYPE)\n-\t    expr = decay_conversion (expr);\n-\n-\t  expr = require_complete_type (expr);\n-\n+\t  expr = decay_conversion (expr);\n+\t  if (error_operand_p (expr))\n+\t    return error_mark_node;\n \t  type = TREE_TYPE (expr);\n-\n-\t  /* Build a TARGET_EXPR for this aggregate.  finish_stmt_expr\n-\t     will then pull it apart so the lifetime of the target is\n-\t     within the scope of the expression containing this statement\n-\t     expression.  */\n-\t  if (TREE_CODE (expr) == TARGET_EXPR)\n-\t    ;\n-\t  else if (!IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_INIT_REF (type))\n-\t    expr = build_target_expr_with_type (expr, type);\n+\t}\n+      /* The type of the statement-expression is the type of the last\n+\t expression.  */\n+      TREE_TYPE (stmt_expr) = type;\n+      /* We must take particular care if TYPE is a class type.  In\n+\t paticular if EXPR creates a temporary of class type, then it\n+\t must be destroyed at the semicolon terminating the last\n+\t statement -- but we must make a copy before that happens.\n+\n+\t This problem is solved by using a TARGET_EXPR to initialize a\n+\t new temporary variable.  The TARGET_EXPR itself is placed\n+\t outside the statement-expression.  However, the last\n+\t statement in the statement-expression is transformed from\n+\t EXPR to (approximately) T = EXPR, where T is the new\n+\t temporary variable.  Thus, the lifetime of the new temporary\n+\t extends to the full-expression surrounding the\n+\t statement-expression.  */\n+      if (!processing_template_decl && !VOID_TYPE_P (type))\n+\t{\n+\t  tree target_expr; \n+\t  if (CLASS_TYPE_P (type) \n+\t      && !TYPE_HAS_TRIVIAL_INIT_REF (type)) \n+\t    {\n+\t      target_expr = build_target_expr_with_type (expr, type);\n+\t      expr = TARGET_EXPR_INITIAL (target_expr);\n+\t    }\n \t  else\n \t    {\n-\t      /* Copy construct.  */\n-\t      expr = build_special_member_call\n-\t\t(NULL_TREE, complete_ctor_identifier,\n-\t\t build_tree_list (NULL_TREE, expr),\n-\t\t type, LOOKUP_NORMAL);\n-\t      expr = build_cplus_new (type, expr);\n-\t      gcc_assert (TREE_CODE (expr) == TARGET_EXPR);\n+\t      /* Normally, build_target_expr will not create a\n+\t\t TARGET_EXPR for scalars.  However, we need the\n+\t\t temporary here, in order to solve the scoping\n+\t\t problem described above.  */\n+\t      target_expr = force_target_expr (type, expr);\n+\t      expr = TARGET_EXPR_INITIAL (target_expr);\n+\t      expr = build2 (INIT_EXPR, \n+\t\t\t     type,\n+\t\t\t     TARGET_EXPR_SLOT (target_expr),\n+\t\t\t     expr);\n \t    }\n-\t}\n-\n-      if (expr != error_mark_node)\n-\t{\n-\t  result = build_stmt (EXPR_STMT, expr);\n-\t  EXPR_STMT_STMT_EXPR_RESULT (result) = 1;\n-\t  add_stmt (result);\n+\t  TARGET_EXPR_INITIAL (target_expr) = NULL_TREE;\n+\t  /* Save away the TARGET_EXPR in the TREE_TYPE field of the\n+\t     STATEMENT_EXPR.  We will retrieve it in\n+\t     finish_stmt_expr.  */\n+\t  TREE_TYPE (stmt_expr) = target_expr;\n \t}\n     }\n \n-  finish_stmt ();\n+  /* Having modified EXPR to reflect the extra initialization, we now\n+     treat it just like an ordinary statement.  */\n+  expr = finish_expr_stmt (expr);\n \n-  /* Remember the last expression so that finish_stmt_expr\n-     can pull it apart.  */\n-  TREE_TYPE (stmt_expr) = result;\n+  /* Mark the last statement so that we can recognize it as such at\n+     template-instantiation time.  */\n+  if (expr && processing_template_decl)\n+    EXPR_STMT_STMT_EXPR_RESULT (expr) = 1;\n \n-  return result;\n+  return stmt_expr;\n }\n \n /* Finish a statement-expression.  EXPR should be the value returned\n@@ -1610,93 +1628,29 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n tree\n finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n {\n-  tree result, result_stmt, type;\n-  tree *result_stmt_p = NULL;\n+  tree type;\n+  tree result;\n \n-  result_stmt = TREE_TYPE (stmt_expr);\n-  TREE_TYPE (stmt_expr) = void_type_node;\n-  result = pop_stmt_list (stmt_expr);\n+  if (error_operand_p (stmt_expr))\n+    return error_mark_node;\n \n-  if (!result_stmt || VOID_TYPE_P (result_stmt))\n-    type = void_type_node;\n-  else\n-    {\n-      /* We need to search the statement expression for the result_stmt,\n-\t since we'll need to replace it entirely.  */\n-      tree t;\n-      result_stmt_p = &result;\n-      while (1)\n-\t{\n-\t  t = *result_stmt_p;\n-\t  if (t == result_stmt)\n-\t    break;\n+  gcc_assert (TREE_CODE (stmt_expr) == STATEMENT_LIST);\n \n-\t  switch (TREE_CODE (t))\n-\t    {\n-\t    case STATEMENT_LIST:\n-\t      {\n-\t\ttree_stmt_iterator i = tsi_last (t);\n-\t\tresult_stmt_p = tsi_stmt_ptr (i);\n-\t\tbreak;\n-\t      }\n-\t    case BIND_EXPR:\n-\t      result_stmt_p = &BIND_EXPR_BODY (t);\n-\t      break;\n-\t    case TRY_FINALLY_EXPR:\n-\t    case TRY_CATCH_EXPR:\n-\t    case CLEANUP_STMT:\n-\t      result_stmt_p = &TREE_OPERAND (t, 0);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      type = TREE_TYPE (EXPR_STMT_EXPR (result_stmt));\n-    }\n+  type = TREE_TYPE (stmt_expr);\n+  result = pop_stmt_list (stmt_expr);\n \n   if (processing_template_decl)\n     {\n       result = build_min (STMT_EXPR, type, result);\n       TREE_SIDE_EFFECTS (result) = 1;\n       STMT_EXPR_NO_SCOPE (result) = has_no_scope;\n     }\n-  else if (!VOID_TYPE_P (type))\n+  else if (!TYPE_P (type))\n     {\n-      /* Pull out the TARGET_EXPR that is the final expression. Put\n-\t the target's init_expr as the final expression and then put\n-\t the statement expression itself as the target's init\n-\t expr. Finally, return the target expression.  */\n-      tree init, target_expr = EXPR_STMT_EXPR (result_stmt);\n-      gcc_assert (TREE_CODE (target_expr) == TARGET_EXPR);\n-\n-      /* The initializer will be void if the initialization is done by\n-\t AGGR_INIT_EXPR; propagate that out to the statement-expression as\n-\t a whole.  */\n-      init = TREE_OPERAND (target_expr, 1);\n-      type = TREE_TYPE (init);\n-\n-      init = maybe_cleanup_point_expr (init);\n-      *result_stmt_p = init;\n-\n-      if (VOID_TYPE_P (type))\n-\t/* No frobbing needed.  */;\n-      else if (TREE_CODE (result) == BIND_EXPR)\n-\t{\n-\t  /* The BIND_EXPR created in finish_compound_stmt is void; if we're\n-\t     returning a value directly, give it the appropriate type.  */\n-\t  if (VOID_TYPE_P (TREE_TYPE (result)))\n-\t    TREE_TYPE (result) = type;\n-\t  else\n-\t    gcc_assert (same_type_p (TREE_TYPE (result), type));\n-\t}\n-      else if (TREE_CODE (result) == STATEMENT_LIST)\n-\t/* We need to wrap a STATEMENT_LIST in a BIND_EXPR so it can have a\n-\t   type other than void.  FIXME why can't we just return a value\n-\t   from STATEMENT_LIST?  */\n-\tresult = build3 (BIND_EXPR, type, NULL, result, NULL);\n-\n-      TREE_OPERAND (target_expr, 1) = result;\n-      result = target_expr;\n+      gcc_assert (TREE_CODE (type) == TARGET_EXPR);\n+      TARGET_EXPR_INITIAL (type) = result;\n+      TREE_TYPE (result) = void_type_node;\n+      result = type;\n     }\n \n   return result;"}, {"sha": "e083e3b3bc85079e3ef52e65f4f9cbfb71147d24", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "patch": "@@ -1,3 +1,9 @@\n+2005-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/21440\n+\t* g++.dg/ext/stmtexpr5.C: New test.\n+\t* g++.dg/ext/stmtexpr6.C: Likewise.\n+\n 2005-09-05  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* gcc.dg/pr21255-1.c: Match different pattern for sh64."}, {"sha": "fc84981ce4997192fa2c7ddc7904b629098fcee1", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr5.C?ref=85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/21440\n+// { dg-options \"\" }\n+\n+struct Foo {\n+  ~Foo();\n+  int i;\n+};\n+\n+void bar() {\n+  Foo foo = ({\n+    Foo bletch;\n+    bletch.i = 0;\n+    bletch;\n+  });\n+}"}, {"sha": "d2518a64a38907c537da89c4ac64aaddb21101ca", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr6.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a56c9d3633b49b06e2b8b01a7dae59f3480a75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr6.C?ref=85a56c9d3633b49b06e2b8b01a7dae59f3480a75", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do run }\n+// { dg-options \"\" }\n+\n+int a[128];\n+\n+int main() {\n+  // Check that array-to-pointer conversion occurs in a\n+  // statement-expression.\n+  if (sizeof (({ a; })) != sizeof (int *))\n+    return 1;\n+}"}]}