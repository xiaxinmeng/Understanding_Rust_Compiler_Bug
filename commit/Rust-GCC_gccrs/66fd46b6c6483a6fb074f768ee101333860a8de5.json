{"sha": "66fd46b6c6483a6fb074f768ee101333860a8de5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZmZDQ2YjZjNjQ4M2E2ZmIwNzRmNzY4ZWUxMDEzMzM4NjBhOGRlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-02-02T00:17:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-02-02T00:17:18Z"}, "message": "alias.c (record_set): Use hard_regno_nregs.\n\n\n\t* alias.c (record_set): Use hard_regno_nregs.\n\t* bt-load.c (find_btr_reference, note_btr_set): Likewise.\n\t* builtins.c (apply_args_size): Likewise.\n\t* caller-save.c (setup_save_areas, save_call_clobbered_regs,\n\tmark_set_regs, add_stored_regs, mark_referenced_regs,\n\tinsert_restore, insert_save, insert_one_insn): Likewise.\n\t* cfgcleanup.c: Include regs.h\n\t(mark_effect, mentions_nonequal_regs): Likewise.\n\t* cfgrtl.c (mark_killed_regs): Likewise\n\t* combine.c (update_table_tick, record_value_for_reg,\n\trecord_dead_and_set_regs, get_last_value_validate, use_crosses_set_p,\n\treg_dead_at_p_1, reg_dead_at_p, mark_used_regs_combine, move_deaths,\n\treg_bitfield_target_p, distribute_notes): Likewise.\n\t* cse.c (mention_regs, insert, invalidate, invalidate_for_call,\n\texp_equiv_p, cse_insn): Likewise.\n\t* cselib.c (cselib_lookup): Likewise.\n\t(cselib_invalidate_regno, cselib_record_set): Likewise.\n\t* df.c (df_ref_record): Likewise.\n\t* dwarf2out.c (reg_loc_descriptor, multiple_reg_loc_descriptor):\n\tLikewise.\n\t* flow.c (mark_reg, insn_dead_p, mark_set_1, mark_used_reg,\n\tcount_or_remove_death_notes_bb): Likewise.\n\t* function.c (aggregate_value_p, keep_stack_depressed): Likewise.\n\t* gloval.c (global_alloc, find_reg, mark_reg_store, mark_reg_conflicts,\n\tmark_reg_death, set_preference, reg_becomes_live, reg_dies): Likewise.\n\t* integrate.c (mark_stores): Likewise.\n\t* jump.c (delete_prior_computation): Likewise.\n\t* lcm.c (reg_dies, reg_becomes_live): Likewise.\n\t* local-alloc.c (combine_regs, find_free_reg, post_mark_life): Likewise.\n\t* loop.c (LOOP_REGNO_NREGS): Likewise.\n\t* postreload.c (reload_combine, reload_combine_note_store,\n\treload_combine_note_use, reload_cse_move2add, move2add_note_store): Likewise.\n\t* ra-colorize.c (combine, color_usable_p, get_free_reg,\n\tcalculate_dont_begin, calculate_dont_begin, colorize_one_web,\n\ttry_recolor_web, insert_coalesced_conflicts, check_colors,\n\tbreak_precolored_alias): Likewise.\n\t* ra-debug.c: Include regs.h\n\t(ra_print_rtx_object): Likewise.\n\t* ra-rewrite (choose_spill_colors): Likewise.\n\t(spill_same_color_p, update_spill_colors, spill_is_free): Likewise.\n\t* ra.c (init_ra): Likewise.\n\t* recog.c (reg_fits_class_p, peep2_reg_dead_p,\n\tpeep2_find_free_register): Likewise.\n\t* reg-stack.c (subst_stack_regs_pat, convert_regs_exit): Likewise.\n\t* regclass.c (hard_regno_nregs): New array.\n\t(init_reg_modes_once): Initialize it.\n\t(choose_hard_reg_mode): Use it.\n\t(record_reg_classes): Likewise.\n\t* regmove.c (mark_flags_life_zones): Likewise.\n\t* regrename.c (note_sets, clear_dead_regs, regrename_optimize,\n\tscan_rtx_reg, dump_def_use_chain, kill_value, set_value_regno,\n\tcopy_value, maybe_mode_change, find_oldest_value_reg,\n\tcopyprop_hardreg_forward_1):\n\t* regs.h (hard_regno_nregs): Declare.\n\t* realod.c (reload_inner_reg_of_subreg): Use it.\n\t(push_reload, combine_reloads, find_dummy_reload,\n\thard_reg_set_here_p, operands_match_p, decompose, find_reloads,\n\trefers_to_regno_for_reload_p, find_equiv_reg, regno_clobbered_p,\n\treload_adjust_reg_for_mode): Likewise.\n\t* reload1.c (compute_use_by_pseudos, count_pseudo,\n\tcount_spilled_pseudo, find_reg, find_reload_regs, mark_home_live,\n\tspill_hard_reg, forget_old_reloads_1, mark_reload_reg_in_use,\n\tclear_reload_reg_in_use, reload_reg_free_for_value_p, free_for_value_p\n\tallocate_reload_reg, choose_reload_regs, emit_reload_insns,\n\tdelete_output_reload): Likewise.\n\t* resource.c (update_live_status, mark_referenced_resources,\n\tmark_set_resources, mark_target_live_regs): Likewise.\n\t* rtlanal.c:  Include regs.h\n\t(refers_to_regno_p, reg_overlap_mentioned_p, dead_or_set_p,\n\tdead_or_set_regno_p, find_regno_note, find_reg_fusage,\n\tsubreg_regno_offset, subreg_offset_representable_p,\n\thoist_test_store): Likewise.\n\t* sched-deps.c (sched_analyze_1, sched_analyze_2): Likewise.\n\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n\t* stmt.c: Include regs.h\n\t(decl_conflicts_with_clobbers_p): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\t* Makefile.in (cfgcleanup.o, rtlanal.o, ra-debug.o): Add regs.h dependnecy.\n\nFrom-SVN: r77088", "tree": {"sha": "21152df3abafc985bdcf61fce3a0dd9124e7be71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21152df3abafc985bdcf61fce3a0dd9124e7be71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66fd46b6c6483a6fb074f768ee101333860a8de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66fd46b6c6483a6fb074f768ee101333860a8de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66fd46b6c6483a6fb074f768ee101333860a8de5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66fd46b6c6483a6fb074f768ee101333860a8de5/comments", "author": null, "committer": null, "parents": [{"sha": "618e342744e69ea70012547ada8461fcd5c626d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618e342744e69ea70012547ada8461fcd5c626d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618e342744e69ea70012547ada8461fcd5c626d1"}], "stats": {"total": 647, "additions": 372, "deletions": 275}, "files": [{"sha": "04aef581e0a0fbbd8092b9452ea631585bb26222", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1,3 +1,84 @@\n+2004-02-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* alias.c (record_set): Use hard_regno_nregs.\n+\t* bt-load.c (find_btr_reference, note_btr_set): Likewise.\n+\t* builtins.c (apply_args_size): Likewise.\n+\t* caller-save.c (setup_save_areas, save_call_clobbered_regs,\n+\tmark_set_regs, add_stored_regs, mark_referenced_regs,\n+\tinsert_restore, insert_save, insert_one_insn): Likewise.\n+\t* cfgcleanup.c: Include regs.h\n+\t(mark_effect, mentions_nonequal_regs): Likewise.\n+\t* cfgrtl.c (mark_killed_regs): Likewise\n+\t* combine.c (update_table_tick, record_value_for_reg,\n+\trecord_dead_and_set_regs, get_last_value_validate, use_crosses_set_p,\n+\treg_dead_at_p_1, reg_dead_at_p, mark_used_regs_combine, move_deaths,\n+\treg_bitfield_target_p, distribute_notes): Likewise.\n+\t* cse.c (mention_regs, insert, invalidate, invalidate_for_call,\n+\texp_equiv_p, cse_insn): Likewise.\n+\t* cselib.c (cselib_lookup): Likewise.\n+\t(cselib_invalidate_regno, cselib_record_set): Likewise.\n+\t* df.c (df_ref_record): Likewise.\n+\t* dwarf2out.c (reg_loc_descriptor, multiple_reg_loc_descriptor):\n+\tLikewise.\n+\t* flow.c (mark_reg, insn_dead_p, mark_set_1, mark_used_reg,\n+\tcount_or_remove_death_notes_bb): Likewise.\n+\t* function.c (aggregate_value_p, keep_stack_depressed): Likewise.\n+\t* gloval.c (global_alloc, find_reg, mark_reg_store, mark_reg_conflicts,\n+\tmark_reg_death, set_preference, reg_becomes_live, reg_dies): Likewise.\n+\t* integrate.c (mark_stores): Likewise.\n+\t* jump.c (delete_prior_computation): Likewise.\n+\t* lcm.c (reg_dies, reg_becomes_live): Likewise.\n+\t* local-alloc.c (combine_regs, find_free_reg, post_mark_life): Likewise.\n+\t* loop.c (LOOP_REGNO_NREGS): Likewise.\n+\t* postreload.c (reload_combine, reload_combine_note_store,\n+\treload_combine_note_use, reload_cse_move2add, move2add_note_store): Likewise.\n+\t* ra-colorize.c (combine, color_usable_p, get_free_reg,\n+\tcalculate_dont_begin, calculate_dont_begin, colorize_one_web, \n+\ttry_recolor_web, insert_coalesced_conflicts, check_colors,\n+\tbreak_precolored_alias): Likewise.\n+\t* ra-debug.c: Include regs.h\n+\t(ra_print_rtx_object): Likewise.\n+\t* ra-rewrite (choose_spill_colors): Likewise.\n+\t(spill_same_color_p, update_spill_colors, spill_is_free): Likewise.\n+\t* ra.c (init_ra): Likewise.\n+\t* recog.c (reg_fits_class_p, peep2_reg_dead_p,\n+\tpeep2_find_free_register): Likewise.\n+\t* reg-stack.c (subst_stack_regs_pat, convert_regs_exit): Likewise.\n+\t* regclass.c (hard_regno_nregs): New array.\n+\t(init_reg_modes_once): Initialize it.\n+\t(choose_hard_reg_mode): Use it.\n+\t(record_reg_classes): Likewise.\n+\t* regmove.c (mark_flags_life_zones): Likewise.\n+\t* regrename.c (note_sets, clear_dead_regs, regrename_optimize,\n+\tscan_rtx_reg, dump_def_use_chain, kill_value, set_value_regno,\n+\tcopy_value, maybe_mode_change, find_oldest_value_reg,\n+\tcopyprop_hardreg_forward_1):\n+\t* regs.h (hard_regno_nregs): Declare.\n+\t* realod.c (reload_inner_reg_of_subreg): Use it.\n+\t(push_reload, combine_reloads, find_dummy_reload,\n+\thard_reg_set_here_p, operands_match_p, decompose, find_reloads,\n+\trefers_to_regno_for_reload_p, find_equiv_reg, regno_clobbered_p,\n+\treload_adjust_reg_for_mode): Likewise.\n+\t* reload1.c (compute_use_by_pseudos, count_pseudo,\n+\tcount_spilled_pseudo, find_reg, find_reload_regs, mark_home_live,\n+\tspill_hard_reg, forget_old_reloads_1, mark_reload_reg_in_use,\n+\tclear_reload_reg_in_use, reload_reg_free_for_value_p, free_for_value_p\n+\tallocate_reload_reg, choose_reload_regs, emit_reload_insns,\n+\tdelete_output_reload): Likewise.\n+\t* resource.c (update_live_status, mark_referenced_resources,\n+\tmark_set_resources, mark_target_live_regs): Likewise.\n+\t* rtlanal.c:  Include regs.h\n+\t(refers_to_regno_p, reg_overlap_mentioned_p, dead_or_set_p,\n+\tdead_or_set_regno_p, find_regno_note, find_reg_fusage,\n+\tsubreg_regno_offset, subreg_offset_representable_p,\n+\thoist_test_store): Likewise.\n+\t* sched-deps.c (sched_analyze_1, sched_analyze_2): Likewise.\n+\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n+\t* stmt.c: Include regs.h\n+\t(decl_conflicts_with_clobbers_p): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\t* Makefile.in (cfgcleanup.o, rtlanal.o, ra-debug.o): Add regs.h dependnecy.\n+\n 2004-02-01  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/arm/arm.c, config/arm/arm.h, config/arm/arm.md,"}, {"sha": "746c74231a1a55c000b9abd9430a5ebe33c6821c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1545,7 +1545,7 @@ print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h $(TM_P_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h flags.h \\\n-   $(BASIC_BLOCK_H)\n+   $(BASIC_BLOCK_H) $(REGS_H)\n \n errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n@@ -1702,7 +1702,7 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) fla\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h \\\n    $(RECOG_H) toplev.h $(GGC_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H) \\\n-   $(PARAMS_H)\n+   $(PARAMS_H) $(REGS_H)\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h flags.h\n cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n@@ -1748,7 +1748,7 @@ ra-colorize.o : ra-colorize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_\n     $(TM_P_H) function.h $(REGS_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h output.h ra.h\n ra-debug.o : ra-debug.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) df.h output.h \\\n-   ra.h $(TM_P_H)\n+   ra.h $(TM_P_H) $(REGS_H)\n ra-rewrite.o : ra-rewrite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) function.h $(REGS_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h $(EXPR_H) \\\n    output.h except.h ra.h reload.h insn-config.h"}, {"sha": "00060fceea1622d434feae6e77b1d494c095658f", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -942,7 +942,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n   /* If this spans multiple hard registers, then we must indicate that every\n      register has an unusable value.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+    n = hard_regno_nregs[regno][GET_MODE (dest)];\n   else\n     n = 1;\n   if (n != 1)"}, {"sha": "010b78e8e0f47954414728b3808bd5db6ef04255", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -198,7 +198,7 @@ find_btr_reference (rtx *px, void *preg)\n   if (GET_CODE (x) != REG)\n     return 0;\n   regno = REGNO (x);\n-  for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1; i >= 0; i--)\n+  for (i = hard_regno_nregs[regno][GET_MODE (x)] - 1; i >= 0; i--)\n     if (TEST_HARD_REG_BIT (all_btrs, regno+i))\n       {\n \tbtr_reference_found = px;\n@@ -430,7 +430,7 @@ note_btr_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n   if (GET_CODE (dest) != REG)\n     return;\n   regno = REGNO (dest);\n-  end_regno = regno + HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+  end_regno = regno + hard_regno_nregs[regno][GET_MODE (dest)];\n   for (; regno < end_regno; regno++)\n     if (TEST_HARD_REG_BIT (all_btrs, regno))\n       {"}, {"sha": "b9b057d944fe7e0c61b7dbe955277414b774d434", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -941,7 +941,7 @@ apply_args_size (void)\n \t\t mode != VOIDmode;\n \t\t mode = GET_MODE_WIDER_MODE (mode))\n \t      if (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t  && HARD_REGNO_NREGS (regno, mode) == 1)\n+\t\t  && hard_regno_nregs[regno][mode] == 1)\n \t\tbest_mode = mode;\n \n \t    if (best_mode == VOIDmode)"}, {"sha": "38bc43160ca1985d2a2b9c4af967bdddcc878df4", "filename": "gcc/caller-save.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -300,7 +300,7 @@ setup_save_areas (void)\n       {\n \tunsigned int regno = reg_renumber[i];\n \tunsigned int endregno\n-\t  = regno + HARD_REGNO_NREGS (regno, GET_MODE (regno_reg_rtx[i]));\n+\t  = regno + hard_regno_nregs[regno][GET_MODE (regno_reg_rtx[i])];\n \n \tfor (r = regno; r < endregno; r++)\n \t  if (call_used_regs[r])\n@@ -436,7 +436,7 @@ save_call_clobbered_regs (void)\n \t\t     {\n \t\t       enum machine_mode mode;\n \n-\t\t       nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno));\n+\t\t       nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n \t\t       mode = HARD_REGNO_CALLER_SAVE_MODE\n \t\t\t        (r, nregs, PSEUDO_REGNO_MODE (regno));\n \t\t       if (GET_MODE_BITSIZE (mode)\n@@ -515,7 +515,7 @@ mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED,\n   else\n     return;\n \n-  endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+  endregno = regno + hard_regno_nregs[regno][mode];\n \n   for (i = regno; i < endregno; i++)\n     SET_HARD_REG_BIT (this_insn_sets, i);\n@@ -548,7 +548,7 @@ add_stored_regs (rtx reg, rtx setter, void *data)\n     return;\n \n   regno = REGNO (reg) + offset;\n-  endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+  endregno = regno + hard_regno_nregs[regno][mode];\n \n   for (i = regno; i < endregno; i++)\n     SET_REGNO_REG_SET ((regset) data, i);\n@@ -595,7 +595,7 @@ mark_referenced_regs (rtx x)\n \n       if (hardregno >= 0)\n \t{\n-\t  int nregs = HARD_REGNO_NREGS (hardregno, GET_MODE (x));\n+\t  int nregs = hard_regno_nregs[hardregno][GET_MODE (x)];\n \t  while (nregs-- > 0)\n \t    SET_HARD_REG_BIT (referenced_regs, hardregno + nregs);\n \t}\n@@ -683,7 +683,7 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == (unsigned int) HARD_REGNO_NREGS (regno, save_mode [regno]))\n+      && numregs == (unsigned int) hard_regno_nregs[regno][save_mode [regno]])\n     mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n@@ -755,7 +755,7 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == (unsigned int) HARD_REGNO_NREGS (regno, save_mode [regno]))\n+      && numregs == (unsigned int) hard_regno_nregs[regno][save_mode [regno]])\n     mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode, mem,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n@@ -828,7 +828,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t\tregno = reg_renumber[regno];\n \t      if (regno < 0)\n \t\tcontinue;\n-\t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n+\t      for (i = hard_regno_nregs[regno][GET_MODE (reg)] - 1;\n \t\t   i >= 0; i--)\n \t\tSET_REGNO_REG_SET (&new->live_throughout, regno + i);\n \t    }"}, {"sha": "38a2915cc7df587ee44bfd3a2f612be0a059d3c9", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -48,6 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n+#include \"regs.h\"\n \n /* cleanup_cfg maintains following flags for each basic block.  */\n \n@@ -220,7 +221,7 @@ mark_effect (rtx exp, regset nonequal)\n \t  CLEAR_REGNO_REG_SET (nonequal, regno);\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t      int n = hard_regno_nregs[regno][GET_MODE (dest)];\n \t      while (--n > 0)\n \t\tCLEAR_REGNO_REG_SET (nonequal, regno + n);\n \t    }\n@@ -239,7 +240,7 @@ mark_effect (rtx exp, regset nonequal)\n       SET_REGNO_REG_SET (nonequal, regno);\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t  int n = hard_regno_nregs[regno][GET_MODE (dest)];\n \t  while (--n > 0)\n \t    SET_REGNO_REG_SET (nonequal, regno + n);\n \t}\n@@ -265,7 +266,7 @@ mentions_nonequal_regs (rtx *x, void *data)\n \treturn 1;\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (*x));\n+\t  int n = hard_regno_nregs[regno][GET_MODE (*x)];\n \t  while (--n > 0)\n \t    if (REGNO_REG_SET_P (nonequal, regno + n))\n \t      return 1;"}, {"sha": "cce760ff7cbf16e2e04a190a4a6f9531290ab831", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1352,7 +1352,7 @@ mark_killed_regs (rtx reg, rtx set ATTRIBUTE_UNUSED, void *data)\n     SET_REGNO_REG_SET (killed, regno);\n   else\n     {\n-      for (i = 0; i < (int) HARD_REGNO_NREGS (regno, GET_MODE (reg)); i++)\n+      for (i = 0; i < (int) hard_regno_nregs[regno][GET_MODE (reg)]; i++)\n \tSET_REGNO_REG_SET (killed, regno + i);\n     }\n }"}, {"sha": "36a7194bc1660ae2b2b397077ce1f335741d3f41", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -11368,7 +11368,7 @@ update_table_tick (rtx x)\n       unsigned int regno = REGNO (x);\n       unsigned int endregno\n \t= regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t   ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t   ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n@@ -11433,7 +11433,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   unsigned int regno = REGNO (reg);\n   unsigned int endregno\n     = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t       ? HARD_REGNO_NREGS (regno, GET_MODE (reg)) : 1);\n+\t       ? hard_regno_nregs[regno][GET_MODE (reg)] : 1);\n   unsigned int i;\n \n   /* If VALUE contains REG and we have a previous value for REG, substitute\n@@ -11590,7 +11590,7 @@ record_dead_and_set_regs (rtx insn)\n \t  unsigned int regno = REGNO (XEXP (link, 0));\n \t  unsigned int endregno\n \t    = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t       ? HARD_REGNO_NREGS (regno, GET_MODE (XEXP (link, 0)))\n+\t\t       ? hard_regno_nregs[regno][GET_MODE (XEXP (link, 0))]\n \t\t       : 1);\n \n \t  for (i = regno; i < endregno; i++)\n@@ -11726,7 +11726,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n       unsigned int regno = REGNO (x);\n       unsigned int endregno\n \t= regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t   ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t   ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n@@ -11888,7 +11888,7 @@ use_crosses_set_p (rtx x, int from_cuid)\n     {\n       unsigned int regno = REGNO (x);\n       unsigned endreg = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t\t\t ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n \n #ifdef PUSH_ROUNDING\n       /* Don't allow uses of the stack pointer to be moved,\n@@ -11945,7 +11945,7 @@ reg_dead_at_p_1 (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (dest)) : 1);\n+\t\t      ? hard_regno_nregs[regno][GET_MODE (dest)] : 1);\n \n   if (reg_dead_endregno > regno && reg_dead_regno < endregno)\n     reg_dead_flag = (GET_CODE (x) == CLOBBER) ? 1 : -1;\n@@ -11968,8 +11968,8 @@ reg_dead_at_p (rtx reg, rtx insn)\n   /* Set variables for reg_dead_at_p_1.  */\n   reg_dead_regno = REGNO (reg);\n   reg_dead_endregno = reg_dead_regno + (reg_dead_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t\t? HARD_REGNO_NREGS (reg_dead_regno,\n-\t\t\t\t\t\t\t    GET_MODE (reg))\n+\t\t\t\t\t? hard_regno_nregs[reg_dead_regno]\n+\t\t\t\t\t\t\t  [GET_MODE (reg)]\n \t\t\t\t\t: 1);\n \n   reg_dead_flag = 0;\n@@ -12070,7 +12070,7 @@ mark_used_regs_combine (rtx x)\n \t      || regno == FRAME_POINTER_REGNUM)\n \t    return;\n \n-\t  endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t  endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \t  for (r = regno; r < endregno; r++)\n \t    SET_HARD_REG_BIT (newpat_used_regs, r);\n \t}\n@@ -12199,10 +12199,10 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t    {\n \t      unsigned int deadregno = REGNO (XEXP (note, 0));\n \t      unsigned int deadend\n-\t\t= (deadregno + HARD_REGNO_NREGS (deadregno,\n-\t\t\t\t\t\t GET_MODE (XEXP (note, 0))));\n+\t\t= (deadregno + hard_regno_nregs[deadregno]\n+\t\t\t\t\t       [GET_MODE (XEXP (note, 0))]);\n \t      unsigned int ourend\n-\t\t= regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n \t      unsigned int i;\n \n \t      for (i = deadregno; i < deadend; i++)\n@@ -12223,15 +12223,15 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t\t\t&& (GET_MODE_SIZE (GET_MODE (XEXP (note, 0)))\n \t\t\t    < GET_MODE_SIZE (GET_MODE (x)))))\n \t\t   && regno < FIRST_PSEUDO_REGISTER\n-\t\t   && HARD_REGNO_NREGS (regno, GET_MODE (x)) > 1)\n+\t\t   && hard_regno_nregs[regno][GET_MODE (x)] > 1)\n \t    {\n \t      unsigned int ourend\n-\t\t= regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n \t      unsigned int i, offset;\n \t      rtx oldnotes = 0;\n \n \t      if (note)\n-\t\toffset = HARD_REGNO_NREGS (regno, GET_MODE (XEXP (note, 0)));\n+\t\toffset = hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))];\n \t      else\n \t\toffset = 1;\n \n@@ -12344,8 +12344,8 @@ reg_bitfield_target_p (rtx x, rtx body)\n       if (tregno >= FIRST_PSEUDO_REGISTER || regno >= FIRST_PSEUDO_REGISTER)\n \treturn target == x;\n \n-      endtregno = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (target));\n-      endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      endtregno = tregno + hard_regno_nregs[tregno][GET_MODE (target)];\n+      endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n       return endregno > tregno && regno < endtregno;\n     }\n@@ -12821,11 +12821,11 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t the previous insn that used this register.  */\n \n \t      if (place && regno < FIRST_PSEUDO_REGISTER\n-\t\t  && HARD_REGNO_NREGS (regno, GET_MODE (XEXP (note, 0))) > 1)\n+\t\t  && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] > 1)\n \t\t{\n \t\t  unsigned int endregno\n-\t\t    = regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\tGET_MODE (XEXP (note, 0)));\n+\t\t    = regno + hard_regno_nregs[regno]\n+\t\t\t\t\t      [GET_MODE (XEXP (note, 0))];\n \t\t  int all_used = 1;\n \t\t  unsigned int i;\n \n@@ -12841,7 +12841,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t not already dead or set.  */\n \n \t\t      for (i = regno; i < endregno;\n-\t\t\t   i += HARD_REGNO_NREGS (i, reg_raw_mode[i]))\n+\t\t\t   i += hard_regno_nregs[i][reg_raw_mode[i]])\n \t\t\t{\n \t\t\t  rtx piece = regno_reg_rtx[i];\n \t\t\t  basic_block bb = this_basic_block;"}, {"sha": "3bdbf0321f10d9575b9bcffee8f84a4310f16238", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1162,7 +1162,7 @@ mention_regs (rtx x)\n       unsigned int regno = REGNO (x);\n       unsigned int endregno\n \t= regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t   : HARD_REGNO_NREGS (regno, GET_MODE (x)));\n+\t\t   : hard_regno_nregs[regno][GET_MODE (x)]);\n       unsigned int i;\n \n       for (i = regno; i < endregno; i++)\n@@ -1529,7 +1529,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n   if (GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      unsigned int endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n       unsigned int i;\n \n       for (i = regno; i < endregno; i++)\n@@ -1842,7 +1842,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \t    HOST_WIDE_INT in_table\n \t      = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n \t    unsigned int endregno\n-\t      = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t      = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \t    unsigned int tregno, tendregno, rn;\n \t    struct table_elt *p, *next;\n \n@@ -1869,7 +1869,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \n \t\t    tregno = REGNO (p->exp);\n \t\t    tendregno\n-\t\t      = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (p->exp));\n+\t\t      = tregno + hard_regno_nregs[tregno][GET_MODE (p->exp)];\n \t\t    if (tendregno > regno && tregno < endregno)\n \t\t      remove_from_table (p, hash);\n \t\t  }\n@@ -2081,7 +2081,7 @@ invalidate_for_call (void)\n \t    continue;\n \n \t  regno = REGNO (p->exp);\n-\t  endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (p->exp));\n+\t  endregno = regno + hard_regno_nregs[regno][GET_MODE (p->exp)];\n \n \t  for (i = regno; i < endregno; i++)\n \t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n@@ -2540,7 +2540,7 @@ exp_equiv_p (rtx x, rtx y, int validate, int equal_values)\n \tunsigned int regno = REGNO (y);\n \tunsigned int endregno\n \t  = regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t     : HARD_REGNO_NREGS (regno, GET_MODE (y)));\n+\t\t     : hard_regno_nregs[regno][GET_MODE (y)]);\n \tunsigned int i;\n \n \t/* If the quantities are not the same, the expressions are not\n@@ -5974,7 +5974,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t      unsigned int regno = REGNO (x);\n \t      unsigned int endregno\n \t\t= regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t   : HARD_REGNO_NREGS (regno, GET_MODE (x)));\n+\t\t\t   : hard_regno_nregs[regno][GET_MODE (x)]);\n \t      unsigned int i;\n \n \t      for (i = regno; i < endregno; i++)"}, {"sha": "1e6aa49ecb8893e4cd7efb286cbc783bf59435e0", "filename": "gcc/cselib.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -900,7 +900,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \n       if (i < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int n = HARD_REGNO_NREGS (i, mode);\n+\t  unsigned int n = hard_regno_nregs[i][mode];\n \n \t  if (n > max_value_regs)\n \t    max_value_regs = n;\n@@ -980,7 +980,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n       else\n \ti = regno - max_value_regs;\n \n-      endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+      endregno = regno + hard_regno_nregs[regno][mode];\n     }\n   else\n     {\n@@ -1001,7 +1001,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  unsigned int this_last = i;\n \n \t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n-\t    this_last += HARD_REGNO_NREGS (i, GET_MODE (v->u.val_rtx)) - 1;\n+\t    this_last += hard_regno_nregs[i][GET_MODE (v->u.val_rtx)] - 1;\n \n \t  if (this_last < regno || v == NULL)\n \t    {\n@@ -1177,7 +1177,7 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n     {\n       if (dreg < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int n = HARD_REGNO_NREGS (dreg, GET_MODE (dest));\n+\t  unsigned int n = hard_regno_nregs[dreg][GET_MODE (dest)];\n \n \t  if (n > max_value_regs)\n \t    max_value_regs = n;"}, {"sha": "686f27d67bca70dadde0a89b9fcf291f41f75fb3", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -819,7 +819,7 @@ df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n \t are really referenced.  E.g., a (subreg:SI (reg:DI 0) 0) does _not_\n \t reference the whole reg 0 in DI mode (which would also include\n \t reg 1, at least, if 0 and 1 are SImode registers).  */\n-      endregno = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      endregno = hard_regno_nregs[regno][GET_MODE (reg)];\n       if (GET_CODE (reg) == SUBREG)\n         regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n \t\t\t\t      SUBREG_BYTE (reg), GET_MODE (reg));"}, {"sha": "3a405ab001861bc8cb74033440a542c5045678fb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -8080,7 +8080,7 @@ reg_loc_descriptor (rtx rtl)\n   reg = reg_number (rtl);\n   regs = (*targetm.dwarf_register_span) (rtl);\n \n-  if (HARD_REGNO_NREGS (reg, GET_MODE (rtl)) > 1\n+  if (hard_regno_nregs[reg][GET_MODE (rtl)] > 1\n       || regs)\n     return multiple_reg_loc_descriptor (rtl, regs);\n   else\n@@ -8110,7 +8110,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n   dw_loc_descr_ref loc_result = NULL;\n \n   reg = reg_number (rtl);\n-  nregs = HARD_REGNO_NREGS (reg, GET_MODE (rtl));\n+  nregs = hard_regno_nregs[reg][GET_MODE (rtl)];\n \n   /* Simple, contiguous registers.  */\n   if (regs == NULL_RTX)"}, {"sha": "1ed469f8f488be367637261a936b6ae7535ac567", "filename": "gcc/flow.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -928,7 +928,7 @@ mark_reg (rtx reg, void *xset)\n   SET_REGNO_REG_SET (set, regno);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int n = hard_regno_nregs[regno][GET_MODE (reg)];\n       while (--n > 0)\n \tSET_REGNO_REG_SET (set, regno + n);\n     }\n@@ -2163,7 +2163,7 @@ insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n \t\t words are not needed.  */\n \t      if (regno < FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n+\t\t  int n = hard_regno_nregs[regno][GET_MODE (r)];\n \n \t\t  while (--n > 0)\n \t\t    if (REGNO_REG_SET_P (pbi->reg_live, regno+n))\n@@ -2560,7 +2560,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n     case REG:\n       regno_last = regno_first = REGNO (reg);\n       if (regno_first < FIRST_PSEUDO_REGISTER)\n-\tregno_last += HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1;\n+\tregno_last += hard_regno_nregs[regno_first][GET_MODE (reg)] - 1;\n       break;\n \n     case SUBREG:\n@@ -2579,7 +2579,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t\t\t\t\t\t  SUBREG_BYTE (reg),\n \t\t\t\t\t\t  outer_mode);\n \t      regno_last = (regno_first\n-\t\t\t    + HARD_REGNO_NREGS (regno_first, outer_mode) - 1);\n+\t\t\t    + hard_regno_nregs[regno_first][outer_mode] - 1);\n \n \t      /* Since we've just adjusted the register number ranges, make\n \t\t sure REG matches.  Otherwise some_was_live will be clear\n@@ -3491,7 +3491,7 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n \n   regno_last = regno_first = REGNO (reg);\n   if (regno_first < FIRST_PSEUDO_REGISTER)\n-    regno_last += HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1;\n+    regno_last += hard_regno_nregs[regno_first][GET_MODE (reg)] - 1;\n \n   /* Find out if any of this register is live after this instruction.  */\n   some_was_live = some_was_dead = 0;\n@@ -4247,7 +4247,7 @@ count_or_remove_death_notes_bb (basic_block bb, int kill)\n \t\t      if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n \t\t        n = 1;\n \t\t      else\n-\t\t        n = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n+\t\t        n = hard_regno_nregs[REGNO (reg)][GET_MODE (reg)];\n \t\t      count += n;\n \t\t    }\n "}, {"sha": "675d919cb0ce8041272ffb384855c9859d63b723", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -4260,7 +4260,7 @@ aggregate_value_p (tree exp, tree fntype)\n     return 0;\n \n   regno = REGNO (reg);\n-  nregs = HARD_REGNO_NREGS (regno, TYPE_MODE (type));\n+  nregs = hard_regno_nregs[regno][TYPE_MODE (type)];\n   for (i = 0; i < nregs; i++)\n     if (! call_used_regs[regno + i])\n       return 1;\n@@ -7489,8 +7489,8 @@ keep_stack_depressed (rtx insns)\n \t\t    && !REGNO_REG_SET_P (EXIT_BLOCK_PTR->global_live_at_start,\n \t\t\t\t\t regno)\n \t\t    && !refers_to_regno_p (regno,\n-\t\t\t\t\t   regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t\t\t     Pmode),\n+\t\t\t\t\t   regno + hard_regno_nregs[regno]\n+\t\t\t\t\t\t\t\t   [Pmode],\n \t\t\t\t\t   info.equiv_reg_src, NULL)\n \t\t    && info.const_equiv[regno] == 0)\n \t\t  break;"}, {"sha": "a676515e5530294b8c573db6f2145a7b20ee121a", "filename": "gcc/global.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -485,7 +485,7 @@ global_alloc (FILE *file)\n     if (reg_renumber[i] >= 0)\n       {\n \tint regno = reg_renumber[i];\n-\tint endregno = regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (i));\n+\tint endregno = regno + hard_regno_nregs[regno][PSEUDO_REGNO_MODE (i)];\n \tint j;\n \n \tfor (j = regno; j < endregno; j++)\n@@ -1072,7 +1072,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t    {\n \t      int j;\n-\t      int lim = regno + HARD_REGNO_NREGS (regno, mode);\n+\t      int lim = regno + hard_regno_nregs[regno][mode];\n \t      for (j = regno + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j));\n@@ -1119,7 +1119,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n \t      int j;\n-\t      int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      int lim = i + hard_regno_nregs[i][mode];\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1158,7 +1158,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n \t      int j;\n-\t      int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      int lim = i + hard_regno_nregs[i][mode];\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1235,7 +1235,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t register, but the check of allocno[num].size above\n \t\t was not enough.  Sometimes we need more than one\n \t\t register for a single-word value.  */\n-\t      && HARD_REGNO_NREGS (regno, mode) == 1\n+\t      && hard_regno_nregs[regno][mode] == 1\n \t      && (allocno[num].calls_crossed == 0\n \t\t  || accept_call_clobbered\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n@@ -1268,7 +1268,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t      {\n \t\t\tint r = reg_renumber[k];\n \t\t\tint endregno\n-\t\t\t  = r + HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (k));\n+\t\t\t  = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (k)];\n \n \t\t\tif (regno >= r && regno < endregno)\n \t\t\t  reg_renumber[k] = -1;\n@@ -1298,7 +1298,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \n       /* Make a set of the hard regs being allocated.  */\n       CLEAR_HARD_REG_SET (this_reg);\n-      lim = best_reg + HARD_REGNO_NREGS (best_reg, mode);\n+      lim = best_reg + hard_regno_nregs[best_reg][mode];\n       for (j = best_reg; j < lim; j++)\n \t{\n \t  SET_HARD_REG_BIT (this_reg, j);\n@@ -1490,7 +1490,7 @@ mark_reg_store (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1539,7 +1539,7 @@ mark_reg_conflicts (rtx reg)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1573,7 +1573,7 @@ mark_reg_death (rtx reg)\n     {\n       /* Pseudo regs already assigned hardware regs are treated\n \t almost the same as explicit hardware regs.  */\n-      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       while (regno < last)\n \t{\n \t  CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n@@ -1590,7 +1590,7 @@ mark_reg_death (rtx reg)\n static void\n mark_reg_live_nc (int regno, enum machine_mode mode)\n {\n-  int last = regno + HARD_REGNO_NREGS (regno, mode);\n+  int last = regno + hard_regno_nregs[regno][mode];\n   while (regno < last)\n     {\n       SET_HARD_REG_BIT (hard_regs_live, regno);\n@@ -1683,7 +1683,7 @@ set_preference (rtx dest, rtx src)\n \t  SET_REGBIT (hard_reg_preferences,\n \t\t      reg_allocno[src_regno], dest_regno);\n \t  for (i = dest_regno;\n-\t       i < dest_regno + HARD_REGNO_NREGS (dest_regno, GET_MODE (dest));\n+\t       i < dest_regno + hard_regno_nregs[dest_regno][GET_MODE (dest)];\n \t       i++)\n \t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n \t}\n@@ -1702,7 +1702,7 @@ set_preference (rtx dest, rtx src)\n \t  SET_REGBIT (hard_reg_preferences,\n \t\t      reg_allocno[dest_regno], src_regno);\n \t  for (i = src_regno;\n-\t       i < src_regno + HARD_REGNO_NREGS (src_regno, GET_MODE (src));\n+\t       i < src_regno + hard_regno_nregs[src_regno][GET_MODE (src)];\n \t       i++)\n \t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n \t}\n@@ -1750,7 +1750,7 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *regs_set)\n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n       while (nregs-- > 0)\n \t{\n \t  SET_REGNO_REG_SET (live_relevant_regs, regno);\n@@ -1772,7 +1772,7 @@ reg_dies (int regno, enum machine_mode mode, struct insn_chain *chain)\n {\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int nregs = HARD_REGNO_NREGS (regno, mode);\n+      int nregs = hard_regno_nregs[regno][mode];\n       while (nregs-- > 0)\n \t{\n \t  CLEAR_REGNO_REG_SET (live_relevant_regs, regno);"}, {"sha": "3e05934fbcf0fb44dd2966cd7eabd5b32009c720", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -2830,7 +2830,7 @@ mark_stores (rtx dest, rtx x ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n     {\n       unsigned int uregno = regno;\n       unsigned int last_reg = (uregno >= FIRST_PSEUDO_REGISTER ? uregno\n-\t\t\t       : uregno + HARD_REGNO_NREGS (uregno, mode) - 1);\n+\t\t\t       : uregno + hard_regno_nregs[uregno][mode] - 1);\n       unsigned int i;\n \n       /* Ignore virtual stack var or virtual arg register since those"}, {"sha": "a1d4e06edde7f02e2b299b4fb14dca03e80bafa1", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1551,13 +1551,13 @@ delete_prior_computation (rtx note, rtx insn)\n \t      int dest_endregno\n \t\t= (dest_regno\n \t\t   + (dest_regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? HARD_REGNO_NREGS (dest_regno,\n-\t\t\t\t\t  GET_MODE (SET_DEST (pat))) : 1));\n+\t\t      ? hard_regno_nregs[dest_regno]\n+\t\t\t\t\t[GET_MODE (SET_DEST (pat))] : 1));\n \t      int regno = REGNO (reg);\n \t      int endregno\n \t\t= (regno\n \t\t   + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (reg)) : 1));\n+\t\t      ? hard_regno_nregs[regno][GET_MODE (reg)] : 1));\n \n \t      if (dest_regno >= regno\n \t\t  && dest_endregno <= endregno)"}, {"sha": "c53b91151c692b66295e3f037ede5188e964f054", "filename": "gcc/lcm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -932,7 +932,7 @@ reg_dies (rtx reg, HARD_REG_SET live)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    for (nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; nregs >= 0;\n+    for (nregs = hard_regno_nregs[regno][GET_MODE (reg)] - 1; nregs >= 0;\n \t nregs--)\n       CLEAR_HARD_REG_BIT (live, regno + nregs);\n }\n@@ -953,7 +953,7 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    for (nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; nregs >= 0;\n+    for (nregs = hard_regno_nregs[regno][GET_MODE (reg)] - 1; nregs >= 0;\n \t nregs--)\n       SET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno + nregs);\n }"}, {"sha": "2d7e32a5d1fc0f2866e83a4623ef81b87ee2b21e", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1799,7 +1799,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n \n   ureg = REGNO (usedreg);\n   if (ureg < FIRST_PSEUDO_REGISTER)\n-    usize = HARD_REGNO_NREGS (ureg, GET_MODE (usedreg));\n+    usize = hard_regno_nregs[ureg][GET_MODE (usedreg)];\n   else\n     usize = ((GET_MODE_SIZE (GET_MODE (usedreg))\n \t      + (REGMODE_NATURAL_SIZE (GET_MODE (usedreg)) - 1))\n@@ -1832,7 +1832,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n \n   sreg = REGNO (setreg);\n   if (sreg < FIRST_PSEUDO_REGISTER)\n-    ssize = HARD_REGNO_NREGS (sreg, GET_MODE (setreg));\n+    ssize = hard_regno_nregs[sreg][GET_MODE (setreg)];\n   else\n     ssize = ((GET_MODE_SIZE (GET_MODE (setreg))\n \t      + (REGMODE_NATURAL_SIZE (GET_MODE (setreg)) - 1))\n@@ -2217,7 +2217,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n \t      || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t{\n \t  int j;\n-\t  int size1 = HARD_REGNO_NREGS (regno, mode);\n+\t  int size1 = hard_regno_nregs[regno][mode];\n \t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n \t  if (j == size1)\n \t    {\n@@ -2275,7 +2275,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n static void\n mark_life (int regno, enum machine_mode mode, int life)\n {\n-  int j = HARD_REGNO_NREGS (regno, mode);\n+  int j = hard_regno_nregs[regno][mode];\n   if (life)\n     while (--j >= 0)\n       SET_HARD_REG_BIT (regs_live, regno + j);\n@@ -2292,7 +2292,7 @@ static void\n post_mark_life (int regno, enum machine_mode mode, int life, int birth,\n \t\tint death)\n {\n-  int j = HARD_REGNO_NREGS (regno, mode);\n+  int j = hard_regno_nregs[regno][mode];\n   HARD_REG_SET this_reg;\n \n   CLEAR_HARD_REG_SET (this_reg);"}, {"sha": "55c9834b2885c787c1f563f655a625d1db80d2da", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -163,7 +163,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define LOOP_REGNO_NREGS(REGNO, SET_DEST) \\\n ((REGNO) < FIRST_PSEUDO_REGISTER \\\n- ? (int) HARD_REGNO_NREGS ((REGNO), GET_MODE (SET_DEST)) : 1)\n+ ? (int) hard_regno_nregs[(REGNO)][GET_MODE (SET_DEST)] : 1)\n \n \n /* Vector mapping INSN_UIDs to luids."}, {"sha": "e0f72d99ebdbcb4c13a603621e56c91f84a9f1df", "filename": "gcc/postreload.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -780,8 +780,8 @@ reload_combine (void)\n       set = single_set (insn);\n       if (set != NULL_RTX\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && (HARD_REGNO_NREGS (REGNO (SET_DEST (set)),\n-\t\t\t\tGET_MODE (SET_DEST (set)))\n+\t  && (hard_regno_nregs[REGNO (SET_DEST (set))]\n+\t\t\t      [GET_MODE (SET_DEST (set))]\n \t      == 1)\n \t  && GET_CODE (SET_SRC (set)) == PLUS\n \t  && GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n@@ -825,7 +825,7 @@ reload_combine (void)\n \t\t\t\t\t i)\n \t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n \t\t      && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n-\t\t      && HARD_REGNO_NREGS (i, GET_MODE (reg)) == 1)\n+\t\t      && hard_regno_nregs[i][GET_MODE (reg)] == 1)\n \t\t    {\n \t\t      rtx index_reg = gen_rtx_REG (GET_MODE (reg), i);\n \n@@ -918,7 +918,7 @@ reload_combine (void)\n \t\t  unsigned int i;\n \t\t  unsigned int start_reg = REGNO (usage_rtx);\n \t\t  unsigned int num_regs =\n-\t\t\tHARD_REGNO_NREGS (start_reg, GET_MODE (usage_rtx));\n+\t\t\thard_regno_nregs[start_reg][GET_MODE (usage_rtx)];\n \t\t  unsigned int end_reg  = start_reg + num_regs - 1;\n \t\t  for (i = start_reg; i <= end_reg; i++)\n \t\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n@@ -999,15 +999,15 @@ reload_combine_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n       || GET_CODE (SET_DEST (set)) == SIGN_EXTRACT\n       || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n     {\n-      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n+      for (i = hard_regno_nregs[regno][mode] - 1 + regno; i >= regno; i--)\n \t{\n \t  reg_state[i].use_index = -1;\n \t  reg_state[i].store_ruid = reload_combine_ruid;\n \t}\n     }\n   else\n     {\n-      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n+      for (i = hard_regno_nregs[regno][mode] - 1 + regno; i >= regno; i--)\n \t{\n \t  reg_state[i].store_ruid = reload_combine_ruid;\n \t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n@@ -1045,7 +1045,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \t/* Mark the return register as used in an unknown fashion.  */\n \t  rtx reg = XEXP (x, 0);\n \t  int regno = REGNO (reg);\n-\t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t  int nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n \n \t  while (--nregs >= 0)\n \t    reg_state[regno + nregs].use_index = -1;\n@@ -1081,7 +1081,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \tif (regno >= FIRST_PSEUDO_REGISTER)\n \t  abort ();\n \n-\tnregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\tnregs = hard_regno_nregs[regno][GET_MODE (x)];\n \n \t/* We can't substitute into multi-hard-reg uses.  */\n \tif (nregs > 1)\n@@ -1391,7 +1391,7 @@ reload_cse_move2add (rtx first)\n \t\t number of calls to gen_rtx_SET to avoid memory\n \t\t allocation if possible.  */\n \t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n-\t      && HARD_REGNO_NREGS (REGNO (XEXP (cnd, 0)), GET_MODE (XEXP (cnd, 0))) == 1\n+\t      && hard_regno_nregs[REGNO (XEXP (cnd, 0))][GET_MODE (XEXP (cnd, 0))] == 1\n \t      && GET_CODE (XEXP (cnd, 1)) == CONST_INT)\n \t    {\n \t      rtx implicit_set =\n@@ -1450,7 +1450,7 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n   regno += REGNO (dst);\n \n   if (SCALAR_INT_MODE_P (mode)\n-      && HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET\n+      && hard_regno_nregs[regno][mode] == 1 && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n       && GET_CODE (SET_DEST (set)) != SIGN_EXTRACT\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n@@ -1551,7 +1551,7 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n     }\n   else\n     {\n-      unsigned int endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+      unsigned int endregno = regno + hard_regno_nregs[regno][mode];\n \n       for (i = regno; i < endregno; i++)\n \t/* Reset the information about this register.  */"}, {"sha": "245292b11ccb6cea73c1c60db0b34fa829f6cd02", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -562,7 +562,7 @@ ok (struct web *target, struct web *source)\n     return 0;\n \n   /* Sanity for funny modes.  */\n-  size = HARD_REGNO_NREGS (color, GET_MODE (target->orig_x));\n+  size = hard_regno_nregs[color][GET_MODE (target->orig_x)];\n   if (!size)\n     return 0;\n \n@@ -726,7 +726,7 @@ combine (struct web *u, struct web *v)\n \t  struct web *web = u;\n \t  int nregs = 1 + v->add_hardregs;\n \t  if (u->type == PRECOLORED)\n-\t    nregs = HARD_REGNO_NREGS (u->color, GET_MODE (v->orig_x));\n+\t    nregs = hard_regno_nregs[u->color][GET_MODE (v->orig_x)];\n \n \t  /* For precolored U's we need to make conflicts between V's\n \t     neighbors and as many hardregs from U as V needed if it gets\n@@ -992,7 +992,7 @@ color_usable_p (int c, HARD_REG_SET dont_begin_colors,\n       && HARD_REGNO_MODE_OK (c, mode))\n     {\n       int i, size;\n-      size = HARD_REGNO_NREGS (c, mode);\n+      size = hard_regno_nregs[c][mode];\n       for (i = 1; i < size && TEST_HARD_REG_BIT (free_colors, c + i); i++);\n       if (i == size)\n \treturn 1;\n@@ -1029,7 +1029,7 @@ get_free_reg (HARD_REG_SET dont_begin_colors, HARD_REG_SET free_colors,\n \t&& HARD_REGNO_MODE_OK (c, mode))\n       {\n \tint i, size;\n-\tsize = HARD_REGNO_NREGS (c, mode);\n+\tsize = hard_regno_nregs[c][mode];\n \tfor (i = 1; i < size && TEST_HARD_REG_BIT (free_colors, c + i); i++);\n \tif (i != size)\n \t  {\n@@ -1172,11 +1172,11 @@ calculate_dont_begin (struct web *web, HARD_REG_SET *result)\n \t  if (ptarget->type == COLORED || ptarget->type == PRECOLORED)\n \t    {\n \t      struct web *source = (sl) ? sl->s : web;\n-\t      unsigned int tsize = HARD_REGNO_NREGS (ptarget->color,\n-\t\t\t\t\t\t     GET_MODE (w->orig_x));\n+\t      unsigned int tsize = hard_regno_nregs[ptarget->color]\n+\t\t\t\t\t\t   [GET_MODE (w->orig_x)];\n \t      /* ssize is only a first guess for the size.  */\n-\t      unsigned int ssize = HARD_REGNO_NREGS (ptarget->color, GET_MODE\n-\t\t\t\t\t             (source->orig_x));\n+\t      unsigned int ssize = hard_regno_nregs[ptarget->color][GET_MODE\n+\t\t\t\t\t            (source->orig_x)];\n \t      unsigned int tofs = 0;\n \t      unsigned int sofs = 0;\n \t      /* C1 and C2 can become negative, so unsigned\n@@ -1202,11 +1202,11 @@ calculate_dont_begin (struct web *web, HARD_REG_SET *result)\n \t\t     c1 to a place, where the last of sources hardregs does not\n \t\t     overlap the first of targets colors.  */\n \t\t  while (c1 + sofs\n-\t\t\t + HARD_REGNO_NREGS (c1, GET_MODE (source->orig_x)) - 1\n+\t\t\t + hard_regno_nregs[c1][GET_MODE (source->orig_x)] - 1\n \t\t\t < ptarget->color + tofs)\n \t\t    c1++;\n \t\t  while (c1 > 0 && c1 + sofs\n-\t\t\t + HARD_REGNO_NREGS (c1, GET_MODE (source->orig_x)) - 1\n+\t\t\t + hard_regno_nregs[c1][GET_MODE (source->orig_x)] - 1\n \t\t\t > ptarget->color + tofs)\n \t\t    c1--;\n \t\t  for (; c1 <= c2; c1++)\n@@ -1588,7 +1588,7 @@ colorize_one_web (struct web *web, int hard)\n       web->color = c;\n       if (flag_ra_biased)\n \t{\n-\t  int nregs = HARD_REGNO_NREGS (c, GET_MODE (web->orig_x));\n+\t  int nregs = hard_regno_nregs[c][GET_MODE (web->orig_x)];\n \t  for (wl = web->conflict_list; wl; wl = wl->next)\n \t    {\n \t      struct web *ptarget = alias (wl->t);\n@@ -1669,7 +1669,7 @@ try_recolor_web (struct web *web)\n       int i, nregs;\n       if (!HARD_REGNO_MODE_OK (c, GET_MODE (web->orig_x)))\n \tcontinue;\n-      nregs = HARD_REGNO_NREGS (c, GET_MODE (web->orig_x));\n+      nregs = hard_regno_nregs[c][GET_MODE (web->orig_x)];\n       for (i = 0; i < nregs; i++)\n \tif (!TEST_HARD_REG_BIT (web->usable_regs, c + i))\n \t  break;\n@@ -1719,14 +1719,14 @@ try_recolor_web (struct web *web)\n       /* Note that min_color[] contains 1-based values (zero means\n \t undef).  */\n       c1 = c1 == 0 ? web2->color : (c1 - 1);\n-      c2 = web2->color + HARD_REGNO_NREGS (web2->color, GET_MODE\n-\t\t\t\t\t   (web2->orig_x)) - 1;\n+      c2 = web2->color + hard_regno_nregs[web2->color][GET_MODE\n+\t\t\t\t\t  (web2->orig_x)] - 1;\n       for (; c1 <= c2; c1++)\n \tif (TEST_HARD_REG_BIT (possible_begin, c1))\n \t  {\n \t    int nregs;\n \t    HARD_REG_SET colors;\n-\t    nregs = HARD_REGNO_NREGS (c1, GET_MODE (web->orig_x));\n+\t    nregs = hard_regno_nregs[c1][GET_MODE (web->orig_x)];\n \t    COPY_HARD_REG_SET (colors, web2->usable_regs);\n \t    for (; nregs--;)\n \t      CLEAR_HARD_REG_BIT (colors, c1 + nregs);\n@@ -1752,7 +1752,7 @@ try_recolor_web (struct web *web)\n       newcol = c;\n   if (newcol >= 0 && cost_neighbors[newcol] < web->spill_cost)\n     {\n-      int nregs = HARD_REGNO_NREGS (newcol, GET_MODE (web->orig_x));\n+      int nregs = hard_regno_nregs[newcol][GET_MODE (web->orig_x)];\n       unsigned HOST_WIDE_INT cost = 0;\n       int *old_colors;\n       struct conflict_link *wl_next;\n@@ -1775,8 +1775,8 @@ try_recolor_web (struct web *web)\n \t  wl_next = wl->next;\n \t  if (web2->type == COLORED)\n \t    {\n-\t      int nregs2 = HARD_REGNO_NREGS (web2->color, GET_MODE\n-\t\t\t\t\t     (web2->orig_x));\n+\t      int nregs2 = hard_regno_nregs[web2->color][GET_MODE\n+\t\t\t\t\t    (web2->orig_x)];\n \t      if (web->color >= web2->color + nregs2\n \t\t  || web2->color >= web->color + nregs)\n \t\tcontinue;\n@@ -1866,7 +1866,7 @@ insert_coalesced_conflicts (void)\n \t  int i;\n \t  int nregs = 1 + web->add_hardregs;\n \t  if (aweb->type == PRECOLORED)\n-\t    nregs = HARD_REGNO_NREGS (aweb->color, GET_MODE (web->orig_x));\n+\t    nregs = hard_regno_nregs[aweb->color][GET_MODE (web->orig_x)];\n \t  for (i = 0; i < nregs; i++)\n \t    {\n \t      if (aweb->type == PRECOLORED)\n@@ -1971,7 +1971,7 @@ check_colors (void)\n       if (aweb->type == SPILLED || web->regno >= max_normal_pseudo)\n \tcontinue;\n       else if (aweb->type == COLORED)\n-\tnregs = HARD_REGNO_NREGS (aweb->color, GET_MODE (web->orig_x));\n+\tnregs = hard_regno_nregs[aweb->color][GET_MODE (web->orig_x)];\n       else if (aweb->type == PRECOLORED)\n \tnregs = 1;\n       else\n@@ -1995,7 +1995,7 @@ check_colors (void)\n \t    struct web *web2 = alias (wl->t);\n \t    int nregs2;\n \t    if (web2->type == COLORED)\n-\t      nregs2 = HARD_REGNO_NREGS (web2->color, GET_MODE (web2->orig_x));\n+\t      nregs2 = hard_regno_nregs[web2->color][GET_MODE (web2->orig_x)];\n \t    else if (web2->type == PRECOLORED)\n \t      nregs2 = 1;\n \t    else\n@@ -2014,8 +2014,8 @@ check_colors (void)\n \t      continue;\n \t    for (sl = wl->sub; sl; sl = sl->next)\n \t      {\n-\t\tint ssize = HARD_REGNO_NREGS (scol, GET_MODE (sl->s->orig_x));\n-\t\tint tsize = HARD_REGNO_NREGS (tcol, GET_MODE (sl->t->orig_x));\n+\t\tint ssize = hard_regno_nregs[scol][GET_MODE (sl->s->orig_x)];\n+\t\tint tsize = hard_regno_nregs[tcol][GET_MODE (sl->t->orig_x)];\n \t\tint sofs = 0, tofs = 0;\n \t        if (SUBWEB_P (sl->t)\n \t\t    && GET_MODE_SIZE (GET_MODE (sl->t->orig_x)) >= UNITS_PER_WORD)\n@@ -2112,7 +2112,7 @@ break_precolored_alias (struct web *web)\n   struct web *pre = web->alias;\n   struct conflict_link *wl;\n   unsigned int c = pre->color;\n-  unsigned int nregs = HARD_REGNO_NREGS (c, GET_MODE (web->orig_x));\n+  unsigned int nregs = hard_regno_nregs[c][GET_MODE (web->orig_x)];\n   if (pre->type != PRECOLORED)\n     abort ();\n   unalias_web (web);"}, {"sha": "780c765d4d1a92e47729dca681f8acee42ff7636", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -32,6 +32,7 @@\n #include \"output.h\"\n #include \"ra.h\"\n #include \"tm_p.h\"\n+#include \"regs.h\"\n \n /* This file contains various dumping and debug functions for\n    the graph coloring register allocator.  */\n@@ -245,7 +246,7 @@ ra_print_rtx_object (FILE *file, rtx x)\n \t\t int regno = REGNO (x);\n \t\t if (regno < FIRST_PSEUDO_REGISTER)\n \t\t   {\n-\t\t     int i, nregs = HARD_REGNO_NREGS (regno, mode);\n+\t\t     int i, nregs = hard_regno_nregs[regno][mode];\n \t\t     if (nregs > 1)\n \t\t       fputs (\"[\", file);\n \t\t     for (i = 0; i < nregs; i++)\n@@ -272,7 +273,7 @@ ra_print_rtx_object (FILE *file, rtx x)\n \t\t     && REGNO (sub) < FIRST_PSEUDO_REGISTER)\n \t\t   {\n \t\t     int regno = REGNO (sub);\n-\t\t     int i, nregs = HARD_REGNO_NREGS (regno, mode);\n+\t\t     int i, nregs = hard_regno_nregs[regno][mode];\n \t\t     regno += subreg_regno_offset (regno, GET_MODE (sub),\n \t\t\t\t\t\t   ofs, mode);\n \t\t     if (nregs > 1)"}, {"sha": "98c87719187828df87b4e9691d0553d3485e6958", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -352,7 +352,7 @@ choose_spill_colors (void)\n \t    && HARD_REGNO_MODE_OK (c, PSEUDO_REGNO_MODE (web->regno)))\n \t  {\n \t    int i, size;\n-\t    size = HARD_REGNO_NREGS (c, PSEUDO_REGNO_MODE (web->regno));\n+\t    size = hard_regno_nregs[c][PSEUDO_REGNO_MODE (web->regno)];\n \t    for (i = 1; i < size\n \t\t && TEST_HARD_REG_BIT (avail, c + i); i++);\n \t    if (i == size)\n@@ -742,9 +742,9 @@ spill_same_color_p (struct web *web1, struct web *web2)\n     return 0;\n \n   size1 = web1->type == PRECOLORED\n-          ? 1 : HARD_REGNO_NREGS (c1, PSEUDO_REGNO_MODE (web1->regno));\n+          ? 1 : hard_regno_nregs[c1][PSEUDO_REGNO_MODE (web1->regno)];\n   size2 = web2->type == PRECOLORED\n-          ? 1 : HARD_REGNO_NREGS (c2, PSEUDO_REGNO_MODE (web2->regno));\n+          ? 1 : hard_regno_nregs[c2][PSEUDO_REGNO_MODE (web2->regno)];\n   if (c1 >= c2 + size2 || c2 >= c1 + size1)\n     return 0;\n   return 1;\n@@ -779,7 +779,7 @@ update_spill_colors (HARD_REG_SET *in_use, struct web *web, int add)\n   if ((c = alias (find_web_for_subweb (web))->color) < 0\n       || c == an_unusable_color)\n     return;\n-  size = HARD_REGNO_NREGS (c, GET_MODE (web->orig_x));\n+  size = hard_regno_nregs[c][GET_MODE (web->orig_x)];\n   if (SUBWEB_P (web))\n     {\n       c += subreg_regno_offset (c, GET_MODE (SUBREG_REG (web->orig_x)),\n@@ -810,7 +810,7 @@ spill_is_free (HARD_REG_SET *in_use, struct web *web)\n   if (c == an_unusable_color)\n     return 1;\n   size = web->type == PRECOLORED\n-         ? 1 : HARD_REGNO_NREGS (c, PSEUDO_REGNO_MODE (web->regno));\n+         ? 1 : hard_regno_nregs[c][PSEUDO_REGNO_MODE (web->regno)];\n   for (; size--;)\n     if (TEST_HARD_REG_BIT (*in_use, c + size))\n       return 0;"}, {"sha": "732c99a2fcb9292d5cd20eaa8e92e8dfb4264f41", "filename": "gcc/ra.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -472,26 +472,26 @@ init_ra (void)\n     {\n       if (! CAN_ELIMINATE (eliminables[j].from, eliminables[j].to)\n \t  || (eliminables[j].to == STACK_POINTER_REGNUM && need_fp))\n-\tfor (i = HARD_REGNO_NREGS (eliminables[j].from, Pmode); i--;)\n+\tfor (i = hard_regno_nregs[eliminables[j].from][Pmode]; i--;)\n \t  SET_HARD_REG_BIT (never_use_colors, eliminables[j].from + i);\n     }\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   if (need_fp)\n-    for (i = HARD_REGNO_NREGS (HARD_FRAME_POINTER_REGNUM, Pmode); i--;)\n+    for (i = hard_regno_nregs[HARD_FRAME_POINTER_REGNUM][Pmode]; i--;)\n       SET_HARD_REG_BIT (never_use_colors, HARD_FRAME_POINTER_REGNUM + i);\n #endif\n \n #else\n   if (need_fp)\n-    for (i = HARD_REGNO_NREGS (FRAME_POINTER_REGNUM, Pmode); i--;)\n+    for (i = hard_regno_nregs[FRAME_POINTER_REGNUM][Pmode]; i--;)\n       SET_HARD_REG_BIT (never_use_colors, FRAME_POINTER_REGNUM + i);\n #endif\n \n   /* Stack and argument pointer are also rather useless to us.  */\n-  for (i = HARD_REGNO_NREGS (STACK_POINTER_REGNUM, Pmode); i--;)\n+  for (i = hard_regno_nregs[STACK_POINTER_REGNUM][Pmode]; i--;)\n     SET_HARD_REG_BIT (never_use_colors, STACK_POINTER_REGNUM + i);\n \n-  for (i = HARD_REGNO_NREGS (ARG_POINTER_REGNUM, Pmode); i--;)\n+  for (i = hard_regno_nregs[ARG_POINTER_REGNUM][Pmode]; i--;)\n     SET_HARD_REG_BIT (never_use_colors, ARG_POINTER_REGNUM + i);\n \n   for (i = 0; i < 256; i++)\n@@ -528,7 +528,7 @@ init_ra (void)\n       for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n \tif (HARD_REGNO_MODE_OK (reg, i)\n \t    /* Ignore VOIDmode and similar things.  */\n-\t    && (size = HARD_REGNO_NREGS (reg, i)) != 0\n+\t    && (size = hard_regno_nregs[reg][i]) != 0\n \t    && (reg + size) <= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    while (size--)"}, {"sha": "470e93b06a3798a0f6abc3461d0a2ccc0991c394", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -2666,7 +2666,7 @@ reg_fits_class_p (rtx operand, enum reg_class class, int offset,\n     {\n       int sr;\n       regno += offset;\n-      for (sr = HARD_REGNO_NREGS (regno, mode) - 1;\n+      for (sr = hard_regno_nregs[regno][mode] - 1;\n \t   sr > 0; sr--)\n \tif (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n \t\t\t\t regno + sr))\n@@ -2910,7 +2910,7 @@ peep2_reg_dead_p (int ofs, rtx reg)\n     abort ();\n \n   regno = REGNO (reg);\n-  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+  n = hard_regno_nregs[regno][GET_MODE (reg)];\n   while (--n >= 0)\n     if (REGNO_REG_SET_P (peep2_insn_data[ofs].live_before, regno + n))\n       return 0;\n@@ -2998,7 +2998,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \tcontinue;\n \n       success = 1;\n-      for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n+      for (j = hard_regno_nregs[regno][mode] - 1; j >= 0; j--)\n \t{\n \t  if (TEST_HARD_REG_BIT (*reg_set, regno + j)\n \t      || TEST_HARD_REG_BIT (live, regno + j))\n@@ -3009,7 +3009,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \t}\n       if (success)\n \t{\n-\t  for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n+\t  for (j = hard_regno_nregs[regno][mode] - 1; j >= 0; j--)\n \t    SET_HARD_REG_BIT (*reg_set, regno + j);\n \n \t  /* Start the next search with the next register.  */"}, {"sha": "433b7393ab6f2974b28277fbb24aaea0cceae3c8", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1491,7 +1491,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t  case CALL:\n \t    {\n \t      int count;\n-\t      for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n+\t      for (count = hard_regno_nregs[REGNO (*dest)][GET_MODE (*dest)];\n \t\t   --count >= 0;)\n \t\t{\n \t\t  regstack->reg[++regstack->top] = REGNO (*dest) + count;\n@@ -2484,7 +2484,7 @@ convert_regs_exit (void)\n     {\n       value_reg_low = REGNO (retvalue);\n       value_reg_high = value_reg_low\n-\t+ HARD_REGNO_NREGS (value_reg_low, GET_MODE (retvalue)) - 1;\n+\t+ hard_regno_nregs[value_reg_low][GET_MODE (retvalue)] - 1;\n     }\n \n   output_stack = &BLOCK_INFO (EXIT_BLOCK_PTR)->stack_in;"}, {"sha": "2ca4cfd2baba02be06e53d6d7e5527ec363a45f8", "filename": "gcc/regclass.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -252,6 +252,8 @@ static struct reg_info_data *reg_info_head;\n \n static int no_global_reg_vars = 0;\n \n+/* Specify number of hard registers given machine mode occupy.  */\n+unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n \n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n@@ -539,7 +541,11 @@ init_reg_sets_1 (void)\n void\n init_reg_modes_once (void)\n {\n-  int i;\n+  int i, j;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    for (j = 0; j < MAX_MACHINE_MODE; j++)\n+      hard_regno_nregs[i][j] = HARD_REGNO_NREGS(i, (enum machine_mode)j);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -658,7 +664,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned) HARD_REGNO_NREGS (regno, mode) == nregs\n+    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n       found_mode = mode;\n@@ -669,7 +675,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned) HARD_REGNO_NREGS (regno, mode) == nregs\n+    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n       found_mode = mode;\n@@ -680,7 +686,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned) HARD_REGNO_NREGS (regno, mode) == nregs\n+    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n       found_mode = mode;\n@@ -691,7 +697,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned) HARD_REGNO_NREGS (regno, mode) == nregs\n+    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n       found_mode = mode;\n@@ -703,7 +709,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (m = (unsigned int) CCmode; m < (unsigned int) NUM_MACHINE_MODES; ++m)\n     {\n       mode = (enum machine_mode) m;\n-      if ((unsigned) HARD_REGNO_NREGS (regno, mode) == nregs\n+      if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t  && HARD_REGNO_MODE_OK (regno, mode)\n \t  && (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \treturn mode;\n@@ -1836,14 +1842,14 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t    op_costs[i].cost[class] = -1;\n \t\t  else\n \t\t    {\n-\t\t      for (nr = 0; nr < (unsigned) HARD_REGNO_NREGS (regno, mode); nr++)\n+\t\t      for (nr = 0; nr < (unsigned) hard_regno_nregs[regno][mode]; nr++)\n \t\t\t{\n \t\t\t  if (! TEST_HARD_REG_BIT (reg_class_contents[class],\n \t\t\t\t\t\t   regno + nr))\n \t\t\t    break;\n \t\t\t}\n \n-\t\t      if (nr == (unsigned) HARD_REGNO_NREGS (regno,mode))\n+\t\t      if (nr == (unsigned) hard_regno_nregs[regno][mode])\n \t\t\top_costs[i].cost[class] = -1;\n \t\t    }\n \t\t}"}, {"sha": "196b86d1e8b545d2610acd89e3758efe926255f7", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -246,7 +246,7 @@ mark_flags_life_zones (rtx flags)\n   flags_nregs = 1;\n #else\n   flags_regno = REGNO (flags);\n-  flags_nregs = HARD_REGNO_NREGS (flags_regno, GET_MODE (flags));\n+  flags_nregs = hard_regno_nregs[flags_regno][GET_MODE (flags)];\n #endif\n   flags_set_1_rtx = flags;\n "}, {"sha": "914bfbc9cb6eb152d169bb6872a1370d6407481a", "filename": "gcc/regrename.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -104,7 +104,7 @@ note_sets (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n   if (GET_CODE (x) != REG)\n     return;\n   regno = REGNO (x);\n-  nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+  nregs = hard_regno_nregs[regno][GET_MODE (x)];\n \n   /* There must not be pseudos at this point.  */\n   if (regno + nregs > FIRST_PSEUDO_REGISTER)\n@@ -126,7 +126,7 @@ clear_dead_regs (HARD_REG_SET *pset, enum machine_mode kind, rtx notes)\n       {\n \trtx reg = XEXP (note, 0);\n \tunsigned int regno = REGNO (reg);\n-\tint nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\tint nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n \n \t/* There must not be pseudos at this point.  */\n \tif (regno + nregs > FIRST_PSEUDO_REGISTER)\n@@ -218,11 +218,11 @@ regrename_optimize (void)\n \t{\n \t  int i;\n \n-\t  for (i = HARD_REGNO_NREGS (FRAME_POINTER_REGNUM, Pmode); i--;)\n+\t  for (i = hard_regno_nregs[FRAME_POINTER_REGNUM][Pmode]; i--;)\n \t    SET_HARD_REG_BIT (unavailable, FRAME_POINTER_REGNUM + i);\n \n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t  for (i = HARD_REGNO_NREGS (HARD_FRAME_POINTER_REGNUM, Pmode); i--;)\n+\t  for (i = hard_regno_nregs[HARD_FRAME_POINTER_REGNUM][Pmode]; i--;)\n \t    SET_HARD_REG_BIT (unavailable, HARD_FRAME_POINTER_REGNUM + i);\n #endif\n \t}\n@@ -287,7 +287,7 @@ regrename_optimize (void)\n \t     have a closer look at each register still in there.  */\n \t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n \t    {\n-\t      int nregs = HARD_REGNO_NREGS (new_reg, GET_MODE (*this->loc));\n+\t      int nregs = hard_regno_nregs[new_reg][GET_MODE (*this->loc)];\n \n \t      for (i = nregs - 1; i >= 0; --i)\n \t        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n@@ -391,7 +391,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n   rtx x = *loc;\n   enum machine_mode mode = GET_MODE (x);\n   int this_regno = REGNO (x);\n-  int this_nregs = HARD_REGNO_NREGS (this_regno, mode);\n+  int this_nregs = hard_regno_nregs[this_regno][mode];\n \n   if (action == mark_write)\n     {\n@@ -431,7 +431,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n       else\n \t{\n \t  int regno = REGNO (*this->loc);\n-\t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (*this->loc));\n+\t  int nregs = hard_regno_nregs[regno][GET_MODE (*this->loc)];\n \t  int exact_match = (regno == this_regno && nregs == this_nregs);\n \n \t  if (regno + nregs <= this_regno\n@@ -973,7 +973,7 @@ dump_def_use_chain (struct du_chain *chains)\n     {\n       struct du_chain *this = chains;\n       int r = REGNO (*this->loc);\n-      int nregs = HARD_REGNO_NREGS (r, GET_MODE (*this->loc));\n+      int nregs = hard_regno_nregs[r][GET_MODE (*this->loc)];\n       fprintf (rtl_dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n       while (this)\n \t{\n@@ -1084,7 +1084,7 @@ kill_value (rtx x, struct value_data *vd)\n   if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n-      unsigned int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      unsigned int n = hard_regno_nregs[regno][GET_MODE (x)];\n       unsigned int i, j;\n \n       /* Kill the value we're told to kill.  */\n@@ -1100,7 +1100,7 @@ kill_value (rtx x, struct value_data *vd)\n \t{\n \t  if (vd->e[j].mode == VOIDmode)\n \t    continue;\n-\t  n = HARD_REGNO_NREGS (j, vd->e[j].mode);\n+\t  n = hard_regno_nregs[j][vd->e[j].mode];\n \t  if (j + n > regno)\n \t    for (i = 0; i < n; ++i)\n \t      kill_value_regno (j + i, vd);\n@@ -1118,7 +1118,7 @@ set_value_regno (unsigned int regno, enum machine_mode mode,\n \n   vd->e[regno].mode = mode;\n \n-  nregs = HARD_REGNO_NREGS (regno, mode);\n+  nregs = hard_regno_nregs[regno][mode];\n   if (nregs > vd->max_value_regs)\n     vd->max_value_regs = nregs;\n }\n@@ -1210,8 +1210,8 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n     return;\n \n   /* If SRC and DEST overlap, don't record anything.  */\n-  dn = HARD_REGNO_NREGS (dr, GET_MODE (dest));\n-  sn = HARD_REGNO_NREGS (sr, GET_MODE (dest));\n+  dn = hard_regno_nregs[dr][GET_MODE (dest)];\n+  sn = hard_regno_nregs[sr][GET_MODE (dest)];\n   if ((dr > sr && dr < sr + sn)\n       || (sr > dr && sr < dr + dn))\n     return;\n@@ -1237,15 +1237,15 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n \n      We can't properly represent the latter case in our tables, so don't\n      record anything then.  */\n-  else if (sn < (unsigned int) HARD_REGNO_NREGS (sr, vd->e[sr].mode)\n+  else if (sn < (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode]\n \t   && (GET_MODE_SIZE (vd->e[sr].mode) > UNITS_PER_WORD\n \t       ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n     return;\n \n   /* If SRC had been assigned a mode narrower than the copy, we can't\n      link DEST into the chain, because not all of the pieces of the\n      copy came from oldest_regno.  */\n-  else if (sn > (unsigned int) HARD_REGNO_NREGS (sr, vd->e[sr].mode))\n+  else if (sn > (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode])\n     return;\n \n   /* Link DR at the end of the value chain used by SR.  */\n@@ -1291,8 +1291,8 @@ maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,\n     return gen_rtx_raw_REG (new_mode, regno);\n   else if (mode_change_ok (orig_mode, new_mode, regno))\n     {\n-      int copy_nregs = HARD_REGNO_NREGS (copy_regno, copy_mode);\n-      int use_nregs = HARD_REGNO_NREGS (copy_regno, new_mode);\n+      int copy_nregs = hard_regno_nregs[copy_regno][copy_mode];\n+      int use_nregs = hard_regno_nregs[copy_regno][new_mode];\n       int copy_offset\n \t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n       int offset\n@@ -1330,8 +1330,8 @@ find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n      Replacing r9 with r11 is invalid.  */\n   if (mode != vd->e[regno].mode)\n     {\n-      if (HARD_REGNO_NREGS (regno, mode)\n-\t  > HARD_REGNO_NREGS (regno, vd->e[regno].mode))\n+      if (hard_regno_nregs[regno][mode]\n+\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n \treturn NULL_RTX;\n     }\n \n@@ -1341,7 +1341,7 @@ find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n       rtx new;\n       unsigned int last;\n \n-      for (last = i; last < i + HARD_REGNO_NREGS (i, mode); last++)\n+      for (last = i; last < i + hard_regno_nregs[i][mode]; last++)\n \tif (!TEST_HARD_REG_BIT (reg_class_contents[class], last))\n \t  return NULL_RTX;\n \n@@ -1600,8 +1600,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t     set it in, make sure that the replacement is valid.  */\n \t  if (mode != vd->e[regno].mode)\n \t    {\n-\t      if (HARD_REGNO_NREGS (regno, mode)\n-\t\t  > HARD_REGNO_NREGS (regno, vd->e[regno].mode))\n+\t      if (hard_regno_nregs[regno][mode]\n+\t\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n \t\tgoto no_move_special_case;\n \t    }\n "}, {"sha": "27592be0c47aca99743a745f9433444e8d61a73d", "filename": "gcc/regs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -224,3 +224,6 @@ extern int caller_save_needed;\n \n /* Allocate reg_n_info tables */\n extern void allocate_reg_info (size_t, int, int);\n+\n+/* Specify number of hard registers given machine mode occupy.  */\n+extern unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];"}, {"sha": "92c3c47a2b8eda49490dbfbbfc662e6538a61f0a", "filename": "gcc/reload.c", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -818,7 +818,7 @@ reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, int output)\n \t  && output\n \t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n \t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n-\t      != (int) HARD_REGNO_NREGS (REGNO (inner), GET_MODE (inner))));\n+\t      != (int) hard_regno_nregs[REGNO (inner)][GET_MODE (inner)]));\n }\n \n /* Return nonzero if IN can be reloaded into REGNO with mode MODE without\n@@ -1038,8 +1038,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       > UNITS_PER_WORD)\n \t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t/ UNITS_PER_WORD)\n-\t\t       != (int) HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t\t  GET_MODE (SUBREG_REG (in)))))\n+\t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (in))]\n+\t\t\t\t\t\t[GET_MODE (SUBREG_REG (in))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (in), inmode)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t  || (SECONDARY_INPUT_RELOAD_CLASS (class, inmode, in) != NO_REGS\n@@ -1135,8 +1135,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       > UNITS_PER_WORD)\n \t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n \t\t\t/ UNITS_PER_WORD)\n-\t\t       != (int) HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n-\t\t\t\t\t\t  GET_MODE (SUBREG_REG (out)))))\n+\t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (out))]\n+\t\t\t\t\t\t[GET_MODE (SUBREG_REG (out))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (out), outmode)))\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  || (SECONDARY_OUTPUT_RELOAD_CLASS (class, outmode, out) != NO_REGS\n@@ -1262,7 +1262,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \tif (HARD_REGNO_MODE_OK (i, mode)\n \t    && TEST_HARD_REG_BIT (reg_class_contents[(int) class], i))\n \t  {\n-\t    int nregs = HARD_REGNO_NREGS (i, mode);\n+\t    int nregs = hard_regno_nregs[i][mode];\n \n \t    int j;\n \t    for (j = 1; j < nregs; j++)\n@@ -1520,17 +1520,17 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       (regno\n-\t\t\t\t\t\t+ HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t\t\t    rel_mode)),\n+\t\t\t\t\t\t+ hard_regno_nregs[regno]\n+\t\t\t\t\t\t\t\t  [rel_mode]),\n \t\t\t\t\t       PATTERN (this_insn), inloc)\n \t    /* If this is also an output reload, IN cannot be used as\n \t       the reload register if it is set in this insn unless IN\n \t       is also OUT.  */\n \t    && (out == 0 || in == out\n \t\t|| ! hard_reg_set_here_p (regno,\n \t\t\t\t\t  (regno\n-\t\t\t\t\t   + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t\t       rel_mode)),\n+\t\t\t\t\t   + hard_regno_nregs[regno]\n+\t\t\t\t\t\t\t     [rel_mode]),\n \t\t\t\t\t  PATTERN (this_insn)))\n \t    /* ??? Why is this code so different from the previous?\n \t       Is there any simple coherent way to describe the two together?\n@@ -1548,8 +1548,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && HARD_REGNO_MODE_OK (regno, outmode))\n \t  {\n \t    unsigned int offs;\n-\t    unsigned int nregs = MAX (HARD_REGNO_NREGS (regno, inmode),\n-\t\t\t\t      HARD_REGNO_NREGS (regno, outmode));\n+\t    unsigned int nregs = MAX (hard_regno_nregs[regno][inmode],\n+\t\t\t\t      hard_regno_nregs[regno][outmode]);\n \n \t    for (offs = 0; offs < nregs; offs++)\n \t      if (fixed_regs[regno + offs]\n@@ -1559,7 +1559,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n \t    if (offs == nregs\n \t\t&& (! (refers_to_regno_for_reload_p\n-\t\t       (regno, (regno + HARD_REGNO_NREGS (regno, inmode)),\n+\t\t       (regno, (regno + hard_regno_nregs[regno][inmode]),\n \t\t\t\tin, (rtx *)0))\n \t\t    || can_reload_into (in, regno, inmode)))\n \t      {\n@@ -1830,8 +1830,8 @@ combine_reloads (void)\n \t&& HARD_REGNO_MODE_OK (REGNO (XEXP (note, 0)), rld[output_reload].outmode)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].class],\n \t\t\t      REGNO (XEXP (note, 0)))\n-\t&& (HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), rld[output_reload].outmode)\n-\t    <= HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), GET_MODE (XEXP (note, 0))))\n+\t&& (hard_regno_nregs[REGNO (XEXP (note, 0))][rld[output_reload].outmode]\n+\t    <= hard_regno_nregs[REGNO (XEXP (note, 0))][GET_MODE (XEXP (note, 0))])\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n \t&& ((secondary_out = rld[output_reload].secondary_out_reload) == -1\n@@ -1923,7 +1923,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n       && REGNO (out) < FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int regno = REGNO (out) + out_offset;\n-      unsigned int nwords = HARD_REGNO_NREGS (regno, outmode);\n+      unsigned int nwords = hard_regno_nregs[regno][outmode];\n       rtx saved_rtx;\n \n       /* When we consider whether the insn uses OUT,\n@@ -1984,7 +1984,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t\t      ? GET_MODE (out) : outmode)))\n     {\n       unsigned int regno = REGNO (in) + in_offset;\n-      unsigned int nwords = HARD_REGNO_NREGS (regno, inmode);\n+      unsigned int nwords = hard_regno_nregs[regno][inmode];\n \n       if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*) 0)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n@@ -2056,7 +2056,7 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n \n \t  /* See if this reg overlaps range under consideration.  */\n \t  if (r < end_regno\n-\t      && r + HARD_REGNO_NREGS (r, GET_MODE (op0)) > beg_regno)\n+\t      && r + hard_regno_nregs[r][GET_MODE (op0)] > beg_regno)\n \t    return 1;\n \t}\n     }\n@@ -2148,10 +2148,10 @@ operands_match_p (rtx x, rtx y)\n \t (reg:SI 1) will be considered the same register.  */\n       if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n \t  && i < FIRST_PSEUDO_REGISTER)\n-\ti += HARD_REGNO_NREGS (i, GET_MODE (x)) - 1;\n+\ti += hard_regno_nregs[i][GET_MODE (x)] - 1;\n       if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (y)) > UNITS_PER_WORD\n \t  && j < FIRST_PSEUDO_REGISTER)\n-\tj += HARD_REGNO_NREGS (j, GET_MODE (y)) - 1;\n+\tj += hard_regno_nregs[j][GET_MODE (y)] - 1;\n \n       return i == j;\n     }\n@@ -2363,7 +2363,7 @@ decompose (rtx x)\n \t}\n       else\n \t/* A hard reg.  */\n-\tval.end = val.start + HARD_REGNO_NREGS (val.start, GET_MODE (x));\n+\tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n     }\n   else if (GET_CODE (x) == SUBREG)\n     {\n@@ -2376,7 +2376,7 @@ decompose (rtx x)\n \treturn decompose (SUBREG_REG (x));\n       else\n \t/* A hard reg.  */\n-\tval.end = val.start + HARD_REGNO_NREGS (val.start, GET_MODE (x));\n+\tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n     }\n   else if (CONSTANT_P (x)\n \t   /* This hasn't been assigned yet, so it can't conflict yet.  */\n@@ -4366,7 +4366,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].class], regno)\n \t    && HARD_REGNO_MODE_OK (regno, rld[i].mode))\n \t  {\n-\t    int nr = HARD_REGNO_NREGS (regno, rld[i].mode);\n+\t    int nr = hard_regno_nregs[regno][rld[i].mode];\n \t    int ok = 1, nri;\n \n \t    for (nri = 1; nri < nr; nri ++)\n@@ -6177,7 +6177,7 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \n       return (endregno > r\n \t      && regno < r + (r < FIRST_PSEUDO_REGISTER\n-\t\t\t      ? HARD_REGNO_NREGS (r, GET_MODE (x))\n+\t\t\t      ? hard_regno_nregs[r][GET_MODE (x)]\n \t\t\t      : 1));\n \n     case SUBREG:\n@@ -6189,7 +6189,7 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t\t     ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n \n \t  return endregno > inner_regno && regno < inner_endregno;\n \t}\n@@ -6328,7 +6328,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n     abort ();\n \n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t      ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n \n   return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n }\n@@ -6539,7 +6539,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t{\n \t\t  int i;\n \n-\t\t  for (i = HARD_REGNO_NREGS (valueno, mode) - 1; i >= 0; i--)\n+\t\t  for (i = hard_regno_nregs[valueno][mode] - 1; i >= 0; i--)\n \t\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n \t\t\t\t\t     valueno + i))\n \t\t      break;\n@@ -6581,19 +6581,22 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n   if (goal_mem && value == SET_DEST (single_set (where))\n       && refers_to_regno_for_reload_p (valueno,\n \t\t\t\t       (valueno\n-\t\t\t\t\t+ HARD_REGNO_NREGS (valueno, mode)),\n+\t\t\t\t\t+ hard_regno_nregs[valueno][mode]),\n \t\t\t\t       goal, (rtx*) 0))\n     return 0;\n \n   /* Reject registers that overlap GOAL.  */\n \n   if (!goal_mem && !goal_const\n-      && regno + (int) HARD_REGNO_NREGS (regno, mode) > valueno\n-      && regno < valueno + (int) HARD_REGNO_NREGS (valueno, mode))\n+      && regno + (int) hard_regno_nregs[regno][mode] > valueno\n+      && regno < valueno + (int) hard_regno_nregs[valueno][mode])\n     return 0;\n \n-  nregs = HARD_REGNO_NREGS (regno, mode);\n-  valuenregs = HARD_REGNO_NREGS (valueno, mode);\n+  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n+    nregs = hard_regno_nregs[regno][mode];\n+  else\n+    nregs = 1;\n+  valuenregs = hard_regno_nregs[valueno][mode];\n \n   /* Reject VALUE if it is one of the regs reserved for reloads.\n      Reload1 knows how to reuse them anyway, and it would get\n@@ -6619,8 +6622,8 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \tif (rld[i].reg_rtx != 0 && rld[i].in)\n \t  {\n \t    int regno1 = REGNO (rld[i].reg_rtx);\n-\t    int nregs1 = HARD_REGNO_NREGS (regno1,\n-\t\t\t\t\t   GET_MODE (rld[i].reg_rtx));\n+\t    int nregs1 = hard_regno_nregs[regno1]\n+\t\t\t\t\t [GET_MODE (rld[i].reg_rtx)];\n \t    if (regno1 < valueno + valuenregs\n \t\t&& regno1 + nregs1 > valueno)\n \t      return 0;\n@@ -6694,7 +6697,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t  int xregno = REGNO (dest);\n \t\t  int xnregs;\n \t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-\t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n+\t\t    xnregs = hard_regno_nregs[xregno][GET_MODE (dest)];\n \t\t  else\n \t\t    xnregs = 1;\n \t\t  if (xregno < regno + nregs && xregno + xnregs > regno)\n@@ -6738,7 +6741,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs;\n \t\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-\t\t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n+\t\t\t    xnregs = hard_regno_nregs[xregno][GET_MODE (dest)];\n \t\t\t  else\n \t\t\t    xnregs = 1;\n \t\t\t  if (xregno < regno + nregs\n@@ -6783,7 +6786,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t\t{\n \t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs\n-\t\t\t    = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n+\t\t\t    = hard_regno_nregs[xregno][GET_MODE (dest)];\n \n \t\t\t  if (xregno < regno + nregs\n \t\t\t      && xregno + xnregs > regno)\n@@ -6898,7 +6901,7 @@ int\n regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,\n \t\t   int sets)\n {\n-  unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n+  unsigned int nregs = hard_regno_nregs[regno][mode];\n   unsigned int endregno = regno + nregs;\n \n   if ((GET_CODE (PATTERN (insn)) == CLOBBER\n@@ -6944,8 +6947,8 @@ reload_adjust_reg_for_mode (rtx reloadreg, enum machine_mode mode)\n   regno = REGNO (reloadreg);\n \n   if (WORDS_BIG_ENDIAN)\n-    regno += HARD_REGNO_NREGS (regno, GET_MODE (reloadreg))\n-      - HARD_REGNO_NREGS (regno, mode);\n+    regno += (int) hard_regno_nregs[regno][GET_MODE (reloadreg)]\n+      - (int) hard_regno_nregs[regno][mode];\n \n   return gen_rtx_REG (mode, regno);\n }"}, {"sha": "5cce770ca12a03aa5643c8854dff0c051afcd5ef", "filename": "gcc/reload1.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -534,7 +534,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n \t }\n        else\n \t {\n-\t   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno));\n+\t   nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n \t   while (nregs-- > 0)\n \t     SET_HARD_REG_BIT (*to, r + nregs);\n \t }\n@@ -1572,7 +1572,7 @@ count_pseudo (int reg)\n \n   spill_add_cost[r] += freq;\n \n-  nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n+  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (reg)];\n   while (nregs-- > 0)\n     spill_cost[r + nregs] += freq;\n }\n@@ -1634,7 +1634,7 @@ static void\n count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n {\n   int r = reg_renumber[reg];\n-  int nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n+  int nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (reg)];\n \n   if (REGNO_REG_SET_P (&spilled_pseudos, reg)\n       || spilled + spilled_nregs <= r || r + nregs <= spilled)\n@@ -1685,7 +1685,7 @@ find_reg (struct insn_chain *chain, int order)\n \t{\n \t  int this_cost = spill_cost[regno];\n \t  int ok = 1;\n-\t  unsigned int this_nregs = HARD_REGNO_NREGS (regno, rl->mode);\n+\t  unsigned int this_nregs = hard_regno_nregs[regno][rl->mode];\n \n \t  for (j = 1; j < this_nregs; j++)\n \t    {\n@@ -1724,7 +1724,7 @@ find_reg (struct insn_chain *chain, int order)\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n \n-  rl->nregs = HARD_REGNO_NREGS (best_reg, rl->mode);\n+  rl->nregs = hard_regno_nregs[best_reg][rl->mode];\n   rl->regno = best_reg;\n \n   EXECUTE_IF_SET_IN_REG_SET\n@@ -1772,7 +1772,7 @@ find_reload_regs (struct insn_chain *chain)\n \t  int regno = REGNO (chain->rld[i].reg_rtx);\n \t  chain->rld[i].regno = regno;\n \t  chain->rld[i].nregs\n-\t    = HARD_REGNO_NREGS (regno, GET_MODE (chain->rld[i].reg_rtx));\n+\t    = hard_regno_nregs[regno][GET_MODE (chain->rld[i].reg_rtx)];\n \t}\n       else\n \tchain->rld[i].regno = -1;\n@@ -2062,7 +2062,7 @@ mark_home_live (int regno)\n   i = reg_renumber[regno];\n   if (i < 0)\n     return;\n-  lim = i + HARD_REGNO_NREGS (i, PSEUDO_REGNO_MODE (regno));\n+  lim = i + hard_regno_nregs[i][PSEUDO_REGNO_MODE (regno)];\n   while (i < lim)\n     regs_ever_live[i++] = 1;\n }\n@@ -3516,8 +3516,8 @@ spill_hard_reg (unsigned int regno, int cant_eliminate)\n     if (reg_renumber[i] >= 0\n \t&& (unsigned int) reg_renumber[i] <= regno\n \t&& ((unsigned int) reg_renumber[i]\n-\t    + HARD_REGNO_NREGS ((unsigned int) reg_renumber[i],\n-\t\t\t\tPSEUDO_REGNO_MODE (i))\n+\t    + hard_regno_nregs[(unsigned int) reg_renumber[i]]\n+\t\t\t      [PSEUDO_REGNO_MODE (i)]\n \t    > regno))\n       SET_REGNO_REG_SET (&spilled_pseudos, i);\n }\n@@ -4059,7 +4059,7 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n     {\n       unsigned int i;\n \n-      nr = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      nr = hard_regno_nregs[regno][GET_MODE (x)];\n       /* Storing into a spilled-reg invalidates its contents.\n \t This can happen if a block-local pseudo is allocated to that reg\n \t and it wasn't spilled because this block's total need is 0.\n@@ -4133,7 +4133,7 @@ static void\n mark_reload_reg_in_use (unsigned int regno, int opnum, enum reload_type type,\n \t\t\tenum machine_mode mode)\n {\n-  unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n+  unsigned int nregs = hard_regno_nregs[regno][mode];\n   unsigned int i;\n \n   for (i = regno; i < nregs + regno; i++)\n@@ -4195,7 +4195,7 @@ static void\n clear_reload_reg_in_use (unsigned int regno, int opnum,\n \t\t\t enum reload_type type, enum machine_mode mode)\n {\n-  unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n+  unsigned int nregs = hard_regno_nregs[regno][mode];\n   unsigned int start_regno, end_regno, r;\n   int i;\n   /* A complication is that for some reload types, inheritance might\n@@ -4279,7 +4279,7 @@ clear_reload_reg_in_use (unsigned int regno, int opnum,\n \t      unsigned int conflict_start = true_regnum (rld[i].reg_rtx);\n \t      unsigned int conflict_end\n \t\t= (conflict_start\n-\t\t   + HARD_REGNO_NREGS (conflict_start, rld[i].mode));\n+\t\t   + hard_regno_nregs[conflict_start][rld[i].mode]);\n \n \t      /* If there is an overlap with the first to-be-freed register,\n \t\t adjust the interval start.  */\n@@ -4774,7 +4774,7 @@ reload_reg_free_for_value_p (int start_regno, int regno, int opnum,\n       rtx reg = rld[i].reg_rtx;\n       if (reg && GET_CODE (reg) == REG\n \t  && ((unsigned) regno - true_regnum (reg)\n-\t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned) 1)\n+\t      <= hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] - (unsigned) 1)\n \t  && i != reloadnum)\n \t{\n \t  rtx other_input = rld[i].in;\n@@ -4930,7 +4930,7 @@ free_for_value_p (int regno, enum machine_mode mode, int opnum,\n \t\t  enum reload_type type, rtx value, rtx out, int reloadnum,\n \t\t  int ignore_address_reloads)\n {\n-  int nregs = HARD_REGNO_NREGS (regno, mode);\n+  int nregs = hard_regno_nregs[regno][mode];\n   while (nregs-- > 0)\n     if (! reload_reg_free_for_value_p (regno, regno + nregs, opnum, type,\n \t\t\t\t       value, out, reloadnum,\n@@ -5103,7 +5103,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t      && ! TEST_HARD_REG_BIT (reload_reg_used_for_inherit,\n \t\t\t\t\t      regnum))))\n \t    {\n-\t      int nr = HARD_REGNO_NREGS (regnum, rld[r].mode);\n+\t      int nr = hard_regno_nregs[regnum][rld[r].mode];\n \t      /* Avoid the problem where spilling a GENERAL_OR_FP_REG\n \t\t (on 68000) got us two FP regs.  If NR is 1,\n \t\t we would reject both of them.  */\n@@ -5436,7 +5436,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n-\t\t      int nr = HARD_REGNO_NREGS (i, rld[r].mode);\n+\t\t      int nr = hard_regno_nregs[i][rld[r].mode];\n \t\t      int k;\n \n \t\t      for (k = 1; k < nr; k++)\n@@ -5669,7 +5669,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  && (regno != HARD_FRAME_POINTER_REGNUM\n \t\t      || !frame_pointer_needed))\n \t\t{\n-\t\t  int nr = HARD_REGNO_NREGS (regno, rld[r].mode);\n+\t\t  int nr = hard_regno_nregs[regno][rld[r].mode];\n \t\t  int k;\n \t\t  rld[r].reg_rtx = equiv;\n \t\t  reload_inherited[r] = 1;\n@@ -5884,14 +5884,14 @@ choose_reload_regs (struct insn_chain *chain)\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n-\t    nr = HARD_REGNO_NREGS (nregno, rld[r].mode);\n+\t    nr = hard_regno_nregs[nregno][rld[r].mode];\n \n \t  while (--nr >= 0)\n \t    reg_has_output_reload[nregno + nr] = 1;\n \n \t  if (i >= 0)\n \t    {\n-\t      nr = HARD_REGNO_NREGS (i, rld[r].mode);\n+\t      nr = hard_regno_nregs[i][rld[r].mode];\n \t      while (--nr >= 0)\n \t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n \t    }\n@@ -7032,7 +7032,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n       if (i >= 0 && rld[r].reg_rtx != 0)\n \t{\n-\t  int nr = HARD_REGNO_NREGS (i, GET_MODE (rld[r].reg_rtx));\n+\t  int nr = hard_regno_nregs[i][GET_MODE (rld[r].reg_rtx)];\n \t  int k;\n \t  int part_reaches_end = 0;\n \t  int all_reaches_end = 1;\n@@ -7076,8 +7076,8 @@ emit_reload_insns (struct insn_chain *chain)\n /* AUTO_INC */\t\t     : XEXP (rld[r].in_reg, 0));\n \t\t  int nregno = REGNO (out);\n \t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t     : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t\t GET_MODE (rld[r].reg_rtx)));\n+\t\t\t     : hard_regno_nregs[nregno]\n+\t\t\t\t\t       [GET_MODE (rld[r].reg_rtx)]);\n \n \t\t  spill_reg_store[i] = new_spill_reg_store[i];\n \t\t  spill_reg_stored_to[i] = out;\n@@ -7137,8 +7137,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  nregno = REGNO (in);\n \n \t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t     GET_MODE (rld[r].reg_rtx)));\n+\t\t\t : hard_regno_nregs[nregno]\n+\t\t\t\t\t   [GET_MODE (rld[r].reg_rtx)]);\n \n \t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n \n@@ -7238,7 +7238,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  int src_regno = REGNO (src_reg);\n-\t\t  int nr = HARD_REGNO_NREGS (src_regno, rld[r].mode);\n+\t\t  int nr = hard_regno_nregs[src_regno][rld[r].mode];\n \t\t  /* The place where to find a death note varies with\n \t\t     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not\n \t\t     necessarily checked exactly in the code that moves\n@@ -7269,7 +7269,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t    }\n \t  else\n \t    {\n-\t      int num_regs = HARD_REGNO_NREGS (nregno, GET_MODE (rld[r].out));\n+\t      int num_regs = hard_regno_nregs[nregno][GET_MODE (rld[r].out)];\n \n \t      while (num_regs-- > 0)\n \t\treg_last_reload_reg[nregno + num_regs] = 0;\n@@ -7594,7 +7594,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n     }\n \n   /* We will be deleting the insn.  Remove the spill reg information.  */\n-  for (k = HARD_REGNO_NREGS (last_reload_reg, GET_MODE (reg)); k-- > 0; )\n+  for (k = hard_regno_nregs[last_reload_reg][GET_MODE (reg)]; k-- > 0; )\n     {\n       spill_reg_store[last_reload_reg + k] = 0;\n       spill_reg_stored_to[last_reload_reg + k] = 0;"}, {"sha": "0eb52b20cb45cf59ca7ea614208e928a9b6cae4a", "filename": "gcc/resource.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -104,7 +104,7 @@ update_live_status (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n   else\n     first_regno = REGNO (dest);\n \n-  last_regno = first_regno + HARD_REGNO_NREGS (first_regno, GET_MODE (dest));\n+  last_regno = first_regno + hard_regno_nregs[first_regno][GET_MODE (dest)];\n \n   if (GET_CODE (x) == CLOBBER)\n     for (i = first_regno; i < last_regno; i++)\n@@ -233,7 +233,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t{\n \t  unsigned int regno = subreg_regno (x);\n \t  unsigned int last_regno\n-\t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n \t  if (last_regno > FIRST_PSEUDO_REGISTER)\n \t    abort ();\n@@ -246,7 +246,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t{\n \t  unsigned int regno = REGNO (x);\n \t  unsigned int last_regno\n-\t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n \t  if (last_regno > FIRST_PSEUDO_REGISTER)\n \t    abort ();\n@@ -771,7 +771,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t    {\n \t      unsigned int regno = subreg_regno (x);\n \t      unsigned int last_regno\n-\t\t= regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n \t      if (last_regno > FIRST_PSEUDO_REGISTER)\n \t\tabort ();\n@@ -786,7 +786,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t{\n \t  unsigned int regno = REGNO (x);\n \t  unsigned int last_regno\n-\t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n \t  if (last_regno > FIRST_PSEUDO_REGISTER)\n \t    abort ();\n@@ -970,8 +970,8 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t     {\n \t       regno = reg_renumber[i];\n \t       for (j = regno;\n-\t\t    j < regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t  PSEUDO_REGNO_MODE (i));\n+\t\t    j < regno + hard_regno_nregs[regno]\n+\t\t\t\t\t\t[PSEUDO_REGNO_MODE (i)];\n \t\t    j++)\n \t\t SET_HARD_REG_BIT (current_live_regs, j);\n \t     }\n@@ -1044,8 +1044,8 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n \t\t    unsigned int last_regno\n \t\t      = (first_regno\n-\t\t\t + HARD_REGNO_NREGS (first_regno,\n-\t\t\t\t\t     GET_MODE (XEXP (link, 0))));\n+\t\t\t + hard_regno_nregs[first_regno]\n+\t\t\t\t\t   [GET_MODE (XEXP (link, 0))]);\n \n \t\t    for (i = first_regno; i < last_regno; i++)\n \t\t      SET_HARD_REG_BIT (pending_dead_regs, i);\n@@ -1063,8 +1063,8 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n \t\t    unsigned int last_regno\n \t\t      = (first_regno\n-\t\t\t + HARD_REGNO_NREGS (first_regno,\n-\t\t\t\t\t     GET_MODE (XEXP (link, 0))));\n+\t\t\t + hard_regno_nregs[first_regno]\n+\t\t\t\t\t   [GET_MODE (XEXP (link, 0))]);\n \n \t\t    for (i = first_regno; i < last_regno; i++)\n \t\t      CLEAR_HARD_REG_BIT (current_live_regs, i);"}, {"sha": "856af2f3a78176a7d61883dfbfecb2078cb1cdf5", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -33,6 +33,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"real.h\"\n+#include \"regs.h\"\n \n /* Forward declarations */\n static int global_reg_mentioned_p_1 (rtx *, void *);\n@@ -1437,7 +1438,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n \n       return (endregno > x_regno\n \t      && regno < x_regno + (x_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t\t    ? HARD_REGNO_NREGS (x_regno, GET_MODE (x))\n+\t\t\t\t    ? hard_regno_nregs[x_regno][GET_MODE (x)]\n \t\t\t      : 1));\n \n     case SUBREG:\n@@ -1449,7 +1450,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n \t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t\t     ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n \n \t  return endregno > inner_regno && regno < inner_endregno;\n \t}\n@@ -1541,7 +1542,7 @@ reg_overlap_mentioned_p (rtx x, rtx in)\n       regno = REGNO (x);\n     do_reg:\n       endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t  ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\t\t\t  ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n       return refers_to_regno_p (regno, endregno, in, (rtx*) 0);\n \n     case MEM:\n@@ -1794,7 +1795,7 @@ dead_or_set_p (rtx insn, rtx x)\n \n   regno = REGNO (x);\n   last_regno = (regno >= FIRST_PSEUDO_REGISTER ? regno\n-\t\t: regno + HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1);\n+\t\t: regno + hard_regno_nregs[regno][GET_MODE (x)] - 1);\n \n   for (i = regno; i <= last_regno; i++)\n     if (! dead_or_set_regno_p (insn, i))\n@@ -1844,7 +1845,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n \n       regno = REGNO (dest);\n       endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t\t  : regno + HARD_REGNO_NREGS (regno, GET_MODE (dest)));\n+\t\t  : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n \n       return (test_regno >= regno && test_regno < endregno);\n     }\n@@ -1875,7 +1876,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n \n \t      regno = REGNO (dest);\n \t      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t\t\t  : regno + HARD_REGNO_NREGS (regno, GET_MODE (dest)));\n+\t\t\t  : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n \n \t      if (test_regno >= regno && test_regno < endregno)\n \t\treturn 1;\n@@ -1927,8 +1928,8 @@ find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n \t&& REGNO (XEXP (link, 0)) <= regno\n \t&& ((REGNO (XEXP (link, 0))\n \t     + (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t: HARD_REGNO_NREGS (REGNO (XEXP (link, 0)),\n-\t\t\t\t    GET_MODE (XEXP (link, 0)))))\n+\t\t: hard_regno_nregs[REGNO (XEXP (link, 0))]\n+\t\t\t\t  [GET_MODE (XEXP (link, 0))]))\n \t    > regno))\n       return link;\n   return 0;\n@@ -1990,7 +1991,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n \t  unsigned int end_regno\n-\t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (datum));\n+\t    = regno + hard_regno_nregs[regno][GET_MODE (datum)];\n \t  unsigned int i;\n \n \t  for (i = regno; i < end_regno; i++)\n@@ -2025,7 +2026,7 @@ find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n       if (GET_CODE (op = XEXP (link, 0)) == code\n \t  && GET_CODE (reg = XEXP (op, 0)) == REG\n \t  && (regnote = REGNO (reg)) <= regno\n-\t  && regnote + HARD_REGNO_NREGS (regnote, GET_MODE (reg)) > regno)\n+\t  && regnote + hard_regno_nregs[regnote][GET_MODE (reg)] > regno)\n \treturn 1;\n     }\n \n@@ -3257,8 +3258,8 @@ subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n   if (xregno >= FIRST_PSEUDO_REGISTER)\n     abort ();\n \n-  nregs_xmode = HARD_REGNO_NREGS (xregno, xmode);\n-  nregs_ymode = HARD_REGNO_NREGS (xregno, ymode);\n+  nregs_xmode = hard_regno_nregs[xregno][xmode];\n+  nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n   /* If this is a big endian paradoxical subreg, which uses more actual\n      hard registers than the original register, we must return a negative\n@@ -3300,8 +3301,8 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n   if (xregno >= FIRST_PSEUDO_REGISTER)\n     abort ();\n \n-  nregs_xmode = HARD_REGNO_NREGS (xregno, xmode);\n-  nregs_ymode = HARD_REGNO_NREGS (xregno, ymode);\n+  nregs_xmode = hard_regno_nregs[xregno][xmode];\n+  nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n   /* paradoxical subregs are always valid.  */\n   if (offset == 0\n@@ -3513,7 +3514,7 @@ hoist_test_store (rtx x, rtx val, regset live)\n   if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n     {\n       int regno = REGNO (x);\n-      int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      int n = hard_regno_nregs[regno][GET_MODE (x)];\n \n       if (!live)\n \treturn false;"}, {"sha": "0a6738895f8db80861a7392447ec8526e51af716", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -492,7 +492,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n          If so, mark all of them just like the first.  */\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int i = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t  int i = hard_regno_nregs[regno][GET_MODE (dest)];\n \t  if (code == SET)\n \t    {\n \t      while (--i >= 0)\n@@ -639,7 +639,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \tint regno = REGNO (x);\n \tif (regno < FIRST_PSEUDO_REGISTER)\n \t  {\n-\t    int i = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    int i = hard_regno_nregs[regno][GET_MODE (x)];\n \t    while (--i >= 0)\n \t      SET_REGNO_REG_SET (reg_pending_uses, regno + i);\n \t  }"}, {"sha": "95d5f8e03e4886021dd4a18dc60542095d9701d1", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -1323,7 +1323,7 @@ check_live_1 (int src, rtx x)\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n \t  /* Check for hard registers.  */\n-\t  int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t  int j = hard_regno_nregs[regno][GET_MODE (reg)];\n \t  while (--j >= 0)\n \t    {\n \t      for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n@@ -1397,7 +1397,7 @@ update_live_1 (int src, rtx x)\n     {\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t  int j = hard_regno_nregs[regno][GET_MODE (reg)];\n \t  while (--j >= 0)\n \t    {\n \t      for (i = 0; i < candidate_table[src].update_bbs.nr_members; i++)"}, {"sha": "74d76c72f5527c8da193e418a59444f996a3e241", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -58,6 +58,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"predict.h\"\n #include \"optabs.h\"\n #include \"target.h\"\n+#include \"regs.h\"\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -1413,7 +1414,7 @@ decl_conflicts_with_clobbers_p (tree decl, const HARD_REG_SET clobbered_regs)\n \n       for (regno = REGNO (reg);\n \t   regno < (REGNO (reg)\n-\t\t    + HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)));\n+\t\t    + hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]);\n \t   regno++)\n \tif (TEST_HARD_REG_BIT (clobbered_regs, regno))\n \t  {"}, {"sha": "27f2f34b32c6a6907d7109c47b9dd1c2799494b7", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66fd46b6c6483a6fb074f768ee101333860a8de5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=66fd46b6c6483a6fb074f768ee101333860a8de5", "patch": "@@ -795,7 +795,7 @@ make_decl_rtl (tree decl, const char *asmspec)\n #ifdef ASM_DECLARE_REGISTER_GLOBAL\n \t      ASM_DECLARE_REGISTER_GLOBAL (asm_out_file, decl, reg_number, name);\n #endif\n-\t      nregs = HARD_REGNO_NREGS (reg_number, DECL_MODE (decl));\n+\t      nregs = hard_regno_nregs[reg_number][DECL_MODE (decl)];\n \t      while (nregs > 0)\n \t\tglobalize_reg (reg_number + --nregs);\n \t    }"}]}