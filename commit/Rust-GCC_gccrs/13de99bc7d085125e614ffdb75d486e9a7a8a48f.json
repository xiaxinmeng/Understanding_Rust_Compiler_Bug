{"sha": "13de99bc7d085125e614ffdb75d486e9a7a8a48f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNkZTk5YmM3ZDA4NTEyNWU2MTRmZmRiNzVkNDg2ZTlhN2E4YTQ4Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-12-12T08:44:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-12T08:44:27Z"}, "message": "re PR c++/88446 (__builtin_is_constant_evaluated rejects some converted constant expressions.)\n\n\tPR c++/88446\n\t* cp-tree.h (maybe_constant_value): Add manifestly_const_eval\n\targument.\n\t* constexpr.c (struct constexpr_call): Rename pretend_const_required\n\tmember to manifestly_const_eval.\n\t(struct constexpr_ctx): Likewise.\n\t(constexpr_call_hasher::equal): Adjust users.\n\t(cxx_eval_builtin_function_call): Likewise.  Formatting fix.\n\t(cxx_eval_call_expression): Adjust users.\n\t(cxx_eval_outermost_constant_expr, maybe_constant_init_1,\n\tmaybe_constant_init): Rename pretend_const_required argument to\n\tmanifestly_const_eval, adjust function comments.\n\t(maybe_constant_value): Add manifestly_const_eval argument.  If true,\n\tdon't cache and call cxx_eval_outermost_constant_expr with true as\n\tmanifestly_const_eval.\n\t* decl.c (compute_array_index_type_loc): Call maybe_constant_value\n\twith true as manifestly_const_eval.\n\n\t* g++.dg/cpp2a/is-constant-evaluated3.C: New test.\n\nFrom-SVN: r267047", "tree": {"sha": "b608cbd81f75cde8ce4f3264c08646a15e1fb0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b608cbd81f75cde8ce4f3264c08646a15e1fb0ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13de99bc7d085125e614ffdb75d486e9a7a8a48f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13de99bc7d085125e614ffdb75d486e9a7a8a48f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13de99bc7d085125e614ffdb75d486e9a7a8a48f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13de99bc7d085125e614ffdb75d486e9a7a8a48f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66e30545db6ed4c1913e76d1085d0586ee6d055d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e30545db6ed4c1913e76d1085d0586ee6d055d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e30545db6ed4c1913e76d1085d0586ee6d055d"}], "stats": {"total": 98, "additions": 77, "deletions": 21}, "files": [{"sha": "2c1f39288c43bd288009f0e5c9a0b2117bcdc320", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -1,5 +1,23 @@\n 2018-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/88446\n+\t* cp-tree.h (maybe_constant_value): Add manifestly_const_eval\n+\targument.\n+\t* constexpr.c (struct constexpr_call): Rename pretend_const_required\n+\tmember to manifestly_const_eval.\n+\t(struct constexpr_ctx): Likewise.\n+\t(constexpr_call_hasher::equal): Adjust users.\n+\t(cxx_eval_builtin_function_call): Likewise.  Formatting fix.\n+\t(cxx_eval_call_expression): Adjust users.\n+\t(cxx_eval_outermost_constant_expr, maybe_constant_init_1,\n+\tmaybe_constant_init): Rename pretend_const_required argument to\n+\tmanifestly_const_eval, adjust function comments.\n+\t(maybe_constant_value): Add manifestly_const_eval argument.  If true,\n+\tdon't cache and call cxx_eval_outermost_constant_expr with true as\n+\tmanifestly_const_eval.\n+\t* decl.c (compute_array_index_type_loc): Call maybe_constant_value\n+\twith true as manifestly_const_eval.\n+\n \tPR c++/88449\n \t* constexpr.c (struct constexpr_call): Add pretend_const_required\n \tmember."}, {"sha": "f8049468c2233fee1f98e64c1c7e9d9b6cb84627", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -977,7 +977,7 @@ struct GTY((for_user)) constexpr_call {\n      recalculate it when expanding the hash table.  */\n   hashval_t hash;\n   /* Whether __builtin_is_constant_evaluated() should evaluate to true.  */\n-  bool pretend_const_required;\n+  bool manifestly_const_eval;\n };\n \n struct constexpr_call_hasher : ggc_ptr_hash<constexpr_call>\n@@ -1025,7 +1025,7 @@ struct constexpr_ctx {\n      trying harder to get a constant value.  */\n   bool strict;\n   /* Whether __builtin_is_constant_evaluated () should be true.  */\n-  bool pretend_const_required;\n+  bool manifestly_const_eval;\n };\n \n /* A table of all constexpr calls that have been evaluated by the\n@@ -1057,7 +1057,7 @@ constexpr_call_hasher::equal (constexpr_call *lhs, constexpr_call *rhs)\n     return true;\n   if (lhs->hash != rhs->hash)\n     return false;\n-  if (lhs->pretend_const_required != rhs->pretend_const_required)\n+  if (lhs->manifestly_const_eval != rhs->manifestly_const_eval)\n     return false;\n   if (!constexpr_fundef_hasher::equal (lhs->fundef, rhs->fundef))\n     return false;\n@@ -1206,11 +1206,11 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n     }\n \n   /* For __builtin_is_constant_evaluated, defer it if not\n-     ctx->pretend_const_required, otherwise fold it to true.  */\n+     ctx->manifestly_const_eval, otherwise fold it to true.  */\n   if (fndecl_built_in_p (fun, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n-\t\t       BUILT_IN_FRONTEND))\n+\t\t\t BUILT_IN_FRONTEND))\n     {\n-      if (!ctx->pretend_const_required)\n+      if (!ctx->manifestly_const_eval)\n \t{\n \t  *non_constant_p = true;\n \t  return t;\n@@ -1508,7 +1508,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   location_t loc = cp_expr_loc_or_loc (t, input_location);\n   tree fun = get_function_named_in_call (t);\n   constexpr_call new_call\n-    = { NULL, NULL, NULL, 0, ctx->pretend_const_required };\n+    = { NULL, NULL, NULL, 0, ctx->manifestly_const_eval };\n   bool depth_ok;\n \n   if (fun == NULL_TREE)\n@@ -1684,7 +1684,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       new_call.hash\n \t= iterative_hash_template_arg (new_call.bindings, new_call.hash);\n       new_call.hash\n-\t= iterative_hash_object (ctx->pretend_const_required, new_call.hash);\n+\t= iterative_hash_object (ctx->manifestly_const_eval, new_call.hash);\n \n       /* If we have seen this call before, we are done.  */\n       maybe_initialize_constexpr_call_table ();\n@@ -5022,13 +5022,13 @@ instantiate_constexpr_fns (tree t)\n    STRICT has the same sense as for constant_value_1: true if we only allow\n    conforming C++ constant expressions, or false if we want a constant value\n    even if it doesn't conform.\n-   PRETEND_CONST_REQUIRED is true if T is required to be const-evaluated as\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated as\n    per P0595 even when ALLOW_NON_CONSTANT is true.  */\n \n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n-\t\t\t\t  bool pretend_const_required = false,\n+\t\t\t\t  bool manifestly_const_eval = false,\n \t\t\t\t  tree object = NULL_TREE)\n {\n   auto_timevar time (TV_CONSTEXPR);\n@@ -5039,7 +5039,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \n   constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n-\t\t\tpretend_const_required || !allow_non_constant };\n+\t\t\tmanifestly_const_eval || !allow_non_constant };\n \n   tree type = initialized_type (t);\n   tree r = t;\n@@ -5131,7 +5131,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n       /* If __builtin_is_constant_evaluated () was evaluated to true\n \t and the result is not a valid constant expression, we need to\n \t punt.  */\n-      if (pretend_const_required)\n+      if (manifestly_const_eval)\n \treturn cxx_eval_outermost_constant_expr (t, true, strict,\n \t\t\t\t\t\t false, object);\n       /* This isn't actually constant, so unset TREE_CONSTANT.\n@@ -5274,12 +5274,14 @@ fold_simple (tree t)\n \n /* If T is a constant expression, returns its reduced value.\n    Otherwise, if T does not have TREE_CONSTANT set, returns T.\n-   Otherwise, returns a version of T without TREE_CONSTANT.  */\n+   Otherwise, returns a version of T without TREE_CONSTANT.\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated\n+   as per P0595.  */\n \n static GTY((deletable)) hash_map<tree, tree> *cv_cache;\n \n tree\n-maybe_constant_value (tree t, tree decl)\n+maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n {\n   tree r;\n \n@@ -5296,6 +5298,9 @@ maybe_constant_value (tree t, tree decl)\n     /* No caching or evaluation needed.  */\n     return t;\n \n+  if (manifestly_const_eval)\n+    return cxx_eval_outermost_constant_expr (t, true, true, true, decl);\n+\n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n   if (tree *cached = cv_cache->get (t))\n@@ -5399,12 +5404,12 @@ fold_non_dependent_expr (tree t,\n /* Like maybe_constant_value, but returns a CONSTRUCTOR directly, rather\n    than wrapped in a TARGET_EXPR.\n    ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n-   PRETEND_CONST_REQUIRED is true if T is required to be const-evaluated as\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated as\n    per P0595 even when ALLOW_NON_CONSTANT is true.  */\n \n static tree\n maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n-\t\t       bool pretend_const_required)\n+\t\t       bool manifestly_const_eval)\n {\n   if (!t)\n     return t;\n@@ -5424,7 +5429,7 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n   else\n     t = cxx_eval_outermost_constant_expr (t, allow_non_constant,\n \t\t\t\t\t  /*strict*/false,\n-\t\t\t\t\t  pretend_const_required, decl);\n+\t\t\t\t\t  manifestly_const_eval, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n@@ -5437,9 +5442,9 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n /* Wrapper for maybe_constant_init_1 which permits non constants.  */\n \n tree\n-maybe_constant_init (tree t, tree decl, bool pretend_const_required)\n+maybe_constant_init (tree t, tree decl, bool manifestly_const_eval)\n {\n-  return maybe_constant_init_1 (t, decl, true, pretend_const_required);\n+  return maybe_constant_init_1 (t, decl, true, manifestly_const_eval);\n }\n \n /* Wrapper for maybe_constant_init_1 which does not permit non constants.  */"}, {"sha": "1d806b782bdcf0adf7b4120e451536de4ad444ea", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -7663,7 +7663,7 @@ extern bool require_rvalue_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree fold_simple\t\t\t\t(tree);"}, {"sha": "9b0ea702ec46ad37f1ff170c23ec13037830b97e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -9646,7 +9646,11 @@ compute_array_index_type_loc (location_t name_loc, tree name, tree size,\n \t{\n \t  size = instantiate_non_dependent_expr_sfinae (size, complain);\n \t  size = build_converted_constant_expr (size_type_node, size, complain);\n-\t  size = maybe_constant_value (size);\n+\t  /* Pedantically a constant expression is required here and so\n+\t     __builtin_is_constant_evaluated () should fold to true if it\n+\t     is successfully folded into a constant.  */\n+\t  size = maybe_constant_value (size, NULL_TREE,\n+\t\t\t\t       /*manifestly_const_eval=*/true);\n \n \t  if (!TREE_CONSTANT (size))\n \t    size = osize;"}, {"sha": "9e851e4042a8f305ae3dd2a9e22eba7ffc93b30e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -1,5 +1,8 @@\n 2018-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/88446\n+\t* g++.dg/cpp2a/is-constant-evaluated3.C: New test.\n+\n \tPR c++/88449\n \t* g++.dg/cpp2a/is-constant-evaluated1.C: Change from dg-do compile\n \tto dg-do run."}, {"sha": "dd6104eced48feadb27095ee2d109b5cece2b629", "filename": "gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de99bc7d085125e614ffdb75d486e9a7a8a48f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated3.C?ref=13de99bc7d085125e614ffdb75d486e9a7a8a48f", "patch": "@@ -0,0 +1,26 @@\n+// P0595R1\n+// { dg-do run { target c++14 } }\n+\n+struct false_type { static constexpr bool value = false; };\n+struct true_type { static constexpr bool value = true; };\n+template<class T, class U>\n+struct is_same : false_type {};\n+template<class T>\n+struct is_same<T, T> : true_type {};\n+\n+int a[__builtin_is_constant_evaluated () ? 1 : 2];\n+int b[1];\n+static_assert (is_same<decltype (a), decltype (b)>::value, \"\");\n+\n+int\n+main ()\n+{\n+  int c[__builtin_is_constant_evaluated () ? 3 : 4];\n+  int d[3];\n+  static_assert (is_same<decltype (c), decltype (d)>::value, \"\");\n+  int (*e)[7][9] = new int[__builtin_is_constant_evaluated () ? -1 : 5]\n+\t\t\t  [__builtin_is_constant_evaluated () ? 7 : 8]\n+\t\t\t  [__builtin_is_constant_evaluated () ? 9 : 10];\n+  e[0][0][0] = 6;\n+  delete[] e;\n+}"}]}