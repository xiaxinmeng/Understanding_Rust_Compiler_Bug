{"sha": "fcbbf14a65cb7cb5814087870a0ecb47c227592c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNiYmYxNGE2NWNiN2NiNTgxNDA4Nzg3MGEwZWNiNDdjMjI3NTkyYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-06-27T07:46:04Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-06-27T07:46:04Z"}, "message": "parser.c (cp_parser_compound_literal_p): New.\n\n2014-06-27  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_compound_literal_p): New.\n\t(cp_parser_postfix_expression, cp_parser_sizeof_operand): Use it.\n\nFrom-SVN: r212064", "tree": {"sha": "802b3594f135651fb3a071931354cede040f2a5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/802b3594f135651fb3a071931354cede040f2a5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcbbf14a65cb7cb5814087870a0ecb47c227592c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcbbf14a65cb7cb5814087870a0ecb47c227592c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcbbf14a65cb7cb5814087870a0ecb47c227592c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcbbf14a65cb7cb5814087870a0ecb47c227592c/comments", "author": null, "committer": null, "parents": [{"sha": "a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ee446d6d7f1c120e9ef281ec4586f7535647cc"}], "stats": {"total": 66, "additions": 34, "deletions": 32}, "files": [{"sha": "e8aee0f992729a51a6332c50f21a80bfa37f099c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcbbf14a65cb7cb5814087870a0ecb47c227592c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcbbf14a65cb7cb5814087870a0ecb47c227592c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fcbbf14a65cb7cb5814087870a0ecb47c227592c", "patch": "@@ -1,3 +1,8 @@\n+2014-06-27  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_compound_literal_p): New.\n+\t(cp_parser_postfix_expression, cp_parser_sizeof_operand): Use it.\n+\n 2014-06-26  Jason Merrill  <jason@redhat.com>\n \n \t* parser.c (cp_parser_for_init_statement): Change range-for error"}, {"sha": "057b6ca14cc88e2fb4b6138f39938ed90228cb81", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcbbf14a65cb7cb5814087870a0ecb47c227592c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcbbf14a65cb7cb5814087870a0ecb47c227592c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fcbbf14a65cb7cb5814087870a0ecb47c227592c", "patch": "@@ -2480,7 +2480,9 @@ static bool cp_parser_is_keyword\n static tree cp_parser_make_typename_type\n   (cp_parser *, tree, tree, location_t location);\n static cp_declarator * cp_parser_make_indirect_declarator\n- (enum tree_code, tree, cp_cv_quals, cp_declarator *, tree);\n+  (enum tree_code, tree, cp_cv_quals, cp_declarator *, tree);\n+static bool cp_parser_compound_literal_p\n+  (cp_parser *);\n \n /* Returns nonzero if we are parsing tentatively.  */\n \n@@ -5609,6 +5611,30 @@ cp_parser_qualifying_entity (cp_parser *parser,\n   return scope;\n }\n \n+/* Return true if we are looking at a compound-literal, false otherwise.  */\n+\n+static bool\n+cp_parser_compound_literal_p (cp_parser *parser)\n+{\n+  /* Consume the `('.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  cp_lexer_save_tokens (parser->lexer);\n+\n+  /* Skip tokens until the next token is a closing parenthesis.\n+     If we find the closing `)', and the next token is a `{', then\n+     we are looking at a compound-literal.  */\n+  bool compound_literal_p\n+    = (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t      /*consume_paren=*/true)\n+       && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n+  \n+  /* Roll back the tokens we skipped.  */\n+  cp_lexer_rollback_tokens (parser->lexer);\n+\n+  return compound_literal_p;\n+}\n+\n /* Parse a postfix-expression.\n \n    postfix-expression:\n@@ -5917,25 +5943,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n \t    tree initializer = NULL_TREE;\n-\t    bool compound_literal_p;\n \n \t    cp_parser_parse_tentatively (parser);\n-\t    /* Consume the `('.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n \n \t    /* Avoid calling cp_parser_type_id pointlessly, see comment\n \t       in cp_parser_cast_expression about c++/29234.  */\n-\t    cp_lexer_save_tokens (parser->lexer);\n-\n-\t    compound_literal_p\n-\t      = (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n-\t\t\t\t\t\t\t/*consume_paren=*/true)\n-\t\t && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n-\n-\t    /* Roll back the tokens we skipped.  */\n-\t    cp_lexer_rollback_tokens (parser->lexer);\n-\n-\t    if (!compound_literal_p)\n+\t    if (!cp_parser_compound_literal_p (parser))\n \t      cp_parser_simulate_error (parser);\n \t    else\n \t      {\n@@ -23966,31 +23979,15 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n       tree type = NULL_TREE;\n-      bool compound_literal_p;\n \n       /* We can't be sure yet whether we're looking at a type-id or an\n \t expression.  */\n       cp_parser_parse_tentatively (parser);\n-      /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n       /* Note: as a GNU Extension, compound literals are considered\n \t postfix-expressions as they are in C99, so they are valid\n \t arguments to sizeof.  See comment in cp_parser_cast_expression\n \t for details.  */\n-      cp_lexer_save_tokens (parser->lexer);\n-      /* Skip tokens until the next token is a closing parenthesis.\n-\t If we find the closing `)', and the next token is a `{', then\n-\t we are looking at a compound-literal.  */\n-      compound_literal_p\n-\t= (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n-\t\t\t\t\t\t  /*consume_paren=*/true)\n-\t   && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n-      /* Roll back the tokens we skipped.  */\n-      cp_lexer_rollback_tokens (parser->lexer);\n-      /* If we were looking at a compound-literal, simulate an error\n-\t so that the call to cp_parser_parse_definitely below will\n-\t fail.  */\n-      if (compound_literal_p)\n+      if (cp_parser_compound_literal_p (parser))\n \tcp_parser_simulate_error (parser);\n       else\n \t{"}]}