{"sha": "f0ebf6e3229d88be4bc8d13b219327a7a073df83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBlYmY2ZTMyMjlkODhiZTRiYzhkMTNiMjE5MzI3YTdhMDczZGY4Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-04T19:10:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-04T19:10:05Z"}, "message": "compiler: fix crashes on cyclic var/type references\n    \n    This patch fixes type traversal to avoid compiler crashes for test\n    cases where a type T includes an expression that refers back to the\n    type without actually explicitly mentioning T. Examples include\n    \n      var x [uintptr(unsafe.Sizeof(&x))]byte\n      var a [len(a)]int\n    \n    The fix involves expanding the set of types that the traversal code\n    \"remembers\" (to avoid cycles) to include array types, and introducing an\n    additional guard in Builtin_call_expression::do_is_constant to catch\n    cyclic type constructs.\n    \n    Fixes golang/go#25299\n    Fixes golang/go#25679\n    Fixes golang/go#25315\n    Fixes golang/go#25680\n    \n    Reviewed-on: https://go-review.googlesource.com/115796\n\nFrom-SVN: r261168", "tree": {"sha": "bac6ab9a7cb11017d4e4ab53577eebb573d2e3dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bac6ab9a7cb11017d4e4ab53577eebb573d2e3dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0ebf6e3229d88be4bc8d13b219327a7a073df83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ebf6e3229d88be4bc8d13b219327a7a073df83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ebf6e3229d88be4bc8d13b219327a7a073df83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ebf6e3229d88be4bc8d13b219327a7a073df83/comments", "author": null, "committer": null, "parents": [{"sha": "e68086c43226ee8ada8ac71365f571a3d3ad2a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68086c43226ee8ada8ac71365f571a3d3ad2a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68086c43226ee8ada8ac71365f571a3d3ad2a0a"}], "stats": {"total": 22, "additions": 17, "deletions": 5}, "files": [{"sha": "f2ec42058fcab45f5119be6dcff91e283a120dee", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f0ebf6e3229d88be4bc8d13b219327a7a073df83", "patch": "@@ -1,4 +1,4 @@\n-79eca4fd642724d89e9bec8f79889451f6632a46\n+8e74a218e11ef6eaaf7014a3ad1cd0b13359c607\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "75b8b69383cea162d7b9a55f02d0c86c6f992f89", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f0ebf6e3229d88be4bc8d13b219327a7a073df83", "patch": "@@ -8061,9 +8061,13 @@ Builtin_call_expression::do_is_constant() const\n \t  arg_type = arg_type->points_to();\n \n \tif (arg_type->array_type() != NULL\n-\t    && arg_type->array_type()->length() != NULL\n-\t    && Builtin_call_expression::array_len_is_constant(arg))\n-\t  return true;\n+\t    && arg_type->array_type()->length() != NULL)\n+          {\n+\t    this->seen_ = true;\n+\t    bool ret = Builtin_call_expression::array_len_is_constant(arg);\n+\t    this->seen_ = false;\n+\t    return ret;\n+          }\n \n \tif (this->code_ == BUILTIN_LEN && arg_type->is_string_type())\n \t  {"}, {"sha": "6c20a2b9a45c1da8be7cd5b2b3e675bf61d5e7a4", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ebf6e3229d88be4bc8d13b219327a7a073df83/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f0ebf6e3229d88be4bc8d13b219327a7a073df83", "patch": "@@ -8258,8 +8258,16 @@ Traverse::remember_type(const Type* type)\n   // We mostly only have to remember named types.  But it turns out\n   // that an interface type can refer to itself without using a name\n   // by relying on interface inheritance, as in\n-  // type I interface { F() interface{I} }\n+  //\n+  //         type I interface { F() interface{I} }\n+  //\n+  // Similarly it is possible for array types to refer to themselves\n+  // without a name, e.g.\n+  //\n+  //         var x [uintptr(unsafe.Sizeof(&x))]byte\n+  //\n   if (type->classification() != Type::TYPE_NAMED\n+      && type->classification() != Type::TYPE_ARRAY\n       && type->classification() != Type::TYPE_INTERFACE)\n     return false;\n   if (this->types_seen_ == NULL)"}]}