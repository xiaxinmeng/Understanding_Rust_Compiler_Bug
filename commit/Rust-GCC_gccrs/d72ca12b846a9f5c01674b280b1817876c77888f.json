{"sha": "d72ca12b846a9f5c01674b280b1817876c77888f", "node_id": "C_kwDOANBUbNoAKGQ3MmNhMTJiODQ2YTlmNWMwMTY3NGIyODBiMTgxNzg3NmM3Nzg4OGY", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-11-20T07:55:58Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-09-02T09:25:30Z"}, "message": "RISC-V: Implement TARGET_COMPUTE_MULTILIB\n\nUse TARGET_COMPUTE_MULTILIB to search the multi-lib reuse for riscv*-*-elf*,\naccording following rules:\n\n 1. Check ABI is same.\n 2. Check both has atomic extension or both don't have atomic extension.\n    - Because mix soft and hard atomic operation doesn't make sense and\n      won't work as expect.\n 3. Check current arch is superset of the target multi-lib arch.\n    - It might result slower performance or larger code size, but it\n      safe to run.\n 4. Pick most match multi-lib set if more than one multi-lib are pass\n    the above checking.\n\nExample for how to select multi-lib:\n  We build code with -march=rv32imaf and -mabi=ilp32, and we have\n  following 5 multi-lib set:\n\n    1. rv32ia/ilp32\n    2. rv32ima/ilp32\n    3. rv32imf/ilp32\n    4. rv32imaf/ilp32f\n    5. rv32imafd/ilp32\n\n  The first and second multi-lib is safe to like, 3rd multi-lib can't\n  re-use becasue it don't have atomic extension, which is mismatch according\n  rule 2, and the 4th multi-lib can't re-use too due to the ABI mismatch,\n  the last multi-lib can't use since current arch is not superset of the\n  arch of multi-lib.\n\nAnd emit error if not found suitable multi-lib set, the error message\nonly emit when link with standard libraries.\n\nExample for when error will be emitted:\n\n  $ riscv64-unknown-elf-gcc -print-multi-lib\n  .;\n  rv32i/ilp32;@march=rv32i@mabi=ilp32\n  rv32im/ilp32;@march=rv32im@mabi=ilp32\n  rv32iac/ilp32;@march=rv32iac@mabi=ilp32\n  rv32imac/ilp32;@march=rv32imac@mabi=ilp32\n  rv32imafc/ilp32f;@march=rv32imafc@mabi=ilp32f\n  rv64imac/lp64;@march=rv64imac@mabi=lp64\n\n  // No actual linking, so no error emitted.\n  $ riscv64-unknown-elf-gcc -print-multi-directory -march=rv32ia -mabi=ilp32\n  .\n\n  // Link to default libc and libgcc, so check the multi-lib, and emit\n  // error because not found suitable multilib.\n  $ riscv64-unknown-elf-gcc -march=rv32ia -mabi=ilp32 ~/hello.c\n  riscv64-unknown-elf-gcc: fatal error: can't found suitable multilib set for '-march=rv32ia'/'-mabi=ilp32'\n  compilation terminated.\n\n  // No error emitted, because not link to stdlib.\n  $ riscv64-unknown-elf-gcc -march=rv32ia -mabi=ilp32 ~/hello.c -nostdlib\n\n  // No error emitted, because compile only.\n  $ riscv64-unknown-elf-gcc -march=rv32ia -mabi=ilp32 ~/hello.c -c\n\ngcc/ChangeLog:\n\n\t* common/config/riscv/riscv-common.cc: Include <vector>.\n\t(struct riscv_multi_lib_info_t): New.\n\t(riscv_subset_list::match_score): Ditto.\n\t(find_last_appear_switch): Ditto.\n\t(prefixed_with): Ditto.\n\t(struct multi_lib_info_t): Ditto.\n\t(riscv_current_arch_str): Ditto.\n\t(riscv_current_abi_str): Ditto.\n\t(riscv_multi_lib_info_t::parse): Ditto.\n\t(riscv_check_cond): Ditto.\n\t(riscv_check_conds): Ditto.\n\t(riscv_compute_multilib): Ditto.\n\t(TARGET_COMPUTE_MULTILIB): Defined.\n\t* config/riscv/elf.h (LIB_SPEC): Call riscv_multi_lib_check if\n\tdoing link.\n\t(RISCV_USE_CUSTOMISED_MULTI_LIB): New.\n\t* config/riscv/riscv.h (riscv_multi_lib_check): New.\n\t(EXTRA_SPEC_FUNCTIONS): Add riscv_multi_lib_check.\n\t* config/riscv/riscv-subset.h (riscv_subset_list::match_score): New.", "tree": {"sha": "e1927e05aa17a1658d3def80c50f33d47630e4f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1927e05aa17a1658d3def80c50f33d47630e4f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d72ca12b846a9f5c01674b280b1817876c77888f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72ca12b846a9f5c01674b280b1817876c77888f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72ca12b846a9f5c01674b280b1817876c77888f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72ca12b846a9f5c01674b280b1817876c77888f/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ca9980fc86242505ffdaaf62bca1fd5db26550b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca9980fc86242505ffdaaf62bca1fd5db26550b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca9980fc86242505ffdaaf62bca1fd5db26550b"}], "stats": {"total": 389, "additions": 387, "deletions": 2}, "files": [{"sha": "cb3a5d270df97be813579658e200c8b03e7fc3e5", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=d72ca12b846a9f5c01674b280b1817876c77888f", "patch": "@@ -18,6 +18,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include <sstream>\n+#include <vector>\n \n #define INCLUDE_STRING\n #include \"config.h\"\n@@ -230,6 +231,26 @@ const riscv_subset_list *riscv_current_subset_list ()\n   return current_subset_list;\n }\n \n+/* struct for recording multi-lib info.  */\n+struct riscv_multi_lib_info_t {\n+  std::string path;\n+  std::string arch_str;\n+  std::string abi_str;\n+  std::vector<std::string> conds;\n+  riscv_subset_list *subset_list;\n+\n+  static bool parse (struct riscv_multi_lib_info_t *,\n+\t\t     const std::string &,\n+\t\t     const std::vector<std::string> &);\n+};\n+\n+/* Flag for checking if there is no suitable multi-lib found.  */\n+static bool riscv_no_matched_multi_lib;\n+\n+/* Used for record value of -march and -mabi.  */\n+static std::string riscv_current_arch_str;\n+static std::string riscv_current_abi_str;\n+\n riscv_subset_t::riscv_subset_t ()\n   : name (), major_version (0), minor_version (0), next (NULL),\n     explicit_version_p (false), implied_p (false)\n@@ -255,6 +276,42 @@ riscv_subset_list::~riscv_subset_list ()\n     }\n }\n \n+/* Compute the match score of two arch string, return 0 if incompatible.  */\n+int\n+riscv_subset_list::match_score (riscv_subset_list *list) const\n+{\n+  riscv_subset_t *s;\n+  int score = 0;\n+  bool has_a_ext, list_has_a_ext;\n+\n+  /* Impossible to match if XLEN is different.  */\n+  if (list->m_xlen != this->m_xlen)\n+    return 0;\n+\n+  /* There is different code gen in libstdc++ and libatomic between w/ A-ext\n+     and w/o A-ext, and it not work if using soft and hard atomic mechanism\n+     at same time, so they are incompatible.  */\n+  has_a_ext = this->lookup (\"a\") != NULL;\n+  list_has_a_ext = list->lookup (\"a\") != NULL;\n+\n+  if (has_a_ext != list_has_a_ext)\n+    return 0;\n+\n+\n+  /* list must be subset of current this list, otherwise it not safe to\n+     link.\n+     TODO: We might give different weight for each extension, but the rule could\n+\t   be complicated.\n+     TODO: We might consider the version of each extension.  */\n+  for (s = list->m_head; s != NULL; s = s->next)\n+    if (this->lookup (s->name.c_str ()) != NULL)\n+      score++;\n+    else\n+      return 0;\n+\n+  return score;\n+}\n+\n /* Get the rank for single-letter subsets, lower value meaning higher\n    priority.  */\n \n@@ -1305,6 +1362,326 @@ riscv_expand_arch_from_cpu (int argc ATTRIBUTE_UNUSED,\n   return xasprintf (\"-march=%s\", arch.c_str());\n }\n \n+/* Find last switch with the prefix, options are take last one in general,\n+   return NULL if not found, and return the option value if found, it could\n+   return empty string if the option has no value.  */\n+\n+static const char *\n+find_last_appear_switch (\n+  const struct switchstr *switches,\n+  int n_switches,\n+  const char *prefix)\n+{\n+  int i;\n+  size_t len = strlen (prefix);\n+\n+  for (i = 0; i < n_switches; ++i)\n+    {\n+      const struct switchstr *this_switch = &switches[n_switches - i - 1];\n+\n+      if (this_switch->live_cond & SWITCH_FALSE)\n+\tcontinue;\n+\n+      if (strncmp (this_switch->part1, prefix, len) == 0)\n+\treturn this_switch->part1 + len;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Utils functions to check STR is start with PREFIX or not.  */\n+\n+static bool\n+prefixed_with (const std::string &str, const char *prefix)\n+{\n+  return strncmp (prefix, str.c_str (), strlen (prefix)) == 0;\n+}\n+\n+/* Parse the path and cond string into riscv_multi_lib_info_t, return false\n+   if parsing failed. */\n+\n+bool\n+riscv_multi_lib_info_t::parse (\n+  struct riscv_multi_lib_info_t *multi_lib_info,\n+  const std::string &path,\n+  const std::vector<std::string> &conds)\n+{\n+  const char *default_arch_str = STRINGIZING (TARGET_RISCV_DEFAULT_ARCH);\n+  const char *default_abi_str = STRINGIZING (TARGET_RISCV_DEFAULT_ABI);\n+  multi_lib_info->conds = conds;\n+  if (path == \".\")\n+    {\n+      multi_lib_info->arch_str = default_arch_str;\n+      multi_lib_info->abi_str = default_abi_str;\n+    }\n+  else\n+    {\n+      std::vector<std::string>::const_iterator itr;\n+      for (itr = conds.begin (); itr != conds.end (); ++itr)\n+\tif (prefixed_with (*itr, \"march=\"))\n+\t  multi_lib_info->arch_str = itr->c_str () + strlen (\"march=\");\n+\telse if (prefixed_with (*itr, \"mabi=\"))\n+\t  multi_lib_info->abi_str = itr->c_str () + strlen (\"mabi=\");\n+\n+\t/* Skip this multi-lib if this configuration is exactly same as\n+\t   default multi-lib settings.  */\n+      if (multi_lib_info->arch_str == default_arch_str\n+\t  && multi_lib_info->abi_str == default_abi_str)\n+\treturn false;\n+    }\n+\n+  multi_lib_info->subset_list =\n+    riscv_subset_list::parse (multi_lib_info->arch_str.c_str (), input_location);\n+\n+  return true;\n+}\n+\n+/* Report error if not found suitable multilib.  */\n+const char *\n+riscv_multi_lib_check (int argc ATTRIBUTE_UNUSED,\n+\t\t       const char **argv ATTRIBUTE_UNUSED)\n+{\n+  if (riscv_no_matched_multi_lib)\n+    fatal_error (\n+      input_location,\n+      \"Can't find suitable multilib set for %<-march=%s%>/%<-mabi=%s%>\",\n+      riscv_current_arch_str.c_str (),\n+      riscv_current_abi_str.c_str ());\n+\n+  return \"\";\n+}\n+\n+/* Checking ARG is not appeared in SWITCHES if NOT_ARG is set or\n+   ARG is appeared if NOT_ARG is not set.  */\n+\n+static bool\n+riscv_check_cond (\n+  const struct switchstr *switches,\n+  int n_switches,\n+  const std::string &arg,\n+  bool not_arg)\n+{\n+  int i;\n+  for (i = 0; i < n_switches; ++i)\n+    {\n+      const struct switchstr *this_switch = &switches[n_switches - i - 1];\n+\n+      if ((this_switch->live_cond & SWITCH_IGNORE) != 0)\n+\tcontinue;\n+\n+      if (this_switch->live_cond & SWITCH_FALSE)\n+\tcontinue;\n+\n+      /* ARG should not appear if NOT_ARG is set.  */\n+      if (arg == this_switch->part1)\n+\treturn not_arg ? false : true;\n+    }\n+\n+  /* Not found ARG? that's ok if NOT_ARG is not set.  */\n+  return not_arg ? true : false;\n+}\n+\n+/* Check the other cond is found or not, return -1 if we should reject this\n+   multi-lib option set, otherwise return updated MATCH_SCORE.   */\n+\n+static int\n+riscv_check_conds (\n+  const struct switchstr *switches,\n+  int n_switches,\n+  int match_score,\n+  const std::vector<std::string> &conds)\n+{\n+  bool not_arg;\n+  bool ok;\n+  int ok_count = 0;\n+  std::vector<std::string>::const_iterator itr;\n+  const char *checking_arg;\n+\n+  if (match_score == 0)\n+    return 0;\n+\n+  for (itr = conds.begin (); itr != conds.end (); ++itr)\n+    {\n+      /* We'll check march= and mabi= in ohter place.  */\n+      if (prefixed_with (*itr, \"march=\") || prefixed_with (*itr, \"mabi=\"))\n+\tcontinue;\n+\n+      checking_arg = itr->c_str ();\n+      if (checking_arg[0] == '!')\n+\t{\n+\t  not_arg = true;\n+\t  /* Skip '!'. */\n+\t  checking_arg = checking_arg + 1;\n+\t}\n+      else\n+\tnot_arg = false;\n+\n+      ok = riscv_check_cond (switches, n_switches, checking_arg, not_arg);\n+\n+      if (!ok)\n+\treturn -1;\n+\n+      ok_count++;\n+    }\n+\n+  /* 100 is magic number, it's just used for make sure this multi-lib has\n+     higher priority if we found any some option is listed in the option check\n+     list. */\n+  return match_score + ok_count * 100;\n+}\n+\n+/* We only override this in bare-metal toolchain.  */\n+#ifdef RISCV_USE_CUSTOMISED_MULTI_LIB\n+\n+/* Implement TARGET_COMPUTE_MULTILIB.  */\n+static const char *\n+riscv_compute_multilib (\n+  const struct switchstr *switches,\n+  int n_switches,\n+  const char *multilib_dir,\n+  const char *multilib_defaults ATTRIBUTE_UNUSED,\n+  const char *multilib_select,\n+  const char *multilib_matches ATTRIBUTE_UNUSED,\n+  const char *multilib_exclusions ATTRIBUTE_UNUSED,\n+  const char *multilib_reuse ATTRIBUTE_UNUSED)\n+{\n+  const char *p;\n+  const char *this_path;\n+  size_t this_path_len;\n+  bool result;\n+  riscv_no_matched_multi_lib = false;\n+  riscv_subset_list *subset_list = NULL;\n+\n+  std::vector<riscv_multi_lib_info_t> multilib_infos;\n+  std::vector<std::string> option_conds;\n+  std::string option_cond;\n+  riscv_multi_lib_info_t multilib_info;\n+\n+  /* Already found suitable, multi-lib, just use that.  */\n+  if (multilib_dir != NULL)\n+    return multilib_dir;\n+\n+  /* Find march.  */\n+  riscv_current_arch_str =\n+    find_last_appear_switch (switches, n_switches, \"march=\");\n+  /* Find mabi.  */\n+  riscv_current_abi_str =\n+    find_last_appear_switch (switches, n_switches, \"mabi=\");\n+\n+  /* Failed to find -march or -mabi, but it should not happened since we have\n+     set both in OPTION_DEFAULT_SPECS.  */\n+  if (riscv_current_arch_str.empty () || riscv_current_abi_str.empty ())\n+    return multilib_dir;\n+\n+  subset_list = riscv_subset_list::parse (riscv_current_arch_str.c_str (),\n+\t\t\t\t\t  input_location);\n+\n+  /* Failed to parse -march, fallback to using what gcc use.  */\n+  if (subset_list == NULL)\n+    return multilib_dir;\n+\n+  /* Parsing MULTILIB_SELECT, ignore MULTILIB_REUSE here, we have our own rules.\n+     TODO: most codes are grab from gcc.c, maybe we should refine that?  */\n+  p = multilib_select;\n+\n+  while (*p != '\\0')\n+    {\n+      /* Ignore newlines.  */\n+      if (*p == '\\n')\n+\t{\n+\t  ++p;\n+\t  continue;\n+\t}\n+\n+      /* Format of each multilib:\n+\t <path> <opt1> <opt2> ... <optN>;  */\n+      /* Get the path.  */\n+      this_path = p;\n+      while (*p != ' ')\n+\t{\n+\t  if (*p == '\\0')\n+\t    {\n+\t      fatal_error (input_location, \"multilib select %qs %qs is invalid\",\n+\t\t\t   multilib_select, multilib_reuse);\n+\t    }\n+\t  ++p;\n+\t}\n+\n+      this_path_len = p - this_path;\n+      multilib_info.path = std::string (this_path, this_path_len);\n+\n+      option_conds.clear ();\n+      /* Pasrse option check list into vector<string>.\n+\t e.g. \"march=rv64imafd mabi=lp64 !mcmodel=medany\" to\n+\t      [\"march=rv64imafd\", \"mabi=lp64\", \"!mcmodel=medany\"].  */\n+      while (*p != ';')\n+\t{\n+\t  option_cond = \"\";\n+\t  /* Skip space.  */\n+\t  while (*p == ' ') p++;\n+\n+\t  while (*p && *p != ' ' && *p != ';')\n+\t      option_cond.push_back (*p++);\n+\n+\t  /* Ignore `!march=` and `!mabi=`, we will handle march and mabi\n+\t     later. */\n+\t  if (option_cond.size ()\n+\t      && !prefixed_with (option_cond, \"!march=\")\n+\t      && !prefixed_with (option_cond, \"!mabi=\"))\n+\t    option_conds.push_back (option_cond);\n+\t}\n+\n+      result =\n+\triscv_multi_lib_info_t::parse (\n+\t  &multilib_info,\n+\t  std::string (this_path, this_path_len),\n+\t  option_conds);\n+\n+      if (result)\n+\tmultilib_infos.push_back (multilib_info);\n+\n+      p++;\n+    }\n+\n+  int match_score = 0;\n+  int max_match_score = 0;\n+  int best_match_multi_lib = -1;\n+  /* Try to decision which set we should used.  */\n+  /* We have 3 level decision tree here, ABI, check input arch/ABI must\n+     be superset of multi-lib arch, and other rest option checking.  */\n+  for (size_t i = 0; i < multilib_infos.size (); ++i)\n+    {\n+      /* Check ABI is same first.  */\n+      if (riscv_current_abi_str != multilib_infos[i].abi_str)\n+\tcontinue;\n+\n+      /* Found a potential compatible multi-lib setting!\n+\t Calculate the match score.  */\n+      match_score = subset_list->match_score (multilib_infos[i].subset_list);\n+\n+      /* Checking other cond in the multi-lib setting.  */\n+      match_score = riscv_check_conds (switches,\n+\t\t\t\t       n_switches,\n+\t\t\t\t       match_score,\n+\t\t\t\t       multilib_infos[i].conds);\n+\n+      /* Record highest match score multi-lib setting.  */\n+      if (match_score > max_match_score)\n+\tbest_match_multi_lib = i;\n+    }\n+\n+  if (best_match_multi_lib == -1)\n+    {\n+      riscv_no_matched_multi_lib = true;\n+      return multilib_dir;\n+    }\n+  else\n+    return xstrdup (multilib_infos[best_match_multi_lib].path.c_str ());\n+}\n+\n+#undef TARGET_COMPUTE_MULTILIB\n+#define TARGET_COMPUTE_MULTILIB riscv_compute_multilib\n+#endif\n \n /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n static const struct default_options riscv_option_optimization_table[] ="}, {"sha": "f3d767c6d42f9fea4fac03dfb01f7d971c73b595", "filename": "gcc/config/riscv/elf.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Felf.h?ref=d72ca12b846a9f5c01674b280b1817876c77888f", "patch": "@@ -27,10 +27,14 @@ along with GCC; see the file COPYING3.  If not see\n /* Link against Newlib libraries, because the ELF backend assumes Newlib.\n    Handle the circular dependence between libc and libgloss. */\n #undef  LIB_SPEC\n-#define LIB_SPEC \"--start-group -lc %{!specs=nosys.specs:-lgloss} --end-group\"\n+#define LIB_SPEC \\\n+  \"--start-group -lc %{!specs=nosys.specs:-lgloss} --end-group \" \\\n+  \"%{!nostartfiles:%{!nodefaultlibs:%{!nolibc:%{!nostdlib:%:riscv_multi_lib_check()}}}}\"\n \n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC \"crt0%O%s crtbegin%O%s\"\n \n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend%O%s\"\n+\n+#define RISCV_USE_CUSTOMISED_MULTI_LIB 1"}, {"sha": "0bb3a9d29d09be88974afbf25def6ef863051ca4", "filename": "gcc/config/riscv/riscv-subset.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Friscv-subset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Friscv-subset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-subset.h?ref=d72ca12b846a9f5c01674b280b1817876c77888f", "patch": "@@ -89,6 +89,8 @@ class riscv_subset_list\n \n   const riscv_subset_t *begin () const {return m_head;};\n   const riscv_subset_t *end () const {return NULL;};\n+\n+  int match_score (riscv_subset_list *) const;\n };\n \n extern const riscv_subset_list *riscv_current_subset_list (void);"}, {"sha": "e35aaa7cc141a9cc503336dc53593ab16ed35902", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ca12b846a9f5c01674b280b1817876c77888f/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=d72ca12b846a9f5c01674b280b1817876c77888f", "patch": "@@ -50,11 +50,13 @@ along with GCC; see the file COPYING3.  If not see\n extern const char *riscv_expand_arch (int argc, const char **argv);\n extern const char *riscv_expand_arch_from_cpu (int argc, const char **argv);\n extern const char *riscv_default_mtune (int argc, const char **argv);\n+extern const char *riscv_multi_lib_check (int argc, const char **argv);\n \n # define EXTRA_SPEC_FUNCTIONS\t\t\t\t\t\t\\\n   { \"riscv_expand_arch\", riscv_expand_arch },\t\t\t\t\\\n   { \"riscv_expand_arch_from_cpu\", riscv_expand_arch_from_cpu },\t\t\\\n-  { \"riscv_default_mtune\", riscv_default_mtune },\n+  { \"riscv_default_mtune\", riscv_default_mtune },\t\t\t\\\n+  { \"riscv_multi_lib_check\", riscv_multi_lib_check },\n \n /* Support for a compile-time default CPU, et cetera.  The rules are:\n    --with-arch is ignored if -march or -mcpu is specified."}]}