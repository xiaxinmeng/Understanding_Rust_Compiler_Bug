{"sha": "56b138aed218de6e61416f2615424800ff7a0d18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiMTM4YWVkMjE4ZGU2ZTYxNDE2ZjI2MTU0MjQ4MDBmZjdhMGQxOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-05-22T19:33:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-05-22T19:33:37Z"}, "message": "hard-reg-set.h (GO_IF_HARD_REG_SUBSET, [...]): Delete in favor of...\n\ngcc/\n\t* hard-reg-set.h (GO_IF_HARD_REG_SUBSET, GO_IF_HARD_REG_EQUAL): Delete\n\tin favor of...\n\t(hard_reg_subset_p, hard_reg_sets_equal_p, hard_reg_sets_intersect_p)\n\t(hard_reg_set_empty_p): ...these new functions.\n\t* bt-load.c (choose_btr): Use hard_reg_subset_p instead of\n\tGO_IF_HARD_REG_SUBSET.\n\t* cfgcleanup.c (old_insns_match_p): Use hard_reg_sets_equal_p\n\tinstead of GO_IF_HARD_REG_EQUAL.\n\t* df-problems.c (df_urec_local_compute): Use hard_reg_set_empty_p\n\tinstead of GO_IF_HARD_REG_EQUAL.\n\t* global.c (find_reg): Use hard_reg_set_empty_p instead of\n\tGO_IF_HARD_REG_SUBSET.\n\t(modify_reg_pav): Use hard_reg_set_empty_p instead of\n\tGO_IF_HARD_REG_EQUAL.\n\t* local-alloc.c (find_free_reg): Use hard_reg_subset_p instead\n\tof GO_IF_HARD_REG_SUBSET.\n\t* reg-stack.c (change_stack, convert_regs_1): Use hard_reg_sets_equal_p\n\tinstead of GO_IF_HARD_REG_EQUAL.\n\t* regclass.c (init_reg_sets_1, reg_scan_mark_refs): Use\n\thard_reg_subset_p instead of GO_IF_HARD_REG_SUBSET.\n\t(reg_classes_intersect_p): Use hard_reg_sets_intersect_p instead\n\tof GO_IF_HARD_REG_SUBSET,\n\t* reload1.c (finish_spills): Use hard_reg_subset_p instead of\n\tGO_IF_HARD_REG_SUBSET.\n\t* struct-equiv.c (death_notes_match_p): Use hard_reg_sets_equal_p\n\tinstead of GO_IF_HARD_REG_EQUAL.\n\t* config/sh/sh.c (push_regs, calc_live_regs): Use\n\thard_reg_sets_intersect_p instead of hard_regs_intersect_p.\n\t(hard_regs_intersect_p): Delete.\n\nFrom-SVN: r124954", "tree": {"sha": "cfa4aaeabd4b1bbd0608b1fb3976bc0540f8ed3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa4aaeabd4b1bbd0608b1fb3976bc0540f8ed3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b138aed218de6e61416f2615424800ff7a0d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b138aed218de6e61416f2615424800ff7a0d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b138aed218de6e61416f2615424800ff7a0d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b138aed218de6e61416f2615424800ff7a0d18/comments", "author": null, "committer": null, "parents": [{"sha": "965ff67081ef58732db2256a1acba5cc3bb986be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965ff67081ef58732db2256a1acba5cc3bb986be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965ff67081ef58732db2256a1acba5cc3bb986be"}], "stats": {"total": 493, "additions": 275, "deletions": 218}, "files": [{"sha": "d65adea16426754074dc5f3c15d7e48644eed339", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -1,3 +1,35 @@\n+2007-05-22  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* hard-reg-set.h (GO_IF_HARD_REG_SUBSET, GO_IF_HARD_REG_EQUAL): Delete\n+\tin favor of...\n+\t(hard_reg_subset_p, hard_reg_sets_equal_p, hard_reg_sets_intersect_p)\n+\t(hard_reg_set_empty_p): ...these new functions.\n+\t* bt-load.c (choose_btr): Use hard_reg_subset_p instead of\n+\tGO_IF_HARD_REG_SUBSET.\n+\t* cfgcleanup.c (old_insns_match_p): Use hard_reg_sets_equal_p\n+\tinstead of GO_IF_HARD_REG_EQUAL.\n+\t* df-problems.c (df_urec_local_compute): Use hard_reg_set_empty_p\n+\tinstead of GO_IF_HARD_REG_EQUAL.\n+\t* global.c (find_reg): Use hard_reg_set_empty_p instead of\n+\tGO_IF_HARD_REG_SUBSET.\n+\t(modify_reg_pav): Use hard_reg_set_empty_p instead of\n+\tGO_IF_HARD_REG_EQUAL.\n+\t* local-alloc.c (find_free_reg): Use hard_reg_subset_p instead\n+\tof GO_IF_HARD_REG_SUBSET.\n+\t* reg-stack.c (change_stack, convert_regs_1): Use hard_reg_sets_equal_p\n+\tinstead of GO_IF_HARD_REG_EQUAL.\n+\t* regclass.c (init_reg_sets_1, reg_scan_mark_refs): Use\n+\thard_reg_subset_p instead of GO_IF_HARD_REG_SUBSET.\n+\t(reg_classes_intersect_p): Use hard_reg_sets_intersect_p instead\n+\tof GO_IF_HARD_REG_SUBSET,\n+\t* reload1.c (finish_spills): Use hard_reg_subset_p instead of\n+\tGO_IF_HARD_REG_SUBSET.\n+\t* struct-equiv.c (death_notes_match_p): Use hard_reg_sets_equal_p\n+\tinstead of GO_IF_HARD_REG_EQUAL.\n+\t* config/sh/sh.c (push_regs, calc_live_regs): Use\n+\thard_reg_sets_intersect_p instead of hard_regs_intersect_p.\n+\t(hard_regs_intersect_p): Delete.\n+\n 2007-05-22  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/sourcebuild.texi (Test Directives) Add dg-message."}, {"sha": "f5b07822cce35415e4c62e6698397e22004eb1cc", "filename": "gcc/bt-load.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -988,20 +988,19 @@ static int\n choose_btr (HARD_REG_SET used_btrs)\n {\n   int i;\n-  GO_IF_HARD_REG_SUBSET (all_btrs, used_btrs, give_up);\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n+  if (!hard_reg_set_subset_p (all_btrs, used_btrs))\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      {\n #ifdef REG_ALLOC_ORDER\n-      int regno = reg_alloc_order[i];\n+\tint regno = reg_alloc_order[i];\n #else\n-      int regno = i;\n+\tint regno = i;\n #endif\n-      if (TEST_HARD_REG_BIT (all_btrs, regno)\n-\t  && !TEST_HARD_REG_BIT (used_btrs, regno))\n-\treturn regno;\n-    }\n-give_up:\n+\tif (TEST_HARD_REG_BIT (all_btrs, regno)\n+\t    && !TEST_HARD_REG_BIT (used_btrs, regno))\n+\t  return regno;\n+      }\n   return -1;\n }\n "}, {"sha": "d2738435804bfc7eacdbfca9c2eb701bdb89b17e", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -974,12 +974,8 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n \tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n \t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n \n-      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n-\n-      return false;\n-\n-    done:\n-      ;\n+      if (!hard_reg_set_equal_p (i1_regset, i2_regset))\n+\treturn false;\n     }\n #endif\n "}, {"sha": "b3c46ab4688213559bcfb4dc8ed9a03e43f210f6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -267,7 +267,6 @@ static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n static int sh_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t         tree, bool);\n static int sh_dwarf_calling_convention (tree);\n-static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -5777,7 +5776,7 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t and we have to push any floating point register, we need\n \t to switch to the correct precision first.  */\n       if (i == FIRST_FP_REG && interrupt_handler && TARGET_FMOVD\n-\t  && hard_regs_intersect_p (mask, &reg_class_contents[DF_REGS]))\n+\t  && hard_reg_set_intersect_p (*mask, reg_class_contents[DF_REGS]))\n \t{\n \t  HARD_REG_SET unsaved;\n \n@@ -5987,10 +5986,10 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n      Make sure we save at least one general purpose register when we need\n      to save target registers.  */\n   if (interrupt_handler\n-      && hard_regs_intersect_p (live_regs_mask,\n-\t\t\t\t&reg_class_contents[TARGET_REGS])\n-      && ! hard_regs_intersect_p (live_regs_mask,\n-\t\t\t\t  &reg_class_contents[GENERAL_REGS]))\n+      && hard_reg_set_intersect_p (*live_regs_mask,\n+\t\t\t\t   reg_class_contents[TARGET_REGS])\n+      && ! hard_reg_set_intersect_p (*live_regs_mask,\n+\t\t\t\t     reg_class_contents[GENERAL_REGS]))\n     {\n       SET_HARD_REG_BIT (*live_regs_mask, R0_REG);\n       count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (R0_REG));\n@@ -6766,8 +6765,8 @@ sh_expand_epilogue (bool sibcall_p)\n \t  int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n \n \t  if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n-\t      && hard_regs_intersect_p (&live_regs_mask,\n-\t\t\t\t\t&reg_class_contents[DF_REGS]))\n+\t      && hard_reg_set_intersect_p (live_regs_mask,\n+\t\t\t\t\t  reg_class_contents[DF_REGS]))\n \t    fpscr_deferred = 1;\n \t  else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n \t    pop (j);\n@@ -10643,21 +10642,6 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n     }\n }\n \n-/* Determine if two hard register sets intersect.\n-   Return 1 if they do.  */\n-\n-static int\n-hard_regs_intersect_p (HARD_REG_SET *a, HARD_REG_SET *b)\n-{\n-  HARD_REG_SET c;\n-  COPY_HARD_REG_SET (c, *a);\n-  AND_HARD_REG_SET (c, *b);\n-  GO_IF_HARD_REG_SUBSET (c, reg_class_contents[(int) NO_REGS], lose);\n-  return 1;\n-lose:\n-  return 0;\n-}\n-\n /* Replace any occurrence of FROM(n) in X with TO(n).  The function does\n    not enter into CONST_DOUBLE for the replace.\n "}, {"sha": "385b8fb4725703641e5fe3012b6e2d7084c0ecec", "filename": "gcc/df-problems.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -2487,7 +2487,7 @@ df_urec_local_compute (struct dataflow *dflow,\n   bitmap_iterator bi;\n #ifdef STACK_REGS\n   int i;\n-  HARD_REG_SET zero, stack_hard_regs, used;\n+  HARD_REG_SET stack_hard_regs, used;\n   struct df_urec_problem_data *problem_data\n     = (struct df_urec_problem_data *) dflow->problem_data;\n   \n@@ -2498,7 +2498,6 @@ df_urec_local_compute (struct dataflow *dflow,\n \n      FIXME: This seems like an incredibly poor idea.  */\n \n-  CLEAR_HARD_REG_SET (zero);\n   CLEAR_HARD_REG_SET (stack_hard_regs);\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n     SET_HARD_REG_BIT (stack_hard_regs, i);\n@@ -2508,10 +2507,8 @@ df_urec_local_compute (struct dataflow *dflow,\n       COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n       IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n       AND_HARD_REG_SET (used, stack_hard_regs);\n-      GO_IF_HARD_REG_EQUAL (used, zero, skip);\n-      bitmap_set_bit (problem_data->stack_regs, i);\n-    skip:\n-      ;\n+      if (!hard_reg_set_empty_p (used))\n+\tbitmap_set_bit (problem_data->stack_regs, i);\n     }\n #endif\n "}, {"sha": "fd947607533e44097c0c1ba47ee3faf1a1f4de06", "filename": "gcc/global.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -1161,10 +1161,8 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n      preferred registers.  */\n \n   AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_copy_preferences, used);\n-  GO_IF_HARD_REG_SUBSET (allocno[num].hard_reg_copy_preferences,\n-\t\t\t reg_class_contents[(int) NO_REGS], no_copy_prefs);\n-\n-  if (best_reg >= 0)\n+  if (!hard_reg_set_empty_p (allocno[num].hard_reg_copy_preferences)\n+      && best_reg >= 0)\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_copy_preferences, i)\n@@ -1197,13 +1195,10 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t\t}\n \t    }\n     }\n- no_copy_prefs:\n \n   AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_preferences, used);\n-  GO_IF_HARD_REG_SUBSET (allocno[num].hard_reg_preferences,\n-\t\t\t reg_class_contents[(int) NO_REGS], no_prefs);\n-\n-  if (best_reg >= 0)\n+  if (!hard_reg_set_empty_p (allocno[num].hard_reg_preferences)\n+      && best_reg >= 0)\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_preferences, i)\n@@ -2437,10 +2432,9 @@ modify_reg_pav (void)\n   struct bb_info *bb_info;\n #ifdef STACK_REGS\n   int i;\n-  HARD_REG_SET zero, stack_hard_regs, used;\n+  HARD_REG_SET stack_hard_regs, used;\n   bitmap stack_regs;\n \n-  CLEAR_HARD_REG_SET (zero);\n   CLEAR_HARD_REG_SET (stack_hard_regs);\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n     SET_HARD_REG_BIT(stack_hard_regs, i);\n@@ -2450,10 +2444,8 @@ modify_reg_pav (void)\n       COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n       IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n       AND_HARD_REG_SET (used, stack_hard_regs);\n-      GO_IF_HARD_REG_EQUAL(used, zero, skip);\n-      bitmap_set_bit (stack_regs, i);\n-    skip:\n-      ;\n+      if (!hard_reg_set_empty_p (used))\n+\tbitmap_set_bit (stack_regs, i);\n     }\n #endif\n   FOR_EACH_BB (bb)"}, {"sha": "c5b456fea32183eb128124031b0756c850d59d84", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 151, "deletions": 58, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -83,9 +83,12 @@ typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n    IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n    which use the complement of the set FROM.\n \n-   Also define GO_IF_HARD_REG_SUBSET (X, Y, TO):\n-   if X is a subset of Y, go to TO.\n-*/\n+   Also define:\n+\n+   hard_reg_set_subset_p (X, Y), which returns true if X is a subset of Y.\n+   hard_reg_set_equal_p (X, Y), which returns true if X and Y are equal.\n+   hard_reg_set_intersect_p (X, Y), which returns true if X and Y intersect.\n+   hard_reg_set_empty_p (X), which returns true if X is empty.  */\n \n #ifdef HARD_REG_SET\n \n@@ -107,9 +110,29 @@ typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n #define AND_HARD_REG_SET(TO, FROM) ((TO) &= (FROM))\n #define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n \n-#define GO_IF_HARD_REG_SUBSET(X,Y,TO) if (HARD_CONST (0) == ((X) & ~(Y))) goto TO\n-\n-#define GO_IF_HARD_REG_EQUAL(X,Y,TO) if ((X) == (Y)) goto TO\n+static inline bool\n+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return (x & ~y) == HARD_CONST (0);\n+}\n+\n+static inline bool\n+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return x == y;\n+}\n+\n+static inline bool\n+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return (x & y) != HARD_CONST (0);\n+}\n+\n+static inline bool\n+hard_reg_set_empty_p (const HARD_REG_SET x)\n+{\n+  return x == HARD_CONST (0);\n+}\n \n #else\n \n@@ -168,17 +191,29 @@ do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= ~ scan_fp_[1]; } while (0)\n \n-#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n-\t && (0 == (scan_xp_[1] & ~ scan_yp_[1])))\t\t\\\n-\tgoto TO; } while (0)\n-\n-#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n-\t && (scan_xp_[1] == scan_yp_[1]))\t\t\t\\\n-\tgoto TO; } while (0)\n+static inline bool\n+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return (x[0] & ~y[0]) == 0 && (x[1] & ~y[1]) == 0;\n+}\n+\n+static inline bool\n+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return x[0] == y[0] && x[1] == y[1];\n+}\n+\n+static inline bool\n+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return (x[0] & y[0]) != 0 || (x[1] & y[1]) != 0;\n+}\n+\n+static inline bool\n+hard_reg_set_empty_p (const HARD_REG_SET x)\n+{\n+  return x[0] == 0 && x[1] == 0;\n+}\n \n #else\n #if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDEST_FAST_INT\n@@ -230,19 +265,33 @@ do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[1] |= ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] |= ~ scan_fp_[2]; } while (0)\n \n-#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n-\t && (0 == (scan_xp_[1] & ~ scan_yp_[1]))\t\t\\\n-\t && (0 == (scan_xp_[2] & ~ scan_yp_[2])))\t\t\\\n-\tgoto TO; } while (0)\n-\n-#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n-\t && (scan_xp_[1] == scan_yp_[1])\t\t\t\\\n-\t && (scan_xp_[2] == scan_yp_[2]))\t\t\t\\\n-\tgoto TO; } while (0)\n+static inline bool\n+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return ((x[0] & ~y[0]) == 0\n+\t  && (x[1] & ~y[1]) == 0\n+\t  && (x[2] & ~y[2]) == 0);\n+}\n+\n+static inline bool\n+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return x[0] == y[0] && x[1] == y[1] && x[2] == y[2];\n+}\n+\n+static inline bool\n+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return ((x[0] & y[0]) != 0\n+\t  || (x[1] & y[1]) != 0\n+\t  || (x[2] & y[2]) != 0);\n+}\n+\n+static inline bool\n+hard_reg_set_empty_p (const HARD_REG_SET x)\n+{\n+  return x[0] == 0 && x[1] == 0 && x[2] == 0;\n+}\n \n #else\n #if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDEST_FAST_INT\n@@ -302,21 +351,35 @@ do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[2] |= ~ scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] |= ~ scan_fp_[3]; } while (0)\n \n-#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n-\t && (0 == (scan_xp_[1] & ~ scan_yp_[1]))\t\t\\\n-\t && (0 == (scan_xp_[2] & ~ scan_yp_[2]))\t\t\\\n-\t && (0 == (scan_xp_[3] & ~ scan_yp_[3])))\t\t\\\n-\tgoto TO; } while (0)\n-\n-#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n-\t && (scan_xp_[1] == scan_yp_[1])\t\t\t\\\n-\t && (scan_xp_[2] == scan_yp_[2])\t\t\t\\\n-\t && (scan_xp_[3] == scan_yp_[3]))\t\t\t\\\n-\tgoto TO; } while (0)\n+static inline bool\n+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return ((x[0] & ~y[0]) == 0\n+\t  && (x[1] & ~y[1]) == 0\n+\t  && (x[2] & ~y[2]) == 0\n+\t  && (x[3] & ~y[3]) == 0);\n+}\n+\n+static inline bool\n+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return x[0] == y[0] && x[1] == y[1] && x[2] == y[2] && x[3] == y[3];\n+}\n+\n+static inline bool\n+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  return ((x[0] & y[0]) != 0\n+\t  || (x[1] & y[1]) != 0\n+\t  || (x[2] & y[2]) != 0\n+\t  || (x[3] & y[3]) != 0);\n+}\n+\n+static inline bool\n+hard_reg_set_empty_p (const HARD_REG_SET x)\n+{\n+  return x[0] == 0 && x[1] == 0 && x[2] == 0 && x[3] == 0;\n+}\n \n #else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDEST_FAST_INT */\n \n@@ -368,19 +431,49 @@ do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n \n-#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       if (0 != (*scan_xp_++ & ~ *scan_yp_++)) break;\t\t\\\n-     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n-\n-#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       if (*scan_xp_++ != *scan_yp_++) break;\t\t\t\\\n-     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n+static inline bool\n+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  int i;\n+\n+  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n+    if ((x[i] & ~y[i]) != 0)\n+      return false;\n+  return true;\n+}\n+\n+static inline bool\n+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  int i;\n+\n+  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n+    if (x[i] != y[i])\n+      return false;\n+  return true;\n+}\n+\n+static inline bool\n+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+{\n+  int i;\n+\n+  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n+    if ((x[i] & y[i]) != 0)\n+      return true;\n+  return false;\n+}\n+\n+static inline bool\n+hard_reg_set_empty_p (const HARD_REG_SET x)\n+{\n+  int i;\n+\n+  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n+    if (x[i] != 0)\n+      return false;\n+  return true;\n+}\n \n #endif\n #endif"}, {"sha": "cd1c01d753d5f723092b90202cf4ebe2f6a819cb", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -2286,42 +2286,40 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n \tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qtyno]);\n     }\n \n-  /* If all registers are excluded, we can't do anything.  */\n-  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) ALL_REGS], first_used, fail);\n-\n   /* If at least one would be suitable, test each hard reg.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n+  if (!hard_reg_set_subset_p (reg_class_contents[(int) ALL_REGS], first_used))\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      {\n #ifdef REG_ALLOC_ORDER\n-      int regno = reg_alloc_order[i];\n+\tint regno = reg_alloc_order[i];\n #else\n-      int regno = i;\n+\tint regno = i;\n #endif\n-      if (! TEST_HARD_REG_BIT (first_used, regno)\n-\t  && HARD_REGNO_MODE_OK (regno, mode)\n-\t  && (qty[qtyno].n_calls_crossed == 0\n-\t      || accept_call_clobbered\n-\t      || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n-\t{\n-\t  int j;\n-\t  int size1 = hard_regno_nregs[regno][mode];\n-\t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n-\t  if (j == size1)\n-\t    {\n-\t      /* Mark that this register is in use between its birth and death\n-\t\t insns.  */\n-\t      post_mark_life (regno, mode, 1, born_index, dead_index);\n-\t      return regno;\n-\t    }\n+\tif (!TEST_HARD_REG_BIT (first_used, regno)\n+\t    && HARD_REGNO_MODE_OK (regno, mode)\n+\t    && (qty[qtyno].n_calls_crossed == 0\n+\t\t|| accept_call_clobbered\n+\t\t|| !HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n+\t  {\n+\t    int j;\n+\t    int size1 = hard_regno_nregs[regno][mode];\n+\t    j = 1;\n+\t    while (j < size1 && !TEST_HARD_REG_BIT (used, regno + j))\n+\t      j++;\n+\t    if (j == size1)\n+\t      {\n+\t\t/* Mark that this register is in use between its birth\n+\t\t   and death insns.  */\n+\t\tpost_mark_life (regno, mode, 1, born_index, dead_index);\n+\t\treturn regno;\n+\t      }\n #ifndef REG_ALLOC_ORDER\n-\t  /* Skip starting points we know will lose.  */\n-\t  i += j;\n+\t    /* Skip starting points we know will lose.  */\n+\t    i += j;\n #endif\n-\t}\n-    }\n+\t  }\n+      }\n \n- fail:\n   /* If we are just trying suggested register, we have just tried copy-\n      suggested registers, and there are arithmetic-suggested registers,\n      try them.  */"}, {"sha": "5a8d8bf460f845e291f0f131ea39dafc608f9372", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -2485,9 +2485,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n       /* By now, the only difference should be the order of the stack,\n \t not their depth or liveliness.  */\n \n-      GO_IF_HARD_REG_EQUAL (old->reg_set, new->reg_set, win);\n-      gcc_unreachable ();\n-    win:\n+      gcc_assert (hard_reg_set_equal_p (old->reg_set, new->reg_set));\n       gcc_assert (old->top == new->top);\n \n       /* If the stack is not empty (new->top != -1), loop here emitting\n@@ -2955,9 +2953,8 @@ convert_regs_1 (basic_block block)\n   /* Something failed if the stack lives don't match.  If we had malformed\n      asms, we zapped the instruction itself, but that didn't produce the\n      same pattern of register kills as before.  */\n-  GO_IF_HARD_REG_EQUAL (regstack.reg_set, bi->out_reg_set, win);\n-  gcc_assert (any_malformed_asm);\n- win:\n+  gcc_assert (hard_reg_set_equal_p (regstack.reg_set, bi->out_reg_set)\n+\t      || any_malformed_asm);\n   bi->stack_out = regstack;\n   bi->done = true;\n }"}, {"sha": "1067f9384d52fc55e450b51ba4a6a77bc07ad2db", "filename": "gcc/regclass.c", "status": "modified", "additions": 30, "deletions": 56, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -338,20 +338,11 @@ init_reg_sets_1 (void)\n \t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n-\t    {\n-\t      GO_IF_HARD_REG_SUBSET (reg_class_contents[k], c,\n-\t\t\t\t     subclass1);\n-\t      continue;\n-\n-\t    subclass1:\n-\t      /* Keep the largest subclass.  */\t\t/* SPEE 900308 */\n-\t      GO_IF_HARD_REG_SUBSET (reg_class_contents[k],\n-\t\t\t\t     reg_class_contents[(int) reg_class_subunion[i][j]],\n-\t\t\t\t     subclass2);\n+\t    if (hard_reg_set_subset_p (reg_class_contents[k], c)\n+\t\t&& !hard_reg_set_subset_p (reg_class_contents[k],\n+\t\t\t\t\t  reg_class_contents\n+\t\t\t\t\t  [(int) reg_class_subunion[i][j]]))\n \t      reg_class_subunion[i][j] = (enum reg_class) k;\n-\t    subclass2:\n-\t      ;\n-\t    }\n \t}\n     }\n \n@@ -369,9 +360,9 @@ init_reg_sets_1 (void)\n \t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n-\t    GO_IF_HARD_REG_SUBSET (c, reg_class_contents[k], superclass);\n+\t    if (hard_reg_set_subset_p (c, reg_class_contents[k]))\n+\t      break;\n \n-\tsuperclass:\n \t  reg_class_superunion[i][j] = (enum reg_class) k;\n \t}\n     }\n@@ -394,23 +385,21 @@ init_reg_sets_1 (void)\n \tcontinue;\n \n       for (j = i + 1; j < N_REG_CLASSES; j++)\n-\t{\n-\t  enum reg_class *p;\n-\n-\t  GO_IF_HARD_REG_SUBSET (reg_class_contents[i], reg_class_contents[j],\n-\t\t\t\t subclass);\n-\t  continue;\n-\tsubclass:\n-\t  /* Reg class I is a subclass of J.\n-\t     Add J to the table of superclasses of I.  */\n-\t  p = &reg_class_superclasses[i][0];\n-\t  while (*p != LIM_REG_CLASSES) p++;\n-\t  *p = (enum reg_class) j;\n-\t  /* Add I to the table of superclasses of J.  */\n-\t  p = &reg_class_subclasses[j][0];\n-\t  while (*p != LIM_REG_CLASSES) p++;\n-\t  *p = (enum reg_class) i;\n-\t}\n+\tif (hard_reg_set_subset_p (reg_class_contents[i],\n+\t\t\t\t  reg_class_contents[j]))\n+\t  {\n+\t    /* Reg class I is a subclass of J.\n+\t       Add J to the table of superclasses of I.  */\n+\t    enum reg_class *p;\n+\n+\t    p = &reg_class_superclasses[i][0];\n+\t    while (*p != LIM_REG_CLASSES) p++;\n+\t    *p = (enum reg_class) j;\n+\t    /* Add I to the table of superclasses of J.  */\n+\t    p = &reg_class_subclasses[j][0];\n+\t    while (*p != LIM_REG_CLASSES) p++;\n+\t    *p = (enum reg_class) i;\n+\t  }\n     }\n \n   /* Initialize \"constant\" tables.  */\n@@ -2502,37 +2491,22 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n int\n reg_class_subset_p (enum reg_class c1, enum reg_class c2)\n {\n-  if (c1 == c2) return 1;\n-\n-  if (c2 == ALL_REGS)\n-  win:\n-    return 1;\n-  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) c1],\n-\t\t\t reg_class_contents[(int) c2],\n-\t\t\t win);\n-  return 0;\n+  return (c1 == c2\n+\t  || c2 == ALL_REGS\n+\t  || hard_reg_set_subset_p (reg_class_contents[(int) c1],\n+\t\t\t\t   reg_class_contents[(int) c2]));\n }\n \n /* Return nonzero if there is a register that is in both C1 and C2.  */\n \n int\n reg_classes_intersect_p (enum reg_class c1, enum reg_class c2)\n {\n-  HARD_REG_SET c;\n-\n-  if (c1 == c2) return 1;\n-\n-  if (c1 == ALL_REGS || c2 == ALL_REGS)\n-    return 1;\n-\n-  COPY_HARD_REG_SET (c, reg_class_contents[(int) c1]);\n-  AND_HARD_REG_SET (c, reg_class_contents[(int) c2]);\n-\n-  GO_IF_HARD_REG_SUBSET (c, reg_class_contents[(int) NO_REGS], lose);\n-  return 1;\n-\n- lose:\n-  return 0;\n+  return (c1 == c2\n+\t  || c1 == ALL_REGS\n+\t  || c2 == ALL_REGS\n+\t  || hard_reg_set_intersect_p (reg_class_contents[(int) c1],\n+\t\t\t\t      reg_class_contents[(int) c2]));\n }\n \n #ifdef CANNOT_CHANGE_MODE_CLASS"}, {"sha": "4d0251db923e7078c16710c5a247b45966212135", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -3891,9 +3891,8 @@ finish_spills (int global)\n \t  AND_HARD_REG_SET (chain->used_spill_regs, used_spill_regs);\n \n \t  /* Make sure we only enlarge the set.  */\n-\t  GO_IF_HARD_REG_SUBSET (used_by_pseudos2, chain->used_spill_regs, ok);\n-\t  gcc_unreachable ();\n-\tok:;\n+\t  gcc_assert (hard_reg_set_subset_p (used_by_pseudos2,\n+\t\t\t\t\t    chain->used_spill_regs));\n \t}\n     }\n "}, {"sha": "c37378e457d3071e10dfafe0c017fb274804ad04", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b138aed218de6e61416f2615424800ff7a0d18/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=56b138aed218de6e61416f2615424800ff7a0d18", "patch": "@@ -865,12 +865,8 @@ death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n \t    SET_HARD_REG_BIT (i2_regset, regno);\n \t  }\n \n-      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n-\n-      return false;\n-\n-    done:\n-      ;\n+      if (!hard_reg_set_equal_p (i1_regset, i2_regset))\n+\treturn false;\n     }\n #endif\n   return true;"}]}