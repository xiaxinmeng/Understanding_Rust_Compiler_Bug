{"sha": "8a8d1a16c7a355304ad77a873eda56d5fca915e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4ZDFhMTZjN2EzNTUzMDRhZDc3YTg3M2VkYTU2ZDVmY2E5MTVlOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-05-08T17:00:07Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-05-08T17:00:07Z"}, "message": "gfortran.h (gfc_isym_id): Add GFC_ISYM_CAF_GET and GFC_ISYM_CAF_SEND.\n\n2014-05-08  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.h (gfc_isym_id): Add GFC_ISYM_CAF_GET\n        and GFC_ISYM_CAF_SEND.\n        * intrinsic.c (add_functions): Add only internally\n        accessible caf_get and caf_send functions.\n        * resolve.c (add_caf_get_intrinsic,\n        remove_caf_get_intrinsic): New functions.\n        (resolve_variable): Resolve expression rank and\n        prepare for add_caf_get_intrinsic call.\n        (gfc_resolve_expr): For variables, remove rank\n        resolution.\n        (resolve_ordinary_assign): Prepare call to\n        GFC_ISYM_CAF_SEND.\n        (resolve_code): Avoid call to GFC_ISYM_CAF_GET for\n        the LHS of an assignment.\n\nFrom-SVN: r210225", "tree": {"sha": "f2d0daef2d098f751fcd083d8e97e0c3481625f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2d0daef2d098f751fcd083d8e97e0c3481625f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a8d1a16c7a355304ad77a873eda56d5fca915e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8d1a16c7a355304ad77a873eda56d5fca915e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8d1a16c7a355304ad77a873eda56d5fca915e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8d1a16c7a355304ad77a873eda56d5fca915e8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c980a137cc7c86dc7a0bf67149af3d3b8ca5367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c980a137cc7c86dc7a0bf67149af3d3b8ca5367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c980a137cc7c86dc7a0bf67149af3d3b8ca5367"}], "stats": {"total": 123, "additions": 115, "deletions": 8}, "files": [{"sha": "45c09a13515533252efc75217acba2892b10a9dc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8a8d1a16c7a355304ad77a873eda56d5fca915e8", "patch": "@@ -1,3 +1,20 @@\n+2014-05-08  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_CAF_GET\n+\tand GFC_ISYM_CAF_SEND.\n+\t* intrinsic.c (add_functions): Add only internally\n+\taccessible caf_get and caf_send functions.\n+\t* resolve.c (add_caf_get_intrinsic,\n+\tremove_caf_get_intrinsic): New functions.\n+\t(resolve_variable): Resolve expression rank and\n+\tprepare for add_caf_get_intrinsic call.\n+\t(gfc_resolve_expr): For variables, remove rank\n+\tresolution.\n+\t(resolve_ordinary_assign): Prepare call to\n+\tGFC_ISYM_CAF_SEND.\n+\t(resolve_code): Avoid call to GFC_ISYM_CAF_GET for\n+\tthe LHS of an assignment.\n+\n 2014-05-08  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-intrinsic.c (conv_co_minmaxsum): Change condition style."}, {"sha": "d654d2ba97ce289fede7b0dcd743044426a37ec5", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8a8d1a16c7a355304ad77a873eda56d5fca915e8", "patch": "@@ -318,6 +318,8 @@ enum gfc_isym_id\n   GFC_ISYM_BLE,\n   GFC_ISYM_BLT,\n   GFC_ISYM_BTEST,\n+  GFC_ISYM_CAF_GET,\n+  GFC_ISYM_CAF_SEND,\n   GFC_ISYM_CEILING,\n   GFC_ISYM_CHAR,\n   GFC_ISYM_CHDIR,"}, {"sha": "4c2eaa5f72910094be4436a2877654f11d13c0dc", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=8a8d1a16c7a355304ad77a873eda56d5fca915e8", "patch": "@@ -2756,7 +2756,7 @@ add_functions (void)\n   make_generic (\"size\", GFC_ISYM_SIZE, GFC_STD_F95);\n \n   /* Obtain the stride for a given dimensions; to be used only internally.\n-     \"make_from_module\" makes inaccessible for external users.  */\n+     \"make_from_module\" makes it inaccessible for external users.  */\n   add_sym_2 (GFC_PREFIX (\"stride\"), GFC_ISYM_STRIDE, CLASS_INQUIRY, ACTUAL_NO,\n \t     BT_INTEGER, gfc_index_integer_kind, GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_stride,\n@@ -2994,6 +2994,13 @@ add_functions (void)\n \t     x, BT_UNKNOWN, 0, REQUIRED);\n \t\t\n   make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n+\n+  /* The following function is internally used for coarray libray functions.\n+     \"make_from_module\" makes it inaccessible for external users.  */\n+  add_sym_1 (GFC_PREFIX (\"caf_get\"), GFC_ISYM_CAF_GET, CLASS_IMPURE, ACTUAL_NO,\n+\t     BT_REAL, dr, GFC_STD_GNU, NULL, NULL, NULL,\n+\t     x, BT_REAL, dr, REQUIRED);\n+  make_from_module();\n }\n \n \n@@ -3235,6 +3242,15 @@ add_subroutines (void)\n \t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT,\n \t      errmsg, BT_CHARACTER, dc, OPTIONAL, INTENT_OUT);\n \n+  /* The following subroutine is internally used for coarray libray functions.\n+     \"make_from_module\" makes it inaccessible for external users.  */\n+  add_sym_2s (GFC_PREFIX (\"caf_send\"), GFC_ISYM_CAF_SEND, CLASS_IMPURE,\n+\t      BT_UNKNOWN, 0, GFC_STD_GNU, NULL, NULL, NULL,\n+\t      \"x\", BT_REAL, dr, REQUIRED, INTENT_OUT,\n+\t      \"y\", BT_REAL, dr, REQUIRED, INTENT_IN);\n+  make_from_module();\n+\n+\n   /* More G77 compatibility garbage.  */\n   add_sym_3s (\"alarm\", GFC_ISYM_ALARM, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_alarm_sub, NULL, gfc_resolve_alarm_sub,"}, {"sha": "241b85e4e96706ad8a41282e90a30c45ddd14ac9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8d1a16c7a355304ad77a873eda56d5fca915e8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8a8d1a16c7a355304ad77a873eda56d5fca915e8", "patch": "@@ -4730,6 +4730,50 @@ expression_rank (gfc_expr *e)\n }\n \n \n+static void\n+add_caf_get_intrinsic (gfc_expr *e)\n+{\n+  gfc_expr *wrapper, *tmp_expr;\n+  gfc_ref *ref;\n+  int n;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+      break;\n+  if (ref == NULL)\n+    return;\n+\n+  for (n = ref->u.ar.dimen; n < ref->u.ar.dimen + ref->u.ar.codimen; n++)\n+    if (ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n+      return;\n+\n+  tmp_expr = XCNEW (gfc_expr);\n+  *tmp_expr = *e;\n+  wrapper = gfc_build_intrinsic_call (gfc_current_ns, GFC_ISYM_CAF_GET,\n+\t\t\t\t      \"caf_get\", tmp_expr->where, 1, tmp_expr);\n+  wrapper->ts = e->ts;\n+  wrapper->rank = e->rank;\n+  if (e->rank)\n+    wrapper->shape = gfc_copy_shape (e->shape, e->rank);\n+  *e = *wrapper;\n+  free (wrapper);\n+}\n+\n+\n+static void\n+remove_caf_get_intrinsic (gfc_expr *e)\n+{\n+  gcc_assert (e->expr_type == EXPR_FUNCTION && e->value.function.isym\n+\t      && e->value.function.isym->id == GFC_ISYM_CAF_GET);\n+  gfc_expr *e2 = e->value.function.actual->expr;\n+  e->value.function.actual->expr =NULL;\n+  gfc_free_actual_arglist (e->value.function.actual);\n+  gfc_free_shape (&e->shape, e->rank);\n+  *e = *e2;\n+  free (e2);\n+}\n+\n+\n /* Resolve a variable expression.  */\n \n static bool\n@@ -5009,6 +5053,12 @@ resolve_variable (gfc_expr *e)\n \t}\n     }\n \n+  if (t)\n+    expression_rank (e);\n+\n+  if (0 && t && gfc_option.coarray == GFC_FCOARRAY_LIB && gfc_is_coindexed (e))\n+    add_caf_get_intrinsic (e);\n+\n   return t;\n }\n \n@@ -6092,11 +6142,7 @@ gfc_resolve_expr (gfc_expr *e)\n       if (check_host_association (e))\n \tt = resolve_function (e);\n       else\n-\t{\n-\t  t = resolve_variable (e);\n-\t  if (t)\n-\t    expression_rank (e);\n-\t}\n+\tt = resolve_variable (e);\n \n       if (e->ts.type == BT_CHARACTER && e->ts.u.cl == NULL && e->ref\n \t  && e->ref->type != REF_SUBSTRING)\n@@ -9214,15 +9260,36 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n       return false;\n     }\n \n+  bool lhs_coindexed = gfc_is_coindexed (lhs);\n+\n   /* F2008, Section 7.2.1.2.  */\n-  if (gfc_is_coindexed (lhs) && gfc_has_ultimate_allocatable (lhs))\n+  if (lhs_coindexed && gfc_has_ultimate_allocatable (lhs))\n     {\n       gfc_error (\"Coindexed variable must not have an allocatable ultimate \"\n \t\t \"component in assignment at %L\", &lhs->where);\n       return false;\n     }\n \n   gfc_check_assign (lhs, rhs, 1);\n+\n+  if (0 && lhs_coindexed && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    {\n+      code->op = EXEC_CALL;\n+      gfc_get_sym_tree (GFC_PREFIX (\"caf_send\"), ns, &code->symtree, true);\n+      code->resolved_sym = code->symtree->n.sym;\n+      code->resolved_sym->attr.flavor = FL_PROCEDURE;\n+      code->resolved_sym->attr.intrinsic = 1;\n+      code->resolved_sym->attr.subroutine = 1;\n+      code->resolved_isym = gfc_intrinsic_subroutine_by_id (GFC_ISYM_CAF_SEND);\n+      gfc_commit_symbol (code->resolved_sym);\n+      code->ext.actual = gfc_get_actual_arglist ();\n+      code->ext.actual->expr = lhs;\n+      code->ext.actual->next = gfc_get_actual_arglist ();\n+      code->ext.actual->next->expr = rhs;\n+      code->expr1 = NULL;\n+      code->expr2 = NULL;\n+    }\n+\n   return false;\n }\n \n@@ -9845,6 +9912,11 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (!t)\n \t    break;\n \n+\t  if (code->expr1->expr_type == EXPR_FUNCTION\n+\t      && code->expr1->value.function.isym\n+\t      && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)\n+\t    remove_caf_get_intrinsic (code->expr1);\n+\n \t  if (!gfc_check_vardef_context (code->expr1, false, false, false, \n \t\t\t\t\t _(\"assignment\")))\n \t    break;\n@@ -9858,7 +9930,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    }\n \n \t  /* F03 7.4.1.3 for non-allocatable, non-pointer components.  */\n-\t  if (code->expr1->ts.type == BT_DERIVED\n+\t  if (code->op != EXEC_CALL && code->expr1->ts.type == BT_DERIVED\n \t      && code->expr1->ts.u.derived->attr.defined_assign_comp)\n \t    generate_component_assignments (&code, ns);\n "}]}