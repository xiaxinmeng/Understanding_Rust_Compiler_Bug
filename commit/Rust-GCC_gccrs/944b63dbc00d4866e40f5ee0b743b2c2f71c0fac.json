{"sha": "944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0YjYzZGJjMDBkNDg2NmU0MGY1ZWUwYjc0M2IyYzJmNzFjMGZhYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-02-25T21:19:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-02-25T21:19:06Z"}, "message": "re PR c++/55877 (Anon visibility issues)\n\n\tPR c++/55877\n\t* decl2.c (no_linkage_error): Handle C++98 semantics.\n\t(reset_type_linkage): Move from decl.c.\n\t(reset_type_linkage_1, reset_type_linkage_2, bt_reset_linkage_1)\n\t(bt_reset_linkage_2, reset_decl_linkage): New.\n\t(tentative_decl_linkage): Factor out of expand_or_defer_fn_1.\n\t(cp_write_global_declarations): Move condition into no_linkage_error.\n\t* decl.c (grokfndecl, grokvardecl): Use no_linkage_error.\n\t* semantics.c (expand_or_defer_fn_1): Factor out\n\ttentative_decl_linkage.\n\t* cp-tree.h: Adjust.\n\nFrom-SVN: r208157", "tree": {"sha": "8e1328e1336c9af40c2714b3596faa9091015d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1328e1336c9af40c2714b3596faa9091015d87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6659b552d17639829425eef63e5a9569049f371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6659b552d17639829425eef63e5a9569049f371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6659b552d17639829425eef63e5a9569049f371"}], "stats": {"total": 376, "additions": 272, "deletions": 104}, "files": [{"sha": "c4a81771a5b79596dbbc97c81f3219dcbb0b6f3e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -1,5 +1,17 @@\n 2014-02-25  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/55877\n+\t* decl2.c (no_linkage_error): Handle C++98 semantics.\n+\t(reset_type_linkage): Move from decl.c.\n+\t(reset_type_linkage_1, reset_type_linkage_2, bt_reset_linkage_1)\n+\t(bt_reset_linkage_2, reset_decl_linkage): New.\n+\t(tentative_decl_linkage): Factor out of expand_or_defer_fn_1.\n+\t(cp_write_global_declarations): Move condition into no_linkage_error.\n+\t* decl.c (grokfndecl, grokvardecl): Use no_linkage_error.\n+\t* semantics.c (expand_or_defer_fn_1): Factor out\n+\ttentative_decl_linkage.\n+\t* cp-tree.h: Adjust.\n+\n \t* decl2.c (finish_static_data_member_decl): Diagnose static data\n \tmember in unnamed class.\n \t* class.c (finish_struct_anon_r): Avoid redundant diagnostic."}, {"sha": "3db18f3eaecd4914f99be94d649614f58225988c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -5313,12 +5313,15 @@ extern tree coerce_delete_type\t\t\t(tree);\n extern void comdat_linkage\t\t\t(tree);\n extern void determine_visibility\t\t(tree);\n extern void constrain_class_visibility\t\t(tree);\n+extern void reset_type_linkage\t\t\t(tree);\n+extern void tentative_decl_linkage\t\t(tree);\n extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool decl_constant_var_p\t\t\t(tree);\n extern bool decl_maybe_constant_var_p\t\t(tree);\n+extern void no_linkage_error\t\t\t(tree);\n extern void check_default_args\t\t\t(tree);\n extern bool mark_used\t\t\t\t(tree);\n extern bool mark_used\t\t\t        (tree, tsubst_flags_t);"}, {"sha": "db86d97278396f7f3e5eacb3291591adcfd6d5ef", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 68, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -7569,29 +7569,7 @@ grokfndecl (tree ctype,\n \t declare an entity with linkage.\n \n \t DR 757 relaxes this restriction for C++0x.  */\n-      t = no_linkage_check (TREE_TYPE (decl),\n-\t\t\t    /*relaxed_p=*/false);\n-      if (t)\n-\t{\n-\t  if (TYPE_ANONYMOUS_P (t))\n-\t    {\n-\t      if (DECL_EXTERN_C_P (decl))\n-\t\t/* Allow this; it's pretty common in C.  */;\n-\t      else\n-\t\t{\n-\t\t  permerror (input_location, \"anonymous type with no linkage \"\n-\t\t\t     \"used to declare function %q#D with linkage\",\n-\t\t\t     decl);\n-\t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    permerror (input_location, \"%q+#D does not refer to the unqualified \"\n-\t\t\t       \"type, so it is not used for linkage\",\n-\t\t\t       TYPE_NAME (t));\n-\t\t}\n-\t    }\n-\t  else\n-\t    permerror (input_location, \"type %qT with no linkage used to \"\n-\t\t       \"declare function %q#D with linkage\", t, decl);\n-\t}\n+      no_linkage_error (decl);\n     }\n \n   TREE_PUBLIC (decl) = publicp;\n@@ -7874,7 +7852,7 @@ set_linkage_for_static_data_member (tree decl)\n \n    If SCOPE is non-NULL, it is the class type or namespace containing\n    the variable.  If SCOPE is NULL, the variable should is created in\n-   the innermost enclosings scope.  */\n+   the innermost enclosing scope.  */\n \n static tree\n grokvardecl (tree type,\n@@ -7972,33 +7950,8 @@ grokvardecl (tree type,\n \t declare an entity with linkage.\n \n \t DR 757 relaxes this restriction for C++0x.  */\n-      tree t = (cxx_dialect > cxx98 ? NULL_TREE\n-\t\t: no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false));\n-      if (t)\n-\t{\n-\t  if (TYPE_ANONYMOUS_P (t))\n-\t    {\n-\t      if (DECL_EXTERN_C_P (decl))\n-\t\t/* Allow this; it's pretty common in C.  */\n-\t\t;\n-\t      else\n-\t\t{\n-\t\t  /* DRs 132, 319 and 389 seem to indicate types with\n-\t\t     no linkage can only be used to declare extern \"C\"\n-\t\t     entities.  Since it's not always an error in the\n-\t\t     ISO C++ 90 Standard, we only issue a warning.  */\n-\t\t  warning (0, \"anonymous type with no linkage used to declare \"\n-\t\t\t   \"variable %q#D with linkage\", decl);\n-\t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    warning (0, \"%q+#D does not refer to the unqualified \"\n-\t\t\t     \"type, so it is not used for linkage\",\n-\t\t\t     TYPE_NAME (t));\n-\t\t}\n-\t    }\n-\t  else\n-\t    warning (0, \"type %qT with no linkage used to declare variable \"\n-\t\t     \"%q#D with linkage\", t, decl);\n-\t}\n+      if (cxx_dialect < cxx11)\n+\tno_linkage_error (decl);\n     }\n   else\n     DECL_INTERFACE_KNOWN (decl) = 1;\n@@ -8670,23 +8623,6 @@ check_var_type (tree identifier, tree type)\n   return type;\n }\n \n-/* Functions for adjusting the visibility of a tagged type and its nested\n-   types when it gets a name for linkage purposes from a typedef.  */\n-\n-static void bt_reset_linkage (binding_entry, void *);\n-static void\n-reset_type_linkage (tree type)\n-{\n-  set_linkage_according_to_type (type, TYPE_MAIN_DECL (type));\n-  if (CLASS_TYPE_P (type))\n-    binding_table_foreach (CLASSTYPE_NESTED_UTDS (type), bt_reset_linkage, NULL);\n-}\n-static void\n-bt_reset_linkage (binding_entry b, void */*data*/)\n-{\n-  reset_type_linkage (b->type);\n-}\n-\n /* Given declspecs and a declarator (abstract or otherwise), determine\n    the name and type of the object declared and construct a DECL node\n    for it."}, {"sha": "1afe16ee949e862c0c8c52ff35188897eccc25d9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 166, "deletions": 14, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -2475,6 +2475,125 @@ constrain_class_visibility (tree type)\n     }\n }\n \n+/* Functions for adjusting the visibility of a tagged type and its nested\n+   types and declarations when it gets a name for linkage purposes from a\n+   typedef.  */\n+\n+static void bt_reset_linkage_1 (binding_entry, void *);\n+static void bt_reset_linkage_2 (binding_entry, void *);\n+\n+/* First reset the visibility of all the types.  */\n+\n+static void\n+reset_type_linkage_1 (tree type)\n+{\n+  set_linkage_according_to_type (type, TYPE_MAIN_DECL (type));\n+  if (CLASS_TYPE_P (type))\n+    binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),\n+\t\t\t   bt_reset_linkage_1, NULL);\n+}\n+static void\n+bt_reset_linkage_1 (binding_entry b, void */*data*/)\n+{\n+  reset_type_linkage_1 (b->type);\n+}\n+\n+/* Then reset the visibility of any static data members or member\n+   functions that use those types.  */\n+\n+static void\n+reset_decl_linkage (tree decl)\n+{\n+  if (TREE_PUBLIC (decl))\n+    return;\n+  if (DECL_CLONED_FUNCTION_P (decl))\n+    return;\n+  TREE_PUBLIC (decl) = true;\n+  DECL_INTERFACE_KNOWN (decl) = false;\n+  determine_visibility (decl);\n+  tentative_decl_linkage (decl);\n+}\n+static void\n+reset_type_linkage_2 (tree type)\n+{\n+  if (CLASS_TYPE_P (type))\n+    {\n+      if (tree vt = CLASSTYPE_VTABLES (type))\n+\t{\n+\t  tree name = mangle_vtbl_for_type (type);\n+\t  DECL_NAME (vt) = name;\n+\t  SET_DECL_ASSEMBLER_NAME (vt, name);\n+\t  reset_decl_linkage (vt);\n+\t}\n+      if (tree ti = CLASSTYPE_TYPEINFO_VAR (type))\n+\t{\n+\t  tree name = mangle_typeinfo_for_type (type);\n+\t  DECL_NAME (ti) = name;\n+\t  SET_DECL_ASSEMBLER_NAME (ti, name);\n+\t  TREE_TYPE (name) = type;\n+\t  reset_decl_linkage (ti);\n+\t}\n+      for (tree m = TYPE_FIELDS (type); m; m = DECL_CHAIN (m))\n+\tif (TREE_CODE (m) == VAR_DECL)\n+\t  reset_decl_linkage (m);\n+      for (tree m = TYPE_METHODS (type); m; m = DECL_CHAIN (m))\n+\treset_decl_linkage (m);\n+      binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),\n+\t\t\t     bt_reset_linkage_2, NULL);\n+    }\n+}\n+static void\n+bt_reset_linkage_2 (binding_entry b, void */*data*/)\n+{\n+  reset_type_linkage_2 (b->type);\n+}\n+void\n+reset_type_linkage (tree type)\n+{\n+  reset_type_linkage_1 (type);\n+  reset_type_linkage_2 (type);\n+}\n+\n+/* Set up our initial idea of what the linkage of DECL should be.  */\n+\n+void\n+tentative_decl_linkage (tree decl)\n+{\n+  if (DECL_INTERFACE_KNOWN (decl))\n+    /* We've already made a decision as to how this function will\n+       be handled.  */;\n+  else if (vague_linkage_p (decl))\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  DECL_EXTERNAL (decl) = 1;\n+\t  DECL_NOT_REALLY_EXTERN (decl) = 1;\n+\t  note_vague_linkage_fn (decl);\n+\t  /* A non-template inline function with external linkage will\n+\t     always be COMDAT.  As we must eventually determine the\n+\t     linkage of all functions, and as that causes writes to\n+\t     the data mapped in from the PCH file, it's advantageous\n+\t     to mark the functions at this point.  */\n+\t  if (DECL_DECLARED_INLINE_P (decl)\n+\t      && (!DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t  || DECL_DEFAULTED_FN (decl)))\n+\t    {\n+\t      /* This function must have external linkage, as\n+\t\t otherwise DECL_INTERFACE_KNOWN would have been\n+\t\t set.  */\n+\t      gcc_assert (TREE_PUBLIC (decl));\n+\t      comdat_linkage (decl);\n+\t      DECL_INTERFACE_KNOWN (decl) = 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+\t  maybe_commonize_var (decl);\n+\t}\n+    }\n+}\n+\n /* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage\n    for DECL has not already been determined, do so now by setting\n    DECL_EXTERNAL, DECL_COMDAT and other related flags.  Until this\n@@ -3966,23 +4085,57 @@ decl_maybe_constant_var_p (tree decl)\n \t  && INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n }\n \n-/* Complain that DECL uses a type with no linkage but is never defined.  */\n+/* Complain that DECL uses a type with no linkage.  In C++98 mode this is\n+   called from grokfndecl and grokvardecl; in all modes it is called from\n+   cp_write_global_declarations.  */\n \n-static void\n+void\n no_linkage_error (tree decl)\n {\n+  if (cxx_dialect >= cxx11 && decl_defined_p (decl))\n+    /* In C++11 it's ok if the decl is defined.  */\n+    return;\n   tree t = no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false);\n-  if (TYPE_ANONYMOUS_P (t))\n-    {\n-      permerror (0, \"%q+#D, declared using anonymous type, \"\n-\t\t \"is used but never defined\", decl);\n-      if (is_typedef_decl (TYPE_NAME (t)))\n-\tpermerror (0, \"%q+#D does not refer to the unqualified type, \"\n-\t\t   \"so it is not used for linkage\", TYPE_NAME (t));\n-    }\n+  if (t == NULL_TREE)\n+    /* The type that got us on no_linkage_decls must have gotten a name for\n+       linkage purposes.  */;\n+  else if (CLASS_TYPE_P (t) && TYPE_BEING_DEFINED (t))\n+    /* The type might end up having a typedef name for linkage purposes.  */\n+    vec_safe_push (no_linkage_decls, decl);\n+  else if (TYPE_ANONYMOUS_P (t))\n+    {\n+      bool d = false;\n+      if (cxx_dialect >= cxx11)\n+\td = permerror (DECL_SOURCE_LOCATION (decl), \"%q#D, declared using \"\n+\t\t       \"anonymous type, is used but never defined\", decl);\n+      else if (DECL_EXTERN_C_P (decl))\n+\t/* Allow this; it's pretty common in C.  */;\n+      else if (TREE_CODE (decl) == VAR_DECL)\n+\t/* DRs 132, 319 and 389 seem to indicate types with\n+\t   no linkage can only be used to declare extern \"C\"\n+\t   entities.  Since it's not always an error in the\n+\t   ISO C++ 90 Standard, we only issue a warning.  */\n+\td = warning_at (DECL_SOURCE_LOCATION (decl), 0, \"anonymous type \"\n+\t\t\t\"with no linkage used to declare variable %q#D with \"\n+\t\t\t\"linkage\", decl);\n+      else\n+\td = permerror (DECL_SOURCE_LOCATION (decl), \"anonymous type with no \"\n+\t\t       \"linkage used to declare function %q#D with linkage\",\n+\t\t       decl);\n+      if (d && is_typedef_decl (TYPE_NAME (t)))\n+\tinform (DECL_SOURCE_LOCATION (TYPE_NAME (t)), \"%q#D does not refer \"\n+\t\t\"to the unqualified type, so it is not used for linkage\",\n+\t\tTYPE_NAME (t));\n+    }\n+  else if (cxx_dialect >= cxx11)\n+    permerror (DECL_SOURCE_LOCATION (decl), \"%q#D, declared using local type \"\n+\t       \"%qT, is used but never defined\", decl, t);\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    warning_at (DECL_SOURCE_LOCATION (decl), 0, \"type %qT with no linkage \"\n+\t\t\"used to declare variable %q#D with linkage\", t, decl);\n   else\n-    permerror (0, \"%q+#D, declared using local type %qT, \"\n-\t       \"is used but never defined\", decl, t);\n+    permerror (DECL_SOURCE_LOCATION (decl), \"type %qT with no linkage used \"\n+\t       \"to declare function %q#D with linkage\", t, decl);\n }\n \n /* Collect declarations from all namespaces relevant to SOURCE_FILE.  */\n@@ -4407,8 +4560,7 @@ cp_write_global_declarations (void)\n \n   /* So must decls that use a type with no linkage.  */\n   FOR_EACH_VEC_SAFE_ELT (no_linkage_decls, i, decl)\n-    if (!decl_defined_p (decl))\n-      no_linkage_error (decl);\n+    no_linkage_error (decl);\n \n   /* Then, do the Objective-C stuff.  This is where all the\n      Objective-C module stuff gets generated (symtab,"}, {"sha": "9c1c29d28e4e12e6dca19f729f0491975c70267a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -3977,25 +3977,7 @@ expand_or_defer_fn_1 (tree fn)\n \t/* We've already made a decision as to how this function will\n \t   be handled.  */;\n       else if (!at_eof)\n-\t{\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  DECL_NOT_REALLY_EXTERN (fn) = 1;\n-\t  note_vague_linkage_fn (fn);\n-\t  /* A non-template inline function with external linkage will\n-\t     always be COMDAT.  As we must eventually determine the\n-\t     linkage of all functions, and as that causes writes to\n-\t     the data mapped in from the PCH file, it's advantageous\n-\t     to mark the functions at this point.  */\n-\t  if (!DECL_IMPLICIT_INSTANTIATION (fn) || DECL_DEFAULTED_FN (fn))\n-\t    {\n-\t      /* This function must have external linkage, as\n-\t\t otherwise DECL_INTERFACE_KNOWN would have been\n-\t\t set.  */\n-\t      gcc_assert (TREE_PUBLIC (fn));\n-\t      comdat_linkage (fn);\n-\t      DECL_INTERFACE_KNOWN (fn) = 1;\n-\t    }\n-\t}\n+\ttentative_decl_linkage (fn);\n       else\n \timport_export_decl (fn);\n "}, {"sha": "a818b70e5a94070e413fbfca77f7a0e1537b3ce9", "filename": "gcc/testsuite/g++.dg/abi/anon2.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon2.C?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -0,0 +1,66 @@\n+// PR c++/55877\n+// { dg-require-weak \"\" }\n+\n+namespace N1 {\n+  typedef struct {\n+    typedef enum { X, Y } A;\n+    typedef struct { } B;\n+    struct C {\n+      // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N11D1C3fn1ENS0_1BE\" } }\n+      static void fn1 (B) { }\n+      // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N11D1C3fn2ES1_\" } }\n+      static void fn2 (C) { }\n+    };\n+  } D;\n+\n+  void *p = (void *) D::C::fn1;\n+  void *q = (void *) D::C::fn2;\n+}\n+\n+namespace N2 {\n+  typedef struct {\n+    typedef enum { X, Y } A;\n+    typedef struct { } B;\n+    struct C {\n+      // { dg-final { scan-assembler-not \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N23._31C3fn1ENS0_1BE\" } }\n+      static void fn1 (B) { } // { dg-error \"no linkage\" \"\" { target c++98 } }\n+      // { dg-final { scan-assembler-not \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N23._31C3fn2ES1_\" } }\n+      static void fn2 (C) { } // { dg-error \"no linkage\" \"\" { target c++98 } }\n+    };\n+  } const D;\n+\n+  void *p = (void *) D::C::fn1;\n+  void *q = (void *) D::C::fn2;\n+}\n+\n+namespace N3 {\n+  typedef struct {\n+    typedef enum { X, Y } A;\n+    typedef struct { } B;\n+    template <class T> struct C {\n+      // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N31D1CIiE3fn1ENS0_1BE\" } }\n+      static void fn1 (B) { }\n+      // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N31D1CIiE3fn2ES2_\" } }\n+      static void fn2 (C) { }\n+    };\n+  } D;\n+\n+  void *p = (void *) D::C<int>::fn1;\n+  void *q = (void *) D::C<int>::fn2;\n+}\n+\n+namespace N4 {\n+  typedef struct {\n+    typedef enum { X, Y } A;\n+    typedef struct { } B;\n+    template <class T> struct C {\n+      // { dg-final { scan-assembler-not \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N43._91CIiE3fn1ENS0_1BE\" } }\n+      static void fn1 (B) { } // { not-dg-error \"no linkage\" \"\" { target c++98 } }\n+      // { dg-final { scan-assembler-not \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN2N43._91CIiE3fn2ES2_\" } }\n+      static void fn2 (C) { } // { not-dg-error \"no linkage\" \"\" { target c++98 } }\n+    };\n+  } const D;\n+\n+  void *p = (void *) D::C<int>::fn1;\n+  void *q = (void *) D::C<int>::fn2;\n+}"}, {"sha": "623c7f5c6e1751c803d3f4671baecac5ebc79fb5", "filename": "gcc/testsuite/g++.dg/abi/anon3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon3.C?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -0,0 +1,19 @@\n+// { dg-require-weak \"\" }\n+\n+typedef struct {\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN4Heya4blahEv\" } }\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZTI4Heya\" } }\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZTV4Heya\" } }\n+  virtual const char *blah() {\n+    return \"Heya::blah\";\n+  }\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZN4Heya1A1fEv\" } }\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZTIN4Heya1AE\" } }\n+  // { dg-final { scan-assembler \".weak\\(_definition\\)?\\[ \\t\\]_?_ZTVN4Heya1AE\" } }\n+  struct A {\n+    virtual void f() { }\n+  };\n+} Heya;\n+\n+Heya h;\n+Heya::A a;"}, {"sha": "6c4874b21380a356fef34981166426848c51755b", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/linkage1.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Flinkage1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Flinkage1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Flinkage1.C?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -11,8 +11,6 @@\n // checking that another translation unit can call it.  We don't do\n // the right things on functions, but we do on data members.\n \n-// { dg-bogus \"\" \"\" { xfail *-*-* } 0 }\n-\n typedef struct {\n   void f();\n } S;"}, {"sha": "acb4f460608b358605feff3798a8095d6471b673", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944b63dbc00d4866e40f5ee0b743b2c2f71c0fac/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C?ref=944b63dbc00d4866e40f5ee0b743b2c2f71c0fac", "patch": "@@ -2,5 +2,5 @@\n // Test that we properly diagnose an attempt to use an anonymous class\n // in declaring an external function.\n \n-typedef const struct { int i; } T; // { dg-error \"\" } referenced below\n+typedef const struct { int i; } T; // { dg-message \"\" } referenced below\n void f (T* t);\t\t\t// { dg-error \"\" } uses unnamed type"}]}