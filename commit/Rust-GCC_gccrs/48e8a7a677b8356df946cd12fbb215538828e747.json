{"sha": "48e8a7a677b8356df946cd12fbb215538828e747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlOGE3YTY3N2I4MzU2ZGY5NDZjZDEyZmJiMjE1NTM4ODI4ZTc0Nw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-07T23:29:30Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-07T23:29:30Z"}, "message": "analyzer: remove add_any_constraints_from_ssa_def_stmt\n\nI'm working on reimplementing -Wanalyzer-use-of-uninitialized-value, but\nI ran into issues with\nregion_model::add_any_constraints_from_ssa_def_stmt.\nThis function is from the initial commit of the analyzer and walks the\nSSA names finding conditions that were missed due to the GCC 10 era\nregion_model not retaining useful information on how values were\ncreated; as of GCC 11 the symbolic values contain this information,\nand so the conditions can be reconstructed from them instead.\n\nregion_model::add_any_constraints_from_ssa_def_stmt is a liability\nwhen tracking uninitialized values as it requires looking up SSA\nvalues when those values may have been purged, thus greatly complicating\ndetection of uses of uninitialized values.\n\nIt's simplest to eliminate it and reimplement the condition-finding\nvia the makeup of the svalues, which this patch does.  Doing so requires\nsupporting add_condition on svalues rather than just on trees, which\nrequires some changes to ana::state_machine and its subclasses.\n\ngcc/analyzer/ChangeLog:\n\t* diagnostic-manager.cc (null_assignment_sm_context::get_state):\n\tNew overload.\n\t(null_assignment_sm_context::set_next_state): New overload.\n\t(null_assignment_sm_context::get_diagnostic_tree): New.\n\t* engine.cc (impl_sm_context::get_state): New overload.\n\t(impl_sm_context::set_next_state): New overload.\n\t(impl_sm_context::get_diagnostic_tree): New overload.\n\t(impl_region_model_context::on_condition): Convert params from\n\ttree to const svalue *.\n\t* exploded-graph.h (impl_region_model_context::on_condition):\n\tLikewise.\n\t* region-model.cc (region_model::on_call_pre): Move handling of\n\tinternal calls to before checking for get_fndecl_for_call.\n\t(region_model::add_constraints_from_binop): New.\n\t(region_model::add_constraint): Split out into a new overload\n\tworking on const svalue * rather than tree.  Call\n\tadd_constraints_from_binop.  Drop call to\n\tadd_any_constraints_from_ssa_def_stmt.\n\t(region_model::add_any_constraints_from_ssa_def_stmt): Delete.\n\t(region_model::add_any_constraints_from_gassign): Delete.\n\t(region_model::add_any_constraints_from_gcall): Delete.\n\t* region-model.h\n\t(region_model::add_any_constraints_from_ssa_def_stmt): Delete.\n\t(region_model::add_any_constraints_from_gassign): Delete.\n\t(region_model::add_any_constraints_from_gcall): Delete.\n\t(region_model::add_constraint): Add overload decl.\n\t(region_model::add_constraints_from_binop): New decl.\n\t(region_model_context::on_condition): Convert params from tree to\n\tconst svalue *.\n\t(noop_region_model_context::on_condition): Likewise.\n\t* sm-file.cc (fileptr_state_machine::condition): Likewise.\n\t* sm-malloc.cc (malloc_state_machine::on_condition): Likewise.\n\t* sm-pattern-test.cc: Include tristate.h, selftest.h,\n\tanalyzer/call-string.h, analyzer/program-point.h,\n\tanalyzer/store.h, and analyzer/region-model.h.\n\t(pattern_test_state_machine::on_condition): Convert params from tree to\n\tconst svalue *.\n\t* sm-sensitive.cc (sensitive_state_machine::on_condition): Delete.\n\t* sm-signal.cc (signal_state_machine::on_condition): Delete.\n\t* sm-taint.cc (taint_state_machine::on_condition): Convert params\n\tfrom tree to const svalue *.\n\t* sm.cc: Include tristate.h, selftest.h, analyzer/call-string.h,\n\tanalyzer/program-point.h, analyzer/store.h, and\n\tanalyzer/region-model.h.\n\t(any_pointer_p): Add overload taking const svalue *sval.\n\t* sm.h (any_pointer_p): Add overload taking const svalue *sval.\n\t(state_machine::on_condition): Convert params from tree to\n\tconst svalue *.  Provide no-op default implementation.\n\t(sm_context::get_state): Add overload taking const svalue *sval.\n\t(sm_context::set_next_state): Likewise.\n\t(sm_context::on_transition): Likewise.\n\t(sm_context::get_diagnostic_tree): Likewise.\n\t* svalue.cc (svalue::all_zeroes_p): New.\n\t(constant_svalue::all_zeroes_p): New.\n\t(repeated_svalue::all_zeroes_p): Convert to vfunc.\n\t* svalue.h (svalue::all_zeroes_p): New decl.\n\t(constant_svalue::all_zeroes_p): New decl.\n\t(repeated_svalue::all_zeroes_p): Convert decl to vfunc.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/pattern-test-2.c: Update expected results.\n\t* gcc.dg/plugin/analyzer_gil_plugin.c\n\t(gil_state_machine::on_condition): Remove.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "69ba331f17fc0cbe375d5e311f3327d465a41cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69ba331f17fc0cbe375d5e311f3327d465a41cfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48e8a7a677b8356df946cd12fbb215538828e747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e8a7a677b8356df946cd12fbb215538828e747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e8a7a677b8356df946cd12fbb215538828e747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e8a7a677b8356df946cd12fbb215538828e747/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a110855667782dac7b674d3e328b253b3b3c919b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a110855667782dac7b674d3e328b253b3b3c919b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a110855667782dac7b674d3e328b253b3b3c919b"}], "stats": {"total": 631, "additions": 361, "deletions": 270}, "files": [{"sha": "b7d263b42179d92340bed9fb133e9bc90419a6d7", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -1377,6 +1377,14 @@ struct null_assignment_sm_context : public sm_context\n     return current;\n   }\n \n+  state_machine::state_t get_state (const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t    const svalue *sval) FINAL OVERRIDE\n+  {\n+    const sm_state_map *old_smap = m_old_state->m_checker_states[m_sm_idx];\n+    state_machine::state_t current = old_smap->get_state (sval, m_ext_state);\n+    return current;\n+  }\n+\n   void set_next_state (const gimple *stmt,\n \t\t       tree var,\n \t\t       state_machine::state_t to,\n@@ -1401,6 +1409,28 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\t\t\t*m_new_state));\n   }\n \n+  void set_next_state (const gimple *stmt,\n+\t\t       const svalue *sval,\n+\t\t       state_machine::state_t to,\n+\t\t       tree origin ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+    state_machine::state_t from = get_state (stmt, sval);\n+    if (from != m_sm.get_start_state ())\n+      return;\n+\n+    const supernode *supernode = m_point->get_supernode ();\n+    int stack_depth = m_point->get_stack_depth ();\n+\n+    m_emission_path->add_event (new state_change_event (supernode,\n+\t\t\t\t\t\t\tm_stmt,\n+\t\t\t\t\t\t\tstack_depth,\n+\t\t\t\t\t\t\tm_sm,\n+\t\t\t\t\t\t\tsval,\n+\t\t\t\t\t\t\tfrom, to,\n+\t\t\t\t\t\t\tNULL,\n+\t\t\t\t\t\t\t*m_new_state));\n+  }\n+\n   void warn (const supernode *, const gimple *,\n \t     tree, pending_diagnostic *d) FINAL OVERRIDE\n   {\n@@ -1412,6 +1442,11 @@ struct null_assignment_sm_context : public sm_context\n     return expr;\n   }\n \n+  tree get_diagnostic_tree (const svalue *sval) FINAL OVERRIDE\n+  {\n+    return m_new_state->m_region_model->get_representative_tree (sval);\n+  }\n+\n   state_machine::state_t get_global_state () const FINAL OVERRIDE\n   {\n     return 0;"}, {"sha": "01b83a4ef282ec4feb8544477a84d7e00a0e80d6", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -245,6 +245,16 @@ class impl_sm_context : public sm_context\n       = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n     return current;\n   }\n+  state_machine::state_t get_state (const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t    const svalue *sval)\n+  {\n+    logger * const logger = get_logger ();\n+    LOG_FUNC (logger);\n+    state_machine::state_t current\n+      = m_old_smap->get_state (sval, m_eg.get_ext_state ());\n+    return current;\n+  }\n+\n \n   void set_next_state (const gimple *stmt,\n \t\t       tree var,\n@@ -280,6 +290,41 @@ class impl_sm_context : public sm_context\n \t\t\t   to, origin_new_sval, m_eg.get_ext_state ());\n   }\n \n+  void set_next_state (const gimple *stmt,\n+\t\t       const svalue *sval,\n+\t\t       state_machine::state_t to,\n+\t\t       tree origin)\n+  {\n+    logger * const logger = get_logger ();\n+    LOG_FUNC (logger);\n+    impl_region_model_context old_ctxt\n+      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n+       NULL, stmt);\n+\n+    impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n+\t\t\t\t\tm_old_state, m_new_state,\n+\t\t\t\t\tNULL,\n+\t\t\t\t\tstmt);\n+    const svalue *origin_new_sval\n+      = m_new_state->m_region_model->get_rvalue (origin, &new_ctxt);\n+\n+    state_machine::state_t current\n+      = m_old_smap->get_state (sval, m_eg.get_ext_state ());\n+    if (logger)\n+      {\n+\tlogger->start_log_line ();\n+\tlogger->log_partial (\"%s: state transition of \",\n+\t\t\t     m_sm.get_name ());\n+\tsval->dump_to_pp (logger->get_printer (), true);\n+\tlogger->log_partial (\": %s -> %s\",\n+\t\t\t     current->get_name (),\n+\t\t\t     to->get_name ());\n+\tlogger->end_log_line ();\n+      }\n+    m_new_smap->set_state (m_new_state->m_region_model, sval,\n+\t\t\t   to, origin_new_sval, m_eg.get_ext_state ());\n+  }\n+\n   void warn (const supernode *snode, const gimple *stmt,\n \t     tree var, pending_diagnostic *d) FINAL OVERRIDE\n   {\n@@ -323,6 +368,11 @@ class impl_sm_context : public sm_context\n       return expr;\n   }\n \n+  tree get_diagnostic_tree (const svalue *sval) FINAL OVERRIDE\n+  {\n+    return m_new_state->m_region_model->get_representative_tree (sval);\n+  }\n+\n   state_machine::state_t get_global_state () const FINAL OVERRIDE\n   {\n     return m_old_state->m_checker_states[m_sm_idx]->get_global_state ();\n@@ -654,7 +704,9 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n    state transitions.  */\n \n void\n-impl_region_model_context::on_condition (tree lhs, enum tree_code op, tree rhs)\n+impl_region_model_context::on_condition (const svalue *lhs,\n+\t\t\t\t\t enum tree_code op,\n+\t\t\t\t\t const svalue *rhs)\n {\n   int sm_idx;\n   sm_state_map *smap;"}, {"sha": "2d25e5e51678514479a73539f85e7fa374782498", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -59,7 +59,9 @@ class impl_region_model_context : public region_model_context\n \t\t      const svalue *sval,\n \t\t      state_machine::state_t state);\n \n-  void on_condition (tree lhs, enum tree_code op, tree rhs) FINAL OVERRIDE;\n+  void on_condition (const svalue *lhs,\n+\t\t     enum tree_code op,\n+\t\t     const svalue *rhs) FINAL OVERRIDE;\n \n   void on_unknown_change (const svalue *sval, bool is_mutable) FINAL OVERRIDE;\n "}, {"sha": "acbbd112543e2464ad0c5bde85f593e2bfef7800", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 154, "deletions": 150, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -881,12 +881,23 @@ bool\n region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t\t\t   bool *out_terminate_path)\n {\n+  call_details cd (call, this, ctxt);\n+\n   bool unknown_side_effects = false;\n \n-  if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n+  if (gimple_call_internal_p (call))\n     {\n-      call_details cd (call, this, ctxt);\n+      switch (gimple_call_internal_fn (call))\n+       {\n+       default:\n+\t break;\n+       case IFN_BUILTIN_EXPECT:\n+\t return impl_call_builtin_expect (cd);\n+       }\n+    }\n \n+  if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n+    {\n       /* The various impl_call_* member functions are implemented\n \t in region-model-impl-calls.cc.\n \t Having them split out into separate functions makes it easier\n@@ -958,16 +969,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t       on the return value.  */\n \t    break;\n \t  }\n-      else if (gimple_call_internal_p (call))\n-\tswitch (gimple_call_internal_fn (call))\n-\t  {\n-\t  default:\n-\t    if (!DECL_PURE_P (callee_fndecl))\n-\t      unknown_side_effects = true;\n-\t    break;\n-\t  case IFN_BUILTIN_EXPECT:\n-\t    return impl_call_builtin_expect (cd);\n-\t  }\n       else if (is_named_call_p (callee_fndecl, \"malloc\", call, 1))\n \treturn impl_call_malloc (cd);\n       else if (is_named_call_p (callee_fndecl, \"calloc\", call, 2))\n@@ -2251,6 +2252,123 @@ region_model::compare_initial_and_pointer (const initial_svalue *init,\n   return tristate::TS_UNKNOWN;\n }\n \n+/* Handle various constraints of the form:\n+     LHS: ((bool)INNER_LHS INNER_OP INNER_RHS))\n+     OP : == or !=\n+     RHS: zero\n+   and (with a cast):\n+     LHS: CAST([long]int, ((bool)INNER_LHS INNER_OP INNER_RHS))\n+     OP : == or !=\n+     RHS: zero\n+   by adding constraints for INNER_LHS INNEROP INNER_RHS.\n+\n+   Return true if this function can fully handle the constraint; if\n+   so, add the implied constraint(s) and write true to *OUT if they\n+   are consistent with existing constraints, or write false to *OUT\n+   if they contradicts existing constraints.\n+\n+   Return false for cases that this function doeesn't know how to handle.\n+\n+   For example, if we're checking a stored conditional, we'll have\n+   something like:\n+     LHS: CAST(long int, (&HEAP_ALLOCATED_REGION(8)!=(int *)0B))\n+     OP : NE_EXPR\n+     RHS: zero\n+   which this function can turn into an add_constraint of:\n+     (&HEAP_ALLOCATED_REGION(8) != (int *)0B)\n+\n+   Similarly, optimized && and || conditionals lead to e.g.\n+     if (p && q)\n+   becoming gimple like this:\n+     _1 = p_6 == 0B;\n+     _2 = q_8 == 0B\n+     _3 = _1 | _2\n+   On the \"_3 is false\" branch we can have constraints of the form:\n+     ((&HEAP_ALLOCATED_REGION(8)!=(int *)0B)\n+      | (&HEAP_ALLOCATED_REGION(10)!=(int *)0B))\n+     == 0\n+   which implies that both _1 and _2 are false,\n+   which this function can turn into a pair of add_constraints of\n+     (&HEAP_ALLOCATED_REGION(8)!=(int *)0B)\n+   and:\n+     (&HEAP_ALLOCATED_REGION(10)!=(int *)0B).  */\n+\n+bool\n+region_model::add_constraints_from_binop (const svalue *outer_lhs,\n+\t\t\t\t\t  enum tree_code outer_op,\n+\t\t\t\t\t  const svalue *outer_rhs,\n+\t\t\t\t\t  bool *out,\n+\t\t\t\t\t  region_model_context *ctxt)\n+{\n+  while (const svalue *cast = outer_lhs->maybe_undo_cast ())\n+    outer_lhs = cast;\n+  const binop_svalue *binop_sval = outer_lhs->dyn_cast_binop_svalue ();\n+  if (!binop_sval)\n+    return false;\n+  if (!outer_rhs->all_zeroes_p ())\n+    return false;\n+\n+  const svalue *inner_lhs = binop_sval->get_arg0 ();\n+  enum tree_code inner_op = binop_sval->get_op ();\n+  const svalue *inner_rhs = binop_sval->get_arg1 ();\n+\n+  if (outer_op != NE_EXPR && outer_op != EQ_EXPR)\n+    return false;\n+\n+  /* We have either\n+     - \"OUTER_LHS != false\" (i.e. OUTER is true), or\n+     - \"OUTER_LHS == false\" (i.e. OUTER is false).  */\n+  bool is_true = outer_op == NE_EXPR;\n+\n+  switch (inner_op)\n+    {\n+    default:\n+      return false;\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      {\n+\t/* ...and \"(inner_lhs OP inner_rhs) == 0\"\n+\t   then (inner_lhs OP inner_rhs) must have the same\n+\t   logical value as LHS.  */\n+\tif (!is_true)\n+\t  inner_op = invert_tree_comparison (inner_op, false /* honor_nans */);\n+\t*out = add_constraint (inner_lhs, inner_op, inner_rhs, ctxt);\n+\treturn true;\n+      }\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      if (is_true)\n+\t{\n+\t  /* ...and \"(inner_lhs & inner_rhs) != 0\"\n+\t     then both inner_lhs and inner_rhs must be true.  */\n+\t  const svalue *false_sval\n+\t    = m_mgr->get_or_create_constant_svalue (boolean_false_node);\n+\t  bool sat1 = add_constraint (inner_lhs, NE_EXPR, false_sval, ctxt);\n+\t  bool sat2 = add_constraint (inner_rhs, NE_EXPR, false_sval, ctxt);\n+\t  *out = sat1 && sat2;\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case BIT_IOR_EXPR:\n+      if (!is_true)\n+\t{\n+\t  /* ...and \"(inner_lhs | inner_rhs) == 0\"\n+\t     i.e. \"(inner_lhs | inner_rhs)\" is false\n+\t     then both inner_lhs and inner_rhs must be false.  */\n+\t  const svalue *false_sval\n+\t    = m_mgr->get_or_create_constant_svalue (boolean_false_node);\n+\t  bool sat1 = add_constraint (inner_lhs, EQ_EXPR, false_sval, ctxt);\n+\t  bool sat2 = add_constraint (inner_rhs, EQ_EXPR, false_sval, ctxt);\n+\t  *out = sat1 && sat2;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+}\n+\n /* Attempt to add the constraint \"LHS OP RHS\" to this region_model.\n    If it is consistent with existing constraints, add it, and return true.\n    Return false if it contradicts existing constraints.\n@@ -2268,7 +2386,21 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n   const svalue *lhs_sval = get_rvalue (lhs, ctxt);\n   const svalue *rhs_sval = get_rvalue (rhs, ctxt);\n \n-  tristate t_cond = eval_condition (lhs_sval, op, rhs_sval);\n+  return add_constraint (lhs_sval, op, rhs_sval, ctxt);\n+}\n+\n+/* Attempt to add the constraint \"LHS OP RHS\" to this region_model.\n+   If it is consistent with existing constraints, add it, and return true.\n+   Return false if it contradicts existing constraints.\n+   Use CTXT for reporting any diagnostics associated with the accesses.  */\n+\n+bool\n+region_model::add_constraint (const svalue *lhs,\n+\t\t\t      enum tree_code op,\n+\t\t\t      const svalue *rhs,\n+\t\t\t      region_model_context *ctxt)\n+{\n+  tristate t_cond = eval_condition (lhs, op, rhs);\n \n   /* If we already have the condition, do nothing.  */\n   if (t_cond.is_true ())\n@@ -2279,10 +2411,12 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n   if (t_cond.is_false ())\n     return false;\n \n-  /* Store the constraint.  */\n-  m_constraints->add_constraint (lhs_sval, op, rhs_sval);\n+  bool out;\n+  if (add_constraints_from_binop (lhs, op, rhs, &out, ctxt))\n+    return out;\n \n-  add_any_constraints_from_ssa_def_stmt (lhs, op, rhs, ctxt);\n+  /* Store the constraint.  */\n+  m_constraints->add_constraint (lhs, op, rhs);\n \n   /* Notify the context, if any.  This exists so that the state machines\n      in a program_state can be notified about the condition, and so can\n@@ -2293,9 +2427,10 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n \n   /* If we have &REGION == NULL, then drop dynamic extents for REGION (for\n      the case where REGION is heap-allocated and thus could be NULL).  */\n-  if (op == EQ_EXPR && zerop (rhs))\n-    if (const region_svalue *region_sval = lhs_sval->dyn_cast_region_svalue ())\n-      unset_dynamic_extents (region_sval->get_pointee ());\n+  if (tree rhs_cst = rhs->maybe_get_constant ())\n+    if (op == EQ_EXPR && zerop (rhs_cst))\n+      if (const region_svalue *region_sval = lhs->dyn_cast_region_svalue ())\n+\tunset_dynamic_extents (region_sval->get_pointee ());\n \n   return true;\n }\n@@ -2314,137 +2449,6 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n   return sat;\n }\n \n-/* Subroutine of region_model::add_constraint for handling optimized\n-   && and || conditionals.\n-\n-   If we have an SSA_NAME for a boolean compared against 0,\n-   look at anything implied by the def stmt and call add_constraint\n-   for it (which could recurse).\n-\n-   For example, if we have\n-      _1 = p_6 == 0B;\n-      _2 = p_8 == 0B\n-      _3 = _1 | _2\n-    and add the constraint\n-      (_3 == 0),\n-    then the def stmt for _3 implies that _1 and _2 are both false,\n-    and hence we can add the constraints:\n-      p_6 != 0B\n-      p_8 != 0B.  */\n-\n-void\n-region_model::add_any_constraints_from_ssa_def_stmt (tree lhs,\n-\t\t\t\t\t\t     enum tree_code op,\n-\t\t\t\t\t\t     tree rhs,\n-\t\t\t\t\t\t     region_model_context *ctxt)\n-{\n-  if (TREE_CODE (lhs) != SSA_NAME)\n-    return;\n-\n-  if (!zerop (rhs))\n-    return;\n-\n-  if (op != NE_EXPR && op != EQ_EXPR)\n-    return;\n-\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (lhs);\n-  if (const gassign *assign = dyn_cast<gassign *> (def_stmt))\n-    add_any_constraints_from_gassign (op, rhs, assign, ctxt);\n-  else if (gcall *call = dyn_cast<gcall *> (def_stmt))\n-    add_any_constraints_from_gcall (op, rhs, call, ctxt);\n-}\n-\n-/* Add any constraints for an SSA_NAME defined by ASSIGN\n-   where the result OP RHS.  */\n-\n-void\n-region_model::add_any_constraints_from_gassign (enum tree_code op,\n-\t\t\t\t\t\ttree rhs,\n-\t\t\t\t\t\tconst gassign *assign,\n-\t\t\t\t\t\tregion_model_context *ctxt)\n-{\n-  /* We have either\n-     - \"LHS != false\" (i.e. LHS is true), or\n-     - \"LHS == false\" (i.e. LHS is false).  */\n-  bool is_true = op == NE_EXPR;\n-\n-  enum tree_code rhs_code = gimple_assign_rhs_code (assign);\n-\n-  switch (rhs_code)\n-    {\n-    default:\n-      break;\n-\n-    case NOP_EXPR:\n-    case VIEW_CONVERT_EXPR:\n-      {\n-\tadd_constraint (gimple_assign_rhs1 (assign), op, rhs, ctxt);\n-      }\n-      break;\n-\n-    case BIT_AND_EXPR:\n-      {\n-\tif (is_true)\n-\t  {\n-\t    /* ...and \"LHS == (rhs1 & rhs2) i.e. \"(rhs1 & rhs2)\" is true\n-\t       then both rhs1 and rhs2 must be true.  */\n-\t    tree rhs1 = gimple_assign_rhs1 (assign);\n-\t    tree rhs2 = gimple_assign_rhs2 (assign);\n-\t    add_constraint (rhs1, NE_EXPR, boolean_false_node, ctxt);\n-\t    add_constraint (rhs2, NE_EXPR, boolean_false_node, ctxt);\n-\t  }\n-      }\n-      break;\n-\n-    case BIT_IOR_EXPR:\n-      {\n-\tif (!is_true)\n-\t  {\n-\t    /* ...and \"LHS == (rhs1 | rhs2)\n-\t       i.e. \"(rhs1 | rhs2)\" is false\n-\t       then both rhs1 and rhs2 must be false.  */\n-\t    tree rhs1 = gimple_assign_rhs1 (assign);\n-\t    tree rhs2 = gimple_assign_rhs2 (assign);\n-\t    add_constraint (rhs1, EQ_EXPR, boolean_false_node, ctxt);\n-\t    add_constraint (rhs2, EQ_EXPR, boolean_false_node, ctxt);\n-\t  }\n-      }\n-      break;\n-\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      {\n-\t/* ...and \"LHS == (rhs1 OP rhs2)\"\n-\t   then rhs1 OP rhs2 must have the same logical value as LHS.  */\n-\ttree rhs1 = gimple_assign_rhs1 (assign);\n-\ttree rhs2 = gimple_assign_rhs2 (assign);\n-\tif (!is_true)\n-\t  rhs_code\n-\t    = invert_tree_comparison (rhs_code, false /* honor_nans */);\n-\tadd_constraint (rhs1, rhs_code, rhs2, ctxt);\n-      }\n-      break;\n-    }\n-}\n-\n-/* Add any constraints for an SSA_NAME defined by CALL\n-   where the result OP RHS.  */\n-\n-void\n-region_model::add_any_constraints_from_gcall (enum tree_code op,\n-\t\t\t\t\t      tree rhs,\n-\t\t\t\t\t      const gcall *call,\n-\t\t\t\t\t      region_model_context *ctxt)\n-{\n-  if (gimple_call_builtin_p (call, BUILT_IN_EXPECT)\n-      || gimple_call_builtin_p (call, BUILT_IN_EXPECT_WITH_PROBABILITY)\n-      || gimple_call_internal_p (call, IFN_BUILTIN_EXPECT))\n-    {\n-      /* __builtin_expect's return value is its initial argument.  */\n-      add_constraint (gimple_call_arg (call, 0), op, rhs, ctxt);\n-    }\n-}\n-\n /* Determine what is known about the condition \"LHS OP RHS\" within\n    this model.\n    Use CTXT for reporting any diagnostics associated with the accesses.  */"}, {"sha": "cf5232dfab8e21dde03202be6521f87e0428fa32", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -691,18 +691,15 @@ class region_model\n   get_representative_path_var_1 (const region *reg,\n \t\t\t\t svalue_set *visited) const;\n \n-  void add_any_constraints_from_ssa_def_stmt (tree lhs,\n-\t\t\t\t\t      enum tree_code op,\n-\t\t\t\t\t      tree rhs,\n-\t\t\t\t\t      region_model_context *ctxt);\n-  void add_any_constraints_from_gassign (enum tree_code op,\n-\t\t\t\t\t tree rhs,\n-\t\t\t\t\t const gassign *assign,\n-\t\t\t\t\t region_model_context *ctxt);\n-  void add_any_constraints_from_gcall (enum tree_code op,\n-\t\t\t\t       tree rhs,\n-\t\t\t\t       const gcall *call,\n-\t\t\t\t       region_model_context *ctxt);\n+  bool add_constraint (const svalue *lhs,\n+\t\t       enum tree_code op,\n+\t\t       const svalue *rhs,\n+\t\t       region_model_context *ctxt);\n+  bool add_constraints_from_binop (const svalue *outer_lhs,\n+\t\t\t\t   enum tree_code outer_op,\n+\t\t\t\t   const svalue *outer_rhs,\n+\t\t\t\t   bool *out,\n+\t\t\t\t   region_model_context *ctxt);\n \n   void update_for_call_superedge (const call_superedge &call_edge,\n \t\t\t\t  region_model_context *ctxt);\n@@ -781,7 +778,9 @@ class region_model_context\n      and use them to trigger sm-state transitions (e.g. transitions due\n      to ptrs becoming known to be NULL or non-NULL, rather than just\n      \"unchecked\") */\n-  virtual void on_condition (tree lhs, enum tree_code op, tree rhs) = 0;\n+  virtual void on_condition (const svalue *lhs,\n+\t\t\t     enum tree_code op,\n+\t\t\t     const svalue *rhs) = 0;\n \n   /* Hooks for clients to be notified when an unknown change happens\n      to SVAL (in response to a call to an unknown function).  */\n@@ -812,9 +811,9 @@ class noop_region_model_context : public region_model_context\n   void on_liveness_change (const svalue_set &,\n \t\t\t   const region_model *) OVERRIDE {}\n   logger *get_logger () OVERRIDE { return NULL; }\n-  void on_condition (tree lhs ATTRIBUTE_UNUSED,\n+  void on_condition (const svalue *lhs ATTRIBUTE_UNUSED,\n \t\t     enum tree_code op ATTRIBUTE_UNUSED,\n-\t\t     tree rhs ATTRIBUTE_UNUSED) OVERRIDE\n+\t\t     const svalue *rhs ATTRIBUTE_UNUSED) OVERRIDE\n   {\n   }\n   void on_unknown_change (const svalue *sval ATTRIBUTE_UNUSED,"}, {"sha": "b40a9a1edb939252d529ddd56df98ed2731d2e2b", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -77,9 +77,9 @@ class fileptr_state_machine : public state_machine\n   void on_condition (sm_context *sm_ctxt,\n \t\t     const supernode *node,\n \t\t     const gimple *stmt,\n-\t\t     tree lhs,\n+\t\t     const svalue *lhs,\n \t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n+\t\t     const svalue *rhs) const FINAL OVERRIDE;\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n   pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n@@ -381,19 +381,18 @@ void\n fileptr_state_machine::on_condition (sm_context *sm_ctxt,\n \t\t\t\t     const supernode *node,\n \t\t\t\t     const gimple *stmt,\n-\t\t\t\t     tree lhs,\n+\t\t\t\t     const svalue *lhs,\n \t\t\t\t     enum tree_code op,\n-\t\t\t\t     tree rhs) const\n+\t\t\t\t     const svalue *rhs) const\n {\n-  if (!zerop (rhs))\n+  if (!rhs->all_zeroes_p ())\n     return;\n \n   // TODO: has to be a FILE *, specifically\n-  if (TREE_CODE (TREE_TYPE (lhs)) != POINTER_TYPE)\n+  if (!any_pointer_p (lhs))\n     return;\n-\n   // TODO: has to be a FILE *, specifically\n-  if (TREE_CODE (TREE_TYPE (rhs)) != POINTER_TYPE)\n+  if (!any_pointer_p (rhs))\n     return;\n \n   if (op == NE_EXPR)"}, {"sha": "40e64b3630f938cc875b8b86bdea8b5bb3f874d0", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -375,9 +375,9 @@ class malloc_state_machine : public state_machine\n   void on_condition (sm_context *sm_ctxt,\n \t\t     const supernode *node,\n \t\t     const gimple *stmt,\n-\t\t     tree lhs,\n+\t\t     const svalue *lhs,\n \t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n+\t\t     const svalue *rhs) const FINAL OVERRIDE;\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n   pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n@@ -1863,11 +1863,11 @@ void\n malloc_state_machine::on_condition (sm_context *sm_ctxt,\n \t\t\t\t    const supernode *node ATTRIBUTE_UNUSED,\n \t\t\t\t    const gimple *stmt,\n-\t\t\t\t    tree lhs,\n+\t\t\t\t    const svalue *lhs,\n \t\t\t\t    enum tree_code op,\n-\t\t\t\t    tree rhs) const\n+\t\t\t\t    const svalue *rhs) const\n {\n-  if (!zerop (rhs))\n+  if (!rhs->all_zeroes_p ())\n     return;\n \n   if (!any_pointer_p (lhs))"}, {"sha": "4e285492d048de88ab895ef05766dfc77803628d", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -37,6 +37,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -61,9 +67,9 @@ class pattern_test_state_machine : public state_machine\n   void on_condition (sm_context *sm_ctxt,\n \t\t     const supernode *node,\n \t\t     const gimple *stmt,\n-\t\t     tree lhs,\n+\t\t     const svalue *lhs,\n \t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n+\t\t     const svalue *rhs) const FINAL OVERRIDE;\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n };\n@@ -118,18 +124,22 @@ void\n pattern_test_state_machine::on_condition (sm_context *sm_ctxt,\n \t\t\t\t\t  const supernode *node,\n \t\t\t\t\t  const gimple *stmt,\n-\t\t\t\t\t  tree lhs,\n+\t\t\t\t\t  const svalue *lhs,\n \t\t\t\t\t  enum tree_code op,\n-\t\t\t\t\t  tree rhs) const\n+\t\t\t\t\t  const svalue *rhs) const\n {\n   if (stmt == NULL)\n     return;\n \n-  if (!CONSTANT_CLASS_P (rhs))\n+  tree rhs_cst = rhs->maybe_get_constant ();\n+  if (!rhs_cst)\n     return;\n \n-  pending_diagnostic *diag = new pattern_match (lhs, op, rhs);\n-  sm_ctxt->warn (node, stmt, lhs, diag);\n+  if (tree lhs_expr = sm_ctxt->get_diagnostic_tree (lhs))\n+    {\n+      pending_diagnostic *diag = new pattern_match (lhs_expr, op, rhs_cst);\n+      sm_ctxt->warn (node, stmt, lhs_expr, diag);\n+    }\n }\n \n bool"}, {"sha": "4add55e91fb9a78a8e5a3031449e7b6ee4da502d", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -58,13 +58,6 @@ class sensitive_state_machine : public state_machine\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n \n-  void on_condition (sm_context *sm_ctxt,\n-\t\t     const supernode *node,\n-\t\t     const gimple *stmt,\n-\t\t     tree lhs,\n-\t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n-\n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n   /* State for \"sensitive\" data, such as a password.  */\n@@ -222,17 +215,6 @@ sensitive_state_machine::on_stmt (sm_context *sm_ctxt,\n   return false;\n }\n \n-void\n-sensitive_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n-\t\t\t\t       const supernode *node ATTRIBUTE_UNUSED,\n-\t\t\t\t       const gimple *stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t       tree lhs ATTRIBUTE_UNUSED,\n-\t\t\t\t       enum tree_code op ATTRIBUTE_UNUSED,\n-\t\t\t\t       tree rhs ATTRIBUTE_UNUSED) const\n-{\n-  /* Empty.  */\n-}\n-\n bool\n sensitive_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n {"}, {"sha": "fcbf322f502c9a8b68e8ff1453f85ede72cb9a52", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -81,13 +81,6 @@ class signal_state_machine : public state_machine\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n \n-  void on_condition (sm_context *sm_ctxt,\n-\t\t     const supernode *node,\n-\t\t     const gimple *stmt,\n-\t\t     tree lhs,\n-\t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n-\n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n   /* These states are \"global\", rather than per-expression.  */\n@@ -363,20 +356,6 @@ signal_state_machine::on_stmt (sm_context *sm_ctxt,\n   return false;\n }\n \n-/* Implementation of state_machine::on_condition vfunc for\n-   signal_state_machine.  */\n-\n-void\n-signal_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n-\t\t\t\t    const supernode *node ATTRIBUTE_UNUSED,\n-\t\t\t\t    const gimple *stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t    tree lhs ATTRIBUTE_UNUSED,\n-\t\t\t\t    enum tree_code op ATTRIBUTE_UNUSED,\n-\t\t\t\t    tree rhs ATTRIBUTE_UNUSED) const\n-{\n-  // Empty\n-}\n-\n bool\n signal_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n {"}, {"sha": "721d3eabb8ff4c5db62887eb2bdd33614d45a54a", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -61,9 +61,9 @@ class taint_state_machine : public state_machine\n   void on_condition (sm_context *sm_ctxt,\n \t\t     const supernode *node,\n \t\t     const gimple *stmt,\n-\t\t     tree lhs,\n+\t\t     const svalue *lhs,\n \t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n+\t\t     const svalue *rhs) const FINAL OVERRIDE;\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n@@ -281,9 +281,9 @@ void\n taint_state_machine::on_condition (sm_context *sm_ctxt,\n \t\t\t\t   const supernode *node,\n \t\t\t\t   const gimple *stmt,\n-\t\t\t\t   tree lhs,\n+\t\t\t\t   const svalue *lhs,\n \t\t\t\t   enum tree_code op,\n-\t\t\t\t   tree rhs ATTRIBUTE_UNUSED) const\n+\t\t\t\t   const svalue *rhs ATTRIBUTE_UNUSED) const\n {\n   if (stmt == NULL)\n     return;"}, {"sha": "db07bf31d295aaabc7aa3df1415bd705327d163b", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -35,6 +35,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n+#include \"tristate.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/svalue.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -48,6 +53,15 @@ any_pointer_p (tree var)\n   return POINTER_TYPE_P (TREE_TYPE (var));\n }\n \n+/* Return true if SVAL has pointer or reference type.  */\n+\n+bool\n+any_pointer_p (const svalue *sval)\n+{\n+  if (!sval->get_type ())\n+    return false;\n+  return POINTER_TYPE_P (sval->get_type ());\n+}\n \n /* class state_machine::state.  */\n "}, {"sha": "6bb036e343b6a009a69612c1dd37b8e71d00a9fe", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -29,7 +29,8 @@ class state_machine;\n class sm_context;\n class pending_diagnostic;\n \n-extern bool any_pointer_p (tree var);\n+extern bool any_pointer_p (tree expr);\n+extern bool any_pointer_p (const svalue *sval);\n \n /* An abstract base class for a state machine describing an API.\n    Manages a set of state objects, and has various virtual functions\n@@ -89,10 +90,14 @@ class state_machine : public log_user\n   {\n   }\n \n-  virtual void on_condition (sm_context *sm_ctxt,\n-\t\t\t     const supernode *node,\n-\t\t\t     const gimple *stmt,\n-\t\t\t     tree lhs, enum tree_code op, tree rhs) const = 0;\n+  virtual void on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t\t     const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t     const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t     const svalue *lhs ATTRIBUTE_UNUSED,\n+\t\t\t     enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t\t     const svalue *rhs ATTRIBUTE_UNUSED) const\n+  {\n+  }\n \n   /* Return true if it safe to discard the given state (to help\n      when simplifying state objects).\n@@ -182,13 +187,19 @@ class sm_context\n   /* Get the old state of VAR at STMT.  */\n   virtual state_machine::state_t get_state (const gimple *stmt,\n \t\t\t\t\t    tree var) = 0;\n+  virtual state_machine::state_t get_state (const gimple *stmt,\n+\t\t\t\t\t    const svalue *) = 0;\n   /* Set the next state of VAR to be TO, recording the \"origin\" of the\n      state as ORIGIN.\n      Use STMT for location information.  */\n   virtual void set_next_state (const gimple *stmt,\n \t\t\t       tree var,\n \t\t\t       state_machine::state_t to,\n \t\t\t       tree origin = NULL_TREE) = 0;\n+  virtual void set_next_state (const gimple *stmt,\n+\t\t\t       const svalue *var,\n+\t\t\t       state_machine::state_t to,\n+\t\t\t       tree origin = NULL_TREE) = 0;\n \n   /* Called by state_machine in response to pattern matches:\n      if VAR is in state FROM, transition it to state TO, potentially\n@@ -206,6 +217,18 @@ class sm_context\n       set_next_state (stmt, var, to, origin);\n   }\n \n+  void on_transition (const supernode *node ATTRIBUTE_UNUSED,\n+\t\t      const gimple *stmt,\n+\t\t      const svalue *var,\n+\t\t      state_machine::state_t from,\n+\t\t      state_machine::state_t to,\n+\t\t      tree origin = NULL_TREE)\n+  {\n+    state_machine::state_t current = get_state (stmt, var);\n+    if (current == from)\n+      set_next_state (stmt, var, to, origin);\n+  }\n+\n   /* Called by state_machine in response to pattern matches:\n      issue a diagnostic D using NODE and STMT for location information.  */\n   virtual void warn (const supernode *node, const gimple *stmt,\n@@ -220,6 +243,7 @@ class sm_context\n   {\n     return expr;\n   }\n+  virtual tree get_diagnostic_tree (const svalue *) = 0;\n \n   virtual state_machine::state_t get_global_state () const = 0;\n   virtual void set_global_state (state_machine::state_t) = 0;"}, {"sha": "70c23f016f9c8b95c2c3b2814dc2b8179dd459fd", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -557,6 +557,15 @@ svalue::maybe_fold_bits_within (tree,\n   return NULL;\n }\n \n+/* Base implementation of svalue::all_zeroes_p.\n+   Return true if this value is known to be all zeroes.  */\n+\n+bool\n+svalue::all_zeroes_p () const\n+{\n+  return false;\n+}\n+\n /* class region_svalue : public svalue.  */\n \n /* Implementation of svalue::dump_to_pp vfunc for region_svalue.  */\n@@ -742,6 +751,14 @@ constant_svalue::maybe_fold_bits_within (tree type,\n   return NULL;\n }\n \n+/* Implementation of svalue::all_zeroes_p for constant_svalue.  */\n+\n+bool\n+constant_svalue::all_zeroes_p () const\n+{\n+  return zerop (m_cst_expr);\n+}\n+\n /* class unknown_svalue : public svalue.  */\n \n /* Implementation of svalue::dump_to_pp vfunc for unknown_svalue.  */\n@@ -1154,15 +1171,12 @@ repeated_svalue::accept (visitor *v) const\n   m_inner_svalue->accept (v);\n }\n \n-/* Return true if this value is known to be all zeroes.  */\n+/* Implementation of svalue::all_zeroes_p for repeated_svalue.  */\n \n bool\n repeated_svalue::all_zeroes_p () const\n {\n-  if (tree cst = m_inner_svalue->maybe_get_constant ())\n-    if (zerop (cst))\n-      return true;\n-  return false;\n+  return m_inner_svalue->all_zeroes_p ();\n }\n \n /* Implementation of svalue::maybe_fold_bits_within vfunc"}, {"sha": "5552fcf4c992eb949b7581737bf2c4dacbf08428", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -157,6 +157,8 @@ class svalue\n \t\t\t  const bit_range &subrange,\n \t\t\t  region_model_manager *mgr) const;\n \n+  virtual bool all_zeroes_p () const;\n+\n  protected:\n   svalue (complexity c, tree type)\n   : m_complexity (c), m_type (type)\n@@ -277,6 +279,8 @@ class constant_svalue : public svalue\n \t\t\t  const bit_range &subrange,\n \t\t\t  region_model_manager *mgr) const FINAL OVERRIDE;\n \n+  bool all_zeroes_p () const FINAL OVERRIDE;\n+\n  private:\n   tree m_cst_expr;\n };\n@@ -858,7 +862,7 @@ class repeated_svalue : public svalue\n   const svalue *get_outer_size () const { return m_outer_size; }\n   const svalue *get_inner_svalue () const { return m_inner_svalue; }\n \n-  bool all_zeroes_p () const;\n+  bool all_zeroes_p () const FINAL OVERRIDE;\n \n   const svalue *\n   maybe_fold_bits_within (tree type,"}, {"sha": "7c8d1b33fc98d3e9d24ce4d975a7fdfaa39ed41c", "filename": "gcc/testsuite/gcc.dg/analyzer/pattern-test-2.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -25,11 +25,8 @@ void test_2 (void *p, void *q)\n     return;\n   foo(p);\n \n-  /* { dg-warning \"pattern match on 'tmp1 == 0'\" \"tmp1 == 0\" { target *-*-* } cond_2 } */\n-  /* { dg-warning \"pattern match on 'tmp2 == 0'\" \"tmp2 == 0\" { target *-*-* } cond_2 } */\n-  /* { dg-warning \"pattern match on '<unknown> == 0'\" \"<unknown> == 0\" { target *-*-* } cond_2 } */\n-  /* { dg-warning \"pattern match on '<unknown> != 0'\" \"<unknown> != 0\" { target *-*-* } cond_2 } */\n   /* { dg-warning \"pattern match on 'p != 0'\" \"p != 0\" { target *-*-* } cond_2 } */\n+  /* { dg-warning \"pattern match on 'tmp1 | tmp2 != 0'\" \"tmp1 | tmp2 != 0\" { target *-*-* } cond_2 } */\n   /* { dg-warning \"pattern match on 'q != 0'\" \"q != 0\" { target *-*-* } cond_2 } */\n }\n \n@@ -44,10 +41,7 @@ void test_3 (void *p, void *q)\n     return;\n   foo(p);\n \n-  /* { dg-warning \"pattern match on 'tmp1 != 0'\" \"tmp1 != 0\" { target *-*-* } cond_3 } */\n-  /* { dg-warning \"pattern match on 'tmp2 != 0'\" \"tmp2 != 0\" { target *-*-* } cond_3 } */\n-  /* { dg-warning \"pattern match on '<unknown> == 0'\" \"<unknown> == 0\" { target *-*-* } cond_3 } */\n-  /* { dg-warning \"pattern match on '<unknown> != 0'\" \"<unknown> != 0\" { target *-*-* } cond_3 } */\n   /* { dg-warning \"pattern match on 'p == 0'\" \"p == 0\" { target *-*-* } cond_3 } */\n+  /* { dg-warning \"pattern match on 'tmp1 & tmp2 == 0'\" \"tmp1 & tmp2 == 0\" { target *-*-* } cond_3 } */\n   /* { dg-warning \"pattern match on 'q == 0'\" \"q == 0\" { target *-*-* } cond_3 } */\n }"}, {"sha": "61dd490436a8db4764f91b6a2181bc933ad47b6e", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8a7a677b8356df946cd12fbb215538828e747/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=48e8a7a677b8356df946cd12fbb215538828e747", "patch": "@@ -53,13 +53,6 @@ class gil_state_machine : public state_machine\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n \n-  void on_condition (sm_context *sm_ctxt,\n-\t\t     const supernode *node,\n-\t\t     const gimple *stmt,\n-\t\t     tree lhs,\n-\t\t     enum tree_code op,\n-\t\t     tree rhs) const FINAL OVERRIDE;\n-\n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n   void check_for_pyobject_usage_without_gil (sm_context *sm_ctxt,\n@@ -365,20 +358,6 @@ gil_state_machine::on_stmt (sm_context *sm_ctxt,\n   return false;\n }\n \n-/* Implementation of state_machine::on_condition vfunc for\n-   gil_state_machine.  */\n-\n-void\n-gil_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n-\t\t\t\t const supernode *node ATTRIBUTE_UNUSED,\n-\t\t\t\t const gimple *stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t tree lhs ATTRIBUTE_UNUSED,\n-\t\t\t\t enum tree_code op ATTRIBUTE_UNUSED,\n-\t\t\t\t tree rhs ATTRIBUTE_UNUSED) const\n-{\n-  // Empty\n-}\n-\n bool\n gil_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n {"}]}