{"sha": "c49ea23d52792120c23ceb81550920335752ac26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5ZWEyM2Q1Mjc5MjEyMGMyM2NlYjgxNTUwOTIwMzM1NzUyYWMyNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-12-11T20:42:23Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-12-11T20:42:23Z"}, "message": "re PR fortran/41539 ([OOP] Calling function which takes CLASS: Rank comparison does not work)\n\n2011-12-11  Paul Thomas  <pault@gcc.gnu.org>\n\tTobias Burnus  <burnus@gcc.gnu.org>\n\n\tPR fortran/41539\n\tPR fortran/43214\n\tPR fortran/43969\n\tPR fortran/44568\n\tPR fortran/46356\n\tPR fortran/46990\n\tPR fortran/49074\n\t* interface.c(symbol_rank): Return the rank of the _data\n\tcomponent of class objects.\n\t(compare_parameter): Also compare the derived type of the class\n\t_data component for type mismatch.  Similarly, return 1 if the\n\tformal and _data ranks match.\n\t(compare_actual_formal): Do not compare storage sizes for class\n\texpressions. It is an error if an actual class array, passed to\n\ta formal class array is not full.\n\t* trans-expr.c (gfc_class_data_get, gfc_class_vptr_get,\n\tgfc_vtable_field_get, gfc_vtable_hash_get, gfc_vtable_size_get,\n\tgfc_vtable_extends_get, gfc_vtable_def_init_get,\n\tgfc_vtable_copy_get): New functions for class API.\n\t(gfc_conv_derived_to_class): For an array reference in an\n\telemental procedure call retain the ss to provide the\n\tscalarized array reference. Moved in file.\n\t(gfc_conv_class_to_class): New function.\n        (gfc_conv_subref_array_arg): Use the type of the\n\tclass _data component as a basetype.\n\t(gfc_conv_procedure_call): Ensure that class array expressions\n\thave both the _data reference and an array reference. Use \n\tgfc_conv_class_to_class to handle class arrays for elemental\n\tfunctions in scalarized loops, class array elements and full\n\tclass arrays. Use a call to gfc_conv_subref_array_arg in order\n\tthat the copy-in/copy-out for passing class arrays to derived\n\ttype arrays occurs correctly.\n\t(gfc_conv_expr): If it is missing, add the _data component\n\tbetween a class object or component and an array reference.\n\t(gfc_trans_class_array_init_assign): New function.\n\t(gfc_trans_class_init_assign): Call it for array expressions.\n\t* trans-array.c (gfc_add_loop_ss_code): Do not use a temp for\n\tclass scalars since their size will depend on the dynamic type.\n\t(build_class_array_ref): New function.\n\t(gfc_conv_scalarized_array_ref): Call build_class_array_ref.\n\t(gfc_array_init_size): Add extra argument, expr3, that represents\n\tthe SOURCE argument. If present,use this for the element size.\n\t(gfc_array_allocate): Also add argument expr3 and use it when\n\tcalling gfc_array_init_size.\n\t(structure_alloc_comps): Enable class arrays.\n\t* class.c (gfc_add_component_ref): Carry over the derived type\n\tof the _data component.\n\t(gfc_add_class_array_ref): New function.\n\t(class_array_ref_detected): New static function.\n\t(gfc_is_class_array_ref): New function that calls previous.\n\t(gfc_is_class_scalar_expr): New function.\n\t(gfc_build_class_symbol): Throw not implemented error for\n\tassumed size class arrays.  Remove error that prevents\n\tCLASS arrays.\n\t(gfc_build_class_symbol): Prevent pointer/allocatable conflict.\n\tAlso unset codimension.\n\t(gfc_find_derived_vtab): Make 'copy' elemental and set the\n\tintent of the arguments accordingly.: \n\t* trans-array.h : Update prototype for gfc_array_allocate.\n\t* array.c (gfc_array_dimen_size): Return failure if class expr.\n\t(gfc_array_size): Likewise.\n\t* gfortran.h : New prototypes for gfc_add_class_array_ref,\n\tgfc_is_class_array_ref and gfc_is_class_scalar_expr.\n\t* trans-stmt.c (trans_associate_var): Exclude class targets\n\tfrom test. Move the allocation of the _vptr to an earlier time\n\tfor class objects.\n\t(trans_associate_var): Assign the descriptor directly for class\n\tarrays.\n\t(gfc_trans_allocate): Add expr3 to gfc_array_allocate arguments.\n\tConvert array element references into sections. Do not invoke\n\tgfc_conv_procedure_call, use gfc_trans_call instead.\n\t* expr.c (gfc_get_corank): Fix for BT_CLASS.\n\t(gfc_is_simply_contiguous): Exclude class from test.\n\t* trans.c (gfc_build_array_ref): Include class array refs.\n\t* trans.h : Include prototypes for class API functions that are\n\tnew in trans-expr. Define GFC_DECL_CLASS(node).\n\t* resolve.c (check_typebound_baseobject ): Remove error for\n\tnon-scalar base object.\n\t(resolve_allocate_expr): Ensure that class _data component is\n\tpresent. If array, call gfc_expr_to_intialize.\n\t(resolve_select): Remove scalar error for SELECT statement as a\n\ttemporary measure.\n\t(resolve_assoc_var): Update 'target' (aka 'selector') as\n\tneeded. Ensure that the target expression has the right rank.\n\t(resolve_select_type): Ensure that target expressions have a\n\tvalid locus.\n\t(resolve_allocate_expr, resolve_fl_derived0): Fix for BT_CLASS.\n\t* trans-decl.c (gfc_get_symbol_decl): Set GFC_DECL_CLASS, where\n\tappropriate.\n\t(gfc_trans_deferred_vars): Get class arrays right.\n\t* match.c(select_type_set_tmp): Add array spec to temporary.\n\t(gfc_match_select_type): Allow class arrays.\n\t* check.c (array_check): Ensure that class arrays have refs.\n\t(dim_corank_check, dim_rank_check): Retrun success if class.\n\t* primary.c (gfc_match_varspec): Fix for class arrays and\n\tco-arrays. Make sure that class _data is present.\n\t(gfc_match_rvalue): Handle class arrays.\n\t*trans-intrinsic.c (gfc_conv_intrinsic_size): Add class array\n\treference.\n\t(gfc_conv_allocated): Add _data component to class expressions.\n\t(gfc_add_intrinsic_ss_code): ditto.\n\t* simplify.c (simplify_cobound): Fix for BT_CLASS.\n\t(simplify_bound): Return NULL for class arrays.\n\t(simplify_cobound): Obtain correct array_spec. Use cotype as\n\tappropriate. Use arrayspec for bounds.\n\n2011-12-11  Paul Thomas  <pault@gcc.gnu.org>\n\tTobias Burnus  <burnus@gcc.gnu.org>\n\n\tPR fortran/41539\n\tPR fortran/43214\n\tPR fortran/43969\n\tPR fortran/44568\n\tPR fortran/46356\n\tPR fortran/46990\n\tPR fortran/49074\n\t* gfortran.dg/class_array_1.f03: New.\n\t* gfortran.dg/class_array_2.f03: New.\n\t* gfortran.dg/class_array_3.f03: New.\n\t* gfortran.dg/class_array_4.f03: New.\n\t* gfortran.dg/class_array_5.f03: New.\n\t* gfortran.dg/class_array_6.f03: New.\n\t* gfortran.dg/class_array_7.f03: New.\n\t* gfortran.dg/class_array_8.f03: New.\n\t* gfortran.dg/coarray_poly_1.f90: New.\n\t* gfortran.dg/coarray_poly_2.f90: New.\n\t* gfortran.dg/coarray/poly_run_1.f90: New.\n\t* gfortran.dg/coarray/poly_run_2.f90: New.\n\t* gfortran.dg/class_to_type_1.f03: New.\n\t* gfortran.dg/type_to_class_1.f03: New.\n\t* gfortran.dg/typebound_assignment_3.f03: Remove the error.\n\t* gfortran.dg/auto_dealloc_2.f90: Occurences of __builtin_free\n\tnow 2.\n\t* gfortran.dg/class_19.f03: Occurences of __builtin_free now 8.\n\n\nCo-Authored-By: Tobias Burnus <burnus@gcc.gnu.org>\n\nFrom-SVN: r182210", "tree": {"sha": "7124c877d521be0a5e83d92f147fea8b99d7e2de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7124c877d521be0a5e83d92f147fea8b99d7e2de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c49ea23d52792120c23ceb81550920335752ac26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49ea23d52792120c23ceb81550920335752ac26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49ea23d52792120c23ceb81550920335752ac26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49ea23d52792120c23ceb81550920335752ac26/comments", "author": null, "committer": null, "parents": [{"sha": "e07e39f6e56373b87d59806a3cce7fc3bcd8c57e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e07e39f6e56373b87d59806a3cce7fc3bcd8c57e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e07e39f6e56373b87d59806a3cce7fc3bcd8c57e"}], "stats": {"total": 2189, "additions": 1971, "deletions": 218}, "files": [{"sha": "c87daeb7df1068242942d4ea903b1cbeed9bd69c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1,3 +1,112 @@\n+2011-12-11  Paul Thomas  <pault@gcc.gnu.org>\n+\tTobias Burnus  <burnus@gcc.gnu.org>\n+\n+\tPR fortran/41539\n+\tPR fortran/43214\n+\tPR fortran/43969\n+\tPR fortran/44568\n+\tPR fortran/46356\n+\tPR fortran/46990\n+\tPR fortran/49074\n+\t* interface.c(symbol_rank): Return the rank of the _data\n+\tcomponent of class objects.\n+\t(compare_parameter): Also compare the derived type of the class\n+\t_data component for type mismatch.  Similarly, return 1 if the\n+\tformal and _data ranks match.\n+\t(compare_actual_formal): Do not compare storage sizes for class\n+\texpressions. It is an error if an actual class array, passed to\n+\ta formal class array is not full.\n+\t* trans-expr.c (gfc_class_data_get, gfc_class_vptr_get,\n+\tgfc_vtable_field_get, gfc_vtable_hash_get, gfc_vtable_size_get,\n+\tgfc_vtable_extends_get, gfc_vtable_def_init_get,\n+\tgfc_vtable_copy_get): New functions for class API.\n+\t(gfc_conv_derived_to_class): For an array reference in an\n+\telemental procedure call retain the ss to provide the\n+\tscalarized array reference. Moved in file.\n+\t(gfc_conv_class_to_class): New function.\n+        (gfc_conv_subref_array_arg): Use the type of the\n+\tclass _data component as a basetype.\n+\t(gfc_conv_procedure_call): Ensure that class array expressions\n+\thave both the _data reference and an array reference. Use \n+\tgfc_conv_class_to_class to handle class arrays for elemental\n+\tfunctions in scalarized loops, class array elements and full\n+\tclass arrays. Use a call to gfc_conv_subref_array_arg in order\n+\tthat the copy-in/copy-out for passing class arrays to derived\n+\ttype arrays occurs correctly.\n+\t(gfc_conv_expr): If it is missing, add the _data component\n+\tbetween a class object or component and an array reference.\n+\t(gfc_trans_class_array_init_assign): New function.\n+\t(gfc_trans_class_init_assign): Call it for array expressions.\n+\t* trans-array.c (gfc_add_loop_ss_code): Do not use a temp for\n+\tclass scalars since their size will depend on the dynamic type.\n+\t(build_class_array_ref): New function.\n+\t(gfc_conv_scalarized_array_ref): Call build_class_array_ref.\n+\t(gfc_array_init_size): Add extra argument, expr3, that represents\n+\tthe SOURCE argument. If present,use this for the element size.\n+\t(gfc_array_allocate): Also add argument expr3 and use it when\n+\tcalling gfc_array_init_size.\n+\t(structure_alloc_comps): Enable class arrays.\n+\t* class.c (gfc_add_component_ref): Carry over the derived type\n+\tof the _data component.\n+\t(gfc_add_class_array_ref): New function.\n+\t(class_array_ref_detected): New static function.\n+\t(gfc_is_class_array_ref): New function that calls previous.\n+\t(gfc_is_class_scalar_expr): New function.\n+\t(gfc_build_class_symbol): Throw not implemented error for\n+\tassumed size class arrays.  Remove error that prevents\n+\tCLASS arrays.\n+\t(gfc_build_class_symbol): Prevent pointer/allocatable conflict.\n+\tAlso unset codimension.\n+\t(gfc_find_derived_vtab): Make 'copy' elemental and set the\n+\tintent of the arguments accordingly.: \n+\t* trans-array.h : Update prototype for gfc_array_allocate.\n+\t* array.c (gfc_array_dimen_size): Return failure if class expr.\n+\t(gfc_array_size): Likewise.\n+\t* gfortran.h : New prototypes for gfc_add_class_array_ref,\n+\tgfc_is_class_array_ref and gfc_is_class_scalar_expr.\n+\t* trans-stmt.c (trans_associate_var): Exclude class targets\n+\tfrom test. Move the allocation of the _vptr to an earlier time\n+\tfor class objects.\n+\t(trans_associate_var): Assign the descriptor directly for class\n+\tarrays.\n+\t(gfc_trans_allocate): Add expr3 to gfc_array_allocate arguments.\n+\tConvert array element references into sections. Do not invoke\n+\tgfc_conv_procedure_call, use gfc_trans_call instead.\n+\t* expr.c (gfc_get_corank): Fix for BT_CLASS.\n+\t(gfc_is_simply_contiguous): Exclude class from test.\n+\t* trans.c (gfc_build_array_ref): Include class array refs.\n+\t* trans.h : Include prototypes for class API functions that are\n+\tnew in trans-expr. Define GFC_DECL_CLASS(node).\n+\t* resolve.c (check_typebound_baseobject ): Remove error for\n+\tnon-scalar base object.\n+\t(resolve_allocate_expr): Ensure that class _data component is\n+\tpresent. If array, call gfc_expr_to_intialize.\n+\t(resolve_select): Remove scalar error for SELECT statement as a\n+\ttemporary measure.\n+\t(resolve_assoc_var): Update 'target' (aka 'selector') as\n+\tneeded. Ensure that the target expression has the right rank.\n+\t(resolve_select_type): Ensure that target expressions have a\n+\tvalid locus.\n+\t(resolve_allocate_expr, resolve_fl_derived0): Fix for BT_CLASS.\n+\t* trans-decl.c (gfc_get_symbol_decl): Set GFC_DECL_CLASS, where\n+\tappropriate.\n+\t(gfc_trans_deferred_vars): Get class arrays right.\n+\t* match.c(select_type_set_tmp): Add array spec to temporary.\n+\t(gfc_match_select_type): Allow class arrays.\n+\t* check.c (array_check): Ensure that class arrays have refs.\n+\t(dim_corank_check, dim_rank_check): Retrun success if class.\n+\t* primary.c (gfc_match_varspec): Fix for class arrays and\n+\tco-arrays. Make sure that class _data is present.\n+\t(gfc_match_rvalue): Handle class arrays.\n+\t*trans-intrinsic.c (gfc_conv_intrinsic_size): Add class array\n+\treference.\n+\t(gfc_conv_allocated): Add _data component to class expressions.\n+\t(gfc_add_intrinsic_ss_code): ditto.\n+\t* simplify.c (simplify_cobound): Fix for BT_CLASS.\n+\t(simplify_bound): Return NULL for class arrays.\n+\t(simplify_cobound): Obtain correct array_spec. Use cotype as\n+\tappropriate. Use arrayspec for bounds.\n+\n 2011-12-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/50690"}, {"sha": "b36d517cff7b1927d7ba48d0da2468848d602b03", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -2112,6 +2112,9 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n   gfc_ref *ref;\n   int i;\n \n+  if (array->ts.type == BT_CLASS)\n+    return FAILURE;\n+\n   if (dimen < 0 || array == NULL || dimen > array->rank - 1)\n     gfc_internal_error (\"gfc_array_dimen_size(): Bad dimension\");\n \n@@ -2190,6 +2193,9 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n   int i;\n   gfc_try t;\n \n+  if (array->ts.type == BT_CLASS)\n+    return FAILURE;\n+\n   switch (array->expr_type)\n     {\n     case EXPR_ARRAY:"}, {"sha": "dca97cba7eb2b5a3f4fcca9539fef3906546566c", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -240,6 +240,14 @@ logical_array_check (gfc_expr *array, int n)\n static gfc_try\n array_check (gfc_expr *e, int n)\n {\n+  if (e->ts.type == BT_CLASS\n+\t&& CLASS_DATA (e)->attr.dimension\n+\t&& CLASS_DATA (e)->as->rank)\n+    {\n+      gfc_add_class_array_ref (e);\n+      return SUCCESS;\n+    }\n+\n   if (e->rank != 0)\n     return SUCCESS;\n \n@@ -554,6 +562,9 @@ dim_corank_check (gfc_expr *dim, gfc_expr *array)\n \n   if (dim->expr_type != EXPR_CONSTANT)\n     return SUCCESS;\n+  \n+  if (array->ts.type == BT_CLASS)\n+    return SUCCESS;\n \n   corank = gfc_get_corank (array);\n \n@@ -587,6 +598,9 @@ dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n   if (dim->expr_type != EXPR_CONSTANT)\n     return SUCCESS;\n \n+  if (array->ts.type == BT_CLASS)\n+    return SUCCESS;\n+\n   if (array->expr_type == EXPR_FUNCTION && array->value.function.isym\n       && array->value.function.isym->id == GFC_ISYM_SPREAD)\n     rank = array->rank + 1;"}, {"sha": "37c653a6c33de7db7f8c4633405a89d82f69a652", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 173, "deletions": 11, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -64,7 +64,14 @@ gfc_add_component_ref (gfc_expr *e, const char *name)\n   while (*tail != NULL)\n     {\n       if ((*tail)->type == REF_COMPONENT)\n-\tderived = (*tail)->u.c.component->ts.u.derived;\n+\t{\n+\t  if (strcmp ((*tail)->u.c.component->name, \"_data\") == 0\n+\t\t&& (*tail)->next\n+\t\t&& (*tail)->next->type == REF_ARRAY\n+\t\t&& (*tail)->next->next == NULL)\n+\t    return;\n+\t  derived = (*tail)->u.c.component->ts.u.derived;\n+\t}\n       if ((*tail)->type == REF_ARRAY && (*tail)->next == NULL)\n \tbreak;\n       tail = &((*tail)->next);\n@@ -82,6 +89,155 @@ gfc_add_component_ref (gfc_expr *e, const char *name)\n }\n \n \n+/* This is used to add both the _data component reference and an array\n+   reference to class expressions.  Used in translation of intrinsic\n+   array inquiry functions.  */\n+\n+void\n+gfc_add_class_array_ref (gfc_expr *e)\n+{\n+  int rank =  CLASS_DATA (e)->as->rank;\n+  gfc_array_spec *as = CLASS_DATA (e)->as;\n+  gfc_ref *ref = NULL;\n+  gfc_add_component_ref (e, \"_data\");\n+  e->rank = rank;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (!ref->next)\n+      break;\n+  if (ref->type != REF_ARRAY)\n+    {\n+      ref->next = gfc_get_ref ();\n+      ref = ref->next;\n+      ref->type = REF_ARRAY;\n+      ref->u.ar.type = AR_FULL;\n+      ref->u.ar.as = as;\t  \n+    }\n+}\n+\n+\n+/* Unfortunately, class array expressions can appear in various conditions;\n+   with and without both _data component and an arrayspec.  This function\n+   deals with that variability.  The previous reference to 'ref' is to a\n+   class array.  */\n+\n+static bool\n+class_array_ref_detected (gfc_ref *ref, bool *full_array)\n+{\n+  bool no_data = false;\n+  bool with_data = false;\n+\n+  /* An array reference with no _data component.  */\n+  if (ref && ref->type == REF_ARRAY\n+\t&& !ref->next\n+\t&& ref->u.ar.type != AR_ELEMENT)\n+    {\n+      if (full_array)\n+        *full_array = ref->u.ar.type == AR_FULL;\n+      no_data = true;\n+    }\n+\n+  /* Cover cases where _data appears, with or without an array ref.  */\n+  if (ref && ref->type == REF_COMPONENT\n+\t&& strcmp (ref->u.c.component->name, \"_data\") == 0)\n+    {\n+      if (!ref->next)\n+\t{\n+\t  with_data = true;\n+\t  if (full_array)\n+\t    *full_array = true;\n+\t}\n+      else if (ref->next && ref->next->type == REF_ARRAY\n+\t    && !ref->next->next\n+\t    && ref->type == REF_COMPONENT\n+\t    && ref->next->type == REF_ARRAY\n+\t    && ref->next->u.ar.type != AR_ELEMENT)\n+\t{\n+\t  with_data = true;\n+\t  if (full_array)\n+\t    *full_array = ref->next->u.ar.type == AR_FULL;\n+\t}\n+    }\n+\n+  return no_data || with_data;\n+}\n+\n+\n+/* Returns true if the expression contains a reference to a class\n+   array.  Notice that class array elements return false.  */\n+\n+bool\n+gfc_is_class_array_ref (gfc_expr *e, bool *full_array)\n+{\n+  gfc_ref *ref;\n+\n+  if (!e->rank)\n+    return false;\n+\n+  if (full_array)\n+    *full_array= false;\n+\n+  /* Is this a class array object? ie. Is the symbol of type class?  */\n+  if (e->symtree\n+\t&& e->symtree->n.sym->ts.type == BT_CLASS\n+\t&& CLASS_DATA (e->symtree->n.sym)\n+\t&& CLASS_DATA (e->symtree->n.sym)->attr.dimension\n+\t&& class_array_ref_detected (e->ref, full_array))\n+    return true;\n+\n+  /* Or is this a class array component reference?  */\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t    && ref->u.c.component->ts.type == BT_CLASS\n+\t    && CLASS_DATA (ref->u.c.component)->attr.dimension\n+\t    && class_array_ref_detected (ref->next, full_array))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Returns true if the expression is a reference to a class\n+   scalar.  This function is necessary because such expressions\n+   can be dressed with a reference to the _data component and so\n+   have a type other than BT_CLASS.  */\n+\n+bool\n+gfc_is_class_scalar_expr (gfc_expr *e)\n+{\n+  gfc_ref *ref;\n+\n+  if (e->rank)\n+    return false;\n+\n+  /* Is this a class object?  */\n+  if (e->symtree\n+\t&& e->symtree->n.sym->ts.type == BT_CLASS\n+\t&& CLASS_DATA (e->symtree->n.sym)\n+\t&& !CLASS_DATA (e->symtree->n.sym)->attr.dimension\n+\t&& (e->ref == NULL\n+\t    || (strcmp (e->ref->u.c.component->name, \"_data\") == 0\n+\t\t&& e->ref->next == NULL)))\n+    return true;\n+\n+  /* Or is the final reference BT_CLASS or _data?  */\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t    && ref->u.c.component->ts.type == BT_CLASS\n+\t    && CLASS_DATA (ref->u.c.component)\n+\t    && !CLASS_DATA (ref->u.c.component)->attr.dimension\n+\t    && (ref->next == NULL\n+\t\t|| (strcmp (ref->next->u.c.component->name, \"_data\") == 0\n+\t\t    && ref->next->next == NULL)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Build a NULL initializer for CLASS pointers,\n    initializing the _data component to NULL and\n    the _vptr component to the declared type.  */\n@@ -183,7 +339,14 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   gfc_symbol *fclass;\n   gfc_symbol *vtab;\n   gfc_component *c;\n-  \n+\n+  if (as && *as && (*as)->type == AS_ASSUMED_SIZE)\n+    {\n+      gfc_error (\"Assumed size polymorphic objects or components, such \"\n+\t\t \"as that at %C, have not yet been implemented\");\n+      return FAILURE;\n+    }\n+\n   if (attr->class_ok)\n     /* Class container has already been built.  */\n     return SUCCESS;\n@@ -195,12 +358,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n     /* We can not build the class container yet.  */\n     return SUCCESS;\n \n-  if (*as)\n-    {\n-      gfc_fatal_error (\"Polymorphic array at %C not yet supported\");\n-      return FAILURE;\n-    }\n-\n   /* Determine the name of the encapsulating type.  */\n   get_unique_hashed_string (tname, ts->u.derived);\n   if ((*as) && (*as)->rank && attr->allocatable)\n@@ -277,8 +434,8 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   fclass->attr.extension = ts->u.derived->attr.extension + 1;\n   fclass->attr.is_class = 1;\n   ts->u.derived = fclass;\n-  attr->allocatable = attr->pointer = attr->dimension = 0;\n-  (*as) = NULL;  /* XXX */\n+  attr->allocatable = attr->pointer = attr->dimension = attr->codimension = 0;\n+  (*as) = NULL;\n   return SUCCESS;\n }\n \n@@ -402,7 +559,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   gfc_namespace *ns;\n   gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n-  \n+\n   /* Find the top-level namespace (MODULE or PROGRAM).  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n     if (!ns->parent)\n@@ -556,6 +713,9 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  copy->attr.flavor = FL_PROCEDURE;\n \t\t  copy->attr.subroutine = 1;\n \t\t  copy->attr.if_source = IFSRC_DECL;\n+\t\t  /* This is elemental so that arrays are automatically\n+\t\t     treated correctly by the scalarizer.  */\n+\t\t  copy->attr.elemental = 1;\n \t\t  if (ns->proc_name->attr.flavor == FL_MODULE)\n \t\t    copy->module = ns->proc_name->name;\n \t\t  gfc_set_sym_referenced (copy);\n@@ -565,6 +725,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  src->ts.u.derived = derived;\n \t\t  src->attr.flavor = FL_VARIABLE;\n \t\t  src->attr.dummy = 1;\n+\t\t  src->attr.intent = INTENT_IN;\n \t\t  gfc_set_sym_referenced (src);\n \t\t  copy->formal = gfc_get_formal_arglist ();\n \t\t  copy->formal->sym = src;\n@@ -573,6 +734,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  dst->ts.u.derived = derived;\n \t\t  dst->attr.flavor = FL_VARIABLE;\n \t\t  dst->attr.dummy = 1;\n+\t\t  dst->attr.intent = INTENT_OUT;\n \t\t  gfc_set_sym_referenced (dst);\n \t\t  copy->formal->next = gfc_get_formal_arglist ();\n \t\t  copy->formal->next->sym = dst;"}, {"sha": "d8ae04f049421121ab5f850e8dde4686c58301f9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -4309,7 +4309,11 @@ gfc_get_corank (gfc_expr *e)\n   if (!gfc_is_coarray (e))\n     return 0;\n \n-  corank = e->symtree->n.sym->as ? e->symtree->n.sym->as->corank : 0;\n+  if (e->ts.type == BT_CLASS && e->ts.u.derived->components)\n+    corank = e->ts.u.derived->components->as\n+\t     ? e->ts.u.derived->components->as->corank : 0;\n+  else \n+    corank = e->symtree->n.sym->as ? e->symtree->n.sym->as->corank : 0;\n \n   for (ref = e->ref; ref; ref = ref->next)\n     {\n@@ -4394,6 +4398,7 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n   int i;\n   gfc_array_ref *ar = NULL;\n   gfc_ref *ref, *part_ref = NULL;\n+  gfc_symbol *sym;\n \n   if (expr->expr_type == EXPR_FUNCTION)\n     return expr->value.function.esym\n@@ -4417,11 +4422,15 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n \tar = &ref->u.ar;\n     }\n \n-  if ((part_ref && !part_ref->u.c.component->attr.contiguous\n-       && part_ref->u.c.component->attr.pointer)\n-      || (!part_ref && !expr->symtree->n.sym->attr.contiguous\n-\t  && (expr->symtree->n.sym->attr.pointer\n-\t      || expr->symtree->n.sym->as->type == AS_ASSUMED_SHAPE)))\n+  sym = expr->symtree->n.sym;\n+  if (expr->ts.type != BT_CLASS\n+\t&& ((part_ref\n+\t\t&& !part_ref->u.c.component->attr.contiguous\n+\t\t&& part_ref->u.c.component->attr.pointer)\n+\t    || (!part_ref\n+\t\t&& !sym->attr.contiguous\n+\t\t&& (sym->attr.pointer\n+\t\t      || sym->as->type == AS_ASSUMED_SHAPE))))\n     return false;\n \n   if (!ar || ar->type == AR_FULL)"}, {"sha": "daa28965189515dfe4ef234a1d06c885d5f7361e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -2911,11 +2911,14 @@ gfc_try gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n \n /* class.c */\n void gfc_add_component_ref (gfc_expr *, const char *);\n+void gfc_add_class_array_ref (gfc_expr *);\n #define gfc_add_data_component(e)     gfc_add_component_ref(e,\"_data\")\n #define gfc_add_vptr_component(e)     gfc_add_component_ref(e,\"_vptr\")\n #define gfc_add_hash_component(e)     gfc_add_component_ref(e,\"_hash\")\n #define gfc_add_size_component(e)     gfc_add_component_ref(e,\"_size\")\n #define gfc_add_def_init_component(e) gfc_add_component_ref(e,\"_def_init\")\n+bool gfc_is_class_array_ref (gfc_expr *, bool *);\n+bool gfc_is_class_scalar_expr (gfc_expr *);\n gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n unsigned int gfc_hash_value (gfc_symbol *);\n gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,"}, {"sha": "e914c6c7910e2140e34a3104b5195464b0de2cbf", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1541,6 +1541,9 @@ gfc_check_interfaces (gfc_namespace *ns)\n static int\n symbol_rank (gfc_symbol *sym)\n {\n+  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)\n+    return CLASS_DATA (sym)->as->rank;\n+\n   return (sym->as == NULL) ? 0 : sym->as->rank;\n }\n \n@@ -1691,7 +1694,10 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && actual->ts.type != BT_HOLLERITH\n-      && !gfc_compare_types (&formal->ts, &actual->ts))\n+      && !gfc_compare_types (&formal->ts, &actual->ts)\n+      && !(formal->ts.type == BT_DERIVED && actual->ts.type == BT_CLASS\n+\t   && gfc_compare_derived_types (formal->ts.u.derived, \n+\t\t\t\t\t CLASS_DATA (actual)->ts.u.derived)))\n     {\n       if (where)\n \tgfc_error (\"Type mismatch in argument '%s' at %L; passed %s to %s\",\n@@ -1820,6 +1826,10 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (symbol_rank (formal) == actual->rank)\n     return 1;\n \n+  if (actual->ts.type == BT_CLASS && CLASS_DATA (actual)->as\n+\t&& CLASS_DATA (actual)->as->rank == symbol_rank (formal))\n+    return 1;\n+\n   rank_check = where != NULL && !is_elemental && formal->as\n \t       && (formal->as->type == AS_ASSUMED_SHAPE\n \t\t   || formal->as->type == AS_DEFERRED)\n@@ -1829,7 +1839,11 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (rank_check || ranks_must_agree\n       || (formal->attr.pointer && actual->expr_type != EXPR_NULL)\n       || (actual->rank != 0 && !(is_elemental || formal->attr.dimension))\n-      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE\n+      || (actual->rank == 0\n+\t  && ((formal->ts.type == BT_CLASS\n+\t       && CLASS_DATA (formal)->as->type == AS_ASSUMED_SHAPE)\n+\t      || (formal->ts.type != BT_CLASS\n+\t\t   && formal->as->type == AS_ASSUMED_SHAPE))\n \t  && actual->expr_type != EXPR_NULL)\n       || (actual->rank == 0 && formal->attr.dimension\n \t  && gfc_is_coindexed (actual)))\n@@ -2158,6 +2172,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n   gfc_formal_arglist *f;\n   int i, n, na;\n   unsigned long actual_size, formal_size;\n+  bool full_array = false;\n \n   actual = *ap;\n \n@@ -2297,6 +2312,9 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return 0;\n \t}\n \n+      if (f->sym->ts.type == BT_CLASS)\n+\tgoto skip_size_check;\n+\n       actual_size = get_expr_storage_size (a->expr);\n       formal_size = get_sym_storage_size (f->sym);\n       if (actual_size != 0 && actual_size < formal_size\n@@ -2316,6 +2334,8 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return  0;\n \t}\n \n+     skip_size_check:\n+\n       /* Satisfy 12.4.1.3 by ensuring that a procedure pointer actual argument\n \t is provided for a procedure pointer formal argument.  */\n       if (f->sym->attr.proc_pointer\n@@ -2428,6 +2448,18 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return 0;\n \t}\n \n+     if (f->sym->ts.type == BT_CLASS\n+\t   && CLASS_DATA (f->sym)->attr.allocatable\n+\t   && gfc_is_class_array_ref (a->expr, &full_array)\n+\t   && !full_array)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual CLASS array argument for '%s' must be a full \"\n+\t\t       \"array at %L\", f->sym->name, &a->expr->where);\n+\t  return 0;\n+\t}\n+\n+\n       if (a->expr->expr_type != EXPR_NULL\n \t  && compare_allocatable (f->sym, a->expr) == 0)\n \t{"}, {"sha": "0e12730015013b8fb3d6c7659aa214be8e0acec8", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -5151,6 +5151,27 @@ select_type_set_tmp (gfc_typespec *ts)\n     sprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);\n+\n+/* Copy across the array spec to the selector, taking care as to\n+   whether or not it is a class object or not.  */\n+  if (select_type_stack->selector->ts.type == BT_CLASS &&\n+      CLASS_DATA (select_type_stack->selector)->attr.dimension)\n+    {\n+      if (ts->type == BT_CLASS)\n+\t{\n+\t  CLASS_DATA (tmp->n.sym)->attr.dimension = 1;\n+\t  CLASS_DATA (tmp->n.sym)->as = gfc_get_array_spec ();\n+\t  CLASS_DATA (tmp->n.sym)->as\n+\t\t\t= CLASS_DATA (select_type_stack->selector)->as;\n+\t}\n+      else\n+\t{\n+\t  tmp->n.sym->attr.dimension = 1;\n+\t  tmp->n.sym->as = gfc_get_array_spec ();\n+\t  tmp->n.sym->as = CLASS_DATA (select_type_stack->selector)->as;\n+\t}\n+    }\n+\n   gfc_set_sym_referenced (tmp->n.sym);\n   gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n   tmp->n.sym->attr.select_type_temporary = 1;\n@@ -5176,6 +5197,7 @@ gfc_match_select_type (void)\n   gfc_expr *expr1, *expr2 = NULL;\n   match m;\n   char name[GFC_MAX_SYMBOL_LEN];\n+  bool class_array;\n \n   m = gfc_match_label ();\n   if (m == MATCH_ERROR)\n@@ -5216,8 +5238,24 @@ gfc_match_select_type (void)\n   if (m != MATCH_YES)\n     goto cleanup;\n \n+  /* This ghastly expression seems to be needed to distinguish a CLASS\n+     array, which can have a reference, from other expressions that\n+     have references, such as derived type components, and are not\n+     allowed by the standard.\n+     TODO; see is it is sufficent to exclude component and substring\n+     references.  */\n+  class_array = expr1->expr_type == EXPR_VARIABLE\n+\t\t  && expr1->ts.type != BT_UNKNOWN\n+\t\t  && CLASS_DATA (expr1)\n+\t\t  && (strcmp (CLASS_DATA (expr1)->name, \"_data\") == 0)\n+\t\t  && CLASS_DATA (expr1)->attr.dimension\n+\t\t  && expr1->ref\n+\t\t  && expr1->ref->type == REF_ARRAY\n+\t\t  && expr1->ref->next == NULL;\n+\n   /* Check for F03:C811.  */\n-  if (!expr2 && (expr1->expr_type != EXPR_VARIABLE || expr1->ref != NULL))\n+  if (!expr2 && (expr1->expr_type != EXPR_VARIABLE\n+\t\t  || (!class_array && expr1->ref != NULL)))\n     {\n       gfc_error (\"Selector in SELECT TYPE at %C is not a named variable; \"\n \t\t \"use associate-name=>\");"}, {"sha": "75c7e137187ad6425ca44a946b21273782064954", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1789,13 +1789,17 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   if (gfc_peek_ascii_char () == '[')\n     {\n-      if (sym->attr.dimension)\n+      if ((sym->ts.type != BT_CLASS && sym->attr.dimension)\n+\t  || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t      && CLASS_DATA (sym)->attr.dimension))\n \t{\n \t  gfc_error (\"Array section designator, e.g. '(:)', is required \"\n \t\t     \"besides the coarray designator '[...]' at %C\");\n \t  return MATCH_ERROR;\n \t}\n-      if (!sym->attr.codimension)\n+      if ((sym->ts.type != BT_CLASS && !sym->attr.codimension)\n+\t  || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t      && !CLASS_DATA (sym)->attr.codimension))\n \t{\n \t  gfc_error (\"Coarray designator at %C but '%s' is not a coarray\",\n \t\t     sym->name);\n@@ -1827,7 +1831,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n       m = gfc_match_array_ref (&tail->u.ar, equiv_flag ? NULL : sym->as,\n \t\t\t       equiv_flag,\n-\t\t\t       sym->ts.type == BT_CLASS\n+\t\t\t       sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t\t\t       ? (CLASS_DATA (sym)->as\n \t\t\t\t  ? CLASS_DATA (sym)->as->corank : 0)\n \t\t\t       : (sym->as ? sym->as->corank : 0));\n@@ -2909,6 +2913,22 @@ gfc_match_rvalue (gfc_expr **result)\n \t  break;\n \t}\n \n+      if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)\n+\t{\n+\t  if (gfc_add_flavor (&sym->attr, FL_VARIABLE,\n+\t\t\t      sym->name, NULL) == FAILURE)\n+\t    {\n+\t      m = MATCH_ERROR;\n+\t      break;\n+\t    }\n+\n+\t  e = gfc_get_expr ();\n+\t  e->symtree = symtree;\n+\t  e->expr_type = EXPR_VARIABLE;\n+\t  m = gfc_match_varspec (e, 0, false, true);\n+\t  break;\n+\t}\n+\n       /* Name is not an array, so we peek to see if a '(' implies a\n \t function call or a substring reference.  Otherwise the\n \t variable is just a scalar.  */"}, {"sha": "b4a9d1cadf88dec45234fc3d0d8c02efe2bd7954", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -5584,14 +5584,6 @@ check_typebound_baseobject (gfc_expr* e)\n       goto cleanup;\n     }\n \n-  /* FIXME: Remove once PR 43214 is fixed (TBP with non-scalar PASS).  */\n-  if (base->rank > 0)\n-    {\n-      gfc_error (\"Non-scalar base object at %L currently not implemented\",\n-\t\t &e->where);\n-      goto cleanup;\n-    }\n-\n   return_value = SUCCESS;\n \n cleanup:\n@@ -6765,7 +6757,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     }\n   else\n     {\n-      if (sym->ts.type == BT_CLASS)\n+      if (sym->ts.type == BT_CLASS && CLASS_DATA (sym))\n \t{\n \t  allocatable = CLASS_DATA (sym)->attr.allocatable;\n \t  pointer = CLASS_DATA (sym)->attr.class_pointer;\n@@ -6911,7 +6903,16 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   if (t == FAILURE)\n     goto failure;\n \n-  if (!code->expr3)\n+  if (e->ts.type == BT_CLASS && CLASS_DATA (e)->attr.dimension\n+\t&& !code->expr3 && code->ext.alloc.ts.type == BT_DERIVED)\n+    {\n+      /* For class arrays, the initialization with SOURCE is done\n+\t using _copy and trans_call. It is convenient to exploit that\n+\t when the allocated type is different from the declared type but\n+\t no SOURCE exists by setting expr3.  */\n+      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts); \n+    }\n+  else if (!code->expr3)\n     {\n       /* Set up default initializer if needed.  */\n       gfc_typespec ts;\n@@ -6955,6 +6956,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       else if (code->ext.alloc.ts.type == BT_DERIVED)\n \tts = code->ext.alloc.ts;\n       gfc_find_derived_vtab (ts.u.derived);\n+      if (dimension)\n+\te = gfc_expr_to_initialize (e);\n     }\n \n   if (dimension == 0 && codimension == 0)\n@@ -7531,16 +7534,6 @@ resolve_select (gfc_code *code)\n       return;\n     }\n \n-  if (case_expr->rank != 0)\n-    {\n-      gfc_error (\"Argument of SELECT statement at %L must be a scalar \"\n-\t\t \"expression\", &case_expr->where);\n-\n-      /* Punt.  */\n-      return;\n-    }\n-\n-\n   /* Raise a warning if an INTEGER case value exceeds the range of\n      the case-expr. Later, all expressions will be promoted to the\n      largest kind of all case-labels.  */\n@@ -7825,6 +7818,9 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       sym->attr.volatile_ = tsym->attr.volatile_;\n \n       sym->attr.target = (tsym->attr.target || tsym->attr.pointer);\n+\n+      if (sym->ts.type == BT_DERIVED && target->symtree->n.sym->ts.type == BT_CLASS)\n+\ttarget->rank = sym->as ? sym->as->rank : 0;\n     }\n \n   /* Get type if this was not already set.  Note that it can be\n@@ -7839,7 +7835,10 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \t\t\t  && !gfc_has_vector_subscript (target));\n \n   /* Finally resolve if this is an array or not.  */\n-  if (sym->attr.dimension && target->rank == 0)\n+  if (sym->attr.dimension\n+\t&& (target->ts.type == BT_CLASS\n+\t      ? !CLASS_DATA (target)->attr.dimension\n+\t      : target->rank == 0))\n     {\n       gfc_error (\"Associate-name '%s' at %L is used as array\",\n \t\t sym->name, &sym->declared_at);\n@@ -7955,6 +7954,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n       assoc = gfc_get_association_list ();\n       assoc->st = code->expr1->symtree;\n       assoc->target = gfc_copy_expr (code->expr2);\n+      assoc->target->where = code->expr2->where;\n       /* assoc->variable will be set by resolve_assoc_var.  */\n       \n       code->ext.block.assoc = assoc;\n@@ -8006,6 +8006,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n       st = gfc_find_symtree (ns->sym_root, name);\n       gcc_assert (st->n.sym->assoc);\n       st->n.sym->assoc->target = gfc_get_variable_expr (code->expr1->symtree);\n+      st->n.sym->assoc->target->where = code->expr1->where;\n       if (c->ts.type == BT_DERIVED)\n \tgfc_add_data_component (st->n.sym->assoc->target);\n \n@@ -11432,7 +11433,8 @@ resolve_fl_derived0 (gfc_symbol *sym)\n   for (c = sym->components; c != NULL; c = c->next)\n     {\n       /* F2008, C442.  */\n-      if (c->attr.codimension /* FIXME: c->as check due to PR 43412.  */\n+      if ((!sym->attr.is_class || c != sym->components)\n+\t  && c->attr.codimension\n \t  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))\n \t{\n \t  gfc_error (\"Coarray component '%s' at %L must be allocatable with \""}, {"sha": "e82753abd773b032047b799fc4c4a5891f364e12", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -3326,6 +3326,9 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n   gfc_array_spec *as;\n   int d;\n \n+  if (array->ts.type == BT_CLASS)\n+    return NULL;\n+\n   if (array->expr_type != EXPR_VARIABLE)\n     {\n       as = NULL;\n@@ -3462,7 +3465,9 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n     return NULL;\n \n   /* Follow any component references.  */\n-  as = array->symtree->n.sym->as;\n+  as = (array->ts.type == BT_CLASS && array->ts.u.derived->components)\n+       ? array->ts.u.derived->components->as\n+       : array->symtree->n.sym->as;\n   for (ref = array->ref; ref; ref = ref->next)\n     {\n       switch (ref->type)\n@@ -3506,11 +3511,12 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t}\n     }\n \n-  gcc_unreachable ();\n+  if (!as)\n+    gcc_unreachable ();\n \n  done:\n \n-  if (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE)\n+  if (as->cotype == AS_DEFERRED || as->cotype == AS_ASSUMED_SHAPE)\n     return NULL;\n \n   if (dim == NULL)\n@@ -3523,7 +3529,7 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       /* Simplify the cobounds for each dimension.  */\n       for (d = 0; d < as->corank; d++)\n \t{\n-\t  bounds[d] = simplify_bound_dim (array, kind, d + 1 + array->rank,\n+\t  bounds[d] = simplify_bound_dim (array, kind, d + 1 + as->rank,\n \t\t\t\t\t  upper, as, ref, true);\n \t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n \t    {\n@@ -3575,7 +3581,7 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t  return &gfc_bad_expr;\n \t}\n \n-      return simplify_bound_dim (array, kind, d+array->rank, upper, as, ref, true);\n+      return simplify_bound_dim (array, kind, d+as->rank, upper, as, ref, true);\n     }\n }\n "}, {"sha": "d441102476855bed5fac059f847ea382ce9e1511", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 145, "deletions": 20, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -2428,9 +2428,18 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n+\t  if (gfc_is_class_scalar_expr (expr))\n+\t    /* This is necessary because the dynamic type will always be\n+\t       large than the declared type.  In consequence, assigning\n+\t       the value to a temporary could segfault.\n+\t       OOP-TODO: see if this is generally correct or is the value\n+\t       has to be written to an allocated temporary, whose address\n+\t       is passed via ss_info.  */\n+\t    ss_info->data.scalar.value = se.expr;\n+\t  else\n+\t    ss_info->data.scalar.value = gfc_evaluate_now (se.expr,\n+\t\t\t\t\t\t\t   &outer_loop->pre);\n \n-\t  ss_info->data.scalar.value = gfc_evaluate_now (se.expr,\n-\t\t\t\t\t\t\t &outer_loop->pre);\n \t  ss_info->string_length = se.string_length;\n \t  break;\n \n@@ -2879,6 +2888,82 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n }\n \n \n+/* Build a scalarized array reference using the vptr 'size'.  */\n+\n+static bool\n+build_class_array_ref (gfc_se *se, tree base, tree index)\n+{\n+  tree type;\n+  tree size;\n+  tree offset;\n+  tree decl;\n+  tree tmp;\n+  gfc_expr *expr = se->ss->info->expr;\n+  gfc_ref *ref;\n+  gfc_ref *class_ref;\n+  gfc_typespec *ts;\n+\n+  if (expr == NULL || expr->ts.type != BT_CLASS)\n+    return false;\n+\n+  if (expr->symtree && expr->symtree->n.sym->ts.type == BT_CLASS)\n+    ts = &expr->symtree->n.sym->ts;\n+  else\n+    ts = NULL;\n+  class_ref = NULL;\n+\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t    && ref->u.c.component->ts.type == BT_CLASS\n+\t    && ref->next && ref->next->type == REF_COMPONENT\n+\t    && strcmp (ref->next->u.c.component->name, \"_data\") == 0\n+\t    && ref->next->next\n+\t    && ref->next->next->type == REF_ARRAY\n+\t    && ref->next->next->u.ar.type != AR_ELEMENT)\n+\t{\n+\t  ts = &ref->u.c.component->ts;\n+\t  class_ref = ref;\n+\t  break;\n+\t}\t   \n+    }\n+\n+  if (ts == NULL)\n+    return false;\n+\n+  if (class_ref == NULL)\n+    decl = expr->symtree->n.sym->backend_decl;\n+  else\n+    {\n+      /* Remove everything after the last class reference, convert the\n+\t expression and then recover its tailend once more.  */\n+      gfc_se tmpse;\n+      ref = class_ref->next;\n+      class_ref->next = NULL;\n+      gfc_init_se (&tmpse, NULL);\n+      gfc_conv_expr (&tmpse, expr);\n+      decl = tmpse.expr;\n+      class_ref->next = ref;\n+    }\n+\n+  size = gfc_vtable_size_get (decl);\n+\n+  /* Build the address of the element.  */\n+  type = TREE_TYPE (TREE_TYPE (base));\n+  size = fold_convert (TREE_TYPE (index), size);\n+  offset = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t    gfc_array_index_type,\n+\t\t\t    index, size);\n+  tmp = gfc_build_addr_expr (pvoid_type_node, base);\n+  tmp = fold_build_pointer_plus_loc (input_location, tmp, offset);\n+  tmp = fold_convert (build_pointer_type (type), tmp);\n+\n+  /* Return the element in the se expression.  */\n+  se->expr = build_fold_indirect_ref_loc (input_location, tmp);\n+  return true;\n+}\n+\n+\n /* Build a scalarized reference to an array.  */\n \n static void\n@@ -2911,6 +2996,12 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n     decl = expr->symtree->n.sym->backend_decl;\n \n   tmp = build_fold_indirect_ref_loc (input_location, info->data);\n+\n+  /* Use the vptr 'size' field to access a class the element of a class\n+     array.  */\n+  if (build_class_array_ref (se, tmp, index))\n+    return;\n+\n   se->expr = gfc_build_array_ref (tmp, index, decl);\n }\n \n@@ -4592,7 +4683,8 @@ gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n-\t\t     stmtblock_t * descriptor_block, tree * overflow)\n+\t\t     stmtblock_t * descriptor_block, tree * overflow,\n+\t\t     gfc_expr *expr3)\n {\n   tree type;\n   tree tmp;\n@@ -4747,8 +4839,30 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n     }\n \n   /* The stride is the number of elements in the array, so multiply by the\n-     size of an element to get the total size.  */\n-  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+     size of an element to get the total size.  Obviously, if there ia a\n+     SOURCE expression (expr3) we must use its element size.  */\n+  if (expr3 != NULL)\n+    {\n+      if (expr3->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_se se_sz;\n+\t  gfc_expr *sz = gfc_copy_expr (expr3);\n+\t  gfc_add_vptr_component (sz);\n+\t  gfc_add_size_component (sz);\n+\t  gfc_init_se (&se_sz, NULL);\n+\t  gfc_conv_expr (&se_sz, sz);\n+\t  gfc_free_expr (sz);\n+\t  tmp = se_sz.expr;\n+\t}\n+      else\n+\t{\n+\t  tmp = gfc_typenode_for_spec (&expr3->ts);\n+\t  tmp = TYPE_SIZE_UNIT (tmp);\n+\t}\n+    }\n+  else\n+    tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\n   /* Convert to size_t.  */\n   element_size = fold_convert (size_type_node, tmp);\n \n@@ -4813,7 +4927,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n-\t\t    tree errlen)\n+\t\t    tree errlen, gfc_expr *expr3)\n {\n   tree tmp;\n   tree pointer;\n@@ -4897,7 +5011,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   gfc_init_block (&set_descriptor_block);\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n-\t\t\t      &se->pre, &set_descriptor_block, &overflow);\n+\t\t\t      &se->pre, &set_descriptor_block, &overflow,\n+\t\t\t      expr3);\n \n   if (dimension)\n     {\n@@ -4972,7 +5087,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   else\n       gfc_add_expr_to_block (&se->pre, set_descriptor);\n \n-  if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n+  if ((expr->ts.type == BT_DERIVED)\n \t&& expr->ts.u.derived->attr.alloc_comp)\n     {\n       tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, se->expr,\n@@ -7240,7 +7355,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n-\t      /* Allocatable scalar CLASS components.  */\n+\t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      \n@@ -7249,13 +7364,18 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n \n-\t      tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n-\t\t\t\t\t\t       CLASS_DATA (c)->ts);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      if (GFC_DESCRIPTOR_TYPE_P(TREE_TYPE (comp)))\n+\t        tmp = gfc_trans_dealloc_allocated (comp);\n+\t      else\n+\t\t{\n+\t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n+\t\t\t\t\t\t\t   CLASS_DATA (c)->ts);\n+\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \n-\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t     void_type_node, comp,\n-\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n+\t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t\t void_type_node, comp,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t\t}\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  break;\n@@ -7282,17 +7402,22 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n-\t      /* Allocatable scalar CLASS components.  */\n+\t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      /* Add reference to '_data' component.  */\n \t      tmp = CLASS_DATA (c)->backend_decl;\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n-\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t     void_type_node, comp,\n-\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      if (GFC_DESCRIPTOR_TYPE_P(TREE_TYPE (comp)))\n+\t\tgfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n+\t      else\n+\t\t{\n+\t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t\t void_type_node, comp,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t\t}\n \t    }\n           else if (cmp_has_alloc_comps)\n \t    {"}, {"sha": "340c1a7c94c8c7b678e74c5a31a67a0691f27c90", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -22,9 +22,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Generate code to free an array.  */\n tree gfc_array_deallocate (tree, tree, gfc_expr*);\n \n-/* Generate code to initialize an allocate an array.  Statements are added to\n+/* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n-bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree);\n+bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, gfc_expr *);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,"}, {"sha": "1f1696feaf2e82ca7ea23d9f80c1d3be814b4728", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1293,7 +1293,12 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  && DECL_CONTEXT (sym->backend_decl) != current_function_decl)\n \tgfc_nonlocal_dummy_array_decl (sym);\n \n-      return sym->backend_decl;\n+      if (sym->ts.type == BT_CLASS && sym->backend_decl)\n+\tGFC_DECL_CLASS(sym->backend_decl) = 1;\n+\n+      if (sym->ts.type == BT_CLASS && sym->backend_decl)\n+\tGFC_DECL_CLASS(sym->backend_decl) = 1;\n+     return sym->backend_decl;\n     }\n \n   if (sym->backend_decl)\n@@ -1314,7 +1319,11 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t&& !intrinsic_array_parameter\n \t&& sym->module\n \t&& gfc_get_module_backend_decl (sym))\n-    return sym->backend_decl;\n+    {\n+      if (sym->ts.type == BT_CLASS && sym->backend_decl)\n+\tGFC_DECL_CLASS(sym->backend_decl) = 1;\n+      return sym->backend_decl;\n+    }\n \n   if (sym->attr.flavor == FL_PROCEDURE)\n     {\n@@ -1431,6 +1440,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       GFC_TYPE_ARRAY_SPAN (TREE_TYPE (decl)) = span;\n     }\n \n+  if (sym->ts.type == BT_CLASS)\n+\tGFC_DECL_CLASS(decl) = 1;\n+\n   sym->backend_decl = decl;\n \n   if (sym->attr.assign)\n@@ -3655,6 +3667,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  if (sym_has_alloc_comp && !seen_trans_deferred_array)\n \t    gfc_trans_deferred_array (sym, block);\n \t}\n+      else if ((!sym->attr.dummy || sym->ts.deferred)\n+\t\t&& (sym->ts.type == BT_CLASS\n+\t\t&& CLASS_DATA (sym)->attr.pointer))\n+\tbreak;\n       else if ((!sym->attr.dummy || sym->ts.deferred)\n \t\t&& (sym->attr.allocatable\n \t\t    || (sym->ts.type == BT_CLASS\n@@ -3669,8 +3685,26 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\tgfc_add_data_component (e);\n \n \t      gfc_init_se (&se, NULL);\n-\t      se.want_pointer = 1;\n-\t      gfc_conv_expr (&se, e);\n+\t      if (sym->ts.type != BT_CLASS\n+\t\t  || sym->ts.u.derived->attr.dimension\n+\t\t  || sym->ts.u.derived->attr.codimension)\n+\t\t{\n+\t\t  se.want_pointer = 1;\n+\t\t  gfc_conv_expr (&se, e);\n+\t\t}\n+\t      else if (sym->ts.type == BT_CLASS\n+\t\t       && !CLASS_DATA (sym)->attr.dimension\n+\t\t       && !CLASS_DATA (sym)->attr.codimension)\n+\t\t{\n+\t\t  se.want_pointer = 1;\n+\t\t  gfc_conv_expr (&se, e);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gfc_conv_expr (&se, e);\n+\t\t  se.expr = gfc_conv_descriptor_data_addr (se.expr);\n+\t\t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+\t\t}\n \t      gfc_free_expr (e);\n \n \t      gfc_save_backend_locus (&loc);"}, {"sha": "b1c85e14c491560e7cfba15e7c74a722acc1b87a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 386, "deletions": 72, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -41,6 +41,270 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-stmt.h\"\n #include \"dependency.h\"\n \n+\n+/* This is the seed for an eventual trans-class.c\n+\n+   The following parameters should not be used directly since they might\n+   in future implementations.  Use the corresponding APIs.  */\n+#define CLASS_DATA_FIELD 0\n+#define CLASS_VPTR_FIELD 1\n+#define VTABLE_HASH_FIELD 0\n+#define VTABLE_SIZE_FIELD 1\n+#define VTABLE_EXTENDS_FIELD 2\n+#define VTABLE_DEF_INIT_FIELD 3\n+#define VTABLE_COPY_FIELD 4\n+\n+\n+tree\n+gfc_class_data_get (tree decl)\n+{\n+  tree data;\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n+  data = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n+\t\t\t    CLASS_DATA_FIELD);\n+  return fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t  TREE_TYPE (data), decl, data,\n+\t\t\t  NULL_TREE);\n+}\n+\n+\n+tree\n+gfc_class_vptr_get (tree decl)\n+{\n+  tree vptr;\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n+  vptr = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n+\t\t\t    CLASS_VPTR_FIELD);\n+  return fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t  TREE_TYPE (vptr), decl, vptr,\n+\t\t\t  NULL_TREE);\n+}\n+\n+\n+static tree\n+gfc_vtable_field_get (tree decl, int field)\n+{\n+  tree size;\n+  tree vptr;\n+  vptr = gfc_class_vptr_get (decl);\n+  vptr = build_fold_indirect_ref_loc (input_location, vptr);\n+  size = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (vptr)),\n+\t\t\t    field);\n+  size = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t  TREE_TYPE (size), vptr, size,\n+\t\t\t  NULL_TREE);\n+  /* Always return size as an array index type.  */\n+  if (field == VTABLE_SIZE_FIELD)\n+    size = fold_convert (gfc_array_index_type, size);\n+  gcc_assert (size);\n+  return size;\n+}\n+\n+\n+tree\n+gfc_vtable_hash_get (tree decl)\n+{\n+  return gfc_vtable_field_get (decl, VTABLE_HASH_FIELD);\n+}\n+\n+\n+tree\n+gfc_vtable_size_get (tree decl)\n+{\n+  return gfc_vtable_field_get (decl, VTABLE_SIZE_FIELD);\n+}\n+\n+\n+tree\n+gfc_vtable_extends_get (tree decl)\n+{\n+  return gfc_vtable_field_get (decl, VTABLE_EXTENDS_FIELD);\n+}\n+\n+\n+tree\n+gfc_vtable_def_init_get (tree decl)\n+{\n+  return gfc_vtable_field_get (decl, VTABLE_DEF_INIT_FIELD);\n+}\n+\n+\n+tree\n+gfc_vtable_copy_get (tree decl)\n+{\n+  return gfc_vtable_field_get (decl, VTABLE_COPY_FIELD);\n+}\n+\n+\n+#undef CLASS_DATA_FIELD\n+#undef CLASS_VPTR_FIELD\n+#undef VTABLE_HASH_FIELD\n+#undef VTABLE_SIZE_FIELD\n+#undef VTABLE_EXTENDS_FIELD\n+#undef VTABLE_DEF_INIT_FIELD\n+#undef VTABLE_COPY_FIELD\n+\n+\n+/* Takes a derived type expression and returns the address of a temporary\n+   class object of the 'declared' type.  */ \n+static void\n+gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n+\t\t\t   gfc_typespec class_ts)\n+{\n+  gfc_symbol *vtab;\n+  gfc_ss *ss;\n+  tree ctree;\n+  tree var;\n+  tree tmp;\n+\n+  /* The derived type needs to be converted to a temporary\n+     CLASS object.  */\n+  tmp = gfc_typenode_for_spec (&class_ts);\n+  var = gfc_create_var (tmp, \"class\");\n+\n+  /* Set the vptr.  */\n+  ctree =  gfc_class_vptr_get (var);\n+\n+  /* Remember the vtab corresponds to the derived type\n+     not to the class declared type.  */\n+  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n+  gcc_assert (vtab);\n+  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+  gfc_add_modify (&parmse->pre, ctree,\n+\t\t  fold_convert (TREE_TYPE (ctree), tmp));\n+\n+  /* Now set the data field.  */\n+  ctree =  gfc_class_data_get (var);\n+\n+  if (parmse->ss && parmse->ss->info->useflags)\n+    {\n+      /* For an array reference in an elemental procedure call we need\n+\t to retain the ss to provide the scalarized array reference.  */\n+      gfc_conv_expr_reference (parmse, e);\n+      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n+    }\n+  else\n+    {\n+      ss = gfc_walk_expr (e);\n+      if (ss == gfc_ss_terminator)\n+\t{\n+\t  parmse->ss = NULL;\n+\t  gfc_conv_expr_reference (parmse, e);\n+\t  tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+\t  gfc_add_modify (&parmse->pre, ctree, tmp);\n+\t}\n+      else\n+\t{\n+\t  parmse->ss = ss;\n+\t  gfc_conv_expr_descriptor (parmse, e, ss);\n+\t  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\t}\n+    }\n+\n+  /* Pass the address of the class object.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+}\n+\n+\n+/* Takes a scalarized class array expression and returns the\n+   address of a temporary scalar class object of the 'declared'\n+   type.  \n+   OOP-TODO: This could be improved by adding code that branched on\n+   the dynamic type being the same as the declared type. In this case\n+   the original class expression can be passed directly.  */ \n+static void\n+gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n+\t\t\t gfc_typespec class_ts, bool elemental)\n+{\n+  tree ctree;\n+  tree var;\n+  tree tmp;\n+  tree vptr;\n+  gfc_ref *ref;\n+  gfc_ref *class_ref;\n+  bool full_array = false;\n+\n+  class_ref = NULL;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t    && ref->u.c.component->ts.type == BT_CLASS)\n+\tclass_ref = ref;\n+\n+      if (ref->next == NULL)\n+\tbreak;\n+    }\n+\n+  if (ref == NULL || class_ref == ref)\n+    return;\n+\n+  /* Test for FULL_ARRAY.  */\n+  gfc_is_class_array_ref (e, &full_array);\n+\n+  /* The derived type needs to be converted to a temporary\n+     CLASS object.  */\n+  tmp = gfc_typenode_for_spec (&class_ts);\n+  var = gfc_create_var (tmp, \"class\");\n+\n+  /* Set the data.  */\n+  ctree = gfc_class_data_get (var);\n+  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\n+  /* Return the data component, except in the case of scalarized array\n+     references, where nullification of the cannot occur and so there\n+     is no need.  */\n+  if (!elemental && full_array)\n+    gfc_add_modify (&parmse->post, parmse->expr, ctree);\n+\n+  /* Set the vptr.  */\n+  ctree = gfc_class_vptr_get (var);\n+\n+  /* The vptr is the second field of the actual argument.\n+     First we have to find the corresponding class reference. */\n+\n+  tmp = NULL_TREE;\n+  if (class_ref == NULL\n+\t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS) \n+    tmp = e->symtree->n.sym->backend_decl;\n+  else\n+    {\n+      /* Remove everything after the last class reference, convert the\n+\t expression and then recover its tailend once more.  */\n+      gfc_se tmpse;\n+      ref = class_ref->next;\n+      class_ref->next = NULL;\n+      gfc_init_se (&tmpse, NULL);\n+      gfc_conv_expr (&tmpse, e);\n+      class_ref->next = ref;\n+      tmp = tmpse.expr;\n+    }\n+\n+  gcc_assert (tmp != NULL_TREE);\n+\n+  /* Dereference if needs be.  */\n+  if (TREE_CODE (TREE_TYPE (tmp)) == REFERENCE_TYPE)\n+    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\n+  vptr = gfc_class_vptr_get (tmp);\n+  gfc_add_modify (&parmse->pre, ctree,\n+\t\t  fold_convert (TREE_TYPE (ctree), vptr));\n+\n+  /* Return the vptr component, except in the case of scalarized array\n+     references, where the dynamic type cannot change.  */\n+  if (!elemental && full_array)\n+    gfc_add_modify (&parmse->post, vptr,\n+\t\t    fold_convert (TREE_TYPE (vptr), ctree));\n+\n+  /* Pass the address of the class object.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+}\n+\n+/* End of prototype trans-class.c  */\n+\n+\n static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n \t\t\t\t\t\t gfc_expr *);\n@@ -799,6 +1063,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t    conv_parent_component_references (se, ref);\n \n \t  gfc_conv_component_ref (se, ref);\n+\n \t  break;\n \n \tcase REF_SUBSTRING:\n@@ -2409,6 +2674,9 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n \t\t|| GFC_DESCRIPTOR_TYPE_P (base_type))\n     base_type = gfc_get_element_type (base_type);\n \n+  if (expr->ts.type == BT_CLASS)\n+    base_type = gfc_typenode_for_spec (&CLASS_DATA (expr)->ts);\n+\n   loop.temp_ss = gfc_get_temp_ss (base_type, ((expr->ts.type == BT_CHARACTER)\n \t\t\t\t\t      ? expr->ts.u.cl->backend_decl\n \t\t\t\t\t      : NULL),\n@@ -2645,64 +2913,6 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n }\n \n \n-/* Takes a derived type expression and returns the address of a temporary\n-   class object of the 'declared' type.  */ \n-static void\n-gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n-\t\t\t   gfc_typespec class_ts)\n-{\n-  gfc_component *cmp;\n-  gfc_symbol *vtab;\n-  gfc_symbol *declared = class_ts.u.derived;\n-  gfc_ss *ss;\n-  tree ctree;\n-  tree var;\n-  tree tmp;\n-\n-  /* The derived type needs to be converted to a temporary\n-     CLASS object.  */\n-  tmp = gfc_typenode_for_spec (&class_ts);\n-  var = gfc_create_var (tmp, \"class\");\n-\n-  /* Set the vptr.  */\n-  cmp = gfc_find_component (declared, \"_vptr\", true, true);\n-  ctree = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t   TREE_TYPE (cmp->backend_decl),\n-\t\t\t   var, cmp->backend_decl, NULL_TREE);\n-\n-  /* Remember the vtab corresponds to the derived type\n-     not to the class declared type.  */\n-  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n-  gcc_assert (vtab);\n-  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n-  gfc_add_modify (&parmse->pre, ctree,\n-\t\t  fold_convert (TREE_TYPE (ctree), tmp));\n-\n-  /* Now set the data field.  */\n-  cmp = gfc_find_component (declared, \"_data\", true, true);\n-  ctree = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t   TREE_TYPE (cmp->backend_decl),\n-\t\t\t   var, cmp->backend_decl, NULL_TREE);\n-  ss = gfc_walk_expr (e);\n-  if (ss == gfc_ss_terminator)\n-    {\n-      parmse->ss = NULL;\n-      gfc_conv_expr_reference (parmse, e);\n-      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n-      gfc_add_modify (&parmse->pre, ctree, tmp);\n-    }\n-  else\n-    {\n-      parmse->ss = ss;\n-      gfc_conv_expr (parmse, e);\n-      gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n-    }\n-\n-  /* Pass the address of the class object.  */\n-  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n-}\n-\n-\n /* The following routine generates code for the intrinsic\n    procedures from the ISO_C_BINDING module:\n     * C_LOC           (function)\n@@ -2954,6 +3164,19 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n \n+      /* Class array expressions are sometimes coming completely unadorned\n+\t with either arrayspec or _data component.  Correct that here.\n+\t OOP-TODO: Move this to the frontend.  */\n+      if (e && e->expr_type == EXPR_VARIABLE\n+\t    && !e->ref\n+\t    && e->ts.type == BT_CLASS\n+\t    && CLASS_DATA (e)->attr.dimension)\n+\t{\n+\t  gfc_typespec temp_ts = e->ts;\n+\t  gfc_add_class_array_ref (e);\n+\t  e->ts = temp_ts;\n+\t}\n+\n       if (e == NULL)\n \t{\n \t  if (se->ignore_optional)\n@@ -3010,6 +3233,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    }\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);\n+\n+\t  /* The scalarizer does not repackage the reference to a class\n+\t     array - instead it returns a pointer to the data element.  */\n+\t  if (fsym && fsym->ts.type == BT_CLASS && e->ts.type == BT_CLASS)\n+\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, true);\n \t}\n       else\n \t{\n@@ -3073,6 +3301,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  gfc_conv_expr_reference (&parmse, e);\n \n+\t\t  /* A class array element needs converting back to be a\n+\t\t     class object, if the formal argument is a class object.  */\n+\t\t  if (fsym && fsym->ts.type == BT_CLASS\n+\t\t\t&& e->ts.type == BT_CLASS\n+\t\t\t&& CLASS_DATA (e)->attr.dimension)\n+\t\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n+\n \t\t  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n \t\t     allocated on entry, it must be deallocated.  */\n \t\t  if (fsym && fsym->attr.allocatable\n@@ -3124,6 +3359,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    }\n \t\t}\n \t    }\n+\t  else if (e->ts.type == BT_CLASS\n+\t\t    && fsym && fsym->ts.type == BT_CLASS\n+\t\t    && CLASS_DATA (fsym)->attr.dimension)\n+\t    {\n+\t      /* Pass a class array.  */\n+\t      gfc_init_se (&parmse, se);\n+\t      gfc_conv_expr_descriptor (&parmse, e, argss);\n+\t      /* The conversion does not repackage the reference to a class\n+\t         array - _data descriptor.  */\n+\t      gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n+\t    }\n \t  else\n \t    {\n               /* If the procedure requires an explicit interface, the actual\n@@ -3188,6 +3434,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_subref_array_arg (&parmse, e, f,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n+\t      else if (gfc_is_class_array_ref (e, NULL)\n+\t\t\t && fsym && fsym->ts.type == BT_DERIVED)\n+\t\t/* The actual argument is a component reference to an\n+\t\t   array of derived types.  In this case, the argument\n+\t\t   is converted to a temporary, which is passed and then\n+\t\t   written back after the procedure call.\n+\t\t   OOP-TODO: Insert code so that if the dynamic type is\n+\t\t   the same as the declared type, copy-in/copy-out does\n+\t\t   not occur.  */\n+\t\tgfc_conv_subref_array_arg (&parmse, e, f,\n+\t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n+\t\t\t\tfsym && fsym->attr.pointer);\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,\n \t\t\t\t\t  sym->name, NULL);\n@@ -4895,7 +5153,12 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n           expr->ts.kind = expr->ts.u.derived->ts.kind;\n         }\n     }\n-  \n+\n+  /* TODO: make this work for general class array expressions.  */\n+  if (expr->ts.type == BT_CLASS\n+\t&& expr->ref && expr->ref->type == REF_ARRAY)\n+    gfc_add_component_ref (expr, \"_data\");\n+\n   switch (expr->expr_type)\n     {\n     case EXPR_OP:\n@@ -6469,6 +6732,36 @@ gfc_trans_assign (gfc_code * code)\n }\n \n \n+static tree\n+gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n+{\n+  gfc_actual_arglist *actual;\n+  gfc_expr *ppc;\n+  gfc_code *ppc_code;\n+  tree res;\n+\n+  actual = gfc_get_actual_arglist ();\n+  actual->expr = gfc_copy_expr (rhs);\n+  actual->next = gfc_get_actual_arglist ();\n+  actual->next->expr = gfc_copy_expr (lhs);\n+  ppc = gfc_copy_expr (obj);\n+  gfc_add_vptr_component (ppc);\n+  gfc_add_component_ref (ppc, \"_copy\");\n+  ppc_code = gfc_get_code ();\n+  ppc_code->resolved_sym = ppc->symtree->n.sym;\n+  /* Although '_copy' is set to be elemental in class.c, it is\n+     not staying that way.  Find out why, sometime....  */\n+  ppc_code->resolved_sym->attr.elemental = 1;\n+  ppc_code->ext.actual = actual;\n+  ppc_code->expr1 = ppc;\n+  ppc_code->op = EXEC_CALL;\n+  /* Since '_copy' is elemental, the scalarizer will take care\n+     of arrays in gfc_trans_call.  */\n+  res = gfc_trans_call (ppc_code, false, NULL, NULL, false);\n+  gfc_free_statements (ppc_code);\n+  return res;\n+}\n+\n /* Special case for initializing a polymorphic dummy with INTENT(OUT).\n    A MEMCPY is needed to copy the full data from the default initializer\n    of the dynamic type.  */\n@@ -6495,18 +6788,24 @@ gfc_trans_class_init_assign (gfc_code *code)\n   gfc_get_derived_type (rhs->ts.u.derived);\n   gfc_add_def_init_component (rhs);\n \n-  sz = gfc_copy_expr (code->expr1);\n-  gfc_add_vptr_component (sz);\n-  gfc_add_size_component (sz);\n-\n-  gfc_init_se (&dst, NULL);\n-  gfc_init_se (&src, NULL);\n-  gfc_init_se (&memsz, NULL);\n-  gfc_conv_expr (&dst, lhs);\n-  gfc_conv_expr (&src, rhs);\n-  gfc_conv_expr (&memsz, sz);\n-  gfc_add_block_to_block (&block, &src.pre);\n-  tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n+  if (code->expr1->ts.type == BT_CLASS\n+\t&& CLASS_DATA (code->expr1)->attr.dimension)\n+    tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n+  else\n+    {\n+      sz = gfc_copy_expr (code->expr1);\n+      gfc_add_vptr_component (sz);\n+      gfc_add_size_component (sz);\n+\n+      gfc_init_se (&dst, NULL);\n+      gfc_init_se (&src, NULL);\n+      gfc_init_se (&memsz, NULL);\n+      gfc_conv_expr (&dst, lhs);\n+      gfc_conv_expr (&src, rhs);\n+      gfc_conv_expr (&memsz, sz);\n+      gfc_add_block_to_block (&block, &src.pre);\n+      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n+    }\n   gfc_add_expr_to_block (&block, tmp);\n   \n   return gfc_finish_block (&block);\n@@ -6550,12 +6849,27 @@ gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n       tmp = gfc_trans_pointer_assignment (lhs, rhs);\n       gfc_add_expr_to_block (&block, tmp);\n \n+      gfc_free_expr (lhs);\n+      gfc_free_expr (rhs);\n+    }\n+  else if (CLASS_DATA (expr2)->attr.dimension)\n+    {\n+      /* Insert an additional assignment which sets the '_vptr' field.  */\n+      lhs = gfc_copy_expr (expr1);\n+      gfc_add_vptr_component (lhs);\n+\n+      rhs = gfc_copy_expr (expr2);\n+      gfc_add_vptr_component (rhs);\n+\n+      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n       gfc_free_expr (lhs);\n       gfc_free_expr (rhs);\n     }\n \n   /* Do the actual CLASS assignment.  */\n-  if (expr2->ts.type == BT_CLASS)\n+  if (expr2->ts.type == BT_CLASS && !CLASS_DATA (expr2)->attr.dimension)\n     op = EXEC_ASSIGN;\n   else\n     gfc_add_data_component (expr1);"}, {"sha": "58112e37ee9aebe653bb3d197928be9a30b33b54", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -5028,6 +5028,9 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   gfc_init_se (&argse, NULL);\n   actual = expr->value.function.actual;\n \n+  if (actual->expr->ts.type == BT_CLASS)\n+    gfc_add_class_array_ref (actual->expr);\n+\n   ss = gfc_walk_expr (actual->expr);\n   gcc_assert (ss != gfc_ss_terminator);\n   argse.want_pointer = 1;\n@@ -5667,14 +5670,24 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n \n   gfc_init_se (&arg1se, NULL);\n   arg1 = expr->value.function.actual;\n+\n+  if (arg1->expr->ts.type == BT_CLASS)\n+    {\n+      /* Make sure that class array expressions have both a _data\n+\t component reference and an array reference....  */\n+      if (CLASS_DATA (arg1->expr)->attr.dimension)\n+\tgfc_add_class_array_ref (arg1->expr);\n+      /* .... whilst scalars only need the _data component.  */\n+      else\n+\tgfc_add_data_component (arg1->expr);\n+    }\n+\n   ss1 = gfc_walk_expr (arg1->expr);\n \n   if (ss1 == gfc_ss_terminator)\n     {\n       /* Allocatable scalar.  */\n       arg1se.want_pointer = 1;\n-      if (arg1->expr->ts.type == BT_CLASS)\n-\tgfc_add_data_component (arg1->expr);\n       gfc_conv_expr (&arg1se, arg1->expr);\n       tmp = arg1se.expr;\n     }\n@@ -6998,6 +7011,9 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n static gfc_ss *\n gfc_walk_intrinsic_bound (gfc_ss * ss, gfc_expr * expr)\n {\n+  if (expr->value.function.actual->expr->ts.type == BT_CLASS)\n+    gfc_add_class_array_ref (expr->value.function.actual->expr);\n+\n   /* The two argument version returns a scalar.  */\n   if (expr->value.function.actual->next->expr)\n     return ss;"}, {"sha": "9e903d81bea045cf256fb2461d81b161d0a86ffb", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 136, "deletions": 62, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1093,14 +1093,19 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n {\n   gfc_expr *e;\n   tree tmp;\n+  bool class_target;\n \n   gcc_assert (sym->assoc);\n   e = sym->assoc->target;\n \n+  class_target = (e->expr_type == EXPR_VARIABLE)\n+\t\t    && (gfc_is_class_scalar_expr (e)\n+\t\t\t|| gfc_is_class_array_ref (e, NULL));\n+\n   /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n      to array temporary) for arrays with either unknown shape or if associating\n      to a variable.  */\n-  if (sym->attr.dimension\n+  if (sym->attr.dimension && !class_target\n       && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n     {\n       gfc_se se;\n@@ -1140,6 +1145,23 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t\t    gfc_finish_block (&se.post));\n     }\n \n+  /* CLASS arrays just need the descriptor to be directly assigned.  */\n+  else if (class_target && sym->attr.dimension)\n+    {\n+      gfc_se se;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, e);\n+\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)));\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (sym->backend_decl)));\n+\n+      gfc_add_modify (&se.pre, sym->backend_decl, se.expr);\n+      \n+      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n+\n   /* Do a scalar pointer assignment; this is for scalar variable targets.  */\n   else if (gfc_is_associate_pointer (sym))\n     {\n@@ -4677,6 +4699,7 @@ tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n+  gfc_expr *e;\n   gfc_expr *expr;\n   gfc_se se;\n   tree tmp;\n@@ -4748,7 +4771,7 @@ gfc_trans_allocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen))\n+      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, code->expr3))\n \t{\n \t  /* A scalar or derived type.  */\n \n@@ -4878,6 +4901,16 @@ gfc_trans_allocate (gfc_code * code)\n \t      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, tmp, 0);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n+\t  else if (al->expr->ts.type == BT_CLASS && code->expr3)\n+\t    {\n+\t      /* With class objects, it is best to play safe and null the \n+\t\t memory because we cannot know if dynamic types have allocatable\n+\t\t components or not.  */\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t\t builtin_decl_explicit (BUILT_IN_MEMSET),\n+\t\t\t\t\t 3, se.expr, integer_zero_node,  memsz);\n+\t      gfc_add_expr_to_block (&se.pre, tmp);\n+\t    }\n \t}\n \n       gfc_add_block_to_block (&block, &se.pre);\n@@ -4901,38 +4934,131 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n  \n+      /* We need the vptr of CLASS objects to be initialized.  */ \n+      e = gfc_copy_expr (al->expr);\n+      if (e->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_expr *lhs,*rhs;\n+\t  gfc_se lse;\n+\n+\t  lhs = gfc_expr_to_initialize (e);\n+\t  gfc_add_vptr_component (lhs);\n+\t  rhs = NULL;\n+\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\t    {\n+\t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n+\t      rhs = gfc_copy_expr (code->expr3);\n+\t      gfc_add_vptr_component (rhs);\n+\t      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+\t      gfc_add_expr_to_block (&block, tmp);\n+\t      gfc_free_expr (rhs);\n+\t      rhs = gfc_expr_to_initialize (e);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* VPTR is fixed at compile time.  */\n+\t      gfc_symbol *vtab;\n+\t      gfc_typespec *ts;\n+\t      if (code->expr3)\n+\t\tts = &code->expr3->ts;\n+\t      else if (e->ts.type == BT_DERIVED)\n+\t\tts = &e->ts;\n+\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n+\t\tts = &code->ext.alloc.ts;\n+\t      else if (e->ts.type == BT_CLASS)\n+\t\tts = &CLASS_DATA (e)->ts;\n+\t      else\n+\t\tts = &e->ts;\n+\n+\t      if (ts->type == BT_DERIVED)\n+\t\t{\n+\t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n+\t\t  gcc_assert (vtab);\n+\t\t  gfc_init_se (&lse, NULL);\n+\t\t  lse.want_pointer = 1;\n+\t\t  gfc_conv_expr (&lse, lhs);\n+\t\t  tmp = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t     gfc_get_symbol_decl (vtab));\n+\t\t  gfc_add_modify (&block, lse.expr,\n+\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n+\t\t}\n+\t    }\n+\t  gfc_free_expr (lhs);\n+\t}\n+\n+      gfc_free_expr (e);\n+\n       if (code->expr3 && !code->expr3->mold)\n \t{\n \t  /* Initialization via SOURCE block\n \t     (or static default initializer).  */\n \t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n \t  if (al->expr->ts.type == BT_CLASS)\n \t    {\n-\t      gfc_se call;\n \t      gfc_actual_arglist *actual;\n \t      gfc_expr *ppc;\n-\t      gfc_init_se (&call, NULL);\n+\t      gfc_code *ppc_code;\n+\t      gfc_ref *dataref;\n+\n \t      /* Do a polymorphic deep copy.  */\n \t      actual = gfc_get_actual_arglist ();\n \t      actual->expr = gfc_copy_expr (rhs);\n \t      if (rhs->ts.type == BT_CLASS)\n \t\tgfc_add_data_component (actual->expr);\n \t      actual->next = gfc_get_actual_arglist ();\n \t      actual->next->expr = gfc_copy_expr (al->expr);\n+\t      actual->next->expr->ts.type = BT_CLASS;\n \t      gfc_add_data_component (actual->next->expr);\n+\t      dataref = actual->next->expr->ref;\n+\t      if (dataref->u.c.component->as)\n+\t\t{\n+\t\t  int dim;\n+\t\t  gfc_expr *temp;\n+\t\t  gfc_ref *ref = dataref->next;\n+\t\t  ref->u.ar.type = AR_SECTION;\n+\t\t  /* We have to set up the array reference to give ranges\n+\t\t    in all dimensions and ensure that the end and stride\n+\t\t    are set so that the copy can be scalarized.  */\n+\t\t  dim = 0;\n+\t\t  for (; dim < dataref->u.c.component->as->rank; dim++)\n+\t\t    {\n+\t\t      ref->u.ar.dimen_type[dim] = DIMEN_RANGE;\n+\t\t      if (ref->u.ar.end[dim] == NULL)\n+\t\t\t{\n+\t\t\t  ref->u.ar.end[dim] = ref->u.ar.start[dim];\n+\t\t\t  temp = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t   &al->expr->where, 1);\n+\t\t\t  ref->u.ar.start[dim] = temp;\n+\t\t\t}\n+\t\t      temp = gfc_subtract (gfc_copy_expr (ref->u.ar.end[dim]),\n+\t\t\t\t\t   gfc_copy_expr (ref->u.ar.start[dim]));\n+\t\t      temp = gfc_add (gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t\t&al->expr->where, 1),\n+\t\t\t\t      temp);\n+\t\t    }\n+\t\t}\n \t      if (rhs->ts.type == BT_CLASS)\n \t\t{\n \t\t  ppc = gfc_copy_expr (rhs);\n \t\t  gfc_add_vptr_component (ppc);\n \t\t}\n \t      else\n-\t\tppc = gfc_lval_expr_from_sym (gfc_find_derived_vtab (rhs->ts.u.derived));\n+\t\tppc = gfc_lval_expr_from_sym\n+\t\t\t\t(gfc_find_derived_vtab (rhs->ts.u.derived));\n \t      gfc_add_component_ref (ppc, \"_copy\");\n-\t      gfc_conv_procedure_call (&call, ppc->symtree->n.sym, actual,\n-\t\t\t\t\tppc, NULL);\n-\t      gfc_add_expr_to_block (&call.pre, call.expr);\n-\t      gfc_add_block_to_block (&call.pre, &call.post);\n-\t      tmp = gfc_finish_block (&call.pre);\n+\n+\t      ppc_code = gfc_get_code ();\n+\t      ppc_code->resolved_sym = ppc->symtree->n.sym;\n+\t      /* Although '_copy' is set to be elemental in class.c, it is\n+\t\t not staying that way.  Find out why, sometime....  */\n+\t      ppc_code->resolved_sym->attr.elemental = 1;\n+\t      ppc_code->ext.actual = actual;\n+\t      ppc_code->expr1 = ppc;\n+\t      ppc_code->op = EXEC_CALL;\n+\t      /* Since '_copy' is elemental, the scalarizer will take care\n+\t\t of arrays in gfc_trans_call.  */\n+\t      tmp = gfc_trans_call (ppc_code, true, NULL, NULL, false);\n+\t      gfc_free_statements (ppc_code);\n \t    }\n \t  else if (expr3 != NULL_TREE)\n \t    {\n@@ -4972,59 +5098,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_free_expr (rhs);\n \t}\n \n-      /* Allocation of CLASS entities.  */\n       gfc_free_expr (expr);\n-      expr = al->expr;\n-      if (expr->ts.type == BT_CLASS)\n-\t{\n-\t  gfc_expr *lhs,*rhs;\n-\t  gfc_se lse;\n-\n-\t  /* Initialize VPTR for CLASS objects.  */\n-\t  lhs = gfc_expr_to_initialize (expr);\n-\t  gfc_add_vptr_component (lhs);\n-\t  rhs = NULL;\n-\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n-\t    {\n-\t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n-\t      rhs = gfc_copy_expr (code->expr3);\n-\t      gfc_add_vptr_component (rhs);\n-\t      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-\t      gfc_add_expr_to_block (&block, tmp);\n-\t      gfc_free_expr (rhs);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* VPTR is fixed at compile time.  */\n-\t      gfc_symbol *vtab;\n-\t      gfc_typespec *ts;\n-\t      if (code->expr3)\n-\t\tts = &code->expr3->ts;\n-\t      else if (expr->ts.type == BT_DERIVED)\n-\t\tts = &expr->ts;\n-\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n-\t\tts = &code->ext.alloc.ts;\n-\t      else if (expr->ts.type == BT_CLASS)\n-\t\tts = &CLASS_DATA (expr)->ts;\n-\t      else\n-\t\tts = &expr->ts;\n-\n-\t      if (ts->type == BT_DERIVED)\n-\t\t{\n-\t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n-\t\t  gcc_assert (vtab);\n-\t\t  gfc_init_se (&lse, NULL);\n-\t\t  lse.want_pointer = 1;\n-\t\t  gfc_conv_expr (&lse, lhs);\n-\t\t  tmp = gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\t     gfc_get_symbol_decl (vtab));\n-\t\t  gfc_add_modify (&block, lse.expr,\n-\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n-\t\t}\n-\t    }\n-\t  gfc_free_expr (lhs);\n-\t}\n-\n     }\n \n   /* STAT  (ERRMSG only makes sense with STAT).  */"}, {"sha": "085f58f608a24ad2bc44ec8deddedc757ac5b060", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -315,6 +315,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n {\n   tree type = TREE_TYPE (base);\n   tree tmp;\n+  tree span;\n \n   if (GFC_ARRAY_TYPE_P (type) && GFC_TYPE_ARRAY_RANK (type) == 0)\n     {\n@@ -345,12 +346,33 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n   if (decl && (TREE_CODE (decl) == FIELD_DECL\n \t\t || TREE_CODE (decl) == VAR_DECL\n \t\t || TREE_CODE (decl) == PARM_DECL)\n-\t&& GFC_DECL_SUBREF_ARRAY_P (decl)\n-\t&& !integer_zerop (GFC_DECL_SPAN(decl)))\n+\t&& ((GFC_DECL_SUBREF_ARRAY_P (decl)\n+\t      && !integer_zerop (GFC_DECL_SPAN(decl)))\n+\t   || GFC_DECL_CLASS (decl)))\n     {\n+      if (GFC_DECL_CLASS (decl))\n+\t{\n+\t  /* Allow for dummy arguments and other good things.  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+\t    decl = build_fold_indirect_ref_loc (input_location, decl);\n+\n+\t  /* Check if '_data' is an array descriptor. If it is not,\n+\t     the array must be one of the components of the class object,\n+\t     so return a normal array reference.  */\n+\t  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_class_data_get (decl))))\n+\t    return build4_loc (input_location, ARRAY_REF, type, base,\n+\t\t\t       offset, NULL_TREE, NULL_TREE);\n+\n+\t  span = gfc_vtable_size_get (decl);\n+\t}\n+      else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n+\tspan = GFC_DECL_SPAN(decl);\n+      else\n+\tgcc_unreachable ();\n+\n       offset = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\tgfc_array_index_type,\n-\t\t\t\toffset, GFC_DECL_SPAN(decl));\n+\t\t\t\toffset, span);\n       tmp = gfc_build_addr_expr (pvoid_type_node, base);\n       tmp = fold_build_pointer_plus_loc (input_location, tmp, offset);\n       tmp = fold_convert (build_pointer_type (type), tmp);"}, {"sha": "259a08aae069f5bac26aecd8c9e7d6be16549cae", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -333,6 +333,14 @@ typedef struct\n }\n gfc_wrapped_block;\n \n+/* Class API functions.  */\n+tree gfc_class_data_get (tree);\n+tree gfc_class_vptr_get (tree);\n+tree gfc_vtable_hash_get (tree);\n+tree gfc_vtable_size_get (tree);\n+tree gfc_vtable_extends_get (tree);\n+tree gfc_vtable_def_init_get (tree);\n+tree gfc_vtable_copy_get (tree);\n \n /* Initialize an init/cleanup block.  */\n void gfc_start_wrapped_block (gfc_wrapped_block* block, tree code);\n@@ -803,6 +811,7 @@ struct GTY((variable_size)) lang_decl {\n #define GFC_DECL_RESULT(node) DECL_LANG_FLAG_5(node)\n #define GFC_DECL_SUBREF_ARRAY_P(node) DECL_LANG_FLAG_6(node)\n #define GFC_DECL_PUSH_TOPLEVEL(node) DECL_LANG_FLAG_7(node)\n+#define GFC_DECL_CLASS(node) DECL_LANG_FLAG_8(node)\n \n /* An array descriptor.  */\n #define GFC_DESCRIPTOR_TYPE_P(node) TYPE_LANG_FLAG_1(node)"}, {"sha": "b46988bd392886a8a1d01d4fa2e434854854b0c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -1,3 +1,32 @@\n+2011-12-11  Paul Thomas  <pault@gcc.gnu.org>\n+\tTobias Burnus  <burnus@gcc.gnu.org>\n+\n+\tPR fortran/41539\n+\tPR fortran/43214\n+\tPR fortran/43969\n+\tPR fortran/44568\n+\tPR fortran/46356\n+\tPR fortran/46990\n+\tPR fortran/49074\n+\t* gfortran.dg/class_array_1.f03: New.\n+\t* gfortran.dg/class_array_2.f03: New.\n+\t* gfortran.dg/class_array_3.f03: New.\n+\t* gfortran.dg/class_array_4.f03: New.\n+\t* gfortran.dg/class_array_5.f03: New.\n+\t* gfortran.dg/class_array_6.f03: New.\n+\t* gfortran.dg/class_array_7.f03: New.\n+\t* gfortran.dg/class_array_8.f03: New.\n+\t* gfortran.dg/coarray_poly_1.f90: New.\n+\t* gfortran.dg/coarray_poly_2.f90: New.\n+\t* gfortran.dg/coarray/poly_run_1.f90: New.\n+\t* gfortran.dg/coarray/poly_run_2.f90: New.\n+\t* gfortran.dg/class_to_type_1.f03: New.\n+\t* gfortran.dg/type_to_class_1.f03: New.\n+\t* gfortran.dg/typebound_assignment_3.f03: Remove the error.\n+\t* gfortran.dg/auto_dealloc_2.f90: Occurences of __builtin_free\n+\tnow 2.\n+\t* gfortran.dg/class_19.f03: Occurences of __builtin_free now 8.\n+\n 2011-12-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/50690"}, {"sha": "e607b6ad91d48eeabec41e8e377c20a05a9f644a", "filename": "gcc/testsuite/gfortran.dg/auto_dealloc_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -25,5 +25,5 @@ subroutine init(x)\n \n end program \n \n-! { dg-final { scan-tree-dump-times \"__builtin_free\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 3 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "27ee7b4e2cb44829665a1f354e13de8e9310d113", "filename": "gcc/testsuite/gfortran.dg/class_19.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -39,7 +39,7 @@ program main\n \n end program main\n \n-! { dg-final { scan-tree-dump-times \"__builtin_free\" 8 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 11 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n \n ! { dg-final { cleanup-modules \"foo_mod\" } }"}, {"sha": "32a0e54bf0a4ec3e27f6417edf3321f0472ea962", "filename": "gcc/testsuite/gfortran.dg/class_array_1.f03", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_1.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+!\n+! Test functionality of allocatable class arrays:\n+! ALLOCATE with source, ALLOCATED, DEALLOCATE, passing as arguments for\n+! ELEMENTAL and non-ELEMENTAL procedures, SELECT TYPE and LOWER/UPPER.\n+!\n+  type :: type1\n+    integer :: i\n+  end type\n+  type, extends(type1) :: type2\n+    real :: r\n+  end type\n+  class(type1), allocatable, dimension (:) :: x\n+\n+  allocate(x(2), source = type2(42,42.0))\n+  call display(x, [1], [2], t2 = [type2(42,42.0),type2(42,42.0)])\n+  call display(x, [1], [2], t2 = [type2(111,99.0),type2(111,99.0)])\n+  if (allocated (x)) deallocate (x)\n+\n+  allocate(x(1:4), source = [(type2(i,42.0 + float (i)), i = 1, 4)]) \n+  call display(x, [1], [4], t2 = [(type2(i,42.0 + float (i)), i = 1, 4)])\n+  call display(x, [1], [4], t2 = [(type2(111,99.0), i = 1, 4)])\n+\n+  if (any (disp (x) .ne. [99.0,99.0,99.0,99.0])) call abort\n+\n+  if (allocated (x)) deallocate (x)\n+\n+  allocate(x(1:4), source = type1(42))\n+  call display(x, [1], [4], t1 = [(type1(42), i = 1, 4)])\n+  call display(x, [1], [4], t1 = [type1(42),type1(99),type1(42),type1(42)])\n+  if (any (disp (x) .ne. [0.0,0.0,0.0,0.0])) call abort\n+\n+contains\n+  subroutine display(x, lower, upper, t1, t2)\n+    class(type1), allocatable, dimension (:) :: x\n+    integer, dimension (:) :: lower, upper\n+    type(type1), optional, dimension(:) :: t1\n+    type(type2), optional, dimension(:) :: t2\n+    select type (x)\n+      type is (type1)\n+        if (present (t1)) then\n+          if (any (x%i .ne. t1%i)) call abort\n+        else\n+          call abort\n+        end if\n+        x(2)%i = 99\n+      type is (type2)\n+        if (present (t2)) then\n+          if (any (x%i .ne. t2%i)) call abort\n+          if (any (x%r .ne. t2%r)) call abort\n+        else\n+          call abort\n+        end if\n+        x%i = 111\n+        x%r = 99.0\n+    end select\n+    call bounds (x, lower, upper)\n+  end subroutine\n+  subroutine bounds (x, lower, upper)\n+    class(type1), allocatable, dimension (:) :: x\n+    integer, dimension (:) :: lower, upper\n+    if (any (lower .ne. lbound (x))) call abort\n+    if (any (upper .ne. ubound (x))) call abort\n+  end subroutine\n+  elemental function disp(y) result(ans)\n+    class(type1), intent(in) :: y\n+    real :: ans\n+    select type (y)\n+      type is (type1)\n+        ans = 0.0\n+      type is (type2)\n+        ans = y%r\n+    end select\n+  end function\n+end\n+"}, {"sha": "68f1b71e552cca11f736785640203d83c92098ab", "filename": "gcc/testsuite/gfortran.dg/class_array_2.f03", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_2.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do run }\n+!\n+! Test functionality of pointer class arrays:\n+! ALLOCATE with source, ASSOCIATED, DEALLOCATE, passing as arguments for\n+! ELEMENTAL and non-ELEMENTAL procedures, SELECT TYPE and LOWER/UPPER.\n+!\n+  type :: type1\n+    integer :: i\n+  end type\n+  type, extends(type1) :: type2\n+    real :: r\n+  end type\n+  class(type1), pointer, dimension (:) :: x\n+\n+  allocate(x(2), source = type2(42,42.0))\n+  call display(x, [1], [2], t2 = [type2(42,42.0),type2(42,42.0)])\n+  call display(x, [1], [2], t2 = [type2(111,99.0),type2(111,99.0)])\n+  if (associated (x)) deallocate (x)\n+\n+  allocate(x(1:4), source = [(type2(i,42.0 + float (i)), i = 1, 4)]) \n+  call display(x, [1], [4], t2 = [(type2(i,42.0 + float (i)), i = 1, 4)])\n+  call display(x, [1], [4], t2 = [(type2(111,99.0), i = 1, 4)])\n+\n+  if (any (disp (x) .ne. [99.0,99.0,99.0,99.0])) call abort\n+\n+  if (associated (x)) deallocate (x)\n+\n+  allocate(x(1:4), source = type1(42))\n+  call display(x, [1], [4], t1 = [(type1(42), i = 1, 4)])\n+  call display(x, [1], [4], t1 = [type1(42),type1(99),type1(42),type1(42)])\n+  if (any (disp (x) .ne. [0.0,0.0,0.0,0.0])) call abort\n+\n+  if (associated (x)) deallocate (x)\n+\n+contains\n+  subroutine display(x, lower, upper, t1, t2)\n+    class(type1), pointer, dimension (:) :: x\n+    integer, dimension (:) :: lower, upper\n+    type(type1), optional, dimension(:) :: t1\n+    type(type2), optional, dimension(:) :: t2\n+    select type (x)\n+      type is (type1)\n+        if (present (t1)) then\n+          if (any (x%i .ne. t1%i)) call abort\n+        else\n+          call abort\n+        end if\n+        x(2)%i = 99\n+      type is (type2)\n+        if (present (t2)) then\n+          if (any (x%i .ne. t2%i)) call abort\n+          if (any (x%r .ne. t2%r)) call abort\n+        else\n+          call abort\n+        end if\n+        x%i = 111\n+        x%r = 99.0\n+    end select\n+    call bounds (x, lower, upper)\n+  end subroutine\n+  subroutine bounds (x, lower, upper)\n+    class(type1), pointer, dimension (:) :: x\n+    integer, dimension (:) :: lower, upper\n+    if (any (lower .ne. lbound (x))) call abort\n+    if (any (upper .ne. ubound (x))) call abort\n+  end subroutine\n+  elemental function disp(y) result(ans)\n+    class(type1), intent(in) :: y\n+    real :: ans\n+    select type (y)\n+      type is (type1)\n+        ans = 0.0\n+      type is (type2)\n+        ans = y%r\n+    end select\n+  end function\n+end\n+"}, {"sha": "0ca0a006eaf14dac1b8cec94e37ab2c64720e11c", "filename": "gcc/testsuite/gfortran.dg/class_array_3.f03", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do run }\n+!\n+! class based quick sort program - starting point comment #0 of pr41539\n+!\n+! Note assignment with vector index reference fails because temporary\n+! allocation does not occur - also false dependency detected. Nullification\n+! of temp descriptor data causes a segfault.\n+!\n+module m_qsort\n+ implicit none\n+ type, abstract :: sort_t\n+ contains\n+   procedure(disp), deferred :: disp\n+   procedure(lt_cmp), deferred :: lt_cmp\n+   procedure(assign), deferred :: assign\n+   generic :: operator(<) => lt_cmp\n+   generic :: assignment(=) => assign\n+ end type sort_t\n+ interface\n+   elemental integer function disp(a)\n+     import\n+     class(sort_t), intent(in) :: a\n+   end function disp\n+ end interface\n+ interface\n+   impure elemental logical function lt_cmp(a,b)\n+     import\n+     class(sort_t), intent(in) :: a, b\n+   end function lt_cmp\n+ end interface\n+ interface\n+   elemental subroutine assign(a,b)\n+     import\n+     class(sort_t), intent(out) :: a\n+     class(sort_t), intent(in) :: b\n+   end subroutine assign\n+ end interface\n+contains\n+\n+ subroutine qsort(a)\n+   class(sort_t), intent(inout),allocatable :: a(:)\n+   class(sort_t), allocatable :: tmp (:)\n+   integer, allocatable :: index_array (:)\n+   integer :: i\n+   allocate (tmp(size (a, 1)), source = a)\n+   index_array = [(i, i = 1, size (a, 1))]\n+   call internal_qsort (tmp, index_array)   ! Do not move class elements around until end\n+   do i = 1, size (a, 1)                    ! Since they can be of arbitrary size.\n+     a(i) = tmp(index_array(i))             ! Vector index array would be neater\n+   end do\n+!    a = tmp(index_array)                    ! Like this - TODO: fixme\n+ end subroutine qsort\n+\n+ recursive subroutine internal_qsort (x, iarray)\n+   class(sort_t), intent(inout),allocatable :: x(:)\n+   class(sort_t), allocatable :: ptr\n+   integer, allocatable :: iarray(:), above(:), below(:), itmp(:)\n+   integer :: pivot, nelem, i, iptr\n+   if (.not.allocated (iarray)) return\n+   nelem = size (iarray, 1)\n+   if (nelem .le. 1) return\n+   pivot = nelem / 2\n+   allocate (ptr, source = x(iarray(pivot))) ! Pointer to the pivot element\n+   do i = 1, nelem\n+     iptr = iarray(i)                  ! Index for i'th element\n+     if (ptr%lt_cmp (x(iptr))) then    ! Compare pivot with i'th element\n+       itmp = [iptr]\n+       above = concat (itmp, above)    ! Invert order to prevent infinite loops\n+     else\n+       itmp = [iptr]\n+       below = concat (itmp, below)    ! -ditto-\n+     end if\n+   end do\n+   call internal_qsort (x, above)      ! Recursive sort of 'above' and 'below'\n+   call internal_qsort (x, below)\n+   iarray = concat (below, above)      ! Concatenate the result\n+ end subroutine internal_qsort\n+\n+ function concat (ia, ib) result (ic)\n+   integer, allocatable, dimension(:) :: ia, ib, ic\n+   if (allocated (ia) .and. allocated (ib)) then\n+     ic = [ia, ib]\n+   else if (allocated (ia)) then\n+     ic = ia\n+   else if (allocated (ib)) then\n+     ic = ib\n+   end if\n+ end function concat\n+end module m_qsort\n+\n+module test\n+ use m_qsort\n+ implicit none\n+ type, extends(sort_t) :: sort_int_t\n+   integer :: i\n+ contains\n+   procedure :: disp => disp_int\n+   procedure :: lt_cmp => lt_cmp_int\n+   procedure :: assign => assign_int\n+ end type\n+contains\n+ elemental integer function disp_int(a)\n+     class(sort_int_t), intent(in) :: a\n+     disp_int = a%i\n+ end function disp_int\n+ elemental subroutine assign_int (a, b)\n+   class(sort_int_t), intent(out) :: a\n+   class(sort_t), intent(in) :: b         ! TODO: gfortran does not throw 'class(sort_int_t)'\n+   select type (b)\n+     class is (sort_int_t)\n+       a%i = b%i\n+     class default\n+       a%i = -1\n+   end select\n+ end subroutine assign_int\n+ impure elemental logical function lt_cmp_int(a,b) result(cmp)\n+   class(sort_int_t), intent(in) :: a\n+   class(sort_t), intent(in) :: b\n+   select type(b)\n+     type is(sort_int_t)\n+       if (a%i < b%i) then\n+         cmp = .true.\n+       else\n+         cmp = .false.\n+       end if\n+     class default\n+         ERROR STOP \"Don't compare apples with oranges\"\n+   end select\n+ end function lt_cmp_int\n+end module test\n+\n+program main\n+ use test\n+ class(sort_t), allocatable :: A(:)\n+ integer :: i, m(5)= [7 , 4, 5, 2, 3]\n+ allocate (A(5), source = [(sort_int_t(m(i)), i=1,5)])\n+!  print *, \"Before qsort: \", (A(i)%disp(), i = 1, size(a,1))\n+ call qsort(A)\n+!  print *, \"After qsort:  \", (A(i)%disp(), i = 1, size(a,1))\n+ if (any ([(A(i)%disp(), i = 1, size(a,1))] .ne. [2,3,4,5,7])) call abort\n+end program main\n+\n+! { dg-final { cleanup-modules \"m_qsort test\" } }"}, {"sha": "7c748f008d0606c7dc0bbff9779eac734f7bb597", "filename": "gcc/testsuite/gfortran.dg/class_array_4.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_4.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! PR43214 - implementation of class arrays\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module m\n+  type t\n+    real :: r = 99\n+  contains\n+    procedure, pass :: foo => foo\n+  end type t\n+contains\n+  elemental subroutine foo(x, i)\n+    class(t),intent(in) :: x\n+    integer,intent(inout) :: i\n+    i = x%r + i\n+  end subroutine foo\n+end module m\n+\n+  use m\n+  type(t) :: x(3)\n+  integer :: n(3) = [0,100,200]\n+  call x(:)%foo(n)\n+  if (any(n .ne. [99,199,299])) call abort\n+end\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "2a7e2f1bc4671ed73716b6a94415d41b4556e2b3", "filename": "gcc/testsuite/gfortran.dg/class_array_5.f03", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_5.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! PR44568 - class array impelementation.\n+!\n+! Contributed by Hans-Werner Boschmann\n+!\n+module ice6\n+\n+  type::a_type\n+   contains\n+     procedure::do_something\n+  end type a_type\n+\n+  contains\n+\n+  subroutine do_something(this)\n+    class(a_type),intent(in)::this\n+  end subroutine do_something\n+\n+  subroutine do_something_else()\n+    class(a_type),dimension(:),allocatable::values\n+    call values(1)%do_something()\n+  end subroutine do_something_else\n+\n+end module ice6\n+! { dg-final { cleanup-modules \"ice6\" } }"}, {"sha": "4f8b803befbf66cf049f3273c92ca638245b393b", "filename": "gcc/testsuite/gfortran.dg/class_array_6.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_6.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! PR46356 - class arrays \n+!\n+! Contributed by Ian Harvey\n+!\n+MODULE procedure_intent_nonsense\n+  IMPLICIT NONE  \n+  PRIVATE    \n+  TYPE, PUBLIC :: Parent\n+    INTEGER :: comp\n+  END TYPE Parent\n+\n+  TYPE :: ParentVector\n+    INTEGER :: a\n+    ! CLASS(Parent), ALLOCATABLE :: a\n+  END TYPE ParentVector  \n+CONTAINS           \n+  SUBROUTINE vector_operation(pvec)     \n+    CLASS(ParentVector), INTENT(INOUT) :: pvec(:)\n+    INTEGER :: i    \n+    !---\n+    DO i = 1, SIZE(pvec)\n+      CALL item_operation(pvec(i))\n+    END DO  \n+    ! PRINT *, pvec(1)%a%comp\n+  END SUBROUTINE vector_operation\n+\n+  SUBROUTINE item_operation(pvec)  \n+    CLASS(ParentVector), INTENT(INOUT) :: pvec\n+    !TYPE(ParentVector), INTENT(INOUT) :: pvec\n+  END SUBROUTINE item_operation\n+END MODULE procedure_intent_nonsense\n+! { dg-final { cleanup-modules \"procedure_intent_nonsense\" } }"}, {"sha": "225cc7e06c888272ac78f16c38c3c25ce53ff386", "filename": "gcc/testsuite/gfortran.dg/class_array_7.f03", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_7.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! PR46990 - class array implementation\n+!\n+! Contributed by Wolfgang Kilian on comp.lang.fortran - see comment #7 of PR\n+!\n+module realloc\n+  implicit none\n+\n+  type :: base_type\n+     integer :: i\n+  contains\n+    procedure :: assign\n+    generic :: assignment(=) => assign   ! define generic assignment\n+  end type base_type\n+\n+  type, extends(base_type) :: extended_type\n+     integer :: j\n+  end type extended_type\n+\n+contains\n+\n+  elemental subroutine assign (a, b)\n+    class(base_type), intent(out) :: a\n+    type(base_type), intent(in) :: b\n+    a%i = b%i\n+  end subroutine assign\n+\n+  subroutine reallocate (a)\n+    class(base_type), dimension(:), allocatable, intent(inout) :: a\n+    class(base_type), dimension(:), allocatable :: tmp\n+    allocate (tmp (2 * size (a))) ! how to alloc b with same type as a ?\n+    if (trim (print_type (\"tmp\", tmp)) .ne. \"tmp is base_type\") call abort\n+    tmp(:size(a)) = a             ! polymorphic l.h.s.\n+    call move_alloc (from=tmp, to=a)\n+  end subroutine reallocate\n+\n+  character(20) function print_type (name, a)\n+    character(*), intent(in) :: name\n+    class(base_type), dimension(:), intent(in) :: a\n+    select type (a)\n+     type is (base_type);      print_type = NAME // \" is base_type\"\n+     type is (extended_type);  print_type = NAME // \" is extended_type\"\n+    end select\n+  end function\n+\n+end module realloc\n+\n+program main\n+  use realloc\n+  implicit none\n+  class(base_type), dimension(:), allocatable :: a\n+\n+  allocate (extended_type :: a(10))\n+  if (trim (print_type (\"a\", a)) .ne. \"a is extended_type\") call abort\n+  call reallocate (a)\n+  if (trim (print_type (\"a\", a)) .ne. \"a is base_type\") call abort\n+end program main\n+\n+! { dg-final { cleanup-modules \"realloc\" } }"}, {"sha": "20c57ec03ff091d4ac3fec631c275ccb0ff8370b", "filename": "gcc/testsuite/gfortran.dg/class_array_8.f03", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_8.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! PR43969 - class array implementation\n+!\n+! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+  implicit none\n+\n+  type indx_map\n+  end type\n+\n+  type desc_type\n+    class(indx_map), allocatable :: indxmap(:)\n+  end type\n+\n+  type(desc_type)  :: desc\n+  if (allocated(desc%indxmap)) call abort()\n+\n+end"}, {"sha": "0243343d6377f4e581c71a1b464e82824349eb63", "filename": "gcc/testsuite/gfortran.dg/class_to_type_1.f03", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_1.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,97 @@\n+! { dg-do run }\n+!\n+! Passing CLASS to TYPE\n+!\n+implicit none\n+type t\n+  integer :: A\n+  real, allocatable :: B(:)\n+end type t\n+\n+type, extends(t) ::  t2\n+  complex :: z = cmplx(3.3, 4.4)\n+end type t2\n+integer :: i\n+class(t), allocatable :: x(:)\n+\n+allocate(t2 :: x(10))\n+select type(x)\n+ type is(t2)\n+  if (size (x) /= 10) call abort ()\n+  x = [(t2(a=-i, B=[1*i,2*i,3*i,4*i]), i = 1, 10)]\n+  do i = 1, 10\n+    if (x(i)%a /= -i .or. size (x(i)%b) /= 4 &\n+        .or. any (x(i)%b /= [1*i,2*i,3*i,4*i])) then\n+        call abort()\n+    end if\n+    if (x(i)%z /= cmplx(3.3, 4.4)) call abort()\n+  end do\n+  class default\n+    call abort()\n+end select\n+\n+call base(x)\n+call baseExplicit(x, size(x))\n+call class(x)\n+call classExplicit(x, size(x))\n+contains\n+  subroutine base(y)\n+    type(t) :: y(:)\n+    if (size (y) /= 10) call abort ()\n+    do i = 1, 10\n+      if (y(i)%a /= -i .or. size (y(i)%b) /= 4 &\n+          .or. any (y(i)%b /= [1*i,2*i,3*i,4*i])) then\n+        call abort()\n+      end if\n+    end do\n+  end subroutine base\n+  subroutine baseExplicit(v, n)\n+    integer, intent(in) :: n\n+    type(t) :: v(n)\n+    if (size (v) /= 10) call abort ()\n+    do i = 1, 10\n+      if (v(i)%a /= -i .or. size (v(i)%b) /= 4 &\n+          .or. any (v(i)%b /= [1*i,2*i,3*i,4*i])) then\n+        call abort()\n+      end if\n+    end do\n+  end subroutine baseExplicit\n+  subroutine class(z)\n+    class(t), intent(in) :: z(:)\n+    select type(z)\n+     type is(t2)\n+      if (size (z) /= 10) call abort ()\n+      do i = 1, 10\n+        if (z(i)%a /= -i .or. size (z(i)%b) /= 4 &\n+            .or. any (z(i)%b /= [1*i,2*i,3*i,4*i])) then\n+            call abort()\n+        end if\n+        if (z(i)%z /= cmplx(3.3, 4.4)) call abort()\n+      end do\n+      class default\n+        call abort()\n+    end select\n+    call base(z)\n+    call baseExplicit(z, size(z))\n+  end subroutine class\n+  subroutine classExplicit(u, n)\n+    integer, intent(in) :: n\n+    class(t), intent(in) :: u(n)\n+    select type(u)\n+     type is(t2)\n+      if (size (u) /= 10) call abort ()\n+      do i = 1, 10\n+        if (u(i)%a /= -i .or. size (u(i)%b) /= 4 &\n+            .or. any (u(i)%b /= [1*i,2*i,3*i,4*i])) then\n+            call abort()\n+        end if\n+        if (u(i)%z /= cmplx(3.3, 4.4)) call abort()\n+      end do\n+      class default\n+        call abort()\n+    end select\n+    call base(u)\n+    call baseExplicit(u, n)\n+  end subroutine classExplicit\n+end\n+"}, {"sha": "a371aef0810ab2b25df75d1ed1eff951002140cf", "filename": "gcc/testsuite/gfortran.dg/coarray/poly_run_1.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+!\n+! Test for polymorphic coarrays\n+!\n+type t\n+end type t\n+class(t), allocatable :: A(:)[:,:]\n+allocate (A(2)[1:4,-5:*])\n+if (any (lcobound(A) /= [1, -5])) call abort ()\n+if (num_images() == 1) then\n+  if (any (ucobound(A) /= [4, -5])) call abort ()\n+else\n+  if (ucobound(A,dim=1) /= 4) call abort ()\n+end if\n+if (allocated(A)) i = 5\n+call s(A)\n+!call t(A) ! FIXME\n+\n+contains\n+\n+subroutine s(x)\n+  class(t),allocatable :: x(:)[:,:]\n+  if (any (lcobound(x) /= [1, -5])) call abort ()\n+  if (num_images() == 1) then\n+    if (any (ucobound(x) /= [4, -5])) call abort ()\n+! FIXME: Tree-walking issue?\n+!  else\n+!    if (ucobound(x,dim=1) /= 4) call abort ()\n+  end if\n+end subroutine s\n+\n+! FIXME\n+!subroutine st(x)\n+!  class(t),allocatable :: x(:)[:,:]\n+!  if (any (lcobound(x) /= [1, 2])) call abort ()\n+!  if (num_images() == 1) then\n+!    if (any (ucobound(x) /= [4, 2])) call abort ()\n+!  else\n+!    if (ucobound(x,dim=1) /= 4) call abort ()\n+!  end if\n+!end subroutine st\n+end\n+"}, {"sha": "fe524a0751a2fc95e5f618478fa35110d11cf5be", "filename": "gcc/testsuite/gfortran.dg/coarray/poly_run_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_2.f90?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+!\n+! Test for polymorphic coarrays\n+!\n+type t\n+end type t\n+class(t), allocatable :: A[:,:]\n+allocate (A[1:4,-5:*])\n+if (allocated(A)) stop\n+if (any (lcobound(A) /= [1, -5])) call abort ()\n+if (num_images() == 1) then\n+  if (any (ucobound(A) /= [4, -5])) call abort ()\n+! FIXME: Tree walk issue\n+!else\n+!  if (ucobound(A,dim=1) /= 4) call abort ()\n+end if\n+if (allocated(A)) i = 5\n+call s(A)\n+call st(A)\n+contains\n+subroutine s(x)\n+  class(t) :: x[4,2:*]\n+  if (any (lcobound(x) /= [1, 2])) call abort ()\n+  if (num_images() == 1) then\n+    if (any (ucobound(x) /= [4, 2])) call abort ()\n+  else\n+    if (ucobound(x,dim=1) /= 4) call abort ()\n+  end if\n+end subroutine s\n+subroutine st(x)\n+  class(t) :: x[:,:]\n+  if (any (lcobound(x) /= [1, -5])) call abort ()\n+  if (num_images() == 1) then\n+    if (any (ucobound(x) /= [4, -5])) call abort ()\n+  else\n+    if (ucobound(x,dim=1) /= 4) call abort ()\n+  end if\n+end subroutine st\n+end\n+"}, {"sha": "03dbee79839359f4fb6c55170fea8e2b553e1964", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_1.f90?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Test for polymorphic coarrays\n+!\n+subroutine s2()\n+  type t\n+  end type t\n+  class(t) :: A(:)[4,2:*] ! { dg-error \"is not ALLOCATABLE, SAVE nor a dummy argument\" }\n+  print *, ucobound(a)\n+  allocate(a) ! { dg-error \"must be ALLOCATABLE or a POINTER\" }\n+end\n+"}, {"sha": "dd5a5537f46e60408797ab4184db65e94f16b9e9", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_2.f90?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+   type t\n+  end type t\n+  type(t) :: a[*]\n+  call test(a) ! { dg-error \"Rank mismatch in argument 'x' at .1. .rank-1 and scalar.\" }\n+contains\n+  subroutine test(x)\n+   class(t) :: x(:)[*]\n+   print *, ucobound(x)\n+  end\n+end"}, {"sha": "173ca3635eb55abeae3b27320c6c6694ae9becc9", "filename": "gcc/testsuite/gfortran.dg/type_to_class_1.f03", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_to_class_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_to_class_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_to_class_1.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! Passing TYPE to CLASS\n+!\n+implicit none\n+type t\n+  integer :: A\n+  real, allocatable :: B(:)\n+end type t\n+\n+type(t), allocatable :: x(:)\n+type(t) :: y(10)\n+integer :: i\n+\n+allocate(x(10))\n+if (size (x) /= 10) call abort ()\n+x = [(t(a=-i, B=[1*i,2*i,3*i,4*i]), i = 1, 10)]\n+do i = 1, 10\n+  if (x(i)%a /= -i .or. size (x(i)%b) /= 4 &\n+      .or. any (x(i)%b /= [1*i,2*i,3*i,4*i])) then\n+      call abort()\n+  end if\n+end do\n+\n+y = x ! TODO: Segfaults in runtime without 'y' being set\n+\n+call class(x)\n+call classExplicit(x, size(x))\n+call class(y)\n+call classExplicit(y, size(y))\n+\n+contains\n+  subroutine class(z)\n+    class(t), intent(in) :: z(:)\n+    select type(z)\n+     type is(t)\n+      if (size (z) /= 10) call abort ()\n+      do i = 1, 10\n+        if (z(i)%a /= -i .or. size (z(i)%b) /= 4 &\n+            .or. any (z(i)%b /= [1*i,2*i,3*i,4*i])) then\n+            call abort()\n+        end if\n+      end do\n+      class default\n+        call abort()\n+    end select\n+  end subroutine class\n+  subroutine classExplicit(u, n)\n+    integer, intent(in) :: n\n+    class(t), intent(in) :: u(n)\n+    select type(u)\n+     type is(t)\n+      if (size (u) /= 10) call abort ()\n+      do i = 1, 10\n+        if (u(i)%a /= -i .or. size (u(i)%b) /= 4 &\n+            .or. any (u(i)%b /= [1*i,2*i,3*i,4*i])) then\n+            call abort()\n+        end if\n+      end do\n+      class default\n+        call abort()\n+    end select\n+  end subroutine classExplicit\n+end\n+"}, {"sha": "2001589a9ca376c8516e56f32e3a616d568ca197", "filename": "gcc/testsuite/gfortran.dg/typebound_assignment_3.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49ea23d52792120c23ceb81550920335752ac26/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_3.f03?ref=c49ea23d52792120c23ceb81550920335752ac26", "patch": "@@ -24,7 +24,7 @@ elemental subroutine assgn (a, b)\n \n   use foo\n   type (bar) :: foobar(2)\n-  foobar = bar()           ! { dg-error \"currently not implemented\" }\n+  foobar = bar()           ! There was a not-implemented error here \n end\n \n ! { dg-final { cleanup-modules \"foo\" } }"}]}