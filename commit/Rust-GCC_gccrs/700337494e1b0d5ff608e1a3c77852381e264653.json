{"sha": "700337494e1b0d5ff608e1a3c77852381e264653", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwMzM3NDk0ZTFiMGQ1ZmY2MDhlMWEzYzc3ODUyMzgxZTI2NDY1Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-19T04:01:06Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-19T04:01:06Z"}, "message": "Minor H8 shift code generation change in preparation for cc0 removal\n\nSo I didn't stay up late to work from pago pago this year and beat the stage1\nclose, but I do want to flush out the removal of cc0 from the H8 port this\ncycle.  Given these patches only affect the H8 and the H8 would be killed this\ncycle without the conversion, I think this is suitable even though we're past\nstage1 close.\n\nThis patch addresses an initial codegen issue that would have resulted in\nregressions after removal of cc0.  The compare/test eliminate pass is unable to\nhandle multiple clobbers.  So patterns that clobber a scratch and also clobber\na condition code are never used to eliminate a compare/test.\n\nThe H8 can shift 1 or 2 bits at a time depending on the precise model.  Not\nsurprisingly we have multiple strategies to implement shifts, some of which\nclobber scratch registers -- but we have a clobber on every shift insn and as\na result they can not participate in compare/test removal once cc0 is removed\nfrom the port.\n\nThis patch removes the clobber in the initial code generation in cases where\nit's obviously not needed allowing those shifts to participate in compare/test\nremoval in a future patch.  It has the advantage that is also generates\nslightly better code.  By installing this now the removal of cc0 is a smaller\npatch, but more importantly, it allows for a more direct comparison of the\ngenerated code before/after cc0 removal.\n\nI've had my tester test before/after this patch with no regressions on the\nmajor H8 multilibs.  I've also spot checked the generated code and as expected\nit's ever-so-slightly better after this patch.\n\nI'll be installing this on the trunk momentarily.  More patches will follow,\nthough probably not in rapid succession as my time to push this stuff is very\nlimited.\n\ngcc/\n\n\t* config/h8300/constraints.md (R constraint): Add argument to call\n\tto h8300_shift_needs_scratch_p.\n\t(S and T constraints): Similary.\n\t* config/h8300/h8300-protos.h: Update h8300_shift_needs_scratch_p\n\tprototype.\n\t* config/h8300/h8300.c (expand_a_shift): Emit a different pattern\n\tif the shift does not require a scratch register.\n\t(h8300_shift_needs_scratch_p): Refine to be more accurate.\n\t* config/h8300/shiftrotate.md (shiftqi_noscratch): New pattern.\n\t(shifthi_noscratch, shiftsi_noscratch): Similarly.", "tree": {"sha": "9f334878639095cd8e9957b57deebaa21facbb7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f334878639095cd8e9957b57deebaa21facbb7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/700337494e1b0d5ff608e1a3c77852381e264653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700337494e1b0d5ff608e1a3c77852381e264653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700337494e1b0d5ff608e1a3c77852381e264653", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700337494e1b0d5ff608e1a3c77852381e264653/comments", "author": null, "committer": null, "parents": [{"sha": "25bb75f841c552cfd27a4344b7487efbe35b4481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25bb75f841c552cfd27a4344b7487efbe35b4481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25bb75f841c552cfd27a4344b7487efbe35b4481"}], "stats": {"total": 100, "additions": 82, "deletions": 18}, "files": [{"sha": "1d80152ce412fdfd745dc9e3eedab1d72b49a43d", "filename": "gcc/config/h8300/constraints.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=700337494e1b0d5ff608e1a3c77852381e264653", "patch": "@@ -152,7 +152,7 @@\n (define_constraint \"R\"\n   \"@internal\"\n   (and (match_code \"const_int\")\n-       (match_test \"!h8300_shift_needs_scratch_p (ival, QImode)\")))\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, QImode, CLOBBER)\")))\n \n (define_constraint \"C\"\n   \"@internal\"\n@@ -161,12 +161,12 @@\n (define_constraint \"S\"\n   \"@internal\"\n   (and (match_code \"const_int\")\n-       (match_test \"!h8300_shift_needs_scratch_p (ival, HImode)\")))\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, HImode, CLOBBER)\")))\n \n (define_constraint \"T\"\n   \"@internal\"\n   (and (match_code \"const_int\")\n-       (match_test \"!h8300_shift_needs_scratch_p (ival, SImode)\")))\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, SImode, CLOBBER)\")))\n \n (define_constraint \"U\"\n   \"An operand valid for a bset destination.\""}, {"sha": "8a8ebf6f490fe648bdfb446ca9b3e24fe323579a", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=700337494e1b0d5ff608e1a3c77852381e264653", "patch": "@@ -47,7 +47,7 @@ extern enum attr_cc compute_logical_op_cc (machine_mode, rtx *);\n extern void h8300_expand_branch (rtx[]);\n extern void h8300_expand_store (rtx[]);\n extern bool expand_a_shift (machine_mode, enum rtx_code, rtx[]);\n-extern int h8300_shift_needs_scratch_p (int, machine_mode);\n+extern int h8300_shift_needs_scratch_p (int, machine_mode, rtx_code);\n extern int expand_a_rotate (rtx[]);\n extern int fix_bit_operand (rtx *, enum rtx_code);\n extern int h8300_adjust_insn_length (rtx, int);"}, {"sha": "767ecda79799e6759b8368ffb0acd51ccda65d41", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=700337494e1b0d5ff608e1a3c77852381e264653", "patch": "@@ -3381,19 +3381,25 @@ expand_a_shift (machine_mode mode, enum rtx_code code, rtx operands[])\n       break;\n     }\n \n-  emit_move_insn (copy_rtx (operands[0]), operands[1]);\n-\n   /* Need a loop to get all the bits we want  - we generate the\n      code at emit time, but need to allocate a scratch reg now.  */\n-\n-  emit_insn (gen_rtx_PARALLEL\n-\t     (VOIDmode,\n-\t      gen_rtvec (2,\n-\t\t\t gen_rtx_SET (copy_rtx (operands[0]),\n-\t\t\t\t      gen_rtx_fmt_ee (code, mode,\n-\t\t\t\t\t\t      copy_rtx (operands[0]), operands[2])),\n-\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n+  emit_move_insn (copy_rtx (operands[0]), operands[1]);\n+  if (operands[2] == CONST0_RTX (QImode))\n+    ;\n+  else if (GET_CODE (operands[2]) == CONST_INT\n+      && !h8300_shift_needs_scratch_p (INTVAL (operands[2]), mode, code))\n+    emit_insn (gen_rtx_SET (copy_rtx (operands[0]),\n+\t\t\t      gen_rtx_fmt_ee (code, mode,\n+\t\t\t\t\t      copy_rtx (operands[1]), operands[2])));\n+  else\n+    emit_insn (gen_rtx_PARALLEL\n+\t       (VOIDmode,\n+\t\tgen_rtvec (2,\n+\t\t\t   gen_rtx_SET (copy_rtx (operands[0]),\n+\t\t\t\t\tgen_rtx_fmt_ee (code, mode,\n+\t\t\t\t\t\t\tcopy_rtx (operands[0]), operands[2])),\n+\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t    gen_rtx_SCRATCH (QImode)))));\n   return true;\n }\n \n@@ -3920,7 +3926,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n    needed for some shift with COUNT and MODE.  Return 0 otherwise.  */\n \n int\n-h8300_shift_needs_scratch_p (int count, machine_mode mode)\n+h8300_shift_needs_scratch_p (int count, machine_mode mode, enum rtx_code type)\n {\n   enum h8_cpu cpu;\n   int a, lr, ar;\n@@ -3960,8 +3966,18 @@ h8300_shift_needs_scratch_p (int count, machine_mode mode)\n     }\n \n   /* On H8/300H, count == 8 uses a scratch register.  */\n-  return (a == SHIFT_LOOP || lr == SHIFT_LOOP || ar == SHIFT_LOOP\n-\t  || (TARGET_H8300H && mode == SImode && count == 8));\n+  if (type == CLOBBER)\n+    return (a == SHIFT_LOOP || lr == SHIFT_LOOP || ar == SHIFT_LOOP\n+\t    || (TARGET_H8300H && mode == SImode && count == 8));\n+  else if (type == ASHIFT)\n+    return (a == SHIFT_LOOP\n+\t    || (TARGET_H8300H && mode == SImode && count == 8));\n+  else if (type == LSHIFTRT)\n+    return (lr == SHIFT_LOOP\n+\t    || (TARGET_H8300H && mode == SImode && count == 8));\n+  else if (type == ASHIFTRT)\n+    return (ar == SHIFT_LOOP\n+\t    || (TARGET_H8300H && mode == SImode && count == 8));\n }\n \n /* Output the assembler code for doing shifts.  */"}, {"sha": "5a85e1673fe889cde9167c3522c63a796d2237b1", "filename": "gcc/config/h8300/shiftrotate.md", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700337494e1b0d5ff608e1a3c77852381e264653/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md?ref=700337494e1b0d5ff608e1a3c77852381e264653", "patch": "@@ -101,6 +101,22 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n+(define_insn \"*shiftqi_noscratch\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:QI 3 \"nshift_operator\"\n+\t [(match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"R,rn\")]))]\n+  \"(GET_CODE (operands[2]) == CONST_INT\n+    && !h8300_shift_needs_scratch_p (INTVAL (operands[2]), QImode,\n+\t\t\t\t     GET_CODE (operands[3])))\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n (define_insn \"*shifthi\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:HI 3 \"nshift_operator\"\n@@ -116,6 +132,22 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n+(define_insn \"*shifthi_noscratch\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:HI 3 \"nshift_operator\"\n+\t [(match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"S,rn\")]))]\n+  \"(GET_CODE (operands[2]) == CONST_INT\n+    && !h8300_shift_needs_scratch_p (INTVAL (operands[2]), HImode,\n+\t\t\t\t     GET_CODE (operands[3])))\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n (define_insn \"*shiftsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:SI 3 \"nshift_operator\"\n@@ -131,6 +163,22 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n+(define_insn \"*shiftsi_noscratch\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI 3 \"nshift_operator\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"T,rn\")]))]\n+  \"(GET_CODE (operands[2]) == CONST_INT\n+    && !h8300_shift_needs_scratch_p (INTVAL (operands[2]), SImode,\n+\t\t\t\t     GET_CODE (operands[3])))\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n \n ;; Split a variable shift into a loop.  If the register containing\n ;; the shift count dies, then we just use that register."}]}