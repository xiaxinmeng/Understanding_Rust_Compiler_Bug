{"sha": "89576d863a879c4986867f991a6ac493106a9879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk1NzZkODYzYTg3OWM0OTg2ODY3Zjk5MWE2YWM0OTMxMDZhOTg3OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-22T04:33:34Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-22T04:33:34Z"}, "message": "Move nested function info out of cgraph_node\n\nthis patch moves nested function information out of symbol table (to a summary).\nThis saves memory (especially at WPA time) and also makes nested function\nsupport more contained.\n\ngcc/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cgraph.c: Include tree-nested.h\n\t(cgraph_node::create): Call maybe_record_nested_function.\n\t(cgraph_node::remove): Do not remove function from nested function\n\tinfos.\n\t(cgraph_node::dump): Update.\n\t(cgraph_node::unnest): Move to tree-nested.c\n\t(cgraph_node::verify_node): Update.\n\t(cgraph_c_finalize): Call nested_function_info::release.\n\t* cgraph.h (struct symtab_node): Remove nested function info.\n\t* cgraphclones.c (cgraph_node::create_clone): Do not clone nested\n\tfunction info.\n\t* cgraphunit.c (cgraph_node::analyze): Update.\n\t(cgraph_node::expand): Do not worry about nested functions; they are\n\tlowered.\n\t(symbol_table::finalize_compilation_unit): Call\n\tnested_function_info::release.\n\t* gimplify.c: Include tree-nested.h\n\t(unshare_body): Update.\n\t(unvisit_body): Update.\n\t* omp-offload.c (omp_discover_implicit_declare_target): Update.\n\t* tree-nested.c: Include alloc-pool.h, tree-nested.h, symbol-summary.h\n\t(nested_function_sum): New static variable.\n\t(nested_function_info::get): New member function.\n\t(nested_function_info::get_create): New member function.\n\t(unnest_function): New function.\n\t(nested_function_info::~nested_function_info): New member function.\n\t(nested_function_info::release): New function.\n\t(maybe_record_nested_function): New function.\n\t(lookup_element_for_decl): Update.\n\t(check_for_nested_with_variably_modified): Update.\n\t(create_nesting_tree): Update.\n\t(unnest_nesting_tree_1): Update.\n\t(gimplify_all_functions): Update.\n\t(lower_nested_functions): Update.\n\t* tree-nested.h (class nested_function_info): New class.\n\t(maybe_record_nested_function): Declare.\n\t(unnest_function): Declare.\n\t(first_nested_function): New inline function.\n\t(next_nested_function): New inline function.\n\t(nested_function_origin): New inline function.\n\ngcc/ada/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc-interface/trans.c: Include tree-nested.h\n\t(walk_nesting_tree): Update for new nested function info.\n\ngcc/c-family/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* c-gimplify.c: Include tree-nested.h\n\t(c_genericize): Update for new nested function info.\n\ngcc/d/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* decl.cc: Include tree-nested.h\n\t(get_symbol_decl): Update for new nested function info.", "tree": {"sha": "507d7d68dfee1f4104d461f63007a79d5f2123d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/507d7d68dfee1f4104d461f63007a79d5f2123d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89576d863a879c4986867f991a6ac493106a9879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89576d863a879c4986867f991a6ac493106a9879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89576d863a879c4986867f991a6ac493106a9879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89576d863a879c4986867f991a6ac493106a9879/comments", "author": null, "committer": null, "parents": [{"sha": "52e7f09698ecb5ba6d9e921ffe912d1f66158e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e7f09698ecb5ba6d9e921ffe912d1f66158e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e7f09698ecb5ba6d9e921ffe912d1f66158e9e"}], "stats": {"total": 302, "additions": 213, "deletions": 89}, "files": [{"sha": "6babbd41d524629e0d931aed772b816fe5a0012f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -50,6 +50,7 @@\n #include \"gomp-constants.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"tree-nested.h\"\n \n #include \"ada.h\"\n #include \"adadecode.h\"\n@@ -3696,7 +3697,8 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n static void\n walk_nesting_tree (struct cgraph_node *node, walk_tree_fn func, void *data)\n {\n-  for (node = node->nested; node; node = node->next_nested)\n+  for (node = first_nested_function (node);\n+       node; node = next_nested_function (node))\n     {\n       walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), func, data);\n       walk_nesting_tree (node, func, data);"}, {"sha": "a7c0ec3be0df8bd59c5cce7166bd97a9ac22c04b", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"dumpfile.h\"\n #include \"c-ubsan.h\"\n+#include \"tree-nested.h\"\n \n /*  The gimplification pass converts the language-dependent trees\n     (ld-trees) emitted by the parser into language-independent trees\n@@ -572,7 +573,8 @@ c_genericize (tree fndecl)\n \n   /* Dump all nested functions now.  */\n   cgn = cgraph_node::get_create (fndecl);\n-  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+  for (cgn = first_nested_function (cgn);\n+       cgn; cgn = next_nested_function (cgn))\n     c_genericize (cgn->decl);\n }\n "}, {"sha": "9480935ff84f1bf829e2c767633bc1f75370cd73", "filename": "gcc/cgraph.c", "status": "modified", "additions": 25, "deletions": 51, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"tree-into-ssa.h\"\n #include \"ipa-inline.h\"\n+#include \"tree-nested.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -517,13 +518,8 @@ cgraph_node::create (tree decl)\n     node->ifunc_resolver = true;\n \n   node->register_symbol ();\n+  maybe_record_nested_function (node);\n \n-  if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n-    {\n-      node->origin = cgraph_node::get_create (DECL_CONTEXT (decl));\n-      node->next_nested = node->origin->nested;\n-      node->origin->nested = node;\n-    }\n   return node;\n }\n \n@@ -1861,22 +1857,7 @@ cgraph_node::remove (void)\n      */\n   force_output = false;\n   forced_by_abi = false;\n-  cgraph_node *next;\n-  for (cgraph_node *n = nested; n; n = next)\n-  {\n-    next = n->next_nested;\n-    n->origin = NULL;\n-    n->next_nested = NULL;\n-  }\n-  nested = NULL;\n-  if (origin)\n-    {\n-      cgraph_node **node2 = &origin->nested;\n \n-      while (*node2 != this)\n-\tnode2 = &(*node2)->next_nested;\n-      *node2 = next_nested;\n-    }\n   unregister ();\n   if (prev_sibling_clone)\n     prev_sibling_clone->next_sibling_clone = next_sibling_clone;\n@@ -2139,7 +2120,7 @@ cgraph_node::dump (FILE *f)\n     }\n   if (tp_first_run > 0)\n     fprintf (f, \" first_run:%\" PRId64, (int64_t) tp_first_run);\n-  if (origin)\n+  if (cgraph_node *origin = nested_function_origin (this))\n     fprintf (f, \" nested in:%s\", origin->dump_asm_name ());\n   if (gimple_has_body_p (decl))\n     fprintf (f, \" body\");\n@@ -2348,19 +2329,6 @@ cgraph_function_possibly_inlined_p (tree decl)\n   return DECL_POSSIBLY_INLINED (decl);\n }\n \n-/* cgraph_node is no longer nested function; update cgraph accordingly.  */\n-void\n-cgraph_node::unnest (void)\n-{\n-  cgraph_node **node2 = &origin->nested;\n-  gcc_assert (origin);\n-\n-  while (*node2 != this)\n-    node2 = &(*node2)->next_nested;\n-  *node2 = next_nested;\n-  origin = NULL;\n-}\n-\n /* Return function availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n@@ -3798,27 +3766,32 @@ cgraph_node::verify_node (void)\n \t}\n     }\n \n-  if (nested != NULL)\n+  if (nested_function_info *info = nested_function_info::get (this))\n     {\n-      for (cgraph_node *n = nested; n != NULL; n = n->next_nested)\n+      if (info->nested != NULL)\n \t{\n-\t  if (n->origin == NULL)\n-\t    {\n-\t      error (\"missing origin for a node in a nested list\");\n-\t      error_found = true;\n-\t    }\n-\t  else if (n->origin != this)\n+\t  for (cgraph_node *n = info->nested; n != NULL;\n+\t       n = next_nested_function (n))\n \t    {\n-\t      error (\"origin points to a different parent\");\n-\t      error_found = true;\n-\t      break;\n+\t      nested_function_info *ninfo = nested_function_info::get (n);\n+\t      if (ninfo->origin == NULL)\n+\t\t{\n+\t\t  error (\"missing origin for a node in a nested list\");\n+\t\t  error_found = true;\n+\t\t}\n+\t      else if (ninfo->origin != this)\n+\t\t{\n+\t\t  error (\"origin points to a different parent\");\n+\t\t  error_found = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n-    }\n-  if (next_nested != NULL && origin == NULL)\n-    {\n-      error (\"missing origin for a node in a nested list\");\n-      error_found = true;\n+      if (info->next_nested != NULL && info->origin == NULL)\n+\t{\n+\t  error (\"missing origin for a node in a nested list\");\n+\t  error_found = true;\n+\t}\n     }\n \n   if (error_found)\n@@ -4022,6 +3995,7 @@ cgraph_node::get_fun () const\n void\n cgraph_c_finalize (void)\n {\n+  nested_function_info::release ();\n   symtab = NULL;\n \n   x_cgraph_nodes_queue = NULL;"}, {"sha": "c953a1b6711fefdd295374198a76ea5b97276447", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -921,7 +921,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Constructor.  */\n   explicit cgraph_node (int uid)\n     : symtab_node (SYMTAB_FUNCTION), callees (NULL), callers (NULL),\n-      indirect_calls (NULL), origin (NULL), nested (NULL), next_nested (NULL),\n+      indirect_calls (NULL),\n       next_sibling_clone (NULL), prev_sibling_clone (NULL), clones (NULL),\n       clone_of (NULL), call_site_hash (NULL), former_clone_of (NULL),\n       simdclone (NULL), simd_clones (NULL), ipa_transforms_to_apply (vNULL),\n@@ -1161,9 +1161,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Return the DECL_STRUCT_FUNCTION of the function.  */\n   struct function *get_fun () const;\n \n-  /* cgraph_node is no longer nested function; update cgraph accordingly.  */\n-  void unnest (void);\n-\n   /* Bring cgraph node local.  */\n   void make_local (void);\n \n@@ -1436,13 +1433,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* List of edges representing indirect calls with a yet undetermined\n      callee.  */\n   cgraph_edge *indirect_calls;\n-  /* For nested functions points to function the node is nested in.  */\n-  cgraph_node *origin;\n-  /* Points to first nested function, if any.  */\n-  cgraph_node *nested;\n-  /* Pointer to the next function with same origin, if any.  */\n-  cgraph_node *next_nested;\n-  /* Pointer to the next clone.  */\n   cgraph_node *next_sibling_clone;\n   cgraph_node *prev_sibling_clone;\n   cgraph_node *clones;"}, {"sha": "f920dcb4c297044841d99274041c855da55e1549", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -382,13 +382,7 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n     }\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n-  new_node->origin = origin;\n   new_node->lto_file_data = lto_file_data;\n-  if (new_node->origin)\n-    {\n-      new_node->next_nested = new_node->origin->nested;\n-      new_node->origin->nested = new_node;\n-    }\n   new_node->analyzed = analyzed;\n   new_node->definition = definition;\n   new_node->versionable = versionable;"}, {"sha": "05713c28cf06df8f35aa4fda07f6f05e479a869f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -673,9 +673,8 @@ cgraph_node::analyze (void)\n       /* Lower the function.  */\n       if (!lowered)\n \t{\n-\t  if (nested)\n+\t  if (first_nested_function (this))\n \t    lower_nested_functions (decl);\n-\t  gcc_assert (!nested);\n \n \t  gimple_register_cfg_hooks ();\n \t  bitmap_obstack_initialize (NULL);\n@@ -2343,14 +2342,11 @@ cgraph_node::expand (void)\n     }\n \n   gimple_set_body (decl, NULL);\n-  if (DECL_STRUCT_FUNCTION (decl) == 0\n-      && !cgraph_node::get (decl)->origin)\n+  if (DECL_STRUCT_FUNCTION (decl) == 0)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.\n-\t For a nested function, this is done in c_pop_function_context.\n-\t If rest_of_compilation set this to 0, leave it 0.  */\n+\t was an actual function definition.  */\n       if (DECL_INITIAL (decl) != 0)\n \tDECL_INITIAL (decl) = error_mark_node;\n     }\n@@ -3001,6 +2997,9 @@ symbol_table::finalize_compilation_unit (void)\n   /* Gimplify and lower thunks.  */\n   analyze_functions (/*first_time=*/false);\n \n+  /* All nested functions should be lowered now.  */\n+  nested_function_info::release ();\n+\n   /* Offloading requires LTO infrastructure.  */\n   if (!in_lto_p && g->have_offload)\n     flag_generate_offload = 1;"}, {"sha": "1167462c305a05fb5926a96a984f545e8d2ce97d", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"debug.h\"\n #include \"tree-pretty-print.h\"\n+#include \"tree-nested.h\"\n \n #include \"d-tree.h\"\n \n@@ -1280,8 +1281,8 @@ get_symbol_decl (Declaration *decl)\n \t all static chain passing is handled by the front-end.  Do this even\n \t if we are not emitting the body.  */\n       struct cgraph_node *node = cgraph_node::get_create (decl->csym);\n-      if (node->origin)\n-\tnode->unnest ();\n+      if (nested_function_origin (node))\n+\tunnest_function (node);\n     }\n \n   /* Mark compiler generated temporaries as artificial.  */"}, {"sha": "29f385c9368a30935b3b84b78b42eb786b88b6ab", "filename": "gcc/gimplify.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"omp-offload.h\"\n #include \"context.h\"\n+#include \"tree-nested.h\"\n \n /* Hash set of poisoned variables in a bind expr.  */\n static hash_set<tree> *asan_poisoned_variables = NULL;\n@@ -959,7 +960,8 @@ unshare_body (tree fndecl)\n   delete visited;\n \n   if (cgn)\n-    for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    for (cgn = first_nested_function (cgn); cgn;\n+\t cgn = next_nested_function (cgn))\n       unshare_body (cgn->decl);\n }\n \n@@ -1002,7 +1004,8 @@ unvisit_body (tree fndecl)\n   unmark_visited (&DECL_SIZE_UNIT (DECL_RESULT (fndecl)));\n \n   if (cgn)\n-    for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    for (cgn = first_nested_function (cgn);\n+\t cgn; cgn = next_nested_function (cgn))\n       unvisit_body (cgn->decl);\n }\n "}, {"sha": "3e9c31d2cbede772b6acaa067caee139d001f3fc", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -334,7 +334,8 @@ omp_discover_implicit_declare_target (void)\n \telse if (DECL_STRUCT_FUNCTION (node->decl)\n \t\t && DECL_STRUCT_FUNCTION (node->decl)->has_omp_target)\n \t  worklist.safe_push (node->decl);\n-\tfor (cgn = node->nested; cgn; cgn = cgn->next_nested)\n+\tfor (cgn = first_nested_function (node);\n+\t     cgn; cgn = next_nested_function (cgn))\n \t  if (omp_declare_target_fn_p (cgn->decl))\n \t    worklist.safe_push (cgn->decl);\n \t  else if (DECL_STRUCT_FUNCTION (cgn->decl)"}, {"sha": "433f37fffe33fd5734404dad84bb629b398ed1eb", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 103, "deletions": 7, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -42,7 +42,100 @@\n #include \"gimple-low.h\"\n #include \"gomp-constants.h\"\n #include \"diagnostic.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-nested.h\"\n+#include \"symbol-summary.h\"\n \n+/* Summary of nested functions.  */\n+static function_summary <nested_function_info *>\n+   *nested_function_sum = NULL;\n+\n+/* Return nested_function_info, if available.  */\n+nested_function_info *\n+nested_function_info::get (cgraph_node *node)\n+{\n+  if (!nested_function_sum)\n+    return NULL;\n+  return nested_function_sum->get (node);\n+}\n+\n+/* Return nested_function_info possibly creating new one.  */\n+nested_function_info *\n+nested_function_info::get_create (cgraph_node *node)\n+{\n+  if (!nested_function_sum)\n+    nested_function_sum = new function_summary <nested_function_info *>\n+\t\t\t\t (symtab);\n+  return nested_function_sum->get_create (node);\n+}\n+\n+/* cgraph_node is no longer nested function; update cgraph accordingly.  */\n+void\n+unnest_function (cgraph_node *node)\n+{\n+  nested_function_info *info = nested_function_info::get (node);\n+  cgraph_node **node2 = &nested_function_info::get\n+\t\t(nested_function_origin (node))->nested;\n+\n+  gcc_checking_assert (info->origin);\n+  while (*node2 != node)\n+    node2 = &nested_function_info::get (*node2)->next_nested;\n+  *node2 = info->next_nested;\n+  info->next_nested = NULL;\n+  info->origin = NULL;\n+  nested_function_sum->remove (node);\n+}\n+\n+/* Destructor: unlink function from nested function lists.  */\n+nested_function_info::~nested_function_info ()\n+{\n+  cgraph_node *next;\n+  for (cgraph_node *n = nested; n; n = next)\n+    {\n+      nested_function_info *info = nested_function_info::get (n);\n+      next = info->next_nested;\n+      info->origin = NULL;\n+      info->next_nested = NULL;\n+    }\n+  nested = NULL;\n+  if (origin)\n+    {\n+      cgraph_node **node2\n+\t     = &nested_function_info::get (origin)->nested;\n+\n+      nested_function_info *info;\n+      while ((info = nested_function_info::get (*node2)) != this && info)\n+\tnode2 = &info->next_nested;\n+      *node2 = next_nested;\n+    }\n+}\n+\n+/* Free nested function info summaries.  */\n+void\n+nested_function_info::release ()\n+{\n+  if (nested_function_sum)\n+    delete (nested_function_sum);\n+  nested_function_sum = NULL;\n+}\n+\n+/* If NODE is nested function, record it.  */\n+void\n+maybe_record_nested_function (cgraph_node *node)\n+{\n+  if (DECL_CONTEXT (node->decl)\n+      && TREE_CODE (DECL_CONTEXT (node->decl)) == FUNCTION_DECL)\n+    {\n+      cgraph_node *origin = cgraph_node::get_create (DECL_CONTEXT (node->decl));\n+      nested_function_info *info = nested_function_info::get_create (node);\n+      nested_function_info *origin_info\n+\t\t = nested_function_info::get_create (origin);\n+\n+      info->origin = origin;\n+      info->next_nested = origin_info->nested;\n+      origin_info->nested = node;\n+    }\n+}\n \n /* The object of this pass is to lower the representation of a set of nested\n    functions in order to expose all of the gory details of the various\n@@ -586,7 +679,7 @@ lookup_element_for_decl (struct nesting_info *info, tree decl,\n     *slot = build_tree_list (NULL_TREE, NULL_TREE);\n \n   return (tree) *slot;\n-} \n+}\n \n /* Given DECL, a nested function, create a field in the non-local\n    frame structure for this function.  */\n@@ -817,7 +910,8 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n   struct cgraph_node *cgn = cgraph_node::get (fndecl);\n   tree arg;\n \n-  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+  for (cgn = first_nested_function (cgn); cgn;\n+       cgn = next_nested_function (cgn))\n     {\n       for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = DECL_CHAIN (arg))\n \tif (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))\n@@ -845,7 +939,8 @@ create_nesting_tree (struct cgraph_node *cgn)\n   info->context = cgn->decl;\n   info->thunk_p = cgn->thunk.thunk_p;\n \n-  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+  for (cgn = first_nested_function (cgn); cgn;\n+       cgn = next_nested_function (cgn))\n     {\n       struct nesting_info *sub = create_nesting_tree (cgn);\n       sub->outer = info;\n@@ -3498,9 +3593,9 @@ unnest_nesting_tree_1 (struct nesting_info *root)\n \n   /* For nested functions update the cgraph to reflect unnesting.\n      We also delay finalizing of these functions up to this point.  */\n-  if (node->origin)\n+  if (nested_function_info::get (node)->origin)\n     {\n-       node->unnest ();\n+       unnest_function (node);\n        if (!root->thunk_p)\n \t cgraph_node::finalize_function (root->context, true);\n     }\n@@ -3541,7 +3636,8 @@ gimplify_all_functions (struct cgraph_node *root)\n   struct cgraph_node *iter;\n   if (!gimple_body (root->decl))\n     gimplify_function_tree (root->decl);\n-  for (iter = root->nested; iter; iter = iter->next_nested)\n+  for (iter = first_nested_function (root); iter;\n+       iter = next_nested_function (iter))\n     if (!iter->thunk.thunk_p)\n       gimplify_all_functions (iter);\n }\n@@ -3557,7 +3653,7 @@ lower_nested_functions (tree fndecl)\n \n   /* If there are no nested functions, there's nothing to do.  */\n   cgn = cgraph_node::get (fndecl);\n-  if (!cgn->nested)\n+  if (!first_nested_function (cgn))\n     return;\n \n   gimplify_all_functions (cgn);"}, {"sha": "bdef4160ffbb11184a67992728604a360b40d84b", "filename": "gcc/tree-nested.h", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89576d863a879c4986867f991a6ac493106a9879/gcc%2Ftree-nested.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89576d863a879c4986867f991a6ac493106a9879/gcc%2Ftree-nested.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.h?ref=89576d863a879c4986867f991a6ac493106a9879", "patch": "@@ -24,4 +24,66 @@ extern tree build_addr (tree);\n extern void insert_field_into_struct (tree, tree);\n extern void lower_nested_functions (tree);\n \n+class nested_function_info\n+{\n+public:\n+  /* Constructor.  */\n+  nested_function_info ()\n+    : origin (NULL),\n+      nested (NULL),\n+      next_nested (NULL)\n+  {\n+  }\n+  /* Copy constructor.  We can not simply copy the structure,\n+     because the linked lists would go wrong.  However we should never\n+     need that.  */\n+  nested_function_info (const nested_function_info &)\n+  {\n+     gcc_unreachable ();\n+  }\n+  ~nested_function_info ();\n+\n+  /* Return nested_function_info, if available.  */\n+  static nested_function_info *get (cgraph_node *node);\n+\n+  /* Return nested_function_info possibly creating new one.  */\n+  static nested_function_info *get_create (cgraph_node *node);\n+\n+  /* Release all nested_function_infos.  */\n+  static void release (void);\n+\n+  /* For nested functions points to function the node is nested in.  */\n+  cgraph_node *origin;\n+  /* Points to first nested function, if any.  */\n+  cgraph_node *nested;\n+  /* Pointer to the next function with same origin, if any.  */\n+  cgraph_node *next_nested;\n+};\n+\n+extern void maybe_record_nested_function (cgraph_node *node);\n+extern void unnest_function (cgraph_node *node);\n+\n+/* If there are functions nested in NODE, return first one.  */\n+inline cgraph_node *\n+first_nested_function (cgraph_node *node)\n+{\n+  nested_function_info *info = nested_function_info::get (node);\n+  return info ? info->nested : NULL;\n+}\n+\n+/* Return next nested function (used to iterate from first_nested_function).  */\n+inline cgraph_node *\n+next_nested_function (cgraph_node *node)\n+{\n+  return nested_function_info::get (node)->next_nested;\n+}\n+\n+/* Return origin of nested function (and NULL otherwise).  */\n+inline cgraph_node *\n+nested_function_origin (cgraph_node *node)\n+{\n+  nested_function_info *info = nested_function_info::get (node);\n+  return info ? info->origin : NULL;\n+}\n+\n #endif /* GCC_TREE_NESTED_H */"}]}