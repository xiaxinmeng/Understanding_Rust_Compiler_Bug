{"sha": "56bafc49a02cbff82b628e83c35e36d1872fdcc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiYWZjNDlhMDJjYmZmODJiNjI4ZTgzYzM1ZTM2ZDE4NzJmZGNjOA==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2016-09-23T19:36:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-23T19:36:45Z"}, "message": "compiler: better abstraction layer for diagnostics.\n\n    \n    Introduce an abstraction layer for reporting diagnostics, so as to avoid\n    directly using the native GCC interfaces such as \"error_at\",\n    \"warning_at\", \"open_quote\", \"close_quote\", etc.  The new interfaces have\n    the same look and feel as the GCC equivalents, but make calls into\n    back-end functions to allow the back end to select the proper final\n    reporting routine.\n    \n    Reviewed-on: https://go-review.googlesource.com/29191\n\n\t* go-gcc-diagnostics.cc: New file.\n\t* go-location.h (Location): Remove operator source_location.  Add\n\toperator==.\n\t* go-system.h: #include <sstream>.\n\t* Make-lang.in (GO_OBJS): Add go/go-diagnostics.o and\n\tgo/go-gcc-diagnostics.o.\n\t(CFLAGS-go/go-gcc-diagnostics.o): New variable.\n\nFrom-SVN: r240453", "tree": {"sha": "a45167990fa1fe860cc44939f3ec887785089c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a45167990fa1fe860cc44939f3ec887785089c27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56bafc49a02cbff82b628e83c35e36d1872fdcc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bafc49a02cbff82b628e83c35e36d1872fdcc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56bafc49a02cbff82b628e83c35e36d1872fdcc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bafc49a02cbff82b628e83c35e36d1872fdcc8/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34a594e85618002815e2faf3b515ba1d7446a55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a594e85618002815e2faf3b515ba1d7446a55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a594e85618002815e2faf3b515ba1d7446a55b"}], "stats": {"total": 2063, "additions": 1217, "deletions": 846}, "files": [{"sha": "2af23240e42d8333371935cd34effda5d5f49725", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -1,3 +1,13 @@\n+2016-09-23  Than McIntosh  <thanm@google.com>\n+\n+\t* go-gcc-diagnostics.cc: New file.\n+\t* go-location.h (Location): Remove operator source_location.  Add\n+\toperator==.\n+\t* go-system.h: #include <sstream>.\n+\t* Make-lang.in (GO_OBJS): Add go/go-diagnostics.o and\n+\tgo/go-gcc-diagnostics.o.\n+\t(CFLAGS-go/go-gcc-diagnostics.o): New variable.\n+\n 2016-09-23  Chris Manghane  <cmang@google.com>\n \n \tPR go/77701"}, {"sha": "7235f19af17e4bedb7835fb66f99272bca2ecadc", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -54,8 +54,10 @@ GO_OBJS = \\\n \tgo/export.o \\\n \tgo/expressions.o \\\n \tgo/go-backend.o \\\n+\tgo/go-diagnostics.o \\\n \tgo/go-dump.o \\\n \tgo/go-gcc.o \\\n+\tgo/go-gcc-diagnostics.o \\\n \tgo/go-lang.o \\\n \tgo/go-linemap.o \\\n \tgo/go-optimize.o \\\n@@ -227,6 +229,7 @@ GOINCLUDES = -I $(srcdir)/go -I $(srcdir)/go/gofrontend\n CFLAGS-go/go-gcc.o += $(GOINCLUDES)\n CFLAGS-go/go-linemap.o += $(GOINCLUDES)\n CFLAGS-go/go-sha1.o += $(GOINCLUDES)\n+CFLAGS-go/go-gcc-diagnostics.o += $(GOINCLUDES)\n \n go/%.o: go/gofrontend/%.cc\n \t$(COMPILE) $(GOINCLUDES) $<"}, {"sha": "893b31e659704a01748a61e2c4a08843268e10c2", "filename": "gcc/go/go-gcc-diagnostics.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc-diagnostics.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -0,0 +1,61 @@\n+// go-gcc-diagnostics.cc -- GCC implementation of go diagnostics interface.\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+// Contributed by Than McIntosh, Google.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"go-system.h\"\n+#include \"go-diagnostics.h\"\n+\n+void\n+go_be_error_at(const Location location, const std::string& errmsg)\n+{\n+  source_location gcc_loc = location.gcc_location();\n+  error_at(gcc_loc, \"%s\", errmsg.c_str());\n+}\n+\n+\n+void\n+go_be_warning_at(const Location location,\n+                 int opt, const std::string& warningmsg)\n+{\n+  source_location gcc_loc = location.gcc_location();\n+  warning_at(gcc_loc, opt, \"%s\", warningmsg.c_str());\n+}\n+\n+void\n+go_be_fatal_error(const Location location,\n+                  const std::string& fatalmsg)\n+{\n+  source_location gcc_loc = location.gcc_location();\n+  fatal_error(gcc_loc, \"%s\", fatalmsg.c_str());\n+}\n+\n+void\n+go_be_inform(const Location location,\n+             const std::string& infomsg)\n+{\n+  source_location gcc_loc = location.gcc_location();\n+  inform(gcc_loc, \"%s\", infomsg.c_str());\n+}\n+\n+void\n+go_be_get_quotechars(const char** open_qu, const char** close_qu)\n+{\n+  *open_qu = open_quote;\n+  *close_qu = close_quote;\n+}"}, {"sha": "90258ea1a29d97512636d45a7b8a3273775ef776", "filename": "gcc/go/go-location.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-location.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -26,10 +26,6 @@ class Location\n   gcc_location() const\n   { return this->gcc_loc_; }\n \n-  // Temporary hack till error_at and warning_at can deal with a Location.\n-  operator source_location() const\n-  { return this->gcc_loc_; }\n-\n  private:\n   source_location gcc_loc_;\n };\n@@ -42,4 +38,10 @@ operator<(Location loca, Location locb)\n   return loca.gcc_location() < locb.gcc_location();\n }\n \n+inline bool\n+operator==(Location loca, Location locb)\n+{\n+  return loca.gcc_location() == locb.gcc_location();\n+}\n+\n #endif // !defined(GO_LOCATION_H)"}, {"sha": "d348d5c533a553a9d1f18234cc71c3f69acd0b70", "filename": "gcc/go/go-system.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgo-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-system.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -30,6 +30,7 @@\n #include <map>\n #include <set>\n #include <vector>\n+#include <sstream>\n \n #if defined(HAVE_UNORDERED_MAP)\n "}, {"sha": "a3457cfcfbc69f2a721b6e2a72cdaa6d76f25f34", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -1,4 +1,4 @@\n-4f84c5e0210e674163f3f6462da6f5be9e5b0a36\n+57bf3f21005c4508003f65207282c057e3526ec0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "94bf5ef4369309d0e9e361b1db7bb49c72191f56", "filename": "gcc/go/gofrontend/ast-dump.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -16,6 +16,7 @@\n #include \"ast-dump.h\"\n #include \"go-c.h\"\n #include \"go-dump.h\"\n+#include \"go-diagnostics.h\"\n \n // The -fgo-dump-ast flag to activate AST dumps.\n \n@@ -173,7 +174,8 @@ Ast_dump_context::dump(Gogo* gogo, const char* basename)\n \n   if (out.fail())\n     {\n-      error(\"cannot open %s:%m, -fgo-dump-ast ignored\", dumpname.c_str());\n+      go_error_at(Linemap::unknown_location(),\n+\t\t  \"cannot open %s:%m, -fgo-dump-ast ignored\", dumpname.c_str());\n       return;\n     }\n "}, {"sha": "3b9d3a6202ab842a3b7b3d4324306402f10ebffc", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -55,7 +55,7 @@ class Backend\n     Location location;\n \n     Btyped_identifier()\n-      : name(), btype(NULL), location(UNKNOWN_LOCATION)\n+        : name(), btype(NULL), location(Linemap::unknown_location())\n     { }\n \n     Btyped_identifier(const std::string& a_name, Btype* a_btype,"}, {"sha": "1c810769d229fb9e2542e19a0cae500e6aed4543", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 91, "deletions": 86, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -17,6 +17,7 @@\n #include \"escape.h\"\n #include \"ast-dump.h\"\n #include \"go-optimize.h\"\n+#include \"go-diagnostics.h\"\n \n // class Node.\n \n@@ -737,9 +738,9 @@ Gogo::analyze_escape()\n \t    {\n \t      Node::Escape_state* state = (*n)->state(context, NULL);\n \t      if (((*n)->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n-\t\tinform((*n)->location(), \"%s %s does not escape\",\n-\t\t       strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n-\t\t       (*n)->ast_format(this).c_str());\n+\t\tgo_inform((*n)->location(), \"%s %s does not escape\",\n+\t\t\t  strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n+\t\t\t  (*n)->ast_format(this).c_str());\n \t    }\n \t  // TODO(cmang): Which objects in context->noesc actually don't escape.\n \t}\n@@ -1039,9 +1040,9 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n     {\n       Node* n = Node::make_node(s);\n       std::string fn_name = this->context_->current_function_name();\n-      inform(s->location(), \"[%d] %s esc: %s\",\n-\t     this->context_->loop_depth(), fn_name.c_str(),\n-\t     n->ast_format(gogo).c_str());\n+      go_inform(s->location(), \"[%d] %s esc: %s\",\n+\t        this->context_->loop_depth(), fn_name.c_str(),\n+\t        n->ast_format(gogo).c_str());\n     }\n \n   switch (s->classification())\n@@ -1074,9 +1075,9 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n \t    std::string label_type = (label_stmt->label()->looping()\n \t\t\t\t      ? \"looping\"\n \t\t\t\t      : \"nonlooping\");\n-\t    inform(s->location(), \"%s %s label\",\n-\t\t   label_stmt->label()->name().c_str(),\n-\t\t   label_type.c_str());\n+\t    go_inform(s->location(), \"%s %s label\",\n+\t\t      label_stmt->label()->name().c_str(),\n+\t\t      label_type.c_str());\n \t  }\n       }\n       break;\n@@ -1163,7 +1164,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       && n->is_big(this->context_))\n     {\n       if (debug_level > 1)\n-\tinform((*pexpr)->location(), \"too large for stack\");\n+\tgo_inform((*pexpr)->location(), \"too large for stack\");\n       n->set_encoding(Node::ESCAPE_HEAP);\n       (*pexpr)->address_taken(true);\n       this->assign(this->context_->sink(), n);\n@@ -1176,9 +1177,9 @@ Escape_analysis_assign::expression(Expression** pexpr)\n     {\n       Node* n = Node::make_node(*pexpr);\n       std::string fn_name = this->context_->current_function_name();\n-      inform((*pexpr)->location(), \"[%d] %s esc: %s\",\n-\t     this->context_->loop_depth(), fn_name.c_str(),\n-\t     n->ast_format(gogo).c_str());\n+      go_inform((*pexpr)->location(), \"[%d] %s esc: %s\",\n+\t\tthis->context_->loop_depth(), fn_name.c_str(),\n+\t\tn->ast_format(gogo).c_str());\n     }\n \n   switch ((*pexpr)->classification())\n@@ -1210,7 +1211,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t\t  this->assign_deref(this->context_->sink(), appended);\n \n \t\t  if (debug_level > 2)\n-\t\t    error_at((*pexpr)->location(),\n+\t\t    go_error_at((*pexpr)->location(),\n \t\t\t     \"special treatment of append(slice1, slice2...)\");\n \n \t\t  // The content of the original slice leaks as well.\n@@ -1507,9 +1508,9 @@ Escape_analysis_assign::call(Call_expression* call)\n            ++p)\n \t{\n \t  if (debug_level > 2)\n-\t    inform(call->location(),\n-\t\t   \"esccall:: indirect call <- %s, untracked\",\n-\t\t   (*p)->ast_format(gogo).c_str());\n+\t    go_inform(call->location(),\n+\t\t      \"esccall:: indirect call <- %s, untracked\",\n+\t\t      (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n \n@@ -1523,8 +1524,8 @@ Escape_analysis_assign::call(Call_expression* call)\n       && !fntype->is_tagged())\n     {\n       if (debug_level > 2)\n-\tinform(call->location(), \"esccall:: %s in recursive group\",\n-\t       call_node->ast_format(gogo).c_str());\n+\tgo_inform(call->location(), \"esccall:: %s in recursive group\",\n+\t\t  call_node->ast_format(gogo).c_str());\n \n       Function* f = fn->named_object()->func_value();\n       const Bindings* callee_bindings = f->block()->bindings();\n@@ -1592,8 +1593,8 @@ Escape_analysis_assign::call(Call_expression* call)\n \t  for (; p != arg_nodes.end(); ++p)\n \t    {\n \t      if (debug_level > 2)\n-\t\tinform(call->location(), \"esccall:: ... <- %s, untracked\",\n-\t\t       (*p)->ast_format(gogo).c_str());\n+\t\tgo_inform(call->location(), \"esccall:: ... <- %s, untracked\",\n+\t\t\t  (*p)->ast_format(gogo).c_str());\n \t      this->assign(this->context_->sink(), *p);\n \t    }\n \t}\n@@ -1602,12 +1603,14 @@ Escape_analysis_assign::call(Call_expression* call)\n     }\n \n   if (debug_level > 2)\n-    inform(call->location(), \"esccall:: %s not recursive\",\n-\t   call_node->ast_format(gogo).c_str());\n+    go_inform(call->location(), \"esccall:: %s not recursive\",\n+\t      call_node->ast_format(gogo).c_str());\n \n   Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n   if (!call_state->retvals.empty())\n-    error(\"esc already decorated call %s\", call_node->ast_format(gogo).c_str());\n+    go_error_at(Linemap::unknown_location(),\n+\t\t\"esc already decorated call %s\",\n+\t\tcall_node->ast_format(gogo).c_str());\n   this->context_->init_retvals(call_node, fntype);\n \n   // Receiver.\n@@ -1676,8 +1679,8 @@ Escape_analysis_assign::call(Call_expression* call)\n       for (; p != arg_nodes.end(); ++p)\n \t{\n \t  if (debug_level > 2)\n-\t    inform(call->location(), \"esccall:: ... <- %s, untracked\",\n-\t\t   (*p)->ast_format(gogo).c_str());\n+\t    go_inform(call->location(), \"esccall:: ... <- %s, untracked\",\n+                      (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n     }\n@@ -1695,13 +1698,13 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n   Gogo* gogo = this->context_->gogo();\n   int debug_level = gogo->debug_escape_level();\n   if (debug_level > 1)\n-    inform(dst->location(), \"[%d] %s escassign: %s(%s)[%s] = %s(%s)[%s]\",\n-\t   this->context_->loop_depth(),\n-\t   strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n-\t   dst->ast_format(gogo).c_str(), dst->details().c_str(),\n-\t   dst->op_format().c_str(),\n-\t   src->ast_format(gogo).c_str(), src->details().c_str(),\n-\t   src->op_format().c_str());\n+    go_inform(dst->location(), \"[%d] %s escassign: %s(%s)[%s] = %s(%s)[%s]\",\n+\t      this->context_->loop_depth(),\n+\t      strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n+\t      dst->ast_format(gogo).c_str(), dst->details().c_str(),\n+\t      dst->op_format().c_str(),\n+\t      src->ast_format(gogo).c_str(), src->details().c_str(),\n+\t      src->op_format().c_str());\n \n   if (dst->expr() != NULL)\n     {\n@@ -2123,8 +2126,8 @@ Escape_analysis_assign::assign_from_note(std::string* note,\n     }\n \n   if (this->context_->gogo()->debug_escape_level() > 2)\n-    inform(src->location(), \"assignfromtag:: src=  em=%s\",\n-\t   Escape_note::make_tag(enc).c_str());\n+    go_inform(src->location(), \"assignfromtag:: src=  em=%s\",\n+\t      Escape_note::make_tag(enc).c_str());\n \n   if (enc == Node::ESCAPE_UNKNOWN)\n     {\n@@ -2194,8 +2197,8 @@ Escape_analysis_assign::flows(Node* dst, Node* src)\n \n   Gogo* gogo = this->context_->gogo();\n   if (gogo->debug_escape_level() > 2)\n-    inform(Linemap::unknown_location(), \"flows:: %s <- %s\",\n-\t   dst->ast_format(gogo).c_str(), src->ast_format(gogo).c_str());\n+    go_inform(Linemap::unknown_location(), \"flows:: %s <- %s\",\n+              dst->ast_format(gogo).c_str(), src->ast_format(gogo).c_str());\n \n   if (dst_state->flows.empty())\n     this->context_->add_dst(dst);\n@@ -2355,18 +2358,18 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   Gogo* gogo = this->context_->gogo();\n   int debug_level = gogo->debug_escape_level();\n   if (debug_level > 1)\n-    inform(Linemap::unknown_location(),\n-\t   \"escwalk: level:{%d %d} depth:%d \"\n-\t   \"op=%s %s(%s) \"\n-\t   \"scope:%s[%d] \"\n-\t   \"extraloopdepth=%d\",\n-\t   level.value(), level.suffix_value(), this->context_->pdepth(),\n-\t   src->op_format().c_str(),\n-\t   src->ast_format(gogo).c_str(),\n-\t   src->details().c_str(),\n-\t   debug_function_name(src_state->fn).c_str(),\n-\t   src_state->loop_depth,\n-\t   extra_loop_depth);\n+    go_inform(Linemap::unknown_location(),\n+\t      \"escwalk: level:{%d %d} depth:%d \"\n+\t      \"op=%s %s(%s) \"\n+\t      \"scope:%s[%d] \"\n+\t      \"extraloopdepth=%d\",\n+\t      level.value(), level.suffix_value(), this->context_->pdepth(),\n+\t      src->op_format().c_str(),\n+\t      src->ast_format(gogo).c_str(),\n+\t      src->details().c_str(),\n+\t      debug_function_name(src_state->fn).c_str(),\n+\t      src_state->loop_depth,\n+\t      extra_loop_depth);\n \n   this->context_->increase_pdepth();\n \n@@ -2400,15 +2403,17 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       if (debug_level != 0)\n \t{\n \t  if (debug_level == 1)\n-\t    inform(src->location(),\n-\t\t   \"leaking param: %s to result %s level=%d\",\n-\t\t   src->ast_format(gogo).c_str(), dst->ast_format(gogo).c_str(),\n-\t\t   level.value());\n+\t    go_inform(src->location(),\n+\t\t      \"leaking param: %s to result %s level=%d\",\n+\t\t      src->ast_format(gogo).c_str(),\n+\t\t      dst->ast_format(gogo).c_str(),\n+\t\t      level.value());\n \t  else\n-\t    inform(src->location(),\n-\t\t   \"leaking param: %s to result %s level={%d %d}\",\n-\t\t   src->ast_format(gogo).c_str(), dst->ast_format(gogo).c_str(),\n-\t\t   level.value(), level.suffix_value());\n+\t    go_inform(src->location(),\n+\t\t      \"leaking param: %s to result %s level={%d %d}\",\n+\t\t      src->ast_format(gogo).c_str(),\n+\t\t      dst->ast_format(gogo).c_str(),\n+\t\t      level.value(), level.suffix_value());\n \t}\n \n       if ((src->encoding() & ESCAPE_MASK) != Node::ESCAPE_RETURN)\n@@ -2446,8 +2451,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t   Node::ESCAPE_NONE);\n       src->set_encoding(enc);\n       if (debug_level != 0)\n-\tinform(src->location(), \"mark escaped content: %s\",\n-\t       src->ast_format(gogo).c_str());\n+\tgo_inform(src->location(), \"mark escaped content: %s\",\n+\t\t  src->ast_format(gogo).c_str());\n     }\n \n   // A src object leaks if its value or address is assigned to a dst object\n@@ -2468,13 +2473,13 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t       Node::ESCAPE_NONE);\n \t  src->set_encoding(enc);\n \t  if (debug_level != 0)\n-\t    inform(src->location(), \"leaking param content: %s\",\n-\t\t   src->ast_format(gogo).c_str());\n+\t    go_inform(src->location(), \"leaking param content: %s\",\n+\t\t      src->ast_format(gogo).c_str());\n \t}\n       else\n \t{\n \t  if (debug_level != 0)\n-\t    inform(src->location(), \"leaking param\");\n+\t    go_inform(src->location(), \"leaking param\");\n \t  src->set_encoding(Node::ESCAPE_SCOPE);\n \t}\n     }\n@@ -2484,8 +2489,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       if (e->enclosed_var_expression() != NULL)\n \t{\n \t  if (src_leaks && debug_level != 0)\n-\t    inform(src->location(), \"leaking closure reference %s\",\n-\t\t   src->ast_format(gogo).c_str());\n+\t    go_inform(src->location(), \"leaking closure reference %s\",\n+\t\t      src->ast_format(gogo).c_str());\n \n \t  Node* enclosed_node =\n \t    Node::make_node(e->enclosed_var_expression()->variable());\n@@ -2511,19 +2516,19 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n \t      if (debug_level != 0)\n \t\t{\n-\t\t  inform(underlying->location(), \"moved to heap: %s\",\n-\t\t\t underlying_node->ast_format(gogo).c_str());\n+\t\t  go_inform(underlying->location(), \"moved to heap: %s\",\n+                            underlying_node->ast_format(gogo).c_str());\n \n \t\t  if (debug_level > 1)\n-\t\t    inform(src->location(),\n-\t\t\t   \"%s escapes to heap, level={%d %d}, \"\n-\t\t\t   \"dst.eld=%d, src.eld=%d\",\n-\t\t\t   src->ast_format(gogo).c_str(), level.value(),\n-\t\t\t   level.suffix_value(), dst_state->loop_depth,\n-\t\t\t   mod_loop_depth);\n+\t\t    go_inform(src->location(),\n+\t\t\t      \"%s escapes to heap, level={%d %d}, \"\n+\t\t\t      \"dst.eld=%d, src.eld=%d\",\n+\t\t\t      src->ast_format(gogo).c_str(), level.value(),\n+\t\t\t      level.suffix_value(), dst_state->loop_depth,\n+\t\t\t      mod_loop_depth);\n \t\t  else\n-\t\t    inform(src->location(), \"%s escapes to heap\",\n-\t\t\t   src->ast_format(gogo).c_str());\n+\t\t    go_inform(src->location(), \"%s escapes to heap\",\n+\t\t\t      src->ast_format(gogo).c_str());\n \t\t}\n \n \t      this->flood(level.decrease(), dst,\n@@ -2553,8 +2558,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n \t      if (debug_level != 0)\n-\t\tinform(src->location(), \"%s escapes to heap\",\n-\t\t       src->ast_format(gogo).c_str());\n+\t\tgo_inform(src->location(), \"%s escapes to heap\",\n+\t\t\t  src->ast_format(gogo).c_str());\n \t      extra_loop_depth = mod_loop_depth;\n \t    }\n \t}\n@@ -2598,8 +2603,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t{\n \t\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n \t\t\t  if (debug_level != 0)\n-\t\t\t    inform(src->location(), \"%s escapes to heap\",\n-\t\t\t\t   src->ast_format(gogo).c_str());\n+\t\t\t    go_inform(src->location(), \"%s escapes to heap\",\n+\t\t\t\t      src->ast_format(gogo).c_str());\n \t\t\t  extra_loop_depth = mod_loop_depth;\n \t\t\t}\n \t\t      break;\n@@ -2616,8 +2621,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t  // so if this leaks, this call must be done on the heap.\n \t\t  src->set_encoding(Node::ESCAPE_HEAP);\n \t\t  if (debug_level != 0)\n-\t\t    inform(src->location(), \"%s escapes to heap\",\n-\t\t\t   src->ast_format(gogo).c_str());\n+\t\t    go_inform(src->location(), \"%s escapes to heap\",\n+\t\t\t      src->ast_format(gogo).c_str());\n \t\t}\n \t    }\n \t}\n@@ -2626,8 +2631,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  // Calls to Runtime::NEW get lowered into an allocation expression.\n \t  src->set_encoding(Node::ESCAPE_HEAP);\n \t  if (debug_level != 0)\n-\t    inform(src->location(), \"%s escapes to heap\",\n-\t\t   src->ast_format(gogo).c_str());\n+\t    go_inform(src->location(), \"%s escapes to heap\",\n+                      src->ast_format(gogo).c_str());\n \t}\n       else if ((e->field_reference_expression() != NULL\n \t\t&& e->field_reference_expression()->expr()->unary_expression() == NULL)\n@@ -2703,10 +2708,10 @@ Gogo::propagate_escape(Escape_context* context, Node* dst)\n   Node::Escape_state* state = dst->state(context, NULL);\n   Gogo* gogo = context->gogo();\n   if (gogo->debug_escape_level() > 1)\n-    inform(Linemap::unknown_location(), \"escflood:%d: dst %s scope:%s[%d]\",\n-\t   context->flood_id(), dst->ast_format(gogo).c_str(),\n-\t   debug_function_name(state->fn).c_str(),\n-\t   state->loop_depth);\n+    go_inform(Linemap::unknown_location(), \"escflood:%d: dst %s scope:%s[%d]\",\n+\t      context->flood_id(), dst->ast_format(gogo).c_str(),\n+\t      debug_function_name(state->fn).c_str(),\n+\t      state->loop_depth);\n \n   Escape_analysis_flood eaf(context);\n   for (std::set<Node*>::const_iterator p = state->flows.begin();"}, {"sha": "5342e45754dc0b6773941f9bd4fdc1ddcd79c115", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 201, "deletions": 194, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -10,6 +10,7 @@\n \n #include \"go-c.h\"\n #include \"gogo.h\"\n+#include \"go-diagnostics.h\"\n #include \"types.h\"\n #include \"export.h\"\n #include \"import.h\"\n@@ -107,7 +108,7 @@ Expression::set_is_error()\n void\n Expression::report_error(const char* msg)\n {\n-  error_at(this->location_, \"%s\", msg);\n+  go_error_at(this->location_, \"%s\", msg);\n   this->set_is_error();\n }\n \n@@ -1139,9 +1140,9 @@ Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n   // can't take their address.\n   if (fntype->is_builtin())\n     {\n-      error_at(loc,\n-\t       \"invalid use of special builtin function %qs; must be called\",\n-\t       no->message_name().c_str());\n+      go_error_at(loc,\n+\t\t  \"invalid use of special builtin function %qs; must be called\",\n+\t\t  no->message_name().c_str());\n       return gogo->backend()->error_expression();\n     }\n \n@@ -1178,10 +1179,10 @@ Func_expression::do_get_backend(Translate_context* context)\n \t{\n \t  if (no->func_declaration_value()->type()->is_builtin())\n \t    {\n-\t      error_at(this->location(),\n-\t\t       (\"invalid use of special builtin function %qs; \"\n-\t\t\t\"must be called\"),\n-\t\t       no->message_name().c_str());\n+\t      go_error_at(this->location(),\n+\t\t\t  (\"invalid use of special builtin function %qs; \"\n+\t\t\t   \"must be called\"),\n+\t\t\t  no->message_name().c_str());\n \t      return gogo->backend()->error_expression();\n \t    }\n \t  descriptor = no->func_declaration_value()->descriptor(gogo, no);\n@@ -1447,8 +1448,8 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \t  if (this->is_composite_literal_key_)\n \t    return this;\n \t  if (!this->no_error_message_)\n-\t    error_at(location, \"reference to undefined name %qs\",\n-\t\t     this->named_object_->message_name().c_str());\n+\t    go_error_at(location, \"reference to undefined name %qs\",\n+\t\t\tthis->named_object_->message_name().c_str());\n \t  return Expression::make_error(location);\n \t}\n     }\n@@ -1462,8 +1463,8 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       if (this->is_composite_literal_key_)\n \treturn this;\n       if (!this->no_error_message_)\n-\terror_at(location, \"reference to undefined type %qs\",\n-\t\t real->message_name().c_str());\n+\tgo_error_at(location, \"reference to undefined type %qs\",\n+\t\t    real->message_name().c_str());\n       return Expression::make_error(location);\n     case Named_object::NAMED_OBJECT_VAR:\n       real->var_value()->set_is_used();\n@@ -1475,7 +1476,7 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       if (this->is_composite_literal_key_)\n \treturn this;\n       if (!this->no_error_message_)\n-\terror_at(location, \"unexpected reference to package\");\n+\tgo_error_at(location, \"unexpected reference to package\");\n       return Expression::make_error(location);\n     default:\n       go_unreachable();\n@@ -1726,7 +1727,7 @@ String_expression::do_import(Import* imp)\n \t    }\n \t  else\n \t    {\n-\t      error_at(imp->location(), \"bad string constant\");\n+\t      go_error_at(imp->location(), \"bad string constant\");\n \t      return Expression::make_error(imp->location());\n \t    }\n \t}\n@@ -2036,8 +2037,8 @@ Integer_expression::do_get_backend(Translate_context* context)\n       else\n         {\n           if (!saw_errors())\n-            error_at(this->location(),\n-                     \"unknown type for large integer constant\");\n+            go_error_at(this->location(),\n+                        \"unknown type for large integer constant\");\n           return context->gogo()->backend()->error_expression();\n         }\n     }\n@@ -2088,8 +2089,8 @@ Integer_expression::do_import(Import* imp)\n \tpos = plus_pos;\n       else\n \t{\n-\t  error_at(imp->location(), \"bad number in import data: %qs\",\n-\t\t   num.c_str());\n+\t  go_error_at(imp->location(), \"bad number in import data: %qs\",\n+\t\t      num.c_str());\n \t  return Expression::make_error(imp->location());\n \t}\n       if (pos == std::string::npos)\n@@ -2099,8 +2100,8 @@ Integer_expression::do_import(Import* imp)\n \t  std::string real_str = num.substr(0, pos);\n \t  if (mpfr_init_set_str(real, real_str.c_str(), 10, GMP_RNDN) != 0)\n \t    {\n-\t      error_at(imp->location(), \"bad number in import data: %qs\",\n-\t\t       real_str.c_str());\n+\t      go_error_at(imp->location(), \"bad number in import data: %qs\",\n+\t\t\t  real_str.c_str());\n \t      return Expression::make_error(imp->location());\n \t    }\n \t}\n@@ -2114,8 +2115,8 @@ Integer_expression::do_import(Import* imp)\n       mpfr_t imag;\n       if (mpfr_init_set_str(imag, imag_str.c_str(), 10, GMP_RNDN) != 0)\n \t{\n-\t  error_at(imp->location(), \"bad number in import data: %qs\",\n-\t\t   imag_str.c_str());\n+\t  go_error_at(imp->location(), \"bad number in import data: %qs\",\n+\t\t      imag_str.c_str());\n \t  return Expression::make_error(imp->location());\n \t}\n       mpc_t cval;\n@@ -2137,8 +2138,8 @@ Integer_expression::do_import(Import* imp)\n       mpz_t val;\n       if (mpz_init_set_str(val, num.c_str(), 10) != 0)\n \t{\n-\t  error_at(imp->location(), \"bad number in import data: %qs\",\n-\t\t   num.c_str());\n+\t  go_error_at(imp->location(), \"bad number in import data: %qs\",\n+\t\t      num.c_str());\n \t  return Expression::make_error(imp->location());\n \t}\n       Expression* ret;\n@@ -2154,8 +2155,8 @@ Integer_expression::do_import(Import* imp)\n       mpfr_t val;\n       if (mpfr_init_set_str(val, num.c_str(), 10, GMP_RNDN) != 0)\n \t{\n-\t  error_at(imp->location(), \"bad number in import data: %qs\",\n-\t\t   num.c_str());\n+\t  go_error_at(imp->location(), \"bad number in import data: %qs\",\n+\t\t      num.c_str());\n \t  return Expression::make_error(imp->location());\n \t}\n       Expression* ret = Expression::make_float(&val, NULL, imp->location());\n@@ -2758,8 +2759,8 @@ Const_expression::do_lower(Gogo* gogo, Named_object*,\n     {\n       if (iota_value == -1)\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"iota is only defined in const declarations\");\n+\t  go_error_at(this->location(),\n+\t\t      \"iota is only defined in const declarations\");\n \t  iota_value = 0;\n \t}\n       return Expression::make_integer_ul(iota_value, NULL, this->location());\n@@ -3215,7 +3216,7 @@ Type_conversion_expression::do_lower(Gogo*, Named_object*,\n \t\t      int adv = Lex::fetch_char(p, &c);\n \t\t      if (adv == 0)\n \t\t\t{\n-\t\t\t  warning_at(this->location(), 0,\n+\t\t\t  go_warning_at(this->location(), 0,\n \t\t\t\t     \"invalid UTF-8 encoding\");\n \t\t\t  adv = 1;\n \t\t\t}\n@@ -3374,7 +3375,7 @@ Type_conversion_expression::do_check_types(Gogo*)\n   if (Type::are_convertible(type, expr_type, &reason))\n     return;\n \n-  error_at(this->location(), \"%s\", reason.c_str());\n+  go_error_at(this->location(), \"%s\", reason.c_str());\n   this->set_is_error();\n }\n \n@@ -3691,8 +3692,8 @@ Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \t\t  // *&x == x.\n \t\t  if (!ue->expr_->is_addressable() && !ue->create_temp_)\n \t\t    {\n-\t\t      error_at(ue->location(),\n-\t\t\t       \"invalid operand for unary %<&%>\");\n+\t\t      go_error_at(ue->location(),\n+\t\t\t\t  \"invalid operand for unary %<&%>\");\n \t\t      this->set_is_error();\n \t\t    }\n \t\t  return ue->expr_;\n@@ -3706,7 +3707,7 @@ Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n   // having to deal with TYPE_VOID in other places.\n   if (op == OPERATOR_MULT && expr->type()->is_unsafe_pointer_type())\n     {\n-      error_at(this->location(), \"invalid indirect of %<unsafe.Pointer%>\");\n+      go_error_at(this->location(), \"invalid indirect of %<unsafe.Pointer%>\");\n       return Expression::make_error(this->location());\n     }\n \n@@ -4116,7 +4117,7 @@ Unary_expression::do_check_types(Gogo*)\n \t{\n \t  if (!this->create_temp_)\n \t    {\n-\t      error_at(this->location(), \"invalid operand for unary %<&%>\");\n+\t      go_error_at(this->location(), \"invalid operand for unary %<&%>\");\n \t      this->set_is_error();\n \t    }\n \t}\n@@ -4723,7 +4724,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n       mpz_add(val, left_val, right_val);\n       if (mpz_sizeinbase(val, 2) > 0x100000)\n \t{\n-\t  error_at(location, \"constant addition overflow\");\n+\t  go_error_at(location, \"constant addition overflow\");\n           nc->set_invalid();\n \t  mpz_set_ui(val, 1);\n \t}\n@@ -4732,7 +4733,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n       mpz_sub(val, left_val, right_val);\n       if (mpz_sizeinbase(val, 2) > 0x100000)\n \t{\n-\t  error_at(location, \"constant subtraction overflow\");\n+\t  go_error_at(location, \"constant subtraction overflow\");\n           nc->set_invalid();\n \t  mpz_set_ui(val, 1);\n \t}\n@@ -4747,7 +4748,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n       mpz_mul(val, left_val, right_val);\n       if (mpz_sizeinbase(val, 2) > 0x100000)\n \t{\n-\t  error_at(location, \"constant multiplication overflow\");\n+\t  go_error_at(location, \"constant multiplication overflow\");\n           nc->set_invalid();\n \t  mpz_set_ui(val, 1);\n \t}\n@@ -4757,7 +4758,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n \tmpz_tdiv_q(val, left_val, right_val);\n       else\n \t{\n-\t  error_at(location, \"division by zero\");\n+\t  go_error_at(location, \"division by zero\");\n           nc->set_invalid();\n \t  mpz_set_ui(val, 0);\n \t}\n@@ -4767,7 +4768,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n \tmpz_tdiv_r(val, left_val, right_val);\n       else\n \t{\n-\t  error_at(location, \"division by zero\");\n+\t  go_error_at(location, \"division by zero\");\n           nc->set_invalid();\n \t  mpz_set_ui(val, 0);\n \t}\n@@ -4779,7 +4780,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n \t  mpz_mul_2exp(val, left_val, shift);\n \telse\n \t  {\n-\t    error_at(location, \"shift count overflow\");\n+\t    go_error_at(location, \"shift count overflow\");\n             nc->set_invalid();\n \t    mpz_set_ui(val, 1);\n \t  }\n@@ -4791,7 +4792,7 @@ Binary_expression::eval_integer(Operator op, const Numeric_constant* left_nc,\n \tunsigned long shift = mpz_get_ui(right_val);\n \tif (mpz_cmp_ui(right_val, shift) != 0)\n \t  {\n-\t    error_at(location, \"shift count overflow\");\n+\t    go_error_at(location, \"shift count overflow\");\n             nc->set_invalid();\n \t    mpz_set_ui(val, 1);\n \t  }\n@@ -4886,7 +4887,7 @@ Binary_expression::eval_float(Operator op, const Numeric_constant* left_nc,\n \tmpfr_div(val, left_val, right_val, GMP_RNDN);\n       else\n \t{\n-\t  error_at(location, \"division by zero\");\n+\t  go_error_at(location, \"division by zero\");\n           nc->set_invalid();\n \t  mpfr_set_ui(val, 0, GMP_RNDN);\n \t}\n@@ -4951,7 +4952,7 @@ Binary_expression::eval_complex(Operator op, const Numeric_constant* left_nc,\n     case OPERATOR_DIV:\n       if (mpc_cmp_si(right_val, 0) == 0)\n \t{\n-\t  error_at(location, \"division by zero\");\n+\t  go_error_at(location, \"division by zero\");\n           nc->set_invalid();\n \t  mpc_set_ui(val, 0, MPC_RNDNN);\n \t  break;\n@@ -5542,7 +5543,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n       if (!type->is_boolean_type()\n           || !otype->is_boolean_type())\n \t{\n-\t  error_at(location, \"expected boolean type\");\n+\t  go_error_at(location, \"expected boolean type\");\n \t  return false;\n \t}\n       break;\n@@ -5553,7 +5554,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n \tstd::string reason;\n \tif (!Type::are_compatible_for_comparison(true, type, otype, &reason))\n \t  {\n-\t    error_at(location, \"%s\", reason.c_str());\n+\t    go_error_at(location, \"%s\", reason.c_str());\n \t    return false;\n \t  }\n       }\n@@ -5567,7 +5568,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n \tstd::string reason;\n \tif (!Type::are_compatible_for_comparison(false, type, otype, &reason))\n \t  {\n-\t    error_at(location, \"%s\", reason.c_str());\n+\t    go_error_at(location, \"%s\", reason.c_str());\n \t    return false;\n \t  }\n       }\n@@ -5578,7 +5579,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n       if ((!type->is_numeric_type() && !type->is_string_type())\n           || (!otype->is_numeric_type() && !otype->is_string_type()))\n \t{\n-\t  error_at(location,\n+\t  go_error_at(location,\n \t\t   \"expected integer, floating, complex, or string type\");\n \t  return false;\n \t}\n@@ -5592,7 +5593,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n     case OPERATOR_DIVEQ:\n       if (!type->is_numeric_type() || !otype->is_numeric_type())\n \t{\n-\t  error_at(location, \"expected integer, floating, or complex type\");\n+\t  go_error_at(location, \"expected integer, floating, or complex type\");\n \t  return false;\n \t}\n       break;\n@@ -5609,7 +5610,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n     case OPERATOR_BITCLEAREQ:\n       if (type->integer_type() == NULL || otype->integer_type() == NULL)\n \t{\n-\t  error_at(location, \"expected integer type\");\n+\t  go_error_at(location, \"expected integer type\");\n \t  return false;\n \t}\n       break;\n@@ -6135,7 +6136,7 @@ Binary_expression::do_import(Import* imp)\n     }\n   else\n     {\n-      error_at(imp->location(), \"unrecognized binary operator\");\n+      go_error_at(imp->location(), \"unrecognized binary operator\");\n       return Expression::make_error(imp->location());\n     }\n \n@@ -6925,7 +6926,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t    Expression* arg = args->front();\n \t    if (!arg->is_type_expression())\n \t      {\n-\t\terror_at(arg->location(), \"expected type\");\n+\t\tgo_error_at(arg->location(), \"expected type\");\n \t\tthis->set_is_error();\n \t      }\n \t    else\n@@ -6959,10 +6960,10 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \tif (!slice_type->is_slice_type())\n \t  {\n \t    if (slice_type->is_nil_type())\n-\t      error_at(args->front()->location(), \"use of untyped nil\");\n+\t      go_error_at(args->front()->location(), \"use of untyped nil\");\n \t    else\n-\t      error_at(args->front()->location(),\n-\t\t       \"argument 1 must be a slice\");\n+\t      go_error_at(args->front()->location(),\n+\t\t\t  \"argument 1 must be a slice\");\n \t    this->set_is_error();\n \t    return this;\n \t  }\n@@ -7103,7 +7104,7 @@ Builtin_call_expression::lower_make()\n   Expression* first_arg = *parg;\n   if (!first_arg->is_type_expression())\n     {\n-      error_at(first_arg->location(), \"expected type\");\n+      go_error_at(first_arg->location(), \"expected type\");\n       this->set_is_error();\n       return Expression::make_error(this->location());\n     }\n@@ -7235,12 +7236,12 @@ Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n \tcase Numeric_constant::NC_UL_VALID:\n \t  break;\n \tcase Numeric_constant::NC_UL_NOTINT:\n-\t  error_at(e->location(), \"non-integer %s argument to make\",\n-\t\t   is_length ? \"len\" : \"cap\");\n+\t  go_error_at(e->location(), \"non-integer %s argument to make\",\n+\t\t      is_length ? \"len\" : \"cap\");\n \t  return false;\n \tcase Numeric_constant::NC_UL_NEGATIVE:\n-\t  error_at(e->location(), \"negative %s argument to make\",\n-\t\t   is_length ? \"len\" : \"cap\");\n+\t  go_error_at(e->location(), \"negative %s argument to make\",\n+\t\t      is_length ? \"len\" : \"cap\");\n \t  return false;\n \tcase Numeric_constant::NC_UL_BIG:\n \t  // We don't want to give a compile-time error for a 64-bit\n@@ -7256,8 +7257,8 @@ Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n       Type* int_type = Type::lookup_integer_type(\"int\");\n       if (bits >= int_type->integer_type()->bits())\n \t{\n-\t  error_at(e->location(), \"%s argument too large for make\",\n-\t\t   is_length ? \"len\" : \"cap\");\n+\t  go_error_at(e->location(), \"%s argument too large for make\",\n+\t\t      is_length ? \"len\" : \"cap\");\n \t  return false;\n \t}\n \n@@ -7267,8 +7268,8 @@ Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n   if (e->type()->integer_type() != NULL)\n     return true;\n \n-  error_at(e->location(), \"non-integer %s argument to make\",\n-\t   is_length ? \"len\" : \"cap\");\n+  go_error_at(e->location(), \"non-integer %s argument to make\",\n+\t      is_length ? \"len\" : \"cap\");\n   return false;\n }\n \n@@ -7976,7 +7977,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \tif (args == NULL)\n \t  {\n \t    if (this->code_ == BUILTIN_PRINT)\n-\t      warning_at(this->location(), 0,\n+\t      go_warning_at(this->location(), 0,\n \t\t\t \"no arguments for builtin function %<%s%>\",\n \t\t\t (this->code_ == BUILTIN_PRINT\n \t\t\t  ? \"print\"\n@@ -8136,8 +8137,9 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t      this->report_error(_(\"argument 2 has invalid type\"));\n \t    else\n \t      {\n-\t\terror_at(this->location(), \"argument 2 has invalid type (%s)\",\n-\t\t\t reason.c_str());\n+\t\tgo_error_at(this->location(),\n+\t\t\t    \"argument 2 has invalid type (%s)\",\n+\t\t\t    reason.c_str());\n \t\tthis->set_is_error();\n \t      }\n \t  }\n@@ -8618,7 +8620,7 @@ Builtin_call_expression::do_export(Export* exp) const\n   Numeric_constant nc;\n   if (!this->numeric_constant_value(&nc))\n     {\n-      error_at(this->location(), \"value is not constant\");\n+      go_error_at(this->location(), \"value is not constant\");\n       return;\n     }\n \n@@ -8794,8 +8796,8 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t      // the ellipsis operator should be applied to.  If we unpack the\n \t      // the call into its individual results here, the ellipsis will be\n \t      // applied to the last result.\n-\t      error_at(call->location(),\n-\t\t       _(\"multiple-value argument in single-value context\"));\n+\t      go_error_at(call->location(),\n+\t\t\t  _(\"multiple-value argument in single-value context\"));\n \t      return Expression::make_error(call->location());\n \t    }\n \n@@ -8998,8 +9000,8 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t    this->report_error(_(\"too many arguments\"));\n \t  else\n \t    {\n-\t      error_at(this->location(),\n-\t\t       _(\"invalid use of %<...%> with non-slice\"));\n+\t      go_error_at(this->location(),\n+\t\t\t  _(\"invalid use of %<...%> with non-slice\"));\n \t      this->set_is_error();\n \t    }\n \t  return;\n@@ -9365,11 +9367,11 @@ Call_expression::check_argument_type(int i, const Type* parameter_type,\n       if (!issued_error)\n \t{\n \t  if (reason.empty())\n-\t    error_at(argument_location, \"argument %d has incompatible type\", i);\n+\t    go_error_at(argument_location, \"argument %d has incompatible type\", i);\n \t  else\n-\t    error_at(argument_location,\n-\t\t     \"argument %d has incompatible type (%s)\",\n-\t\t     i, reason.c_str());\n+\t    go_error_at(argument_location,\n+\t\t\t\"argument %d has incompatible type (%s)\",\n+\t\t\ti, reason.c_str());\n \t}\n       this->set_is_error();\n       return false;\n@@ -9418,9 +9420,9 @@ Call_expression::do_check_types(Gogo*)\n \t    this->report_error(_(\"incompatible type for receiver\"));\n \t  else\n \t    {\n-\t      error_at(this->location(),\n-\t\t       \"incompatible type for receiver (%s)\",\n-\t\t       reason.c_str());\n+\t      go_error_at(this->location(),\n+                          \"incompatible type for receiver (%s)\",\n+                          reason.c_str());\n \t      this->set_is_error();\n \t    }\n \t}\n@@ -9432,8 +9434,8 @@ Call_expression::do_check_types(Gogo*)\n     {\n       if (!fntype->is_varargs())\n \t{\n-\t  error_at(this->location(),\n-\t\t   _(\"invalid use of %<...%> calling non-variadic function\"));\n+\t  go_error_at(this->location(),\n+                      _(\"invalid use of %<...%> calling non-variadic function\"));\n \t  this->set_is_error();\n \t  return;\n \t}\n@@ -9910,7 +9912,7 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     }\n   else if (left->is_type_expression())\n     {\n-      error_at(location, \"attempt to index type expression\");\n+      go_error_at(location, \"attempt to index type expression\");\n       return Expression::make_error(location);\n     }\n   else if (type->array_type() != NULL)\n@@ -9935,7 +9937,7 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     {\n       if (cap != NULL)\n         {\n-          error_at(location, \"invalid 3-index slice of string\");\n+          go_error_at(location, \"invalid 3-index slice of string\");\n           return Expression::make_error(location);\n         }\n       return Expression::make_string_index(left, start, end, location);\n@@ -9944,15 +9946,15 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     {\n       if (end != NULL || cap != NULL)\n \t{\n-\t  error_at(location, \"invalid slice of map\");\n+\t  go_error_at(location, \"invalid slice of map\");\n \t  return Expression::make_error(location);\n \t}\n       return Expression::make_map_index(left, start, location);\n     }\n   else\n     {\n-      error_at(location,\n-\t       \"attempt to index object which is not array, string, or map\");\n+      go_error_at(location,\n+                  \"attempt to index object which is not array, string, or map\");\n       return Expression::make_error(location);\n     }\n }\n@@ -10138,7 +10140,7 @@ Array_index_expression::do_check_types(Gogo*)\n \t\t  ? mpz_cmp(ival, lval) >= 0\n \t\t  : mpz_cmp(ival, lval) > 0)))\n \t{\n-\t  error_at(this->start_->location(), \"array index out of bounds\");\n+\t  go_error_at(this->start_->location(), \"array index out of bounds\");\n \t  this->set_is_error();\n \t}\n     }\n@@ -10154,7 +10156,7 @@ Array_index_expression::do_check_types(Gogo*)\n \t      || mpz_sizeinbase(eval, 2) >= int_bits\n \t      || (lval_valid && mpz_cmp(eval, lval) > 0))\n \t    {\n-\t      error_at(this->end_->location(), \"array index out of bounds\");\n+\t      go_error_at(this->end_->location(), \"array index out of bounds\");\n \t      this->set_is_error();\n \t    }\n \t  else if (ival_valid && mpz_cmp(ival, eval) > 0)\n@@ -10170,19 +10172,19 @@ Array_index_expression::do_check_types(Gogo*)\n               || mpz_sizeinbase(cval, 2) >= int_bits\n               || (lval_valid && mpz_cmp(cval, lval) > 0))\n             {\n-              error_at(this->cap_->location(), \"array index out of bounds\");\n+              go_error_at(this->cap_->location(), \"array index out of bounds\");\n               this->set_is_error();\n             }\n \t  else if (ival_valid && mpz_cmp(ival, cval) > 0)\n \t    {\n-\t      error_at(this->cap_->location(),\n-\t\t       \"invalid slice index: capacity less than start\");\n+\t      go_error_at(this->cap_->location(),\n+                          \"invalid slice index: capacity less than start\");\n \t      this->set_is_error();\n \t    }\n           else if (eval_valid && mpz_cmp(eval, cval) > 0)\n             {\n-              error_at(this->cap_->location(),\n-                       \"invalid slice index: capacity less than length\");\n+              go_error_at(this->cap_->location(),\n+                          \"invalid slice index: capacity less than length\");\n               this->set_is_error();\n             }\n           mpz_clear(cval);\n@@ -10611,7 +10613,7 @@ String_index_expression::do_check_types(Gogo*)\n \t\t  ? mpz_cmp_ui(ival, sval.length()) >= 0\n \t\t  : mpz_cmp_ui(ival, sval.length()) > 0)))\n \t{\n-\t  error_at(this->start_->location(), \"string index out of bounds\");\n+\t  go_error_at(this->start_->location(), \"string index out of bounds\");\n \t  this->set_is_error();\n \t}\n     }\n@@ -10624,7 +10626,7 @@ String_index_expression::do_check_types(Gogo*)\n \t  if (mpz_sgn(eval) < 0\n \t      || (sval_valid && mpz_cmp_ui(eval, sval.length()) > 0))\n \t    {\n-\t      error_at(this->end_->location(), \"string index out of bounds\");\n+\t      go_error_at(this->end_->location(), \"string index out of bounds\");\n \t      this->set_is_error();\n \t    }\n \t  else if (ival_valid && mpz_cmp(ival, eval) > 0)\n@@ -10854,8 +10856,8 @@ Map_index_expression::do_check_types(Gogo*)\n \tthis->report_error(_(\"incompatible type for map index\"));\n       else\n \t{\n-\t  error_at(this->location(), \"incompatible type for map index (%s)\",\n-\t\t   reason.c_str());\n+\t  go_error_at(this->location(), \"incompatible type for map index (%s)\",\n+                      reason.c_str());\n \t  this->set_is_error();\n \t}\n     }\n@@ -11226,8 +11228,8 @@ Interface_field_reference_expression::do_check_types(Gogo*)\n \tinterface_type->find_method(this->name_);\n       if (method == NULL)\n \t{\n-\t  error_at(this->location(), \"method %qs not in interface\",\n-\t\t   Gogo::message_name(this->name_).c_str());\n+\t  go_error_at(this->location(), \"method %qs not in interface\",\n+                      Gogo::message_name(this->name_).c_str());\n \t  this->set_is_error();\n \t}\n     }\n@@ -11505,9 +11507,9 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n   Named_type* nt = type->named_type();\n   if (nt == NULL)\n     {\n-      error_at(location,\n-\t       (\"method expression requires named type or \"\n-\t\t\"pointer to named type\"));\n+      go_error_at(location,\n+                  (\"method expression requires named type or \"\n+                   \"pointer to named type\"));\n       return Expression::make_error(location);\n     }\n \n@@ -11525,23 +11527,23 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n       || (left_type->named_type() != NULL && left_type->points_to() != NULL))\n     {\n       if (!is_ambiguous)\n-\terror_at(location, \"type %<%s%s%> has no method %<%s%>\",\n-\t\t is_pointer ? \"*\" : \"\",\n-\t\t nt->message_name().c_str(),\n-\t\t Gogo::message_name(name).c_str());\n+\tgo_error_at(location, \"type %<%s%s%> has no method %<%s%>\",\n+                    is_pointer ? \"*\" : \"\",\n+                    nt->message_name().c_str(),\n+                    Gogo::message_name(name).c_str());\n       else\n-\terror_at(location, \"method %<%s%s%> is ambiguous in type %<%s%>\",\n-\t\t Gogo::message_name(name).c_str(),\n-\t\t is_pointer ? \"*\" : \"\",\n-\t\t nt->message_name().c_str());\n+\tgo_error_at(location, \"method %<%s%s%> is ambiguous in type %<%s%>\",\n+                    Gogo::message_name(name).c_str(),\n+                    is_pointer ? \"*\" : \"\",\n+                    nt->message_name().c_str());\n       return Expression::make_error(location);\n     }\n \n   if (method != NULL && !is_pointer && !method->is_value_method())\n     {\n-      error_at(location, \"method requires pointer (use %<(*%s).%s%>)\",\n-\t       nt->message_name().c_str(),\n-\t       Gogo::message_name(name).c_str());\n+      go_error_at(location, \"method requires pointer (use %<(*%s).%s%>)\",\n+                  nt->message_name().c_str(),\n+                  Gogo::message_name(name).c_str());\n       return Expression::make_error(location);\n     }\n \n@@ -11916,14 +11918,14 @@ Struct_construction_expression::do_check_types(Gogo*)\n       if (!Type::are_assignable(pf->type(), (*pv)->type(), &reason))\n \t{\n \t  if (reason.empty())\n-\t    error_at((*pv)->location(),\n-\t\t     \"incompatible type for field %d in struct construction\",\n-\t\t     i + 1);\n+\t    go_error_at((*pv)->location(),\n+                        \"incompatible type for field %d in struct construction\",\n+                        i + 1);\n \t  else\n-\t    error_at((*pv)->location(),\n-\t\t     (\"incompatible type for field %d in \"\n-\t\t      \"struct construction (%s)\"),\n-\t\t     i + 1, reason.c_str());\n+\t    go_error_at((*pv)->location(),\n+                        (\"incompatible type for field %d in \"\n+                         \"struct construction (%s)\"),\n+                        i + 1, reason.c_str());\n \t  this->set_is_error();\n \t}\n     }\n@@ -12138,9 +12140,9 @@ Array_construction_expression::do_check_types(Gogo*)\n       if (*pv != NULL\n \t  && !Type::are_assignable(element_type, (*pv)->type(), NULL))\n \t{\n-\t  error_at((*pv)->location(),\n-\t\t   \"incompatible type for element %d in composite literal\",\n-\t\t   i + 1);\n+\t  go_error_at((*pv)->location(),\n+                      \"incompatible type for element %d in composite literal\",\n+                      i + 1);\n \t  this->set_is_error();\n \t}\n     }\n@@ -12588,17 +12590,17 @@ Map_construction_expression::do_check_types(Gogo*)\n     {\n       if (!Type::are_assignable(key_type, (*pv)->type(), NULL))\n \t{\n-\t  error_at((*pv)->location(),\n-\t\t   \"incompatible type for element %d key in map construction\",\n-\t\t   i + 1);\n+\t  go_error_at((*pv)->location(),\n+                      \"incompatible type for element %d key in map construction\",\n+                      i + 1);\n \t  this->set_is_error();\n \t}\n       ++pv;\n       if (!Type::are_assignable(val_type, (*pv)->type(), NULL))\n \t{\n-\t  error_at((*pv)->location(),\n-\t\t   (\"incompatible type for element %d value \"\n-\t\t    \"in map construction\"),\n+\t  go_error_at((*pv)->location(),\n+                      (\"incompatible type for element %d value \"\n+                       \"in map construction\"),\n \t\t   i + 1);\n \t  this->set_is_error();\n \t}\n@@ -12779,9 +12781,9 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n       else\n \t{\n \t  if (!type->is_error())\n-\t    error_at(this->location(),\n-\t\t     (\"may only omit types within composite literals \"\n-\t\t      \"of slice, array, or map type\"));\n+\t    go_error_at(this->location(),\n+                        (\"may only omit types within composite literals \"\n+                         \"of slice, array, or map type\"));\n \t  return Expression::make_error(this->location());\n \t}\n     }\n@@ -12805,9 +12807,9 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n     ret = this->lower_map(gogo, function, inserter, type);\n   else\n     {\n-      error_at(this->location(),\n-\t       (\"expected struct, slice, array, or map type \"\n-\t\t\"for composite literal\"));\n+      go_error_at(this->location(),\n+                  (\"expected struct, slice, array, or map type \"\n+                   \"for composite literal\"));\n       return Expression::make_error(this->location());\n     }\n \n@@ -12837,10 +12839,10 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \t    {\n \t      if (Gogo::is_hidden_name(pf->field_name())\n \t\t  || pf->is_embedded_builtin(gogo))\n-\t\terror_at(this->location(),\n-\t\t\t \"assignment of unexported field %qs in %qs literal\",\n-\t\t\t Gogo::message_name(pf->field_name()).c_str(),\n-\t\t\t type->named_type()->message_name().c_str());\n+\t\tgo_error_at(this->location(),\n+                            \"assignment of unexported field %qs in %qs literal\",\n+                            Gogo::message_name(pf->field_name()).c_str(),\n+                            type->named_type()->message_name().c_str());\n \t    }\n \t}\n \n@@ -12865,7 +12867,8 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \n       if (name_expr == NULL)\n \t{\n-\t  error_at(val->location(), \"mixture of field and value initializers\");\n+\t  go_error_at(val->location(),\n+                      \"mixture of field and value initializers\");\n \t  return Expression::make_error(location);\n \t}\n \n@@ -12921,7 +12924,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \t}\n       if (bad_key)\n \t{\n-\t  error_at(name_expr->location(), \"expected struct field name\");\n+\t  go_error_at(name_expr->location(), \"expected struct field name\");\n \t  return Expression::make_error(location);\n \t}\n \n@@ -12952,32 +12955,32 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n       const Struct_field* sf = st->find_local_field(name, &index);\n       if (sf == NULL)\n \t{\n-\t  error_at(name_expr->location(), \"unknown field %qs in %qs\",\n-\t\t   Gogo::message_name(name).c_str(),\n-\t\t   (type->named_type() != NULL\n-\t\t    ? type->named_type()->message_name().c_str()\n-\t\t    : \"unnamed struct\"));\n+\t  go_error_at(name_expr->location(), \"unknown field %qs in %qs\",\n+                      Gogo::message_name(name).c_str(),\n+                      (type->named_type() != NULL\n+                       ? type->named_type()->message_name().c_str()\n+                       : \"unnamed struct\"));\n \t  return Expression::make_error(location);\n \t}\n       if (vals[index] != NULL)\n \t{\n-\t  error_at(name_expr->location(),\n-\t\t   \"duplicate value for field %qs in %qs\",\n-\t\t   Gogo::message_name(name).c_str(),\n-\t\t   (type->named_type() != NULL\n-\t\t    ? type->named_type()->message_name().c_str()\n-\t\t    : \"unnamed struct\"));\n+\t  go_error_at(name_expr->location(),\n+                      \"duplicate value for field %qs in %qs\",\n+                      Gogo::message_name(name).c_str(),\n+                      (type->named_type() != NULL\n+                       ? type->named_type()->message_name().c_str()\n+                       : \"unnamed struct\"));\n \t  return Expression::make_error(location);\n \t}\n \n       if (type->named_type() != NULL\n \t  && type->named_type()->named_object()->package() != NULL\n \t  && (Gogo::is_hidden_name(sf->field_name())\n \t      || sf->is_embedded_builtin(gogo)))\n-\terror_at(name_expr->location(),\n-\t\t \"assignment of unexported field %qs in %qs literal\",\n-\t\t Gogo::message_name(sf->field_name()).c_str(),\n-\t\t type->named_type()->message_name().c_str());\n+\tgo_error_at(name_expr->location(),\n+                    \"assignment of unexported field %qs in %qs literal\",\n+                    Gogo::message_name(sf->field_name()).c_str(),\n+                    type->named_type()->message_name().c_str());\n \n       vals[index] = val;\n       traverse_order->push_back(index);\n@@ -12987,16 +12990,16 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n     {\n       // This is a weird case like bug462 in the testsuite.\n       if (external_expr == NULL)\n-\terror_at(this->location(), \"unknown field in %qs literal\",\n-\t\t (type->named_type() != NULL\n-\t\t  ? type->named_type()->message_name().c_str()\n-\t\t  : \"unnamed struct\"));\n+\tgo_error_at(this->location(), \"unknown field in %qs literal\",\n+                    (type->named_type() != NULL\n+                     ? type->named_type()->message_name().c_str()\n+                     : \"unnamed struct\"));\n       else\n-\terror_at(external_expr->location(), \"unknown field %qs in %qs\",\n-\t\t external_no->message_name().c_str(),\n-\t\t (type->named_type() != NULL\n-\t\t  ? type->named_type()->message_name().c_str()\n-\t\t  : \"unnamed struct\"));\n+\tgo_error_at(external_expr->location(), \"unknown field %qs in %qs\",\n+                    external_no->message_name().c_str(),\n+                    (type->named_type() != NULL\n+                     ? type->named_type()->message_name().c_str()\n+                     : \"unnamed struct\"));\n       return Expression::make_error(location);\n     }\n \n@@ -13064,8 +13067,8 @@ Composite_literal_expression::lower_array(Type* type)\n \t  Numeric_constant nc;\n \t  if (!index_expr->numeric_constant_value(&nc))\n \t    {\n-\t      error_at(index_expr->location(),\n-\t\t       \"index expression is not integer constant\");\n+\t      go_error_at(index_expr->location(),\n+                          \"index expression is not integer constant\");\n \t      return Expression::make_error(location);\n \t    }\n \n@@ -13074,14 +13077,15 @@ Composite_literal_expression::lower_array(Type* type)\n \t    case Numeric_constant::NC_UL_VALID:\n \t      break;\n \t    case Numeric_constant::NC_UL_NOTINT:\n-\t      error_at(index_expr->location(),\n-\t\t       \"index expression is not integer constant\");\n+\t      go_error_at(index_expr->location(),\n+                          \"index expression is not integer constant\");\n \t      return Expression::make_error(location);\n \t    case Numeric_constant::NC_UL_NEGATIVE:\n-\t      error_at(index_expr->location(), \"index expression is negative\");\n+\t      go_error_at(index_expr->location(),\n+                          \"index expression is negative\");\n \t      return Expression::make_error(location);\n \t    case Numeric_constant::NC_UL_BIG:\n-\t      error_at(index_expr->location(), \"index value overflow\");\n+\t      go_error_at(index_expr->location(), \"index value overflow\");\n \t      return Expression::make_error(location);\n \t    default:\n \t      go_unreachable();\n@@ -13092,15 +13096,16 @@ Composite_literal_expression::lower_array(Type* type)\n \t  if (sizeof(index) <= static_cast<size_t>(inttype->bits() * 8)\n \t      && index >> (inttype->bits() - 1) != 0)\n \t    {\n-\t      error_at(index_expr->location(), \"index value overflow\");\n+\t      go_error_at(index_expr->location(), \"index value overflow\");\n \t      return Expression::make_error(location);\n \t    }\n \n \t  if (std::find(indexes->begin(), indexes->end(), index)\n \t      != indexes->end())\n \t    {\n-\t      error_at(index_expr->location(), \"duplicate value for index %lu\",\n-\t\t       index);\n+\t      go_error_at(index_expr->location(),\n+                          \"duplicate value for index %lu\",\n+                          index);\n \t      return Expression::make_error(location);\n \t    }\n \n@@ -13178,7 +13183,7 @@ Composite_literal_expression::make_array(\n \t  if (sizeof(size) <= static_cast<size_t>(it->bits() * 8)\n \t      && size >> (it->bits() - 1) != 0)\n \t    {\n-\t      error_at(location, \"too many elements in composite literal\");\n+\t      go_error_at(location, \"too many elements in composite literal\");\n \t      return Expression::make_error(location);\n \t    }\n \t}\n@@ -13200,7 +13205,8 @@ Composite_literal_expression::make_array(\n \t    {\n \t      if (this->vals_->size() > val)\n \t\t{\n-\t\t  error_at(location, \"too many elements in composite literal\");\n+\t\t  go_error_at(location,\n+                              \"too many elements in composite literal\");\n \t\t  return Expression::make_error(location);\n \t\t}\n \t    }\n@@ -13209,9 +13215,9 @@ Composite_literal_expression::make_array(\n \t      unsigned long max = indexes->back();\n \t      if (max >= val)\n \t\t{\n-\t\t  error_at(location,\n-\t\t\t   (\"some element keys in composite literal \"\n-\t\t\t    \"are out of range\"));\n+\t\t  go_error_at(location,\n+                              (\"some element keys in composite literal \"\n+                               \"are out of range\"));\n \t\t  return Expression::make_error(location);\n \t\t}\n \t    }\n@@ -13237,7 +13243,7 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n     {\n       if (!this->has_keys_)\n \t{\n-\t  error_at(location, \"map composite literal must have keys\");\n+\t  go_error_at(location, \"map composite literal must have keys\");\n \t  return Expression::make_error(location);\n \t}\n \n@@ -13248,8 +13254,9 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t  if (*p == NULL)\n \t    {\n \t      ++p;\n-\t      error_at((*p)->location(),\n-\t\t       \"map composite literal must have keys for every value\");\n+\t      go_error_at((*p)->location(),\n+                          (\"map composite literal must \"\n+                           \"have keys for every value\"));\n \t      return Expression::make_error(location);\n \t    }\n \t  // Make sure we have lowered the key; it may not have been\n@@ -13434,10 +13441,10 @@ Type_guard_expression::do_check_types(Gogo*)\n \t\tthis->report_error(_(\"impossible type assertion: \"\n \t\t\t\t     \"type does not implement interface\"));\n \t      else\n-\t\terror_at(this->location(),\n-\t\t\t (\"impossible type assertion: \"\n-\t\t\t  \"type does not implement interface (%s)\"),\n-\t\t\t reason.c_str());\n+\t\tgo_error_at(this->location(),\n+                            (\"impossible type assertion: \"\n+                             \"type does not implement interface (%s)\"),\n+                            reason.c_str());\n \t    }\n \t  this->set_is_error();\n \t}\n@@ -14873,7 +14880,7 @@ Expression::import_expression(Import* imp)\n     return Type_conversion_expression::do_import(imp);\n   else\n     {\n-      error_at(imp->location(), \"import error: expected expression\");\n+      go_error_at(imp->location(), \"import error: expected expression\");\n       return Expression::make_error(imp->location());\n     }\n }\n@@ -15313,8 +15320,8 @@ Numeric_constant::check_int_type(Integer_type* type, bool issue_error,\n \t{\n \t  if (issue_error)\n             {\n-              error_at(location,\n-                       \"floating point constant truncated to integer\");\n+              go_error_at(location,\n+                          \"floating point constant truncated to integer\");\n               this->set_invalid();\n             }\n \t  return false;\n@@ -15329,7 +15336,7 @@ Numeric_constant::check_int_type(Integer_type* type, bool issue_error,\n \t{\n \t  if (issue_error)\n             {\n-              error_at(location, \"complex constant truncated to integer\");\n+              go_error_at(location, \"complex constant truncated to integer\");\n               this->set_invalid();\n             }\n \t  return false;\n@@ -15370,7 +15377,7 @@ Numeric_constant::check_int_type(Integer_type* type, bool issue_error,\n \n   if (!ret && issue_error)\n     {\n-      error_at(location, \"integer constant overflow\");\n+      go_error_at(location, \"integer constant overflow\");\n       this->set_invalid();\n     }\n \n@@ -15402,7 +15409,7 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n \t  if (issue_error)\n             {\n               this->set_invalid();\n-              error_at(location, \"complex constant truncated to float\");\n+              go_error_at(location, \"complex constant truncated to float\");\n             }\n \t  return false;\n \t}\n@@ -15467,7 +15474,7 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n \n   if (!ret && issue_error)\n     {\n-      error_at(location, \"floating point constant overflow\");\n+      go_error_at(location, \"floating point constant overflow\");\n       this->set_invalid();\n     }\n \n@@ -15525,7 +15532,7 @@ Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n     {\n       if (issue_error)\n         {\n-          error_at(location, \"complex real part overflow\");\n+          go_error_at(location, \"complex real part overflow\");\n           this->set_invalid();\n         }\n       ret = false;\n@@ -15538,7 +15545,7 @@ Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n     {\n       if (issue_error)\n         {\n-          error_at(location, \"complex imaginary part overflow\");\n+          go_error_at(location, \"complex imaginary part overflow\");\n           this->set_invalid();\n         }\n       ret = false;"}, {"sha": "21e45b3af37e2360b1e4d29b40dd74a7c9cff687", "filename": "gcc/go/gofrontend/go-diagnostics.cc", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -0,0 +1,177 @@\n+// go-diagnostics.cc -- Go error/warning diagnostics utilities.\n+\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-diagnostics.h\"\n+\n+static std::string\n+mformat_value()\n+{\n+  return std::string(xstrerror(errno));\n+}\n+\n+// Rewrite a format string to expand any extensions not\n+// supported by sprintf(). See comments in go-diagnostics.h\n+// for list of supported format specifiers.\n+\n+static std::string\n+expand_format(const char* fmt)\n+{\n+  std::stringstream ss;\n+  for (const char* c = fmt; *c; ++c)\n+    {\n+      if (*c != '%')\n+        {\n+          ss << *c;\n+          continue;\n+        }\n+      c++;\n+      switch (*c)\n+        {\n+          case '\\0':\n+            {\n+              // malformed format string\n+              go_unreachable();\n+            }\n+          case '%':\n+            {\n+              ss << \"%\";\n+              break;\n+            }\n+          case 'm':\n+            {\n+              ss << mformat_value();\n+              break;\n+            }\n+          case '<':\n+            {\n+              ss << go_open_quote();\n+              break;\n+            }\n+          case '>':\n+            {\n+              ss << go_close_quote();\n+              break;\n+            }\n+          case 'q':\n+            {\n+              ss << go_open_quote();\n+              c++;\n+              if (*c == 'm')\n+                {\n+                  ss << mformat_value();\n+                }\n+              else\n+                {\n+                  ss << \"%\" << *c;\n+                }\n+              ss << go_close_quote();\n+              break;\n+            }\n+          default:\n+            {\n+              ss << \"%\" << *c;\n+            }\n+        }\n+    }\n+  return ss.str();\n+}\n+\n+// Expand message format specifiers, using a combination of\n+// expand_format above to handle extensions (ex: %m, %q) and vasprintf()\n+// to handle regular printf-style formatting. A pragma is being used here to\n+// suppress this warning:\n+//\n+//   warning: function \u2018std::__cxx11::string expand_message(const char*, __va_list_tag*)\u2019 might be a candidate for \u2018gnu_printf\u2019 format attribute [-Wsuggest-attribute=format]\n+//\n+// What appears to be happening here is that the checker is deciding that\n+// because of the call to vasprintf() (which has attribute gnu_printf), the\n+// calling function must need to have attribute gnu_printf as well, even\n+// though there is already an attribute declaration for it.\n+\n+static std::string\n+expand_message(const char* fmt, va_list ap) GO_ATTRIBUTE_GCC_DIAG(1,0);\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n+\n+static std::string\n+expand_message(const char* fmt, va_list ap)\n+{\n+  char* mbuf = 0;\n+  std::string expanded_fmt = expand_format(fmt);\n+  int nwr = vasprintf(&mbuf, expanded_fmt.c_str(), ap);\n+  if (nwr == -1)\n+    {\n+      // memory allocation failed\n+      go_be_error_at(Linemap::unknown_location(),\n+                     \"memory allocation failed in vasprintf\");\n+      go_assert(0);\n+    }\n+  std::string rval = std::string(mbuf);\n+  free(mbuf);\n+  return rval;\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+static const char* cached_open_quote = NULL;\n+static const char* cached_close_quote = NULL;\n+\n+const char*\n+go_open_quote()\n+{\n+  if (cached_open_quote == NULL)\n+    go_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+  return cached_open_quote;\n+}\n+\n+const char*\n+go_close_quote()\n+{\n+  if (cached_close_quote == NULL)\n+    go_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+  return cached_close_quote;\n+}\n+\n+void\n+go_error_at(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  go_be_error_at(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+go_warning_at(const Location location, int opt, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  go_be_warning_at(location, opt, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+go_fatal_error(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  go_be_fatal_error(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+go_inform(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  go_be_inform(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}"}, {"sha": "70c97cbf8c057f0dc994a3603442900055c21119", "filename": "gcc/go/gofrontend/go-diagnostics.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -0,0 +1,64 @@\n+// go-diagnostics.h -- interface to diagnostic reporting   -*- C++ -*-\n+\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_DIAGNOSTICS_H\n+#define GO_DIAGNOSTICS_H\n+\n+#include \"go-linemap.h\"\n+\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)\n+#define GO_ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (__gcc_tdiag__, m, n))) __attribute__ ((__nonnull__ (m)))\n+#else\n+#define GO_ATTRIBUTE_GCC_DIAG(m,  n)\n+#endif\n+\n+// These declarations define the interface through which the frontend\n+// reports errors and warnings. These functions accept printf-like\n+// format specifiers (e.g. %d, %f, %s, etc), with the following additional\n+// extensions:\n+//\n+//  1.  'q' qualifier may be applied to a specifier to add quoting, e.g.\n+//      %qd produces a quoted decimal output, %qs a quoted string output.\n+//      [This extension is supported only with single-character format\n+//      specifiers].\n+//\n+//  2.  %m specifier outputs value of \"strerror(errno)\" at time of call.\n+//\n+//  3.  %< outputs an opening quote, %> a closing quote.\n+//\n+// All other format specifiers are as defined by 'sprintf'. The final resulting\n+// message is then sent to the back end via go_be_error_at/go_be_warning_at.\n+\n+extern void go_error_at(const Location, const char* fmt, ...)\n+    GO_ATTRIBUTE_GCC_DIAG(2,3);\n+extern void go_warning_at(const Location, int opt, const char* fmt, ...)\n+    GO_ATTRIBUTE_GCC_DIAG(3,4);\n+extern void go_fatal_error(const Location, const char* fmt, ...)\n+    GO_ATTRIBUTE_GCC_DIAG(2,3);\n+extern void go_inform(const Location, const char* fmt, ...)\n+    GO_ATTRIBUTE_GCC_DIAG(2,3);\n+\n+// These interfaces provide a way for the front end to ask for\n+// the open/close quote characters it should use when formatting\n+// diagnostics (warnings, errors).\n+extern const char* go_open_quote();\n+extern const char* go_close_quote();\n+\n+// These interfaces are used by utilities above to pass warnings and\n+// errors (once format specifiers have been expanded) to the back end,\n+// and to determine quoting style. Avoid calling these routines directly;\n+// instead use the equivalent routines above. The back end is required to\n+// implement these routines.\n+\n+extern void go_be_error_at(const Location, const std::string& errmsg);\n+extern void go_be_warning_at(const Location, int opt,\n+                             const std::string& warningmsg);\n+extern void go_be_fatal_error(const Location, const std::string& errmsg);\n+extern void go_be_inform(const Location, const std::string& infomsg);\n+extern void go_be_get_quotechars(const char** open_quote,\n+                                 const char** close_quote);\n+\n+#endif // !defined(GO_DIAGNOSTICS_H)"}, {"sha": "927f29d81330324e128824ca7402a50648290b8d", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -7,6 +7,7 @@\n #include \"go-system.h\"\n \n #include \"go-c.h\"\n+#include \"go-diagnostics.h\"\n \n #include \"lex.h\"\n #include \"parse.h\"\n@@ -68,8 +69,8 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t{\n \t  file = fopen(filename, \"r\");\n \t  if (file == NULL)\n-\t    fatal_error(Linemap::unknown_location(),\n-\t\t\t\"cannot open %s: %m\", filename);\n+\t    go_fatal_error(Linemap::unknown_location(),\n+\t\t\t   \"cannot open %s: %m\", filename);\n \t}\n \n       Lex lexer(filename, file, ::gogo->linemap());\n@@ -88,9 +89,9 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t      for (Lex::Linknames::const_iterator p = linknames->begin();\n \t\t   p != linknames->end();\n \t\t   ++p)\n-\t\terror_at(p->second.loc,\n-\t\t\t (\"//go:linkname only allowed in Go files that \"\n-\t\t\t  \"import \\\"unsafe\\\"\"));\n+\t\tgo_error_at(p->second.loc,\n+\t\t\t    (\"//go:linkname only allowed in Go files that \"\n+\t\t\t     \"import \\\"unsafe\\\"\"));\n \t    }\n \t  all_linknames.insert(linknames->begin(), linknames->end());\n \t}"}, {"sha": "7617815c98bbc11b7dcdccf8d85948d34a6ca86d", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 132, "deletions": 119, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -11,6 +11,7 @@\n #include \"filenames.h\"\n \n #include \"go-c.h\"\n+#include \"go-diagnostics.h\"\n #include \"go-dump.h\"\n #include \"go-optimize.h\"\n #include \"lex.h\"\n@@ -333,8 +334,8 @@ Gogo::set_package_name(const std::string& package_name,\n   if (this->package_ != NULL)\n     {\n       if (this->package_->package_name() != package_name)\n-\terror_at(location, \"expected package %<%s%>\",\n-\t\t Gogo::message_name(this->package_->package_name()).c_str());\n+\tgo_error_at(location, \"expected package %<%s%>\",\n+\t\t    Gogo::message_name(this->package_->package_name()).c_str());\n       return;\n     }\n \n@@ -397,7 +398,7 @@ Gogo::import_package(const std::string& filename,\n {\n   if (filename.empty())\n     {\n-      error_at(location, \"import path is empty\");\n+      go_error_at(location, \"import path is empty\");\n       return;\n     }\n \n@@ -409,45 +410,46 @@ Gogo::import_package(const std::string& filename,\n       int adv = Lex::fetch_char(pf, &c);\n       if (adv == 0)\n \t{\n-\t  error_at(location, \"import path contains invalid UTF-8 sequence\");\n+\t  go_error_at(location, \"import path contains invalid UTF-8 sequence\");\n \t  return;\n \t}\n       if (c == '\\0')\n \t{\n-\t  error_at(location, \"import path contains NUL\");\n+\t  go_error_at(location, \"import path contains NUL\");\n \t  return;\n \t}\n       if (c < 0x20 || c == 0x7f)\n \t{\n-\t  error_at(location, \"import path contains control character\");\n+\t  go_error_at(location, \"import path contains control character\");\n \t  return;\n \t}\n       if (c == '\\\\')\n \t{\n-\t  error_at(location, \"import path contains backslash; use slash\");\n+\t  go_error_at(location, \"import path contains backslash; use slash\");\n \t  return;\n \t}\n       if (Lex::is_unicode_space(c))\n \t{\n-\t  error_at(location, \"import path contains space character\");\n+\t  go_error_at(location, \"import path contains space character\");\n \t  return;\n \t}\n       if (c < 0x7f && strchr(\"!\\\"#$%&'()*,:;<=>?[]^`{|}\", c) != NULL)\n \t{\n-\t  error_at(location, \"import path contains invalid character '%c'\", c);\n+\t  go_error_at(location,\n+                      \"import path contains invalid character '%c'\", c);\n \t  return;\n \t}\n       pf += adv;\n     }\n \n   if (IS_ABSOLUTE_PATH(filename.c_str()))\n     {\n-      error_at(location, \"import path cannot be absolute path\");\n+      go_error_at(location, \"import path cannot be absolute path\");\n       return;\n     }\n \n   if (local_name == \"init\")\n-    error_at(location, \"cannot import package as init\");\n+    go_error_at(location, \"cannot import package as init\");\n \n   if (filename == \"unsafe\")\n     {\n@@ -495,7 +497,7 @@ Gogo::import_package(const std::string& filename,\n \t\t\t\t\t\tthis->relative_import_path_);\n   if (stream == NULL)\n     {\n-      error_at(location, \"import file %qs not found\", filename.c_str());\n+      go_error_at(location, \"import file %qs not found\", filename.c_str());\n       return;\n     }\n \n@@ -505,9 +507,9 @@ Gogo::import_package(const std::string& filename,\n   if (package != NULL)\n     {\n       if (package->pkgpath() == this->pkgpath())\n-\terror_at(location,\n-\t\t (\"imported package uses same package path as package \"\n-\t\t  \"being compiled (see -fgo-pkgpath option)\"));\n+\tgo_error_at(location,\n+\t\t    (\"imported package uses same package path as package \"\n+\t\t     \"being compiled (see -fgo-pkgpath option)\"));\n \n       this->imports_.insert(std::make_pair(filename, package));\n     }\n@@ -544,12 +546,13 @@ Gogo::add_import_init_fn(const std::string& package_name,\n \t  // an error about it.\n \t  if (ii->package_name() != package_name)\n \t    {\n-\t      error(\"duplicate package initialization name %qs\",\n-\t\t    Gogo::message_name(init_name).c_str());\n-\t      inform(UNKNOWN_LOCATION, \"used by package %qs\",\n-\t\t     Gogo::message_name(ii->package_name()).c_str());\n-\t      inform(UNKNOWN_LOCATION, \" and by package %qs\",\n-\t\t     Gogo::message_name(package_name).c_str());\n+\t      go_error_at(Linemap::unknown_location(),\n+\t\t       \"duplicate package initialization name %qs\",\n+\t\t       Gogo::message_name(init_name).c_str());\n+\t      go_inform(Linemap::unknown_location(), \"used by package %qs\",\n+\t\t\tGogo::message_name(ii->package_name()).c_str());\n+\t      go_inform(Linemap::unknown_location(), \" and by package %qs\",\n+\t\t\tGogo::message_name(package_name).c_str());\n \t    }\n           ii->set_priority(prio);\n           return;\n@@ -1126,13 +1129,13 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n \t\t\t\t      var);\n \t      if (ins.first->second)\n \t\t{\n-\t\t  error_at(var->location(),\n-\t\t\t   (\"initialization expressions for %qs and \"\n-\t\t\t    \"%qs depend upon each other\"),\n-\t\t\t   var->message_name().c_str(),\n-\t\t\t   p2var->message_name().c_str());\n-\t\t  inform(p2->var()->location(), \"%qs defined here\",\n-\t\t\t p2var->message_name().c_str());\n+\t\t  go_error_at(var->location(),\n+\t\t\t      (\"initialization expressions for %qs and \"\n+\t\t\t       \"%qs depend upon each other\"),\n+\t\t\t      var->message_name().c_str(),\n+\t\t\t      p2var->message_name().c_str());\n+\t\t  go_inform(p2->var()->location(), \"%qs defined here\",\n+\t\t\t    p2var->message_name().c_str());\n \t\t  init_loop = true;\n \t\t  break;\n \t\t}\n@@ -1192,9 +1195,9 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n       Named_object* dep = gogo->var_depends_on(var->var_value());\n       if (init != NULL && dep == NULL\n \t  && expression_requires(init, preinit, NULL, var))\n-\terror_at(var->location(),\n-\t\t \"initialization expression for %qs depends upon itself\",\n-\t\t var->message_name().c_str());\n+\tgo_error_at(var->location(),\n+\t\t    \"initialization expression for %qs depends upon itself\",\n+\t\t    var->message_name().c_str());\n     }\n }\n \n@@ -1322,10 +1325,10 @@ Gogo::write_globals()\n \t\t{\n \t\t  if (expression_requires(var->init(), NULL,\n \t\t\t\t\t  this->var_depends_on(var), no))\n-\t\t    error_at(no->location(),\n-\t\t\t     \"initialization expression for %qs depends \"\n-\t\t\t     \"upon itself\",\n-\t\t\t     no->message_name().c_str());\n+\t\t    go_error_at(no->location(),\n+\t\t\t\t\"initialization expression for %qs depends \"\n+\t\t\t\t\"upon itself\",\n+\t\t\t\tno->message_name().c_str());\n \t\t  this->backend()->global_variable_set_init(bvar, var_binit);\n \t\t}\n \t      else if (is_sink)\n@@ -1664,8 +1667,8 @@ Gogo::start_function(const std::string& name, Function_type* type,\n     {\n       if ((type->parameters() != NULL && !type->parameters()->empty())\n \t  || (type->results() != NULL && !type->results()->empty()))\n-\terror_at(location,\n-\t\t \"func init must have no arguments and no return values\");\n+\tgo_error_at(location,\n+\t\t    \"func init must have no arguments and no return values\");\n       // There can be multiple \"init\" functions, so give them each a\n       // different name.\n       static int init_count;\n@@ -1761,8 +1764,9 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t    }\n \t  else\n             {\n-              error_at(type->receiver()->location(),\n-                       \"invalid receiver type (receiver must be a named type)\");\n+\t      go_error_at(type->receiver()->location(),\n+\t\t\t  (\"invalid receiver type (receiver must \"\n+\t\t\t   \"be a named type)\"));\n               ret = Named_object::make_function(name, NULL, function);\n             }\n \t}\n@@ -1874,8 +1878,8 @@ Gogo::declare_function(const std::string& name, Function_type* type,\n \t}\n       else\n         {\n-          error_at(type->receiver()->location(),\n-                   \"invalid receiver type (receiver must be a named type)\");\n+\t  go_error_at(type->receiver()->location(),\n+\t\t      \"invalid receiver type (receiver must be a named type)\");\n           return Named_object::make_erroneous_name(name);\n         }\n     }\n@@ -2084,16 +2088,16 @@ Gogo::add_linkname(const std::string& go_name, bool is_exported,\n     this->package_->bindings()->lookup(this->pack_hidden_name(go_name,\n \t\t\t\t\t\t\t      is_exported));\n   if (no == NULL)\n-    error_at(loc, \"%s is not defined\", go_name.c_str());\n+    go_error_at(loc, \"%s is not defined\", go_name.c_str());\n   else if (no->is_function())\n     no->func_value()->set_asm_name(ext_name);\n   else if (no->is_function_declaration())\n     no->func_declaration_value()->set_asm_name(ext_name);\n   else\n-    error_at(loc,\n-\t     (\"%s is not a function; \"\n-\t      \"//go:linkname is only supported for functions\"),\n-\t     go_name.c_str());\n+    go_error_at(loc,\n+\t\t(\"%s is not a function; \"\n+\t\t \"//go:linkname is only supported for functions\"),\n+\t\tgo_name.c_str());\n }\n \n // Mark all local variables used.  This is used when some types of\n@@ -2185,13 +2189,13 @@ Gogo::define_global_names()\n \t  if (global_no->is_type())\n \t    {\n \t      if (no->type_declaration_value()->has_methods())\n-\t\terror_at(no->location(),\n-\t\t\t \"may not define methods for global type\");\n+\t\tgo_error_at(no->location(),\n+\t\t\t    \"may not define methods for global type\");\n \t      no->set_type_value(global_no->type_value());\n \t    }\n \t  else\n \t    {\n-\t      error_at(no->location(), \"expected type\");\n+\t      go_error_at(no->location(), \"expected type\");\n \t      Type* errtype = Type::make_error_type();\n \t      Named_object* err =\n                 Named_object::make_type(\"erroneous_type\", NULL, errtype,\n@@ -2223,18 +2227,18 @@ Gogo::define_global_names()\n       if (pf != this->file_block_names_.end())\n \t{\n \t  std::string n = p->second->message_name();\n-\t  error_at(p->second->location(),\n-\t\t   \"%qs defined as both imported name and global name\",\n-\t\t   n.c_str());\n-\t  inform(pf->second, \"%qs imported here\", n.c_str());\n+\t  go_error_at(p->second->location(),\n+\t\t      \"%qs defined as both imported name and global name\",\n+\t\t      n.c_str());\n+\t  go_inform(pf->second, \"%qs imported here\", n.c_str());\n \t}\n \n       // No package scope identifier may be named \"init\".\n       if (!p->second->is_function()\n \t  && Gogo::unpack_hidden_name(p->second->name()) == \"init\")\n \t{\n-\t  error_at(p->second->location(),\n-\t           \"cannot declare init - must be func\");\n+\t  go_error_at(p->second->location(),\n+\t\t      \"cannot declare init - must be func\");\n \t}\n     }\n }\n@@ -2265,15 +2269,15 @@ Gogo::clear_file_scope()\n                   std::string pkg_name = package->package_name();\n                   if (p1->first != pkg_name && p1->first[0] != '.')\n                     {\n-                      error_at(p1->second->location(),\n-                               \"imported and not used: %s as %s\",\n-                               Gogo::message_name(pkg_name).c_str(),\n-                               Gogo::message_name(p1->first).c_str());\n+\t\t      go_error_at(p1->second->location(),\n+\t\t\t\t  \"imported and not used: %s as %s\",\n+\t\t\t\t  Gogo::message_name(pkg_name).c_str(),\n+\t\t\t\t  Gogo::message_name(p1->first).c_str());\n                     }\n                   else\n-                    error_at(p1->second->location(),\n-                             \"imported and not used: %s\",\n-                             Gogo::message_name(pkg_name).c_str());\n+\t\t    go_error_at(p1->second->location(),\n+\t\t\t\t\"imported and not used: %s\",\n+\t\t\t\tGogo::message_name(pkg_name).c_str());\n                 }\n             }\n         }\n@@ -3078,11 +3082,11 @@ Check_types_traverse::variable(Named_object* named_object)\n \t  && !Type::are_assignable(var->type(), init->type(), &reason))\n \t{\n \t  if (reason.empty())\n-\t    error_at(var->location(), \"incompatible type in initialization\");\n+\t    go_error_at(var->location(), \"incompatible type in initialization\");\n \t  else\n-\t    error_at(var->location(),\n-\t\t     \"incompatible type in initialization (%s)\",\n-\t\t     reason.c_str());\n+\t    go_error_at(var->location(),\n+\t\t\t\"incompatible type in initialization (%s)\",\n+\t\t\treason.c_str());\n           init = Expression::make_error(named_object->location());\n \t  var->clear_init();\n \t}\n@@ -3102,10 +3106,10 @@ Check_types_traverse::variable(Named_object* named_object)\n           // initialization.\n           if (fntype->is_builtin())\n             {\n-              error_at(init->location(),\n-                       \"invalid use of special builtin function %qs; \"\n-                       \"must be called\",\n-                       no->message_name().c_str());\n+\t      go_error_at(init->location(),\n+\t\t\t  \"invalid use of special builtin function %qs; \"\n+\t\t\t  \"must be called\",\n+\t\t\t  no->message_name().c_str());\n             }\n         }\n       if (!var->is_used()\n@@ -3115,8 +3119,8 @@ Check_types_traverse::variable(Named_object* named_object)\n           && !var->type()->is_error()\n           && (init == NULL || !init->is_error_expression())\n           && !Lex::is_invalid_identifier(named_object->name()))\n-\terror_at(var->location(), \"%qs declared and not used\",\n-\t\t named_object->message_name().c_str());\n+\tgo_error_at(var->location(), \"%qs declared and not used\",\n+\t\t    named_object->message_name().c_str());\n     }\n   return TRAVERSE_CONTINUE;\n }\n@@ -3135,21 +3139,21 @@ Check_types_traverse::constant(Named_object* named_object, bool)\n       && !ctype->is_string_type())\n     {\n       if (ctype->is_nil_type())\n-\terror_at(constant->location(), \"const initializer cannot be nil\");\n+\tgo_error_at(constant->location(), \"const initializer cannot be nil\");\n       else if (!ctype->is_error())\n-\terror_at(constant->location(), \"invalid constant type\");\n+\tgo_error_at(constant->location(), \"invalid constant type\");\n       constant->set_error();\n     }\n   else if (!constant->expr()->is_constant())\n     {\n-      error_at(constant->expr()->location(), \"expression is not constant\");\n+      go_error_at(constant->expr()->location(), \"expression is not constant\");\n       constant->set_error();\n     }\n   else if (!Type::are_assignable(constant->type(), constant->expr()->type(),\n \t\t\t\t NULL))\n     {\n-      error_at(constant->location(),\n-\t       \"initialization expression has wrong type\");\n+      go_error_at(constant->location(),\n+                  \"initialization expression has wrong type\");\n       constant->set_error();\n     }\n   return TRAVERSE_CONTINUE;\n@@ -4389,8 +4393,8 @@ Check_return_statements_traverse::function(Named_object* no)\n     return TRAVERSE_CONTINUE;\n \n   if (func->block()->may_fall_through())\n-    error_at(func->block()->end_location(),\n-\t     \"missing return at end of function\");\n+    go_error_at(func->block()->end_location(),\n+\t\t\"missing return at end of function\");\n \n   return TRAVERSE_CONTINUE;\n }\n@@ -4454,7 +4458,8 @@ Gogo::write_c_header()\n   out.open(this->c_header_.c_str());\n   if (out.fail())\n     {\n-      error(\"cannot open %s: %m\", this->c_header_.c_str());\n+      go_error_at(Linemap::unknown_location(),\n+\t\t  \"cannot open %s: %m\", this->c_header_.c_str());\n       return;\n     }\n \n@@ -4562,7 +4567,8 @@ Gogo::write_c_header()\n \n   out.close();\n   if (out.fail())\n-    error(\"error writing to %s: %m\", this->c_header_.c_str());\n+    go_error_at(Linemap::unknown_location(),\n+\t\t\"error writing to %s: %m\", this->c_header_.c_str());\n }\n \n // Find the blocks in order to convert named types defined in blocks.\n@@ -4836,10 +4842,10 @@ Function::add_label_definition(Gogo* gogo, const std::string& label_name,\n       label = ins.first->second;\n       if (label->is_defined())\n \t{\n-\t  error_at(location, \"label %qs already defined\",\n-\t\t   Gogo::message_name(label_name).c_str());\n-\t  inform(label->location(), \"previous definition of %qs was here\",\n-\t\t Gogo::message_name(label_name).c_str());\n+\t  go_error_at(location, \"label %qs already defined\",\n+\t\t      Gogo::message_name(label_name).c_str());\n+\t  go_inform(label->location(), \"previous definition of %qs was here\",\n+\t\t    Gogo::message_name(label_name).c_str());\n \t  return new Label(label_name);\n \t}\n     }\n@@ -4905,8 +4911,8 @@ Function::check_labels() const\n     {\n       Label* label = p->second;\n       if (!label->is_used())\n-\terror_at(label->location(), \"label %qs defined and not used\",\n-\t\t Gogo::message_name(label->name()).c_str());\n+\tgo_error_at(label->location(), \"label %qs defined and not used\",\n+\t\t    Gogo::message_name(label->name()).c_str());\n     }\n }\n \n@@ -5680,7 +5686,7 @@ Block::Block(Block* enclosing, Location location)\n \t\t\t   ? NULL\n \t\t\t   : enclosing->bindings())),\n     start_location_(location),\n-    end_location_(UNKNOWN_LOCATION)\n+    end_location_(Linemap::unknown_location())\n {\n }\n \n@@ -5966,8 +5972,8 @@ Bindings_snapshot::check_goto_block(Location loc, const Block* bfrom,\n     {\n       if (pb == NULL)\n \t{\n-\t  error_at(loc, \"goto jumps into block\");\n-\t  inform(bto->start_location(), \"goto target block starts here\");\n+\t  go_error_at(loc, \"goto jumps into block\");\n+\t  go_inform(bto->start_location(), \"goto target block starts here\");\n \t  return false;\n \t}\n     }\n@@ -5995,8 +6001,8 @@ Bindings_snapshot::check_goto_defs(Location loc, const Block* block,\n       go_assert(p != block->bindings()->end_definitions());\n \n       std::string n = (*p)->message_name();\n-      error_at(loc, \"goto jumps over declaration of %qs\", n.c_str());\n-      inform((*p)->location(), \"%qs defined here\", n.c_str());\n+      go_error_at(loc, \"goto jumps over declaration of %qs\", n.c_str());\n+      go_inform((*p)->location(), \"%qs defined here\", n.c_str());\n     }\n }\n \n@@ -6206,7 +6212,7 @@ Variable::type_from_tuple(Expression* expr, bool report_error) const\n   else\n     {\n       if (report_error)\n-\terror_at(this->location(), \"invalid tuple definition\");\n+\tgo_error_at(this->location(), \"invalid tuple definition\");\n       return Type::make_error_type();\n     }\n }\n@@ -6250,15 +6256,16 @@ Variable::type_from_range(Expression* expr, bool get_index_type,\n       else\n \t{\n \t  if (report_error)\n-\t    error_at(this->location(),\n-\t\t     \"invalid definition of value variable for channel range\");\n+\t    go_error_at(this->location(),\n+\t\t\t(\"invalid definition of value variable \"\n+\t\t\t \"for channel range\"));\n \t  return Type::make_error_type();\n \t}\n     }\n   else\n     {\n       if (report_error)\n-\terror_at(this->location(), \"invalid type for range clause\");\n+\tgo_error_at(this->location(), \"invalid type for range clause\");\n       return Type::make_error_type();\n     }\n }\n@@ -6274,7 +6281,7 @@ Variable::type_from_chan_element(Expression* expr, bool report_error) const\n   else\n     {\n       if (report_error)\n-\terror_at(this->location(), \"expected channel\");\n+\tgo_error_at(this->location(), \"expected channel\");\n       return Type::make_error_type();\n     }\n }\n@@ -6305,7 +6312,7 @@ Variable::type()\n     {\n       if (this->type_ == NULL || !this->type_->is_error_type())\n \t{\n-\t  error_at(this->location_, \"variable initializer refers to itself\");\n+\t  go_error_at(this->location_, \"variable initializer refers to itself\");\n \t  this->type_ = Type::make_error_type();\n \t}\n       return this->type_;\n@@ -6413,17 +6420,17 @@ Variable::determine_type()\n \n \t  if (type->is_void_type())\n \t    {\n-\t      error_at(this->location_, \"variable has no type\");\n+\t      go_error_at(this->location_, \"variable has no type\");\n \t      type = Type::make_error_type();\n \t    }\n \t  else if (type->is_nil_type())\n \t    {\n-\t      error_at(this->location_, \"variable defined to nil type\");\n+\t      go_error_at(this->location_, \"variable defined to nil type\");\n \t      type = Type::make_error_type();\n \t    }\n \t  else if (type->is_call_multiple_result_type())\n \t    {\n-\t      error_at(this->location_,\n+\t      go_error_at(this->location_,\n \t\t       \"single variable set to multiple-value function call\");\n \t      type = Type::make_error_type();\n \t    }\n@@ -7070,9 +7077,9 @@ Named_object::export_named_object(Export* exp) const\n       break;\n \n     case NAMED_OBJECT_TYPE_DECLARATION:\n-      error_at(this->type_declaration_value()->location(),\n-\t       \"attempt to export %<%s%> which was declared but not defined\",\n-\t       this->message_name().c_str());\n+      go_error_at(this->type_declaration_value()->location(),\n+\t\t  \"attempt to export %<%s%> which was declared but not defined\",\n+\t\t  this->message_name().c_str());\n       break;\n \n     case NAMED_OBJECT_FUNC_DECLARATION:\n@@ -7217,8 +7224,9 @@ Named_object::get_backend(Gogo* gogo, std::vector<Bexpression*>& const_decls,\n       break;\n \n     case NAMED_OBJECT_TYPE_DECLARATION:\n-      error(\"reference to undefined type %qs\",\n-\t    this->message_name().c_str());\n+      go_error_at(Linemap::unknown_location(),\n+\t\t  \"reference to undefined type %qs\",\n+\t\t  this->message_name().c_str());\n       return;\n \n     case NAMED_OBJECT_VAR:\n@@ -7450,7 +7458,9 @@ Bindings::new_definition(Named_object* old_object, Named_object* new_object)\n       if (new_object->is_function_declaration())\n \t{\n \t  if (!new_object->func_declaration_value()->asm_name().empty())\n-\t    sorry(\"__asm__ for function definitions\");\n+\t    go_error_at(Linemap::unknown_location(),\n+\t\t\t(\"sorry, not implemented: \"\n+\t\t\t \"__asm__ for function definitions\"));\n \t  Function_type* old_type = old_object->func_value()->type();\n \t  Function_type* new_type =\n \t    new_object->func_declaration_value()->type();\n@@ -7469,7 +7479,9 @@ Bindings::new_definition(Named_object* old_object, Named_object* new_object)\n \t    if (old_type->is_valid_redeclaration(new_type, &reason))\n \t      {\n \t\tif (!old_object->func_declaration_value()->asm_name().empty())\n-\t\t  sorry(\"__asm__ for function definitions\");\n+\t\t  go_error_at(Linemap::unknown_location(),\n+\t\t\t      (\"sorry, not implemented: \"\n+\t\t\t       \"__asm__ for function definitions\"));\n \t\told_object->set_function_value(new_object->func_value());\n \t\tthis->named_objects_.push_back(old_object);\n \t\treturn old_object;\n@@ -7484,15 +7496,15 @@ Bindings::new_definition(Named_object* old_object, Named_object* new_object)\n \n   std::string n = old_object->message_name();\n   if (reason.empty())\n-    error_at(new_object->location(), \"redefinition of %qs\", n.c_str());\n+    go_error_at(new_object->location(), \"redefinition of %qs\", n.c_str());\n   else\n-    error_at(new_object->location(), \"redefinition of %qs: %s\", n.c_str(),\n-\t     reason.c_str());\n+    go_error_at(new_object->location(), \"redefinition of %qs: %s\", n.c_str(),\n+\t\treason.c_str());\n   old_object->set_is_redefinition();\n   new_object->set_is_redefinition();\n \n-  inform(old_object->location(), \"previous definition of %qs was here\",\n-\t n.c_str());\n+  go_inform(old_object->location(), \"previous definition of %qs was here\",\n+            n.c_str());\n \n   return old_object;\n }\n@@ -7798,10 +7810,11 @@ Package::set_package_name(const std::string& package_name, Location location)\n   if (this->package_name_.empty())\n     this->package_name_ = package_name;\n   else if (this->package_name_ != package_name)\n-    error_at(location,\n-\t     \"saw two different packages with the same package path %s: %s, %s\",\n-\t     this->pkgpath_.c_str(), this->package_name_.c_str(),\n-\t     package_name.c_str());\n+    go_error_at(location,\n+\t\t(\"saw two different packages with \"\n+\t\t \"the same package path %s: %s, %s\"),\n+\t\tthis->pkgpath_.c_str(), this->package_name_.c_str(),\n+\t\tpackage_name.c_str());\n }\n \n // Return the pkgpath symbol, which is a prefix for symbols defined in\n@@ -7851,8 +7864,8 @@ Package::forget_usage(Expression* usage) const\n   this->fake_uses_.erase(p);\n \n   if (this->fake_uses_.empty())\n-    error_at(this->location(), \"imported and not used: %s\",\n-             Gogo::message_name(this->package_name()).c_str());\n+    go_error_at(this->location(), \"imported and not used: %s\",\n+\t\tGogo::message_name(this->package_name()).c_str());\n }\n \n // Clear the used field for the next file.  If the only usages of this package"}, {"sha": "18d1fdc24bd84a7fcd68ef00722e792cf4e60943", "filename": "gcc/go/gofrontend/import-archive.cc", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -6,6 +6,7 @@\n \n #include \"go-system.h\"\n \n+#include \"go-diagnostics.h\"\n #include \"import.h\"\n \n #ifndef O_BINARY\n@@ -144,7 +145,7 @@ Archive_file::initialize()\n   struct stat st;\n   if (fstat(this->fd_, &st) < 0)\n     {\n-      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      go_error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n       return false;\n     }\n   this->filesize_ = st.st_size;\n@@ -153,7 +154,7 @@ Archive_file::initialize()\n   if (::lseek(this->fd_, 0, SEEK_SET) < 0\n       || ::read(this->fd_, buf, sizeof(armagt)) != sizeof(armagt))\n     {\n-      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      go_error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n       return false;\n     }\n   this->is_thin_archive_ = memcmp(buf, armagt, sizeof(armagt)) == 0;\n@@ -183,7 +184,7 @@ Archive_file::initialize()\n       char* rdbuf = new char[size];\n       if (::read(this->fd_, rdbuf, size) != size)\n \t{\n-\t  error_at(this->location_, \"%s: could not read extended names\",\n+\t  go_error_at(this->location_, \"%s: could not read extended names\",\n \t\t   filename.c_str());\n \t  delete[] rdbuf;\n \t  return false;\n@@ -203,7 +204,7 @@ Archive_file::read(off_t offset, off_t size, char* buf)\n   if (::lseek(this->fd_, offset, SEEK_SET) < 0\n       || ::read(this->fd_, buf, size) != size)\n     {\n-      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      go_error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n       return false;\n     }\n   return true;\n@@ -219,20 +220,20 @@ Archive_file::read_header(off_t off, std::string* pname, off_t* size,\n   Archive_header hdr;\n   if (::lseek(this->fd_, off, SEEK_SET) < 0)\n     {\n-      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      go_error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n       return false;\n     }\n   ssize_t got = ::read(this->fd_, &hdr, sizeof hdr);\n   if (got != sizeof hdr)\n     {\n       if (got < 0)\n-\terror_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+\tgo_error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n       else if (got > 0)\n-\terror_at(this->location_, \"%s: short archive header at %ld\",\n-\t\t this->filename_.c_str(), static_cast<long>(off));\n+\tgo_error_at(this->location_, \"%s: short archive header at %ld\",\n+\t\t    this->filename_.c_str(), static_cast<long>(off));\n       else\n-\terror_at(this->location_, \"%s: unexpected EOF at %ld\",\n-\t\t this->filename_.c_str(), static_cast<long>(off));\n+\tgo_error_at(this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t    this->filename_.c_str(), static_cast<long>(off));\n     }\n   off_t local_nested_off;\n   if (!this->interpret_header(&hdr, off, pname, size, &local_nested_off))\n@@ -252,8 +253,8 @@ Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n {\n   if (memcmp(hdr->ar_fmag, arfmag, sizeof arfmag) != 0)\n     {\n-      error_at(this->location_, \"%s: malformed archive header at %lu\",\n-\t       this->filename_.c_str(), static_cast<unsigned long>(off));\n+      go_error_at(this->location_, \"%s: malformed archive header at %lu\",\n+\t\t  this->filename_.c_str(), static_cast<unsigned long>(off));\n       return false;\n     }\n \n@@ -272,8 +273,8 @@ Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n       || *size < 0\n       || (*size == LONG_MAX && errno == ERANGE))\n     {\n-      error_at(this->location_, \"%s: malformed archive header size at %lu\",\n-\t       this->filename_.c_str(), static_cast<unsigned long>(off));\n+      go_error_at(this->location_, \"%s: malformed archive header size at %lu\",\n+\t\t  this->filename_.c_str(), static_cast<unsigned long>(off));\n       return false;\n     }\n \n@@ -284,8 +285,9 @@ Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n       if (name_end == NULL\n \t  || name_end - hdr->ar_name >= static_cast<int>(sizeof hdr->ar_name))\n \t{\n-\t  error_at(this->location_, \"%s: malformed archive header name at %lu\",\n-\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  go_error_at(this->location_,\n+\t\t      \"%s: malformed archive header name at %lu\",\n+\t\t      this->filename_.c_str(), static_cast<unsigned long>(off));\n \t  return false;\n \t}\n       pname->assign(hdr->ar_name, name_end - hdr->ar_name);\n@@ -321,8 +323,8 @@ Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n \t  || (x == LONG_MAX && errno == ERANGE)\n \t  || static_cast<size_t>(x) >= this->extended_names_.size())\n \t{\n-\t  error_at(this->location_, \"%s: bad extended name index at %lu\",\n-\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  go_error_at(this->location_, \"%s: bad extended name index at %lu\",\n+\t\t      this->filename_.c_str(), static_cast<unsigned long>(off));\n \t  return false;\n \t}\n \n@@ -331,8 +333,9 @@ Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n       if (static_cast<size_t>(name_end - name) > this->extended_names_.size()\n \t  || name_end[-1] != '/')\n \t{\n-\t  error_at(this->location_, \"%s: bad extended name entry at header %lu\",\n-\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  go_error_at(this->location_,\n+\t\t      \"%s: bad extended name entry at header %lu\",\n+\t\t      this->filename_.c_str(), static_cast<unsigned long>(off));\n \t  return false;\n \t}\n       pname->assign(name, name_end - 1 - name);\n@@ -380,8 +383,8 @@ Archive_file::get_file_and_offset(off_t off, const std::string& hdrname,\n \t  int nfd = open(filename.c_str(), O_RDONLY | O_BINARY);\n \t  if (nfd < 0)\n \t    {\n-\t      error_at(this->location_, \"%s: can't open nested archive %s\",\n-\t\t       this->filename_.c_str(), filename.c_str());\n+\t      go_error_at(this->location_, \"%s: can't open nested archive %s\",\n+\t\t\t  this->filename_.c_str(), filename.c_str());\n \t      return false;\n \t    }\n \t  nfile = new Archive_file(filename, nfd, this->location_);\n@@ -406,7 +409,7 @@ Archive_file::get_file_and_offset(off_t off, const std::string& hdrname,\n   *memfd = open(filename.c_str(), O_RDONLY | O_BINARY);\n   if (*memfd < 0)\n     {\n-      error_at(this->location_, \"%s: %m\", filename.c_str());\n+      go_error_at(this->location_, \"%s: %m\", filename.c_str());\n       return false;\n     }\n   *memoff = 0;\n@@ -499,10 +502,10 @@ Archive_iterator::read_next_header()\n \t{\n \t  if (filesize != this->off_)\n \t    {\n-\t      error_at(this->afile_->location(),\n-\t\t       \"%s: short archive header at %lu\",\n-\t\t       this->afile_->filename().c_str(),\n-\t\t       static_cast<unsigned long>(this->off_));\n+\t      go_error_at(this->afile_->location(),\n+\t\t\t  \"%s: short archive header at %lu\",\n+\t\t\t  this->afile_->filename().c_str(),\n+\t\t\t  static_cast<unsigned long>(this->off_));\n \t      this->off_ = filesize;\n \t    }\n \t  this->header_.off = filesize;"}, {"sha": "2694cea4797309e2b29e508b3e8182b2e3d3bccf", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -9,6 +9,7 @@\n #include \"filenames.h\"\n \n #include \"go-c.h\"\n+#include \"go-diagnostics.h\"\n #include \"gogo.h\"\n #include \"lex.h\"\n #include \"types.h\"\n@@ -132,7 +133,7 @@ Import::try_package_in_directory(const std::string& filename,\n   if (fd < 0)\n     {\n       if (errno != ENOENT && errno != EISDIR)\n-\twarning_at(location, 0, \"%s: %m\", filename.c_str());\n+\tgo_warning_at(location, 0, \"%s: %m\", filename.c_str());\n \n       fd = Import::try_suffixes(&found_filename);\n       if (fd < 0)\n@@ -146,8 +147,8 @@ Import::try_package_in_directory(const std::string& filename,\n \n   close(fd);\n \n-  error_at(location, \"%s exists but does not contain any Go export data\",\n-\t   found_filename.c_str());\n+  go_error_at(location, \"%s exists but does not contain any Go export data\",\n+\t      found_filename.c_str());\n \n   return NULL;\n }\n@@ -211,7 +212,7 @@ Import::find_export_data(const std::string& filename, int fd, Location location)\n \n   if (lseek(fd, 0, SEEK_SET) < 0)\n     {\n-      error_at(location, \"lseek %s failed: %m\", filename.c_str());\n+      go_error_at(location, \"lseek %s failed: %m\", filename.c_str());\n       return NULL;\n     }\n \n@@ -247,10 +248,10 @@ Import::find_object_export_data(const std::string& filename,\n   if (errmsg != NULL)\n     {\n       if (err == 0)\n-\terror_at(location, \"%s: %s\", filename.c_str(), errmsg);\n+\tgo_error_at(location, \"%s: %s\", filename.c_str(), errmsg);\n       else\n-\terror_at(location, \"%s: %s: %s\", filename.c_str(), errmsg,\n-\t\t xstrerror(err));\n+\tgo_error_at(location, \"%s: %s: %s\", filename.c_str(), errmsg,\n+\t\t    xstrerror(err));\n       return NULL;\n     }\n \n@@ -307,9 +308,9 @@ Import::import(Gogo* gogo, const std::string& local_name,\n \t}\n       else\n \t{\n-\t  error_at(this->location_,\n-\t           (\"error in import data at %d: invalid magic string\"),\n-\t           stream->pos());\n+\t  go_error_at(this->location_,\n+\t\t      (\"error in import data at %d: invalid magic string\"),\n+\t\t      stream->pos());\n \t  return NULL;\n \t}\n \n@@ -382,11 +383,11 @@ Import::import(Gogo* gogo, const std::string& local_name,\n \t    break;\n \t  else\n \t    {\n-\t      error_at(this->location_,\n-\t\t       (\"error in import data at %d: \"\n-\t\t\t\"expected %<const%>, %<type%>, %<var%>, \"\n-\t\t\t\"%<func%>, or %<checksum%>\"),\n-\t\t       stream->pos());\n+\t      go_error_at(this->location_,\n+\t\t\t  (\"error in import data at %d: \"\n+\t\t\t   \"expected %<const%>, %<type%>, %<var%>, \"\n+\t\t\t   \"%<func%>, or %<checksum%>\"),\n+\t\t\t  stream->pos());\n \t      stream->set_saw_error();\n \t      return NULL;\n \t    }\n@@ -664,9 +665,9 @@ Import::read_type()\n \t  : (static_cast<size_t>(index) >= this->types_.size()\n \t     || this->types_[index] == NULL))\n \t{\n-\t  error_at(this->location_,\n-\t\t   \"error in import data at %d: bad type index %d\",\n-\t\t   stream->pos(), index);\n+\t  go_error_at(this->location_,\n+\t\t      \"error in import data at %d: bad type index %d\",\n+\t\t      stream->pos(), index);\n \t  stream->set_saw_error();\n \t  return Type::make_error_type();\n \t}\n@@ -677,9 +678,9 @@ Import::read_type()\n   if (c != ' ')\n     {\n       if (!stream->saw_error())\n-\terror_at(this->location_,\n-\t\t \"error in import data at %d: expect %< %> or %<>%>'\",\n-\t\t stream->pos());\n+\tgo_error_at(this->location_,\n+\t\t    \"error in import data at %d: expect %< %> or %<>%>'\",\n+\t\t    stream->pos());\n       stream->set_saw_error();\n       stream->advance(1);\n       return Type::make_error_type();\n@@ -689,9 +690,9 @@ Import::read_type()\n       || (static_cast<size_t>(index) < this->types_.size()\n \t  && this->types_[index] != NULL))\n     {\n-      error_at(this->location_,\n-\t       \"error in import data at %d: type index already defined\",\n-\t       stream->pos());\n+      go_error_at(this->location_,\n+\t\t  \"error in import data at %d: type index already defined\",\n+\t\t  stream->pos());\n       stream->set_saw_error();\n       return Type::make_error_type();\n     }\n@@ -768,8 +769,8 @@ Import::read_type()\n     no = package->add_type_declaration(type_name, this->location_);\n   else if (!no->is_type_declaration() && !no->is_type())\n     {\n-      error_at(this->location_, \"imported %<%s.%s%> both type and non-type\",\n-\t       pkgpath.c_str(), Gogo::message_name(type_name).c_str());\n+      go_error_at(this->location_, \"imported %<%s.%s%> both type and non-type\",\n+\t\t  pkgpath.c_str(), Gogo::message_name(type_name).c_str());\n       stream->set_saw_error();\n       return Type::make_error_type();\n     }\n@@ -866,9 +867,10 @@ Import::read_escape()\n \n       if (c != '>')\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"error in import data at %d: expect %< %> or %<>%>, got %c\",\n-\t\t   stream->pos(), c);\n+\t  go_error_at(this->location(),\n+\t\t      (\"error in import data at %d: \"\n+\t\t       \"expect %< %> or %<>%>, got %c\"),\n+\t\t      stream->pos(), c);\n \t  stream->set_saw_error();\n \t  stream->advance(1);\n \t  escape = Escape_note::make_tag(Node::ESCAPE_UNKNOWN);\n@@ -961,8 +963,8 @@ Import::string_to_int(const std::string &s, bool is_neg_ok, int* ret)\n   long prio = strtol(s.c_str(), &end, 10);\n   if (*end != '\\0' || prio > 0x7fffffff || (prio < 0 && !is_neg_ok))\n     {\n-      error_at(this->location_, \"invalid integer in import data at %d\",\n-\t       this->stream_->pos());\n+      go_error_at(this->location_, \"invalid integer in import data at %d\",\n+\t\t  this->stream_->pos());\n       this->stream_->set_saw_error();\n       return false;\n     }\n@@ -1018,8 +1020,8 @@ Import::Stream::require_bytes(Location location, const char* bytes,\n       || memcmp(bytes, read, length) != 0)\n     {\n       if (!this->saw_error_)\n-\terror_at(location, \"import error at %d: expected %<%.*s%>\",\n-\t\t this->pos(), static_cast<int>(length), bytes);\n+\tgo_error_at(location, \"import error at %d: expected %<%.*s%>\",\n+\t\t    this->pos(), static_cast<int>(length), bytes);\n       this->saw_error_ = true;\n       return;\n     }\n@@ -1033,7 +1035,7 @@ Stream_from_file::Stream_from_file(int fd)\n {\n   if (lseek(fd, 0, SEEK_SET) != 0)\n     {\n-      error(\"lseek failed: %m\");\n+      go_fatal_error(Linemap::unknown_location(), \"lseek failed: %m\");\n       this->set_saw_error();\n     }\n }\n@@ -1061,15 +1063,15 @@ Stream_from_file::do_peek(size_t length, const char** bytes)\n   if (got < 0)\n     {\n       if (!this->saw_error())\n-\terror(\"read failed: %m\");\n+\tgo_fatal_error(Linemap::unknown_location(), \"read failed: %m\");\n       this->set_saw_error();\n       return false;\n     }\n \n   if (lseek(this->fd_, - got, SEEK_CUR) != 0)\n     {\n       if (!this->saw_error())\n-\terror(\"lseek failed: %m\");\n+\tgo_fatal_error(Linemap::unknown_location(), \"lseek failed: %m\");\n       this->set_saw_error();\n       return false;\n     }\n@@ -1091,7 +1093,7 @@ Stream_from_file::do_advance(size_t skip)\n   if (lseek(this->fd_, skip, SEEK_CUR) != 0)\n     {\n       if (!this->saw_error())\n-\terror(\"lseek failed: %m\");\n+\tgo_fatal_error(Linemap::unknown_location(), \"lseek failed: %m\");\n       this->set_saw_error();\n     }\n   if (!this->data_.empty())"}, {"sha": "b040edde2be68f6d428495935df7f8ae4e9fff5b", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -5,6 +5,7 @@\n // license that can be found in the LICENSE file.\n \n #include \"go-system.h\"\n+#include \"go-diagnostics.h\"\n \n #include \"lex.h\"\n \n@@ -477,7 +478,7 @@ Lex::get_line()\n \t{\n \t  size_t ns = 2 * size + 1;\n \t  if (ns < size || static_cast<ssize_t>(ns) < 0)\n-\t    error_at(this->location(), \"out of memory\");\n+\t    go_error_at(this->location(), \"out of memory\");\n \t  char* nb = new char[ns];\n \t  memcpy(nb, buf, cur);\n \t  delete[] buf;\n@@ -743,9 +744,9 @@ Lex::next_token()\n \t\t  return this->gather_identifier();\n \n \t\tif (!issued_error)\n-\t\t  error_at(this->location(),\n-\t\t\t   \"invalid character 0x%x in input file\",\n-\t\t\t   ci);\n+\t\t  go_error_at(this->location(),\n+\t\t\t      \"invalid character 0x%x in input file\",\n+\t\t\t      ci);\n \n \t\tp = pend;\n \n@@ -834,7 +835,7 @@ Lex::advance_one_utf8_char(const char* p, unsigned int* value,\n \n   if (*p == '\\0')\n     {\n-      error_at(this->location(), \"invalid NUL byte\");\n+      go_error_at(this->location(), \"invalid NUL byte\");\n       *issued_error = true;\n       *value = 0;\n       return p + 1;\n@@ -843,15 +844,15 @@ Lex::advance_one_utf8_char(const char* p, unsigned int* value,\n   int adv = Lex::fetch_char(p, value);\n   if (adv == 0)\n     {\n-      error_at(this->location(), \"invalid UTF-8 encoding\");\n+      go_error_at(this->location(), \"invalid UTF-8 encoding\");\n       *issued_error = true;\n       return p + 1;\n     }\n \n   // Warn about byte order mark, except at start of file.\n   if (*value == 0xfeff && (this->lineno_ != 1 || this->lineoff_ != 0))\n     {\n-      error_at(this->location(), \"Unicode (UTF-8) BOM in middle of file\");\n+      go_error_at(this->location(), \"Unicode (UTF-8) BOM in middle of file\");\n       *issued_error = true;\n     }\n \n@@ -890,9 +891,9 @@ Lex::gather_identifier()\n \t\tbreak;\n \n \t      this->lineoff_ = p - this->linebuf_;\n-\t      error_at(this->location(),\n-\t\t       \"invalid character 0x%x in identifier\",\n-\t\t       cc);\n+\t      go_error_at(this->location(),\n+\t\t\t  \"invalid character 0x%x in identifier\",\n+\t\t\t  cc);\n \t      if (!has_non_ascii_char)\n \t\t{\n \t\t  buf.assign(pstart, p - pstart);\n@@ -925,9 +926,9 @@ Lex::gather_identifier()\n \t      // handling behavior if we swallow this character after\n \t      // giving an error.\n \t      if (!issued_error)\n-\t\terror_at(this->location(),\n-\t\t\t \"invalid character 0x%x in identifier\",\n-\t\t\t ci);\n+\t\tgo_error_at(this->location(),\n+\t\t\t    \"invalid character 0x%x in identifier\",\n+\t\t\t    ci);\n \t      is_invalid = true;\n \t    }\n \t  if (is_first)\n@@ -1109,9 +1110,9 @@ Lex::gather_number()\n           if (r != 0)\n             {\n               if (base == 8)\n-                error_at(this->location(), \"invalid octal literal\");\n+                go_error_at(this->location(), \"invalid octal literal\");\n               else\n-                error_at(this->location(), \"invalid hex literal\");\n+                go_error_at(this->location(), \"invalid hex literal\");\n             }\n \n \t  if (neg)\n@@ -1225,7 +1226,7 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n       if (is_single_quote\n \t  && (*value == '\\'' || *value == '\\n')\n \t  && !issued_error)\n-\terror_at(this->location(), \"invalid character literal\");\n+\tgo_error_at(this->location(), \"invalid character literal\");\n       return ret;\n     }\n   else\n@@ -1244,12 +1245,12 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \t\t\t+ Lex::octal_value(p[2]));\n \t      if (*value > 255)\n \t\t{\n-\t\t  error_at(this->location(), \"invalid octal constant\");\n+\t\t  go_error_at(this->location(), \"invalid octal constant\");\n \t\t  *value = 255;\n \t\t}\n \t      return p + 3;\n \t    }\n-\t      error_at(this->location(), \"invalid octal character\");\n+\t      go_error_at(this->location(), \"invalid octal character\");\n \t  return (p[1] >= '0' && p[1] <= '7'\n \t\t  ? p + 2\n \t\t  : p + 1);\n@@ -1261,7 +1262,7 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \t      *value = (Lex::hex_val(p[1]) << 4) + Lex::hex_val(p[2]);\n \t      return p + 3;\n \t    }\n-\t  error_at(this->location(), \"invalid hex character\");\n+\t  go_error_at(this->location(), \"invalid hex character\");\n \t  return (Lex::is_hex_digit(p[1])\n \t\t  ? p + 2\n \t\t  : p + 1);\n@@ -1292,12 +1293,12 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \t  return p + 1;\n \tcase '\\'':\n \t  if (!is_single_quote)\n-\t    error_at(this->location(), \"invalid quoted character\");\n+\t    go_error_at(this->location(), \"invalid quoted character\");\n \t  *value = '\\'';\n \t  return p + 1;\n \tcase '\"':\n \t  if (is_single_quote)\n-\t    error_at(this->location(), \"invalid quoted character\");\n+\t    go_error_at(this->location(), \"invalid quoted character\");\n \t  *value = '\"';\n \t  return p + 1;\n \n@@ -1311,15 +1312,15 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \t\t\t+ Lex::hex_val(p[4]));\n \t      if (*value >= 0xd800 && *value < 0xe000)\n \t\t{\n-\t\t  error_at(this->location(),\n-\t\t\t   \"invalid unicode code point 0x%x\",\n-\t\t\t   *value);\n+\t\t  go_error_at(this->location(),\n+\t\t\t      \"invalid unicode code point 0x%x\",\n+\t\t\t      *value);\n \t\t  // Use the replacement character.\n \t\t  *value = 0xfffd;\n \t\t}\n \t      return p + 5;\n \t    }\n-\t  error_at(this->location(), \"invalid little unicode code point\");\n+\t  go_error_at(this->location(), \"invalid little unicode code point\");\n \t  return p + 1;\n \n \tcase 'U':\n@@ -1339,18 +1340,19 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \t      if (*value > 0x10ffff\n \t\t  || (*value >= 0xd800 && *value < 0xe000))\n \t\t{\n-\t\t  error_at(this->location(), \"invalid unicode code point 0x%x\",\n-\t\t\t   *value);\n+\t\t  go_error_at(this->location(),\n+\t\t\t      \"invalid unicode code point 0x%x\",\n+\t\t\t      *value);\n \t\t  // Use the replacement character.\n \t\t  *value = 0xfffd;\n \t\t}\n \t      return p + 9;\n \t    }\n-\t  error_at(this->location(), \"invalid big unicode code point\");\n+\t  go_error_at(this->location(), \"invalid big unicode code point\");\n \t  return p + 1;\n \n \tdefault:\n-\t  error_at(this->location(), \"invalid character after %<\\\\%>\");\n+\t  go_error_at(this->location(), \"invalid character after %<\\\\%>\");\n \t  *value = *p;\n \t  return p + 1;\n \t}\n@@ -1382,15 +1384,15 @@ Lex::append_char(unsigned int v, bool is_character, std::string* str,\n     {\n       if (v > 0x10ffff)\n \t{\n-\t  warning_at(location, 0,\n-\t\t     \"unicode code point 0x%x out of range in string\", v);\n+\t  go_warning_at(location, 0,\n+\t\t\t\"unicode code point 0x%x out of range in string\", v);\n \t  // Turn it into the \"replacement character\".\n \t  v = 0xfffd;\n \t}\n       if (v >= 0xd800 && v < 0xe000)\n \t{\n-\t  warning_at(location, 0,\n-\t\t     \"unicode code point 0x%x is invalid surrogate pair\", v);\n+\t  go_warning_at(location, 0,\n+\t\t\t\"unicode code point 0x%x is invalid surrogate pair\", v);\n \t  v = 0xfffd;\n \t}\n       if (v <= 0xffff)\n@@ -1427,7 +1429,7 @@ Lex::gather_character()\n \n   if (*p != '\\'')\n     {\n-      error_at(this->location(), \"unterminated character constant\");\n+      go_error_at(this->location(), \"unterminated character constant\");\n       this->lineoff_ = p - this->linebuf_;\n       return this->make_invalid_token();\n     }\n@@ -1461,7 +1463,7 @@ Lex::gather_string()\n       p = this->advance_one_char(p, false, &c, &is_character);\n       if (p >= pend)\n \t{\n-\t  error_at(this->location(), \"unterminated string\");\n+\t  go_error_at(this->location(), \"unterminated string\");\n \t  --p;\n \t  break;\n \t}\n@@ -1505,7 +1507,7 @@ Lex::gather_raw_string()\n       this->lineoff_ = p - this->linebuf_;\n       if (!this->require_line())\n \t{\n-\t  error_at(location, \"unterminated raw string\");\n+\t  go_error_at(location, \"unterminated raw string\");\n \t  return Token::make_string_token(value, location);\n \t}\n       p = this->linebuf_ + this->lineoff_;\n@@ -1685,7 +1687,7 @@ Lex::skip_c_comment(bool* found_newline)\n     {\n       if (!this->require_line())\n \t{\n-\t  error_at(this->location(), \"unterminated comment\");\n+\t  go_error_at(this->location(), \"unterminated comment\");\n \t  return false;\n \t}\n \n@@ -1861,7 +1863,7 @@ Lex::skip_cpp_comment()\n \t    }\n \t}\n       if (go_name.empty() || ext_name.empty())\n-\terror_at(loc, \"usage: //go:linkname localname linkname\");\n+\tgo_error_at(loc, \"usage: //go:linkname localname linkname\");\n       else\n \t{\n \t  if (this->linknames_ == NULL)"}, {"sha": "81525a741d7c4bc0b1f4df6a46ff3b23a7f825ce", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 256, "deletions": 243, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -8,6 +8,7 @@\n \n #include \"lex.h\"\n #include \"gogo.h\"\n+#include \"go-diagnostics.h\"\n #include \"types.h\"\n #include \"statements.h\"\n #include \"expressions.h\"\n@@ -109,7 +110,7 @@ Parse::identifier_list(Typed_identifier_list* til)\n     {\n       if (!token->is_identifier())\n \t{\n-\t  error_at(this->location(), \"expected identifier\");\n+\t  go_error_at(this->location(), \"expected identifier\");\n \t  return;\n \t}\n       std::string name =\n@@ -172,7 +173,7 @@ Parse::qualified_ident(std::string* pname, Named_object** ppackage)\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n     {\n-      error_at(this->location(), \"expected identifier\");\n+      go_error_at(this->location(), \"expected identifier\");\n       return false;\n     }\n \n@@ -191,7 +192,7 @@ Parse::qualified_ident(std::string* pname, Named_object** ppackage)\n   Named_object* package = this->gogo_->lookup(name, NULL);\n   if (package == NULL || !package->is_package())\n     {\n-      error_at(this->location(), \"expected package\");\n+      go_error_at(this->location(), \"expected package\");\n       // We expect . IDENTIFIER; skip both.\n       if (this->advance_token()->is_identifier())\n \tthis->advance_token();\n@@ -203,15 +204,15 @@ Parse::qualified_ident(std::string* pname, Named_object** ppackage)\n   token = this->advance_token();\n   if (!token->is_identifier())\n     {\n-      error_at(this->location(), \"expected identifier\");\n+      go_error_at(this->location(), \"expected identifier\");\n       return false;\n     }\n \n   name = token->identifier();\n \n   if (name == \"_\")\n     {\n-      error_at(this->location(), \"invalid use of %<_%>\");\n+      go_error_at(this->location(), \"invalid use of %<_%>\");\n       name = Gogo::erroneous_name();\n     }\n \n@@ -269,13 +270,13 @@ Parse::type()\n       else\n \t{\n \t  if (!ret->is_error_type())\n-\t    error_at(this->location(), \"expected %<)%>\");\n+\t    go_error_at(this->location(), \"expected %<)%>\");\n \t}\n       return ret;\n     }\n   else\n     {\n-      error_at(token->location(), \"expected type\");\n+      go_error_at(token->location(), \"expected type\");\n       return Type::make_error_type();\n     }\n }\n@@ -329,9 +330,10 @@ Parse::type_name(bool issue_error)\n \t    {\n \t      Package* p = package->package_value();\n \t      const std::string& packname(p->package_name());\n-\t      error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n-\t\t       Gogo::message_name(packname).c_str(),\n-\t\t       Gogo::message_name(name).c_str());\n+\t      go_error_at(location,\n+\t\t\t  \"invalid reference to hidden type %<%s.%s%>\",\n+\t\t\t  Gogo::message_name(packname).c_str(),\n+\t\t\t  Gogo::message_name(name).c_str());\n \t      issue_error = false;\n \t    }\n \t}\n@@ -345,9 +347,9 @@ Parse::type_name(bool issue_error)\n       else\n \t{\n \t  const std::string& packname(package->package_value()->package_name());\n-\t  error_at(location, \"reference to undefined identifier %<%s.%s%>\",\n-\t\t   Gogo::message_name(packname).c_str(),\n-\t\t   Gogo::message_name(name).c_str());\n+\t  go_error_at(location, \"reference to undefined identifier %<%s.%s%>\",\n+\t\t      Gogo::message_name(packname).c_str(),\n+\t\t      Gogo::message_name(name).c_str());\n \t  issue_error = false;\n \t  ok = false;\n \t}\n@@ -365,7 +367,7 @@ Parse::type_name(bool issue_error)\n   if (!ok)\n     {\n       if (issue_error)\n-\terror_at(location, \"expected type\");\n+\tgo_error_at(location, \"expected type\");\n       return Type::make_error_type();\n     }\n \n@@ -405,14 +407,14 @@ Parse::array_type(bool may_use_ellipsis)\n \t}\n       else\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"use of %<[...]%> outside of array literal\");\n+\t  go_error_at(this->location(),\n+\t\t      \"use of %<[...]%> outside of array literal\");\n \t  length = Expression::make_error(this->location());\n \t  this->advance_token();\n \t}\n       if (!this->peek_token()->is_op(OPERATOR_RSQUARE))\n \t{\n-\t  error_at(this->location(), \"expected %<]%>\");\n+\t  go_error_at(this->location(), \"expected %<]%>\");\n \t  return Type::make_error_type();\n \t}\n       this->advance_token();\n@@ -436,7 +438,7 @@ Parse::map_type()\n   go_assert(this->peek_token()->is_keyword(KEYWORD_MAP));\n   if (!this->advance_token()->is_op(OPERATOR_LSQUARE))\n     {\n-      error_at(this->location(), \"expected %<[%>\");\n+      go_error_at(this->location(), \"expected %<[%>\");\n       return Type::make_error_type();\n     }\n   this->advance_token();\n@@ -445,7 +447,7 @@ Parse::map_type()\n \n   if (!this->peek_token()->is_op(OPERATOR_RSQUARE))\n     {\n-      error_at(this->location(), \"expected %<]%>\");\n+      go_error_at(this->location(), \"expected %<]%>\");\n       return Type::make_error_type();\n     }\n   this->advance_token();\n@@ -470,10 +472,10 @@ Parse::struct_type()\n       Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n+\tgo_error_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<{%>\");\n \t  return Type::make_error_type();\n \t}\n     }\n@@ -487,7 +489,7 @@ Parse::struct_type()\n \tthis->advance_token();\n       else if (!this->peek_token()->is_op(OPERATOR_RCURLY))\n \t{\n-\t  error_at(this->location(), \"expected %<;%> or %<}%> or newline\");\n+\t  go_error_at(this->location(), \"expected %<;%> or %<}%> or newline\");\n \t  if (!this->skip_past_error(OPERATOR_RCURLY))\n \t    return Type::make_error_type();\n \t}\n@@ -506,8 +508,8 @@ Parse::struct_type()\n \t{\n \t  if (pi->field_name() == pj->field_name()\n \t      && !Gogo::is_sink_name(pi->field_name()))\n-\t    error_at(pi->location(), \"duplicate field name %<%s%>\",\n-\t\t     Gogo::message_name(pi->field_name()).c_str());\n+\t    go_error_at(pi->location(), \"duplicate field name %<%s%>\",\n+\t\t\tGogo::message_name(pi->field_name()).c_str());\n \t}\n     }\n \n@@ -545,7 +547,7 @@ Parse::field_decl(Struct_field_list* sfl)\n     }\n   else\n     {\n-      error_at(this->location(), \"expected field name\");\n+      go_error_at(this->location(), \"expected field name\");\n       this->gogo_->mark_locals_used();\n       while (!token->is_op(OPERATOR_SEMICOLON)\n \t     && !token->is_op(OPERATOR_RCURLY)\n@@ -561,7 +563,7 @@ Parse::field_decl(Struct_field_list* sfl)\n \t  this->advance_token();\n \t  if (!this->peek_token()->is_identifier())\n \t    {\n-\t      error_at(this->location(), \"expected field name\");\n+\t      go_error_at(this->location(), \"expected field name\");\n \t      this->gogo_->mark_locals_used();\n \t      while (!token->is_op(OPERATOR_SEMICOLON)\n \t\t     && !token->is_op(OPERATOR_RCURLY)\n@@ -596,7 +598,7 @@ Parse::field_decl(Struct_field_list* sfl)\n \t  token = this->peek_token();\n \t  if (!token->is_identifier())\n \t    {\n-\t      error_at(this->location(), \"expected identifier\");\n+\t      go_error_at(this->location(), \"expected identifier\");\n \t      return;\n \t    }\n \t  std::string name =\n@@ -657,7 +659,7 @@ Parse::channel_type()\n     {\n       if (!this->advance_token()->is_keyword(KEYWORD_CHAN))\n \t{\n-\t  error_at(this->location(), \"expected %<chan%>\");\n+\t  go_error_at(this->location(), \"expected %<chan%>\");\n \t  return Type::make_error_type();\n \t}\n       send = false;\n@@ -679,13 +681,13 @@ Parse::channel_type()\n     {\n       token = this->peek_token();\n       if (token->is_op(OPERATOR_RCURLY))\n-\terror_at(this->location(), \"unexpected %<}%> in channel type\");\n+\tgo_error_at(this->location(), \"unexpected %<}%> in channel type\");\n       else if (token->is_op(OPERATOR_RPAREN))\n-\terror_at(this->location(), \"unexpected %<)%> in channel type\");\n+\tgo_error_at(this->location(), \"unexpected %<)%> in channel type\");\n       else if (token->is_op(OPERATOR_COMMA))\n-\terror_at(this->location(), \"unexpected comma in channel type\");\n+\tgo_error_at(this->location(), \"unexpected comma in channel type\");\n       else\n-\terror_at(this->location(), \"expected channel element type\");\n+\tgo_error_at(this->location(), \"expected channel element type\");\n       return Type::make_error_type();\n     }\n \n@@ -710,11 +712,11 @@ Parse::check_signature_names(const Typed_identifier_list* params,\n       std::pair<Parse::Names::iterator, bool> ins = names->insert(val);\n       if (!ins.second)\n \t{\n-\t  error_at(p->location(), \"redefinition of %qs\",\n-\t\t   Gogo::message_name(p->name()).c_str());\n-\t  inform(ins.first->second->location(),\n-\t\t \"previous definition of %qs was here\",\n-\t\t Gogo::message_name(p->name()).c_str());\n+\t  go_error_at(p->location(), \"redefinition of %qs\",\n+\t\t      Gogo::message_name(p->name()).c_str());\n+\t  go_inform(ins.first->second->location(),\n+\t\t    \"previous definition of %qs was here\",\n+\t\t    Gogo::message_name(p->name()).c_str());\n \t}\n     }\n }\n@@ -770,7 +772,7 @@ Parse::parameters(Typed_identifier_list** pparams, bool* is_varargs)\n \n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n     {\n-      error_at(this->location(), \"expected %<(%>\");\n+      go_error_at(this->location(), \"expected %<(%>\");\n       return false;\n     }\n \n@@ -790,7 +792,7 @@ Parse::parameters(Typed_identifier_list** pparams, bool* is_varargs)\n \n   if (!token->is_op(OPERATOR_RPAREN))\n     {\n-      error_at(this->location(), \"expected %<)%>\");\n+      go_error_at(this->location(), \"expected %<)%>\");\n       return false;\n     }\n   this->advance_token();\n@@ -929,7 +931,8 @@ Parse::parameter_list(bool* is_varargs)\n \t\ttype = this->type();\n \t      else\n \t\t{\n-\t\t  error_at(this->location(), \"%<...%> only permits one name\");\n+\t\t  go_error_at(this->location(),\n+\t\t\t      \"%<...%> only permits one name\");\n \t\t  saw_error = true;\n \t\t  this->advance_token();\n \t\t  type = this->type();\n@@ -960,8 +963,8 @@ Parse::parameter_list(bool* is_varargs)\n \t\t    type = Type::make_forward_declaration(no);\n \t\t  else\n \t\t    {\n-\t\t      error_at(p->location(), \"expected %<%s%> to be a type\",\n-\t\t\t       Gogo::message_name(p->name()).c_str());\n+\t\t      go_error_at(p->location(), \"expected %<%s%> to be a type\",\n+\t\t\t\t  Gogo::message_name(p->name()).c_str());\n \t\t      saw_error = true;\n \t\t      type = Type::make_error_type();\n \t\t    }\n@@ -985,15 +988,15 @@ Parse::parameter_list(bool* is_varargs)\n \tbreak;\n       if (is_varargs != NULL && *is_varargs)\n \t{\n-\t  error_at(this->location(), \"%<...%> must be last parameter\");\n+\t  go_error_at(this->location(), \"%<...%> must be last parameter\");\n \t  saw_error = true;\n \t}\n       this->parameter_decl(parameters_have_names, ret, is_varargs, &mix_error,\n \t\t\t   &saw_error);\n     }\n   if (mix_error)\n     {\n-      error_at(location, \"invalid named/anonymous mix\");\n+      go_error_at(location, \"invalid named/anonymous mix\");\n       saw_error = true;\n     }\n   if (saw_error)\n@@ -1024,7 +1027,7 @@ Parse::parameter_decl(bool parameters_have_names,\n \t  else\n \t    {\n \t      if (is_varargs == NULL)\n-\t\terror_at(this->location(), \"invalid use of %<...%>\");\n+\t\tgo_error_at(this->location(), \"invalid use of %<...%>\");\n \t      else\n \t\t*is_varargs = true;\n \t      this->advance_token();\n@@ -1073,12 +1076,12 @@ Parse::parameter_decl(bool parameters_have_names,\n \t{\n \t  if (is_varargs == NULL)\n \t    {\n-\t      error_at(this->location(), \"invalid use of %<...%>\");\n+\t      go_error_at(this->location(), \"invalid use of %<...%>\");\n \t      *saw_error = true;\n \t    }\n \t  else if (new_count > orig_count + 1)\n \t    {\n-\t      error_at(this->location(), \"%<...%> only permits one name\");\n+\t      go_error_at(this->location(), \"%<...%> only permits one name\");\n \t      *saw_error = true;\n \t    }\n \t  else\n@@ -1129,10 +1132,10 @@ Parse::block()\n       Location loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(loc, \"unexpected semicolon or newline before %<{%>\");\n+\tgo_error_at(loc, \"unexpected semicolon or newline before %<{%>\");\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<{%>\");\n \t  return Linemap::unknown_location();\n \t}\n     }\n@@ -1146,7 +1149,7 @@ Parse::block()\n       if (!token->is_op(OPERATOR_RCURLY))\n \t{\n \t  if (!token->is_eof() || !saw_errors())\n-\t    error_at(this->location(), \"expected %<}%>\");\n+\t    go_error_at(this->location(), \"expected %<}%>\");\n \n \t  this->gogo_->mark_locals_used();\n \n@@ -1193,10 +1196,10 @@ Parse::interface_type(bool record)\n       Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n+\tgo_error_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<{%>\");\n \t  return Type::make_error_type();\n \t}\n     }\n@@ -1214,7 +1217,7 @@ Parse::interface_type(bool record)\n \t}\n       if (!this->peek_token()->is_op(OPERATOR_RCURLY))\n \t{\n-\t  error_at(this->location(), \"expected %<}%>\");\n+\t  go_error_at(this->location(), \"expected %<}%>\");\n \t  while (!this->advance_token()->is_op(OPERATOR_RCURLY))\n \t    {\n \t      if (this->peek_token()->is_eof())\n@@ -1250,7 +1253,7 @@ Parse::method_spec(Typed_identifier_list* methods)\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n     {\n-      error_at(this->location(), \"expected identifier\");\n+      go_error_at(this->location(), \"expected identifier\");\n       return;\n     }\n \n@@ -1262,7 +1265,8 @@ Parse::method_spec(Typed_identifier_list* methods)\n     {\n       // This is a MethodName.\n       if (name == \"_\")\n-\terror_at(this->location(), \"methods must have a unique non-blank name\");\n+\tgo_error_at(this->location(),\n+                    \"methods must have a unique non-blank name\");\n       name = this->gogo_->pack_hidden_name(name, is_exported);\n       Type* type = this->signature(NULL, location);\n       if (type == NULL)\n@@ -1279,10 +1283,10 @@ Parse::method_spec(Typed_identifier_list* methods)\n \t      && !this->peek_token()->is_op(OPERATOR_RCURLY)))\n \t{\n \t  if (this->peek_token()->is_op(OPERATOR_COMMA))\n-\t    error_at(this->location(),\n-\t\t     \"name list not allowed in interface type\");\n+\t    go_error_at(this->location(),\n+\t\t\t\"name list not allowed in interface type\");\n \t  else\n-\t    error_at(location, \"expected signature or type name\");\n+\t    go_error_at(location, \"expected signature or type name\");\n \t  this->gogo_->mark_locals_used();\n \t  token = this->peek_token();\n \t  while (!token->is_eof()\n@@ -1307,8 +1311,8 @@ Parse::declaration()\n \n   unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n   if (pragmas != 0 && !token->is_keyword(KEYWORD_FUNC))\n-    warning_at(token->location(), 0,\n-\t       \"ignoring magic comment before non-function\");\n+    go_warning_at(token->location(), 0,\n+\t\t  \"ignoring magic comment before non-function\");\n \n   if (token->is_keyword(KEYWORD_CONST))\n     this->const_decl();\n@@ -1320,7 +1324,7 @@ Parse::declaration()\n     this->function_decl(pragmas);\n   else\n     {\n-      error_at(this->location(), \"expected declaration\");\n+      go_error_at(this->location(), \"expected declaration\");\n       this->advance_token();\n     }\n }\n@@ -1343,7 +1347,7 @@ Parse::decl(void (Parse::*pfn)(void*), void* varg)\n   if (this->peek_token()->is_eof())\n     {\n       if (!saw_errors())\n-\terror_at(this->location(), \"unexpected end of file\");\n+\tgo_error_at(this->location(), \"unexpected end of file\");\n       return;\n     }\n \n@@ -1356,7 +1360,7 @@ Parse::decl(void (Parse::*pfn)(void*), void* varg)\n \t  this->list(pfn, varg, true);\n \t  if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n \t    {\n-\t      error_at(this->location(), \"missing %<)%>\");\n+\t      go_error_at(this->location(), \"missing %<)%>\");\n \t      while (!this->advance_token()->is_op(OPERATOR_RPAREN))\n \t\t{\n \t\t  if (this->peek_token()->is_eof())\n@@ -1382,7 +1386,7 @@ Parse::list(void (Parse::*pfn)(void*), void* varg, bool follow_is_paren)\n \t || this->peek_token()->is_op(OPERATOR_COMMA))\n     {\n       if (this->peek_token()->is_op(OPERATOR_COMMA))\n-\terror_at(this->location(), \"unexpected comma\");\n+\tgo_error_at(this->location(), \"unexpected comma\");\n       if (this->advance_token()->is_op(follow))\n \tbreak;\n       (this->*pfn)(varg);\n@@ -1413,7 +1417,8 @@ Parse::const_decl()\n \t    this->advance_token();\n \t  else if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n \t    {\n-\t      error_at(this->location(), \"expected %<;%> or %<)%> or newline\");\n+\t      go_error_at(this->location(),\n+\t\t\t  \"expected %<;%> or %<)%> or newline\");\n \t      if (!this->skip_past_error(OPERATOR_RPAREN))\n \t\treturn;\n \t    }\n@@ -1446,7 +1451,7 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n     {\n       if (*last_expr_list == NULL)\n \t{\n-\t  error_at(this->location(), \"expected %<=%>\");\n+\t  go_error_at(this->location(), \"expected %<=%>\");\n \t  return;\n \t}\n       type = *last_type;\n@@ -1473,7 +1478,7 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n     {\n       if (pe == expr_list->end())\n \t{\n-\t  error_at(this->location(), \"not enough initializers\");\n+\t  go_error_at(this->location(), \"not enough initializers\");\n \t  return;\n \t}\n       if (type != NULL)\n@@ -1493,7 +1498,7 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n \t}\n     }\n   if (pe != expr_list->end())\n-    error_at(this->location(), \"too many initializers\");\n+    go_error_at(this->location(), \"too many initializers\");\n \n   this->increment_iota();\n \n@@ -1518,7 +1523,7 @@ Parse::type_spec(void*)\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n     {\n-      error_at(this->location(), \"expected identifier\");\n+      go_error_at(this->location(), \"expected identifier\");\n       return;\n     }\n   std::string name = token->identifier();\n@@ -1547,8 +1552,8 @@ Parse::type_spec(void*)\n     type = this->type();\n   else\n     {\n-      error_at(this->location(),\n-\t       \"unexpected semicolon or newline in type declaration\");\n+      go_error_at(this->location(),\n+\t\t  \"unexpected semicolon or newline in type declaration\");\n       type = Type::make_error_type();\n       this->advance_token();\n     }\n@@ -1570,7 +1575,7 @@ Parse::type_spec(void*)\n \t      && (ftype->forward_declaration_type()->named_object()\n \t\t  == named_type))\n \t    {\n-\t      error_at(location, \"invalid recursive type\");\n+\t      go_error_at(location, \"invalid recursive type\");\n \t      type = Type::make_error_type();\n \t    }\n \n@@ -1669,7 +1674,7 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n   if (init != NULL && init->size() != til->size())\n     {\n       if (init->empty() || !init->front()->is_error_expression())\n-\terror_at(location, \"wrong number of initializations\");\n+\tgo_error_at(location, \"wrong number of initializations\");\n       init = NULL;\n       if (type == NULL)\n \ttype = Type::make_error_type();\n@@ -1701,7 +1706,7 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n   if (init != NULL)\n     go_assert(pexpr == init->end());\n   if (is_coloneq && !any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n   this->finish_init_vars(vars, vals, location);\n }\n \n@@ -1761,7 +1766,7 @@ Parse::init_vars_from_call(const Typed_identifier_list* vars, Type* type,\n     }\n \n   if (is_coloneq && !any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n \n   this->finish_init_vars(ivars, ivals, location);\n \n@@ -1804,7 +1809,7 @@ Parse::init_vars_from_map(const Typed_identifier_list* vars, Type* type,\n   Expression* present_var = Expression::make_var_reference(no, location);\n \n   if (is_coloneq && !any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n \n   Statement* s = Statement::make_tuple_map_assignment(val_var, present_var,\n \t\t\t\t\t\t      index, location);\n@@ -1869,7 +1874,7 @@ Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n   Expression* received_var = Expression::make_var_reference(no, location);\n \n   if (is_coloneq && !any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n \n   Statement* s = Statement::make_tuple_receive_assignment(val_var,\n \t\t\t\t\t\t\t  received_var,\n@@ -1940,7 +1945,7 @@ Parse::init_vars_from_type_guard(const Typed_identifier_list* vars,\n \t\t\t\t\t\t\t     location);\n \n   if (is_coloneq && !any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n \n   if (!this->gogo_->in_global_scope())\n     this->gogo_->add_statement(s);\n@@ -2133,8 +2138,8 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \t\t  id = this->gogo_->pack_hidden_name(id, is_id_exported);\n \t\t  ins = uniq_idents.insert(id);\n \t\t  if (!ins.second && !Gogo::is_sink_name(id))\n-\t\t    error_at(id_location, \"multiple assignments to %s\",\n-\t\t\t     Gogo::message_name(id).c_str());\n+\t\t    go_error_at(id_location, \"multiple assignments to %s\",\n+\t\t\t\tGogo::message_name(id).c_str());\n \t\t  til.push_back(Typed_identifier(id, NULL, location));\n \t\t}\n \t      else\n@@ -2187,7 +2192,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n   const Token* token = this->advance_token();\n \n   if (!dup_name.empty())\n-    error_at(dup_loc, \"multiple assignments to %s\", dup_name.c_str());\n+    go_error_at(dup_loc, \"multiple assignments to %s\", dup_name.c_str());\n \n   if (p_range_clause != NULL && token->is_keyword(KEYWORD_RANGE))\n     {\n@@ -2259,7 +2264,7 @@ Parse::function_decl(unsigned int pragmas)\n \n   if (!token->is_identifier())\n     {\n-      error_at(this->location(), \"expected function name\");\n+      go_error_at(this->location(), \"expected function name\");\n       return;\n     }\n \n@@ -2277,19 +2282,19 @@ Parse::function_decl(unsigned int pragmas)\n     {\n       if (!this->advance_token()->is_op(OPERATOR_LPAREN))\n \t{\n-\t  error_at(this->location(), \"expected %<(%>\");\n+\t  go_error_at(this->location(), \"expected %<(%>\");\n \t  return;\n \t}\n       token = this->advance_token();\n       if (!token->is_string())\n \t{\n-\t  error_at(this->location(), \"expected string\");\n+\t  go_error_at(this->location(), \"expected string\");\n \t  return;\n \t}\n       std::string asm_name = token->string_value();\n       if (!this->advance_token()->is_op(OPERATOR_RPAREN))\n \t{\n-\t  error_at(this->location(), \"expected %<)%>\");\n+\t  go_error_at(this->location(), \"expected %<)%>\");\n \t  return;\n \t}\n       this->advance_token();\n@@ -2306,8 +2311,8 @@ Parse::function_decl(unsigned int pragmas)\n     {\n       Location semi_loc = this->location();\n       if (this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(this->location(),\n-\t\t \"unexpected semicolon or newline before %<{%>\");\n+\tgo_error_at(this->location(),\n+\t\t    \"unexpected semicolon or newline before %<{%>\");\n       else\n \tthis->unget_token(Token::make_operator_token(OPERATOR_SEMICOLON,\n \t\t\t\t\t\t     semi_loc));\n@@ -2347,28 +2352,28 @@ Parse::function_decl(unsigned int pragmas)\n \t    {\n \t      if (pragma_check[i].decl_ok)\n \t\tcontinue;\n-\t      warning_at(location, 0,\n-\t\t\t (\"ignoring magic //go:%s comment \"\n-\t\t\t  \"before declaration\"),\n-\t\t\t pragma_check[i].name);\n+\t      go_warning_at(location, 0,\n+\t\t\t    (\"ignoring magic //go:%s comment \"\n+\t\t\t     \"before declaration\"),\n+\t\t\t    pragma_check[i].name);\n \t    }\n \t  else if (rec == NULL)\n \t    {\n \t      if (pragma_check[i].func_ok)\n \t\tcontinue;\n-\t      warning_at(location, 0,\n-\t\t\t (\"ignoring magic //go:%s comment \"\n-\t\t\t  \"before function definition\"),\n-\t\t\t pragma_check[i].name);\n+\t      go_warning_at(location, 0,\n+\t\t\t    (\"ignoring magic //go:%s comment \"\n+\t\t\t     \"before function definition\"),\n+\t\t\t    pragma_check[i].name);\n \t    }\n \t  else\n \t    {\n \t      if (pragma_check[i].method_ok)\n \t\tcontinue;\n-\t      warning_at(location, 0,\n-\t\t\t (\"ignoring magic //go:%s comment \"\n-\t\t\t  \"before method definition\"),\n-\t\t\t pragma_check[i].name);\n+\t      go_warning_at(location, 0,\n+\t\t\t    (\"ignoring magic //go:%s comment \"\n+\t\t\t     \"before method definition\"),\n+\t\t\t    pragma_check[i].name);\n \t    }\n \n \t  pragmas &= ~ pragma_check[i].bit;\n@@ -2445,12 +2450,12 @@ Parse::receiver()\n     return NULL;\n   else if (til == NULL || til->empty())\n     {\n-      error_at(location, \"method has no receiver\");\n+      go_error_at(location, \"method has no receiver\");\n       return NULL;\n     }\n   else if (til->size() > 1)\n     {\n-      error_at(location, \"method has multiple receivers\");\n+      go_error_at(location, \"method has multiple receivers\");\n       return NULL;\n     }\n   else\n@@ -2489,7 +2494,7 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n \t    if (!this->advance_token()->is_op(OPERATOR_DOT)\n \t\t|| !this->advance_token()->is_identifier())\n \t      {\n-\t\terror_at(location, \"unexpected reference to package\");\n+\t\tgo_error_at(location, \"unexpected reference to package\");\n \t\treturn Expression::make_error(location);\n \t      }\n \t    package = named_object->package_value();\n@@ -2509,9 +2514,9 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n \t    && !named_object->type_value()->is_visible())\n \t  {\n \t    go_assert(package != NULL);\n-\t    error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n-\t\t     Gogo::message_name(package->package_name()).c_str(),\n-\t\t     Gogo::message_name(id).c_str());\n+\t    go_error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n+\t\t\tGogo::message_name(package->package_name()).c_str(),\n+\t\t\tGogo::message_name(id).c_str());\n \t    return Expression::make_error(location);\n \t  }\n \n@@ -2523,14 +2528,14 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n \t\tstd::string n1 = Gogo::message_name(package->package_name());\n \t\tstd::string n2 = Gogo::message_name(id);\n \t\tif (!is_exported)\n-\t\t  error_at(location,\n-\t\t\t   (\"invalid reference to unexported identifier \"\n-\t\t\t    \"%<%s.%s%>\"),\n-\t\t\t   n1.c_str(), n2.c_str());\n+\t\t  go_error_at(location,\n+\t\t\t      (\"invalid reference to unexported identifier \"\n+\t\t\t       \"%<%s.%s%>\"),\n+\t\t\t      n1.c_str(), n2.c_str());\n \t\telse\n-\t\t  error_at(location,\n-\t\t\t   \"reference to undefined identifier %<%s.%s%>\",\n-\t\t\t   n1.c_str(), n2.c_str());\n+\t\t  go_error_at(location,\n+\t\t\t      \"reference to undefined identifier %<%s.%s%>\",\n+\t\t\t      n1.c_str(), n2.c_str());\n \t\treturn Expression::make_error(location);\n \t      }\n \n@@ -2567,7 +2572,7 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n \t      return Expression::make_sink(location);\n \t    else\n \t      {\n-\t\terror_at(location, \"cannot use _ as value\");\n+\t\tgo_error_at(location, \"cannot use _ as value\");\n \t\treturn Expression::make_error(location);\n \t      }\n \t  case Named_object::NAMED_OBJECT_FUNC:\n@@ -2652,7 +2657,7 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n \t  ret = this->expression(PRECEDENCE_NORMAL, may_be_sink, true, NULL,\n \t\t\t\t NULL);\n \t  if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n-\t    error_at(this->location(), \"missing %<)%>\");\n+\t    go_error_at(this->location(), \"missing %<)%>\");\n \t  else\n \t    this->advance_token();\n \t  if (is_parenthesized != NULL)\n@@ -2672,7 +2677,7 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n       break;\n     }\n \n-  error_at(this->location(), \"expected operand\");\n+  go_error_at(this->location(), \"expected operand\");\n   return Expression::make_error(this->location());\n }\n \n@@ -2877,10 +2882,11 @@ Parse::composite_lit(Type* type, int depth, Location location)\n       else\n \t{\n \t  if (token->is_op(OPERATOR_SEMICOLON))\n-\t    error_at(this->location(),\n-\t\t     \"need trailing comma before newline in composite literal\");\n+\t    go_error_at(this->location(),\n+\t\t\t(\"need trailing comma before newline \"\n+\t\t\t \"in composite literal\"));\n \t  else\n-\t    error_at(this->location(), \"expected %<,%> or %<}%>\");\n+\t    go_error_at(this->location(), \"expected %<,%> or %<}%>\");\n \n \t  this->gogo_->mark_locals_used();\n \t  int depth = 0;\n@@ -3073,13 +3079,13 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t      Type* t = ret->type();\n \t      if (t->named_type() != NULL\n \t\t  || t->forward_declaration_type() != NULL)\n-\t\terror_at(start_loc,\n-\t\t\t _(\"parentheses required around this composite literal \"\n-\t\t\t   \"to avoid parsing ambiguity\"));\n+\t\tgo_error_at(start_loc,\n+\t\t\t    _(\"parentheses required around this composite \"\n+\t\t\t      \"literal to avoid parsing ambiguity\"));\n \t    }\n \t  else if (operand_is_parenthesized)\n-\t    error_at(start_loc,\n-\t\t     \"cannot parenthesize type in composite literal\");\n+\t    go_error_at(start_loc,\n+\t\t\t\"cannot parenthesize type in composite literal\");\n \t  ret = this->composite_lit(ret->type(), 0, ret->location());\n \t}\n       else if (this->peek_token()->is_op(OPERATOR_LPAREN))\n@@ -3093,12 +3099,12 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t    this->advance_token();\n \t  if (this->peek_token()->is_op(OPERATOR_ELLIPSIS))\n \t    {\n-\t      error_at(this->location(),\n-\t\t       \"invalid use of %<...%> in type conversion\");\n+\t      go_error_at(this->location(),\n+\t\t\t  \"invalid use of %<...%> in type conversion\");\n \t      this->advance_token();\n \t    }\n \t  if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n-\t    error_at(this->location(), \"expected %<)%>\");\n+\t    go_error_at(this->location(), \"expected %<)%>\");\n \t  else\n \t    this->advance_token();\n \t  if (expr->is_error_expression())\n@@ -3110,8 +3116,8 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t  && t->array_type()->length() != NULL\n \t\t  && t->array_type()->length()->is_nil_expression())\n \t\t{\n-\t\t  error_at(ret->location(),\n-\t\t\t   \"use of %<[...]%> outside of array literal\");\n+\t\t  go_error_at(ret->location(),\n+\t\t\t      \"use of %<[...]%> outside of array literal\");\n \t\t  ret = Expression::make_error(loc);\n \t\t}\n \t      else\n@@ -3177,7 +3183,7 @@ Parse::selector(Expression* left, bool* is_type_switch)\n \t\t\t\t      token->is_identifier_exported());\n       if (token->identifier() == \"_\")\n \t{\n-\t  error_at(this->location(), \"invalid use of %<_%>\");\n+\t  go_error_at(this->location(), \"invalid use of %<_%>\");\n \t  name = Gogo::erroneous_name();\n \t}\n       this->advance_token();\n@@ -3195,14 +3201,14 @@ Parse::selector(Expression* left, bool* is_type_switch)\n \t    *is_type_switch = true;\n \t  else\n \t    {\n-\t      error_at(this->location(),\n-\t\t       \"use of %<.(type)%> outside type switch\");\n+\t      go_error_at(this->location(),\n+\t\t\t  \"use of %<.(type)%> outside type switch\");\n \t      type = Type::make_error_type();\n \t    }\n \t  this->advance_token();\n \t}\n       if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n-\terror_at(this->location(), \"missing %<)%>\");\n+\tgo_error_at(this->location(), \"missing %<)%>\");\n       else\n \tthis->advance_token();\n       if (is_type_switch != NULL && *is_type_switch)\n@@ -3211,7 +3217,7 @@ Parse::selector(Expression* left, bool* is_type_switch)\n     }\n   else\n     {\n-      error_at(this->location(), \"expected identifier or %<(%>\");\n+      go_error_at(this->location(), \"expected identifier or %<(%>\");\n       return left;\n     }\n }\n@@ -3240,7 +3246,8 @@ Parse::index(Expression* expr)\n \tend = Expression::make_nil(this->location());\n       else if (this->peek_token()->is_op(OPERATOR_COLON))\n \t{\n-\t  error_at(this->location(), \"middle index required in 3-index slice\");\n+\t  go_error_at(this->location(),\n+\t\t      \"middle index required in 3-index slice\");\n \t  end = Expression::make_error(this->location());\n \t}\n       else\n@@ -3252,14 +3259,15 @@ Parse::index(Expression* expr)\n     {\n       if (this->advance_token()->is_op(OPERATOR_RSQUARE))\n \t{\n-\t  error_at(this->location(), \"final index required in 3-index slice\");\n+\t  go_error_at(this->location(),\n+\t\t      \"final index required in 3-index slice\");\n \t  cap = Expression::make_error(this->location());\n \t}\n       else\n         cap = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n     }\n   if (!this->peek_token()->is_op(OPERATOR_RSQUARE))\n-    error_at(this->location(), \"missing %<]%>\");\n+    go_error_at(this->location(), \"missing %<]%>\");\n   else\n     this->advance_token();\n   return Expression::make_index(expr, start, end, cap, location);\n@@ -3289,7 +3297,7 @@ Parse::call(Expression* func)\n     token = this->advance_token();\n   if (!token->is_op(OPERATOR_RPAREN))\n     {\n-      error_at(this->location(), \"missing %<)%>\");\n+      go_error_at(this->location(), \"missing %<)%>\");\n       if (!this->skip_past_error(OPERATOR_RPAREN))\n \treturn Expression::make_error(this->location());\n     }\n@@ -3356,7 +3364,7 @@ Parse::id_to_expression(const std::string& name, Location location,\n     case Named_object::NAMED_OBJECT_ERRONEOUS:\n       return Expression::make_error(location);\n     default:\n-      error_at(this->location(), \"unexpected type of identifier\");\n+      go_error_at(this->location(), \"unexpected type of identifier\");\n       return Expression::make_error(location);\n     }\n }\n@@ -3561,7 +3569,7 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t      if (ct == NULL)\n \t\t{\n \t\t  // This is probably impossible.\n-\t\t  error_at(location, \"expected channel type\");\n+\t\t  go_error_at(location, \"expected channel type\");\n \t\t  return Expression::make_error(location);\n \t\t}\n \t      else if (ct->may_receive())\n@@ -3633,7 +3641,7 @@ Parse::reassociate_chan_direction(Channel_type *ct, Location location)\n   Channel_type* ele = ct->element_type()->channel_type();\n   if (ele == NULL)\n     {\n-      error_at(location, \"parse error\");\n+      go_error_at(location, \"parse error\");\n       return Type::make_error_type();\n     }\n   Type* sub = ele;\n@@ -3702,7 +3710,7 @@ Parse::statement(Label* label)\n \t    this->for_stat(label);\n \t    break;\n \t  default:\n-\t    error_at(this->location(), \"expected statement\");\n+\t    go_error_at(this->location(), \"expected statement\");\n \t    this->advance_token();\n \t    break;\n \t  }\n@@ -3751,7 +3759,7 @@ Parse::statement(Label* label)\n       break;\n \n     default:\n-      error_at(this->location(), \"expected statement\");\n+      go_error_at(this->location(), \"expected statement\");\n       this->advance_token();\n       break;\n     }\n@@ -3847,7 +3855,7 @@ Parse::labeled_stmt(const std::string& label_name, Location location)\n       if (label != NULL)\n         label->set_is_used();\n \n-      error_at(location, \"missing statement after label\");\n+      go_error_at(location, \"missing statement after label\");\n       this->unget_token(Token::make_operator_token(OPERATOR_SEMICOLON,\n \t\t\t\t\t\t   location));\n       return;\n@@ -3960,7 +3968,7 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n       if (token->is_op(OPERATOR_COLONEQ))\n \t{\n \t  if (!exp->is_error_expression())\n-\t    error_at(token->location(), \"non-name on left side of %<:=%>\");\n+\t    go_error_at(token->location(), \"non-name on left side of %<:=%>\");\n \t  this->gogo_->mark_locals_used();\n \t  while (!token->is_op(OPERATOR_SEMICOLON)\n \t\t && !token->is_eof())\n@@ -3997,7 +4005,7 @@ Parse::statement_list()\n       else\n \t{\n \t  if (!this->peek_token()->is_eof() || !saw_errors())\n-\t    error_at(this->location(), \"expected %<;%> or %<}%> or newline\");\n+\t    go_error_at(this->location(), \"expected %<;%> or %<}%> or newline\");\n \t  if (!this->skip_past_error(OPERATOR_RCURLY))\n \t    return;\n \t}\n@@ -4104,7 +4112,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n       && !token->is_op(OPERATOR_ANDEQ)\n       && !token->is_op(OPERATOR_BITCLEAREQ))\n     {\n-      error_at(this->location(), \"expected assignment operator\");\n+      go_error_at(this->location(), \"expected assignment operator\");\n       return;\n     }\n   Operator op = token->op();\n@@ -4118,7 +4126,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n   if (p_range_clause != NULL && token->is_keyword(KEYWORD_RANGE))\n     {\n       if (op != OPERATOR_EQ)\n-\terror_at(this->location(), \"range clause requires %<=%>\");\n+\tgo_error_at(this->location(), \"range clause requires %<=%>\");\n       this->range_clause_expr(lhs, p_range_clause);\n       return;\n     }\n@@ -4136,7 +4144,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n       if ((*pe)->is_error_expression())\n \treturn;\n       if (op != OPERATOR_EQ && (*pe)->is_sink_expression())\n-\terror_at((*pe)->location(), \"cannot use _ as value\");\n+\tgo_error_at((*pe)->location(), \"cannot use _ as value\");\n     }\n   for (Expression_list::const_iterator pe = vals->begin();\n        pe != vals->end();\n@@ -4156,7 +4164,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n       if (lhs->size() > 1)\n \t{\n \t  if (op != OPERATOR_EQ)\n-\t    error_at(location, \"multiple values only permitted with %<=%>\");\n+\t    go_error_at(location, \"multiple values only permitted with %<=%>\");\n \t  s = Statement::make_tuple_assignment(lhs, vals, location);\n \t}\n       else\n@@ -4176,7 +4184,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n \t   && (call = (*vals->begin())->call_expression()) != NULL)\n     {\n       if (op != OPERATOR_EQ)\n-\terror_at(location, \"multiple results only permitted with %<=%>\");\n+\tgo_error_at(location, \"multiple results only permitted with %<=%>\");\n       call->set_expected_result_count(lhs->size());\n       delete vals;\n       vals = new Expression_list;\n@@ -4190,7 +4198,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n \t   && (map_index = (*vals->begin())->index_expression()) != NULL)\n     {\n       if (op != OPERATOR_EQ)\n-\terror_at(location, \"two values from map requires %<=%>\");\n+\tgo_error_at(location, \"two values from map requires %<=%>\");\n       Expression* val = lhs->front();\n       Expression* present = lhs->back();\n       Statement* s = Statement::make_tuple_map_assignment(val, present,\n@@ -4202,7 +4210,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n \t   && (receive = (*vals->begin())->receive_expression()) != NULL)\n     {\n       if (op != OPERATOR_EQ)\n-\terror_at(location, \"two values from receive requires %<=%>\");\n+\tgo_error_at(location, \"two values from receive requires %<=%>\");\n       Expression* val = lhs->front();\n       Expression* success = lhs->back();\n       Expression* channel = receive->channel();\n@@ -4216,7 +4224,7 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n \t   && (type_guard = (*vals->begin())->type_guard_expression()) != NULL)\n     {\n       if (op != OPERATOR_EQ)\n-\terror_at(location, \"two values from type guard requires %<=%>\");\n+\tgo_error_at(location, \"two values from type guard requires %<=%>\");\n       Expression* val = lhs->front();\n       Expression* ok = lhs->back();\n       Expression* expr = type_guard->expr();\n@@ -4228,7 +4236,8 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n     }\n   else\n     {\n-      error_at(location, \"number of variables does not match number of values\");\n+      go_error_at(location, (\"number of variables does not \"\n+                             \"match number of values\"));\n     }\n }\n \n@@ -4252,7 +4261,7 @@ Parse::go_or_defer_stat()\n   Call_expression* call_expr = expr->call_expression();\n   if (is_parenthesized || call_expr == NULL)\n     {\n-      error_at(expr_location, \"argument to go/defer must be function call\");\n+      go_error_at(expr_location, \"argument to go/defer must be function call\");\n       return;\n     }\n \n@@ -4295,8 +4304,8 @@ Parse::return_stat()\n \t  if (no == NULL)\n \t    go_assert(saw_errors());\n \t  else if (!no->is_result_variable())\n-\t    error_at(location, \"%qs is shadowed during return\",\n-\t\t     (*p)->message_name().c_str());\n+\t    go_error_at(location, \"%qs is shadowed during return\",\n+\t\t\t(*p)->message_name().c_str());\n \t}\n     }\n }\n@@ -4334,19 +4343,19 @@ Parse::if_stat()\n       else if (saw_simple_stat)\n \t{\n \t  if (saw_send_stmt)\n-\t    error_at(this->location(),\n-\t\t     (\"send statement used as value; \"\n-\t\t      \"use select for non-blocking send\"));\n+\t    go_error_at(this->location(),\n+\t\t\t(\"send statement used as value; \"\n+\t\t\t \"use select for non-blocking send\"));\n \t  else\n-\t    error_at(this->location(),\n-\t\t     \"expected %<;%> after statement in if expression\");\n+\t    go_error_at(this->location(),\n+\t\t\t\"expected %<;%> after statement in if expression\");\n \t  if (!this->expression_may_start_here())\n \t    cond = Expression::make_error(this->location());\n \t}\n       if (cond == NULL && this->peek_token()->is_op(OPERATOR_LCURLY))\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"missing condition in if statement\");\n+\t  go_error_at(this->location(),\n+\t\t      \"missing condition in if statement\");\n \t  cond = Expression::make_error(this->location());\n \t}\n       if (cond == NULL)\n@@ -4358,7 +4367,7 @@ Parse::if_stat()\n     {\n       Location semi_loc = this->location();\n       if (this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(semi_loc, \"missing %<{%> after if clause\");\n+\tgo_error_at(semi_loc, \"missing %<{%> after if clause\");\n       // Otherwise we will get an error when we call this->block\n       // below.\n     }\n@@ -4372,7 +4381,7 @@ Parse::if_stat()\n     {\n       Location semi_loc = this->location();\n       if (this->advance_token()->is_keyword(KEYWORD_ELSE))\n-\terror_at(this->location(),\n+\tgo_error_at(this->location(),\n \t\t \"unexpected semicolon or newline before %<else%>\");\n       else\n \tthis->unget_token(Token::make_operator_token(OPERATOR_SEMICOLON,\n@@ -4390,7 +4399,7 @@ Parse::if_stat()\n \tthis->block();\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<if%> or %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<if%> or %<{%>\");\n \t  this->statement(NULL);\n \t}\n       else_block = this->gogo_->finish_block(this->location());\n@@ -4444,12 +4453,12 @@ Parse::switch_stat(Label* label)\n       else if (saw_simple_stat)\n \t{\n \t  if (saw_send_stmt)\n-\t    error_at(this->location(),\n-\t\t     (\"send statement used as value; \"\n-\t\t      \"use select for non-blocking send\"));\n+\t    go_error_at(this->location(),\n+\t\t\t(\"send statement used as value; \"\n+\t\t\t \"use select for non-blocking send\"));\n \t  else\n-\t    error_at(this->location(),\n-\t\t     \"expected %<;%> after statement in switch expression\");\n+\t    go_error_at(this->location(),\n+\t\t\t\"expected %<;%> after statement in switch expression\");\n \t}\n       if (!this->peek_token()->is_op(OPERATOR_LCURLY))\n \t{\n@@ -4482,7 +4491,8 @@ Parse::switch_stat(Label* label)\n \t\t      if (switch_val == NULL\n \t\t\t  || !switch_val->is_error_expression())\n \t\t\t{\n-\t\t\t  error_at(id_loc, \"expected type switch assignment\");\n+\t\t\t  go_error_at(id_loc,\n+\t\t\t\t      \"expected type switch assignment\");\n \t\t\t  switch_val = Expression::make_error(id_loc);\n \t\t\t}\n \t\t    }\n@@ -4507,10 +4517,10 @@ Parse::switch_stat(Label* label)\n       Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(token_loc, \"missing %<{%> after switch clause\");\n+\tgo_error_at(token_loc, \"missing %<{%> after switch clause\");\n       else if (this->peek_token()->is_op(OPERATOR_COLONEQ))\n \t{\n-\t  error_at(token_loc, \"invalid variable name\");\n+\t  go_error_at(token_loc, \"invalid variable name\");\n \t  this->advance_token();\n \t  this->expression(PRECEDENCE_NORMAL, false, false,\n \t\t\t   &type_switch.found, NULL);\n@@ -4530,7 +4540,7 @@ Parse::switch_stat(Label* label)\n \t}\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<{%>\");\n \t  if (have_type_switch_block)\n \t    this->gogo_->add_block(this->gogo_->finish_block(this->location()),\n \t\t\t\t   location);\n@@ -4577,7 +4587,7 @@ Parse::expr_switch_body(Label* label, Expression* switch_val,\n       if (this->peek_token()->is_eof())\n \t{\n \t  if (!saw_errors())\n-\t    error_at(this->location(), \"missing %<}%>\");\n+\t    go_error_at(this->location(), \"missing %<}%>\");\n \t  return NULL;\n \t}\n       this->expr_case_clause(case_clauses, &saw_default);\n@@ -4605,7 +4615,7 @@ Parse::expr_case_clause(Case_clauses* clauses, bool* saw_default)\n   if (!this->peek_token()->is_op(OPERATOR_COLON))\n     {\n       if (!saw_errors())\n-\terror_at(this->location(), \"expected %<:%>\");\n+\tgo_error_at(this->location(), \"expected %<:%>\");\n       return;\n     }\n   else\n@@ -4627,14 +4637,15 @@ Parse::expr_case_clause(Case_clauses* clauses, bool* saw_default)\n       if (this->advance_token()->is_op(OPERATOR_SEMICOLON))\n \tthis->advance_token();\n       if (this->peek_token()->is_op(OPERATOR_RCURLY))\n-\terror_at(fallthrough_loc, _(\"cannot fallthrough final case in switch\"));\n+\tgo_error_at(fallthrough_loc,\n+\t\t    _(\"cannot fallthrough final case in switch\"));\n     }\n \n   if (is_default)\n     {\n       if (*saw_default)\n \t{\n-\t  error_at(location, \"multiple defaults in switch\");\n+\t  go_error_at(location, \"multiple defaults in switch\");\n \t  return;\n \t}\n       *saw_default = true;\n@@ -4664,7 +4675,7 @@ Parse::expr_switch_case(bool* is_default)\n   else\n     {\n       if (!saw_errors())\n-\terror_at(this->location(), \"expected %<case%> or %<default%>\");\n+\tgo_error_at(this->location(), \"expected %<case%> or %<default%>\");\n       if (!token->is_op(OPERATOR_RCURLY))\n \tthis->advance_token();\n       return NULL;\n@@ -4684,8 +4695,8 @@ Parse::type_switch_body(Label* label, const Type_switch& type_switch,\n     {\n       if (Gogo::is_sink_name(var_name))\n         {\n-          error_at(type_switch.location,\n-                   \"no new variables on left side of %<:=%>\");\n+\t  go_error_at(type_switch.location,\n+\t\t      \"no new variables on left side of %<:=%>\");\n           var_name.clear();\n         }\n       else\n@@ -4709,7 +4720,7 @@ Parse::type_switch_body(Label* label, const Type_switch& type_switch,\n     {\n       if (this->peek_token()->is_eof())\n \t{\n-\t  error_at(this->location(), \"missing %<}%>\");\n+\t  go_error_at(this->location(), \"missing %<}%>\");\n \t  return NULL;\n \t}\n       this->type_case_clause(var_name, init, case_clauses, &saw_default,\n@@ -4737,8 +4748,8 @@ Parse::type_switch_body(Label* label, const Type_switch& type_switch,\n \t    }\n \t}\n       if (!used)\n-\terror_at(type_switch.location, \"%qs declared and not used\",\n-\t\t Gogo::message_name(var_name).c_str());\n+\tgo_error_at(type_switch.location, \"%qs declared and not used\",\n+\t\t    Gogo::message_name(var_name).c_str());\n     }\n   return statement;\n }\n@@ -4759,7 +4770,7 @@ Parse::type_case_clause(const std::string& var_name, Expression* init,\n   this->type_switch_case(&types, &is_default);\n \n   if (!this->peek_token()->is_op(OPERATOR_COLON))\n-    error_at(this->location(), \"expected %<:%>\");\n+    go_error_at(this->location(), \"expected %<:%>\");\n   else\n     this->advance_token();\n \n@@ -4789,8 +4800,8 @@ Parse::type_case_clause(const std::string& var_name, Expression* init,\n \n   if (this->peek_token()->is_keyword(KEYWORD_FALLTHROUGH))\n     {\n-      error_at(this->location(),\n-\t       \"fallthrough is not permitted in a type switch\");\n+      go_error_at(this->location(),\n+\t\t  \"fallthrough is not permitted in a type switch\");\n       if (this->advance_token()->is_op(OPERATOR_SEMICOLON))\n \tthis->advance_token();\n     }\n@@ -4800,7 +4811,7 @@ Parse::type_case_clause(const std::string& var_name, Expression* init,\n       go_assert(types.empty());\n       if (*saw_default)\n \t{\n-\t  error_at(location, \"multiple defaults in type switch\");\n+\t  go_error_at(location, \"multiple defaults in type switch\");\n \t  return;\n \t}\n       *saw_default = true;\n@@ -4858,7 +4869,7 @@ Parse::type_switch_case(std::vector<Type*>* types, bool* is_default)\n     }\n   else\n     {\n-      error_at(this->location(), \"expected %<case%> or %<default%>\");\n+      go_error_at(this->location(), \"expected %<case%> or %<default%>\");\n       if (!token->is_op(OPERATOR_RCURLY))\n \tthis->advance_token();\n     }\n@@ -4878,10 +4889,10 @@ Parse::select_stat(Label* label)\n       Location token_loc = token->location();\n       if (token->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n+\tgo_error_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n       else\n \t{\n-\t  error_at(this->location(), \"expected %<{%>\");\n+\t  go_error_at(this->location(), \"expected %<{%>\");\n \t  return;\n \t}\n     }\n@@ -4897,7 +4908,7 @@ Parse::select_stat(Label* label)\n     {\n       if (this->peek_token()->is_eof())\n \t{\n-\t  error_at(this->location(), \"expected %<}%>\");\n+\t  go_error_at(this->location(), \"expected %<}%>\");\n \t  return;\n \t}\n       this->comm_clause(select_clauses, &saw_default);\n@@ -4931,7 +4942,7 @@ Parse::comm_clause(Select_clauses* clauses, bool* saw_default)\n   if (this->peek_token()->is_op(OPERATOR_COLON))\n     this->advance_token();\n   else\n-    error_at(this->location(), \"expected colon\");\n+    go_error_at(this->location(), \"expected colon\");\n \n   this->gogo_->start_block(this->location());\n \n@@ -4962,7 +4973,7 @@ Parse::comm_clause(Select_clauses* clauses, bool* saw_default)\n     {\n       if (*saw_default)\n \t{\n-\t  error_at(location, \"multiple defaults in select\");\n+\t  go_error_at(location, \"multiple defaults in select\");\n \t  return;\n \t}\n       *saw_default = true;\n@@ -5001,7 +5012,7 @@ Parse::comm_case(bool* is_send, Expression** channel, Expression** val,\n     }\n   else\n     {\n-      error_at(this->location(), \"expected %<case%> or %<default%>\");\n+      go_error_at(this->location(), \"expected %<case%> or %<default%>\");\n       if (!token->is_op(OPERATOR_RCURLY))\n \tthis->advance_token();\n       return false;\n@@ -5038,13 +5049,13 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t  if (re == NULL)\n \t    {\n \t      if (!e->is_error_expression())\n-\t\terror_at(this->location(), \"expected receive expression\");\n+\t\tgo_error_at(this->location(), \"expected receive expression\");\n \t      return false;\n \t    }\n \t  if (recv_var == \"_\")\n \t    {\n-\t      error_at(recv_var_loc,\n-\t\t       \"no new variables on left side of %<:=%>\");\n+\t      go_error_at(recv_var_loc,\n+\t\t\t  \"no new variables on left side of %<:=%>\");\n \t      recv_var = Gogo::erroneous_name();\n \t    }\n \t  *is_send = false;\n@@ -5073,14 +5084,14 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t\t  if (re == NULL)\n \t\t    {\n \t\t      if (!e->is_error_expression())\n-\t\t\terror_at(this->location(),\n+\t\t\tgo_error_at(this->location(),\n \t\t\t\t \"expected receive expression\");\n \t\t      return false;\n \t\t    }\n \t\t  if (recv_var == \"_\" && recv_closed == \"_\")\n \t\t    {\n-\t\t      error_at(recv_var_loc,\n-\t\t\t       \"no new variables on left side of %<:=%>\");\n+\t\t      go_error_at(recv_var_loc,\n+\t\t\t\t  \"no new variables on left side of %<:=%>\");\n \t\t      recv_var = Gogo::erroneous_name();\n \t\t    }\n \t\t  *is_send = false;\n@@ -5147,7 +5158,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n     {\n       if (!this->advance_token()->is_op(OPERATOR_CHANOP))\n \t{\n-\t  error_at(this->location(), \"missing %<<-%>\");\n+\t  go_error_at(this->location(), \"missing %<<-%>\");\n \t  return false;\n \t}\n       *is_send = false;\n@@ -5172,9 +5183,9 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n   if (saw_comma)\n     {\n       if (closed_is_id)\n-\terror_at(this->location(), \"expected %<=%> or %<:=%>\");\n+\tgo_error_at(this->location(), \"expected %<=%> or %<:=%>\");\n       else\n-\terror_at(this->location(), \"expected %<=%>\");\n+\tgo_error_at(this->location(), \"expected %<=%>\");\n       return false;\n     }\n \n@@ -5188,7 +5199,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n       return true;\n     }\n \n-  error_at(this->location(), \"expected %<<-%> or %<=%>\");\n+  go_error_at(this->location(), \"expected %<<-%> or %<=%>\");\n   return false;\n }\n \n@@ -5215,8 +5226,8 @@ Parse::for_stat(Label* label)\n     {\n       if (token->is_keyword(KEYWORD_VAR))\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"var declaration not allowed in for initializer\");\n+\t  go_error_at(this->location(),\n+                      \"var declaration not allowed in for initializer\");\n \t  this->var_decl();\n \t}\n \n@@ -5233,17 +5244,18 @@ Parse::for_stat(Label* label)\n \t      if (cond == NULL && !range_clause.found)\n \t\t{\n \t\t  if (saw_send_stmt)\n-\t\t    error_at(this->location(),\n-\t\t\t     (\"send statement used as value; \"\n-\t\t\t      \"use select for non-blocking send\"));\n+\t\t    go_error_at(this->location(),\n+                                (\"send statement used as value; \"\n+                                 \"use select for non-blocking send\"));\n \t\t  else\n-\t\t    error_at(this->location(), \"parse error in for statement\");\n+\t\t    go_error_at(this->location(),\n+                                \"parse error in for statement\");\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (range_clause.found)\n-\t\terror_at(this->location(), \"parse error after range clause\");\n+\t\tgo_error_at(this->location(), \"parse error after range clause\");\n \n \t      if (cond != NULL)\n \t\t{\n@@ -5263,7 +5275,7 @@ Parse::for_stat(Label* label)\n     {\n       Location semi_loc = this->location();\n       if (this->advance_token()->is_op(OPERATOR_LCURLY))\n-\terror_at(semi_loc, \"missing %<{%> after for clause\");\n+\tgo_error_at(semi_loc, \"missing %<{%> after for clause\");\n       // Otherwise we will get an error when we call this->block\n       // below.\n     }\n@@ -5334,15 +5346,15 @@ Parse::for_clause(Expression** cond, Block** post)\n     *cond = NULL;\n   else if (this->peek_token()->is_op(OPERATOR_LCURLY))\n     {\n-      error_at(this->location(), \"missing %<{%> after for clause\");\n+      go_error_at(this->location(), \"missing %<{%> after for clause\");\n       *cond = NULL;\n       *post = NULL;\n       return;\n     }\n   else\n     *cond = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n   if (!this->peek_token()->is_op(OPERATOR_SEMICOLON))\n-    error_at(this->location(), \"expected semicolon\");\n+    go_error_at(this->location(), \"expected semicolon\");\n   else\n     this->advance_token();\n \n@@ -5370,7 +5382,7 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n   p_range_clause->found = true;\n \n   if (til->size() > 2)\n-    error_at(this->location(), \"too many variables for range clause\");\n+    go_error_at(this->location(), \"too many variables for range clause\");\n \n   this->advance_token();\n   Expression* expr = this->expression(PRECEDENCE_NORMAL, false, false, NULL,\n@@ -5405,7 +5417,7 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n     }\n \n   if (!any_new)\n-    error_at(location, \"variables redeclared but no variable is new\");\n+    go_error_at(location, \"variables redeclared but no variable is new\");\n }\n \n // The = version of RangeClause.  This is called with a list of\n@@ -5421,7 +5433,7 @@ Parse::range_clause_expr(const Expression_list* vals,\n \n   go_assert(vals->size() >= 1);\n   if (vals->size() > 2)\n-    error_at(this->location(), \"too many variables for range clause\");\n+    go_error_at(this->location(), \"too many variables for range clause\");\n \n   this->advance_token();\n   p_range_clause->range = this->expression(PRECEDENCE_NORMAL, false, false,\n@@ -5507,8 +5519,8 @@ Parse::break_stat()\n     {\n       if (this->break_stack_ == NULL || this->break_stack_->empty())\n \t{\n-\t  error_at(this->location(),\n-\t\t   \"break statement not within for or switch or select\");\n+\t  go_error_at(this->location(),\n+                      \"break statement not within for or switch or select\");\n \t  return;\n \t}\n       enclosing = this->break_stack_->back().first;\n@@ -5524,8 +5536,8 @@ Parse::break_stat()\n \t  this->gogo_->add_label_reference(token->identifier(),\n                                            Linemap::unknown_location(), false);\n \n-\t  error_at(token->location(), \"invalid break label %qs\",\n-\t\t   Gogo::message_name(token->identifier()).c_str());\n+\t  go_error_at(token->location(), \"invalid break label %qs\",\n+                      Gogo::message_name(token->identifier()).c_str());\n \t  this->advance_token();\n \t  return;\n \t}\n@@ -5564,7 +5576,7 @@ Parse::continue_stat()\n     {\n       if (this->continue_stack_ == NULL || this->continue_stack_->empty())\n \t{\n-\t  error_at(this->location(), \"continue statement not within for\");\n+\t  go_error_at(this->location(), \"continue statement not within for\");\n \t  return;\n \t}\n       enclosing = this->continue_stack_->back().first;\n@@ -5580,8 +5592,8 @@ Parse::continue_stat()\n \t  this->gogo_->add_label_reference(token->identifier(),\n                                            Linemap::unknown_location(), false);\n \n-\t  error_at(token->location(), \"invalid continue label %qs\",\n-\t\t   Gogo::message_name(token->identifier()).c_str());\n+\t  go_error_at(token->location(), \"invalid continue label %qs\",\n+                      Gogo::message_name(token->identifier()).c_str());\n \t  this->advance_token();\n \t  return;\n \t}\n@@ -5609,7 +5621,7 @@ Parse::goto_stat()\n   Location location = this->location();\n   const Token* token = this->advance_token();\n   if (!token->is_identifier())\n-    error_at(this->location(), \"expected label for goto\");\n+    go_error_at(this->location(), \"expected label for goto\");\n   else\n     {\n       Label* label = this->gogo_->add_label_reference(token->identifier(),\n@@ -5630,7 +5642,7 @@ Parse::package_clause()\n   std::string name;\n   if (!token->is_keyword(KEYWORD_PACKAGE))\n     {\n-      error_at(this->location(), \"program must start with package clause\");\n+      go_error_at(this->location(), \"program must start with package clause\");\n       name = \"ERROR\";\n     }\n   else\n@@ -5641,14 +5653,14 @@ Parse::package_clause()\n \t  name = token->identifier();\n \t  if (name == \"_\")\n \t    {\n-\t      error_at(this->location(), \"invalid package name _\");\n+\t      go_error_at(this->location(), \"invalid package name _\");\n \t      name = Gogo::erroneous_name();\n \t    }\n \t  this->advance_token();\n \t}\n       else\n \t{\n-\t  error_at(this->location(), \"package name must be an identifier\");\n+\t  go_error_at(this->location(), \"package name must be an identifier\");\n \t  name = \"ERROR\";\n \t}\n     }\n@@ -5689,7 +5701,7 @@ Parse::import_spec(void*)\n \n   if (!token->is_string())\n     {\n-      error_at(this->location(), \"import statement not a string\");\n+      go_error_at(this->location(), \"import statement not a string\");\n       this->advance_token();\n       return;\n     }\n@@ -5712,8 +5724,8 @@ Parse::program()\n   if (token->is_op(OPERATOR_SEMICOLON))\n     token = this->advance_token();\n   else\n-    error_at(this->location(),\n-\t     \"expected %<;%> or newline after package clause\");\n+    go_error_at(this->location(),\n+                \"expected %<;%> or newline after package clause\");\n \n   while (token->is_keyword(KEYWORD_IMPORT))\n     {\n@@ -5722,8 +5734,8 @@ Parse::program()\n       if (token->is_op(OPERATOR_SEMICOLON))\n \ttoken = this->advance_token();\n       else\n-\terror_at(this->location(),\n-\t\t \"expected %<;%> or newline after import declaration\");\n+\tgo_error_at(this->location(),\n+                    \"expected %<;%> or newline after import declaration\");\n     }\n \n   while (!token->is_eof())\n@@ -5732,7 +5744,7 @@ Parse::program()\n \tthis->declaration();\n       else\n \t{\n-\t  error_at(this->location(), \"expected declaration\");\n+\t  go_error_at(this->location(), \"expected declaration\");\n \t  this->gogo_->mark_locals_used();\n \t  do\n \t    this->advance_token();\n@@ -5749,12 +5761,13 @@ Parse::program()\n       else if (!token->is_eof() || !saw_errors())\n \t{\n \t  if (token->is_op(OPERATOR_CHANOP))\n-\t    error_at(this->location(),\n-\t\t     (\"send statement used as value; \"\n-\t\t      \"use select for non-blocking send\"));\n+\t    go_error_at(this->location(),\n+                        (\"send statement used as value; \"\n+                         \"use select for non-blocking send\"));\n \t  else\n-\t    error_at(this->location(),\n-\t\t     \"expected %<;%> or newline after top level declaration\");\n+\t    go_error_at(this->location(),\n+                        (\"expected %<;%> or newline after top \"\n+                         \"level declaration\"));\n \t  this->skip_past_error(OPERATOR_INVALID);\n \t}\n     }\n@@ -5815,7 +5828,7 @@ Parse::verify_not_sink(Expression* expr)\n {\n   if (expr->is_sink_expression())\n     {\n-      error_at(expr->location(), \"cannot use _ as value\");\n+      go_error_at(expr->location(), \"cannot use _ as value\");\n       expr = Expression::make_error(expr->location());\n     }\n "}, {"sha": "e13dcc97545259b77db0419ea9d5037c9b5367bb", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -81,7 +81,8 @@ class Parse\n     Expression* expr;\n \n     Type_switch()\n-      : found(false), name(), location(UNKNOWN_LOCATION), expr(NULL)\n+        : found(false), name(), location(Linemap::unknown_location()),\n+          expr(NULL)\n     { }\n   };\n "}, {"sha": "390ad3a97b36e92f742d18dfe4389e9f0b0eaf18", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -7,6 +7,7 @@\n #include \"go-system.h\"\n \n #include \"go-c.h\"\n+#include \"go-diagnostics.h\"\n #include \"types.h\"\n #include \"expressions.h\"\n #include \"gogo.h\"\n@@ -163,7 +164,7 @@ Statement::set_is_error()\n void\n Statement::report_error(const char* msg)\n {\n-  error_at(this->location_, \"%s\", msg);\n+  go_error_at(this->location_, \"%s\", msg);\n   this->set_is_error();\n }\n \n@@ -428,9 +429,9 @@ Temporary_statement::do_check_types(Gogo*)\n       if (!Type::are_assignable(this->type_, this->init_->type(), &reason))\n \t{\n \t  if (reason.empty())\n-\t    error_at(this->location(), \"incompatible types in assignment\");\n+\t    go_error_at(this->location(), \"incompatible types in assignment\");\n \t  else\n-\t    error_at(this->location(), \"incompatible types in assignment (%s)\",\n+\t    go_error_at(this->location(), \"incompatible types in assignment (%s)\",\n \t\t     reason.c_str());\n \t  this->set_is_error();\n \t}\n@@ -767,10 +768,10 @@ Assignment_statement::do_check_types(Gogo*)\n   if (!Type::are_assignable(lhs_type, rhs_type, &reason))\n     {\n       if (reason.empty())\n-\terror_at(this->location(), \"incompatible types in assignment\");\n+\tgo_error_at(this->location(), \"incompatible types in assignment\");\n       else\n-\terror_at(this->location(), \"incompatible types in assignment (%s)\",\n-\t\t reason.c_str());\n+\tgo_error_at(this->location(), \"incompatible types in assignment (%s)\",\n+\t\t    reason.c_str());\n       this->set_is_error();\n     }\n \n@@ -2669,11 +2670,12 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n       else\n \t{\n \t  if (reason.empty())\n-\t    error_at(e->location(), \"incompatible type for return value %d\", i);\n+\t    go_error_at(e->location(),\n+\t\t\t\"incompatible type for return value %d\", i);\n \t  else\n-\t    error_at(e->location(),\n-\t\t     \"incompatible type for return value %d (%s)\",\n-\t\t     i, reason.c_str());\n+\t    go_error_at(e->location(),\n+\t\t\t\"incompatible type for return value %d (%s)\",\n+\t\t\ti, reason.c_str());\n \t}\n     }\n   go_assert(lhs->size() == rhs->size());\n@@ -2850,8 +2852,8 @@ Goto_statement::do_check_types(Gogo*)\n {\n   if (!this->label_->is_defined())\n     {\n-      error_at(this->location(), \"reference to undefined label %qs\",\n-\t       Gogo::message_name(this->label_->name()).c_str());\n+      go_error_at(this->location(), \"reference to undefined label %qs\",\n+\t\t  Gogo::message_name(this->label_->name()).c_str());\n       this->set_is_error();\n     }\n }\n@@ -3274,8 +3276,8 @@ Case_clauses::Case_clause::check_types(Type* type)\n \t  if (!Type::are_assignable(type, (*p)->type(), NULL)\n \t      && !Type::are_assignable((*p)->type(), type, NULL))\n \t    {\n-\t      error_at((*p)->location(),\n-\t\t       \"type mismatch between switch value and case clause\");\n+\t      go_error_at((*p)->location(),\n+\t\t\t  \"type mismatch between switch value and case clause\");\n \t      return false;\n \t    }\n \t}\n@@ -3338,7 +3340,7 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n \t  if (!ins.second)\n \t    {\n \t      // Value was already present.\n-\t      error_at(this->location_, \"duplicate case in switch\");\n+\t      go_error_at(this->location_, \"duplicate case in switch\");\n \t      e = Expression::make_error(this->location_);\n \t    }\n \t  cases->push_back(e->get_backend(context));\n@@ -3722,8 +3724,8 @@ Switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n       && !Type::are_compatible_for_comparison(true, this->val_->type(),\n \t\t\t\t\t      Type::make_nil_type(), NULL))\n     {\n-      error_at(this->val_->location(),\n-\t       \"cannot switch on value whose type that may not be compared\");\n+      go_error_at(this->val_->location(),\n+\t\t  \"cannot switch on value whose type that may not be compared\");\n       return Statement::make_error_statement(loc);\n     }\n \n@@ -3857,10 +3859,10 @@ Type_case_clauses::Type_case_clause::lower(Type* switch_val_type,\n \t\t\t\t\t\t\t\t      &reason))\n \t{\n \t  if (reason.empty())\n-\t    error_at(this->location_, \"impossible type switch case\");\n+\t    go_error_at(this->location_, \"impossible type switch case\");\n \t  else\n-\t    error_at(this->location_, \"impossible type switch case (%s)\",\n-\t\t     reason.c_str());\n+\t    go_error_at(this->location_, \"impossible type switch case (%s)\",\n+\t\t\treason.c_str());\n \t}\n \n       Expression* ref = Expression::make_temporary_reference(descriptor_temp,\n@@ -4025,7 +4027,7 @@ Type_case_clauses::check_duplicates() const\n \tt = Type::make_nil_type();\n       std::pair<Types_seen::iterator, bool> ins = types_seen.insert(t);\n       if (!ins.second)\n-\terror_at(p->location(), \"duplicate type in switch\");\n+\tgo_error_at(p->location(), \"duplicate type in switch\");\n     }\n }\n \n@@ -4255,7 +4257,7 @@ Send_statement::do_check_types(Gogo*)\n   Channel_type* channel_type = type->channel_type();\n   if (channel_type == NULL)\n     {\n-      error_at(this->location(), \"left operand of %<<-%> must be channel\");\n+      go_error_at(this->location(), \"left operand of %<<-%> must be channel\");\n       this->set_is_error();\n       return;\n     }\n@@ -4656,14 +4658,14 @@ Select_clauses::Select_clause::check_types()\n   Channel_type* ct = this->channel_->type()->channel_type();\n   if (ct == NULL)\n     {\n-      error_at(this->channel_->location(), \"expected channel\");\n+      go_error_at(this->channel_->location(), \"expected channel\");\n       return;\n     }\n \n   if (this->is_send_ && !ct->may_send())\n-    error_at(this->location(), \"invalid send on receive-only channel\");\n+    go_error_at(this->location(), \"invalid send on receive-only channel\");\n   else if (!this->is_send_ && !ct->may_receive())\n-    error_at(this->location(), \"invalid receive on send-only channel\");\n+    go_error_at(this->location(), \"invalid receive on send-only channel\");\n }\n \n // Whether this clause may fall through to the statement which follows"}, {"sha": "2d395d077baebefa2461ec1dbec253a853584126", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -1624,7 +1624,7 @@ class Case_clauses\n    public:\n     Case_clause()\n       : cases_(NULL), statements_(NULL), is_default_(false),\n-\tis_fallthrough_(false), location_(UNKNOWN_LOCATION)\n+\tis_fallthrough_(false), location_(Linemap::unknown_location())\n     { }\n \n     Case_clause(Expression_list* cases, bool is_default, Block* statements,\n@@ -1811,7 +1811,7 @@ class Type_case_clauses\n    public:\n     Type_case_clause()\n       : type_(NULL), statements_(NULL), is_default_(false),\n-\tlocation_(UNKNOWN_LOCATION)\n+\tlocation_(Linemap::unknown_location())\n     { }\n \n     Type_case_clause(Type* type, bool is_fallthrough, bool is_default,"}, {"sha": "01af8f33db6ba78c9a5ca1c0eaf95609c4a8899e", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bafc49a02cbff82b628e83c35e36d1872fdcc8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=56bafc49a02cbff82b628e83c35e36d1872fdcc8", "patch": "@@ -10,6 +10,7 @@\n \n #include \"go-c.h\"\n #include \"gogo.h\"\n+#include \"go-diagnostics.h\"\n #include \"operator.h\"\n #include \"expressions.h\"\n #include \"statements.h\"\n@@ -2594,12 +2595,13 @@ Type::backend_type_size(Gogo* gogo, int64_t *psize)\n   if (*psize == -1)\n     {\n       if (this->named_type() != NULL)\n-        error_at(this->named_type()->location(),\n-                 \"type %s larger than address space\",\n-                 Gogo::message_name(this->named_type()->name()).c_str());\n+\tgo_error_at(this->named_type()->location(),\n+\t\t \"type %s larger than address space\",\n+\t\t Gogo::message_name(this->named_type()->name()).c_str());\n       else\n-        error(\"type %s larger than address space\",\n-              this->reflection(gogo).c_str());\n+\tgo_error_at(Linemap::unknown_location(),\n+\t\t    \"type %s larger than address space\",\n+\t\t    this->reflection(gogo).c_str());\n \n       // Make this an error type to avoid knock-on errors.\n       this->classification_ = TYPE_ERROR;\n@@ -2663,7 +2665,7 @@ Type::import_type(Import* imp)\n     return Interface_type::do_import(imp);\n   else\n     {\n-      error_at(imp->location(), \"import error: expected type\");\n+      go_error_at(imp->location(), \"import error: expected type\");\n       return Type::make_error_type();\n     }\n }\n@@ -4751,13 +4753,13 @@ Struct_type::do_verify()\n \t{\n \t  if (t->named_type() != NULL && t->points_to() != NULL)\n \t    {\n-\t      error_at(p->location(), \"embedded type may not be a pointer\");\n+\t      go_error_at(p->location(), \"embedded type may not be a pointer\");\n \t      p->set_type(Type::make_error_type());\n \t    }\n \t  else if (t->points_to() != NULL\n \t\t   && t->points_to()->interface_type() != NULL)\n \t    {\n-\t      error_at(p->location(),\n+\t      go_error_at(p->location(),\n \t\t       \"embedded type may not be pointer to interface\");\n \t      p->set_type(Type::make_error_type());\n \t    }\n@@ -6116,7 +6118,7 @@ Array_type::verify_length()\n \n   if (!this->length_->is_constant())\n     {\n-      error_at(this->length_->location(), \"array bound is not constant\");\n+      go_error_at(this->length_->location(), \"array bound is not constant\");\n       return false;\n     }\n \n@@ -6125,9 +6127,9 @@ Array_type::verify_length()\n     {\n       if (this->length_->type()->integer_type() != NULL\n \t  || this->length_->type()->float_type() != NULL)\n-\terror_at(this->length_->location(), \"array bound is not constant\");\n+\tgo_error_at(this->length_->location(), \"array bound is not constant\");\n       else\n-\terror_at(this->length_->location(), \"array bound is not numeric\");\n+\tgo_error_at(this->length_->location(), \"array bound is not numeric\");\n       return false;\n     }\n \n@@ -6139,15 +6141,15 @@ Array_type::verify_length()\n     case Numeric_constant::NC_UL_VALID:\n       if (sizeof(val) >= tbits / 8 && val >> (tbits - 1) != 0)\n \t{\n-\t  error_at(this->length_->location(), \"array bound overflows\");\n+\t  go_error_at(this->length_->location(), \"array bound overflows\");\n \t  return false;\n \t}\n       break;\n     case Numeric_constant::NC_UL_NOTINT:\n-      error_at(this->length_->location(), \"array bound truncated to integer\");\n+      go_error_at(this->length_->location(), \"array bound truncated to integer\");\n       return false;\n     case Numeric_constant::NC_UL_NEGATIVE:\n-      error_at(this->length_->location(), \"negative array bound\");\n+      go_error_at(this->length_->location(), \"negative array bound\");\n       return false;\n     case Numeric_constant::NC_UL_BIG:\n       {\n@@ -6158,7 +6160,7 @@ Array_type::verify_length()\n \tmpz_clear(val);\n \tif (bits >= tbits)\n \t  {\n-\t    error_at(this->length_->location(), \"array bound overflows\");\n+\t    go_error_at(this->length_->location(), \"array bound overflows\");\n \t    return false;\n \t  }\n       }\n@@ -7040,7 +7042,7 @@ Map_type::do_verify()\n {\n   // The runtime support uses \"map[void]void\".\n   if (!this->key_type_->is_comparable() && !this->key_type_->is_void_type())\n-    error_at(this->location_, \"invalid map key type\");\n+    go_error_at(this->location_, \"invalid map key type\");\n   return true;\n }\n \n@@ -7173,14 +7175,14 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   int64_t keysize;\n   if (!this->key_type_->backend_type_size(gogo, &keysize))\n     {\n-      error_at(this->location_, \"error determining map key type size\");\n+      go_error_at(this->location_, \"error determining map key type size\");\n       return Expression::make_error(this->location_);\n     }\n \n   int64_t valsize;\n   if (!this->val_type_->backend_type_size(gogo, &valsize))\n     {\n-      error_at(this->location_, \"error determining map value type size\");\n+      go_error_at(this->location_, \"error determining map value type size\");\n       return Expression::make_error(this->location_);\n     }\n \n@@ -7835,7 +7837,7 @@ Interface_type::finalize_methods()\n       else if (this->find_method(p->name()) == NULL)\n \tthis->all_methods_->push_back(*p);\n       else\n-\terror_at(p->location(), \"duplicate method %qs\",\n+\tgo_error_at(p->location(), \"duplicate method %qs\",\n \t\t Gogo::message_name(p->name()).c_str());\n     }\n \n@@ -7852,14 +7854,14 @@ Interface_type::finalize_methods()\n       if (it == NULL)\n \t{\n \t  if (!t->is_error())\n-\t    error_at(tl, \"interface contains embedded non-interface\");\n+\t    go_error_at(tl, \"interface contains embedded non-interface\");\n \t  continue;\n \t}\n       if (it == this)\n \t{\n \t  if (!issued_recursive_error)\n \t    {\n-\t      error_at(tl, \"invalid recursive interface\");\n+\t      go_error_at(tl, \"invalid recursive interface\");\n \t      issued_recursive_error = true;\n \t    }\n \t  continue;\n@@ -7873,7 +7875,7 @@ Interface_type::finalize_methods()\n \t    {\n \t      if (*q == nt)\n \t\t{\n-\t\t  error_at(tl, \"inherited interface loop\");\n+\t\t  go_error_at(tl, \"inherited interface loop\");\n \t\t  break;\n \t\t}\n \t    }\n@@ -7895,7 +7897,7 @@ Interface_type::finalize_methods()\n \t    this->all_methods_->push_back(Typed_identifier(q->name(),\n \t\t\t\t\t\t\t   q->type(), tl));\n \t  else\n-\t    error_at(tl, \"inherited method %qs is ambiguous\",\n+\t    go_error_at(tl, \"inherited method %qs is ambiguous\",\n \t\t     Gogo::message_name(q->name()).c_str());\n \t}\n     }\n@@ -8045,8 +8047,8 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n \t      char buf[200];\n \t      snprintf(buf, sizeof buf,\n \t\t       _(\"need explicit conversion; missing method %s%s%s\"),\n-\t\t       open_quote, Gogo::message_name(p->name()).c_str(),\n-\t\t       close_quote);\n+\t\t       go_open_quote(), Gogo::message_name(p->name()).c_str(),\n+\t\t       go_close_quote());\n \t      reason->assign(buf);\n \t    }\n \t  return false;\n@@ -8062,11 +8064,11 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n \t      char* buf = new char[len];\n \t      if (subreason.empty())\n \t\tsnprintf(buf, len, _(\"incompatible type for method %s%s%s\"),\n-\t\t\t open_quote, n.c_str(), close_quote);\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote());\n \t      else\n \t\tsnprintf(buf, len,\n \t\t\t _(\"incompatible type for method %s%s%s (%s)\"),\n-\t\t\t open_quote, n.c_str(), close_quote,\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote(),\n \t\t\t subreason.c_str());\n \t      reason->assign(buf);\n \t      delete[] buf;\n@@ -8181,10 +8183,10 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n \t      char* buf = new char[len];\n \t      if (is_ambiguous)\n \t\tsnprintf(buf, len, _(\"ambiguous method %s%s%s\"),\n-\t\t\t open_quote, n.c_str(), close_quote);\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote());\n \t      else\n \t\tsnprintf(buf, len, _(\"missing method %s%s%s\"),\n-\t\t\t open_quote, n.c_str(), close_quote);\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote());\n \t      reason->assign(buf);\n \t      delete[] buf;\n \t    }\n@@ -8204,11 +8206,11 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n \t      char* buf = new char[len];\n \t      if (subreason.empty())\n \t\tsnprintf(buf, len, _(\"incompatible type for method %s%s%s\"),\n-\t\t\t open_quote, n.c_str(), close_quote);\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote());\n \t      else\n \t\tsnprintf(buf, len,\n \t\t\t _(\"incompatible type for method %s%s%s (%s)\"),\n-\t\t\t open_quote, n.c_str(), close_quote,\n+\t\t\t go_open_quote(), n.c_str(), go_close_quote(),\n \t\t\t subreason.c_str());\n \t      reason->assign(buf);\n \t      delete[] buf;\n@@ -8225,7 +8227,7 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n \t      char* buf = new char[len];\n \t      snprintf(buf, len,\n \t\t       _(\"method %s%s%s requires a pointer receiver\"),\n-\t\t       open_quote, n.c_str(), close_quote);\n+\t\t       go_open_quote(), n.c_str(), go_close_quote());\n \t      reason->assign(buf);\n \t      delete[] buf;\n \t    }\n@@ -8243,7 +8245,7 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n \t      char* buf = new char[len];\n \t      snprintf(buf, len,\n \t\t       _(\"method %s%s%s is marked go:nointerface\"),\n-\t\t       open_quote, n.c_str(), close_quote);\n+\t\t       go_open_quote(), n.c_str(), go_close_quote());\n \t      reason->assign(buf);\n \t      delete[] buf;\n \t    }\n@@ -9177,8 +9179,8 @@ Named_type::finalize_methods(Gogo* gogo)\n       for (Bindings::const_declarations_iterator p = lm->begin_declarations();\n \t   p != lm->end_declarations();\n \t   ++p)\n-\terror_at(p->second->location(),\n-\t\t \"invalid pointer or interface receiver type\");\n+\tgo_error_at(p->second->location(),\n+\t\t    \"invalid pointer or interface receiver type\");\n       delete this->local_methods_;\n       this->local_methods_ = NULL;\n       return;\n@@ -9335,8 +9337,8 @@ Named_type::do_verify()\n   Type::traverse(this->type_, &find);\n   if (find.found())\n     {\n-      error_at(this->location_, \"invalid recursive type %qs\",\n-\t       this->message_name().c_str());\n+      go_error_at(this->location_, \"invalid recursive type %qs\",\n+\t\t  this->message_name().c_str());\n       this->is_error_ = true;\n       return false;\n     }\n@@ -9358,9 +9360,9 @@ Named_type::do_verify()\n \t      const std::string& name(p->first);\n \t      if (st != NULL && st->find_local_field(name, NULL) != NULL)\n \t\t{\n-\t\t  error_at(p->second->location(),\n-\t\t\t   \"method %qs redeclares struct field name\",\n-\t\t\t   Gogo::message_name(name).c_str());\n+\t\t  go_error_at(p->second->location(),\n+\t\t\t      \"method %qs redeclares struct field name\",\n+\t\t\t      Gogo::message_name(name).c_str());\n \t\t}\n \t    }\n \t}\n@@ -10547,9 +10549,9 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \t  go_assert(m != NULL);\n \t  if (dereferenced)\n \t    {\n-\t      error_at(location,\n-\t\t       \"calling method %qs requires explicit dereference\",\n-\t\t       Gogo::message_name(name).c_str());\n+\t      go_error_at(location,\n+\t\t\t  \"calling method %qs requires explicit dereference\",\n+\t\t\t  Gogo::message_name(name).c_str());\n \t      return Expression::make_error(location);\n \t    }\n \t  if (!m->is_value_method() && expr->type()->points_to() == NULL)\n@@ -10566,16 +10568,16 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \t  // An error was already reported.\n \t}\n       else if (!ambig1.empty())\n-\terror_at(location, \"%qs is ambiguous via %qs and %qs\",\n-\t\t Gogo::message_name(name).c_str(), ambig1.c_str(),\n-\t\t ambig2.c_str());\n+\tgo_error_at(location, \"%qs is ambiguous via %qs and %qs\",\n+\t\t    Gogo::message_name(name).c_str(), ambig1.c_str(),\n+\t\t    ambig2.c_str());\n       else if (found_pointer_method)\n-\terror_at(location, \"method requires a pointer receiver\");\n+\tgo_error_at(location, \"method requires a pointer receiver\");\n       else if (nt == NULL && st == NULL && it == NULL)\n-\terror_at(location,\n-\t\t (\"reference to field %qs in object which \"\n-\t\t  \"has no fields or methods\"),\n-\t\t Gogo::message_name(name).c_str());\n+\tgo_error_at(location,\n+\t\t    (\"reference to field %qs in object which \"\n+\t\t     \"has no fields or methods\"),\n+\t\t    Gogo::message_name(name).c_str());\n       else\n \t{\n \t  bool is_unexported;\n@@ -10592,11 +10594,11 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \t\t\t\t\t\t\t\t  &seen);\n \t    }\n \t  if (is_unexported)\n-\t    error_at(location, \"reference to unexported field or method %qs\",\n-\t\t     Gogo::message_name(name).c_str());\n+\t    go_error_at(location, \"reference to unexported field or method %qs\",\n+\t\t\tGogo::message_name(name).c_str());\n \t  else\n-\t    error_at(location, \"reference to undefined field or method %qs\",\n-\t\t     Gogo::message_name(name).c_str());\n+\t    go_error_at(location, \"reference to undefined field or method %qs\",\n+\t\t\tGogo::message_name(name).c_str());\n \t}\n       return Expression::make_error(location);\n     }\n@@ -10945,9 +10947,9 @@ Forward_declaration_type::warn() const\n       // The name was not defined anywhere.\n       if (!this->warned_)\n \t{\n-\t  error_at(this->named_object_->location(),\n-\t\t   \"use of undefined type %qs\",\n-\t\t   no->message_name().c_str());\n+\t  go_error_at(this->named_object_->location(),\n+\t\t      \"use of undefined type %qs\",\n+\t\t      no->message_name().c_str());\n \t  this->warned_ = true;\n \t}\n     }\n@@ -10956,9 +10958,9 @@ Forward_declaration_type::warn() const\n       // The name was seen as a type, but the type was never defined.\n       if (no->type_declaration_value()->using_type())\n \t{\n-\t  error_at(this->named_object_->location(),\n-\t\t   \"use of undefined type %qs\",\n-\t\t   no->message_name().c_str());\n+\t  go_error_at(this->named_object_->location(),\n+\t\t      \"use of undefined type %qs\",\n+\t\t      no->message_name().c_str());\n \t  this->warned_ = true;\n \t}\n     }\n@@ -10967,7 +10969,7 @@ Forward_declaration_type::warn() const\n       // The name was defined, but not as a type.\n       if (!this->warned_)\n \t{\n-\t  error_at(this->named_object_->location(), \"expected type\");\n+\t  go_error_at(this->named_object_->location(), \"expected type\");\n \t  this->warned_ = true;\n \t}\n     }"}]}