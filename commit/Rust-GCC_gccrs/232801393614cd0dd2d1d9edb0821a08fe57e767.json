{"sha": "232801393614cd0dd2d1d9edb0821a08fe57e767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMyODAxMzkzNjE0Y2QwZGQyZDFkOWVkYjA4MjFhMDhmZTU3ZTc2Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-27T20:23:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-27T20:23:15Z"}, "message": "Makefile.in (recog.o): Don't depend on resource.h.\n\n\t* Makefile.in (recog.o): Don't depend on resource.h.\n\t* recog.c: Don't include resource.h.\n\t(recog_last_allowed_insn): Remove.\n\t(recog_next_insn): Remove.\n\t(struct peep2_insn_data): New.\n\t(peep2_insn_data, peep2_current): New.\n\t(peep2_next_insn): New.\n\t(peep2_regno_dead_p, peep2_reg_dead_p): New.\n\t(peep2_find_free_register): New.\n\t(peephole2_optimize): Track life information by insn as we go.\n\t* recog.h: Update declarations.\n\t* resource.c (find_free_register, reg_dead_p): Remove.\n\t* resource.h: Remove their declarations.\n\t* toplev.c: Include hard-reg-set.h before recog.h.\n\n\t* genconfig.c (max_insns_per_peep2): New.\n\t(gen_peephole2): New.\n\t(main): Call it.\n\t* genemit.c (output_peephole2_scratches): Generate calls to\n\tpeep2_find_free_register; adjust surrounding code.\n\t(main): Have insn-emit.c include hard-reg-set.h before recog.h.\n\t* genrecog.c (change_state): Don't track last_insn.\n\t(write_action): Write into *_pmatch_len before accepting.\n\t(write_tree): Adjust peephole2_insns and subroutines to match.\n\n\t* config/i386/i386.md (all peepholes): Use peep2_regno_dead_p.\n\nFrom-SVN: r34208", "tree": {"sha": "2a3db5cb69837af35662b42fa3a1b95b877158ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a3db5cb69837af35662b42fa3a1b95b877158ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/232801393614cd0dd2d1d9edb0821a08fe57e767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/232801393614cd0dd2d1d9edb0821a08fe57e767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/232801393614cd0dd2d1d9edb0821a08fe57e767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/232801393614cd0dd2d1d9edb0821a08fe57e767/comments", "author": null, "committer": null, "parents": [{"sha": "30196c1ff4ff35c7d46be079c0b6466e9203a784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30196c1ff4ff35c7d46be079c0b6466e9203a784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30196c1ff4ff35c7d46be079c0b6466e9203a784"}], "stats": {"total": 623, "additions": 408, "deletions": 215}, "files": [{"sha": "b8c478e72e39f4494bfc0be134a3f8e067f5dba4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -1,3 +1,32 @@\n+2000-05-27  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (recog.o): Don't depend on resource.h.\n+\t* recog.c: Don't include resource.h.\n+\t(recog_last_allowed_insn): Remove.\n+\t(recog_next_insn): Remove.\n+\t(struct peep2_insn_data): New.\n+\t(peep2_insn_data, peep2_current): New.\n+\t(peep2_next_insn): New.\n+\t(peep2_regno_dead_p, peep2_reg_dead_p): New.\n+\t(peep2_find_free_register): New.\n+\t(peephole2_optimize): Track life information by insn as we go.\n+\t* recog.h: Update declarations.\n+\t* resource.c (find_free_register, reg_dead_p): Remove.\n+\t* resource.h: Remove their declarations.\n+\t* toplev.c: Include hard-reg-set.h before recog.h.\n+\n+\t* genconfig.c (max_insns_per_peep2): New.\n+\t(gen_peephole2): New.\n+\t(main): Call it.\n+\t* genemit.c (output_peephole2_scratches): Generate calls to\n+\tpeep2_find_free_register; adjust surrounding code.\n+\t(main): Have insn-emit.c include hard-reg-set.h before recog.h.\n+\t* genrecog.c (change_state): Don't track last_insn.\n+\t(write_action): Write into *_pmatch_len before accepting.\n+\t(write_tree): Adjust peephole2_insns and subroutines to match.\n+\n+\t* config/i386/i386.md (all peepholes): Use peep2_regno_dead_p.\n+\n 2000-05-27  Richard Henderson  <rth@cygnus.com>\n \n \t* function.c (thread_prologue_epilogue_insns): Don't move the"}, {"sha": "5456c473fe73aee3863d2fa4de3b73bca53f554f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -1382,7 +1382,7 @@ final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    dbxout.h $(BASIC_BLOCK_H)\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n-   insn-flags.h insn-codes.h real.h toplev.h output.h resource.h \n+   insn-flags.h insn-codes.h real.h toplev.h output.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) $(RECOG_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n    varray.h function.h"}, {"sha": "cdadf5d0e71e4b8f3c301571fdae9bf7dd9a3332", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -9591,10 +9591,11 @@\n   [(match_scratch:SI 1 \"r\")\n    (set (match_operand:SI 0 \"memory_operand\" \"\")\n         (const_int 0))]\n-  \"! optimize_size && get_attr_length (insn) >= ix86_cost->large_insn\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+  \"! optimize_size\n    && ! TARGET_USE_MOV0\n-   && TARGET_SPLIT_LONG_MOVES\"\n+   && TARGET_SPLIT_LONG_MOVES\n+   && get_attr_length (insn) >= ix86_cost->large_insn\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 1) (const_int 0))\n \t      (clobber (reg:CC 17))])\n    (set (match_dup 0) (match_dup 1))]\n@@ -9604,10 +9605,11 @@\n   [(match_scratch:HI 1 \"r\")\n    (set (match_operand:HI 0 \"memory_operand\" \"\")\n         (const_int 0))]\n-  \"! optimize_size && get_attr_length (insn) >= ix86_cost->large_insn\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+  \"! optimize_size\n    && ! TARGET_USE_MOV0\n-   && TARGET_SPLIT_LONG_MOVES\"\n+   && TARGET_SPLIT_LONG_MOVES\n+   && get_attr_length (insn) >= ix86_cost->large_insn\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 2) (const_int 0))\n \t      (clobber (reg:CC 17))])\n    (set (match_dup 0) (match_dup 1))]\n@@ -9617,10 +9619,11 @@\n   [(match_scratch:QI 1 \"q\")\n    (set (match_operand:QI 0 \"memory_operand\" \"\")\n         (const_int 0))]\n-  \"! optimize_size && get_attr_length (insn) >= ix86_cost->large_insn\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+  \"! optimize_size\n    && ! TARGET_USE_MOV0\n-   && TARGET_SPLIT_LONG_MOVES\"\n+   && TARGET_SPLIT_LONG_MOVES\n+   && get_attr_length (insn) >= ix86_cost->large_insn\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 2) (const_int 0))\n \t      (clobber (reg:CC 17))])\n    (set (match_dup 0) (match_dup 1))]\n@@ -9630,8 +9633,9 @@\n   [(match_scratch:SI 2 \"r\")\n    (set (match_operand:SI 0 \"memory_operand\" \"\")\n         (match_operand:SI 1 \"immediate_operand\" \"\"))]\n-  \"! optimize_size && get_attr_length (insn) >= ix86_cost->large_insn\n-  && TARGET_SPLIT_LONG_MOVES\"\n+  \"! optimize_size\n+   && get_attr_length (insn) >= ix86_cost->large_insn\n+   && TARGET_SPLIT_LONG_MOVES\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n@@ -9675,14 +9679,14 @@\n ;; represented using a modRM byte.  The XOR replacement is long decoded,\n ;; so this split helps here as well.\n ;;\n-;; Note: Can't do this as a regular split because reg_dead_p assumes\n-;; resource info is live.\n+;; Note: Can't do this as a regular split because we can't get proper\n+;; lifetime information then.\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")))]\n   \"!optimize_size\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+   && peep2_regno_dead_p (0, FLAGS_REG)\n    && ((TARGET_PENTIUM \n         && (GET_CODE (operands[0]) != MEM\n             || !memory_displacement_operand (operands[0], SImode)))\n@@ -9696,7 +9700,7 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))]\n   \"!optimize_size\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+   && peep2_regno_dead_p (0, FLAGS_REG)\n    && ((TARGET_PENTIUM \n         && (GET_CODE (operands[0]) != MEM\n             || !memory_displacement_operand (operands[0], HImode)))\n@@ -9710,7 +9714,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n   \"!optimize_size\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\n+   && peep2_regno_dead_p (0, FLAGS_REG)\n    && ((TARGET_PENTIUM \n         && (GET_CODE (operands[0]) != MEM\n             || !memory_displacement_operand (operands[0], QImode)))\n@@ -9873,7 +9877,7 @@\n     || GET_MODE (operands[0]) == HImode\n     || GET_MODE (operands[0]) == SImode)\n    && (! TARGET_USE_MOV0 || optimize_size)\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int 0))\n \t      (clobber (reg:CC 17))])]\n   \"operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]));\")\n@@ -9885,7 +9889,7 @@\n   \"(GET_MODE (operands[0]) == HImode\n     || GET_MODE (operands[0]) == SImode)\n    && (optimize_size || TARGET_PENTIUM)\n-   && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int -1))\n \t      (clobber (reg:CC 17))])]\n   \"operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]));\")\n@@ -9896,7 +9900,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n   \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n+  \"peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n   \"\")\n@@ -9905,7 +9909,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n   \t(mult:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"immediate_operand\" \"\")))]\n-  \"reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n+  \"exact_log2 (INTVAL (operands[1])) >= 0\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")"}, {"sha": "e7964aba680363020c51f702ee58f947efc2b4b8", "filename": "gcc/genconfig.c", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -42,6 +42,9 @@ static int have_peephole2_flag;\n /* Maximum number of insns seen in a split.  */\n static int max_insns_per_split = 1;\n \n+/* Maximum number of input insns for peephole2.  */\n+static int max_insns_per_peep2;\n+\n static int clobbers_seen_this_insn;\n static int dup_operands_seen_this_insn;\n \n@@ -239,6 +242,26 @@ gen_peephole (peep)\n     walk_insn_part (XVECEXP (peep, 0, i), 1, 0);\n }\n \n+static void\n+gen_peephole2 (peep)\n+     rtx peep;\n+{\n+  int i, n;\n+\n+  /* Look through the patterns that are matched\n+     to compute the maximum operand number.  */\n+  for (i = XVECLEN (peep, 0) - 1; i >= 0; --i)\n+    walk_insn_part (XVECEXP (peep, 0, i), 1, 0);\n+\n+  /* Look at the number of insns this insn can be matched from.  */\n+  for (i = XVECLEN (peep, 0) - 1, n = 0; i >= 0; --i)\n+    if (GET_CODE (XVECEXP (peep, 0, i)) != MATCH_DUP\n+\t&& GET_CODE (XVECEXP (peep, 0, i)) != MATCH_SCRATCH)\n+      n++;\n+  if (n > max_insns_per_peep2)\n+    max_insns_per_peep2 = n;\n+}\n+\n extern int main PARAMS ((int, char **));\n \n int\n@@ -289,7 +312,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n \t  case DEFINE_PEEPHOLE2:\n \t    have_peephole2_flag = 1;\n-\t    gen_split (desc);\n+\t    gen_peephole2 (desc);\n \t    break;\n \n \t  case DEFINE_PEEPHOLE:\n@@ -302,9 +325,8 @@ from the machine description file `md'.  */\\n\\n\");\n \t}\n     }\n \n-  printf (\"\\n#define MAX_RECOG_OPERANDS %d\\n\", max_recog_operands + 1);\n-\n-  printf (\"\\n#define MAX_DUP_OPERANDS %d\\n\", max_dup_operands);\n+  printf (\"#define MAX_RECOG_OPERANDS %d\\n\", max_recog_operands + 1);\n+  printf (\"#define MAX_DUP_OPERANDS %d\\n\", max_dup_operands);\n \n   /* This is conditionally defined, in case the user writes code which emits\n      more splits than we can readily see (and knows s/he does it).  */\n@@ -328,7 +350,10 @@ from the machine description file `md'.  */\\n\\n\");\n     printf (\"#define HAVE_peephole 1\\n\");\n \n   if (have_peephole2_flag)\n-    printf (\"#define HAVE_peephole2 1\\n\");\n+    {\n+      printf (\"#define HAVE_peephole2 1\\n\");\n+      printf (\"#define MAX_INSNS_PER_PEEP2 %d\\n\", max_insns_per_peep2);\n+    }\n \n   fflush (stdout);\n   return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}, {"sha": "54793d46a470b10b2bbc23421c85ba233c27a12e", "filename": "gcc/genemit.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -699,10 +699,7 @@ output_peephole2_scratches (split)\n   int i;\n   int insn_nr = 0;\n \n-  printf (\"  rtx first_insn ATTRIBUTE_UNUSED;\\n\");\n-  printf (\"  rtx last_insn ATTRIBUTE_UNUSED;\\n\");\n   printf (\"  HARD_REG_SET _regs_allocated;\\n\");\n-\n   printf (\"  CLEAR_HARD_REG_SET (_regs_allocated);\\n\");\n \n   for (i = 0; i < XVECLEN (split, 0); i++)\n@@ -721,15 +718,11 @@ output_peephole2_scratches (split)\n \t      }\n \t    else if (GET_CODE (XVECEXP (split, 0, j)) != MATCH_SCRATCH)\n \t      cur_insn_nr++;\n-\t  printf (\"  first_insn = recog_next_insn (curr_insn, %d);\\n\", insn_nr);\n-\t  if (last_insn_nr > insn_nr)\n-\t    printf (\"  last_insn = recog_next_insn (curr_insn, %d);\\n\",\n-\t\t    last_insn_nr - 1);\n-\t  else\n-\t    printf (\"  last_insn = 0;\\n\");\n-\t  printf (\"  if ((operands[%d] = find_free_register (first_insn, last_insn, \\\"%s\\\", %smode, &_regs_allocated)) == NULL_RTX)\\n\\\n+\n+\t  printf (\"  if ((operands[%d] = peep2_find_free_register (%d, %d, \\\"%s\\\", %smode, &_regs_allocated)) == NULL_RTX)\\n\\\n     return NULL;\\n\", \n \t\t  XINT (elt, 0),\n+\t\t  insn_nr, last_insn_nr,\n \t\t  XSTR (elt, 1),\n \t\t  GET_MODE_NAME (GET_MODE (elt)));\n \n@@ -777,8 +770,8 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"insn-config.h\\\"\\n\");\n   printf (\"#include \\\"insn-flags.h\\\"\\n\");\n   printf (\"#include \\\"insn-codes.h\\\"\\n\");\n-  printf (\"#include \\\"recog.h\\\"\\n\");\n   printf (\"#include \\\"hard-reg-set.h\\\"\\n\");\n+  printf (\"#include \\\"recog.h\\\"\\n\");\n   printf (\"#include \\\"resource.h\\\"\\n\");\n   printf (\"#include \\\"reload.h\\\"\\n\\n\");\n   printf (\"#define FAIL return (end_sequence (), _val)\\n\");"}, {"sha": "b955eb0614949f1699496c838caa9b445881009d", "filename": "gcc/genrecog.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -272,8 +272,8 @@ static struct decision *write_switch\n static void write_cond\n   PARAMS ((struct decision_test *, int, enum routine_type));\n static void write_action\n-  PARAMS ((struct decision_test *, int, int, struct decision *,\n-\t enum routine_type));\n+  PARAMS ((struct decision *, struct decision_test *, int, int,\n+\t   struct decision *, enum routine_type));\n static int is_unconditional\n   PARAMS ((struct decision_test *, enum routine_type));\n static int write_node\n@@ -1578,10 +1578,6 @@ change_state (oldpos, newpos, afterward, indent)\n     if (newpos[new_has_insn] >= 'A' && newpos[new_has_insn] <= 'Z')\n       break;\n \n-  /* Make sure to reset the last_insn pointer when popping back up.  */\n-  if (old_has_insn >= 0 && new_has_insn < 0)\n-    printf (\"%slast_insn = insn;\\n\", indent);\n-\n   /* Go down to desired level.  */\n   while (depth < ndepth)\n     {\n@@ -1591,21 +1587,20 @@ change_state (oldpos, newpos, afterward, indent)\n \t  /* We can only fail if we're moving down the tree.  */\n \t  if (old_has_insn >= 0 && oldpos[old_has_insn] >= newpos[depth])\n \t    {\n-\t      printf (\"%slast_insn = recog_next_insn (insn, %d);\\n\", \n+\t      printf (\"%stem = peep2_next_insn (%d);\\n\", \n \t\t      indent, newpos[depth] - 'A');\n \t    }\n \t  else\n \t    {\n-\t      printf (\"%stem = recog_next_insn (insn, %d);\\n\", \n+\t      printf (\"%stem = peep2_next_insn (%d);\\n\", \n \t\t      indent, newpos[depth] - 'A');\n \t      printf (\"%sif (tem == NULL_RTX)\\n\", indent);\n \t      if (afterward)\n \t\tprintf (\"%s  goto L%d;\\n\", indent, afterward->number);\n \t      else\n \t\tprintf (\"%s  goto ret0;\\n\", indent);\n-\t      printf (\"%slast_insn = tem;\\n\", indent);\n \t    }\n-\t  printf (\"%sx%d = PATTERN (last_insn);\\n\", indent, depth + 1);\n+\t  printf (\"%sx%d = PATTERN (tem);\\n\", indent, depth + 1);\n \t}\n       else if (newpos[depth] >= 'a' && newpos[depth] <= 'z')\n \tprintf (\"%sx%d = XVECEXP (x%d, 0, %d);\\n\",\n@@ -1888,7 +1883,8 @@ write_cond (p, depth, subroutine_type)\n    perform a state change.  For the `accept' tests we must do more work.  */\n \n static void\n-write_action (test, depth, uncond, success, subroutine_type)\n+write_action (p, test, depth, uncond, success, subroutine_type)\n+     struct decision *p;\n      struct decision_test *test;\n      int depth, uncond;\n      struct decision *success;\n@@ -1942,9 +1938,20 @@ write_action (test, depth, uncond, success, subroutine_type)\n \t  break;\n \n \tcase PEEPHOLE2:\n-\t  printf (\"%stem = gen_peephole2_%d (insn, operands);\\n\",\n-\t\t  indent, test->u.insn.code_number);\n-\t  printf (\"%sif (tem != 0)\\n%s  goto ret1;\\n\", indent, indent);\n+\t  {\n+\t    int match_len = 0, i;\n+\n+\t    for (i = strlen (p->position) - 1; i >= 0; --i)\n+\t      if (p->position[i] >= 'A' && p->position[i] <= 'Z')\n+\t\t{\n+\t\t  match_len = p->position[i] - 'A';\n+\t\t  break;\n+\t\t}\n+\t    printf (\"%s*_pmatch_len = %d;\\n\", indent, match_len);\n+\t    printf (\"%stem = gen_peephole2_%d (insn, operands);\\n\",\n+\t\t    indent, test->u.insn.code_number);\n+\t    printf (\"%sif (tem != 0)\\n%s  return tem;\\n\", indent, indent);\n+\t  }\n \t  break;\n \n \tdefault:\n@@ -2027,7 +2034,7 @@ write_node (p, depth, subroutine_type)\n       printf (\")\\n\");\n     }\n \n-  write_action (last_test, depth, uncond, p->success.first, subroutine_type);\n+  write_action (p, last_test, depth, uncond, p->success.first, subroutine_type);\n \n   return uncond > 0;\n }\n@@ -2090,7 +2097,7 @@ write_tree (head, prevpos, type, initial)\n       };\n \n       static const char * const call_suffix[] = {\n-\t  \", pnum_clobbers\", \"\", \", _plast_insn\"\n+\t  \", pnum_clobbers\", \"\", \", _pmatch_len\"\n       };\n \n       /* This node has been broken out into a separate subroutine.\n@@ -2167,30 +2174,27 @@ split%s (x0, insn)\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     case PEEPHOLE2:\n-      printf (\"%srtx peephole2%s PARAMS ((rtx, rtx, rtx *));\\n\", s_or_e, extension);\n+      printf (\"%srtx peephole2%s PARAMS ((rtx, rtx, int *));\\n\",\n+\t      s_or_e, extension);\n       printf (\"%srtx\\n\\\n-peephole2%s (x0, insn, _plast_insn)\\n\\\n+peephole2%s (x0, insn, _pmatch_len)\\n\\\n      register rtx x0;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\\\n-     rtx *_plast_insn ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n+     int *_pmatch_len ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     }\n \n   printf (\"{\\n  register rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\\n\");\n   for (i = 1; i <= max_depth; i++)\n     printf (\"  register rtx x%d ATTRIBUTE_UNUSED;\\n\", i);\n \n-  if (type == PEEPHOLE2)\n-    printf (\"  register rtx last_insn = insn;\\n\");\n   printf (\"  %s tem ATTRIBUTE_UNUSED;\\n\", IS_SPLIT (type) ? \"rtx\" : \"int\");\n \n   if (head->first)\n     write_tree (head, \"\", type, 1);\n   else\n     printf (\"  goto ret0;\\n\");\n \n-  if (type == PEEPHOLE2)\n-    printf (\" ret1:\\n  *_plast_insn = last_insn;\\n  return tem;\\n\");\n   printf (\" ret0:\\n  return %d;\\n}\\n\\n\", IS_SPLIT (type) ? 0 : -1);\n }\n "}, {"sha": "876004129ded1bf3973ca9d6e5700032f9713cd5", "filename": "gcc/recog.c", "status": "modified", "additions": 282, "deletions": 43, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -37,7 +37,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n-#include \"resource.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -2682,100 +2681,340 @@ split_all_insns (upd_life)\n }\n \f\n #ifdef HAVE_peephole2\n-/* This is the last insn we'll allow recog_next_insn to consider.  */\n-static rtx recog_last_allowed_insn;\n+struct peep2_insn_data\n+{\n+  rtx insn;\n+  regset live_before;\n+};\n+\n+static struct peep2_insn_data peep2_insn_data[MAX_INSNS_PER_PEEP2 + 1];\n+static int peep2_current;\n+\n+/* A non-insn marker indicating the last insn of the block.\n+   The live_before regset for this element is correct, indicating\n+   global_live_at_end for the block.  */\n+#define PEEP2_EOB\tpc_rtx\n+\n+/* Return the Nth non-note insn after `current', or return NULL_RTX if it\n+   does not exist.  Used by the recognizer to find the next insn to match\n+   in a multi-insn pattern.  */\n \n-/* Return the Nth non-note insn after INSN, or return NULL_RTX if it does\n-   not exist.  Used by the recognizer to find the next insn to match in a\n-   multi-insn pattern.  */\n rtx\n-recog_next_insn (insn, n)\n-     rtx insn;\n+peep2_next_insn (n)\n      int n;\n {\n-  if (insn != NULL_RTX)\n+  if (n >= MAX_INSNS_PER_PEEP2 + 1)\n+    abort ();\n+\n+  n += peep2_current;\n+  if (n >= MAX_INSNS_PER_PEEP2 + 1)\n+    n -= MAX_INSNS_PER_PEEP2 + 1;\n+\n+  if (peep2_insn_data[n].insn == PEEP2_EOB)\n+    return NULL_RTX;\n+  return peep2_insn_data[n].insn;\n+}\n+\n+/* Return true if REGNO is dead before the Nth non-note insn\n+   after `current'.  */\n+\n+int\n+peep2_regno_dead_p (ofs, regno)\n+     int ofs;\n+     int regno;\n+{\n+  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n+    abort ();\n+\n+  ofs += peep2_current;\n+  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n+    ofs -= MAX_INSNS_PER_PEEP2 + 1;\n+\n+  if (peep2_insn_data[ofs].insn == NULL_RTX)\n+    abort ();\n+\n+  return ! REGNO_REG_SET_P (peep2_insn_data[ofs].live_before, regno);\n+}\n+\n+/* Similarly for a REG.  */\n+\n+int\n+peep2_reg_dead_p (ofs, reg)\n+     int ofs;\n+     rtx reg;\n+{\n+  int regno, n;\n+\n+  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n+    abort ();\n+\n+  ofs += peep2_current;\n+  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n+    ofs -= MAX_INSNS_PER_PEEP2 + 1;\n+\n+  if (peep2_insn_data[ofs].insn == NULL_RTX)\n+    abort ();\n+\n+  regno = REGNO (reg);\n+  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+  while (--n >= 0)\n+    if (REGNO_REG_SET_P (peep2_insn_data[ofs].live_before, regno + n))\n+      return 0;\n+  return 1;\n+}\n+\n+/* Try to find a hard register of mode MODE, matching the register class in\n+   CLASS_STR, which is available at the beginning of insn CURRENT_INSN and\n+   remains available until the end of LAST_INSN.  LAST_INSN may be NULL_RTX,\n+   in which case the only condition is that the register must be available\n+   before CURRENT_INSN.\n+   Registers that already have bits set in REG_SET will not be considered.\n+\n+   If an appropriate register is available, it will be returned and the\n+   corresponding bit(s) in REG_SET will be set; otherwise, NULL_RTX is\n+   returned.  */\n+\n+rtx\n+peep2_find_free_register (from, to, class_str, mode, reg_set)\n+     int from, to;\n+     const char *class_str;\n+     enum machine_mode mode;\n+     HARD_REG_SET *reg_set;\n+{\n+  static int search_ofs;\n+  enum reg_class class;\n+  HARD_REG_SET live;\n+  int i;\n+\n+  if (from >= MAX_INSNS_PER_PEEP2 + 1 || to >= MAX_INSNS_PER_PEEP2 + 1)\n+    abort ();\n+\n+  from += peep2_current;\n+  if (from >= MAX_INSNS_PER_PEEP2 + 1)\n+    from -= MAX_INSNS_PER_PEEP2 + 1;\n+  to += peep2_current;\n+  if (to >= MAX_INSNS_PER_PEEP2 + 1)\n+    to -= MAX_INSNS_PER_PEEP2 + 1;\n+\n+  if (peep2_insn_data[from].insn == NULL_RTX)\n+    abort ();\n+  REG_SET_TO_HARD_REG_SET (live, peep2_insn_data[from].live_before);\n+\n+  while (from != to)\n     {\n-      while (n > 0)\n+      HARD_REG_SET this_live;\n+\n+      if (++from >= MAX_INSNS_PER_PEEP2 + 1)\n+\tfrom = 0;\n+      if (peep2_insn_data[from].insn == NULL_RTX)\n+\tabort ();\n+      REG_SET_TO_HARD_REG_SET (this_live, peep2_insn_data[from].live_before);\n+      IOR_HARD_REG_SET (live, this_live);\n+    }\n+\n+  class = (class_str[0] == 'r' ? GENERAL_REGS\n+\t   : REG_CLASS_FROM_LETTER (class_str[0]));\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int raw_regno, regno, success, j;\n+\n+      /* Distribute the free registers as much as possible.  */\n+      raw_regno = search_ofs + i;\n+      if (raw_regno >= FIRST_PSEUDO_REGISTER)\n+\traw_regno -= FIRST_PSEUDO_REGISTER;\n+#ifdef REG_ALLOC_ORDER\n+      regno = reg_alloc_order[raw_regno];\n+#else\n+      regno = raw_regno;\n+#endif\n+\n+      /* Don't allocate fixed registers.  */\n+      if (fixed_regs[regno])\n+\tcontinue;\n+      /* Make sure the register is of the right class.  */\n+      if (! TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n+\tcontinue;\n+      /* And can support the mode we need.  */\n+      if (! HARD_REGNO_MODE_OK (regno, mode))\n+\tcontinue;\n+      /* And that we don't create an extra save/restore.  */\n+      if (! call_used_regs[regno] && ! regs_ever_live[regno])\n+\tcontinue;\n+      /* And we don't clobber traceback for noreturn functions.  */\n+      if ((regno == FRAME_POINTER_REGNUM || regno == HARD_FRAME_POINTER_REGNUM)\n+\t  && (! reload_completed || frame_pointer_needed))\n+\tcontinue;\n+\n+      success = 1;\n+      for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n+\t{\n+\t  if (TEST_HARD_REG_BIT (*reg_set, regno + j)\n+\t      || TEST_HARD_REG_BIT (live, regno + j))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\t}\n+      if (success)\n \t{\n-\t  if (insn == recog_last_allowed_insn)\n-\t    return NULL_RTX;\n+\t  for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n+\t    SET_HARD_REG_BIT (*reg_set, regno + j);\n \n-\t  insn = NEXT_INSN (insn);\n-\t  if (insn == NULL_RTX)\n-\t    break;\n+\t  /* Start the next search with the next register.  */\n+\t  if (++raw_regno >= FIRST_PSEUDO_REGISTER)\n+\t    raw_regno = 0;\n+\t  search_ofs = raw_regno;\n \n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    n -= 1;\n+\t  return gen_rtx_REG (mode, regno);\n \t}\n     }\n \n-  return insn;\n+  search_ofs = 0;\n+  return NULL_RTX;\n }\n \n /* Perform the peephole2 optimization pass. */\n+\n void\n peephole2_optimize (dump_file)\n      FILE *dump_file ATTRIBUTE_UNUSED;\n {\n+  regset_head rs_heads[MAX_INSNS_PER_PEEP2 + 2];\n   rtx insn, prev;\n-  int i, changed;\n+  regset live;\n+  int i, b;\n+#ifdef HAVE_conditional_execution\n   sbitmap blocks;\n+  int changed;\n+#endif\n \n-  /* ??? TODO: Arrange with resource.c to start at bb->global_live_at_end\n-     and backtrack insn by insn as we proceed through the block.  In this\n-     way we'll not need to keep searching forward from the beginning of \n-     basic blocks to find register life info.  */\n-\n-  init_resource_info (NULL);\n+  /* Initialize the regsets we're going to use.  */\n+  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n+    peep2_insn_data[i].live_before = INITIALIZE_REG_SET (rs_heads[i]);\n+  live = INITIALIZE_REG_SET (rs_heads[i]);\n \n+#ifdef HAVE_conditional_execution\n   blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (blocks);\n   changed = 0;\n+#else\n+  count_or_remove_death_notes (NULL, 1);\n+#endif\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  for (b = n_basic_blocks - 1; b >= 0; --b)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n+      basic_block bb = BASIC_BLOCK (b);\n+      struct propagate_block_info *pbi;\n+\n+      /* Indicate that all slots except the last holds invalid data.  */\n+      for (i = 0; i < MAX_INSNS_PER_PEEP2; ++i)\n+\tpeep2_insn_data[i].insn = NULL_RTX;\n+\n+      /* Indicate that the last slot contains live_after data.  */\n+      peep2_insn_data[MAX_INSNS_PER_PEEP2].insn = PEEP2_EOB;\n+      peep2_current = MAX_INSNS_PER_PEEP2;\n \n-      /* Since we don't update life info until the very end, we can't\n-\t allow matching instructions that we've replaced before.  Walk\n-\t backward through the basic block so that we don't have to \n-\t care about subsequent life info; recog_last_allowed_insn to\n-\t restrict how far forward we will allow the match to proceed.  */\n+      /* Start up propagation.  */\n+      COPY_REG_SET (live, bb->global_live_at_end);\n+      COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n+\n+#ifdef HAVE_conditional_execution\n+      pbi = init_propagate_block_info (bb, live, NULL, 0);\n+#else\n+      pbi = init_propagate_block_info (bb, live, NULL, PROP_DEATH_NOTES);\n+#endif\n \n-      recog_last_allowed_insn = NEXT_INSN (bb->end);\n       for (insn = bb->end; ; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      rtx try, last_insn;\n-\n-\t      try = peephole2_insns (PATTERN (insn), insn, &last_insn);\n+\t      rtx try;\n+\t      int match_len;\n+\n+\t      /* Record this insn.  */\n+\t      if (--peep2_current < 0)\n+\t\tpeep2_current = MAX_INSNS_PER_PEEP2;\n+\t      peep2_insn_data[peep2_current].insn = insn;\n+\t      propagate_one_insn (pbi, insn);\n+\t      COPY_REG_SET (peep2_insn_data[peep2_current].live_before, live);\n+\n+\t      /* Match the peephole.  */\n+\t      try = peephole2_insns (PATTERN (insn), insn, &match_len);\n \t      if (try != NULL)\n \t\t{\n-\t\t  flow_delete_insn_chain (insn, last_insn);\n+\t\t  i = match_len + peep2_current;\n+\t\t  if (i >= MAX_INSNS_PER_PEEP2 + 1)\n+\t\t    i -= MAX_INSNS_PER_PEEP2 + 1;\n+\n+\t\t  /* Replace the old sequence with the new.  */\n+\t\t  flow_delete_insn_chain (insn, peep2_insn_data[i].insn);\n \t\t  try = emit_insn_after (try, prev);\n \n-\t\t  if (last_insn == bb->end)\n+\t\t  /* Adjust the basic block boundaries.  */\n+\t\t  if (peep2_insn_data[i].insn == bb->end)\n \t\t    bb->end = try;\n \t\t  if (insn == bb->head)\n \t\t    bb->head = NEXT_INSN (prev);\n \n-\t\t  recog_last_allowed_insn = NEXT_INSN (prev);\n-\t\t  SET_BIT (blocks, i);\n+#ifdef HAVE_conditional_execution\n+\t\t  /* With conditional execution, we cannot back up the\n+\t\t     live information so easily, since the conditional\n+\t\t     death data structures are not so self-contained.\n+\t\t     So record that we've made a modification to this\n+\t\t     block and update life information at the end.  */\n+\t\t  SET_BIT (blocks, b);\n \t\t  changed = 1;\n+\n+\t\t  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n+\t\t    peep2_insn_data[i].insn = NULL_RTX;\n+\t\t  peep2_insn_data[peep2_current].insn = PEEP2_EOB;\n+#else\n+\t\t  /* Back up lifetime information past the end of the\n+\t\t     newly created sequence.  */\n+\t\t  if (++i >= MAX_INSNS_PER_PEEP2 + 1)\n+\t\t    i = 0;\n+\t\t  COPY_REG_SET (live, peep2_insn_data[i].live_before);\n+\n+\t\t  /* Update life information for the new sequence.  */\n+\t\t  do\n+\t\t    {\n+\t\t      if (INSN_P (try))\n+\t\t\t{\n+\t\t\t  if (--i < 0)\n+\t\t\t    i = MAX_INSNS_PER_PEEP2;\n+\t\t\t  peep2_insn_data[i].insn = try;\n+\t\t\t  propagate_one_insn (pbi, try);\n+\t\t\t  COPY_REG_SET (peep2_insn_data[i].live_before, live);\n+\t\t\t}\n+\t\t      try = PREV_INSN (try);\n+\t\t    }\n+\t\t  while (try != prev);\n+\n+\t\t  /* ??? Should verify that LIVE now matches what we\n+\t\t     had before the new sequence.  */\n+\n+\t\t  peep2_current = i;\n+#endif\n \t\t}\n \t    }\n \n \t  if (insn == bb->head)\n \t    break;\n \t}\n+\n+      free_propagate_block_info (pbi);\n     }\n \n-  free_resource_info ();\n+  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n+    FREE_REG_SET (peep2_insn_data[i].live_before);\n+  FREE_REG_SET (live);\n \n-  compute_bb_for_insn (get_max_uid ());\n+#ifdef HAVE_conditional_execution\n   count_or_remove_death_notes (blocks, 1);\n   update_life_info (blocks, UPDATE_LIFE_LOCAL, PROP_DEATH_NOTES);\n-}\n+  sbitmap_free (blocks);\n #endif\n+}\n+#endif /* HAVE_peephole2 */"}, {"sha": "465013a73070485c2b39139986420128571ed832", "filename": "gcc/recog.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -116,9 +116,16 @@ extern void add_clobbers\t\tPARAMS ((rtx, int));\n extern void insn_extract\t\tPARAMS ((rtx));\n extern void extract_insn\t\tPARAMS ((rtx));\n extern void preprocess_constraints\tPARAMS ((void));\n-extern rtx recog_next_insn\t\tPARAMS ((rtx, int));\n+extern rtx peep2_next_insn\t\tPARAMS ((int));\n+extern int peep2_regno_dead_p\t\tPARAMS ((int, int));\n+extern int peep2_reg_dead_p\t\tPARAMS ((int, rtx));\n+#ifdef CLEAR_HARD_REG_SET\n+extern rtx peep2_find_free_register\tPARAMS ((int, int, const char *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t HARD_REG_SET *));\n+#endif\n extern void peephole2_optimize\t\tPARAMS ((FILE *));\n-extern rtx peephole2_insns\t\tPARAMS ((rtx, rtx, rtx *));\n+extern rtx peephole2_insns\t\tPARAMS ((rtx, rtx, int *));\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;"}, {"sha": "af1b4edf6d0031b5e96a67e3a57e397c673d0a09", "filename": "gcc/resource.c", "status": "modified", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -1268,109 +1268,3 @@ mark_end_of_function_resources (trial, include_delayed_effects)\n   mark_referenced_resources (trial, &end_of_function_needs,\n \t\t\t     include_delayed_effects);\n }\n-\f\n-/* Try to find a hard register of mode MODE, matching the register class in\n-   CLASS_STR, which is available at the beginning of insn CURRENT_INSN and\n-   remains available until the end of LAST_INSN.  LAST_INSN may be NULL_RTX,\n-   in which case the only condition is that the register must be available\n-   before CURRENT_INSN.\n-   Registers that already have bits set in REG_SET will not be considered.\n-\n-   If an appropriate register is available, it will be returned and the\n-   corresponding bit(s) in REG_SET will be set; otherwise, NULL_RTX is\n-   returned.  */\n-\n-rtx\n-find_free_register (current_insn, last_insn, class_str, mode, reg_set)\n-     rtx current_insn, last_insn;\n-     const char *class_str;\n-     int mode;\n-     HARD_REG_SET *reg_set;\n-{\n-  int i, j;\n-  struct resources used;\n-  unsigned char clet = class_str[0];\n-  enum reg_class class\n-    = (clet == 'r' ? GENERAL_REGS :  REG_CLASS_FROM_LETTER (clet));\n-\n-  mark_target_live_regs (get_insns (), current_insn, &used);\n-  if (last_insn)\n-    while (current_insn != last_insn)\n-      {\n-\t/* Exclude anything set in this insn.  */\n-\tmark_set_resources (PATTERN (current_insn), &used, 0,\n-\t\t\t    MARK_SRC_DEST_CALL);\n-\tcurrent_insn = next_nonnote_insn (current_insn);\n-      }\n-\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      int regno;\n-      int success;\n-\n-#ifdef REG_ALLOC_ORDER\n-      regno = reg_alloc_order [i];\n-#else\n-      regno = i;\n-#endif\n-\n-      /* Don't allocate fixed registers.  */\n-      if (fixed_regs[regno])\n-\tcontinue;\n-      /* Make sure the register is of the right class.  */\n-      if (! TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n-\tcontinue;\n-      /* And can support the mode we need.  */\n-      if (! HARD_REGNO_MODE_OK (regno, mode))\n-\tcontinue;\n-      /* And that we don't create an extra save/restore.  */\n-      if (! call_used_regs[regno] && ! regs_ever_live[regno])\n-\tcontinue;\n-      /* And we don't clobber traceback for noreturn functions.  */\n-      if ((regno == FRAME_POINTER_REGNUM || regno == HARD_FRAME_POINTER_REGNUM)\n-\t  && (! reload_completed || frame_pointer_needed))\n-\tcontinue;\n-\n-      success = 1;\n-      for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (*reg_set, regno + j)\n-\t      || TEST_HARD_REG_BIT (used.regs, regno + j))\n-\t    {\n-\t      success = 0;\n-\t      break;\n-\t    }\n-\t}\n-      if (success)\n-\t{\n-\t  for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n-\t    {\n-\t      SET_HARD_REG_BIT (*reg_set, regno + j);\n-\t    }\n-\t  return gen_rtx_REG (mode, regno);\n-\t}\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Return true if REG is dead at CURRENT_INSN.  */\n-\n-int\n-reg_dead_p (current_insn, reg)\n-     rtx current_insn, reg;\n-{\n-  struct resources used;\n-  int regno, j;\n-\n-  mark_target_live_regs (get_insns (), current_insn, &used);\n-  \n-  regno = REGNO (reg);\n-  for (j = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; j >= 0; j--)\n-    {\n-      if (TEST_HARD_REG_BIT (used.regs, regno + j))\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}"}, {"sha": "4f0173102aad9d5c57e50f04dd54313d7c880ba7", "filename": "gcc/resource.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -50,6 +50,3 @@ extern void incr_ticks_for_insn\t\tPARAMS ((rtx));\n extern void mark_end_of_function_resources PARAMS ((rtx, int));\n extern void init_resource_info\t\tPARAMS ((rtx));\n extern void free_resource_info\t\tPARAMS ((void));\n-extern rtx find_free_register\t\tPARAMS ((rtx, rtx, const char *, int,\n-\t\t\t\t\t       HARD_REG_SET *));\n-extern int reg_dead_p\t\t\tPARAMS ((rtx, rtx));"}, {"sha": "1fc72f1fcb0afc559972d2770e14c78e01dd915b", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232801393614cd0dd2d1d9edb0821a08fe57e767/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=232801393614cd0dd2d1d9edb0821a08fe57e767", "patch": "@@ -47,14 +47,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"insn-codes.h\"\n #include \"insn-config.h\"\n+#include \"hard-reg-set.h\"\n #include \"recog.h\"\n #include \"defaults.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"expr.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"intl.h\"\n #include \"ggc.h\""}]}