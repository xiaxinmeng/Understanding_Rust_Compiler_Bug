{"sha": "1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0NmQzM2Q5ZmQ1MDBhMWQxOWEwNGRmYzE3NzBiODg5ZjZmZTEyZg==", "commit": {"author": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-12-19T13:36:32Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-12-19T13:36:32Z"}, "message": "Fix generation of reg-moves\n\nFrom-SVN: r131060", "tree": {"sha": "726fbdaae0aa65a69bc9b8cecdd3808b0d2f110f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/726fbdaae0aa65a69bc9b8cecdd3808b0d2f110f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/comments", "author": null, "committer": null, "parents": [{"sha": "5259c813103b272f141eb5aafc5e473301d58760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5259c813103b272f141eb5aafc5e473301d58760", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5259c813103b272f141eb5aafc5e473301d58760"}], "stats": {"total": 107, "additions": 105, "deletions": 2}, "files": [{"sha": "f9aee9232e4e17710d41821d8bf7a3835cd5157c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "patch": "@@ -1,3 +1,11 @@\n+2007-12-19  Alexander Monakov  <amonakov@ispras.ru>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\t* modulo-sched.c (generate_reg_moves): Insert the reg-moves\n+\tright before the notes which precedes the insn, if they exists.\n+\t(loop_canon_p): Add dump info.\n+\t(sms_schedule): Likewise.\n+\n 2007-12-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* tree.h (set_decl_incoming_rtl): Add a by_reference_p parameter."}, {"sha": "ba65ebde7dd2884f83d15bbfa2e3b59e54fab1d1", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "patch": "@@ -506,7 +506,9 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n       /* Now generate the reg_moves, attaching relevant uses to them.  */\n       SCHED_NREG_MOVES (u) = nreg_moves;\n       old_reg = prev_reg = copy_rtx (SET_DEST (single_set (u->insn)));\n-      last_reg_move = u->insn;\n+      /* Insert the reg-moves right before the notes which precede\n+         the insn they relates to.  */\n+      last_reg_move = u->first_note;\n \n       for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n \t{\n@@ -794,7 +796,11 @@ loop_canon_p (struct loop *loop)\n {\n \n   if (loop->inner || !loop_outer (loop))\n+  {\n+    if (dump_file)\n+      fprintf (dump_file, \"SMS loop inner or !loop_outer\\n\");\n     return false;\n+  }\n \n   if (!single_exit (loop))\n     {\n@@ -910,6 +916,12 @@ sms_schedule (void)\n      We use loop->num as index into this array.  */\n   g_arr = XCNEWVEC (ddg_ptr, number_of_loops ());\n \n+  if (dump_file)\n+  {\n+    fprintf (dump_file, \"\\n\\nSMS analysis phase\\n\");\n+    fprintf (dump_file, \"===================\\n\\n\");\n+  }\n+\n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n      indexed by the loop index.  */\n   FOR_EACH_LOOP (li, loop, 0)\n@@ -926,11 +938,24 @@ sms_schedule (void)\n           break;\n         }\n \n+      if (dump_file)\n+      {\n+         rtx insn = BB_END (loop->header);\n+\n+         fprintf (dump_file, \"SMS loop num: %d, file: %s, line: %d\\n\",\n+                  loop->num, insn_file (insn), insn_line (insn));\n+\n+      }\n+\n       if (! loop_canon_p (loop))\n         continue;\n \n       if (! loop_single_full_bb_p (loop))\n+      {\n+        if (dump_file)\n+          fprintf (dump_file, \"SMS not loop_single_full_bb_p\\n\");\n \tcontinue;\n+      }\n \n       bb = loop->header;\n \n@@ -971,7 +996,11 @@ sms_schedule (void)\n \n       /* Make sure this is a doloop.  */\n       if ( !(count_reg = doloop_register_get (head, tail)))\n+      {\n+        if (dump_file)\n+          fprintf (dump_file, \"SMS doloop_register_get failed\\n\");\n \tcontinue;\n+      }\n \n       /* Don't handle BBs with calls or barriers, or !single_set insns,\n          or auto-increment insns (to avoid creating invalid reg-moves\n@@ -1021,7 +1050,15 @@ sms_schedule (void)\n         }\n \n       g_arr[loop->num] = g;\n+      if (dump_file)\n+        fprintf (dump_file, \"...OK\\n\");\n+\n     }\n+  if (dump_file)\n+  {\n+    fprintf (dump_file, \"\\nSMS transformation phase\\n\");\n+    fprintf (dump_file, \"=========================\\n\\n\");\n+  }\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n   FOR_EACH_LOOP (li, loop, 0)\n@@ -1036,7 +1073,14 @@ sms_schedule (void)\n         continue;\n \n       if (dump_file)\n-\tprint_ddg (dump_file, g);\n+      {\n+         rtx insn = BB_END (loop->header);\n+\n+         fprintf (dump_file, \"SMS loop num: %d, file: %s, line: %d\\n\",\n+                  loop->num, insn_file (insn), insn_line (insn));\n+\n+         print_ddg (dump_file, g);\n+      }\n \n       get_ebb_head_tail (loop->header, loop->header, &head, &tail);\n "}, {"sha": "9701bee17496b7df0ec90fcdeeab6c202b137a5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "patch": "@@ -1,3 +1,7 @@\n+2007-12-19  Revital Eres  <eres@il.ibm.com>\n+\n+\t * gcc.dg/sms-5.c: New testcase.\n+\n 2007-12-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/34325"}, {"sha": "9c2e0165c566055a95f203d828d138f222c89fdf", "filename": "gcc/testsuite/gcc.dg/sms-5.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a46d33d9fd500a1d19a04dfc1770b889f6fe12f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c?ref=1a46d33d9fd500a1d19a04dfc1770b889f6fe12f", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -funroll-loops\" } */\n+/* This is the same test as loop-2e.c test.  It is related to a fix in\n+   the generation of the prolog and epilog.  */\n+\n+extern void abort (void);\n+\n+void f (int *p, int **q)\n+{\n+  int i;\n+  for (i = 0; i < 40; i++)\n+    {\n+      *q++ = &p[i];\n+    }\n+}\n+\n+int main ()\n+{\n+  void *p;\n+  int *q[40];\n+  __SIZE_TYPE__ start;\n+\n+  /* Find the signed middle of the address space.  */\n+  if (sizeof(start) == sizeof(int))\n+    start = (__SIZE_TYPE__) __INT_MAX__;\n+  else if (sizeof(start) == sizeof(long))\n+    start = (__SIZE_TYPE__) __LONG_MAX__;\n+  else if (sizeof(start) == sizeof(long long))\n+    start = (__SIZE_TYPE__) __LONG_LONG_MAX__;\n+  else\n+    return 0;\n+\n+  /* Arbitrarily align the pointer.  */\n+  start &= -32;\n+\n+  /* Pretend that's good enough to start address arithmetic.  */\n+  p = (void *)start;\n+\n+  /* Verify that GIV replacement computes the correct results.  */\n+  q[39] = 0;\n+  f (p, q);\n+  if (q[39] != (int *)p + 39)\n+    abort ();\n+\n+  return 0;\n+}\n+"}]}