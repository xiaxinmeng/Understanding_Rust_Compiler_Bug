{"sha": "ce8dcc9105cbd4043d575d8b2c91309a423951a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U4ZGNjOTEwNWNiZDQwNDNkNTc1ZDhiMmM5MTMwOWE0MjM5NTFhOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-18T14:00:11Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-18T14:00:11Z"}, "message": "As well as the PR this patch fixes problems in handling class objects\n\n2020-12-18  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/83118\n\tPR fortran/96012\n\t* resolve.c (resolve_ordinary_assign): Generate a vtable if\n\tnecessary for scalar non-polymorphic rhs's to unlimited lhs's.\n\t* trans-array.c (get_class_info_from_ss): New function.\n\t(gfc_trans_allocate_array_storage): Defer obtaining class\n\telement type until all sources of class exprs are tried. Use\n\tclass API rather than TREE_OPERAND. Look for class expressions\n\tin ss->info by calling get_class_info_from_ss. After, obtain\n\tthe element size for class descriptors. Where the element type\n\tis unknown, cast the data as character(len=size) to overcome\n\tunlimited polymorphic problems.\n\t(gfc_conv_ss_descriptor): Do not fix class variable refs.\n\t(build_class_array_ref, structure_alloc_comps): Replace code\n\treplicating the new function gfc_resize_class_size_with_len.\n\t(gfc_alloc_allocatable_for_assignment): Obtain element size\n\tfor lhs in cases of deferred characters and class enitities.\n\tMove code for the element size of rhs to start of block. Clean\n\tup extraction of class parameters throughout this function.\n\tAfter the shape check test whether or not the lhs and rhs\n\telement sizes are the same. Use earlier evaluation of\n\t'cond_null'. Reallocation of lhs only to happen if size changes\n\tor element size changes.\n\t* trans-expr.c (gfc_resize_class_size_with_len): New function.\n\t(gfc_get_class_from_expr): If a constant expression is\n\tencountered, return NULL_TREE;\n\t(trans_scalar_class_assign): New function.\n\t(gfc_conv_procedure_call): Ensure the vtable is present for\n\tpassing a non-class actual to an unlimited formal.\n\t(trans_class_vptr_len_assignment): For expressions of type\n\tBT_CLASS, extract the class expression if necessary. Use a\n\tstatement block outside the loop body. Ensure that 'rhs' is\n\tof the correct type. Obtain rhs vptr in all circumstances.\n\t(gfc_trans_scalar_assign): Call trans_scalar_class_assign to\n\tmake maximum use of the vptr copy in place of assignment.\n\t(trans_class_assignment): Actually do reallocation if needed.\n\t(gfc_trans_assignment_1): Simplify some of the logic with\n\t'realloc_flag'. Set 'vptr_copy' for all array assignments to\n\tunlimited polymorphic lhs.\n\t* trans.c (gfc_build_array_ref): Call gfc_resize_class_size_\n\twith_len to correct span for unlimited polymorphic decls.\n\t* trans.h : Add prototype for gfc_resize_class_size_with_len.\n\ngcc/testsuite/\n\tPR fortran/83118\n\tPR fortran/96012\n\t* gfortran.dg/dependency_60.f90: New test.\n\t* gfortran.dg/class_allocate_25.f90: New test.\n\t* gfortran.dg/class_assign_4.f90: New test.\n\t* gfortran.dg/unlimited_polymorphic_32.f03: New test.", "tree": {"sha": "cbdbfaf7af17a254b4191fb5935fbfbec8677016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbdbfaf7af17a254b4191fb5935fbfbec8677016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce8dcc9105cbd4043d575d8b2c91309a423951a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce8dcc9105cbd4043d575d8b2c91309a423951a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce8dcc9105cbd4043d575d8b2c91309a423951a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce8dcc9105cbd4043d575d8b2c91309a423951a9/comments", "author": null, "committer": null, "parents": [{"sha": "11f07ef37786d10517121fc6226681cd1aa2aea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f07ef37786d10517121fc6226681cd1aa2aea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f07ef37786d10517121fc6226681cd1aa2aea2"}], "stats": {"total": 1050, "additions": 889, "deletions": 161}, "files": [{"sha": "cc6173a62217807b73db4c699b5b76fac13e49f5", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -11054,7 +11054,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n   /* Make sure there is a vtable and, in particular, a _copy for the\n      rhs type.  */\n-  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)\n+  if (lhs->ts.type == BT_CLASS && rhs->ts.type != BT_CLASS)\n     gfc_find_vtab (&rhs->ts);\n \n   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB"}, {"sha": "9e461f94536272aa5a6a274e4b5221e9cb7567aa", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 326, "deletions": 122, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -1030,7 +1030,6 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t      gcc_assert (TREE_CODE (tmp) == POINTER_TYPE);\n \t      tmp = TREE_TYPE (tmp); /* The descriptor itself.  */\n \t      tmp = gfc_get_element_type (tmp);\n-\t      gcc_assert (tmp == gfc_get_element_type (TREE_TYPE (desc)));\n \t      packed = gfc_create_var (build_pointer_type (tmp), \"data\");\n \n \t      tmp = build_call_expr_loc (input_location,\n@@ -1139,6 +1138,123 @@ get_array_ref_dim_for_loop_dim (gfc_ss *ss, int loop_dim)\n }\n \n \n+/* Use the information in the ss to obtain the required information about\n+   the type and size of an array temporary, when the lhs in an assignment\n+   is a class expression.  */\n+\n+static tree\n+get_class_info_from_ss (stmtblock_t * pre, gfc_ss *ss, tree *eltype)\n+{\n+  gfc_ss *lhs_ss;\n+  gfc_ss *rhs_ss;\n+  tree tmp;\n+  tree tmp2;\n+  tree vptr;\n+  tree rhs_class_expr = NULL_TREE;\n+  tree lhs_class_expr = NULL_TREE;\n+  bool unlimited_rhs = false;\n+  bool unlimited_lhs = false;\n+  bool rhs_function = false;\n+  gfc_symbol *vtab;\n+\n+  /* The second element in the loop chain contains the source for the\n+     temporary; ie. the rhs of the assignment.  */\n+  rhs_ss = ss->loop->ss->loop_chain;\n+\n+  if (rhs_ss != gfc_ss_terminator\n+      && rhs_ss->info\n+      && rhs_ss->info->expr\n+      && rhs_ss->info->expr->ts.type == BT_CLASS\n+      && rhs_ss->info->data.array.descriptor)\n+    {\n+      rhs_class_expr\n+\t= gfc_get_class_from_expr (rhs_ss->info->data.array.descriptor);\n+      unlimited_rhs = UNLIMITED_POLY (rhs_ss->info->expr);\n+      if (rhs_ss->info->expr->expr_type == EXPR_FUNCTION)\n+\trhs_function = true;\n+    }\n+\n+  /* For an assignment the lhs is the next element in the loop chain.\n+     If we have a class rhs, this had better be a class variable\n+     expression!  */\n+  lhs_ss = rhs_ss->loop_chain;\n+  if (lhs_ss != gfc_ss_terminator\n+      && lhs_ss->info\n+      && lhs_ss->info->expr\n+      && lhs_ss->info->expr->expr_type ==EXPR_VARIABLE\n+      && lhs_ss->info->expr->ts.type == BT_CLASS)\n+    {\n+      tmp = lhs_ss->info->data.array.descriptor;\n+      unlimited_lhs = UNLIMITED_POLY (rhs_ss->info->expr);\n+    }\n+  else\n+    tmp = NULL_TREE;\n+\n+  /* Get the lhs class expression.  */\n+  if (tmp != NULL_TREE && lhs_ss->loop_chain == gfc_ss_terminator)\n+    lhs_class_expr = gfc_get_class_from_expr (tmp);\n+  else\n+    return rhs_class_expr;\n+\n+  gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (lhs_class_expr)));\n+\n+  /* Set the lhs vptr and, if necessary, the _len field.  */\n+  if (rhs_class_expr)\n+    {\n+      /* Both lhs and rhs are class expressions.  */\n+      tmp = gfc_class_vptr_get (lhs_class_expr);\n+      gfc_add_modify (pre, tmp,\n+\t\t      fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t    gfc_class_vptr_get (rhs_class_expr)));\n+      if (unlimited_lhs)\n+\t{\n+\t  tmp = gfc_class_len_get (lhs_class_expr);\n+\t  if (unlimited_rhs)\n+\t    tmp2 = gfc_class_len_get (rhs_class_expr);\n+\t  else\n+\t    tmp2 = build_int_cst (TREE_TYPE (tmp), 0);\n+\t  gfc_add_modify (pre, tmp, tmp2);\n+\t}\n+\n+      if (rhs_function)\n+\t{\n+\t  tmp = gfc_class_data_get (rhs_class_expr);\n+\t  gfc_conv_descriptor_offset_set (pre, tmp, gfc_index_zero_node);\n+\t}\n+    }\n+  else\n+   {\n+      /* lhs is class and rhs is intrinsic or derived type.  */\n+      *eltype = TREE_TYPE (rhs_ss->info->data.array.descriptor);\n+      *eltype = gfc_get_element_type (*eltype);\n+      vtab = gfc_find_vtab (&rhs_ss->info->expr->ts);\n+      vptr = vtab->backend_decl;\n+      if (vptr == NULL_TREE)\n+\tvptr = gfc_get_symbol_decl (vtab);\n+      vptr = gfc_build_addr_expr (NULL_TREE, vptr);\n+      tmp = gfc_class_vptr_get (lhs_class_expr);\n+      gfc_add_modify (pre, tmp,\n+\t\t      fold_convert (TREE_TYPE (tmp), vptr));\n+\n+      if (unlimited_lhs)\n+\t{\n+\t  tmp = gfc_class_len_get (lhs_class_expr);\n+\t  if (rhs_ss->info\n+\t      && rhs_ss->info->expr\n+\t      && rhs_ss->info->expr->ts.type == BT_CHARACTER)\n+\t    tmp2 = build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t  rhs_ss->info->expr->ts.kind);\n+\t  else\n+\t    tmp2 = build_int_cst (TREE_TYPE (tmp), 0);\n+\t  gfc_add_modify (pre, tmp, tmp2);\n+\t}\n+    }\n+\n+  return rhs_class_expr;\n+}\n+\n+\n+\n /* Generate code to create and initialize the descriptor for a temporary\n    array.  This is used for both temporaries needed by the scalarizer, and\n    functions returning arrays.  Adjusts the loop variables to be\n@@ -1184,13 +1300,46 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n     {\n       gcc_assert (POINTER_TYPE_P (TREE_TYPE (initial)));\n       class_expr = build_fold_indirect_ref_loc (input_location, initial);\n-      eltype = TREE_TYPE (class_expr);\n-      eltype = gfc_get_element_type (eltype);\n       /* Obtain the structure (class) expression.  */\n-      class_expr = TREE_OPERAND (class_expr, 0);\n+      class_expr = gfc_get_class_from_expr (class_expr);\n       gcc_assert (class_expr);\n     }\n \n+  /* Otherwise, some expressions, such as class functions, arising from\n+     dependency checking in assignments come here with class element type.\n+     The descriptor can be obtained from the ss->info and then converted\n+     to the class object.  */\n+  if (class_expr == NULL_TREE && GFC_CLASS_TYPE_P (eltype))\n+    class_expr = get_class_info_from_ss (pre, ss, &eltype);\n+\n+  /* If the dynamic type is not available, use the declared type.  */\n+  if (eltype && GFC_CLASS_TYPE_P (eltype))\n+    eltype = gfc_get_element_type (TREE_TYPE (TYPE_FIELDS (eltype)));\n+\n+  if (class_expr == NULL_TREE)\n+    elemsize = fold_convert (gfc_array_index_type,\n+\t\t\t     TYPE_SIZE_UNIT (eltype));\n+  else\n+    {\n+      /* Unlimited polymorphic entities are initialised with NULL vptr. They\n+\t can be tested for by checking if the len field is present. If so\n+\t test the vptr before using the vtable size.  */\n+      tmp = gfc_class_vptr_get (class_expr);\n+      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     logical_type_node,\n+\t\t\t     tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+      elemsize = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t  tmp,\n+\t\t\t\t  gfc_class_vtab_size_get (class_expr),\n+\t\t\t\t  gfc_index_zero_node);\n+      elemsize = gfc_evaluate_now (elemsize, pre);\n+      elemsize = gfc_resize_class_size_with_len (pre, class_expr, elemsize);\n+      /* Casting the data as a character of the dynamic length ensures that\n+\t assignment of elements works when needed.  */\n+      eltype = gfc_get_character_type_len (1, elemsize);\n+    }\n+\n   memset (from, 0, sizeof (from));\n   memset (to, 0, sizeof (to));\n \n@@ -1339,12 +1488,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t}\n     }\n \n-  if (class_expr == NULL_TREE)\n-    elemsize = fold_convert (gfc_array_index_type,\n-\t\t\t     TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  else\n-    elemsize = gfc_class_vtab_size_get (class_expr);\n-\n   /* Get the size of the array.  */\n   if (size && !callee_alloc)\n     {\n@@ -2910,13 +3053,16 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n \t}\n       /* Also the data pointer.  */\n       tmp = gfc_conv_array_data (se.expr);\n-      /* If this is a variable or address of a variable we use it directly.\n+      /* If this is a variable or address or a class array, use it directly.\n          Otherwise we must evaluate it now to avoid breaking dependency\n \t analysis by pulling the expressions for elemental array indices\n \t inside the loop.  */\n       if (!(DECL_P (tmp)\n \t    || (TREE_CODE (tmp) == ADDR_EXPR\n-\t\t&& DECL_P (TREE_OPERAND (tmp, 0)))))\n+\t\t&& DECL_P (TREE_OPERAND (tmp, 0)))\n+\t    || (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr))\n+\t\t&& TREE_CODE (se.expr) == COMPONENT_REF\n+\t\t&& GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (se.expr, 0))))))\n \ttmp = gfc_evaluate_now (tmp, block);\n       info->data = tmp;\n \n@@ -3373,18 +3519,10 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n   size = gfc_class_vtab_size_get (decl);\n \n   /* For unlimited polymorphic entities then _len component needs to be\n-     multiplied with the size.  If no _len component is present, then\n-     gfc_class_len_or_zero_get () return a zero_node.  */\n-  tmp = gfc_class_len_or_zero_get (decl);\n-  if (!integer_zerop (tmp))\n-    size = fold_build2 (MULT_EXPR, TREE_TYPE (index),\n-\t\t\tfold_convert (TREE_TYPE (index), size),\n-\t\t\tfold_build2 (MAX_EXPR, TREE_TYPE (index),\n-\t\t\t\t     fold_convert (TREE_TYPE (index), tmp),\n-\t\t\t\t     fold_convert (TREE_TYPE (index),\n-\t\t\t\t\t\t   integer_one_node)));\n-  else\n-    size = fold_convert (TREE_TYPE (index), size);\n+     multiplied with the size.  */\n+  size = gfc_resize_class_size_with_len (&se->pre, decl, size);\n+\n+  size = fold_convert (TREE_TYPE (index), size);\n \n   /* Build the address of the element.  */\n   type = TREE_TYPE (TREE_TYPE (base));\n@@ -9233,21 +9371,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t for the malloc call.  */\n \t      if (UNLIMITED_POLY (c))\n \t\t{\n-\t\t  tree ctmp;\n \t\t  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),\n \t\t\t\t  gfc_class_len_get (comp));\n-\n-\t\t  size = gfc_evaluate_now (size, &tmpblock);\n-\t\t  tmp = gfc_class_len_get (comp);\n-\t\t  ctmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t\t  size_type_node, size,\n-\t\t\t\t\t  fold_convert (size_type_node, tmp));\n-\t\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\t logical_type_node, tmp,\n-\t\t\t\t\t build_zero_cst (TREE_TYPE (tmp)));\n-\t\t  size = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\t  size_type_node, tmp, ctmp, size);\n-\t\t  size = gfc_evaluate_now (size, &tmpblock);\n+\t\t  size = gfc_resize_class_size_with_len (&tmpblock, comp, size);\n \t\t}\n \n \t      /* Coarray component have to have the same allocation status and\n@@ -10033,6 +10159,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   tree alloc_expr;\n   tree size1;\n   tree size2;\n+  tree elemsize1;\n+  tree elemsize2;\n   tree array1;\n   tree cond_null;\n   tree cond;\n@@ -10112,6 +10240,108 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));\n   array1 = gfc_conv_descriptor_data_get (desc);\n \n+  if (expr2)\n+    desc2 = rss->info->data.array.descriptor;\n+  else\n+    desc2 = NULL_TREE;\n+\n+  /* Get the old lhs element size for deferred character and class expr1.  */\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      if (expr1->ts.u.cl->backend_decl\n+\t  && VAR_P (expr1->ts.u.cl->backend_decl))\n+\telemsize1 = expr1->ts.u.cl->backend_decl;\n+      else\n+\telemsize1 = lss->info->string_length;\n+    }\n+  else if (expr1->ts.type == BT_CLASS)\n+    {\n+      tmp = expr1->rank ? gfc_get_class_from_expr (desc) : NULL_TREE;\n+      if (tmp != NULL_TREE)\n+\t{\n+\t  tmp2 = gfc_class_vptr_get (tmp);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t  logical_type_node, tmp2,\n+\t\t\t\t  build_int_cst (TREE_TYPE (tmp2), 0));\n+\t  elemsize1 = gfc_class_vtab_size_get (tmp);\n+\t  elemsize1 = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      gfc_array_index_type, cond,\n+\t\t\t\t      elemsize1, gfc_index_zero_node);\n+\t}\n+      else\n+\telemsize1 = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&CLASS_DATA (expr1)->ts));\n+    }\n+  else\n+    elemsize1 = NULL_TREE;\n+  if (elemsize1 != NULL_TREE)\n+    elemsize1 = gfc_evaluate_now (elemsize1, &fblock);\n+\n+  /* Get the new lhs size in bytes.  */\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      if (expr2->ts.deferred)\n+\t{\n+\t  if (expr2->ts.u.cl->backend_decl\n+\t      && VAR_P (expr2->ts.u.cl->backend_decl))\n+\t    tmp = expr2->ts.u.cl->backend_decl;\n+\t  else\n+\t    tmp = rss->info->string_length;\n+\t}\n+      else\n+\t{\n+\t  tmp = expr2->ts.u.cl->backend_decl;\n+\t  if (!tmp && expr2->expr_type == EXPR_OP\n+\t      && expr2->value.op.op == INTRINSIC_CONCAT)\n+\t    {\n+\t      tmp = concat_str_length (expr2);\n+\t      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);\n+\t    }\n+\t  else if (!tmp && expr2->ts.u.cl->length)\n+\t    {\n+\t      gfc_se tmpse;\n+\t      gfc_init_se (&tmpse, NULL);\n+\t      gfc_conv_expr_type (&tmpse, expr2->ts.u.cl->length,\n+\t\t\t\t  gfc_charlen_type_node);\n+\t      tmp = tmpse.expr;\n+\t      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);\n+\t    }\n+\t  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);\n+\t}\n+\n+      if (expr1->ts.u.cl->backend_decl\n+\t  && VAR_P (expr1->ts.u.cl->backend_decl))\n+\tgfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);\n+      else\n+\tgfc_add_modify (&fblock, lss->info->string_length, tmp);\n+\n+      if (expr1->ts.kind > 1)\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       TREE_TYPE (tmp),\n+\t\t\t       tmp, build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t\t\t   expr1->ts.kind));\n+    }\n+  else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)\n+    {\n+      tmp = TYPE_SIZE_UNIT (TREE_TYPE (gfc_typenode_for_spec (&expr1->ts)));\n+      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t     expr1->ts.u.cl->backend_decl);\n+    }\n+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)\n+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));\n+  else if (expr1->ts.type == BT_CLASS && expr2->ts.type == BT_CLASS)\n+    {\n+      tmp = expr2->rank ? gfc_get_class_from_expr (desc2) : NULL_TREE;\n+      if (tmp != NULL_TREE)\n+\ttmp = gfc_class_vtab_size_get (tmp);\n+      else\n+\ttmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&CLASS_DATA (expr2)->ts));\n+    }\n+  else\n+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));\n+  elemsize2 = fold_convert (gfc_array_index_type, tmp);\n+  elemsize2 = gfc_evaluate_now (elemsize2, &fblock);\n+\n   /* 7.4.1.3 \"If variable is an allocated allocatable variable, it is\n      deallocated if expr is an array of different shape or any of the\n      corresponding length type parameter values of variable and expr\n@@ -10131,6 +10361,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t     rss->info->string_length);\n       cond_null = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n \t\t\t\t   logical_type_node, tmp, cond_null);\n+      cond_null= gfc_evaluate_now (cond_null, &fblock);\n     }\n   else\n     cond_null= gfc_evaluate_now (cond_null, &fblock);\n@@ -10179,6 +10410,19 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_expr_to_block (&fblock, tmp);\n     }\n \n+  /* ...else if the element lengths are not the same also go to\n+     setting the bounds and doing the reallocation.... */\n+  if (elemsize1 != NULL_TREE)\n+    {\n+      cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t      logical_type_node,\n+\t\t\t      elemsize1, elemsize2);\n+      tmp = build3_v (COND_EXPR, cond,\n+\t\t      build1_v (GOTO_EXPR, jump_label1),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&fblock, tmp);\n+    }\n+\n   /* ....else jump past the (re)alloc code.  */\n   tmp = build1_v (GOTO_EXPR, jump_label2);\n   gfc_add_expr_to_block (&fblock, tmp);\n@@ -10201,11 +10445,6 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   gfc_add_expr_to_block (&fblock, tmp);\n \n   /* Get the rhs size and fix it.  */\n-  if (expr2)\n-    desc2 = rss->info->data.array.descriptor;\n-  else\n-    desc2 = NULL_TREE;\n-\n   size2 = gfc_index_one_node;\n   for (n = 0; n < expr2->rank; n++)\n     {\n@@ -10320,69 +10559,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \tgfc_add_modify (&fblock, linfo->delta[dim], tmp);\n     }\n \n-  /* Get the new lhs size in bytes.  */\n-  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n-    {\n-      if (expr2->ts.deferred)\n-\t{\n-\t  if (expr2->ts.u.cl->backend_decl\n-\t      && VAR_P (expr2->ts.u.cl->backend_decl))\n-\t    tmp = expr2->ts.u.cl->backend_decl;\n-\t  else\n-\t    tmp = rss->info->string_length;\n-\t}\n-      else\n-\t{\n-\t  tmp = expr2->ts.u.cl->backend_decl;\n-\t  if (!tmp && expr2->expr_type == EXPR_OP\n-\t      && expr2->value.op.op == INTRINSIC_CONCAT)\n-\t    {\n-\t      tmp = concat_str_length (expr2);\n-\t      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);\n-\t    }\n-\t  else if (!tmp && expr2->ts.u.cl->length)\n-\t    {\n-\t      gfc_se tmpse;\n-\t      gfc_init_se (&tmpse, NULL);\n-\t      gfc_conv_expr_type (&tmpse, expr2->ts.u.cl->length,\n-\t\t\t\t  gfc_charlen_type_node);\n-\t      tmp = tmpse.expr;\n-\t      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);\n-\t    }\n-\t  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);\n-\t}\n-\n-      if (expr1->ts.u.cl->backend_decl\n-\t  && VAR_P (expr1->ts.u.cl->backend_decl))\n-\tgfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);\n-      else\n-\tgfc_add_modify (&fblock, lss->info->string_length, tmp);\n-\n-      if (expr1->ts.kind > 1)\n-\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t       TREE_TYPE (tmp),\n-\t\t\t       tmp, build_int_cst (TREE_TYPE (tmp),\n-\t\t\t\t\t\t   expr1->ts.kind));\n-    }\n-  else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)\n-    {\n-      tmp = TYPE_SIZE_UNIT (TREE_TYPE (gfc_typenode_for_spec (&expr1->ts)));\n-      tmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t     gfc_array_index_type, tmp,\n-\t\t\t     expr1->ts.u.cl->backend_decl);\n-    }\n-  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)\n-    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));\n-  else\n-    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));\n-  tmp = fold_convert (gfc_array_index_type, tmp);\n-\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n-    gfc_conv_descriptor_span_set (&fblock, desc, tmp);\n+    gfc_conv_descriptor_span_set (&fblock, desc, elemsize2);\n \n   size2 = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t   gfc_array_index_type,\n-\t\t\t   tmp, size2);\n+\t\t\t   elemsize2, size2);\n   size2 = fold_convert (size_type_node, size2);\n   size2 = fold_build2_loc (input_location, MAX_EXPR, size_type_node,\n \t\t\t   size2, size_one_node);\n@@ -10403,27 +10585,45 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_modify (&fblock, tmp,\n \t\t      gfc_get_dtype_rank_type (expr1->rank,type));\n     }\n-  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)\n+  else if (expr1->ts.type == BT_CLASS)\n     {\n       tree type;\n       tmp = gfc_conv_descriptor_dtype (desc);\n-      type = gfc_typenode_for_spec (&expr2->ts);\n+\n+      if (expr2->ts.type != BT_CLASS)\n+\ttype = gfc_typenode_for_spec (&expr2->ts);\n+      else\n+\ttype = gfc_get_character_type_len (1, elemsize2);\n+\n       gfc_add_modify (&fblock, tmp,\n \t\t      gfc_get_dtype_rank_type (expr2->rank,type));\n       /* Set the _len field as well...  */\n-      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));\n-      if (expr2->ts.type == BT_CHARACTER)\n-\tgfc_add_modify (&fblock, tmp,\n-\t\t\tfold_convert (TREE_TYPE (tmp),\n-\t\t\t\t      TYPE_SIZE_UNIT (type)));\n-      else\n-\tgfc_add_modify (&fblock, tmp,\n-\t\t\tbuild_int_cst (TREE_TYPE (tmp), 0));\n+      if (UNLIMITED_POLY (expr1))\n+\t{\n+\t  tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));\n+\t  if (expr2->ts.type == BT_CHARACTER)\n+\t    gfc_add_modify (&fblock, tmp,\n+\t\t\t    fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t  TYPE_SIZE_UNIT (type)));\n+\t  else\n+\t    gfc_add_modify (&fblock, tmp,\n+\t\t\t    build_int_cst (TREE_TYPE (tmp), 0));\n+\t}\n       /* ...and the vptr.  */\n       tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));\n-      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));\n-      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);\n-      gfc_add_modify (&fblock, tmp, tmp2);\n+      if (expr2->ts.type == BT_CLASS && !VAR_P (desc2)\n+\t  && TREE_CODE (desc2) == COMPONENT_REF)\n+\t{\n+\t  tmp2 = gfc_get_class_from_expr (desc2);\n+\t  tmp2 = gfc_class_vptr_get (tmp2);\n+\t}\n+      else\n+\t{\n+\t  tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));\n+\t  tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);\n+\t}\n+\n+      gfc_add_modify (&fblock, tmp, fold_convert (TREE_TYPE (tmp), tmp2));\n     }\n   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n     {\n@@ -10499,11 +10699,19 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   gfc_add_block_to_block (&realloc_block, &caf_se.post);\n   realloc_expr = gfc_finish_block (&realloc_block);\n \n-  /* Only reallocate if sizes are different.  */\n+  /* Reallocate if sizes or dynamic types are different.  */\n+  if (elemsize1)\n+    {\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t     elemsize1, elemsize2);\n+      tmp = gfc_evaluate_now (tmp, &fblock);\n+      neq_size = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t  logical_type_node, neq_size, tmp);\n+    }\n   tmp = build3_v (COND_EXPR, neq_size, realloc_expr,\n \t\t  build_empty_stmt (input_location));\n-  realloc_expr = tmp;\n \n+  realloc_expr = tmp;\n \n   /* Malloc expression.  */\n   gfc_init_block (&alloc_block);\n@@ -10550,11 +10758,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   alloc_expr = gfc_finish_block (&alloc_block);\n \n   /* Malloc if not allocated; realloc otherwise.  */\n-  tmp = build_int_cst (TREE_TYPE (array1), 0);\n-  cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t  logical_type_node,\n-\t\t\t  array1, tmp);\n-  tmp = build3_v (COND_EXPR, cond, alloc_expr, realloc_expr);\n+  tmp = build3_v (COND_EXPR, cond_null, alloc_expr, realloc_expr);\n   gfc_add_expr_to_block (&fblock, tmp);\n \n   /* Make sure that the scalarizer data pointer is updated.  */\n@@ -10564,7 +10768,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_modify (&fblock, linfo->data, tmp);\n     }\n \n-  /* Add the exit label.  */\n+  /* Add the label for same shape lhs and rhs.  */\n   tmp = build1_v (LABEL_EXPR, jump_label2);\n   gfc_add_expr_to_block (&fblock, tmp);\n "}, {"sha": "bfe08be2a94121a7295aa277a9fee5b891fc0d6f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 241, "deletions": 23, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -257,6 +257,42 @@ gfc_class_len_or_zero_get (tree decl)\n }\n \n \n+tree\n+gfc_resize_class_size_with_len (stmtblock_t * block, tree class_expr, tree size)\n+{\n+  tree tmp;\n+  tree tmp2;\n+  tree type;\n+\n+  tmp = gfc_class_len_or_zero_get (class_expr);\n+\n+  /* Include the len value in the element size if present.  */\n+  if (!integer_zerop (tmp))\n+    {\n+      type = TREE_TYPE (size);\n+      if (block)\n+\t{\n+\t  size = gfc_evaluate_now (size, block);\n+\t  tmp = gfc_evaluate_now (fold_convert (type , tmp), block);\n+\t}\n+      tmp2 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t      type, size, tmp);\n+      tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t     logical_type_node, tmp,\n+\t\t\t     build_zero_cst (type));\n+      size = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t      type, tmp, tmp2, size);\n+    }\n+  else\n+    return size;\n+\n+  if (block)\n+    size = gfc_evaluate_now (size, block);\n+\n+  return size;\n+}\n+\n+\n /* Get the specified FIELD from the VPTR.  */\n \n static tree\n@@ -483,6 +519,9 @@ gfc_get_class_from_expr (tree expr)\n \n   for (tmp = expr; tmp; tmp = TREE_OPERAND (tmp, 0))\n     {\n+      if (CONSTANT_CLASS_P (tmp))\n+\treturn NULL_TREE;\n+\n       type = TREE_TYPE (tmp);\n       while (type)\n \t{\n@@ -1606,6 +1645,111 @@ gfc_trans_class_init_assign (gfc_code *code)\n }\n \n \n+/* Class valued elemental function calls or class array elements arriving\n+   in gfc_trans_scalar_assign come here.  Wherever possible the vptr copy\n+   is used to ensure that the rhs dynamic type is assigned to the lhs.  */\n+\n+static bool\n+trans_scalar_class_assign (stmtblock_t *block, gfc_se *lse, gfc_se *rse)\n+{\n+  tree fcn;\n+  tree rse_expr;\n+  tree class_data;\n+  tree tmp;\n+  tree zero;\n+  tree cond;\n+  tree final_cond;\n+  stmtblock_t inner_block;\n+  bool is_descriptor;\n+  bool not_call_expr = TREE_CODE (rse->expr) != CALL_EXPR;\n+  bool not_lhs_array_type;\n+\n+  /* Temporaries arising from depencies in assignment get cast as a\n+     character type of the dynamic size of the rhs. Use the vptr copy\n+     for this case.  */\n+  tmp = TREE_TYPE (lse->expr);\n+  not_lhs_array_type = !(tmp && TREE_CODE (tmp) == ARRAY_TYPE\n+\t\t\t && TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)) != NULL_TREE);\n+\n+  /* Use ordinary assignment if the rhs is not a call expression or\n+     the lhs is not a class entity or an array(ie. character) type.  */\n+  if ((not_call_expr && gfc_get_class_from_expr (lse->expr) == NULL_TREE)\n+      && not_lhs_array_type)\n+    return false;\n+\n+  /* Ordinary assignment can be used if both sides are class expressions\n+     since the dynamic type is preserved by copying the vptr.  This\n+     should only occur, where temporaries are involved.  */\n+  if (GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n+      && GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))\n+    return false;\n+\n+  /* Fix the class expression and the class data of the rhs.  */\n+  if (!GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr))\n+      || not_call_expr)\n+    {\n+      tmp = gfc_get_class_from_expr (rse->expr);\n+      if (tmp == NULL_TREE)\n+\treturn false;\n+      rse_expr = gfc_evaluate_now (tmp, block);\n+    }\n+  else\n+    rse_expr = gfc_evaluate_now (rse->expr, block);\n+\n+  class_data = gfc_class_data_get (rse_expr);\n+\n+  /* Check that the rhs data is not null.  */\n+  is_descriptor = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (class_data));\n+  if (is_descriptor)\n+    class_data = gfc_conv_descriptor_data_get (class_data);\n+  class_data = gfc_evaluate_now (class_data, block);\n+\n+  zero = build_int_cst (TREE_TYPE (class_data), 0);\n+  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t  logical_type_node,\n+\t\t\t  class_data, zero);\n+\n+  /* Copy the rhs to the lhs.  */\n+  fcn = gfc_vptr_copy_get (gfc_class_vptr_get (rse_expr));\n+  fcn = build_fold_indirect_ref_loc (input_location, fcn);\n+  tmp = gfc_evaluate_now (gfc_build_addr_expr (NULL, rse->expr), block);\n+  tmp = is_descriptor ? tmp : class_data;\n+  tmp = build_call_expr_loc (input_location, fcn, 2, tmp,\n+\t\t\t     gfc_build_addr_expr (NULL, lse->expr));\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  /* Only elemental function results need to be finalised and freed.  */\n+  if (not_call_expr)\n+    return true;\n+\n+  /* Finalize the class data if needed.  */\n+  gfc_init_block (&inner_block);\n+  fcn = gfc_vptr_final_get (gfc_class_vptr_get (rse_expr));\n+  zero = build_int_cst (TREE_TYPE (fcn), 0);\n+  final_cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\tlogical_type_node, fcn, zero);\n+  fcn = build_fold_indirect_ref_loc (input_location, fcn);\n+  tmp = build_call_expr_loc (input_location, fcn, 1, class_data);\n+  tmp = build3_v (COND_EXPR, final_cond,\n+\t\t  tmp, build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&inner_block, tmp);\n+\n+  /* Free the class data.  */\n+  tmp = gfc_call_free (class_data);\n+  tmp = build3_v (COND_EXPR, cond, tmp,\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&inner_block, tmp);\n+\n+  /* Finish the inner block and subject it to the condition on the\n+     class data being non-zero.  */\n+  tmp = gfc_finish_block (&inner_block);\n+  tmp = build3_v (COND_EXPR, cond, tmp,\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return true;\n+}\n+\n /* End of prototype trans-class.c  */\n \n \n@@ -5613,8 +5757,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  /* The intrinsic type needs to be converted to a temporary\n \t     CLASS object for the unlimited polymorphic formal.  */\n+\t  gfc_find_vtab (&e->ts);\n \t  gfc_init_se (&parmse, se);\n \t  gfc_conv_intrinsic_to_class (&parmse, e, fsym->ts);\n+\n \t}\n       else if (se->ss && se->ss->info->useflags)\n \t{\n@@ -8926,14 +9072,32 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n   tree tmp, to_len = NULL_TREE, from_len = NULL_TREE, lhs_vptr;\n   bool set_vptr = false, temp_rhs = false;\n   stmtblock_t *pre = block;\n+  tree class_expr = NULL_TREE;\n \n   /* Create a temporary for complicated expressions.  */\n   if (re->expr_type != EXPR_VARIABLE && re->expr_type != EXPR_NULL\n       && rse->expr != NULL_TREE && !DECL_P (rse->expr))\n     {\n-      tmp = gfc_create_var (TREE_TYPE (rse->expr), \"rhs\");\n-      pre = &rse->pre;\n-      gfc_add_modify (&rse->pre, tmp, rse->expr);\n+      if (re->ts.type == BT_CLASS && !GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))\n+\tclass_expr = gfc_get_class_from_expr (rse->expr);\n+\n+      if (rse->loop)\n+\tpre = &rse->loop->pre;\n+      else\n+\tpre = &rse->pre;\n+\n+      if (class_expr != NULL_TREE && UNLIMITED_POLY (re))\n+\t{\n+\t  tmp = TREE_OPERAND (rse->expr, 0);\n+\t  tmp = gfc_create_var (TREE_TYPE (tmp), \"rhs\");\n+\t  gfc_add_modify (&rse->pre, tmp, TREE_OPERAND (rse->expr, 0));\n+\t}\n+      else\n+\t{\n+\t  tmp = gfc_create_var (TREE_TYPE (rse->expr), \"rhs\");\n+\t  gfc_add_modify (&rse->pre, tmp, rse->expr);\n+\t}\n+\n       rse->expr = tmp;\n       temp_rhs = true;\n     }\n@@ -9001,9 +9165,17 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n \t  else if (temp_rhs && re->ts.type == BT_CLASS)\n \t    {\n \t      vptr_expr = NULL;\n-\t      se.expr = gfc_class_vptr_get (rse->expr);\n+\t      if (class_expr)\n+\t\ttmp = class_expr;\n+\t      else if (!GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))\n+\t\ttmp = gfc_get_class_from_expr (rse->expr);\n+\t      else\n+\t\ttmp = rse->expr;\n+\n+\t      se.expr = gfc_class_vptr_get (tmp);\n \t      if (UNLIMITED_POLY (re))\n-\t\tfrom_len = gfc_class_len_get (rse->expr);\n+\t\tfrom_len = gfc_class_len_get (tmp);\n+\n \t    }\n \t  else if (re->expr_type != EXPR_NULL)\n \t    /* Only when rhs is non-NULL use its declared type for vptr\n@@ -9750,15 +9922,28 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n-  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)\n+  else if (gfc_bt_struct (ts.type))\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n       tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n \t\t\t     TREE_TYPE (lse->expr), rse->expr);\n       gfc_add_modify (&block, lse->expr, tmp);\n     }\n-  else\n+  /* If possible use the rhs vptr copy with trans_scalar_class_assign....  */\n+  else if (ts.type == BT_CLASS\n+\t   && !trans_scalar_class_assign (&block, lse, rse))\n+    {\n+      gfc_add_block_to_block (&block, &lse->pre);\n+      gfc_add_block_to_block (&block, &rse->pre);\n+      /* ...otherwise assignment suffices. Note the use of VIEW_CONVERT_EXPR\n+\t for the lhs which ensures that class data rhs cast as a string assigns\n+\t correctly.  */\n+      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t     TREE_TYPE (rse->expr), lse->expr);\n+      gfc_add_modify (&block, tmp, rse->expr);\n+    }\n+  else if (ts.type != BT_CLASS)\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n@@ -10666,31 +10851,61 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \t\t\tgfc_se *lse, gfc_se *rse, bool use_vptr_copy,\n \t\t\tbool class_realloc)\n {\n-  tree tmp, fcn, stdcopy, to_len, from_len, vptr;\n+  tree tmp, fcn, stdcopy, to_len, from_len, vptr, old_vptr;\n   vec<tree, va_gc> *args = NULL;\n \n+  /* Store the old vptr so that dynamic types can be compared for\n+     reallocation to occur or not.  */\n+  if (class_realloc)\n+    {\n+      tmp = lse->expr;\n+      if (!GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+\ttmp = gfc_get_class_from_expr (tmp);\n+    }\n+\n   vptr = trans_class_vptr_len_assignment (block, lhs, rhs, rse, &to_len,\n \t\t\t\t\t &from_len);\n \n-  /* Generate allocation of the lhs.  */\n+  /* Generate (re)allocation of the lhs.  */\n   if (class_realloc)\n     {\n-      stmtblock_t alloc;\n-      tree class_han;\n+      stmtblock_t alloc, re_alloc;\n+      tree class_han, re, size;\n \n-      tmp = gfc_vptr_size_get (vptr);\n+      if (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+\told_vptr = gfc_evaluate_now (gfc_class_vptr_get (tmp), block);\n+      else\n+\told_vptr = build_int_cst (TREE_TYPE (vptr), 0);\n+\n+      size = gfc_vptr_size_get (vptr);\n       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n \t  ? gfc_class_data_get (lse->expr) : lse->expr;\n+\n+      /* Allocate block.  */\n       gfc_init_block (&alloc);\n-      gfc_allocate_using_malloc (&alloc, class_han, tmp, NULL_TREE);\n+      gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);\n+\n+      /* Reallocate if dynamic types are different. */\n+      gfc_init_block (&re_alloc);\n+      re = build_call_expr_loc (input_location,\n+\t\t\t\tbuiltin_decl_explicit (BUILT_IN_REALLOC), 2,\n+\t\t\t\tfold_convert (pvoid_type_node, class_han),\n+\t\t\t\tsize);\n+      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     logical_type_node, vptr, old_vptr);\n+      re = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t    tmp, re, build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&re_alloc, re);\n+\n+      /* Allocate if _data is NULL, reallocate otherwise.  */\n       tmp = fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t     logical_type_node, class_han,\n \t\t\t     build_int_cst (prvoid_type_node, 0));\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t     gfc_unlikely (tmp,\n \t\t\t\t\t   PRED_FORTRAN_FAIL_ALLOC),\n \t\t\t     gfc_finish_block (&alloc),\n-\t\t\t     build_empty_stmt (input_location));\n+\t\t\t     gfc_finish_block (&re_alloc));\n       gfc_add_expr_to_block (&lse->pre, tmp);\n     }\n \n@@ -10793,6 +11008,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   bool maybe_workshare = false, lhs_refs_comp = false, rhs_refs_comp = false;\n   symbol_attribute lhs_caf_attr, rhs_caf_attr, lhs_attr;\n   bool is_poly_assign;\n+  bool realloc_flag;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -10833,6 +11049,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t       || gfc_is_class_array_ref (expr2, NULL)\n \t\t       || gfc_is_class_scalar_expr (expr2));\n \n+  realloc_flag = flag_realloc_lhs\n+\t\t && gfc_is_reallocatable_lhs (expr1)\n+\t\t && expr2->rank\n+\t\t && !is_runtime_conformable (expr1, expr2);\n \n   /* Only analyze the expressions for coarray properties, when in coarray-lib\n      mode.  */\n@@ -11077,8 +11297,9 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   if (is_poly_assign)\n     tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n \t\t\t\t  use_vptr_copy || (lhs_attr.allocatable\n-\t\t\t\t\t\t    && !lhs_attr.dimension),\n-\t\t\t\t  flag_realloc_lhs && !lhs_attr.pointer);\n+\t\t\t\t\t\t     && !lhs_attr.dimension),\n+\t\t\t\t  !realloc_flag && flag_realloc_lhs\n+\t\t\t\t  && !lhs_attr.pointer);\n   else if (flag_coarray == GFC_FCOARRAY_LIB\n \t   && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n \t   && ((lhs_caf_attr.allocatable && lhs_refs_comp)\n@@ -11108,7 +11329,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     {\n       /* This case comes about when the scalarizer provides array element\n \t references. Use the vptr copy function, since this does a deep\n-\t copy of allocatable components, without which the finalizer call */\n+\t copy of allocatable components, without which the finalizer call\n+\t will deallocate the components.  */\n       tmp = gfc_get_vptr_from_expr (rse.expr);\n       if (tmp != NULL_TREE)\n \t{\n@@ -11183,10 +11405,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t}\n \n       /* F2003: Allocate or reallocate lhs of allocatable array.  */\n-      if (flag_realloc_lhs\n-\t  && gfc_is_reallocatable_lhs (expr1)\n-\t  && expr2->rank\n-\t  && !is_runtime_conformable (expr1, expr2))\n+      if (realloc_flag)\n \t{\n \t  realloc_lhs_warning (expr1->ts.type, true, &expr1->where);\n \t  ompws_flags &= ~OMPWS_SCALARIZER_WS;\n@@ -11295,8 +11514,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \treturn tmp;\n     }\n \n-  if (UNLIMITED_POLY (expr1) && expr1->rank\n-      && expr2->ts.type != BT_CLASS)\n+  if (UNLIMITED_POLY (expr1) && expr1->rank)\n     use_vptr_copy = true;\n \n   /* Fallback to the scalarizer to generate explicit loops.  */"}, {"sha": "7ee2bd159fc9184c46f03996e2e5a23c1f357cf0", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -477,21 +477,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n       /* Check if this is an unlimited polymorphic object carrying a character\n \t payload. In this case, the 'len' field is non-zero.  */\n       if (decl && GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n-\t{\n-\t  tmp = gfc_class_len_or_zero_get (decl);\n-\t  if (!integer_zerop (tmp))\n-\t    {\n-\t      tree cond;\n-\t      tree stype = TREE_TYPE (span);\n-\t      tmp = fold_convert (stype, tmp);\n-\t      cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t      logical_type_node, tmp,\n-\t\t\t\t      build_int_cst (stype, 0));\n-\t      tmp = fold_build2 (MULT_EXPR, stype, span, tmp);\n-\t      span = fold_build3_loc (input_location, COND_EXPR, stype,\n-\t\t\t\t      cond, span, tmp);\n-\t    }\n-\t}\n+\tspan = gfc_resize_class_size_with_len (NULL, decl, span);\n     }\n   else if (decl)\n     span = get_array_span (type, decl);"}, {"sha": "a1613bd02f3f7a0495a7bebd87a2657b04508c4e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -423,6 +423,7 @@ tree gfc_class_data_get (tree);\n tree gfc_class_vptr_get (tree);\n tree gfc_class_len_get (tree);\n tree gfc_class_len_or_zero_get (tree);\n+tree gfc_resize_class_size_with_len (stmtblock_t *, tree, tree);\n gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);\n /* Get an accessor to the class' vtab's * field, when a class handle is\n    available.  */"}, {"sha": "4e5855f8fb8a1a62cf4fc3ea0037c9e9d0d4bd00", "filename": "gcc/testsuite/gfortran.dg/class_allocate_25.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_25.f90?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! In the course of fixing PR83118, lots of issues came up with class array\n+! assignment, where temporaries are generated. This testcase checks that\n+! the use of assignment by allocate with source is OK, especially with array\n+! constructors using class arrays. While this test did run previously, the\n+! temporaries for such arrays were malformed with the class as the type and\n+! element lengths of 72 bytes rather than the 4 bytes of the decalred type.\n+!\n+! Contributed by Dominique d'Humieres  <dhumieres.dominique@free.fr>\n+!\n+type t1\n+   integer :: i = 5\n+end type t1\n+type, extends(t1) :: t2\n+   integer :: j = 6\n+end type t2\n+\n+class(t1), allocatable :: a(:), b(:), c(:)\n+integer :: i\n+\n+allocate(t2 :: a(3))\n+allocate(t2 :: b(5))\n+if (.not.check_t1 (a, [(5, i = 1, 3)], 2)) stop 1\n+\n+allocate(c, source=[a, b ]) ! F2008, PR 44672\n+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 2\n+\n+deallocate(c)\n+allocate(c(8), source=[ a, b ])\n+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 3\n+\n+deallocate(c)\n+c = [t1 :: a, b ] ! F2008, PR 43366\n+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 4\n+deallocate(a, b, c)\n+\n+contains\n+\n+  logical function check_t1 (arg, array, t)\n+    class(t1) :: arg(:)\n+    integer :: array (:), t\n+    check_t1 = .true.\n+    select type (arg)\n+    type is (t1)\n+      if (any (arg%i .ne. array)) check_t1 = .false.\n+      if (t .eq. 2) check_t1 = .false.\n+    type is (t2)\n+      if (any (arg%i .ne. array)) check_t1 = .false.\n+      if (t .eq. 1) check_t1 = .false.\n+    class default\n+      check_t1 = .false.\n+    end select\n+  end function check_t1\n+\n+end\n+! { dg-final { scan-tree-dump-times \"elem_len=72\" 0 \"original\" } }"}, {"sha": "517e3121cc81d74c7a6a828012e136f4055ad677", "filename": "gcc/testsuite/gfortran.dg/class_assign_4.f90", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -0,0 +1,183 @@\n+! { dg-do run }\n+!\n+! In the course of fixing PR83118, lots of issues came up with class array\n+! assignment, where temporaries are generated. This testcase checks that\n+! it all works correctly.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module m\n+  implicit none\n+  type :: t1\n+    integer :: i\n+  CONTAINS\n+    PROCEDURE :: add_t1\n+    GENERIC :: OPERATOR(+) => add_t1\n+  end type\n+  type, extends(t1) :: t2\n+    real :: r\n+  end type\n+\n+contains\n+  impure elemental function add_t1 (a, b) result (c)\n+    class(t1), intent(in) :: a, b\n+    class(t1), allocatable :: c\n+    allocate (c, source = a)\n+    c%i = a%i + b%i\n+    select type (c)\n+      type is (t2)\n+      select type (b)\n+        type is (t2)\n+          c%r = c%r + b%r\n+      end select\n+    end select\n+  end function add_t1\n+\n+end module m\n+\n+subroutine test_t1\n+  use m\n+  implicit none\n+\n+  class(t1), dimension(:), allocatable :: x, y\n+\n+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]\n+  if (.not.check_t1 (x, [1,2,3], 2, [10, 20, 30]) ) stop 1\n+\n+  y = x\n+  x = realloc_t1 (y)\n+  if (.not.check_t1 (x, [3,2,1], 1) ) stop 2\n+\n+  x = realloc_t1 (x)\n+  if (.not.check_t1 (x, [2,3,1], 1) ) stop 3\n+\n+  x = x([3,1,2])\n+  if (.not.check_t1 (x, [1,2,3], 1) ) stop 4\n+\n+  x = x(3:1:-1) + y\n+  if (.not.check_t1 (x, [4,4,4], 1) ) stop 5\n+\n+  x = y + x(3:1:-1)\n+  if (.not.check_t1 (x, [5,6,7], 2) ) stop 6\n+\n+! Now check that the dynamic type survives assignments.\n+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]\n+  y = x\n+\n+  x = y(3:1:-1)\n+  if (.not.check_t1 (x, [3,2,1], 2, [30,20,10]) ) stop 7\n+\n+  x = x(3:1:-1) + y\n+  if (.not.check_t1 (x, [2,4,6], 2, [20,40,60]) ) stop 8\n+\n+  x = x(3:1:-1)\n+  if (.not.check_t1 (x, [6,4,2], 2, [60,40,20]) ) stop 9\n+\n+  x = x([3,2,1])\n+  if (.not.check_t1 (x, [2,4,6], 2, [20,40,60]) ) stop 10\n+\n+contains\n+\n+  function realloc_t1 (arg) result (res)\n+    class(t1), dimension(:), allocatable :: arg\n+    class(t1), dimension(:), allocatable :: res\n+    select type (arg)\n+      type is (t2)\n+        allocate (res, source = [t1 (arg(3)%i), t1 (arg(2)%i), t1 (arg(1)%i)])\n+      type is (t1)\n+        allocate (res, source = [t1 (arg(2)%i), t1 (arg(1)%i), t1 (arg(3)%i)])\n+    end select\n+  end function realloc_t1\n+\n+  logical function check_t1 (arg, array, t, array2)\n+    class(t1) :: arg(:)\n+    integer :: array (:), t\n+    integer, optional :: array2(:)\n+    check_t1 = .true.\n+    select type (arg)\n+    type is (t1)\n+      if (any (arg%i .ne. array)) check_t1 = .false.\n+      if (t .eq. 2) check_t1 = .false.\n+    type is (t2)\n+      if (any (arg%i .ne. array)) check_t1 = .false.\n+      if (t .eq. 1) check_t1 = .false.\n+      if (present (array2)) then\n+        if (any(int (arg%r) .ne. array2)) check_t1 = .false.\n+      end if\n+    class default\n+      check_t1 = .false.\n+    end select\n+  end function check_t1\n+\n+end subroutine test_t1\n+\n+subroutine test_star\n+  use m\n+  implicit none\n+\n+  class(*), dimension(:), allocatable :: x, y\n+\n+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]\n+  if (.not.check_star (x, [1,2,3], 2) ) stop 11\n+\n+  y = x\n+  x = realloc_star (y)\n+  if (.not.check_star (x, [3,2,1], 1) ) stop 12\n+\n+  x = realloc_star (x)\n+  if (.not.check_star (x, [2,3,1], 1) ) stop 13\n+\n+  x = x([3,1,2])\n+  if (.not.check_star (x, [1,2,3], 1) ) stop 14\n+\n+  x = x(3:1:-1)\n+  if (.not.check_star (x, [3,2,1], 1) ) stop 15\n+\n+! Make sure that all is similarly well with type t2.\n+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]\n+\n+  x = x([3,1,2])\n+  if (.not.check_star (x, [3,1,2], 2, [30,10,20]) ) stop 16\n+\n+  x = x(3:1:-1)\n+  if (.not.check_star (x, [2,1,3], 2, [20,10,30]) ) stop 17\n+\n+contains\n+\n+  function realloc_star (arg) result (res)\n+    class(*), dimension(:), allocatable :: arg\n+    class(*), dimension(:), allocatable :: res\n+    select type (arg)\n+      type is (t2)\n+         allocate (res, source = [t1 (arg(3)%i), t1 (arg(2)%i), t1 (arg(1)%i)])\n+      type is (t1)\n+         allocate (res, source = [t1 (arg(2)%i), t1 (arg(1)%i), t1 (arg(3)%i)])\n+    end select\n+  end function realloc_star\n+\n+  logical function check_star (arg, array, t, array2)\n+    class(*) :: arg(:)\n+    integer :: array (:), t\n+    integer, optional :: array2(:)\n+    check_star = .true.\n+    select type (arg)\n+      type is (t1)\n+        if (any (arg%i .ne. array)) check_star = .false.\n+        if (t .eq. 2) check_star = .false.\n+      type is (t2)\n+        if (any (arg%i .ne. array)) check_star = .false.\n+        if (t .eq. 1) check_star = .false.\n+        if (present (array2)) then\n+          if (any (int(arg%r) .ne. array2)) check_star = .false.\n+        endif\n+      class default\n+        check_star = .false.\n+    end select\n+  end function check_star\n+\n+end subroutine test_star\n+\n+\n+  call test_t1\n+  call test_star\n+end"}, {"sha": "bf108122f3ebc460b4b608d105b6f092f7f9d6a1", "filename": "gcc/testsuite/gfortran.dg/dependency_60.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_60.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_60.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_60.f90?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! PR 92755 - this used to cause an ICE (see dependency_57.f90)\n+! PR83118 - fixed so that it would run :-)\n+! Original test case by Gerhard Steinmetz\n+program p\n+   type t\n+     integer :: i\n+   end type\n+   type t2\n+      class(t), allocatable :: a(:)\n+   end type\n+   type(t2) :: z\n+   z%a = [t(1),t(2),t(3)]\n+   z%a = [z%a]\n+   select type (y => z%a)\n+     type is (t)\n+       if (any (y%i .ne. [1, 2, 3])) stop 1\n+   end select\n+end"}, {"sha": "23d0540526d0fc7e10848253b2f5634cf38548a7", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_32.f03", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_32.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce8dcc9105cbd4043d575d8b2c91309a423951a9/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_32.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_32.f03?ref=ce8dcc9105cbd4043d575d8b2c91309a423951a9", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+!\n+! Test the fix of the test case referenced in comment 17 of PR83118.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+  implicit none\n+  type Wrapper\n+    class(*), allocatable :: elements(:)\n+  end type\n+  type Mytype\n+    real(4) :: r = 42.0\n+  end type\n+\n+  call driver\n+contains\n+  subroutine driver\n+    class(*), allocatable :: obj\n+    type(Wrapper) w\n+    integer(4) :: expected4(2) = [42_4, 43_4]\n+    integer(8) :: expected8(3) = [42_8, 43_8, 44_8]\n+\n+    w = new_wrapper (expected4)\n+    obj = w\n+    call test (obj, 0)\n+    obj =  new_wrapper (expected8) ! Used to generate a linker error\n+    call test (obj, 10)\n+    obj = new_wrapper ([mytype (99.0)])\n+    call test (obj, 100)\n+    obj = Mytype (42.0) ! Used to generate a linker error\n+    call test (obj, 1000)\n+  end subroutine\n+  function new_wrapper(array) result (res)\n+    class(*) :: array(:)\n+    type(Wrapper) :: res\n+    res%elements = array ! Used to runtime segfault\n+  end function\n+  subroutine test (arg, idx)\n+    class(*) :: arg\n+    integer :: idx\n+    select type (arg)\n+      type is (wrapper)\n+        select type (z => arg%elements)\n+          type is (integer(4))\n+            if (any (z .ne. [42_4, 43_4])) stop 1 + idx\n+          type is (integer(8))\n+            if (any (z .ne. [42_8, 43_8, 44_8])) stop 1 + idx\n+          type is (Mytype)\n+            if (abs (z(1)%r - 99.0) .ge. 1e-6) stop 1 + idx\n+        class default\n+          stop 2 + idx\n+        end select\n+      type is (Mytype)\n+        if (abs (arg%r - 42.0) .ge. 1e-6) stop 1 + idx\n+      class default\n+        stop 3 + idx\n+    end select\n+  end subroutine\n+end"}]}