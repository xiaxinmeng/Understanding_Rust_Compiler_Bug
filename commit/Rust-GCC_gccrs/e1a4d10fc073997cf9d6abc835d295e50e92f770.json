{"sha": "e1a4d10fc073997cf9d6abc835d295e50e92f770", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhNGQxMGZjMDczOTk3Y2Y5ZDZhYmM4MzVkMjk1ZTUwZTkyZjc3MA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-07-23T09:53:53Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-07-23T09:53:53Z"}, "message": "boehm.cc (_Jv_BuildGCDescr): Wrote.\n\n\t* boehm.cc (_Jv_BuildGCDescr): Wrote.\n\tInclude limits.h.\n\nFrom-SVN: r69700", "tree": {"sha": "c95f1a561d15eef08aaefa8f0d22ac7220eda79b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c95f1a561d15eef08aaefa8f0d22ac7220eda79b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1a4d10fc073997cf9d6abc835d295e50e92f770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a4d10fc073997cf9d6abc835d295e50e92f770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1a4d10fc073997cf9d6abc835d295e50e92f770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a4d10fc073997cf9d6abc835d295e50e92f770/comments", "author": null, "committer": null, "parents": [{"sha": "5c798f921aa4118b8189aed1ab4f1dced24340dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c798f921aa4118b8189aed1ab4f1dced24340dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c798f921aa4118b8189aed1ab4f1dced24340dd"}], "stats": {"total": 51, "additions": 47, "deletions": 4}, "files": [{"sha": "cf97e58d82440034b1deba0b68bcc783d9b70417", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1a4d10fc073997cf9d6abc835d295e50e92f770/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1a4d10fc073997cf9d6abc835d295e50e92f770/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e1a4d10fc073997cf9d6abc835d295e50e92f770", "patch": "@@ -1,3 +1,8 @@\n+2003-07-22  Tom Tromey  <tromey@redhat.com>\n+\n+\t* boehm.cc (_Jv_BuildGCDescr): Wrote.\n+\tInclude limits.h.\n+\n 2003-07-22  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/Window.java (getWarningString): Just return the"}, {"sha": "8e621594bf264a86c6ee697cc92a1a88ff2b076c", "filename": "libjava/boehm.cc", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1a4d10fc073997cf9d6abc835d295e50e92f770/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1a4d10fc073997cf9d6abc835d295e50e92f770/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=e1a4d10fc073997cf9d6abc835d295e50e92f770", "patch": "@@ -1,6 +1,6 @@\n // boehm.cc - interface between libjava and Boehm GC.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,6 +11,7 @@ details.  */\n #include <config.h>\n \n #include <stdio.h>\n+#include <limits.h>\n \n #include <jvm.h>\n #include <gcj/cni.h>\n@@ -325,11 +326,48 @@ _Jv_MarkArray (void *addr, void *msp, void *msl, void * /*env*/)\n // since another one could be registered first.  But the compiler also\n // knows this, so in that case everything else will break, too.\n #define GCJ_DEFAULT_DESCR GC_MAKE_PROC(GC_GCJ_RESERVED_MARK_PROC_INDEX,0)\n+\n void *\n-_Jv_BuildGCDescr(jclass)\n+_Jv_BuildGCDescr(jclass self)\n {\n-  /* FIXME: We should really look at the class and build the descriptor. */\n-  return (void *)(GCJ_DEFAULT_DESCR);\n+  jlong desc = 0;\n+\n+  // Note: for now we only consider a bitmap mark descriptor.  We\n+  // could also handle the case where the first N fields of a type are\n+  // references.  However, this is not very likely to be used by many\n+  // classes, and it is easier to compute things this way.\n+\n+  for (jclass klass = self; klass != NULL; klass = klass->getSuperclass())\n+    {\n+      jfieldID field = JvGetFirstInstanceField(klass);\n+      int count = JvNumInstanceFields(klass);\n+\n+      for (int i = 0; i < count; ++i)\n+\t{\n+\t  if (field->isRef())\n+\t    {\n+\t      unsigned int off = field->getOffset();\n+\t      // If we run into a weird situation, we bail.\n+\t      if (off % sizeof (void *) != 0)\n+\t\treturn (void *) (GCJ_DEFAULT_DESCR);\n+\t      off /= sizeof (void *);\n+\t      // Bottom 2 bits are reserved.\n+\t      off += 2;\n+\t      // If we find a field outside the range of our bitmap,\n+\t      // fall back to procedure marker.\n+\t      if (off > CHAR_BIT * sizeof (void *))\n+\t\treturn (void *) (GCJ_DEFAULT_DESCR);\n+\t      desc |= 1 << off;\n+\t    }\n+\n+\t  field = field->getNextField();\n+\t}\n+    }\n+\n+  // For bitmap mark type, bottom bits are 01.\n+  desc |= 1;\n+  // Bogus warning avoidance (on many platforms).\n+  return (void *) (unsigned long) desc;\n }\n \n // Allocate some space that is known to be pointer-free."}]}