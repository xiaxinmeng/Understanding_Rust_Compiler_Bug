{"sha": "95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "node_id": "C_kwDOANBUbNoAKDk1Mzc1ZmZiM2RkNTlmNTFlNzk0MDhkZDNiMmI2MjBkYzFhZjcxYjE", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-01T09:27:36Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:54Z"}, "message": "fortran: Support clobbering of allocatables and pointers [PR41453]\n\nThis adds support for clobbering of allocatable and pointer scalar\nvariables passed as actual argument to a subroutine when the associated\ndummy has the INTENT(OUT) attribute.\nSupport was explicitly disabled (since the beginning for pointers, since\nr11-7315-g2df374b337a5f6cf5528e91718e4e12e4006b7ae for allocatables),\nbut the clobber generation code seems to support it well, as\ndemonstrated by the newly added testcase.\n\n\tPR fortran/41453\n\tPR fortran/99169\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Remove conditions\n\ton ALLOCATABLE and POINTER attributes guarding clobber\n\tgeneration.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_9.f90: New test.", "tree": {"sha": "15a4d6e59420f2ba7b4fe123e155180d492808a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15a4d6e59420f2ba7b4fe123e155180d492808a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95375ffb3dd59f51e79408dd3b2b620dc1af71b1/comments", "author": null, "committer": null, "parents": [{"sha": "d5e1935b09fa05093e31d7ce5e21b7e71957c103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e1935b09fa05093e31d7ce5e21b7e71957c103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e1935b09fa05093e31d7ce5e21b7e71957c103"}], "stats": {"total": 44, "additions": 42, "deletions": 2}, "files": [{"sha": "52b96fa6cf6f75901e64e82ee3d4eb3628be1fd5", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95375ffb3dd59f51e79408dd3b2b620dc1af71b1/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95375ffb3dd59f51e79408dd3b2b620dc1af71b1/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "patch": "@@ -6525,8 +6525,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && e->symtree\n \t\t\t  && e->symtree->n.sym\n \t\t\t  && !e->symtree->n.sym->attr.dimension\n-\t\t\t  && !e->symtree->n.sym->attr.pointer\n-\t\t\t  && !e->symtree->n.sym->attr.allocatable\n \t\t\t  && e->ts.type != BT_CHARACTER\n \t\t\t  && e->ts.type != BT_DERIVED\n \t\t\t  && e->ts.type != BT_CLASS"}, {"sha": "0146dff4e203b94bba0b06b6ab8dc86ca26cf4bb", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_9.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95375ffb3dd59f51e79408dd3b2b620dc1af71b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95375ffb3dd59f51e79408dd3b2b620dc1af71b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90?ref=95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constants to be optimized away in the *.optimized dump,\n+! in the case of scalar allocatables and pointers.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer, intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, allocatable :: ca\n+  integer, target :: ct\n+  integer, pointer :: cp\n+\n+  allocate(ca)\n+  ca = 123456789\n+  call foo(ca)\n+  if (ca /= 42) stop 1\n+  deallocate(ca)\n+\n+  ct = 987654321\n+  cp => ct\n+  call foo(cp)\n+  if (ct /= 42) stop 2\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*ca = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*cp = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }\n+! { dg-final { scan-tree-dump-not \"987654321\" \"optimized\" { target __OPTIMIZE__ } } }"}]}