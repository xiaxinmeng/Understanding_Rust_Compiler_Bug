{"sha": "5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0Mjk4ODZjNWUzOTBhMGQ3YWUyNzMxMWY4NTlkMmFlMWQ0YjJjMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-10-16T06:50:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-10-16T06:50:30Z"}, "message": "re PR tree-optimization/37525 (IVOPTS difference causing 20% degradation in 173.applu benchmark)\n\n\tPR tree-optimization/37525\n\t* tree.c (int_fits_type_p): Rewrite using double_int.  Zero extend\n\tsizetype unsigned constants, both in the case of C and bounds.\n\nFrom-SVN: r141164", "tree": {"sha": "9fa058951dd970add438b293d8a95bfcf27b9c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa058951dd970add438b293d8a95bfcf27b9c5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c39a4ad7a8e2e494432980bdaff5d4b378b50bb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39a4ad7a8e2e494432980bdaff5d4b378b50bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c39a4ad7a8e2e494432980bdaff5d4b378b50bb2"}], "stats": {"total": 111, "additions": 79, "deletions": 32}, "files": [{"sha": "057069dc57da0c55e7b9511f6d39f5bb14b86ace", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "patch": "@@ -1,3 +1,9 @@\n+2008-10-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/37525\n+\t* tree.c (int_fits_type_p): Rewrite using double_int.  Zero extend\n+\tsizetype unsigned constants, both in the case of C and bounds.\n+\n 2008-10-15  Jan Hubicka  <jh@suse.cz>\n \n \t* ira-emit.c (change_regs): Return false when replacing reg by"}, {"sha": "7064e06bcece9ceb974de38a9b8f3892a82435a8", "filename": "gcc/tree.c", "status": "modified", "additions": 73, "deletions": 32, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b429886c5e390a0d7ae27311f859d2ae1d4b2c1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5b429886c5e390a0d7ae27311f859d2ae1d4b2c1", "patch": "@@ -6406,11 +6406,28 @@ get_narrower (tree op, int *unsignedp_ptr)\n int\n int_fits_type_p (const_tree c, const_tree type)\n {\n-  tree type_low_bound = TYPE_MIN_VALUE (type);\n-  tree type_high_bound = TYPE_MAX_VALUE (type);\n-  bool ok_for_low_bound, ok_for_high_bound;\n-  unsigned HOST_WIDE_INT low;\n-  HOST_WIDE_INT high;\n+  tree type_low_bound, type_high_bound;\n+  bool ok_for_low_bound, ok_for_high_bound, unsc;\n+  double_int dc, dd;\n+\n+  dc = tree_to_double_int (c);\n+  unsc = TYPE_UNSIGNED (TREE_TYPE (c));\n+\n+  if (TREE_CODE (TREE_TYPE (c)) == INTEGER_TYPE\n+      && TYPE_IS_SIZETYPE (TREE_TYPE (c))\n+      && unsc)\n+    /* So c is an unsigned integer whose type is sizetype and type is not.\n+       sizetype'd integers are sign extended even though they are\n+       unsigned. If the integer value fits in the lower end word of c,\n+       and if the higher end word has all its bits set to 1, that\n+       means the higher end bits are set to 1 only for sign extension.\n+       So let's convert c into an equivalent zero extended unsigned\n+       integer.  */\n+    dc = double_int_zext (dc, TYPE_PRECISION (TREE_TYPE (c)));\n+\n+retry:\n+  type_low_bound = TYPE_MIN_VALUE (type);\n+  type_high_bound = TYPE_MAX_VALUE (type);\n \n   /* If at least one bound of the type is a constant integer, we can check\n      ourselves and maybe make a decision. If no such decision is possible, but\n@@ -6422,25 +6439,25 @@ int_fits_type_p (const_tree c, const_tree type)\n      for \"unknown if constant fits\", 0 for \"constant known *not* to fit\" and 1\n      for \"constant known to fit\".  */\n \n-  if (TREE_TYPE (c) == sizetype\n-      && TYPE_UNSIGNED (TREE_TYPE (c))\n-      && TREE_INT_CST_HIGH (c) == -1\n-      && !TREE_OVERFLOW (c))\n-      /* So c is an unsigned integer which type is sizetype.\n-         sizetype'd integers are sign extended even though they are\n-\t unsigned. If the integer value fits in the lower end word of c,\n-\t and if the higher end word has all its bits set to 1, that\n-\t means the higher end bits are set to 1 only for sign extension.\n-\t So let's convert c into an equivalent zero extended unsigned\n-\t integer.  */\n-      c = force_fit_type_double (size_type_node,\n-\t\t\t\t TREE_INT_CST_LOW (c),\n-\t\t\t\t TREE_INT_CST_HIGH (c),\n-\t\t\t\t false, false);\n-  /* Check if C >= type_low_bound.  */\n+  /* Check if c >= type_low_bound.  */\n   if (type_low_bound && TREE_CODE (type_low_bound) == INTEGER_CST)\n     {\n-      if (tree_int_cst_lt (c, type_low_bound))\n+      dd = tree_to_double_int (type_low_bound);\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_IS_SIZETYPE (type)\n+\t  && TYPE_UNSIGNED (type))\n+\tdd = double_int_zext (dd, TYPE_PRECISION (type));\n+      if (unsc != TYPE_UNSIGNED (TREE_TYPE (type_low_bound)))\n+\t{\n+\t  int c_neg = (!unsc && double_int_negative_p (dc));\n+\t  int t_neg = (unsc && double_int_negative_p (dd));\n+\n+\t  if (c_neg && !t_neg)\n+\t    return 0;\n+\t  if ((c_neg || !t_neg) && double_int_ucmp (dc, dd) < 0)\n+\t    return 0;\n+\t}\n+      else if (double_int_cmp (dc, dd, unsc) < 0)\n \treturn 0;\n       ok_for_low_bound = true;\n     }\n@@ -6450,7 +6467,22 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* Check if c <= type_high_bound.  */\n   if (type_high_bound && TREE_CODE (type_high_bound) == INTEGER_CST)\n     {\n-      if (tree_int_cst_lt (type_high_bound, c))\n+      dd = tree_to_double_int (type_high_bound);\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_IS_SIZETYPE (type)\n+\t  && TYPE_UNSIGNED (type))\n+\tdd = double_int_zext (dd, TYPE_PRECISION (type));\n+      if (unsc != TYPE_UNSIGNED (TREE_TYPE (type_high_bound)))\n+\t{\n+\t  int c_neg = (!unsc && double_int_negative_p (dc));\n+\t  int t_neg = (unsc && double_int_negative_p (dd));\n+\n+\t  if (t_neg && !c_neg)\n+\t    return 0;\n+\t  if ((t_neg || !c_neg) && double_int_ucmp (dc, dd) > 0)\n+\t    return 0;\n+\t}\n+      else if (double_int_cmp (dc, dd, unsc) > 0)\n \treturn 0;\n       ok_for_high_bound = true;\n     }\n@@ -6464,31 +6496,40 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* Perform some generic filtering which may allow making a decision\n      even if the bounds are not constant.  First, negative integers\n      never fit in unsigned types, */\n-  if (TYPE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n+  if (TYPE_UNSIGNED (type) && !unsc && double_int_negative_p (dc))\n     return 0;\n \n   /* Second, narrower types always fit in wider ones.  */\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (c)))\n     return 1;\n \n   /* Third, unsigned integers with top bit set never fit signed types.  */\n-  if (! TYPE_UNSIGNED (type)\n-      && TYPE_UNSIGNED (TREE_TYPE (c))\n-      && tree_int_cst_msb (c))\n-    return 0;\n+  if (! TYPE_UNSIGNED (type) && unsc)\n+    {\n+      int prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (c))) - 1;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  if (((((unsigned HOST_WIDE_INT) 1) << prec) & dc.low) != 0)\n+\t    return 0;\n+        }\n+      else if (((((unsigned HOST_WIDE_INT) 1)\n+\t\t << (prec - HOST_BITS_PER_WIDE_INT)) & dc.high) != 0)\n+\treturn 0;\n+    }\n \n   /* If we haven't been able to decide at this point, there nothing more we\n      can check ourselves here.  Look at the base type if we have one and it\n      has the same precision.  */\n   if (TREE_CODE (type) == INTEGER_TYPE\n       && TREE_TYPE (type) != 0\n       && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (type)))\n-    return int_fits_type_p (c, TREE_TYPE (type));\n+    {\n+      type = TREE_TYPE (type);\n+      goto retry;\n+    }\n \n   /* Or to fit_double_type, if nothing else.  */\n-  low = TREE_INT_CST_LOW (c);\n-  high = TREE_INT_CST_HIGH (c);\n-  return !fit_double_type (low, high, &low, &high, type);\n+  return !fit_double_type (dc.low, dc.high, &dc.low, &dc.high, type);\n }\n \n /* Stores bounds of an integer TYPE in MIN and MAX.  If TYPE has non-constant"}]}