{"sha": "fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2YzJkYjk5YWM1MDExZjNiM2ZjMjJlZTg2ZTA1MDI1MzhiYjdlOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-15T19:25:22Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-15T19:25:22Z"}, "message": "cpplib.c (start_directive, [...]): New functions.\n\n        * cpplib.c (start_directive, end_directive): New functions.\n        (_cpp_handle_directive, run_directive): Use them.\n        (_cpp_handle_directive): Don't -Wtraditional on indented\n        null directives.\n        (_cpp_push_buffer): Don't re-clear was_skipping.\n        * cpplib.h (struct cpp_reader): New member la_saved.\n        * cppmacro.c (cpp_get_token): Don't interpret _Pragma in\n        directives.\n\nFrom-SVN: r37487", "tree": {"sha": "c0d3e0b141751cde227115dc9b911f8e8050ca84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d3e0b141751cde227115dc9b911f8e8050ca84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/comments", "author": null, "committer": null, "parents": [{"sha": "cbc2c182d1de2ffc2f5f15db9b96fd0c3dafe815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc2c182d1de2ffc2f5f15db9b96fd0c3dafe815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc2c182d1de2ffc2f5f15db9b96fd0c3dafe815"}], "stats": {"total": 151, "additions": 92, "deletions": 59}, "files": [{"sha": "473cd0d83cb10211b0c6053b275a19a659098fe6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "patch": "@@ -1,3 +1,17 @@\n+2000-11-15  Neil Booth  <neilb@earthling.net>\n+\n+        * cpplib.c (start_directive, end_directive): New functions.\n+        (_cpp_handle_directive, run_directive): Use them.\n+        (_cpp_handle_directive): Don't -Wtraditional on indented\n+        null directives.\n+        (_cpp_push_buffer): Don't re-clear was_skipping.\n+        * cpplib.h (struct cpp_reader): New member la_saved.\n+        * cppmacro.c (cpp_get_token): Don't interpret _Pragma in\n+        directives.\n+\n+        gcc.dg/cpp/_Pragma1.c: Update.\n+        gcc.dg/cpp/_Pragma2.c: New test.\n+\n 2000-11-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* toplev.c (wrapup_global_declarations): Don't write out"}, {"sha": "f85851774486a4a698f5de7b0fd4d764a5fba3fa", "filename": "gcc/cpplib.c", "status": "modified", "additions": 73, "deletions": 58, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "patch": "@@ -81,6 +81,8 @@ struct directive\n \n static void skip_rest_of_line\tPARAMS ((cpp_reader *));\n static void check_eol\t\tPARAMS ((cpp_reader *));\n+static void start_directive\tPARAMS ((cpp_reader *));\n+static void end_directive\tPARAMS ((cpp_reader *, int));\n static void run_directive\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t const char *, size_t,\n \t\t\t\t\t const char *));\n@@ -214,18 +216,12 @@ check_eol (pfile)\n     }\n }\n \n-/* Check if a token's name matches that of a known directive.  Put in\n-   this file to save exporting dtable and other unneeded information.  */\n-int\n-_cpp_handle_directive (pfile, indented)\n+/* Called when entering a directive, _Pragma or command-line directive.  */\n+static void\n+start_directive (pfile)\n      cpp_reader *pfile;\n-     int indented;\n {\n-  struct cpp_lookahead *la_saved;\n   cpp_buffer *buffer = pfile->buffer;\n-  const directive *dir = 0;\n-  cpp_token dname;\n-  int not_asm = 1;\n \n   /* Setup in-directive state.  */\n   pfile->state.in_directive = 1;\n@@ -235,9 +231,52 @@ _cpp_handle_directive (pfile, indented)\n   pfile->directive_pos = pfile->lexer_pos;\n \n   /* Don't save directive tokens for external clients.  */\n-  la_saved = pfile->la_write;\n+  pfile->la_saved = pfile->la_write;\n   pfile->la_write = 0;\n \n+  /* Turn off skipping.  */\n+  buffer->was_skipping = pfile->skipping;\n+  pfile->skipping = 0;\n+}\n+\n+/* Called when leaving a directive, _Pragma or command-line directive.  */\n+static void\n+end_directive (pfile, skip_line)\n+     cpp_reader *pfile;\n+     int skip_line;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+\n+  /* Restore pfile->skipping before skip_rest_of_line.  This avoids\n+     warning about poisoned identifiers in skipped #error lines.  */\n+  pfile->skipping = buffer->was_skipping;\n+\n+  /* We don't skip for an assembler #.  */\n+  if (skip_line)\n+    skip_rest_of_line (pfile);\n+\n+  /* Restore state.  */\n+  pfile->la_write = pfile->la_saved;\n+  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n+  pfile->state.in_directive = 0;\n+  pfile->state.angled_headers = 0;\n+  pfile->directive = 0;\n+}\n+\n+/* Check if a token's name matches that of a known directive.  Put in\n+   this file to save exporting dtable and other unneeded information.  */\n+int\n+_cpp_handle_directive (pfile, indented)\n+     cpp_reader *pfile;\n+     int indented;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  const directive *dir = 0;\n+  cpp_token dname;\n+  int skip = 1;\n+\n+  start_directive (pfile);\n+\n   /* Lex the directive name directly.  */\n   _cpp_lex_token (pfile, &dname);\n \n@@ -254,7 +293,7 @@ _cpp_handle_directive (pfile, indented)\n \t skipped conditional groups.  Complain about this form if\n \t we're being pedantic, but not if this is regurgitated input\n \t (preprocessed or fed back in by the C++ frontend).  */\n-      if (! pfile->skipping  && !CPP_OPTION (pfile, lang_asm))\n+      if (! buffer->was_skipping  && !CPP_OPTION (pfile, lang_asm))\n \t{\n \t  dir = &dtable[T_LINE];\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n@@ -294,7 +333,7 @@ _cpp_handle_directive (pfile, indented)\n \n \t  /* If we are skipping a failed conditional group, all\n \t     non-conditional directives are ignored.  */\n-\t  if (! pfile->skipping || (dir->flags & COND))\n+\t  if (! buffer->was_skipping || (dir->flags & COND))\n \t    {\n \t      /* Issue -pedantic warnings for extensions.   */\n \t      if (CPP_PEDANTIC (pfile) && dir->origin == EXTENSION)\n@@ -305,20 +344,11 @@ _cpp_handle_directive (pfile, indented)\n \t      if (! (dir->flags & IF_COND))\n \t\tpfile->mi_state = MI_FAILED;\n \n-\t      buffer->was_skipping = pfile->skipping;\n-\t      pfile->skipping = 0;\n \t      (*dir->handler) (pfile);\n-\t      pfile->skipping = buffer->was_skipping;\n \t    }\n \t}\n     }\n-  else if (dname.type == CPP_EOF)\n-    {\n-      /* The null directive.  */\n-      if (indented && CPP_WTRADITIONAL (pfile))\n-\tcpp_warning (pfile, \"traditional C ignores #\\\\n with the # indented\");\n-    }\n-  else if (!pfile->skipping)\n+  else if (dname.type != CPP_EOF && ! pfile->skipping)\n     {\n       /* An unknown directive.  Don't complain about it in assembly\n \t source: we don't know where the comments are, and # may\n@@ -327,26 +357,16 @@ _cpp_handle_directive (pfile, indented)\n       if (CPP_OPTION (pfile, lang_asm))\n \t{\n \t  /* Output the # and lookahead token for the assembler.  */\n-\t  not_asm = 0;\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n+\t  skip = 0;\n \t}\n       else\n \tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n \t\t   cpp_token_as_text (pfile, &dname));\n     }\n \n-  /* Save the lookahead token for assembler.  */\n-  if (not_asm)\n-    skip_rest_of_line (pfile);\n-\n-  /* Restore state.  */\n-  pfile->la_write = la_saved;\n-  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n-  pfile->state.in_directive = 0;\n-  pfile->state.angled_headers = 0;\n-  pfile->directive = 0;\n-\n-  return not_asm;\n+  end_directive (pfile, skip);\n+  return skip;\n }\n \n /* Directive handler wrapper used by the command line option\n@@ -360,41 +380,37 @@ run_directive (pfile, dir_no, buf, count, name)\n      const char *name;\n {\n   unsigned int output_line = pfile->lexer_pos.output_line;\n+  cpp_buffer *buffer = cpp_push_buffer (pfile, (const U_CHAR *) buf, count);\n \n-  if (cpp_push_buffer (pfile, (const U_CHAR *) buf, count) != NULL)\n+  if (buffer)\n     {\n-      const struct directive *dir = &dtable[dir_no], *orig_dir;\n-      unsigned char orig_in_directive;\n+      const struct directive *dir = &dtable[dir_no];\n \n       if (name)\n-\tCPP_BUFFER (pfile)->nominal_fname = name;\n+\tbuffer->nominal_fname = name;\n       else\n-\tCPP_BUFFER (pfile)->nominal_fname = _(\"<command line>\");\n-\n-      /* A kludge to avoid line markers for _Pragma.  */\n-      if (dir_no == T_PRAGMA)\n-\tpfile->lexer_pos.output_line = output_line;\n-\n-      /* Save any in-process directive; _Pragma can appear in one.  */\n-      orig_dir = pfile->directive;\n-      orig_in_directive = pfile->state.in_directive;\n+\tbuffer->nominal_fname = _(\"<command line>\");\n \n       /* For _Pragma, the text is passed through preprocessing stage 3\n \t only, i.e. no trigraphs, no escaped newline removal, and no\n \t macro expansion.  Do the same for command-line directives.  */\n-      pfile->buffer->from_stage3 = 1;\n-      pfile->state.in_directive = 1;\n-      pfile->directive = dir;\n+      buffer->from_stage3 = 1;\n+\n+      if (dir_no == T_PRAGMA)\n+\t{\n+\t  /* A kludge to avoid line markers for _Pragma.  */\n+\t  pfile->lexer_pos.output_line = output_line;\n+\t  /* Avoid interpretation of directives in a _Pragma string.  */\n+\t  pfile->state.next_bol = 0;\n+\t}\n+\n+      start_directive (pfile);\n       pfile->state.prevent_expansion++;\n       (void) (*dir->handler) (pfile);\n       pfile->state.prevent_expansion--;\n-      pfile->directive = orig_dir;\n-      pfile->state.in_directive = orig_in_directive;\n+      check_eol (pfile);\n+      end_directive (pfile, 1);\n \n-      skip_rest_of_line (pfile);\n-      if (pfile->buffer->cur != pfile->buffer->rlimit)\n-\tcpp_error (pfile, \"extra text after end of #%s directive\",\n-\t\t   dtable[dir_no].name);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1713,7 +1729,6 @@ cpp_push_buffer (pfile, buffer, length)\n   new->rlimit = buffer + length;\n   new->prev = buf;\n   new->pfile = pfile;\n-  new->was_skipping = 0;\n   /* Preprocessed files don't do trigraph and escaped newline processing.  */\n   new->from_stage3 = CPP_OPTION (pfile, preprocessed);\n   /* No read ahead or extra char initially.  */"}, {"sha": "8c1a439b16fb73fdcd42bab4257536035937e3d4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "patch": "@@ -562,6 +562,7 @@ struct cpp_reader\n   struct cpp_lookahead *la_read;\t/* Read from this lookahead.  */\n   struct cpp_lookahead *la_write;\t/* Write to this lookahead.  */\n   struct cpp_lookahead *la_unused;\t/* Free store.  */\n+  struct cpp_lookahead *la_saved;\t/* Backup when entering directive.  */\n \n   /* Error counter for exit code.  */\n   unsigned int errors;"}, {"sha": "fcaa7c6df6a3055e5888bbf4f9d0ccbb6e5175f7", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=fe6c2db99ac5011f3b3fc22ee86e0502538bb7e9", "patch": "@@ -959,7 +959,10 @@ cpp_get_token (pfile, token)\n \t    continue;\n \t}\n \n-      if (token->val.node != pfile->spec_nodes.n__Pragma)\n+      /* Don't interpret _Pragma within directives.  The standard is\n+         not clear on this, but to me this makes most sense.  */\n+      if (token->val.node != pfile->spec_nodes.n__Pragma\n+\t  || pfile->state.in_directive)\n \tbreak;\n \n       /* Handle it, and loop back for another token.  MI is cleared"}]}