{"sha": "7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxNzM3ZDA3YTZiODY5MTIwZDdmY2E5YmQ3NTVjOWU0MjZhMGJmZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-03-16T10:11:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-03-16T10:11:14Z"}, "message": "re PR tree-optimization/31146 (forwprop does not look through casts)\n\n2007-03-16  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/31146\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Restructure\n\tto allow recursion of forward_propagate_addr_expr.\n\t(forward_propagate_addr_into_variable_array_index): Likewise.\n\t(forward_propagate_addr_expr): Likewise.\n\t(tree_ssa_forward_propagate_single_use_vars): Likewise.\n\t(forward_propagate_addr_expr_1): Recurse on simple copies\n\tinstead of propagating into them.  Do so for useless conversions\n\tas well.\n\t(forward_propagate_addr_expr): Clean up unused statements after\n\trecursion.\n\n\t* g++.dg/tree-ssa/pr31146.C: New testcase.\n\nFrom-SVN: r122985", "tree": {"sha": "6c8e4f3d768e11469247eb484982dd5b0f51b792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c8e4f3d768e11469247eb484982dd5b0f51b792"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3811dfcdcdfedc8461aacb29b64c4fd6c0ef10ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3811dfcdcdfedc8461aacb29b64c4fd6c0ef10ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3811dfcdcdfedc8461aacb29b64c4fd6c0ef10ad"}], "stats": {"total": 115, "additions": 81, "deletions": 34}, "files": [{"sha": "e85b40d8018db6a56fd55fc77dcfd17a2dccebe8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "patch": "@@ -1,3 +1,17 @@\n+2007-03-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31146\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Restructure\n+\tto allow recursion of forward_propagate_addr_expr.\n+\t(forward_propagate_addr_into_variable_array_index): Likewise.\n+\t(forward_propagate_addr_expr): Likewise.\n+\t(tree_ssa_forward_propagate_single_use_vars): Likewise.\n+\t(forward_propagate_addr_expr_1): Recurse on simple copies\n+\tinstead of propagating into them.  Do so for useless conversions\n+\tas well.\n+\t(forward_propagate_addr_expr): Clean up unused statements after\n+\trecursion.\n+\n 2007-03-16  Richard Guenther  <rguenther@suse.de>\n \n \t* builtins.c (expand_builtin_cexpi): Use the right argument"}, {"sha": "1b47256ea3d629ca56fbc92a80bf19b2fd48cd76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "patch": "@@ -1,3 +1,8 @@\n+2007-03-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31146\n+\t* g++.dg/tree-ssa/pr31146.C: New testcase.\n+\n 2007-03-16  Richard Sandiford  <richard@codesourcery.com>\n \n \t* lib/target-supports.exp (check_missing_uclibc_feature): Don't"}, {"sha": "e91d17415b32fc4e714288dd725bf09011dc4cf5", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr31146.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C?ref=7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n+\n+/* We should be able to optimize this to i[j] = 1 during\n+   early optimizations.  */\n+\n+int i[5];\n+void foo (int j)\n+{\n+  void *p = &i[j];\n+  int *q = (int *)p;\n+  *q = 1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"i\\\\\\[j.*\\\\\\] = 1;\" \"forwprop1\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "a755a4a4fc3ee803fbd738944961215a0e1e35db", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1737d07a6b869120d7fca9bd755c9e426a0bfe/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "patch": "@@ -149,6 +149,7 @@ Boston, MA 02110-1301, USA.  */\n \n    This will (of course) be extended as other needs arise.  */\n \n+static bool forward_propagate_addr_expr (tree name, tree rhs);\n \n /* Set to true if we delete EH edges during the optimization.  */\n static bool cfg_changed;\n@@ -591,7 +592,7 @@ tidy_after_forward_propagate_addr (tree stmt)\n   mark_symbols_for_renaming (stmt);\n }\n \n-/* STMT defines LHS which is contains the address of the 0th element\n+/* DEF_RHS defines LHS which is contains the address of the 0th element\n    in an array.  USE_STMT uses LHS to compute the address of an\n    arbitrary element within the array.  The (variable) byte offset\n    of the element is contained in OFFSET.\n@@ -608,7 +609,7 @@ tidy_after_forward_propagate_addr (tree stmt)\n \n static bool\n forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n-\t\t\t\t\t\t  tree stmt, tree use_stmt)\n+\t\t\t\t\t\t  tree def_rhs, tree use_stmt)\n {\n   tree index;\n \n@@ -650,8 +651,7 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n   index = TREE_OPERAND (offset, 0);\n \n   /* Replace the pointer addition with array indexing.  */\n-  GIMPLE_STMT_OPERAND (use_stmt, 1)\n-    = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n+  GIMPLE_STMT_OPERAND (use_stmt, 1) = unshare_expr (def_rhs);\n   TREE_OPERAND (TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0), 1)\n     = index;\n \n@@ -662,7 +662,8 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n   return true;\n }\n \n-/* STMT is a statement of the form SSA_NAME = ADDR_EXPR <whatever>.\n+/* NAME is a SSA_NAME representing DEF_RHS which is of the form\n+   ADDR_EXPR <whatever>.\n \n    Try to forward propagate the ADDR_EXPR into the use USE_STMT.\n    Often this will allow for removal of an ADDR_EXPR and INDIRECT_REF\n@@ -672,9 +673,8 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n    be not totally successful, yet things may have been changed).  */\n \n static bool\n-forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n+forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt)\n {\n-  tree name = GIMPLE_STMT_OPERAND (stmt, 0);\n   tree lhs, rhs, array_ref;\n \n   /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS. \n@@ -683,36 +683,37 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n   while (TREE_CODE (lhs) == COMPONENT_REF || TREE_CODE (lhs) == ARRAY_REF)\n     lhs = TREE_OPERAND (lhs, 0);\n \n+  rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n+\n   /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so, \n      propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n   if (TREE_CODE (lhs) == INDIRECT_REF && TREE_OPERAND (lhs, 0) == name)\n     {\n       /* This should always succeed in creating gimple, so there is\n \t no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (lhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n+      TREE_OPERAND (lhs, 0) = unshare_expr (def_rhs);\n       fold_stmt_inplace (use_stmt);\n       tidy_after_forward_propagate_addr (use_stmt);\n-    }\n \n-  /* Trivial case.  The use statement could be a trivial copy.  We\n-     go ahead and handle that case here since it's trivial and\n-     removes the need to run copy-prop before this pass to get\n-     the best results.  Also note that by handling this case here\n-     we can catch some cascading effects, ie the single use is\n-     in a copy, and the copy is used later by a single INDIRECT_REF\n-     for example.  */\n-  else if (TREE_CODE (lhs) == SSA_NAME\n-      \t   && GIMPLE_STMT_OPERAND (use_stmt, 1) == name)\n-    {\n-      GIMPLE_STMT_OPERAND (use_stmt, 1)\n-\t= unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n-      tidy_after_forward_propagate_addr (use_stmt);\n-      return true;\n+      /* The only case we did not replace all uses this way is if the\n+\t use statement is of the form *name = name.  */\n+      return rhs != name;\n     }\n \n+  /* Trivial case.  The use statement could be a trivial copy or a\n+     useless conversion.  Recurse to the uses of the lhs as copyprop does\n+     not copy through differen variant pointers and FRE does not catch\n+     all useless conversions.  */\n+  else if ((TREE_CODE (lhs) == SSA_NAME\n+      \t    && rhs == name)\n+\t   || ((TREE_CODE (rhs) == NOP_EXPR\n+\t\t|| TREE_CODE (rhs) == CONVERT_EXPR)\n+\t       && tree_ssa_useless_type_conversion_1 (TREE_TYPE (rhs),\n+\t\t\t\t\t\t      TREE_TYPE (def_rhs))))\n+    return forward_propagate_addr_expr (lhs, def_rhs);\n+\n   /* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR\n      nodes from the RHS.  */\n-  rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n   while (TREE_CODE (rhs) == COMPONENT_REF\n \t || TREE_CODE (rhs) == ARRAY_REF\n \t || TREE_CODE (rhs) == ADDR_EXPR)\n@@ -724,7 +725,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n     {\n       /* This should always succeed in creating gimple, so there is\n          no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (rhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n+      TREE_OPERAND (rhs, 0) = unshare_expr (def_rhs);\n       fold_stmt_inplace (use_stmt);\n       tidy_after_forward_propagate_addr (use_stmt);\n       return true;\n@@ -734,7 +735,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n      array indexing.  They only apply when we have the address of\n      element zero in an array.  If that is not the case then there\n      is nothing to do.  */\n-  array_ref = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0);\n+  array_ref = TREE_OPERAND (def_rhs, 0);\n   if (TREE_CODE (array_ref) != ARRAY_REF\n       || TREE_CODE (TREE_TYPE (TREE_OPERAND (array_ref, 0))) != ARRAY_TYPE\n       || !integer_zerop (TREE_OPERAND (array_ref, 1)))\n@@ -751,7 +752,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n     {\n       tree orig = unshare_expr (rhs);\n-      TREE_OPERAND (rhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n+      TREE_OPERAND (rhs, 0) = unshare_expr (def_rhs);\n \n       /* If folding succeeds, then we have just exposed new variables\n \t in USE_STMT which will need to be renamed.  If folding fails,\n@@ -783,7 +784,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n       tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n       \n       res = forward_propagate_addr_into_variable_array_index (offset_stmt, lhs,\n-\t\t\t\t\t\t\t      stmt, use_stmt);\n+\t\t\t\t\t\t\t      def_rhs, use_stmt);\n       return res;\n     }\n \t      \n@@ -798,7 +799,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n       bool res;\n       tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n       res = forward_propagate_addr_into_variable_array_index (offset_stmt, lhs,\n-\t\t\t\t\t\t\t      stmt, use_stmt);\n+\t\t\t\t\t\t\t      def_rhs, use_stmt);\n       return res;\n     }\n   return false;\n@@ -812,10 +813,9 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt)\n    Returns true, if all uses have been propagated into.  */\n \n static bool\n-forward_propagate_addr_expr (tree stmt)\n+forward_propagate_addr_expr (tree name, tree rhs)\n {\n-  int stmt_loop_depth = bb_for_stmt (stmt)->loop_depth;\n-  tree name = GIMPLE_STMT_OPERAND (stmt, 0);\n+  int stmt_loop_depth = bb_for_stmt (SSA_NAME_DEF_STMT (name))->loop_depth;\n   imm_use_iterator iter;\n   tree use_stmt;\n   bool all = true;\n@@ -843,10 +843,22 @@ forward_propagate_addr_expr (tree stmt)\n       \n       push_stmt_changes (&use_stmt);\n \n-      result = forward_propagate_addr_expr_1 (stmt, use_stmt);\n+      result = forward_propagate_addr_expr_1 (name, rhs, use_stmt);\n       all &= result;\n \n       pop_stmt_changes (&use_stmt);\n+\n+      /* Remove intermediate now unused copy and conversion chains.  */\n+      if (result\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME\n+\t  && (TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == SSA_NAME\n+\t      || TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == NOP_EXPR\n+\t      || TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == CONVERT_EXPR))\n+\t{\n+\t  block_stmt_iterator bsi = bsi_for_stmt (use_stmt);\n+\t  release_defs (use_stmt);\n+\t  bsi_remove (&bsi, true);\n+\t}\n     }\n \n   return all;\n@@ -981,7 +993,7 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \n \t      if (TREE_CODE (rhs) == ADDR_EXPR)\n \t\t{\n-\t\t  if (forward_propagate_addr_expr (stmt))\n+\t\t  if (forward_propagate_addr_expr (lhs, rhs))\n \t\t    {\n \t\t      release_defs (stmt);\n \t\t      todoflags |= TODO_remove_unused_locals;"}]}