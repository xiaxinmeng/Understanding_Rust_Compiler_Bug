{"sha": "f486280c53be53136f0bb9b578f43dc6c9c5acea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4NjI4MGM1M2JlNTMxMzZmMGJiOWI1NzhmNDNkYzZjOWM1YWNlYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-08T08:35:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-08T08:35:55Z"}, "message": "[C] Opt out of GNU vector extensions for built-in SVE types\n\nThe AArch64 port defines built-in SVE types at start-up under names\nlike __SVInt8_t.  These types are represented in the front end and\ngimple as normal VECTOR_TYPEs and are code-generated as normal vectors.\nHowever, we'd like to stop the frontends from treating them in the\nsame way as GNU-style (\"vector_size\") vectors, for several reasons:\n\n(1) We allowed the GNU vector extensions to be mixed with Advanced SIMD\n    vector types and it ended up causing a lot of confusion on big-endian\n    targets.  Although SVE handles big-endian vectors differently from\n    Advanced SIMD, there are still potential surprises; see the block\n    comment near the head of aarch64-sve.md for details.\n\n(2) One of the SVE vectors is a packed one-bit-per-element boolean vector.\n    That isn't a combination the GNU vector extensions have supported\n    before.  E.g. it means that vectors can no longer decompose to\n    arrays for indexing, and that not all elements are individually\n    addressable.  It also makes it less clear which order the initialiser\n    should be in (lsb first, or bitfield ordering?).  We could define\n    all that of course, but it seems a bit weird to go to the effort\n    for this case when, given all the other reasons, we don't want the\n    extensions anyway.\n\n(3) The GNU vector extensions only provide full-vector operations,\n    which is a very artifical limitation on a predicated architecture\n    like SVE.\n\n(4) The set of operations provided by the GNU vector extensions is\n    relatively small, whereas the SVE intrinsics provide many more.\n\n(5) It makes it easier to ensure that (with default options) code is\n    portable between compilers without the GNU vector extensions having\n    to become an official part of the SVE intrinsics spec.\n\n(6) The length of the SVE types is usually not fixed at compile time,\n    whereas the GNU vector extension is geared around fixed-length\n    vectors.\n\n    It's possible to specify the length of an SVE vector using the\n    command-line option -msve-vector-bits=N, but in principle it should\n    be possible to have functions compiled for different N in the same\n    translation unit.  This isn't supported yet but would be very useful\n    for implementing ifuncs.  Once mixing lengths in a translation unit\n    is supported, the SVE types should represent the same type throughout\n    the translation unit, just as GNU vector types do.\n\nHowever, when -msve-vector-bits=N is in effect, we do allow conversions\nbetween explicit GNU vector types of N bits and the corresponding SVE\ntypes.  This doesn't undermine the intent of (5) because in this case\nthe use of GNU vector types is explicit and intentional.  It also doesn't\nundermine the intent of (6) because converting between the types is just\na conditionally-supported operation.  In other words, the types still\nrepresent the same types throughout the translation unit, it's just that\nconversions between them are valid in cases where a certain precondition\nis known to hold.  It's similar to the way that the SVE vector types are\ndefined throughout the translation unit but can only be used in functions\nfor which SVE is enabled.\n\nThe patch adds a new flag to tree_type_common to select this behaviour.\n(We currently have 17 bits free.)  To avoid making the flag too specific\nto vectors, I called it TYPE_INDIVISIBLE_P, to mean that the frontend\nshould not allow the components of the type to be accessed directly.\nThis could perhaps be useful in future for hiding the fact that a\ntype is an array, or for hiding the fields of a record or union.\n\nThe actual frontend changes are very simple, mostly just replacing\nVECTOR_TYPE_P with gnu_vector_type_p in selected places.\n\nOne interesting case is:\n\n  /* Need to convert condition operand into a vector mask.  */\n  if (VECTOR_TYPE_P (TREE_TYPE (ifexp)))\n    {\n      tree vectype = TREE_TYPE (ifexp);\n      tree elem_type = TREE_TYPE (vectype);\n      tree zero = build_int_cst (elem_type, 0);\n      tree zero_vec = build_vector_from_val (vectype, zero);\n      tree cmp_type = build_same_sized_truth_vector_type (vectype);\n      ifexp = build2 (NE_EXPR, cmp_type, ifexp, zero_vec);\n    }\n\nin build_conditional_expr.  This appears to be trying to support\nelementwise conditions like \"vec1 ? vec2 : vec3\", which is something\nthe C++ frontend supports.  However, this code can never trigger AFAICT,\nbecause \"vec1\" does not survive c_objc_common_truthvalue_conversion:\n\n    case VECTOR_TYPE:\n      error_at (location, \"used vector type where scalar is required\");\n      return error_mark_node;\n\nEven if it did, the operation should be a VEC_COND_EXPR rather\nthan a COND_EXPR.\n\nI've therefore left that condition as-is, but added tests for the\n\"vec1 ? vec2 : vec3\" case to make sure that we don't accidentally\nallow it for SVE vectors in future.\n\n2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-core.h (tree_type_common::indivisible_p): New member variable.\n\t* tree.h (TYPE_INDIVISIBLE_P): New macro.\n\t* config/aarch64/aarch64-sve-builtins.cc (register_builtin_types):\n\tTreat the vector types as indivisible.\n\ngcc/c-family/\n\t* c-common.h (gnu_vector_type_p): New function.\n\t* c-common.c (c_build_vec_perm_expr): Require __builtin_shuffle\n\tvectors to satisfy gnu_vector_type_p.\n\t(c_build_vec_convert): Likewise __builtin_convertvector.\n\t(convert_vector_to_array_for_subscript): Likewise when applying\n\timplicit vector to array conversion.\n\t(scalar_to_vector): Likewise when converting vector-scalar\n\toperations to vector-vector operations.\n\ngcc/c/\n\t* c-convert.c (convert): Only handle vector conversions if one of\n\tthe types satisfies gnu_vector_type_p or if -flax-vector-conversions\n\tallows it.\n\t* c-typeck.c (build_array_ref): Only allow vector indexing if the\n\tvectors satisfy gnu_vector_type_p.\n\t(build_unary_op): Only allow unary operators to be applied to\n\tvectors if they satisfy gnu_vector_type_p.\n\t(digest_init): Only allow by-element initialization of vectors\n\tif they satisfy gnu_vector_type_p.\n\t(really_start_incremental_init): Likewise.\n\t(push_init_level): Likewise.\n\t(pop_init_level): Likewise.\n\t(process_init_element): Likewise.\n\t(build_binary_op): Only allow binary operators to be applied to\n\tvectors if they satisfy gnu_vector_type_p.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_1.c: New test.\n\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_2.c: Likewise.\n\nFrom-SVN: r277950", "tree": {"sha": "889dee82b7f1a9c7ac625d3b7871fc3808d4e79a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/889dee82b7f1a9c7ac625d3b7871fc3808d4e79a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f486280c53be53136f0bb9b578f43dc6c9c5acea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f486280c53be53136f0bb9b578f43dc6c9c5acea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f486280c53be53136f0bb9b578f43dc6c9c5acea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f486280c53be53136f0bb9b578f43dc6c9c5acea/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09eb042a8a8ee16e8f23085a175be25c8ef68820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09eb042a8a8ee16e8f23085a175be25c8ef68820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09eb042a8a8ee16e8f23085a175be25c8ef68820"}], "stats": {"total": 998, "additions": 957, "deletions": 41}, "files": [{"sha": "f4829fdf6aa844af4ce22022b1cd180ecb6442d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1,3 +1,10 @@\n+2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-core.h (tree_type_common::indivisible_p): New member variable.\n+\t* tree.h (TYPE_INDIVISIBLE_P): New macro.\n+\t* config/aarch64/aarch64-sve-builtins.cc (register_builtin_types):\n+\tTreat the vector types as indivisible.\n+\n 2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* optabs.def (gather_load_optab, mask_gather_load_optab)"}, {"sha": "c0efe9005827f986a70e213619686e298256791a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1,3 +1,14 @@\n+2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-common.h (gnu_vector_type_p): New function.\n+\t* c-common.c (c_build_vec_perm_expr): Require __builtin_shuffle\n+\tvectors to satisfy gnu_vector_type_p.\n+\t(c_build_vec_convert): Likewise __builtin_convertvector.\n+\t(convert_vector_to_array_for_subscript): Likewise when applying\n+\timplicit vector to array conversion.\n+\t(scalar_to_vector): Likewise when converting vector-scalar\n+\toperations to vector-vector operations.\n+\n 2019-11-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (Wold-style-definition): Initialize to -1."}, {"sha": "48811994f3894b6642603f39be3b0cf57f37ef90", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1011,16 +1011,17 @@ c_build_vec_perm_expr (location_t loc, tree v0, tree v1, tree mask,\n       || mask == error_mark_node)\n     return error_mark_node;\n \n-  if (!VECTOR_INTEGER_TYPE_P (TREE_TYPE (mask)))\n+  if (!gnu_vector_type_p (TREE_TYPE (mask))\n+      || !VECTOR_INTEGER_TYPE_P (TREE_TYPE (mask)))\n     {\n       if (complain)\n \terror_at (loc, \"%<__builtin_shuffle%> last argument must \"\n \t\t       \"be an integer vector\");\n       return error_mark_node;\n     }\n \n-  if (!VECTOR_TYPE_P (TREE_TYPE (v0))\n-      || !VECTOR_TYPE_P (TREE_TYPE (v1)))\n+  if (!gnu_vector_type_p (TREE_TYPE (v0))\n+      || !gnu_vector_type_p (TREE_TYPE (v1)))\n     {\n       if (complain)\n \terror_at (loc, \"%<__builtin_shuffle%> arguments must be vectors\");\n@@ -1095,16 +1096,18 @@ c_build_vec_convert (location_t loc1, tree expr, location_t loc2, tree type,\n   if (error_operand_p (expr))\n     return error_mark_node;\n \n-  if (!VECTOR_INTEGER_TYPE_P (TREE_TYPE (expr))\n-      && !VECTOR_FLOAT_TYPE_P (TREE_TYPE (expr)))\n+  if (!gnu_vector_type_p (TREE_TYPE (expr))\n+      || (!VECTOR_INTEGER_TYPE_P (TREE_TYPE (expr))\n+\t  && !VECTOR_FLOAT_TYPE_P (TREE_TYPE (expr))))\n     {\n       if (complain)\n \terror_at (loc1, \"%<__builtin_convertvector%> first argument must \"\n \t\t\t\"be an integer or floating vector\");\n       return error_mark_node;\n     }\n \n-  if (!VECTOR_INTEGER_TYPE_P (type) && !VECTOR_FLOAT_TYPE_P (type))\n+  if (!gnu_vector_type_p (type)\n+      || (!VECTOR_INTEGER_TYPE_P (type) && !VECTOR_FLOAT_TYPE_P (type)))\n     {\n       if (complain)\n \terror_at (loc2, \"%<__builtin_convertvector%> second argument must \"\n@@ -8024,7 +8027,7 @@ convert_vector_to_array_for_subscript (location_t loc,\n \t\t\t\t       tree *vecp, tree index)\n {\n   bool ret = false;\n-  if (VECTOR_TYPE_P (TREE_TYPE (*vecp)))\n+  if (gnu_vector_type_p (TREE_TYPE (*vecp)))\n     {\n       tree type = TREE_TYPE (*vecp);\n \n@@ -8060,7 +8063,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n   bool integer_only_op = false;\n   enum stv_conv ret = stv_firstarg;\n \n-  gcc_assert (VECTOR_TYPE_P (type0) || VECTOR_TYPE_P (type1));\n+  gcc_assert (gnu_vector_type_p (type0) || gnu_vector_type_p (type1));\n   switch (code)\n     {\n       /* Most GENERIC binary expressions require homogeneous arguments.\n@@ -8111,7 +8114,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n       case LT_EXPR:\n       case GT_EXPR:\n       /* What about UNLT_EXPR?  */\n-\tif (VECTOR_TYPE_P (type0))\n+\tif (gnu_vector_type_p (type0))\n \t  {\n \t    ret = stv_secondarg;\n \t    std::swap (type0, type1);"}, {"sha": "80a8c9f45432d2a4c640ada4accdc22b9fbdefbd", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -757,6 +757,16 @@ extern bool done_lexing;\n #define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n   (!C_TYPE_FUNCTION_P (type))\n \n+/* Return true if TYPE is a vector type that should be subject to the GNU\n+   vector extensions (as opposed to a vector type that is used only for\n+   the purposes of defining target-specific built-in functions).  */\n+\n+inline bool\n+gnu_vector_type_p (const_tree type)\n+{\n+  return TREE_CODE (type) == VECTOR_TYPE && !TYPE_INDIVISIBLE_P (type);\n+}\n+\n struct visibility_flags\n {\n   unsigned inpragma : 1;\t/* True when in #pragma GCC visibility.  */"}, {"sha": "8cea3f526560a4ed4b087028605169fb863059f0", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1,3 +1,21 @@\n+2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-convert.c (convert): Only handle vector conversions if one of\n+\tthe types satisfies gnu_vector_type_p or if -flax-vector-conversions\n+\tallows it.\n+\t* c-typeck.c (build_array_ref): Only allow vector indexing if the\n+\tvectors satisfy gnu_vector_type_p.\n+\t(build_unary_op): Only allow unary operators to be applied to\n+\tvectors if they satisfy gnu_vector_type_p.\n+\t(digest_init): Only allow by-element initialization of vectors\n+\tif they satisfy gnu_vector_type_p.\n+\t(really_start_incremental_init): Likewise.\n+\t(push_init_level): Likewise.\n+\t(pop_init_level): Likewise.\n+\t(process_init_element): Likewise.\n+\t(build_binary_op): Only allow binary operators to be applied to\n+\tvectors if they satisfy gnu_vector_type_p.\n+\n 2019-11-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (grokparms): Convert () in a function definition to"}, {"sha": "21b127d0d6771a85409ea3b1ccdd6fac5e7ccdde", "filename": "gcc/c/c-convert.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.c?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -147,8 +147,20 @@ convert (tree type, tree expr)\n       goto maybe_fold;\n \n     case VECTOR_TYPE:\n-      ret = convert_to_vector (type, e);\n-      goto maybe_fold;\n+      if (gnu_vector_type_p (type)\n+\t  || gnu_vector_type_p (TREE_TYPE (e))\n+\t  /* Allow conversions between compatible non-GNU vector types\n+\t     when -flax-vector-conversions is passed.  The whole purpose\n+\t     of the option is to bend the normal type rules and accept\n+\t     nonconforming code.  */\n+\t  || (flag_lax_vector_conversions\n+\t      && VECTOR_TYPE_P (TREE_TYPE (e))\n+\t      && vector_types_convertible_p (type, TREE_TYPE (e), false)))\n+\t{\n+\t  ret = convert_to_vector (type, e);\n+\t  goto maybe_fold;\n+\t}\n+      break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:"}, {"sha": "793d10e072ba147509648ed5339e18499fbc1542", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -2610,7 +2610,7 @@ build_array_ref (location_t loc, tree array, tree index)\n   if (TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (array)) != POINTER_TYPE\n       /* Allow vector[index] but not index[vector].  */\n-      && !VECTOR_TYPE_P (TREE_TYPE (array)))\n+      && !gnu_vector_type_p (TREE_TYPE (array)))\n     {\n       if (TREE_CODE (TREE_TYPE (index)) != ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (index)) != POINTER_TYPE)\n@@ -4360,7 +4360,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t associativity, but won't generate any code.  */\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n-\t    || typecode == VECTOR_TYPE))\n+\t    || gnu_vector_type_p (TREE_TYPE (arg))))\n \t{\n \t  error_at (location, \"wrong type argument to unary plus\");\n \t  return error_mark_node;\n@@ -4373,7 +4373,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n     case NEGATE_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n-\t    || typecode == VECTOR_TYPE))\n+\t    || gnu_vector_type_p (TREE_TYPE (arg))))\n \t{\n \t  error_at (location, \"wrong type argument to unary minus\");\n \t  return error_mark_node;\n@@ -4385,7 +4385,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n     case BIT_NOT_EXPR:\n       /* ~ works on integer types and non float vectors. */\n       if (typecode == INTEGER_TYPE\n-\t  || (typecode == VECTOR_TYPE\n+\t  || (gnu_vector_type_p (TREE_TYPE (arg))\n \t      && !VECTOR_FLOAT_TYPE_P (TREE_TYPE (arg))))\n \t{\n \t  tree e = arg;\n@@ -4571,7 +4571,8 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \n       if (typecode != POINTER_TYPE && typecode != FIXED_POINT_TYPE\n \t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE\n-\t  && typecode != COMPLEX_TYPE && typecode != VECTOR_TYPE)\n+\t  && typecode != COMPLEX_TYPE\n+\t  && !gnu_vector_type_p (TREE_TYPE (arg)))\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t    error_at (location, \"wrong type argument to increment\");\n@@ -7858,7 +7859,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t\t     TYPE_MAIN_VARIANT (type))\n \t  || (code == ARRAY_TYPE\n \t      && comptypes (TREE_TYPE (inside_init), type))\n-\t  || (code == VECTOR_TYPE\n+\t  || (gnu_vector_type_p (type)\n \t      && comptypes (TREE_TYPE (inside_init), type))\n \t  || (code == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n@@ -8356,7 +8357,7 @@ really_start_incremental_init (tree type)\n \n       constructor_unfilled_index = constructor_index;\n     }\n-  else if (VECTOR_TYPE_P (constructor_type))\n+  else if (gnu_vector_type_p (constructor_type))\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n@@ -8530,7 +8531,7 @@ push_init_level (location_t loc, int implicit,\n       constructor_unfilled_fields = constructor_fields;\n       constructor_bit_index = bitsize_zero_node;\n     }\n-  else if (VECTOR_TYPE_P (constructor_type))\n+  else if (gnu_vector_type_p (constructor_type))\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n@@ -8719,7 +8720,7 @@ pop_init_level (location_t loc, int implicit,\n     ;\n   else if (!RECORD_OR_UNION_TYPE_P (constructor_type)\n \t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n-\t   && !VECTOR_TYPE_P (constructor_type))\n+\t   && !gnu_vector_type_p (constructor_type))\n     {\n       /* A nonincremental scalar initializer--just return\n \t the element, after verifying there is just one.  */\n@@ -9945,7 +9946,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       else if ((TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t\t|| VECTOR_TYPE_P (constructor_type))\n+\t\t|| gnu_vector_type_p (constructor_type))\n \t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t   constructor_index))\n@@ -10046,7 +10047,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n+\t\t       || fieldcode == UNION_TYPE\n+\t\t       || gnu_vector_type_p (fieldtype)))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n@@ -10137,7 +10139,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n+\t\t       || fieldcode == UNION_TYPE\n+\t\t       || gnu_vector_type_p (fieldtype)))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n@@ -10179,7 +10182,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != elttype\n \t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n-\t\t       || eltcode == UNION_TYPE || eltcode == VECTOR_TYPE))\n+\t\t       || eltcode == UNION_TYPE\n+\t\t       || gnu_vector_type_p (elttype)))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n@@ -10215,7 +10219,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t       constructor_unfilled_index.  */\n \t    constructor_unfilled_index = constructor_index;\n \t}\n-      else if (VECTOR_TYPE_P (constructor_type))\n+      else if (gnu_vector_type_p (constructor_type))\n \t{\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \n@@ -11559,7 +11563,8 @@ build_binary_op (location_t location, enum tree_code code,\n \n   /* In case when one of the operands of the binary operation is\n      a vector and another is a scalar -- convert scalar to vector.  */\n-  if ((code0 == VECTOR_TYPE) != (code1 == VECTOR_TYPE))\n+  if ((gnu_vector_type_p (type0) && code1 != VECTOR_TYPE)\n+      || (gnu_vector_type_p (type1) && code0 != VECTOR_TYPE))\n     {\n       enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1,\n \t\t\t\t\t\t     true);\n@@ -11654,10 +11659,12 @@ build_binary_op (location_t location, enum tree_code code,\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n \t   || code0 == FIXED_POINT_TYPE\n-\t   || code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n+\t   || code0 == COMPLEX_TYPE\n+\t   || gnu_vector_type_p (type0))\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n \t      || code1 == FIXED_POINT_TYPE\n-\t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n+\t      || code1 == COMPLEX_TYPE\n+\t      || gnu_vector_type_p (type1)))\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n \n@@ -11688,8 +11695,8 @@ build_binary_op (location_t location, enum tree_code code,\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \tshorten = -1;\n       /* Allow vector types which are not floating point types.   */\n-      else if (code0 == VECTOR_TYPE\n-\t       && code1 == VECTOR_TYPE\n+      else if (gnu_vector_type_p (type0)\n+\t       && gnu_vector_type_p (type1)\n \t       && !VECTOR_FLOAT_TYPE_P (type0)\n \t       && !VECTOR_FLOAT_TYPE_P (type1))\n \tcommon = 1;\n@@ -11700,7 +11707,8 @@ build_binary_op (location_t location, enum tree_code code,\n       doing_div_or_mod = true;\n       warn_for_div_by_zero (location, op1);\n \n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+      if (gnu_vector_type_p (type0)\n+\t  && gnu_vector_type_p (type1)\n \t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)\n \tcommon = 1;\n@@ -11779,7 +11787,8 @@ build_binary_op (location_t location, enum tree_code code,\n \t Also set SHORT_SHIFT if shifting rightward.  */\n \n     case RSHIFT_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+      if (gnu_vector_type_p (type0)\n+\t  && gnu_vector_type_p (type1)\n \t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n \t  && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n@@ -11789,7 +11798,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  converted = 1;\n \t}\n       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE\n-\t\t|| (code0 == VECTOR_TYPE\n+\t\t|| (gnu_vector_type_p (type0)\n \t\t    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))\n \t       && code1 == INTEGER_TYPE)\n \t{\n@@ -11838,7 +11847,8 @@ build_binary_op (location_t location, enum tree_code code,\n       break;\n \n     case LSHIFT_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+      if (gnu_vector_type_p (type0)\n+\t  && gnu_vector_type_p (type1)\n \t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n \t  && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n@@ -11848,7 +11858,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  converted = 1;\n \t}\n       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE\n-\t\t|| (code0 == VECTOR_TYPE\n+\t\t|| (gnu_vector_type_p (type0)\n \t\t    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))\n \t       && code1 == INTEGER_TYPE)\n \t{\n@@ -11907,7 +11917,7 @@ build_binary_op (location_t location, enum tree_code code,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+      if (gnu_vector_type_p (type0) && gnu_vector_type_p (type1))\n         {\n           tree intt;\n \t  if (!vector_types_compatible_elements_p (type0, type1))\n@@ -12075,7 +12085,7 @@ build_binary_op (location_t location, enum tree_code code,\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+      if (gnu_vector_type_p (type0) && gnu_vector_type_p (type1))\n         {\n           tree intt;\n \t  if (!vector_types_compatible_elements_p (type0, type1))\n@@ -12222,7 +12232,8 @@ build_binary_op (location_t location, enum tree_code code,\n   if (code0 == ERROR_MARK || code1 == ERROR_MARK)\n     return error_mark_node;\n \n-  if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+  if (gnu_vector_type_p (type0)\n+      && gnu_vector_type_p (type1)\n       && (!tree_int_cst_equal (TYPE_SIZE (type0), TYPE_SIZE (type1))\n \t  || !vector_types_compatible_elements_p (type0, type1)))\n     {\n@@ -12237,10 +12248,12 @@ build_binary_op (location_t location, enum tree_code code,\n     }\n \n   if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n-       || code0 == FIXED_POINT_TYPE || code0 == VECTOR_TYPE)\n+       || code0 == FIXED_POINT_TYPE\n+       || gnu_vector_type_p (type0))\n       &&\n       (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n-       || code1 == FIXED_POINT_TYPE || code1 == VECTOR_TYPE))\n+       || code1 == FIXED_POINT_TYPE\n+       || gnu_vector_type_p (type1)))\n     {\n       bool first_complex = (code0 == COMPLEX_TYPE);\n       bool second_complex = (code1 == COMPLEX_TYPE);"}, {"sha": "bb5aadab782580d52ab2c0ffa1f29f9e07fbb057", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -2996,6 +2996,7 @@ register_builtin_types ()\n       gcc_assert (vectype == TYPE_MAIN_VARIANT (vectype));\n       SET_TYPE_STRUCTURAL_EQUALITY (vectype);\n       TYPE_ARTIFICIAL (vectype) = 1;\n+      TYPE_INDIVISIBLE_P (vectype) = 1;\n       abi_vector_types[i] = vectype;\n       lang_hooks.types.register_builtin_type (vectype,\n \t\t\t\t\t      vector_types[i].abi_name);"}, {"sha": "22f15fde5b48306b421f84503f6bd69567baf88f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1,3 +1,8 @@\n+2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_1.c: New test.\n+\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_2.c: Likewise.\n+\n 2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR target/92132"}, {"sha": "285751eebc40ad3628656225d615b7f5ac17d669", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/gnu_vectors_1.c", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_1.c?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -0,0 +1,415 @@\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1, int n, unsigned char uc)\n+{\n+  /* Initialization.  */\n+\n+  svuint8_t init_sve_u1 = 0; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  svuint8_t init_sve_u2 = {}; /* { dg-error {empty scalar initializer} } */\n+  svuint8_t init_sve_u3 = { sve_u1 };\n+  svuint8_t init_sve_u4 = { gnu_u1 };\n+  svuint8_t init_sve_u5 = { sve_s1 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'svint8_t'} } */\n+  svuint8_t init_sve_u6 = { gnu_s1 }; /* { dg-error {incompatible types when initializing type 'svuint8_t'} } */\n+  svuint8_t init_sve_u7 = { 0 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  svuint8_t init_sve_u8 = { sve_u1, sve_u1 }; /* { dg-warning {excess elements in scalar initializer} } */\n+  svuint8_t init_sve_u9 = { gnu_u1, gnu_u1 }; /* { dg-warning {excess elements in scalar initializer} } */\n+\n+  gnu_uint8_t init_gnu_u1 = 0; /* { dg-error {incompatible types when initializing type 'gnu_uint8_t'[^\\n]* using type 'int'} } */\n+  gnu_uint8_t init_gnu_u2 = {};\n+  gnu_uint8_t init_gnu_u3 = { sve_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u4 = { gnu_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u5 = { sve_s1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u6 = { gnu_s1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u7 = { 0 };\n+\n+  /* Compound literals.  */\n+\n+  (svuint8_t) {}; /* { dg-error {empty scalar initializer} } */\n+  (svuint8_t) { 0 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  (svuint8_t) { sve_u1 };\n+  (svuint8_t) { gnu_u1 };\n+  (svuint8_t) { sve_s1 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'svint8_t'} } */\n+  (svuint8_t) { gnu_s1 }; /* { dg-error {incompatible types when initializing type 'svuint8_t'} } */\n+\n+  (gnu_uint8_t) {};\n+  (gnu_uint8_t) { 0 };\n+  (gnu_uint8_t) { sve_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  (gnu_uint8_t) { gnu_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+\n+  /* Assignment.  */\n+\n+  sve_u1 = 0; /* { dg-error {incompatible types when assigning to type 'svuint8_t' from type 'int'} } */\n+  sve_u1 = sve_u1;\n+  sve_u1 = gnu_u1;\n+  sve_u1 = sve_s1; /* { dg-error {incompatible types when assigning to type 'svuint8_t' from type 'svint8_t'} } */\n+  sve_u1 = gnu_s1; /* { dg-error {incompatible types when assigning to type 'svuint8_t' from type 'gnu_int8_t'} } */\n+\n+  gnu_u1 = 0; /* { dg-error {incompatible types when assigning to type 'gnu_uint8_t'[^\\n]* from type 'int'} } */\n+  gnu_u1 = sve_u1;\n+  gnu_u1 = gnu_u1;\n+  gnu_u1 = sve_s1; /* { dg-error {incompatible types when assigning to type 'gnu_uint8_t'[^\\n]* from type 'svint8_t'} } */\n+  gnu_u1 = gnu_s1; /* { dg-error {incompatible types when assigning to type 'gnu_uint8_t'[^\\n]* from type 'gnu_int8_t'} } */\n+\n+  /* Casts.  */\n+\n+  (void) sve_u1;\n+  (svuint8_t) sve_u1;\n+  (svuint8_t) gnu_u1;\n+  (svuint8_t) 0; /* { dg-error {conversion to non-scalar type requested} } */\n+  (svuint8_t) n; /* { dg-error {conversion to non-scalar type requested} } */\n+  (svint8_t) sve_u1; /* { dg-error {conversion to non-scalar type requested} } */\n+  (svint8_t) gnu_u1;\n+\n+  (void) gnu_u1;\n+  (gnu_uint8_t) sve_u1;\n+  (gnu_uint8_t) gnu_u1;\n+  (gnu_uint8_t) 0; /* { dg-error {cannot convert a value of type 'int' to vector type '[^']*' which has different size} } */\n+  (gnu_uint8_t) n; /* { dg-error {cannot convert a value of type 'int' to vector type '[^']*' which has different size} } */\n+  (gnu_int8_t) sve_u1;\n+  (gnu_int8_t) gnu_u1;\n+\n+  /* Vector indexing.  */\n+\n+  sve_u1[0]; /* { dg-error {subscripted value is neither array nor pointer} } */\n+  &sve_u1[0]; /* { dg-error {subscripted value is neither array nor pointer} } */\n+\n+  gnu_u1[0];\n+  &gnu_u1[0];\n+\n+  /* Unary operators.  */\n+\n+  +sve_u1; /* { dg-error {wrong type argument to unary plus} } */\n+  -sve_u1; /* { dg-error {wrong type argument to unary minus} } */\n+  ~sve_u1; /* { dg-error {wrong type argument to bit-complement} } */\n+  !sve_u1; /* { dg-error {wrong type argument to unary exclamation mark} } */\n+  *sve_u1; /* { dg-error {invalid type argument of unary '\\*'} } */\n+  __real sve_u1; /* { dg-error {wrong type argument to __real} } */\n+  __imag sve_u1; /* { dg-error {wrong type argument to __imag} } */\n+  ++sve_u1; /* { dg-error {wrong type argument to increment} } */\n+  --sve_u1; /* { dg-error {wrong type argument to decrement} } */\n+  sve_u1++; /* { dg-error {wrong type argument to increment} } */\n+  sve_u1--; /* { dg-error {wrong type argument to decrement} } */\n+\n+  +gnu_u1;\n+  -gnu_u1;\n+  ~gnu_u1;\n+  !gnu_u1; /* { dg-error {wrong type argument to unary exclamation mark} } */\n+  *gnu_u1; /* { dg-error {invalid type argument of unary '\\*'} } */\n+  __real gnu_u1; /* { dg-error {wrong type argument to __real} } */\n+  __imag gnu_u1; /* { dg-error {wrong type argument to __imag} } */\n+  ++gnu_u1;\n+  --gnu_u1;\n+  gnu_u1++;\n+  gnu_u1--;\n+\n+  /* Vector-vector binary arithmetic.  */\n+\n+  sve_u1 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + gnu_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - gnu_u1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * gnu_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / gnu_u1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % gnu_u1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & gnu_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | gnu_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ gnu_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == gnu_u1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != gnu_u1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= gnu_u1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < gnu_u1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > gnu_u1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= gnu_u1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << gnu_u1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> gnu_u1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  gnu_u1 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  gnu_u1 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  gnu_u1 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  gnu_u1 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  gnu_u1 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  gnu_u1 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  gnu_u1 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  gnu_u1 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  gnu_u1 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  gnu_u1 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  gnu_u1 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  gnu_u1 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  gnu_u1 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  gnu_u1 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  gnu_u1 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  gnu_u1 && sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + gnu_u1;\n+  gnu_u1 - gnu_u1;\n+  gnu_u1 * gnu_u1;\n+  gnu_u1 / gnu_u1;\n+  gnu_u1 % gnu_u1;\n+  gnu_u1 & gnu_u1;\n+  gnu_u1 | gnu_u1;\n+  gnu_u1 ^ gnu_u1;\n+  gnu_u1 == gnu_u1;\n+  gnu_u1 != gnu_u1;\n+  gnu_u1 <= gnu_u1;\n+  gnu_u1 < gnu_u1;\n+  gnu_u1 > gnu_u1;\n+  gnu_u1 >= gnu_u1;\n+  gnu_u1 << gnu_u1;\n+  gnu_u1 >> gnu_u1;\n+  gnu_u1 && gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Vector-scalar binary arithmetic.  */\n+\n+  sve_u1 + 2; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - 2; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * 2; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / 2; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % 2; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & 2; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | 2; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ 2; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == 2; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != 2; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= 2; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < 2; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > 2; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= 2; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << 2; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> 2; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && 2; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || 2; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + uc; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - uc; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * uc; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / uc; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % uc; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & uc; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | uc; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ uc; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == uc; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != uc; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= uc; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < uc; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > uc; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= uc; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << uc; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> uc; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && uc; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || uc; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + 2;\n+  gnu_u1 - 2;\n+  gnu_u1 * 2;\n+  gnu_u1 / 2;\n+  gnu_u1 % 2;\n+  gnu_u1 & 2;\n+  gnu_u1 | 2;\n+  gnu_u1 ^ 2;\n+  gnu_u1 == 2;\n+  gnu_u1 != 2;\n+  gnu_u1 <= 2;\n+  gnu_u1 < 2;\n+  gnu_u1 > 2;\n+  gnu_u1 >= 2;\n+  gnu_u1 << 2;\n+  gnu_u1 >> 2;\n+  gnu_u1 && 2; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || 2; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + uc;\n+  gnu_u1 - uc;\n+  gnu_u1 * uc;\n+  gnu_u1 / uc;\n+  gnu_u1 % uc;\n+  gnu_u1 & uc;\n+  gnu_u1 | uc;\n+  gnu_u1 ^ uc;\n+  gnu_u1 == uc;\n+  gnu_u1 != uc;\n+  gnu_u1 <= uc;\n+  gnu_u1 < uc;\n+  gnu_u1 > uc;\n+  gnu_u1 >= uc;\n+  gnu_u1 << uc;\n+  gnu_u1 >> uc;\n+  gnu_u1 && uc; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || uc; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Scalar-vector binary arithmetic.  */\n+\n+  3 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  3 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  3 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  3 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  3 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  3 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  3 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  3 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  3 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  3 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  3 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  3 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  3 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  3 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  3 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  3 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  3 && sve_u1; /* { dg-error {invalid operands to binary \\&\\&} } */\n+  3 || sve_u1; /* { dg-error {invalid operands to binary \\|\\|} } */\n+\n+  3 + gnu_u1;\n+  3 - gnu_u1;\n+  3 * gnu_u1;\n+  3 / gnu_u1;\n+  3 % gnu_u1;\n+  3 & gnu_u1;\n+  3 | gnu_u1;\n+  3 ^ gnu_u1;\n+  3 == gnu_u1;\n+  3 != gnu_u1;\n+  3 <= gnu_u1;\n+  3 < gnu_u1;\n+  3 > gnu_u1;\n+  3 >= gnu_u1;\n+  3 << gnu_u1;\n+  3 >> gnu_u1;\n+  3 && gnu_u1; /* { dg-error {invalid operands to binary \\&\\&} } */\n+  3 || gnu_u1; /* { dg-error {invalid operands to binary \\|\\|} } */\n+\n+  /* Mismatched types.  */\n+\n+  sve_u1 + sve_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - sve_s1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * sve_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / sve_s1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % sve_s1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & sve_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | sve_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ sve_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == sve_s1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != sve_s1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= sve_s1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < sve_s1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > sve_s1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= sve_s1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << sve_s1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> sve_s1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + gnu_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - gnu_s1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * gnu_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / gnu_s1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % gnu_s1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & gnu_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | gnu_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ gnu_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == gnu_s1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != gnu_s1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= gnu_s1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < gnu_s1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > gnu_s1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= gnu_s1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << gnu_s1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> gnu_s1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + sve_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  gnu_u1 - sve_s1; /* { dg-error {invalid operands to binary -} } */\n+  gnu_u1 * sve_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  gnu_u1 / sve_s1; /* { dg-error {invalid operands to binary /} } */\n+  gnu_u1 % sve_s1; /* { dg-error {invalid operands to binary %} } */\n+  gnu_u1 & sve_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  gnu_u1 | sve_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  gnu_u1 ^ sve_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  gnu_u1 == sve_s1; /* { dg-error {invalid operands to binary ==} } */\n+  gnu_u1 != sve_s1; /* { dg-error {invalid operands to binary !=} } */\n+  gnu_u1 <= sve_s1; /* { dg-error {invalid operands to binary <=} } */\n+  gnu_u1 < sve_s1; /* { dg-error {invalid operands to binary <} } */\n+  gnu_u1 > sve_s1; /* { dg-error {invalid operands to binary >} } */\n+  gnu_u1 >= sve_s1; /* { dg-error {invalid operands to binary >=} } */\n+  gnu_u1 << sve_s1; /* { dg-error {invalid operands to binary <<} } */\n+  gnu_u1 >> sve_s1; /* { dg-error {invalid operands to binary >>} } */\n+  gnu_u1 && sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + gnu_s1;\n+  gnu_u1 - gnu_s1;\n+  gnu_u1 * gnu_s1;\n+  gnu_u1 / gnu_s1;\n+  gnu_u1 % gnu_s1;\n+  gnu_u1 & gnu_s1;\n+  gnu_u1 | gnu_s1;\n+  gnu_u1 ^ gnu_s1;\n+  gnu_u1 == gnu_s1;\n+  gnu_u1 != gnu_s1;\n+  gnu_u1 <= gnu_s1;\n+  gnu_u1 < gnu_s1;\n+  gnu_u1 > gnu_s1;\n+  gnu_u1 >= gnu_s1;\n+  gnu_u1 << gnu_s1;\n+  gnu_u1 >> gnu_s1;\n+  gnu_u1 && gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Conditional expressions.  */\n+\n+  uc ? sve_u1 : sve_u1;\n+  uc ? gnu_u1 : sve_u1; /* { dg-error {type mismatch in conditional expression} } */\n+  uc ? sve_u1 : gnu_u1; /* { dg-error {type mismatch in conditional expression} } */\n+  uc ? gnu_u1 : gnu_u1;\n+\n+  sve_u1 ? sve_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? gnu_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? sve_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? gnu_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 ? sve_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? gnu_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? sve_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? gnu_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Vector built-ins.  */\n+\n+  __builtin_shuffle (sve_u1, sve_u1, sve_u1); /* { dg-error {'__builtin_shuffle' last argument must be an integer vector} } */\n+  __builtin_shuffle (sve_u1, gnu_u1, gnu_u1); /* { dg-error {'__builtin_shuffle' arguments must be vectors} } */\n+  __builtin_shuffle (gnu_u1, sve_u1, gnu_u1); /* { dg-error {'__builtin_shuffle' arguments must be vectors} } */\n+  __builtin_shuffle (gnu_u1, gnu_u1, sve_u1); /* { dg-error {'__builtin_shuffle' last argument must be an integer vector} } */\n+  __builtin_shuffle (gnu_u1, gnu_u1, gnu_u1);\n+\n+  __builtin_convertvector (sve_u1, svuint8_t); /* { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} } */\n+  __builtin_convertvector (gnu_u1, svuint8_t); /* { dg-error {'__builtin_convertvector' second argument must be an integer or floating vector type} } */\n+  __builtin_convertvector (sve_u1, gnu_uint8_t); /* { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} } */\n+  __builtin_convertvector (gnu_u1, gnu_uint8_t);\n+}"}, {"sha": "306fd478047b58d1a9c69d0b83a91eb8a44b3883", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/gnu_vectors_2.c", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_2.c?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -0,0 +1,415 @@\n+/* { dg-options \"-msve-vector-bits=256 -flax-vector-conversions\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1, int n, unsigned char uc)\n+{\n+  /* Initialization.  */\n+\n+  svuint8_t init_sve_u1 = 0; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  svuint8_t init_sve_u2 = {}; /* { dg-error {empty scalar initializer} } */\n+  svuint8_t init_sve_u3 = { sve_u1 };\n+  svuint8_t init_sve_u4 = { gnu_u1 };\n+  svuint8_t init_sve_u5 = { sve_s1 };\n+  svuint8_t init_sve_u6 = { gnu_s1 };\n+  svuint8_t init_sve_u7 = { 0 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  svuint8_t init_sve_u8 = { sve_u1, sve_u1 }; /* { dg-warning {excess elements in scalar initializer} } */\n+  svuint8_t init_sve_u9 = { gnu_u1, gnu_u1 }; /* { dg-warning {excess elements in scalar initializer} } */\n+\n+  gnu_uint8_t init_gnu_u1 = 0; /* { dg-error {incompatible types when initializing type 'gnu_uint8_t'[^\\n]* using type 'int'} } */\n+  gnu_uint8_t init_gnu_u2 = {};\n+  gnu_uint8_t init_gnu_u3 = { sve_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u4 = { gnu_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u5 = { sve_s1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u6 = { gnu_s1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  gnu_uint8_t init_gnu_u7 = { 0 };\n+\n+  /* Compound literals.  */\n+\n+  (svuint8_t) {}; /* { dg-error {empty scalar initializer} } */\n+  (svuint8_t) { 0 }; /* { dg-error {incompatible types when initializing type 'svuint8_t' using type 'int'} } */\n+  (svuint8_t) { sve_u1 };\n+  (svuint8_t) { gnu_u1 };\n+  (svuint8_t) { sve_s1 };\n+  (svuint8_t) { gnu_s1 };\n+\n+  (gnu_uint8_t) {};\n+  (gnu_uint8_t) { 0 };\n+  (gnu_uint8_t) { sve_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+  (gnu_uint8_t) { gnu_u1 }; /* { dg-error {incompatible types when initializing type 'unsigned char'} } */\n+\n+  /* Assignment.  */\n+\n+  sve_u1 = 0; /* { dg-error {incompatible types when assigning to type 'svuint8_t' from type 'int'} } */\n+  sve_u1 = sve_u1;\n+  sve_u1 = gnu_u1;\n+  sve_u1 = sve_s1;\n+  sve_u1 = gnu_s1;\n+\n+  gnu_u1 = 0; /* { dg-error {incompatible types when assigning to type 'gnu_uint8_t'[^\\n]* from type 'int'} } */\n+  gnu_u1 = sve_u1;\n+  gnu_u1 = gnu_u1;\n+  gnu_u1 = sve_s1;\n+  gnu_u1 = gnu_s1;\n+\n+  /* Casts.  */\n+\n+  (void) sve_u1;\n+  (svuint8_t) sve_u1;\n+  (svuint8_t) gnu_u1;\n+  (svuint8_t) 0; /* { dg-error {conversion to non-scalar type requested} } */\n+  (svuint8_t) n; /* { dg-error {conversion to non-scalar type requested} } */\n+  (svint8_t) sve_u1;\n+  (svint8_t) gnu_u1;\n+\n+  (void) gnu_u1;\n+  (gnu_uint8_t) sve_u1;\n+  (gnu_uint8_t) gnu_u1;\n+  (gnu_uint8_t) 0; /* { dg-error {cannot convert a value of type 'int' to vector type '[^']*' which has different size} } */\n+  (gnu_uint8_t) n; /* { dg-error {cannot convert a value of type 'int' to vector type '[^']*' which has different size} } */\n+  (gnu_int8_t) sve_u1;\n+  (gnu_int8_t) gnu_u1;\n+\n+  /* Vector indexing.  */\n+\n+  sve_u1[0]; /* { dg-error {subscripted value is neither array nor pointer} } */\n+  &sve_u1[0]; /* { dg-error {subscripted value is neither array nor pointer} } */\n+\n+  gnu_u1[0];\n+  &gnu_u1[0];\n+\n+  /* Unary operators.  */\n+\n+  +sve_u1; /* { dg-error {wrong type argument to unary plus} } */\n+  -sve_u1; /* { dg-error {wrong type argument to unary minus} } */\n+  ~sve_u1; /* { dg-error {wrong type argument to bit-complement} } */\n+  !sve_u1; /* { dg-error {wrong type argument to unary exclamation mark} } */\n+  *sve_u1; /* { dg-error {invalid type argument of unary '\\*'} } */\n+  __real sve_u1; /* { dg-error {wrong type argument to __real} } */\n+  __imag sve_u1; /* { dg-error {wrong type argument to __imag} } */\n+  ++sve_u1; /* { dg-error {wrong type argument to increment} } */\n+  --sve_u1; /* { dg-error {wrong type argument to decrement} } */\n+  sve_u1++; /* { dg-error {wrong type argument to increment} } */\n+  sve_u1--; /* { dg-error {wrong type argument to decrement} } */\n+\n+  +gnu_u1;\n+  -gnu_u1;\n+  ~gnu_u1;\n+  !gnu_u1; /* { dg-error {wrong type argument to unary exclamation mark} } */\n+  *gnu_u1; /* { dg-error {invalid type argument of unary '\\*'} } */\n+  __real gnu_u1; /* { dg-error {wrong type argument to __real} } */\n+  __imag gnu_u1; /* { dg-error {wrong type argument to __imag} } */\n+  ++gnu_u1;\n+  --gnu_u1;\n+  gnu_u1++;\n+  gnu_u1--;\n+\n+  /* Vector-vector binary arithmetic.  */\n+\n+  sve_u1 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + gnu_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - gnu_u1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * gnu_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / gnu_u1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % gnu_u1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & gnu_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | gnu_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ gnu_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == gnu_u1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != gnu_u1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= gnu_u1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < gnu_u1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > gnu_u1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= gnu_u1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << gnu_u1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> gnu_u1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  gnu_u1 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  gnu_u1 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  gnu_u1 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  gnu_u1 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  gnu_u1 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  gnu_u1 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  gnu_u1 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  gnu_u1 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  gnu_u1 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  gnu_u1 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  gnu_u1 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  gnu_u1 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  gnu_u1 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  gnu_u1 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  gnu_u1 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  gnu_u1 && sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + gnu_u1;\n+  gnu_u1 - gnu_u1;\n+  gnu_u1 * gnu_u1;\n+  gnu_u1 / gnu_u1;\n+  gnu_u1 % gnu_u1;\n+  gnu_u1 & gnu_u1;\n+  gnu_u1 | gnu_u1;\n+  gnu_u1 ^ gnu_u1;\n+  gnu_u1 == gnu_u1;\n+  gnu_u1 != gnu_u1;\n+  gnu_u1 <= gnu_u1;\n+  gnu_u1 < gnu_u1;\n+  gnu_u1 > gnu_u1;\n+  gnu_u1 >= gnu_u1;\n+  gnu_u1 << gnu_u1;\n+  gnu_u1 >> gnu_u1;\n+  gnu_u1 && gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Vector-scalar binary arithmetic.  */\n+\n+  sve_u1 + 2; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - 2; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * 2; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / 2; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % 2; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & 2; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | 2; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ 2; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == 2; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != 2; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= 2; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < 2; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > 2; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= 2; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << 2; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> 2; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && 2; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || 2; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + uc; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - uc; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * uc; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / uc; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % uc; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & uc; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | uc; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ uc; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == uc; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != uc; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= uc; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < uc; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > uc; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= uc; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << uc; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> uc; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && uc; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || uc; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + 2;\n+  gnu_u1 - 2;\n+  gnu_u1 * 2;\n+  gnu_u1 / 2;\n+  gnu_u1 % 2;\n+  gnu_u1 & 2;\n+  gnu_u1 | 2;\n+  gnu_u1 ^ 2;\n+  gnu_u1 == 2;\n+  gnu_u1 != 2;\n+  gnu_u1 <= 2;\n+  gnu_u1 < 2;\n+  gnu_u1 > 2;\n+  gnu_u1 >= 2;\n+  gnu_u1 << 2;\n+  gnu_u1 >> 2;\n+  gnu_u1 && 2; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || 2; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + uc;\n+  gnu_u1 - uc;\n+  gnu_u1 * uc;\n+  gnu_u1 / uc;\n+  gnu_u1 % uc;\n+  gnu_u1 & uc;\n+  gnu_u1 | uc;\n+  gnu_u1 ^ uc;\n+  gnu_u1 == uc;\n+  gnu_u1 != uc;\n+  gnu_u1 <= uc;\n+  gnu_u1 < uc;\n+  gnu_u1 > uc;\n+  gnu_u1 >= uc;\n+  gnu_u1 << uc;\n+  gnu_u1 >> uc;\n+  gnu_u1 && uc; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || uc; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Scalar-vector binary arithmetic.  */\n+\n+  3 + sve_u1; /* { dg-error {invalid operands to binary \\+} } */\n+  3 - sve_u1; /* { dg-error {invalid operands to binary -} } */\n+  3 * sve_u1; /* { dg-error {invalid operands to binary \\*} } */\n+  3 / sve_u1; /* { dg-error {invalid operands to binary /} } */\n+  3 % sve_u1; /* { dg-error {invalid operands to binary %} } */\n+  3 & sve_u1; /* { dg-error {invalid operands to binary \\&} } */\n+  3 | sve_u1; /* { dg-error {invalid operands to binary \\|} } */\n+  3 ^ sve_u1; /* { dg-error {invalid operands to binary \\^} } */\n+  3 == sve_u1; /* { dg-error {invalid operands to binary ==} } */\n+  3 != sve_u1; /* { dg-error {invalid operands to binary !=} } */\n+  3 <= sve_u1; /* { dg-error {invalid operands to binary <=} } */\n+  3 < sve_u1; /* { dg-error {invalid operands to binary <} } */\n+  3 > sve_u1; /* { dg-error {invalid operands to binary >} } */\n+  3 >= sve_u1; /* { dg-error {invalid operands to binary >=} } */\n+  3 << sve_u1; /* { dg-error {invalid operands to binary <<} } */\n+  3 >> sve_u1; /* { dg-error {invalid operands to binary >>} } */\n+  3 && sve_u1; /* { dg-error {invalid operands to binary \\&\\&} } */\n+  3 || sve_u1; /* { dg-error {invalid operands to binary \\|\\|} } */\n+\n+  3 + gnu_u1;\n+  3 - gnu_u1;\n+  3 * gnu_u1;\n+  3 / gnu_u1;\n+  3 % gnu_u1;\n+  3 & gnu_u1;\n+  3 | gnu_u1;\n+  3 ^ gnu_u1;\n+  3 == gnu_u1;\n+  3 != gnu_u1;\n+  3 <= gnu_u1;\n+  3 < gnu_u1;\n+  3 > gnu_u1;\n+  3 >= gnu_u1;\n+  3 << gnu_u1;\n+  3 >> gnu_u1;\n+  3 && gnu_u1; /* { dg-error {invalid operands to binary \\&\\&} } */\n+  3 || gnu_u1; /* { dg-error {invalid operands to binary \\|\\|} } */\n+\n+  /* Mismatched types.  */\n+\n+  sve_u1 + sve_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - sve_s1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * sve_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / sve_s1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % sve_s1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & sve_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | sve_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ sve_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == sve_s1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != sve_s1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= sve_s1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < sve_s1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > sve_s1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= sve_s1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << sve_s1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> sve_s1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  sve_u1 + gnu_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  sve_u1 - gnu_s1; /* { dg-error {invalid operands to binary -} } */\n+  sve_u1 * gnu_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  sve_u1 / gnu_s1; /* { dg-error {invalid operands to binary /} } */\n+  sve_u1 % gnu_s1; /* { dg-error {invalid operands to binary %} } */\n+  sve_u1 & gnu_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  sve_u1 | gnu_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  sve_u1 ^ gnu_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  sve_u1 == gnu_s1; /* { dg-error {invalid operands to binary ==} } */\n+  sve_u1 != gnu_s1; /* { dg-error {invalid operands to binary !=} } */\n+  sve_u1 <= gnu_s1; /* { dg-error {invalid operands to binary <=} } */\n+  sve_u1 < gnu_s1; /* { dg-error {invalid operands to binary <} } */\n+  sve_u1 > gnu_s1; /* { dg-error {invalid operands to binary >} } */\n+  sve_u1 >= gnu_s1; /* { dg-error {invalid operands to binary >=} } */\n+  sve_u1 << gnu_s1; /* { dg-error {invalid operands to binary <<} } */\n+  sve_u1 >> gnu_s1; /* { dg-error {invalid operands to binary >>} } */\n+  sve_u1 && gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 || gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + sve_s1; /* { dg-error {invalid operands to binary \\+} } */\n+  gnu_u1 - sve_s1; /* { dg-error {invalid operands to binary -} } */\n+  gnu_u1 * sve_s1; /* { dg-error {invalid operands to binary \\*} } */\n+  gnu_u1 / sve_s1; /* { dg-error {invalid operands to binary /} } */\n+  gnu_u1 % sve_s1; /* { dg-error {invalid operands to binary %} } */\n+  gnu_u1 & sve_s1; /* { dg-error {invalid operands to binary \\&} } */\n+  gnu_u1 | sve_s1; /* { dg-error {invalid operands to binary \\|} } */\n+  gnu_u1 ^ sve_s1; /* { dg-error {invalid operands to binary \\^} } */\n+  gnu_u1 == sve_s1; /* { dg-error {invalid operands to binary ==} } */\n+  gnu_u1 != sve_s1; /* { dg-error {invalid operands to binary !=} } */\n+  gnu_u1 <= sve_s1; /* { dg-error {invalid operands to binary <=} } */\n+  gnu_u1 < sve_s1; /* { dg-error {invalid operands to binary <} } */\n+  gnu_u1 > sve_s1; /* { dg-error {invalid operands to binary >} } */\n+  gnu_u1 >= sve_s1; /* { dg-error {invalid operands to binary >=} } */\n+  gnu_u1 << sve_s1; /* { dg-error {invalid operands to binary <<} } */\n+  gnu_u1 >> sve_s1; /* { dg-error {invalid operands to binary >>} } */\n+  gnu_u1 && sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || sve_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 + gnu_s1;\n+  gnu_u1 - gnu_s1;\n+  gnu_u1 * gnu_s1;\n+  gnu_u1 / gnu_s1;\n+  gnu_u1 % gnu_s1;\n+  gnu_u1 & gnu_s1;\n+  gnu_u1 | gnu_s1;\n+  gnu_u1 ^ gnu_s1;\n+  gnu_u1 == gnu_s1;\n+  gnu_u1 != gnu_s1;\n+  gnu_u1 <= gnu_s1;\n+  gnu_u1 < gnu_s1;\n+  gnu_u1 > gnu_s1;\n+  gnu_u1 >= gnu_s1;\n+  gnu_u1 << gnu_s1;\n+  gnu_u1 >> gnu_s1;\n+  gnu_u1 && gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 || gnu_s1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Conditional expressions.  */\n+\n+  uc ? sve_u1 : sve_u1;\n+  uc ? gnu_u1 : sve_u1; /* { dg-error {type mismatch in conditional expression} } */\n+  uc ? sve_u1 : gnu_u1; /* { dg-error {type mismatch in conditional expression} } */\n+  uc ? gnu_u1 : gnu_u1;\n+\n+  sve_u1 ? sve_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? gnu_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? sve_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  sve_u1 ? gnu_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  gnu_u1 ? sve_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? gnu_u1 : sve_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? sve_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+  gnu_u1 ? gnu_u1 : gnu_u1; /* { dg-error {used vector type where scalar is required} } */\n+\n+  /* Vector built-ins.  */\n+\n+  __builtin_shuffle (sve_u1, sve_u1, sve_u1); /* { dg-error {'__builtin_shuffle' last argument must be an integer vector} } */\n+  __builtin_shuffle (sve_u1, gnu_u1, gnu_u1); /* { dg-error {'__builtin_shuffle' arguments must be vectors} } */\n+  __builtin_shuffle (gnu_u1, sve_u1, gnu_u1); /* { dg-error {'__builtin_shuffle' arguments must be vectors} } */\n+  __builtin_shuffle (gnu_u1, gnu_u1, sve_u1); /* { dg-error {'__builtin_shuffle' last argument must be an integer vector} } */\n+  __builtin_shuffle (gnu_u1, gnu_u1, gnu_u1);\n+\n+  __builtin_convertvector (sve_u1, svuint8_t); /* { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} } */\n+  __builtin_convertvector (gnu_u1, svuint8_t); /* { dg-error {'__builtin_convertvector' second argument must be an integer or floating vector type} } */\n+  __builtin_convertvector (sve_u1, gnu_uint8_t); /* { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} } */\n+  __builtin_convertvector (gnu_u1, gnu_uint8_t);\n+}"}, {"sha": "12e078882da08575b33ac36c81f6a579dcf908e1", "filename": "gcc/tree-core.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -1628,7 +1628,8 @@ struct GTY(()) tree_type_common {\n   unsigned warn_if_not_align : 6;\n   unsigned typeless_storage : 1;\n   unsigned empty_flag : 1;\n-  unsigned spare : 17;\n+  unsigned indivisible_p : 1;\n+  unsigned spare : 16;\n \n   alias_set_type alias_set;\n   tree pointer_to;"}, {"sha": "a7d39c3a74dfb17e712219206b29dae36cbaccf0", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f486280c53be53136f0bb9b578f43dc6c9c5acea/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f486280c53be53136f0bb9b578f43dc6c9c5acea", "patch": "@@ -714,6 +714,11 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Used to indicate that this TYPE represents a compiler-generated entity.  */\n #define TYPE_ARTIFICIAL(NODE) (TYPE_CHECK (NODE)->base.nowarning_flag)\n \n+/* True if the type is indivisible at the source level, i.e. if its\n+   component parts cannot be accessed directly.  This is used to suppress\n+   normal GNU extensions for target-specific vector types.  */\n+#define TYPE_INDIVISIBLE_P(NODE) (TYPE_CHECK (NODE)->type_common.indivisible_p)\n+\n /* In an IDENTIFIER_NODE, this means that assemble_name was called with\n    this string as an argument.  */\n #define TREE_SYMBOL_REFERENCED(NODE) \\"}]}