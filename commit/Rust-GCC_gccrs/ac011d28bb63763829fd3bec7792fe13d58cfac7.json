{"sha": "ac011d28bb63763829fd3bec7792fe13d58cfac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwMTFkMjhiYjYzNzYzODI5ZmQzYmVjNzc5MmZlMTNkNThjZmFjNw==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-03-12T08:15:54Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-03-12T08:15:54Z"}, "message": "[multiple changes]\n\n2004-03-12  Ito Kazumitsu  <ito.kazumitsu@hitachi-cable.co.jp>\n\n\t* java/net/URI.java (toURL): Implemented.\n\n2004-03-12  Ito Kazumitsu  <ito.kazumitsu@hitachi-cable.co.jp>\n\n\t* java/net/URI.java\n\t(URI_REGEXP) updated to contain scheme specific part.\n\t(SCHEME_SPEC_PART_GROUP) new constant.\n\t(AUTHORITY_GROUP, PATH_GROUP, QUERY_GROUP, FRAGMENT_GROUP)\n\tupdated to make room for SCHEME_SPEC_PART_GROUP.\n\t(parseURI) parse scheme specific part.\n\t(resolve, isAbsolute, isOpaque, getRawSchemeSpecificPart,\n\tgetSchemeSpecificPart, getAuthority, getUserInfo, getPath,\n\tgetQuery, getFragment) implemented.\n\n2004-03-12  Dalibor Topic  <robilad@kaffe.org>\n\n\t* libraries/javalib/java/net/URI.java\n\tpartially implemented using java.util.regex.\n\t(URI_REGEXP) new constant. Used to parse URIs.\n\t(SCHEME_GROUP) new constant representing index of scheme group\n\tin parsed URI.\n\t(AUTHORITY_GROUP) new constant representing index of authority\n\tgroup in parsed URI.\n\t(PATH_GROUP) new constant representing index of path group in\n\tparsed URI.\n\t(QUERY_GROUP) new constant representing index of query group in\n\tparsed URI.\n\t(FRAGMENT_GROUP) new constant representing index of fragment\n\tgroup in parsed URI.\n\t(getURIGroup) new static utility method.\n\t(parseURI) implemented.\n\t(quote) stub for new static utility method.\n\t(quoteAuthority) stub for new static utility method.\n\t(quoteHost) stub for new static utility method.\n\t(quotePath) stub for new static utility method.\n\t(quoteUserInfo) stub for new static utility method.\n\t(URI) implemented.\n\t(create) don't throw URISyntaxException. Implemented.\n\t(toString) implemented.\n\nFrom-SVN: r79375", "tree": {"sha": "678223894236ff0749b97ea1e3f8012b3aacc02b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/678223894236ff0749b97ea1e3f8012b3aacc02b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac011d28bb63763829fd3bec7792fe13d58cfac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac011d28bb63763829fd3bec7792fe13d58cfac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac011d28bb63763829fd3bec7792fe13d58cfac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac011d28bb63763829fd3bec7792fe13d58cfac7/comments", "author": null, "committer": null, "parents": [{"sha": "75e0f3fe0fb3871b640a8c143340eb084acd9b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e0f3fe0fb3871b640a8c143340eb084acd9b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e0f3fe0fb3871b640a8c143340eb084acd9b34"}], "stats": {"total": 315, "additions": 295, "deletions": 20}, "files": [{"sha": "2f1fcf30878ad9607f3c6967f6005426f010ad21", "filename": "libjava/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac011d28bb63763829fd3bec7792fe13d58cfac7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac011d28bb63763829fd3bec7792fe13d58cfac7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ac011d28bb63763829fd3bec7792fe13d58cfac7", "patch": "@@ -1,3 +1,45 @@\n+2004-03-12  Ito Kazumitsu  <ito.kazumitsu@hitachi-cable.co.jp>\n+\n+\t* java/net/URI.java (toURL): Implemented.\n+\n+2004-03-12  Ito Kazumitsu  <ito.kazumitsu@hitachi-cable.co.jp>\n+\n+\t* java/net/URI.java\n+\t(URI_REGEXP) updated to contain scheme specific part.\n+\t(SCHEME_SPEC_PART_GROUP) new constant.\n+\t(AUTHORITY_GROUP, PATH_GROUP, QUERY_GROUP, FRAGMENT_GROUP)\n+\tupdated to make room for SCHEME_SPEC_PART_GROUP.\n+\t(parseURI) parse scheme specific part.\n+\t(resolve, isAbsolute, isOpaque, getRawSchemeSpecificPart,\n+\tgetSchemeSpecificPart, getAuthority, getUserInfo, getPath,\n+\tgetQuery, getFragment) implemented.\n+\n+2004-03-12  Dalibor Topic  <robilad@kaffe.org>\n+\n+\t* libraries/javalib/java/net/URI.java\n+\tpartially implemented using java.util.regex.\n+\t(URI_REGEXP) new constant. Used to parse URIs.\n+\t(SCHEME_GROUP) new constant representing index of scheme group\n+\tin parsed URI.\n+\t(AUTHORITY_GROUP) new constant representing index of authority\n+\tgroup in parsed URI.\n+\t(PATH_GROUP) new constant representing index of path group in\n+\tparsed URI.\n+\t(QUERY_GROUP) new constant representing index of query group in\n+\tparsed URI.\n+\t(FRAGMENT_GROUP) new constant representing index of fragment\n+\tgroup in parsed URI.\n+\t(getURIGroup) new static utility method.\n+\t(parseURI) implemented.\n+\t(quote) stub for new static utility method.\n+\t(quoteAuthority) stub for new static utility method.\n+\t(quoteHost) stub for new static utility method.\n+\t(quotePath) stub for new static utility method.\n+\t(quoteUserInfo) stub for new static utility method.\n+\t(URI) implemented.\n+\t(create) don't throw URISyntaxException. Implemented.\n+\t(toString) implemented.\n+\n 2004-03-12  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/HttpURLConnection.java"}, {"sha": "a2f77a460560795cbca5e4b5f657932fba1cd29e", "filename": "libjava/java/net/URI.java", "status": "modified", "additions": 253, "deletions": 20, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac011d28bb63763829fd3bec7792fe13d58cfac7/libjava%2Fjava%2Fnet%2FURI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac011d28bb63763829fd3bec7792fe13d58cfac7/libjava%2Fjava%2Fnet%2FURI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURI.java?ref=ac011d28bb63763829fd3bec7792fe13d58cfac7", "patch": "@@ -1,5 +1,5 @@\n /* URI.java - An URI class\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,17 +41,59 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n /**\n- * @author Michael Koch <konqueror@gmx.de>\n+ * @author Ito Kazumitsu (ito.kazumitsu@hitachi-cable.co.jp)\n+ * @author Dalibor Topic (robilad@kaffe.org)\n+ * @author Michael Koch (konqueror@gmx.de)\n  * @since 1.4\n  */\n public final class URI\n   implements Comparable, Serializable\n {\n   static final long serialVersionUID = -6052424284110960213L;\n \n-  String string;\n+  /**\n+   * Regular expression for parsing URIs.\n+   *\n+   * Taken from RFC 2396, Appendix B.\n+   * This expression doesn't parse IPv6 addresses.\n+   */\n+  private static final String URI_REGEXP =\n+    \"^(([^:/?#]+):)?((//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?)?(#(.*))?\";\n+\n+  /**\n+   * Index of scheme component in parsed URI.\n+   */\n+  private static final int SCHEME_GROUP = 2;\n+\n+  /**\n+   * Index of scheme-specific-part in parsed URI.\n+   */\n+  private static final int SCHEME_SPEC_PART_GROUP = 3;\n+\n+  /**\n+   * Index of authority component in parsed URI.\n+   */\n+  private static final int AUTHORITY_GROUP = 5;\n+\n+  /**\n+   * Index of path component in parsed URI.\n+   */\n+  private static final int PATH_GROUP = 6;\n+\n+  /**\n+   * Index of query component in parsed URI.\n+   */\n+  private static final int QUERY_GROUP = 8;\n+\n+  /**\n+   * Index of fragment component in parsed URI.\n+   */\n+  private static final int FRAGMENT_GROUP = 10;\n+\n   private String scheme;\n   private String schemeSpecificPart;\n   private String authority;\n@@ -72,11 +114,117 @@ private void writeObject (ObjectOutputStream is)\n   {\n   }\n \n+  private static String getURIGroup (Matcher match, int group) {\n+    String matched = match.group(group);\n+    return matched.length() == 0 ? null : matched;\n+  }\n+\n+  /**\n+   * Sets fields of this URI by parsing the given string.\n+   *\n+   * @param str The string to parse\n+   *\n+   * @exception URISyntaxException If the given string violates RFC 2396\n+   */\n   private void parseURI (String str)\n     throws URISyntaxException\n   {\n+    Pattern pattern = Pattern.compile(URI_REGEXP);\n+    Matcher matcher = pattern.matcher(str);\n+    if (matcher.matches())\n+      {\n+\tscheme = getURIGroup(matcher, SCHEME_GROUP);\n+\tschemeSpecificPart = getURIGroup(matcher, SCHEME_SPEC_PART_GROUP); \n+\tauthority = getURIGroup(matcher, AUTHORITY_GROUP);\n+\tpath = getURIGroup(matcher, PATH_GROUP);\n+\tquery = getURIGroup(matcher, QUERY_GROUP);\n+\tfragment = getURIGroup(matcher, FRAGMENT_GROUP);\n+      }\n+    else\n+      throw new URISyntaxException(str,\n+\t\t\t\t   \"doesn't match URI regular expression\");\n+  }\n+\n+  /**\n+   * Quote characters illegal in URIs in given string.\n+   *\n+   * Replace illegal characters by encoding their UTF-8\n+   * representation as \"%\" + hex code for each resulting\n+   * UTF-8 character.\n+   *\n+   * @param str The string to quote\n+   * \n+   * @return The quoted string.\n+   */\n+  private static String quote (String str) {\n+    // FIXME: unimplemented.\n+    return str;\n+  }\n+\n+  /**\n+   * Quote characters illegal in URI authorities in given string.\n+   *\n+   * Replace illegal characters by encoding their UTF-8\n+   * representation as \"%\" + hex code for each resulting\n+   * UTF-8 character.\n+   *\n+   * @param str The string to quote\n+   * \n+   * @return The quoted string.\n+   */\n+  private static String quoteAuthority (String str) {\n+    // FIXME: unimplemented.\n+    return str;\n   }\n-  \n+\n+  /**\n+   * Quote characters illegal in URI hosts in given string.\n+   *\n+   * Replace illegal characters by encoding their UTF-8\n+   * representation as \"%\" + hex code for each resulting\n+   * UTF-8 character.\n+   *\n+   * @param str The string to quote\n+   * \n+   * @return The quoted string.\n+   */\n+  private static String quoteHost (String str) {\n+    // FIXME: unimplemented.\n+    return str;\n+  }\n+\n+  /**\n+   * Quote characters illegal in URI paths in given string.\n+   *\n+   * Replace illegal characters by encoding their UTF-8\n+   * representation as \"%\" + hex code for each resulting\n+   * UTF-8 character.\n+   *\n+   * @param str The string to quote\n+   * \n+   * @return The quoted string.\n+   */\n+  private static String quotePath (String str) {\n+    // FIXME: unimplemented.\n+    return str;\n+  }\n+\n+  /**\n+   * Quote characters illegal in URI user infos in given string.\n+   *\n+   * Replace illegal characters by encoding their UTF-8\n+   * representation as \"%\" + hex code for each resulting\n+   * UTF-8 character.\n+   *\n+   * @param str The string to quote\n+   * \n+   * @return The quoted string.\n+   */\n+  private static String quoteUserInfo (String str) {\n+    // FIXME: unimplemented.\n+    return str;\n+  }\n+\n   /**\n    * Creates an URI from the given string\n    *\n@@ -88,6 +236,7 @@ private void parseURI (String str)\n   public URI (String str)\n     throws URISyntaxException\n   {\n+    parseURI(str);\n   }\n  \n   /**\n@@ -107,6 +256,16 @@ public URI (String scheme, String userInfo, String host, int port,\n \t     String path, String query, String fragment)\n     throws URISyntaxException\n   {\n+    this((scheme == null ? \"\" : scheme + \":\" )\n+\t + (userInfo == null && host == null && port == -1 ? \"\" : \"//\")\n+\t + (userInfo == null ? \"\" : quoteUserInfo(userInfo) + \"@\")\n+\t + (host == null ? \"\" : quoteHost(host))\n+\t + (port == -1 ? \"\" : \":\" + String.valueOf(port))\n+\t + (path == null ? \"\" : quotePath(path))\n+\t + (query == null ? \"\" : \"?\" + quote(query))\n+\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n+    \n+    parseServerAuthority();\n   }\n \n   /**\n@@ -116,14 +275,19 @@ public URI (String scheme, String userInfo, String host, int port,\n    * @param authority The authority\n    * @param path The apth\n    * @param query The query\n-   * @param fragment The fragmen\n+   * @param fragment The fragment\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n   public URI (String scheme, String authority, String path, String query,\n \t     String fragment)\n     throws URISyntaxException\n   {\n+    this((scheme == null ? \"\" : scheme + \":\")\n+\t + (authority == null ? \"\" : \"//\" + quoteAuthority(authority))\n+\t + (path == null ? \"\" : quotePath(path))\n+\t + (query == null ? \"\" : \"?\" + quote(query))\n+\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n   }\n \n   /**\n@@ -139,6 +303,7 @@ public URI (String scheme, String authority, String path, String query,\n   public URI (String scheme, String host, String path, String fragment)\n     throws URISyntaxException\n   {\n+    this(scheme, null, host, -1, path, null, fragment);\n   }\n \n   /**\n@@ -153,6 +318,9 @@ public URI (String scheme, String host, String path, String fragment)\n   public URI (String scheme, String ssp, String fragment)\n     throws URISyntaxException\n   {\n+    this((scheme == null ? \"\" : scheme + \":\")\n+\t + (ssp == null ? \"\" : quote(ssp))\n+\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n   }\n \n   /**\n@@ -165,7 +333,15 @@ public URI (String scheme, String ssp, String fragment)\n    */\n   public static URI create (String str)\n   {\n-    return null;\n+    try\n+      {\n+\treturn new URI(str);\n+      }\n+    catch(URISyntaxException e)\n+      {\n+\tthrow (IllegalArgumentException)\n+\t  new IllegalArgumentException().initCause(e);\n+      }\n   }\n \n   /**\n@@ -193,13 +369,57 @@ public URI normalize ()\n    *\n    * @param uri The URI to resolve against this URI\n    *\n-   * @return The resulting URI\n+   * @return The resulting URI, or null when it couldn't be resolved\n+   * for some reason.\n    *\n    * @exception NullPointerException If uri is null\n    */\n   public URI resolve (URI uri)\n   { \n-    return null;\n+    if (uri.isAbsolute())\n+      return uri;\n+    if (uri.isOpaque())\n+      return uri;\n+\n+    String scheme = uri.getScheme();\n+    String schemeSpecificPart = uri.getSchemeSpecificPart();\n+    String authority = uri.getAuthority();\n+    String path = uri.getPath();\n+    String query = uri.getQuery();\n+    String fragment = uri.getFragment();\n+\n+    try\n+      {\n+        if (fragment != null &&\n+            path != null && path.equals(\"\") &&\n+            scheme == null && authority == null && query == null)\n+\t  return new URI(this.scheme, this.schemeSpecificPart, fragment);\n+\n+        if (authority == null)\n+\t  {\n+            authority = this.authority;\n+            if (path == null)\n+\t      path = \"\";\n+            if (!(path.startsWith(\"/\")))\n+\t      {\n+                StringBuffer basepath = new StringBuffer(this.path);\n+                int i = this.path.lastIndexOf('/');\n+\n+                if (i >= 0)\n+\t\t  basepath.delete(i+1, basepath.length());\n+\n+                basepath.append(path);\n+                path = basepath.toString();\n+                //  FIXME We must normalize the path here.\n+                //  Normalization process omitted.\n+\t      }\n+\t  }\n+        return new URI(this.scheme, authority, path, query, fragment);\n+      }\n+    catch (URISyntaxException e)\n+      {\n+        return null;\n+      }\n   }\n \n   /**\n@@ -216,7 +436,7 @@ public URI resolve (URI uri)\n   public URI resolve (String str)\n     throws IllegalArgumentException\n   {\n-    return null;\n+    return resolve(create(str));\n   }\n \n   /**\n@@ -243,7 +463,10 @@ public URI relativize (URI uri)\n   public URL toURL ()\n     throws IllegalArgumentException, MalformedURLException\n   {\n-    return null;\n+    if (isAbsolute())\n+      return new URL(this.toString());\n+\n+    throw new IllegalArgumentException(\"not absolute\");\n   }\n \n   /**\n@@ -259,15 +482,15 @@ public String getScheme ()\n    */\n   public boolean isAbsolute ()\n   {\n-    return false;\n+    return (scheme != null);\n   }\n \n   /**\n    * Tell whether this URI is opaque or not\n    */\n   public boolean isOpaque ()\n   {\n-    return false;\n+    return ((scheme != null) && !(schemeSpecificPart.startsWith(\"/\")));\n   }\n \n   /**\n@@ -276,15 +499,16 @@ public boolean isOpaque ()\n    */\n   public String getRawSchemeSpecificPart ()\n   {\n-    return null;\n+    return schemeSpecificPart;\n   }\n \n   /**\n    * Returns the decoded scheme specific part of this URI.\n    */\n   public String getSchemeSpecificPart ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return schemeSpecificPart;\n   }\n \n   /**\n@@ -300,7 +524,8 @@ public String getRawAuthority ()\n    */\n   public String getAuthority ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return authority;\n   }\n \n   /**\n@@ -316,7 +541,8 @@ public String getRawUserInfo ()\n    */\n   public String getUserInfo ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return userInfo;\n   }\n \n   /**\n@@ -348,7 +574,8 @@ public String getRawPath ()\n    */\n   public String getPath ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return path;\n   }\n \n   /**\n@@ -364,7 +591,8 @@ public String getRawQuery ()\n    */\n   public String getQuery ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return query;\n   }\n \n   /**\n@@ -380,7 +608,8 @@ public String getRawFragment ()\n    */\n   public String getFragment ()\n   {\n-    return null;\n+    // FIXME: unimplemented.\n+    return fragment;\n   }\n \n   /**\n@@ -419,7 +648,11 @@ public int compareTo (Object obj)\n    */\n   public String toString ()\n   {\n-    return \"\";\n+    return (getScheme() == null ? \"\" : getScheme() + \":\")\n+      + (getRawAuthority() == null ? \"\" : \"//\" + getRawAuthority())\n+      + (getRawPath() == null ? \"\" : getRawPath())\n+      + (getRawQuery() == null ? \"\" : \"?\" + getRawQuery())\n+      + (getRawFragment() == null ? \"\" : \"#\" + getRawFragment());\n   }\n \n   /**"}]}