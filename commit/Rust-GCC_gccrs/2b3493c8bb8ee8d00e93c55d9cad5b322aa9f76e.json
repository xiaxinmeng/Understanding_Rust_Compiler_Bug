{"sha": "2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzNDkzYzhiYjhlZThkMDBlOTNjNTVkOWNhZDViMzIyYWE5Zjc2ZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2004-03-06T01:21:28Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-03-06T01:21:28Z"}, "message": "rtl.h (mem_expr_equal_p): Function prototype added.\n\n2004-03-05  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* rtl.h (mem_expr_equal_p): Function prototype added.\n\t* cfgcleanup.c (merge_memattrs): New function.\n\t(flow_find_cross_jump): Call merge_memattrs for matching insns.\n\t* emit-rtl.c (mem_expr_equal_p): New function.\n\n2004-03-05  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* gcc.dg/20040305-1.c: New test.\n\nFrom-SVN: r79005", "tree": {"sha": "357cb8fd1a073e3842ae68057a07998e44bc5205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/357cb8fd1a073e3842ae68057a07998e44bc5205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/comments", "author": null, "committer": null, "parents": [{"sha": "1a4a7065a972b721e9a5555dc87cd8d4d4ce755e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4a7065a972b721e9a5555dc87cd8d4d4ce755e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4a7065a972b721e9a5555dc87cd8d4d4ce755e"}], "stats": {"total": 182, "additions": 182, "deletions": 0}, "files": [{"sha": "76710e788cb122133c08d8c8ace9e75e03eda815", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -1,3 +1,10 @@\n+2004-03-05  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* rtl.h (mem_expr_equal_p): Function prototype added.\n+\t* cfgcleanup.c (merge_memattrs): New function.\n+\t(flow_find_cross_jump): Call merge_memattrs for matching insns.\n+\t* emit-rtl.c (mem_expr_equal_p): New function.\n+\n 2004-03-05  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc/objc-act.c (synth_module_prologue): Const-qualify"}, {"sha": "9029b5fb850be79a72d60bbad11217ddf0891a3f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"regs.h\"\n+#include \"expr.h\"\n \n /* cleanup_cfg maintains following flags for each basic block.  */\n \n@@ -87,6 +88,7 @@ static bool mark_effect (rtx, bitmap);\n static void notice_new_block (basic_block);\n static void update_forwarder_flag (basic_block);\n static int mentions_nonequal_regs (rtx *, void *);\n+static void merge_memattrs (rtx, rtx);\n \f\n /* Set flags for newly created block.  */\n \n@@ -862,6 +864,88 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n }\n \f\n \n+/* Removes the memory attributes of MEM expression\n+   if they are not equal.  */\n+\n+void\n+merge_memattrs (rtx x, rtx y)\n+{\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == y)\n+    return;\n+  if (x == 0 || y == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  if (code != GET_CODE (y))\n+    return;\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return;\n+\n+  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))\n+    {\n+      if (! MEM_ATTRS (x))\n+\tMEM_ATTRS (y) = 0;\n+      else if (! MEM_ATTRS (y))\n+\tMEM_ATTRS (x) = 0;\n+      else \n+\t{\n+\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n+\t    {\n+\t      set_mem_alias_set (x, 0);\n+\t      set_mem_alias_set (y, 0);\n+\t    }\n+\t  \n+\t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n+\t    {\n+\t      set_mem_expr (x, 0);\n+\t      set_mem_expr (y, 0);\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n+\t    {\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t  \n+\t  set_mem_size (x, MAX (MEM_SIZE (x), MEM_SIZE (y)));\n+\t  set_mem_size (y, MEM_SIZE (x));\n+\n+\t  set_mem_align (x, MIN (MEM_ALIGN (x), MEM_ALIGN (y)));\n+\t  set_mem_align (y, MEM_ALIGN (x));\n+\t}\n+    }\n+  \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    merge_memattrs (XVECEXP (x, i, j), XVECEXP (y, i, j));\n+\n+\t  break;\n+\n+\tcase 'e':\n+\t  merge_memattrs (XEXP (x, i), XEXP (y, i));\n+\t}\n+    }\n+  return;\n+}\n+\n+\n /* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n \n static bool\n@@ -1022,6 +1106,8 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n       if (!insns_match_p (mode, i1, i2))\n \tbreak;\n \n+      merge_memattrs (i1, i2);\n+\n       /* Don't begin a cross-jump with a NOTE insn.  */\n       if (INSN_P (i1))\n \t{"}, {"sha": "3032b539e297d758d9e59c383f593b9f2d030cba", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -1434,6 +1434,40 @@ component_ref_for_mem_expr (tree ref)\n \t\t  TREE_OPERAND (ref, 1));\n }\n \n+/* Returns 1 if both MEM_EXPR can be considered equal\n+   and 0 otherwise.  */\n+\n+int\n+mem_expr_equal_p (tree expr1, tree expr2)\n+{\n+  if (expr1 == expr2)\n+    return 1;\n+\n+  if (! expr1 || ! expr2)\n+    return 0;\n+\n+  if (TREE_CODE (expr1) != TREE_CODE (expr2))\n+    return 0;\n+\n+  if (TREE_CODE (expr1) == COMPONENT_REF)\n+    return \n+      mem_expr_equal_p (TREE_OPERAND (expr1, 0),\n+\t\t\tTREE_OPERAND (expr2, 0))\n+      && mem_expr_equal_p (TREE_OPERAND (expr1, 1), /* field decl */\n+\t\t\t   TREE_OPERAND (expr2, 1));\n+  \n+  if (TREE_CODE (expr1) == INDIRECT_REF)\n+    return mem_expr_equal_p (TREE_OPERAND (expr1, 0),\n+\t\t\t     TREE_OPERAND (expr2, 0));\n+  \n+  /* Decls with different pointers can't be equal.  */\n+  if (DECL_P (expr1))\n+    return 0;\n+\n+  abort(); /* ARRAY_REFs, ARRAY_RANGE_REFs and BIT_FIELD_REFs should already\n+\t      have been resolved here.  */\n+}\n+\n /* Given REF, a MEM, and T, either the type of X or the expression\n    corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n    if we are making a new object of this type.  BITPOS is nonzero if"}, {"sha": "6da77683fa3e3181d0ad269d7ce0640b382f62e0", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -1569,6 +1569,7 @@ extern void set_reg_attrs_from_mem (rtx, rtx);\n extern void set_mem_attrs_from_reg (rtx, rtx);\n extern void set_reg_attrs_for_parm (rtx, rtx);\n extern void set_reg_pointer_align (rtx, unsigned int);\n+extern int mem_expr_equal_p (tree, tree);\n \n /* In rtl.c */\n extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);"}, {"sha": "00a174a74c9381584226f868117a9e4a86293666", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -1,3 +1,7 @@\n+2004-03-05  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* gcc.dg/20040305-1.c: New test.\n+\n 2004-03-05  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR other/14354"}, {"sha": "62b920c5e1b2eaf9b7aea2fb33df7d73c680bd04", "filename": "gcc/testsuite/gcc.dg/20040305-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Ftestsuite%2Fgcc.dg%2F20040305-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e/gcc%2Ftestsuite%2Fgcc.dg%2F20040305-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20040305-1.c?ref=2b3493c8bb8ee8d00e93c55d9cad5b322aa9f76e", "patch": "@@ -0,0 +1,50 @@\n+\n+/* The testcase failed due to corrupted alias information.\n+   During the crossjump analyzing step the mem alias info of the\n+   st instructions are merged and get copied during basic block\n+   reordering which leads to an insn with wrong alias info.\n+   The scheduler afterwards exchanges the mvc and st instructions \n+   not recognizing the anti dependence.  */\n+/* { dg-do run { target s390-*-* } } */\n+/* { dg-options \"-O3 -mtune=z990 -fno-inline\" } */\n+\n+int f;\n+int g;\n+int h;\n+\n+int* x  = &f;\n+int* p1 = &g;\n+int* p2 = &h;\n+\n+int\n+foo(void)\n+{\n+\n+  if (*x == 0)\n+    {\n+      x = p1;         /* mvc - memory to memory */\n+      p1 = (int*)0;   /* st  - register to memory */\n+      return 1;\n+    }\n+  if (*x == 5)\n+    {\n+      f = 1;\n+      g = 2;\n+\n+      p2 = (int*)0;   /* st */   \n+      return 1;\n+    }\n+}\n+\n+int\n+main (int argc, char** argv)\n+{\n+  foo ();\n+\n+  /* If the scheduler has exchanged the mvc and st instructions,\n+     x is 0. The expected result is &g.  */\n+  if (x == &g)\n+    exit (0);\n+  else\n+    abort ();\n+}"}]}