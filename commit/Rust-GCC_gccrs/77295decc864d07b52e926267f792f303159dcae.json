{"sha": "77295decc864d07b52e926267f792f303159dcae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcyOTVkZWNjODY0ZDA3YjUyZTkyNjI2N2Y3OTJmMzAzMTU5ZGNhZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-14T06:19:31Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-14T06:19:31Z"}, "message": "(extract_bit_field, fields bigger than word case): Count subwords in target.\n\n(extract_bit_field, fields bigger than word case): Count\nsubwords in target.  Zero remaining upper bits if unsigned.\n\nFrom-SVN: r8756", "tree": {"sha": "2334c5522fd484510c51bf4fc45d9eea68072804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2334c5522fd484510c51bf4fc45d9eea68072804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77295decc864d07b52e926267f792f303159dcae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77295decc864d07b52e926267f792f303159dcae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77295decc864d07b52e926267f792f303159dcae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77295decc864d07b52e926267f792f303159dcae/comments", "author": null, "committer": null, "parents": [{"sha": "7726fc45eeb1e9088947f16ba80bf3f5a24dc4b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7726fc45eeb1e9088947f16ba80bf3f5a24dc4b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7726fc45eeb1e9088947f16ba80bf3f5a24dc4b5"}], "stats": {"total": 32, "additions": 29, "deletions": 3}, "files": [{"sha": "6ff8b2b104947b35b2dc8bed4c43171e89a3eb04", "filename": "gcc/expmed.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77295decc864d07b52e926267f792f303159dcae/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77295decc864d07b52e926267f792f303159dcae/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=77295decc864d07b52e926267f792f303159dcae", "patch": "@@ -847,6 +847,10 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       offset += SUBREG_WORD (op0);\n       op0 = SUBREG_REG (op0);\n     }\n+\n+  /* ??? We currently assume TARGET is at least as big as BITSIZE.\n+     If that's wrong, the solution is to test for it and set TARGET to 0\n+     if needed.  */\n   \n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n@@ -909,7 +913,11 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t{\n \t  /* If I is 0, use the low-order word in both field and target;\n \t     if I is 1, use the next to lowest word; and so on.  */\n-\t  int wordnum = (WORDS_BIG_ENDIAN ? nwords - i - 1 : i);\n+\t  /* Word number in TARGET to use.  */\n+\t  int wordnum = (WORDS_BIG_ENDIAN\n+\t\t\t ? GET_MODE_SIZE (GET_MODE (target)) / UNITS_PER_WORD - i - 1\n+\t\t\t : i);\n+\t  /* Offset from start of field in OP0.  */\n \t  int bit_offset = (WORDS_BIG_ENDIAN\n \t\t\t    ? MAX (0, bitsize - (i + 1) * BITS_PER_WORD)\n \t\t\t    : i * BITS_PER_WORD);\n@@ -929,7 +937,24 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t}\n \n       if (unsignedp)\n-\treturn target;\n+\t{\n+\t  /* Unless we've filled TARGET, the upper regs in a multi-reg value\n+\t     need to be zero'd out.  */\n+\t  if (GET_MODE_SIZE (GET_MODE (target)) > nwords * UNITS_PER_WORD)\n+\t    {\n+\t      int i,total_words;\n+\n+\t      total_words = GET_MODE_SIZE (GET_MODE (target)) / UNITS_PER_WORD;\n+\t      for (i = nwords; i < total_words; i++)\n+\t\t{\n+\t\t  int wordnum = WORDS_BIG_ENDIAN ? total_words - i - 1 : i;\n+\t\t  rtx target_part = operand_subword (target, wordnum, 1, VOIDmode);\n+\t\t  emit_move_insn (target_part, const0_rtx);\n+\t\t}\n+\t    }\n+\t  return target;\n+\t}\n+\n       /* Signed bit field: sign-extend with two arithmetic shifts.  */\n       target = expand_shift (LSHIFT_EXPR, mode, target,\n \t\t\t     build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n@@ -1424,7 +1449,8 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n /* Return a constant integer (CONST_INT or CONST_DOUBLE) mask value\n    of mode MODE with BITSIZE ones followed by BITPOS zeros, or the\n    complement of that if COMPLEMENT.  The mask is truncated if\n-   necessary to the width of mode MODE.  */\n+   necessary to the width of mode MODE.  The mask is zero-extended if\n+   BITSIZE+BITPOS is too small for MODE.  */\n \n static rtx\n mask_rtx (mode, bitpos, bitsize, complement)"}]}