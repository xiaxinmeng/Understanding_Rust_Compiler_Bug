{"sha": "0e3a99ae913c732f015b0dcfecb85d3236cc142f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzYTk5YWU5MTNjNzMyZjAxNWIwZGNmZWNiODVkMzIzNmNjMTQyZg==", "commit": {"author": {"name": "Artjoms Sinkarovs", "email": "artyom.shinkaroff@gmail.com", "date": "2011-08-10T14:44:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-10T14:44:02Z"}, "message": "c-typeck.c (scalar_to_vector): New function.\n\n2011-08-10  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n\n\t* c-typeck.c (scalar_to_vector): New function. Try scalar to\n\tvector conversion.\n\t(stv_conv): New enum for scalar_to_vector return type.\n\t(build_binary_op): Adjust.\n\t* doc/extend.texi: Description of scalar to vector expansion.\n\n\tc-family/\n\t* c-common.c (unsafe_conversion_p): New function. Check if it is\n\tunsafe to convert an expression to the type.\n\t(conversion_warning): Adjust, use unsafe_conversion_p.\n\t* c-common.h (unsafe_conversion_p): New function declaration.\n\n\ttestsuite/\n\t* gcc.c-torture/execute/scal-to-vec1.c: New test.\n\t* gcc.c-torture/execute/scal-to-vec2.c: New test.\n\t* gcc.c-torture/execute/scal-to-vec3.c: New test.\n\t* gcc.dg/scal-to-vec1.c: New test.\n\t* gcc.dg/scal-to-vec2.c: New test.\n\nFrom-SVN: r177622", "tree": {"sha": "1a68ab24120fe0d7e02fe83b3b5e700f8d676001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a68ab24120fe0d7e02fe83b3b5e700f8d676001"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3a99ae913c732f015b0dcfecb85d3236cc142f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3a99ae913c732f015b0dcfecb85d3236cc142f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3a99ae913c732f015b0dcfecb85d3236cc142f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3a99ae913c732f015b0dcfecb85d3236cc142f/comments", "author": {"login": "ashinkarov", "id": 892232, "node_id": "MDQ6VXNlcjg5MjIzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/892232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashinkarov", "html_url": "https://github.com/ashinkarov", "followers_url": "https://api.github.com/users/ashinkarov/followers", "following_url": "https://api.github.com/users/ashinkarov/following{/other_user}", "gists_url": "https://api.github.com/users/ashinkarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashinkarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashinkarov/subscriptions", "organizations_url": "https://api.github.com/users/ashinkarov/orgs", "repos_url": "https://api.github.com/users/ashinkarov/repos", "events_url": "https://api.github.com/users/ashinkarov/events{/privacy}", "received_events_url": "https://api.github.com/users/ashinkarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0eb778344e8c1d4e9da37a098bceef7201283432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb778344e8c1d4e9da37a098bceef7201283432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb778344e8c1d4e9da37a098bceef7201283432"}], "stats": {"total": 736, "additions": 592, "deletions": 144}, "files": [{"sha": "7d5b49224b38457678329337b90c3fbe55ad24dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -1,3 +1,11 @@\n+2011-08-10  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n+\n+\t* c-typeck.c (scalar_to_vector): New function. Try scalar to\n+\tvector conversion.\n+\t(stv_conv): New enum for scalar_to_vector return type.\n+\t(build_binary_op): Adjust.\n+\t* doc/extend.texi: Description of scalar to vector expansion.\n+\n 2011-08-10  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.h (get_pointer_alignment): Remove max-align argument."}, {"sha": "5f56369f3c34b049c067f1cad9f610df67d4a032", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -1,3 +1,10 @@\n+2011-08-10  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n+\n+\t* c-common.c (unsafe_conversion_p): New function. Check if it is\n+\tunsafe to convert an expression to the type.\n+\t(conversion_warning): Adjust, use unsafe_conversion_p.\n+\t* c-common.h (unsafe_conversion_p): New function declaration.\n+\n 2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-common.h (c_finish_omp_atomic): Adjust prototype."}, {"sha": "1ef7e3c42e20f5bdefb4931a4b03f02fb59c7252", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 164, "deletions": 137, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -1922,143 +1922,92 @@ shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n   return result_type;\n }\n \n-/* Warns if the conversion of EXPR to TYPE may alter a value.\n-   This is a helper function for warnings_for_convert_and_check.  */\n-\n-static void\n-conversion_warning (tree type, tree expr)\n+/* Checks if expression EXPR of real/integer type cannot be converted \n+   to the real/integer type TYPE. Function returns true when:\n+\t* EXPR is a constant which cannot be exactly converted to TYPE \n+\t* EXPR is not a constant and size of EXPR's type > than size of TYPE, \n+\t  for EXPR type and TYPE being both integers or both real.\n+\t* EXPR is not a constant of real type and TYPE is an integer.  \n+\t* EXPR is not a constant of integer type which cannot be \n+\t  exactly converted to real type.  \n+   Function allows conversions between types of different signedness and\n+   does not return true in that case.  Function can produce signedness\n+   warnings if PRODUCE_WARNS is true.  */\n+bool\n+unsafe_conversion_p (tree type, tree expr, bool produce_warns)\n {\n   bool give_warning = false;\n-\n-  int i;\n-  const int expr_num_operands = TREE_OPERAND_LENGTH (expr);\n   tree expr_type = TREE_TYPE (expr);\n   location_t loc = EXPR_LOC_OR_HERE (expr);\n \n-  if (!warn_conversion && !warn_sign_conversion)\n-    return;\n-\n-  /* If any operand is artificial, then this expression was generated\n-     by the compiler and we do not warn.  */\n-  for (i = 0; i < expr_num_operands; i++)\n-    {\n-      tree op = TREE_OPERAND (expr, i);\n-      if (op && DECL_P (op) && DECL_ARTIFICIAL (op))\n-\treturn;\n-    }\n-\n-  switch (TREE_CODE (expr))\n+  if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n     {\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_NOT_EXPR:\n-      /* Conversion from boolean to a signed:1 bit-field (which only\n-\t can hold the values 0 and -1) doesn't lose information - but\n-\t it does change the value.  */\n-      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT from boolean expression\", type);\n-      return;\n-\n-    case REAL_CST:\n-    case INTEGER_CST:\n-\n       /* Warn for real constant that is not an exact integer converted\n-         to integer type.  */\n+\t to integer type.  */\n       if (TREE_CODE (expr_type) == REAL_TYPE\n-          && TREE_CODE (type) == INTEGER_TYPE)\n-        {\n-          if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (expr_type)))\n-            give_warning = true;\n-        }\n+\t  && TREE_CODE (type) == INTEGER_TYPE)\n+\t{\n+\t  if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (expr_type)))\n+\t    give_warning = true;\n+\t}\n       /* Warn for an integer constant that does not fit into integer type.  */\n       else if (TREE_CODE (expr_type) == INTEGER_TYPE\n-               && TREE_CODE (type) == INTEGER_TYPE\n-               && !int_fits_type_p (expr, type))\n-        {\n-          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)\n+\t       && TREE_CODE (type) == INTEGER_TYPE\n+\t       && !int_fits_type_p (expr, type))\n+\t{\n+\t  if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)\n \t      && tree_int_cst_sgn (expr) < 0)\n-\t    warning_at (loc, OPT_Wsign_conversion, \"negative integer\"\n-\t\t\t\" implicitly converted to unsigned type\");\n-          else if (!TYPE_UNSIGNED (type) && TYPE_UNSIGNED (expr_type))\n-\t    warning_at (loc, OPT_Wsign_conversion, \"conversion of unsigned\"\n-\t\t\t\" constant value to negative integer\");\n+\t    {\n+\t      if (produce_warns)\n+\t\twarning_at (loc, OPT_Wsign_conversion, \"negative integer\"\n+\t\t\t    \" implicitly converted to unsigned type\");\n+\t    }\n+\t  else if (!TYPE_UNSIGNED (type) && TYPE_UNSIGNED (expr_type))\n+\t    {\n+\t      if (produce_warns)\n+\t\twarning_at (loc, OPT_Wsign_conversion, \"conversion of unsigned\"\n+\t\t\t    \" constant value to negative integer\");\n+\t    }\n \t  else\n \t    give_warning = true;\n-        }\n+\t}\n       else if (TREE_CODE (type) == REAL_TYPE)\n-        {\n-          /* Warn for an integer constant that does not fit into real type.  */\n-          if (TREE_CODE (expr_type) == INTEGER_TYPE)\n-            {\n-              REAL_VALUE_TYPE a = real_value_from_int_cst (0, expr);\n-              if (!exact_real_truncate (TYPE_MODE (type), &a))\n-                give_warning = true;\n-            }\n-          /* Warn for a real constant that does not fit into a smaller\n-             real type.  */\n-          else if (TREE_CODE (expr_type) == REAL_TYPE\n-                   && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n-            {\n-              REAL_VALUE_TYPE a = TREE_REAL_CST (expr);\n-              if (!exact_real_truncate (TYPE_MODE (type), &a))\n-                give_warning = true;\n-            }\n-        }\n-\n-      if (give_warning)\n-        warning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT alters %qT constant value\",\n-\t\t    type, expr_type);\n-\n-      return;\n-\n-    case COND_EXPR:\n-      {\n-\t/* In case of COND_EXPR, if both operands are constants or\n-\t   COND_EXPR, then we do not care about the type of COND_EXPR,\n-\t   only about the conversion of each operand.  */\n-\ttree op1 = TREE_OPERAND (expr, 1);\n-\ttree op2 = TREE_OPERAND (expr, 2);\n-\n-\tif ((TREE_CODE (op1) == REAL_CST || TREE_CODE (op1) == INTEGER_CST\n-\t     || TREE_CODE (op1) == COND_EXPR)\n-\t    && (TREE_CODE (op2) == REAL_CST || TREE_CODE (op2) == INTEGER_CST\n-\t\t|| TREE_CODE (op2) == COND_EXPR))\n-\t  {\n-\t    conversion_warning (type, op1);\n-\t    conversion_warning (type, op2);\n-\t    return;\n-\t  }\n-\t/* Fall through.  */\n-      }\n-\n-    default: /* 'expr' is not a constant.  */\n-\n+\t{\n+\t  /* Warn for an integer constant that does not fit into real type.  */\n+\t  if (TREE_CODE (expr_type) == INTEGER_TYPE)\n+\t    {\n+\t      REAL_VALUE_TYPE a = real_value_from_int_cst (0, expr);\n+\t      if (!exact_real_truncate (TYPE_MODE (type), &a))\n+\t\tgive_warning = true;\n+\t    }\n+\t  /* Warn for a real constant that does not fit into a smaller\n+\t     real type.  */\n+\t  else if (TREE_CODE (expr_type) == REAL_TYPE\n+\t\t   && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n+\t    {\n+\t      REAL_VALUE_TYPE a = TREE_REAL_CST (expr);\n+\t      if (!exact_real_truncate (TYPE_MODE (type), &a))\n+\t\tgive_warning = true;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n       /* Warn for real types converted to integer types.  */\n       if (TREE_CODE (expr_type) == REAL_TYPE\n-          && TREE_CODE (type) == INTEGER_TYPE)\n-        give_warning = true;\n+\t  && TREE_CODE (type) == INTEGER_TYPE)\n+\tgive_warning = true;\n \n       else if (TREE_CODE (expr_type) == INTEGER_TYPE\n-               && TREE_CODE (type) == INTEGER_TYPE)\n-        {\n+\t       && TREE_CODE (type) == INTEGER_TYPE)\n+\t{\n \t  /* Don't warn about unsigned char y = 0xff, x = (int) y;  */\n \t  expr = get_unwidened (expr, 0);\n \t  expr_type = TREE_TYPE (expr);\n \n \t  /* Don't warn for short y; short x = ((int)y & 0xff);  */\n \t  if (TREE_CODE (expr) == BIT_AND_EXPR\n-\t\t|| TREE_CODE (expr) == BIT_IOR_EXPR\n+\t      || TREE_CODE (expr) == BIT_IOR_EXPR\n \t      || TREE_CODE (expr) == BIT_XOR_EXPR)\n \t    {\n \t      /* If both args were extended from a shortest type,\n@@ -2085,7 +2034,7 @@ conversion_warning (tree type, tree expr)\n \t\t\t  && int_fits_type_p (op1, c_common_signed_type (type))\n \t\t\t  && int_fits_type_p (op1,\n \t\t\t\t\t      c_common_unsigned_type (type))))\n-\t\t    return;\n+\t\t    return false;\n \t\t  /* If constant is unsigned and fits in the target\n \t\t     type, then the result will also fit.  */\n \t\t  else if ((TREE_CODE (op0) == INTEGER_CST\n@@ -2094,58 +2043,136 @@ conversion_warning (tree type, tree expr)\n \t\t\t   || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t       && unsigned1\n \t\t\t       && int_fits_type_p (op1, type)))\n-\t\t    return;\n+\t\t    return false;\n \t\t}\n \t    }\n-          /* Warn for integer types converted to smaller integer types.  */\n+\t  /* Warn for integer types converted to smaller integer types.  */\n \t  if (TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n \t    give_warning = true;\n \n \t  /* When they are the same width but different signedness,\n \t     then the value may change.  */\n-\t  else if ((TYPE_PRECISION (type) == TYPE_PRECISION (expr_type)\n+\t  else if (((TYPE_PRECISION (type) == TYPE_PRECISION (expr_type)\n \t\t    && TYPE_UNSIGNED (expr_type) != TYPE_UNSIGNED (type))\n \t\t   /* Even when converted to a bigger type, if the type is\n \t\t      unsigned but expr is signed, then negative values\n \t\t      will be changed.  */\n-\t\t   || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)))\n+\t\t    || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)))\n+\t\t   && produce_warns)\n \t    warning_at (loc, OPT_Wsign_conversion, \"conversion to %qT from %qT \"\n \t\t\t\"may change the sign of the result\",\n \t\t\ttype, expr_type);\n-        }\n+\t}\n \n       /* Warn for integer types converted to real types if and only if\n-         all the range of values of the integer type cannot be\n-         represented by the real type.  */\n+\t all the range of values of the integer type cannot be\n+\t represented by the real type.  */\n       else if (TREE_CODE (expr_type) == INTEGER_TYPE\n-               && TREE_CODE (type) == REAL_TYPE)\n-        {\n+\t       && TREE_CODE (type) == REAL_TYPE)\n+\t{\n \t  tree type_low_bound, type_high_bound;\n-          REAL_VALUE_TYPE real_low_bound, real_high_bound;\n+\t  REAL_VALUE_TYPE real_low_bound, real_high_bound;\n \n \t  /* Don't warn about char y = 0xff; float x = (int) y;  */\n \t  expr = get_unwidened (expr, 0);\n \t  expr_type = TREE_TYPE (expr);\n \n-          type_low_bound = TYPE_MIN_VALUE (expr_type);\n-          type_high_bound = TYPE_MAX_VALUE (expr_type);\n-          real_low_bound = real_value_from_int_cst (0, type_low_bound);\n-          real_high_bound = real_value_from_int_cst (0, type_high_bound);\n+\t  type_low_bound = TYPE_MIN_VALUE (expr_type);\n+\t  type_high_bound = TYPE_MAX_VALUE (expr_type);\n+\t  real_low_bound = real_value_from_int_cst (0, type_low_bound);\n+\t  real_high_bound = real_value_from_int_cst (0, type_high_bound);\n \n-          if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n-              || !exact_real_truncate (TYPE_MODE (type), &real_high_bound))\n-            give_warning = true;\n-        }\n+\t  if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n+\t      || !exact_real_truncate (TYPE_MODE (type), &real_high_bound))\n+\t    give_warning = true;\n+\t}\n \n       /* Warn for real types converted to smaller real types.  */\n       else if (TREE_CODE (expr_type) == REAL_TYPE\n-               && TREE_CODE (type) == REAL_TYPE\n-               && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n-        give_warning = true;\n+\t       && TREE_CODE (type) == REAL_TYPE\n+\t       && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n+\tgive_warning = true;\n+    }\n \n+  return give_warning;\n+}\n+\n+/* Warns if the conversion of EXPR to TYPE may alter a value.\n+   This is a helper function for warnings_for_convert_and_check.  */\n \n-      if (give_warning)\n-        warning_at (loc, OPT_Wconversion,\n+static void\n+conversion_warning (tree type, tree expr)\n+{\n+  int i;\n+  const int expr_num_operands = TREE_OPERAND_LENGTH (expr);\n+  tree expr_type = TREE_TYPE (expr);\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n+\n+  if (!warn_conversion && !warn_sign_conversion)\n+    return;\n+\n+  /* If any operand is artificial, then this expression was generated\n+     by the compiler and we do not warn.  */\n+  for (i = 0; i < expr_num_operands; i++)\n+    {\n+      tree op = TREE_OPERAND (expr, i);\n+      if (op && DECL_P (op) && DECL_ARTIFICIAL (op))\n+\treturn;\n+    }\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case TRUTH_NOT_EXPR:\n+      /* Conversion from boolean to a signed:1 bit-field (which only\n+\t can hold the values 0 and -1) doesn't lose information - but\n+\t it does change the value.  */\n+      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT from boolean expression\", type);\n+      return;\n+\n+    case REAL_CST:\n+    case INTEGER_CST:\n+      if (unsafe_conversion_p (type, expr, true))\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT alters %qT constant value\",\n+\t\t    type, expr_type);\n+      return;\n+\n+    case COND_EXPR:\n+      {\n+\t/* In case of COND_EXPR, if both operands are constants or\n+\t   COND_EXPR, then we do not care about the type of COND_EXPR,\n+\t   only about the conversion of each operand.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\n+\tif ((TREE_CODE (op1) == REAL_CST || TREE_CODE (op1) == INTEGER_CST\n+\t     || TREE_CODE (op1) == COND_EXPR)\n+\t    && (TREE_CODE (op2) == REAL_CST || TREE_CODE (op2) == INTEGER_CST\n+\t\t|| TREE_CODE (op2) == COND_EXPR))\n+\t  {\n+\t    conversion_warning (type, op1);\n+\t    conversion_warning (type, op2);\n+\t    return;\n+\t  }\n+\t/* Fall through.  */\n+      }\n+\n+    default: /* 'expr' is not a constant.  */\n+      if (unsafe_conversion_p (type, expr, true))\n+\twarning_at (loc, OPT_Wconversion,\n \t\t    \"conversion to %qT from %qT may alter its value\",\n \t\t    type, expr_type);\n     }"}, {"sha": "6905737c28e4069fced1fd0ecede9d4d1fb088be", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -742,6 +742,7 @@ extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern void c_common_init_ts (void);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);\n+extern bool unsafe_conversion_p (tree, tree, bool);\n extern bool decl_with_nonnull_addr_p (const_tree);\n extern tree c_fully_fold (tree, bool, bool *);\n extern tree decl_constant_value_for_optimization (tree);"}, {"sha": "7577f4f830fb88e7c81cc3fd6599e9f3046d27df", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 139, "deletions": 1, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -51,6 +51,14 @@ enum impl_conv {\n   ic_return\n };\n \n+/* Possibe cases of scalar_to_vector conversion.  */\n+enum stv_conv {\n+  stv_error,        /* Error occured.  */\n+  stv_nothing,      /* Nothing happened.  */\n+  stv_firstarg,     /* First argument must be expanded.  */\n+  stv_secondarg     /* Second argument must be expanded.  */\n+};\n+\n /* The level of nesting inside \"__alignof__\".  */\n int in_alignof;\n \n@@ -9323,6 +9331,88 @@ push_cleanup (tree decl, tree cleanup, bool eh_only)\n   TREE_OPERAND (stmt, 0) = list;\n   STATEMENT_LIST_STMT_EXPR (list) = stmt_expr;\n }\n+\n+/* Convert scalar to vector for the range of operations.  */\n+static enum stv_conv\n+scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n+{\n+  tree type0 = TREE_TYPE (op0);\n+  tree type1 = TREE_TYPE (op1);\n+  bool integer_only_op = false;\n+  enum stv_conv ret = stv_firstarg;\n+  \n+  gcc_assert (TREE_CODE (type0) == VECTOR_TYPE \n+\t      || TREE_CODE (type1) == VECTOR_TYPE);\n+  switch (code)\n+    {\n+      case RSHIFT_EXPR:\n+      case LSHIFT_EXPR:\n+\tif (TREE_CODE (type0) == INTEGER_TYPE\n+\t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)\n+\t  {\n+\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t      {\n+\t\terror_at (loc, \"conversion of scalar to vector \"\n+\t\t\t       \"involves truncation\");\n+\t\treturn stv_error;\n+\t      }\n+\t    else\n+\t      return stv_firstarg;\n+\t  }\n+\tbreak;\n+\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+      case BIT_AND_EXPR:\n+\tinteger_only_op = true;\n+\t/* ... fall through ...  */\n+      \n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+      case MULT_EXPR:\n+      case TRUNC_DIV_EXPR:\n+      case TRUNC_MOD_EXPR:\n+      case RDIV_EXPR:\n+\tif (TREE_CODE (type0) == VECTOR_TYPE)\n+\t  {\n+\t    tree tmp;\n+\t    ret = stv_secondarg;\n+\t    /* Swap TYPE0 with TYPE1 and OP0 with OP1  */\n+\t    tmp = type0; type0 = type1; type1 = tmp;\n+\t    tmp = op0; op0 = op1; op1 = tmp;\n+\t  }\n+\n+\tif (TREE_CODE (type0) == INTEGER_TYPE\n+\t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE) \n+\t  {\n+\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t      {\n+\t\terror_at (loc, \"conversion of scalar to vector \"\n+\t\t\t       \"involves truncation\");\n+\t\treturn stv_error;\n+\t      }\n+\t    return ret;\n+\t  }\n+\telse if (!integer_only_op\n+\t\t    /* Allow integer --> real conversion if safe.  */\n+\t\t && (TREE_CODE (type0) == REAL_TYPE \n+\t\t     || TREE_CODE (type0) == INTEGER_TYPE)\n+\t\t && SCALAR_FLOAT_TYPE_P (TREE_TYPE (type1)))\n+\t  {\n+\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t      {\n+\t\terror_at (loc, \"conversion of scalar to vector \"\n+\t\t\t       \"involves truncation\");\n+\t\treturn stv_error;\n+\t      }\n+\t    return ret;\n+\t  }\n+      default:\n+\tbreak;\n+    }\n+ \n+  return stv_nothing;\n+}\n \f\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n@@ -9434,7 +9524,10 @@ build_binary_op (location_t location, enum tree_code code,\n   else\n     int_const = int_const_or_overflow = false;\n \n-  if (convert_p)\n+  /* Do not apply default conversion in mixed vector/scalar expression.  */\n+  if (convert_p \n+      && !((TREE_CODE (TREE_TYPE (op0)) == VECTOR_TYPE) \n+\t   != (TREE_CODE (TREE_TYPE (op1)) == VECTOR_TYPE)))\n     {\n       op0 = default_conversion (op0);\n       op1 = default_conversion (op1);\n@@ -9506,6 +9599,51 @@ build_binary_op (location_t location, enum tree_code code,\n \n   objc_ok = objc_compare_types (type0, type1, -3, NULL_TREE);\n \n+  /* In case when one of the operands of the binary operation is\n+     a vector and another is a scalar -- convert scalar to vector.  */\n+  if ((code0 == VECTOR_TYPE) != (code1 == VECTOR_TYPE))\n+    {\n+      enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1);\n+      \n+      switch (convert_flag)\n+\t{\n+\t  case stv_error:\n+\t    return error_mark_node;\n+\t  case stv_firstarg:\n+\t    {\n+              bool maybe_const = true;\n+              tree sc;\n+              sc = c_fully_fold (op0, false, &maybe_const);\n+              sc = save_expr (sc);\n+              sc = convert (TREE_TYPE (type1), sc);\n+              op0 = build_vector_from_val (type1, sc);\n+              if (!maybe_const)\n+                op0 = c_wrap_maybe_const (op0, true);\n+              orig_type0 = type0 = TREE_TYPE (op0);\n+              code0 = TREE_CODE (type0);\n+              converted = 1;\n+              break;\n+\t    }\n+\t  case stv_secondarg:\n+\t    {\n+\t      bool maybe_const = true;\n+\t      tree sc;\n+\t      sc = c_fully_fold (op1, false, &maybe_const);\n+\t      sc = save_expr (sc);\n+\t      sc = convert (TREE_TYPE (type0), sc);\n+\t      op1 = build_vector_from_val (type0, sc);\n+\t      if (!maybe_const)\n+\t\top0 = c_wrap_maybe_const (op1, true);\n+\t      orig_type1 = type1 = TREE_TYPE (op1);\n+\t      code1 = TREE_CODE (type1);\n+\t      converted = 1;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    break;\n+\t}\n+    }\n+\n   switch (code)\n     {\n     case PLUS_EXPR:"}, {"sha": "49a81253593af00ecc77cdb460dde031cb2c9a0d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -6526,18 +6526,25 @@ In C it is possible to use shifting operators @code{<<}, @code{>>} on\n integer-type vectors. The operation is defined as following: @code{@{a0,\n a1, @dots{}, an@} >> @{b0, b1, @dots{}, bn@} == @{a0 >> b0, a1 >> b1,\n @dots{}, an >> bn@}}@. Vector operands must have the same number of\n-elements.  Additionally second operands can be a scalar integer in which\n-case the scalar is converted to the type used by the vector operand (with\n-possible truncation) and each element of this new vector is the scalar's\n-value.\n+elements. \n+\n+For the convenience in C it is allowed to use a binary vector operation\n+where one operand is a scalar. In that case the compiler will transform\n+the scalar operand into a vector where each element is the scalar from\n+the operation. The transformation will happen only if the scalar could be\n+safely converted to the vector-element type.\n Consider the following code.\n \n @smallexample\n typedef int v4si __attribute__ ((vector_size (16)));\n \n-v4si a, b;\n+v4si a, b, c;\n+long l;\n+\n+a = b + 1;    /* a = b + @{1,1,1,1@}; */\n+a = 2 * b;    /* a = @{2,2,2,2@} * b; */\n \n-b = a >> 1;     /* b = a >> @{1,1,1,1@}; */\n+a = l + a;    /* Error, cannot convert long to int. */\n @end smallexample\n \n In C vectors can be subscripted as if the vector were an array with"}, {"sha": "b4b76d5a8a6f4312bf65075173d2a117a8704c09", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -1,3 +1,11 @@\n+2011-08-10  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n+\n+\t* gcc.c-torture/execute/scal-to-vec1.c: New test.\n+\t* gcc.c-torture/execute/scal-to-vec2.c: New test.\n+\t* gcc.c-torture/execute/scal-to-vec3.c: New test.\n+\t* gcc.dg/scal-to-vec1.c: New test.\n+\t* gcc.dg/scal-to-vec2.c: New test.\n+\n 2011-08-09  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/vrp57.c: Disable CCP."}, {"sha": "e2b43f4263530a56736cc2c4eb5630cb294410e9", "filename": "gcc/testsuite/gcc.c-torture/execute/scal-to-vec1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec1.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -0,0 +1,85 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*((type *) &(vec) + idx))\n+\n+#define operl(a, b, op) (a op b)\n+#define operr(a, b, op) (b op a)\n+\n+#define check(type, count, vec0, vec1, num, op, lr) \\\n+do {\\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) {\\\n+        if (vidx (type, vec1, __i) != oper##lr (num, vidx (type, vec0, __i), op)) \\\n+            __builtin_abort (); \\\n+    }\\\n+} while (0)\n+\n+#define veccompare(type, count, v0, v1) \\\n+do {\\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+#define fvec_2 (vector(4, float)){2., 2., 2., 2.}\n+#define dvec_2 (vector(2, double)){2., 2.}\n+\n+\n+    vector(8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector(8, short) v1;\n+\n+    vector(4, float) f0 = {1., 2., 3., 4.};\n+    vector(4, float) f1, f2;\n+\n+    vector(2, double) d0 = {1., 2.};\n+    vector(2, double) d1, d2;\n+\n+\n+\n+    v1 = 2 + v0;   check (short, 8, v0, v1, 2, +, l);\n+    v1 = 2 - v0;   check (short, 8, v0, v1, 2, -, l);\n+    v1 = 2 * v0;   check (short, 8, v0, v1, 2, *, l);\n+    v1 = 2 / v0;   check (short, 8, v0, v1, 2, /, l);\n+    v1 = 2 % v0;   check (short, 8, v0, v1, 2, %, l);\n+    v1 = 2 ^ v0;   check (short, 8, v0, v1, 2, ^, l);\n+    v1 = 2 & v0;   check (short, 8, v0, v1, 2, &, l);\n+    v1 = 2 | v0;   check (short, 8, v0, v1, 2, |, l);\n+    v1 = 2 << v0;   check (short, 8, v0, v1, 2, <<, l);\n+    v1 = 2 >> v0;   check (short, 8, v0, v1, 2, >>, l);\n+\n+    v1 = v0 + 2;   check (short, 8, v0, v1, 2, +, r);\n+    v1 = v0 - 2;   check (short, 8, v0, v1, 2, -, r);\n+    v1 = v0 * 2;   check (short, 8, v0, v1, 2, *, r);\n+    v1 = v0 / 2;   check (short, 8, v0, v1, 2, /, r);\n+    v1 = v0 % 2;   check (short, 8, v0, v1, 2, %, r);\n+    v1 = v0 ^ 2;   check (short, 8, v0, v1, 2, ^, r);\n+    v1 = v0 & 2;   check (short, 8, v0, v1, 2, &, r);\n+    v1 = v0 | 2;   check (short, 8, v0, v1, 2, |, r);\n+\n+    f1 = 2. + f0;  f2 = fvec_2 + f0; veccompare (float, 4, f1, f2);\n+    f1 = 2. - f0;  f2 = fvec_2 - f0; veccompare (float, 4, f1, f2);\n+    f1 = 2. * f0;  f2 = fvec_2 * f0; veccompare (float, 4, f1, f2);\n+    f1 = 2. / f0;  f2 = fvec_2 / f0; veccompare (float, 4, f1, f2);\n+\n+    f1 = f0 + 2.;  f2 = f0 + fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 - 2.;  f2 = f0 - fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 * 2.;  f2 = f0 * fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 / 2.;  f2 = f0 / fvec_2; veccompare (float, 4, f1, f2);\n+\n+    d1 = 2. + d0;  d2 = dvec_2 + d0; veccompare (double, 2, d1, d2);\n+    d1 = 2. - d0;  d2 = dvec_2 - d0; veccompare (double, 2, d1, d2);\n+    d1 = 2. * d0;  d2 = dvec_2 * d0; veccompare (double, 2, d1, d2);\n+    d1 = 2. / d0;  d2 = dvec_2 / d0; veccompare (double, 2, d1, d2);\n+\n+    d1 = d0 + 2.;  d2 = d0 + dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 - 2.;  d2 = d0 - dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 * 2.;  d2 = d0 * dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 / 2.;  d2 = d0 / dvec_2; veccompare (double, 2, d1, d2);\n+\n+    return 0;\n+}"}, {"sha": "0a5037e333ea9c20ec7ea615f721fa56c2cebae7", "filename": "gcc/testsuite/gcc.c-torture/execute/scal-to-vec2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec2.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -0,0 +1,62 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*((type *) &(vec) + idx))\n+\n+#define operl(a, b, op) (a op b)\n+#define operr(a, b, op) (b op a)\n+\n+#define check(type, count, vec0, vec1, num, op, lr) \\\n+do {\\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) {\\\n+        if (vidx (type, vec1, __i) != oper##lr (num, vidx (type, vec0, __i), op)) \\\n+            __builtin_abort (); \\\n+    }\\\n+} while (0)\n+\n+#define veccompare(type, count, v0, v1) \\\n+do {\\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+\n+long __attribute__ ((noinline)) vlng () {   return (long)42; }\n+int  __attribute__ ((noinline)) vint () {   return (int) 43; }\n+short __attribute__ ((noinline)) vsrt () {   return (short)42; }\n+char __attribute__ ((noinline)) vchr () {    return (char)42; }\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector(16, char) c0 = {argc, 1,2,3,4,5,6,7, argc, 1,2,3,4,5,6,7};\n+    vector(16, char) c1;\n+    \n+    vector(8, short) s0 = {argc, 1,2,3,4,5,6,7};\n+    vector(8, short) s1;\n+\n+    vector(4, int) i0 = {argc, 1, 2, 3};\n+    vector(4, int) i1;\n+\n+    vector(2, long) l0 = {argc, 1};\n+    vector(2, long) l1;\n+\n+    c1 = vchr() + c0; check (char, 16, c0, c1, vchr(), +, l);\n+    \n+    s1 = vsrt() + s0; check (short, 8, s0, s1, vsrt(), +, l);\n+    s1 = vchr() + s0; check (short, 8, s0, s1, vchr(), +, l);\n+\n+    i1 = vint() * i0; check (int, 4, i0, i1, vint(), *, l);\n+    i1 = vsrt() * i0; check (int, 4, i0, i1, vsrt(), *, l);\n+    i1 = vchr() * i0; check (int, 4, i0, i1, vchr(), *, l);\n+\n+    l1 = vlng() * l0; check (long, 2, l0, l1, vlng(), *, l);\n+    l1 = vint() * l0; check (long, 2, l0, l1, vint(), *, l);\n+    l1 = vsrt() * l0; check (long, 2, l0, l1, vsrt(), *, l);\n+    l1 = vchr() * l0; check (long, 2, l0, l1, vchr(), *, l);\n+\n+    return 0;\n+}"}, {"sha": "76fc245c6ea5e1bf67491ae47e1868fd6ec0389d", "filename": "gcc/testsuite/gcc.c-torture/execute/scal-to-vec3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fscal-to-vec3.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -0,0 +1,48 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*((type *) &(vec) + idx))\n+\n+#define veccompare(type, count, v0, v1) \\\n+do {\\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+#define fvec_2 (vector(4, float)){2., 2., 2., 2.}\n+#define dvec_2 (vector(2, double)){2., 2.}\n+\n+    vector(4, float) f0 = {1., 2., 3., 4.};\n+    vector(4, float) f1, f2;\n+\n+    vector(2, double) d0 = {1., 2.};\n+    vector(2, double) d1, d2;\n+\n+\n+    f1 = 2 + f0;  f2 = fvec_2 + f0; veccompare (float, 4, f1, f2);\n+    f1 = 2 - f0;  f2 = fvec_2 - f0; veccompare (float, 4, f1, f2);\n+    f1 = 2 * f0;  f2 = fvec_2 * f0; veccompare (float, 4, f1, f2);\n+    f1 = 2 / f0;  f2 = fvec_2 / f0; veccompare (float, 4, f1, f2);\n+\n+    f1 = f0 + 2;  f2 = f0 + fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 - 2;  f2 = f0 - fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 * 2;  f2 = f0 * fvec_2; veccompare (float, 4, f1, f2);\n+    f1 = f0 / 2;  f2 = f0 / fvec_2; veccompare (float, 4, f1, f2);\n+\n+    d1 = 2 + d0;  d2 = dvec_2 + d0; veccompare (double, 2, d1, d2);\n+    d1 = 2 - d0;  d2 = dvec_2 - d0; veccompare (double, 2, d1, d2);\n+    d1 = 2 * d0;  d2 = dvec_2 * d0; veccompare (double, 2, d1, d2);\n+    d1 = 2 / d0;  d2 = dvec_2 / d0; veccompare (double, 2, d1, d2);\n+\n+    d1 = d0 + 2;  d2 = d0 + dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 - 2;  d2 = d0 - dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 * 2;  d2 = d0 * dvec_2; veccompare (double, 2, d1, d2);\n+    d1 = d0 / 2;  d2 = d0 / dvec_2; veccompare (double, 2, d1, d2);\n+\n+    return 0;\n+}"}, {"sha": "503426dbb292692c16cd8bc328ac7b5c332cd3c5", "filename": "gcc/testsuite/gcc.dg/scal-to-vec1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec1.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wno-long-long\" } */\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*((type *) &(vec) + idx))\n+\n+\n+extern float sfl;\n+extern int   sint;\n+extern long long sll;\n+\n+int main (int argc, char *argv[]) {\n+    vector(8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector(8, short) v1;\n+\n+    vector(4, float) f0 = {1., 2., 3., 4.};\n+    vector(4, float) f1, f2;\n+\n+    vector(4, int) i0 = {1,2,3,4};\n+    vector(4, int) i1, i2;\n+\n+    \n+    int     i = 12;\n+    double  d = 3.;\n+\n+    v1 = i + v0;        /* { dg-error \"conversion of scalar to vector\" } */\n+    v1 = 99999 + v0;    /* { dg-error \"conversion of scalar to vector\" } */\n+\n+    f1 = d + f0;        /* { dg-error \"conversion of scalar to vector\" } */\n+    f1 = 1.3 + f0;      /* { dg-error \"conversion of scalar to vector\" } */\n+    f1 = sll + f0;      /* { dg-error \"conversion of scalar to vector\" } */\n+    f1 = ((int)998769576) + f0; /* { dg-error \"conversion of scalar to vector\" } */\n+\n+    /* convert.c should take care of this.  */\n+    i1 = sfl + i0;      /* { dg-error \"can't convert value to a vector\" } */\n+    i1 = 1.5 + i0;      /* { dg-error \"can't convert value to a vector\" } */\n+    v1 = d + v0;        /* { dg-error \"can't convert value to a vector\" } */\n+\n+    return 0;\n+}"}, {"sha": "1354aa55b3d3fde8d79a47104cb6de2bbd5ec355", "filename": "gcc/testsuite/gcc.dg/scal-to-vec2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3a99ae913c732f015b0dcfecb85d3236cc142f/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fscal-to-vec2.c?ref=0e3a99ae913c732f015b0dcfecb85d3236cc142f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */   \n+\n+/* Test for C_MAYBE_CONST are folded correctly when \n+   expanding an expression to vector.  */\n+\n+int \t\t\tf(void);\n+unsigned int \t\tg(void);\n+unsigned int \t\th;\n+\n+typedef unsigned int vec __attribute__((vector_size(16)));\n+\n+vec i;\n+\n+\n+vec fv1(void) { return i + (h ? f() : g()); }\n+vec fv2(void) { return (h ? f() : g()) + i; }"}]}