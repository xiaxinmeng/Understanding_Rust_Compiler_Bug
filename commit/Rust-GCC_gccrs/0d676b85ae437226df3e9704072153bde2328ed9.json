{"sha": "0d676b85ae437226df3e9704072153bde2328ed9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2NzZiODVhZTQzNzIyNmRmM2U5NzA0MDcyMTUzYmRlMjMyOGVkOQ==", "commit": {"author": {"name": "Christopher Faylor", "email": "cgf@timesys.com", "date": "2005-09-15T00:46:20Z"}, "committer": {"name": "Christopher Faylor", "email": "cgf@gcc.gnu.org", "date": "2005-09-15T00:46:20Z"}, "message": "pex-win32.c: Include \"windows.h\".\n\n* pex-win32.c: Include \"windows.h\".\n(backslashify): New function.\n(fix_argv): Use backslashify to convert path to windows format.  Allocate one\nmore place in new argv for potential executable from '#!' parsing.\n(tack_on_executable): New function.  Conditional on USE_MINGW_MSYS\n(openkey): Ditto.\n(mingw_rootify): Ditto.\n(msys_rootify): Ditto.\n(spawn_script): New function.\n(pex_win32_exec_child): Save translated argv in newargv.  Pass to spawn_script\nif spawnv* fails.\n(main): New function.  Conditional on MAIN.  Useful for testing.\n\nFrom-SVN: r104292", "tree": {"sha": "978bd36a50357fad8d1572b2c9bf9323f5c70dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/978bd36a50357fad8d1572b2c9bf9323f5c70dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d676b85ae437226df3e9704072153bde2328ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d676b85ae437226df3e9704072153bde2328ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d676b85ae437226df3e9704072153bde2328ed9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d676b85ae437226df3e9704072153bde2328ed9/comments", "author": null, "committer": null, "parents": [{"sha": "62ff44d425edc510aa387fd788618cb275bb4c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ff44d425edc510aa387fd788618cb275bb4c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ff44d425edc510aa387fd788618cb275bb4c05"}], "stats": {"total": 321, "additions": 307, "deletions": 14}, "files": [{"sha": "4cf1a404b117c4df668a3097c9f674a60a20dd58", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d676b85ae437226df3e9704072153bde2328ed9/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d676b85ae437226df3e9704072153bde2328ed9/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=0d676b85ae437226df3e9704072153bde2328ed9", "patch": "@@ -1,3 +1,19 @@\n+2005-09-14  Christopher Faylor  <cgf@timesys.com>\n+\n+\t* pex-win32.c: Include \"windows.h\".\n+\t(backslashify): New function.\n+\t(fix_argv): Use backslashify to convert path to windows format.\n+\tAllocate one more place in new argv for potential executable from '#!'\n+\tparsing.\n+\t(tack_on_executable): New function.  Conditional on USE_MINGW_MSYS\n+\t(openkey): Ditto.\n+\t(mingw_rootify): Ditto.\n+\t(msys_rootify): Ditto.\n+\t(spawn_script): New function.\n+\t(pex_win32_exec_child): Save translated argv in newargv.  Pass to\n+\tspawn_script if spawnv* fails.\n+\t(main): New function.  Conditional on MAIN.  Useful for testing.\n+\n 2005-08-17  Mark Kettenis  <kettenis@gnu.org>\n \n \t* floatformat.c (floatformat_always_valid): Change type of last"}, {"sha": "ed45e5b8bb83a2aa1223873b250c6782498c2bea", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 291, "deletions": 14, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d676b85ae437226df3e9704072153bde2328ed9/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d676b85ae437226df3e9704072153bde2328ed9/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=0d676b85ae437226df3e9704072153bde2328ed9", "patch": "@@ -21,6 +21,8 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"pex-common.h\"\n \n+#include <windows.h>\n+\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #endif\n@@ -53,6 +55,23 @@ Boston, MA 02110-1301, USA.  */\n #  define WAIT_GRANDCHILD\t1\n #endif\n \n+#define MINGW_NAME \"Minimalist GNU for Windows\"\n+#define MINGW_NAME_LEN (sizeof(MINGW_NAME) - 1)\n+\n+/* Ensure that the executable pathname uses Win32 backslashes. This\n+   is not necessary on NT, but on W9x, forward slashes causes\n+   failure of spawn* and exec* functions (and probably any function\n+   that calls CreateProcess) *iff* the executable pathname (argv[0])\n+   is a quoted string.  And quoting is necessary in case a pathname\n+   contains embedded white space.  You can't win.  */\n+static void\n+backslashify (char *s)\n+{\n+  while ((s = strchr (s, '/')) != NULL)\n+    *s = '\\\\';\n+  return;\n+}\n+\n /* This is a kludge to get around the Microsoft C spawn functions' propensity\n    to remove the outermost set of double quotes from all arguments.  */\n \n@@ -79,20 +98,16 @@ fix_argv (char * const *argvec)\n \n   for (i = 0; argvec[i] != NULL; i++)\n     ;\n-  argv = XNEWVEC (char *, i + 1);\n+  argv = XNEWVEC (char *, i + 2);\n+\n+  argv++;\t/* Leave space at the beginning of argv\n+\t\t   for potential #! handling */\n+\n   for (i = 0; argvec[i] != NULL; i++)\n     argv[i] = xstrdup (argvec[i]);\n   argv[i] = NULL;\n \n-  /* Ensure that the executable pathname uses Win32 backslashes. This\n-     is not necessary on NT, but on W9x, forward slashes causes\n-     failure of spawn* and exec* functions (and probably any function\n-     that calls CreateProcess) *iff* the executable pathname (argv[0])\n-     is a quoted string.  And quoting is necessary in case a pathname\n-     contains embedded white space.  You can't win.  */\n-  for (command0 = argv[0]; *command0 != '\\0'; command0++)\n-    if (*command0 == '/')\n-      *command0 = '\\\\';\n+  backslashify (argv[0]);\n \n   for (i = 1; argv[i] != 0; i++)\n     {\n@@ -137,11 +152,11 @@ fix_argv (char * const *argvec)\n \t     space ends in a backslash (such as in the case of -iprefix arg\n \t     passed to cpp). The resulting quoted strings gets misinterpreted\n \t     by the command interpreter -- it thinks that the ending quote\n-\t     is escaped by the trailing backslash and things get confused. \n+\t     is escaped by the trailing backslash and things get confused.\n \t     We handle this case by escaping the trailing backslash, provided\n \t     it was not escaped in the first place.  */\n-\t  if (len > 1 \n-\t      && argv[i][len-1] == '\\\\' \n+\t  if (len > 1\n+\t      && argv[i][len-1] == '\\\\'\n \t      && argv[i][len-2] != '\\\\')\n \t    {\n \t      trailing_backslash = 1;\n@@ -230,6 +245,249 @@ pex_win32_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n   return _close (fd);\n }\n \n+#ifdef USE_MINGW_MSYS\n+static const char *mingw_keys[] = {\"SOFTWARE\", \"Microsoft\", \"Windows\", \"CurrentVersion\", \"Uninstall\", NULL};\n+\n+/* Tack the executable on the end of a (possibly slash terminated) buffer\n+   and convert everything to \\. */\n+static const char *\n+tack_on_executable (char *buf, const char *executable)\n+{\n+  char *p = strchr (buf, '\\0');\n+  if (p > buf && (p[-1] == '\\\\' || p[-1] == '/'))\n+    p[-1] = '\\0';\n+  backslashify (strcat (buf, executable));\n+  return buf;\n+}\n+\n+/* Walk down a registry hierarchy until the end.  Return the key. */\n+static HKEY\n+openkey (HKEY hStart, const char *keys[])\n+{\n+  HKEY hKey, hTmp;\n+  for (hKey = hStart; *keys; keys++)\n+    {\n+      LONG res;\n+      hTmp = hKey;\n+      res = RegOpenKey (hTmp, *keys, &hKey);\n+\n+      if (hTmp != HKEY_LOCAL_MACHINE)\n+\tRegCloseKey (hTmp);\n+\n+      if (res != ERROR_SUCCESS)\n+\treturn NULL;\n+    }\n+  return hKey;\n+}\n+\n+/* Return the \"mingw root\" as derived from the mingw uninstall information. */\n+static const char *\n+mingw_rootify (const char *executable)\n+{\n+  HKEY hKey, hTmp;\n+  DWORD maxlen;\n+  char *namebuf, *foundbuf;\n+  DWORD i;\n+  LONG res;\n+\n+  /* Open the uninstall \"directory\". */\n+  hKey = openkey (HKEY_LOCAL_MACHINE, mingw_keys);\n+\n+  /* Not found. */\n+  if (!hKey)\n+    return executable;\n+\n+  /* Need to enumerate all of the keys here looking for one the most recent\n+     one for MinGW. */\n+  if (RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, &maxlen, NULL, NULL,\n+\t\t       NULL, NULL, NULL, NULL) != ERROR_SUCCESS)\n+    {\n+      RegCloseKey (hKey);\n+      return executable;\n+    }\n+  namebuf = XNEWVEC (char, ++maxlen);\n+  foundbuf = XNEWVEC (char, maxlen);\n+  foundbuf[0] = '\\0';\n+  if (!namebuf || !foundbuf)\n+    {\n+      RegCloseKey (hKey);\n+      if (namebuf)\n+\tfree (namebuf);\n+      if (foundbuf)\n+\tfree (foundbuf);\n+      return executable;\n+    }\n+\n+  /* Look through all of the keys for one that begins with Minimal GNU...\n+     Try to get the latest version by doing a string compare although that\n+     string never really works with version number sorting. */\n+  for (i = 0; RegEnumKey (hKey, i, namebuf, maxlen) == ERROR_SUCCESS; i++)\n+    {\n+      int match = strcasecmp (namebuf, MINGW_NAME);\n+      if (match < 0)\n+\tcontinue;\n+      if (match > 0 && strncasecmp (namebuf, MINGW_NAME, MINGW_NAME_LEN) > 0)\n+\tcontinue;\n+      if (strcasecmp (namebuf, foundbuf) > 0)\n+\tstrcpy (foundbuf, namebuf);\n+    }\n+  free (namebuf);\n+\n+  /* If foundbuf is empty, we didn't find anything.  Punt. */\n+  if (!foundbuf[0])\n+    {\n+      free (foundbuf);\n+      RegCloseKey (hKey);\n+      return executable;\n+    }\n+\n+  /* Open the key that we wanted */\n+  res = RegOpenKey (hKey, foundbuf, &hTmp);\n+  RegCloseKey (hKey);\n+  free (foundbuf);\n+\n+  /* Don't know why this would fail, but you gotta check */\n+  if (res != ERROR_SUCCESS)\n+    return executable;\n+\n+  maxlen = 0;\n+  /* Get the length of the value pointed to by InstallLocation */\n+  if (RegQueryValueEx (hTmp, \"InstallLocation\", 0, NULL, NULL,\n+\t\t       &maxlen) != ERROR_SUCCESS || maxlen == 0)\n+    {\n+      RegCloseKey (hTmp);\n+      return executable;\n+    }\n+\n+  /* Allocate space for the install location */\n+  foundbuf = XNEWVEC (char, maxlen + strlen (executable));\n+  if (!foundbuf)\n+    {\n+      free (foundbuf);\n+      RegCloseKey (hTmp);\n+    }\n+\n+  /* Read the install location into the buffer */\n+  res = RegQueryValueEx (hTmp, \"InstallLocation\", 0, NULL, (LPBYTE) foundbuf,\n+\t\t\t &maxlen);\n+  RegCloseKey (hTmp);\n+  if (res != ERROR_SUCCESS)\n+    {\n+      free (foundbuf);\n+      return executable;\n+    }\n+\n+  /* Concatenate the install location and the executable, turn all slashes\n+     to backslashes, and return that. */\n+  return tack_on_executable (foundbuf, executable);\n+}\n+\n+/* Read the install location of msys from it's installation file and\n+   rootify the executable based on that. */\n+static const char *\n+msys_rootify (const char *executable)\n+{\n+  size_t bufsize = 64;\n+  size_t execlen = strlen (executable) + 1;\n+  char *buf;\n+  DWORD res = 0;\n+  for (;;)\n+    {\n+      buf = XNEWVEC (char, bufsize + execlen);\n+      if (!buf)\n+\tbreak;\n+      res = GetPrivateProfileString (\"InstallSettings\", \"InstallPath\", NULL,\n+\t\t\t\t     buf, bufsize, \"msys.ini\");\n+      if (!res)\n+\tbreak;\n+      if (strlen (buf) < bufsize)\n+\tbreak;\n+      res = 0;\n+      free (buf);\n+      bufsize *= 2;\n+      if (bufsize > 65536)\n+\t{\n+\t  buf = NULL;\n+\t  break;\n+\t}\n+    }\n+\n+  if (res)\n+    return tack_on_executable (buf, executable);\n+\n+  /* failed */\n+  if (buf)\n+    free (buf);\n+  return executable;\n+}\n+#endif\n+\n+static long\n+spawn_script (const char *executable, const char * const * argv)\n+{\n+  int pid = -1;\n+  int save_errno = errno;\n+  int fd = _open (executable, _O_RDONLY);\n+\n+  if (fd >= 0)\n+    {\n+      char buf[MAX_PATH + 5];\n+      int len = _read (fd, buf, sizeof (buf) - 1);\n+      _close (fd);\n+      if (len > 3)\n+\t{\n+\t  char *eol;\n+\t  buf[len] = '\\0';\n+\t  eol = strchr (buf, '\\n');\n+\t  if (eol && strncmp (buf, \"#!\", 2) == 0)\n+\t    {\n+\t      char *executable1;\n+\t      const char ** avhere = (const char **) --argv;\n+\t      do\n+\t\t*eol = '\\0';\n+\t      while (*--eol == '\\r' || *eol == ' ' || *eol == '\\t');\n+\t      for (executable1 = buf + 2; *executable1 == ' ' || *executable1 == '\\t'; executable1++)\n+\t\tcontinue;\n+\n+\t      backslashify (executable1);\n+\t      *avhere = executable1;\n+#ifndef USE_MINGW_MSYS\n+\t      executable = strrchr (executable1, '\\\\') + 1;\n+\t      if (!executable)\n+\t\texecutable = executable1;\n+\t      pid = _spawnvp (_P_NOWAIT, executable, argv);\n+#else\n+\t      if (strchr (executable1, '\\\\') == NULL)\n+\t\tpid = _spawnvp (_P_NOWAIT, executable1, argv);\n+\t      else if (executable1[0] != '\\\\')\n+\t\tpid = _spawnv (_P_NOWAIT, executable1, argv);\n+\t      else\n+\t\t{\n+\t\t  const char *newex = mingw_rootify (executable1);\n+\t\t  *avhere = newex;\n+\t\t  pid = _spawnv (_P_NOWAIT, newex, argv);\n+\t\t  if (executable1 != newex)\n+\t\t    free ((char *) newex);\n+\t\t  if (pid < 0)\n+\t\t    {\n+\t\t      newex = msys_rootify (executable1);\n+\t\t      if (newex != executable1)\n+\t\t\t{\n+\t\t\t  *avhere = newex;\n+\t\t\t  pid = _spawnv (_P_NOWAIT, newex, argv);\n+\t\t\t  free ((char *) newex);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+#endif\n+\t    }\n+\t}\n+    }\n+  if (pid < 0)\n+    errno = save_errno;\n+  return pid;\n+}\n+\n /* Execute a child.  */\n \n static long\n@@ -240,6 +498,7 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n {\n   int org_in, org_out, org_errdes;\n   long pid;\n+  const char * const * newargv;\n \n   org_in = -1;\n   org_out = -1;\n@@ -319,8 +578,12 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n \t}\n     }\n \n+  newargv = fix_argv (argv);\n   pid = (((flags & PEX_SEARCH) != 0 ? _spawnvp : _spawnv)\n-\t (_P_NOWAIT, executable, fix_argv (argv)));\n+\t (_P_NOWAIT, executable, newargv));\n+\n+  if (pid == -1)\n+    pid = spawn_script (executable, newargv);\n \n   if (pid == -1)\n     {\n@@ -438,3 +701,17 @@ pex_win32_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n {\n   return fdopen (fd, binary ? \"rb\" : \"r\");\n }\n+\n+#ifdef MAIN\n+#include <stdio.h>\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  char const *errmsg;\n+  int err;\n+  argv++;\n+  printf (\"%ld\\n\", pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, 0, 1, 2, &errmsg, &err));\n+  exit (0);\n+}\n+#endif"}]}