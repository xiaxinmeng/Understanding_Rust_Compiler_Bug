{"sha": "8901decfba91a9fc7134e8fbb258a14c87335845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwMWRlY2ZiYTkxYTlmYzcxMzRlOGZiYjI1OGExNGM4NzMzNTg0NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-03-14T22:50:19Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-03-14T22:50:19Z"}, "message": "flow.c (fixup_reorder_chain): Avoid double labels in the basic block...\n\n        * flow.c (fixup_reorder_chain): Avoid double labels in the basic block;\n        end of basic block is jump_insn, not barrier; use create_basic_block\n        instead of creating basic block by hand.\n\nFrom-SVN: r32547", "tree": {"sha": "b4ca67eb803618ed866fdce0d67feeab30ba4eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ca67eb803618ed866fdce0d67feeab30ba4eea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8901decfba91a9fc7134e8fbb258a14c87335845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8901decfba91a9fc7134e8fbb258a14c87335845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8901decfba91a9fc7134e8fbb258a14c87335845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8901decfba91a9fc7134e8fbb258a14c87335845/comments", "author": null, "committer": null, "parents": [{"sha": "90a883ae6be11e9916f0907bac3ad1426d6e9c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a883ae6be11e9916f0907bac3ad1426d6e9c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a883ae6be11e9916f0907bac3ad1426d6e9c6d"}], "stats": {"total": 108, "additions": 53, "deletions": 55}, "files": [{"sha": "d82cb85da1198f0d2943deb341183969b7c2f61a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8901decfba91a9fc7134e8fbb258a14c87335845/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8901decfba91a9fc7134e8fbb258a14c87335845/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8901decfba91a9fc7134e8fbb258a14c87335845", "patch": "@@ -1,3 +1,7 @@\n+Wed Feb 23 13:00:06 CET 2000  Jan Hubicka  <jh@suse.cz>\n+        * flow.c (fixup_reorder_chain): Avoid double labels in the basic block;\n+        end of basic block is jump_insn, not barrier; use create_basic_block\n+        instead of creating basic block by hand.\n \n 2000-03-14  Jason Eckhardt  <jle@cygnus.com>\n \t* flow.c (reorder_basic_blocks): Account for barriers when writing"}, {"sha": "9fda6bd2bf1f31c52b3a863e904e5eac1cbcc3c5", "filename": "gcc/flow.c", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8901decfba91a9fc7134e8fbb258a14c87335845/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8901decfba91a9fc7134e8fbb258a14c87335845/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=8901decfba91a9fc7134e8fbb258a14c87335845", "patch": "@@ -7592,75 +7592,69 @@ fixup_reorder_chain ()\n   /* Add jumps and labels to fixup blocks.  */\n   for (i = 0; i < n_basic_blocks - 1; i++)\n     {\n-      if (REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i)))\n+      basic_block bbi = BASIC_BLOCK (i);\n+      if (REORDER_BLOCK_ADD_JUMP (bbi))\n \t{\n-\t  rtx new_label = gen_label_rtx ();\n \t  rtx label_insn, jump_insn, barrier_insn;\n \n-\t  label_insn = emit_label_before (new_label,\n-\t\t\t  REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i))->head);\n-\t  REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i))->head = label_insn;\t \n+\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head)\n+\t      == CODE_LABEL)\n+\t    label_insn  = REORDER_BLOCK_ADD_JUMP (bbi)->head;\n+\t  else\n+\t    {\n+\t      rtx new_label = gen_label_rtx ();\n+\t      label_insn = emit_label_before (new_label,\n+\t\t\t      REORDER_BLOCK_ADD_JUMP (bbi)->head);\n+\t    }\n+\t  REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n \n \t  jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n-\t\t\t\t\t    BASIC_BLOCK (i)->end);\n+\t\t\t\t\t    bbi->end);\n \t  JUMP_LABEL (jump_insn) = label_insn;\n \t  ++LABEL_NUSES (label_insn);\n \t  barrier_insn = emit_barrier_after (jump_insn);\n-\t  if (GET_CODE (BASIC_BLOCK (i)->end) != JUMP_INSN)\n-\t    BASIC_BLOCK (i)->end = barrier_insn;\n+\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n+\t    bbi->end = jump_insn;\n \t  /* Add block for jump.  Typically this is when a then is not\n \t     predicted and we are jumping to the moved then block.  */\n \t  else\t\n \t    {\n-\t      basic_block b;\n+\t      basic_block nb;\n \n-\t      b = (basic_block) obstack_alloc (function_obstack, sizeof (*b));\n \t      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-\t      BASIC_BLOCK (n_basic_blocks - 1) = b;\n-\t      b->index = n_basic_blocks - 1;\n-\t      b->head = emit_note_before (NOTE_INSN_BASIC_BLOCK, jump_insn);\n-\t      NOTE_BASIC_BLOCK (b->head) = b;\n-\t      b->end = barrier_insn;\n-\t      \n-\t      {\n-\t\tbasic_block nb = BASIC_BLOCK (n_basic_blocks - 1);\n-\t\tnb->global_live_at_start\n-\t\t  = OBSTACK_ALLOC_REG_SET (function_obstack);\n-\t\tnb->global_live_at_end\n-\t\t  = OBSTACK_ALLOC_REG_SET (function_obstack);\n-\n-\t\tCOPY_REG_SET (nb->global_live_at_start,\n-\t\t\t      BASIC_BLOCK (i)->global_live_at_start);\n-\t\tCOPY_REG_SET (nb->global_live_at_end,\n-\t\t\t      BASIC_BLOCK (i)->global_live_at_start);\n-\t\tif (BASIC_BLOCK (i)->local_set)\n-\t\t  {\n-\t\t    OBSTACK_ALLOC_REG_SET (function_obstack);\n-\t\t    COPY_REG_SET (nb->local_set, BASIC_BLOCK (i)->local_set);\n-\t\t  }\n-\t\telse\n-\t\t  BASIC_BLOCK (nb->index)->local_set = 0;\n-\n-\t\tnb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-\t\tREORDER_BLOCK_INDEX (BASIC_BLOCK (n_basic_blocks - 1))\n-\t\t  = REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) + 1;\n-\t\t/* Relink to new block.  */\n-\t\tnb->succ = BASIC_BLOCK (i)->succ;\n-\n-\t\tmake_edge (0, BASIC_BLOCK (i), nb, 0);\n-\t\tBASIC_BLOCK (i)->succ->succ_next\n-\t\t  = BASIC_BLOCK (i)->succ->succ_next->succ_next;\n-\t\tnb->succ->succ_next = 0;\n-\t\t/* Fix reorder block index to reflect new block.  */\n-\t\tfor (j = 0; j < n_basic_blocks - 1; j++)\n-\t\t  {\n-\t\t    basic_block bbj = BASIC_BLOCK (j);\n-\t\t    basic_block bbi = BASIC_BLOCK (i);\n-\t\t    if (REORDER_BLOCK_INDEX (bbj)\n-\t\t\t>= REORDER_BLOCK_INDEX (bbi) + 1)\n-\t\t      REORDER_BLOCK_INDEX (bbj)++;\n-\t\t  }\n-\t      }\n+\t      create_basic_block (n_basic_blocks - 1, jump_insn,\n+\t\t\t\t  jump_insn, NULL);\n+\t      nb = BASIC_BLOCK (n_basic_blocks - 1);\n+\t      nb->global_live_at_start\n+\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n+\t      nb->global_live_at_end\n+\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n+\n+\t      COPY_REG_SET (nb->global_live_at_start,\n+\t\t\t    bbi->global_live_at_start);\n+\t      COPY_REG_SET (nb->global_live_at_end,\n+\t\t\t    bbi->global_live_at_start);\n+\t      BASIC_BLOCK (nb->index)->local_set = 0;\n+\n+\t      nb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+\t      REORDER_BLOCK_INDEX (BASIC_BLOCK (n_basic_blocks - 1))\n+\t\t= REORDER_BLOCK_INDEX (bbi) + 1;\n+\t      /* Relink to new block.  */\n+\t      nb->succ = bbi->succ;\n+\t      nb->succ->src = nb;\n+\n+\t      make_edge (NULL, bbi, nb, 0);\n+\t      bbi->succ->succ_next\n+\t\t= bbi->succ->succ_next->succ_next;\n+\t      nb->succ->succ_next = 0;\n+\t      /* Fix reorder block index to reflect new block.  */\n+\t      for (j = 0; j < n_basic_blocks - 1; j++)\n+\t\t{\n+\t\t  basic_block bbj = BASIC_BLOCK (j);\n+\t\t  if (REORDER_BLOCK_INDEX (bbj)\n+\t\t      >= REORDER_BLOCK_INDEX (bbi) + 1)\n+\t\t    REORDER_BLOCK_INDEX (bbj)++;\n+\t\t}\n \t    }\n \t}\n     }"}]}