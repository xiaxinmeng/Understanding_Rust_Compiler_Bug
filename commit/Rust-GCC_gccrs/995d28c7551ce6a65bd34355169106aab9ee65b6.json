{"sha": "995d28c7551ce6a65bd34355169106aab9ee65b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk1ZDI4Yzc1NTFjZTZhNjViZDM0MzU1MTY5MTA2YWFiOWVlNjViNg==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2019-07-09T07:53:45Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-09T07:53:45Z"}, "message": "[Ada] Handle implicit moves in SPARK ownership pointer support\n\nAllocator expressions and sub-expressions of (extension) aggregates are\nimplicitly the source of assignments in Ada. Thus, they should be moved\nwhen of a deep type when checking ownership rules in SPARK.\n\nThere is no impact on compilation.\n\n2019-07-09  Yannick Moy  <moy@adacore.com>\n\ngcc/ada/\n\n\t* sem_spark.adb (Check_Expression): Handle correctly implicit\n\tassignments as part of allocators and (extension) aggregates.\n\t(Get_Root_Object): Adapt for new path expressions.\n\t(Is_Path_Expression): Return True for (extension) aggregate.\n\nFrom-SVN: r273271", "tree": {"sha": "aad0e457523bfb411fb26a2edf8c00da9765613e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aad0e457523bfb411fb26a2edf8c00da9765613e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/995d28c7551ce6a65bd34355169106aab9ee65b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995d28c7551ce6a65bd34355169106aab9ee65b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/995d28c7551ce6a65bd34355169106aab9ee65b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995d28c7551ce6a65bd34355169106aab9ee65b6/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "578d5941ee23743c28959d84fd5f6eec09c7734d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/578d5941ee23743c28959d84fd5f6eec09c7734d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/578d5941ee23743c28959d84fd5f6eec09c7734d"}], "stats": {"total": 215, "additions": 167, "deletions": 48}, "files": [{"sha": "86b02b36cb4d25fd9e2170f596136c5b4c4d8dca", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995d28c7551ce6a65bd34355169106aab9ee65b6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995d28c7551ce6a65bd34355169106aab9ee65b6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=995d28c7551ce6a65bd34355169106aab9ee65b6", "patch": "@@ -1,3 +1,10 @@\n+2019-07-09  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_spark.adb (Check_Expression): Handle correctly implicit\n+\tassignments as part of allocators and (extension) aggregates.\n+\t(Get_Root_Object): Adapt for new path expressions.\n+\t(Is_Path_Expression): Return True for (extension) aggregate.\n+\n 2019-07-09  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* einfo.ads: Fix a typo."}, {"sha": "bbd727987c6b29e8f7a460680696523aa699bfb5", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 160, "deletions": 48, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995d28c7551ce6a65bd34355169106aab9ee65b6/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995d28c7551ce6a65bd34355169106aab9ee65b6/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=995d28c7551ce6a65bd34355169106aab9ee65b6", "patch": "@@ -1436,6 +1436,13 @@ package body Sem_SPARK is\n       function Is_Type_Name (Expr : Node_Id) return Boolean;\n       --  Detect when a path expression is in fact a type name\n \n+      procedure Move_Expression (Expr : Node_Id);\n+      --  Some subexpressions are only analyzed in Move mode. This is a\n+      --  specialized version of Check_Expression for that case.\n+\n+      procedure Move_Expression_List (L : List_Id);\n+      --  Call Move_Expression on every expression in the list L\n+\n       procedure Read_Expression (Expr : Node_Id);\n       --  Most subexpressions are only analyzed in Read mode. This is a\n       --  specialized version of Check_Expression for that case.\n@@ -1458,6 +1465,36 @@ package body Sem_SPARK is\n            and then Is_Type (Entity (Expr));\n       end Is_Type_Name;\n \n+      ---------------------\n+      -- Move_Expression --\n+      ---------------------\n+\n+      --  Distinguish the case where the argument is a path expression that\n+      --  needs explicit moving.\n+\n+      procedure Move_Expression (Expr : Node_Id) is\n+      begin\n+         if Is_Path_Expression (Expr) then\n+            Check_Expression (Expr, Move);\n+         else\n+            Read_Expression (Expr);\n+         end if;\n+      end Move_Expression;\n+\n+      --------------------------\n+      -- Move_Expression_List --\n+      --------------------------\n+\n+      procedure Move_Expression_List (L : List_Id) is\n+         N : Node_Id;\n+      begin\n+         N := First (L);\n+         while Present (N) loop\n+            Move_Expression (N);\n+            Next (N);\n+         end loop;\n+      end Move_Expression_List;\n+\n       ---------------------\n       -- Read_Expression --\n       ---------------------\n@@ -1489,7 +1526,26 @@ package body Sem_SPARK is\n \n          --  Local subprograms\n \n+         function Is_Singleton_Choice (Choices : List_Id) return Boolean;\n+         --  Return whether Choices is a singleton choice\n+\n          procedure Read_Param (Formal : Entity_Id; Actual : Node_Id);\n+         --  Call Read_Expression on the actual\n+\n+         -------------------------\n+         -- Is_Singleton_Choice --\n+         -------------------------\n+\n+         function Is_Singleton_Choice (Choices : List_Id) return Boolean is\n+            Choice : constant Node_Id := First (Choices);\n+         begin\n+            return List_Length (Choices) = 1\n+              and then Nkind (Choice) /= N_Others_Choice\n+              and then not Nkind_In (Choice, N_Subtype_Indication, N_Range)\n+              and then not\n+                (Nkind_In (Choice, N_Identifier, N_Expanded_Name)\n+                  and then Is_Type (Entity (Choice)));\n+         end Is_Singleton_Choice;\n \n          ----------------\n          -- Read_Param --\n@@ -1526,8 +1582,11 @@ package body Sem_SPARK is\n                Read_Indexes (Prefix (Expr));\n                Read_Expression (Discrete_Range (Expr));\n \n+            --  The argument of an allocator is moved as part of the implicit\n+            --  assignment.\n+\n             when N_Allocator =>\n-               Read_Expression (Expression (Expr));\n+               Move_Expression (Expression (Expr));\n \n             when N_Function_Call =>\n                Read_Params (Expr);\n@@ -1539,6 +1598,91 @@ package body Sem_SPARK is\n             =>\n                Read_Indexes (Expression (Expr));\n \n+            when N_Aggregate =>\n+               declare\n+                  Assocs : constant List_Id := Component_Associations (Expr);\n+                  CL     : List_Id;\n+                  Assoc  : Node_Id := Nlists.First (Assocs);\n+                  Choice : Node_Id;\n+\n+               begin\n+                  --  The subexpressions of an aggregate are moved as part\n+                  --  of the implicit assignments. Handle the positional\n+                  --  components first.\n+\n+                  Move_Expression_List (Expressions (Expr));\n+\n+                  --  Handle the named components next.\n+\n+                  while Present (Assoc) loop\n+                     CL := Choices (Assoc);\n+\n+                     --  For an array aggregate, we should also check that the\n+                     --  expressions used in choices are readable.\n+\n+                     if Is_Array_Type (Etype (Expr)) then\n+                        Choice := Nlists.First (CL);\n+                        while Present (Choice) loop\n+                           if Nkind (Choice) /= N_Others_Choice then\n+                              Read_Expression (Choice);\n+                           end if;\n+                           Next (Choice);\n+                        end loop;\n+                     end if;\n+\n+                     --  There can be only one element for a value of deep type\n+                     --  in order to avoid aliasing.\n+\n+                     if Is_Deep (Etype (Expression (Assoc)))\n+                       and then not Is_Singleton_Choice (CL)\n+                     then\n+                        Error_Msg_F (\"singleton choice required\"\n+                                     & \" to prevent aliasing\", First (CL));\n+                     end if;\n+\n+                     --  The subexpressions of an aggregate are moved as part\n+                     --  of the implicit assignments.\n+\n+                     Move_Expression (Expression (Assoc));\n+\n+                     Next (Assoc);\n+                  end loop;\n+               end;\n+\n+            when N_Extension_Aggregate =>\n+               declare\n+                  Exprs  : constant List_Id := Expressions (Expr);\n+                  Assocs : constant List_Id := Component_Associations (Expr);\n+                  CL     : List_Id;\n+                  Assoc  : Node_Id := Nlists.First (Assocs);\n+\n+               begin\n+                  Move_Expression (Ancestor_Part (Expr));\n+\n+                  --  No positional components allowed at this stage\n+\n+                  if Present (Exprs) then\n+                     raise Program_Error;\n+                  end if;\n+\n+                  while Present (Assoc) loop\n+                     CL := Choices (Assoc);\n+\n+                     --  Only singleton components allowed at this stage\n+\n+                     if not Is_Singleton_Choice (CL) then\n+                        raise Program_Error;\n+                     end if;\n+\n+                     --  The subexpressions of an aggregate are moved as part\n+                     --  of the implicit assignments.\n+\n+                     Move_Expression (Expression (Assoc));\n+\n+                     Next (Assoc);\n+                  end loop;\n+               end;\n+\n             when others =>\n                raise Program_Error;\n          end case;\n@@ -1759,45 +1903,6 @@ package body Sem_SPARK is\n                Read_Expression (Condition (Expr));\n             end;\n \n-         when N_Aggregate =>\n-            declare\n-               Assocs  : constant List_Id := Component_Associations (Expr);\n-               Assoc   : Node_Id := First (Assocs);\n-               CL      : List_Id;\n-               Choice  : Node_Id;\n-\n-            begin\n-               while Present (Assoc) loop\n-\n-                  --  An array aggregate with a single component association\n-                  --  may have a nonstatic choice expression that needs to be\n-                  --  analyzed. This can only occur for a single choice that\n-                  --  is not the OTHERS one.\n-\n-                  if Is_Array_Type (Etype (Expr)) then\n-                     CL := Choices (Assoc);\n-                     if List_Length (CL) = 1 then\n-                        Choice := First (CL);\n-                        if Nkind (Choice) /= N_Others_Choice then\n-                           Read_Expression (Choice);\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-                  --  The expression in the component association also needs to\n-                  --  be analyzed.\n-\n-                  Read_Expression (Expression (Assoc));\n-                  Next (Assoc);\n-               end loop;\n-\n-               Read_Expression_List (Expressions (Expr));\n-            end;\n-\n-         when N_Extension_Aggregate =>\n-            Read_Expression (Ancestor_Part (Expr));\n-            Read_Expression_List (Expressions (Expr));\n-\n          when N_Character_Literal\n             | N_Numeric_Or_String_Literal\n             | N_Operator_Symbol\n@@ -1818,9 +1923,11 @@ package body Sem_SPARK is\n \n          --  Path expressions are handled before this point\n \n-         when N_Allocator\n+         when N_Aggregate\n+            | N_Allocator\n             | N_Expanded_Name\n             | N_Explicit_Dereference\n+            | N_Extension_Aggregate\n             | N_Function_Call\n             | N_Identifier\n             | N_Indexed_Component\n@@ -3283,7 +3390,7 @@ package body Sem_SPARK is\n                return (R => Unfolded, Tree_Access => C);\n             end;\n \n-         --  For a non-terminal path, we get the permission tree of its\n+         --  For a nonterminal path, we get the permission tree of its\n          --  prefix, and then get the subtree associated with the extension,\n          --  if unfolded. If folded, we return the permission associated with\n          --  children.\n@@ -3389,9 +3496,12 @@ package body Sem_SPARK is\n          =>\n             return Get_Root_Object (Prefix (Expr), Through_Traversal);\n \n-         --  There is no root object for an allocator or NULL\n+         --  There is no root object for an (extension) aggregate, allocator,\n+         --  or NULL.\n \n-         when N_Allocator\n+         when N_Aggregate\n+            | N_Allocator\n+            | N_Extension_Aggregate\n             | N_Null\n          =>\n             return Empty;\n@@ -3596,10 +3706,12 @@ package body Sem_SPARK is\n          when N_Null =>\n             return True;\n \n-         --  Object returned by a allocator or function call corresponds to\n-         --  a path.\n+         --  Object returned by an (extension) aggregate, an allocator, or\n+         --  a function call corresponds to a path.\n \n-         when N_Allocator\n+         when N_Aggregate\n+            | N_Allocator\n+            | N_Extension_Aggregate\n             | N_Function_Call\n          =>\n             return True;\n@@ -4763,7 +4875,7 @@ package body Sem_SPARK is\n                return C;\n             end;\n \n-         --  For a non-terminal path, we set the permission tree of its prefix,\n+         --  For a nonterminal path, we set the permission tree of its prefix,\n          --  and then we extract from the returned pointer the subtree and\n          --  assign an adequate permission to it, if unfolded. If folded,\n          --  we unroll the tree one level."}]}