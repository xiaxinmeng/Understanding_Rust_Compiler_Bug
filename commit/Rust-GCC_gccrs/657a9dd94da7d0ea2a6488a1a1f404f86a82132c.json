{"sha": "657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU3YTlkZDk0ZGE3ZDBlYTJhNjQ4OGExYTFmNDA0Zjg2YTgyMTMyYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-29T10:26:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-29T10:26:16Z"}, "message": "3vtrasym.adb, [...]: Minor reformatting\n\n\t* 3vtrasym.adb, 5vtraent.ads, sprint.adb,\n\tsem_ch10.adb: Minor reformatting\n\n\t* exp_ch5.adb (Expand_Assign_Array): Test for bit unaligned operands\n\t(Expand_Assign_Record): Test right hand side for bit unaligned as well\n\n\t* 3vtrasym.adb:\n\t* 5vtraent.adb:\n\t* 5vtraent.ads:\n\t* tb-alvms.c:\n\tSupport for TBK$SYMBOLIZE-based symbolic traceback.\n\n\t* exp_disp.adb:\n\tRevert previous change, that did not work well when pragma No_Run_Time\n\twas used in conjunction with a run-time other than ZFP.\n\n\t* make.adb:\n\t(Gnatmake): When there are no Ada mains in attribute Main, disable the\n\t bind and link steps only is switch -z is not used.\n\n\t* Makefile.generic: Remove duplicated setting of CC.\n\n\t* Makefile.prolog: Set CC to gcc by default, to override make's\n\tdefault (cc).\n\n\t* einfo.h: Regenerated.\n\n\t* sem_ch10.adb (Analyze_Subunit): Restore state of suppress flags for\n\tcurrent body, after compiling subunit.\n\n\t* itypes.adb (Create_Itype): In ASIS_Mode, do not freeze the itype\n\twhen in deleted code, because gigi needs properly ordered freeze\n\tactions to annotate types.\n\n\t* freeze.adb (Is_Fully_Defined): Predicate must be recursive, to\n\tprevent the premature freezing of record type that contains\n\tsubcomponents with a private type that does not yet have a completion.\n\n\t* sem_ch12.adb:\n\t(Analyze_Package_Instantiation): Check that instances can not be used in\n\tlimited with_clauses.\n\n\t* sem_ch8.adb:\n\t(Analyze_Package_Renaming): Check that limited withed packages cannot\n\tbe renamed. Improve text on error messages related to limited\n\twith_clauses.\n\n\t* einfo.adb, einfo.ads: Remove Non_Limited_Views attribute.\n\n\t* sprint.adb: (Sprint_Node_Actual): Print limited with_clauses.\n\tUpdate copyright notice.\n\n\t* sem_ch10.adb: (Build_Limited_Views): Complete its documentation.\n\t(Install_Limited_Context_Clauses): New subprogram that isolates all the\n\tchecks required for limited context_clauses and installs the limited\n\tview.\n\t(Install_Limited_Withed_Unit): Complete its documentation.\n\t(Analyze_Context): Check that limited with_clauses are only allowed in\n\tpackage specs.\n\t(Install_Context): Call Install_Limited_Context_Clauses after the\n\tparents have been installed.\n\t(Install_Limited_Withed_Unit): Add documentation. Mark the installed\n\tpackage as 'From_With_Type'; this mark indicates that the limited view\n\tis installed. Used to check bad usages of limited with_clauses.\n\t(Build_Limited_Views): Do not add shadow entities to the scope's list\n\tof entities. Do not add real entities to the Non_Limited_Views chain.\n\tImprove error notification.\n\t(Remove_Context_Clauses): Remove context clauses in two phases:\n\tlimited views first and regular views later (to maintain the\n\tstack model).\n\t(Remove_Limited_With_Clause): If the package is analyzed then reinstall\n\tits visible entities.\n\n\t* sem_type.adb (Specific_Type): Type Universal_Fixed is compatible\n\twith any type that Is_Fixed_Point_Type.\n\n\t* sinfo.ads: Fix documentation for Associated_Node attribute.\n\n\t* switch-c.adb (Scan_Front_End_Switches): ASIS_Mode is set now when\n\tboth '-gnatc' and '-gnatt' are specified.\n\n\t* atree.adb (Initialize): Add initialization for Node_Count (set to\n\tzero).\n\n\t* decl.c (gnat_to_gnu_entity, case E_Subprogram): If no return value,\n\tdo not consider as Pure.\n\n\tPart of implementation of function-at-a-time:\n\n\t* trans.c (gnat_to_gnu_code): If IS_STMT, call expand_expr_stmt.\n\t(tree_transform): Add new argument to build_component_ref.\n\t(tree_transform, case N_Assignment_Statement): Make and return an\n\tEXPR_STMT.\n\t(tree_transform): If result IS_STMT, set flags and return it.\n\t(gnat_expand_stmt, set_lineno_from_sloc): New functions.\n\n\t* utils2.c (build_simple_component_ref, build_component_ref): Add new\n\targ, NO_FOLD_P.\n\t(build_binary_op, case EQ_EXPR): Pass additional arg to it.\n\t(build_allocator): Likewise.\n\n\t* utils.c (convert_to_fat_pointer, convert_to_thin_pointer, convert):\n\tAdd new arg to build_component_ref.\n\t(maybe_unconstrained_array, unchecked_convert): Likewise.\n\n\t* ada-tree.def (EXPR_STMT): New code.\n\n\t* ada-tree.h (IS_STMT, TREE_SLOC, EXPR_STMT_EXPR): New macros.\n\n\t* decl.c (gnat_to_gnu_entity, case object): Add extra arg to\n\tbuild_component_ref calls.\n\n\t* misc.c (gnat_expand_expr): If IS_STMT, call gnat_expand_stmt.\n\n\t* gigi.h (gnat_expand_stmt, set_lineno_from_sloc): New functions.\n\t(build_component_ref): Add new argument, NO_FOLD_P.\n\nFrom-SVN: r73032", "tree": {"sha": "bfeb47fbaa83d3e8b0332c1ec93ed78b01e52cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfeb47fbaa83d3e8b0332c1ec93ed78b01e52cf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/comments", "author": null, "committer": null, "parents": [{"sha": "e9da8a5af764758dab39da8afb53009bbd01e795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9da8a5af764758dab39da8afb53009bbd01e795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9da8a5af764758dab39da8afb53009bbd01e795"}], "stats": {"total": 1280, "additions": 966, "deletions": 314}, "files": [{"sha": "d11e26b730c89b90402b190a377579e461b62e8b", "filename": "gcc/ada/3vtrasym.adb", "status": "modified", "additions": 104, "deletions": 91, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F3vtrasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F3vtrasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F3vtrasym.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -34,7 +34,6 @@\n \n with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n with Interfaces.C;\n-with Interfaces.C.Strings;\n with System;\n with System.Aux_DEC;\n with System.Soft_Links;\n@@ -45,133 +44,147 @@ package body GNAT.Traceback.Symbolic is\n    pragma Warnings (Off);\n    pragma Linker_Options (\"--for-linker=sys$library:trace.exe\");\n \n-   use Interfaces.C.Strings;\n+   use Interfaces.C;\n    use System;\n    use System.Aux_DEC;\n    use System.Traceback_Entries;\n \n-   type Dscdef1_Type is record\n-      Maxstrlen : Unsigned_Word;\n-      Dtype     : Unsigned_Byte;\n-      Class     : Unsigned_Byte;\n-      Pointer   : chars_ptr;\n-   end record;\n+   subtype User_Arg_Type is Unsigned_Longword;\n+   subtype Cond_Value_Type is Unsigned_Longword;\n \n-   for Dscdef1_Type use record\n-      Maxstrlen at 0 range 0 .. 15;\n-      Dtype     at 2 range 0 .. 7;\n-      Class     at 3 range 0 .. 7;\n-      Pointer   at 4 range 0 .. 31;\n+   type ASCIC is record\n+      Count : unsigned_char;\n+      Data  : char_array (1 .. 255);\n    end record;\n-   for Dscdef1_Type'Size use 64;\n+   pragma Convention (C, ASCIC);\n \n-   Image_Buf  : String (1 .. 10240);\n-   Image_Len  : Integer;\n-   Image_Need_Hdr : Boolean := True;\n-   Image_Do_Another_Line : Boolean;\n-   Image_Xtra_Msg : Boolean;\n-\n-   procedure Traceback_Image (Out_Desc : access Dscdef1_Type);\n-\n-   procedure Traceback_Image (Out_Desc : access Dscdef1_Type) is\n-      Image : String (1 .. Integer (Out_Desc.Maxstrlen));\n-   begin\n-      Image := Value (Out_Desc.Pointer,\n-                      Interfaces.C.size_t (Out_Desc.Maxstrlen));\n-\n-      if Image_Do_Another_Line and then\n-        (Image_Need_Hdr or else\n-         Image (Image'First .. Image'First + 27) /=\n-         \"  image    module    routine\")\n-      then\n-         declare\n-            First : Integer := Image_Len + 1;\n-            Last  : Integer := First + Image'Length - 1;\n-         begin\n-            Image_Buf (First .. Last + 1) := Image & ASCII.LF;\n-            Image_Len := Last + 1;\n-         end;\n-\n-         Image_Need_Hdr := False;\n-\n-         if Image (Image'First .. Image'First + 3) = \"----\" then\n-            if Image_Xtra_Msg = False then\n-               Image_Xtra_Msg := True;\n-            else\n-               Image_Xtra_Msg := False;\n-            end if;\n-         end if;\n+   for ASCIC use record\n+      Count at 0 range 0 .. 7;\n+      Data  at 1 range 0 .. 8 * 255 - 1;\n+   end record;\n+   for ASCIC'Size use 8 * 256;\n \n-         if Out_Desc.Maxstrlen = 79 and then not Image_Xtra_Msg then\n-            Image_Len := Image_Len - 1;\n-            Image_Do_Another_Line := False;\n-         end if;\n-      end if;\n-   end Traceback_Image;\n+   function Fetch_ASCIC is new Fetch_From_Address (ASCIC);\n \n-   subtype User_Arg_Type is Unsigned_Longword;\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-\n-   procedure Show_Traceback\n+   procedure Symbolize\n      (Status         : out Cond_Value_Type;\n-      Faulting_FP    : Address;\n-      Faulting_SP    : Address;\n-      Faulting_PC    : Address;\n-      Detail_Level   : Integer           := Integer'Null_Parameter;\n+      Current_PC     : in Address;\n+      Adjusted_PC    : in Address;\n+      Current_FP     : in Address;\n+      Current_R26    : in Address;\n+      Image_Name     : out Address;\n+      Module_Name    : out Address;\n+      Routine_Name   : out Address;\n+      Line_Number    : out Integer;\n+      Relative_PC    : out Address;\n+      Absolute_PC    : out Address;\n+      PC_Is_Valid    : out Long_Integer;\n       User_Act_Proc  : Address           := Address'Null_Parameter;\n-      User_Arg_Value : User_Arg_Type     := User_Arg_Type'Null_Parameter;\n-      Exceptionn     : Unsigned_Longword := Unsigned_Longword'Null_Parameter);\n+      User_Arg_Value : User_Arg_Type     := User_Arg_Type'Null_Parameter);\n \n-   pragma Interface (External, Show_Traceback);\n+   pragma Interface (External, Symbolize);\n \n    pragma Import_Valued_Procedure\n-     (Show_Traceback, \"TBK$SHOW_TRACEBACK\",\n-      (Cond_Value_Type, Address, Address, Address, Integer, Address,\n-       User_Arg_Type, Unsigned_Longword),\n-      (Value, Value, Value, Value, Reference, Value, Value, Reference),\n-       Detail_Level);\n-\n+     (Symbolize, \"TBK$SYMBOLIZE\",\n+      (Cond_Value_Type, Address, Address, Address, Address,\n+       Address, Address, Address, Integer,\n+       Address, Address, Long_Integer,\n+       Address, User_Arg_Type),\n+      (Value, Value, Value, Value, Value,\n+       Reference, Reference, Reference, Reference,\n+       Reference, Reference, Reference,\n+       Value, Value),\n+       User_Act_Proc);\n \n    ------------------------\n    -- Symbolic_Traceback --\n    ------------------------\n \n    function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-      Res : String (1 .. 256 * Traceback'Length);\n-      Len : Integer;\n-      Status : Cond_Value_Type;\n+      Status       : Cond_Value_Type;\n+      Image_Name        : ASCIC;\n+      Image_Name_Addr   : Address;\n+      Module_Name       : ASCIC;\n+      Module_Name_Addr  : Address;\n+      Routine_Name      : ASCIC;\n+      Routine_Name_Addr : Address;\n+      Line_Number       : Integer;\n+      Relative_PC       : Address;\n+      Absolute_PC       : Address;\n+      PC_Is_Valid       : Long_Integer;\n+      Return_Address    : Address;\n+      Res               : String (1 .. 256 * Traceback'Length);\n+      Len               : Integer;\n \n    begin\n       if Traceback'Length > 0 then\n-\n          Len := 0;\n \n          --  Since image computation is not thread-safe we need task lockout\n+\n          System.Soft_Links.Lock_Task.all;\n-         for I in Traceback'Range loop\n-            Image_Len := 0;\n-            Image_Do_Another_Line := True;\n-            Image_Xtra_Msg := False;\n \n-            Show_Traceback\n+         for J in Traceback'Range loop\n+            if J = Traceback'Last then\n+               Return_Address := Address_Zero;\n+            else\n+               Return_Address := PC_For (Traceback (J + 1));\n+            end if;\n+\n+            Symbolize\n               (Status,\n-               FP_For (Traceback (I)),\n-               SP_For (Traceback (I)),\n-               PC_For (Traceback (I)),\n-               0,\n-               Traceback_Image'Address);\n+               PC_For (Traceback (J)),\n+               PC_For (Traceback (J)),\n+               PV_For (Traceback (J)),\n+               Return_Address,\n+               Image_Name_Addr,\n+               Module_Name_Addr,\n+               Routine_Name_Addr,\n+               Line_Number,\n+               Relative_PC,\n+               Absolute_PC,\n+               PC_Is_Valid);\n+\n+            Image_Name   := Fetch_ASCIC (Image_Name_Addr);\n+            Module_Name  := Fetch_ASCIC (Module_Name_Addr);\n+            Routine_Name := Fetch_ASCIC (Routine_Name_Addr);\n \n             declare\n                First : Integer := Len + 1;\n-               Last  : Integer := First + Image_Len - 1;\n+               Last  : Integer := First + 80 - 1;\n+\n             begin\n-               Res (First .. Last + 1) := Image_Buf & ASCII.LF;\n-               Len := Last + 1;\n+               Res (First .. Last) := (others => ' ');\n+\n+               Res (First .. First + Integer (Image_Name.Count) - 1) :=\n+                 To_Ada\n+                  (Image_Name.Data (1 .. size_t (Image_Name.Count)),\n+                   False);\n+\n+               Res (First + 10 ..\n+                    First + 10 + Integer (Module_Name.Count) - 1) :=\n+                 To_Ada\n+                  (Module_Name.Data (1 .. size_t (Module_Name.Count)),\n+                   False);\n+\n+               Res (First + 30 ..\n+                    First + 30 + Integer (Routine_Name.Count) - 1) :=\n+                 To_Ada\n+                  (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n+                   False);\n+\n+               Res (First + 50 ..\n+                    First + 50 + Integer'Image (Line_Number)'Length - 1) :=\n+                 Integer'Image (Line_Number);\n+\n+               Res (Last) := ASCII.LF;\n+               Len := Last;\n             end;\n          end loop;\n-         System.Soft_Links.Unlock_Task.all;\n \n+         System.Soft_Links.Unlock_Task.all;\n          return Res (1 .. Len);\n+\n       else\n          return \"\";\n       end if;"}, {"sha": "532acad6e32d6aa56709cbc2d8ba3ec7b2cfc93b", "filename": "gcc/ada/5vtraent.adb", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F5vtraent.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F5vtraent.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtraent.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -47,30 +47,21 @@ package body System.Traceback_Entries is\n    end PC_For;\n \n    ------------\n-   -- SP_For --\n+   -- PV_For --\n    ------------\n \n-   function SP_For (TB_Entry : Traceback_Entry) return System.Address is\n+   function PV_For (TB_Entry : Traceback_Entry) return System.Address is\n    begin\n-      return TB_Entry.SP;\n-   end SP_For;\n-\n-   ------------\n-   -- FP_For --\n-   ------------\n-\n-   function FP_For (TB_Entry : Traceback_Entry) return System.Address is\n-   begin\n-      return TB_Entry.FP;\n-   end FP_For;\n+      return TB_Entry.PV;\n+   end PV_For;\n \n    ------------------\n    -- TB_Entry_For --\n    ------------------\n \n    function TB_Entry_For (PC : System.Address) return Traceback_Entry is\n    begin\n-      return (PC => PC, SP => System.Null_Address, FP => System.Null_Address);\n+      return (PC => PC, PV => System.Null_Address);\n    end TB_Entry_For;\n \n end System.Traceback_Entries;"}, {"sha": "0d27c197fff374b0561dcfb90d8ca8ef725d4ed4", "filename": "gcc/ada/5vtraent.ads", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F5vtraent.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2F5vtraent.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtraent.ads?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -35,34 +35,25 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the Alpha/OpenVMS version of this package.\n+--  This is the Alpha/OpenVMS version of this package\n \n package System.Traceback_Entries is\n \n-   type Traceback_Entry is private;\n-\n-   Null_TB_Entry : constant Traceback_Entry;\n-\n-   function PC_For (TB_Entry : Traceback_Entry) return System.Address;\n-   function SP_For (TB_Entry : Traceback_Entry) return System.Address;\n-   function FP_For (TB_Entry : Traceback_Entry) return System.Address;\n-\n-   function TB_Entry_For (PC : System.Address) return Traceback_Entry;\n-\n-private\n-\n    type Traceback_Entry is record\n       PC : System.Address;\n-      SP : System.Address;\n-      FP : System.Address;\n+      PV : System.Address;\n    end record;\n \n    pragma Suppress_Initialization (Traceback_Entry);\n \n-   Null_TB_Entry : constant Traceback_Entry\n-     := (PC => System.Null_Address,\n-         SP => System.Null_Address,\n-         FP => System.Null_Address);\n+   Null_TB_Entry : constant Traceback_Entry :=\n+                     (PC => System.Null_Address,\n+                      PV => System.Null_Address);\n+\n+   function PC_For (TB_Entry : Traceback_Entry) return System.Address;\n+   function PV_For (TB_Entry : Traceback_Entry) return System.Address;\n+\n+   function TB_Entry_For (PC : System.Address) return Traceback_Entry;\n \n end System.Traceback_Entries;\n "}, {"sha": "c6de5e02630fe9f5dda9ad3ef261b2da67d85695", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -1,3 +1,140 @@\n+2003-10-29  Robert Dewar  <dewar@gnat.com>\n+\n+\t* 3vtrasym.adb, 5vtraent.ads, sprint.adb,\n+\tsem_ch10.adb: Minor reformatting\n+\n+\t* exp_ch5.adb (Expand_Assign_Array): Test for bit unaligned operands\n+\t(Expand_Assign_Record): Test right hand side for bit unaligned as well\n+\n+2003-10-29  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* 3vtrasym.adb: \n+\t* 5vtraent.adb: \n+\t* 5vtraent.ads: \n+\t* tb-alvms.c: \n+\tSupport for TBK$SYMBOLIZE-based symbolic traceback.\n+\n+2003-10-29  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* exp_disp.adb: \n+\tRevert previous change, that did not work well when pragma No_Run_Time\n+\twas used in conjunction with a run-time other than ZFP.\n+\n+2003-10-29  Vincent Celier  <celier@gnat.com>\n+\n+\t* make.adb: \n+\t(Gnatmake): When there are no Ada mains in attribute Main, disable the\n+\t bind and link steps only is switch -z is not used.\n+\n+2003-10-29  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* Makefile.generic: Remove duplicated setting of CC.\n+\n+\t* Makefile.prolog: Set CC to gcc by default, to override make's\n+\tdefault (cc).\n+\n+\t* einfo.h: Regenerated.\n+\n+2003-10-29  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch10.adb (Analyze_Subunit): Restore state of suppress flags for\n+\tcurrent body, after compiling subunit.\n+\n+\t* itypes.adb (Create_Itype): In ASIS_Mode, do not freeze the itype\n+\twhen in deleted code, because gigi needs properly ordered freeze\n+\tactions to annotate types.\n+\n+\t* freeze.adb (Is_Fully_Defined): Predicate must be recursive, to\n+\tprevent the premature freezing of record type that contains\n+\tsubcomponents with a private type that does not yet have a completion.\n+\n+2003-10-29  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sem_ch12.adb: \n+\t(Analyze_Package_Instantiation): Check that instances can not be used in\n+\tlimited with_clauses.\n+\n+\t* sem_ch8.adb: \n+\t(Analyze_Package_Renaming): Check that limited withed packages cannot\n+\tbe renamed. Improve text on error messages related to limited\n+\twith_clauses.\n+\n+\t* einfo.adb, einfo.ads: Remove Non_Limited_Views attribute.\n+\n+\t* sprint.adb: (Sprint_Node_Actual): Print limited with_clauses.\n+\tUpdate copyright notice.\n+\n+\t* sem_ch10.adb: (Build_Limited_Views): Complete its documentation.\n+\t(Install_Limited_Context_Clauses): New subprogram that isolates all the\n+\tchecks required for limited context_clauses and installs the limited\n+\tview.\n+\t(Install_Limited_Withed_Unit): Complete its documentation.\n+\t(Analyze_Context): Check that limited with_clauses are only allowed in\n+\tpackage specs.\n+\t(Install_Context): Call Install_Limited_Context_Clauses after the\n+\tparents have been installed.\n+\t(Install_Limited_Withed_Unit): Add documentation. Mark the installed\n+\tpackage as 'From_With_Type'; this mark indicates that the limited view\n+\tis installed. Used to check bad usages of limited with_clauses.\n+\t(Build_Limited_Views): Do not add shadow entities to the scope's list\n+\tof entities. Do not add real entities to the Non_Limited_Views chain.\n+\tImprove error notification.\n+\t(Remove_Context_Clauses): Remove context clauses in two phases:\n+\tlimited views first and regular views later (to maintain the\n+\tstack model).\n+\t(Remove_Limited_With_Clause): If the package is analyzed then reinstall\n+\tits visible entities.\n+\n+2003-10-29  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_type.adb (Specific_Type): Type Universal_Fixed is compatible\n+\twith any type that Is_Fixed_Point_Type.\n+\n+\t* sinfo.ads: Fix documentation for Associated_Node attribute.\n+\n+2003-10-29  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* switch-c.adb (Scan_Front_End_Switches): ASIS_Mode is set now when\n+\tboth '-gnatc' and '-gnatt' are specified.\n+\n+\t* atree.adb (Initialize): Add initialization for Node_Count (set to\n+\tzero).\n+\n+2003-10-29  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (gnat_to_gnu_entity, case E_Subprogram): If no return value,\n+\tdo not consider as Pure.\n+\n+\tPart of implementation of function-at-a-time:\n+\n+\t* trans.c (gnat_to_gnu_code): If IS_STMT, call expand_expr_stmt.\n+\t(tree_transform): Add new argument to build_component_ref.\n+\t(tree_transform, case N_Assignment_Statement): Make and return an\n+\tEXPR_STMT.\n+\t(tree_transform): If result IS_STMT, set flags and return it.\n+\t(gnat_expand_stmt, set_lineno_from_sloc): New functions.\n+\n+\t* utils2.c (build_simple_component_ref, build_component_ref): Add new\n+\targ, NO_FOLD_P.\n+\t(build_binary_op, case EQ_EXPR): Pass additional arg to it.\n+\t(build_allocator): Likewise.\n+\n+\t* utils.c (convert_to_fat_pointer, convert_to_thin_pointer, convert):\n+\tAdd new arg to build_component_ref.\n+\t(maybe_unconstrained_array, unchecked_convert): Likewise.\n+\n+\t* ada-tree.def (EXPR_STMT): New code.\n+\n+\t* ada-tree.h (IS_STMT, TREE_SLOC, EXPR_STMT_EXPR): New macros.\n+\n+\t* decl.c (gnat_to_gnu_entity, case object): Add extra arg to\n+\tbuild_component_ref calls.\n+\n+\t* misc.c (gnat_expand_expr): If IS_STMT, call gnat_expand_stmt.\n+\n+\t* gigi.h (gnat_expand_stmt, set_lineno_from_sloc): New functions.\n+\t(build_component_ref): Add new argument, NO_FOLD_P.\n+\n 2003-10-27  Arnaud Charlet  <charlet@act-europe.fr>\n \n \t* Makefile.generic: Add missing substitution on object_deps handling."}, {"sha": "34e0d24af01e9f450cef356c6f322ed864bb9e22", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -67,10 +67,6 @@ ifndef MAIN\n    MAIN=ada\n endif\n \n-ifndef CC\n-   CC=gcc\n-endif\n-\n ifndef ADA_SPEC\n    ADA_SPEC=.ads\n endif"}, {"sha": "1aaff2946170d1c506bd02ec8d5ba5d6e038c81f", "filename": "gcc/ada/Makefile.prolog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FMakefile.prolog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2FMakefile.prolog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.prolog?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -39,6 +39,7 @@ C_EXT:=.c\n CXX_EXT:=.cc\n AR_EXT=.a\n OBJ_EXT=.o\n+CC=gcc\n \n # Default target is to build (compile/bind/link)\n # Target build is defined in Makefile.generic"}, {"sha": "24cfa59fa8e4efbf32afe7144f5043ef231b36fc", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -77,3 +77,11 @@ DEFTREECODE (GNAT_NOP_EXPR, \"gnat_nop_expr\", '1', 1)\n    ??? This should be redone at some point.  */\n \n DEFTREECODE (GNAT_LOOP_ID, \"gnat_loop_id\", 'x', 0)\n+\n+/* Here are the tree codes for the statement types known to Ada.  These\n+   must be at the end of this file to allow IS_STMT to work.\n+\n+   We start with an expression statement, whose only operand is an\n+   expression, EXPR_STMT_EXPR, Execution of the statement means evaluation of\n+   the expression (such as a MODIFY_EXPR) and discarding its result.  */\n+DEFTREECODE (EXPR_STMT, \"expr_stmt_expr\", 's', 1)"}, {"sha": "13487ffb0680376475d9492735142a2c1aef37e9", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -275,3 +275,14 @@ struct lang_type GTY(())\n    node.  We need to find some other place to store it!  */\n #define TREE_LOOP_ID(NODE) \\\n   (((union lang_tree_node *)TREE_CHECK (NODE, GNAT_LOOP_ID))->loop_id.loop_id)\n+\n+/* Define fields and macros for statements.\n+\n+   Start by defining which tree codes are used for statements.  */\n+#define IS_STMT(NODE)\t\t(TREE_CODE_CLASS (TREE_CODE (NODE)) == 's')\n+\n+/* We store the Sloc in statement nodes.  */\n+#define TREE_SLOC(NODE)\t\tTREE_COMPLEXITY (STMT_CHECK (NODE))\n+\n+/* There is just one field in an EXPR_STMT: the expression.  */\n+#define EXPR_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXPR_STMT, 0)"}, {"sha": "50647da5eebf8b758c301c6cf04d9c6f5e16ccf7", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -838,6 +838,7 @@ package body Atree is\n       pragma Warnings (Off, Dummy);\n \n    begin\n+      Node_Count := 0;\n       Atree_Private_Part.Nodes.Init;\n       Orig_Nodes.Init;\n "}, {"sha": "d01074e9b0a514b8c5f5cc56b9b146887c3884ae", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -946,7 +946,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t    gnu_expr\n \t\t      = build_component_ref\n \t\t\t(gnu_expr, NULL_TREE,\n-\t\t\t TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))));\n+\t\t\t TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))), 0);\n \t\t  }\n \n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST\n@@ -990,15 +990,15 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t(build_binary_op\n \t\t (MODIFY_EXPR, NULL_TREE,\n \t\t  build_component_ref (gnu_new_var, NULL_TREE,\n-\t\t\t\t       TYPE_FIELDS (gnu_new_type)),\n+\t\t\t\t       TYPE_FIELDS (gnu_new_type), 0),\n \t\t  gnu_expr));\n \n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_expr\n \t      = build_unary_op\n \t\t(ADDR_EXPR, gnu_type,\n \t\t build_component_ref (gnu_new_var, NULL_TREE,\n-\t\t\t\t      TYPE_FIELDS (gnu_new_type)));\n+\t\t\t\t      TYPE_FIELDS (gnu_new_type), 0));\n \n \t    gnu_size = 0;\n \t    used_by_ref = 1;\n@@ -3536,6 +3536,13 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \tif (! global_bindings_p ())\n \t  pure_flag = 0;\n \n+\t/* A subprogram (something that doesn't return anything) shouldn't\n+\t   be considered Pure since there would be no reason for such a\n+\t   subprogram.  Note that procedures with Out (or In Out) parameters\n+\t   have already been converted into a function with a return type. */\n+\tif (TREE_CODE (gnu_return_type) == VOID_TYPE)\n+\t  pure_flag = 0;\n+\n \tgnu_type\n \t  = build_qualified_type (gnu_type,\n \t\t\t\t  (TYPE_QUALS (gnu_type)"}, {"sha": "6b0c1a132aa6c34d2aae8aeaba843ec9c25e1fda", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -80,7 +80,6 @@ package body Einfo is\n    --    Hiding_Loop_Variable            Node8\n    --    Mechanism                       Uint8 (but returns Mechanism_Type)\n    --    Normalized_First_Bit            Uint8\n-   --    Non_Limited_Views               Elist8\n \n    --    Class_Wide_Type                 Node9\n    --    Current_Value                   Node9\n@@ -1798,17 +1797,10 @@ package body Einfo is\n    function Non_Limited_View (Id : E) return E is\n    begin\n       pragma Assert (False\n-        or else Ekind (Id) = E_Incomplete_Type\n-        or else Ekind (Id) = E_Package);\n+        or else Ekind (Id) = E_Incomplete_Type);\n       return Node17 (Id);\n    end Non_Limited_View;\n \n-   function Non_Limited_Views (Id : E) return L is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Package);\n-      return Elist8 (Id);\n-   end Non_Limited_Views;\n-\n    function Nonzero_Is_True (Id : E) return B is\n    begin\n       pragma Assert (Root_Type (Id) = Standard_Boolean);\n@@ -2845,7 +2837,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Type (Id)\n-          or else Ekind (Id) = E_Package);\n+         or else Ekind (Id) = E_Package);\n       Set_Flag159 (Id, V);\n    end Set_From_With_Type;\n \n@@ -3741,18 +3733,11 @@ package body Einfo is\n \n    procedure Set_Non_Limited_View (Id : E; V : E) is\n       pragma Assert (False\n-        or else Ekind (Id) = E_Incomplete_Type\n-        or else Ekind (Id) = E_Package);\n+        or else Ekind (Id) = E_Incomplete_Type);\n    begin\n       Set_Node17 (Id, V);\n    end Set_Non_Limited_View;\n \n-   procedure Set_Non_Limited_Views (Id : E; V : L) is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Package);\n-      Set_Elist8 (Id, V);\n-   end Set_Non_Limited_Views;\n-\n    procedure Set_Nonzero_Is_True (Id : E; V : B := True) is\n    begin\n       pragma Assert"}, {"sha": "a16063d27be9191a63ca4bbcec2237fdcf18cc29", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -2381,8 +2381,7 @@ package Einfo is\n --       Present in non-generic package entities that are not instances.\n --       The elements of this list are the shadow entities created for the\n --       types and local packages that are declared in a package that appears\n---       in a limited_with clause. This list and Non_Limited_Views are built\n---       at the same time, and their elements are in one-one correspondence.\n+--       in a limited_with clause.\n \n --    Lit_Indexes (Node15)\n --       Present in enumeration types and subtypes. Non-empty only for the\n@@ -2551,14 +2550,9 @@ package Einfo is\n --       is other than a power of 2.\n \n --    Non_Limited_View (Node17)\n---       Present in incomplete types, and local packages that are the\n---       shadow entities created when analyzing a limited_with_clause.\n---       Points to the definining entity in the original declaration.\n-\n---    Non_Limited_Views (Elist8)\n---       Present in non-generic packages that are not instances. The elements\n---       of this list are defining identifiers for types and local packages\n---       declared within a package that appears in a limited_with clause.\n+--       Present in incomplete types that are the shadow entities\n+--       created when analyzing a limited_with_clause. Points to the\n+--       definining entity in the original declaration.\n \n --    Nonzero_Is_True (Flag162) [base type only]\n --       Present in enumeration types. True if any non-zero value is to be\n@@ -4388,7 +4382,6 @@ package Einfo is\n    --  E_Package\n    --  E_Generic_Package\n    --    Dependent_Instances           (Elist8)   (for an instance)\n-   --    Non_Limited_Views             (Elist8)   (non-generic, not instance)\n    --    Renaming_Map                  (Uint9)\n    --    Handler_Records               (List10)   (non-generic case only)\n    --    Generic_Homonym               (Node11)   (generic case only)\n@@ -5152,7 +5145,6 @@ package Einfo is\n    function No_Return                          (Id : E) return B;\n    function Non_Binary_Modulus                 (Id : E) return B;\n    function Non_Limited_View                   (Id : E) return E;\n-   function Non_Limited_Views                  (Id : E) return L;\n    function Nonzero_Is_True                    (Id : E) return B;\n    function Normalized_First_Bit               (Id : E) return U;\n    function Normalized_Position                (Id : E) return U;\n@@ -5624,7 +5616,6 @@ package Einfo is\n    procedure Set_No_Return                     (Id : E; V : B := True);\n    procedure Set_Non_Binary_Modulus            (Id : E; V : B := True);\n    procedure Set_Non_Limited_View              (Id : E; V : E);\n-   procedure Set_Non_Limited_Views             (Id : E; V : L);\n    procedure Set_Nonzero_Is_True               (Id : E; V : B := True);\n    procedure Set_Normalized_First_Bit          (Id : E; V : U);\n    procedure Set_Normalized_Position           (Id : E; V : U);\n@@ -6150,7 +6141,6 @@ package Einfo is\n    pragma Inline (No_Return);\n    pragma Inline (Non_Binary_Modulus);\n    pragma Inline (Non_Limited_View);\n-   pragma Inline (Non_Limited_Views);\n    pragma Inline (Nonzero_Is_True);\n    pragma Inline (Normalized_First_Bit);\n    pragma Inline (Normalized_Position);\n@@ -6455,7 +6445,6 @@ package Einfo is\n    pragma Inline (Set_No_Return);\n    pragma Inline (Set_Non_Binary_Modulus);\n    pragma Inline (Set_Non_Limited_View);\n-   pragma Inline (Set_Non_Limited_Views);\n    pragma Inline (Set_Nonzero_Is_True);\n    pragma Inline (Set_Normalized_First_Bit);\n    pragma Inline (Set_Normalized_Position);"}, {"sha": "05db041ddc6b9ced55497f0d7752e14c990c5905", "filename": "gcc/ada/einfo.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Feinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.h?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -483,7 +483,6 @@\n    INLINE B No_Return                          (E Id);\n    INLINE B Non_Binary_Modulus                 (E Id);\n    INLINE E Non_Limited_View                   (E Id);\n-   INLINE L Non_Limited_Views                  (E Id);\n    INLINE B Nonzero_Is_True                    (E Id);\n    INLINE U Normalized_First_Bit               (E Id);\n    INLINE U Normalized_Position                (E Id);\n@@ -1517,9 +1516,6 @@\n    INLINE E Non_Limited_View (E Id)\n       { return Node17 (Id); }\n \n-   INLINE L Non_Limited_Views (E Id)\n-      { return Elist8 (Id); }\n-\n    INLINE B Nonzero_Is_True (E Id)\n       { return Flag162 (Base_Type (Id)); }\n "}, {"sha": "8105de381d2b002c57dc811b3aceaf96ed72bdaf", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -98,15 +98,17 @@ package body Exp_Ch5 is\n    function Maybe_Bit_Aligned_Large_Component (N : Node_Id) return Boolean;\n    --  This function is used in processing the assignment of a record or\n    --  indexed component. The back end can handle such assignments fine\n-   --  if the object involved is small (64-bits) or if it is aligned on\n+   --  if the objects involved are small (64-bits) or are both aligned on\n    --  a byte boundary (starts on a byte, and ends on a byte). However,\n    --  problems arise for large components that are not byte aligned,\n-   --  since the assignment may clobber other components that share\n-   --  bit positions in the starting or ending bytes. This function is\n-   --  used to detect such situations, so that the assignment can be\n-   --  handled component-wise. A value of False means that either the\n-   --  object is known to be greater than 64 bits, or that it is known\n-   --  to be byte aligned. True is returned if the object is known to\n+   --  since the assignment may clobber other components that share bit\n+   --  positions in the starting or ending bytes, and in the case of\n+   --  components not starting on a byte boundary, the back end cannot\n+   --  even manage to extract the value. This function is used to detect\n+   --  such situations, so that the assignment can be handled component-wise.\n+   --  A value of False means that either the object is known to be greater\n+   --  than 64 bits, or that it is known to be byte aligned (and occupy an\n+   --  integral number of bytes. True is returned if the object is known to\n    --  be greater than 64 bits, and is known to be unaligned. As implied\n    --  by the name, the result is conservative, in that if the compiler\n    --  cannot determine these conditions at compile time, True is returned.\n@@ -368,6 +370,14 @@ package body Exp_Ch5 is\n          R_Type  := Get_Actual_Subtype (Act_Rhs);\n          Loop_Required := True;\n \n+      --  We require a loop if the left side is possibly bit unaligned\n+\n+      elsif Maybe_Bit_Aligned_Large_Component (Lhs)\n+              or else\n+            Maybe_Bit_Aligned_Large_Component (Rhs)\n+      then\n+         Loop_Required := True;\n+\n       --  Arrays with controlled components are expanded into a loop\n       --  to force calls to adjust at the component level.\n \n@@ -1016,7 +1026,10 @@ package body Exp_Ch5 is\n       --  clobbering of other components sharing bits in the first or\n       --  last byte of the component to be assigned.\n \n-      elsif Maybe_Bit_Aligned_Large_Component (Lhs) then\n+      elsif Maybe_Bit_Aligned_Large_Component (Lhs)\n+              or\n+            Maybe_Bit_Aligned_Large_Component (Rhs)\n+      then\n          null;\n \n       --  If neither condition met, then nothing special to do, the back end"}, {"sha": "0d203b6d289336f3ef37f544603e7ee4ea6c5294", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -922,10 +922,11 @@ package body Exp_Disp is\n \n       --        Register_Tag (Dt_Ptr);\n \n-      --  Skip this if routine not available\n+      --  Skip this if routine not available, or in No_Run_Time mode\n \n          if RTE_Available (RE_Register_Tag)\n            and then Is_RTE (Generalized_Tag, RE_Tag)\n+           and then not No_Run_Time_Mode\n          then\n             Append_To (Elab_Code,\n               Make_Procedure_Call_Statement (Loc,"}, {"sha": "0ac32c3dd9e4d51a88ae3c955bf5b4379126d26a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -124,7 +124,12 @@ package body Freeze is\n    --  a subprogram type (i.e. an access to a subprogram).\n \n    function Is_Fully_Defined (T : Entity_Id) return Boolean;\n-   --  true if T is not private, or has a full view.\n+   --  true if T is not private and has no private components, or has a full\n+   --  view. Used to determine whether the designated type of an access type\n+   --  should be frozen when the access type is frozen. This is done when an\n+   --  allocator is frozen, or an expression that may involve attributes of\n+   --  the designated type. Otherwise freezing the access type does not freeze\n+   --  the designated type.\n \n    procedure Process_Default_Expressions\n      (E     : Entity_Id;\n@@ -4246,15 +4251,38 @@ package body Freeze is\n    --  Is_Fully_Defined --\n    -----------------------\n \n-   --  Should this be in Sem_Util ???\n-\n    function Is_Fully_Defined (T : Entity_Id) return Boolean is\n    begin\n       if Ekind (T) = E_Class_Wide_Type then\n          return Is_Fully_Defined (Etype (T));\n-      else\n-         return not Is_Private_Type (T)\n-           or else Present (Full_View (Base_Type (T)));\n+\n+      elsif Is_Array_Type (T) then\n+         return Is_Fully_Defined (Component_Type (T));\n+\n+      elsif Is_Record_Type (T)\n+        and not Is_Private_Type (T)\n+      then\n+\n+         --  Verify that the record type has no components with\n+         --  private types without completion.\n+\n+         declare\n+            Comp : Entity_Id;\n+         begin\n+            Comp := First_Component (T);\n+\n+            while Present (Comp) loop\n+               if not Is_Fully_Defined (Etype (Comp)) then\n+                  return False;\n+               end if;\n+\n+               Next_Component (Comp);\n+            end loop;\n+            return True;\n+         end;\n+\n+      else return not Is_Private_Type (T)\n+        or else Present (Full_View (Base_Type (T)));\n       end if;\n    end Is_Fully_Defined;\n "}, {"sha": "f820e3a0a415479a243f8850310528a989c66700", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -190,6 +190,9 @@ extern void gnat_to_code\tPARAMS ((Node_Id));\n    code.  */\n extern tree gnat_to_gnu\t\tPARAMS ((Node_Id));\n \n+/* GNU_STMT is a statement.  We generate code for that statement.  */\n+extern void gnat_expand_stmt\tPARAMS ((tree));\n+\n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n@@ -201,6 +204,9 @@ extern void process_type\tPARAMS ((Entity_Id));\n    input_line.  If WRITE_NOTE_P is true, emit a line number note. */\n extern void set_lineno\t\tPARAMS ((Node_Id, int));\n \n+/* Likewise, but passed a Sloc.  */\n+extern void set_lineno_from_sloc PARAMS ((Source_Ptr, int));\n+\n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    \"&\" substitution.  */\n@@ -699,8 +705,8 @@ extern tree gnat_build_constructor PARAMS((tree, tree));\n \n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n-   for the field, or both.  */\n-extern tree build_component_ref\tPARAMS((tree, tree, tree));\n+   for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n+extern tree build_component_ref\tPARAMS((tree, tree, tree, int));\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,"}, {"sha": "dd5f98a5132aac515bd0edf80c29400f44aa60f6", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -26,6 +26,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -64,7 +65,9 @@ package body Itypes is\n       Set_Is_Itype (Typ);\n       Set_Associated_Node_For_Itype (Typ, Related_Nod);\n \n-      if In_Deleted_Code then\n+      if In_Deleted_Code\n+        and then not ASIS_Mode\n+      then\n          Set_Is_Frozen (Typ);\n       end if;\n "}, {"sha": "e0f5998f21f22b3a0c37ddc6aa2a13aad183b60c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -3623,10 +3623,12 @@ package body Make is\n                      if not At_Least_One_Main then\n \n                         --  First make sure that the binder and the linker\n-                        --  will not be invoked.\n+                        --  will not be invoked if -z is not used.\n \n-                        Do_Bind_Step := False;\n-                        Do_Link_Step := False;\n+                        if not No_Main_Subprogram then\n+                           Do_Bind_Step := False;\n+                           Do_Link_Step := False;\n+                        end if;\n \n                         --  Put all the sources in the queue\n "}, {"sha": "8d541e4d0b97a7f5853d851b29c4b4a941fd2a66", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -544,6 +544,13 @@ gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier)\n   tree new;\n   rtx result;\n \n+  /* If this is a statement, call the expansion routine for statements.  */\n+  if (IS_STMT (exp))\n+    {\n+      gnat_expand_stmt (exp);\n+      return const0_rtx;\n+    }\n+\n   /* Update EXP to be the new expression to expand.  */\n   switch (TREE_CODE (exp))\n     {"}, {"sha": "c7803048681174ebadee64218d2b8cd2552d9559", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 449, "deletions": 58, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -73,8 +73,10 @@ package body Sem_Ch10 is\n    --  Analyzes items in the context clause of compilation unit\n \n    procedure Build_Limited_Views (N : Node_Id);\n-   --  Build list of shadow entities for a package mentioned in a\n-   --  limited_with clause.\n+   --  Build and decorate the list of shadow entities for a package mentioned\n+   --  in a limited_with clause. If the package was not previously analyzed\n+   --  then it also performs a basic decoration of the real entities; this\n+   --  is required to do not pass non-decorated entities to the back-end.\n \n    procedure Check_Body_Needed_For_SAL (Unit_Name : Entity_Id);\n    --  Check whether the source for the body of a compilation unit must\n@@ -123,10 +125,13 @@ package body Sem_Ch10 is\n    --  Subsidiary to previous one. Process only with_ and use_clauses for\n    --  current unit and its library unit if any.\n \n+   procedure Install_Limited_Context_Clauses (N : Node_Id);\n+   --  Subsidiary to Install_Context. Process only limited with_clauses\n+   --  for current unit.\n+\n    procedure Install_Limited_Withed_Unit (N : Node_Id);\n    --  Place shadow entities for a limited_with package in the visibility\n-   --  structures for the current compilation. Verify that there is no\n-   --  regular with_clause in the context.\n+   --  structures for the current compilation.\n \n    procedure Install_Withed_Unit (With_Clause : Node_Id);\n    --  If the unit is not a child unit, make unit immediately visible.\n@@ -782,7 +787,7 @@ package body Sem_Ch10 is\n    begin\n       --  Loop through context items. This is done is three passes:\n       --  a) The first pass analyze non-limited with-clauses.\n-      --  b) The second pass add implicit limited_with clauses for the\n+      --  b) The second pass add implicit limited_with clauses for\n       --     the parents of child units.\n       --  c) The third pass analyzes limited_with clauses.\n \n@@ -792,7 +797,9 @@ package body Sem_Ch10 is\n          --  For with clause, analyze the with clause, and then update\n          --  the version, since we are dependent on a unit that we with.\n \n-         if Nkind (Item) = N_With_Clause then\n+         if Nkind (Item) = N_With_Clause\n+           and then not Limited_Present (Item)\n+         then\n \n             --  Skip analyzing with clause if no unit, nothing to do (this\n             --  happens for a with that references a non-existant unit)\n@@ -845,6 +852,11 @@ package body Sem_Ch10 is\n            and then Limited_Present (Item)\n          then\n \n+            if Nkind (Unit (N)) /= N_Package_Declaration then\n+               Error_Msg_N (\"limited with_clause only allowed in\"\n+                            & \" package specification\", Item);\n+            end if;\n+\n             --  Skip analyzing with clause if no unit, see above.\n \n             if Present (Library_Unit (Item)) then\n@@ -1239,6 +1251,7 @@ package body Sem_Ch10 is\n       Num_Scopes      : Int := 0;\n       Use_Clauses     : array (1 .. Scope_Stack.Last) of Node_Id;\n       Enclosing_Child : Entity_Id := Empty;\n+      Svg             : constant Suppress_Array := Scope_Suppress;\n \n       procedure Analyze_Subunit_Context;\n       --  Capture names in use clauses of the subunit. This must be done\n@@ -1482,6 +1495,10 @@ package body Sem_Ch10 is\n          Re_Install_Use_Clauses;\n          Install_Context (N);\n \n+         --  Restore state of suppress flags for current body.\n+\n+         Scope_Suppress := Svg;\n+\n          --  If the subunit is within a child unit, then siblings of any\n          --  parent unit that appear in the context clause of the subunit\n          --  must also be made immediately visible.\n@@ -2534,6 +2551,8 @@ package body Sem_Ch10 is\n          Install_Parents (Lib_Unit, Private_Present (Parent (Lib_Unit)));\n       end if;\n \n+      Install_Limited_Context_Clauses (N);\n+\n       Check_With_Type_Clauses (N);\n    end Install_Context;\n \n@@ -2548,7 +2567,6 @@ package body Sem_Ch10 is\n       Check_Private : Boolean := False;\n       Decl_Node     : Node_Id;\n       Lib_Parent    : Entity_Id;\n-      Lim_Present   : Boolean := False;\n \n    begin\n       --  Loop through context clauses to find the with/use clauses.\n@@ -2565,9 +2583,8 @@ package body Sem_Ch10 is\n          then\n             if Limited_Present (Item) then\n \n-               --  Second pass will be necessary\n+               --  Limited withed units will be installed later.\n \n-               Lim_Present := True;\n                goto Continue;\n \n             --  If Name (Item) is not an entity name, something is wrong, and\n@@ -2703,7 +2720,7 @@ package body Sem_Ch10 is\n \n       if Is_Child_Spec (Lib_Unit) then\n \n-         --  The unit also has implicit withs on its own parents.\n+         --  The unit also has implicit withs on its own parents\n \n          if No (Context_Items (N)) then\n             Set_Context_Items (N, New_List);\n@@ -2778,23 +2795,224 @@ package body Sem_Ch10 is\n       if Check_Private then\n          Check_Private_Child_Unit (N);\n       end if;\n+   end Install_Context_Clauses;\n \n-      --  Second pass: install limited_with clauses\n+   -------------------------------------\n+   -- Install_Limited_Context_Clauses --\n+   -------------------------------------\n \n-      if Lim_Present then\n-         Item := First (Context_Items (N));\n+   procedure Install_Limited_Context_Clauses (N : Node_Id) is\n+      Item : Node_Id;\n+\n+      procedure Check_Parent (P : Node_Id; W : Node_Id);\n+      --  Check that the unlimited view of a given compilation_unit is not\n+      --  already visible in the parents (neither immediately through the\n+      --  context clauses, nor indirectly through \"use + renamings\").\n+\n+      procedure Check_Private_Limited_Withed_Unit (N : Node_Id);\n+      --  Check that if a limited_with clause of a given compilation_unit\n+      --  mentions a private child of some library unit, then the given\n+      --  compilation_unit shall be the declaration of a private descendant\n+      --  of that library unit.\n+\n+      procedure Check_Withed_Unit (W : Node_Id);\n+      --  Check that a limited with_clause does not appear in the same\n+      --  context_clause as a nonlimited with_clause that mentions\n+      --  the same library.\n+\n+      --------------------\n+      --  Check_Parent  --\n+      --------------------\n+\n+      procedure Check_Parent (P : Node_Id; W : Node_Id) is\n+         Item   : Node_Id;\n+         Spec   : Node_Id;\n+         WEnt   : Entity_Id;\n+         Nam    : Node_Id;\n+         E      : Entity_Id;\n+         E2     : Entity_Id;\n \n+      begin\n+         pragma Assert (Nkind (W) = N_With_Clause);\n+\n+         --  Step 1: Check if the unlimited view is installed in the parent\n+\n+         Item := First (Context_Items (P));\n          while Present (Item) loop\n             if Nkind (Item) = N_With_Clause\n-              and then Limited_Present (Item)\n+              and then not Limited_Present (Item)\n+              and then not Implicit_With (Item)\n+              and then Library_Unit (Item) = Library_Unit (W)\n             then\n-               Install_Limited_Withed_Unit (Item);\n+               Error_Msg_N (\"unlimited view visible in ancestor\", W);\n+               return;\n             end if;\n \n             Next (Item);\n          end loop;\n-      end if;\n-   end Install_Context_Clauses;\n+\n+         --  Step 2: Check \"use + renamings\"\n+\n+         WEnt := Defining_Unit_Name (Specification (Unit (Library_Unit (W))));\n+         Spec := Specification (Unit (P));\n+\n+         --  We tried to traverse the list of entities corresponding to the\n+         --  defining entity of the package spec. However, first_entity was\n+         --  found to be 'empty'. Don't know why???\n+\n+         --          Def  := Defining_Unit_Name (Spec);\n+         --          Ent  := First_Entity (Def);\n+\n+         --  As a workaround we traverse the list of visible declarations ???\n+\n+         Item := First (Visible_Declarations (Spec));\n+         while Present (Item) loop\n+\n+            if Nkind (Item) = N_Use_Package_Clause then\n+\n+               --  Traverse the list of packages\n+\n+               Nam := First (Names (Item));\n+\n+               while Present (Nam) loop\n+                  E := Entity (Nam);\n+\n+                  pragma Assert (Present (Parent (E)));\n+\n+                  if Nkind (Parent (E))\n+                    = N_Package_Renaming_Declaration\n+                    and then Renamed_Entity (E) = WEnt\n+                  then\n+                     Error_Msg_N (\"unlimited view visible through \"\n+                                  & \"use_clause + renamings\", W);\n+                     return;\n+\n+                  elsif Nkind (Parent (E)) = N_Package_Specification then\n+\n+                     --  The use clause may refer to a local package.\n+                     --  Check all the enclosing scopes.\n+\n+                     E2 := E;\n+                     while E2 /= Standard_Standard\n+                       and then E2 /= WEnt loop\n+                        E2 := Scope (E2);\n+                     end loop;\n+\n+                     if E2 = WEnt then\n+                        Error_Msg_N (\"unlimited view visible through \"\n+                                     & \"use_clause \", W);\n+                        return;\n+                     end if;\n+\n+                  end if;\n+                  Next (Nam);\n+               end loop;\n+\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n+\n+         --  Recursive call to check all the ancestors\n+\n+         if Is_Child_Spec (Unit (P)) then\n+            Check_Parent (P => Parent_Spec (Unit (P)), W => W);\n+         end if;\n+      end Check_Parent;\n+\n+      ---------------------------------------\n+      -- Check_Private_Limited_Withed_Unit --\n+      ---------------------------------------\n+\n+      procedure Check_Private_Limited_Withed_Unit (N : Node_Id) is\n+         C     : Node_Id;\n+         P     : Node_Id;\n+         Found : Boolean := False;\n+\n+      begin\n+         --  If the current compilation unit is not private we don't\n+         --  need to check anything else.\n+\n+         if not Private_Present (Parent (N)) then\n+            Found := False;\n+\n+         else\n+            --  Compilation unit of the parent of the withed library unit\n+\n+            P := Parent_Spec (Unit (Library_Unit (N)));\n+\n+            --  Traverse all the ancestors of the current compilation\n+            --  unit to check if it is a descendant of named library unit.\n+\n+            C := Parent (N);\n+            while Present (Parent_Spec (Unit (C))) loop\n+               C := Parent_Spec (Unit (C));\n+\n+               if C = P then\n+                  Found := True;\n+                  exit;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         if not Found then\n+            Error_Msg_N (\"current unit is not a private descendant\"\n+                         & \" of the withed unit ('R'M 10.1.2(8)\", N);\n+         end if;\n+      end Check_Private_Limited_Withed_Unit;\n+\n+      -----------------------\n+      -- Check_Withed_Unit --\n+      -----------------------\n+\n+      procedure Check_Withed_Unit (W : Node_Id) is\n+         Item : Node_Id;\n+\n+      begin\n+         --  A limited with_clause can not appear in the same context_clause\n+         --  as a nonlimited with_clause which mentions the same library.\n+\n+         Item := First (Context_Items (N));\n+         while Present (Item) loop\n+            if Nkind (Item) = N_With_Clause\n+              and then not Limited_Present (Item)\n+              and then not Implicit_With (Item)\n+              and then Library_Unit (Item) = Library_Unit (W)\n+            then\n+               Error_Msg_N (\"limited and unlimited view \"\n+                            & \"not allowed in the same context clauses\", W);\n+               return;\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n+      end Check_Withed_Unit;\n+\n+   --  Start of processing for Install_Limited_Context_Clauses\n+\n+   begin\n+      Item := First (Context_Items (N));\n+      while Present (Item) loop\n+         if Nkind (Item) = N_With_Clause\n+           and then Limited_Present (Item)\n+         then\n+\n+            Check_Withed_Unit (Item);\n+\n+            if Private_Present (Library_Unit (Item)) then\n+               Check_Private_Limited_Withed_Unit (Item);\n+            end if;\n+\n+            if Is_Child_Spec (Unit (N)) then\n+               Check_Parent (Parent_Spec (Unit (N)), Item);\n+            end if;\n+\n+            Install_Limited_Withed_Unit (Item);\n+         end if;\n+\n+         Next (Item);\n+      end loop;\n+   end Install_Limited_Context_Clauses;\n \n    ---------------------\n    -- Install_Parents --\n@@ -2917,6 +3135,10 @@ package body Sem_Ch10 is\n       --  the current unit.\n       --  Shouldn't this be somewhere more general ???\n \n+      -----------------\n+      -- Is_Ancestor --\n+      -----------------\n+\n       function Is_Ancestor (E : Entity_Id) return Boolean is\n          Par : Entity_Id;\n \n@@ -3047,16 +3269,37 @@ package body Sem_Ch10 is\n          P := Defining_Identifier (P);\n       end if;\n \n+      --  A common usage of the limited-with is to have a limited-with\n+      --  in the package spec, and a normal with in its package body.\n+      --  For example:\n+\n+      --       limited with X;  -- [1]\n+      --       package A is ...\n+\n+      --       with X;          -- [2]\n+      --       package body A is ...\n+\n+      --  The compilation of A's body installs the entities of its\n+      --  withed packages (the context clauses found at [2]) and\n+      --  then the context clauses of its specification (found at [1]).\n+\n+      --  As a consequence, at point [1] the specification of X has been\n+      --  analyzed and it is immediately visible. According to the semantics\n+      --  of the limited-with context clauses we don't install the limited\n+      --  view because the full view of X supersedes its limited view.\n+\n       if Analyzed (Cunit (Unum))\n         and then Is_Immediately_Visible (P)\n       then\n-         --  disallow naming in a limited with clause a unit (or renaming\n-         --  thereof) that is mentioned in an enclosing normal with clause.\n-         Error_Msg_N (\"limited_with not allowed on unit already withed\", N);\n-\n          return;\n       end if;\n \n+      if Debug_Flag_I then\n+         Write_Str (\"install limited view of \");\n+         Write_Name (Chars (P));\n+         Write_Eol;\n+      end if;\n+\n       if not Analyzed (Cunit (Unum)) then\n          Set_Ekind (P, E_Package);\n          Set_Etype (P, Standard_Void_Type);\n@@ -3067,6 +3310,13 @@ package body Sem_Ch10 is\n          if Current_Entity (P) /= P then\n             Set_Homonym (P, Current_Entity (P));\n             Set_Current_Entity (P);\n+\n+            if Debug_Flag_I then\n+               Write_Str (\"   (homonym) chain \");\n+               Write_Name (Chars (P));\n+               Write_Eol;\n+            end if;\n+\n          end if;\n \n          if Is_Child_Package then\n@@ -3084,7 +3334,9 @@ package body Sem_Ch10 is\n                Set_Scope (P, Parent_Id);\n             end;\n          end if;\n+\n       else\n+\n          --  If the unit appears in a previous regular with_clause, the\n          --  regular entities must be unchained before the shadow ones\n          --  are made accessible.\n@@ -3099,6 +3351,7 @@ package body Sem_Ch10 is\n                Next_Entity (Ent);\n             end loop;\n          end;\n+\n       end if;\n \n       --  The package must be visible while the with_type clause is active,\n@@ -3116,6 +3369,13 @@ package body Sem_Ch10 is\n          if not In_Chain (Lim_Typ) then\n             Set_Homonym (Lim_Typ, Current_Entity (Lim_Typ));\n             Set_Current_Entity (Lim_Typ);\n+\n+            if Debug_Flag_I then\n+               Write_Str (\"   (homonym) chain \");\n+               Write_Name (Chars (Lim_Typ));\n+               Write_Eol;\n+            end if;\n+\n          end if;\n \n          Next_Elmt (Lim_Elmt);\n@@ -3125,6 +3385,7 @@ package body Sem_Ch10 is\n       --  accordingly, to uninstall it when the context is removed.\n \n       Set_Limited_View_Installed (N);\n+      Set_From_With_Type (P);\n    end Install_Limited_Withed_Unit;\n \n    -------------------------\n@@ -3136,6 +3397,13 @@ package body Sem_Ch10 is\n       P     : constant Entity_Id := Scope (Uname);\n \n    begin\n+\n+      if Debug_Flag_I then\n+         Write_Str (\"install withed unit \");\n+         Write_Name (Chars (Uname));\n+         Write_Eol;\n+      end if;\n+\n       --  We do not apply the restrictions to an internal unit unless\n       --  we are compiling the internal unit as a main unit. This check\n       --  is also skipped for dummy units (for missing packages).\n@@ -3308,6 +3576,13 @@ package body Sem_Ch10 is\n       --  Construct list of shadow entities and attach it to entity of\n       --  package that is mentioned in a limited_with clause.\n \n+      function New_Internal_Shadow_Entity\n+        (Kind       : Entity_Kind;\n+         Sloc_Value : Source_Ptr;\n+         Id_Char    : Character) return Entity_Id;\n+      --  This function is similar to New_Internal_Entity, except that the\n+      --  entity is not added to the scope's list of entities.\n+\n       ------------------------------\n       -- Decorate_Incomplete_Type --\n       ------------------------------\n@@ -3324,7 +3599,6 @@ package body Sem_Ch10 is\n          Set_Stored_Constraint         (E, No_Elist);\n          Set_Full_View                 (E, Empty);\n          Init_Size_Align               (E);\n-         Set_Has_Unknown_Discriminants (E);\n       end Decorate_Incomplete_Type;\n \n       --------------------------\n@@ -3374,22 +3648,54 @@ package body Sem_Ch10 is\n          Set_Etype (P, Standard_Void_Type);\n       end Decorate_Package_Specification;\n \n+      -------------------------\n+      -- New_Internal_Entity --\n+      -------------------------\n+\n+      function New_Internal_Shadow_Entity\n+        (Kind       : Entity_Kind;\n+         Sloc_Value : Source_Ptr;\n+         Id_Char    : Character) return Entity_Id\n+      is\n+         N : constant Entity_Id :=\n+               Make_Defining_Identifier (Sloc_Value,\n+                 Chars => New_Internal_Name (Id_Char));\n+\n+      begin\n+         Set_Ekind          (N, Kind);\n+         Set_Is_Internal    (N, True);\n+\n+         if Kind in Type_Kind then\n+            Init_Size_Align (N);\n+         end if;\n+\n+         return N;\n+      end New_Internal_Shadow_Entity;\n+\n       -----------------\n       -- Build_Chain --\n       -----------------\n \n+      --  Could use more comments below ???\n+\n       procedure Build_Chain (Spec : Node_Id; Scope : Entity_Id) is\n-         Decl : Node_Id;\n+         Decl          : Node_Id;\n+         Analyzed_Unit : Boolean := Analyzed (Cunit (Unum));\n+         Is_Tagged     : Boolean;\n \n       begin\n          Decl := First (Visible_Declarations (Spec));\n \n          while Present (Decl) loop\n             if Nkind (Decl) = N_Full_Type_Declaration then\n+               Is_Tagged :=\n+                  Nkind (Type_Definition (Decl)) = N_Record_Definition\n+                  and then Tagged_Present (Type_Definition (Decl));\n+\n                Comp_Typ := Defining_Identifier (Decl);\n \n-               if not Analyzed (Cunit (Unum)) then\n-                  if Tagged_Present (Type_Definition (Decl)) then\n+               if not Analyzed_Unit then\n+                  if Is_Tagged then\n                      Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n                   else\n                      Decorate_Incomplete_Type (Comp_Typ, Scope);\n@@ -3398,41 +3704,35 @@ package body Sem_Ch10 is\n \n                --  Create shadow entity for type\n \n-               Lim_Typ  := New_Internal_Entity\n+               Lim_Typ  := New_Internal_Shadow_Entity\n                  (Kind       => Ekind (Comp_Typ),\n-                  Scope_Id   => Scope,\n                   Sloc_Value => Sloc (Comp_Typ),\n                   Id_Char    => 'Z');\n \n                Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n                Set_Parent (Lim_Typ, Parent (Comp_Typ));\n                Set_From_With_Type (Lim_Typ);\n \n-               if Tagged_Present (Type_Definition (Decl)) then\n+               if Is_Tagged then\n                   Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n                else\n                   Decorate_Incomplete_Type (Lim_Typ, Scope);\n                end if;\n \n                Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n-\n-               --  Add each entity to the proper list\n-\n-               Append_Elmt (Comp_Typ, To => Non_Limited_Views (P));\n                Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n \n             elsif Nkind (Decl) = N_Private_Type_Declaration\n               and then Tagged_Present (Decl)\n             then\n                Comp_Typ := Defining_Identifier (Decl);\n \n-               if not Analyzed (Cunit (Unum)) then\n+               if not Analyzed_Unit then\n                   Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n                end if;\n \n-               Lim_Typ  := New_Internal_Entity\n+               Lim_Typ  := New_Internal_Shadow_Entity\n                  (Kind       => Ekind (Comp_Typ),\n-                  Scope_Id   => Scope,\n                   Sloc_Value => Sloc (Comp_Typ),\n                   Id_Char    => 'Z');\n \n@@ -3443,10 +3743,6 @@ package body Sem_Ch10 is\n                Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n \n                Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n-\n-               --  Add the entities to the proper list\n-\n-               Append_Elmt (Comp_Typ, To => Non_Limited_Views (P));\n                Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n \n             elsif Nkind (Decl) = N_Package_Declaration then\n@@ -3464,9 +3760,8 @@ package body Sem_Ch10 is\n                      Set_Scope (Comp_Typ, Scope);\n                   end if;\n \n-                  Lim_Typ  := New_Internal_Entity\n+                  Lim_Typ  := New_Internal_Shadow_Entity\n                     (Kind       => Ekind (Comp_Typ),\n-                     Scope_Id   => Scope,\n                      Sloc_Value => Sloc (Comp_Typ),\n                      Id_Char    => 'Z');\n \n@@ -3480,8 +3775,6 @@ package body Sem_Ch10 is\n                   --  Note: The non_limited_view attribute is not used\n                   --  for local packages.\n \n-                  --  Add the entities to the proper list.\n-                  Append_Elmt (Comp_Typ, To => Non_Limited_Views (P));\n                   Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n \n                   Build_Chain (Spec, Scope => Lim_Typ);\n@@ -3497,14 +3790,41 @@ package body Sem_Ch10 is\n    begin\n       pragma Assert (Limited_Present (N));\n \n-      --  Limited withed subprograms are not allowed. Therefore, we\n-      --  don't need to build the limited-view auxiliary chain.\n+      --  A library_item mentioned in a limited_with_clause shall be\n+      --  a package_declaration, not a subprogram_declaration,\n+      --  generic_declaration, generic_instantiation, or\n+      --  package_renaming_declaration\n \n-      if Nkind (Parent (P)) = N_Function_Specification\n-        or else Nkind (Parent (P)) = N_Procedure_Specification\n-      then\n-         return;\n-      end if;\n+      case Nkind (Unit (Library_Unit (N))) is\n+\n+         when N_Package_Declaration =>\n+            null;\n+\n+         when N_Subprogram_Declaration =>\n+            Error_Msg_N (\"subprograms not allowed in \"\n+                         & \"limited with_clauses\", N);\n+\n+         when N_Generic_Package_Declaration |\n+              N_Generic_Subprogram_Declaration =>\n+            Error_Msg_N (\"generics not allowed in \"\n+                         & \"limited with_clauses\", N);\n+\n+         when N_Package_Instantiation |\n+              N_Function_Instantiation |\n+              N_Procedure_Instantiation =>\n+            Error_Msg_N (\"generic instantiations not allowed in \"\n+                         & \"limited with_clauses\", N);\n+\n+         when N_Generic_Package_Renaming_Declaration |\n+              N_Generic_Procedure_Renaming_Declaration |\n+              N_Generic_Function_Renaming_Declaration =>\n+            Error_Msg_N (\"generic renamings not allowed in \"\n+                         & \"limited with_clauses\", N);\n+\n+         when others =>\n+            pragma Assert (False);\n+            null;\n+      end case;\n \n       --  Check if the chain is already built\n \n@@ -3516,7 +3836,6 @@ package body Sem_Ch10 is\n \n       Set_Ekind (P, E_Package);\n       Set_Limited_Views     (P, New_Elmt_List);\n-      Set_Non_Limited_Views (P, New_Elmt_List);\n       --  Set_Entity (Name (N), P);\n \n       --  Create the auxiliary chain\n@@ -3650,11 +3969,32 @@ package body Sem_Ch10 is\n       Unit_Name : Entity_Id;\n \n    begin\n+      --  We remove the context clauses in two phases: limited-views first\n+      --  and regular-views later (to maintain the stack model).\n \n-      --  Loop through context items and undo with_clauses and use_clauses.\n+      --  First Phase: Remove limited_with context clauses\n \n       Item := First (Context_Items (N));\n+      while Present (Item) loop\n+\n+         --  We are interested only in with clauses which got installed\n+         --  on entry.\n \n+         if Nkind (Item) = N_With_Clause\n+           and then Limited_Present (Item)\n+           and then Limited_View_Installed (Item)\n+         then\n+            Remove_Limited_With_Clause (Item);\n+\n+         end if;\n+\n+         Next (Item);\n+      end loop;\n+\n+      --  Second Phase: Loop through context items and undo regular\n+      --  with_clauses and use_clauses.\n+\n+      Item := First (Context_Items (N));\n       while Present (Item) loop\n \n          --  We are interested only in with clauses which got installed\n@@ -3664,7 +4004,7 @@ package body Sem_Ch10 is\n            and then Limited_Present (Item)\n            and then Limited_View_Installed (Item)\n          then\n-            Remove_Limited_With_Clause (Item);\n+            null;\n \n          elsif Nkind (Item) = N_With_Clause\n             and then Context_Installed (Item)\n@@ -3687,7 +4027,6 @@ package body Sem_Ch10 is\n \n          Next (Item);\n       end loop;\n-\n    end Remove_Context_Clauses;\n \n    --------------------------------\n@@ -3697,7 +4036,6 @@ package body Sem_Ch10 is\n    procedure Remove_Limited_With_Clause (N : Node_Id) is\n       P_Unit    : Entity_Id := Unit (Library_Unit (N));\n       P         : Entity_Id := Defining_Unit_Name (Specification (P_Unit));\n-\n       Lim_Elmt  : Elmt_Id;\n       Lim_Typ   : Entity_Id;\n \n@@ -3709,6 +4047,13 @@ package body Sem_Ch10 is\n          P := Defining_Identifier (P);\n       end if;\n \n+      if Debug_Flag_I then\n+         Write_Str (\"remove limited view of \");\n+         Write_Name (Chars (P));\n+         Write_Str (\" from visibility\");\n+         Write_Eol;\n+      end if;\n+\n       --  Remove all shadow entities from visibility\n \n       Lim_Elmt  := First_Elmt (Limited_Views (P));\n@@ -3720,6 +4065,11 @@ package body Sem_Ch10 is\n          Next_Elmt (Lim_Elmt);\n       end loop;\n \n+      --  Indicate that the limited view of the package is not installed\n+\n+      Set_From_With_Type (P, False);\n+      Set_Limited_View_Installed (N, False);\n+\n       --  If the exporting package has previously been analyzed, it\n       --  has appeared in the closure already and should be left alone.\n       --  Otherwise, remove package itself from visibility.\n@@ -3731,9 +4081,40 @@ package body Sem_Ch10 is\n          Set_Ekind (P, E_Void);\n          Set_Scope (P, Empty);\n          Set_Is_Immediately_Visible (P, False);\n-      end if;\n \n-      Set_Limited_View_Installed (N, False);\n+      else\n+\n+         --  Reinstall visible entities (entities removed from visibility in\n+         --  Install_Limited_Withed to install the shadow entities).\n+\n+         declare\n+            Ent : Entity_Id;\n+\n+         begin\n+            Ent := First_Entity (P);\n+            while Present (Ent) and then Ent /= First_Private_Entity (P) loop\n+\n+               --  Shadow entities have not been added to the list of\n+               --  entities associated to the package spec. Therefore we\n+               --  just have to re-chain all its visible entities.\n+\n+               if not Is_Class_Wide_Type (Ent) then\n+\n+                  Set_Homonym (Ent, Current_Entity (Ent));\n+                  Set_Current_Entity (Ent);\n+\n+                  if Debug_Flag_I then\n+                     Write_Str (\"   (homonym) chain \");\n+                     Write_Name (Chars (Ent));\n+                     Write_Eol;\n+                  end if;\n+\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+         end;\n+      end if;\n    end Remove_Limited_With_Clause;\n \n    --------------------\n@@ -3819,6 +4200,8 @@ package body Sem_Ch10 is\n          end if;\n       end Unchain;\n \n+      --  Start of Remove_With_Type_Clause\n+\n    begin\n       if Nkind (Name) = N_Selected_Component then\n          Typ := Entity (Selector_Name (Name));\n@@ -3882,8 +4265,9 @@ package body Sem_Ch10 is\n    begin\n \n       if Debug_Flag_I then\n-         Write_Str (\"remove withed unit \");\n+         Write_Str (\"remove unit \");\n          Write_Name (Chars (Unit_Name));\n+         Write_Str (\" from visibility\");\n          Write_Eol;\n       end if;\n \n@@ -3923,5 +4307,12 @@ package body Sem_Ch10 is\n             Set_Homonym (Prev, Homonym (E));\n          end if;\n       end if;\n+\n+      if Debug_Flag_I then\n+         Write_Str (\"   (homonym) unchain \");\n+         Write_Name (Chars (E));\n+         Write_Eol;\n+      end if;\n+\n    end Unchain;\n end Sem_Ch10;"}, {"sha": "09e9717f18bb1e4b615b7c3f10a4bc6ff399c57d", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -2332,8 +2332,15 @@ package body Sem_Ch12 is\n          return;\n \n       elsif Ekind (Gen_Unit) /= E_Generic_Package then\n-         Error_Msg_N\n-           (\"expect name of generic package in instantiation\", Gen_Id);\n+\n+         if From_With_Type (Gen_Unit) then\n+            Error_Msg_N\n+              (\"cannot instantiate a limited withed package\", Gen_Id);\n+         else\n+            Error_Msg_N\n+              (\"expect name of generic package in instantiation\", Gen_Id);\n+         end if;\n+\n          Restore_Env;\n          return;\n       end if;"}, {"sha": "3f249c5428f3d80d6b6e1567de87b6c88655d194", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -789,8 +789,14 @@ package body Sem_Ch8 is\n       end if;\n \n       if Etype (Old_P) = Any_Type then\n-            Error_Msg_N\n-             (\"expect package name in renaming\", Name (N));\n+         Error_Msg_N\n+           (\"expect package name in renaming\", Name (N));\n+\n+      elsif Ekind (Old_P) = E_Package\n+        and then From_With_Type (Old_P)\n+      then\n+         Error_Msg_N\n+           (\"limited withed package cannot be renamed\", Name (N));\n \n       elsif Ekind (Old_P) /= E_Package\n         and then not (Ekind (Old_P) = E_Generic_Package\n@@ -811,11 +817,6 @@ package body Sem_Ch8 is\n          Set_Ekind (New_P, E_Package);\n          Set_Etype (New_P, Standard_Void_Type);\n \n-      elsif Ekind (Old_P) = E_Package\n-        and then From_With_Type (Old_P)\n-      then\n-         Error_Msg_N (\"imported package cannot be renamed\", Name (N));\n-\n       else\n          --  Entities in the old package are accessible through the\n          --  renaming entity. The simplest implementation is to have\n@@ -3397,7 +3398,8 @@ package body Sem_Ch8 is\n             null;\n          else\n             Error_Msg_N\n-              (\"imported package can only be used to access imported type\",\n+              (\"limited withed package can only be used to access \"\n+               & \" incomplete types\",\n                 N);\n          end if;\n       end if;\n@@ -5285,7 +5287,7 @@ package body Sem_Ch8 is\n       Set_In_Use (P);\n \n       if From_With_Type (P) then\n-         Error_Msg_N (\"imported package cannot appear in use clause\", N);\n+         Error_Msg_N (\"limited withed package cannot appear in use clause\", N);\n       end if;\n \n       --  Find enclosing instance, if any."}, {"sha": "dda7d1d785e2b83d4bf0e05d6baab7392c3f2e66", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -2134,15 +2134,19 @@ package body Sem_Type is\n       if B1 = B2 then\n          return B1;\n \n-      elsif (T1 = Universal_Integer  and then Is_Integer_Type (T2))\n-        or else (T1 = Universal_Real and then Is_Real_Type (T2))\n-        or else (T1 = Any_Fixed      and then Is_Fixed_Point_Type (T2))\n+      elsif False\n+        or else (T1 = Universal_Integer and then Is_Integer_Type (T2))\n+        or else (T1 = Universal_Real    and then Is_Real_Type (T2))\n+        or else (T1 = Universal_Fixed   and then Is_Fixed_Point_Type (T2))\n+        or else (T1 = Any_Fixed         and then Is_Fixed_Point_Type (T2))\n       then\n          return B2;\n \n-      elsif (T2 = Universal_Integer  and then Is_Integer_Type (T1))\n-        or else (T2 = Universal_Real and then Is_Real_Type (T1))\n-        or else (T2 = Any_Fixed      and then Is_Fixed_Point_Type (T1))\n+      elsif False\n+        or else (T2 = Universal_Integer and then Is_Integer_Type (T1))\n+        or else (T2 = Universal_Real    and then Is_Real_Type (T1))\n+        or else (T2 = Universal_Fixed   and then Is_Fixed_Point_Type (T1))\n+        or else (T2 = Any_Fixed         and then Is_Fixed_Point_Type (T1))\n       then\n          return B1;\n "}, {"sha": "fe94742e6e3f90e95b7112e7699725dee32068c0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -573,7 +573,7 @@ package Sinfo is\n    --    and N_Extension_Aggregate nodes. This field is used during generic\n    --    processing to relate nodes in the original template to nodes in the\n    --    generic copy. It overlaps the Entity field, and is used to capture\n-   --    global references in the analyzed copy and place them in the template.\n+   --    global references in the analyzed copy and place them in the instance.\n    --    See description in Sem_Ch12 for further details on this usage.\n \n    --  At_End_Proc (Node1)"}, {"sha": "6ae6542c9b2861ca1d3ee18d236ee329bb1eca74", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2490,7 +2490,12 @@ package body Sprint is\n \n             else\n                if First_Name (Node) or else not Dump_Original_Only then\n-                  Write_Indent_Str (\"with \");\n+                  if Limited_Present (Node) then\n+                     Write_Indent_Str (\"limited with \");\n+                  else\n+                     Write_Indent_Str (\"with \");\n+                  end if;\n+\n                else\n                   Write_Str (\", \");\n                end if;"}, {"sha": "e5e953683920f9a96bb4673ab9bdf82fbcfa5b95", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -216,6 +216,10 @@ package body Switch.C is\n                Ptr := Ptr + 1;\n                Operating_Mode := Check_Semantics;\n \n+               if Tree_Output then\n+                  ASIS_Mode := True;\n+               end if;\n+\n             --  Processing for d switch\n \n             when 'd' =>\n@@ -638,7 +642,11 @@ package body Switch.C is\n             when 't' =>\n                Ptr := Ptr + 1;\n                Tree_Output := True;\n-               ASIS_Mode := True;\n+\n+               if Operating_Mode = Check_Semantics then\n+                  ASIS_Mode := True;\n+               end if;\n+\n                Back_Annotate_Rep_Info := True;\n \n             --  Processing for T switch"}, {"sha": "ff222603a8f3d587cb97be4c39b5616e4ce942fd", "filename": "gcc/ada/tb-alvms.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ftb-alvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ftb-alvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvms.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -89,6 +89,10 @@ typedef struct\n #define RA_UNKNOWN ((REG)~0)\n #define RA_STOP    ((REG)0)\n \n+/* Compute Procedure Value from a live Frame Pointer value.  */\n+#define PV_FOR(FP) \\\n+  ((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP);\n+\n /**********\n  * unwind *\n  **********/\n@@ -127,10 +131,7 @@ unwind (frame_state_t * fs)\n   if (fs->fp == 0)\n     return;\n \n-  if ((REG_AT (fs->fp) & 0x7) == 0)\n-    pv = *(PDSCDEF **)fs->fp;\n-  else\n-    pv = (PDSCDEF *) fs->fp;\n+  pv = PV_FOR (fs->fp);\n \n   if (pv == 0\n       || pv->pdsc$w_flags & PDSC$M_BASE_FRAME)\n@@ -190,18 +191,15 @@ unwind (frame_state_t * fs)\n }\n \n /* Structure representing a traceback entry in the tracebacks array to be\n-   filled by __gnat_backtrace below. This should match the declaration of\n-   Traceback_Entry in System.Traceback_Entries.\n+   filled by __gnat_backtrace below.\n \n    The use of a structure is motivated by the potential necessity of having\n    several fields to fill for each entry, for instance if later calls to VMS\n    system functions need more than just a mere PC to compute info on a frame\n    (e.g. for non-symbolic->symbolic translation purposes).  */\n-\n typedef struct {\n-  void * pc;  /* Address of the call instruction in the chain.  */\n-  void * sp;  /* Stack Pointer value at the point of this call.  */\n-  void * fp;  /* Frame Pointer value at the point of this call.  */\n+  void * pc;\n+  void * pv;\n } tb_entry_t;\n \n /********************\n@@ -249,8 +247,7 @@ __gnat_backtrace (array, size, exclude_min, exclude_max, skip_frames)\n \t  || frame_state.pc > exclude_max)\n \t{\n \t  tbe->pc = frame_state.pc;\n-\t  tbe->sp = frame_state.sp;\n-\t  tbe->fp = frame_state.fp;\n+\t  tbe->pv = PV_FOR (frame_state.fp);\n \t\n \t  cnt ++;\n \t  tbe ++;"}, {"sha": "0d4539f97465b143fcea71284bfa3743914bc2b8", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -243,9 +243,13 @@ gnat_to_code (gnat_node)\n \n   gnu_root = tree_transform (gnat_node);\n \n+  /* If we return a statement, generate code for it.  */\n+  if (IS_STMT (gnu_root))\n+    expand_expr_stmt (gnu_root);\n+\n   /* This should just generate code, not return a value.  If it returns\n      a value, something is wrong.  */\n-  if (gnu_root != error_mark_node)\n+  else if (gnu_root != error_mark_node)\n     gigi_abort (302);\n }\n \n@@ -997,7 +1001,9 @@ tree_transform (gnat_node)\n \t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, 0);\n \n \t    gnu_result\n-\t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field);\n+\t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field,\n+\t\t\t\t     (Nkind (Parent (gnat_node))\n+\t\t\t\t      == N_Attribute_Reference));\n \t  }\n \n \tif (gnu_result == 0)\n@@ -2058,8 +2064,6 @@ tree_transform (gnat_node)\n       gnu_rhs\n \t= maybe_unconstrained_array (gnat_to_gnu (Expression (gnat_node)));\n \n-      set_lineno (gnat_node, 1);\n-\n       /* If range check is needed, emit code to generate it */\n       if (Do_Range_Check (Expression (gnat_node)))\n \tgnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)));\n@@ -2071,10 +2075,12 @@ tree_transform (gnat_node)\n \t   && TREE_OVERFLOW (TYPE_SIZE (TREE_TYPE (gnu_lhs))))\n \t  || (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_rhs))) == INTEGER_CST\n \t      && TREE_OVERFLOW (TYPE_SIZE (TREE_TYPE (gnu_rhs)))))\n-\texpand_expr_stmt (build_call_raise (SE_Object_Too_Large));\n+\tgnu_result = build_call_raise (SE_Object_Too_Large);\n       else\n-\texpand_expr_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t   gnu_lhs, gnu_rhs));\n+\tgnu_result\n+\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\n+      gnu_result = build_nt (EXPR_STMT, gnu_result);\n       break;\n \n     case N_If_Statement:\n@@ -3168,7 +3174,7 @@ tree_transform (gnat_node)\n \t\t    = length == 1 ? gnu_subprog_call\n \t\t      : build_component_ref\n \t\t\t(gnu_subprog_call, NULL_TREE,\n-\t\t\t TREE_PURPOSE (scalar_return_list));\n+\t\t\t TREE_PURPOSE (scalar_return_list), 0);\n \t\t  int unchecked_conversion\n \t\t    = Nkind (gnat_actual) == N_Unchecked_Type_Conversion;\n \t\t  /* If the actual is a conversion, get the inner expression,\n@@ -3614,7 +3620,8 @@ tree_transform (gnat_node)\n \t\t\t(build_unary_op\n \t\t\t (INDIRECT_REF, NULL_TREE,\n \t\t\t  TREE_VALUE (gnu_except_ptr_stack)),\n-\t\t\t get_identifier (\"not_handled_by_others\"), NULL_TREE)),\n+\t\t\t get_identifier (\"not_handled_by_others\"), NULL_TREE,\n+\t\t\t 0)),\n \t\t\t integer_zero_node);\n \t\t}\n \n@@ -3643,7 +3650,7 @@ tree_transform (gnat_node)\n \t\t\t (build_unary_op\n \t\t\t  (INDIRECT_REF, NULL_TREE,\n \t\t\t   TREE_VALUE (gnu_except_ptr_stack)),\n-\t\t\t  get_identifier (\"import_code\"), NULL_TREE),\n+\t\t\t  get_identifier (\"import_code\"), NULL_TREE, 0),\n \t\t\t gnu_expr);\n \t\t  else\n \t\t    this_choice\n@@ -3664,7 +3671,7 @@ tree_transform (gnat_node)\n \t\t\t  (build_unary_op\n \t\t\t   (INDIRECT_REF, NULL_TREE,\n \t\t\t    TREE_VALUE (gnu_except_ptr_stack)),\n-\t\t\t   get_identifier (\"lang\"), NULL_TREE);\n+\t\t\t   get_identifier (\"lang\"), NULL_TREE, 0);\n \n \t\t      this_choice\n \t\t\t= build_binary_op\n@@ -4024,8 +4031,17 @@ tree_transform (gnat_node)\n \tgigi_abort (321);\n     }\n \n+  /* If the result is a statement, set needed flags and return it.  */\n+  if (IS_STMT (gnu_result))\n+    {\n+      TREE_TYPE (gnu_result) = void_type_node;\n+      TREE_THIS_VOLATILE (gnu_result) = TREE_SIDE_EFFECTS (gnu_result) = 1;\n+      TREE_SLOC (gnu_result) = Sloc (gnat_node);\n+      return gnu_result;\n+    }\n+\n   /* If the result is a constant that overflows, raise constraint error.  */\n-  if (TREE_CODE (gnu_result) == INTEGER_CST\n+  else if (TREE_CODE (gnu_result) == INTEGER_CST\n       && TREE_CONSTANT_OVERFLOW (gnu_result))\n     {\n       post_error (\"Constraint_Error will be raised at run-time?\", gnat_node);\n@@ -4137,6 +4153,25 @@ tree_transform (gnat_node)\n   return gnu_result;\n }\n \f\n+/* GNU_STMT is a statement.  We generate code for that statement.  */\n+\n+void\n+gnat_expand_stmt (gnu_stmt)\n+     tree gnu_stmt;\n+{\n+  set_lineno_from_sloc (TREE_SLOC (gnu_stmt), 1);\n+\n+  switch (TREE_CODE (gnu_stmt))\n+    {\n+    case EXPR_STMT:\n+      expand_expr_stmt (EXPR_STMT_EXPR (gnu_stmt));\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n /* Force references to each of the entities in packages GNAT_NODE with's\n    so that the debugging information for all of them are identical\n    in all clients.  Operate recursively on anything it with's, but check\n@@ -5407,6 +5442,16 @@ set_lineno (gnat_node, write_note_p)\n {\n   Source_Ptr source_location = Sloc (gnat_node);\n \n+  set_lineno_from_sloc (source_location, write_note_p);\n+}\n+\n+/* Likewise, but passed a Sloc.  */\n+\n+void\n+set_lineno_from_sloc (source_location, write_note_p)\n+     Source_Ptr source_location;\n+     int write_note_p;\n+{\n   /* If node not from source code, ignore.  */\n   if (source_location < 0)\n     return;"}, {"sha": "a474870922f4a8e70b1c61edf887d3c536a28125", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -2825,10 +2825,10 @@ convert_to_fat_pointer (type, expr)\n       else\n \texpr = build1 (INDIRECT_REF, TREE_TYPE (etype), expr);\n \n-      template = build_component_ref (expr, NULL_TREE, fields);\n+      template = build_component_ref (expr, NULL_TREE, fields, 0);\n       expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  TREE_CHAIN (fields)));\n+\t\t\t\t\t\t  TREE_CHAIN (fields), 0));\n     }\n   else\n     /* Otherwise, build the constructor for the template.  */\n@@ -2872,7 +2872,8 @@ convert_to_thin_pointer (type, expr)\n \n   /* We get the pointer to the data and use a NOP_EXPR to make it the\n      proper GCC type.  */\n-  expr = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (TREE_TYPE (expr)));\n+  expr\n+    = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (TREE_TYPE (expr)), 0);\n   expr = build1 (NOP_EXPR, type, expr);\n \n   return expr;\n@@ -2927,7 +2928,7 @@ convert (type, expr)\n \treturn TREE_VALUE (CONSTRUCTOR_ELTS (expr));\n       else\n \treturn convert (type, build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t   TYPE_FIELDS (etype)));\n+\t\t\t\t\t\t   TYPE_FIELDS (etype), 0));\n     }\n   else if (code == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n     {\n@@ -2977,7 +2978,7 @@ convert (type, expr)\n   if (ecode == RECORD_TYPE && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype)\n       && code != UNCONSTRAINED_ARRAY_TYPE)\n     return convert (type, build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t       TYPE_FIELDS (etype)));\n+\t\t\t\t\t       TYPE_FIELDS (etype), 0));\n \n   /* If converting to a type that contains a template, convert to the data\n      type and then build the template. */\n@@ -3051,7 +3052,7 @@ convert (type, expr)\n       expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t     build_component_ref (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\t  get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t  NULL_TREE));\n+\t\t\t\t\t\t  NULL_TREE, 0));\n       etype = TREE_TYPE (expr);\n       ecode = TREE_CODE (etype);\n       break;\n@@ -3146,7 +3147,7 @@ convert (type, expr)\n \t array and then convert it.  */\n       else if (TYPE_FAT_POINTER_P (etype))\n \texpr = build_component_ref (expr, get_identifier (\"P_ARRAY\"),\n-\t\t\t\t    NULL_TREE);\n+\t\t\t\t    NULL_TREE, 0);\n \n       return fold (convert_to_pointer (type, expr));\n \n@@ -3278,7 +3279,7 @@ maybe_unconstrained_array (exp)\n \t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t   NULL_TREE));\n+\t\t\t\t\t\t   NULL_TREE, 0));\n \t  TREE_READONLY (new) = TREE_STATIC (new) = TREE_READONLY (exp);\n \t  return new;\n \t}\n@@ -3306,12 +3307,13 @@ maybe_unconstrained_array (exp)\n \t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new)))\n \t    return\n \t      build_component_ref (new, NULL_TREE,\n-\t\t\t\t   TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new))));\n+\t\t\t\t   TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new))),\n+\t\t\t\t   0);\n \t}\n       else if (TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (exp)))\n \treturn\n \t  build_component_ref (exp, NULL_TREE,\n-\t\t\t       TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (exp))));\n+\t\t\t       TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (exp))), 0);\n       break;\n \n     default:\n@@ -3399,7 +3401,7 @@ unchecked_convert (type, expr, notrunc_p)\n       layout_type (rec_type);\n \n       expr = unchecked_convert (rec_type, expr, notrunc_p);\n-      expr = build_component_ref (expr, NULL_TREE, field);\n+      expr = build_component_ref (expr, NULL_TREE, field, 0);\n     }\n \n   /* Similarly for integral input type whose precision is not equal to its"}, {"sha": "3e90487d7111811602218775d91e855f65636d4f", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657a9dd94da7d0ea2a6488a1a1f404f86a82132c/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=657a9dd94da7d0ea2a6488a1a1f404f86a82132c", "patch": "@@ -50,7 +50,7 @@ static tree contains_null_expr\t\tPARAMS ((tree));\n static tree compare_arrays\t\tPARAMS ((tree, tree, tree));\n static tree nonbinary_modular_operation\tPARAMS ((enum tree_code, tree,\n \t\t\t\t\t\ttree, tree));\n-static tree build_simple_component_ref\tPARAMS ((tree, tree, tree));\n+static tree build_simple_component_ref\tPARAMS ((tree, tree, tree, int));\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -955,7 +955,8 @@ build_binary_op (op_code, result_type, left_operand, right_operand)\n \t       && integer_zerop (TREE_VALUE (CONSTRUCTOR_ELTS (right_operand))))\n \t{\n \t  right_operand = build_component_ref (left_operand, NULL_TREE,\n-\t\t\t\t\t       TYPE_FIELDS (left_base_type));\n+\t\t\t\t\t       TYPE_FIELDS (left_base_type),\n+\t\t\t\t\t       0);\n \t  left_operand = convert (TREE_TYPE (right_operand),\n \t\t\t\t  integer_zero_node);\n \t}\n@@ -1609,16 +1610,17 @@ gnat_build_constructor (type, list)\n \f\n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n-   for the field.\n+   for the field.  Don't fold the result if NO_FOLD_P is nonzero.\n \n    We also handle the fact that we might have been passed a pointer to the\n    actual record and know how to look for fields in variant parts.  */\n \n static tree\n-build_simple_component_ref (record_variable, component, field)\n+build_simple_component_ref (record_variable, component, field, no_fold_p)\n      tree record_variable;\n      tree component;\n      tree field;\n+     int no_fold_p;\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n   tree ref;\n@@ -1674,8 +1676,9 @@ build_simple_component_ref (record_variable, component, field)\n \t    {\n \t      tree field_ref\n \t\t= build_simple_component_ref (record_variable, \n-\t\t\t\t\t      NULL_TREE, new_field);\n-\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field);\n+\t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n+\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n+\t\t\t\t\t\tno_fold_p);\n \n \t      if (ref != 0)\n \t\treturn ref;\n@@ -1697,19 +1700,21 @@ build_simple_component_ref (record_variable, component, field)\n       || TYPE_VOLATILE (record_type))\n     TREE_THIS_VOLATILE (ref) = 1;\n \n-  return fold (ref);\n+  return no_fold_p ? ref : fold (ref);\n }\n \f\n /* Like build_simple_component_ref, except that we give an error if the\n    reference could not be found.  */\n \n tree\n-build_component_ref (record_variable, component, field)\n+build_component_ref (record_variable, component, field, no_fold_p)\n      tree record_variable;\n      tree component;\n      tree field;\n+     int no_fold_p;\n {\n-  tree ref = build_simple_component_ref (record_variable, component, field);\n+  tree ref = build_simple_component_ref (record_variable, component, field,\n+\t\t\t\t\t no_fold_p);\n \n   if (ref != 0)\n     return ref;\n@@ -1945,7 +1950,7 @@ build_allocator (type, init, result_type, gnat_proc, gnat_pool, gnat_node)\n \t    build_component_ref\n \t    (build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t     convert (storage_ptr_type, storage)),\n-\t     NULL_TREE, TYPE_FIELDS (storage_type)),\n+\t     NULL_TREE, TYPE_FIELDS (storage_type), 0),\n \t    build_template (template_type, type, NULL_TREE)),\n \t   convert (result_type, convert (storage_ptr_type, storage)));\n     }\n@@ -1990,7 +1995,7 @@ build_allocator (type, init, result_type, gnat_proc, gnat_pool, gnat_node)\n       result = convert (build_pointer_type (new_type), result);\n       result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n       result = build_component_ref (result, NULL_TREE,\n-\t\t\t\t    TYPE_FIELDS (new_type));\n+\t\t\t\t    TYPE_FIELDS (new_type), 0);\n       result = convert (result_type,\n \t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n     }"}]}