{"sha": "5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3YzcwNDYyNzJiODljMGI2ZTRiYzlmMDBhNjFlZGQ5ZTBmYjU3Yg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2001-07-03T06:22:01Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-03T06:22:01Z"}, "message": "Makefile.in (insn-recog.o): Add dependency on reload.h.\n\n\t* Makefile.in (insn-recog.o): Add dependency on reload.h.\n\n\t* genrecog.c (write_header): Include reload.h for prototypes in\n\tinsn-recog.c.\n\nFrom-SVN: r43722", "tree": {"sha": "cec08edf8891909adf0953fa9e9cb0181d82c1b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec08edf8891909adf0953fa9e9cb0181d82c1b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5f4be42801f710d636f26d1f4f18e7166eae3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f4be42801f710d636f26d1f4f18e7166eae3ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f4be42801f710d636f26d1f4f18e7166eae3ba"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "47ddeaa195706b1932b8e01cfbbca63f1355a2ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "patch": "@@ -1,3 +1,10 @@\n+2001-07-03  Andreas Jaeger  <aj@suse.de>\n+\n+\t* Makefile.in (insn-recog.o): Add dependency on reload.h.\n+\n+\t* genrecog.c (write_header): Include reload.h for prototypes in\n+\tinsn-recog.c.\n+\n 2001-07-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n config:"}, {"sha": "b6aaae0e2556d1cd524db5e24d46b7e8fcb8a890", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "patch": "@@ -1619,7 +1619,7 @@ s-emit : $(md_file) genemit$(build_exeext) $(srcdir)/move-if-change\n \n insn-recog.o : insn-recog.c $(CONFIG_H) $(RTL_H) insn-config.h $(RECOG_H) \\\n   real.h output.h flags.h $(SYSTEM_H) function.h hard-reg-set.h resource.h \\\n-  $(TM_P_H) toplev.h\n+  $(TM_P_H) toplev.h reload.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-recog.c\n \n insn-recog.c: s-recog ; @true"}, {"sha": "44be087074c0be8cad0df15f6edeef85131e74e9", "filename": "gcc/genrecog.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=5b7c7046272b89c0b6e4bc9f00a61edd9e0fb57b", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to recognize rtl as insns.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -73,7 +73,7 @@ struct decision_head\n   struct decision *first;\n   struct decision *last;\n };\n-    \n+\n /* A single test.  The two accept types aren't tests per-se, but\n    their equality (or lack thereof) does affect tree merging so\n    it is convenient to keep them here.  */\n@@ -88,7 +88,7 @@ struct decision_test\n     {\n       DT_mode, DT_code, DT_veclen,\n       DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,\n-      DT_veclen_ge, DT_dup, DT_pred, DT_c_test, \n+      DT_veclen_ge, DT_dup, DT_pred, DT_c_test,\n       DT_accept_op, DT_accept_insn\n     } type;\n \n@@ -295,7 +295,7 @@ static struct decision_head make_insn_sequence\n   PARAMS ((rtx, enum routine_type));\n static void process_tree\n   PARAMS ((struct decision_head *, enum routine_type));\n-  \n+\n static void record_insn_name\n   PARAMS ((int, const char *));\n \n@@ -570,7 +570,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t\t     && XSTR (pattern, 2)[0] != '+')\n \t      {\n \t\tmessage_with_line (pattern_lineno,\n-\t\t\t\t   \"operand %d missing output reload\", \n+\t\t\t\t   \"operand %d missing output reload\",\n \t\t\t\t   XINT (pattern, 0));\n \t\terror_count++;\n \t      }\n@@ -591,7 +591,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t/* A modeless MATCH_OPERAND can be handy when we can\n \t   check for multiple modes in the c_test.  In most other cases,\n \t   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT\n-\t   and PEEP2 can FAIL within the output pattern.  Exclude \n+\t   and PEEP2 can FAIL within the output pattern.  Exclude\n \t   address_operand, since its mode is related to the mode of\n \t   the memory not the operand.  Exclude the SET_DEST of a call\n \t   instruction, as that is a common idiom.  */\n@@ -659,7 +659,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t    error_count++;\n \t  }\n \n-\t/* If only one of the operands is VOIDmode, and PC or CC0 is \n+\t/* If only one of the operands is VOIDmode, and PC or CC0 is\n \t   not involved, it's probably a mistake.  */\n \telse if (dmode != smode\n \t\t && GET_CODE (dest) != PC\n@@ -1300,7 +1300,7 @@ nodes_identical_1 (d1, d2)\n }\n \n /* True iff the two nodes are identical (on one level only).  Due\n-   to the way these lists are constructed, we shouldn't have to \n+   to the way these lists are constructed, we shouldn't have to\n    consider different orderings on the tests.  */\n \n static int\n@@ -1336,7 +1336,7 @@ nodes_identical (d1, d2)\n /* A subroutine of merge_trees; given two nodes that have been declared\n    identical, cope with two insn accept states.  If they differ in the\n    number of clobbers, then the conflict was created by make_insn_sequence\n-   and we can drop the with-clobbers version on the floor.  If both \n+   and we can drop the with-clobbers version on the floor.  If both\n    nodes have no additional clobbers, we have found an ambiguity in the\n    source machine description.  */\n \n@@ -1424,7 +1424,7 @@ merge_trees (oldh, addh)\n \t that tests just the same mode.\n \n \t If we have no match, place NEW after the closest match we found.  */\n-\t \n+\n       for (old = oldh->last; old; old = old->prev)\n \t{\n \t  if (nodes_identical (old, add))\n@@ -1466,7 +1466,7 @@ merge_trees (oldh, addh)\n     }\n }\n \f\n-/* Walk the tree looking for sub-nodes that perform common tests.  \n+/* Walk the tree looking for sub-nodes that perform common tests.\n    Factor out the common test into a new node.  This enables us\n    (depending on the test type) to emit switch statements later.  */\n \n@@ -1488,7 +1488,7 @@ factor_tests (head)\n       if (next->tests->type != type)\n \tcontinue;\n \n-      /* Don't want all node types, just those we can turn into \n+      /* Don't want all node types, just those we can turn into\n \t switch statements.  */\n       if (type != DT_mode\n \t  && type != DT_code\n@@ -1506,7 +1506,7 @@ factor_tests (head)\n \t  new->tests = first->tests->next;\n \t  first->tests->next = NULL;\n \t}\n-\t\n+\n       /* Crop the node tree off after our first test.  */\n       first->next = NULL;\n       old_last = head->last;\n@@ -1623,7 +1623,7 @@ find_afterward (head, real_afterward)\n {\n   struct decision *p, *q, *afterward;\n \n-  /* We can't propogate alternatives across subroutine boundaries. \n+  /* We can't propogate alternatives across subroutine boundaries.\n      This is not incorrect, merely a minor optimization loss.  */\n \n   p = head->first;\n@@ -1636,7 +1636,7 @@ find_afterward (head, real_afterward)\n \tif (maybe_both_true (p, q, 1))\n \t  break;\n \n-      /* If we reached the end of the list without finding one, \n+      /* If we reached the end of the list without finding one,\n \t use the incoming afterward position.  */\n       if (!q)\n \tq = afterward;\n@@ -1698,12 +1698,12 @@ change_state (oldpos, newpos, afterward, indent)\n \t  /* We can only fail if we're moving down the tree.  */\n \t  if (old_has_insn >= 0 && oldpos[old_has_insn] >= newpos[depth])\n \t    {\n-\t      printf (\"%stem = peep2_next_insn (%d);\\n\", \n+\t      printf (\"%stem = peep2_next_insn (%d);\\n\",\n \t\t      indent, newpos[depth] - 'A');\n \t    }\n \t  else\n \t    {\n-\t      printf (\"%stem = peep2_next_insn (%d);\\n\", \n+\t      printf (\"%stem = peep2_next_insn (%d);\\n\",\n \t\t      indent, newpos[depth] - 'A');\n \t      printf (\"%sif (tem == NULL_RTX)\\n\", indent);\n \t      if (afterward)\n@@ -1752,7 +1752,7 @@ write_afterward (start, afterward, indent)\n     }\n }\n \n-/* Emit a switch statement, if possible, for an initial sequence of \n+/* Emit a switch statement, if possible, for an initial sequence of\n    nodes at START.  Return the first node yet untested.  */\n \n static struct decision *\n@@ -1786,7 +1786,7 @@ write_switch (start, depth)\n \n       printf (\"  switch (GET_CODE (x%d))\\n    {\\n\", depth);\n       code = p->tests->u.code;\n-      do \n+      do\n \t{\n \t  if (p != start && p->need_label && needs_label == NULL)\n \t    needs_label = p;\n@@ -2283,7 +2283,7 @@ write_subroutine (head, type)\n   const char *s_or_e;\n   char extension[32];\n   int i;\n-  \n+\n   s_or_e = subfunction ? \"static \" : \"\";\n \n   if (subfunction)\n@@ -2378,6 +2378,7 @@ write_header ()\n #include \\\"hard-reg-set.h\\\"\\n\\\n #include \\\"resource.h\\\"\\n\\\n #include \\\"toplev.h\\\"\\n\\\n+#include \\\"reload.h\\\"\\n\\\n \\n\");\n \n   puts (\"\\n\\\n@@ -2660,7 +2661,7 @@ main (argc, argv)\n \t  h = make_insn_sequence (desc, PEEPHOLE2);\n \t  merge_trees (&peephole2_tree, &h);\n \t}\n-\t\n+\n       next_index++;\n     }\n \n@@ -2703,7 +2704,7 @@ record_insn_name (code, name)\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n       insn_name_ptr =\n \t(char **) xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n-      memset (insn_name_ptr + insn_name_ptr_size, 0, \n+      memset (insn_name_ptr + insn_name_ptr_size, 0,\n \t      sizeof(char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;\n     }\n@@ -2718,9 +2719,9 @@ record_insn_name (code, name)\n       last_real_name = new = xstrdup (name);\n       last_real_code = code;\n     }\n-  \n+\n   insn_name_ptr[code] = new;\n-}  \n+}\n \f\n static void\n debug_decision_2 (test)\n@@ -2773,7 +2774,7 @@ debug_decision_2 (test)\n       fprintf (stderr, \"A_op=%d\", test->u.opno);\n       break;\n     case DT_accept_insn:\n-      fprintf (stderr, \"A_insn=(%d,%d)\", \n+      fprintf (stderr, \"A_insn=(%d,%d)\",\n \t       test->u.insn.code_number, test->u.insn.num_clobbers_to_add);\n       break;\n "}]}