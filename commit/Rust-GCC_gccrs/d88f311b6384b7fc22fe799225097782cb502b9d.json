{"sha": "d88f311b6384b7fc22fe799225097782cb502b9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg4ZjMxMWI2Mzg0YjdmYzIyZmU3OTkyMjUwOTc3ODJjYjUwMmI5ZA==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "2000-03-19T17:53:38Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "2000-03-19T17:53:38Z"}, "message": "Makefile.in (tree.o): Depend on HASHTAB_H.\n\n\t* Makefile.in (tree.o): Depend on HASHTAB_H.\n\t* tree.c: Include hashtab.h.\n\t(struct type_hash): Remove next field.\n\t(TYPE_HASH_SIZE): Remove.\n\t(TYPE_HASH_INITIAL_SIZE): New define.\n\t(type_hash_table): Change type to htab_t.\n\t(type_hash_eq, type_hash_hash, print_type_hash_statistics,\n\tmark_hash_entry): New functions.\n\t(init_obstacks): Allocate type hash.\n\t(type_hash_lookup): Use htab functions.\n\t(type_hash_add, mark_type_hash): Likewise.\n\t(dump_tree_statistics): Call print_type_hash_statistics.\n\nFrom-SVN: r32642", "tree": {"sha": "443856c449bc3cbdb93e910ddd5227d5d8e06c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/443856c449bc3cbdb93e910ddd5227d5d8e06c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d88f311b6384b7fc22fe799225097782cb502b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88f311b6384b7fc22fe799225097782cb502b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88f311b6384b7fc22fe799225097782cb502b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88f311b6384b7fc22fe799225097782cb502b9d/comments", "author": null, "committer": null, "parents": [{"sha": "e680248ee3883ade8e5ee164bf0c665ffb0a6067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e680248ee3883ade8e5ee164bf0c665ffb0a6067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e680248ee3883ade8e5ee164bf0c665ffb0a6067"}], "stats": {"total": 170, "additions": 116, "deletions": 54}, "files": [{"sha": "3dce7cf551d7d94bc3f3fbebc56d429a7bac1720", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d88f311b6384b7fc22fe799225097782cb502b9d", "patch": "@@ -1,3 +1,18 @@\n+2000-03-18  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* Makefile.in (tree.o): Depend on HASHTAB_H.\n+\t* tree.c: Include hashtab.h.\n+\t(struct type_hash): Remove next field.\n+\t(TYPE_HASH_SIZE): Remove.\n+\t(TYPE_HASH_INITIAL_SIZE): New define.\n+\t(type_hash_table): Change type to htab_t.\n+\t(type_hash_eq, type_hash_hash, print_type_hash_statistics,\n+\tmark_hash_entry): New functions.\n+\t(init_obstacks): Allocate type hash.\n+\t(type_hash_lookup): Use htab functions.\n+\t(type_hash_add, mark_type_hash): Likewise.\n+\t(dump_tree_statistics): Call print_type_hash_statistics.\n+\n 2000-03-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* rs6000/t-aix41: New file."}, {"sha": "6fa0873584b34eee9931b01fa10375598590323d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d88f311b6384b7fc22fe799225097782cb502b9d", "patch": "@@ -1476,7 +1476,7 @@ prefix.o: prefix.c $(CONFIG_H) system.h Makefile prefix.h\n convert.o: convert.c $(CONFIG_H) system.h $(TREE_H) flags.h convert.h toplev.h\n \n tree.o : tree.c $(CONFIG_H) system.h $(TREE_H) flags.h function.h toplev.h \\\n-   ggc.h\n+   ggc.h $(HASHTAB_H)\n print-tree.o : print-tree.c $(CONFIG_H) system.h $(TREE_H) ggc.h\n stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h ggc.h"}, {"sha": "9dbdeea04b3af06ed64d1b752a16ccbe7602e234", "filename": "gcc/tree.c", "status": "modified", "additions": 100, "deletions": 53, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88f311b6384b7fc22fe799225097782cb502b9d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d88f311b6384b7fc22fe799225097782cb502b9d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"hashtab.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -252,30 +253,34 @@ int (*lang_get_alias_set) PARAMS ((tree));\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)\n \n-/* Each hash table slot is a bucket containing a chain\n-   of these structures.  */\n+/* Since we cannot rehash a type after it is in the table, we have to\n+   keep the hash code.  */\n \n struct type_hash\n {\n-  struct type_hash *next;\t/* Next structure in the bucket.  */\n-  unsigned int hashcode;\t/* Hash code of this type.  */\n-  tree type;\t\t\t/* The type recorded here.  */\n+  unsigned long hash;\n+  tree type;\n };\n \n-/* Now here is the hash table.  When recording a type, it is added\n-   to the slot whose index is the hash code mod the table size.\n-   Note that the hash table is used for several kinds of types\n-   (function types, array types and array index range types, for now).\n-   While all these live in the same table, they are completely independent,\n-   and the hash code is computed differently for each of these.  */\n+/* Initial size of the hash table (rounded to next prime). */\n+#define TYPE_HASH_INITIAL_SIZE 1000\n \n-#define TYPE_HASH_SIZE 59\n-struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n+/* Now here is the hash table.  When recording a type, it is added to\n+   the slot whose index is the hash code.  Note that the hash table is\n+   used for several kinds of types (function types, array types and\n+   array index range types, for now).  While all these live in the\n+   same table, they are completely independent, and the hash code is\n+   computed differently for each of these.  */\n+\n+htab_t type_hash_table;\n \n static void build_real_from_int_cst_1 PARAMS ((PTR));\n static void set_type_quals PARAMS ((tree, int));\n static void append_random_chars PARAMS ((char *));\n static void mark_type_hash PARAMS ((void *));\n+static int type_hash_eq PARAMS ((const void*, const void*));\n+static unsigned int type_hash_hash PARAMS ((const void*));\n+static void print_type_hash_statistics PARAMS((void));\n \n /* If non-null, these are language-specific helper functions for\n    unsave_expr_now.  If present, LANG_UNSAVE is called before its\n@@ -328,11 +333,9 @@ init_obstacks ()\n   ggc_add_tree_root (hash_table, sizeof hash_table / sizeof (tree));\n \n   /* Initialize the hash table of types.  */\n-  bzero ((char *) type_hash_table,\n-\t sizeof type_hash_table / sizeof type_hash_table[0]);\n-  ggc_add_root (type_hash_table,\n-\t\tsizeof type_hash_table / sizeof type_hash_table [0],\n-\t\tsizeof type_hash_table[0], mark_type_hash);\n+  type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash, \n+\t\t\t\t type_hash_eq, 0);\n+  ggc_add_root (&type_hash_table, 1, sizeof type_hash_table, mark_type_hash);\n   ggc_add_tree_root (global_trees, TI_MAX);\n   ggc_add_tree_root (integer_types, itk_none);\n }\n@@ -3963,6 +3966,49 @@ type_hash_list (list)\n   return hashcode;\n }\n \n+/* These are the Hashtable callback functions.  */\n+\n+/* Returns true if the types are equal.  */\n+\n+static int\n+type_hash_eq (va, vb)\n+     const void *va;\n+     const void *vb;\n+{\n+  const struct type_hash *a = va, *b = vb;\n+  if (a->hash == b->hash\n+      && TREE_CODE (a->type) == TREE_CODE (b->type)\n+      && TREE_TYPE (a->type) == TREE_TYPE (b->type)\n+      && attribute_list_equal (TYPE_ATTRIBUTES (a->type),\n+\t\t\t       TYPE_ATTRIBUTES (b->type))\n+      && TYPE_ALIGN (a->type) == TYPE_ALIGN (b->type)\n+      && (TYPE_MAX_VALUE (a->type) == TYPE_MAX_VALUE (b->type)\n+\t  || tree_int_cst_equal (TYPE_MAX_VALUE (a->type),\n+\t\t\t\t TYPE_MAX_VALUE (b->type)))\n+      && (TYPE_MIN_VALUE (a->type) == TYPE_MIN_VALUE (b->type)\n+\t  || tree_int_cst_equal (TYPE_MIN_VALUE (a->type),\n+\t\t\t\t TYPE_MIN_VALUE (b->type)))\n+      /* Note that TYPE_DOMAIN is TYPE_ARG_TYPES for FUNCTION_TYPE.  */\n+      && (TYPE_DOMAIN (a->type) == TYPE_DOMAIN (b->type)\n+\t  || (TYPE_DOMAIN (a->type)\n+\t      && TREE_CODE (TYPE_DOMAIN (a->type)) == TREE_LIST\n+\t      && TYPE_DOMAIN (b->type)\n+\t      && TREE_CODE (TYPE_DOMAIN (b->type)) == TREE_LIST\n+\t      && type_list_equal (TYPE_DOMAIN (a->type),\n+\t\t\t\t  TYPE_DOMAIN (b->type)))))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return the cached hash value.  */\n+\n+static unsigned int\n+type_hash_hash (item)\n+     const void *item;\n+{\n+  return ((const struct type_hash*)item)->hash;\n+}\n+\n /* Look in the type hash table for a type isomorphic to TYPE.\n    If one is found, return it.  Otherwise return 0.  */\n \n@@ -3971,36 +4017,19 @@ type_hash_lookup (hashcode, type)\n      unsigned int hashcode;\n      tree type;\n {\n-  register struct type_hash *h;\n+  struct type_hash *h, in;\n \n   /* The TYPE_ALIGN field of a type is set by layout_type(), so we\n      must call that routine before comparing TYPE_ALIGNs. */\n   layout_type (type);\n \n-  for (h = type_hash_table[hashcode % TYPE_HASH_SIZE]; h; h = h->next)\n-    if (h->hashcode == hashcode\n-\t&& TREE_CODE (h->type) == TREE_CODE (type)\n-\t&& TREE_TYPE (h->type) == TREE_TYPE (type)\n-        && attribute_list_equal (TYPE_ATTRIBUTES (h->type),\n-\t\t\t\t   TYPE_ATTRIBUTES (type))\n-\t&& TYPE_ALIGN (h->type) == TYPE_ALIGN (type)\n-\t&& (TYPE_MAX_VALUE (h->type) == TYPE_MAX_VALUE (type)\n-\t    || tree_int_cst_equal (TYPE_MAX_VALUE (h->type),\n-\t\t\t\t   TYPE_MAX_VALUE (type)))\n-\t&& (TYPE_MIN_VALUE (h->type) == TYPE_MIN_VALUE (type)\n-\t    || tree_int_cst_equal (TYPE_MIN_VALUE (h->type),\n-\t\t\t\t   TYPE_MIN_VALUE (type)))\n-\t/* Note that TYPE_DOMAIN is TYPE_ARG_TYPES for FUNCTION_TYPE.  */\n-\t&& (TYPE_DOMAIN (h->type) == TYPE_DOMAIN (type)\n-\t    || (TYPE_DOMAIN (h->type)\n-\t\t&& TREE_CODE (TYPE_DOMAIN (h->type)) == TREE_LIST\n-\t\t&& TYPE_DOMAIN (type)\n-\t\t&& TREE_CODE (TYPE_DOMAIN (type)) == TREE_LIST\n-\t\t&& type_list_equal (TYPE_DOMAIN (h->type),\n-\t\t\t\t    TYPE_DOMAIN (type)))))\n-      return h->type;\n+  in.hash = hashcode;\n+  in.type = type;\n \n-  return 0;\n+  h = htab_find_with_hash (type_hash_table, &in, hashcode);\n+  if (h)\n+    return h->type;\n+  return NULL_TREE;\n }\n \n /* Add an entry to the type-hash-table\n@@ -4011,13 +4040,14 @@ type_hash_add (hashcode, type)\n      unsigned int hashcode;\n      tree type;\n {\n-  register struct type_hash *h;\n+  struct type_hash *h;\n+  void **loc;\n \n   h = (struct type_hash *) permalloc (sizeof (struct type_hash));\n-  h->hashcode = hashcode;\n+  h->hash = hashcode;\n   h->type = type;\n-  h->next = type_hash_table[hashcode % TYPE_HASH_SIZE];\n-  type_hash_table[hashcode % TYPE_HASH_SIZE] = h;\n+  loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, 1);\n+  *(struct type_hash**)loc = h;\n }\n \n /* Given TYPE, and HASHCODE its hash code, return the canonical\n@@ -4064,19 +4094,35 @@ type_hash_canon (hashcode, type)\n   return type;\n }\n \n-/* Mark ARG (which is really a struct type_hash **) for GC.  */\n+/* Callback function for htab_traverse.  */\n+\n+static int\n+mark_hash_entry (entry, param)\n+     void **entry;\n+     void *param ATTRIBUTE_UNUSED;\n+{\n+  struct type_hash *p = *(struct type_hash **)entry;\n+  ggc_mark_tree (p->type);\n+  /* Continue scan.  */\n+  return 1;\n+}\n+\n+/* Mark ARG (which is really a htab_t *) for GC.  */\n \n static void\n mark_type_hash (arg)\n      void *arg;\n {\n-  struct type_hash *t = *(struct type_hash **) arg;\n+  htab_t t = *(htab_t *) arg;\n+  htab_traverse (t, mark_hash_entry, 0);\n+}\n \n-  while (t)\n-    {\n-      ggc_mark_tree (t->type);\n-      t = t->next;\n-    }\n+static void\n+print_type_hash_statistics ()\n+{\n+  fprintf (stderr, \"Type hash: size %d, %d elements, %f collisions\\n\",\n+\t   htab_size (type_hash_table), htab_elements (type_hash_table),\n+\t   htab_collisions (type_hash_table));\n }\n \n /* Compute a hash code for a list of attributes (chain of TREE_LIST nodes\n@@ -5249,6 +5295,7 @@ dump_tree_statistics ()\n   print_obstack_statistics (\"temporary_obstack\", &temporary_obstack);\n   print_obstack_statistics (\"momentary_obstack\", &momentary_obstack);\n   print_obstack_statistics (\"temp_decl_obstack\", &temp_decl_obstack);\n+  print_type_hash_statistics ();\n   print_lang_statistics ();\n }\n \f"}]}