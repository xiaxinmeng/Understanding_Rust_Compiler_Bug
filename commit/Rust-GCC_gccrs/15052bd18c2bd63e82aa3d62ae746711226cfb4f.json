{"sha": "15052bd18c2bd63e82aa3d62ae746711226cfb4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwNTJiZDE4YzJiZDYzZTgyYWEzZDYyYWU3NDY3MTEyMjZjZmI0Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-12T13:38:38Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-12T13:38:38Z"}, "message": "Treat QImode addresses the same way GO_IF_LEGITIMATE_INDEX does.\n\nFrom-SVN: r30500", "tree": {"sha": "6d8b8fea1adac4f57fec99469b26af073b141c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d8b8fea1adac4f57fec99469b26af073b141c5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15052bd18c2bd63e82aa3d62ae746711226cfb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15052bd18c2bd63e82aa3d62ae746711226cfb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15052bd18c2bd63e82aa3d62ae746711226cfb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15052bd18c2bd63e82aa3d62ae746711226cfb4f/comments", "author": null, "committer": null, "parents": [{"sha": "e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e"}], "stats": {"total": 97, "additions": 51, "deletions": 46}, "files": [{"sha": "faf8e240dd2d9a4b2686ae4ee335275efd35243a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15052bd18c2bd63e82aa3d62ae746711226cfb4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15052bd18c2bd63e82aa3d62ae746711226cfb4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15052bd18c2bd63e82aa3d62ae746711226cfb4f", "patch": "@@ -1,3 +1,8 @@\n+Fri Nov 12 13:31:54 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* config/arm/arm.h (LEGITIMIZE_RELOAD_ADDRESS): Treat QImode\n+\taddresses the same way GO_IF_LEGITIMATE_INDEX does. \n+\n Fri Nov 12 12:36:04 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cse.c (hash_arg_in_struct): Delete."}, {"sha": "14e5293009ed4af9565ad09bdd3b4d6e24dfa34f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15052bd18c2bd63e82aa3d62ae746711226cfb4f/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15052bd18c2bd63e82aa3d62ae746711226cfb4f/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=15052bd18c2bd63e82aa3d62ae746711226cfb4f", "patch": "@@ -1015,52 +1015,52 @@ enum reg_class\n    For the ARM, we wish to handle large displacements off a base\n    register by splitting the addend across a MOV and the mem insn.\n    This can cut the number of reloads needed. */\n-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\t\\\n-\t  && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n-\t  && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\t\t\\\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\t\\\n-\t  HOST_WIDE_INT low, high;\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\t\\\n-\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\t\t\\\n-\t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\t\t\\\n-\t  else if (MODE == SImode || MODE == QImode\t\t\t\t\t\\\n-\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\t\\\n-\t\t   || (MODE == HImode && ! arm_arch4))\t\t\t\t\t\\\n-\t    /* Need to be careful, -4096 is not a valid offset */\t\t\t\\\n-\t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\t\t\\\n-\t  else if (MODE == HImode && arm_arch4)\t\t\t\t\t\t\\\n-\t    /* Need to be careful, -256 is not a valid offset */\t\t\t\\\n-\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\t\t\\\n-\t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\t\\\n-\t\t   && TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n-\t    /* Need to be careful, -1024 is not a valid offset */\t\t\t\\\n-\t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\t\\\n-\t  high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\t\\\n-\t  /* Check for overflow or zero */\t\t\t\t\t\t\\\n-\t  if (low == 0 || high == 0 || (high + low != val))\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\t\\\n-\t  /* Reload the high part into a base reg; leave the low part\t\t\t\\\n-\t     in the mem.  */\t\t\t\t\t\t\t\t\\\n-\t  X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\t\\\n-\t\t\t    gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\t\t\\\n-\t\t\t\t\t  GEN_INT (high)),\t\t\t\t\\\n-\t\t\t    GEN_INT (low));\t\t\t\t\t\t\\\n-\t  push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\t\t\\\n-\t\t       BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\t\t\\\n-\t\t       OPNUM, TYPE);\t\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\t\t\\\n+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+\t  && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+\t  && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\t\\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n+\t  HOST_WIDE_INT low, high;\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\\\n+\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\t\\\n+\t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\t\\\n+\t  else if (MODE == SImode\t\t\t\t\t\t\\\n+\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\\\n+\t\t   || ((MODE == HImode || MODE == QImode) && ! arm_arch4))\t\\\n+\t    /* Need to be careful, -4096 is not a valid offset */\t\t\\\n+\t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\t\\\n+\t  else if ((MODE == HImode || MODE == QImode) && arm_arch4)\t\t\\\n+\t    /* Need to be careful, -256 is not a valid offset */\t\t\\\n+\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\t\\\n+\t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+\t\t   && TARGET_HARD_FLOAT)\t\t\t\t\t\\\n+\t    /* Need to be careful, -1024 is not a valid offset */\t\t\\\n+\t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\\\n+\t  high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\\\n+\t  /* Check for overflow or zero */\t\t\t\t\t\\\n+\t  if (low == 0 || high == 0 || (high + low != val))\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\\\n+\t  /* Reload the high part into a base reg; leave the low part\t\t\\\n+\t     in the mem.  */\t\t\t\t\t\t\t\\\n+\t  X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n+\t\t\t    gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\t\\\n+\t\t\t\t\t  GEN_INT (high)),\t\t\t\\\n+\t\t\t    GEN_INT (low));\t\t\t\t\t\\\n+\t  push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\t\\\n+\t\t       BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\t\\\n+\t\t       OPNUM, TYPE);\t\t\t\t\t\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n /* Return the maximum number of consecutive registers"}]}