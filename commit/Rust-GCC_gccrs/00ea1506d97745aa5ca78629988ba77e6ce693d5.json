{"sha": "00ea1506d97745aa5ca78629988ba77e6ce693d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlYTE1MDZkOTc3NDVhYTVjYTc4NjI5OTg4YmE3N2U2Y2U2OTNkNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-10-13T13:04:51Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-10-13T13:04:51Z"}, "message": "[ARM] Remove redundant TARGET_VFP\n\n\t* arm.h (TARGET_VFP): Delete.\n\t(TARGET_VFPD32): Remove references to TARGET_VFP.\n\t(TARGET_VFP3, TARGET_VFP5): Likewise.\n\t(TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE): Likewise.\n\t(TARGET_NEON_FP16): Likewise.\n\t(TARGET_FMA): Likewise.\n\t(TARGET_CRYPTO): Likewise.\n\t(TARGET_NEON): Likewise.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n\t(FUNCTION_ARG_REGNO_P): Likewise.\n\t* arm.c (arm_option_check_internal): Likewise.\n\t(arm_option_override): Likewise.\n\t(use_return_insn): Likewise.\n\t(arm_function_value_regno_p): Likewise.\n\t(arm_apply_result_size): Likewise.\n\t(use_vfp_abi): Likewise.\n\t(arm_legitimate_address_outer_p): Likewise.\n\t(thumb2_legitimate_address_p): Likewise.\n\t(arm_legitimate_index_p): Likewise.\n\t(thumb2_legitimate_index_p): Likewise.\n\t(arm_legitimate_address): Likewise.\n\t(arm_get_vfp_saved_size): Likewise.\n\t(arm_emit_vfp_multi_reg_pop): Likewise.\n\t(arm_get_frame_offsets): Likewise.\n\t(arm_save_coproc_regs): Likewise.\n\t(arm_hard_regno_mode_ok): Likewise.\n\t(arm_expand_epilogue_apcs_frame): Likewise.\n\t(arm_expand_epilogue): Likewise.\n\t(arm_file_start): Likewise.\n\t(arm_conditional_register_usage): Likewise.\n\t(arm_validize_comparison): Use vfp_compare_operand directly.\n\t* arm-builtins.c (arm_init_builtins): Remove references to TARGET_VFP.\n\t(arm_expand_vfp_builtin): Use TARGET_HARD_FLOAT for detecting\n\tunsupported usage.\n\t(arm_atomic_assign_expand_fenv): Likewise.\n\t* arm.md (divsf3): Likewise.\n\t(arm_negsi2): Likewise.\n\t(absdf2): Likewise.\n\t(arm_movdi): Likewise.\n\t(arm_movt): Likewise.\n\t(cbranchsf4): Change predicate to vfp_compare_operand.\n\t(cbranchdf4): Change predicate to vfp_compare_operand.\n\t(cstorehf4): Change predicate to vfp_compare_operand.\n\t(cstoresf4): Change predicate to vfp_compare_operand.\n\t(cstoredf4): Change predicate to vfp_compare_operand.\n\t(vfp_pop_multiple_with_writeback): Remove references to TARGET_VFP.\n\t(movhi_insn_arch4, movhi_bytes): Likewise.\n\t* constraints.md (Dt): Likewise.\n\t(Dp): Likewise.\n\t* iterators.md (SDF): Likewise.\n\t* predicates.md (arm_float_compare_operand): Delete.\n\t(const_double_vcvt_power_of_two_reciprocal): Remove references to\n\tTARGET_VFP.\n\t(const_double_vcvt_power_of_two): Likewise.\n\t* thumb2.md thumb2_movsi_insn): Likewise.\n\t* vfp.md (arm_movhi_vfp, thumb2_movhi_vfp): Likewise.\n\t(movhf_vfp): Likewise.\n\t(arm_movsi_vfp, thumb2_movsi_vfp): Likewise.\n\t(movdi_vfp, movdi_vfp_cortexa8): Likewise.\n\t(movsf_vfp, thumb2_movsf_vfp): Likewise.\n\t(movdf_vfp, thumb2_movdf_vfp): Likewise.\n\t(movsfcc_vfp, abssf2_vfp, negsf2_vfp, addsf3_vfp): Likewise.\n\t(subsf3_vfp, divsf3_vfp): Likewise.\n\t(mulsf3_vfp, mulsf3negsf_vfp, negmulsf3_vfp): Likewise.\n\t(mulsf3addsf_vfp, (mulsf3subsf_vfp, mulsf3negsfaddsf_vfp): Likewise.\n\t(mulsf3negsfsubsf_vfp): Likewise.\n\t(truncsisf2_vfp, fixuns_truncsfsi2, floatsisf2_vfp): Likewise.\n\t(floatunssisf2, sqrtsf2_vfp): Likewise.\n\t(movcc_vfp): Likewise.\n\t(cmpsf_split_vfp, cmpsf_trap_split_vfp): Likewise.\n\t(cmpsf_vfp, cmpsf_trap_vfp): Likewise.\n\t(push_multi_vfp): Likewise.\n\t(set_fpscr, get_fpscr): Likewise.\n\t* arm-c.c (arm_cpu_builtins): Unconditionally define __VFP_FP__.\n\nFrom-SVN: r241118", "tree": {"sha": "e4670771fe9a4362757d2b179f64828c5af147a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4670771fe9a4362757d2b179f64828c5af147a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00ea1506d97745aa5ca78629988ba77e6ce693d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ea1506d97745aa5ca78629988ba77e6ce693d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00ea1506d97745aa5ca78629988ba77e6ce693d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ea1506d97745aa5ca78629988ba77e6ce693d5/comments", "author": null, "committer": null, "parents": [{"sha": "ec2255295c35008f5f39c9a79d5f342416ce6e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2255295c35008f5f39c9a79d5f342416ce6e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2255295c35008f5f39c9a79d5f342416ce6e86"}], "stats": {"total": 327, "additions": 191, "deletions": 136}, "files": [{"sha": "bf15ecc18aae63993598180a626433d3c9d7a007", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -1,3 +1,80 @@\n+2016-10-13  Richard Earsnhaw  <rearnsha@arm.com>\n+\n+\t* arm.h (TARGET_VFP): Delete.\n+\t(TARGET_VFPD32): Remove references to TARGET_VFP.\n+\t(TARGET_VFP3, TARGET_VFP5): Likewise.\n+\t(TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE): Likewise.\n+\t(TARGET_NEON_FP16): Likewise.\n+\t(TARGET_FMA): Likewise.\n+\t(TARGET_CRYPTO): Likewise.\n+\t(TARGET_NEON): Likewise.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n+\t(FUNCTION_ARG_REGNO_P): Likewise.\n+\t* arm.c (arm_option_check_internal): Likewise.\n+\t(arm_option_override): Likewise.\n+\t(use_return_insn): Likewise.\n+\t(arm_function_value_regno_p): Likewise.\n+\t(arm_apply_result_size): Likewise.\n+\t(use_vfp_abi): Likewise.\n+\t(arm_legitimate_address_outer_p): Likewise.\n+\t(thumb2_legitimate_address_p): Likewise.\n+\t(arm_legitimate_index_p): Likewise.\n+\t(thumb2_legitimate_index_p): Likewise.\n+\t(arm_legitimate_address): Likewise.\n+\t(arm_get_vfp_saved_size): Likewise.\n+\t(arm_emit_vfp_multi_reg_pop): Likewise.\n+\t(arm_get_frame_offsets): Likewise.\n+\t(arm_save_coproc_regs): Likewise.\n+\t(arm_hard_regno_mode_ok): Likewise.\n+\t(arm_expand_epilogue_apcs_frame): Likewise.\n+\t(arm_expand_epilogue): Likewise.\n+\t(arm_file_start): Likewise.\n+\t(arm_conditional_register_usage): Likewise.\n+\t(arm_validize_comparison): Use vfp_compare_operand directly.\n+\t* arm-builtins.c (arm_init_builtins): Remove references to TARGET_VFP.\n+\t(arm_expand_vfp_builtin): Use TARGET_HARD_FLOAT for detecting\n+\tunsupported usage.\n+\t(arm_atomic_assign_expand_fenv): Likewise.\n+\t* arm.md (divsf3): Likewise.\n+\t(arm_negsi2): Likewise.\n+\t(absdf2): Likewise.\n+\t(arm_movdi): Likewise.\n+\t(arm_movt): Likewise.\n+\t(cbranchsf4): Change predicate to vfp_compare_operand.\n+\t(cbranchdf4): Change predicate to vfp_compare_operand.\n+\t(cstorehf4): Change predicate to vfp_compare_operand.\n+\t(cstoresf4): Change predicate to vfp_compare_operand.\n+\t(cstoredf4): Change predicate to vfp_compare_operand.\n+\t(vfp_pop_multiple_with_writeback): Remove references to TARGET_VFP.\n+\t(movhi_insn_arch4, movhi_bytes): Likewise.\n+\t* constraints.md (Dt): Likewise.\n+\t(Dp): Likewise.\n+\t* iterators.md (SDF): Likewise.\n+\t* predicates.md (arm_float_compare_operand): Delete.\n+\t(const_double_vcvt_power_of_two_reciprocal): Remove references to\n+\tTARGET_VFP.\n+\t(const_double_vcvt_power_of_two): Likewise.\n+\t* thumb2.md thumb2_movsi_insn): Likewise.\n+\t* vfp.md (arm_movhi_vfp, thumb2_movhi_vfp): Likewise.\n+\t(movhf_vfp): Likewise.\n+\t(arm_movsi_vfp, thumb2_movsi_vfp): Likewise.\n+\t(movdi_vfp, movdi_vfp_cortexa8): Likewise.\n+\t(movsf_vfp, thumb2_movsf_vfp): Likewise.\n+\t(movdf_vfp, thumb2_movdf_vfp): Likewise.\n+\t(movsfcc_vfp, abssf2_vfp, negsf2_vfp, addsf3_vfp): Likewise.\n+\t(subsf3_vfp, divsf3_vfp): Likewise.\n+\t(mulsf3_vfp, mulsf3negsf_vfp, negmulsf3_vfp): Likewise.\n+\t(mulsf3addsf_vfp, (mulsf3subsf_vfp, mulsf3negsfaddsf_vfp): Likewise.\n+\t(mulsf3negsfsubsf_vfp): Likewise.\n+\t(truncsisf2_vfp, fixuns_truncsfsi2, floatsisf2_vfp): Likewise.\n+\t(floatunssisf2, sqrtsf2_vfp): Likewise.\n+\t(movcc_vfp): Likewise.\n+\t(cmpsf_split_vfp, cmpsf_trap_split_vfp): Likewise.\n+\t(cmpsf_vfp, cmpsf_trap_vfp): Likewise.\n+\t(push_multi_vfp): Likewise.\n+\t(set_fpscr, get_fpscr): Likewise.\n+\t* arm-c.c (arm_cpu_builtins): Unconditionally define __VFP_FP__.\n+\n 2016-10-13  Richard Earsnhaw  <rearnsha@arm.com>\n \n \t* arm.h (TARGET_VFP): Unconditionally define to 1."}, {"sha": "cbc17944e24a2df96d12adc5581577f03e470856", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -243,15 +243,15 @@ typedef struct {\n \n /* The NEON builtin data can be found in arm_neon_builtins.def and\n    arm_vfp_builtins.def.  The entries in arm_neon_builtins.def require\n-   TARGET_NEON to be true.  The entries in arm_vfp_builtins.def require\n-   TARGET_VFP to be true.  The feature tests are checked when the builtins are\n-   expanded.\n+   TARGET_NEON to be true.  The feature tests are checked when the\n+   builtins are expanded.\n \n-   The mode entries in the following table correspond to\n-   the \"key\" type of the instruction variant, i.e. equivalent to that which\n-   would be specified after the assembler mnemonic, which usually refers to the\n-   last vector operand.  The modes listed per instruction should be the same as\n-   those defined for that instruction's pattern in neon.md.  */\n+   The mode entries in the following table correspond to the \"key\"\n+   type of the instruction variant, i.e. equivalent to that which\n+   would be specified after the assembler mnemonic, which usually\n+   refers to the last vector operand.  The modes listed per\n+   instruction should be the same as those defined for that\n+   instruction's pattern in neon.md.  */\n \n static neon_builtin_datum vfp_builtin_data[] =\n {\n@@ -1817,7 +1817,7 @@ arm_init_builtins (void)\n   if (TARGET_CRC32)\n     arm_init_crc32_builtins ();\n \n-  if (TARGET_VFP && TARGET_HARD_FLOAT)\n+  if (TARGET_HARD_FLOAT)\n     {\n       tree ftype_set_fpscr\n \t= build_function_type_list (void_type_node, unsigned_type_node, NULL);\n@@ -2357,14 +2357,14 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n   return arm_expand_neon_builtin_1 (fcode, exp, target, d);\n }\n \n-/* Expand a VFP builtin, if TARGET_VFP is true.  These builtins are treated like\n+/* Expand a VFP builtin.  These builtins are treated like\n    neon builtins except that the data is looked up in table\n    VFP_BUILTIN_DATA.  */\n \n static rtx\n arm_expand_vfp_builtin (int fcode, tree exp, rtx target)\n {\n-  if (fcode >= ARM_BUILTIN_VFP_BASE && ! TARGET_VFP)\n+  if (fcode >= ARM_BUILTIN_VFP_BASE && ! TARGET_HARD_FLOAT)\n     {\n       fatal_error (input_location,\n \t\t   \"You must enable VFP instructions\"\n@@ -3078,7 +3078,7 @@ arm_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n   tree new_fenv_var, reload_fenv, restore_fnenv;\n   tree update_call, atomic_feraiseexcept, hold_fnclex;\n \n-  if (!TARGET_VFP || !TARGET_HARD_FLOAT)\n+  if (!TARGET_HARD_FLOAT)\n     return;\n \n   /* Generate the equivalent of :"}, {"sha": "a6fc60b0e44896d5d626026e54ec9fe0004ce386", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -128,7 +128,7 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   if (TARGET_SOFT_FLOAT)\n     builtin_define (\"__SOFTFP__\");\n \n-  def_or_undef_macro (pfile, \"__VFP_FP__\", TARGET_VFP);\n+  builtin_define (\"__VFP_FP__\");\n \n   if (TARGET_ARM_FP)\n     builtin_define_with_int_value (\"__ARM_FP\", TARGET_ARM_FP);"}, {"sha": "39e3aa85c0cc1d42b0c58dda143513feb248827e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -2814,8 +2814,8 @@ arm_option_check_internal (struct gcc_options *opts)\n   const struct arm_fpu_desc *fpu_desc = &all_fpus[opts->x_arm_fpu_index];\n \n   /* iWMMXt and NEON are incompatible.  */\n-    if (TARGET_IWMMXT && TARGET_VFP\n-      && ARM_FPU_FSET_HAS (fpu_desc->features, FPU_FL_NEON))\n+    if (TARGET_IWMMXT\n+\t&& ARM_FPU_FSET_HAS (fpu_desc->features, FPU_FL_NEON))\n     error (\"iWMMXt and NEON are incompatible\");\n \n   /* Make sure that the processor choice does not conflict with any of the\n@@ -3301,10 +3301,8 @@ arm_option_override (void)\n   /* If soft-float is specified then don't use FPU.  */\n   if (TARGET_SOFT_FLOAT)\n     arm_fpu_attr = FPU_NONE;\n-  else if (TARGET_VFP)\n-    arm_fpu_attr = FPU_VFP;\n   else\n-    gcc_unreachable();\n+    arm_fpu_attr = FPU_VFP;\n \n   if (TARGET_AAPCS_BASED)\n     {\n@@ -3324,15 +3322,14 @@ arm_option_override (void)\n       if (arm_abi == ARM_ABI_IWMMXT)\n \tarm_pcs_default = ARM_PCS_AAPCS_IWMMXT;\n       else if (arm_float_abi == ARM_FLOAT_ABI_HARD\n-\t       && TARGET_HARD_FLOAT\n-\t       && TARGET_VFP)\n+\t       && TARGET_HARD_FLOAT)\n \tarm_pcs_default = ARM_PCS_AAPCS_VFP;\n       else\n \tarm_pcs_default = ARM_PCS_AAPCS;\n     }\n   else\n     {\n-      if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)\n+      if (arm_float_abi == ARM_FLOAT_ABI_HARD)\n \tsorry (\"-mfloat-abi=hard and VFP\");\n \n       if (arm_abi == ARM_ABI_APCS)\n@@ -3891,7 +3888,7 @@ use_return_insn (int iscond, rtx sibling)\n \n   /* Can't be done if any of the VFP regs are pushed,\n      since this also requires an insn.  */\n-  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_HARD_FLOAT)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n       if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \treturn 0;\n@@ -5344,7 +5341,6 @@ arm_function_value_regno_p (const unsigned int regno)\n   if (regno == ARG_REGISTER (1)\n       || (TARGET_32BIT\n \t  && TARGET_AAPCS_BASED\n-\t  && TARGET_VFP\n \t  && TARGET_HARD_FLOAT\n \t  && regno == FIRST_VFP_REGNUM)\n       || (TARGET_IWMMXT_ABI\n@@ -5363,7 +5359,7 @@ arm_apply_result_size (void)\n \n   if (TARGET_32BIT)\n     {\n-      if (TARGET_HARD_FLOAT_ABI && TARGET_VFP)\n+      if (TARGET_HARD_FLOAT_ABI)\n \tsize += 32;\n       if (TARGET_IWMMXT_ABI)\n \tsize += 8;\n@@ -5811,7 +5807,7 @@ use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)\n   if (pcs_variant != ARM_PCS_AAPCS_LOCAL)\n     return false;\n \n-  return (TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT &&\n+  return (TARGET_32BIT && TARGET_HARD_FLOAT &&\n \t  (TARGET_VFP_DOUBLE || !is_double));\n }\n \n@@ -7272,8 +7268,7 @@ arm_legitimate_address_outer_p (machine_mode mode, rtx x, RTX_CODE outer,\n     return 1;\n \n   use_ldrd = (TARGET_LDRD\n-\t      && (mode == DImode\n-\t\t  || (mode == DFmode && (TARGET_SOFT_FLOAT || TARGET_VFP))));\n+\t      && (mode == DImode || mode == DFmode));\n \n   if (code == POST_INC || code == PRE_DEC\n       || ((code == PRE_INC || code == POST_DEC)\n@@ -7358,8 +7353,7 @@ thumb2_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n     return 1;\n \n   use_ldrd = (TARGET_LDRD\n-\t      && (mode == DImode\n-\t\t  || (mode == DFmode && (TARGET_SOFT_FLOAT || TARGET_VFP))));\n+\t      && (mode == DImode || mode == DFmode));\n \n   if (code == POST_INC || code == PRE_DEC\n       || ((code == PRE_INC || code == POST_DEC)\n@@ -7452,7 +7446,6 @@ arm_legitimate_index_p (machine_mode mode, rtx index, RTX_CODE outer,\n \n   /* Standard coprocessor addressing modes.  */\n   if (TARGET_HARD_FLOAT\n-      && TARGET_VFP\n       && (mode == SFmode || mode == DFmode))\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    && INTVAL (index) > -1024\n@@ -7572,7 +7565,6 @@ thumb2_legitimate_index_p (machine_mode mode, rtx index, int strict_p)\n   /* ??? Combine arm and thumb2 coprocessor addressing modes.  */\n   /* Standard coprocessor addressing modes.  */\n   if (TARGET_HARD_FLOAT\n-      && TARGET_VFP\n       && (mode == SFmode || mode == DFmode))\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    /* Thumb-2 allows only > -256 index range for it's core register\n@@ -8118,8 +8110,7 @@ arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n \n \t  /* VFP addressing modes actually allow greater offsets, but for\n \t     now we just stick with the lowest common denominator.  */\n-\t  if (mode == DImode\n-\t      || ((TARGET_SOFT_FLOAT || TARGET_VFP) && mode == DFmode))\n+\t  if (mode == DImode || mode == DFmode)\n \t    {\n \t      low_n = n & 0x0f;\n \t      n &= ~0x0f;\n@@ -18722,7 +18713,7 @@ output_move_vfp (rtx *operands)\n \n   gcc_assert (REG_P (reg));\n   gcc_assert (IS_VFP_REGNUM (REGNO (reg)));\n-  gcc_assert ((mode == HFmode && TARGET_HARD_FLOAT && TARGET_VFP)\n+  gcc_assert ((mode == HFmode && TARGET_HARD_FLOAT)\n \t      || mode == SFmode\n \t      || mode == DFmode\n \t      || mode == HImode\n@@ -19567,7 +19558,7 @@ arm_get_vfp_saved_size (void)\n \n   saved = 0;\n   /* Space for saved VFP registers.  */\n-  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_HARD_FLOAT)\n     {\n       count = 0;\n       for (regno = FIRST_VFP_REGNUM;\n@@ -20566,7 +20557,7 @@ arm_emit_vfp_multi_reg_pop (int first_reg, int num_regs, rtx base_reg)\n   REG_NOTES (par) = dwarf;\n \n   /* Make sure cfa doesn't leave with IP_REGNUM to allow unwinding fron FP.  */\n-  if (TARGET_VFP && REGNO (base_reg) == IP_REGNUM)\n+  if (REGNO (base_reg) == IP_REGNUM)\n     {\n       RTX_FRAME_RELATED_P (par) = 1;\n       add_reg_note (par, REG_CFA_DEF_CFA, hard_frame_pointer_rtx);\n@@ -21027,7 +21018,7 @@ arm_get_frame_offsets (void)\n       func_type = arm_current_func_type ();\n       /* Space for saved VFP registers.  */\n       if (! IS_VOLATILE (func_type)\n-\t  && TARGET_HARD_FLOAT && TARGET_VFP)\n+\t  && TARGET_HARD_FLOAT)\n \tsaved += arm_get_vfp_saved_size ();\n     }\n   else /* TARGET_THUMB1 */\n@@ -21248,7 +21239,7 @@ arm_save_coproc_regs(void)\n \tsaved_size += 8;\n       }\n \n-  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_HARD_FLOAT)\n     {\n       start_reg = FIRST_VFP_REGNUM;\n \n@@ -23493,7 +23484,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return (regno == CC_REGNUM\n-\t    || (TARGET_HARD_FLOAT && TARGET_VFP\n+\t    || (TARGET_HARD_FLOAT\n \t\t&& regno == VFPCC_REGNUM));\n \n   if (regno == CC_REGNUM && GET_MODE_CLASS (mode) != MODE_CC)\n@@ -23507,8 +23498,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n-  if (TARGET_HARD_FLOAT && TARGET_VFP\n-      && IS_VFP_REGNUM (regno))\n+  if (TARGET_HARD_FLOAT && IS_VFP_REGNUM (regno))\n     {\n       if (mode == SFmode || mode == SImode)\n \treturn VFP_REGNO_OK_FOR_SINGLE (regno);\n@@ -25253,7 +25243,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n         floats_from_frame += 4;\n       }\n \n-  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_HARD_FLOAT)\n     {\n       int start_reg;\n       rtx ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n@@ -25499,7 +25489,7 @@ arm_expand_epilogue (bool really_return)\n         }\n     }\n \n-  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_HARD_FLOAT)\n     {\n       /* Generate VFP register multi-pop.  */\n       int end_reg = LAST_VFP_REGNUM + 1;\n@@ -26110,7 +26100,7 @@ arm_file_start (void)\n       if (print_tune_info)\n \tarm_print_tune_info ();\n \n-      if (! TARGET_SOFT_FLOAT && TARGET_VFP)\n+      if (! TARGET_SOFT_FLOAT)\n \t{\n \t  if (TARGET_HARD_FLOAT && TARGET_VFP_SINGLE)\n \t    arm_emit_eabi_attribute (\"Tag_ABI_HardFP_use\", 27, 1);\n@@ -27832,7 +27822,7 @@ arm_conditional_register_usage (void)\n   if (TARGET_THUMB1)\n     fixed_regs[LR_REGNUM] = call_used_regs[LR_REGNUM] = 1;\n \n-  if (TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP)\n+  if (TARGET_32BIT && TARGET_HARD_FLOAT)\n     {\n       /* VFPv3 registers are disabled when earlier VFP\n \t versions are selected due to the definition of\n@@ -29435,9 +29425,9 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n       /* Fall through.  */\n     case SFmode:\n     case DFmode:\n-      if (!arm_float_compare_operand (*op1, mode))\n+      if (!vfp_compare_operand (*op1, mode))\n \t*op1 = force_reg (mode, *op1);\n-      if (!arm_float_compare_operand (*op2, mode))\n+      if (!vfp_compare_operand (*op2, mode))\n \t*op2 = force_reg (mode, *op2);\n       return true;\n     default:"}, {"sha": "8a076ba3d8eb66e237790d23dd7c2ecb4b6fd264", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -134,8 +134,6 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_HARD_FLOAT\t\t(arm_float_abi != ARM_FLOAT_ABI_SOFT)\n /* Use hardware floating point calling convention.  */\n #define TARGET_HARD_FLOAT_ABI\t\t(arm_float_abi == ARM_FLOAT_ABI_HARD)\n-/* We only support the VFP model these days.  */\n-#define TARGET_VFP\t\t        (1)\n #define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n #define TARGET_IWMMXT2\t\t\t(arm_arch_iwmmxt2)\n #define TARGET_REALLY_IWMMXT\t\t(TARGET_IWMMXT && TARGET_32BIT)\n@@ -173,46 +171,45 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n    to be more careful with TARGET_NEON as noted below.  */\n \n /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */\n-#define TARGET_VFPD32 (TARGET_VFP && TARGET_FPU_REGS == VFP_REG_D32)\n+#define TARGET_VFPD32 (TARGET_FPU_REGS == VFP_REG_D32)\n \n /* FPU supports VFPv3 instructions.  */\n-#define TARGET_VFP3 (TARGET_VFP && TARGET_FPU_REV >= 3)\n+#define TARGET_VFP3 (TARGET_FPU_REV >= 3)\n \n /* FPU supports FPv5 instructions.  */\n-#define TARGET_VFP5 (TARGET_VFP && TARGET_FPU_REV >= 5)\n+#define TARGET_VFP5 (TARGET_FPU_REV >= 5)\n \n /* FPU only supports VFP single-precision instructions.  */\n-#define TARGET_VFP_SINGLE (TARGET_VFP && TARGET_FPU_REGS == VFP_REG_SINGLE)\n+#define TARGET_VFP_SINGLE (TARGET_FPU_REGS == VFP_REG_SINGLE)\n \n /* FPU supports VFP double-precision instructions.  */\n-#define TARGET_VFP_DOUBLE (TARGET_VFP && TARGET_FPU_REGS != VFP_REG_SINGLE)\n+#define TARGET_VFP_DOUBLE (TARGET_FPU_REGS != VFP_REG_SINGLE)\n \n /* FPU supports half-precision floating-point with NEON element load/store.  */\n-#define TARGET_NEON_FP16\t\t\t\t\t\t\\\n-  (TARGET_VFP\t\t\t\t\t\t\t\t\\\n-   && ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_NEON)\t\t\\\n+#define TARGET_NEON_FP16\t\t\t\t\t\\\n+  (ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_NEON)\t\t\\\n    && ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_FP16))\n \n /* FPU supports VFP half-precision floating-point.  */\n #define TARGET_FP16\t\t\t\t\t\t\t\\\n-  (TARGET_VFP && ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_FP16))\n+  (ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_FP16))\n \n /* FPU supports fused-multiply-add operations.  */\n-#define TARGET_FMA (TARGET_VFP && TARGET_FPU_REV >= 4)\n+#define TARGET_FMA (TARGET_FPU_REV >= 4)\n \n /* FPU is ARMv8 compatible.  */\n-#define TARGET_FPU_ARMV8 (TARGET_VFP && TARGET_FPU_REV >= 8)\n+#define TARGET_FPU_ARMV8 (TARGET_FPU_REV >= 8)\n \n /* FPU supports Crypto extensions.  */\n #define TARGET_CRYPTO\t\t\t\t\t\t\t\\\n-  (TARGET_VFP && ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_CRYPTO))\n+  (ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_CRYPTO))\n \n /* FPU supports Neon instructions.  The setting of this macro gets\n    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT\n    and TARGET_HARD_FLOAT to ensure that NEON instructions are\n    available.  */\n #define TARGET_NEON\t\t\t\t\t\t\t\\\n-  (TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\t\t\t\\\n+  (TARGET_32BIT && TARGET_HARD_FLOAT\t\t\t\t\t\\\n    && ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_NEON))\n \n /* FPU supports ARMv8.1 Adv.SIMD extensions.  */\n@@ -1216,7 +1213,7 @@ enum reg_class\n    the data layout happens to be consistent for big-endian, so we explicitly allow\n    that case.  */\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (TARGET_VFP && TARGET_BIG_END\t\t\t\t\t\\\n+  (TARGET_BIG_END\t\t\t\t\t\t\\\n    && !(GET_MODE_SIZE (FROM) == 16 && GET_MODE_SIZE (TO) == 8)\t\\\n    && (GET_MODE_SIZE (FROM) > UNITS_PER_WORD\t\t\t\\\n        || GET_MODE_SIZE (TO) > UNITS_PER_WORD)\t\t\t\\\n@@ -1267,8 +1264,7 @@ enum reg_class\n    NO_REGS is returned.  */\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n-  ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n-    && IS_VFP_CLASS (CLASS))\t\t\t\t\t\\\n+  ((TARGET_HARD_FLOAT && IS_VFP_CLASS (CLASS))\t\t\t\\\n    ? coproc_secondary_reload_class (MODE, X, FALSE)\t\t\\\n    : (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS)\t\t\t\\\n    ? coproc_secondary_reload_class (MODE, X, TRUE)\t\t\\\n@@ -1280,8 +1276,7 @@ enum reg_class\n /* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n-  ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n-    && IS_VFP_CLASS (CLASS))\t\t\t\t\t\\\n+  ((TARGET_HARD_FLOAT && IS_VFP_CLASS (CLASS))\t\t\t\\\n     ? coproc_secondary_reload_class (MODE, X, FALSE) :\t\t\\\n     (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS) ?\t\t\t\\\n     coproc_secondary_reload_class (MODE, X, TRUE) :\t\t\\\n@@ -1541,7 +1536,7 @@ typedef struct\n    On the ARM, r0-r3 are used to pass args.  */\n #define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\t\t\\\n    (IN_RANGE ((REGNO), 0, 3)\t\t\t\t\t\t\\\n-    || (TARGET_AAPCS_BASED && TARGET_VFP && TARGET_HARD_FLOAT\t\t\\\n+    || (TARGET_AAPCS_BASED && TARGET_HARD_FLOAT\t\t\t\t\\\n \t&& IN_RANGE ((REGNO), FIRST_VFP_REGNUM, FIRST_VFP_REGNUM + 15))\t\\\n     || (TARGET_IWMMXT_ABI\t\t\t\t\t\t\\\n \t&& IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))"}, {"sha": "374b54e3c0e205a375b67f5da805dd06609569db", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -2156,7 +2156,7 @@\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"s_register_operand\" \"\")\n \t\t(match_operand:SF 2 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_expand \"divdf3\"\n@@ -4747,7 +4747,7 @@\n (define_expand \"negsf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\"\n )\n \n@@ -5020,7 +5020,7 @@\n (define_expand \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n \t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_expand \"sqrtdf2\"\n@@ -5825,7 +5825,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, r, q, m\")\n \t(match_operand:DI 1 \"di_operand\"              \"rDa,Db,Dc,mi,q\"))]\n   \"TARGET_32BIT\n-   && !(TARGET_HARD_FLOAT && TARGET_VFP)\n+   && !(TARGET_HARD_FLOAT)\n    && !TARGET_IWMMXT\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n@@ -6051,8 +6051,7 @@\n (define_insn \"*arm_movsi_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,r,r,rk,m\")\n \t(match_operand:SI 1 \"general_operand\"      \"rk, I,K,j,mi,rk\"))]\n-  \"TARGET_ARM && ! TARGET_IWMMXT\n-   && !(TARGET_HARD_FLOAT && TARGET_VFP)\n+  \"TARGET_ARM && !TARGET_IWMMXT && !TARGET_HARD_FLOAT\n    && (   register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n@@ -6701,7 +6700,7 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m,r\")\n \t(match_operand:HI 1 \"general_operand\"      \"rIk,K,n,r,mi\"))]\n   \"TARGET_ARM\n-   && arm_arch4 && !(TARGET_HARD_FLOAT && TARGET_VFP)\n+   && arm_arch4 && !TARGET_HARD_FLOAT\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n   \"@\n@@ -6727,7 +6726,7 @@\n (define_insn \"*movhi_bytes\"\n   [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r,r\")\n \t(match_operand:HI 1 \"arm_rhs_operand\"  \"I,rk,K\"))]\n-  \"TARGET_ARM && !(TARGET_HARD_FLOAT && TARGET_VFP)\"\n+  \"TARGET_ARM && !TARGET_HARD_FLOAT\"\n   \"@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n@@ -6887,7 +6886,7 @@\n (define_insn \"*arm32_movhf\"\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n-  \"TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_VFP)\n+  \"TARGET_32BIT && !TARGET_HARD_FLOAT\n    && (\t  s_register_operand (operands[0], HFmode)\n        || s_register_operand (operands[1], HFmode))\"\n   \"*\n@@ -7231,7 +7230,7 @@\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"expandable_comparison_operator\"\n \t       [(match_operand:SF 1 \"s_register_operand\" \"\")\n-\t        (match_operand:SF 2 \"arm_float_compare_operand\" \"\")])\n+\t        (match_operand:SF 2 \"vfp_compare_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n@@ -7243,7 +7242,7 @@\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"expandable_comparison_operator\"\n \t       [(match_operand:DF 1 \"s_register_operand\" \"\")\n-\t        (match_operand:DF 2 \"arm_float_compare_operand\" \"\")])\n+\t        (match_operand:DF 2 \"vfp_compare_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n@@ -7709,7 +7708,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\")\n \t(match_operator:SI 1 \"expandable_comparison_operator\"\n \t [(match_operand:HF 2 \"s_register_operand\")\n-\t  (match_operand:HF 3 \"arm_float_compare_operand\")]))]\n+\t  (match_operand:HF 3 \"vfp_compare_operand\")]))]\n   \"TARGET_VFP_FP16INST\"\n   {\n     if (!arm_validize_comparison (&operands[1],\n@@ -7727,7 +7726,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(match_operator:SI 1 \"expandable_comparison_operator\"\n \t [(match_operand:SF 2 \"s_register_operand\" \"\")\n-\t  (match_operand:SF 3 \"arm_float_compare_operand\" \"\")]))]\n+\t  (match_operand:SF 3 \"vfp_compare_operand\" \"\")]))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n \t\t\t     operands[2], operands[3])); DONE;\"\n@@ -7737,7 +7736,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(match_operator:SI 1 \"expandable_comparison_operator\"\n \t [(match_operand:DF 2 \"s_register_operand\" \"\")\n-\t  (match_operand:DF 3 \"arm_float_compare_operand\" \"\")]))]\n+\t  (match_operand:DF 3 \"vfp_compare_operand\" \"\")]))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n \t\t\t     operands[2], operands[3])); DONE;\"\n@@ -11052,7 +11051,7 @@\n                    (match_operand:SI 2 \"const_int_I_operand\" \"I\")))\n      (set (match_operand:DF 3 \"vfp_hard_register_operand\" \"\")\n           (mem:DF (match_dup 1)))])]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"*\n   {\n     int num_regs = XVECLEN (operands[0], 0);"}, {"sha": "562a9fc1b5bd734484088e24416965187de782b0", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -333,13 +333,13 @@\n  \"@internal\n   In ARM/ Thumb2 a const_double which can be used with a vcvt.f32.s32 with fract bits operation\"\n   (and (match_code \"const_double\")\n-       (match_test \"TARGET_32BIT && TARGET_VFP && vfp3_const_double_for_fract_bits (op)\")))\n+       (match_test \"TARGET_32BIT && vfp3_const_double_for_fract_bits (op)\")))\n \n (define_constraint \"Dp\"\n  \"@internal\n   In ARM/ Thumb2 a const_double which can be used with a vcvt.s32.f32 with bits operation\"\n   (and (match_code \"const_double\")\n-       (match_test \"TARGET_32BIT && TARGET_VFP\n+       (match_test \"TARGET_32BIT\n \t\t    && vfp3_const_double_for_bits (op) > 0\")))\n \n (define_register_constraint \"Ts\" \"(arm_restrict_it) ? LO_REGS : GENERAL_REGS\""}, {"sha": "82ba08eb70edb007a068a42a6a53438fdda15aac", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -46,7 +46,7 @@\n (define_mode_iterator SIDI [SI DI])\n \n ;; A list of modes which the VFP unit can handle\n-(define_mode_iterator SDF [(SF \"TARGET_VFP\") (DF \"TARGET_VFP_DOUBLE\")])\n+(define_mode_iterator SDF [(SF \"\") (DF \"TARGET_VFP_DOUBLE\")])\n \n ;; Integer element sizes implemented by IWMMXT.\n (define_mode_iterator VMMX [V2SI V4HI V8QI])"}, {"sha": "3e747d682300fe4c232a618e9a549a833ee153fe", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -241,11 +241,6 @@\n        (and (match_code \"const_double\")\n \t    (match_test \"arm_const_double_rtx (op)\"))))\n \n-(define_predicate \"arm_float_compare_operand\"\n-  (if_then_else (match_test \"TARGET_VFP\")\n-\t\t(match_operand 0 \"vfp_compare_operand\")\n-\t\t(match_operand 0 \"s_register_operand\")))\n-\n ;; True for valid index operands.\n (define_predicate \"index_operand\"\n   (ior (match_operand 0 \"s_register_operand\")\n@@ -621,12 +616,12 @@\n \n (define_predicate \"const_double_vcvt_power_of_two_reciprocal\"\n   (and (match_code \"const_double\")\n-       (match_test \"TARGET_32BIT && TARGET_VFP\n-                   && vfp3_const_double_for_fract_bits (op)\")))\n+       (match_test \"TARGET_32BIT\n+\t\t    && vfp3_const_double_for_fract_bits (op)\")))\n \n (define_predicate \"const_double_vcvt_power_of_two\"\n   (and (match_code \"const_double\")\n-       (match_test \"TARGET_32BIT && TARGET_VFP\n+       (match_test \"TARGET_32BIT\n \t\t    && vfp3_const_double_for_bits (op) > 0\")))\n \n (define_predicate \"neon_struct_operand\""}, {"sha": "affcd832b72b7d358347e7370265be492866bb90", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -278,8 +278,7 @@\n (define_insn \"*thumb2_movsi_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,l,r,r,l ,*hk,m,*m\")\n \t(match_operand:SI 1 \"general_operand\"\t   \"rk,I,Py,K,j,mi,*mi,l,*hk\"))]\n-  \"TARGET_THUMB2 && ! TARGET_IWMMXT\n-   && !(TARGET_HARD_FLOAT && TARGET_VFP)\n+  \"TARGET_THUMB2 && !TARGET_IWMMXT && !TARGET_HARD_FLOAT\n    && (   register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@"}, {"sha": "45ce5c9196b2febab6bf7b1592ff79ac9e00087e", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ea1506d97745aa5ca78629988ba77e6ce693d5/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=00ea1506d97745aa5ca78629988ba77e6ce693d5", "patch": "@@ -26,7 +26,7 @@\n     \"=rk,  r, r, m, r, *t,  r, *t\")\n    (match_operand:HI 1 \"general_operand\"\n     \"rIk, K, n, r, mi, r, *t, *t\"))]\n- \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n+ \"TARGET_ARM && TARGET_HARD_FLOAT\n   && !TARGET_VFP_FP16INST\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -77,7 +77,7 @@\n     \"=rk, r, l, r, m, r, *t, r, *t\")\n    (match_operand:HI 1 \"general_operand\"\n     \"rk, I, Py, n, r, m, r, *t, *t\"))]\n- \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\n+ \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n   && !TARGET_VFP_FP16INST\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -217,7 +217,7 @@\n (define_insn \"*arm_movsi_vfp\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,r,r,rk,m ,*t,r,*t,*t, *Uv\")\n       (match_operand:SI 1 \"general_operand\"\t   \"rk, I,K,j,mi,rk,r,*t,*t,*Uvi,*t\"))]\n-  \"TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n   \"*\n@@ -260,7 +260,7 @@\n (define_insn \"*thumb2_movsi_vfp\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,l,r,r, l,*hk,m, *m,*t, r,*t,*t,  *Uv\")\n \t(match_operand:SI 1 \"general_operand\"\t   \"rk,I,Py,K,j,mi,*mi,l,*hk, r,*t,*t,*Uvi,*t\"))]\n-  \"TARGET_THUMB2 && TARGET_VFP && TARGET_HARD_FLOAT\n+  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n   \"*\n@@ -306,7 +306,7 @@\n (define_insn \"*movdi_vfp\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,r,r,q,q,m,w,r,w,w, Uv\")\n        (match_operand:DI 1 \"di_operand\"              \"r,rDa,Db,Dc,mi,mi,q,r,w,w,Uvi,w\"))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune != cortexa8\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && arm_tune != cortexa8\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\n    && !(TARGET_NEON && CONST_INT_P (operands[1])\n@@ -357,7 +357,7 @@\n (define_insn \"*movdi_vfp_cortexa8\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,r,r,r,r,m,w,!r,w,w, Uv\")\n        (match_operand:DI 1 \"di_operand\"              \"r,rDa,Db,Dc,mi,mi,r,r,w,w,Uvi,w\"))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune == cortexa8\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && arm_tune == cortexa8\n     && (   register_operand (operands[0], DImode)\n         || register_operand (operands[1], DImode))\n     && !(TARGET_NEON && CONST_INT_P (operands[1])\n@@ -540,7 +540,7 @@\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,t,r,t,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" m,r,t,r,r,t,F\"))]\n   \"TARGET_32BIT\n-   && TARGET_HARD_FLOAT && TARGET_VFP\n+   && TARGET_HARD_FLOAT\n    && !TARGET_NEON_FP16\n    && !TARGET_VFP_FP16INST\n    && (   s_register_operand (operands[0], HFmode)\n@@ -595,7 +595,7 @@\n (define_insn \"*movsf_vfp\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=t,?r,t ,t  ,Uv,r ,m,t,r\")\n         (match_operand:SF 1 \"general_operand\"\t   \" ?r,t,Dv,UvE,t, mE,r,t,r\"))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n   \"*\n@@ -631,7 +631,7 @@\n (define_insn \"*thumb2_movsf_vfp\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=t,?r,t, t  ,Uv,r ,m,t,r\")\n \t(match_operand:SF 1 \"general_operand\"\t   \" ?r,t,Dv,UvE,t, mE,r,t,r\"))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\n+  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n   \"*\n@@ -670,7 +670,7 @@\n (define_insn \"*movdf_vfp\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,w,w  ,Uv,r, m,w,r\")\n \t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dy,G,UvF,w ,mF,r,w,r\"))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -721,7 +721,7 @@\n (define_insn \"*thumb2_movdf_vfp\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,w,w  ,Uv,r ,m,w,r\")\n \t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dy,G,UvF,w, mF,r, w,r\"))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\n+  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -776,7 +776,7 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:SF 1 \"s_register_operand\" \"0,t,t,0,?r,?r,0,t,t\")\n \t  (match_operand:SF 2 \"s_register_operand\" \"t,0,t,?r,0,?r,t,0,t\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"@\n    vmov%D3.f32\\\\t%0, %2\n    vmov%d3.f32\\\\t%0, %1\n@@ -799,7 +799,7 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:SF 1 \"s_register_operand\" \"0,t,t,0,?r,?r,0,t,t\")\n \t  (match_operand:SF 2 \"s_register_operand\" \"t,0,t,?r,0,?r,t,0,t\")))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP && !arm_restrict_it\"\n+  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && !arm_restrict_it\"\n   \"@\n    it\\\\t%D3\\;vmov%D3.f32\\\\t%0, %2\n    it\\\\t%d3\\;vmov%d3.f32\\\\t%0, %1\n@@ -867,7 +867,7 @@\n (define_insn \"*abssf2_vfp\"\n   [(set (match_operand:SF\t  0 \"s_register_operand\" \"=t\")\n \t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vabs%?.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -887,7 +887,7 @@\n (define_insn \"*negsf2_vfp\"\n   [(set (match_operand:SF\t  0 \"s_register_operand\" \"=t,?r\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"t,r\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"@\n    vneg%?.f32\\\\t%0, %1\n    eor%?\\\\t%0, %1, #-2147483648\"\n@@ -1004,7 +1004,7 @@\n   [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n \t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n \t\t (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vadd%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1038,7 +1038,7 @@\n   [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n \t(minus:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n \t\t  (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vsub%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1079,7 +1079,7 @@\n   [(set (match_operand:SF\t  0 \"s_register_operand\" \"=&t,t\")\n \t(div:SF (match_operand:SF 1 \"s_register_operand\" \"t,t\")\n \t\t(match_operand:SF 2 \"s_register_operand\" \"t,t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vdiv%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1117,7 +1117,7 @@\n   [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n \t\t (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vmul%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1159,7 +1159,7 @@\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(mult:SF (neg:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))\n \t\t (match_operand:SF\t   2 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && !flag_rounding_math\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !flag_rounding_math\"\n   \"vnmul%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1170,7 +1170,7 @@\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(neg:SF (mult:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n \t\t (match_operand:SF\t   2 \"s_register_operand\" \"t\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vnmul%?.f32\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1221,7 +1221,7 @@\n \t(plus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n \t\t\t  (match_operand:SF 3 \"s_register_operand\" \"t\"))\n \t\t (match_operand:SF\t    1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vmla%?.f32\\\\t%0, %2, %3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1257,7 +1257,7 @@\n \t(minus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n \t\t\t   (match_operand:SF 3 \"s_register_operand\" \"t\"))\n \t\t  (match_operand:SF\t     1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vnmls%?.f32\\\\t%0, %2, %3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1293,7 +1293,7 @@\n \t(minus:SF (match_operand:SF\t     1 \"s_register_operand\" \"0\")\n \t\t  (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n \t\t\t   (match_operand:SF 3 \"s_register_operand\" \"t\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vmls%?.f32\\\\t%0, %2, %3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1332,7 +1332,7 @@\n \t\t    (neg:SF (match_operand:SF 2 \"s_register_operand\" \"t\"))\n \t\t    (match_operand:SF\t      3 \"s_register_operand\" \"t\"))\n \t\t  (match_operand:SF\t      1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vnmla%?.f32\\\\t%0, %2, %3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1520,7 +1520,7 @@\n (define_insn \"*truncsisf2_vfp\"\n   [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vcvt%?.s32.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1541,7 +1541,7 @@\n (define_insn \"fixuns_truncsfsi2\"\n   [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vcvt%?.u32.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1562,7 +1562,7 @@\n (define_insn \"*floatsisf2_vfp\"\n   [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n \t(float:SF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vcvt%?.f32.s32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1583,7 +1583,7 @@\n (define_insn \"floatunssisf2\"\n   [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n \t(unsigned_float:SF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vcvt%?.f32.u32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1630,7 +1630,7 @@\n (define_insn \"*sqrtsf2_vfp\"\n   [(set (match_operand:SF\t   0 \"s_register_operand\" \"=&t,t\")\n \t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"t,t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vsqrt%?.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1655,7 +1655,7 @@\n (define_insn \"*movcc_vfp\"\n   [(set (reg CC_REGNUM)\n \t(reg VFPCC_REGNUM))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"vmrs%?\\\\tAPSR_nzcv, FPSCR\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"f_flag\")]\n@@ -1665,9 +1665,9 @@\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"t\")\n \t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"tG\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"#\"\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   [(set (reg:CCFP VFPCC_REGNUM)\n \t(compare:CCFP (match_dup 0)\n \t\t      (match_dup 1)))\n@@ -1680,9 +1680,9 @@\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"t\")\n \t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"tG\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"#\"\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   [(set (reg:CCFPE VFPCC_REGNUM)\n \t(compare:CCFPE (match_dup 0)\n \t\t       (match_dup 1)))\n@@ -1731,7 +1731,7 @@\n   [(set (reg:CCFP VFPCC_REGNUM)\n \t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"t,t\")\n \t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"t,G\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"@\n    vcmp%?.f32\\\\t%0, %1\n    vcmp%?.f32\\\\t%0, #0\"\n@@ -1744,7 +1744,7 @@\n   [(set (reg:CCFPE VFPCC_REGNUM)\n \t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"t,t\")\n \t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"t,G\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"@\n    vcmpe%?.f32\\\\t%0, %1\n    vcmpe%?.f32\\\\t%0, #0\"\n@@ -1949,7 +1949,7 @@\n     [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n \t  (unspec:BLK [(match_operand:DF 1 \"vfp_register_operand\" \"\")]\n \t\t      UNSPEC_PUSH_MULT))])]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"* return vfp_output_vstmd (operands);\"\n   [(set_attr \"type\" \"f_stored\")]\n )\n@@ -2040,15 +2040,15 @@\n ;; Write Floating-point Status and Control Register.\n (define_insn \"set_fpscr\"\n   [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")] VUNSPEC_SET_FPSCR)]\n-  \"TARGET_VFP && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"mcr\\\\tp10, 7, %0, cr1, cr0, 0\\\\t @SET_FPSCR\"\n   [(set_attr \"type\" \"mrs\")])\n \n ;; Read Floating-point Status and Control Register.\n (define_insn \"get_fpscr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (unspec_volatile:SI [(const_int 0)] VUNSPEC_GET_FPSCR))]\n-  \"TARGET_VFP && TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"mrc\\\\tp10, 7, %0, cr1, cr0, 0\\\\t @GET_FPSCR\"\n   [(set_attr \"type\" \"mrs\")])\n "}]}