{"sha": "bf3d27e6892e4438d183062340ce17e39cb9fa9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYzZDI3ZTY4OTJlNDQzOGQxODMwNjIzNDBjZTE3ZTM5Y2I5ZmE5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-19T01:07:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-19T01:07:10Z"}, "message": "ifcvt.c (noce_process_if_block): Correctly detect X modified with INSN_B before COND_EARLIEST.\n\n        * ifcvt.c (noce_process_if_block): Correctly detect X modified\n        with INSN_B before COND_EARLIEST.  Don't check A and B for\n        modification in condition range.  Reorder INSN_B for A==B properly.\n        (if_convert): Iterate until no matches for a block.\n\n\t* gcc.c-torture/execute/20020916-1.c: New.\n\nFrom-SVN: r57294", "tree": {"sha": "6817aa9bc3ff6e8d11f2ab3f5a2a0d8f9a3b3d77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6817aa9bc3ff6e8d11f2ab3f5a2a0d8f9a3b3d77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf3d27e6892e4438d183062340ce17e39cb9fa9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3d27e6892e4438d183062340ce17e39cb9fa9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3d27e6892e4438d183062340ce17e39cb9fa9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3d27e6892e4438d183062340ce17e39cb9fa9d/comments", "author": null, "committer": null, "parents": [{"sha": "1b1f20cab9ba8fea71e43cecfe985eb60e2f59e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1f20cab9ba8fea71e43cecfe985eb60e2f59e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1f20cab9ba8fea71e43cecfe985eb60e2f59e7"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "40f48b7fa15955b3a8407ed39828036725389877", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf3d27e6892e4438d183062340ce17e39cb9fa9d", "patch": "@@ -1,3 +1,10 @@\n+2002-09-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* ifcvt.c (noce_process_if_block): Correctly detect X modified\n+\twith INSN_B before COND_EARLIEST.  Don't check A and B for \n+\tmodification in condition range.  Reorder INSN_B for A==B properly.\n+\t(if_convert): Iterate until no matches for a block.\n+\n 2002-09-18  Richard Henderson  <rth@redhat.com>\n \n \t* calls.c (store_one_arg): Rename default_align to parm_align;"}, {"sha": "42c5fb50bdb379063ea2927e1559e6aa9580369e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bf3d27e6892e4438d183062340ce17e39cb9fa9d", "patch": "@@ -1700,7 +1700,7 @@ noce_process_if_block (ce_info)\n   rtx insn_a, insn_b;\n   rtx set_a, set_b;\n   rtx orig_x, x, a, b;\n-  rtx jump, cond, insn;\n+  rtx jump, cond;\n \n   /* We're looking for patterns of the form\n \n@@ -1776,24 +1776,12 @@ noce_process_if_block (ce_info)\n \t  || ! rtx_equal_p (x, SET_DEST (set_b))\n \t  || reg_overlap_mentioned_p (x, cond)\n \t  || reg_overlap_mentioned_p (x, a)\n-\t  || reg_overlap_mentioned_p (x, SET_SRC (set_b)))\n+\t  || reg_overlap_mentioned_p (x, SET_SRC (set_b))\n+\t  || modified_between_p (x, if_info.cond_earliest, NEXT_INSN (jump)))\n \tinsn_b = set_b = NULL_RTX;\n     }\n   b = (set_b ? SET_SRC (set_b) : x);\n \n-  /* X may not be mentioned in the range (cond_earliest, jump]. \n-     Note the use of reg_overlap_mentioned_p, which handles memories\n-     properly, as opposed to reg_mentioned_p, which doesn't.  */\n-  for (insn = jump; insn != if_info.cond_earliest; insn = PREV_INSN (insn))\n-    if (INSN_P (insn) && reg_overlap_mentioned_p (x, PATTERN (insn)))\n-      return FALSE;\n-\n-  /* A and B may not be modified in the range [cond_earliest, jump).  */\n-  for (insn = if_info.cond_earliest; insn != jump; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (modified_in_p (a, insn) || modified_in_p (b, insn)))\n-      return FALSE;\n-\n   /* Only operate on register destinations, and even then avoid extending\n      the lifetime of hard registers on small register class machines.  */\n   orig_x = x;\n@@ -1839,7 +1827,7 @@ noce_process_if_block (ce_info)\n \n \t  if (else_bb && insn_b == else_bb->end)\n \t    else_bb->end = PREV_INSN (insn_b);\n-\t  reorder_insns (insn_b, insn_b, PREV_INSN (if_info.cond_earliest));\n+\t  reorder_insns (insn_b, insn_b, PREV_INSN (jump));\n \n \t  /* If there was a REG_EQUAL note, delete it since it may have been\n \t     true due to this insn being after a jump.  */\n@@ -1894,9 +1882,9 @@ noce_process_if_block (ce_info)\n   if (insn_b && else_bb)\n     delete_insn (insn_b);\n \n-  /* The new insns will have been inserted before cond_earliest.  We should\n-     be able to remove the jump with impunity, but the condition itself may\n-     have been modified by gcse to be shared across basic blocks.  */\n+  /* The new insns will have been inserted immediately before the jump.  We\n+     should be able to remove the jump with impunity, but the condition itself\n+     may have been modified by gcse to be shared across basic blocks.  */\n   delete_insn (jump);\n \n   /* If we used a temporary, fix it up now.  */\n@@ -3115,8 +3103,8 @@ if_convert (x_life_data_ok)\n \n       FOR_EACH_BB (bb)\n \t{\n-\t  basic_block new_bb = find_if_header (bb, pass);\n-\t  if (new_bb)\n+\t  basic_block new_bb;\n+\t  while ((new_bb = find_if_header (bb, pass)))\n \t    bb = new_bb;\n \t}\n "}, {"sha": "3f2db15d019573a04530cc8c6a372eed4529ec7e", "filename": "gcc/testsuite/gcc.c-torture/execute/20020916-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020916-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3d27e6892e4438d183062340ce17e39cb9fa9d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020916-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020916-1.c?ref=bf3d27e6892e4438d183062340ce17e39cb9fa9d", "patch": "@@ -0,0 +1,19 @@\n+/* Distilled from try_pre_increment in flow.c.  If-conversion inserted\n+   new instructions at the wrong place on ppc.  */\n+\n+int foo(int a)\n+{\n+  int x;\n+  x = 0;\n+  if (a > 0) x = 1;\n+  if (a < 0) x = 1;\n+  return x;\n+}\n+\n+int main()\n+{\n+  if (foo(1) != 1)\n+    abort();\n+  return 0;\n+}\n+"}]}