{"sha": "31acf1bb1163d7f306bbcda8149e6b55d465cc02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhY2YxYmIxMTYzZDdmMzA2YmJjZGE4MTQ5ZTZiNTVkNDY1Y2MwMg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-08-04T11:56:50Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-08-04T11:56:50Z"}, "message": "IPA C++ refactoring 3/N\n\n\t* cgraph.h (csi_end_p): Removed.\n\t(csi_next): Likewise.\n\t(csi_node): Likewise.\n\t(csi_start): Likewise.\n\t(cgraph_node_in_set_p): Likewise.\n\t(cgraph_node_set_size): Likewise.\n\t(vsi_end_p): Likewise.\n\t(vsi_next): Likewise.\n\t(vsi_node): Likewise.\n\t(vsi_start): Likewise.\n\t(varpool_node_set_size): Likewise.\n\t(cgraph_node_set_nonempty_p): Likewise.\n\t(varpool_node_set_nonempty_p): Likewise.\n\t* cgraphunit.c (cgraph_process_new_functions): vec replaces\n\tcgraph_node_set.\n\t* ipa-inline-transform.c: Likewise.\n\t* ipa-utils.c (cgraph_node_set_new): Removed.\n\t(cgraph_node_set_add): Likewise.\n\t(cgraph_node_set_remove): Likewise.\n\t(cgraph_node_set_find): Likewise.\n\t(dump_cgraph_node_set): Likewise.\n\t(debug_cgraph_node_set): Likewise.\n\t(free_cgraph_node_set): Likewise.\n\t(varpool_node_set_new): Likewise.\n\t(varpool_node_set_add): Likewise.\n\t(varpool_node_set_remove): Likewise.\n\t(varpool_node_set_find): Likewise.\n\t(dump_varpool_node_set): Likewise.\n\t(free_varpool_node_set): Likewise.\n\t(debug_varpool_node_set): Likewise.\n\t* tree-emutls.c (struct tls_var_data):\n\t(emutls_index): Removed.\n\t(emutls_decl): Likewise.\n\t(gen_emutls_addr): Function implementation uses newly added\n\thash_map<varpool_node *, tls_var_data>.\n\t(clear_access_vars): Likewise.\n\t(create_emultls_var): Likewise.\n\t(ipa_lower_emutls): Likewise.\n\t(reset_access): New function.\n\nFrom-SVN: r213573", "tree": {"sha": "2217af79011362dc9a023ba16850a1a06b4a7c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2217af79011362dc9a023ba16850a1a06b4a7c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31acf1bb1163d7f306bbcda8149e6b55d465cc02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31acf1bb1163d7f306bbcda8149e6b55d465cc02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31acf1bb1163d7f306bbcda8149e6b55d465cc02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31acf1bb1163d7f306bbcda8149e6b55d465cc02/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "890e586486bb82edc724fbf1a1685bcb713996ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/890e586486bb82edc724fbf1a1685bcb713996ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/890e586486bb82edc724fbf1a1685bcb713996ef"}], "stats": {"total": 552, "additions": 99, "deletions": 453}, "files": [{"sha": "ea4c5cb7145c5d6e2a0c5ffb7ccf8d7fd046c3b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -1,3 +1,45 @@\n+2014-08-04  Martin Liska <mliska@suse.cz>\n+\n+\t* cgraph.h (csi_end_p): Removed.\n+\t(csi_next): Likewise.\n+\t(csi_node): Likewise.\n+\t(csi_start): Likewise.\n+\t(cgraph_node_in_set_p): Likewise.\n+\t(cgraph_node_set_size): Likewise.\n+\t(vsi_end_p): Likewise.\n+\t(vsi_next): Likewise.\n+\t(vsi_node): Likewise.\n+\t(vsi_start): Likewise.\n+\t(varpool_node_set_size): Likewise.\n+\t(cgraph_node_set_nonempty_p): Likewise.\n+\t(varpool_node_set_nonempty_p): Likewise.\n+\t* cgraphunit.c (cgraph_process_new_functions): vec replaces\n+\tcgraph_node_set.\n+\t* ipa-inline-transform.c: Likewise.\n+\t* ipa-utils.c (cgraph_node_set_new): Removed.\n+\t(cgraph_node_set_add): Likewise.\n+\t(cgraph_node_set_remove): Likewise.\n+\t(cgraph_node_set_find): Likewise.\n+\t(dump_cgraph_node_set): Likewise.\n+\t(debug_cgraph_node_set): Likewise.\n+\t(free_cgraph_node_set): Likewise.\n+\t(varpool_node_set_new): Likewise.\n+\t(varpool_node_set_add): Likewise.\n+\t(varpool_node_set_remove): Likewise.\n+\t(varpool_node_set_find): Likewise.\n+\t(dump_varpool_node_set): Likewise.\n+\t(free_varpool_node_set): Likewise.\n+\t(debug_varpool_node_set): Likewise.\n+\t* tree-emutls.c (struct tls_var_data):\n+\t(emutls_index): Removed.\n+\t(emutls_decl): Likewise.\n+\t(gen_emutls_addr): Function implementation uses newly added\n+\thash_map<varpool_node *, tls_var_data>.\n+\t(clear_access_vars): Likewise.\n+\t(create_emultls_var): Likewise.\n+\t(ipa_lower_emutls): Likewise.\n+\t(reset_access): New function.\n+\n 2014-08-04 Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n \n \t* config/i386/i386.c (ix86_option_override_internal): Add"}, {"sha": "13c09af2a0583cb470ebc9eca3bab1bda6488145", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 119, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -1510,7 +1510,7 @@ enum cgraph_state\n };\n extern enum cgraph_state cgraph_state;\n extern bool cgraph_function_flags_ready;\n-extern cgraph_node_set cgraph_new_nodes;\n+extern vec<cgraph_node *> cgraph_new_nodes;\n \n extern GTY(()) struct asm_node *asm_nodes;\n extern GTY(()) int symtab_order;\n@@ -1616,24 +1616,7 @@ void record_references_in_initializer (tree, bool);\n \n /* In ipa.c  */\n bool symtab_remove_unreachable_nodes (bool, FILE *);\n-cgraph_node_set cgraph_node_set_new (void);\n-cgraph_node_set_iterator cgraph_node_set_find (cgraph_node_set,\n-\t\t\t\t\t       cgraph_node *);\n-void cgraph_node_set_add (cgraph_node_set, cgraph_node *);\n-void cgraph_node_set_remove (cgraph_node_set, cgraph_node *);\n-void dump_cgraph_node_set (FILE *, cgraph_node_set);\n-void debug_cgraph_node_set (cgraph_node_set);\n-void free_cgraph_node_set (cgraph_node_set);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n-\n-varpool_node_set varpool_node_set_new (void);\n-varpool_node_set_iterator varpool_node_set_find (varpool_node_set,\n-\t\t\t\t\t\t varpool_node *);\n-void varpool_node_set_add (varpool_node_set, varpool_node *);\n-void varpool_node_set_remove (varpool_node_set, varpool_node *);\n-void dump_varpool_node_set (FILE *, varpool_node_set);\n-void debug_varpool_node_set (varpool_node_set);\n-void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n \n /* In predict.c  */\n@@ -1949,93 +1932,6 @@ cgraph_next_function_with_gimple_body (cgraph_node *node)\n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n \n-/* Return true if iterator CSI points to nothing.  */\n-static inline bool\n-csi_end_p (cgraph_node_set_iterator csi)\n-{\n-  return csi.index >= csi.set->nodes.length ();\n-}\n-\n-/* Advance iterator CSI.  */\n-static inline void\n-csi_next (cgraph_node_set_iterator *csi)\n-{\n-  csi->index++;\n-}\n-\n-/* Return the node pointed to by CSI.  */\n-static inline cgraph_node *\n-csi_node (cgraph_node_set_iterator csi)\n-{\n-  return csi.set->nodes[csi.index];\n-}\n-\n-/* Return an iterator to the first node in SET.  */\n-static inline cgraph_node_set_iterator\n-csi_start (cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator csi;\n-\n-  csi.set = set;\n-  csi.index = 0;\n-  return csi;\n-}\n-\n-/* Return true if SET contains NODE.  */\n-static inline bool\n-cgraph_node_in_set_p (cgraph_node *node, cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator csi;\n-  csi = cgraph_node_set_find (set, node);\n-  return !csi_end_p (csi);\n-}\n-\n-/* Return number of nodes in SET.  */\n-static inline size_t\n-cgraph_node_set_size (cgraph_node_set set)\n-{\n-  return set->nodes.length ();\n-}\n-\n-/* Return true if iterator VSI points to nothing.  */\n-static inline bool\n-vsi_end_p (varpool_node_set_iterator vsi)\n-{\n-  return vsi.index >= vsi.set->nodes.length ();\n-}\n-\n-/* Advance iterator VSI.  */\n-static inline void\n-vsi_next (varpool_node_set_iterator *vsi)\n-{\n-  vsi->index++;\n-}\n-\n-/* Return the node pointed to by VSI.  */\n-static inline varpool_node *\n-vsi_node (varpool_node_set_iterator vsi)\n-{\n-  return vsi.set->nodes[vsi.index];\n-}\n-\n-/* Return an iterator to the first node in SET.  */\n-static inline varpool_node_set_iterator\n-vsi_start (varpool_node_set set)\n-{\n-  varpool_node_set_iterator vsi;\n-\n-  vsi.set = set;\n-  vsi.index = 0;\n-  return vsi;\n-}\n-\n-/* Return number of nodes in SET.  */\n-static inline size_t\n-varpool_node_set_size (varpool_node_set set)\n-{\n-  return set->nodes.length ();\n-}\n-\n /* Uniquize all constants that appear in memory.\n    Each constant in memory thus far output is recorded\n    in `const_desc_table'.  */\n@@ -2053,20 +1949,6 @@ struct GTY(()) constant_descriptor_tree {\n   hashval_t hash;\n };\n \n-/* Return true if set is nonempty.  */\n-static inline bool\n-cgraph_node_set_nonempty_p (cgraph_node_set set)\n-{\n-  return !set->nodes.is_empty ();\n-}\n-\n-/* Return true if set is nonempty.  */\n-static inline bool\n-varpool_node_set_nonempty_p (varpool_node_set set)\n-{\n-  return !set->nodes.is_empty ();\n-}\n-\n /* Return true when function is only called directly or it has alias.\n    i.e. it is not externally visible, address was not taken and\n    it is not used in any other non-standard way.  */"}, {"sha": "d9acc65096637fdc6abfde4f3183f62c1fc6d8ba", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -215,7 +215,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n    may generate new functions that need to be optimized and expanded.  */\n-cgraph_node_set cgraph_new_nodes;\n+vec<cgraph_node *> cgraph_new_nodes;\n \n static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n@@ -300,17 +300,16 @@ void\n cgraph_process_new_functions (void)\n {\n   tree fndecl;\n-  struct cgraph_node *node;\n-  cgraph_node_set_iterator csi;\n \n-  if (!cgraph_new_nodes)\n+  if (!cgraph_new_nodes.exists ())\n     return;\n+\n   handle_alias_pairs ();\n   /*  Note that this queue may grow as its being processed, as the new\n       functions may generate new ones.  */\n-  for (csi = csi_start (cgraph_new_nodes); !csi_end_p (csi); csi_next (&csi))\n+  for (unsigned i = 0; i < cgraph_new_nodes.length (); i++)\n     {\n-      node = csi_node (csi);\n+      cgraph_node *node = cgraph_new_nodes[i];\n       fndecl = node->decl;\n       switch (cgraph_state)\n \t{\n@@ -357,8 +356,8 @@ cgraph_process_new_functions (void)\n \t  break;\n \t}\n     }\n-  free_cgraph_node_set (cgraph_new_nodes);\n-  cgraph_new_nodes = NULL;\n+\n+  cgraph_new_nodes.release ();\n }\n \n /* As an GCC extension we allow redefinition of the function.  The\n@@ -501,9 +500,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_node::get_create (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n-\tif (!cgraph_new_nodes)\n-\t  cgraph_new_nodes = cgraph_node_set_new ();\n-\tcgraph_node_set_add (cgraph_new_nodes, node);\n+\tcgraph_new_nodes.safe_push (node);\n         break;\n \n       case CGRAPH_STATE_IPA:\n@@ -529,9 +526,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \t  }\n \tif (lowered)\n \t  node->lowered = true;\n-\tif (!cgraph_new_nodes)\n-\t  cgraph_new_nodes = cgraph_node_set_new ();\n-\tcgraph_node_set_add (cgraph_new_nodes, node);\n+\tcgraph_new_nodes.safe_push (node);\n         break;\n \n       case CGRAPH_STATE_FINISHED:"}, {"sha": "2ddd029e5fcb4e1a32e5613d2a8522696e250c02", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -96,7 +96,7 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n \t  && !DECL_VIRTUAL_P (node->decl)\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n \t     callgraph and they might reffer the function in question.  */\n-\t  && !cgraph_new_nodes);\n+\t  && !cgraph_new_nodes.exists ());\n }\n \n /* We are going to eliminate last direct call to NODE (or alias of it) via edge E."}, {"sha": "590ac270d0ae3dac71784ca3d42762f41e1389e4", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -381,258 +381,6 @@ get_base_var (tree t)\n }\n \n \n-/* Create a new cgraph node set.  */\n-\n-cgraph_node_set\n-cgraph_node_set_new (void)\n-{\n-  cgraph_node_set new_node_set;\n-\n-  new_node_set = XCNEW (struct cgraph_node_set_def);\n-  new_node_set->map = new hash_map<cgraph_node *, size_t>;\n-  new_node_set->nodes.create (0);\n-  return new_node_set;\n-}\n-\n-\n-/* Add cgraph_node NODE to cgraph_node_set SET.  */\n-\n-void\n-cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  bool existed_p;\n-  size_t &index = set->map->get_or_insert (node, &existed_p);\n-\n-  if (existed_p)\n-    {\n-      gcc_checking_assert ((set->nodes[index]\n-\t\t           == node));\n-      return;\n-    }\n-\n-  index = set->nodes.length () + 1;\n-\n-  /* Insert into node vector.  */\n-  set->nodes.safe_push (node);\n-}\n-\n-\n-/* Remove cgraph_node NODE from cgraph_node_set SET.  */\n-\n-void\n-cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  int index;\n-  struct cgraph_node *last_node;\n-\n-  size_t *slot = set->map->get (node);\n-  if (slot == NULL || !*slot)\n-    return;\n-\n-  index = *slot - 1;\n-  gcc_checking_assert (set->nodes[index]\n-\t      \t       == node);\n-\n-  /* Remove from vector. We do this by swapping node with the last element\n-     of the vector.  */\n-  last_node = set->nodes.pop ();\n-  if (last_node != node)\n-    {\n-      size_t *last_slot = set->map->get (last_node);\n-      gcc_checking_assert (last_slot && *last_slot);\n-      *last_slot = index + 1;\n-\n-      /* Move the last element to the original spot of NODE.  */\n-      set->nodes[index] = last_node;\n-    }\n-\n-  /* Remove element from hash table.  */\n-  set->map->remove (node);\n-}\n-\n-\n-/* Find NODE in SET and return an iterator to it if found.  A null iterator\n-   is returned if NODE is not in SET.  */\n-\n-cgraph_node_set_iterator\n-cgraph_node_set_find (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  size_t *slot;\n-  cgraph_node_set_iterator csi;\n-\n-  slot = set->map->get (node);\n-  if (slot == NULL || !*slot)\n-    csi.index = (unsigned) ~0;\n-  else\n-    csi.index = *slot - 1;\n-  csi.set = set;\n-\n-  return csi;\n-}\n-\n-\n-/* Dump content of SET to file F.  */\n-\n-void\n-dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator iter;\n-\n-  for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n-    {\n-      struct cgraph_node *node = csi_node (iter);\n-      fprintf (f, \" %s/%i\", node->name (), node->order);\n-    }\n-  fprintf (f, \"\\n\");\n-}\n-\n-\n-/* Dump content of SET to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_cgraph_node_set (cgraph_node_set set)\n-{\n-  dump_cgraph_node_set (stderr, set);\n-}\n-\n-\n-/* Free varpool node set.  */\n-\n-void\n-free_cgraph_node_set (cgraph_node_set set)\n-{\n-  set->nodes.release ();\n-  delete set->map;\n-  free (set);\n-}\n-\n-\n-/* Create a new varpool node set.  */\n-\n-varpool_node_set\n-varpool_node_set_new (void)\n-{\n-  varpool_node_set new_node_set;\n-\n-  new_node_set = XCNEW (struct varpool_node_set_def);\n-  new_node_set->map = new hash_map<varpool_node *, size_t>;\n-  new_node_set->nodes.create (0);\n-  return new_node_set;\n-}\n-\n-\n-/* Add varpool_node NODE to varpool_node_set SET.  */\n-\n-void\n-varpool_node_set_add (varpool_node_set set, varpool_node *node)\n-{\n-  bool existed;\n-  size_t &slot = set->map->get_or_insert (node, &existed);\n-\n-  if (existed)\n-    {\n-      int index = slot - 1;\n-      gcc_checking_assert ((set->nodes[index]\n-\t\t           == node));\n-      return;\n-    }\n-\n-  slot = set->nodes.length () + 1;\n-\n-  /* Insert into node vector.  */\n-  set->nodes.safe_push (node);\n-}\n-\n-\n-/* Remove varpool_node NODE from varpool_node_set SET.  */\n-\n-void\n-varpool_node_set_remove (varpool_node_set set, varpool_node *node)\n-{\n-  int index;\n-  varpool_node *last_node;\n-\n-  size_t *slot = set->map->get (node);\n-  if (slot == NULL || !*slot)\n-    return;\n-\n-  index = *slot - 1;\n-  gcc_checking_assert (set->nodes[index]\n-\t      \t       == node);\n-\n-  /* Remove from vector. We do this by swapping node with the last element\n-     of the vector.  */\n-  last_node = set->nodes.pop ();\n-  if (last_node != node)\n-    {\n-      size_t *last_slot = set->map->get (last_node);\n-      gcc_checking_assert (last_slot && *last_slot);\n-      *last_slot = index + 1;\n-\n-      /* Move the last element to the original spot of NODE.  */\n-      set->nodes[index] = last_node;\n-    }\n-\n-  /* Remove element from hash table.  */\n-  set->map->remove (node);\n-}\n-\n-\n-/* Find NODE in SET and return an iterator to it if found.  A null iterator\n-   is returned if NODE is not in SET.  */\n-\n-varpool_node_set_iterator\n-varpool_node_set_find (varpool_node_set set, varpool_node *node)\n-{\n-  varpool_node_set_iterator vsi;\n-\n-  size_t *slot = set->map->get (node);\n-  if (slot == NULL || !*slot)\n-    vsi.index = (unsigned) ~0;\n-  else\n-    vsi.index = *slot - 1;\n-  vsi.set = set;\n-\n-  return vsi;\n-}\n-\n-\n-/* Dump content of SET to file F.  */\n-\n-void\n-dump_varpool_node_set (FILE *f, varpool_node_set set)\n-{\n-  varpool_node_set_iterator iter;\n-\n-  for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n-    {\n-      varpool_node *node = vsi_node (iter);\n-      fprintf (f, \" %s\", node->name ());\n-    }\n-  fprintf (f, \"\\n\");\n-}\n-\n-\n-/* Free varpool node set.  */\n-\n-void\n-free_varpool_node_set (varpool_node_set set)\n-{\n-  set->nodes.release ();\n-  delete set->map;\n-  free (set);\n-}\n-\n-\n-/* Dump content of SET to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_varpool_node_set (varpool_node_set set)\n-{\n-  dump_varpool_node_set (stderr, set);\n-}\n-\n-\n /* SRC and DST are going to be merged.  Take SRC's profile and merge it into\n    DST so it is not going to be lost.  Destroy SRC's body on the way.  */\n "}, {"sha": "00b27b5eb0957d2cf2c37ffb9f191f82f388728e", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 46, "deletions": 67, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31acf1bb1163d7f306bbcda8149e6b55d465cc02/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=31acf1bb1163d7f306bbcda8149e6b55d465cc02", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"targhooks.h\"\n #include \"tree-iterator.h\"\n-\n+#include \"hash-map.h\"\n \n /* Whenever a target does not support thread-local storage (TLS) natively,\n    we can emulate it with some run-time support in libgcc.  This will in\n@@ -67,15 +67,17 @@ along with GCC; see the file COPYING3.  If not see\n    to the symbol table early in the GIMPLE optimization path, before we\n    write things out to LTO intermediate files.  */\n \n-/* These two vectors, once fully populated, are kept in lock-step so that\n-   the index of a TLS variable equals the index of its control variable in\n-   the other vector.  */\n-static varpool_node_set tls_vars;\n-static vec<varpool_node *> control_vars;\n+/* Value for TLS varpool node where a pointer to control variable and\n+   access variable are stored.  */\n+struct tls_var_data\n+{\n+  varpool_node *control_var;\n+  tree access;\n+};\n \n-/* For the current basic block, an SSA_NAME that has computed the address \n-   of the TLS variable at the corresponding index.  */\n-static vec<tree> access_vars;\n+/* TLS map accesses mapping between a TLS varpool node and a pair\n+   made by control variable and access variable.  */\n+static hash_map<varpool_node *, tls_var_data> *tls_map = NULL;\n \n /* The type of the control structure, shared with the emutls.c runtime.  */\n static tree emutls_object_type;\n@@ -350,33 +352,6 @@ new_emutls_decl (tree decl, tree alias_of)\n   return to;\n }\n \n-/* Look up the index of the TLS variable DECL.  This index can then be\n-   used in both the control_vars and access_vars arrays.  */\n-\n-static unsigned int\n-emutls_index (tree decl)\n-{\n-  varpool_node_set_iterator i;\n-  \n-  i = varpool_node_set_find (tls_vars, varpool_node::get (decl));\n-  gcc_assert (i.index != ~0u);\n-\n-  return i.index;\n-}\n-\n-/* Look up the control variable for the TLS variable DECL.  */\n-\n-static tree\n-emutls_decl (tree decl)\n-{\n-  varpool_node *var;\n-  unsigned int i;\n-\n-  i = emutls_index (decl);\n-  var = control_vars[i];\n-  return var->decl;\n-}\n-\n /* Generate a call statement to initialize CONTROL_DECL for TLS_DECL.\n    This only needs to happen for TLS COMMON variables; non-COMMON\n    variables can be initialized statically.  Insert the generated\n@@ -423,19 +398,17 @@ struct lower_emutls_data\n static tree\n gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n {\n-  unsigned int index;\n-  tree addr;\n-\n   /* Compute the address of the TLS variable with help from runtime.  */\n-  index = emutls_index (decl);\n-  addr = access_vars[index];\n+  tls_var_data *data = tls_map->get (varpool_node::get (decl));\n+  tree addr = data->access;\n+\n   if (addr == NULL)\n     {\n       varpool_node *cvar;\n       tree cdecl;\n       gimple x;\n \n-      cvar = control_vars[index];\n+      cvar = data->control_var;\n       cdecl = cvar->decl;\n       TREE_ADDRESSABLE (cdecl) = 1;\n \n@@ -455,7 +428,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n       d->cfun_node->add_reference (cvar, IPA_REF_ADDR, x);\n \n       /* Record this ssa_name for possible use later in the basic block.  */\n-      access_vars[index] = addr;\n+      data->access = addr;\n     }\n \n   return addr;\n@@ -608,13 +581,22 @@ lower_emutls_phi_arg (gimple phi, unsigned int i, struct lower_emutls_data *d)\n     }\n }\n \n-/* Clear the ACCESS_VARS array, in order to begin a new block.  */\n+/* Reset access variable for a given TLS variable data DATA.  */\n+\n+bool\n+reset_access (varpool_node * const &, tls_var_data *data, void *)\n+{\n+  data->access = NULL;\n+\n+  return true;\n+}\n+\n+/* Clear the access variables, in order to begin a new block.  */\n \n static inline void\n clear_access_vars (void)\n {\n-  memset (access_vars.address (), 0,\n-          access_vars.length () * sizeof (tree));\n+  tls_map->traverse<void *, reset_access> (NULL);\n }\n \n /* Lower the entire function NODE.  */\n@@ -705,14 +687,13 @@ static bool\n create_emultls_var (varpool_node *var, void *data)\n {\n   tree cdecl;\n-  varpool_node *cvar;\n+  tls_var_data value;\n \n   cdecl = new_emutls_decl (var->decl,\n \t\t\t   var->alias && var->analyzed\n \t\t\t   ? var->get_alias_target ()->decl : NULL);\n \n-  cvar = varpool_node::get (cdecl);\n-  control_vars.quick_push (cvar);\n+  varpool_node *cvar = varpool_node::get (cdecl);\n \n   if (!var->alias)\n     {\n@@ -730,6 +711,10 @@ create_emultls_var (varpool_node *var, void *data)\n      which is special-cased inside the DWARF2 output routines.  */\n   SET_DECL_VALUE_EXPR (var->decl, cdecl);\n   DECL_HAS_VALUE_EXPR_P (var->decl) = 1;\n+\n+  value.control_var = cvar;\n+  tls_map->put (var, value);\n+\n   return false;\n }\n \n@@ -739,43 +724,37 @@ static unsigned int\n ipa_lower_emutls (void)\n {\n   varpool_node *var;\n-  struct cgraph_node *func;\n+  cgraph_node *func;\n   bool any_aliases = false;\n   tree ctor_body = NULL;\n-  unsigned int i, n_tls;\n \n-  tls_vars = varpool_node_set_new ();\n+  auto_vec <varpool_node *> tls_vars;\n \n   /* Examine all global variables for TLS variables.  */\n   FOR_EACH_VARIABLE (var)\n     if (DECL_THREAD_LOCAL_P (var->decl))\n       {\n \tgcc_checking_assert (TREE_STATIC (var->decl)\n \t\t\t     || DECL_EXTERNAL (var->decl));\n-\tvarpool_node_set_add (tls_vars, var);\n+\ttls_vars.safe_push (var);\n \tif (var->alias && var->definition)\n-\t  varpool_node_set_add (tls_vars, var->ultimate_alias_target ());\n+\t  tls_vars.safe_push (var->ultimate_alias_target ());\n       }\n \n   /* If we found no TLS variables, then there is no further work to do.  */\n-  if (!tls_vars->nodes.exists ())\n+  if (tls_vars.is_empty ())\n     {\n-      tls_vars = NULL;\n       if (dump_file)\n \tfprintf (dump_file, \"No TLS variables found.\\n\");\n       return 0;\n     }\n \n-  /* Allocate the on-the-side arrays that share indicies with the TLS vars.  */\n-  n_tls = tls_vars->nodes.length ();\n-  control_vars.create (n_tls);\n-  access_vars.create (n_tls);\n-  access_vars.safe_grow_cleared (n_tls);\n+  tls_map = new hash_map <varpool_node *, tls_var_data> ();\n \n   /* Create the control variables for each TLS variable.  */\n-  FOR_EACH_VEC_ELT (tls_vars->nodes, i, var)\n+  for (unsigned i = 0; i < tls_vars.length (); i++)\n     {\n-      var = tls_vars->nodes[i];\n+      var = tls_vars[i];\n \n       if (var->alias && !var->analyzed)\n \tany_aliases = true;\n@@ -787,10 +766,12 @@ ipa_lower_emutls (void)\n   if (any_aliases)\n     {\n       alias_pair *p;\n+      unsigned int i;\n       FOR_EACH_VEC_SAFE_ELT (alias_pairs, i, p)\n \tif (DECL_THREAD_LOCAL_P (p->decl))\n \t  {\n-\t    p->decl = emutls_decl (p->decl);\n+\t    p->decl = tls_map->get\n+\t      (varpool_node::get (p->decl))->control_var->decl;\n \t    p->target = get_emutls_object_name (p->target);\n \t  }\n     }\n@@ -804,9 +785,7 @@ ipa_lower_emutls (void)\n   if (ctor_body)\n     cgraph_build_static_cdtor ('I', ctor_body, DEFAULT_INIT_PRIORITY);\n \n-  control_vars.release ();\n-  access_vars.release ();\n-  free_varpool_node_set (tls_vars);\n+  delete tls_map;\n \n   return 0;\n }"}]}