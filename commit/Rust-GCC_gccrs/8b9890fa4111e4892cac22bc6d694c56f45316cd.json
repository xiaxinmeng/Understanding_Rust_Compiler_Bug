{"sha": "8b9890fa4111e4892cac22bc6d694c56f45316cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5ODkwZmE0MTExZTQ4OTJjYWMyMmJjNmQ2OTRjNTZmNDUzMTZjZA==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-04-24T10:42:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T10:42:30Z"}, "message": "prj-proc.adb, [...] (Project_Data.Seen): field removed.\n\n2009-04-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, makeutl.adb,\n\tclean.adb, prj-nmsc.adb, prj-env.adb, prj-env.ads (Project_Data.Seen):\n\tfield removed. This is not a property of the\n\tproject, just a boolean used to traverse the project tree, and storing\n\tit in the structure prevents doing multiple traversal in parallel.\n\t(Project_Data.Checked): also removed, since it was playing the same role\n\tas Seen when we had two nested loops, and this is no longer necessary\n\t(For_All_Imported_Projects): removed, since in fact there was already\n\tthe equivalent in For_Every_Project_Imported. The latter was rewritten\n\tto use a local hash table instead of Project_Data.Seen\n\tVarious loops were rewritten to use For_Every_Project_Imported, thus\n\tremoving the need for Project_Data.Seen. This avoids a lot of code\n\tduplication\n\nFrom-SVN: r146699", "tree": {"sha": "91ff2f053b43e69b2568c289f3b8b7443163499c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91ff2f053b43e69b2568c289f3b8b7443163499c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b9890fa4111e4892cac22bc6d694c56f45316cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9890fa4111e4892cac22bc6d694c56f45316cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b9890fa4111e4892cac22bc6d694c56f45316cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9890fa4111e4892cac22bc6d694c56f45316cd/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76e776e5e8c79221e20b722f3de2aa47aff82a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e776e5e8c79221e20b722f3de2aa47aff82a11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e776e5e8c79221e20b722f3de2aa47aff82a11"}], "stats": {"total": 1140, "additions": 467, "deletions": 673}, "files": [{"sha": "4385443ab0439d9f3bcc0f2f7893b283d5821246", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -1,3 +1,19 @@\n+2009-04-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, makeutl.adb,\n+\tclean.adb, prj-nmsc.adb, prj-env.adb, prj-env.ads (Project_Data.Seen):\n+\tfield removed. This is not a property of the\n+\tproject, just a boolean used to traverse the project tree, and storing\n+\tit in the structure prevents doing multiple traversal in parallel.\n+\t(Project_Data.Checked): also removed, since it was playing the same role\n+\tas Seen when we had two nested loops, and this is no longer necessary\n+\t(For_All_Imported_Projects): removed, since in fact there was already\n+\tthe equivalent in For_Every_Project_Imported. The latter was rewritten\n+\tto use a local hash table instead of Project_Data.Seen\n+\tVarious loops were rewritten to use For_Every_Project_Imported, thus\n+\tremoving the need for Project_Data.Seen. This avoids a lot of code\n+\tduplication\n+\n 2009-04-24  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Resolve_Actuals): Do not create blocks around code"}, {"sha": "8a70175cca8bdfcc0090398353b3d2ab95fb2954", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -878,7 +878,7 @@ package body Clean is\n                --  Source_Dirs or Source_Files is specified as an empty list,\n                --  so always look for Ada units in extending projects.\n \n-               if Data.Ada_Sources_Present\n+               if Has_Ada_Sources (Data)\n                  or else Data.Extends /= No_Project\n                then\n                   for Unit in Unit_Table.First ..\n@@ -1028,8 +1028,8 @@ package body Clean is\n                   for Proj in Project_Table.First ..\n                     Project_Table.Last (Project_Tree.Projects)\n                   loop\n-                     if Project_Tree.Projects.Table\n-                       (Proj).Other_Sources_Present\n+                     if Has_Foreign_Sources\n+                       (Project_Tree.Projects.Table (Proj))\n                      then\n                         Global_Archive := True;\n                         exit;"}, {"sha": "4478ce991e5912698d1088bf405d381f99b7de1d", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 41, "deletions": 140, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -587,15 +587,9 @@ package body Make is\n    procedure Debug_Msg (S : String; N : Unit_Name_Type);\n    --  If Debug.Debug_Flag_W is set outputs string S followed by name N\n \n-   procedure Recursive_Compute_Depth\n-     (Project : Project_Id;\n-      Depth   : Natural);\n+   procedure Recursive_Compute_Depth (Project : Project_Id);\n    --  Compute depth of Project and of the projects it depends on\n \n-   procedure Compute_All_Imported_Projects (Project : Project_Id);\n-   --  Compute, the list of the projects imported directly or indirectly by\n-   --  project Project.\n-\n    -----------------------\n    -- Gnatmake Routines --\n    -----------------------\n@@ -3717,95 +3711,6 @@ package body Make is\n       end if;\n    end Compile_Sources;\n \n-   -----------------------------------\n-   -- Compute_All_Imported_Projects --\n-   -----------------------------------\n-\n-   procedure Compute_All_Imported_Projects (Project : Project_Id) is\n-      procedure Add_To_List (Prj : Project_Id);\n-      --  Add a project to the list All_Imported_Projects of project Project\n-\n-      procedure Recursive_Add_Imported (Project : Project_Id);\n-      --  Recursively add the projects imported by project Project, but not\n-      --  those that are extended.\n-\n-      -----------------\n-      -- Add_To_List --\n-      -----------------\n-\n-      procedure Add_To_List (Prj : Project_Id) is\n-         Element : constant Project_Element :=\n-           (Prj, Project_Tree.Projects.Table (Project).All_Imported_Projects);\n-         List : Project_List;\n-      begin\n-         Project_List_Table.Increment_Last (Project_Tree.Project_Lists);\n-         List := Project_List_Table.Last (Project_Tree.Project_Lists);\n-         Project_Tree.Project_Lists.Table (List) := Element;\n-         Project_Tree.Projects.Table (Project).All_Imported_Projects := List;\n-      end Add_To_List;\n-\n-      ----------------------------\n-      -- Recursive_Add_Imported --\n-      ----------------------------\n-\n-      procedure Recursive_Add_Imported (Project : Project_Id) is\n-         List    : Project_List;\n-         Element : Project_Element;\n-         Prj     : Project_Id;\n-\n-      begin\n-         if Project /= No_Project then\n-\n-            --  For all the imported projects\n-\n-            List := Project_Tree.Projects.Table (Project).Imported_Projects;\n-            while List /= Empty_Project_List loop\n-               Element := Project_Tree.Project_Lists.Table (List);\n-               Prj := Element.Project;\n-\n-               --  Get the ultimate extending project\n-\n-               while\n-                 Project_Tree.Projects.Table (Prj).Extended_By /= No_Project\n-               loop\n-                  Prj := Project_Tree.Projects.Table (Prj).Extended_By;\n-               end loop;\n-\n-               --  If project has not yet been visited, add to list and recurse\n-\n-               if not Project_Tree.Projects.Table (Prj).Seen then\n-                  Project_Tree.Projects.Table (Prj).Seen := True;\n-                  Add_To_List (Prj);\n-                  Recursive_Add_Imported (Prj);\n-               end if;\n-\n-               List := Element.Next;\n-            end loop;\n-\n-            --  Recurse on projects being imported, if any\n-\n-            Recursive_Add_Imported\n-              (Project_Tree.Projects.Table (Project).Extends);\n-         end if;\n-      end Recursive_Add_Imported;\n-\n-   begin\n-      --  Reset the Seen flag for all projects\n-\n-      for Index in 1 .. Project_Table.Last (Project_Tree.Projects) loop\n-         Project_Tree.Projects.Table (Index).Seen := False;\n-      end loop;\n-\n-      --  Make sure the list is empty\n-\n-      Project_Tree.Projects.Table (Project).All_Imported_Projects :=\n-        Empty_Project_List;\n-\n-      --  Add to the list all projects imported directly or indirectly\n-\n-      Recursive_Add_Imported (Project);\n-   end Compute_All_Imported_Projects;\n-\n    ----------------------------------\n    -- Configuration_Pragmas_Switch --\n    ----------------------------------\n@@ -7065,24 +6970,15 @@ package body Make is\n          Add_Source_Directories (Main_Project, Project_Tree);\n          Add_Object_Directories (Main_Project, Project_Tree);\n \n-         --  Compute depth of each project\n-\n-         for Proj in Project_Table.First ..\n-                     Project_Table.Last (Project_Tree.Projects)\n-         loop\n-            Project_Tree.Projects.Table (Proj).Seen := False;\n-            Project_Tree.Projects.Table (Proj).Depth := 0;\n-         end loop;\n-\n-         Recursive_Compute_Depth (Main_Project, Depth => 1);\n+         Recursive_Compute_Depth (Main_Project);\n \n          --  For each project compute the list of the projects it imports\n          --  directly or indirectly.\n \n          for Proj in Project_Table.First ..\n                      Project_Table.Last (Project_Tree.Projects)\n          loop\n-            Compute_All_Imported_Projects (Proj);\n+            Compute_All_Imported_Projects (Proj, Project_Tree);\n          end loop;\n \n       else\n@@ -7632,51 +7528,56 @@ package body Make is\n    -- Recursive_Compute_Depth --\n    -----------------------------\n \n-   procedure Recursive_Compute_Depth\n-     (Project : Project_Id;\n-      Depth   : Natural)\n-   is\n-      List : Project_List;\n-      Proj : Project_Id;\n+   procedure Recursive_Compute_Depth (Project : Project_Id) is\n+      use Project_Boolean_Htable;\n+      Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n \n-   begin\n-      --  Nothing to do if there is no project or if the project has already\n-      --  been seen or if the depth is large enough.\n+      procedure Recurse (Prj : Project_Id; Depth : Natural);\n \n-      if Project = No_Project\n-        or else Project_Tree.Projects.Table (Project).Seen\n-        or else Project_Tree.Projects.Table (Project).Depth >= Depth\n-      then\n-         return;\n-      end if;\n+      procedure Recurse (Prj : Project_Id; Depth : Natural) is\n+         Data : Project_Data renames Project_Tree.Projects.Table (Prj);\n+         List : Project_List;\n+         Proj : Project_Id;\n+      begin\n+         if Data.Depth >= Depth\n+           or Get (Seen, Prj)\n+         then\n+            return;\n+         end if;\n \n-      Project_Tree.Projects.Table (Project).Depth := Depth;\n+         --  We need a test to avoid infinite recursions with limited withs:\n+         --  If we have A -> B -> A, then when set level of A to n, we try and\n+         --  set level of B to n+1, and then level of A to n + 2,...\n \n-      --  Mark project as Seen to avoid endless loop caused by limited withs\n+         Set (Seen, Prj, True);\n \n-      Project_Tree.Projects.Table (Project).Seen := True;\n+         Data.Depth := Depth;\n \n-      List := Project_Tree.Projects.Table (Project).Imported_Projects;\n+         List := Data.Imported_Projects;\n \n-      --  Visit each imported project\n+         --  Visit each imported project\n \n-      while List /= Empty_Project_List loop\n-         Proj := Project_Tree.Project_Lists.Table (List).Project;\n-         List := Project_Tree.Project_Lists.Table (List).Next;\n-         Recursive_Compute_Depth\n-           (Project => Proj,\n-            Depth => Depth + 1);\n-      end loop;\n+         while List /= Empty_Project_List loop\n+            Proj := Project_Tree.Project_Lists.Table (List).Project;\n+            List := Project_Tree.Project_Lists.Table (List).Next;\n+            Recurse (Prj => Proj, Depth => Depth + 1);\n+         end loop;\n \n-      --  Visit a project being extended, if any\n+         --  We again allow changing the depth of this project later on if it\n+         --  is in fact imported by a lower-level project.\n \n-      Recursive_Compute_Depth\n-        (Project => Project_Tree.Projects.Table (Project).Extends,\n-         Depth   => Depth + 1);\n+         Set (Seen, Prj, False);\n+      end Recurse;\n \n-      --  Reset the Seen flag, as we leave this project\n+   begin\n+      for Proj in Project_Table.First ..\n+        Project_Table.Last (Project_Tree.Projects)\n+      loop\n+         Project_Tree.Projects.Table (Proj).Depth := 0;\n+      end loop;\n \n-      Project_Tree.Projects.Table (Project).Seen := False;\n+      Recurse (Project, Depth => 1);\n+      Reset (Seen);\n    end Recursive_Compute_Depth;\n \n    -------------------------------"}, {"sha": "7281711ffbe2d2a91902c9233c4870372e669734", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -364,74 +364,53 @@ package body Makeutl is\n      (Project  : Project_Id;\n       In_Tree  : Project_Tree_Ref) return String_List\n    is\n-      procedure Recursive_Add_Linker_Options (Proj : Project_Id);\n+      procedure Recursive_Add (Proj : Project_Id; Dummy : in out Boolean);\n       --  The recursive routine used to add linker options\n \n-      ----------------------------------\n-      -- Recursive_Add_Linker_Options --\n-      ----------------------------------\n+      -------------------\n+      -- Recursive_Add --\n+      -------------------\n \n-      procedure Recursive_Add_Linker_Options (Proj : Project_Id) is\n-         Data           : Project_Data;\n+      procedure Recursive_Add (Proj : Project_Id; Dummy : in out Boolean) is\n+         pragma Unreferenced (Dummy);\n+         Data           : Project_Data renames In_Tree.Projects.Table (Proj);\n          Linker_Package : Package_Id;\n          Options        : Variable_Value;\n-         Imported       : Project_List;\n \n       begin\n-         if Proj /= No_Project then\n-            Data := In_Tree.Projects.Table (Proj);\n-\n-            if not Data.Seen then\n-               In_Tree.Projects.Table (Proj).Seen := True;\n-               Imported := Data.Imported_Projects;\n-\n-               while Imported /= Empty_Project_List loop\n-                  Recursive_Add_Linker_Options\n-                    (In_Tree.Project_Lists.Table\n-                       (Imported).Project);\n-                  Imported := In_Tree.Project_Lists.Table\n-                                (Imported).Next;\n-               end loop;\n-\n-               if Proj /= Project then\n-                  Linker_Package :=\n-                    Prj.Util.Value_Of\n-                      (Name        => Name_Linker,\n-                       In_Packages => Data.Decl.Packages,\n-                       In_Tree     => In_Tree);\n-                  Options :=\n-                    Prj.Util.Value_Of\n-                      (Name                    => Name_Ada,\n-                       Index                   => 0,\n-                       Attribute_Or_Array_Name => Name_Linker_Options,\n-                       In_Package              => Linker_Package,\n-                       In_Tree                 => In_Tree);\n-\n-                  --  If attribute is present, add the project with\n-                  --  the attribute to table Linker_Opts.\n-\n-                  if Options /= Nil_Variable_Value then\n-                     Linker_Opts.Increment_Last;\n-                     Linker_Opts.Table (Linker_Opts.Last) :=\n-                       (Project => Proj, Options => Options.Values);\n-                  end if;\n-               end if;\n-            end if;\n+         Linker_Package :=\n+           Prj.Util.Value_Of\n+             (Name        => Name_Linker,\n+              In_Packages => Data.Decl.Packages,\n+              In_Tree     => In_Tree);\n+         Options :=\n+           Prj.Util.Value_Of\n+             (Name                    => Name_Ada,\n+              Index                   => 0,\n+              Attribute_Or_Array_Name => Name_Linker_Options,\n+              In_Package              => Linker_Package,\n+              In_Tree                 => In_Tree);\n+\n+         --  If attribute is present, add the project with\n+         --  the attribute to table Linker_Opts.\n+\n+         if Options /= Nil_Variable_Value then\n+            Linker_Opts.Increment_Last;\n+            Linker_Opts.Table (Linker_Opts.Last) :=\n+              (Project => Proj, Options => Options.Values);\n          end if;\n-      end Recursive_Add_Linker_Options;\n+      end Recursive_Add;\n+\n+      procedure For_All_Projects is\n+        new For_Every_Project_Imported (Boolean, Recursive_Add);\n+      Dummy : Boolean := False;\n \n    --  Start of processing for Linker_Options_Switches\n \n    begin\n       Linker_Opts.Init;\n \n-      for Index in Project_Table.First ..\n-                   Project_Table.Last (In_Tree.Projects)\n-      loop\n-         In_Tree.Projects.Table (Index).Seen := False;\n-      end loop;\n-\n-      Recursive_Add_Linker_Options (Project);\n+      For_All_Projects (Project, In_Tree, Dummy);\n \n       Last_Linker_Option := 0;\n \n@@ -449,8 +428,7 @@ package body Makeutl is\n                In_Tree.Projects.Table (Proj).Dir_Path :=\n                  new String'\n                    (Get_Name_String\n-                        (In_Tree.Projects.Table\n-                             (Proj).Directory.Name));\n+                        (In_Tree.Projects.Table (Proj).Directory.Name));\n             end if;\n \n             while Options /= Nil_String loop"}, {"sha": "167dfdb7832f9669462a06e480e4fbdfc64223c7", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2008, AdaCore                     --\n+--                     Copyright (C) 2001-2009, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "e3cdf4cae57a49ac2b97cf5a9bc759e1e55f97af", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 81, "deletions": 372, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -30,22 +30,10 @@ with Output;   use Output;\n with Prj.Com;  use Prj.Com;\n with Tempdir;\n \n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n package body Prj.Env is\n \n    Default_Naming    : constant Naming_Id := Naming_Table.First;\n \n-   package Project_Boolean_Htable is new Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Project_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  A table that associates a project to a boolean. This is used to detect\n-   --  whether a project was already processed for instance.\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -73,9 +61,6 @@ package body Prj.Env is\n    --  Add Object_Dir to object path table. Make sure it is not duplicate\n    --  and it is the last one in the current table.\n \n-   function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean;\n-   --  Return True if there is at least one ALI file in the directory Dir\n-\n    procedure Set_Path_File_Var (Name : String; Value : String);\n    --  Call Setenv, after calling To_Host_File_Spec\n \n@@ -91,70 +76,35 @@ package body Prj.Env is\n \n    function Ada_Include_Path\n      (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return String_Access is\n-\n-      procedure Add (Project : Project_Id);\n-      --  Add all the source directories of a project to the path only if\n-      --  this project has not been visited. Calls itself recursively for\n-      --  projects being extended, and imported projects. Adds the project\n-      --  to the list Seen if this is the call to Add for this project.\n+      In_Tree : Project_Tree_Ref) return String_Access\n+   is\n+      procedure Add (Project : Project_Id; Dummy : in out Boolean);\n+      --  Add source dirs of Project to the path\n \n       ---------\n       -- Add --\n       ---------\n \n-      procedure Add (Project : Project_Id) is\n+      procedure Add (Project : Project_Id; Dummy : in out Boolean) is\n+         pragma Unreferenced (Dummy);\n       begin\n-         --  If Seen is empty, then the project cannot have been visited\n-\n-         if not In_Tree.Projects.Table (Project).Seen then\n-            In_Tree.Projects.Table (Project).Seen := True;\n-\n-            declare\n-               Data : constant Project_Data :=\n-                        In_Tree.Projects.Table (Project);\n-               List : Project_List := Data.Imported_Projects;\n-\n-            begin\n-               --  Add to path all source directories of this project\n-\n-               Add_To_Path (Data.Source_Dirs, In_Tree);\n-\n-               --  Call Add to the project being extended, if any\n-\n-               if Data.Extends /= No_Project then\n-                  Add (Data.Extends);\n-               end if;\n-\n-               --  Call Add for each imported project, if any\n-\n-               while List /= Empty_Project_List loop\n-                  Add\n-                    (In_Tree.Project_Lists.Table (List).Project);\n-                  List := In_Tree.Project_Lists.Table (List).Next;\n-               end loop;\n-            end;\n-         end if;\n+         Add_To_Path (In_Tree.Projects.Table (Project).Source_Dirs, In_Tree);\n       end Add;\n \n+      procedure For_All_Projects is\n+        new For_Every_Project_Imported (Boolean, Add);\n+      Dummy : Boolean := False;\n+\n    --  Start of processing for Ada_Include_Path\n \n    begin\n       --  If it is the first time we call this function for\n       --  this project, compute the source path\n \n-      if\n-        In_Tree.Projects.Table (Project).Ada_Include_Path = null\n-      then\n+      if In_Tree.Projects.Table (Project).Ada_Include_Path = null then\n          In_Tree.Private_Part.Ada_Path_Length := 0;\n+         For_All_Projects (Project, In_Tree, Dummy);\n \n-         for Index in Project_Table.First ..\n-                      Project_Table.Last (In_Tree.Projects)\n-         loop\n-            In_Tree.Projects.Table (Index).Seen := False;\n-         end loop;\n-\n-         Add (Project);\n          In_Tree.Projects.Table (Project).Ada_Include_Path :=\n            new String'\n              (In_Tree.Private_Part.Ada_Path_Buffer\n@@ -195,102 +145,40 @@ package body Prj.Env is\n       In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean := True) return String_Access\n    is\n-      procedure Add (Project : Project_Id);\n-      --  Add all the object directories of a project to the path only if\n-      --  this project has not been visited. Calls itself recursively for\n-      --  projects being extended, and imported projects. Adds the project\n-      --  to the list Seen if this is the first call to Add for this project.\n+      procedure Add (Project : Project_Id; Dummy : in out Boolean);\n+      --  Add all the object directories of a project to the path\n \n       ---------\n       -- Add --\n       ---------\n \n-      procedure Add (Project : Project_Id) is\n+      procedure Add (Project : Project_Id; Dummy : in out Boolean) is\n+         pragma Unreferenced (Dummy);\n+         Path : constant Path_Name_Type :=\n+           Get_Object_Directory\n+             (In_Tree, Project,\n+              Including_Libraries => Including_Libraries,\n+              Only_If_Ada         => False);\n       begin\n-         --  If this project has not been seen yet\n-\n-         if not In_Tree.Projects.Table (Project).Seen then\n-            In_Tree.Projects.Table (Project).Seen := True;\n-\n-            declare\n-               Data : constant Project_Data :=\n-                 In_Tree.Projects.Table (Project);\n-               List : Project_List := Data.Imported_Projects;\n-\n-            begin\n-               --  Add to path the object directory of this project\n-               --  except if we don't include library project and\n-               --  this is a library project.\n-\n-               if (Data.Library and then Including_Libraries)\n-                 or else\n-                 (Data.Object_Directory /= No_Path_Information\n-                   and then\n-                   (not Including_Libraries or else not Data.Library))\n-               then\n-                  --  For a library project, add the library directory,\n-                  --  if there is no object directory or if it contains ALI\n-                  --  files; otherwise add the object directory.\n-\n-                  if Data.Library then\n-                     if Data.Object_Directory = No_Path_Information\n-                       or else\n-                         Contains_ALI_Files (Data.Library_ALI_Dir.Name)\n-                     then\n-                        Add_To_Path\n-                          (Get_Name_String (Data.Library_ALI_Dir.Name),\n-                           In_Tree);\n-                     else\n-                        Add_To_Path\n-                          (Get_Name_String (Data.Object_Directory.Name),\n-                           In_Tree);\n-                     end if;\n-\n-                  else\n-                     --  For a non library project, add the object directory\n-\n-                     Add_To_Path\n-                       (Get_Name_String (Data.Object_Directory.Name),\n-                        In_Tree);\n-                  end if;\n-               end if;\n-\n-               --  Call Add to the project being extended, if any\n-\n-               if Data.Extends /= No_Project then\n-                  Add (Data.Extends);\n-               end if;\n-\n-               --  Call Add for each imported project, if any\n-\n-               while List /= Empty_Project_List loop\n-                  Add\n-                    (In_Tree.Project_Lists.Table (List).Project);\n-                  List := In_Tree.Project_Lists.Table (List).Next;\n-               end loop;\n-            end;\n-\n+         if Path /= No_Path then\n+            Add_To_Path (Get_Name_String (Path), In_Tree);\n          end if;\n       end Add;\n \n+      procedure For_All_Projects is\n+        new For_Every_Project_Imported (Boolean, Add);\n+      Dummy : Boolean := False;\n+\n    --  Start of processing for Ada_Objects_Path\n \n    begin\n       --  If it is the first time we call this function for\n       --  this project, compute the objects path\n \n-      if\n-        In_Tree.Projects.Table (Project).Ada_Objects_Path = null\n-      then\n+      if In_Tree.Projects.Table (Project).Ada_Objects_Path = null then\n          In_Tree.Private_Part.Ada_Path_Length := 0;\n+         For_All_Projects (Project, In_Tree, Dummy);\n \n-         for Index in Project_Table.First ..\n-                      Project_Table.Last (In_Tree.Projects)\n-         loop\n-            In_Tree.Projects.Table (Index).Seen := False;\n-         end loop;\n-\n-         Add (Project);\n          In_Tree.Projects.Table (Project).Ada_Objects_Path :=\n            new String'\n              (In_Tree.Private_Part.Ada_Path_Buffer\n@@ -495,45 +383,6 @@ package body Prj.Env is\n       end loop;\n    end Add_To_Source_Path;\n \n-   ------------------------\n-   -- Contains_ALI_Files --\n-   ------------------------\n-\n-   function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean is\n-      Dir_Name : constant String := Get_Name_String (Dir);\n-      Direct : Dir_Type;\n-      Name   : String (1 .. 1_000);\n-      Last   : Natural;\n-      Result : Boolean := False;\n-\n-   begin\n-      Open (Direct, Dir_Name);\n-\n-      --  For each file in the directory, check if it is an ALI file\n-\n-      loop\n-         Read (Direct, Name, Last);\n-         exit when Last = 0;\n-         Canonical_Case_File_Name (Name (1 .. Last));\n-         Result := Last >= 5 and then Name (Last - 3 .. Last) = \".ali\";\n-         exit when Result;\n-      end loop;\n-\n-      Close (Direct);\n-      return Result;\n-\n-   exception\n-      --  If there is any problem, close the directory if open and return\n-      --  True; the library directory will be added to the path.\n-\n-      when others =>\n-         if Is_Open (Direct) then\n-            Close (Direct);\n-         end if;\n-\n-         return True;\n-   end Contains_ALI_Files;\n-\n    --------------------------------\n    -- Create_Config_Pragmas_File --\n    --------------------------------\n@@ -1457,56 +1306,6 @@ package body Prj.Env is\n       return \"\";\n    end File_Name_Of_Library_Unit_Body;\n \n-   -------------------------------\n-   -- For_All_Imported_Projects --\n-   -------------------------------\n-\n-   procedure For_All_Imported_Projects\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n-   is\n-      use Project_Boolean_Htable;\n-      Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n-\n-      procedure Recurse (Prj : Project_Id);\n-      --  Process Prj recursively\n-\n-      -------------\n-      -- Recurse --\n-      -------------\n-\n-      procedure Recurse (Prj : Project_Id) is\n-         Data : Project_Data renames In_Tree.Projects.Table (Prj);\n-         List : Project_List := Data.Imported_Projects;\n-\n-      begin\n-         if not Get (Seen, Prj) then\n-            Set (Seen, Prj, True);\n-\n-            Action (Prj);\n-\n-            --  If we are extending a project, visit it\n-\n-            if Data.Extends /= No_Project then\n-               Recurse (Data.Extends);\n-            end if;\n-\n-            --  And visit all imported projects\n-\n-            while List /= Empty_Project_List loop\n-               Recurse (In_Tree.Project_Lists.Table (List).Project);\n-               List := In_Tree.Project_Lists.Table (List).Next;\n-            end loop;\n-         end if;\n-      end Recurse;\n-\n-   --  Start of processing for For_All_Imported_Projects\n-\n-   begin\n-      Recurse (Project);\n-      Reset (Seen);\n-   end For_All_Imported_Projects;\n-\n    -------------------------\n    -- For_All_Object_Dirs --\n    -------------------------\n@@ -1515,28 +1314,34 @@ package body Prj.Env is\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref)\n    is\n-      procedure For_Project (Prj : Project_Id);\n+      procedure For_Project (Prj : Project_Id; Dummy : in out Integer);\n       --  Get all object directories of Prj\n \n       -----------------\n       -- For_Project --\n       -----------------\n \n-      procedure For_Project (Prj : Project_Id) is\n+      procedure For_Project (Prj : Project_Id; Dummy : in out Integer) is\n+         pragma Unreferenced (Dummy);\n          Data : Project_Data renames In_Tree.Projects.Table (Prj);\n       begin\n+         --  ??? Set_Ada_Paths has a different behavior for library project\n+         --  files, should we have the same ?\n+\n          if Data.Object_Directory /= No_Path_Information then\n             Get_Name_String (Data.Object_Directory.Display_Name);\n             Action (Name_Buffer (1 .. Name_Len));\n          end if;\n       end For_Project;\n \n-      procedure Get_Object_Dirs is new For_All_Imported_Projects (For_Project);\n+      procedure Get_Object_Dirs is\n+        new For_Every_Project_Imported (Integer, For_Project);\n+      Dummy : Integer := 1;\n \n    --  Start of processing for For_All_Object_Dirs\n \n    begin\n-      Get_Object_Dirs (Project, In_Tree);\n+      Get_Object_Dirs (Project, In_Tree, Dummy);\n    end For_All_Object_Dirs;\n \n    -------------------------\n@@ -1547,14 +1352,15 @@ package body Prj.Env is\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref)\n    is\n-      procedure For_Project (Prj : Project_Id);\n+      procedure For_Project (Prj : Project_Id; Dummy : in out Integer);\n       --  Get all object directories of Prj\n \n       -----------------\n       -- For_Project --\n       -----------------\n \n-      procedure For_Project (Prj : Project_Id) is\n+      procedure For_Project (Prj : Project_Id; Dummy : in out Integer) is\n+         pragma Unreferenced (Dummy);\n          Data       : Project_Data renames In_Tree.Projects.Table (Prj);\n          Current    : String_List_Id := Data.Source_Dirs;\n          The_String : String_Element;\n@@ -1572,12 +1378,14 @@ package body Prj.Env is\n          end if;\n       end For_Project;\n \n-      procedure Get_Source_Dirs is new For_All_Imported_Projects (For_Project);\n+      procedure Get_Source_Dirs is\n+        new For_Every_Project_Imported (Integer, For_Project);\n+      Dummy : Integer := 1;\n \n    --  Start of processing for For_All_Source_Dirs\n \n    begin\n-      Get_Source_Dirs (Project, In_Tree);\n+      Get_Source_Dirs (Project, In_Tree, Dummy);\n    end For_All_Source_Dirs;\n \n    -------------------\n@@ -1860,146 +1668,45 @@ package body Prj.Env is\n \n       Len : Natural;\n \n-      procedure Add (Proj : Project_Id);\n-      --  Add all the source/object directories of a project to the path only\n-      --  if this project has not been visited. Calls an internal procedure\n-      --  recursively for projects being extended, and imported projects.\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add (Proj : Project_Id) is\n-\n-         procedure Recursive_Add (Project : Project_Id);\n-         --  Recursive procedure to add the source/object paths of extended/\n-         --  imported projects.\n-\n-         -------------------\n-         -- Recursive_Add --\n-         -------------------\n+      procedure Recursive_Add (Project : Project_Id; Dummy : in out Boolean);\n+      --  Recursive procedure to add the source/object paths of extended/\n+      --  imported projects.\n \n-         procedure Recursive_Add (Project : Project_Id) is\n-         begin\n-            --  If Seen is False, then the project has not yet been visited\n+      -------------------\n+      -- Recursive_Add --\n+      -------------------\n \n-            if not In_Tree.Projects.Table (Project).Seen then\n-               In_Tree.Projects.Table (Project).Seen := True;\n-\n-               declare\n-                  Data : constant Project_Data :=\n-                    In_Tree.Projects.Table (Project);\n-                  List : Project_List := Data.Imported_Projects;\n-\n-               begin\n-                  if Process_Source_Dirs then\n-\n-                     --  Add to path all source directories of this project if\n-                     --  there are Ada sources.\n-\n-                     if In_Tree.Projects.Table (Project).Ada_Sources /=\n-                        Nil_String\n-                     then\n-                        Add_To_Source_Path (Data.Source_Dirs, In_Tree);\n-                     end if;\n-                  end if;\n-\n-                  if Process_Object_Dirs then\n-\n-                     --  Add to path the object directory of this project\n-                     --  except if we don't include library project and this\n-                     --  is a library project.\n-\n-                     if (Data.Library and Including_Libraries)\n-                       or else\n-                         (Data.Object_Directory /= No_Path_Information\n-                           and then\n-                            (not Including_Libraries or else not Data.Library))\n-                     then\n-                        --  For a library project, add the library ALI\n-                        --  directory if there is no object directory or\n-                        --  if the library ALI directory contains ALI files;\n-                        --  otherwise add the object directory.\n-\n-                        if Data.Library then\n-                           if Data.Object_Directory = No_Path_Information\n-                             or else Contains_ALI_Files\n-                               (Data.Library_ALI_Dir.Name)\n-                           then\n-                              Add_To_Object_Path\n-                                (Data.Library_ALI_Dir.Name, In_Tree);\n-                           else\n-                              Add_To_Object_Path\n-                                (Data.Object_Directory.Name, In_Tree);\n-                           end if;\n-\n-                        --  For a non-library project, add object directory if\n-                        --  it is not a virtual project, and if there are Ada\n-                        --  sources in the project or one of the projects it\n-                        --  extends. If there are no Ada sources, adding the\n-                        --  object directory could disrupt the order of the\n-                        --  object dirs in the path.\n-\n-                        elsif not Data.Virtual then\n-                           declare\n-                              Add_Object_Dir : Boolean    := False;\n-                              Prj            : Project_Id := Project;\n-\n-                           begin\n-                              while not Add_Object_Dir\n-                                and then Prj /= No_Project\n-                              loop\n-                                 if In_Tree.Projects.Table\n-                                      (Prj).Ada_Sources /= Nil_String\n-                                 then\n-                                    Add_Object_Dir := True;\n-\n-                                 else\n-                                    Prj :=\n-                                      In_Tree.Projects.Table (Prj).Extends;\n-                                 end if;\n-                              end loop;\n-\n-                              if Add_Object_Dir then\n-                                 Add_To_Object_Path\n-                                   (Data.Object_Directory.Name, In_Tree);\n-                              end if;\n-                           end;\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-                  --  Call Add to the project being extended, if any\n-\n-                  if Data.Extends /= No_Project then\n-                     Recursive_Add (Data.Extends);\n-                  end if;\n+      procedure Recursive_Add (Project : Project_Id; Dummy : in out Boolean) is\n+         pragma Unreferenced (Dummy);\n+         Data : constant Project_Data := In_Tree.Projects.Table (Project);\n+         Path : Path_Name_Type;\n+      begin\n+         --  ??? This is almost the equivalent of For_All_Source_Dirs\n+         if Process_Source_Dirs then\n \n-                  --  Call Add for each imported project, if any\n+            --  Add to path all source directories of this project if\n+            --  there are Ada sources.\n \n-                  while List /= Empty_Project_List loop\n-                     Recursive_Add\n-                       (In_Tree.Project_Lists.Table\n-                          (List).Project);\n-                     List :=\n-                       In_Tree.Project_Lists.Table (List).Next;\n-                  end loop;\n-               end;\n+            if Has_Ada_Sources (In_Tree.Projects.Table (Project)) then\n+               Add_To_Source_Path (Data.Source_Dirs, In_Tree);\n             end if;\n-         end Recursive_Add;\n+         end if;\n \n-      begin\n-         Source_Path_Table.Set_Last (In_Tree.Private_Part.Source_Paths, 0);\n-         Object_Path_Table.Set_Last (In_Tree.Private_Part.Object_Paths, 0);\n+         if Process_Object_Dirs then\n+            Path := Get_Object_Directory\n+              (In_Tree, Project,\n+               Including_Libraries => Including_Libraries,\n+               Only_If_Ada         => True);\n \n-         for Index in Project_Table.First ..\n-                      Project_Table.Last (In_Tree.Projects)\n-         loop\n-            In_Tree.Projects.Table (Index).Seen := False;\n-         end loop;\n+            if Path /= No_Path then\n+               Add_To_Object_Path (Path, In_Tree);\n+            end if;\n+         end if;\n+      end Recursive_Add;\n \n-         Recursive_Add (Proj);\n-      end Add;\n+      procedure For_All_Projects is\n+        new For_Every_Project_Imported (Boolean, Recursive_Add);\n+      Dummy : Boolean := False;\n \n    --  Start of processing for Set_Ada_Paths\n \n@@ -2042,7 +1749,9 @@ package body Prj.Env is\n       --  then call the recursive procedure Add for Project.\n \n       if Process_Source_Dirs or Process_Object_Dirs then\n-         Add (Project);\n+         Source_Path_Table.Set_Last (In_Tree.Private_Part.Source_Paths, 0);\n+         Object_Path_Table.Set_Last (In_Tree.Private_Part.Object_Paths, 0);\n+         For_All_Projects (Project, In_Tree, Dummy);\n       end if;\n \n       --  Write and close any file that has been created"}, {"sha": "0f12ebbef26a47fd025dcd21fcf7c8c34ca97e6c", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -172,11 +172,4 @@ package Prj.Env is\n    --  Iterate through all the object directories of a project, including\n    --  those of imported or modified projects.\n \n-   generic\n-      with procedure Action (Project : Project_Id);\n-   procedure For_All_Imported_Projects\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n-   --  Execute Action for Project and all imported or extended projects\n-\n end Prj.Env;"}, {"sha": "3928fc19210046d7595c91a6893ac4aee603518b", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -5445,7 +5445,7 @@ package body Prj.Nmsc is\n                      Read (Dir, Name_Buffer, Name_Len);\n \n                      if Current_Verbosity = High then\n-                        Write_Str  (\"   Checking \");\n+                        Write_Str  (\" Checking \");\n                         Write_Line (Name_Buffer (1 .. Name_Len));\n                      end if;\n \n@@ -6450,7 +6450,7 @@ package body Prj.Nmsc is\n \n       if Last = Filename'Last then\n          if Current_Verbosity = High then\n-            Write_Line (\"  No matching suffix\");\n+            Write_Line (\"   No matching suffix\");\n          end if;\n          return;\n       end if;\n@@ -6602,9 +6602,9 @@ package body Prj.Nmsc is\n         and then Current_Verbosity = High\n       then\n          case Kind is\n-            when Spec => Write_Str (\"     spec of \");\n-            when Impl => Write_Str (\"     body of \");\n-            when Sep  => Write_Str (\"     sep of \");\n+            when Spec => Write_Str (\"   spec of \");\n+            when Impl => Write_Str (\"   body of \");\n+            when Sep  => Write_Str (\"   sep of \");\n          end case;\n \n          Write_Line (Get_Name_String (Unit));\n@@ -8456,7 +8456,7 @@ package body Prj.Nmsc is\n \n             begin\n                if Current_Verbosity = High then\n-                  Write_Str  (\"Putting \");\n+                  Write_Str  (\"   Putting \");\n                   Write_Str  (Get_Name_String (Unit_Name));\n                   Write_Line (\" in the unit list.\");\n                end if;"}, {"sha": "e4ffe49824e277e4b913f407c995a223d2fca319", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 27, "deletions": 62, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -141,16 +141,19 @@ package body Prj.Proc is\n    --  recursively for all imported projects and a extended project, if any.\n    --  Then process the declarative items of the project.\n \n-   procedure Recursive_Check\n-     (Project         : Project_Id;\n+   type Recursive_Check_Data is record\n       In_Tree         : Project_Tree_Ref;\n-      Current_Dir     : String;\n-      When_No_Sources : Error_Warning);\n-   --  If Project is not marked as checked, mark it as checked, call\n-   --  Check_Naming_Scheme for the project, then call itself for a\n-   --  possible extended project and all the imported projects of Project.\n+      Current_Dir     : String_Access;\n+      When_No_Sources : Error_Warning;\n+   end record;\n+   --  Data passed to Recursive_Check\n    --  Current_Dir is for optimization purposes, avoiding extra system calls.\n \n+   procedure Recursive_Check\n+     (Project         : Project_Id;\n+      Data            : in out Recursive_Check_Data);\n+   --  Check_Naming_Scheme for the project\n+\n    ---------\n    -- Add --\n    ---------\n@@ -274,16 +277,14 @@ package body Prj.Proc is\n       Current_Dir     : String;\n       When_No_Sources : Error_Warning)\n    is\n-   begin\n-      --  Make sure that all projects are marked as not checked\n+      Dir : aliased String := Current_Dir;\n \n-      for Index in Project_Table.First ..\n-                   Project_Table.Last (In_Tree.Projects)\n-      loop\n-         In_Tree.Projects.Table (Index).Checked := False;\n-      end loop;\n-\n-      Recursive_Check (Project, In_Tree, Current_Dir, When_No_Sources);\n+      procedure Check_All_Projects is new\n+        For_Every_Project_Imported (Recursive_Check_Data, Recursive_Check);\n+      Data : Recursive_Check_Data :=\n+        (In_Tree, Dir'Unchecked_Access, When_No_Sources);\n+   begin\n+      Check_All_Projects (Project, In_Tree, Data, Imported_First => True);\n \n       --  Set the Other_Part field for the units\n \n@@ -2461,55 +2462,19 @@ package body Prj.Proc is\n \n    procedure Recursive_Check\n      (Project         : Project_Id;\n-      In_Tree         : Project_Tree_Ref;\n-      Current_Dir     : String;\n-      When_No_Sources : Error_Warning)\n+      Data            : in out Recursive_Check_Data)\n    is\n-      Data                  : Project_Data;\n-      Imported_Project_List : Project_List := Empty_Project_List;\n-\n    begin\n-      --  Do nothing if Project is No_Project, or Project has already\n-      --  been marked as checked.\n-\n-      if Project /= No_Project\n-        and then not In_Tree.Projects.Table (Project).Checked\n-      then\n-         --  Mark project as checked, to avoid infinite recursion in\n-         --  ill-formed trees, where a project imports itself.\n-\n-         In_Tree.Projects.Table (Project).Checked := True;\n-\n-         Data := In_Tree.Projects.Table (Project);\n-\n-         --  Call itself for a possible extended project.\n-         --  (if there is no extended project, then nothing happens).\n-\n-         Recursive_Check (Data.Extends, In_Tree, Current_Dir, When_No_Sources);\n-\n-         --  Call itself for all imported projects\n-\n-         Imported_Project_List := Data.Imported_Projects;\n-         while Imported_Project_List /= Empty_Project_List loop\n-            Recursive_Check\n-              (In_Tree.Project_Lists.Table\n-                 (Imported_Project_List).Project,\n-               In_Tree, Current_Dir, When_No_Sources);\n-            Imported_Project_List :=\n-              In_Tree.Project_Lists.Table\n-                (Imported_Project_List).Next;\n-         end loop;\n-\n-         if Verbose_Mode then\n-            Write_Str (\"Checking project file \"\"\");\n-            Write_Str (Get_Name_String (Data.Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-\n-         Prj.Nmsc.Check\n-           (Project, In_Tree, Error_Report, When_No_Sources,\n-            Current_Dir);\n+      if Verbose_Mode then\n+         Write_Str (\"Checking project file \"\"\");\n+         Write_Str\n+           (Get_Name_String (Data.In_Tree.Projects.Table (Project).Name));\n+         Write_Line (\"\"\"\");\n       end if;\n+\n+      Prj.Nmsc.Check\n+        (Project, Data.In_Tree, Error_Report, Data.When_No_Sources,\n+         Data.Current_Dir.all);\n    end Recursive_Check;\n \n    -----------------------"}, {"sha": "eb7f653a4110eb8f899e26e4319df6f1f8ee46c2", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 216, "deletions": 13, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -34,6 +34,8 @@ with Snames;   use Snames;\n with Table;\n with Uintp;    use Uintp;\n \n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+\n with System.Case_Util; use System.Case_Util;\n with System.HTable;\n \n@@ -130,8 +132,6 @@ package body Prj is\n                       Config_File_Name               => No_Path,\n                       Config_File_Temp               => False,\n                       Config_Checked                 => False,\n-                      Checked                        => False,\n-                      Seen                           => False,\n                       Need_To_Build_Lib              => False,\n                       Depth                          => 0,\n                       Unkept_Comments                => False);\n@@ -157,6 +157,9 @@ package body Prj is\n    procedure Project_Changed (Iter : in out Source_Iterator);\n    --  Called when a new project or language was selected for this iterator.\n \n+   function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean;\n+   --  Return True if there is at least one ALI file in the directory Dir\n+\n    -------------------\n    -- Add_To_Buffer --\n    -------------------\n@@ -497,8 +500,11 @@ package body Prj is\n    procedure For_Every_Project_Imported\n      (By         : Project_Id;\n       In_Tree    : Project_Tree_Ref;\n-      With_State : in out State)\n+      With_State : in out State;\n+      Imported_First : Boolean := False)\n    is\n+      use Project_Boolean_Htable;\n+      Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n \n       procedure Recursive_Check (Project : Project_Id);\n       --  Check if a project has already been seen. If not seen, mark it as\n@@ -509,30 +515,41 @@ package body Prj is\n       ---------------------\n \n       procedure Recursive_Check (Project : Project_Id) is\n+         Data : Project_Data renames In_Tree.Projects.Table (Project);\n          List : Project_List;\n       begin\n-         if not In_Tree.Projects.Table (Project).Seen then\n-            In_Tree.Projects.Table (Project).Seen := True;\n-            Action (Project, With_State);\n+         if not Get (Seen, Project) then\n+            Set (Seen, Project, True);\n+\n+            if not Imported_First then\n+               Action (Project, With_State);\n+            end if;\n+\n+            --  Visited all extended projects\n \n-            List := In_Tree.Projects.Table (Project).Imported_Projects;\n+            if Data.Extends /= No_Project then\n+               Recursive_Check (Data.Extends);\n+            end if;\n+\n+            --  Visited all imported projects\n+\n+            List := Data.Imported_Projects;\n             while List /= Empty_Project_List loop\n                Recursive_Check (In_Tree.Project_Lists.Table (List).Project);\n                List := In_Tree.Project_Lists.Table (List).Next;\n             end loop;\n+\n+            if Imported_First then\n+               Action (Project, With_State);\n+            end if;\n          end if;\n       end Recursive_Check;\n \n    --  Start of processing for For_Every_Project_Imported\n \n    begin\n-      for Project in Project_Table.First ..\n-                     Project_Table.Last (In_Tree.Projects)\n-      loop\n-         In_Tree.Projects.Table (Project).Seen := False;\n-      end loop;\n-\n       Recursive_Check (Project => By);\n+      Reset (Seen);\n    end For_Every_Project_Imported;\n \n    --------------\n@@ -1189,6 +1206,10 @@ package body Prj is\n    function Has_Ada_Sources (Data : Project_Data) return Boolean is\n       Lang : Language_Ptr := Data.Languages;\n    begin\n+      if Data.Ada_Sources /= Nil_String then\n+         return True;\n+      end if;\n+\n       while Lang /= No_Language_Index loop\n          if Lang.Name = Name_Ada then\n             return Lang.First_Source /= No_Source;\n@@ -1218,6 +1239,188 @@ package body Prj is\n       return False;\n    end Has_Foreign_Sources;\n \n+   ------------------------\n+   -- Contains_ALI_Files --\n+   ------------------------\n+\n+   function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean is\n+      Dir_Name : constant String := Get_Name_String (Dir);\n+      Direct : Dir_Type;\n+      Name   : String (1 .. 1_000);\n+      Last   : Natural;\n+      Result : Boolean := False;\n+\n+   begin\n+      Open (Direct, Dir_Name);\n+\n+      --  For each file in the directory, check if it is an ALI file\n+\n+      loop\n+         Read (Direct, Name, Last);\n+         exit when Last = 0;\n+         Canonical_Case_File_Name (Name (1 .. Last));\n+         Result := Last >= 5 and then Name (Last - 3 .. Last) = \".ali\";\n+         exit when Result;\n+      end loop;\n+\n+      Close (Direct);\n+      return Result;\n+\n+   exception\n+      --  If there is any problem, close the directory if open and return\n+      --  True; the library directory will be added to the path.\n+\n+      when others =>\n+         if Is_Open (Direct) then\n+            Close (Direct);\n+         end if;\n+\n+         return True;\n+   end Contains_ALI_Files;\n+\n+   --------------------------\n+   -- Get_Object_Directory --\n+   --------------------------\n+\n+   function Get_Object_Directory\n+     (In_Tree             : Project_Tree_Ref;\n+      Project             : Project_Id;\n+      Including_Libraries : Boolean;\n+      Only_If_Ada         : Boolean := False) return Path_Name_Type\n+   is\n+      Data : Project_Data renames In_Tree.Projects.Table (Project);\n+   begin\n+      if (Data.Library and Including_Libraries)\n+        or else\n+          (Data.Object_Directory /= No_Path_Information\n+           and then (not Including_Libraries or else not Data.Library))\n+      then\n+         --  For a library project, add the library ALI directory if there is\n+         --  no object directory or if the library ALI directory contains ALI\n+         --  files; otherwise add the object directory.\n+\n+         if Data.Library then\n+            if Data.Object_Directory = No_Path_Information\n+              or else Contains_ALI_Files (Data.Library_ALI_Dir.Name)\n+            then\n+               return Data.Library_ALI_Dir.Name;\n+            else\n+               return Data.Object_Directory.Name;\n+            end if;\n+\n+            --  For a non-library project, add object directory if it is not a\n+            --  virtual project, and if there are Ada sources in the project or\n+            --  one of the projects it extends. If there are no Ada sources,\n+            --  adding the object directory could disrupt the order of the\n+            --  object dirs in the path.\n+\n+         elsif not Data.Virtual then\n+            declare\n+               Add_Object_Dir : Boolean    := not Only_If_Ada;\n+               Prj            : Project_Id := Project;\n+\n+            begin\n+               while not Add_Object_Dir and then Prj /= No_Project loop\n+                  if Has_Ada_Sources (In_Tree.Projects.Table (Prj)) then\n+                     Add_Object_Dir := True;\n+                  else\n+                     Prj := In_Tree.Projects.Table (Prj).Extends;\n+                  end if;\n+               end loop;\n+\n+               if Add_Object_Dir then\n+                  return Data.Object_Directory.Name;\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+      return No_Path;\n+   end Get_Object_Directory;\n+\n+   -----------------------------------\n+   -- Ultimate_Extending_Project_Of --\n+   -----------------------------------\n+\n+   function Ultimate_Extending_Project_Of\n+     (Proj : Project_Id; In_Tree : Project_Tree_Ref) return Project_Id\n+   is\n+      Prj : Project_Id := Proj;\n+   begin\n+      while In_Tree.Projects.Table (Prj).Extended_By /= No_Project loop\n+         Prj := In_Tree.Projects.Table (Prj).Extended_By;\n+      end loop;\n+\n+      return Prj;\n+   end Ultimate_Extending_Project_Of;\n+\n+   -----------------------------------\n+   -- Compute_All_Imported_Projects --\n+   -----------------------------------\n+\n+   procedure Compute_All_Imported_Projects\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref)\n+   is\n+      procedure Add_To_List (Prj : Project_Id);\n+      --  Add a project to the list All_Imported_Projects of project Project\n+\n+      procedure Recursive_Add (Prj : Project_Id; Dummy : in out Boolean);\n+      --  Recursively add the projects imported by project Project, but not\n+      --  those that are extended.\n+\n+      -----------------\n+      -- Add_To_List --\n+      -----------------\n+\n+      procedure Add_To_List (Prj : Project_Id) is\n+         Element : constant Project_Element :=\n+           (Prj, In_Tree.Projects.Table (Project).All_Imported_Projects);\n+         List : Project_List;\n+      begin\n+         --  Check that the project is not already in the list. We know the one\n+         --  passed to Recursive_Add have never been visited before, but the\n+         --  one passed it are the extended projects.\n+\n+         List := In_Tree.Projects.Table (Project).All_Imported_Projects;\n+         while List /= Empty_Project_List loop\n+            if In_Tree.Project_Lists.Table (List).Project = Prj then\n+               return;\n+            end if;\n+            List := In_Tree.Project_Lists.Table (List).Next;\n+         end loop;\n+\n+         --  Add it to the list\n+\n+         Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n+         List := Project_List_Table.Last (In_Tree.Project_Lists);\n+         In_Tree.Project_Lists.Table (List) := Element;\n+         In_Tree.Projects.Table (Project).All_Imported_Projects := List;\n+      end Add_To_List;\n+\n+      -------------------\n+      -- Recursive_Add --\n+      -------------------\n+\n+      procedure Recursive_Add (Prj : Project_Id; Dummy : in out Boolean) is\n+         pragma Unreferenced (Dummy);\n+         Prj2    : Project_Id;\n+      begin\n+         --  A project is not importing itself\n+         if Project /= Prj then\n+            Prj2 := Ultimate_Extending_Project_Of (Prj, In_Tree);\n+            Add_To_List (Prj2);\n+         end if;\n+      end Recursive_Add;\n+\n+      procedure For_All_Projects is\n+        new For_Every_Project_Imported (Boolean, Recursive_Add);\n+      Dummy : Boolean := False;\n+\n+   begin\n+      In_Tree.Projects.Table (Project).All_Imported_Projects :=\n+        Empty_Project_List;\n+      For_All_Projects (Project, In_Tree, Dummy);\n+   end Compute_All_Imported_Projects;\n+\n begin\n    --  Make sure that the standard config and user project file extensions are\n    --  compatible with canonical case file naming."}, {"sha": "7dca8c7b9909d3fd43e620b27735ad04d0da9897", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9890fa4111e4892cac22bc6d694c56f45316cd/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=8b9890fa4111e4892cac22bc6d694c56f45316cd", "patch": "@@ -906,6 +906,29 @@ package Prj is\n       Naming   : in out Naming_Data;\n       Suffix   : File_Name_Type);\n \n+   function Get_Object_Directory\n+     (In_Tree             : Project_Tree_Ref;\n+      Project             : Project_Id;\n+      Including_Libraries : Boolean;\n+      Only_If_Ada         : Boolean := False) return Path_Name_Type;\n+   --  Return the object directory to use for the project. This depends on\n+   --  whether we have a library project or a standard project. This function\n+   --  might return No_Name when no directory applies.\n+   --  If we have a a library project file and Including_Libraries is True then\n+   --  the library dir is returned instead of the object dir.\n+   --  If Only_If_Ada is True, then No_Name will be returned when the project\n+   --  doesn't Ada sources.\n+\n+   procedure Compute_All_Imported_Projects\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref);\n+   --  Compute, the list of the projects imported directly or indirectly by\n+   --  project Project. The result is stored in Project.All_Imported_Projects\n+\n+   function Ultimate_Extending_Project_Of\n+     (Proj : Project_Id; In_Tree : Project_Tree_Ref) return Project_Id;\n+   --  Returns the ultimate extending project of project Proj. If project Proj\n+   --  is not extended, returns Proj.\n+\n    function Standard_Naming_Data\n      (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data;\n    pragma Inline (Standard_Naming_Data);\n@@ -1310,14 +1333,6 @@ package Prj is\n       Config_Checked : Boolean := False;\n       --  A flag to avoid checking repetitively the configuration pragmas file\n \n-      Checked : Boolean := False;\n-      --  A flag to avoid checking repetitively the naming scheme of this\n-      --  project file.\n-\n-      Seen : Boolean := False;\n-      --  A flag to mark a project as \"visited\" to avoid processing the same\n-      --  project several time.\n-\n       Depth : Natural := 0;\n       --  The maximum depth of a project in the project graph. Depth of main\n       --  project is 0.\n@@ -1496,6 +1511,16 @@ package Prj is\n    --  Otherwise, this information will be automatically added to Naming_Data\n    --  when a project is processed, in the lists Spec_Suffix and Body_Suffix.\n \n+   package Project_Boolean_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Project_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  A table that associates a project to a boolean. This is used to detect\n+   --  whether a project was already processed for instance.\n+\n    generic\n       type State is limited private;\n       with procedure Action\n@@ -1504,15 +1529,19 @@ package Prj is\n    procedure For_Every_Project_Imported\n      (By         : Project_Id;\n       In_Tree    : Project_Tree_Ref;\n-      With_State : in out State);\n+      With_State : in out State;\n+      Imported_First : Boolean := False);\n    --  Call Action for each project imported directly or indirectly by project\n-   --  By. Action is called according to the order of importation: if A\n+   --  By, as well as extended projects.\n+   --  The order of processing depends on Imported_First:\n+   --  If False, Action is called according to the order of importation: if A\n    --  imports B, directly or indirectly, Action will be called for A before\n    --  it is called for B. If two projects import each other directly or\n    --  indirectly (using at least one \"limited with\"), it is not specified\n-   --  for which of these two projects Action will be called first. Projects\n-   --  that are extended by other projects are not considered. With_State may\n-   --  be used by Action to choose a behavior or to report some global result.\n+   --  for which of these two projects Action will be called first.\n+   --  The order is reversed if Imported_First is True.\n+   --  With_State may be used by Action to choose a behavior or to report some\n+   --  global result.\n \n    function Extend_Name\n      (File        : File_Name_Type;"}]}