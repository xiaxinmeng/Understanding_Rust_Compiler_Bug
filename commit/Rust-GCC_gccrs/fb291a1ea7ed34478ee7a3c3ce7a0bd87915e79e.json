{"sha": "fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIyOTFhMWVhN2VkMzQ0NzhlZTdhM2MzY2U3YTBiZDg3OTE1ZTc5ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-20T09:35:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-20T09:35:03Z"}, "message": "gimple.c (gimple_register_type_1): Do not fiddle with main-variant or pointer-to chains.\n\n2011-05-20  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gimple_register_type_1): Do not fiddle with\n\tmain-variant or pointer-to chains.  Delay all fixup to\n\tuniquify_nodes.\n\n\tlto/\n\t* lto.c (lto_ft_common): Remove pointer-to chain teardown.\n\t(lto_ft_type): Move main-variant and pointer-to chain building ...\n\t(uniquify_nodes): ... here.  Compute TYPE_CANONICAL also here,\n\tin a separate final loop.\n\nFrom-SVN: r173938", "tree": {"sha": "f09684a1b04556f7ae7b1d021b47b245ae4e895b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09684a1b04556f7ae7b1d021b47b245ae4e895b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b59eb51cac40f66eb7c02c175858a8498a815391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59eb51cac40f66eb7c02c175858a8498a815391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59eb51cac40f66eb7c02c175858a8498a815391"}], "stats": {"total": 347, "additions": 135, "deletions": 212}, "files": [{"sha": "b89b3f9a0b1cec9a0ca52069bfaad152e63254d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "patch": "@@ -1,3 +1,9 @@\n+2011-05-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_register_type_1): Do not fiddle with\n+\tmain-variant or pointer-to chains.  Delay all fixup to\n+\tuniquify_nodes.\n+\n 2011-05-19  Quentin Neill  <quentin.neill@amd.com>\n \n \t* config/i386/sse.md (fma4_fmsubadd): Use <ssemodesuffix>."}, {"sha": "5b03e15a1fc2206f855d108f12fa18e9d120be8f", "filename": "gcc/gimple.c", "status": "modified", "additions": 7, "deletions": 76, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "patch": "@@ -4476,7 +4476,6 @@ gimple_register_type_1 (tree t, bool registering_mv)\n {\n   void **slot;\n   gimple_type_leader_entry *leader;\n-  tree mv_leader;\n \n   /* If we registered this type before return the cached result.  */\n   leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n@@ -4495,91 +4494,23 @@ gimple_register_type_1 (tree t, bool registering_mv)\n      case we do not care for the main variant leader.  */\n   if (!registering_mv\n       && TYPE_MAIN_VARIANT (t) != t)\n-    mv_leader = gimple_register_type_1 (TYPE_MAIN_VARIANT (t), true);\n-  else\n-    mv_leader = t;\n+    gimple_register_type_1 (TYPE_MAIN_VARIANT (t), true);\n \n+  /* See if we already have an equivalent type registered.  */\n   slot = htab_find_slot (gimple_types, t, INSERT);\n   if (*slot\n       && *(tree *)slot != t)\n     {\n       tree new_type = (tree) *((tree *) slot);\n-\n-      /* Do not merge types with different addressability.  */\n-      gcc_assert (TREE_ADDRESSABLE (t) == TREE_ADDRESSABLE (new_type));\n-\n-      /* If t is not its main variant then make t unreachable from its\n-\t main variant list.  Otherwise we'd queue up a lot of duplicates\n-\t there.  */\n-      if (t != TYPE_MAIN_VARIANT (t))\n-\t{\n-\t  tree tem = TYPE_MAIN_VARIANT (t);\n-\t  while (tem && TYPE_NEXT_VARIANT (tem) != t)\n-\t    tem = TYPE_NEXT_VARIANT (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n-\t  TYPE_NEXT_VARIANT (t) = NULL_TREE;\n-\t}\n-\n-      /* If we are a pointer then remove us from the pointer-to or\n-\t reference-to chain.  Otherwise we'd queue up a lot of duplicates\n-\t there.  */\n-      if (TREE_CODE (t) == POINTER_TYPE)\n-\t{\n-\t  if (TYPE_POINTER_TO (TREE_TYPE (t)) == t)\n-\t    TYPE_POINTER_TO (TREE_TYPE (t)) = TYPE_NEXT_PTR_TO (t);\n-\t  else\n-\t    {\n-\t      tree tem = TYPE_POINTER_TO (TREE_TYPE (t));\n-\t      while (tem && TYPE_NEXT_PTR_TO (tem) != t)\n-\t\ttem = TYPE_NEXT_PTR_TO (tem);\n-\t      if (tem)\n-\t\tTYPE_NEXT_PTR_TO (tem) = TYPE_NEXT_PTR_TO (t);\n-\t    }\n-\t  TYPE_NEXT_PTR_TO (t) = NULL_TREE;\n-\t}\n-      else if (TREE_CODE (t) == REFERENCE_TYPE)\n-\t{\n-\t  if (TYPE_REFERENCE_TO (TREE_TYPE (t)) == t)\n-\t    TYPE_REFERENCE_TO (TREE_TYPE (t)) = TYPE_NEXT_REF_TO (t);\n-\t  else\n-\t    {\n-\t      tree tem = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-\t      while (tem && TYPE_NEXT_REF_TO (tem) != t)\n-\t\ttem = TYPE_NEXT_REF_TO (tem);\n-\t      if (tem)\n-\t\tTYPE_NEXT_REF_TO (tem) = TYPE_NEXT_REF_TO (t);\n-\t    }\n-\t  TYPE_NEXT_REF_TO (t) = NULL_TREE;\n-\t}\n-\n       leader->type = t;\n       leader->leader = new_type;\n-      t = new_type;\n-    }\n-  else\n-    {\n-      leader->type = t;\n-      leader->leader = t;\n-      /* We're the type leader.  Make our TYPE_MAIN_VARIANT valid.  */\n-      if (TYPE_MAIN_VARIANT (t) != t\n-\t  && TYPE_MAIN_VARIANT (t) != mv_leader)\n-\t{\n-\t  /* Remove us from our main variant list as we are not the variant\n-\t     leader and the variant leader will change.  */\n-\t  tree tem = TYPE_MAIN_VARIANT (t);\n-\t  while (tem && TYPE_NEXT_VARIANT (tem) != t)\n-\t    tem = TYPE_NEXT_VARIANT (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n-\t  TYPE_NEXT_VARIANT (t) = NULL_TREE;\n-\t  /* Adjust our main variant.  Linking us into its variant list\n-\t     will happen at fixup time.  */\n-\t  TYPE_MAIN_VARIANT (t) = mv_leader;\n-\t}\n-      *slot = (void *) t;\n+      return new_type;\n     }\n \n+  /* If not, insert it to the cache and the hash.  */\n+  leader->type = t;\n+  leader->leader = t;\n+  *slot = (void *) t;\n   return t;\n }\n "}, {"sha": "893997a68812d8c1e580718a143253d1cd0a4fab", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "patch": "@@ -1,3 +1,10 @@\n+2011-05-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (lto_ft_common): Remove pointer-to chain teardown.\n+\t(lto_ft_type): Move main-variant and pointer-to chain building ...\n+\t(uniquify_nodes): ... here.  Compute TYPE_CANONICAL also here,\n+\tin a separate final loop.\n+\n 2011-05-19  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (uniquify_nodes): First register all types before"}, {"sha": "d64ba18d5921ce2daab485a860f9cb565385c29d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 115, "deletions": 136, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=fb291a1ea7ed34478ee7a3c3ce7a0bd87915e79e", "patch": "@@ -259,45 +259,9 @@ static void lto_fixup_types (tree);\n static void\n lto_ft_common (tree t)\n {\n-  /* The following re-creates the TYPE_REFERENCE_TO and TYPE_POINTER_TO\n-     lists.  We do not stream TYPE_REFERENCE_TO, TYPE_POINTER_TO or\n-     TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO.\n-     First remove us from any pointer list we are on.  */\n-  if (TREE_CODE (t) == POINTER_TYPE)\n-    {\n-      if (TYPE_POINTER_TO (TREE_TYPE (t)) == t)\n-\tTYPE_POINTER_TO (TREE_TYPE (t)) = TYPE_NEXT_PTR_TO (t);\n-      else\n-\t{\n-\t  tree tem = TYPE_POINTER_TO (TREE_TYPE (t));\n-\t  while (tem && TYPE_NEXT_PTR_TO (tem) != t)\n-\t    tem = TYPE_NEXT_PTR_TO (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_PTR_TO (tem) = TYPE_NEXT_PTR_TO (t);\n-\t}\n-      TYPE_NEXT_PTR_TO (t) = NULL_TREE;\n-    }\n-  else if (TREE_CODE (t) == REFERENCE_TYPE)\n-    {\n-      if (TYPE_REFERENCE_TO (TREE_TYPE (t)) == t)\n-\tTYPE_REFERENCE_TO (TREE_TYPE (t)) = TYPE_NEXT_REF_TO (t);\n-      else\n-\t{\n-\t  tree tem = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-\t  while (tem && TYPE_NEXT_REF_TO (tem) != t)\n-\t    tem = TYPE_NEXT_REF_TO (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_REF_TO (tem) = TYPE_NEXT_REF_TO (t);\n-\t}\n-      TYPE_NEXT_REF_TO (t) = NULL_TREE;\n-    }\n-\n   /* Fixup our type.  */\n   LTO_FIXUP_TREE (TREE_TYPE (t));\n \n-  /* Second put us on the list of pointers of the new pointed-to type\n-     if we are a main variant.  This is done in lto_ft_type after\n-     fixing up our main variant.  */\n   LTO_FIXUP_TREE (TREE_CHAIN (t));\n }\n \n@@ -374,8 +338,6 @@ lto_ft_field_decl (tree t)\n static void\n lto_ft_type (tree t)\n {\n-  tree tem, mv;\n-\n   lto_ft_common (t);\n   LTO_FIXUP_TREE (TYPE_CACHED_VALUES (t));\n   LTO_FIXUP_TREE (TYPE_SIZE (t));\n@@ -392,67 +354,6 @@ lto_ft_type (tree t)\n   LTO_FIXUP_TREE (t->type_non_common.binfo);\n \n   LTO_FIXUP_TREE (TYPE_CONTEXT (t));\n-\n-  /* Compute the canonical type of t and fix that up.  From this point\n-     there are no longer any types with TYPE_STRUCTURAL_EQUALITY_P\n-     and its type-based alias problems.  */\n-  if (!TYPE_CANONICAL (t))\n-    {\n-      TYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n-      LTO_FIXUP_TREE (TYPE_CANONICAL (t));\n-    }\n-\n-  /* The following re-creates proper variant lists while fixing up\n-     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n-     variant list state before fixup is broken.  */\n-\n-  /* Remove us from our main variant list if we are not the variant leader.  */\n-  if (TYPE_MAIN_VARIANT (t) != t)\n-    {\n-      tem = TYPE_MAIN_VARIANT (t);\n-      while (tem && TYPE_NEXT_VARIANT (tem) != t)\n-\ttem = TYPE_NEXT_VARIANT (tem);\n-      if (tem)\n-\tTYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n-    }\n-\n-  /* Query our new main variant.  */\n-  mv = gimple_register_type (TYPE_MAIN_VARIANT (t));\n-\n-  /* If we were the variant leader and we get replaced ourselves drop\n-     all variants from our list.  */\n-  if (TYPE_MAIN_VARIANT (t) == t\n-      && mv != t)\n-    {\n-      tem = t;\n-      while (tem)\n-\t{\n-\t  tree tem2 = TYPE_NEXT_VARIANT (tem);\n-\t  TYPE_NEXT_VARIANT (tem) = NULL_TREE;\n-\t  tem = tem2;\n-\t}\n-    }\n-\n-  /* Finally adjust our main variant and fix it up.  */\n-  TYPE_MAIN_VARIANT (t) = mv;\n-  LTO_FIXUP_TREE (TYPE_MAIN_VARIANT (t));\n-\n-  /* As the second step of reconstructing the pointer chains put us\n-     on the list of pointers of the new pointed-to type\n-     if we are a main variant.  See lto_ft_common for the first step.  */\n-  if (TREE_CODE (t) == POINTER_TYPE\n-      && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n-      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n-    }\n-  else if (TREE_CODE (t) == REFERENCE_TYPE\n-\t   && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n-    }\n }\n \n /* Fix up fields of a BINFO T.  */\n@@ -608,19 +509,21 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n \n   /* Go backwards because childs streamed for the first time come\n      as part of their parents, and hence are created after them.  */\n+\n+  /* First register all types in the cache.\n+     This makes sure to have the original structure in the type cycles\n+     when registering them and computing hashes.  */\n   for (i = len; i-- > from;)\n     {\n       tree t = VEC_index (tree, cache->nodes, i);\n-      if (!t)\n+      if (!t\n+\t  || !TYPE_P (t))\n \tcontinue;\n \n-      /* Now try to find a canonical variant of T itself.  */\n-      if (TYPE_P (t))\n-\tgimple_register_type (t);\n+      gimple_register_type (t);\n     }\n \n-  /* Go backwards because childs streamed for the first time come\n-     as part of their parents, and hence are created after them.  */\n+  /* Second fixup all trees in the new cache entries.  */\n   for (i = len; i-- > from;)\n     {\n       tree t = VEC_index (tree, cache->nodes, i);\n@@ -631,50 +534,126 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n       /* First fixup the fields of T.  */\n       lto_fixup_types (t);\n \n+      if (!TYPE_P (t))\n+\tcontinue;\n+\n       /* Now try to find a canonical variant of T itself.  */\n-      if (TYPE_P (t))\n+      t = gimple_register_type (t);\n+\n+      if (t == oldt)\n \t{\n-\t  t = gimple_register_type (t);\n-\t  if (t == oldt\n-\t      && TYPE_MAIN_VARIANT (t) != t)\n+\t  /* The following re-creates proper variant lists while fixing up\n+\t     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n+\t     variant list state before fixup is broken.  */\n+\t  tree tem, mv;\n+\n+\t  /* Remove us from our main variant list if we are not the\n+\t     variant leader.  */\n+\t  if (TYPE_MAIN_VARIANT (t) != t)\n \t    {\n-\t      /* If this is its own type, link it into the variant chain.  */\n-\t      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (TYPE_MAIN_VARIANT (t));\n-\t      TYPE_NEXT_VARIANT (TYPE_MAIN_VARIANT (t)) = t;\n+\t      tem = TYPE_MAIN_VARIANT (t);\n+\t      while (tem && TYPE_NEXT_VARIANT (tem) != t)\n+\t\ttem = TYPE_NEXT_VARIANT (tem);\n+\t      if (tem)\n+\t\tTYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n+\t      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n \t    }\n-\t}\n-      if (t != oldt)\n-\t{\n-\t  if (RECORD_OR_UNION_TYPE_P (t))\n+\n+\t  /* Query our new main variant.  */\n+\t  mv = gimple_register_type (TYPE_MAIN_VARIANT (t));\n+\n+\t  /* If we were the variant leader and we get replaced ourselves drop\n+\t     all variants from our list.  */\n+\t  if (TYPE_MAIN_VARIANT (t) == t\n+\t      && mv != t)\n \t    {\n-\t      tree f1, f2;\n-\t      if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n-\t\tfor (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n-\t\t     f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t\t  {\n-\t\t    unsigned ix;\n-\t\t    gcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n-\t\t    if (!lto_streamer_cache_lookup (cache, f2, &ix))\n-\t\t      gcc_unreachable ();\n-\t\t    /* If we're going to replace an element which we'd\n-\t\t       still visit in the next iterations, we wouldn't\n-\t\t       handle it, so do it here.  We do have to handle it\n-\t\t       even though the field_decl itself will be removed,\n-\t\t       as it could refer to e.g. integer_cst which we\n-\t\t       wouldn't reach via any other way, hence they\n-\t\t       (and their type) would stay uncollected.  */\n-\t\t    if (ix < i)\n-\t\t      lto_fixup_types (f2);\n-\t\t    lto_streamer_cache_insert_at (cache, f1, ix);\n-\t\t  }\n+\t      tem = t;\n+\t      while (tem)\n+\t\t{\n+\t\t  tree tem2 = TYPE_NEXT_VARIANT (tem);\n+\t\t  TYPE_NEXT_VARIANT (tem) = NULL_TREE;\n+\t\t  tem = tem2;\n+\t\t}\n+\t    }\n+\n+\t  /* If we are not our own variant leader link us into our new leaders\n+\t     variant list.  */\n+\t  if (mv != t)\n+\t    {\n+\t      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n+\t      TYPE_NEXT_VARIANT (mv) = t;\n+\t    }\n+\n+\t  /* Finally adjust our main variant and fix it up.  */\n+\t  TYPE_MAIN_VARIANT (t) = mv;\n+\n+\t  /* The following reconstructs the pointer chains\n+\t     of the new pointed-to type if we are a main variant.  We do\n+\t     not stream those so they are broken before fixup.  */\n+\t  if (TREE_CODE (t) == POINTER_TYPE\n+\t      && TYPE_MAIN_VARIANT (t) == t)\n+\t    {\n+\t      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n+\t      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n+\t    }\n+\t  else if (TREE_CODE (t) == REFERENCE_TYPE\n+\t\t   && TYPE_MAIN_VARIANT (t) == t)\n+\t    {\n+\t      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+\t      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n \t    }\n+\t}\n+\n+      else if (RECORD_OR_UNION_TYPE_P (t))\n+\t{\n+\t  tree f1, f2;\n+\t  if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n+\t    for (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n+\t\t f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t      {\n+\t\tunsigned ix;\n+\t\tgcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n+\t\tif (!lto_streamer_cache_lookup (cache, f2, &ix))\n+\t\t  gcc_unreachable ();\n+\t\t/* If we're going to replace an element which we'd\n+\t\t   still visit in the next iterations, we wouldn't\n+\t\t   handle it, so do it here.  We do have to handle it\n+\t\t   even though the field_decl itself will be removed,\n+\t\t   as it could refer to e.g. integer_cst which we\n+\t\t   wouldn't reach via any other way, hence they\n+\t\t   (and their type) would stay uncollected.  */\n+\t\t/* ???  We should rather make sure to replace all\n+\t\t   references to f2 with f1.  That means handling\n+\t\t   COMPONENT_REFs and CONSTRUCTOR elements in\n+\t\t   lto_fixup_types and special-case the field-decl\n+\t\t   operand handling.  */\n+\t\tif (ix < i)\n+\t\t  lto_fixup_types (f2);\n+\t\tlto_streamer_cache_insert_at (cache, f1, ix);\n+\t      }\n \n \t  /* If we found a tree that is equal to oldt replace it in the\n \t     cache, so that further users (in the various LTO sections)\n \t     make use of it.  */\n \t  lto_streamer_cache_insert_at (cache, t, i);\n \t}\n     }\n+\n+  /* Finally compute the canonical type of t.  From this point\n+     there are no longer any types with TYPE_STRUCTURAL_EQUALITY_P\n+     and its type-based alias problems.  This step requires the\n+     TYPE_POINTER_TO lists being present, so make sure it is done\n+     last.  */\n+  for (i = len; i-- > from;)\n+    {\n+      tree t = VEC_index (tree, cache->nodes, i);\n+      if (!t\n+\t  || !TYPE_P (t))\n+\tcontinue;\n+\n+      if (!TYPE_CANONICAL (t))\n+\tTYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+    }\n }\n \n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA."}]}