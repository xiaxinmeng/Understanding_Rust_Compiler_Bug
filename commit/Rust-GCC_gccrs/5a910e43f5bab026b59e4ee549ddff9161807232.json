{"sha": "5a910e43f5bab026b59e4ee549ddff9161807232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5MTBlNDNmNWJhYjAyNmI1OWU0ZWU1NDlkZGZmOTE2MTgwNzIzMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-08-04T23:37:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-08-04T23:37:00Z"}, "message": "re PR middle-end/21291 (can't find a register in class 'GENERAL_REGS' while reloading 'asm')\n\n        PR 21291\n        * tree-outof-ssa.c (coalesce_asm_operands): New.\n        (coalesce_ssa_name): Use it.  Split out ...\n        (coalesce_phi_operands, coalesce_result_decls): ... these.\n\nFrom-SVN: r102751", "tree": {"sha": "bfdd2b6c29f1c29b751dec9101525d577ee095f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfdd2b6c29f1c29b751dec9101525d577ee095f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a910e43f5bab026b59e4ee549ddff9161807232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a910e43f5bab026b59e4ee549ddff9161807232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a910e43f5bab026b59e4ee549ddff9161807232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a910e43f5bab026b59e4ee549ddff9161807232/comments", "author": null, "committer": null, "parents": [{"sha": "27c370005e6ffd8dc7e96ba94382264aa9e36978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c370005e6ffd8dc7e96ba94382264aa9e36978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c370005e6ffd8dc7e96ba94382264aa9e36978"}], "stats": {"total": 197, "additions": 156, "deletions": 41}, "files": [{"sha": "f5a7b3551020e10ca47c94bd120f1b882cd6d502", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a910e43f5bab026b59e4ee549ddff9161807232", "patch": "@@ -1,3 +1,10 @@\n+2005-08-04  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 21291\n+\t* tree-outof-ssa.c (coalesce_asm_operands): New.\n+\t(coalesce_ssa_name): Use it.  Split out ...\n+\t(coalesce_phi_operands, coalesce_result_decls): ... these.\n+\n 2005-08-04  Paul Brook  <paul@codesourcery.com>\n \n \t* read-rtl.c (read_quoted_string): Break if EOF."}, {"sha": "acfc43df67f94b0f1e3e8ed0516af85929dae3ee", "filename": "gcc/testsuite/gcc.target/i386/pr21291.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21291.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21291.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21291.c?ref=5a910e43f5bab026b59e4ee549ddff9161807232", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+typedef unsigned long bngdigit;\n+typedef bngdigit *bng;\n+typedef unsigned int bngcarry;\n+typedef unsigned long bngsize;\n+\n+bngdigit\n+bng_ia32_mult_sub_digit (bng a, bngsize alen, bng b, bngsize blen, bngdigit d)\n+{\n+  bngdigit out, tmp;\n+  bngcarry carry;\n+  bngdigit a11;\n+\n+  alen -= blen;\n+  out = 0;\n+  asm (\"\"\n+       : \"+r\" (a), \"+r\" (b), \"+mr\" (blen), \"+mr\" (out), \"=&r\" (tmp)\n+       : \"mr\" (d)\n+       : \"eax\", \"edx\");\n+  if (alen == 0)\n+    {\n+      a11 = out;\n+      goto t;\n+    }\n+\n+  a11 = 1;\n+ t:\n+  return a11;\n+}"}, {"sha": "3d8303693c29f6c5d9c8e0f63bc3b89a4804b7ec", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 118, "deletions": 41, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a910e43f5bab026b59e4ee549ddff9161807232/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=5a910e43f5bab026b59e4ee549ddff9161807232", "patch": "@@ -676,49 +676,26 @@ coalesce_abnormal_edges (var_map map, conflict_graph graph, root_var_p rv)\n \t  }\n }\n \n+/* Coalesce potential copies via PHI arguments.  */\n \n-/* Reduce the number of live ranges in MAP.  Live range information is \n-   returned if FLAGS indicates that we are combining temporaries, otherwise \n-   NULL is returned.  The only partitions which are associated with actual \n-   variables at this point are those which are forced to be coalesced for \n-   various reason. (live on entry, live across abnormal edges, etc.).  */\n-\n-static tree_live_info_p\n-coalesce_ssa_name (var_map map, int flags)\n+static void\n+coalesce_phi_operands (var_map map, coalesce_list_p cl)\n {\n-  unsigned num, x, i;\n-  sbitmap live;\n-  tree var, phi;\n-  root_var_p rv;\n-  tree_live_info_p liveinfo;\n-  var_ann_t ann;\n-  conflict_graph graph;\n   basic_block bb;\n-  coalesce_list_p cl = NULL;\n-  sbitmap_iterator sbi;\n-\n-  if (num_var_partitions (map) <= 1)\n-    return NULL;\n-\n-  liveinfo = calculate_live_on_entry (map);\n-  calculate_live_on_exit (liveinfo);\n-  rv = root_var_init (map);\n-\n-  /* Remove single element variable from the list.  */\n-  root_var_compact (rv);\n-\n-  cl = create_coalesce_list (map);\n+  tree phi;\n \n-  /* Add all potential copies via PHI arguments to the list.  */\n   FOR_EACH_BB (bb)\n     {\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  tree res = PHI_RESULT (phi);\n \t  int p = var_to_partition (map, res);\n+\t  int x;\n+\n \t  if (p == NO_PARTITION)\n \t    continue;\n-\t  for (x = 0; x < (unsigned)PHI_NUM_ARGS (phi); x++)\n+\n+\t  for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n \t    {\n \t      tree arg = PHI_ARG_DEF (phi, x);\n \t      int p2;\n@@ -739,14 +716,20 @@ coalesce_ssa_name (var_map map, int flags)\n \t    }\n \t}\n     }\n+}\n \n-  /* Coalesce all the result decls together.  */\n-  var = NULL_TREE;\n-  i = 0;\n-  for (x = 0; x < num_var_partitions (map); x++)\n+/* Coalesce all the result decls together.  */\n+\n+static void\n+coalesce_result_decls (var_map map, coalesce_list_p cl)\n+{\n+  unsigned int i, x;\n+  tree var = NULL;\n+\n+  for (i = x = 0; x < num_var_partitions (map); x++)\n     {\n       tree p = partition_to_var (map, x);\n-      if (TREE_CODE (SSA_NAME_VAR(p)) == RESULT_DECL)\n+      if (TREE_CODE (SSA_NAME_VAR (p)) == RESULT_DECL)\n \t{\n \t  if (var == NULL_TREE)\n \t    {\n@@ -760,6 +743,100 @@ coalesce_ssa_name (var_map map, int flags)\n \t\t\t\t\t false));\n \t}\n     }\n+}\n+\n+/* Coalesce matching constraints in asms.  */\n+\n+static void\n+coalesce_asm_operands (var_map map, coalesce_list_p cl)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  unsigned long noutputs, i;\n+\t  tree *outputs, link;\n+\n+\t  if (TREE_CODE (stmt) != ASM_EXPR)\n+\t    continue;\n+\n+\t  noutputs = list_length (ASM_OUTPUTS (stmt));\n+\t  outputs = (tree *) alloca (noutputs * sizeof (tree));\n+\t  for (i = 0, link = ASM_OUTPUTS (stmt); link;\n+\t       ++i, link = TREE_CHAIN (link))\n+\t    outputs[i] = TREE_VALUE (link);\n+\n+\t  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n+\t    {\n+\t      const char *constraint\n+\t\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t      tree input = TREE_VALUE (link);\n+\t      char *end;\n+\t      unsigned long match;\n+\t      int p1, p2;\n+\n+\t      if (TREE_CODE (input) != SSA_NAME && !DECL_P (input))\n+\t\tcontinue;\n+\n+\t      match = strtoul (constraint, &end, 10);\n+\t      if (match >= noutputs || end == constraint)\n+\t\tcontinue;\n+\n+\t      if (TREE_CODE (outputs[match]) != SSA_NAME\n+\t\t  && !DECL_P (outputs[match]))\n+\t\tcontinue;\n+\n+\t      p1 = var_to_partition (map, outputs[match]);\n+\t      if (p1 == NO_PARTITION)\n+\t\tcontinue;\n+\t      p2 = var_to_partition (map, input);\n+\t      if (p2 == NO_PARTITION)\n+\t\tcontinue;\n+\n+\t      add_coalesce (cl, p1, p2, coalesce_cost (REG_BR_PROB_BASE,\n+\t\t\t\t\t\t       maybe_hot_bb_p (bb),\n+\t\t\t\t\t\t       false));\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Reduce the number of live ranges in MAP.  Live range information is \n+   returned if FLAGS indicates that we are combining temporaries, otherwise \n+   NULL is returned.  The only partitions which are associated with actual \n+   variables at this point are those which are forced to be coalesced for \n+   various reason. (live on entry, live across abnormal edges, etc.).  */\n+\n+static tree_live_info_p\n+coalesce_ssa_name (var_map map, int flags)\n+{\n+  unsigned num, x;\n+  sbitmap live;\n+  root_var_p rv;\n+  tree_live_info_p liveinfo;\n+  conflict_graph graph;\n+  coalesce_list_p cl = NULL;\n+  sbitmap_iterator sbi;\n+\n+  if (num_var_partitions (map) <= 1)\n+    return NULL;\n+\n+  liveinfo = calculate_live_on_entry (map);\n+  calculate_live_on_exit (liveinfo);\n+  rv = root_var_init (map);\n+\n+  /* Remove single element variable from the list.  */\n+  root_var_compact (rv);\n+\n+  cl = create_coalesce_list (map);\n+\n+  coalesce_phi_operands (map, cl);\n+  coalesce_result_decls (map, cl);\n+  coalesce_asm_operands (map, cl);\n \n   /* Build a conflict graph.  */\n   graph = build_tree_conflict_graph (liveinfo, rv, cl);\n@@ -787,14 +864,14 @@ coalesce_ssa_name (var_map map, int flags)\n   /* First, coalesce all live on entry variables to their root variable. \n      This will ensure the first use is coming from the correct location.  */\n \n-  live = sbitmap_alloc (num_var_partitions (map));\n+  num = num_var_partitions (map);\n+  live = sbitmap_alloc (num);\n   sbitmap_zero (live);\n \n   /* Set 'live' vector to indicate live on entry partitions.  */\n-  num = num_var_partitions (map);\n   for (x = 0 ; x < num; x++)\n     {\n-      var = partition_to_var (map, x);\n+      tree var = partition_to_var (map, x);\n       if (default_def (SSA_NAME_VAR (var)) == var)\n \tSET_BIT (live, x);\n     }\n@@ -809,8 +886,8 @@ coalesce_ssa_name (var_map map, int flags)\n      partition.  */\n   EXECUTE_IF_SET_IN_SBITMAP (live, 0, x, sbi)\n     {\n-      var = root_var (rv, root_var_find (rv, x));\n-      ann = var_ann (var);\n+      tree var = root_var (rv, root_var_find (rv, x));\n+      var_ann_t ann = var_ann (var);\n       /* If these aren't already coalesced...  */\n       if (partition_to_var (map, x) != var)\n \t{"}]}