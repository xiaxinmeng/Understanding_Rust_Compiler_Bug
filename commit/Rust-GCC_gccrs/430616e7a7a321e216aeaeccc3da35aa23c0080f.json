{"sha": "430616e7a7a321e216aeaeccc3da35aa23c0080f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwNjE2ZTdhN2EzMjFlMjE2YWVhZWNjYzNkYTM1YWEyM2MwMDgwZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-10T00:29:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-10T00:29:38Z"}, "message": "libitm: Work around assembler missing AVX insns.\n\nFrom-SVN: r181246", "tree": {"sha": "c7c77fdbc7b50f224cc4d0500b462b578274d47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7c77fdbc7b50f224cc4d0500b462b578274d47f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/430616e7a7a321e216aeaeccc3da35aa23c0080f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430616e7a7a321e216aeaeccc3da35aa23c0080f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430616e7a7a321e216aeaeccc3da35aa23c0080f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430616e7a7a321e216aeaeccc3da35aa23c0080f/comments", "author": null, "committer": null, "parents": [{"sha": "41582ffe43fa994c13d0e5225f96a02cb0995c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41582ffe43fa994c13d0e5225f96a02cb0995c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41582ffe43fa994c13d0e5225f96a02cb0995c99"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "8aeb589bfed817534413d67bfe01417712361932", "filename": "libitm/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -1,3 +1,10 @@\n+2011-11-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* acinclude.m4 (LIBITM_CHECK_AS_AVX): New.\n+\t* configure.ac: Use it.\n+\t* config.h.in, configure: Rebuild.\n+\t* config/x86/x86_avx.cc: Handle !HAVE_AS_AVX.\n+\n 2011-11-09  Richard Henderson  <rth@redhat.com>\n \n \t* barrier.tpl, memcpy.cc, memset.cc, method-wbetl.cc: Remove file."}, {"sha": "58fbf424c609a33b456e9e759722dc94fdd91b5f", "filename": "libitm/acinclude.m4", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Facinclude.m4?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -95,6 +95,20 @@ AC_DEFUN([LIBITM_CHECK_SIZE_T_MANGLING], [\n     [Define to the letter to which size_t is mangled.])\n ])\n \n+dnl Check if as supports AVX instructions.\n+AC_DEFUN([LIBITM_CHECK_AS_AVX], [\n+case \"${target_cpu}\" in\n+i[3456]86 | x86_64)\n+  AC_CACHE_CHECK([if the assembler supports AVX], libitm_cv_as_avx, [\n+    AC_TRY_COMPILE([], [asm(\"vzeroupper\");],\n+\t\t   [libitm_cv_as_avx=yes], [libitm_cv_as_avx=no])\n+  ])\n+  if test x$libitm_cv_as_avx = xyes; then\n+    AC_DEFINE(HAVE_AS_AVX, 1, [Define to 1 if the assembler supports AVX.])\n+  fi\n+  ;;\n+esac])\n+\n sinclude(../libtool.m4)\n dnl The lines below arrange for aclocal not to bring an installed\n dnl libtool.m4 into aclocal.m4, while still arranging for automake to"}, {"sha": "52db1a6fdc1c122b100dfe0699aee0f69c100ae1", "filename": "libitm/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig.h.in?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -6,6 +6,9 @@\n /* Define to 1 if the target supports 64-bit __sync_*_compare_and_swap */\n #undef HAVE_64BIT_SYNC_BUILTINS\n \n+/* Define to 1 if the assembler supports AVX. */\n+#undef HAVE_AS_AVX\n+\n /* Define if your assembler supports .cfi_* directives. */\n #undef HAVE_AS_CFI_PSEUDO_OP\n "}, {"sha": "cd20fe25cdc9acf409f2d30f0aa3af50f9089590", "filename": "libitm/config/x86/x86_avx.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfig%2Fx86%2Fx86_avx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfig%2Fx86%2Fx86_avx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fx86_avx.cc?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -22,9 +22,66 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#include \"config.h\"\n+\n+// ??? This is pretty gross, but we're going to frob types of the functions.\n+// Is this better or worse than just admitting we need to do this in pure\n+// assembly?\n+\n+#ifndef HAVE_AS_AVX\n+#undef __AVX__\n+#endif\n+\n #include \"libitm_i.h\"\n #include \"dispatch.h\"\n \n+extern \"C\" {\n+\n+#ifndef HAVE_AS_AVX\n+typedef float _ITM_TYPE_M256 __attribute__((vector_size(32), may_alias));\n+#endif\n+\n+// ??? Re-define the memcpy implementations so that we can frob the\n+// interface to deal with possibly missing AVX instruction set support.\n+\n+#ifdef HAVE_AS_AVX\n+#define RETURN(X)\treturn X\n+#define STORE(X,Y)\tX = Y\n+#define OUTPUT(T)\t_ITM_TYPE_##T\n+#define INPUT(T,X)\t, _ITM_TYPE_##T X\n+#else\n+/* Emit vmovaps (%rax),%ymm0.  */\n+#define RETURN(X) \\\n+  asm volatile(\".byte 0xc5,0xfc,0x28,0x00\" : \"=m\"(X) : \"a\"(&X));\n+/* Emit vmovaps %ymm0,(%rax); vzeroupper.  */\n+#define STORE(X,Y) \\\n+  asm volatile(\".byte 0xc5,0xfc,0x29,0x00,0xc5,0xf8,0x77\" : \"=m\"(X) : \"a\"(&X));\n+#define OUTPUT(T)\tvoid\n+#define INPUT(T,X)\n+#endif\n+\n+#undef ITM_READ_MEMCPY\n+#define ITM_READ_MEMCPY(T, LSMOD, TARGET, M2)\t\t\t\t\\\n+OUTPUT(T) ITM_REGPARM _ITM_##LSMOD##T (const _ITM_TYPE_##T *ptr)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _ITM_TYPE_##T v;\t\t\t\t\t\t\t\\\n+  TARGET memtransfer##M2(&v, ptr, sizeof(_ITM_TYPE_##T), false,\t\t\\\n+\t\t\t GTM::abi_dispatch::NONTXNAL,\t\t\t\\\n+\t\t\t GTM::abi_dispatch::LSMOD);\t\t\t\\\n+  RETURN(v);\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef ITM_WRITE_MEMCPY\n+#define ITM_WRITE_MEMCPY(T, LSMOD, TARGET, M2)\t\t\t\t\\\n+void ITM_REGPARM _ITM_##LSMOD##T (_ITM_TYPE_##T *ptr INPUT(T,in))\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _ITM_TYPE_##T v;\t\t\t\t\t\t\t\\\n+  STORE(v, in);\t\t\t\t\t\t\t\t\\\n+  TARGET memtransfer##M2(ptr, &v, sizeof(_ITM_TYPE_##T), false,\t\t\\\n+\t\t\t GTM::abi_dispatch::LSMOD,\t\t\t\\\n+\t\t\t GTM::abi_dispatch::NONTXNAL);\t\t\t\\\n+}\n+\n // ??? Use memcpy for now, until we have figured out how to best instantiate\n // these loads/stores.\n CREATE_DISPATCH_FUNCTIONS_T_MEMCPY(M256, GTM::abi_disp()->, )\n@@ -34,3 +91,5 @@ _ITM_LM256 (const _ITM_TYPE_M256 *ptr)\n {\n   GTM::GTM_LB (ptr, sizeof (*ptr));\n }\n+\n+}"}, {"sha": "b30ced11548504602398b7e0647925356cdd9a50", "filename": "libitm/configure", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -17115,6 +17115,43 @@ $as_echo \"#define HAVE_64BIT_SYNC_BUILTINS 1\" >>confdefs.h\n \n   fi\n \n+case \"${target_cpu}\" in\n+i345686 | x86_64)\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if the assembler supports AVX\" >&5\n+$as_echo_n \"checking if the assembler supports AVX... \" >&6; }\n+if test \"${libitm_cv_as_avx+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+asm(\"vzeroupper\");\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libitm_cv_as_avx=yes\n+else\n+  libitm_cv_as_avx=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libitm_cv_as_avx\" >&5\n+$as_echo \"$libitm_cv_as_avx\" >&6; }\n+  if test x$libitm_cv_as_avx = xyes; then\n+\n+$as_echo \"#define HAVE_AS_AVX 1\" >>confdefs.h\n+\n+  fi\n+  ;;\n+esac\n+\n # Cleanup and exit.\n CFLAGS=\"$save_CFLAGS\"\n cat >confcache <<\\_ACEOF"}, {"sha": "7de5cbeed912283ba399ec040bde099bb74b0289", "filename": "libitm/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430616e7a7a321e216aeaeccc3da35aa23c0080f/libitm%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.ac?ref=430616e7a7a321e216aeaeccc3da35aa23c0080f", "patch": "@@ -237,6 +237,7 @@ CFLAGS=\"$save_CFLAGS $XCFLAGS\"\n # had a chance to set XCFLAGS.\n LIBITM_CHECK_SYNC_BUILTINS\n LIBITM_CHECK_64BIT_SYNC_BUILTINS\n+LIBITM_CHECK_AS_AVX\n \n # Cleanup and exit.\n CFLAGS=\"$save_CFLAGS\""}]}