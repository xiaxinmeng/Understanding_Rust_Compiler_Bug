{"sha": "b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3MmRkMDIwMWQ2OWNmZDBhNDIyMjkyNzA2YzFkMGI4YjRmMWIyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-11-07T12:35:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-11-07T12:35:16Z"}, "message": "expmed.c (expand_mult): Force operand to register before computing cost.\n\n\t* expmed.c (expand_mult): Force operand to register before computing\n\tcost.\n\t* i386.c (x86_decompose_lea): New global vairable.\n\t* i386.h (x86_decompose_lea): Declare.\n\t(TARGET_DECOMPOSE_LEA): New macro.\n\t(RTX_COST): Handle leas properly.\n\nFrom-SVN: r46823", "tree": {"sha": "03db7da381d0f1ca3f877597e7c68578266a36ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03db7da381d0f1ca3f877597e7c68578266a36ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/comments", "author": null, "committer": null, "parents": [{"sha": "ab901443dc4df860aef92b4f4b8189771663f994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab901443dc4df860aef92b4f4b8189771663f994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab901443dc4df860aef92b4f4b8189771663f994"}], "stats": {"total": 72, "additions": 47, "deletions": 25}, "files": [{"sha": "fcac3da9a70e0e0ddf257e4ca2cc228746a732db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "patch": "@@ -1,3 +1,12 @@\n+Wed Nov  7 13:33:34 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expmed.c (expand_mult): Force operand to register before computing\n+\tcost.\n+\t* i386.c (x86_decompose_lea): New global vairable.\n+\t* i386.h (x86_decompose_lea): Declare.\n+\t(TARGET_DECOMPOSE_LEA): New macro.\n+\t(RTX_COST): Handle leas properly.\n+\n 2001-11-06  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/elf.h (DO_SELECT_SECTION): TREE_READONLY is not"}, {"sha": "47f8e7859f3e19a643733c66c04f1695ca4524f7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "patch": "@@ -375,6 +375,7 @@ const int x86_memory_mismatch_stall = m_ATHLON | m_PENT4;\n const int x86_accumulate_outgoing_args = m_ATHLON | m_PENT4 | m_PPRO;\n const int x86_prologue_using_move = m_ATHLON | m_PENT4 | m_PPRO;\n const int x86_epilogue_using_move = m_ATHLON | m_PENT4 | m_PPRO;\n+const int x86_decompose_lea = m_PENT4;\n \n /* In case the avreage insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and"}, {"sha": "7edfc283c4868e4b139592360b7795e22588f74e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "patch": "@@ -218,7 +218,7 @@ extern const int x86_promote_hi_regs, x86_integer_DFmode_moves;\n extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;\n extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n extern const int x86_accumulate_outgoing_args, x86_prologue_using_move;\n-extern const int x86_epilogue_using_move;\n+extern const int x86_epilogue_using_move, x86_decompose_lea;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -256,6 +256,7 @@ extern const int x86_epilogue_using_move;\n #define TARGET_MEMORY_MISMATCH_STALL (x86_memory_mismatch_stall & CPUMASK)\n #define TARGET_PROLOGUE_USING_MOVE (x86_prologue_using_move & CPUMASK)\n #define TARGET_EPILOGUE_USING_MOVE (x86_epilogue_using_move & CPUMASK)\n+#define TARGET_DECOMPOSE_LEA (x86_decompose_lea & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n \n@@ -2485,7 +2486,9 @@ while (0)\n \tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n \tif (value == 1)\t\t\t\t\t\t\t\\\n \t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\\\n-\tif (value == 2 || value == 3)\t\t\t\t\t\\\n+\tif ((value == 2 || value == 3)\t\t\t\t\t\\\n+\t    && !TARGET_DECOMPOSE_LEA\t\t\t\t\t\\\n+\t    && ix86_cost->lea <= ix86_cost->shift_const)\t\t\\\n \t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->lea);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n@@ -2546,37 +2549,42 @@ while (0)\n     TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == MULT\t\t\t\\\n-\t&& GET_CODE (XEXP (XEXP (XEXP (X, 0), 0), 1)) == CONST_INT\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+    if (!TARGET_DECOMPOSE_LEA\t\t\t\t\t\t\\\n+\t&& INTEGRAL_MODE_P (GET_MODE (X))\t\t\t\t\\\n+\t&& GET_MODE_BITSIZE (GET_MODE (X)) <= GET_MODE_BITSIZE (Pmode))\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tHOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 0), 0), 1));\t\\\n-\tif (val == 2 || val == 4 || val == 8)\t\t\t\t\\\n+        if (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n+\t    && GET_CODE (XEXP (XEXP (X, 0), 0)) == MULT\t\t\t\\\n+\t    && GET_CODE (XEXP (XEXP (XEXP (X, 0), 0), 1)) == CONST_INT\t\\\n+\t    && CONSTANT_P (XEXP (X, 1)))\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-            return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0), OUTER_CODE) \\\n-\t\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t    HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 0), 0), 1));\\\n+\t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0), OUTER_CODE) \\\n+\t\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n-\t     && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tHOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\t\\\n-\tif (val == 2 || val == 4 || val == 8)\t\t\t\t\\\n+\telse if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n+\t\t && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    HOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\t\\\n+\t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n+\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n+\t\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (GET_CODE (XEXP (X, 0)) == PLUS)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n \t\t    + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n \t\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (GET_CODE (XEXP (X, 0)) == PLUS)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\t\\\n-\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\t\\\n-\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\t\\\n-\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\"}, {"sha": "9435a62d63d8846242f89a212ce8779567cf03e9", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972dd0201d69cfd0a422292706c1d0b8b4f1b2d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b972dd0201d69cfd0a422292706c1d0b8b4f1b2d", "patch": "@@ -2406,6 +2406,10 @@ expand_mult (mode, op0, op1, target, unsignedp)\n       int mult_cost;\n       enum {basic_variant, negate_variant, add_variant} variant = basic_variant;\n \n+      /* op0 must be register to make mult_cost match the precomputed\n+         shiftadd_cost array.  */\n+      op0 = force_reg (mode, op0);\n+\n       /* Try to do the computation three ways: multiply by the negative of OP1\n \t and then negate, do the multiplication directly, or do multiplication\n \t by OP1 - 1.  */"}]}