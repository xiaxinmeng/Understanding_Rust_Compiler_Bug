{"sha": "f19a9af7e12657d431363e301fc31aec7d507684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5YTlhZjdlMTI2NTdkNDMxMzYzZTMwMWZjMzFhZWM3ZDUwNzY4NA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2003-11-30T15:51:36Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-11-30T15:51:36Z"}, "message": "s390.md (\"tmdi_reg\", [...]): Insns now use multiple letter constraints.\n\n2003-11-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.md (\"tmdi_reg\", \"tmsi_reg\", \"*movdi_64\", \"*movdi_31\",\n\t\"iordi3\"): Insns now use multiple letter constraints.\n\t(\"*movdi_lhi\", \"*movdi_lli\", \"*movdi_lay\"): Insns deleted. They are now\n\tcovered by \"*movdi_64\".\n\t(\"*movsi_lhi\", \"*movsi_lli\", \"*movsi_lay\"): Insns deleted. They are now\n\tcovered by \"*movsi_zarch\" and \"*movsi_esa\".\n\t(\"*movsi_zarch\", \"*movsi_!zarch\"): New insns.\n\t(\"*llgt_sisi_split\", \"*llgt_didi_split\"): Insns deleted. Now covered\n\tby \"*andsi3_zarch\" and \"anddi3\".\n\t(\"*anddi3_ni\"): Insn merged with \"anddi3\".\n\t(\"*andsi3_ni\"): Insn merged with \"*andsi3_zarch\".\n\t(\"*andsi3_zarch\", \"*andsi3_esa\"): New insns.\n\t(\"*iordi3_oi\"): Insn merged with \"iordi3\".\n\t(\"*iorsi3_oi\"): Insn merged with \"*iorsi3_zarch\".\n\t(\"*iorsi3_zarch\", \"*iorsi3_esa\"): New insns.\n\n\t* config/s390/s390.c (s390_single_qi, s390_single_hi): Functions\n\tmerged to s390_single_part.\n\t(s390_single_part): New function.\n\tNOTE: Semantics have changed a bit. Now the value of the part must\n\tbe different from the others to get a non-negative return value.\n\t(s390_extract_qi, s390_extract_hi): Functions merged to\n\ts390_extract_part.\n\t(s390_extract_part, s390_extra_constraint_str,\n\ts390_const_ok_for_constraint_p): New functions. The L constraint got a\n\tnew meaning and the N constraint was added as a multiple letter\n\tconstraint.\n\t(s390_extra_constraint): Function deleted.\n\t(print_operand): New output modifier 'i' and 'j' added.\n\tAll uses of CONST_OK_FOR_LETTER_P were replaced by\n\tCONST_OK_FOR_CONSTRAINT_P.\n\n\t* config/s390/s390-protos.h: Function prototypes adapted.\n\t* doc/md.texi: Documentation for new constraint letters added.\n\nFrom-SVN: r74061", "tree": {"sha": "73bfafe86255f768c51672ef2ae4dc4c95ebc09a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73bfafe86255f768c51672ef2ae4dc4c95ebc09a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19a9af7e12657d431363e301fc31aec7d507684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19a9af7e12657d431363e301fc31aec7d507684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19a9af7e12657d431363e301fc31aec7d507684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19a9af7e12657d431363e301fc31aec7d507684/comments", "author": null, "committer": null, "parents": [{"sha": "11816ba2800e4671ca9e9cc737b1c2fb9e9ba4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11816ba2800e4671ca9e9cc737b1c2fb9e9ba4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11816ba2800e4671ca9e9cc737b1c2fb9e9ba4b4"}], "stats": {"total": 899, "additions": 431, "deletions": 468}, "files": [{"sha": "2b9a4a933328ab1531099b19b2cee33c8a6ef570", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -1,3 +1,40 @@\n+2003-11-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.md (\"tmdi_reg\", \"tmsi_reg\", \"*movdi_64\", \"*movdi_31\", \n+\t\"iordi3\"): Insns now use multiple letter constraints.\n+\t(\"*movdi_lhi\", \"*movdi_lli\", \"*movdi_lay\"): Insns deleted. They are now\n+\tcovered by \"*movdi_64\".\n+\t(\"*movsi_lhi\", \"*movsi_lli\", \"*movsi_lay\"): Insns deleted. They are now\n+\tcovered by \"*movsi_zarch\" and \"*movsi_esa\".\n+\t(\"*movsi_zarch\", \"*movsi_!zarch\"): New insns.\n+\t(\"*llgt_sisi_split\", \"*llgt_didi_split\"): Insns deleted. Now covered \n+\tby \"*andsi3_zarch\" and \"anddi3\".\n+\t(\"*anddi3_ni\"): Insn merged with \"anddi3\".\n+\t(\"*andsi3_ni\"): Insn merged with \"*andsi3_zarch\".\n+\t(\"*andsi3_zarch\", \"*andsi3_esa\"): New insns.\n+\t(\"*iordi3_oi\"): Insn merged with \"iordi3\".\n+\t(\"*iorsi3_oi\"): Insn merged with \"*iorsi3_zarch\".\n+\t(\"*iorsi3_zarch\", \"*iorsi3_esa\"): New insns.\n+\n+\t* config/s390/s390.c (s390_single_qi, s390_single_hi): Functions \n+\tmerged to s390_single_part.\n+\t(s390_single_part): New function.\n+\tNOTE: Semantics have changed a bit. Now the value of the part must\n+\tbe different from the others to get a non-negative return value.\n+\t(s390_extract_qi, s390_extract_hi): Functions merged to \n+\ts390_extract_part.\n+\t(s390_extract_part, s390_extra_constraint_str,\n+\ts390_const_ok_for_constraint_p): New functions. The L constraint got a \n+\tnew meaning and the N constraint was added as a multiple letter \n+\tconstraint.\n+\t(s390_extra_constraint): Function deleted.\n+\t(print_operand): New output modifier 'i' and 'j' added.\n+\tAll uses of CONST_OK_FOR_LETTER_P were replaced by \n+\tCONST_OK_FOR_CONSTRAINT_P.\n+\n+\t* config/s390/s390-protos.h: Function prototypes adapted.\n+\t* doc/md.texi: Documentation for new constraint letters added.\n+\n 2003-11-30  Andreas Schwab  <schwab@suse.de>\n \n \t* Makefile.in ($(DESTDIR)$(infodir)/%.info): Fix missing semicolon."}, {"sha": "c45ff4dcd0f9c5f3b82e1acf6dd47d585684fd96", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -30,7 +30,8 @@ extern void s390_emit_epilogue (void);\n extern void s390_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE\n-extern int s390_extra_constraint (rtx, int);\n+extern int s390_extra_constraint_str (rtx, int, const char *);\n+extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);\n extern int const0_operand (rtx, enum machine_mode);\n extern int consttable_operand (rtx, enum machine_mode);\n extern int larl_operand (rtx, enum machine_mode);\n@@ -40,10 +41,8 @@ extern int shift_count_operand (rtx, enum machine_mode);\n extern int bras_sym_operand (rtx, enum machine_mode);\n extern int load_multiple_operation (rtx, enum machine_mode);\n extern int store_multiple_operation (rtx, enum machine_mode);\n-extern int s390_single_hi (rtx, enum machine_mode, int);\n-extern int s390_extract_hi (rtx, enum machine_mode, int);\n-extern int s390_single_qi (rtx, enum machine_mode, int);\n-extern int s390_extract_qi (rtx, enum machine_mode, int);\n+extern int s390_single_part (rtx, enum machine_mode, enum machine_mode, int);\n+extern unsigned HOST_WIDE_INT s390_extract_part (rtx, enum machine_mode, int);\n extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n extern int tls_symbolic_operand (rtx);\n "}, {"sha": "ef9c2130f1299123d50f566529c972398c7eba97", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 151, "deletions": 198, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -374,7 +374,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n       case EQ:\n       case NE:\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t    && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K'))\n+\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (XEXP (op0, 1)), 'K', \"K\"))\n \t  return CCAPmode;\n \tif ((GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n \t     || GET_CODE (op1) == NEG)\n@@ -410,7 +410,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n       case GE:\n       case GT:\n \t  if (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K'))\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (XEXP (op0, 1)), 'K', \"K\"))\n             {\n \t      if (INTVAL (XEXP((op0), 1)) < 0)\n \t        return CCANmode;\n@@ -760,198 +760,68 @@ s390_branch_condition_mnemonic (rtx code, int inv)\n   return mnemonic[mask];\n }\n \n-/* If OP is an integer constant of mode MODE with exactly one\n-   HImode subpart unequal to DEF, return the number of that\n-   subpart.  As a special case, all HImode subparts of OP are\n-   equal to DEF, return zero.  Otherwise, return -1.  */\n+/* Return the part of op which has a value different from def.\n+   The size of the part is determined by mode.\n+   Use this function only if you already know that op really \n+   contains such a part.  */\n \n-int\n-s390_single_hi (rtx op, enum machine_mode mode, int def)\n+unsigned HOST_WIDE_INT\n+s390_extract_part (rtx op, enum machine_mode mode, int def)\n {\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      unsigned HOST_WIDE_INT value = 0;\n-      int n_parts = GET_MODE_SIZE (mode) / 2;\n-      int i, part = -1;\n-\n-      for (i = 0; i < n_parts; i++)\n-        {\n-          if (i == 0)\n-            value = (unsigned HOST_WIDE_INT) INTVAL (op);\n-          else\n-            value >>= 16;\n-\n-          if ((value & 0xffff) != (unsigned)(def & 0xffff))\n-            {\n-              if (part != -1)\n-                return -1;\n-              else\n-                part = i;\n-            }\n-        }\n-\n-      return part == -1 ? 0 : (n_parts - 1 - part);\n-    }\n-\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-           && GET_MODE (op) == VOIDmode)\n-    {\n-      unsigned HOST_WIDE_INT value = 0;\n-      int n_parts = GET_MODE_SIZE (mode) / 2;\n-      int i, part = -1;\n-\n-      for (i = 0; i < n_parts; i++)\n-        {\n-          if (i == 0)\n-            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n-          else if (i == HOST_BITS_PER_WIDE_INT / 16)\n-            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op);\n-          else\n-            value >>= 16;\n-\n-          if ((value & 0xffff) != (unsigned)(def & 0xffff))\n-            {\n-              if (part != -1)\n-                return -1;\n-              else\n-                part = i;\n-            }\n-        }\n-\n-      return part == -1 ? 0 : (n_parts - 1 - part);\n-    }\n-\n-  return -1;\n-}\n-\n-/* Extract the HImode part number PART from integer\n-   constant OP of mode MODE.  */\n-\n-int\n-s390_extract_hi (rtx op, enum machine_mode mode, int part)\n-{\n-  int n_parts = GET_MODE_SIZE (mode) / 2;\n-  if (part < 0 || part >= n_parts)\n-    abort();\n-  else\n-    part = n_parts - 1 - part;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      unsigned HOST_WIDE_INT value = (unsigned HOST_WIDE_INT) INTVAL (op);\n-      return ((value >> (16 * part)) & 0xffff);\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-           && GET_MODE (op) == VOIDmode)\n+  unsigned HOST_WIDE_INT value = 0;\n+  int max_parts = HOST_BITS_PER_WIDE_INT / GET_MODE_BITSIZE (mode);\n+  int part_bits = GET_MODE_BITSIZE (mode);\n+  unsigned HOST_WIDE_INT part_mask = (1 << part_bits) - 1;\n+  int i;\n+  \n+  for (i = 0; i < max_parts; i++)\n     {\n-      unsigned HOST_WIDE_INT value;\n-      if (part < HOST_BITS_PER_WIDE_INT / 16)\n-        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+      if (i == 0)\n+\tvalue = (unsigned HOST_WIDE_INT) INTVAL (op);\n       else\n-        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n-        part -= HOST_BITS_PER_WIDE_INT / 16;\n-\n-      return ((value >> (16 * part)) & 0xffff);\n+\tvalue >>= part_bits;\n+      \n+      if ((value & part_mask) != (def & part_mask))\n+\treturn value & part_mask;\n     }\n-\n+  \n   abort ();\n }\n \n /* If OP is an integer constant of mode MODE with exactly one\n-   QImode subpart unequal to DEF, return the number of that\n-   subpart.  As a special case, all QImode subparts of OP are\n-   equal to DEF, return zero.  Otherwise, return -1.  */\n+   part of mode PART_MODE unequal to DEF, return the number of that\n+   part. Otherwise, return -1.  */\n \n int\n-s390_single_qi (rtx op, enum machine_mode mode, int def)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      unsigned HOST_WIDE_INT value = 0;\n-      int n_parts = GET_MODE_SIZE (mode);\n-      int i, part = -1;\n-\n-      for (i = 0; i < n_parts; i++)\n-        {\n-          if (i == 0)\n-            value = (unsigned HOST_WIDE_INT) INTVAL (op);\n-          else\n-            value >>= 8;\n-\n-          if ((value & 0xff) != (unsigned)(def & 0xff))\n-            {\n-              if (part != -1)\n-                return -1;\n-              else\n-                part = i;\n-            }\n-        }\n-\n-      return part == -1 ? 0 : (n_parts - 1 - part);\n-    }\n-\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-           && GET_MODE (op) == VOIDmode)\n-    {\n-      unsigned HOST_WIDE_INT value = 0;\n-      int n_parts = GET_MODE_SIZE (mode);\n-      int i, part = -1;\n-\n-      for (i = 0; i < n_parts; i++)\n-        {\n-          if (i == 0)\n-            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n-          else if (i == HOST_BITS_PER_WIDE_INT / 8)\n-            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op);\n-          else\n-            value >>= 8;\n-\n-          if ((value & 0xff) != (unsigned)(def & 0xff))\n-            {\n-              if (part != -1)\n-                return -1;\n-              else\n-                part = i;\n-            }\n-        }\n-\n-      return part == -1 ? 0 : (n_parts - 1 - part);\n-    }\n-\n-  return -1;\n-}\n-\n-/* Extract the QImode part number PART from integer\n-   constant OP of mode MODE.  */\n-\n-int\n-s390_extract_qi (rtx op, enum machine_mode mode, int part)\n-{\n-  int n_parts = GET_MODE_SIZE (mode);\n-  if (part < 0 || part >= n_parts)\n-    abort();\n-  else\n-    part = n_parts - 1 - part;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      unsigned HOST_WIDE_INT value = (unsigned HOST_WIDE_INT) INTVAL (op);\n-      return ((value >> (8 * part)) & 0xff);\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-           && GET_MODE (op) == VOIDmode)\n-    {\n-      unsigned HOST_WIDE_INT value;\n-      if (part < HOST_BITS_PER_WIDE_INT / 8)\n-        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+s390_single_part (rtx op, \n+\t\t  enum machine_mode mode, \n+\t\t  enum machine_mode part_mode,\n+\t\t  int def)\n+{\n+  unsigned HOST_WIDE_INT value = 0;\n+  int n_parts = GET_MODE_SIZE (mode) / GET_MODE_SIZE (part_mode);\n+  unsigned HOST_WIDE_INT part_mask = (1 << GET_MODE_BITSIZE (part_mode)) - 1;\n+  int i, part = -1;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return -1;\n+  \n+  for (i = 0; i < n_parts; i++)\n+    {\n+      if (i == 0)\n+\tvalue = (unsigned HOST_WIDE_INT) INTVAL (op);\n       else\n-        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n-        part -= HOST_BITS_PER_WIDE_INT / 8;\n-\n-      return ((value >> (8 * part)) & 0xff);\n+\tvalue >>= GET_MODE_BITSIZE (part_mode);\n+      \n+      if ((value & part_mask) != (def & part_mask))\n+\t{\n+\t  if (part != -1)\n+\t    return -1;\n+\t  else\n+\t    part = i;\n+\t}\n     }\n-\n-  abort ();\n+  return part == -1 ? -1 : n_parts - 1 - part;\n }\n \n /* Check whether we can (and want to) split a double-word\n@@ -1353,10 +1223,13 @@ s390_short_displacement (rtx disp)\n /* Return true if OP is a valid operand for a C constraint.  */\n \n int\n-s390_extra_constraint (rtx op, int c)\n+s390_extra_constraint_str (rtx op, int c, const char * str)\n {\n   struct s390_address addr;\n \n+  if (c != str[0])\n+    abort ();\n+\n   switch (c)\n     {\n     case 'Q':\n@@ -1442,6 +1315,78 @@ s390_extra_constraint (rtx op, int c)\n   return 1;\n }\n \n+/* Return true if VALUE matches the constraint STR.  */\n+\n+int\n+s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n+\t\t\t\tint c,\n+\t\t\t\tconst char * str)\n+{\n+  enum machine_mode mode, part_mode;\n+  int def;\n+  unsigned char part;\n+\n+  if (c != str[0])\n+    abort ();\n+\n+  switch (str[0])\n+    {\n+    case 'I':\n+      return (unsigned int)value < 256;\n+\n+    case 'J':\n+      return (unsigned int)value < 4096;\n+\n+    case 'K':\n+      return value >= -32768 && value < 32768;\n+\n+    case 'L':\n+      return (TARGET_LONG_DISPLACEMENT ? \n+\t      (value >= -524288 && value <= 524287) \n+\t      : (value >= 0 && value <= 4095));\n+    case 'M':\n+      return value == 2147483647;\n+\n+    case 'N':\n+      part = str[1] - '0';\n+\n+      switch (str[2])\n+\t{\n+\tcase 'H': part_mode = HImode; break;\n+\tcase 'Q': part_mode = QImode; break;\n+\tdefault:  return 0;\n+\t}\n+      \n+      switch (str[3])\n+\t{\n+\tcase 'H': mode = HImode; break;\n+\tcase 'S': mode = SImode; break;\n+\tcase 'D': mode = DImode; break;\n+\tdefault: return 0;\n+\t}\n+\n+      switch (str[4])\n+\t{\n+\tcase '0': def = 0;  break;\n+\tcase 'F': def = -1; break;\n+\tdefault: return 0;\n+\t}\n+\n+      if (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (part_mode))\n+\treturn 0;\n+\n+      if (s390_single_part (GEN_INT (value), mode, part_mode, def) != part)\n+\treturn 0;\n+\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n@@ -1866,12 +1811,12 @@ legitimate_reload_constant_p (register rtx op)\n \n   /* Accept l(g)hi operands.  */\n   if (GET_CODE (op) == CONST_INT\n-      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'))\n+      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'K', \"K\"))\n     return 1;\n \n   /* Accept lliXX operands.  */\n   if (TARGET_ZARCH\n-      && s390_single_hi (op, DImode, 0) >= 0)\n+      && s390_single_part (op, DImode, HImode, 0) >= 0)\n   return 1;\n \n   /* Accept larl operands.  */\n@@ -3493,7 +3438,9 @@ print_operand_address (FILE *file, rtx addr)\n \n     'b': print integer X as if it's an unsigned byte.\n     'x': print integer X as if it's an unsigned word.\n-    'h': print integer X as if it's a signed word.  */\n+    'h': print integer X as if it's a signed word.\n+    'i': print the first nonzero HImode part of X.\n+    'j': print the first HImode part unequal to 0xffff of X.  */\n \n void\n print_operand (FILE *file, rtx x, int code)\n@@ -3609,6 +3556,12 @@ print_operand (FILE *file, rtx x, int code)\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xffff);\n       else if (code == 'h')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((INTVAL (x) & 0xffff) ^ 0x8000) - 0x8000);\n+      else if (code == 'i')\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\t\t s390_extract_part (x, HImode, 0));\n+      else if (code == 'j')\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\t\t s390_extract_part (x, HImode, -1));\t\n       else\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n       break;\n@@ -5694,7 +5647,7 @@ s390_emit_prologue (void)\n \t}\n       else\n \t{\n-\t  if (!CONST_OK_FOR_LETTER_P (INTVAL (frame_off), 'K'))\n+\t  if (!CONST_OK_FOR_CONSTRAINT_P (INTVAL (frame_off), 'K', \"K\"))\n \t    frame_off = force_const_mem (Pmode, frame_off);\n \n           insn = emit_insn (gen_add2_insn (stack_pointer_rtx, frame_off));\n@@ -5889,7 +5842,7 @@ s390_emit_epilogue (void)\n \t}\n       else\n \t{\n-\t  if (!CONST_OK_FOR_LETTER_P (INTVAL (frame_off), 'K'))\n+\t  if (!CONST_OK_FOR_CONSTRAINT_P (INTVAL (frame_off), 'K', \"K\"))\n \t    frame_off = force_const_mem (Pmode, frame_off);\n \n \t  insn = emit_insn (gen_add2_insn (frame_pointer, frame_off));\n@@ -6898,9 +6851,9 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n     {\n       /* Setup literal pool pointer if required.  */\n       if ((!DISP_IN_RANGE (delta)\n-\t   && !CONST_OK_FOR_LETTER_P (delta, 'K'))\n+\t   && !CONST_OK_FOR_CONSTRAINT_P (delta, 'K', \"K\"))\n \t  || (!DISP_IN_RANGE (vcall_offset)\n-\t      && !CONST_OK_FOR_LETTER_P (vcall_offset, 'K')))\n+\t      && !CONST_OK_FOR_CONSTRAINT_P (vcall_offset, 'K', \"K\")))\n \t{\n \t  op[5] = gen_label_rtx ();\n \t  output_asm_insn (\"larl\\t%4,%5\", op);\n@@ -6909,11 +6862,11 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       /* Add DELTA to this pointer.  */\n       if (delta)\n \t{\n-\t  if (CONST_OK_FOR_LETTER_P (delta, 'J'))\n+\t  if (CONST_OK_FOR_CONSTRAINT_P (delta, 'J', \"J\"))\n \t    output_asm_insn (\"la\\t%1,%2(%1)\", op);\n \t  else if (DISP_IN_RANGE (delta))\n \t    output_asm_insn (\"lay\\t%1,%2(%1)\", op);\n-\t  else if (CONST_OK_FOR_LETTER_P (delta, 'K'))\n+\t  else if (CONST_OK_FOR_CONSTRAINT_P (delta, 'K', \"K\"))\n \t    output_asm_insn (\"aghi\\t%1,%2\", op);\n \t  else\n \t    {\n@@ -6930,7 +6883,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t      output_asm_insn (\"lg\\t%4,0(%1)\", op);\n \t      output_asm_insn (\"ag\\t%1,%3(%4)\", op);\n \t    }\n-\t  else if (CONST_OK_FOR_LETTER_P (vcall_offset, 'K'))\n+\t  else if (CONST_OK_FOR_CONSTRAINT_P (vcall_offset, 'K', \"K\"))\n \t    {\n \t      output_asm_insn (\"lghi\\t%4,%3\", op);\n \t      output_asm_insn (\"ag\\t%4,0(%1)\", op);\n@@ -6973,9 +6926,9 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       /* Setup base pointer if required.  */\n       if (!vcall_offset\n \t  || (!DISP_IN_RANGE (delta)\n-              && !CONST_OK_FOR_LETTER_P (delta, 'K'))\n+              && !CONST_OK_FOR_CONSTRAINT_P (delta, 'K', \"K\"))\n \t  || (!DISP_IN_RANGE (delta)\n-              && !CONST_OK_FOR_LETTER_P (vcall_offset, 'K')))\n+              && !CONST_OK_FOR_CONSTRAINT_P (vcall_offset, 'K', \"K\")))\n \t{\n \t  op[5] = gen_label_rtx ();\n \t  output_asm_insn (\"basr\\t%4,0\", op);\n@@ -6986,11 +6939,11 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       /* Add DELTA to this pointer.  */\n       if (delta)\n \t{\n-\t  if (CONST_OK_FOR_LETTER_P (delta, 'J'))\n+\t  if (CONST_OK_FOR_CONSTRAINT_P (delta, 'J', \"J\"))\n \t    output_asm_insn (\"la\\t%1,%2(%1)\", op);\n \t  else if (DISP_IN_RANGE (delta))\n \t    output_asm_insn (\"lay\\t%1,%2(%1)\", op);\n-\t  else if (CONST_OK_FOR_LETTER_P (delta, 'K'))\n+\t  else if (CONST_OK_FOR_CONSTRAINT_P (delta, 'K', \"K\"))\n \t    output_asm_insn (\"ahi\\t%1,%2\", op);\n \t  else\n \t    {\n@@ -7002,7 +6955,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       /* Perform vcall adjustment.  */\n       if (vcall_offset)\n         {\n-\t  if (CONST_OK_FOR_LETTER_P (vcall_offset, 'J'))\n+\t  if (CONST_OK_FOR_CONSTRAINT_P (vcall_offset, 'J', \"J\"))\n \t    {\n \t      output_asm_insn (\"lg\\t%4,0(%1)\", op);\n \t      output_asm_insn (\"a\\t%1,%3(%4)\", op);\n@@ -7012,7 +6965,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t      output_asm_insn (\"lg\\t%4,0(%1)\", op);\n \t      output_asm_insn (\"ay\\t%1,%3(%4)\", op);\n \t    }\n-\t  else if (CONST_OK_FOR_LETTER_P (vcall_offset, 'K'))\n+\t  else if (CONST_OK_FOR_CONSTRAINT_P (vcall_offset, 'K', \"K\"))\n \t    {\n \t      output_asm_insn (\"lhi\\t%4,%3\", op);\n \t      output_asm_insn (\"a\\t%4,0(%1)\", op);"}, {"sha": "cbe02d657f84e7ff9f08e0c57cd826fd48615261", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -536,21 +536,20 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    (C) == 'd' ? GENERAL_REGS :                                          \\\n    (C) == 'f' ? FP_REGS : NO_REGS)\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C)                                 \\\n-  ((C) == 'I' ? (unsigned long) (VALUE) < 256 :                         \\\n-   (C) == 'J' ? (unsigned long) (VALUE) < 4096 :                        \\\n-   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 :                  \\\n-   (C) == 'L' ? (unsigned long) (VALUE) < 65536 : 0)\n+#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)                          \\\n+  s390_const_ok_for_constraint_p ((VALUE), (C), (STR))\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n+#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(VALUE, C, STR)  1\n \n-#define EXTRA_CONSTRAINT(OP, C)                               \t\\\n-  s390_extra_constraint ((OP), (C))\n+#define EXTRA_CONSTRAINT_STR(OP, C, STR)                               \t\\\n+  s390_extra_constraint_str ((OP), (C), (STR))\n #define EXTRA_MEMORY_CONSTRAINT(C, STR)\t\t\t\t\\\n   ((C) == 'Q' || (C) == 'R' || (C) == 'S' || (C) == 'T')\n #define EXTRA_ADDRESS_CONSTRAINT(C, STR)\t\t\t\\\n   ((C) == 'U' || (C) == 'W' || (C) == 'Y')\n \n+#define CONSTRAINT_LEN(C, STR)                                   \\\n+  ((C) == 'N' ? 5 : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n \n /* Stack layout and calling conventions.  */\n "}, {"sha": "2b79f75f751d7c99a6828162383fd636f087850b", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 190, "deletions": 254, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -28,17 +28,42 @@\n ;;    I -- An 8-bit constant (0..255).\n ;;    J -- A 12-bit constant (0..4095).\n ;;    K -- A 16-bit constant (-32768..32767).\n-;;    Q -- A memory reference without index-register.\n-;;    S -- Valid operand for the LARL instruction.\n+;;    L -- Value appropriate as displacement. \n+;;         (0..4095) for short displacement\n+;;         (-524288..524287) for long displacement\n+;;    M -- Constant integer with a value of 0x7fffffff.\n+;;    N -- Multiple letter constraint followed by 4 parameter letters.\n+;;         0..9:  number of the part counting from most to least significant\n+;;         H,Q:   mode of the part\n+;;         D,S,H: mode of the containing operand\n+;;         0,F:   value of the other parts (F - all bits set)\n+;;         \n+;;         The constraint matches if the specified part of a constant\n+;;         has a value different from its other parts.\n+;;    Q -- Memory reference without index register and with short displacement.\n+;;    R -- Memory reference with index register and short displacement.\n+;;    S -- Memory reference without index register but with long displacement.\n+;;    T -- Memory reference with index register and long displacement.\n+;;    U -- Pointer with short displacement.\n+;;    W -- Pointer with long displacement.\n+;;    Y -- Shift count operand.\n ;;\n ;; Special formats used for outputting 390 instructions.\n ;;\n-;;   %b -- Print a constant byte integer.               xy\n-;;   %h -- Print a signed 16-bit.                       wxyz\n-;;   %N -- Print next register (second word of a DImode reg) or next word.\n-;;   %M -- Print next register (second word of a TImode reg) or next word.\n-;;   %O -- Print the offset of a memory reference (PLUS (REG) (CONST_INT)).\n-;;   %R -- Print the register of a memory reference (PLUS (REG) (CONST_INT)).\n+;;     %C: print opcode suffix for branch condition.\n+;;     %D: print opcode suffix for inverse branch condition.\n+;;     %J: print tls_load/tls_gdcall/tls_ldcall suffix\n+;;     %O: print only the displacement of a memory reference.\n+;;     %R: print only the base register of a memory reference.\n+;;     %N: print the second word of a DImode operand.\n+;;     %M: print the second word of a TImode operand.\n+\n+;;     %b: print integer X as if it's an unsigned byte.\n+;;     %x: print integer X as if it's an unsigned word.\n+;;     %h: print integer X as if it's a signed word.\n+;;     %i: print the first nonzero HImode part of X\n+;;     %j: print the first HImode part unequal to 0xffff of X\n+\n ;;\n ;; We have a special constraint for pattern matching.\n ;;\n@@ -430,10 +455,10 @@\n                          (match_operand:DI 1 \"immediate_operand\" \"n,n\"))\n                  (match_operand:DI 2 \"immediate_operand\" \"n,n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_qi (operands[1], DImode, 0) >= 0\"\n+   && s390_single_part (operands[1], DImode, QImode, 0) >= 0\"\n {\n-  int part = s390_single_qi (operands[1], DImode, 0);\n-  operands[1] = GEN_INT (s390_extract_qi (operands[1], DImode, part));\n+  int part = s390_single_part (operands[1], DImode, QImode, 0);\n+  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n \n   operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n@@ -447,10 +472,10 @@\n                          (match_operand:SI 1 \"immediate_operand\" \"n,n\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_qi (operands[1], SImode, 0) >= 0\"\n+   && s390_single_part (operands[1], SImode, QImode, 0) >= 0\"\n {\n-  int part = s390_single_qi (operands[1], SImode, 0);\n-  operands[1] = GEN_INT (s390_extract_qi (operands[1], SImode, part));\n+  int part = s390_single_part (operands[1], SImode, QImode, 0);\n+  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n \n   operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n@@ -464,10 +489,10 @@\n                          (match_operand:SI 1 \"immediate_operand\" \"n,n\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_qi (operands[1], HImode, 0) >= 0\"\n+   && s390_single_part (operands[1], HImode, QImode, 0) >= 0\"\n {\n-  int part = s390_single_qi (operands[1], HImode, 0);\n-  operands[1] = GEN_INT (s390_extract_qi (operands[1], HImode, part));\n+  int part = s390_single_part (operands[1], HImode, QImode, 0);\n+  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n \n   operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n@@ -488,45 +513,30 @@\n \n (define_insn \"*tmdi_reg\"\n   [(set (reg 33)\n-        (compare (and:DI (match_operand:DI 0 \"nonimmediate_operand\" \"d\")\n-                         (match_operand:DI 1 \"immediate_operand\" \"n\"))\n-                 (match_operand:DI 2 \"immediate_operand\" \"n\")))]\n+        (compare (and:DI (match_operand:DI 0 \"nonimmediate_operand\" \"d,d,d,d\")\n+                         (match_operand:DI 1 \"immediate_operand\" \n+\t\t\t\t\t     \"N0HD0,N1HD0,N2HD0,N3HD0\"))\n+                 (match_operand:DI 2 \"immediate_operand\" \"n,n,n,n\")))]\n   \"TARGET_64BIT\n    && s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 1))\n-   && s390_single_hi (operands[1], DImode, 0) >= 0\"\n-{\n-  int part = s390_single_hi (operands[1], DImode, 0);\n-  operands[1] = GEN_INT (s390_extract_hi (operands[1], DImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"tmhh\\t%0,%x1\";\n-      case 1: return \"tmhl\\t%0,%x1\";\n-      case 2: return \"tmlh\\t%0,%x1\";\n-      case 3: return \"tmll\\t%0,%x1\";\n-      default: abort ();\n-    }\n-}\n+   && s390_single_part (operands[1], DImode, HImode, 0) >= 0\"\n+  \"@\n+   tmhh\\t%0,%i1\n+   tmhl\\t%0,%i1\n+   tmlh\\t%0,%i1\n+   tmll\\t%0,%i1\"\n   [(set_attr \"op_type\" \"RI\")])\n \n (define_insn \"*tmsi_reg\"\n   [(set (reg 33)\n-        (compare (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"d\")\n-                         (match_operand:SI 1 \"immediate_operand\" \"n\"))\n-                 (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n+        (compare (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"d,d\")\n+                         (match_operand:SI 1 \"immediate_operand\" \"N0HS0,N1HS0\"))\n+                 (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 1))\n-   && s390_single_hi (operands[1], SImode, 0) >= 0\"\n-{\n-  int part = s390_single_hi (operands[1], SImode, 0);\n-  operands[1] = GEN_INT (s390_extract_hi (operands[1], SImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"tmh\\t%0,%x1\";\n-      case 1: return \"tml\\t%0,%x1\";\n-      default: abort ();\n-    }\n-}\n+   && s390_single_part (operands[1], SImode, HImode, 0) >= 0\"\n+  \"@\n+   tmh\\t%0,%i1\n+   tml\\t%0,%i1\"\n   [(set_attr \"op_type\" \"RI\")])\n \n (define_insn \"*tmhi_full\"\n@@ -1039,47 +1049,6 @@\n     operands[1] = force_const_mem (DImode, operands[1]);\n })\n \n-(define_insn \"*movdi_lhi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (match_operand:DI 1 \"immediate_operand\" \"K\"))]\n-  \"TARGET_64BIT\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')\n-   && !FP_REG_P (operands[0])\"\n-  \"lghi\\t%0,%h1\"\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*movdi_lli\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (match_operand:DI 1 \"immediate_operand\" \"n\"))]\n-  \"TARGET_64BIT && s390_single_hi (operands[1], DImode, 0) >= 0\n-   && !FP_REG_P (operands[0])\"\n-{\n-  int part = s390_single_hi (operands[1], DImode, 0);\n-  operands[1] = GEN_INT (s390_extract_hi (operands[1], DImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"llihh\\t%0,%x1\";\n-      case 1: return \"llihl\\t%0,%x1\";\n-      case 2: return \"llilh\\t%0,%x1\";\n-      case 3: return \"llill\\t%0,%x1\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*movdi_lay\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (match_operand:DI 1 \"address_operand\" \"p\"))]\n-  \"TARGET_64BIT\n-   && TARGET_LONG_DISPLACEMENT\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && !FP_REG_P (operands[0])\"\n-  \"lay\\t%0,%a1\"\n-  [(set_attr \"op_type\" \"RXY\")\n-   (set_attr \"type\" \"la\")])\n-\n (define_insn \"*movdi_larl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (match_operand:DI 1 \"larl_operand\" \"X\"))]\n@@ -1090,10 +1059,18 @@\n     (set_attr \"type\"    \"larl\")])\n \n (define_insn \"*movdi_64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,m,!*f,!*f,!*f,!R,!T,?Q\")\n-        (match_operand:DI 1 \"general_operand\" \"d,m,d,*f,R,T,*f,*f,?Q\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \n+                            \"=d,d,d,d,d,d,d,d,m,!*f,!*f,!*f,!R,!T,?Q\")\n+        (match_operand:DI 1 \"general_operand\" \n+                            \"K,N0HD0,N1HD0,N2HD0,N3HD0,L,d,m,d,*f,R,T,*f,*f,?Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n+   lghi\\t%0,%h1\n+   llihh\\t%0,%i1\n+   llihl\\t%0,%i1\n+   llilh\\t%0,%i1\n+   llill\\t%0,%i1\n+   lay\\t%0,%a1\n    lgr\\t%0,%1\n    lg\\t%0,%1\n    stg\\t%1,%0\n@@ -1103,8 +1080,9 @@\n    std\\t%1,%0\n    stdy\\t%1,%0\n    mvc\\t%O0(8,%R0),%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY,RXY,RR,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"lr,load,store,floadd,floadd,floadd,fstored,fstored,cs\")])\n+  [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RXY,RRE,RXY,RXY,RR,RX,RXY,RX,RXY,SS\")\n+   (set_attr \"type\" \"*,*,*,*,*,la,lr,load,store,floadd,floadd,floadd,\n+                     fstored,fstored,cs\")])\n \n (define_insn \"*movdi_31\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,Q,d,o,!*f,!*f,!*f,!R,!T,Q\")\n@@ -1224,43 +1202,6 @@\n     operands[1] = force_const_mem (SImode, operands[1]);\n })\n \n-(define_insn \"*movsi_lhi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (match_operand:SI 1 \"immediate_operand\" \"K\"))]\n-  \"GET_CODE (operands[1]) == CONST_INT\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')\n-   && !FP_REG_P (operands[0])\"\n-  \"lhi\\t%0,%h1\"\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*movsi_lli\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (match_operand:SI 1 \"immediate_operand\" \"n\"))]\n-  \"TARGET_ZARCH && s390_single_hi (operands[1], SImode, 0) >= 0\n-   && !FP_REG_P (operands[0])\"\n-{\n-  int part = s390_single_hi (operands[1], SImode, 0);\n-  operands[1] = GEN_INT (s390_extract_hi (operands[1], SImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"llilh\\t%0,%x1\";\n-      case 1: return \"llill\\t%0,%x1\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*movsi_lay\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (match_operand:SI 1 \"address_operand\" \"p\"))]\n-  \"TARGET_LONG_DISPLACEMENT\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && !FP_REG_P (operands[0])\"\n-  \"lay\\t%0,%a1\"\n-  [(set_attr \"op_type\" \"RXY\")\n-   (set_attr \"type\" \"la\")])\n-\n (define_insn \"*movsi_larl\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:SI 1 \"larl_operand\" \"X\"))]\n@@ -1270,11 +1211,17 @@\n    [(set_attr \"op_type\" \"RIL\")\n     (set_attr \"type\"    \"larl\")])\n \n-(define_insn \"*movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,T,!*f,!*f,!*f,!R,!T,?Q\")\n-        (match_operand:SI 1 \"general_operand\" \"d,R,T,d,d,*f,R,T,*f,*f,?Q\"))]\n-  \"\"\n+(define_insn \"*movsi_zarch\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \n+                            \"=d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,?Q\")\n+        (match_operand:SI 1 \"general_operand\" \n+                            \"K,N0HS0,N1HS0,L,d,R,T,d,d,*f,R,T,*f,*f,?Q\"))]\n+  \"TARGET_ZARCH\"\n   \"@\n+   lhi\\t%0,%h1\n+   llilh\\t%0,%i1\n+   llill\\t%0,%i1\n+   lay\\t%0,%a1\n    lr\\t%0,%1\n    l\\t%0,%1\n    ly\\t%0,%1\n@@ -1286,8 +1233,24 @@\n    ste\\t%1,%0\n    stey\\t%1,%0\n    mvc\\t%O0(4,%R0),%1\"\n-  [(set_attr \"op_type\" \"RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"lr,load,load,store,store,floads,floads,floads,fstores,fstores,cs\")])\n+  [(set_attr \"op_type\" \"RI,RI,RI,RXY,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n+   (set_attr \"type\" \"*,*,*,la,lr,load,load,store,store,floads,floads,floads,fstores,fstores,cs\")])\n+\n+(define_insn \"*movsi_esa\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,!*f,!*f,!R,?Q\")\n+        (match_operand:SI 1 \"general_operand\" \"K,d,R,d,*f,R,*f,?Q\"))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   lhi\\t%0,%h1\n+   lr\\t%0,%1\n+   l\\t%0,%1\n+   st\\t%1,%0\n+   ler\\t%0,%1\n+   le\\t%0,%1\n+   ste\\t%1,%0\n+   mvc\\t%O0(4,%R0),%1\"\n+  [(set_attr \"op_type\" \"RI,RR,RX,RX,RR,RX,RX,SS\")\n+   (set_attr \"type\" \"*,lr,load,store,floads,floads,fstores,cs\")])\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -2503,14 +2466,12 @@\n    llgt\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")])\n \n-(define_insn_and_split \"*llgt_sisi_split\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"d,m\")\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n \t\t(const_int 2147483647)))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"TARGET_64BIT && reload_completed\"\n   [(set (match_dup 0)\n         (and:SI (match_dup 1)\n \t\t(const_int 2147483647)))]\n@@ -2526,14 +2487,12 @@\n    llgt\\t%0,%N1\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")])\n \n-(define_insn_and_split \"*llgt_didi_split\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"d,o\")\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n                 (const_int 2147483647)))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"TARGET_64BIT && reload_completed\"\n   [(set (match_dup 0)\n         (and:DI (match_dup 1)\n                 (const_int 2147483647)))]\n@@ -3193,7 +3152,7 @@\n         (plus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_64BIT\n    && s390_match_ccmode (insn, CCAmode)\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+   && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'K', \\\"K\\\")\"\n   \"aghi\\t%0,%h2\"\n   [(set_attr \"op_type\"  \"RI\")])\n \n@@ -3421,7 +3380,7 @@\n    (set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCAmode)\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+   && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'K', \\\"K\\\")\"\n   \"ahi\\t%0,%h2\"\n   [(set_attr \"op_type\"  \"RI\")])\n \n@@ -5009,37 +4968,23 @@\n    ng\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n-(define_insn \"*anddi3_ni\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-                (match_operand:DI 2 \"immediate_operand\" \"n\")))\n-   (clobber (reg:CC 33))]\n-  \"TARGET_64BIT && s390_single_hi (operands[2], DImode, -1) >= 0\"\n-{\n-  int part = s390_single_hi (operands[2], DImode, -1);\n-  operands[2] = GEN_INT (s390_extract_hi (operands[2], DImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"nihh\\t%0,%x2\";\n-      case 1: return \"nihl\\t%0,%x2\";\n-      case 2: return \"nilh\\t%0,%x2\";\n-      case 3: return \"nill\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\"  \"RI\")])\n-\n (define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-                (match_operand:DI 2 \"general_operand\" \"d,m\")))\n-   (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   ngr\\t%0,%2\n-   ng\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXY\")])\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d,d,d,d,d,d\")\n+\t(and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"d,o,0,0,0,0,0,0\")\n+ \t\t(match_operand:DI 2 \"general_operand\" \n+\t\t\t\t    \"M,M,N0HDF,N1HDF,N2HDF,N3HDF,d,m\")))\n+     (clobber (reg:CC 33))]\n+   \"TARGET_64BIT\"\n+   \"@\n+    #\n+    #\n+    nihh\\t%0,%j2\n+    nihl\\t%0,%j2\n+    nilh\\t%0,%j2\n+    nill\\t%0,%j2\n+    ngr\\t%0,%2\n+    ng\\t%0,%2\"\n+ [(set_attr \"op_type\" \"RRE,RXE,RI,RI,RI,RI,RRE,RXY\")])\n \n (define_insn \"*anddi3_ss\"\n   [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n@@ -5090,36 +5035,41 @@\n    ny\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n-(define_insn \"*andsi3_ni\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-                (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-   (clobber (reg:CC 33))]\n-  \"TARGET_ZARCH && s390_single_hi (operands[2], SImode, -1) >= 0\"\n-{\n-  int part = s390_single_hi (operands[2], SImode, -1);\n-  operands[2] = GEN_INT (s390_extract_hi (operands[2], SImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"nilh\\t%0,%x2\";\n-      case 1: return \"nill\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\"  \"RI\")])\n+(define_expand \"andsi3\"\n+  [(parallel \n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  \"\")\n \n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-                (match_operand:SI 2 \"general_operand\" \"d,R,T\")))\n+(define_insn \"*andsi3_zarch\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d,d,d,d\")\n+        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"d,o,0,0,0,0,0\")\n+                (match_operand:SI 2 \"general_operand\" \"M,M,N0HSF,N1HSF,d,R,T\")))\n    (clobber (reg:CC 33))]\n-  \"\"\n+  \"TARGET_ZARCH\"\n   \"@\n+   #\n+   #\n+   nilh\\t%0,%j2\n+   nill\\t%0,%j2   \n    nr\\t%0,%2\n    n\\t%0,%2\n    ny\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n+  [(set_attr \"op_type\"  \"RRE,RXE,RI,RI,RR,RX,RXY\")])\n+\n+(define_insn \"*andsi3_esa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n+                (match_operand:SI 2 \"general_operand\" \"d,R\")))\n+   (clobber (reg:CC 33))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   nr\\t%0,%2\n+   n\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX\")])\n \n (define_insn \"*andsi3_ss\"\n   [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n@@ -5263,37 +5213,20 @@\n    og\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n-(define_insn \"*iordi3_oi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-                (match_operand:DI 2 \"immediate_operand\" \"n\")))\n-   (clobber (reg:CC 33))]\n-  \"TARGET_64BIT && s390_single_hi (operands[2], DImode, 0) >= 0\"\n-{\n-  int part = s390_single_hi (operands[2], DImode, 0);\n-  operands[2] = GEN_INT (s390_extract_hi (operands[2], DImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"oihh\\t%0,%x2\";\n-      case 1: return \"oihl\\t%0,%x2\";\n-      case 2: return \"oilh\\t%0,%x2\";\n-      case 3: return \"oill\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\"  \"RI\")])\n-\n (define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-                (match_operand:DI 2 \"general_operand\" \"d,m\")))\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d,d,d,d\")\n+        (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0,0,0,0,0\")\n+                (match_operand:DI 2 \"general_operand\" \"N0HD0,N1HD0,N2HD0,N3HD0,d,m\")))\n    (clobber (reg:CC 33))]\n   \"TARGET_64BIT\"\n   \"@\n+   oihh\\t%0,%i2\n+   oihl\\t%0,%i2\n+   oilh\\t%0,%i2\n+   oill\\t%0,%i2\n    ogr\\t%0,%2\n    og\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXY\")])\n+  [(set_attr \"op_type\"  \"RI,RI,RI,RI,RRE,RXY\")])\n \n (define_insn \"*iordi3_ss\"\n   [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n@@ -5344,36 +5277,39 @@\n    oy\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n-(define_insn \"*iorsi3_oi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-                (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-   (clobber (reg:CC 33))]\n-  \"TARGET_ZARCH && s390_single_hi (operands[2], SImode, 0) >= 0\"\n-{\n-  int part = s390_single_hi (operands[2], SImode, 0);\n-  operands[2] = GEN_INT (s390_extract_hi (operands[2], SImode, part));\n-\n-  switch (part)\n-    {\n-      case 0: return \"oilh\\t%0,%x2\";\n-      case 1: return \"oill\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\"  \"RI\")])\n+(define_expand \"iorsi3\"\n+  [(parallel \n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  \"\")\n \n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-        (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-                (match_operand:SI 2 \"general_operand\" \"d,R,T\")))\n+(define_insn \"iorsi3_zarch\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d,d\")\n+        (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0,0,0,0\")\n+                (match_operand:SI 2 \"general_operand\" \"N0HS0,N1HS0,d,R,T\")))\n    (clobber (reg:CC 33))]\n-  \"\"\n+  \"TARGET_ZARCH\"\n   \"@\n+   oilh\\t%0,%i2\n+   oill\\t%0,%i2\n    or\\t%0,%2\n    o\\t%0,%2\n    oy\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n+  [(set_attr \"op_type\"  \"RI,RI,RR,RX,RXY\")])\n+\n+(define_insn \"iorsi3_esa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n+                (match_operand:SI 2 \"general_operand\" \"d,R\")))\n+   (clobber (reg:CC 33))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   or\\t%0,%2\n+   o\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX\")])\n \n (define_insn \"*iorsi3_ss\"\n   [(set (match_operand:SI 0 \"s_operand\" \"=Q\")"}, {"sha": "5e3618f78b3ebb0280ff8535d44988501b530f8d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a9af7e12657d431363e301fc31aec7d507684/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f19a9af7e12657d431363e301fc31aec7d507684", "patch": "@@ -2196,13 +2196,52 @@ Unsigned 12-bit constant (0--4095)\n Signed 16-bit constant (@minus{}32768--32767)\n \n @item L\n-Unsigned 16-bit constant (0--65535)\n+Value appropriate as displacement.\n+@table @code\n+       @item (0..4095)\n+       for short displacement\n+       @item (-524288..524287)\n+       for long displacement\n+@end table\n+\n+@item M\n+Constant integer with a value of 0x7fffffff.\n+\n+@item N\n+Multiple letter constraint followed by 4 parameter letters.\n+@table @code\n+         @item 0..9:\n+         number of the part counting from most to least significant\n+         @item H,Q:\n+         mode of the part\n+         @item D,S,H:\n+         mode of the containing operand\n+         @item 0,F:\n+         value of the other parts (F - all bits set)\n+@end table\n+The constraint matches if the specified part of a constant\n+has a value different from it's other parts.\n \n @item Q\n-Memory reference without index register\n+Memory reference without index register and with short displacement.\n+\n+@item R\n+Memory reference with index register and short displacement.\n \n @item S\n-Symbolic constant suitable for use with the @code{larl} instruction\n+Memory reference without index register but with long displacement.\n+\n+@item T\n+Memory reference with index register and long displacement.\n+\n+@item U\n+Pointer with short displacement.\n+\n+@item W\n+Pointer with long displacement.\n+\n+@item Y\n+Shift count operand.\n \n @end table\n "}]}