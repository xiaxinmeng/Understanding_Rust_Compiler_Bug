{"sha": "51bf9bdffff02529ce6331fda689e0d2fde3100f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiZjliZGZmZmYwMjUyOWNlNjMzMWZkYTY4OWUwZDJmZGUzMTAwZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T13:46:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T13:46:36Z"}, "message": "[multiple changes]\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.ads (Check_Policy_List): Add some clarifying comments\n\t* sem_prag.adb (Analyze_Pragma, case Check): Set Pragma_Enabled flag\n\ton rewritten Assert pragma.\n\n2010-06-14  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch6.adb (Check_Overriding_Indicator): Add a special check for\n\tcontrolled operations, so that they will be treated as overriding even\n\tif the overridden subprogram is marked Is_Hidden, as long as the\n\toverridden subprogram's parent subprogram is not hidden.\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Entry for gnatw.d no longer specific for while loops\n\t* einfo.adb (First_Exit_Statement): New attribute for E_Loop\n\t* einfo.ads (First_Exit_Statement): New attribute for E_Loop\n\t* sem_ch5.adb (Analyze_Loop_Statement): Check_Infinite_Loop_Warning has\n\tnew calling sequence to include test for EXIT WHEN.\n\t(Analyze_Exit_Statement): Chain EXIT statement into exit statement chain\n\t* sem_warn.ads, sem_warn.adb (Check_Infinite_Loop_Warning): Now handles\n\tEXIT WHEN case.\n\t* sinfo.adb (Next_Exit_Statement): New attribute of N_Exit_Statement\n\tnode.\n\t* sinfo.ads (N_Pragma): Correct comment on Sloc field (points to\n\tPRAGMA, not to pragma identifier).\n\t(Next_Exit_Statement): New attribute of N_Exit_Statement node\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb (Resolve_Short_Circuit): Fix sloc of \"assertion/check\n\twould fail\" msg.\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch2.adb (Scan_Pragma_Argument_Association): Clarify message for\n\tmissing pragma argument identifier.\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.ads, atree.adb (Ekind_In): New functions\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Expon): Optimize 2**N in stand alone context\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* usage.adb (Usage): Redo documentation of -gnatwa.\n\nFrom-SVN: r160743", "tree": {"sha": "a0283a841af37f2fc802a622bdd4010911b38019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0283a841af37f2fc802a622bdd4010911b38019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51bf9bdffff02529ce6331fda689e0d2fde3100f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bf9bdffff02529ce6331fda689e0d2fde3100f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51bf9bdffff02529ce6331fda689e0d2fde3100f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bf9bdffff02529ce6331fda689e0d2fde3100f/comments", "author": null, "committer": null, "parents": [{"sha": "ae24748803fb1d0de3fd2f3c2f0f8363dc14417f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae24748803fb1d0de3fd2f3c2f0f8363dc14417f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae24748803fb1d0de3fd2f3c2f0f8363dc14417f"}], "stats": {"total": 599, "additions": 507, "deletions": 92}, "files": [{"sha": "78ebd9234cbacb92419728ebd105093750dd9805", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -1,3 +1,54 @@\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.ads (Check_Policy_List): Add some clarifying comments\n+\t* sem_prag.adb (Analyze_Pragma, case Check): Set Pragma_Enabled flag\n+\ton rewritten Assert pragma.\n+\n+2010-06-14  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Overriding_Indicator): Add a special check for\n+\tcontrolled operations, so that they will be treated as overriding even\n+\tif the overridden subprogram is marked Is_Hidden, as long as the\n+\toverridden subprogram's parent subprogram is not hidden.\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Entry for gnatw.d no longer specific for while loops\n+\t* einfo.adb (First_Exit_Statement): New attribute for E_Loop\n+\t* einfo.ads (First_Exit_Statement): New attribute for E_Loop\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Check_Infinite_Loop_Warning has\n+\tnew calling sequence to include test for EXIT WHEN.\n+\t(Analyze_Exit_Statement): Chain EXIT statement into exit statement chain\n+\t* sem_warn.ads, sem_warn.adb (Check_Infinite_Loop_Warning): Now handles\n+\tEXIT WHEN case.\n+\t* sinfo.adb (Next_Exit_Statement): New attribute of N_Exit_Statement\n+\tnode.\n+\t* sinfo.ads (N_Pragma): Correct comment on Sloc field (points to\n+\tPRAGMA, not to pragma identifier).\n+\t(Next_Exit_Statement): New attribute of N_Exit_Statement node\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Short_Circuit): Fix sloc of \"assertion/check\n+\twould fail\" msg.\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch2.adb (Scan_Pragma_Argument_Association): Clarify message for\n+\tmissing pragma argument identifier.\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.ads, atree.adb (Ekind_In): New functions\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Expon): Optimize 2**N in stand alone context\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* usage.adb (Usage): Redo documentation of -gnatwa.\n+\n 2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch8.adb (Find_Type): The attribute 'class cannot be applied to"}, {"sha": "de7bd7e971952ff24f77509e390e89e235563532", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -766,6 +766,104 @@ package body Atree is\n       return N_To_E (Nodes.Table (E + 1).Nkind);\n    end Ekind;\n \n+   --------------\n+   -- Ekind_In --\n+   --------------\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2;\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3;\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4;\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5;\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2);\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3);\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3, V4);\n+   end Ekind_In;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3, V4, V5);\n+   end Ekind_In;\n+\n    ------------------\n    -- Error_Posted --\n    ------------------"}, {"sha": "2f61374a6e945bb8667a25fadd661eade751c94a", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -543,8 +543,12 @@ package Atree is\n    --  Tests given Id for inequality with the Empty node. This allows notations\n    --  like \"if Present (Statement)\" as opposed to \"if Statement /= Empty\".\n \n-   --  Node_Kind tests, like the functions in Sinfo, but the first argument is\n-   --  a Node_Id, and the tested field is Nkind (N).\n+   ---------------------\n+   -- Node_Kind Tests --\n+   ---------------------\n+\n+   --  These are like the functions in Sinfo, but the first argument is a\n+   --  Node_Id, and the tested field is Nkind (N).\n \n    function Nkind_In\n      (N  : Node_Id;\n@@ -617,6 +621,70 @@ package Atree is\n    pragma Inline (Nkind_In);\n    --  Inline all above functions\n \n+   -----------------------\n+   -- Entity_Kind_Tests --\n+   -----------------------\n+\n+   --  Utility functions to test whether an Entity_Kind value, either given\n+   --  directly as the first argument, or the Ekind field of an Entity give\n+   --  as the first argument, matches any of the given list of Entity_Kind\n+   --  values. Return True if any match, False if no match.\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind) return Boolean;\n+\n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind) return Boolean;\n+\n+   pragma Inline (Ekind_In);\n+   --  Inline all above functions\n+\n    -----------------------------\n    -- Entity Access Functions --\n    -----------------------------"}, {"sha": "8f08dcc81b8a795a0dffda7e321eeda77139e993", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -113,7 +113,7 @@ package body Debug is\n    --  d.t  Disable static allocation of library level dispatch tables\n    --  d.u\n    --  d.v  Enable OK_To_Reorder_Components in variant records\n-   --  d.w  Do not check for infinite while loops\n+   --  d.w  Do not check for infinite loops\n    --  d.x  No exception handlers\n    --  d.y\n    --  d.z\n@@ -548,7 +548,7 @@ package body Debug is\n    --  d.v  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have at least one discriminant (v = variant).\n \n-   --  d.w  This flag turns off the scanning of while loops to detect possible\n+   --  d.w  This flag turns off the scanning of loops to detect possible\n    --       infinite loops.\n \n    --  d.x  No exception handlers in generated code. This causes exception"}, {"sha": "1fd68b8fcf7d18addc08ca6803a3e07c49c859e1", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -79,6 +79,7 @@ package body Einfo is\n    --    Normalized_First_Bit            Uint8\n    --    Postcondition_Proc              Node8\n    --    Return_Applies_To               Node8\n+   --    First_Exit_Statement            Node8\n \n    --    Class_Wide_Type                 Node9\n    --    Current_Value                   Node9\n@@ -1053,6 +1054,12 @@ package body Einfo is\n       return Node17 (Id);\n    end First_Entity;\n \n+   function First_Exit_Statement (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      return Node8 (Id);\n+   end First_Exit_Statement;\n+\n    function First_Index (Id : E) return N is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_String_Type (Id));\n@@ -3492,6 +3499,12 @@ package body Einfo is\n       Set_Node17 (Id, V);\n    end Set_First_Entity;\n \n+   procedure Set_First_Exit_Statement (Id : E; V : N) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      Set_Node8 (Id, V);\n+   end Set_First_Exit_Statement;\n+\n    procedure Set_First_Index (Id : E; V : N) is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_String_Type (Id));\n@@ -7236,6 +7249,9 @@ package body Einfo is\n          when Type_Kind                                    =>\n             Write_Str (\"Associated_Node_For_Itype\");\n \n+         when E_Loop                                       =>\n+            Write_Str (\"First_Exit_Statement\");\n+\n          when E_Package                                    =>\n             Write_Str (\"Dependent_Instances\");\n "}, {"sha": "d9ff8c0a24db035771860276b3106e1b5a8ef5d5", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -1116,6 +1116,13 @@ package Einfo is\n --       Points to a list of associated entities using the Next_Entity field\n --       as a chain pointer with Empty marking the end of the list.\n \n+--    First_Exit_Statement (Node8)\n+--       Present in E_Loop entity. The exit statements for a loop are chained\n+--       (in reverse order of appearence) using this field to point to the\n+--       first entry in the chain (last exit statement in the loop). The\n+--       entries are chained through the Next_Exit_Statement field of the\n+--       N_Exit_Statement node with Empty marking the end of the list.\n+\n --    First_Formal (synthesized)\n --       Applies to subprograms and subprogram types, and also in entries\n --       and entry families. Returns first formal of the subprogram or entry.\n@@ -5063,6 +5070,7 @@ package Einfo is\n    --    (plus type attributes)\n \n    --  E_Loop\n+   --    First_Exit_Statement                (Node8)\n    --    Has_Exit                            (Flag47)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n@@ -5743,6 +5751,7 @@ package Einfo is\n    function Finalization_Chain_Entity           (Id : E) return E;\n    function Finalize_Storage_Only               (Id : E) return B;\n    function First_Entity                        (Id : E) return E;\n+   function First_Exit_Statement                (Id : E) return N;\n    function First_Index                         (Id : E) return N;\n    function First_Literal                       (Id : E) return E;\n    function First_Optional_Parameter            (Id : E) return E;\n@@ -6291,6 +6300,7 @@ package Einfo is\n    procedure Set_Finalization_Chain_Entity       (Id : E; V : E);\n    procedure Set_Finalize_Storage_Only           (Id : E; V : B := True);\n    procedure Set_First_Entity                    (Id : E; V : E);\n+   procedure Set_First_Exit_Statement            (Id : E; V : N);\n    procedure Set_First_Index                     (Id : E; V : N);\n    procedure Set_First_Literal                   (Id : E; V : E);\n    procedure Set_First_Optional_Parameter        (Id : E; V : E);\n@@ -6945,6 +6955,7 @@ package Einfo is\n    pragma Inline (Can_Use_Internal_Rep);\n    pragma Inline (Finalization_Chain_Entity);\n    pragma Inline (First_Entity);\n+   pragma Inline (First_Exit_Statement);\n    pragma Inline (First_Index);\n    pragma Inline (First_Literal);\n    pragma Inline (First_Optional_Parameter);\n@@ -7376,6 +7387,7 @@ package Einfo is\n    pragma Inline (Set_Can_Use_Internal_Rep);\n    pragma Inline (Set_Finalization_Chain_Entity);\n    pragma Inline (Set_First_Entity);\n+   pragma Inline (Set_First_Exit_Statement);\n    pragma Inline (Set_First_Index);\n    pragma Inline (Set_First_Literal);\n    pragma Inline (Set_First_Optional_Parameter);"}, {"sha": "a8b7854421908c6bce9a08e3ac37a7f724499c41", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -47,6 +47,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -5066,7 +5067,7 @@ package body Exp_Ch4 is\n         and then Is_Power_Of_2_For_Shift (Ropnd)\n \n       --  We cannot do this transformation in configurable run time mode if we\n-      --  have 64-bit --  integers and long shifts are not available.\n+      --  have 64-bit integers and long shifts are not available.\n \n         and then\n           (Esize (Ltyp) <= 32\n@@ -5912,6 +5913,9 @@ package body Exp_Ch4 is\n       --  the flag Is_Natural_Power_Of_2_for_Shift set, then the expansion\n       --  of the higher level node converts it into a shift.\n \n+      --  Another case is 2 ** N in any other context. We simply convert\n+      --  this to 1 * 2 ** N, and then the above transformation applies.\n+\n       --  Note: this transformation is not applicable for a modular type with\n       --  a non-binary modulus in the multiplication case, since we get a wrong\n       --  result if the shift causes an overflow before the modular reduction.\n@@ -5922,33 +5926,45 @@ package body Exp_Ch4 is\n         and then Esize (Root_Type (Exptyp)) <= Esize (Standard_Integer)\n         and then Is_Unsigned_Type (Exptyp)\n         and then not Ovflo\n-        and then Nkind (Parent (N)) in N_Binary_Op\n       then\n-         declare\n-            P : constant Node_Id := Parent (N);\n-            L : constant Node_Id := Left_Opnd (P);\n-            R : constant Node_Id := Right_Opnd (P);\n+         --  First the multiply and divide cases\n \n-         begin\n-            if (Nkind (P) = N_Op_Multiply\n-                 and then not Non_Binary_Modulus (Typ)\n-                 and then\n-                   ((Is_Integer_Type (Etype (L)) and then R = N)\n-                       or else\n-                    (Is_Integer_Type (Etype (R)) and then L = N))\n-                 and then not Do_Overflow_Check (P))\n-\n-              or else\n-                (Nkind (P) = N_Op_Divide\n-                  and then Is_Integer_Type (Etype (L))\n-                  and then Is_Unsigned_Type (Etype (L))\n-                  and then R = N\n-                  and then not Do_Overflow_Check (P))\n-            then\n-               Set_Is_Power_Of_2_For_Shift (N);\n-               return;\n-            end if;\n-         end;\n+         if Nkind_In (Parent (N), N_Op_Divide, N_Op_Multiply) then\n+            declare\n+               P : constant Node_Id := Parent (N);\n+               L : constant Node_Id := Left_Opnd (P);\n+               R : constant Node_Id := Right_Opnd (P);\n+\n+            begin\n+               if (Nkind (P) = N_Op_Multiply\n+                   and then not Non_Binary_Modulus (Typ)\n+                   and then\n+                     ((Is_Integer_Type (Etype (L)) and then R = N)\n+                         or else\n+                      (Is_Integer_Type (Etype (R)) and then L = N))\n+                   and then not Do_Overflow_Check (P))\n+                 or else\n+                  (Nkind (P) = N_Op_Divide\n+                     and then Is_Integer_Type (Etype (L))\n+                     and then Is_Unsigned_Type (Etype (L))\n+                     and then R = N\n+                     and then not Do_Overflow_Check (P))\n+               then\n+                  Set_Is_Power_Of_2_For_Shift (N);\n+                  return;\n+               end if;\n+            end;\n+\n+         --  Now the other cases\n+\n+         elsif not Non_Binary_Modulus (Typ) then\n+            Rewrite (N,\n+              Make_Op_Multiply (Loc,\n+                Left_Opnd  => Make_Integer_Literal (Loc, 1),\n+                Right_Opnd => Relocate_Node (N)));\n+            Analyze_And_Resolve (N, Typ);\n+            return;\n+         end if;\n       end if;\n \n       --  Fall through if exponentiation must be done using a runtime routine\n@@ -8745,6 +8761,12 @@ package body Exp_Ch4 is\n \n       if Compile_Time_Known_Value (Left) then\n \n+         --  Mark SCO for left condition as compile time known\n+\n+         if Generate_SCO and then Comes_From_Source (Left) then\n+            Set_SCO_Condition (Left, Expr_Value_E (Left) = Standard_True);\n+         end if;\n+\n          --  Rewrite True AND THEN Right / False OR ELSE Right to Right.\n          --  Any actions associated with Right will be executed unconditionally\n          --  and can thus be inserted into the tree unconditionally.\n@@ -8830,6 +8852,12 @@ package body Exp_Ch4 is\n \n       if Compile_Time_Known_Value (Right) then\n \n+         --  Mark SCO for left condition as compile time known\n+\n+         if Generate_SCO and then Comes_From_Source (Right) then\n+            Set_SCO_Condition (Right, Expr_Value_E (Right) = Standard_True);\n+         end if;\n+\n          --  Change (Left and then True), (Left or else False) to Left.\n          --  Note that we know there are no actions associated with the right\n          --  operand, since we just checked for this case above."}, {"sha": "90b44599edd02547e1ea357f2b0e18f72bdc87d8", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -224,7 +224,10 @@ package Opt is\n    --  GNAT\n    --  This points to the list of N_Pragma nodes for Check_Policy pragmas\n    --  that are linked through the Next_Pragma fields, with the list being\n-   --  terminated by Empty. The order is most recently processed first.\n+   --  terminated by Empty. The order is most recently processed first. Note\n+   --  that Push_Scope and Pop_Scope in Sem_Ch8 save and restore the value\n+   --  of this variable, implementing the required scope control for pragmas\n+   --  appearing a declarative part.\n \n    Check_Readonly_Files : Boolean := False;\n    --  GNATMAKE"}, {"sha": "def8ef5c521b0ba7c0d5647978496c035accf706", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -503,7 +503,9 @@ package body Ch2 is\n \n       if Identifier_Seen and not Id_Present then\n          Error_Msg_SC\n-           (\"|pragma argument identifier required here (RM 2.8(4))\");\n+           (\"|pragma argument identifier required here\");\n+         Error_Msg_SC\n+           (\"\\since previous argument had identifier (RM 2.8(4))\");\n       end if;\n \n       if Id_Present then"}, {"sha": "44909e2e36b181ab7d9fefd3376926b3c707868c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -1209,6 +1209,11 @@ package body Sem_Ch5 is\n          Check_Unset_Reference (Cond);\n       end if;\n \n+      --  Chain exit statement to associated loop entity\n+\n+      Set_Next_Exit_Statement  (N, First_Exit_Statement (Scope_Id));\n+      Set_First_Exit_Statement (Scope_Id, N);\n+\n       --  Since the exit may take us out of a loop, any previous assignment\n       --  statement is not useless, so clear last assignment indications. It\n       --  is OK to keep other current values, since if the exit statement\n@@ -2060,8 +2065,12 @@ package body Sem_Ch5 is\n       End_Scope;\n       Kill_Current_Values;\n \n-      --  Check for infinite loop. We skip this check for generated code, since\n-      --  it justs waste time and makes debugging the routine called harder.\n+      --  Check for infinite loop. Skip check for generated code, since it\n+      --  justs waste time and makes debugging the routine called harder.\n+\n+      --  Note that we have to wait till the body of the loop is fully analyzed\n+      --  before making this call, since Check_Infinite_Loop_Warning relies on\n+      --  being able to use semantic visibility information to find references.\n \n       if Comes_From_Source (N) then\n          Check_Infinite_Loop_Warning (N);"}, {"sha": "befa1d48e9789e8ea6efaa4a4682cc21b516f46c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -4420,8 +4420,24 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n+      --  If there is an overridden subprogram, then check that there is not\n+      --  a \"not overriding\" indicator, and mark the subprogram as overriding.\n+      --  This is not done if the overridden subprogram is marked as hidden,\n+      --  which can occur for the case of inherited controlled operations\n+      --  (see Derive_Subprogram), unless the inherited subprogram's parent\n+      --  subprogram is not itself hidden. (Note: This condition could probably\n+      --  be simplified, leaving out the testing for the specific controlled\n+      --  cases, but it seems safer and clearer this way, and echoes similar\n+      --  special-case tests of this kind in other places.)\n+\n       if Present (Overridden_Subp)\n-        and then not Is_Hidden (Overridden_Subp)\n+        and then (not Is_Hidden (Overridden_Subp)\n+                   or else\n+                     ((Chars (Overridden_Subp) = Name_Initialize\n+                         or else Chars (Overridden_Subp) = Name_Adjust\n+                         or else Chars (Overridden_Subp) = Name_Finalize)\n+                       and then Present (Alias (Overridden_Subp))\n+                       and then not Is_Hidden (Alias (Overridden_Subp))))\n       then\n          if Must_Not_Override (Spec) then\n             Error_Msg_Sloc := Sloc (Overridden_Subp);"}, {"sha": "0e8157a875b9456eef638b31058438f8eb91befc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -5771,8 +5771,13 @@ package body Sem_Prag is\n             end if;\n \n             Check_Arg_Is_Identifier (Arg1);\n+\n+            --  Indicate if pragma is enabled. The Original_Node reference here\n+            --  is to deal with pragma Assert rewritten as a Check pragma.\n+\n             Check_On := Check_Enabled (Chars (Get_Pragma_Arg (Arg1)));\n             Set_Pragma_Enabled (N, Check_On);\n+            Set_Pragma_Enabled (Original_Node (N), Check_On);\n \n             --  If expansion is active and the check is not enabled then we\n             --  rewrite the Check as:"}, {"sha": "0e234925bac27e22b05d6e38a500a425e1ceb0dc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -7846,15 +7846,15 @@ package body Sem_Res is\n                   then\n                      null;\n                   else\n-                     --  Issue warning. Note that we don't want to make this\n-                     --  an unconditional warning, because if the assert is\n-                     --  within deleted code we do not want the warning. But\n-                     --  we do not want the deletion of the IF/AND-THEN to\n-                     --  take this message with it. We achieve this by making\n-                     --  sure that the expanded code points to the Sloc of\n-                     --  the expression, not the original pragma.\n-\n-                     Error_Msg_N (\"?assertion would fail at run-time\", Orig);\n+                     --  Issue warning. We do not want the deletion of the\n+                     --  IF/AND-THEN to take this message with it. We achieve\n+                     --  this by making sure that the expanded code points to\n+                     --  the Sloc of the expression, not the original pragma.\n+\n+                     Error_Msg_N\n+                       (\"?assertion would fail at run-time!\",\n+                        Expression\n+                          (First (Pragma_Argument_Associations (Orig))));\n                   end if;\n                end;\n \n@@ -7877,7 +7877,10 @@ package body Sem_Res is\n                   then\n                      null;\n                   else\n-                     Error_Msg_N (\"?check would fail at run-time\", Orig);\n+                     Error_Msg_N\n+                       (\"?check would fail at run-time!\",\n+                        Expression\n+                          (Last (Pragma_Argument_Associations (Orig))));\n                   end if;\n                end;\n             end if;"}, {"sha": "841f5dd61cb5636914db8f284296a2ae24691bc8", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 83, "deletions": 18, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -234,10 +234,11 @@ package body Sem_Warn is\n    --  within the body of the loop.\n \n    procedure Check_Infinite_Loop_Warning (Loop_Statement : Node_Id) is\n-      Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n+      Expression : Node_Id := Empty;\n+      --  Set to WHILE or EXIT WHEN condition to be tested\n \n       Ref : Node_Id := Empty;\n-      --  Reference in iteration scheme to variable that might not be modified\n+      --  Reference in Expression to variable that might not be modified\n       --  in loop, indicating a possible infinite loop.\n \n       Var : Entity_Id := Empty;\n@@ -267,9 +268,9 @@ package body Sem_Warn is\n \n       function Test_Ref (N : Node_Id) return Traverse_Result;\n       --  Test for reference to variable in question. Returns Abandon if\n-      --  matching reference found.\n+      --  matching reference found. Used in instantiation of No_Ref_Found.\n \n-      function Find_Ref is new Traverse_Func (Test_Ref);\n+      function No_Ref_Found is new Traverse_Func (Test_Ref);\n       --  Function to traverse body of procedure. Returns Abandon if matching\n       --  reference found.\n \n@@ -465,9 +466,9 @@ package body Sem_Warn is\n \n       function Test_Ref (N : Node_Id) return Traverse_Result is\n       begin\n-         --  Waste of time to look at iteration scheme\n+         --  Waste of time to look at the expression we are testing\n \n-         if N = Iter then\n+         if N = Expression then\n             return Skip;\n \n          --  Direct reference to variable in question\n@@ -547,20 +548,86 @@ package body Sem_Warn is\n    --  Start of processing for Check_Infinite_Loop_Warning\n \n    begin\n-      --  We need a while iteration with no condition actions. Condition\n-      --  actions just make things too complicated to get the warning right.\n+      --  Skip processing if debug flag gnatd.w is set\n \n-      if No (Iter)\n-        or else No (Condition (Iter))\n-        or else Present (Condition_Actions (Iter))\n-        or else Debug_Flag_Dot_W\n-      then\n+      if Debug_Flag_Dot_W then\n+         return;\n+      end if;\n+\n+      --  Case of WHILE loop\n+\n+      declare\n+         Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n+\n+      begin\n+         if Present (Iter) and then Present (Condition (Iter)) then\n+\n+            --  Skip processing for while iteration with conditions actions,\n+            --  since they make it too complicated to get the warning right.\n+\n+            if Present (Condition_Actions (Iter)) then\n+               return;\n+            end if;\n+\n+            --  Capture WHILE condition\n+\n+            Expression := Condition (Iter);\n+         end if;\n+      end;\n+\n+      --  Check chain of EXIT statements, we only process loops that have a\n+      --  single exit condition (either a single EXIT WHEN statement, or a\n+      --  WHILE loop not containing any EXIT WHEN statements).\n+\n+      declare\n+         Ident     : constant Node_Id := Identifier (Loop_Statement);\n+         Exit_Stmt : Node_Id;\n+\n+      begin\n+         --  If we don't have a proper chain set, ignore call entirely. This\n+         --  happens because of previous errors.\n+\n+         if No (Entity (Ident))\n+           or else Ekind (Entity (Ident)) /= E_Loop\n+         then\n+            return;\n+         end if;\n+\n+         --  Otherwise prepare to scan list of EXIT statements\n+\n+         Exit_Stmt := First_Exit_Statement (Entity (Ident));\n+         while Present (Exit_Stmt) loop\n+\n+            --  Check for EXIT WHEN\n+\n+            if Present (Condition (Exit_Stmt)) then\n+\n+               --  Quit processing if EXIT WHEN in WHILE loop, or more than\n+               --  one EXIT WHEN statement present in the loop.\n+\n+               if Present (Expression) then\n+                  return;\n+\n+               --  Otherwise capture condition from EXIT WHEN statement\n+\n+               else\n+                  Expression := Condition (Exit_Stmt);\n+               end if;\n+            end if;\n+\n+            Exit_Stmt := Next_Exit_Statement (Exit_Stmt);\n+         end loop;\n+      end;\n+\n+      --  Return if no condition to test\n+\n+      if No (Expression) then\n          return;\n       end if;\n \n       --  Initial conditions met, see if condition is of right form\n \n-      Find_Var (Condition (Iter));\n+      Find_Var (Expression);\n \n       --  Nothing to do if local variable from source not found. If it's a\n       --  renaming, it is probably renaming something too complicated to deal\n@@ -608,7 +675,7 @@ package body Sem_Warn is\n       --  We have a variable reference of the right form, now we scan the loop\n       --  body to see if it looks like it might not be modified\n \n-      if Find_Ref (Loop_Statement) = OK then\n+      if No_Ref_Found (Loop_Statement) = OK then\n          Error_Msg_NE\n            (\"?variable& is not modified in loop body!\", Ref, Var);\n          Error_Msg_N\n@@ -3432,9 +3499,7 @@ package body Sem_Warn is\n             Sloc_Range (Orig, Start, Dummy);\n             Atrue := Test_Result;\n \n-            if Present (Parent (C))\n-              and then Nkind (Parent (C)) = N_Op_Not\n-            then\n+            if Present (Parent (C)) and then Nkind (Parent (C)) = N_Op_Not then\n                Atrue := not Atrue;\n             end if;\n "}, {"sha": "e74e144fc5b2269cbd6a5e207420c8351aef5cf0", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -170,7 +170,8 @@ package Sem_Warn is\n \n    procedure Check_Infinite_Loop_Warning (Loop_Statement : Node_Id);\n    --  N is the node for a loop statement. This procedure checks if a warning\n-   --  should be given for a possible infinite loop, and if so issues it.\n+   --  for a possible infinite loop should be given for a suspicious WHILE or\n+   --  EXIT WHEN condition.\n \n    procedure Check_Low_Bound_Tested (Expr : Node_Id);\n    --  Expr is the node for a comparison operation. This procedure checks if"}, {"sha": "57f8f93965d3fe23d251e418fcc81e360e65d3c3", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -2021,6 +2021,14 @@ package body Sinfo is\n       return Node2 (N);\n    end Next_Entity;\n \n+   function Next_Exit_Statement\n+     (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Exit_Statement);\n+      return Node3 (N);\n+   end Next_Exit_Statement;\n+\n    function Next_Implicit_With\n      (N : Node_Id) return Node_Id is\n    begin\n@@ -4907,6 +4915,14 @@ package body Sinfo is\n       Set_Node2 (N, Val); -- semantic field, no parent set\n    end Set_Next_Entity;\n \n+   procedure Set_Next_Exit_Statement\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Exit_Statement);\n+      Set_Node3 (N, Val); -- semantic field, no parent set\n+   end Set_Next_Exit_Statement;\n+\n    procedure Set_Next_Implicit_With\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "31f555b4050b44155bb822631d059e1fb833a1bf", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -1395,6 +1395,12 @@ package Sinfo is\n    --    scope are chained, and this field is used as the forward pointer for\n    --    this list. See Einfo for further details.\n \n+   --  Next_Exit_Statement (Node3-Sem)\n+   --    Present in N_Exit_Statement nodes. The exit statements for a loop are\n+   --    chained (in reverse order of appearence) from the First_Exit_Statement\n+   --    field of the E_Loop entity for the loop. Next_Exit_Statement points to\n+   --    the next entry on this chain (Empty = end of list).\n+\n    --  Next_Implicit_With (Node3-Sem)\n    --    Present in N_With_Clause. Part of a chain of with_clauses generated\n    --    in rtsfind to indicate implicit dependencies on predefined units. Used\n@@ -1980,7 +1986,7 @@ package Sinfo is\n       --  which are explicitly documented.\n \n       --  N_Pragma\n-      --  Sloc points to pragma identifier\n+      --  Sloc points to PRAGMA\n       --  Next_Pragma (Node1-Sem)\n       --  Pragma_Argument_Associations (List2) (set to No_List if none)\n       --  Debug_Statement (Node3) (set to Empty if not Debug, Assert)\n@@ -4040,6 +4046,13 @@ package Sinfo is\n       --  Is_Null_Loop (Flag16)\n       --  Suppress_Loop_Warnings (Flag17)\n \n+      --  Note: the parser fills in the Identifier field if there is an\n+      --  explicit loop identifier. Otherwise the parser leaves this field\n+      --  set to Empty, and then the semantic processing for a loop statement\n+      --  creates an identifier, setting the Has_Created_Identifier flag to\n+      --  True. So after semantic anlaysis, the Identifier is always set,\n+      --  referencing an identifier whose entity has an Ekind of E_Loop.\n+\n       --------------------------\n       -- 5.5 Iteration Scheme --\n       --------------------------\n@@ -4128,7 +4141,8 @@ package Sinfo is\n       --  N_Exit_Statement\n       --  Sloc points to EXIT\n       --  Name (Node2) (set to Empty if no loop name present)\n-      --  Condition (Node1) (set to Empty if no when part present)\n+      --  Condition (Node1) (set to Empty if no WHEN part present)\n+      --  Next_Exit_Statement (Node3-Sem): Next exit on chain\n \n       -------------------------\n       -- 5.9  Goto Statement --\n@@ -8247,6 +8261,9 @@ package Sinfo is\n    function Next_Entity\n      (N : Node_Id) return Node_Id;    -- Node2\n \n+   function Next_Exit_Statement\n+     (N : Node_Id) return Node_Id;    -- Node3\n+\n    function Next_Implicit_With\n      (N : Node_Id) return Node_Id;    -- Node3\n \n@@ -9168,6 +9185,9 @@ package Sinfo is\n    procedure Set_Next_Entity\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n+   procedure Set_Next_Exit_Statement\n+     (N : Node_Id; Val : Node_Id);            -- Node3\n+\n    procedure Set_Next_Implicit_With\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n@@ -11360,6 +11380,7 @@ package Sinfo is\n    pragma Inline (Name);\n    pragma Inline (Names);\n    pragma Inline (Next_Entity);\n+   pragma Inline (Next_Exit_Statement);\n    pragma Inline (Next_Implicit_With);\n    pragma Inline (Next_Named_Actual);\n    pragma Inline (Next_Pragma);\n@@ -11664,6 +11685,7 @@ package Sinfo is\n    pragma Inline (Set_Name);\n    pragma Inline (Set_Names);\n    pragma Inline (Set_Next_Entity);\n+   pragma Inline (Set_Next_Exit_Statement);\n    pragma Inline (Set_Next_Implicit_With);\n    pragma Inline (Set_Next_Named_Actual);\n    pragma Inline (Set_Next_Pragma);"}, {"sha": "9e2b3c43f85c74fb21ac9b4119597052b1ffa70d", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf9bdffff02529ce6331fda689e0d2fde3100f/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=51bf9bdffff02529ce6331fda689e0d2fde3100f", "patch": "@@ -397,47 +397,46 @@ begin\n \n    Write_Switch_Char (\"wxx\");\n    Write_Line (\"Enable selected warning modes, xx = list of parameters:\");\n-   Write_Line (\"        a    turn on all optional info/warnings \" &\n-                                                  \"(except dhl.ot.w)\");\n+   Write_Line (\"        a    turn on all info/warnings marked below with +\");\n    Write_Line (\"        A    turn off all optional info/warnings\");\n-   Write_Line (\"        .a*  turn on warnings for failing assertion\");\n+   Write_Line (\"        .a*+ turn on warnings for failing assertion\");\n    Write_Line (\"        .A   turn off warnings for failing assertion\");\n-   Write_Line (\"        b    turn on warnings for bad fixed value \" &\n+   Write_Line (\"        b+   turn on warnings for bad fixed value \" &\n                                                   \"(not multiple of small)\");\n    Write_Line (\"        B*   turn off warnings for bad fixed value \" &\n                                                   \"(not multiple of small)\");\n-   Write_Line (\"        .b*  turn on warnings for biased representation\");\n+   Write_Line (\"        .b*+ turn on warnings for biased representation\");\n    Write_Line (\"        .B   turn off warnings for biased representation\");\n-   Write_Line (\"        c    turn on warnings for constant conditional\");\n+   Write_Line (\"        c+   turn on warnings for constant conditional\");\n    Write_Line (\"        C*   turn off warnings for constant conditional\");\n-   Write_Line (\"        .c   turn on warnings for unrepped components\");\n+   Write_Line (\"        .c+  turn on warnings for unrepped components\");\n    Write_Line (\"        .C*  turn off warnings for unrepped components\");\n    Write_Line (\"        d    turn on warnings for implicit dereference\");\n    Write_Line (\"        D*   turn off warnings for implicit dereference\");\n    Write_Line (\"        e    treat all warnings (but not info) as errors\");\n    Write_Line (\"        .e   turn on every optional info/warning \" &\n                                                   \"(no exceptions)\");\n-   Write_Line (\"        f    turn on warnings for unreferenced formal\");\n+   Write_Line (\"        f+   turn on warnings for unreferenced formal\");\n    Write_Line (\"        F*   turn off warnings for unreferenced formal\");\n-   Write_Line (\"        g*   turn on warnings for unrecognized pragma\");\n+   Write_Line (\"        g*+  turn on warnings for unrecognized pragma\");\n    Write_Line (\"        G    turn off warnings for unrecognized pragma\");\n    Write_Line (\"        h    turn on warnings for hiding variable\");\n    Write_Line (\"        H*   turn off warnings for hiding variable\");\n-   Write_Line (\"        i*   turn on warnings for implementation unit\");\n+   Write_Line (\"        i*+  turn on warnings for implementation unit\");\n    Write_Line (\"        I    turn off warnings for implementation unit\");\n    Write_Line (\"        .i   turn on warnings for overlapping actuals\");\n    Write_Line (\"        .I*  turn off warnings for overlapping actuals\");\n-   Write_Line (\"        j    turn on warnings for obsolescent \" &\n+   Write_Line (\"        j+   turn on warnings for obsolescent \" &\n                                                   \"(annex J) feature\");\n    Write_Line (\"        J*   turn off warnings for obsolescent \" &\n                                                   \"(annex J) feature\");\n-   Write_Line (\"        k    turn on warnings on constant variable\");\n+   Write_Line (\"        k+   turn on warnings on constant variable\");\n    Write_Line (\"        K*   turn off warnings on constant variable\");\n    Write_Line (\"        l    turn on warnings for missing \" &\n                                                   \"elaboration pragma\");\n    Write_Line (\"        L*   turn off warnings for missing \" &\n                                                   \"elaboration pragma\");\n-   Write_Line (\"        m    turn on warnings for variable assigned \" &\n+   Write_Line (\"        m+   turn on warnings for variable assigned \" &\n                                                   \"but not read\");\n    Write_Line (\"        M*   turn off warnings for variable assigned \" &\n                                                   \"but not read\");\n@@ -450,47 +449,48 @@ begin\n                                                   \"but not read\");\n    Write_Line (\"        .O*  turn off warnings for out parameters assigned \" &\n                                                   \"but not read\");\n-   Write_Line (\"        p    turn on warnings for ineffective pragma \" &\n+   Write_Line (\"        p+   turn on warnings for ineffective pragma \" &\n                                                   \"Inline in frontend\");\n    Write_Line (\"        P*   turn off warnings for ineffective pragma \" &\n                                                   \"Inline in frontend\");\n-   Write_Line (\"        .p   turn on warnings for suspicious parameter \" &\n+   Write_Line (\"        .p+  turn on warnings for suspicious parameter \" &\n                                                   \"order\");\n    Write_Line (\"        .P*  turn off warnings for suspicious parameter \" &\n                                                   \"order\");\n-   Write_Line (\"        q*   turn on warnings for questionable \" &\n+   Write_Line (\"        q*+  turn on warnings for questionable \" &\n                                                   \"missing parenthesis\");\n    Write_Line (\"        Q    turn off warnings for questionable \" &\n                                                   \"missing parenthesis\");\n-   Write_Line (\"        r    turn on warnings for redundant construct\");\n+   Write_Line (\"        r+   turn on warnings for redundant construct\");\n    Write_Line (\"        R*   turn off warnings for redundant construct\");\n-   Write_Line (\"        .r   turn on warnings for object renaming function\");\n+   Write_Line (\"        .r+  turn on warnings for object renaming function\");\n    Write_Line (\"        .R*  turn off warnings for object renaming function\");\n    Write_Line (\"        s    suppress all info/warnings\");\n    Write_Line (\"        t    turn on warnings for tracking deleted code\");\n    Write_Line (\"        T*   turn off warnings for tracking deleted code\");\n-   Write_Line (\"        u    turn on warnings for unused entity\");\n+   Write_Line (\"        u+   turn on warnings for unused entity\");\n    Write_Line (\"        U*   turn off warnings for unused entity\");\n-   Write_Line (\"        v*   turn on warnings for unassigned variable\");\n+   Write_Line (\"        v*+  turn on warnings for unassigned variable\");\n    Write_Line (\"        V    turn off warnings for unassigned variable\");\n-   Write_Line (\"        .v*  turn on info messages for reverse bit order\");\n+   Write_Line (\"        .v*+ turn on info messages for reverse bit order\");\n    Write_Line (\"        .V   turn off info messages for reverse bit order\");\n-   Write_Line (\"        w*   turn on warnings for wrong low bound assumption\");\n+   Write_Line (\"        w*+  turn on warnings for wrong low bound assumption\");\n    Write_Line (\"        W    turn off warnings for wrong low bound \" &\n                                                   \"assumption\");\n    Write_Line (\"        .w   turn on warnings on pragma Warnings Off\");\n    Write_Line (\"        .W*  turn off warnings on pragma Warnings Off\");\n-   Write_Line (\"        x*   turn on warnings for export/import\");\n+   Write_Line (\"        x*+  turn on warnings for export/import\");\n    Write_Line (\"        X    turn off warnings for export/import\");\n-   Write_Line (\"        .x   turn on warnings for non-local exception\");\n+   Write_Line (\"        .x+  turn on warnings for non-local exception\");\n    Write_Line (\"        .X*  turn off warnings for non-local exception\");\n-   Write_Line (\"        y*   turn on warnings for Ada 2005 incompatibility\");\n+   Write_Line (\"        y*+  turn on warnings for Ada 2005 incompatibility\");\n    Write_Line (\"        Y    turn off warnings for Ada 2005 incompatibility\");\n-   Write_Line (\"        z*   turn on warnings for suspicious \" &\n+   Write_Line (\"        z*+  turn on warnings for suspicious \" &\n                                                   \"unchecked conversion\");\n    Write_Line (\"        Z    turn off warnings for suspicious \" &\n                                                   \"unchecked conversion\");\n    Write_Line (\"        *    indicates default in above list\");\n+   Write_Line (\"        +    indicates warning flag included in -gnatwa\");\n \n    --  Line for -gnatW switch\n "}]}