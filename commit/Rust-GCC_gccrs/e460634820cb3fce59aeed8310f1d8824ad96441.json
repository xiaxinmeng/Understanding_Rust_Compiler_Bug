{"sha": "e460634820cb3fce59aeed8310f1d8824ad96441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ2MDYzNDgyMGNiM2ZjZTU5YWVlZDgzMTBmMWQ4ODI0YWQ5NjQ0MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-11-14T18:42:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-11-14T18:42:13Z"}, "message": "omp-low.c (lower_omp_ordered): Add argument to GOMP_SMD_ORDERED_* internal calls - 0 if...\n\ngcc/\n2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-low.c (lower_omp_ordered): Add argument to GOMP_SMD_ORDERED_*\n\tinternal calls - 0 if ordered simd and 1 for ordered threads simd.\n\t* tree-vectorizer.c (adjust_simduid_builtins): If GOMP_SIMD_ORDERED_*\n\targument is 1, replace it with GOMP_ordered_* call instead of removing\n\tit.\ngcc/c/\n2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* c-typeck.c (c_finish_omp_clauses): Don't mark\n\tGOMP_MAP_FIRSTPRIVATE_POINTER decls addressable.\ngcc/cp/\n2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* semantics.c (finish_omp_clauses): Don't mark\n\tGOMP_MAP_FIRSTPRIVATE_POINTER decls addressable.\nlibgomp/\n2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* ordered.c (gomp_doacross_init, GOMP_doacross_post,\n\tGOMP_doacross_wait, gomp_doacross_ull_init, GOMP_doacross_ull_post,\n\tGOMP_doacross_ull_wait): For GFS_GUIDED don't divide number of\n\titerators or IV by chunk size.\n\t* parallel.c (gomp_resolve_num_threads): Don't assume that\n\tif thr->ts.team is non-NULL, then pool must be non-NULL.\n\t* libgomp-plugin.h (GOMP_PLUGIN_target_task_completion): Declare.\n\t* libgomp.map (GOMP_PLUGIN_1.1): New symbol version, export\n\tGOMP_PLUGIN_target_task_completion.\n\t* Makefile.am (libgomp_la_SOURCES): Add priority_queue.c.\n\t* Makefile.in: Regenerate.\n\t* libgomp.h: Shuffle prototypes and forward definitions around so\n\tpriority queues can be defined.\n\t(enum gomp_task_kind): Add GOMP_TASK_ASYNC_RUNNING.\n\t(enum gomp_target_task_state): New enum.\n\t(struct gomp_target_task): Add state, tgt, task and team fields.\n\t(gomp_create_target_task): Change return type to bool, add\n\tstate argument.\n\t(gomp_target_task_fn): Change return type to bool.\n\t(struct gomp_device_descr): Add async_run_func.\n\t(struct gomp_task): Remove children, next_child, prev_child,\n\tnext_queue, prev_queue, next_taskgroup, prev_taskgroup.\n\tAdd pnode field.\n\t(struct gomp_taskgroup): Remove children.\n\tAdd taskgroup_queue.\n\t(struct gomp_team): Change task_queue type to a priority queue.\n\t(splay_compare): Define inline.\n\t(priority_queue_offset): New.\n\t(priority_node_to_task): New.\n\t(task_to_priority_node): New.\n\t* oacc-mem.c: Do not include splay-tree.h.\n\t* priority_queue.c: New file.\n\t* priority_queue.h: New file.\n\t* splay-tree.c: Do not include splay-tree.h.\n\t(splay_tree_foreach_internal): New.\n\t(splay_tree_foreach): New.\n\t* splay-tree.h: Become re-entrant if splay_tree_prefix is defined.\n\t(splay_tree_callback): Define typedef.\n\t* target.c (splay_compare): Move to libgomp.h.\n\t(GOMP_target): Don't adjust *thr in any way around running offloaded\n\ttask.\n\t(GOMP_target_ext): Likewise.  Handle target nowait.\n\t(GOMP_target_update_ext, GOMP_target_enter_exit_data): Check\n\treturn value from gomp_create_target_task, if false, fallthrough\n\tas if no dependencies exist.\n\t(gomp_target_task_fn): Change return type to bool, return true\n\tif the task should have another part scheduled later.  Handle\n\ttarget nowait.\n\t(gomp_load_plugin_for_device): Initialize async_run.\n\t* task.c (gomp_init_task): Initialize children_queue.\n\t(gomp_clear_parent_in_list): New.\n\t(gomp_clear_parent_in_tree): New.\n\t(gomp_clear_parent): Handle priorities.\n\t(GOMP_task): Likewise.\n\t(priority_queue_move_task_first,\n\tgomp_target_task_completion, GOMP_PLUGIN_target_task_completion):\n\tNew functions.\n\t(gomp_create_target_task): Use priority queues.  Change return type\n\tto bool, add state argument, return false if for async\n\t{{enter,exit} data,update} constructs no dependencies need to be\n\twaited for, handle target nowait.  Set task->fn to NULL instead of\n\tgomp_target_task_fn.\n\t(verify_children_queue): Remove.\n\t(priority_list_upgrade_task): New.\n\t(priority_queue_upgrade_task): New.\n\t(verify_task_queue): Remove.\n\t(priority_list_downgrade_task): New.\n\t(priority_queue_downgrade_task): New.\n\t(gomp_task_run_pre): Use priority queues.\n\tAbstract code out to priority_queue_downgrade_task.\n\t(gomp_task_run_post_handle_dependers): Use priority queues.\n\t(gomp_task_run_post_remove_parent): Likewise.\n\t(gomp_task_run_post_remove_taskgroup): Likewise.\n\t(gomp_barrier_handle_tasks): Likewise.  Handle target nowait target\n\ttasks specially.\n\t(GOMP_taskwait): Likewise.\n\t(gomp_task_maybe_wait_for_dependencies): Likewise.  Abstract code to\n\tpriority-queue_upgrade_task.\n\t(GOMP_taskgroup_start): Use priority queues.\n\t(GOMP_taskgroup_end): Likewise.  Handle target nowait target tasks\n\tspecially.  If taskgroup is NULL, and thr->ts.level is 0, act as a\n\tbarrier.\n\t* taskloop.c (GOMP_taskloop): Handle priorities.\n\t* team.c (gomp_new_team): Call priority_queue_init.\n\t(free_team): Call priority_queue_free.\n\t(gomp_free_thread): Call gomp_team_end if thr->ts.team is artificial\n\tteam created for target nowait in implicit parallel region.\n\t(gomp_team_start): For nested check, test thr->ts.level instead of\n\tthr->ts.team != NULL.\n\t* testsuite/libgomp.c/doacross-3.c: New test.\n\t* testsuite/libgomp.c/ordered-5.c: New test.\n\t* testsuite/libgomp.c/priority.c: New test.\n\t* testsuite/libgomp.c/target-31.c: New test.\n\t* testsuite/libgomp.c/target-32.c: New test.\n\t* testsuite/libgomp.c/target-33.c: New test.\n\t* testsuite/libgomp.c/target-34.c: New test.\nliboffloadmic/\n2015-11-14  Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* runtime/offload_host.cpp (task_completion_callback): New\n\tvariable.\n\t(offload_proxy_task_completed_ooo): Call task_completion_callback.\n\t(__offload_register_task_callback): New function.\n\t* runtime/offload_host.h (__offload_register_task_callback): New\n\tdeclaration.\n\t* plugin/libgomp-plugin-intelmic.cpp (offload): Add async_data\n\targument, handle async offloading.\n\t(register_main_image): Call register_main_image.\n\t(GOMP_OFFLOAD_init_device, get_target_table, GOMP_OFFLOAD_alloc,\n\tGOMP_OFFLOAD_free, GOMP_OFFLOAD_host2dev, GOMP_OFFLOAD_dev2host,\n\tGOMP_OFFLOAD_dev2dev) Adjust offload callers.\n\t(GOMP_OFFLOAD_async_run): New function.\n\t(GOMP_OFFLOAD_run): Implement using GOMP_OFFLOAD_async_run.\n\nFrom-SVN: r230381", "tree": {"sha": "560f8f0eb6abb39ff71e1aef13322010ebc8e000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/560f8f0eb6abb39ff71e1aef13322010ebc8e000"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e460634820cb3fce59aeed8310f1d8824ad96441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e460634820cb3fce59aeed8310f1d8824ad96441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e460634820cb3fce59aeed8310f1d8824ad96441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e460634820cb3fce59aeed8310f1d8824ad96441/comments", "author": null, "committer": null, "parents": [{"sha": "67f0527a22878ddf4be811390d5550d8e9f03d32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f0527a22878ddf4be811390d5550d8e9f03d32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f0527a22878ddf4be811390d5550d8e9f03d32"}], "stats": {"total": 3610, "additions": 2888, "deletions": 722}, "files": [{"sha": "69a3044dfa38b604a37855788a2ee309a4e4b48b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -1,3 +1,11 @@\n+2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_omp_ordered): Add argument to GOMP_SMD_ORDERED_*\n+\tinternal calls - 0 if ordered simd and 1 for ordered threads simd.\n+\t* tree-vectorizer.c (adjust_simduid_builtins): If GOMP_SIMD_ORDERED_*\n+\targument is 1, replace it with GOMP_ordered_* call instead of removing\n+\tit.\n+\n 2015-11-13  Rich Felker <dalias@libc.org>\n \n \t* config/sh/sh.md (symGOT_load): Suppress __stack_chk_guard"}, {"sha": "5be190fec6b7192d51e78f93703ed5ea2afa44fc", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -1,3 +1,8 @@\n+2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.c (c_finish_omp_clauses): Don't mark\n+\tGOMP_MAP_FIRSTPRIVATE_POINTER decls addressable.\n+\n 2015-11-14  Marek Polacek  <polacek@redhat.com>\n \n \t* c-decl.c: Use RECORD_OR_UNION_TYPE_P throughout."}, {"sha": "c18c3076752145d12841782b38c5ec7378faa478", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -12918,7 +12918,10 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (!c_mark_addressable (t))\n+\t  else if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n+\t\t    || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t!= GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\t\t   && !c_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t     && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER"}, {"sha": "baaabc8761f77c626aa11dda15ce8977cc17afd1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -1,3 +1,8 @@\n+2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* semantics.c (finish_omp_clauses): Don't mark\n+\tGOMP_MAP_FIRSTPRIVATE_POINTER decls addressable.\n+\n 2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n \t    Marek Polacek  <polacek@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>"}, {"sha": "e7e5d8ecfaa263aa0c3d8ea7d924dec7c351c844", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -6581,6 +6581,9 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  else if (!processing_template_decl\n \t\t   && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t   && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n+\t\t       || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t   != GOMP_MAP_FIRSTPRIVATE_POINTER))\n \t\t   && !cxx_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP"}, {"sha": "987bc3ea60243c5471d0ed8bdf78bba2a3257133", "filename": "gcc/omp-low.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -13951,8 +13951,10 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gomp_ordered *ord_stmt = as_a <gomp_ordered *> (stmt);\n   gcall *x;\n   gbind *bind;\n-  bool simd\n-    = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt), OMP_CLAUSE_SIMD);\n+  bool simd = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n+\t\t\t       OMP_CLAUSE_SIMD);\n+  bool threads = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n+\t\t\t\t  OMP_CLAUSE_THREADS);\n \n   if (find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n \t\t       OMP_CLAUSE_DEPEND))\n@@ -13975,7 +13977,8 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   if (simd)\n     {\n-      x = gimple_build_call_internal (IFN_GOMP_SIMD_ORDERED_START, 0);\n+      x = gimple_build_call_internal (IFN_GOMP_SIMD_ORDERED_START, 1,\n+\t\t\t\t      build_int_cst (NULL_TREE, threads));\n       cfun->has_simduid_loops = true;\n     }\n   else\n@@ -13989,7 +13992,8 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_omp_set_body (stmt, NULL);\n \n   if (simd)\n-    x = gimple_build_call_internal (IFN_GOMP_SIMD_ORDERED_END, 0);\n+    x = gimple_build_call_internal (IFN_GOMP_SIMD_ORDERED_END, 1,\n+\t\t\t\t    build_int_cst (NULL_TREE, threads));\n   else\n     x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_END),\n \t\t\t   0);"}, {"sha": "b721c56d62acb4dc5f9ff285752c5d57cd3bb561", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -177,6 +177,21 @@ adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n \t      break;\n \t    case IFN_GOMP_SIMD_ORDERED_START:\n \t    case IFN_GOMP_SIMD_ORDERED_END:\n+\t      if (integer_onep (gimple_call_arg (stmt, 0)))\n+\t\t{\n+\t\t  enum built_in_function bcode\n+\t\t    = (ifn == IFN_GOMP_SIMD_ORDERED_START\n+\t\t       ? BUILT_IN_GOMP_ORDERED_START\n+\t\t       : BUILT_IN_GOMP_ORDERED_END);\n+\t\t  gimple *g\n+\t\t    = gimple_build_call (builtin_decl_explicit (bcode), 0);\n+\t\t  tree vdef = gimple_vdef (stmt);\n+\t\t  gimple_set_vdef (g, vdef);\n+\t\t  SSA_NAME_DEF_STMT (vdef) = g;\n+\t\t  gimple_set_vuse (g, gimple_vuse (stmt));\n+\t\t  gsi_replace (&i, g, true);\n+\t\t  continue;\n+\t\t}\n \t      gsi_remove (&i, true);\n \t      unlink_stmt_vdef (stmt);\n \t      continue;"}, {"sha": "15be0142a22549b80db643032de4c4f4659c5333", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -1,3 +1,104 @@\n+2015-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* ordered.c (gomp_doacross_init, GOMP_doacross_post,\n+\tGOMP_doacross_wait, gomp_doacross_ull_init, GOMP_doacross_ull_post,\n+\tGOMP_doacross_ull_wait): For GFS_GUIDED don't divide number of\n+\titerators or IV by chunk size.\n+\t* parallel.c (gomp_resolve_num_threads): Don't assume that\n+\tif thr->ts.team is non-NULL, then pool must be non-NULL.\n+\t* libgomp-plugin.h (GOMP_PLUGIN_target_task_completion): Declare.\n+\t* libgomp.map (GOMP_PLUGIN_1.1): New symbol version, export\n+\tGOMP_PLUGIN_target_task_completion.\n+\t* Makefile.am (libgomp_la_SOURCES): Add priority_queue.c.\n+\t* Makefile.in: Regenerate.\n+\t* libgomp.h: Shuffle prototypes and forward definitions around so\n+\tpriority queues can be defined.\n+\t(enum gomp_task_kind): Add GOMP_TASK_ASYNC_RUNNING.\n+\t(enum gomp_target_task_state): New enum.\n+\t(struct gomp_target_task): Add state, tgt, task and team fields.\n+\t(gomp_create_target_task): Change return type to bool, add\n+\tstate argument.\n+\t(gomp_target_task_fn): Change return type to bool.\n+\t(struct gomp_device_descr): Add async_run_func.\n+\t(struct gomp_task): Remove children, next_child, prev_child,\n+\tnext_queue, prev_queue, next_taskgroup, prev_taskgroup.\n+\tAdd pnode field.\n+\t(struct gomp_taskgroup): Remove children.\n+\tAdd taskgroup_queue.\n+\t(struct gomp_team): Change task_queue type to a priority queue.\n+\t(splay_compare): Define inline.\n+\t(priority_queue_offset): New.\n+\t(priority_node_to_task): New.\n+\t(task_to_priority_node): New.\n+\t* oacc-mem.c: Do not include splay-tree.h.\n+\t* priority_queue.c: New file.\n+\t* priority_queue.h: New file.\n+\t* splay-tree.c: Do not include splay-tree.h.\n+\t(splay_tree_foreach_internal): New.\n+\t(splay_tree_foreach): New.\n+\t* splay-tree.h: Become re-entrant if splay_tree_prefix is defined.\n+\t(splay_tree_callback): Define typedef.\n+\t* target.c (splay_compare): Move to libgomp.h.\n+\t(GOMP_target): Don't adjust *thr in any way around running offloaded\n+\ttask.\n+\t(GOMP_target_ext): Likewise.  Handle target nowait.\n+\t(GOMP_target_update_ext, GOMP_target_enter_exit_data): Check\n+\treturn value from gomp_create_target_task, if false, fallthrough\n+\tas if no dependencies exist.\n+\t(gomp_target_task_fn): Change return type to bool, return true\n+\tif the task should have another part scheduled later.  Handle\n+\ttarget nowait.\n+\t(gomp_load_plugin_for_device): Initialize async_run.\n+\t* task.c (gomp_init_task): Initialize children_queue.\n+\t(gomp_clear_parent_in_list): New.\n+\t(gomp_clear_parent_in_tree): New.\n+\t(gomp_clear_parent): Handle priorities.\n+\t(GOMP_task): Likewise.\n+\t(priority_queue_move_task_first,\n+\tgomp_target_task_completion, GOMP_PLUGIN_target_task_completion):\n+\tNew functions.\n+\t(gomp_create_target_task): Use priority queues.  Change return type\n+\tto bool, add state argument, return false if for async\n+\t{{enter,exit} data,update} constructs no dependencies need to be\n+\twaited for, handle target nowait.  Set task->fn to NULL instead of\n+\tgomp_target_task_fn.\n+\t(verify_children_queue): Remove.\n+\t(priority_list_upgrade_task): New.\n+\t(priority_queue_upgrade_task): New.\n+\t(verify_task_queue): Remove.\n+\t(priority_list_downgrade_task): New.\n+\t(priority_queue_downgrade_task): New.\n+\t(gomp_task_run_pre): Use priority queues.\n+\tAbstract code out to priority_queue_downgrade_task.\n+\t(gomp_task_run_post_handle_dependers): Use priority queues.\n+\t(gomp_task_run_post_remove_parent): Likewise.\n+\t(gomp_task_run_post_remove_taskgroup): Likewise.\n+\t(gomp_barrier_handle_tasks): Likewise.  Handle target nowait target\n+\ttasks specially.\n+\t(GOMP_taskwait): Likewise.\n+\t(gomp_task_maybe_wait_for_dependencies): Likewise.  Abstract code to\n+\tpriority-queue_upgrade_task.\n+\t(GOMP_taskgroup_start): Use priority queues.\n+\t(GOMP_taskgroup_end): Likewise.  Handle target nowait target tasks\n+\tspecially.  If taskgroup is NULL, and thr->ts.level is 0, act as a\n+\tbarrier.\n+\t* taskloop.c (GOMP_taskloop): Handle priorities.\n+\t* team.c (gomp_new_team): Call priority_queue_init.\n+\t(free_team): Call priority_queue_free.\n+\t(gomp_free_thread): Call gomp_team_end if thr->ts.team is artificial\n+\tteam created for target nowait in implicit parallel region.\n+\t(gomp_team_start): For nested check, test thr->ts.level instead of\n+\tthr->ts.team != NULL.\n+\t* testsuite/libgomp.c/doacross-3.c: New test.\n+\t* testsuite/libgomp.c/ordered-5.c: New test.\n+\t* testsuite/libgomp.c/priority.c: New test.\n+\t* testsuite/libgomp.c/target-31.c: New test.\n+\t* testsuite/libgomp.c/target-32.c: New test.\n+\t* testsuite/libgomp.c/target-33.c: New test.\n+\t* testsuite/libgomp.c/target-34.c: New test.\n+\n 2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c: New."}, {"sha": "a3e1c2b2c0f476bd0a0f4e76fa09be26f85a77a4", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -63,7 +63,7 @@ libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n \ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n \ttime.c fortran.c affinity.c target.c splay-tree.c libgomp-plugin.c \\\n \toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c oacc-async.c \\\n-\toacc-plugin.c oacc-cuda.c\n+\toacc-plugin.c oacc-cuda.c priority_queue.c\n \n include $(top_srcdir)/plugin/Makefrag.am\n "}, {"sha": "7a1c976c5c984cdd118f77e09ba349c714264b22", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -168,7 +168,7 @@ am_libgomp_la_OBJECTS = alloc.lo barrier.lo critical.lo env.lo \\\n \tfortran.lo affinity.lo target.lo splay-tree.lo \\\n \tlibgomp-plugin.lo oacc-parallel.lo oacc-host.lo oacc-init.lo \\\n \toacc-mem.lo oacc-async.lo oacc-plugin.lo oacc-cuda.lo \\\n-\t$(am__objects_1)\n+\tpriority_queue.lo $(am__objects_1)\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n@@ -415,7 +415,7 @@ libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n \tbar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n \tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c \\\n \toacc-init.c oacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c \\\n-\t$(am__append_2)\n+\tpriority_queue.c $(am__append_2)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -589,6 +589,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptrlock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@"}, {"sha": "ab22e85cf61c728bbcf5b6821e675d0e0e54fba5", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -63,6 +63,7 @@ struct addr_pair\n extern void *GOMP_PLUGIN_malloc (size_t) __attribute__ ((malloc));\n extern void *GOMP_PLUGIN_malloc_cleared (size_t) __attribute__ ((malloc));\n extern void *GOMP_PLUGIN_realloc (void *, size_t);\n+void GOMP_PLUGIN_target_task_completion (void *);\n \n extern void GOMP_PLUGIN_debug (int, const char *, ...)\n \t__attribute__ ((format (printf, 2, 3)));"}, {"sha": "c467f97788bd3d38f11bef6e4c41b32c9e2f75e5", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 150, "deletions": 71, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -50,6 +50,22 @@\n #include <stdlib.h>\n #include <stdarg.h>\n \n+/* Needed for memset in priority_queue.c.  */\n+#if _LIBGOMP_CHECKING_\n+# ifdef STRING_WITH_STRINGS\n+#  include <string.h>\n+#  include <strings.h>\n+# else\n+#  ifdef HAVE_STRING_H\n+#   include <string.h>\n+#  else\n+#   ifdef HAVE_STRINGS_H\n+#    include <strings.h>\n+#   endif\n+#  endif\n+# endif\n+#endif\n+\n #ifdef HAVE_ATTRIBUTE_VISIBILITY\n # pragma GCC visibility push(hidden)\n #endif\n@@ -65,6 +81,44 @@ enum memmodel\n   MEMMODEL_SEQ_CST = 5\n };\n \n+/* alloc.c */\n+\n+extern void *gomp_malloc (size_t) __attribute__((malloc));\n+extern void *gomp_malloc_cleared (size_t) __attribute__((malloc));\n+extern void *gomp_realloc (void *, size_t);\n+\n+/* Avoid conflicting prototypes of alloca() in system headers by using\n+   GCC's builtin alloca().  */\n+#define gomp_alloca(x)  __builtin_alloca(x)\n+\n+/* error.c */\n+\n+extern void gomp_vdebug (int, const char *, va_list);\n+extern void gomp_debug (int, const char *, ...)\n+\t__attribute__ ((format (printf, 2, 3)));\n+#define gomp_vdebug(KIND, FMT, VALIST) \\\n+  do { \\\n+    if (__builtin_expect (gomp_debug_var, 0)) \\\n+      (gomp_vdebug) ((KIND), (FMT), (VALIST)); \\\n+  } while (0)\n+#define gomp_debug(KIND, ...) \\\n+  do { \\\n+    if (__builtin_expect (gomp_debug_var, 0)) \\\n+      (gomp_debug) ((KIND), __VA_ARGS__); \\\n+  } while (0)\n+extern void gomp_verror (const char *, va_list);\n+extern void gomp_error (const char *, ...)\n+\t__attribute__ ((format (printf, 1, 2)));\n+extern void gomp_vfatal (const char *, va_list)\n+\t__attribute__ ((noreturn));\n+extern void gomp_fatal (const char *, ...)\n+\t__attribute__ ((noreturn, format (printf, 1, 2)));\n+\n+struct gomp_task;\n+struct gomp_taskgroup;\n+struct htab;\n+\n+#include \"priority_queue.h\"\n #include \"sem.h\"\n #include \"mutex.h\"\n #include \"bar.h\"\n@@ -298,6 +352,7 @@ extern gomp_mutex_t gomp_managed_threads_lock;\n #endif\n extern unsigned long gomp_max_active_levels_var;\n extern bool gomp_cancel_var;\n+extern int gomp_max_task_priority_var;\n extern unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n extern unsigned long gomp_available_cpus, gomp_managed_threads;\n extern unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n@@ -318,13 +373,14 @@ enum gomp_task_kind\n   /* Task created by GOMP_task and waiting to be run.  */\n   GOMP_TASK_WAITING,\n   /* Task currently executing or scheduled and about to execute.  */\n-  GOMP_TASK_TIED\n+  GOMP_TASK_TIED,\n+  /* Used for target tasks that have vars mapped and async run started,\n+     but not yet completed.  Once that completes, they will be readded\n+     into the queues as GOMP_TASK_WAITING in order to perform the var\n+     unmapping.  */\n+  GOMP_TASK_ASYNC_RUNNING\n };\n \n-struct gomp_task;\n-struct gomp_taskgroup;\n-struct htab;\n-\n struct gomp_task_depend_entry\n {\n   /* Address of dependency.  */\n@@ -352,35 +408,19 @@ struct gomp_taskwait\n {\n   bool in_taskwait;\n   bool in_depend_wait;\n+  /* Number of tasks we are waiting for.  */\n   size_t n_depend;\n-  struct gomp_task *last_parent_depends_on;\n   gomp_sem_t taskwait_sem;\n };\n \n /* This structure describes a \"task\" to be run by a thread.  */\n \n struct gomp_task\n {\n-  /* Parent circular list.  See children description below.  */\n+  /* Parent of this task.  */\n   struct gomp_task *parent;\n-  /* Circular list representing the children of this task.\n-\n-     In this list we first have parent_depends_on ready to run tasks,\n-     then !parent_depends_on ready to run tasks, and finally already\n-     running tasks.  */\n-  struct gomp_task *children;\n-  struct gomp_task *next_child;\n-  struct gomp_task *prev_child;\n-  /* Circular task_queue in `struct gomp_team'.\n-\n-     GOMP_TASK_WAITING tasks come before GOMP_TASK_TIED tasks.  */\n-  struct gomp_task *next_queue;\n-  struct gomp_task *prev_queue;\n-  /* Circular queue in gomp_taskgroup->children.\n-\n-     GOMP_TASK_WAITING tasks come before GOMP_TASK_TIED tasks.  */\n-  struct gomp_task *next_taskgroup;\n-  struct gomp_task *prev_taskgroup;\n+  /* Children of this task.  */\n+  struct priority_queue children_queue;\n   /* Taskgroup this task belongs in.  */\n   struct gomp_taskgroup *taskgroup;\n   /* Tasks that depend on this task.  */\n@@ -389,8 +429,19 @@ struct gomp_task\n   struct gomp_taskwait *taskwait;\n   /* Number of items in DEPEND.  */\n   size_t depend_count;\n-  /* Number of tasks in the DEPENDERS field above.  */\n+  /* Number of tasks this task depends on.  Once this counter reaches\n+     0, we have no unsatisfied dependencies, and this task can be put\n+     into the various queues to be scheduled.  */\n   size_t num_dependees;\n+\n+  /* Priority of this task.  */\n+  int priority;\n+  /* The priority node for this task in each of the different queues.\n+     We put this here to avoid allocating space for each priority\n+     node.  Then we play offsetof() games to convert between pnode[]\n+     entries and the gomp_task in which they reside.  */\n+  struct priority_node pnode[3];\n+\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n   void *fn_data;\n@@ -407,21 +458,32 @@ struct gomp_task\n   struct gomp_task_depend_entry depend[];\n };\n \n+/* This structure describes a single #pragma omp taskgroup.  */\n+\n struct gomp_taskgroup\n {\n   struct gomp_taskgroup *prev;\n-  /* Circular list of tasks that belong in this taskgroup.\n-\n-     Tasks are chained by next/prev_taskgroup within gomp_task, and\n-     are sorted by GOMP_TASK_WAITING tasks, and then GOMP_TASK_TIED\n-     tasks.  */\n-  struct gomp_task *children;\n+  /* Queue of tasks that belong in this taskgroup.  */\n+  struct priority_queue taskgroup_queue;\n   bool in_taskgroup_wait;\n   bool cancelled;\n   gomp_sem_t taskgroup_sem;\n   size_t num_children;\n };\n \n+/* Various state of OpenMP async offloading tasks.  */\n+enum gomp_target_task_state\n+{\n+  GOMP_TARGET_TASK_DATA,\n+  GOMP_TARGET_TASK_BEFORE_MAP,\n+  GOMP_TARGET_TASK_FALLBACK,\n+  GOMP_TARGET_TASK_READY_TO_RUN,\n+  GOMP_TARGET_TASK_RUNNING,\n+  GOMP_TARGET_TASK_FINISHED\n+};\n+\n+/* This structure describes a target task.  */\n+\n struct gomp_target_task\n {\n   struct gomp_device_descr *devicep;\n@@ -430,6 +492,10 @@ struct gomp_target_task\n   size_t *sizes;\n   unsigned short *kinds;\n   unsigned int flags;\n+  enum gomp_target_task_state state;\n+  struct target_mem_desc *tgt;\n+  struct gomp_task *task;\n+  struct gomp_team *team;\n   void *hostaddrs[];\n };\n \n@@ -495,9 +561,8 @@ struct gomp_team\n   struct gomp_work_share work_shares[8];\n \n   gomp_mutex_t task_lock;\n-  /* Scheduled tasks.  Chain fields are next/prev_queue within a\n-     gomp_task.  */\n-  struct gomp_task *task_queue;\n+  /* Scheduled tasks.  */\n+  struct priority_queue task_queue;\n   /* Number of all GOMP_TASK_{WAITING,TIED} tasks in the team.  */\n   unsigned int task_count;\n   /* Number of GOMP_TASK_WAITING tasks currently waiting to be scheduled.  */\n@@ -627,39 +692,6 @@ extern bool gomp_affinity_init_level (int, unsigned long, bool);\n extern void gomp_affinity_print_place (void *);\n extern void gomp_get_place_proc_ids_8 (int, int64_t *);\n \n-/* alloc.c */\n-\n-extern void *gomp_malloc (size_t) __attribute__((malloc));\n-extern void *gomp_malloc_cleared (size_t) __attribute__((malloc));\n-extern void *gomp_realloc (void *, size_t);\n-\n-/* Avoid conflicting prototypes of alloca() in system headers by using\n-   GCC's builtin alloca().  */\n-#define gomp_alloca(x)  __builtin_alloca(x)\n-\n-/* error.c */\n-\n-extern void gomp_vdebug (int, const char *, va_list);\n-extern void gomp_debug (int, const char *, ...)\n-\t__attribute__ ((format (printf, 2, 3)));\n-#define gomp_vdebug(KIND, FMT, VALIST) \\\n-  do { \\\n-    if (__builtin_expect (gomp_debug_var, 0)) \\\n-      (gomp_vdebug) ((KIND), (FMT), (VALIST)); \\\n-  } while (0)\n-#define gomp_debug(KIND, ...) \\\n-  do { \\\n-    if (__builtin_expect (gomp_debug_var, 0)) \\\n-      (gomp_debug) ((KIND), __VA_ARGS__); \\\n-  } while (0)\n-extern void gomp_verror (const char *, va_list);\n-extern void gomp_error (const char *, ...)\n-\t__attribute__ ((format (printf, 1, 2)));\n-extern void gomp_vfatal (const char *, va_list)\n-\t__attribute__ ((noreturn));\n-extern void gomp_fatal (const char *, ...)\n-\t__attribute__ ((noreturn, format (printf, 1, 2)));\n-\n /* iter.c */\n \n extern int gomp_iter_static_next (long *, long *);\n@@ -715,10 +747,10 @@ extern void gomp_init_task (struct gomp_task *, struct gomp_task *,\n extern void gomp_end_task (void);\n extern void gomp_barrier_handle_tasks (gomp_barrier_state_t);\n extern void gomp_task_maybe_wait_for_dependencies (void **);\n-extern void gomp_create_target_task (struct gomp_device_descr *,\n+extern bool gomp_create_target_task (struct gomp_device_descr *,\n \t\t\t\t     void (*) (void *), size_t, void **,\n \t\t\t\t     size_t *, unsigned short *, unsigned int,\n-\t\t\t\t     void **);\n+\t\t\t\t     void **, enum gomp_target_task_state);\n \n static void inline\n gomp_finish_task (struct gomp_task *task)\n@@ -739,8 +771,9 @@ extern void gomp_free_thread (void *);\n \n extern void gomp_init_targets_once (void);\n extern int gomp_get_num_devices (void);\n-extern void gomp_target_task_fn (void *);\n+extern bool gomp_target_task_fn (void *);\n \n+/* Splay tree definitions.  */\n typedef struct splay_tree_node_s *splay_tree_node;\n typedef struct splay_tree_s *splay_tree;\n typedef struct splay_tree_key_s *splay_tree_key;\n@@ -800,6 +833,21 @@ struct splay_tree_key_s {\n   uintptr_t async_refcount;\n };\n \n+/* The comparison function.  */\n+\n+static inline int\n+splay_compare (splay_tree_key x, splay_tree_key y)\n+{\n+  if (x->host_start == x->host_end\n+      && y->host_start == y->host_end)\n+    return 0;\n+  if (x->host_end <= y->host_start)\n+    return -1;\n+  if (x->host_start >= y->host_end)\n+    return 1;\n+  return 0;\n+}\n+\n #include \"splay-tree.h\"\n \n typedef struct acc_dispatch_t\n@@ -877,6 +925,7 @@ struct gomp_device_descr\n   void *(*host2dev_func) (int, void *, const void *, size_t);\n   void *(*dev2dev_func) (int, void *, const void *, size_t);\n   void (*run_func) (int, void *, void *);\n+  void (*async_run_func) (int, void *, void *, void *);\n \n   /* Splay tree containing information about mapped memory regions.  */\n   struct splay_tree_s mem_map;\n@@ -1016,4 +1065,34 @@ extern int gomp_test_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n # define ialias_call(fn) fn\n #endif\n \n+/* Helper function for priority_node_to_task() and\n+   task_to_priority_node().\n+\n+   Return the offset from a task to its priority_node entry.  The\n+   priority_node entry is has a type of TYPE.  */\n+\n+static inline size_t\n+priority_queue_offset (enum priority_queue_type type)\n+{\n+  return offsetof (struct gomp_task, pnode[(int) type]);\n+}\n+\n+/* Return the task associated with a priority NODE of type TYPE.  */\n+\n+static inline struct gomp_task *\n+priority_node_to_task (enum priority_queue_type type,\n+\t\t       struct priority_node *node)\n+{\n+  return (struct gomp_task *) ((char *) node - priority_queue_offset (type));\n+}\n+\n+/* Return the priority node of type TYPE for a given TASK.  */\n+\n+static inline struct priority_node *\n+task_to_priority_node (enum priority_queue_type type,\n+\t\t       struct gomp_task *task)\n+{\n+  return (struct priority_node *) ((char *) task\n+\t\t\t\t   + priority_queue_offset (type));\n+}\n #endif /* LIBGOMP_H */"}, {"sha": "4d42c42f4416a076f2746f3a9db5f180c853ae80", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -407,3 +407,8 @@ GOMP_PLUGIN_1.0 {\n \tGOMP_PLUGIN_async_unmap_vars;\n \tGOMP_PLUGIN_acc_thread;\n };\n+\n+GOMP_PLUGIN_1.1 {\n+  global:\n+\tGOMP_PLUGIN_target_task_completion;\n+} GOMP_PLUGIN_1.0;"}, {"sha": "2488480717a6fbb6582847ce9ec184ac4a77ab37", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -31,7 +31,6 @@\n #include \"libgomp.h\"\n #include \"gomp-constants.h\"\n #include \"oacc-int.h\"\n-#include \"splay-tree.h\"\n #include <stdint.h>\n #include <assert.h>\n "}, {"sha": "52df385e427d2739962d78d68a5980f9a2fe98de", "filename": "libgomp/ordered.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fordered.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -297,6 +297,8 @@ gomp_doacross_init (unsigned ncounts, long *counts, long chunk_size)\n \n   if (ws->sched == GFS_STATIC)\n     num_ents = team->nthreads;\n+  else if (ws->sched == GFS_GUIDED)\n+    num_ents = counts[0];\n   else\n     num_ents = (counts[0] - 1) / chunk_size + 1;\n   if (num_bits <= MAX_COLLAPSED_BITS)\n@@ -366,6 +368,8 @@ GOMP_doacross_post (long *counts)\n \n   if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n     ent = thr->ts.team_id;\n+  else if (ws->sched == GFS_GUIDED)\n+    ent = counts[0];\n   else\n     ent = counts[0] / doacross->chunk_size;\n   unsigned long *array = (unsigned long *) (doacross->array\n@@ -426,6 +430,8 @@ GOMP_doacross_wait (long first, ...)\n       else\n \tent = first / ws->chunk_size % thr->ts.team->nthreads;\n     }\n+  else if (ws->sched == GFS_GUIDED)\n+    ent = first;\n   else\n     ent = first / doacross->chunk_size;\n   unsigned long *array = (unsigned long *) (doacross->array\n@@ -520,6 +526,8 @@ gomp_doacross_ull_init (unsigned ncounts, gomp_ull *counts, gomp_ull chunk_size)\n \n   if (ws->sched == GFS_STATIC)\n     num_ents = team->nthreads;\n+  else if (ws->sched == GFS_GUIDED)\n+    num_ents = counts[0];\n   else\n     num_ents = (counts[0] - 1) / chunk_size + 1;\n   if (num_bits <= MAX_COLLAPSED_BITS)\n@@ -595,6 +603,8 @@ GOMP_doacross_ull_post (gomp_ull *counts)\n \n   if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n     ent = thr->ts.team_id;\n+  else if (ws->sched == GFS_GUIDED)\n+    ent = counts[0];\n   else\n     ent = counts[0] / doacross->chunk_size_ull;\n \n@@ -676,6 +686,8 @@ GOMP_doacross_ull_wait (gomp_ull first, ...)\n       else\n \tent = first / ws->chunk_size_ull % thr->ts.team->nthreads;\n     }\n+  else if (ws->sched == GFS_GUIDED)\n+    ent = first;\n   else\n     ent = first / doacross->chunk_size_ull;\n "}, {"sha": "228086f40a2aa65c0b780cda4477aa16b78a378e", "filename": "libgomp/parallel.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -85,7 +85,7 @@ gomp_resolve_num_threads (unsigned specified, unsigned count)\n      nested parallel, so there is just one thread in the\n      contention group as well, no need to handle it atomically.  */\n   pool = thr->thread_pool;\n-  if (thr->ts.team == NULL)\n+  if (thr->ts.team == NULL || pool == NULL)\n     {\n       num_threads = max_num_threads;\n       if (num_threads > icv->thread_limit_var)"}, {"sha": "4bc5f9b126846ed77f40c51e1d822eba06445c30", "filename": "libgomp/priority_queue.c", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fpriority_queue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fpriority_queue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fpriority_queue.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,300 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Priority queue implementation of GOMP tasks.  */\n+\n+#include \"libgomp.h\"\n+\n+#if _LIBGOMP_CHECKING_\n+#include <stdio.h>\n+\n+/* Sanity check to verify whether a TASK is in LIST.  Return TRUE if\n+   found, FALSE otherwise.\n+\n+   TYPE is the type of priority queue this task resides in.  */\n+\n+static inline bool\n+priority_queue_task_in_list_p (enum priority_queue_type type,\n+\t\t\t       struct priority_list *list,\n+\t\t\t       struct gomp_task *task)\n+{\n+  struct priority_node *p = list->tasks;\n+  do\n+    {\n+      if (priority_node_to_task (type, p) == task)\n+\treturn true;\n+      p = p->next;\n+    }\n+  while (p != list->tasks);\n+  return false;\n+}\n+\n+/* Tree version of priority_queue_task_in_list_p.  */\n+\n+static inline bool\n+priority_queue_task_in_tree_p (enum priority_queue_type type,\n+\t\t\t       struct priority_queue *head,\n+\t\t\t       struct gomp_task *task)\n+{\n+  struct priority_list *list\n+    = priority_queue_lookup_priority (head, task->priority);\n+  if (!list)\n+    return false;\n+  return priority_queue_task_in_list_p (type, list, task);\n+}\n+\n+/* Generic version of priority_queue_task_in_list_p that works for\n+   trees or lists.  */\n+\n+bool\n+priority_queue_task_in_queue_p (enum priority_queue_type type,\n+\t\t\t\tstruct priority_queue *head,\n+\t\t\t\tstruct gomp_task *task)\n+{\n+  if (priority_queue_empty_p (head, MEMMODEL_RELAXED))\n+    return false;\n+  if (priority_queue_multi_p (head))\n+    return priority_queue_task_in_tree_p (type, head, task);\n+  else\n+    return priority_queue_task_in_list_p (type, &head->l, task);\n+}\n+\n+/* Sanity check LIST to make sure the tasks therein are in the right\n+   order.  LIST is a priority list of type TYPE.\n+\n+   The expected order is that GOMP_TASK_WAITING tasks come before\n+   GOMP_TASK_TIED/GOMP_TASK_ASYNC_RUNNING ones.\n+\n+   If CHECK_DEPS is TRUE, we also check that parent_depends_on WAITING\n+   tasks come before !parent_depends_on WAITING tasks.  This is only\n+   applicable to the children queue, and the caller is expected to\n+   ensure that we are verifying the children queue.  */\n+\n+static void\n+priority_list_verify (enum priority_queue_type type,\n+\t\t      struct priority_list *list, bool check_deps)\n+{\n+  bool seen_tied = false;\n+  bool seen_plain_waiting = false;\n+  struct priority_node *p = list->tasks;\n+  while (1)\n+    {\n+      struct gomp_task *t = priority_node_to_task (type, p);\n+      if (seen_tied && t->kind == GOMP_TASK_WAITING)\n+\tgomp_fatal (\"priority_queue_verify: WAITING task after TIED\");\n+      if (t->kind >= GOMP_TASK_TIED)\n+\tseen_tied = true;\n+      else if (check_deps && t->kind == GOMP_TASK_WAITING)\n+\t{\n+\t  if (t->parent_depends_on)\n+\t    {\n+\t      if (seen_plain_waiting)\n+\t\tgomp_fatal (\"priority_queue_verify: \"\n+\t\t\t    \"parent_depends_on after !parent_depends_on\");\n+\t    }\n+\t  else\n+\t    seen_plain_waiting = true;\n+\t}\n+      p = p->next;\n+      if (p == list->tasks)\n+\tbreak;\n+    }\n+}\n+\n+/* Callback type for priority_tree_verify_callback.  */\n+struct cbtype\n+{\n+  enum priority_queue_type type;\n+  bool check_deps;\n+};\n+\n+/* Verify every task in NODE.\n+\n+   Callback for splay_tree_foreach.  */\n+\n+static void\n+priority_tree_verify_callback (prio_splay_tree_key key, void *data)\n+{\n+  struct cbtype *cb = (struct cbtype *) data;\n+  priority_list_verify (cb->type, &key->l, cb->check_deps);\n+}\n+\n+/* Generic version of priority_list_verify.\n+\n+   Sanity check HEAD to make sure the tasks therein are in the right\n+   order.  The priority_queue holds tasks of type TYPE.\n+\n+   If CHECK_DEPS is TRUE, we also check that parent_depends_on WAITING\n+   tasks come before !parent_depends_on WAITING tasks.  This is only\n+   applicable to the children queue, and the caller is expected to\n+   ensure that we are verifying the children queue.  */\n+\n+void\n+priority_queue_verify (enum priority_queue_type type,\n+\t\t       struct priority_queue *head, bool check_deps)\n+{\n+  if (priority_queue_empty_p (head, MEMMODEL_RELAXED))\n+    return;\n+  if (priority_queue_multi_p (head))\n+    {\n+      struct cbtype cb = { type, check_deps };\n+      prio_splay_tree_foreach (&head->t,\n+\t\t\t       priority_tree_verify_callback, &cb);\n+    }\n+  else\n+    priority_list_verify (type, &head->l, check_deps);\n+}\n+#endif /* _LIBGOMP_CHECKING_ */\n+\n+/* Remove NODE from priority queue HEAD, wherever it may be inside the\n+   tree.  HEAD contains tasks of type TYPE.  */\n+\n+void\n+priority_tree_remove (enum priority_queue_type type,\n+\t\t      struct priority_queue *head,\n+\t\t      struct priority_node *node)\n+{\n+  /* ?? The only reason this function is not inlined is because we\n+     need to find the priority within gomp_task (which has not been\n+     completely defined in the header file).  If the lack of inlining\n+     is a concern, we could pass the priority number as a\n+     parameter, or we could move this to libgomp.h.  */\n+  int priority = priority_node_to_task (type, node)->priority;\n+\n+  /* ?? We could avoid this lookup by keeping a pointer to the key in\n+     the priority_node.  */\n+  struct priority_list *list\n+    = priority_queue_lookup_priority (head, priority);\n+#if _LIBGOMP_CHECKING_\n+  if (!list)\n+    gomp_fatal (\"Unable to find priority %d\", priority);\n+#endif\n+  /* If NODE was the last in its priority, clean up the priority.  */\n+  if (priority_list_remove (list, node, MEMMODEL_RELAXED))\n+    {\n+      prio_splay_tree_remove (&head->t, (prio_splay_tree_key) list);\n+      list->tasks = NULL;\n+#if _LIBGOMP_CHECKING_\n+      memset (list, 0xaf, sizeof (*list));\n+#endif\n+      free (list);\n+    }\n+}\n+\n+/* Return the highest priority WAITING task in a splay tree NODE.  If\n+   there are no WAITING tasks available, return NULL.\n+\n+   NODE is a priority list containing tasks of type TYPE.\n+\n+   The right most node in a tree contains the highest priority.\n+   Recurse down to find such a node.  If the task at that max node is\n+   not WAITING, bubble back up and look at the remaining tasks\n+   in-order.  */\n+\n+static struct gomp_task *\n+priority_tree_next_task_1 (enum priority_queue_type type,\n+\t\t\t   prio_splay_tree_node node)\n+{\n+ again:\n+  if (!node)\n+    return NULL;\n+  struct gomp_task *ret = priority_tree_next_task_1 (type, node->right);\n+  if (ret)\n+    return ret;\n+  ret = priority_node_to_task (type, node->key.l.tasks);\n+  if (ret->kind == GOMP_TASK_WAITING)\n+    return ret;\n+  node = node->left;\n+  goto again;\n+}\n+\n+/* Return the highest priority WAITING task from within Q1 and Q2,\n+   while giving preference to tasks from Q1.  Q1 is a queue containing\n+   items of type TYPE1.  Q2 is a queue containing items of type TYPE2.\n+\n+   Since we are mostly interested in Q1, if there are no WAITING tasks\n+   in Q1, we don't bother checking Q2, and just return NULL.\n+\n+   As a special case, Q2 can be NULL, in which case, we just choose\n+   the highest priority WAITING task in Q1.  This is an optimization\n+   to speed up looking through only one queue.\n+\n+   If the returned task is chosen from Q1, *Q1_CHOSEN_P is set to\n+   TRUE, otherwise it is set to FALSE.  */\n+\n+struct gomp_task *\n+priority_tree_next_task (enum priority_queue_type type1,\n+\t\t\t struct priority_queue *q1,\n+\t\t\t enum priority_queue_type type2,\n+\t\t\t struct priority_queue *q2,\n+\t\t\t bool *q1_chosen_p)\n+{\n+  struct gomp_task *t1 = priority_tree_next_task_1 (type1, q1->t.root);\n+  if (!t1\n+      /* Special optimization when only searching through one queue.  */\n+      || !q2)\n+    {\n+      *q1_chosen_p = true;\n+      return t1;\n+    }\n+  struct gomp_task *t2 = priority_tree_next_task_1 (type2, q2->t.root);\n+  if (!t2 || t1->priority > t2->priority)\n+    {\n+      *q1_chosen_p = true;\n+      return t1;\n+    }\n+  if (t2->priority > t1->priority)\n+    {\n+      *q1_chosen_p = false;\n+      return t2;\n+    }\n+  /* If we get here, the priorities are the same, so we must look at\n+     parent_depends_on to make our decision.  */\n+#if _LIBGOMP_CHECKING_\n+  if (t1 != t2)\n+    gomp_fatal (\"priority_tree_next_task: t1 != t2\");\n+#endif\n+  if (t2->parent_depends_on && !t1->parent_depends_on)\n+    {\n+      *q1_chosen_p = false;\n+      return t2;\n+    }\n+  *q1_chosen_p = true;\n+  return t1;\n+}\n+\n+/* Priority splay trees comparison function.  */\n+static inline int\n+prio_splay_compare (prio_splay_tree_key x, prio_splay_tree_key y)\n+{\n+  if (x->l.priority == y->l.priority)\n+    return 0;\n+  return x->l.priority < y->l.priority ? -1 : 1;\n+}\n+\n+/* Define another splay tree instantiation, for priority_list's.  */\n+#define splay_tree_prefix prio\n+#define splay_tree_c\n+#include \"splay-tree.h\""}, {"sha": "e9c369b774aa1784943855c99052fd721c89cb1e", "filename": "libgomp/priority_queue.h", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fpriority_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fpriority_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fpriority_queue.h?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,485 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Header file for a priority queue of GOMP tasks.  */\n+\n+/* ?? Perhaps all the priority_tree_* functions are complex and rare\n+   enough to go out-of-line and be moved to priority_queue.c.  ??  */\n+\n+#ifndef _PRIORITY_QUEUE_H_\n+#define _PRIORITY_QUEUE_H_\n+\n+/* One task.  */\n+\n+struct priority_node\n+{\n+  /* Next and previous chains in a circular doubly linked list for\n+     tasks within this task's priority.  */\n+  struct priority_node *next, *prev;\n+};\n+\n+/* All tasks within the same priority.  */\n+\n+struct priority_list\n+{\n+  /* Priority of the tasks in this set.  */\n+  int priority;\n+\n+  /* Tasks.  */\n+  struct priority_node *tasks;\n+\n+  /* This points to the last of the higher priority WAITING tasks.\n+     Remember that for the children queue, we have:\n+\n+\tparent_depends_on WAITING tasks.\n+\t!parent_depends_on WAITING tasks.\n+\tTIED tasks.\n+\n+     This is a pointer to the last of the parent_depends_on WAITING\n+     tasks which are essentially, higher priority items within their\n+     priority.  */\n+  struct priority_node *last_parent_depends_on;\n+};\n+\n+/* Another splay tree instantiation, for priority_list's.  */\n+typedef struct prio_splay_tree_node_s *prio_splay_tree_node;\n+typedef struct prio_splay_tree_s *prio_splay_tree;\n+typedef struct prio_splay_tree_key_s *prio_splay_tree_key;\n+struct prio_splay_tree_key_s {\n+  /* This structure must only containing a priority_list, as we cast\n+     prio_splay_tree_key to priority_list throughout.  */\n+  struct priority_list l;\n+};\n+#define splay_tree_prefix prio\n+#include \"splay-tree.h\"\n+\n+/* The entry point into a priority queue of tasks.\n+\n+   There are two alternate implementations with which to store tasks:\n+   as a balanced tree of sorts, or as a simple list of tasks.  If\n+   there are only priority-0 items (ROOT is NULL), we use the simple\n+   list, otherwise (ROOT is non-NULL) we use the tree.  */\n+\n+struct priority_queue\n+{\n+  /* If t.root != NULL, this is a splay tree of priority_lists to hold\n+     all tasks.  This is only used if multiple priorities are in play,\n+     otherwise we use the priority_list `l' below to hold all\n+     (priority-0) tasks.  */\n+  struct prio_splay_tree_s t;\n+\n+  /* If T above is NULL, only priority-0 items exist, so keep them\n+     in a simple list.  */\n+  struct priority_list l;\n+};\n+\n+enum priority_insert_type {\n+  /* Insert at the beginning of a priority list.  */\n+  PRIORITY_INSERT_BEGIN,\n+  /* Insert at the end of a priority list.  */\n+  PRIORITY_INSERT_END\n+};\n+\n+/* Used to determine in which queue a given priority node belongs in.\n+   See pnode field of gomp_task.  */\n+\n+enum priority_queue_type\n+{\n+  PQ_TEAM,\t    /* Node belongs in gomp_team's task_queue.  */\n+  PQ_CHILDREN,\t    /* Node belongs in parent's children_queue.  */\n+  PQ_TASKGROUP,\t    /* Node belongs in taskgroup->taskgroup_queue.  */\n+  PQ_IGNORED = 999\n+};\n+\n+/* Priority queue implementation prototypes.  */\n+\n+extern bool priority_queue_task_in_queue_p (enum priority_queue_type,\n+\t\t\t\t\t    struct priority_queue *,\n+\t\t\t\t\t    struct gomp_task *);\n+extern void priority_queue_dump (enum priority_queue_type,\n+\t\t\t\t struct priority_queue *);\n+extern void priority_queue_verify (enum priority_queue_type,\n+\t\t\t\t   struct priority_queue *, bool);\n+extern void priority_tree_remove (enum priority_queue_type,\n+\t\t\t\t  struct priority_queue *,\n+\t\t\t\t  struct priority_node *);\n+extern struct gomp_task *priority_tree_next_task (enum priority_queue_type,\n+\t\t\t\t\t\t  struct priority_queue *,\n+\t\t\t\t\t\t  enum priority_queue_type,\n+\t\t\t\t\t\t  struct priority_queue *,\n+\t\t\t\t\t\t  bool *);\n+\n+/* Return TRUE if there is more than one priority in HEAD.  This is\n+   used throughout to to choose between the fast path (priority 0 only\n+   items) and a world with multiple priorities.  */\n+\n+static inline bool\n+priority_queue_multi_p (struct priority_queue *head)\n+{\n+  return __builtin_expect (head->t.root != NULL, 0);\n+}\n+\n+/* Initialize a priority queue.  */\n+\n+static inline void\n+priority_queue_init (struct priority_queue *head)\n+{\n+  head->t.root = NULL;\n+  /* To save a few microseconds, we don't initialize head->l.priority\n+     to 0 here.  It is implied that priority will be 0 if head->t.root\n+     == NULL.\n+\n+     priority_tree_insert() will fix this when we encounter multiple\n+     priorities.  */\n+  head->l.tasks = NULL;\n+  head->l.last_parent_depends_on = NULL;\n+}\n+\n+static inline void\n+priority_queue_free (struct priority_queue *head)\n+{\n+  /* There's nothing to do, as tasks were freed as they were removed\n+     in priority_queue_remove.  */\n+}\n+\n+/* Forward declarations.  */\n+static inline size_t priority_queue_offset (enum priority_queue_type);\n+static inline struct gomp_task *priority_node_to_task\n+\t\t\t\t(enum priority_queue_type,\n+\t\t\t\t struct priority_node *);\n+static inline struct priority_node *task_to_priority_node\n+\t\t\t\t    (enum priority_queue_type,\n+\t\t\t\t     struct gomp_task *);\n+\n+/* Return TRUE if priority queue HEAD is empty.\n+\n+   MODEL IS MEMMODEL_ACQUIRE if we should use an acquire atomic to\n+   read from the root of the queue, otherwise MEMMODEL_RELAXED if we\n+   should use a plain load.  */\n+\n+static inline _Bool\n+priority_queue_empty_p (struct priority_queue *head, enum memmodel model)\n+{\n+  /* Note: The acquire barriers on the loads here synchronize with\n+     the write of a NULL in gomp_task_run_post_remove_parent.  It is\n+     not necessary that we synchronize with other non-NULL writes at\n+     this point, but we must ensure that all writes to memory by a\n+     child thread task work function are seen before we exit from\n+     GOMP_taskwait.  */\n+  if (priority_queue_multi_p (head))\n+    {\n+      if (model == MEMMODEL_ACQUIRE)\n+\treturn __atomic_load_n (&head->t.root, MEMMODEL_ACQUIRE) == NULL;\n+      return head->t.root == NULL;\n+    }\n+  if (model == MEMMODEL_ACQUIRE)\n+    return __atomic_load_n (&head->l.tasks, MEMMODEL_ACQUIRE) == NULL;\n+  return head->l.tasks == NULL;\n+}\n+\n+/* Look for a given PRIORITY in HEAD.  Return it if found, otherwise\n+   return NULL.  This only applies to the tree variant in HEAD.  There\n+   is no point in searching for priorities in HEAD->L.  */\n+\n+static inline struct priority_list *\n+priority_queue_lookup_priority (struct priority_queue *head, int priority)\n+{\n+  if (head->t.root == NULL)\n+    return NULL;\n+  struct prio_splay_tree_key_s k;\n+  k.l.priority = priority;\n+  return (struct priority_list *)\n+    prio_splay_tree_lookup (&head->t, &k);\n+}\n+\n+/* Insert task in DATA, with PRIORITY, in the priority list in LIST.\n+   LIST contains items of type TYPE.\n+\n+   If POS is PRIORITY_INSERT_BEGIN, the new task is inserted at the\n+   top of its respective priority.  If POS is PRIORITY_INSERT_END, the\n+   task is inserted at the end of its priority.\n+\n+   If ADJUST_PARENT_DEPENDS_ON is TRUE, LIST is a children queue, and\n+   we must keep track of higher and lower priority WAITING tasks by\n+   keeping the queue's last_parent_depends_on field accurate.  This\n+   only applies to the children queue, and the caller must ensure LIST\n+   is a children queue in this case.\n+\n+   If ADJUST_PARENT_DEPENDS_ON is TRUE, TASK_IS_PARENT_DEPENDS_ON is\n+   set to the task's parent_depends_on field.  If\n+   ADJUST_PARENT_DEPENDS_ON is FALSE, this field is irrelevant.\n+\n+   Return the new priority_node.  */\n+\n+static inline void\n+priority_list_insert (enum priority_queue_type type,\n+\t\t      struct priority_list *list,\n+\t\t      struct gomp_task *task,\n+\t\t      int priority,\n+\t\t      enum priority_insert_type pos,\n+\t\t      bool adjust_parent_depends_on,\n+\t\t      bool task_is_parent_depends_on)\n+{\n+  struct priority_node *node = task_to_priority_node (type, task);\n+  if (list->tasks)\n+    {\n+      /* If we are keeping track of higher/lower priority items,\n+\t but this is a lower priority WAITING task\n+\t (parent_depends_on != NULL), put it after all ready to\n+\t run tasks.  See the comment in\n+\t priority_queue_upgrade_task for a visual on how tasks\n+\t should be organized.  */\n+      if (adjust_parent_depends_on\n+\t  && pos == PRIORITY_INSERT_BEGIN\n+\t  && list->last_parent_depends_on\n+\t  && !task_is_parent_depends_on)\n+\t{\n+\t  struct priority_node *last_parent_depends_on\n+\t    = list->last_parent_depends_on;\n+\t  node->next = last_parent_depends_on->next;\n+\t  node->prev = last_parent_depends_on;\n+\t}\n+      /* Otherwise, put it at the top/bottom of the queue.  */\n+      else\n+\t{\n+\t  node->next = list->tasks;\n+\t  node->prev = list->tasks->prev;\n+\t  if (pos == PRIORITY_INSERT_BEGIN)\n+\t    list->tasks = node;\n+\t}\n+      node->next->prev = node;\n+      node->prev->next = node;\n+    }\n+  else\n+    {\n+      node->next = node;\n+      node->prev = node;\n+      list->tasks = node;\n+    }\n+  if (adjust_parent_depends_on\n+      && list->last_parent_depends_on == NULL\n+      && task_is_parent_depends_on)\n+    list->last_parent_depends_on = node;\n+}\n+\n+/* Tree version of priority_list_insert.  */\n+\n+static inline void\n+priority_tree_insert (enum priority_queue_type type,\n+\t\t      struct priority_queue *head,\n+\t\t      struct gomp_task *task,\n+\t\t      int priority,\n+\t\t      enum priority_insert_type pos,\n+\t\t      bool adjust_parent_depends_on,\n+\t\t      bool task_is_parent_depends_on)\n+{\n+  if (__builtin_expect (head->t.root == NULL, 0))\n+    {\n+      /* The first time around, transfer any priority 0 items to the\n+\t tree.  */\n+      if (head->l.tasks != NULL)\n+\t{\n+\t  prio_splay_tree_node k = gomp_malloc (sizeof (*k));\n+\t  k->left = NULL;\n+\t  k->right = NULL;\n+\t  k->key.l.priority = 0;\n+\t  k->key.l.tasks = head->l.tasks;\n+\t  k->key.l.last_parent_depends_on = head->l.last_parent_depends_on;\n+\t  prio_splay_tree_insert (&head->t, k);\n+\t  head->l.tasks = NULL;\n+\t}\n+    }\n+  struct priority_list *list\n+    = priority_queue_lookup_priority (head, priority);\n+  if (!list)\n+    {\n+      prio_splay_tree_node k = gomp_malloc (sizeof (*k));\n+      k->left = NULL;\n+      k->right = NULL;\n+      k->key.l.priority = priority;\n+      k->key.l.tasks = NULL;\n+      k->key.l.last_parent_depends_on = NULL;\n+      prio_splay_tree_insert (&head->t, k);\n+      list = &k->key.l;\n+    }\n+  priority_list_insert (type, list, task, priority, pos,\n+\t\t\tadjust_parent_depends_on,\n+\t\t\ttask_is_parent_depends_on);\n+}\n+\n+/* Generic version of priority_*_insert.  */\n+\n+static inline void\n+priority_queue_insert (enum priority_queue_type type,\n+\t\t       struct priority_queue *head,\n+\t\t       struct gomp_task *task,\n+\t\t       int priority,\n+\t\t       enum priority_insert_type pos,\n+\t\t       bool adjust_parent_depends_on,\n+\t\t       bool task_is_parent_depends_on)\n+{\n+#if _LIBGOMP_CHECKING_\n+  if (priority_queue_task_in_queue_p (type, head, task))\n+    gomp_fatal (\"Attempt to insert existing task %p\", task);\n+#endif\n+  if (priority_queue_multi_p (head) || __builtin_expect (priority > 0, 0))\n+    priority_tree_insert (type, head, task, priority, pos,\n+\t\t\t  adjust_parent_depends_on,\n+\t\t\t  task_is_parent_depends_on);\n+  else\n+    priority_list_insert (type, &head->l, task, priority, pos,\n+\t\t\t  adjust_parent_depends_on,\n+\t\t\t  task_is_parent_depends_on);\n+}\n+\n+/* If multiple priorities are in play, return the highest priority\n+   task from within Q1 and Q2, while giving preference to tasks from\n+   Q1.  If the returned task is chosen from Q1, *Q1_CHOSEN_P is set to\n+   TRUE, otherwise it is set to FALSE.\n+\n+   If multiple priorities are not in play (only 0 priorities are\n+   available), the next task is chosen exclusively from Q1.\n+\n+   As a special case, Q2 can be NULL, in which case, we just choose\n+   the highest priority WAITING task in Q1.  This is an optimization\n+   to speed up looking through only one queue.\n+\n+   We assume Q1 has at least one item.  */\n+\n+static inline struct gomp_task *\n+priority_queue_next_task (enum priority_queue_type t1,\n+\t\t\t  struct priority_queue *q1,\n+\t\t\t  enum priority_queue_type t2,\n+\t\t\t  struct priority_queue *q2,\n+\t\t\t  bool *q1_chosen_p)\n+{\n+#if _LIBGOMP_CHECKING_\n+  if (priority_queue_empty_p (q1, MEMMODEL_RELAXED))\n+    gomp_fatal (\"priority_queue_next_task: Q1 is empty\");\n+#endif\n+  if (priority_queue_multi_p (q1))\n+    {\n+      struct gomp_task *t\n+\t= priority_tree_next_task (t1, q1, t2, q2, q1_chosen_p);\n+      /* If T is NULL, there are no WAITING tasks in Q1.  In which\n+\t case, return any old (non-waiting) task which will cause the\n+\t caller to do the right thing when checking T->KIND ==\n+\t GOMP_TASK_WAITING.  */\n+      if (!t)\n+\t{\n+#if _LIBGOMP_CHECKING_\n+\t  if (*q1_chosen_p == false)\n+\t    gomp_fatal (\"priority_queue_next_task inconsistency\");\n+#endif\n+\t  return priority_node_to_task (t1, q1->t.root->key.l.tasks);\n+\t}\n+      return t;\n+    }\n+  else\n+    {\n+      *q1_chosen_p = true;\n+      return priority_node_to_task (t1, q1->l.tasks);\n+    }\n+}\n+\n+/* Remove NODE from LIST.\n+\n+   If we are removing the one and only item in the list, and MODEL is\n+   MEMMODEL_RELEASE, use an atomic release to clear the list.\n+\n+   If the list becomes empty after the remove, return TRUE.  */\n+\n+static inline bool\n+priority_list_remove (struct priority_list *list,\n+\t\t      struct priority_node *node,\n+\t\t      enum memmodel model)\n+{\n+  bool empty = false;\n+  node->prev->next = node->next;\n+  node->next->prev = node->prev;\n+  if (list->tasks == node)\n+    {\n+      if (node->next != node)\n+\tlist->tasks = node->next;\n+      else\n+\t{\n+\t  /* We access task->children in GOMP_taskwait outside of\n+\t     the task lock mutex region, so need a release barrier\n+\t     here to ensure memory written by child_task->fn above\n+\t     is flushed before the NULL is written.  */\n+\t  if (model == MEMMODEL_RELEASE)\n+\t    __atomic_store_n (&list->tasks, NULL, MEMMODEL_RELEASE);\n+\t  else\n+\t    list->tasks = NULL;\n+\t  empty = true;\n+\t  goto remove_out;\n+\t}\n+    }\n+remove_out:\n+#if _LIBGOMP_CHECKING_\n+  memset (node, 0xaf, sizeof (*node));\n+#endif\n+  return empty;\n+}\n+\n+/* This is the generic version of priority_list_remove.\n+\n+   Remove NODE from priority queue HEAD.  HEAD contains tasks of type TYPE.\n+\n+   If we are removing the one and only item in the priority queue and\n+   MODEL is MEMMODEL_RELEASE, use an atomic release to clear the queue.\n+\n+   If the queue becomes empty after the remove, return TRUE.  */\n+\n+static inline bool\n+priority_queue_remove (enum priority_queue_type type,\n+\t\t       struct priority_queue *head,\n+\t\t       struct gomp_task *task,\n+\t\t       enum memmodel model)\n+{\n+#if _LIBGOMP_CHECKING_\n+  if (!priority_queue_task_in_queue_p (type, head, task))\n+    gomp_fatal (\"Attempt to remove missing task %p\", task);\n+#endif\n+  if (priority_queue_multi_p (head))\n+    {\n+      priority_tree_remove (type, head, task_to_priority_node (type, task));\n+      if (head->t.root == NULL)\n+\t{\n+\t  if (model == MEMMODEL_RELEASE)\n+\t    /* Errr, we store NULL twice, the alternative would be to\n+\t       use an atomic release directly in the splay tree\n+\t       routines.  Worth it?  */\n+\t    __atomic_store_n (&head->t.root, NULL, MEMMODEL_RELEASE);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  else\n+    return priority_list_remove (&head->l,\n+\t\t\t\t task_to_priority_node (type, task), model);\n+}\n+\n+#endif /* _PRIORITY_QUEUE_H_ */"}, {"sha": "862bbb80aa57a2005a2fabb7ff184fe074d4eb69", "filename": "libgomp/splay-tree.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -37,9 +37,6 @@\n    are amortized O(log n) time for a tree with n nodes.  */\n \n #include \"libgomp.h\"\n-#include \"splay-tree.h\"\n-\n-extern int splay_compare (splay_tree_key, splay_tree_key);\n \n /* Rotate the edge joining the left child N with its parent P.  PP is the\n    grandparents' pointer to P.  */\n@@ -215,3 +212,27 @@ splay_tree_lookup (splay_tree sp, splay_tree_key key)\n   else\n     return NULL;\n }\n+\n+/* Helper function for splay_tree_foreach.\n+\n+   Run FUNC on every node in KEY.  */\n+\n+static void\n+splay_tree_foreach_internal (splay_tree_node node, splay_tree_callback func,\n+\t\t\t     void *data)\n+{\n+  if (!node)\n+    return;\n+  func (&node->key, data);\n+  splay_tree_foreach_internal (node->left, func, data);\n+  /* Yeah, whatever.  GCC can fix my tail recursion.  */\n+  splay_tree_foreach_internal (node->right, func, data);\n+}\n+\n+/* Run FUNC on each of the nodes in SP.  */\n+\n+attribute_hidden void\n+splay_tree_foreach (splay_tree sp, splay_tree_callback func, void *data)\n+{\n+  splay_tree_foreach_internal (sp->root, func, data);\n+}"}, {"sha": "92c51bf930805c520ad871e2282f23f1736d2cc9", "filename": "libgomp/splay-tree.h", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.h?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -33,7 +33,17 @@ typedef struct splay_tree_node_s *splay_tree_node;\n typedef struct splay_tree_s *splay_tree;\n typedef struct splay_tree_key_s *splay_tree_key;\n    define splay_tree_key_s structure, and define\n-   splay_compare inline function.  */\n+   splay_compare inline function.\n+\n+   Alternatively, they can define splay_tree_prefix macro before\n+   including this header and then all the above types, the\n+   splay_compare function and the splay_tree_{lookup,insert_remove}\n+   function will be prefixed by that prefix.  If splay_tree_prefix\n+   macro is defined, this header must be included twice: once where\n+   you need the header file definitions, and once where you need the\n+   .c implementation routines.  In the latter case, you must also\n+   define the macro splay_tree_c.  See the include of splay-tree.h in\n+   priority_queue.[hc] for an example.  */\n \n /* For an easily readable description of splay-trees, see:\n \n@@ -43,8 +53,37 @@ typedef struct splay_tree_key_s *splay_tree_key;\n    The major feature of splay trees is that all basic tree operations\n    are amortized O(log n) time for a tree with n nodes.  */\n \n-#ifndef _SPLAY_TREE_H\n-#define _SPLAY_TREE_H 1\n+#ifdef splay_tree_prefix\n+# define splay_tree_name_1(prefix, name) prefix ## _ ## name\n+# define splay_tree_name(prefix, name) splay_tree_name_1 (prefix, name)\n+# define splay_tree_node_s\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_node_s)\n+# define splay_tree_s\t\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_s)\n+# define splay_tree_key_s\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_key_s)\n+# define splay_tree_node\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_node)\n+# define splay_tree\t\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree)\n+# define splay_tree_key\t\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_key)\n+# define splay_compare\t\t\\\n+    splay_tree_name (splay_tree_prefix, splay_compare)\n+# define splay_tree_lookup\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_lookup)\n+# define splay_tree_insert\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_insert)\n+# define splay_tree_remove\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_remove)\n+# define splay_tree_foreach\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_foreach)\n+# define splay_tree_callback\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_callback)\n+#endif\n+\n+#ifndef splay_tree_c\n+/* Header file definitions and prototypes.  */\n \n /* The nodes in the splay tree.  */\n struct splay_tree_node_s {\n@@ -59,8 +98,33 @@ struct splay_tree_s {\n   splay_tree_node root;\n };\n \n+typedef void (*splay_tree_callback) (splay_tree_key, void *);\n+\n extern splay_tree_key splay_tree_lookup (splay_tree, splay_tree_key);\n extern void splay_tree_insert (splay_tree, splay_tree_node);\n extern void splay_tree_remove (splay_tree, splay_tree_key);\n+extern void splay_tree_foreach (splay_tree, splay_tree_callback, void *);\n+#else  /* splay_tree_c */\n+#  ifdef splay_tree_prefix\n+#    include \"splay-tree.c\"\n+#    undef splay_tree_name_1\n+#    undef splay_tree_name\n+#    undef splay_tree_node_s\n+#    undef splay_tree_s\n+#    undef splay_tree_key_s\n+#    undef splay_tree_node\n+#    undef splay_tree\n+#    undef splay_tree_key\n+#    undef splay_compare\n+#    undef splay_tree_lookup\n+#    undef splay_tree_insert\n+#    undef splay_tree_remove\n+#    undef splay_tree_foreach\n+#    undef splay_tree_callback\n+#    undef splay_tree_c\n+#  endif\n+#endif /* #ifndef splay_tree_c */\n \n-#endif /* _SPLAY_TREE_H */\n+#ifdef splay_tree_prefix\n+#  undef splay_tree_prefix\n+#endif"}, {"sha": "cf9d0e64c7c241d9870642ee9954da3d74fb6827", "filename": "libgomp/target.c", "status": "modified", "additions": 124, "deletions": 86, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -92,23 +92,6 @@ gomp_realloc_unlock (void *old, size_t size)\n   return ret;\n }\n \n-/* The comparison function.  */\n-\n-attribute_hidden int\n-splay_compare (splay_tree_key x, splay_tree_key y)\n-{\n-  if (x->host_start == x->host_end\n-      && y->host_start == y->host_end)\n-    return 0;\n-  if (x->host_end <= y->host_start)\n-    return -1;\n-  if (x->host_start >= y->host_end)\n-    return 1;\n-  return 0;\n-}\n-\n-#include \"splay-tree.h\"\n-\n attribute_hidden void\n gomp_init_targets_once (void)\n {\n@@ -1365,17 +1348,7 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n \t\t     GOMP_MAP_VARS_TARGET);\n-  struct gomp_thread old_thr, *thr = gomp_thread ();\n-  old_thr = *thr;\n-  memset (thr, '\\0', sizeof (*thr));\n-  if (gomp_places_list)\n-    {\n-      thr->place = old_thr.place;\n-      thr->ts.place_partition_len = gomp_places_list_len;\n-    }\n   devicep->run_func (devicep->target_id, fn_addr, (void *) tgt_vars->tgt_start);\n-  gomp_free_thread (thr);\n-  *thr = old_thr;\n   gomp_unmap_vars (tgt_vars, true);\n }\n \n@@ -1404,10 +1377,52 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n   (void) num_teams;\n   (void) thread_limit;\n \n-  /* If there are depend clauses, but nowait is not present,\n-     block the parent task until the dependencies are resolved\n-     and then just continue with the rest of the function as if it\n-     is a merged task.  */\n+  if (flags & GOMP_TARGET_FLAG_NOWAIT)\n+    {\n+      struct gomp_thread *thr = gomp_thread ();\n+      /* Create a team if we don't have any around, as nowait\n+\t target tasks make sense to run asynchronously even when\n+\t outside of any parallel.  */\n+      if (__builtin_expect (thr->ts.team == NULL, 0))\n+\t{\n+\t  struct gomp_team *team = gomp_new_team (1);\n+\t  struct gomp_task *task = thr->task;\n+\t  struct gomp_task_icv *icv = task ? &task->icv : &gomp_global_icv;\n+\t  team->prev_ts = thr->ts;\n+\t  thr->ts.team = team;\n+\t  thr->ts.team_id = 0;\n+\t  thr->ts.work_share = &team->work_shares[0];\n+\t  thr->ts.last_work_share = NULL;\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  thr->ts.single_count = 0;\n+#endif\n+\t  thr->ts.static_trip = 0;\n+\t  thr->task = &team->implicit_task[0];\n+\t  gomp_init_task (thr->task, NULL, icv);\n+\t  if (task)\n+\t    {\n+\t      thr->task = task;\n+\t      gomp_end_task ();\n+\t      free (task);\n+\t      thr->task = &team->implicit_task[0];\n+\t    }\n+\t  else\n+\t    pthread_setspecific (gomp_thread_destructor, thr);\n+\t}\n+      if (thr->ts.team\n+\t  && !thr->task->final_task)\n+\t{\n+\t  gomp_create_target_task (devicep, fn, mapnum, hostaddrs,\n+\t\t\t\t   sizes, kinds, flags, depend,\n+\t\t\t\t   GOMP_TARGET_TASK_BEFORE_MAP);\n+\t  return;\n+\t}\n+    }\n+\n+  /* If there are depend clauses, but nowait is not present\n+     (or we are in a final task), block the parent task until the\n+     dependencies are resolved and then just continue with the rest\n+     of the function as if it is a merged task.  */\n   if (depend != NULL)\n     {\n       struct gomp_thread *thr = gomp_thread ();\n@@ -1427,17 +1442,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, true,\n \t\t     GOMP_MAP_VARS_TARGET);\n-  struct gomp_thread old_thr, *thr = gomp_thread ();\n-  old_thr = *thr;\n-  memset (thr, '\\0', sizeof (*thr));\n-  if (gomp_places_list)\n-    {\n-      thr->place = old_thr.place;\n-      thr->ts.place_partition_len = gomp_places_list_len;\n-    }\n   devicep->run_func (devicep->target_id, fn_addr, (void *) tgt_vars->tgt_start);\n-  gomp_free_thread (thr);\n-  *thr = old_thr;\n   gomp_unmap_vars (tgt_vars, true);\n }\n \n@@ -1544,23 +1549,25 @@ GOMP_target_update_ext (int device, size_t mapnum, void **hostaddrs,\n \t      && thr->ts.team\n \t      && !thr->task->final_task)\n \t    {\n-\t      gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n-\t\t\t\t       mapnum, hostaddrs, sizes, kinds,\n-\t\t\t\t       flags | GOMP_TARGET_FLAG_UPDATE,\n-\t\t\t\t       depend);\n-\t      return;\n+\t      if (gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n+\t\t\t\t\t   mapnum, hostaddrs, sizes, kinds,\n+\t\t\t\t\t   flags | GOMP_TARGET_FLAG_UPDATE,\n+\t\t\t\t\t   depend, GOMP_TARGET_TASK_DATA))\n+\t\treturn;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct gomp_team *team = thr->ts.team;\n+\t      /* If parallel or taskgroup has been cancelled, don't start new\n+\t\t tasks.  */\n+\t      if (team\n+\t\t  && (gomp_team_barrier_cancelled (&team->barrier)\n+\t\t      || (thr->task->taskgroup\n+\t\t\t  && thr->task->taskgroup->cancelled)))\n+\t\treturn;\n+\n+\t      gomp_task_maybe_wait_for_dependencies (depend);\n \t    }\n-\n-\t  struct gomp_team *team = thr->ts.team;\n-\t  /* If parallel or taskgroup has been cancelled, don't start new\n-\t     tasks.  */\n-\t  if (team\n-\t      && (gomp_team_barrier_cancelled (&team->barrier)\n-\t\t  || (thr->task->taskgroup\n-\t\t      && thr->task->taskgroup->cancelled)))\n-\t    return;\n-\n-\t  gomp_task_maybe_wait_for_dependencies (depend);\n \t}\n     }\n \n@@ -1664,22 +1671,25 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n \t      && thr->ts.team\n \t      && !thr->task->final_task)\n \t    {\n-\t      gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n-\t\t\t\t       mapnum, hostaddrs, sizes, kinds,\n-\t\t\t\t       flags, depend);\n-\t      return;\n+\t      if (gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n+\t\t\t\t\t   mapnum, hostaddrs, sizes, kinds,\n+\t\t\t\t\t   flags, depend,\n+\t\t\t\t\t   GOMP_TARGET_TASK_DATA))\n+\t\treturn;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct gomp_team *team = thr->ts.team;\n+\t      /* If parallel or taskgroup has been cancelled, don't start new\n+\t\t tasks.  */\n+\t      if (team\n+\t\t  && (gomp_team_barrier_cancelled (&team->barrier)\n+\t\t      || (thr->task->taskgroup\n+\t\t\t  && thr->task->taskgroup->cancelled)))\n+\t\treturn;\n+\n+\t      gomp_task_maybe_wait_for_dependencies (depend);\n \t    }\n-\n-\t  struct gomp_team *team = thr->ts.team;\n-\t  /* If parallel or taskgroup has been cancelled, don't start new\n-\t     tasks.  */\n-\t  if (team\n-\t      && (gomp_team_barrier_cancelled (&team->barrier)\n-\t\t  || (thr->task->taskgroup\n-\t\t      && thr->task->taskgroup->cancelled)))\n-\t    return;\n-\n-\t  gomp_task_maybe_wait_for_dependencies (depend);\n \t}\n     }\n \n@@ -1711,38 +1721,65 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n     gomp_exit_data (devicep, mapnum, hostaddrs, sizes, kinds);\n }\n \n-void\n+bool\n gomp_target_task_fn (void *data)\n {\n   struct gomp_target_task *ttask = (struct gomp_target_task *) data;\n+  struct gomp_device_descr *devicep = ttask->devicep;\n+\n   if (ttask->fn != NULL)\n     {\n-      /* GOMP_target_ext */\n+      if (devicep == NULL\n+\t  || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+\t{\n+\t  ttask->state = GOMP_TARGET_TASK_FALLBACK;\n+\t  gomp_target_fallback_firstprivate (ttask->fn, ttask->mapnum,\n+\t\t\t\t\t     ttask->hostaddrs, ttask->sizes,\n+\t\t\t\t\t     ttask->kinds);\n+\t  return false;\n+\t}\n+\n+      if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\t{\n+\t  gomp_unmap_vars (ttask->tgt, true);\n+\t  return false;\n+\t}\n+\n+      void *fn_addr = gomp_get_target_fn_addr (devicep, ttask->fn);\n+      ttask->tgt\n+\t= gomp_map_vars (devicep, ttask->mapnum, ttask->hostaddrs, NULL,\n+\t\t\t ttask->sizes, ttask->kinds, true,\n+\t\t\t GOMP_MAP_VARS_TARGET);\n+      ttask->state = GOMP_TARGET_TASK_READY_TO_RUN;\n+\n+      devicep->async_run_func (devicep->target_id, fn_addr,\n+\t\t\t       (void *) ttask->tgt->tgt_start, (void *) ttask);\n+      return true;\n     }\n-  else if (ttask->devicep == NULL\n-\t   || !(ttask->devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n-    return;\n+  else if (devicep == NULL\n+\t   || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+    return false;\n \n   size_t i;\n   if (ttask->flags & GOMP_TARGET_FLAG_UPDATE)\n-    gomp_update (ttask->devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n+    gomp_update (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n \t\t ttask->kinds, true);\n   else if ((ttask->flags & GOMP_TARGET_FLAG_EXIT_DATA) == 0)\n     for (i = 0; i < ttask->mapnum; i++)\n       if ((ttask->kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n \t{\n-\t  gomp_map_vars (ttask->devicep, ttask->sizes[i] + 1,\n-\t\t\t &ttask->hostaddrs[i], NULL, &ttask->sizes[i],\n-\t\t\t &ttask->kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n+\t  gomp_map_vars (devicep, ttask->sizes[i] + 1, &ttask->hostaddrs[i],\n+\t\t\t NULL, &ttask->sizes[i], &ttask->kinds[i], true,\n+\t\t\t GOMP_MAP_VARS_ENTER_DATA);\n \t  i += ttask->sizes[i];\n \t}\n       else\n-\tgomp_map_vars (ttask->devicep, 1, &ttask->hostaddrs[i], NULL,\n-\t\t       &ttask->sizes[i], &ttask->kinds[i],\n-\t\t       true, GOMP_MAP_VARS_ENTER_DATA);\n+\tgomp_map_vars (devicep, 1, &ttask->hostaddrs[i], NULL, &ttask->sizes[i],\n+\t\t       &ttask->kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n   else\n-    gomp_exit_data (ttask->devicep, ttask->mapnum, ttask->hostaddrs,\n-\t\t    ttask->sizes, ttask->kinds);\n+    gomp_exit_data (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n+\t\t    ttask->kinds);\n+  return false;\n }\n \n void\n@@ -2187,6 +2224,7 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   if (device->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n     {\n       DLSYM (run);\n+      DLSYM (async_run);\n       DLSYM (dev2dev);\n     }\n   if (device->capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)"}, {"sha": "541008d016b39f1c5ce3d1e5c114d564123d8a59", "filename": "libgomp/task.c", "status": "modified", "additions": 720, "deletions": 476, "changes": 1196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -65,6 +65,14 @@ void\n gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n \t\tstruct gomp_task_icv *prev_icv)\n {\n+  /* It would seem that using memset here would be a win, but it turns\n+     out that partially filling gomp_task allows us to keep the\n+     overhead of task creation low.  In the nqueens-1.c test, for a\n+     sufficiently large N, we drop the overhead from 5-6% to 1%.\n+\n+     Note, the nqueens-1.c test in serial mode is a good test to\n+     benchmark the overhead of creating tasks as there are millions of\n+     tiny tasks created that all run undeferred.  */\n   task->parent = parent_task;\n   task->icv = *prev_icv;\n   task->kind = GOMP_TASK_IMPLICIT;\n@@ -73,7 +81,7 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->final_task = false;\n   task->copy_ctors_done = false;\n   task->parent_depends_on = false;\n-  task->children = NULL;\n+  priority_queue_init (&task->children_queue);\n   task->taskgroup = NULL;\n   task->dependers = NULL;\n   task->depend_hash = NULL;\n@@ -92,24 +100,66 @@ gomp_end_task (void)\n   thr->task = task->parent;\n }\n \n-/* Orphan the task in CHILDREN and all its siblings.  */\n+/* Clear the parent field of every task in LIST.  */\n \n static inline void\n-gomp_clear_parent (struct gomp_task *children)\n+gomp_clear_parent_in_list (struct priority_list *list)\n {\n-  struct gomp_task *task = children;\n-\n-  if (task)\n+  struct priority_node *p = list->tasks;\n+  if (p)\n     do\n       {\n-\ttask->parent = NULL;\n-\ttask = task->next_child;\n+\tpriority_node_to_task (PQ_CHILDREN, p)->parent = NULL;\n+\tp = p->next;\n       }\n-    while (task != children);\n+    while (p != list->tasks);\n }\n \n-/* Helper function for GOMP_task and gomp_create_target_task.  Depend clause\n-   handling for undeferred task creation.  */\n+/* Splay tree version of gomp_clear_parent_in_list.\n+\n+   Clear the parent field of every task in NODE within SP, and free\n+   the node when done.  */\n+\n+static void\n+gomp_clear_parent_in_tree (prio_splay_tree sp, prio_splay_tree_node node)\n+{\n+  if (!node)\n+    return;\n+  prio_splay_tree_node left = node->left, right = node->right;\n+  gomp_clear_parent_in_list (&node->key.l);\n+#if _LIBGOMP_CHECKING_\n+  memset (node, 0xaf, sizeof (*node));\n+#endif\n+  /* No need to remove the node from the tree.  We're nuking\n+     everything, so just free the nodes and our caller can clear the\n+     entire splay tree.  */\n+  free (node);\n+  gomp_clear_parent_in_tree (sp, left);\n+  gomp_clear_parent_in_tree (sp, right);\n+}\n+\n+/* Clear the parent field of every task in Q and remove every task\n+   from Q.  */\n+\n+static inline void\n+gomp_clear_parent (struct priority_queue *q)\n+{\n+  if (priority_queue_multi_p (q))\n+    {\n+      gomp_clear_parent_in_tree (&q->t, q->t.root);\n+      /* All the nodes have been cleared in gomp_clear_parent_in_tree.\n+\t No need to remove anything.  We can just nuke everything.  */\n+      q->t.root = NULL;\n+    }\n+  else\n+    gomp_clear_parent_in_list (&q->l);\n+}\n+\n+/* Helper function for GOMP_task and gomp_create_target_task.\n+\n+   For a TASK with in/out dependencies, fill in the various dependency\n+   queues.  PARENT is the parent of said task.  DEPEND is as in\n+   GOMP_task.  */\n \n static void\n gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n@@ -260,8 +310,8 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \n   if ((flags & GOMP_TASK_FLAG_PRIORITY) == 0)\n     priority = 0;\n-  /* FIXME, use priority.  */\n-  (void) priority;\n+  else if (priority > gomp_max_task_priority_var)\n+    priority = gomp_max_task_priority_var;\n \n   if (!if_clause || team == NULL\n       || (thr->task && thr->task->final_task)\n@@ -283,6 +333,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       task.kind = GOMP_TASK_UNDEFERRED;\n       task.final_task = (thr->task && thr->task->final_task)\n \t\t\t|| (flags & GOMP_TASK_FLAG_FINAL);\n+      task.priority = priority;\n       if (thr->task)\n \t{\n \t  task.in_tied_task = thr->task->in_tied_task;\n@@ -308,10 +359,10 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t child thread, but seeing a stale non-NULL value is not a\n \t problem.  Once past the task_lock acquisition, this thread\n \t will see the real value of task.children.  */\n-      if (task.children != NULL)\n+      if (!priority_queue_empty_p (&task.children_queue, MEMMODEL_RELAXED))\n \t{\n \t  gomp_mutex_lock (&team->task_lock);\n-\t  gomp_clear_parent (task.children);\n+\t  gomp_clear_parent (&task.children_queue);\n \t  gomp_mutex_unlock (&team->task_lock);\n \t}\n       gomp_end_task ();\n@@ -333,6 +384,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       arg = (char *) (((uintptr_t) (task + 1) + depend_size + arg_align - 1)\n \t\t      & ~(uintptr_t) (arg_align - 1));\n       gomp_init_task (task, parent, gomp_icv (false));\n+      task->priority = priority;\n       task->kind = GOMP_TASK_UNDEFERRED;\n       task->in_tied_task = parent->in_tied_task;\n       task->taskgroup = taskgroup;\n@@ -368,53 +420,36 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t  gomp_task_handle_depend (task, parent, depend);\n \t  if (task->num_dependees)\n \t    {\n+\t      /* Tasks that depend on other tasks are not put into the\n+\t\t various waiting queues, so we are done for now.  Said\n+\t\t tasks are instead put into the queues via\n+\t\t gomp_task_run_post_handle_dependers() after their\n+\t\t dependencies have been satisfied.  After which, they\n+\t\t can be picked up by the various scheduling\n+\t\t points.  */\n \t      gomp_mutex_unlock (&team->task_lock);\n \t      return;\n \t    }\n \t}\n-      if (parent->children)\n-\t{\n-\t  task->next_child = parent->children;\n-\t  task->prev_child = parent->children->prev_child;\n-\t  task->next_child->prev_child = task;\n-\t  task->prev_child->next_child = task;\n-\t}\n-      else\n-\t{\n-\t  task->next_child = task;\n-\t  task->prev_child = task;\n-\t}\n-      parent->children = task;\n+\n+      priority_queue_insert (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t     task, priority,\n+\t\t\t     PRIORITY_INSERT_BEGIN,\n+\t\t\t     /*adjust_parent_depends_on=*/false,\n+\t\t\t     task->parent_depends_on);\n       if (taskgroup)\n-\t{\n-\t  /* If applicable, place task into its taskgroup.  */\n-\t  if (taskgroup->children)\n-\t    {\n-\t      task->next_taskgroup = taskgroup->children;\n-\t      task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n-\t      task->next_taskgroup->prev_taskgroup = task;\n-\t      task->prev_taskgroup->next_taskgroup = task;\n-\t    }\n-\t  else\n-\t    {\n-\t      task->next_taskgroup = task;\n-\t      task->prev_taskgroup = task;\n-\t    }\n-\t  taskgroup->children = task;\n-\t}\n-      if (team->task_queue)\n-\t{\n-\t  task->next_queue = team->task_queue;\n-\t  task->prev_queue = team->task_queue->prev_queue;\n-\t  task->next_queue->prev_queue = task;\n-\t  task->prev_queue->next_queue = task;\n-\t}\n-      else\n-\t{\n-\t  task->next_queue = task;\n-\t  task->prev_queue = task;\n-\t  team->task_queue = task;\n-\t}\n+\tpriority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t       task, priority,\n+\t\t\t       PRIORITY_INSERT_BEGIN,\n+\t\t\t       /*adjust_parent_depends_on=*/false,\n+\t\t\t       task->parent_depends_on);\n+\n+      priority_queue_insert (PQ_TEAM, &team->task_queue,\n+\t\t\t     task, priority,\n+\t\t\t     PRIORITY_INSERT_END,\n+\t\t\t     /*adjust_parent_depends_on=*/false,\n+\t\t\t     task->parent_depends_on);\n+\n       ++team->task_count;\n       ++team->task_queued_count;\n       gomp_team_barrier_set_task_pending (&team->barrier);\n@@ -445,13 +480,119 @@ ialias (GOMP_taskgroup_end)\n #undef UTYPE\n #undef GOMP_taskloop\n \n-/* Called for nowait target tasks.  */\n+static void inline\n+priority_queue_move_task_first (enum priority_queue_type type,\n+\t\t\t\tstruct priority_queue *head,\n+\t\t\t\tstruct gomp_task *task)\n+{\n+#if _LIBGOMP_CHECKING_\n+  if (!priority_queue_task_in_queue_p (type, head, task))\n+    gomp_fatal (\"Attempt to move first missing task %p\", task);\n+#endif\n+  struct priority_list *list;\n+  if (priority_queue_multi_p (head))\n+    {\n+      list = priority_queue_lookup_priority (head, task->priority);\n+#if _LIBGOMP_CHECKING_\n+      if (!list)\n+\tgomp_fatal (\"Unable to find priority %d\", task->priority);\n+#endif\n+    }\n+  else\n+    list = &head->l;\n+  priority_list_remove (list, task_to_priority_node (type, task), 0);\n+  priority_list_insert (type, list, task, task->priority,\n+\t\t\tPRIORITY_INSERT_BEGIN, type == PQ_CHILDREN,\n+\t\t\ttask->parent_depends_on);\n+}\n+\n+/* Actual body of GOMP_PLUGIN_target_task_completion that is executed\n+   with team->task_lock held, or is executed in the thread that called\n+   gomp_target_task_fn if GOMP_PLUGIN_target_task_completion has been\n+   run before it acquires team->task_lock.  */\n+\n+static void\n+gomp_target_task_completion (struct gomp_team *team, struct gomp_task *task)\n+{\n+  struct gomp_task *parent = task->parent;\n+  if (parent)\n+    priority_queue_move_task_first (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t\t    task);\n+\n+  struct gomp_taskgroup *taskgroup = task->taskgroup;\n+  if (taskgroup)\n+    priority_queue_move_task_first (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t\t    task);\n+\n+  priority_queue_insert (PQ_TEAM, &team->task_queue, task, task->priority,\n+\t\t\t PRIORITY_INSERT_BEGIN, false,\n+\t\t\t task->parent_depends_on);\n+  task->kind = GOMP_TASK_WAITING;\n+  if (parent && parent->taskwait)\n+    {\n+      if (parent->taskwait->in_taskwait)\n+\t{\n+\t  /* One more task has had its dependencies met.\n+\t     Inform any waiters.  */\n+\t  parent->taskwait->in_taskwait = false;\n+\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n+\t}\n+      else if (parent->taskwait->in_depend_wait)\n+\t{\n+\t  /* One more task has had its dependencies met.\n+\t     Inform any waiters.  */\n+\t  parent->taskwait->in_depend_wait = false;\n+\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n+\t}\n+    }\n+  if (taskgroup && taskgroup->in_taskgroup_wait)\n+    {\n+      /* One more task has had its dependencies met.\n+\t Inform any waiters.  */\n+      taskgroup->in_taskgroup_wait = false;\n+      gomp_sem_post (&taskgroup->taskgroup_sem);\n+    }\n+\n+  ++team->task_queued_count;\n+  gomp_team_barrier_set_task_pending (&team->barrier);\n+  /* I'm afraid this can't be done after releasing team->task_lock,\n+     as gomp_target_task_completion is run from unrelated thread and\n+     therefore in between gomp_mutex_unlock and gomp_team_barrier_wake\n+     the team could be gone already.  */\n+  if (team->nthreads > team->task_running_count)\n+    gomp_team_barrier_wake (&team->barrier, 1);\n+}\n+\n+/* Signal that a target task TTASK has completed the asynchronously\n+   running phase and should be requeued as a task to handle the\n+   variable unmapping.  */\n \n void\n+GOMP_PLUGIN_target_task_completion (void *data)\n+{\n+  struct gomp_target_task *ttask = (struct gomp_target_task *) data;\n+  struct gomp_task *task = ttask->task;\n+  struct gomp_team *team = ttask->team;\n+\n+  gomp_mutex_lock (&team->task_lock);\n+  if (ttask->state == GOMP_TARGET_TASK_READY_TO_RUN)\n+    {\n+      ttask->state = GOMP_TARGET_TASK_FINISHED;\n+      gomp_mutex_unlock (&team->task_lock);\n+    }\n+  ttask->state = GOMP_TARGET_TASK_FINISHED;\n+  gomp_target_task_completion (team, task);\n+  gomp_mutex_unlock (&team->task_lock);\n+}\n+\n+/* Called for nowait target tasks.  */\n+\n+bool\n gomp_create_target_task (struct gomp_device_descr *devicep,\n \t\t\t void (*fn) (void *), size_t mapnum, void **hostaddrs,\n \t\t\t size_t *sizes, unsigned short *kinds,\n-\t\t\t unsigned int flags, void **depend)\n+\t\t\t unsigned int flags, void **depend,\n+\t\t\t enum gomp_target_task_state state)\n {\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n@@ -460,27 +601,53 @@ gomp_create_target_task (struct gomp_device_descr *devicep,\n   if (team\n       && (gomp_team_barrier_cancelled (&team->barrier)\n \t  || (thr->task->taskgroup && thr->task->taskgroup->cancelled)))\n-    return;\n+    return true;\n \n   struct gomp_target_task *ttask;\n   struct gomp_task *task;\n   struct gomp_task *parent = thr->task;\n   struct gomp_taskgroup *taskgroup = parent->taskgroup;\n   bool do_wake;\n   size_t depend_size = 0;\n+  uintptr_t depend_cnt = 0;\n+  size_t tgt_align = 0, tgt_size = 0;\n \n   if (depend != NULL)\n-    depend_size = ((uintptr_t) depend[0]\n-\t\t   * sizeof (struct gomp_task_depend_entry));\n+    {\n+      depend_cnt = (uintptr_t) depend[0];\n+      depend_size = depend_cnt * sizeof (struct gomp_task_depend_entry);\n+    }\n+  if (fn)\n+    {\n+      /* GOMP_MAP_FIRSTPRIVATE need to be copied first, as they are\n+\t firstprivate on the target task.  */\n+      size_t i;\n+      for (i = 0; i < mapnum; i++)\n+\tif ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n+\t  {\n+\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t    if (tgt_align < align)\n+\t      tgt_align = align;\n+\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t    tgt_size += sizes[i];\n+\t  }\n+      if (tgt_align)\n+\ttgt_size += tgt_align - 1;\n+      else\n+\ttgt_size = 0;\n+    }\n+\n   task = gomp_malloc (sizeof (*task) + depend_size\n \t\t      + sizeof (*ttask)\n \t\t      + mapnum * (sizeof (void *) + sizeof (size_t)\n-\t\t\t\t  + sizeof (unsigned short)));\n+\t\t\t\t  + sizeof (unsigned short))\n+\t\t      + tgt_size);\n   gomp_init_task (task, parent, gomp_icv (false));\n+  task->priority = 0;\n   task->kind = GOMP_TASK_WAITING;\n   task->in_tied_task = parent->in_tied_task;\n   task->taskgroup = taskgroup;\n-  ttask = (struct gomp_target_task *) &task->depend[(uintptr_t) depend[0]];\n+  ttask = (struct gomp_target_task *) &task->depend[depend_cnt];\n   ttask->devicep = devicep;\n   ttask->fn = fn;\n   ttask->mapnum = mapnum;\n@@ -489,8 +656,29 @@ gomp_create_target_task (struct gomp_device_descr *devicep,\n   memcpy (ttask->sizes, sizes, mapnum * sizeof (size_t));\n   ttask->kinds = (unsigned short *) &ttask->sizes[mapnum];\n   memcpy (ttask->kinds, kinds, mapnum * sizeof (unsigned short));\n+  if (tgt_align)\n+    {\n+      char *tgt = (char *) &ttask->kinds[mapnum];\n+      size_t i;\n+      uintptr_t al = (uintptr_t) tgt & (tgt_align - 1);\n+      if (al)\n+\ttgt += tgt_align - al;\n+      tgt_size = 0;\n+      for (i = 0; i < mapnum; i++)\n+\tif ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n+\t  {\n+\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t    memcpy (tgt + tgt_size, hostaddrs[i], sizes[i]);\n+\t    ttask->hostaddrs[i] = tgt + tgt_size;\n+\t    tgt_size = tgt_size + sizes[i];\n+\t  }\n+    }\n   ttask->flags = flags;\n-  task->fn = gomp_target_task_fn;\n+  ttask->state = state;\n+  ttask->task = task;\n+  ttask->team = team;\n+  task->fn = NULL;\n   task->fn_data = ttask;\n   task->final_task = 0;\n   gomp_mutex_lock (&team->task_lock);\n@@ -501,62 +689,78 @@ gomp_create_target_task (struct gomp_device_descr *devicep,\n       gomp_mutex_unlock (&team->task_lock);\n       gomp_finish_task (task);\n       free (task);\n-      return;\n+      return true;\n     }\n-  if (taskgroup)\n-    taskgroup->num_children++;\n   if (depend_size)\n     {\n       gomp_task_handle_depend (task, parent, depend);\n       if (task->num_dependees)\n \t{\n+\t  if (taskgroup)\n+\t    taskgroup->num_children++;\n \t  gomp_mutex_unlock (&team->task_lock);\n-\t  return;\n+\t  return true;\n \t}\n     }\n-  if (parent->children)\n-    {\n-      task->next_child = parent->children;\n-      task->prev_child = parent->children->prev_child;\n-      task->next_child->prev_child = task;\n-      task->prev_child->next_child = task;\n-    }\n-  else\n+  if (state == GOMP_TARGET_TASK_DATA)\n     {\n-      task->next_child = task;\n-      task->prev_child = task;\n+      gomp_mutex_unlock (&team->task_lock);\n+      gomp_finish_task (task);\n+      free (task);\n+      return false;\n     }\n-  parent->children = task;\n   if (taskgroup)\n+    taskgroup->num_children++;\n+  /* For async offloading, if we don't need to wait for dependencies,\n+     run the gomp_target_task_fn right away, essentially schedule the\n+     mapping part of the task in the current thread.  */\n+  if (devicep != NULL\n+      && (devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n     {\n-      /* If applicable, place task into its taskgroup.  */\n-      if (taskgroup->children)\n-\t{\n-\t  task->next_taskgroup = taskgroup->children;\n-\t  task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n-\t  task->next_taskgroup->prev_taskgroup = task;\n-\t  task->prev_taskgroup->next_taskgroup = task;\n-\t}\n+      priority_queue_insert (PQ_CHILDREN, &parent->children_queue, task, 0,\n+\t\t\t     PRIORITY_INSERT_END,\n+\t\t\t     /*adjust_parent_depends_on=*/false,\n+\t\t\t     task->parent_depends_on);\n+      if (taskgroup)\n+\tpriority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t       task, 0, PRIORITY_INSERT_END,\n+\t\t\t       /*adjust_parent_depends_on=*/false,\n+\t\t\t       task->parent_depends_on);\n+      task->pnode[PQ_TEAM].next = NULL;\n+      task->pnode[PQ_TEAM].prev = NULL;\n+      task->kind = GOMP_TASK_TIED;\n+      ++team->task_count;\n+      gomp_mutex_unlock (&team->task_lock);\n+\n+      thr->task = task;\n+      gomp_target_task_fn (task->fn_data);\n+      thr->task = parent;\n+\n+      gomp_mutex_lock (&team->task_lock);\n+      task->kind = GOMP_TASK_ASYNC_RUNNING;\n+      /* If GOMP_PLUGIN_target_task_completion has run already\n+\t in between gomp_target_task_fn and the mutex lock,\n+\t perform the requeuing here.  */\n+      if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\tgomp_target_task_completion (team, task);\n       else\n-\t{\n-\t  task->next_taskgroup = task;\n-\t  task->prev_taskgroup = task;\n-\t}\n-      taskgroup->children = task;\n-    }\n-  if (team->task_queue)\n-    {\n-      task->next_queue = team->task_queue;\n-      task->prev_queue = team->task_queue->prev_queue;\n-      task->next_queue->prev_queue = task;\n-      task->prev_queue->next_queue = task;\n-    }\n-  else\n-    {\n-      task->next_queue = task;\n-      task->prev_queue = task;\n-      team->task_queue = task;\n+\tttask->state = GOMP_TARGET_TASK_RUNNING;\n+      gomp_mutex_unlock (&team->task_lock);\n+      return true;\n     }\n+  priority_queue_insert (PQ_CHILDREN, &parent->children_queue, task, 0,\n+\t\t\t PRIORITY_INSERT_BEGIN,\n+\t\t\t /*adjust_parent_depends_on=*/false,\n+\t\t\t task->parent_depends_on);\n+  if (taskgroup)\n+    priority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue, task, 0,\n+\t\t\t   PRIORITY_INSERT_BEGIN,\n+\t\t\t   /*adjust_parent_depends_on=*/false,\n+\t\t\t   task->parent_depends_on);\n+  priority_queue_insert (PQ_TEAM, &team->task_queue, task, 0,\n+\t\t\t PRIORITY_INSERT_END,\n+\t\t\t /*adjust_parent_depends_on=*/false,\n+\t\t\t task->parent_depends_on);\n   ++team->task_count;\n   ++team->task_queued_count;\n   gomp_team_barrier_set_task_pending (&team->barrier);\n@@ -565,210 +769,214 @@ gomp_create_target_task (struct gomp_device_descr *devicep,\n   gomp_mutex_unlock (&team->task_lock);\n   if (do_wake)\n     gomp_team_barrier_wake (&team->barrier, 1);\n+  return true;\n }\n \n-#if _LIBGOMP_CHECKING\n-/* Sanity check TASK to make sure it is in its parent's children\n-   queue, and that the tasks therein are in the right order.\n+/* Given a parent_depends_on task in LIST, move it to the front of its\n+   priority so it is run as soon as possible.\n \n-   The expected order is:\n-\tparent_depends_on WAITING tasks\n-\t!parent_depends_on WAITING tasks\n-\tTIED tasks\n+   Care is taken to update the list's LAST_PARENT_DEPENDS_ON field.\n \n-   PARENT is the alleged parent of TASK.  */\n+   We rearrange the queue such that all parent_depends_on tasks are\n+   first, and last_parent_depends_on points to the last such task we\n+   rearranged.  For example, given the following tasks in a queue\n+   where PD[123] are the parent_depends_on tasks:\n \n-static void\n-verify_children_queue (struct gomp_task *task, struct gomp_task *parent)\n-{\n-  if (task->parent != parent)\n-    gomp_fatal (\"verify_children_queue: incompatible parents\");\n-  /* It's OK, Annie was an orphan and she turned out all right.  */\n-  if (!parent)\n-    return;\n+\ttask->children\n+\t|\n+\tV\n+\tC1 -> C2 -> C3 -> PD1 -> PD2 -> PD3 -> C4\n \n-  bool seen_tied = false;\n-  bool seen_plain_waiting = false;\n-  bool found = false;\n-  struct gomp_task *t = parent->children;\n-  while (1)\n+\tWe rearrange such that:\n+\n+\ttask->children\n+\t|\t       +--- last_parent_depends_on\n+\t|\t       |\n+\tV\t       V\n+\tPD1 -> PD2 -> PD3 -> C1 -> C2 -> C3 -> C4.  */\n+\n+static void inline\n+priority_list_upgrade_task (struct priority_list *list,\n+\t\t\t    struct priority_node *node)\n+{\n+  struct priority_node *last_parent_depends_on\n+    = list->last_parent_depends_on;\n+  if (last_parent_depends_on)\n     {\n-      if (t == task)\n-\tfound = true;\n-      if (seen_tied && t->kind == GOMP_TASK_WAITING)\n-\tgomp_fatal (\"verify_children_queue: WAITING task after TIED\");\n-      if (t->kind == GOMP_TASK_TIED)\n-\tseen_tied = true;\n-      else if (t->kind == GOMP_TASK_WAITING)\n-\t{\n-\t  if (t->parent_depends_on)\n-\t    {\n-\t      if (seen_plain_waiting)\n-\t\tgomp_fatal (\"verify_children_queue: parent_depends_on after \"\n-\t\t\t    \"!parent_depends_on\");\n-\t    }\n-\t  else\n-\t    seen_plain_waiting = true;\n-\t}\n-      t = t->next_child;\n-      if (t == parent->children)\n-\tbreak;\n+      node->prev->next = node->next;\n+      node->next->prev = node->prev;\n+      node->prev = last_parent_depends_on;\n+      node->next = last_parent_depends_on->next;\n+      node->prev->next = node;\n+      node->next->prev = node;\n     }\n-  if (!found)\n-    gomp_fatal (\"verify_children_queue: child not found in parent queue\");\n+  else if (node != list->tasks)\n+    {\n+      node->prev->next = node->next;\n+      node->next->prev = node->prev;\n+      node->prev = list->tasks->prev;\n+      node->next = list->tasks;\n+      list->tasks = node;\n+      node->prev->next = node;\n+      node->next->prev = node;\n+    }\n+  list->last_parent_depends_on = node;\n }\n \n-/* Sanity check TASK to make sure it is in its taskgroup queue (if\n-   applicable), and that the tasks therein are in the right order.\n+/* Given a parent_depends_on TASK in its parent's children_queue, move\n+   it to the front of its priority so it is run as soon as possible.\n \n-   The expected order is that GOMP_TASK_WAITING tasks must come before\n-   GOMP_TASK_TIED tasks.\n+   PARENT is passed as an optimization.\n \n-   TASK is the task.  */\n+   (This function could be defined in priority_queue.c, but we want it\n+   inlined, and putting it in priority_queue.h is not an option, given\n+   that gomp_task has not been properly defined at that point).  */\n \n-static void\n-verify_taskgroup_queue (struct gomp_task *task)\n+static void inline\n+priority_queue_upgrade_task (struct gomp_task *task,\n+\t\t\t     struct gomp_task *parent)\n {\n-  struct gomp_taskgroup *taskgroup = task->taskgroup;\n-  if (!taskgroup)\n-    return;\n-\n-  bool seen_tied = false;\n-  bool found = false;\n-  struct gomp_task *t = taskgroup->children;\n-  while (1)\n+  struct priority_queue *head = &parent->children_queue;\n+  struct priority_node *node = &task->pnode[PQ_CHILDREN];\n+#if _LIBGOMP_CHECKING_\n+  if (!task->parent_depends_on)\n+    gomp_fatal (\"priority_queue_upgrade_task: task must be a \"\n+\t\t\"parent_depends_on task\");\n+  if (!priority_queue_task_in_queue_p (PQ_CHILDREN, head, task))\n+    gomp_fatal (\"priority_queue_upgrade_task: cannot find task=%p\", task);\n+#endif\n+  if (priority_queue_multi_p (head))\n     {\n-      if (t == task)\n-\tfound = true;\n-      if (t->kind == GOMP_TASK_WAITING && seen_tied)\n-\tgomp_fatal (\"verify_taskgroup_queue: WAITING task after TIED\");\n-      if (t->kind == GOMP_TASK_TIED)\n-\tseen_tied = true;\n-      t = t->next_taskgroup;\n-      if (t == taskgroup->children)\n-\tbreak;\n+      struct priority_list *list\n+\t= priority_queue_lookup_priority (head, task->priority);\n+      priority_list_upgrade_task (list, node);\n     }\n-  if (!found)\n-    gomp_fatal (\"verify_taskgroup_queue: child not found in parent queue\");\n+  else\n+    priority_list_upgrade_task (&head->l, node);\n }\n \n-/* Verify that TASK is in the team's task queue.  */\n+/* Given a CHILD_TASK in LIST that is about to be executed, move it out of\n+   the way in LIST so that other tasks can be considered for\n+   execution.  LIST contains tasks of type TYPE.\n \n-static void\n-verify_task_queue (struct gomp_task *task, struct gomp_team *team)\n+   Care is taken to update the queue's LAST_PARENT_DEPENDS_ON field\n+   if applicable.  */\n+\n+static void inline\n+priority_list_downgrade_task (enum priority_queue_type type,\n+\t\t\t      struct priority_list *list,\n+\t\t\t      struct gomp_task *child_task)\n {\n-  struct gomp_task *t = team->task_queue;\n-  if (team)\n-    while (1)\n-      {\n-\tif (t == task)\n-\t  return;\n-\tt = t->next_queue;\n-\tif (t == team->task_queue)\n-\t  break;\n-      }\n-  gomp_fatal (\"verify_team_queue: child not in team\");\n+  struct priority_node *node = task_to_priority_node (type, child_task);\n+  if (list->tasks == node)\n+    list->tasks = node->next;\n+  else if (node->next != list->tasks)\n+    {\n+      /* The task in NODE is about to become TIED and TIED tasks\n+\t cannot come before WAITING tasks.  If we're about to\n+\t leave the queue in such an indeterminate state, rewire\n+\t things appropriately.  However, a TIED task at the end is\n+\t perfectly fine.  */\n+      struct gomp_task *next_task = priority_node_to_task (type, node->next);\n+      if (next_task->kind == GOMP_TASK_WAITING)\n+\t{\n+\t  /* Remove from list.  */\n+\t  node->prev->next = node->next;\n+\t  node->next->prev = node->prev;\n+\t  /* Rewire at the end.  */\n+\t  node->next = list->tasks;\n+\t  node->prev = list->tasks->prev;\n+\t  list->tasks->prev->next = node;\n+\t  list->tasks->prev = node;\n+\t}\n+    }\n+\n+  /* If the current task is the last_parent_depends_on for its\n+     priority, adjust last_parent_depends_on appropriately.  */\n+  if (__builtin_expect (child_task->parent_depends_on, 0)\n+      && list->last_parent_depends_on == node)\n+    {\n+      struct gomp_task *prev_child = priority_node_to_task (type, node->prev);\n+      if (node->prev != node\n+\t  && prev_child->kind == GOMP_TASK_WAITING\n+\t  && prev_child->parent_depends_on)\n+\tlist->last_parent_depends_on = node->prev;\n+      else\n+\t{\n+\t  /* There are no more parent_depends_on entries waiting\n+\t     to run, clear the list.  */\n+\t  list->last_parent_depends_on = NULL;\n+\t}\n+    }\n }\n+\n+/* Given a TASK in HEAD that is about to be executed, move it out of\n+   the way so that other tasks can be considered for execution.  HEAD\n+   contains tasks of type TYPE.\n+\n+   Care is taken to update the queue's LAST_PARENT_DEPENDS_ON field\n+   if applicable.\n+\n+   (This function could be defined in priority_queue.c, but we want it\n+   inlined, and putting it in priority_queue.h is not an option, given\n+   that gomp_task has not been properly defined at that point).  */\n+\n+static void inline\n+priority_queue_downgrade_task (enum priority_queue_type type,\n+\t\t\t       struct priority_queue *head,\n+\t\t\t       struct gomp_task *task)\n+{\n+#if _LIBGOMP_CHECKING_\n+  if (!priority_queue_task_in_queue_p (type, head, task))\n+    gomp_fatal (\"Attempt to downgrade missing task %p\", task);\n #endif\n+  if (priority_queue_multi_p (head))\n+    {\n+      struct priority_list *list\n+\t= priority_queue_lookup_priority (head, task->priority);\n+      priority_list_downgrade_task (type, list, task);\n+    }\n+  else\n+    priority_list_downgrade_task (type, &head->l, task);\n+}\n+\n+/* Setup CHILD_TASK to execute.  This is done by setting the task to\n+   TIED, and updating all relevant queues so that CHILD_TASK is no\n+   longer chosen for scheduling.  Also, remove CHILD_TASK from the\n+   overall team task queue entirely.\n+\n+   Return TRUE if task or its containing taskgroup has been\n+   cancelled.  */\n \n static inline bool\n gomp_task_run_pre (struct gomp_task *child_task, struct gomp_task *parent,\n \t\t   struct gomp_team *team)\n {\n-#if _LIBGOMP_CHECKING\n-  verify_children_queue (child_task, parent);\n-  verify_taskgroup_queue (child_task);\n-  verify_task_queue (child_task, team);\n+#if _LIBGOMP_CHECKING_\n+  if (child_task->parent)\n+    priority_queue_verify (PQ_CHILDREN,\n+\t\t\t   &child_task->parent->children_queue, true);\n+  if (child_task->taskgroup)\n+    priority_queue_verify (PQ_TASKGROUP,\n+\t\t\t   &child_task->taskgroup->taskgroup_queue, false);\n+  priority_queue_verify (PQ_TEAM, &team->task_queue, false);\n #endif\n \n+  /* Task is about to go tied, move it out of the way.  */\n   if (parent)\n-    {\n-      /* Adjust children such that it will point to a next child,\n-\t while the current one is scheduled to be executed.  This way,\n-\t GOMP_taskwait (and others) can schedule a next task while\n-\t waiting.\n-\n-\t Do not remove it entirely from the circular list, as it is\n-\t still a child, though not one we should consider first (say\n-\t by GOMP_taskwait).  */\n-      if (parent->children == child_task)\n-\tparent->children = child_task->next_child;\n-      /* TIED tasks cannot come before WAITING tasks.  If we're about\n-\t to make this task TIED, rewire things appropriately.\n-\t However, a TIED task at the end is perfectly fine.  */\n-      else if (child_task->next_child->kind == GOMP_TASK_WAITING\n-\t       && child_task->next_child != parent->children)\n-\t{\n-\t  /* Remove from the list.  */\n-\t  child_task->prev_child->next_child = child_task->next_child;\n-\t  child_task->next_child->prev_child = child_task->prev_child;\n-\t  /* Rewire at the end of its siblings.  */\n-\t  child_task->next_child = parent->children;\n-\t  child_task->prev_child = parent->children->prev_child;\n-\t  parent->children->prev_child->next_child = child_task;\n-\t  parent->children->prev_child = child_task;\n-\t}\n+    priority_queue_downgrade_task (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t\t   child_task);\n \n-      /* If the current task (child_task) is at the top of the\n-\t parent's last_parent_depends_on, it's about to be removed\n-\t from it.  Adjust last_parent_depends_on appropriately.  */\n-      if (__builtin_expect (child_task->parent_depends_on, 0)\n-\t  && parent->taskwait->last_parent_depends_on == child_task)\n-\t{\n-\t  /* The last_parent_depends_on list was built with all\n-\t     parent_depends_on entries linked to the prev_child.  Grab\n-\t     the next last_parent_depends_on head from this prev_child if\n-\t     available...  */\n-\t  if (child_task->prev_child->kind == GOMP_TASK_WAITING\n-\t      && child_task->prev_child->parent_depends_on)\n-\t    parent->taskwait->last_parent_depends_on = child_task->prev_child;\n-\t  else\n-\t    {\n-\t      /* ...otherwise, there are no more parent_depends_on\n-\t\t entries waiting to run.  In which case, clear the\n-\t\t list.  */\n-\t      parent->taskwait->last_parent_depends_on = NULL;\n-\t    }\n-\t}\n-    }\n-\n-  /* Adjust taskgroup to point to the next taskgroup.  See note above\n-     regarding adjustment of children as to why the child_task is not\n-     removed entirely from the circular list.  */\n+  /* Task is about to go tied, move it out of the way.  */\n   struct gomp_taskgroup *taskgroup = child_task->taskgroup;\n   if (taskgroup)\n-    {\n-      if (taskgroup->children == child_task)\n-\ttaskgroup->children = child_task->next_taskgroup;\n-      /* TIED tasks cannot come before WAITING tasks.  If we're about\n-\t to make this task TIED, rewire things appropriately.\n-\t However, a TIED task at the end is perfectly fine.  */\n-      else if (child_task->next_taskgroup->kind == GOMP_TASK_WAITING\n-\t       && child_task->next_taskgroup != taskgroup->children)\n-\t{\n-\t  /* Remove from the list.  */\n-\t  child_task->prev_taskgroup->next_taskgroup\n-\t    = child_task->next_taskgroup;\n-\t  child_task->next_taskgroup->prev_taskgroup\n-\t    = child_task->prev_taskgroup;\n-\t  /* Rewire at the end of its taskgroup.  */\n-\t  child_task->next_taskgroup = taskgroup->children;\n-\t  child_task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n-\t  taskgroup->children->prev_taskgroup->next_taskgroup = child_task;\n-\t  taskgroup->children->prev_taskgroup = child_task;\n-\t}\n-    }\n+    priority_queue_downgrade_task (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t\t   child_task);\n \n-  /* Remove child_task from the task_queue.  */\n-  child_task->prev_queue->next_queue = child_task->next_queue;\n-  child_task->next_queue->prev_queue = child_task->prev_queue;\n-  if (team->task_queue == child_task)\n-    {\n-      if (child_task->next_queue != child_task)\n-\tteam->task_queue = child_task->next_queue;\n-      else\n-\tteam->task_queue = NULL;\n-    }\n+  priority_queue_remove (PQ_TEAM, &team->task_queue, child_task,\n+\t\t\t MEMMODEL_RELAXED);\n+  child_task->pnode[PQ_TEAM].next = NULL;\n+  child_task->pnode[PQ_TEAM].prev = NULL;\n   child_task->kind = GOMP_TASK_TIED;\n \n   if (--team->task_queued_count == 0)\n@@ -808,8 +1016,11 @@ gomp_task_run_post_handle_depend_hash (struct gomp_task *child_task)\n       }\n }\n \n-/* After CHILD_TASK has been run, adjust the various task queues to\n-   give higher priority to the tasks that depend on CHILD_TASK.\n+/* After a CHILD_TASK has been run, adjust the dependency queue for\n+   each task that depends on CHILD_TASK, to record the fact that there\n+   is one less dependency to worry about.  If a task that depended on\n+   CHILD_TASK now has no dependencies, place it in the various queues\n+   so it gets scheduled to run.\n \n    TEAM is the team to which CHILD_TASK belongs to.  */\n \n@@ -822,99 +1033,60 @@ gomp_task_run_post_handle_dependers (struct gomp_task *child_task,\n   for (i = 0; i < count; i++)\n     {\n       struct gomp_task *task = child_task->dependers->elem[i];\n+\n+      /* CHILD_TASK satisfies a dependency for TASK.  Keep track of\n+\t TASK's remaining dependencies.  Once TASK has no other\n+\t depenencies, put it into the various queues so it will get\n+\t scheduled for execution.  */\n       if (--task->num_dependees != 0)\n \tcontinue;\n \n       struct gomp_taskgroup *taskgroup = task->taskgroup;\n       if (parent)\n \t{\n-\t  if (parent->children)\n-\t    {\n-\t      /* If parent is in gomp_task_maybe_wait_for_dependencies\n-\t\t and it doesn't need to wait for this task, put it after\n-\t\t all ready to run tasks it needs to wait for.  */\n-\t      if (parent->taskwait && parent->taskwait->last_parent_depends_on\n-\t\t  && !task->parent_depends_on)\n-\t\t{\n-\t\t  /* Put depender in last_parent_depends_on.  */\n-\t\t  struct gomp_task *last_parent_depends_on\n-\t\t    = parent->taskwait->last_parent_depends_on;\n-\t\t  task->next_child = last_parent_depends_on->next_child;\n-\t\t  task->prev_child = last_parent_depends_on;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Make depender a sibling of child_task, and place\n-\t\t     it at the top of said sibling list.  */\n-\t\t  task->next_child = parent->children;\n-\t\t  task->prev_child = parent->children->prev_child;\n-\t\t  parent->children = task;\n-\t\t}\n-\t      task->next_child->prev_child = task;\n-\t      task->prev_child->next_child = task;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Make depender a sibling of child_task.  */\n-\t      task->next_child = task;\n-\t      task->prev_child = task;\n-\t      parent->children = task;\n-\t    }\n+\t  priority_queue_insert (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t\t task, task->priority,\n+\t\t\t\t PRIORITY_INSERT_BEGIN,\n+\t\t\t\t /*adjust_parent_depends_on=*/true,\n+\t\t\t\t task->parent_depends_on);\n \t  if (parent->taskwait)\n \t    {\n \t      if (parent->taskwait->in_taskwait)\n \t\t{\n+\t\t  /* One more task has had its dependencies met.\n+\t\t     Inform any waiters.  */\n \t\t  parent->taskwait->in_taskwait = false;\n \t\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n \t\t}\n \t      else if (parent->taskwait->in_depend_wait)\n \t\t{\n+\t\t  /* One more task has had its dependencies met.\n+\t\t     Inform any waiters.  */\n \t\t  parent->taskwait->in_depend_wait = false;\n \t\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n \t\t}\n-\t      if (parent->taskwait->last_parent_depends_on == NULL\n-\t\t  && task->parent_depends_on)\n-\t\tparent->taskwait->last_parent_depends_on = task;\n \t    }\n \t}\n-      /* If depender is in a taskgroup, put it at the TOP of its\n-\t taskgroup.  */\n       if (taskgroup)\n \t{\n-\t  if (taskgroup->children)\n-\t    {\n-\t      task->next_taskgroup = taskgroup->children;\n-\t      task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n-\t      task->next_taskgroup->prev_taskgroup = task;\n-\t      task->prev_taskgroup->next_taskgroup = task;\n-\t    }\n-\t  else\n-\t    {\n-\t      task->next_taskgroup = task;\n-\t      task->prev_taskgroup = task;\n-\t    }\n-\t  taskgroup->children = task;\n+\t  priority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t\t task, task->priority,\n+\t\t\t\t PRIORITY_INSERT_BEGIN,\n+\t\t\t\t /*adjust_parent_depends_on=*/false,\n+\t\t\t\t task->parent_depends_on);\n \t  if (taskgroup->in_taskgroup_wait)\n \t    {\n+\t      /* One more task has had its dependencies met.\n+\t\t Inform any waiters.  */\n \t      taskgroup->in_taskgroup_wait = false;\n \t      gomp_sem_post (&taskgroup->taskgroup_sem);\n \t    }\n \t}\n-      /* Put depender of child_task at the END of the team's\n-\t task_queue.  */\n-      if (team->task_queue)\n-\t{\n-\t  task->next_queue = team->task_queue;\n-\t  task->prev_queue = team->task_queue->prev_queue;\n-\t  task->next_queue->prev_queue = task;\n-\t  task->prev_queue->next_queue = task;\n-\t}\n-      else\n-\t{\n-\t  task->next_queue = task;\n-\t  task->prev_queue = task;\n-\t  team->task_queue = task;\n-\t}\n+      priority_queue_insert (PQ_TEAM, &team->task_queue,\n+\t\t\t     task, task->priority,\n+\t\t\t     PRIORITY_INSERT_END,\n+\t\t\t     /*adjust_parent_depends_on=*/false,\n+\t\t\t     task->parent_depends_on);\n       ++team->task_count;\n       ++team->task_queued_count;\n       ++ret;\n@@ -964,27 +1136,15 @@ gomp_task_run_post_remove_parent (struct gomp_task *child_task)\n       gomp_sem_post (&parent->taskwait->taskwait_sem);\n     }\n \n-  /* Remove CHILD_TASK from its sibling list.  */\n-  child_task->prev_child->next_child = child_task->next_child;\n-  child_task->next_child->prev_child = child_task->prev_child;\n-  if (parent->children != child_task)\n-    return;\n-  if (child_task->next_child != child_task)\n-    parent->children = child_task->next_child;\n-  else\n+  if (priority_queue_remove (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t     child_task, MEMMODEL_RELEASE)\n+      && parent->taskwait && parent->taskwait->in_taskwait)\n     {\n-      /* We access task->children in GOMP_taskwait\n-\t outside of the task lock mutex region, so\n-\t need a release barrier here to ensure memory\n-\t written by child_task->fn above is flushed\n-\t before the NULL is written.  */\n-      __atomic_store_n (&parent->children, NULL, MEMMODEL_RELEASE);\n-      if (parent->taskwait && parent->taskwait->in_taskwait)\n-\t{\n-\t  parent->taskwait->in_taskwait = false;\n-\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n-\t}\n+      parent->taskwait->in_taskwait = false;\n+      gomp_sem_post (&parent->taskwait->taskwait_sem);\n     }\n+  child_task->pnode[PQ_CHILDREN].next = NULL;\n+  child_task->pnode[PQ_CHILDREN].prev = NULL;\n }\n \n /* Remove CHILD_TASK from its taskgroup.  */\n@@ -995,8 +1155,11 @@ gomp_task_run_post_remove_taskgroup (struct gomp_task *child_task)\n   struct gomp_taskgroup *taskgroup = child_task->taskgroup;\n   if (taskgroup == NULL)\n     return;\n-  child_task->prev_taskgroup->next_taskgroup = child_task->next_taskgroup;\n-  child_task->next_taskgroup->prev_taskgroup = child_task->prev_taskgroup;\n+  bool empty = priority_queue_remove (PQ_TASKGROUP,\n+\t\t\t\t      &taskgroup->taskgroup_queue,\n+\t\t\t\t      child_task, MEMMODEL_RELAXED);\n+  child_task->pnode[PQ_TASKGROUP].next = NULL;\n+  child_task->pnode[PQ_TASKGROUP].prev = NULL;\n   if (taskgroup->num_children > 1)\n     --taskgroup->num_children;\n   else\n@@ -1008,18 +1171,10 @@ gomp_task_run_post_remove_taskgroup (struct gomp_task *child_task)\n \t before the NULL is written.  */\n       __atomic_store_n (&taskgroup->num_children, 0, MEMMODEL_RELEASE);\n     }\n-  if (taskgroup->children != child_task)\n-    return;\n-  if (child_task->next_taskgroup != child_task)\n-    taskgroup->children = child_task->next_taskgroup;\n-  else\n+  if (empty && taskgroup->in_taskgroup_wait)\n     {\n-      taskgroup->children = NULL;\n-      if (taskgroup->in_taskgroup_wait)\n-\t{\n-\t  taskgroup->in_taskgroup_wait = false;\n-\t  gomp_sem_post (&taskgroup->taskgroup_sem);\n-\t}\n+      taskgroup->in_taskgroup_wait = false;\n+      gomp_sem_post (&taskgroup->taskgroup_sem);\n     }\n }\n \n@@ -1049,9 +1204,13 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n   while (1)\n     {\n       bool cancelled = false;\n-      if (team->task_queue != NULL)\n+      if (!priority_queue_empty_p (&team->task_queue, MEMMODEL_RELAXED))\n \t{\n-\t  child_task = team->task_queue;\n+\t  bool ignored;\n+\t  child_task\n+\t    = priority_queue_next_task (PQ_TEAM, &team->task_queue,\n+\t\t\t\t\tPQ_IGNORED, NULL,\n+\t\t\t\t\t&ignored);\n \t  cancelled = gomp_task_run_pre (child_task, child_task->parent,\n \t\t\t\t\t team);\n \t  if (__builtin_expect (cancelled, 0))\n@@ -1082,7 +1241,29 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n       if (child_task)\n \t{\n \t  thr->task = child_task;\n-\t  child_task->fn (child_task->fn_data);\n+\t  if (__builtin_expect (child_task->fn == NULL, 0))\n+\t    {\n+\t      if (gomp_target_task_fn (child_task->fn_data))\n+\t\t{\n+\t\t  thr->task = task;\n+\t\t  gomp_mutex_lock (&team->task_lock);\n+\t\t  child_task->kind = GOMP_TASK_ASYNC_RUNNING;\n+\t\t  team->task_running_count--;\n+\t\t  struct gomp_target_task *ttask\n+\t\t    = (struct gomp_target_task *) child_task->fn_data;\n+\t\t  /* If GOMP_PLUGIN_target_task_completion has run already\n+\t\t     in between gomp_target_task_fn and the mutex lock,\n+\t\t     perform the requeuing here.  */\n+\t\t  if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\t\t    gomp_target_task_completion (team, child_task);\n+\t\t  else\n+\t\t    ttask->state = GOMP_TARGET_TASK_RUNNING;\n+\t\t  child_task = NULL;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    child_task->fn (child_task->fn_data);\n \t  thr->task = task;\n \t}\n       else\n@@ -1094,7 +1275,7 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n \t  gomp_task_run_post_remove_parent (child_task);\n-\t  gomp_clear_parent (child_task->children);\n+\t  gomp_clear_parent (&child_task->children_queue);\n \t  gomp_task_run_post_remove_taskgroup (child_task);\n \t  to_free = child_task;\n \t  child_task = NULL;\n@@ -1140,15 +1321,16 @@ GOMP_taskwait (void)\n      child thread task work function are seen before we exit from\n      GOMP_taskwait.  */\n   if (task == NULL\n-      || __atomic_load_n (&task->children, MEMMODEL_ACQUIRE) == NULL)\n+      || priority_queue_empty_p (&task->children_queue, MEMMODEL_ACQUIRE))\n     return;\n \n   memset (&taskwait, 0, sizeof (taskwait));\n+  bool child_q = false;\n   gomp_mutex_lock (&team->task_lock);\n   while (1)\n     {\n       bool cancelled = false;\n-      if (task->children == NULL)\n+      if (priority_queue_empty_p (&task->children_queue, MEMMODEL_RELAXED))\n \t{\n \t  bool destroy_taskwait = task->taskwait != NULL;\n \t  task->taskwait = NULL;\n@@ -1162,9 +1344,12 @@ GOMP_taskwait (void)\n \t    gomp_sem_destroy (&taskwait.taskwait_sem);\n \t  return;\n \t}\n-      if (task->children->kind == GOMP_TASK_WAITING)\n+      struct gomp_task *next_task\n+\t= priority_queue_next_task (PQ_CHILDREN, &task->children_queue,\n+\t\t\t\t    PQ_TEAM, &team->task_queue, &child_q);\n+      if (next_task->kind == GOMP_TASK_WAITING)\n \t{\n-\t  child_task = task->children;\n+\t  child_task = next_task;\n \t  cancelled\n \t    = gomp_task_run_pre (child_task, task, team);\n \t  if (__builtin_expect (cancelled, 0))\n@@ -1180,8 +1365,10 @@ GOMP_taskwait (void)\n \t}\n       else\n \t{\n-\t  /* All tasks we are waiting for are already running\n-\t     in other threads.  Wait for them.  */\n+\t/* All tasks we are waiting for are either running in other\n+\t   threads, or they are tasks that have not had their\n+\t   dependencies met (so they're not even in the queue).  Wait\n+\t   for them.  */\n \t  if (task->taskwait == NULL)\n \t    {\n \t      taskwait.in_depend_wait = false;\n@@ -1205,7 +1392,28 @@ GOMP_taskwait (void)\n       if (child_task)\n \t{\n \t  thr->task = child_task;\n-\t  child_task->fn (child_task->fn_data);\n+\t  if (__builtin_expect (child_task->fn == NULL, 0))\n+\t    {\n+\t      if (gomp_target_task_fn (child_task->fn_data))\n+\t\t{\n+\t\t  thr->task = task;\n+\t\t  gomp_mutex_lock (&team->task_lock);\n+\t\t  child_task->kind = GOMP_TASK_ASYNC_RUNNING;\n+\t\t  struct gomp_target_task *ttask\n+\t\t    = (struct gomp_target_task *) child_task->fn_data;\n+\t\t  /* If GOMP_PLUGIN_target_task_completion has run already\n+\t\t     in between gomp_target_task_fn and the mutex lock,\n+\t\t     perform the requeuing here.  */\n+\t\t  if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\t\t    gomp_target_task_completion (team, child_task);\n+\t\t  else\n+\t\t    ttask->state = GOMP_TARGET_TASK_RUNNING;\n+\t\t  child_task = NULL;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    child_task->fn (child_task->fn_data);\n \t  thr->task = task;\n \t}\n       else\n@@ -1217,21 +1425,16 @@ GOMP_taskwait (void)\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n \n-\t  /* Remove child_task from children list, and set up the next\n-\t     sibling to be run.  */\n-\t  child_task->prev_child->next_child = child_task->next_child;\n-\t  child_task->next_child->prev_child = child_task->prev_child;\n-\t  if (task->children == child_task)\n+\t  if (child_q)\n \t    {\n-\t      if (child_task->next_child != child_task)\n-\t\ttask->children = child_task->next_child;\n-\t      else\n-\t\ttask->children = NULL;\n+\t      priority_queue_remove (PQ_CHILDREN, &task->children_queue,\n+\t\t\t\t     child_task, MEMMODEL_RELAXED);\n+\t      child_task->pnode[PQ_CHILDREN].next = NULL;\n+\t      child_task->pnode[PQ_CHILDREN].prev = NULL;\n \t    }\n-\t  /* Orphan all the children of CHILD_TASK.  */\n-\t  gomp_clear_parent (child_task->children);\n \n-\t  /* Remove CHILD_TASK from its taskgroup.  */\n+\t  gomp_clear_parent (&child_task->children_queue);\n+\n \t  gomp_task_run_post_remove_taskgroup (child_task);\n \n \t  to_free = child_task;\n@@ -1248,8 +1451,16 @@ GOMP_taskwait (void)\n     }\n }\n \n-/* This is like GOMP_taskwait, but we only wait for tasks that the\n-   upcoming task depends on.\n+/* An undeferred task is about to run.  Wait for all tasks that this\n+   undeferred task depends on.\n+\n+   This is done by first putting all known ready dependencies\n+   (dependencies that have their own dependencies met) at the top of\n+   the scheduling queues.  Then we iterate through these imminently\n+   ready tasks (and possibly other high priority tasks), and run them.\n+   If we run out of ready dependencies to execute, we either wait for\n+   the reamining dependencies to finish, or wait for them to get\n+   scheduled so we can run them.\n \n    DEPEND is as in GOMP_task.  */\n \n@@ -1261,7 +1472,6 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n   struct gomp_team *team = thr->ts.team;\n   struct gomp_task_depend_entry elem, *ent = NULL;\n   struct gomp_taskwait taskwait;\n-  struct gomp_task *last_parent_depends_on = NULL;\n   size_t ndepend = (uintptr_t) depend[0];\n   size_t nout = (uintptr_t) depend[1];\n   size_t i;\n@@ -1285,54 +1495,11 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \t      {\n \t\ttsk->parent_depends_on = true;\n \t\t++num_awaited;\n-\t\t/* If a task we need to wait for is not already\n-\t\t   running and is ready to be scheduled, move it to\n-\t\t   front, so that we run it as soon as possible.\n-\n-\t\t   We rearrange the children queue such that all\n-\t\t   parent_depends_on tasks are first, and\n-\t\t   last_parent_depends_on points to the last such task\n-\t\t   we rearranged.  For example, given the following\n-\t\t   children where PD[123] are the parent_depends_on\n-\t\t   tasks:\n-\n-\t\t\ttask->children\n-\t\t\t|\n-\t\t\tV\n-\t\t\tC1 -> C2 -> C3 -> PD1 -> PD2 -> PD3 -> C4\n-\n-\t\t   We rearrange such that:\n-\n-\t\t\ttask->children\n-\t\t\t|\t       +--- last_parent_depends_on\n-\t\t\t|\t       |\n-\t\t\tV\t       V\n-\t\t\tPD1 -> PD2 -> PD3 -> C1 -> C2 -> C3 -> C4\n-\t\t*/\n-\n+\t\t/* If depenency TSK itself has no dependencies and is\n+\t\t   ready to run, move it up front so that we run it as\n+\t\t   soon as possible.  */\n \t\tif (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)\n-\t\t  {\n-\t\t    if (last_parent_depends_on)\n-\t\t      {\n-\t\t\ttsk->prev_child->next_child = tsk->next_child;\n-\t\t\ttsk->next_child->prev_child = tsk->prev_child;\n-\t\t\ttsk->prev_child = last_parent_depends_on;\n-\t\t\ttsk->next_child = last_parent_depends_on->next_child;\n-\t\t\ttsk->prev_child->next_child = tsk;\n-\t\t\ttsk->next_child->prev_child = tsk;\n-\t\t      }\n-\t\t    else if (tsk != task->children)\n-\t\t      {\n-\t\t\ttsk->prev_child->next_child = tsk->next_child;\n-\t\t\ttsk->next_child->prev_child = tsk->prev_child;\n-\t\t\ttsk->prev_child = task->children->prev_child;\n-\t\t\ttsk->next_child = task->children;\n-\t\t\ttask->children = tsk;\n-\t\t\ttsk->prev_child->next_child = tsk;\n-\t\t\ttsk->next_child->prev_child = tsk;\n-\t\t      }\n-\t\t    last_parent_depends_on = tsk;\n-\t\t  }\n+\t\t  priority_queue_upgrade_task (tsk, task);\n \t      }\n \t  }\n     }\n@@ -1344,7 +1511,6 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \n   memset (&taskwait, 0, sizeof (taskwait));\n   taskwait.n_depend = num_awaited;\n-  taskwait.last_parent_depends_on = last_parent_depends_on;\n   gomp_sem_init (&taskwait.taskwait_sem, 0);\n   task->taskwait = &taskwait;\n \n@@ -1363,9 +1529,28 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \t  gomp_sem_destroy (&taskwait.taskwait_sem);\n \t  return;\n \t}\n-      if (task->children->kind == GOMP_TASK_WAITING)\n+\n+      /* Theoretically when we have multiple priorities, we should\n+\t chose between the highest priority item in\n+\t task->children_queue and team->task_queue here, so we should\n+\t use priority_queue_next_task().  However, since we are\n+\t running an undeferred task, perhaps that makes all tasks it\n+\t depends on undeferred, thus a priority of INF?  This would\n+\t make it unnecessary to take anything into account here,\n+\t but the dependencies.\n+\n+\t On the other hand, if we want to use priority_queue_next_task(),\n+\t care should be taken to only use priority_queue_remove()\n+\t below if the task was actually removed from the children\n+\t queue.  */\n+      bool ignored;\n+      struct gomp_task *next_task\n+\t= priority_queue_next_task (PQ_CHILDREN, &task->children_queue,\n+\t\t\t\t    PQ_IGNORED, NULL, &ignored);\n+\n+      if (next_task->kind == GOMP_TASK_WAITING)\n \t{\n-\t  child_task = task->children;\n+\t  child_task = next_task;\n \t  cancelled\n \t    = gomp_task_run_pre (child_task, task, team);\n \t  if (__builtin_expect (cancelled, 0))\n@@ -1380,8 +1565,10 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \t    }\n \t}\n       else\n-\t/* All tasks we are waiting for are already running\n-\t   in other threads.  Wait for them.  */\n+\t/* All tasks we are waiting for are either running in other\n+\t   threads, or they are tasks that have not had their\n+\t   dependencies met (so they're not even in the queue).  Wait\n+\t   for them.  */\n \ttaskwait.in_depend_wait = true;\n       gomp_mutex_unlock (&team->task_lock);\n       if (do_wake)\n@@ -1398,7 +1585,28 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n       if (child_task)\n \t{\n \t  thr->task = child_task;\n-\t  child_task->fn (child_task->fn_data);\n+\t  if (__builtin_expect (child_task->fn == NULL, 0))\n+\t    {\n+\t      if (gomp_target_task_fn (child_task->fn_data))\n+\t\t{\n+\t\t  thr->task = task;\n+\t\t  gomp_mutex_lock (&team->task_lock);\n+\t\t  child_task->kind = GOMP_TASK_ASYNC_RUNNING;\n+\t\t  struct gomp_target_task *ttask\n+\t\t    = (struct gomp_target_task *) child_task->fn_data;\n+\t\t  /* If GOMP_PLUGIN_target_task_completion has run already\n+\t\t     in between gomp_target_task_fn and the mutex lock,\n+\t\t     perform the requeuing here.  */\n+\t\t  if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\t\t    gomp_target_task_completion (team, child_task);\n+\t\t  else\n+\t\t    ttask->state = GOMP_TARGET_TASK_RUNNING;\n+\t\t  child_task = NULL;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    child_task->fn (child_task->fn_data);\n \t  thr->task = task;\n \t}\n       else\n@@ -1412,18 +1620,12 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \t  if (child_task->parent_depends_on)\n \t    --taskwait.n_depend;\n \n-\t  /* Remove child_task from sibling list.  */\n-\t  child_task->prev_child->next_child = child_task->next_child;\n-\t  child_task->next_child->prev_child = child_task->prev_child;\n-\t  if (task->children == child_task)\n-\t    {\n-\t      if (child_task->next_child != child_task)\n-\t\ttask->children = child_task->next_child;\n-\t      else\n-\t\ttask->children = NULL;\n-\t    }\n+\t  priority_queue_remove (PQ_CHILDREN, &task->children_queue,\n+\t\t\t\t child_task, MEMMODEL_RELAXED);\n+\t  child_task->pnode[PQ_CHILDREN].next = NULL;\n+\t  child_task->pnode[PQ_CHILDREN].prev = NULL;\n \n-\t  gomp_clear_parent (child_task->children);\n+\t  gomp_clear_parent (&child_task->children_queue);\n \t  gomp_task_run_post_remove_taskgroup (child_task);\n \t  to_free = child_task;\n \t  child_task = NULL;\n@@ -1463,7 +1665,7 @@ GOMP_taskgroup_start (void)\n     return;\n   taskgroup = gomp_malloc (sizeof (struct gomp_taskgroup));\n   taskgroup->prev = task->taskgroup;\n-  taskgroup->children = NULL;\n+  priority_queue_init (&taskgroup->taskgroup_queue);\n   taskgroup->in_taskgroup_wait = false;\n   taskgroup->cancelled = false;\n   taskgroup->num_children = 0;\n@@ -1485,6 +1687,17 @@ GOMP_taskgroup_end (void)\n   if (team == NULL)\n     return;\n   taskgroup = task->taskgroup;\n+  if (__builtin_expect (taskgroup == NULL, 0)\n+      && thr->ts.level == 0)\n+    {\n+      /* This can happen if GOMP_taskgroup_start is called when\n+\t thr->ts.team == NULL, but inside of the taskgroup there\n+\t is #pragma omp target nowait that creates an implicit\n+\t team with a single thread.  In this case, we want to wait\n+\t for all outstanding tasks in this team.  */\n+      gomp_team_barrier_wait (&team->barrier);\n+      return;\n+    }\n \n   /* The acquire barrier on load of taskgroup->num_children here\n      synchronizes with the write of 0 in gomp_task_run_post_remove_taskgroup.\n@@ -1495,19 +1708,25 @@ GOMP_taskgroup_end (void)\n   if (__atomic_load_n (&taskgroup->num_children, MEMMODEL_ACQUIRE) == 0)\n     goto finish;\n \n+  bool unused;\n   gomp_mutex_lock (&team->task_lock);\n   while (1)\n     {\n       bool cancelled = false;\n-      if (taskgroup->children == NULL)\n+      if (priority_queue_empty_p (&taskgroup->taskgroup_queue,\n+\t\t\t\t  MEMMODEL_RELAXED))\n \t{\n \t  if (taskgroup->num_children)\n \t    {\n-\t      if (task->children == NULL)\n+\t      if (priority_queue_empty_p (&task->children_queue,\n+\t\t\t\t\t  MEMMODEL_RELAXED))\n \t\tgoto do_wait;\n-\t      child_task = task->children;\n-            }\n-          else\n+\t      child_task\n+\t\t= priority_queue_next_task (PQ_CHILDREN, &task->children_queue,\n+\t\t\t\t\t    PQ_TEAM, &team->task_queue,\n+\t\t\t\t\t    &unused);\n+\t    }\n+\t  else\n \t    {\n \t      gomp_mutex_unlock (&team->task_lock);\n \t      if (to_free)\n@@ -1519,7 +1738,9 @@ GOMP_taskgroup_end (void)\n \t    }\n \t}\n       else\n-\tchild_task = taskgroup->children;\n+\tchild_task\n+\t  = priority_queue_next_task (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t\t      PQ_TEAM, &team->task_queue, &unused);\n       if (child_task->kind == GOMP_TASK_WAITING)\n \t{\n \t  cancelled\n@@ -1539,8 +1760,10 @@ GOMP_taskgroup_end (void)\n \t{\n \t  child_task = NULL;\n \t do_wait:\n-\t  /* All tasks we are waiting for are already running\n-\t     in other threads.  Wait for them.  */\n+\t/* All tasks we are waiting for are either running in other\n+\t   threads, or they are tasks that have not had their\n+\t   dependencies met (so they're not even in the queue).  Wait\n+\t   for them.  */\n \t  taskgroup->in_taskgroup_wait = true;\n \t}\n       gomp_mutex_unlock (&team->task_lock);\n@@ -1558,7 +1781,28 @@ GOMP_taskgroup_end (void)\n       if (child_task)\n \t{\n \t  thr->task = child_task;\n-\t  child_task->fn (child_task->fn_data);\n+\t  if (__builtin_expect (child_task->fn == NULL, 0))\n+\t    {\n+\t      if (gomp_target_task_fn (child_task->fn_data))\n+\t\t{\n+\t\t  thr->task = task;\n+\t\t  gomp_mutex_lock (&team->task_lock);\n+\t\t  child_task->kind = GOMP_TASK_ASYNC_RUNNING;\n+\t\t  struct gomp_target_task *ttask\n+\t\t    = (struct gomp_target_task *) child_task->fn_data;\n+\t\t  /* If GOMP_PLUGIN_target_task_completion has run already\n+\t\t     in between gomp_target_task_fn and the mutex lock,\n+\t\t     perform the requeuing here.  */\n+\t\t  if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n+\t\t    gomp_target_task_completion (team, child_task);\n+\t\t  else\n+\t\t    ttask->state = GOMP_TARGET_TASK_RUNNING;\n+\t\t  child_task = NULL;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    child_task->fn (child_task->fn_data);\n \t  thr->task = task;\n \t}\n       else\n@@ -1570,7 +1814,7 @@ GOMP_taskgroup_end (void)\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n \t  gomp_task_run_post_remove_parent (child_task);\n-\t  gomp_clear_parent (child_task->children);\n+\t  gomp_clear_parent (&child_task->children_queue);\n \t  gomp_task_run_post_remove_taskgroup (child_task);\n \t  to_free = child_task;\n \t  child_task = NULL;"}, {"sha": "bcee326670cf24a9f96b726ffa1eabc1728b0a0a", "filename": "libgomp/taskloop.c", "status": "modified", "additions": 24, "deletions": 47, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftaskloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftaskloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftaskloop.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -155,8 +155,8 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n   else\n     ialias_call (GOMP_taskgroup_start) ();\n \n-  /* FIXME, use priority.  */\n-  (void) priority;\n+  if (priority > gomp_max_task_priority_var)\n+    priority = gomp_max_task_priority_var;\n \n   if ((flags & GOMP_TASK_FLAG_IF) == 0 || team == NULL\n       || (thr->task && thr->task->final_task)\n@@ -175,6 +175,7 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t  for (i = 0; i < num_tasks; i++)\n \t    {\n \t      gomp_init_task (&task[i], parent, gomp_icv (false));\n+\t      task[i].priority = priority;\n \t      task[i].kind = GOMP_TASK_UNDEFERRED;\n \t      task[i].final_task = (thr->task && thr->task->final_task)\n \t\t\t\t   || (flags & GOMP_TASK_FLAG_FINAL);\n@@ -198,10 +199,11 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t\ttask_step -= step;\n \t      fn (arg);\n \t      arg += arg_size;\n-\t      if (task[i].children != NULL)\n+\t      if (!priority_queue_empty_p (&task[i].children_queue,\n+\t\t\t\t\t   MEMMODEL_RELAXED))\n \t\t{\n \t\t  gomp_mutex_lock (&team->task_lock);\n-\t\t  gomp_clear_parent (task[i].children);\n+\t\t  gomp_clear_parent (&task[i].children_queue);\n \t\t  gomp_mutex_unlock (&team->task_lock);\n \t\t}\n \t      gomp_end_task ();\n@@ -213,6 +215,7 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t    struct gomp_task task;\n \n \t    gomp_init_task (&task, thr->task, gomp_icv (false));\n+\t    task.priority = priority;\n \t    task.kind = GOMP_TASK_UNDEFERRED;\n \t    task.final_task = (thr->task && thr->task->final_task)\n \t\t\t      || (flags & GOMP_TASK_FLAG_FINAL);\n@@ -228,10 +231,11 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t    if (i == nfirst)\n \t      task_step -= step;\n \t    fn (data);\n-\t    if (task.children != NULL)\n+\t    if (!priority_queue_empty_p (&task.children_queue,\n+\t\t\t\t\t MEMMODEL_RELAXED))\n \t      {\n \t\tgomp_mutex_lock (&team->task_lock);\n-\t\tgomp_clear_parent (task.children);\n+\t\tgomp_clear_parent (&task.children_queue);\n \t\tgomp_mutex_unlock (&team->task_lock);\n \t      }\n \t    gomp_end_task ();\n@@ -254,6 +258,7 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t  arg = (char *) (((uintptr_t) (task + 1) + arg_align - 1)\n \t\t\t  & ~(uintptr_t) (arg_align - 1));\n \t  gomp_init_task (task, parent, gomp_icv (false));\n+\t  task->priority = priority;\n \t  task->kind = GOMP_TASK_UNDEFERRED;\n \t  task->in_tied_task = parent->in_tied_task;\n \t  task->taskgroup = taskgroup;\n@@ -298,48 +303,20 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       for (i = 0; i < num_tasks; i++)\n \t{\n \t  struct gomp_task *task = tasks[i];\n-\t  if (parent->children)\n-\t    {\n-\t      task->next_child = parent->children;\n-\t      task->prev_child = parent->children->prev_child;\n-\t      task->next_child->prev_child = task;\n-\t      task->prev_child->next_child = task;\n-\t    }\n-\t  else\n-\t    {\n-\t      task->next_child = task;\n-\t      task->prev_child = task;\n-\t    }\n-\t  parent->children = task;\n+\t  priority_queue_insert (PQ_CHILDREN, &parent->children_queue,\n+\t\t\t\t task, priority,\n+\t\t\t\t PRIORITY_INSERT_BEGIN,\n+\t\t\t\t /*last_parent_depends_on=*/false,\n+\t\t\t\t task->parent_depends_on);\n \t  if (taskgroup)\n-\t    {\n-\t      if (taskgroup->children)\n-\t\t{\n-\t\t  task->next_taskgroup = taskgroup->children;\n-\t\t  task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n-\t\t  task->next_taskgroup->prev_taskgroup = task;\n-\t\t  task->prev_taskgroup->next_taskgroup = task;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  task->next_taskgroup = task;\n-\t\t  task->prev_taskgroup = task;\n-\t\t}\n-\t      taskgroup->children = task;\n-\t    }\n-\t  if (team->task_queue)\n-\t    {\n-\t      task->next_queue = team->task_queue;\n-\t      task->prev_queue = team->task_queue->prev_queue;\n-\t      task->next_queue->prev_queue = task;\n-\t      task->prev_queue->next_queue = task;\n-\t    }\n-\t  else\n-\t    {\n-\t      task->next_queue = task;\n-\t      task->prev_queue = task;\n-\t      team->task_queue = task;\n-\t    }\n+\t    priority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue,\n+\t\t\t\t   task, priority, PRIORITY_INSERT_BEGIN,\n+\t\t\t\t   /*last_parent_depends_on=*/false,\n+\t\t\t\t   task->parent_depends_on);\n+\t  priority_queue_insert (PQ_TEAM, &team->task_queue, task, priority,\n+\t\t\t\t PRIORITY_INSERT_END,\n+\t\t\t\t /*last_parent_depends_on=*/false,\n+\t\t\t\t task->parent_depends_on);\n \t  ++team->task_count;\n \t  ++team->task_queued_count;\n \t}"}, {"sha": "34b77c07def75862584394d0f3573bebdd486365", "filename": "libgomp/team.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -193,7 +193,7 @@ gomp_new_team (unsigned nthreads)\n   team->ordered_release = (void *) &team->implicit_task[nthreads];\n   team->ordered_release[0] = &team->master_release;\n \n-  team->task_queue = NULL;\n+  priority_queue_init (&team->task_queue);\n   team->task_count = 0;\n   team->task_queued_count = 0;\n   team->task_running_count = 0;\n@@ -214,6 +214,7 @@ free_team (struct gomp_team *team)\n #endif\n   gomp_barrier_destroy (&team->barrier);\n   gomp_mutex_destroy (&team->task_lock);\n+  priority_queue_free (&team->task_queue);\n   free (team);\n }\n \n@@ -271,6 +272,8 @@ gomp_free_thread (void *arg __attribute__((unused)))\n       free (pool);\n       thr->thread_pool = NULL;\n     }\n+  if (thr->ts.level == 0 && __builtin_expect (thr->ts.team != NULL, 0))\n+    gomp_team_end ();\n   if (thr->task != NULL)\n     {\n       struct gomp_task *task = thr->task;\n@@ -300,7 +303,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   struct gomp_thread **affinity_thr = NULL;\n \n   thr = gomp_thread ();\n-  nested = thr->ts.team != NULL;\n+  nested = thr->ts.level;\n   pool = thr->thread_pool;\n   task = thr->task;\n   icv = task ? &task->icv : &gomp_global_icv;"}, {"sha": "eef0d5e2f4b8a7d2e84c7028fcf44e95b0095e11", "filename": "libgomp/testsuite/libgomp.c/doacross-3.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-3.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,225 @@\n+extern void abort (void);\n+\n+#define N 256\n+int a[N], b[N / 16][8][4], c[N / 32][8][8], g[N / 16][8][6];\n+volatile int d, e;\n+volatile unsigned long long f;\n+\n+int\n+main ()\n+{\n+  unsigned long long i;\n+  int j, k, l, m;\n+  #pragma omp parallel private (l)\n+  {\n+    #pragma omp for schedule(guided, 3) ordered (1) nowait\n+    for (i = 1; i < N + f; i++)\n+      {\n+\t#pragma omp atomic write\n+\ta[i] = 1;\n+\t#pragma omp ordered depend(sink: i - 1)\n+\tif (i > 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i - 1];\n+\t    if (l < 2)\n+\t      abort ();\n+\t  }\n+\t#pragma omp atomic write\n+\ta[i] = 2;\n+\tif (i < N - 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i + 1];\n+\t    if (l == 3)\n+\t      abort ();\n+\t  }\n+\t#pragma omp ordered depend(source)\n+\t#pragma omp atomic write\n+\ta[i] = 3;\n+      }\n+    #pragma omp for schedule(guided) ordered (3) nowait\n+    for (i = 3; i < N / 16 - 1 + f; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 1;\n+\t    #pragma omp ordered depend(sink: i, j - 2, k - 1) \\\n+\t\t\t\tdepend(sink: i - 2, j - 2, k + 1)\n+\t    #pragma omp ordered depend(sink: i - 3, j + 2, k - 2)\n+\t    if (j >= 2 && k > 1)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i][j - 2][k - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 2;\n+\t    if (i >= 5 && j >= 2 && k < 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 2][j - 2][k + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (i >= 6 && j < N / 16 - 3 && k == 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 3][j + 2][k - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered depend(source)\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 3;\n+\t  }\n+#define A(n) int n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3)\n+    D(m)\n+#undef A\n+    #pragma omp for collapse (2) ordered(61) schedule(guided, 15)\n+    for (i = 2; i < N / 32 + f; i++)\n+      for (j = 7; j > 1; j--)\n+\tfor (k = 6; k >= 0; k -= 2)\n+#define A(n) for (n = 4; n < 5; n++)\n+\t  D(m)\n+#undef A\n+\t    {\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 1;\n+#define A(n) ,n\n+#define E(n) C(n##0) C(n##1) C(n##2) B(n##30) B(n##31) A(n##320) A(n##321)\n+\t      #pragma omp ordered depend (sink: i, j, k + 2 E(m)) \\\n+\t\t\t\t  depend (sink:i - 2, j + 1, k - 4 E(m)) \\\n+\t\t\t\t  depend(sink: i - 1, j - 2, k - 2 E(m))\n+\t      if (k <= 4)\n+\t\t{\n+\t\t  l = c[i][j][k + 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 2;\n+\t      if (i >= 4 && j < 7 && k >= 4)\n+\t\t{\n+\t\t  l = c[i - 2][j + 1][k - 4];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      if (i >= 3 && j >= 4 && k >= 2)\n+\t\t{\n+\t\t  l = c[i - 1][j - 2][k - 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp ordered depend (source)\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 3;\n+\t    }\n+    #pragma omp for schedule(guided, 5) ordered (3) nowait\n+    for (j = 0; j < N / 16 - 1; j++)\n+      for (k = 0; k < 8; k += 2)\n+\tfor (i = 3; i <= 5 + f; i++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 1;\n+\t    #pragma omp ordered depend(sink: j, k - 2, i - 1) \\\n+\t\t\t\tdepend(sink: j - 2, k - 2, i + 1)\n+\t    #pragma omp ordered depend(sink: j - 3, k + 2, i - 2)\n+\t    if (k >= 2 && i > 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j][k - 2][i - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 2;\n+\t    if (j >= 2 && k >= 2 && i < 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 2][k - 2][i + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (j >= 3 && k < N / 16 - 3 && i == 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 3][k + 2][i - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered depend(source)\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 3;\n+\t  }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d; k++)\n+\t  for (l = 0; l < d + 2; l++)\n+\t    {\n+\t      #pragma omp ordered depend (source)\n+\t      #pragma omp ordered depend (sink:i - 2, j + 2, k - 2, l)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp single\n+    {\n+      if (i != 3 || j != -1 || k != 0)\n+\tabort ();\n+      i = 8; j = 9; k = 10;\n+    }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k, m)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (m = 0; m < d; m++)\n+\t    {\n+\t      #pragma omp ordered depend (source)\n+\t      #pragma omp ordered depend (sink:i - 2, j + 2, k - 2, m)\n+\t      abort ();\n+\t    }\n+    #pragma omp single\n+    if (i != 3 || j != -1 || k != 2 || m != 0)\n+      abort ();\n+    #pragma omp for collapse(2) ordered(4) nowait\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d; j > 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (l = 0; l < d + 4; l++)\n+\t    {\n+\t      #pragma omp ordered depend (source)\n+\t      #pragma omp ordered depend (sink:i - 2, j + 2, k - 2, l)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp for nowait\n+    for (i = 0; i < N; i++)\n+      if (a[i] != 3 * (i >= 1))\n+\tabort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 4; k++)\n+\t  if (b[i][j][k] != 3 * (i >= 3 && i < N / 16 - 1 && (j & 1) == 0 && k >= 1))\n+\t    abort ();\n+    #pragma omp for collapse(3) nowait\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 8; k++)\n+\t  if (c[i][j][k] != 3 * (i >= 2 && j >= 2 && (k & 1) == 0))\n+\t    abort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 6; k++)\n+\t  if (g[i][j][k] != 3 * (i < N / 16 - 1 && (j & 1) == 0 && k >= 3))\n+\t    abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "fac24405720210747f827f312d0e0e0a49a41c5b", "filename": "libgomp/testsuite/libgomp.c/ordered-5.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-5.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-msse2\" { target sse2_runtime } } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+extern void abort (void);\n+int a[1024], b = -1;\n+\n+int\n+main ()\n+{\n+  int i;\n+  #pragma omp parallel for simd ordered\n+  for (i = 0; i < 1024; i++)\n+    {\n+      a[i] = i;\n+      #pragma omp ordered threads simd\n+      {\n+\tif (b + 1 != i)\n+\t  abort ();\n+\tb = i;\n+      }\n+      a[i] += 3;\n+    }\n+  if (b != 1023)\n+    abort ();\n+  for (i = 0; i < 1024; i++)\n+    if (a[i] != i + 3)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "012f09d8f77c82fea361f009ef7d7925e579d107", "filename": "libgomp/testsuite/libgomp.c/priority.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fpriority.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Fpriority.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpriority.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_MAX_TASK_PRIORITY \"10\" } */\n+\n+/* This test verifies that the \"priority\" clause of omp task works as\n+   advertised.\n+\n+   Testing the OpenMP task scheduler is a bit tricky, especially when\n+   trying to determine what ran first (without explicitly calling\n+   time() and/or synchronizing between threads).  What we do here is\n+   run in single threaded mode which guarantees that we won't run into\n+   data races while accessing the \"prio\" array.\n+\n+   We give each task a priority from 0..63, while setting\n+   OMP_MAX_TASK_PRIORITY to 10, which basically gives us 10 lower\n+   priority tasks, and the rest scheduled to run earlier.  We verify\n+   that the priority < 10 tasks run last.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define N 64\n+\n+int main()\n+{\n+  int tsknum=0, prio[N];\n+  int max_priority = omp_get_max_task_priority ();\n+  int saved_tsknum = -1;\n+  int i;\n+\n+#pragma omp parallel num_threads(1)\n+#pragma omp single private (i)\n+  {\n+    for (i = 0; i < N; i++)\n+      #pragma omp task priority(i ^ 1)\n+      {\n+\tint t;\n+\t#pragma omp atomic capture seq_cst\n+\tt = tsknum++;\n+\tprio[t] = i ^ 1;\n+      }\n+    #pragma omp atomic read seq_cst\n+    saved_tsknum = tsknum;\n+  }\n+\n+  /* If any of the tasks have run before all tasks were created, don't\n+     make any assumption on the task order.  Otherwise, we should have\n+     tasks with >= max_priority scheduled first in arbitrary order,\n+     followed by the rest of tasks in decreasing priority order, as\n+     there is only one thread that can schedule them.  */\n+  if (saved_tsknum == 0)\n+    {\n+      for (i = 0; i < N; i++)\n+\tif (i < N - max_priority)\n+\t  {\n+\t    if (prio[i] < max_priority)\n+\t      abort ();\n+\t  }\n+\telse if (i != N - prio[i] - 1)\n+\t  abort ();\n+    }\n+  return 0;\n+}"}, {"sha": "255327c8f76af3afd06bab2db38547b320131a79", "filename": "libgomp/testsuite/libgomp.c/target-31.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-31.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,163 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int a = 1, b = 2, c = 3, d = 4;\n+int e[2] = { 5, 6 }, f[2] = { 7, 8 }, g[2] = { 9, 10 }, h[2] = { 11, 12 };\n+\n+__attribute__((noinline, noclone)) void\n+use (int *k, int *l, int *m, int *n, int *o, int *p, int *q, int *r)\n+{\n+  asm volatile (\"\" : : \"r\" (k) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (l) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (m) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (n) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (o) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (p) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (q) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (r) : \"memory\");\n+}\n+\n+#pragma omp declare target to (use)\n+\n+int\n+main ()\n+{\n+  int err = 0, r = -1, t[4];\n+  long s[4] = { -1, -2, -3, -4 };\n+  int j = 13, k = 14, l[2] = { 15, 16 }, m[2] = { 17, 18 };\n+  #pragma omp target private (a, b, e, f) firstprivate (c, d, g, h) map(from: r, s, t) \\\n+\t\t     map(tofrom: err, j, l) map(to: k, m)\n+  #pragma omp teams num_teams (4) thread_limit (8) private (b, f) firstprivate (d, h, k, m)\n+  {\n+    int u1 = k, u2[2] = { m[0], m[1] };\n+    int u3[64];\n+    int i;\n+    for (i = 0; i < 64; i++)\n+      u3[i] = k + i;\n+    #pragma omp parallel num_threads (1)\n+    {\n+      if (c != 3 || d != 4 || g[0] != 9 || g[1] != 10 || h[0] != 11 || h[1] != 12 || k != 14 || m[0] != 17 || m[1] != 18)\n+\t#pragma omp atomic write\n+\t  err = 1;\n+      b = omp_get_team_num ();\n+      if (b >= 4)\n+\t#pragma omp atomic write\n+\t  err = 1;\n+      if (b == 0)\n+\t{\n+\t  a = omp_get_num_teams ();\n+\t  e[0] = 2 * a;\n+\t  e[1] = 3 * a;\n+\t}\n+      f[0] = 2 * b;\n+      f[1] = 3 * b;\n+      #pragma omp atomic update\n+\tc++;\n+      #pragma omp atomic update\n+\tg[0] += 2;\n+      #pragma omp atomic update\n+\tg[1] += 3;\n+      d++;\n+      h[0] += 2;\n+      h[1] += 3;\n+      k += b;\n+      m[0] += 2 * b;\n+      m[1] += 3 * b;\n+    }\n+    use (&a, &b, &c, &d, e, f, g, h);\n+    #pragma omp parallel firstprivate (u1, u2)\n+    {\n+      int w = omp_get_thread_num ();\n+      int x = 19;\n+      int y[2] = { 20, 21 };\n+      int v = 24;\n+      int ll[64];\n+      if (u1 != 14 || u2[0] != 17 || u2[1] != 18)\n+\t#pragma omp atomic write\n+\t  err = 1;\n+      u1 += w;\n+      u2[0] += 2 * w;\n+      u2[1] += 3 * w;\n+      use (&u1, u2, &t[b], l, &k, m, &j, h);\n+      #pragma omp master\n+\tt[b] = omp_get_num_threads ();\n+      #pragma omp atomic update\n+\tj++;\n+      #pragma omp atomic update\n+\tl[0] += 2;\n+      #pragma omp atomic update\n+\tl[1] += 3;\n+      #pragma omp atomic update\n+\tk += 4;\n+      #pragma omp atomic update\n+\tm[0] += 5;\n+      #pragma omp atomic update\n+\tm[1] += 6;\n+      x += w;\n+      y[0] += 2 * w;\n+      y[1] += 3 * w;\n+      #pragma omp simd safelen(32) private (v)\n+      for (i = 0; i < 64; i++)\n+\t{\n+\t  v = 3 * i;\n+\t  ll[i] = u1 + v * u2[0] + u2[1] + x + y[0] + y[1] + v + h[0] + u3[i];\n+\t}\n+      #pragma omp barrier\n+      use (&u1, u2, &t[b], l, &k, m, &x, y);\n+      if (w < 0 || w > 8 || w != omp_get_thread_num () || u1 != 14 + w\n+\t  || u2[0] != 17 + 2 * w || u2[1] != 18 + 3 * w\n+\t  || x != 19 + w || y[0] != 20 + 2 * w || y[1] != 21 + 3 * w\n+\t  || v != 24)\n+\t#pragma omp atomic write\n+\t  err = 1;\n+      for (i = 0; i < 64; i++)\n+\tif (ll[i] != u1 + 3 * i * u2[0] + u2[1] + x + y[0] + y[1] + 3 * i + 13 + 14 + i)\n+\t  #pragma omp atomic write\n+\t    err = 1;\n+    }\n+    #pragma omp parallel num_threads (1)\n+    {\n+      if (b == 0)\n+\t{\n+\t  r = a;\n+\t  if (a != omp_get_num_teams ()\n+\t      || e[0] != 2 * a\n+\t      || e[1] != 3 * a)\n+\t    #pragma omp atomic write\n+\t      err = 1;\n+\t}\n+      int v1, v2, v3;\n+      #pragma omp atomic read\n+\tv1 = c;\n+      #pragma omp atomic read\n+\tv2 = g[0];\n+      #pragma omp atomic read\n+\tv3 = g[1];\n+      s[b] = v1 * 65536L + v2 * 256L + v3;\n+      if (d != 5 || h[0] != 13 || h[1] != 15\n+\t  || k != 14 + b + 4 * t[b]\n+\t  || m[0] != 17 + 2 * b + 5 * t[b]\n+\t  || m[1] != 18 + 3 * b + 6 * t[b]\n+\t  || b != omp_get_team_num ()\n+\t  || f[0] != 2 * b || f[1] != 3 * b)\n+\t#pragma omp atomic write\n+\t  err = 1;\n+    }\n+  }\n+  if (err != 0) abort ();\n+  if (r < 1 || r > 4) abort ();\n+  if (a != 1 || b != 2 || c != 3 || d != 4) abort ();\n+  if (e[0] != 5 || e[1] != 6 || f[0] != 7 || f[1] != 8) abort ();\n+  if (g[0] != 9 || g[1] != 10 || h[0] != 11 || h[1] != 12) abort ();\n+  int i, cnt = 0;\n+  for (i = 0; i < r; i++)\n+    if ((s[i] >> 16) < 3 + 1 || (s[i] >> 16) > 3 + 4\n+\t|| ((s[i] >> 8) & 0xff) < 9 + 2 * 1 || ((s[i] >> 8) & 0xff) > 9 + 2 * 4\n+\t|| (s[i] & 0xff) < 10 + 3 * 1 || (s[i] & 0xff) > 10 + 3 * 4\n+\t|| t[i] < 1 || t[i] > 8)\n+      abort ();\n+    else\n+      cnt += t[i];\n+  if (j != 13 + cnt || l[0] != 15 + 2 * cnt || l[1] != 16 + 3 * cnt) abort ();\n+  return 0;\n+}"}, {"sha": "233877b702ba6903ba640c3b2ca9e9fb425d3b2b", "filename": "libgomp/testsuite/libgomp.c/target-32.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-32.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,54 @@\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+int main ()\n+{\n+  int a = 0, b = 0, c = 0, d[7];\n+\n+  #pragma omp parallel\n+  #pragma omp single\n+  {\n+    #pragma omp task depend(out: d[0])\n+      a = 2;\n+\n+    #pragma omp target enter data nowait map(to: a,b,c) depend(in: d[0]) depend(out: d[1])\n+\n+    #pragma omp target nowait map(alloc: a) depend(in: d[1]) depend(out: d[2])\n+      a++;\n+\n+    #pragma omp target nowait map(alloc: b) depend(in: d[2]) depend(out: d[3])\n+    {\n+      usleep (1000);\n+      #pragma omp atomic update\n+      b |= 4;\n+    }\n+\n+    #pragma omp target nowait map(alloc: b) depend(in: d[2]) depend(out: d[4])\n+    {\n+      usleep (5000);\n+      #pragma omp atomic update\n+      b |= 1;\n+    }\n+\n+    #pragma omp target nowait map(alloc: c) depend(in: d[3], d[4]) depend(out: d[5])\n+    {\n+      usleep (5000);\n+      #pragma omp atomic update\n+      c |= 8;\n+    }\n+\n+    #pragma omp target nowait map(alloc: c) depend(in: d[3], d[4]) depend(out: d[6])\n+    {\n+      usleep (1000);\n+      #pragma omp atomic update\n+      c |= 2;\n+    }\n+\n+    #pragma omp target exit data map(always,from: a,b,c) depend(in: d[5], d[6])\n+  }\n+\n+  if (a != 3 || b != 5 || c != 10)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1bed4b6bc6738c5a733bd9bbdb7242a95fae1391", "filename": "libgomp/testsuite/libgomp.c/target-33.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-33.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,93 @@\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  int a = 1, b = 2, c = 4, d[7];\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp target enter data nowait map (to: a, b, c) depend(out: d[0])\n+    #pragma omp target nowait map (alloc: a, b) depend(in: d[0]) depend(out: d[1])\n+    {\n+      #pragma omp atomic update\n+      a |= 4;\n+      #pragma omp atomic update\n+      b |= 8;\n+    }\n+    #pragma omp target nowait map (alloc: a, c) depend(in: d[0]) depend(out: d[2])\n+    {\n+      #pragma omp atomic update\n+      a |= 16;\n+      #pragma omp atomic update\n+      c |= 32;\n+    }\n+    #pragma omp target exit data nowait map (from: a, b, c) depend(in: d[1], d[2])\n+  }\n+  if (a != 21 || b != 10 || c != 36)\n+    abort ();\n+  #pragma omp target map (tofrom: a, b) nowait\n+  {\n+    a &= ~16;\n+    b &= ~2;\n+  }\n+  #pragma omp target map (tofrom: c) nowait\n+  {\n+    c |= 8;\n+  }\n+  #pragma omp barrier\n+  if (a != 5 || b != 8 || c != 44)\n+    abort ();\n+  #pragma omp target map (tofrom: a, b) nowait\n+  {\n+    a |= 32;\n+    b |= 4;\n+  }\n+  #pragma omp target map (tofrom: c) nowait\n+  {\n+    c &= ~4;\n+  }\n+  #pragma omp taskwait\n+  if (a != 37 || b != 12 || c != 40)\n+    abort ();\n+  #pragma omp target nowait map (tofrom: a, b) depend(out: d[3])\n+  {\n+    #pragma omp atomic update\n+    a = a + 9;\n+    b -= 8;\n+  }\n+  #pragma omp target nowait map (tofrom: a, c) depend(out: d[4])\n+  {\n+    #pragma omp atomic update\n+    a = a + 4;\n+    c >>= 1;\n+  }\n+  #pragma omp task if (0) depend (in: d[3], d[4]) shared (a, b, c)\n+  if (a != 50 || b != 4 || c != 20)\n+    abort ();\n+  #pragma omp task shared (a)\n+  a += 50;\n+  #pragma omp target nowait map (tofrom: b)\n+  b++;\n+  #pragma omp target map (tofrom: c) nowait\n+  c--;\n+  #pragma omp taskwait\n+  if (a != 100 || b != 5 || c != 19)\n+    abort ();\n+  #pragma omp target map (tofrom: a) nowait depend(out: d[5])\n+  a++;\n+  #pragma omp target map (tofrom: b) nowait depend(out: d[6])\n+  b++;\n+  #pragma omp target map (tofrom: a, b) depend(in: d[5], d[6])\n+  {\n+    if (a != 101 || b != 6)\n+      a = -9;\n+    else\n+      {\n+\ta = 24;\n+\tb = 38;\n+      }\n+  }\n+  if (a != 24 || b != 38)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "66d9f54202bea3047020e2d42853bd404a56850c", "filename": "libgomp/testsuite/libgomp.c/target-34.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-34.c?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -0,0 +1,112 @@\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  int a = 1, b = 2, c = 4, d[7];\n+  #pragma omp parallel\n+  {\n+    #pragma omp single\n+    {\n+      #pragma omp taskgroup\n+      {\n+\t#pragma omp target enter data nowait map (to: a, b, c) depend(out: d[0])\n+\t#pragma omp target nowait map (alloc: a, b) depend(in: d[0]) depend(out: d[1])\n+\t{\n+\t  #pragma omp atomic update\n+\t  a |= 4;\n+\t  #pragma omp atomic update\n+\t  b |= 8;\n+\t}\n+\t#pragma omp target nowait map (alloc: a, c) depend(in: d[0]) depend(out: d[2])\n+\t{\n+\t  #pragma omp atomic update\n+\t  a |= 16;\n+\t  #pragma omp atomic update\n+\t  c |= 32;\n+\t}\n+\t#pragma omp target exit data nowait map (from: a, b, c) depend(in: d[1], d[2])\n+      }\n+      if (a != 21 || b != 10 || c != 36)\n+\tabort ();\n+      #pragma omp target map (tofrom: a, b) nowait\n+      {\n+\ta &= ~16;\n+\tb &= ~2;\n+      }\n+      #pragma omp target map (tofrom: c) nowait\n+      {\n+\tc |= 8;\n+      }\n+    } /* Implicit barrier here.  */\n+    #pragma omp single\n+    {\n+      if (a != 5 || b != 8 || c != 44)\n+\tabort ();\n+      #pragma omp target map (tofrom: a, b) nowait\n+      {\n+\ta |= 32;\n+\tb |= 4;\n+      }\n+      #pragma omp target map (tofrom: c) nowait\n+      c &= ~4;\n+      #pragma omp taskwait\n+      if (a != 37 || b != 12 || c != 40)\n+\tabort ();\n+      #pragma omp target nowait map (tofrom: a, b) depend(out: d[3])\n+      {\n+\t#pragma omp atomic update\n+\ta = a + 9;\n+\tb -= 8;\n+      }\n+      #pragma omp target nowait map (tofrom: a, c) depend(out: d[4])\n+      {\n+\t#pragma omp atomic update\n+\ta = a + 4;\n+\tc >>= 1;\n+      }\n+      #pragma omp task if (0) depend (in: d[3], d[4]) shared (a, b, c)\n+      if (a != 50 || b != 4 || c != 20)\n+\tabort ();\n+      #pragma omp task shared (a)\n+      a += 50;\n+      #pragma omp target nowait map (tofrom: b)\n+      b++;\n+      #pragma omp target map (tofrom: c) nowait\n+      c--;\n+      #pragma omp taskwait\n+      if (a != 100 || b != 5 || c != 19)\n+\tabort ();\n+      #pragma omp target map (tofrom: a) nowait depend(out: d[5])\n+      a++;\n+      #pragma omp target map (tofrom: b) nowait depend(out: d[6])\n+      b++;\n+      #pragma omp target map (tofrom: a, b) depend(in: d[5], d[6])\n+      {\n+\tif (a != 101 || b != 6)\n+\t  a = -9;\n+\telse\n+\t  {\n+\t    a = 24;\n+\t    b = 38;\n+\t  }\n+      }\n+      if (a != 24 || b != 38)\n+\tabort ();\n+    } /* Implicit barrier here.  */\n+    #pragma omp master\n+    {\n+      #pragma omp target nowait map (tofrom: a, b)\n+      {\n+\ta *= 2;\n+\tb++;\n+      }\n+      #pragma omp target map (tofrom: c) nowait\n+      c--;\n+    }\n+    #pragma omp barrier\n+    if (a != 48 || b != 39 || c != 18)\n+      abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "4086d548c0dba8f45773f4ec42438ada906c29c4", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -1,3 +1,20 @@\n+2015-11-14  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* runtime/offload_host.cpp (task_completion_callback): New\n+\tvariable.\n+\t(offload_proxy_task_completed_ooo): Call task_completion_callback.\n+\t(__offload_register_task_callback): New function.\n+\t* runtime/offload_host.h (__offload_register_task_callback): New\n+\tdeclaration.\n+\t* plugin/libgomp-plugin-intelmic.cpp (offload): Add async_data\n+\targument, handle async offloading.\n+\t(register_main_image): Call register_main_image.\n+\t(GOMP_OFFLOAD_init_device, get_target_table, GOMP_OFFLOAD_alloc,\n+\tGOMP_OFFLOAD_free, GOMP_OFFLOAD_host2dev, GOMP_OFFLOAD_dev2host,\n+\tGOMP_OFFLOAD_dev2dev) Adjust offload callers.\n+\t(GOMP_OFFLOAD_async_run): New function.\n+\t(GOMP_OFFLOAD_run): Implement using GOMP_OFFLOAD_async_run.\n+\n 2015-10-26  Ilya Verbin  <ilya.verbin@intel.com>\n \t    Aleksander Ivanushenko  <aleksander.ivanushenko@intel.com>\n "}, {"sha": "772e1985dfbbaf75ac6ec296b0e68a98000cc851", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -192,11 +192,23 @@ GOMP_OFFLOAD_get_num_devices (void)\n \n static void\n offload (const char *file, uint64_t line, int device, const char *name,\n-\t int num_vars, VarDesc *vars, VarDesc2 *vars2)\n+\t int num_vars, VarDesc *vars, VarDesc2 *vars2, const void **async_data)\n {\n   OFFLOAD ofld = __offload_target_acquire1 (&device, file, line);\n   if (ofld)\n-    __offload_offload1 (ofld, name, 0, num_vars, vars, vars2, 0, NULL, NULL);\n+    {\n+      if (async_data == NULL)\n+\t__offload_offload1 (ofld, name, 0, num_vars, vars, vars2, 0, NULL,\n+\t\t\t    NULL);\n+      else\n+\t{\n+\t  OffloadFlags flags;\n+\t  flags.flags = 0;\n+\t  flags.bits.omp_async = 1;\n+\t  __offload_offload3 (ofld, name, 0, num_vars, vars, NULL, 0, NULL,\n+\t\t\t      async_data, 0, NULL, flags, NULL);\n+\t}\n+    }\n   else\n     {\n       fprintf (stderr, \"%s:%d: Offload target acquire failed\\n\", file, line);\n@@ -208,6 +220,10 @@ static void\n register_main_image ()\n {\n   __offload_register_image (&main_target_image);\n+\n+  /* liboffloadmic will call GOMP_PLUGIN_target_task_completion when\n+     asynchronous task on target is completed.  */\n+  __offload_register_task_callback (GOMP_PLUGIN_target_task_completion);\n }\n \n /* liboffloadmic loads and runs offload_target_main on all available devices\n@@ -218,7 +234,7 @@ GOMP_OFFLOAD_init_device (int device)\n   TRACE (\"\");\n   pthread_once (&main_image_is_registered, register_main_image);\n   offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0,\n-\t   NULL, NULL);\n+\t   NULL, NULL, NULL);\n }\n \n extern \"C\" void\n@@ -240,7 +256,7 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n   VarDesc2 vd1g[2] = { { \"num_funcs\", 0 }, { \"num_vars\", 0 } };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2,\n-\t   vd1, vd1g);\n+\t   vd1, vd1g, NULL);\n \n   int table_size = num_funcs + 2 * num_vars;\n   if (table_size > 0)\n@@ -254,7 +270,7 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n       VarDesc2 vd2g = { \"table\", 0 };\n \n       offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\", 1,\n-\t       &vd2, &vd2g);\n+\t       &vd2, &vd2g, NULL);\n     }\n }\n \n@@ -401,8 +417,8 @@ GOMP_OFFLOAD_alloc (int device, size_t size)\n   vd1[1].size = sizeof (void *);\n   VarDesc2 vd1g[2] = { { \"size\", 0 }, { \"tgt_ptr\", 0 } };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2, vd1, vd1g);\n-\n+  offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2, vd1, vd1g,\n+\t   NULL);\n   return tgt_ptr;\n }\n \n@@ -416,7 +432,8 @@ GOMP_OFFLOAD_free (int device, void *tgt_ptr)\n   vd1.size = sizeof (void *);\n   VarDesc2 vd1g = { \"tgt_ptr\", 0 };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1, &vd1, &vd1g);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1, &vd1, &vd1g,\n+\t   NULL);\n }\n \n extern \"C\" void *\n@@ -435,15 +452,15 @@ GOMP_OFFLOAD_host2dev (int device, void *tgt_ptr, const void *host_ptr,\n   VarDesc2 vd1g[2] = { { \"tgt_ptr\", 0 }, { \"size\", 0 } };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2,\n-\t   vd1, vd1g);\n+\t   vd1, vd1g, NULL);\n \n   VarDesc vd2 = vd_host2tgt;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n   VarDesc2 vd2g = { \"var\", 0 };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1,\n-\t   &vd2, &vd2g);\n+\t   &vd2, &vd2g, NULL);\n \n   return tgt_ptr;\n }\n@@ -464,15 +481,15 @@ GOMP_OFFLOAD_dev2host (int device, void *host_ptr, const void *tgt_ptr,\n   VarDesc2 vd1g[2] = { { \"tgt_ptr\", 0 }, { \"size\", 0 } };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2,\n-\t   vd1, vd1g);\n+\t   vd1, vd1g, NULL);\n \n   VarDesc vd2 = vd_tgt2host;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n   VarDesc2 vd2g = { \"var\", 0 };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1,\n-\t   &vd2, &vd2g);\n+\t   &vd2, &vd2g, NULL);\n \n   return host_ptr;\n }\n@@ -495,22 +512,32 @@ GOMP_OFFLOAD_dev2dev (int device, void *dst_ptr, const void *src_ptr,\n   VarDesc2 vd1g[3] = { { \"dst_ptr\", 0 }, { \"src_ptr\", 0 }, { \"size\", 0 } };\n \n   offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3, vd1,\n-\t   vd1g);\n+\t   vd1g, NULL);\n \n   return dst_ptr;\n }\n \n extern \"C\" void\n-GOMP_OFFLOAD_run (int device, void *tgt_fn, void *tgt_vars)\n+GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n+\t\t\tvoid *async_data)\n {\n-  TRACE (\"(tgt_fn = %p, tgt_vars = %p)\", tgt_fn, tgt_vars);\n+  TRACE (\"(device = %d, tgt_fn = %p, tgt_vars = %p, async_data = %p)\", device,\n+\t tgt_fn, tgt_vars, async_data);\n \n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &tgt_fn;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &tgt_vars;\n-  vd1[1].size = sizeof (void *);\n-  VarDesc2 vd1g[2] = { { \"tgt_fn\", 0 }, { \"tgt_vars\", 0 } };\n+  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &tgt_fn;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &tgt_vars;\n+  vd[1].size = sizeof (void *);\n+\n+  offload (__FILE__, __LINE__, device, \"__offload_target_run\", 2, vd, NULL,\n+\t   (const void **) async_data);\n+}\n+\n+extern \"C\" void\n+GOMP_OFFLOAD_run (int device, void *tgt_fn, void *tgt_vars)\n+{\n+  TRACE (\"(device = %d, tgt_fn = %p, tgt_vars = %p)\", device, tgt_fn, tgt_vars);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_run\", 2, vd1, vd1g);\n+  GOMP_OFFLOAD_async_run (device, tgt_fn, tgt_vars, NULL);\n }"}, {"sha": "e52019dfb28e7733cba65fc506d160ccb27e4fba", "filename": "liboffloadmic/runtime/offload_host.cpp", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fruntime%2Foffload_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fruntime%2Foffload_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.cpp?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -64,6 +64,8 @@ static void __offload_fini_library(void);\n #define GET_OFFLOAD_NUMBER(timer_data) \\\n     timer_data? timer_data->offload_number : 0\n \n+static void (*task_completion_callback)(void *);\n+\n extern \"C\" {\n #ifdef TARGET_WINNT\n // Windows does not support imports from libraries without actually\n@@ -2507,7 +2509,7 @@ extern \"C\" {\n         const void *info\n     )\n     {\n-\t/* TODO: Call callback function, pass info.  */\n+\ttask_completion_callback ((void *) info);\n     }\n }\n \n@@ -5669,6 +5671,11 @@ extern \"C\" void __offload_unregister_image(const void *target_image)\n     }\n }\n \n+extern \"C\" void __offload_register_task_callback(void (*cb)(void *))\n+{\n+    task_completion_callback = cb;\n+}\n+\n // Runtime trace interface for user programs\n \n void __offload_console_trace(int level)"}, {"sha": "2a43fd6a68a2eb9b0b219eaf4ed97118bf3d032d", "filename": "liboffloadmic/runtime/offload_host.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fruntime%2Foffload_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e460634820cb3fce59aeed8310f1d8824ad96441/liboffloadmic%2Fruntime%2Foffload_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.h?ref=e460634820cb3fce59aeed8310f1d8824ad96441", "patch": "@@ -376,6 +376,9 @@ extern \"C\" bool __offload_target_image_is_executable(const void *target_image);\n extern \"C\" bool __offload_register_image(const void* image);\n extern \"C\" void __offload_unregister_image(const void* image);\n \n+// Registers asynchronous task completion callback\n+extern \"C\" void __offload_register_task_callback(void (*cb)(void *));\n+\n // Initializes offload runtime library.\n DLL_LOCAL extern int __offload_init_library(void);\n "}]}