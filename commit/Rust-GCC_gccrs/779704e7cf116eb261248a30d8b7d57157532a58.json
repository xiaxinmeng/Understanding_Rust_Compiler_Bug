{"sha": "779704e7cf116eb261248a30d8b7d57157532a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc5NzA0ZTdjZjExNmViMjYxMjQ4YTMwZDhiN2Q1NzE1NzUzMmE1OA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-06-19T16:47:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-06-19T16:47:35Z"}, "message": "tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle ADDR_EXPR pointers.\n\n2009-06-19  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n\tADDR_EXPR pointers.\n\t(ptr_derefs_may_alias_p): Likewise.\n\t(ptr_deref_may_alias_ref_p_1): New function.\n\t(ptr_deref_may_alias_ref_p): Likewise.\n\t(ref_maybe_used_by_call_p_1): Handle builtins that are not\n\tcovered by looking at the ESCAPED solution.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset):\n\tHandle NULL_TREE offset.  Do not produce redundant constraints.\n\t(process_all_all_constraints): New helper function.\n\t(do_structure_copy): Use it.\n\t(handle_lhs_call): Likewise.\n\t(find_func_aliases): Handle some builtins with pointer arguments\n\tand/or return values explicitly.\n\n\t* gcc.c-torture/execute/20090618-1.c: New testcase.\n\nFrom-SVN: r148718", "tree": {"sha": "115043f9abcfc58fee3a9e901196c7d3eba9702f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/115043f9abcfc58fee3a9e901196c7d3eba9702f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/779704e7cf116eb261248a30d8b7d57157532a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779704e7cf116eb261248a30d8b7d57157532a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779704e7cf116eb261248a30d8b7d57157532a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779704e7cf116eb261248a30d8b7d57157532a58/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "217655da6f8d9c11e77452d5b4ed421205716bac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/217655da6f8d9c11e77452d5b4ed421205716bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/217655da6f8d9c11e77452d5b4ed421205716bac"}], "stats": {"total": 428, "additions": 376, "deletions": 52}, "files": [{"sha": "f4e7816bb451705d2319ff4bbe1b4f1ee42f46ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=779704e7cf116eb261248a30d8b7d57157532a58", "patch": "@@ -1,3 +1,21 @@\n+2009-06-19  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n+\tADDR_EXPR pointers.\n+\t(ptr_derefs_may_alias_p): Likewise.\n+\t(ptr_deref_may_alias_ref_p_1): New function.\n+\t(ptr_deref_may_alias_ref_p): Likewise.\n+\t(ref_maybe_used_by_call_p_1): Handle builtins that are not\n+\tcovered by looking at the ESCAPED solution.\n+\t(call_may_clobber_ref_p_1): Likewise.\n+\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset):\n+\tHandle NULL_TREE offset.  Do not produce redundant constraints.\n+\t(process_all_all_constraints): New helper function.\n+\t(do_structure_copy): Use it.\n+\t(handle_lhs_call): Likewise.\n+\t(find_func_aliases): Handle some builtins with pointer arguments\n+\tand/or return values explicitly.\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* varasm.c (const_rtx_hash_1): Remove const qualifier from shift."}, {"sha": "e1ea0a3385cecd0c5f41f8931712923c1486cafe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=779704e7cf116eb261248a30d8b7d57157532a58", "patch": "@@ -1,3 +1,7 @@\n+2009-06-19  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.c-torture/execute/20090618-1.c: New testcase.\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wcxx-compat-17.c: New testcase."}, {"sha": "f522116eba146ecf645f9713b3fce2f8637d6449", "filename": "gcc/testsuite/gcc.c-torture/execute/20090618-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090618-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090618-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090618-1.c?ref=779704e7cf116eb261248a30d8b7d57157532a58", "patch": "@@ -0,0 +1,21 @@\n+extern void abort (void);\n+\n+struct X { int *p; int *q; };\n+\n+int foo(void)\n+{\n+  int i = 0, j = 1;\n+  struct X x, y;\n+  int **p;\n+  y.p = &i;\n+  x.q = &j;\n+  p = __builtin_mempcpy (&x, &y, sizeof (int *));\n+  return **p;\n+}\n+\n+int main()\n+{\n+  if (foo() != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c83488b178806d5c14f38ce1f0aef541dc175080", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 193, "deletions": 24, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=779704e7cf116eb261248a30d8b7d57157532a58", "patch": "@@ -168,14 +168,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n {\n   struct ptr_info_def *pi;\n \n-  /* ???  During SCCVN/PRE we can end up with *&x during valueizing\n-     operands.  Likewise we can end up with dereferencing constant\n-     pointers.  Just bail out in these cases for now.  */\n-  if (TREE_CODE (ptr) == ADDR_EXPR\n-      || TREE_CODE (ptr) == INTEGER_CST)\n-    return true;\n-\n-  gcc_assert (TREE_CODE (ptr) == SSA_NAME\n+  gcc_assert ((TREE_CODE (ptr) == SSA_NAME\n+\t       || TREE_CODE (ptr) == ADDR_EXPR\n+\t       || TREE_CODE (ptr) == INTEGER_CST)\n \t      && (TREE_CODE (decl) == VAR_DECL\n \t\t  || TREE_CODE (decl) == PARM_DECL\n \t\t  || TREE_CODE (decl) == RESULT_DECL));\n@@ -184,6 +179,29 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n   if (!may_be_aliased (decl))\n     return false;\n \n+  /* ADDR_EXPR pointers either just offset another pointer or directly\n+     specify the pointed-to set.  */\n+  if (TREE_CODE (ptr) == ADDR_EXPR)\n+    {\n+      tree base = get_base_address (TREE_OPERAND (ptr, 0));\n+      if (base\n+\t  && INDIRECT_REF_P (base))\n+\tptr = TREE_OPERAND (base, 0);\n+      else if (base\n+\t       && SSA_VAR_P (base))\n+\treturn operand_equal_p (base, decl, 0);\n+      else if (base\n+\t       && CONSTANT_CLASS_P (base))\n+\treturn false;\n+      else\n+\treturn true;\n+    }\n+\n+  /* We can end up with dereferencing constant pointers.\n+     Just bail out in this case.  */\n+  if (TREE_CODE (ptr) == INTEGER_CST)\n+    return true;\n+\n   /* If we do not have useful points-to information for this pointer\n      we cannot disambiguate anything else.  */\n   pi = SSA_NAME_PTR_INFO (ptr);\n@@ -202,18 +220,46 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n {\n   struct ptr_info_def *pi1, *pi2;\n \n-  /* ???  During SCCVN/PRE we can end up with *&x during valueizing\n-     operands.  Likewise we can end up with dereferencing constant\n-     pointers.  Just bail out in these cases for now.  */\n-  if (TREE_CODE (ptr1) == ADDR_EXPR\n-      || TREE_CODE (ptr1) == INTEGER_CST\n-      || TREE_CODE (ptr2) == ADDR_EXPR\n+  gcc_assert ((TREE_CODE (ptr1) == SSA_NAME\n+\t       || TREE_CODE (ptr1) == ADDR_EXPR\n+\t       || TREE_CODE (ptr1) == INTEGER_CST)\n+\t      && (TREE_CODE (ptr2) == SSA_NAME\n+\t\t  || TREE_CODE (ptr2) == ADDR_EXPR\n+\t\t  || TREE_CODE (ptr2) == INTEGER_CST));\n+\n+  /* ADDR_EXPR pointers either just offset another pointer or directly\n+     specify the pointed-to set.  */\n+  if (TREE_CODE (ptr1) == ADDR_EXPR)\n+    {\n+      tree base = get_base_address (TREE_OPERAND (ptr1, 0));\n+      if (base\n+\t  && INDIRECT_REF_P (base))\n+\tptr1 = TREE_OPERAND (base, 0);\n+      else if (base\n+\t       && SSA_VAR_P (base))\n+\treturn ptr_deref_may_alias_decl_p (ptr2, base);\n+      else\n+\treturn true;\n+    }\n+  if (TREE_CODE (ptr2) == ADDR_EXPR)\n+    {\n+      tree base = get_base_address (TREE_OPERAND (ptr2, 0));\n+      if (base\n+\t  && INDIRECT_REF_P (base))\n+\tptr2 = TREE_OPERAND (base, 0);\n+      else if (base\n+\t       && SSA_VAR_P (base))\n+\treturn ptr_deref_may_alias_decl_p (ptr1, base);\n+      else\n+\treturn true;\n+    }\n+\n+  /* We can end up with dereferencing constant pointers.\n+     Just bail out in this case.  */\n+  if (TREE_CODE (ptr1) == INTEGER_CST\n       || TREE_CODE (ptr2) == INTEGER_CST)\n     return true;\n \n-  gcc_assert (TREE_CODE (ptr1) == SSA_NAME\n-\t      && TREE_CODE (ptr2) == SSA_NAME);\n-\n   /* We may end up with two empty points-to solutions for two same pointers.\n      In this case we still want to say both pointers alias, so shortcut\n      that here.  */\n@@ -232,6 +278,31 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n   return pt_solutions_intersect (&pi1->pt, &pi2->pt);\n }\n \n+/* Return true if dereferencing PTR may alias *REF.\n+   The caller is responsible for applying TBAA to see if PTR\n+   may access *REF at all.  */\n+\n+static bool\n+ptr_deref_may_alias_ref_p_1 (tree ptr, ao_ref *ref)\n+{\n+  tree base = ao_ref_base (ref);\n+\n+  if (INDIRECT_REF_P (base))\n+    return ptr_derefs_may_alias_p (ptr, TREE_OPERAND (base, 0));\n+  else if (SSA_VAR_P (base))\n+    return ptr_deref_may_alias_decl_p (ptr, base);\n+\n+  return true;\n+}\n+\n+static bool\n+ptr_deref_may_alias_ref_p (tree ptr, tree ref)\n+{\n+  ao_ref r;\n+  ao_ref_init (&r, ref);\n+  return ptr_deref_may_alias_ref_p_1 (ptr, &r);\n+}\n+\n \n /* Dump alias information on FILE.  */\n \n@@ -778,7 +849,7 @@ refs_output_dependent_p (tree store1, tree store2)\n static bool\n ref_maybe_used_by_call_p_1 (gimple call, tree ref)\n {\n-  tree base;\n+  tree base, callee;\n   unsigned i;\n   int flags = gimple_call_flags (call);\n \n@@ -803,13 +874,41 @@ ref_maybe_used_by_call_p_1 (gimple call, tree ref)\n       && !is_global_var (base))\n     goto process_args;\n \n+  callee = gimple_call_fndecl (call);\n+\n+  /* Handle those builtin functions explicitly that do not act as\n+     escape points.  See tree-ssa-structalias.c:find_func_aliases\n+     for the list of builtins we might need to handle here.  */\n+  if (callee != NULL_TREE\n+      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (callee))\n+      {\n+\t/* All the following functions clobber memory pointed to by\n+\t   their first argument.  */\n+\tcase BUILT_IN_STRCPY:\n+\tcase BUILT_IN_STRNCPY:\n+\tcase BUILT_IN_BCOPY:\n+\tcase BUILT_IN_MEMCPY:\n+\tcase BUILT_IN_MEMMOVE:\n+\tcase BUILT_IN_MEMPCPY:\n+\tcase BUILT_IN_STPCPY:\n+\tcase BUILT_IN_STPNCPY:\n+\tcase BUILT_IN_STRCAT:\n+\tcase BUILT_IN_STRNCAT:\n+\t  {\n+\t    tree src = gimple_call_arg (call, 1);\n+\t    return ptr_deref_may_alias_ref_p (src, ref);\n+\t  }\n+\tdefault:\n+\t  /* Fallthru to general call handling.  */;\n+      }\n+\n   /* Check if base is a global static variable that is not read\n      by the function.  */\n   if (TREE_CODE (base) == VAR_DECL\n       && TREE_STATIC (base)\n       && !TREE_PUBLIC (base))\n     {\n-      tree callee = gimple_call_fndecl (call);\n       bitmap not_read;\n \n       if (callee != NULL_TREE\n@@ -901,6 +1000,7 @@ static bool\n call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n {\n   tree base;\n+  tree callee;\n \n   /* If the call is pure or const it cannot clobber anything.  */\n   if (gimple_call_flags (call)\n@@ -926,18 +1026,87 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n \t  || !is_global_var (base)))\n     return false;\n \n+  callee = gimple_call_fndecl (call);\n+\n+  /* Handle those builtin functions explicitly that do not act as\n+     escape points.  See tree-ssa-structalias.c:find_func_aliases\n+     for the list of builtins we might need to handle here.  */\n+  if (callee != NULL_TREE\n+      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (callee))\n+      {\n+\t/* All the following functions clobber memory pointed to by\n+\t   their first argument.  */\n+\tcase BUILT_IN_STRCPY:\n+\tcase BUILT_IN_STRNCPY:\n+\tcase BUILT_IN_BCOPY:\n+\tcase BUILT_IN_MEMCPY:\n+\tcase BUILT_IN_MEMMOVE:\n+\tcase BUILT_IN_MEMPCPY:\n+\tcase BUILT_IN_STPCPY:\n+\tcase BUILT_IN_STPNCPY:\n+\tcase BUILT_IN_STRCAT:\n+\tcase BUILT_IN_STRNCAT:\n+\t  {\n+\t    tree dest = gimple_call_arg (call, 0);\n+\t    return ptr_deref_may_alias_ref_p_1 (dest, ref);\n+\t  }\n+\t/* Freeing memory kills the pointed-to memory.  More importantly\n+\t   the call has to serve as a barrier for moving loads and stores\n+\t   across it.  Same is true for memset.  */\n+\tcase BUILT_IN_FREE:\n+\tcase BUILT_IN_MEMSET:\n+\t  {\n+\t    tree ptr = gimple_call_arg (call, 0);\n+\t    return ptr_deref_may_alias_ref_p_1 (ptr, ref);\n+\t  }\n+\tcase BUILT_IN_FREXP:\n+\tcase BUILT_IN_FREXPF:\n+\tcase BUILT_IN_FREXPL:\n+\tcase BUILT_IN_GAMMA_R:\n+\tcase BUILT_IN_GAMMAF_R:\n+\tcase BUILT_IN_GAMMAL_R:\n+\tcase BUILT_IN_LGAMMA_R:\n+\tcase BUILT_IN_LGAMMAF_R:\n+\tcase BUILT_IN_LGAMMAL_R:\n+\tcase BUILT_IN_MODF:\n+\tcase BUILT_IN_MODFF:\n+\tcase BUILT_IN_MODFL:\n+\t  {\n+\t    tree out = gimple_call_arg (call, 1);\n+\t    return ptr_deref_may_alias_ref_p_1 (out, ref);\n+\t  }\n+\tcase BUILT_IN_REMQUO:\n+\tcase BUILT_IN_REMQUOF:\n+\tcase BUILT_IN_REMQUOL:\n+\t  {\n+\t    tree out = gimple_call_arg (call, 2);\n+\t    return ptr_deref_may_alias_ref_p_1 (out, ref);\n+\t  }\n+\tcase BUILT_IN_SINCOS:\n+\tcase BUILT_IN_SINCOSF:\n+\tcase BUILT_IN_SINCOSL:\n+\t  {\n+\t    tree sin = gimple_call_arg (call, 1);\n+\t    tree cos = gimple_call_arg (call, 2);\n+\t    return (ptr_deref_may_alias_ref_p_1 (sin, ref)\n+\t\t    || ptr_deref_may_alias_ref_p_1 (cos, ref));\n+\t  }\n+\tdefault:\n+\t  /* Fallthru to general call handling.  */;\n+      }\n+\n   /* Check if base is a global static variable that is not written\n      by the function.  */\n-  if (TREE_CODE (base) == VAR_DECL\n+  if (callee != NULL_TREE\n+      && TREE_CODE (base) == VAR_DECL\n       && TREE_STATIC (base)\n       && !TREE_PUBLIC (base))\n     {\n-      tree callee = gimple_call_fndecl (call);\n       bitmap not_written;\n \n-      if (callee != NULL_TREE\n-\t  && (not_written\n-\t        = ipa_reference_get_not_written_global (cgraph_node (callee)))\n+      if ((not_written\n+\t     = ipa_reference_get_not_written_global (cgraph_node (callee)))\n \t  && bitmap_bit_p (not_written, DECL_UID (base)))\n \treturn false;\n     }"}, {"sha": "bca2145756094cd7cbed114d6c064f7c8e72f99f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 140, "deletions": 28, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779704e7cf116eb261248a30d8b7d57157532a58/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=779704e7cf116eb261248a30d8b7d57157532a58", "patch": "@@ -2857,7 +2857,8 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n      in a HOST_WIDE_INT, we have to fall back to a conservative\n      solution which includes all sub-fields of all pointed-to\n      variables of ptr.  */\n-  if (!host_integerp (offset, 0))\n+  if (offset == NULL_TREE\n+      || !host_integerp (offset, 0))\n     rhsoffset = UNKNOWN_OFFSET;\n   else\n     {\n@@ -2896,7 +2897,8 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t      c2.var = temp->id;\n \t      c2.type = ADDRESSOF;\n \t      c2.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &c2);\n+\t      if (c2.var != c->var)\n+\t\tVEC_safe_push (ce_s, heap, *results, &c2);\n \t      temp = temp->next;\n \t    }\n \t  while (temp);\n@@ -3239,6 +3241,37 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n   get_constraint_for_1 (t, results, false);\n }\n \n+\n+/* Efficiently generates constraints from all entries in *RHSC to all\n+   entries in *LHSC.  */\n+\n+static void\n+process_all_all_constraints (VEC (ce_s, heap) *lhsc, VEC (ce_s, heap) *rhsc)\n+{\n+  struct constraint_expr *lhsp, *rhsp;\n+  unsigned i, j;\n+\n+  if (VEC_length (ce_s, lhsc) <= 1\n+      || VEC_length (ce_s, rhsc) <= 1)\n+    {\n+      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\tfor (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); ++j)\n+\t  process_constraint (new_constraint (*lhsp, *rhsp));\n+    }\n+  else\n+    {\n+      struct constraint_expr tmp;\n+      tree tmpvar = create_tmp_var_raw (ptr_type_node, \"allallcopytmp\");\n+      tmp.var = get_vi_for_tree (tmpvar)->id;\n+      tmp.type = SCALAR;\n+      tmp.offset = 0;\n+      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\tprocess_constraint (new_constraint (tmp, *rhsp));\n+      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\tprocess_constraint (new_constraint (*lhsp, tmp));\n+    }\n+}\n+\n /* Handle aggregate copies by expanding into copies of the respective\n    fields of the structures.  */\n \n@@ -3256,18 +3289,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n   if (lhsp->type == DEREF\n       || (lhsp->type == ADDRESSOF && lhsp->var == anything_id)\n       || rhsp->type == DEREF)\n-    {\n-      struct constraint_expr tmp;\n-      tree tmpvar = create_tmp_var_raw (ptr_type_node,\n-\t\t\t\t\t\"structcopydereftmp\");\n-      tmp.var = get_vi_for_tree (tmpvar)->id;\n-      tmp.type = SCALAR;\n-      tmp.offset = 0;\n-      for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); ++j)\n-\tprocess_constraint (new_constraint (tmp, *rhsp));\n-      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); ++j)\n-\tprocess_constraint (new_constraint (*lhsp, tmp));\n-    }\n+    process_all_all_constraints (lhsc, rhsc);\n   else if (lhsp->type == SCALAR\n \t   && (rhsp->type == SCALAR\n \t       || rhsp->type == ADDRESSOF))\n@@ -3426,8 +3448,6 @@ handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc)\n     }\n   else if (VEC_length (ce_s, rhsc) > 0)\n     {\n-      struct constraint_expr *lhsp, *rhsp;\n-      unsigned int i, j;\n       /* If the store is to a global decl make sure to\n \t add proper escape constraints.  */\n       lhs = get_base_address (lhs);\n@@ -3441,9 +3461,7 @@ handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc)\n \t  tmpc.type = SCALAR;\n \t  VEC_safe_push (ce_s, heap, lhsc, &tmpc);\n \t}\n-      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n-\tfor (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); ++j)\n-\t  process_constraint (new_constraint (*lhsp, *rhsp));\n+      process_all_all_constraints (lhsc, rhsc);\n     }\n   VEC_free (ce_s, heap, lhsc);\n }\n@@ -3608,6 +3626,108 @@ find_func_aliases (gimple origt)\n      pointer passed by address.  */\n   else if (is_gimple_call (t))\n     {\n+      tree fndecl;\n+      if ((fndecl = gimple_call_fndecl (t)) != NULL_TREE\n+\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t/* ???  All builtins that are handled here need to be handled\n+\t   in the alias-oracle query functions explicitly!  */\n+\tswitch (DECL_FUNCTION_CODE (fndecl))\n+\t  {\n+\t  /* All the following functions return a pointer to the same object\n+\t     as their first argument points to.  The functions do not add\n+\t     to the ESCAPED solution.  The functions make the first argument\n+\t     pointed to memory point to what the second argument pointed to\n+\t     memory points to.  */\n+\t  case BUILT_IN_STRCPY:\n+\t  case BUILT_IN_STRNCPY:\n+\t  case BUILT_IN_BCOPY:\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMMOVE:\n+\t  case BUILT_IN_MEMPCPY:\n+\t  case BUILT_IN_STPCPY:\n+\t  case BUILT_IN_STPNCPY:\n+\t  case BUILT_IN_STRCAT:\n+\t  case BUILT_IN_STRNCAT:\n+\t    {\n+\t      tree res = gimple_call_lhs (t);\n+\t      tree dest = gimple_call_arg (t, 0);\n+\t      tree src = gimple_call_arg (t, 1);\n+\t      if (res != NULL_TREE)\n+\t\t{\n+\t\t  get_constraint_for (res, &lhsc);\n+\t\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMPCPY\n+\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPCPY\n+\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPNCPY)\n+\t\t    get_constraint_for_ptr_offset (dest, NULL_TREE, &rhsc);\n+\t\t  else\n+\t\t    get_constraint_for (dest, &rhsc);\n+\t\t  process_all_all_constraints (lhsc, rhsc);\n+\t\t  VEC_free (ce_s, heap, lhsc);\n+\t\t  VEC_free (ce_s, heap, rhsc);\n+\t\t}\n+\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t      get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n+\t      do_deref (&lhsc);\n+\t      do_deref (&rhsc);\n+\t      process_all_all_constraints (lhsc, rhsc);\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      VEC_free (ce_s, heap, rhsc);\n+\t      return;\n+\t    }\n+\t  case BUILT_IN_MEMSET:\n+\t    {\n+\t      tree res = gimple_call_lhs (t);\n+\t      tree dest = gimple_call_arg (t, 0);\n+\t      unsigned i;\n+\t      ce_s *lhsp;\n+\t      struct constraint_expr ac;\n+\t      if (res != NULL_TREE)\n+\t\t{\n+\t\t  get_constraint_for (res, &lhsc);\n+\t\t  get_constraint_for (dest, &rhsc);\n+\t\t  process_all_all_constraints (lhsc, rhsc);\n+\t\t  VEC_free (ce_s, heap, lhsc);\n+\t\t  VEC_free (ce_s, heap, rhsc);\n+\t\t}\n+\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t      do_deref (&lhsc);\n+\t      ac.type = SCALAR;\n+\t      ac.var = integer_id;\n+\t      ac.offset = 0;\n+\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\t\tprocess_constraint (new_constraint (*lhsp, ac));\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      return;\n+\t    }\n+\t  /* All the following functions do not return pointers, do not\n+\t     modify the points-to sets of memory reachable from their\n+\t     arguments and do not add to the ESCAPED solution.  */\n+\t  case BUILT_IN_SINCOS:\n+\t  case BUILT_IN_SINCOSF:\n+\t  case BUILT_IN_SINCOSL:\n+\t  case BUILT_IN_FREXP:\n+\t  case BUILT_IN_FREXPF:\n+\t  case BUILT_IN_FREXPL:\n+\t  case BUILT_IN_GAMMA_R:\n+\t  case BUILT_IN_GAMMAF_R:\n+\t  case BUILT_IN_GAMMAL_R:\n+\t  case BUILT_IN_LGAMMA_R:\n+\t  case BUILT_IN_LGAMMAF_R:\n+\t  case BUILT_IN_LGAMMAL_R:\n+\t  case BUILT_IN_MODF:\n+\t  case BUILT_IN_MODFF:\n+\t  case BUILT_IN_MODFL:\n+\t  case BUILT_IN_REMQUO:\n+\t  case BUILT_IN_REMQUOF:\n+\t  case BUILT_IN_REMQUOL:\n+\t  case BUILT_IN_FREE:\n+\t    return;\n+\t  /* printf-style functions may have hooks to set pointers to\n+\t     point to somewhere into the generated string.  Leave them\n+\t     for a later excercise...  */\n+\t  default:\n+\t    /* Fallthru to general call handling.  */;\n+\t  }\n       if (!in_ipa_mode)\n \t{\n \t  VEC(ce_s, heap) *rhsc = NULL;\n@@ -3724,7 +3844,6 @@ find_func_aliases (gimple origt)\n \tdo_structure_copy (lhsop, rhsop);\n       else\n \t{\n-\t  unsigned int j;\n \t  struct constraint_expr temp;\n \t  get_constraint_for (lhsop, &lhsc);\n \n@@ -3743,14 +3862,7 @@ find_func_aliases (gimple origt)\n \t      temp.offset = 0;\n \t      VEC_safe_push (ce_s, heap, rhsc, &temp);\n \t    }\n-\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n-\t    {\n-\t      struct constraint_expr *c2;\n-\t      unsigned int k;\n-\n-\t      for (k = 0; VEC_iterate (ce_s, rhsc, k, c2); k++)\n-\t\tprocess_constraint (new_constraint (*c, *c2));\n-\t    }\n+\t  process_all_all_constraints (lhsc, rhsc);\n \t}\n       /* If there is a store to a global variable the rhs escapes.  */\n       if ((lhsop = get_base_address (lhsop)) != NULL_TREE"}]}