{"sha": "fe9841365eb7e2908f9ba6b18a85910ee9024a54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5ODQxMzY1ZWI3ZTI5MDhmOWJhNmIxOGE4NTkxMGVlOTAyNGE1NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-13T07:45:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-13T07:45:09Z"}, "message": "target-def.h (TARGET_MUST_PASS_IN_STACK): New.\n\n\t* target-def.h (TARGET_MUST_PASS_IN_STACK): New.\n\t* target.h (struct gcc_target): Add calls.must_pass_in_stack.\n\t* expr.h (MUST_PASS_IN_STACK): Remove.\n\t* system.h (MUST_PASS_IN_STACK): Poison.\n\t* tree.h (must_pass_in_stack_var_size): Declare.\n\t(must_pass_in_stack_var_size_or_pad): Declare.\n\t* calls.c (must_pass_in_stack_var_size): New.\n\t(must_pass_in_stack_var_size_or_pad): Rename from\n\tdefault_must_pass_in_stack.\n\t* config/alpha/alpha.c (unicosmk_must_pass_in_stack): New.\n\t(TARGET_MUST_PASS_IN_STACK): New.\n\t* config/alpha/unicosmk.h (MUST_PASS_IN_STACK): Remove.\n\t* config/fr30/fr30.c (fr30_must_pass_in_stack): New.\n\t(TARGET_MUST_PASS_IN_STACK): New.\n\t* config/fr30/fr30.h (MUST_PASS_IN_STACK): Remove.\n\t* config/frv/frv.c (frv_must_pass_in_stack): New.\n\t(TARGET_MUST_PASS_IN_STACK): New.\n\t* config/frv/frv.h (MUST_PASS_IN_STACK): Remove.\n\t* config/i386/i386-protos.h (ix86_must_pass_in_stack): Remove.\n\t* config/i386/i386.c (TARGET_MUST_PASS_IN_STACK): New.\n\t(ix86_must_pass_in_stack): Make static.\n\t* config/i386/i386.h (MUST_PASS_IN_STACK): Remove.\n\t* config/ia64/ia64.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/ia64/ia64.h (MUST_PASS_IN_STACK): Remove.\n\t* config/m32r/m32r.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/m32r/m32r.h (MUST_PASS_IN_STACK): Remove.\n\t* config/mcore/mcore-protos.h (mcore_must_pass_on_stack): Remove.\n\t* config/mcore/mcore.c (TARGET_MUST_PASS_IN_STACK): New.\n\t(mcore_must_pass_on_stack): Remove.\n\t* config/mcore/mcore.h (MUST_PASS_IN_STACK): Remove.\n\t* config/mips/mips.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/mips/mips.h (MUST_PASS_IN_STACK): Remove.\n\t* config/pa/pa.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/pa/pa.h (MUST_PASS_IN_STACK): Remove.\n\t* config/rs6000/aix.h (MUST_PASS_IN_STACK): Remove.\n\t* config/rs6000/linux64.h (MUST_PASS_IN_STACK): Remove.\n\t* config/rs6000/rs6000.c (rs6000_must_pass_in_stack): New.\n\t(TARGET_MUST_PASS_IN_STACK): New.\n\t* config/sh/sh.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/sh/sh.h (MUST_PASS_IN_STACK): Remove.\n\t* config/sparc/sparc.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/sparc/sparc.h (MUST_PASS_IN_STACK): Remove.\n\t* config/xtensa/xtensa.c (TARGET_MUST_PASS_IN_STACK): New.\n\t* config/xtensa/xtensa.h (MUST_PASS_IN_STACK): Remove.\n\t* doc/tm.texi (TARGET_MUST_PASS_IN_STACK): Update from\n\tMUST_PASS_IN_STACK.\n\n\t* calls.c, function.c, config/alpha/alpha.c, config/alpha/alpha.h,\n\tconfig/alpha/unicosmk.h, config/alpha/vms.h, config/c4x/c4x.c,\n\tconfig/cris/cris.h, config/fr30/fr30.c, config/fr30/fr30.h,\n\tconfig/frv/frv.c, config/i386/i386.c, config/iq2000/iq2000.c,\n\tconfig/mcore/mcore.c, config/mcore/mcore.h, config/mips/mips.c,\n\tconfig/mmix/mmix.c, config/mmix/mmix.h, config/rs6000/rs6000.c,\n\tconfig/sh/sh.c, config/sh/sh.h, config/stormy16/stormy16.c,\n\tconfig/xtensa/xtensa.c: Use target hook.\n\nFrom-SVN: r84606", "tree": {"sha": "d6061a45fae079845a6d37d0db05d65b8eb6b121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6061a45fae079845a6d37d0db05d65b8eb6b121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe9841365eb7e2908f9ba6b18a85910ee9024a54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9841365eb7e2908f9ba6b18a85910ee9024a54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9841365eb7e2908f9ba6b18a85910ee9024a54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9841365eb7e2908f9ba6b18a85910ee9024a54/comments", "author": null, "committer": null, "parents": [{"sha": "29f1711877a0f3f6f7e36d22f4a53b0161591d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f1711877a0f3f6f7e36d22f4a53b0161591d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f1711877a0f3f6f7e36d22f4a53b0161591d4e"}], "stats": {"total": 578, "additions": 242, "deletions": 336}, "files": [{"sha": "6c2ef13d44b18cfde53886578868615385f147e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1,3 +1,61 @@\n+2004-07-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* target-def.h (TARGET_MUST_PASS_IN_STACK): New.\n+\t* target.h (struct gcc_target): Add calls.must_pass_in_stack.\n+\t* expr.h (MUST_PASS_IN_STACK): Remove.\n+\t* system.h (MUST_PASS_IN_STACK): Poison.\n+\t* tree.h (must_pass_in_stack_var_size): Declare.\n+\t(must_pass_in_stack_var_size_or_pad): Declare.\n+\t* calls.c (must_pass_in_stack_var_size): New.\n+\t(must_pass_in_stack_var_size_or_pad): Rename from \n+\tdefault_must_pass_in_stack.\n+\t* config/alpha/alpha.c (unicosmk_must_pass_in_stack): New.\n+\t(TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/alpha/unicosmk.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/fr30/fr30.c (fr30_must_pass_in_stack): New.\n+\t(TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/fr30/fr30.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/frv/frv.c (frv_must_pass_in_stack): New.\n+\t(TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/frv/frv.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/i386/i386-protos.h (ix86_must_pass_in_stack): Remove.\n+\t* config/i386/i386.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t(ix86_must_pass_in_stack): Make static.\n+\t* config/i386/i386.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/ia64/ia64.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/ia64/ia64.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/m32r/m32r.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/m32r/m32r.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/mcore/mcore-protos.h (mcore_must_pass_on_stack): Remove.\n+\t* config/mcore/mcore.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t(mcore_must_pass_on_stack): Remove.\n+\t* config/mcore/mcore.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/mips/mips.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/mips/mips.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/pa/pa.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/pa/pa.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/rs6000/aix.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/rs6000/linux64.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/rs6000/rs6000.c (rs6000_must_pass_in_stack): New.\n+\t(TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/sh/sh.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/sh/sh.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/sparc/sparc.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/sparc/sparc.h (MUST_PASS_IN_STACK): Remove.\n+\t* config/xtensa/xtensa.c (TARGET_MUST_PASS_IN_STACK): New.\n+\t* config/xtensa/xtensa.h (MUST_PASS_IN_STACK): Remove.\n+\t* doc/tm.texi (TARGET_MUST_PASS_IN_STACK): Update from\n+\tMUST_PASS_IN_STACK.\n+\n+\t* calls.c, function.c, config/alpha/alpha.c, config/alpha/alpha.h,\n+\tconfig/alpha/unicosmk.h, config/alpha/vms.h, config/c4x/c4x.c,\n+\tconfig/cris/cris.h, config/fr30/fr30.c, config/fr30/fr30.h,\n+\tconfig/frv/frv.c, config/i386/i386.c, config/iq2000/iq2000.c,\n+\tconfig/mcore/mcore.c, config/mcore/mcore.h, config/mips/mips.c,\n+\tconfig/mmix/mmix.c, config/mmix/mmix.h, config/rs6000/rs6000.c,\n+\tconfig/sh/sh.c, config/sh/sh.h, config/stormy16/stormy16.c,\n+\tconfig/xtensa/xtensa.c: Use target hook.\n+\n 2004-07-13  Anthony Heading  <aheading@jpmorgan.com>\n \n \t* configure.ac (gcc_cv_as_offsetable_lo10: Fix a typo."}, {"sha": "e1281624a05e70df1505abf8007e0005341fcfde", "filename": "gcc/calls.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1097,7 +1097,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  = FUNCTION_ARG_PARTIAL_NREGS (*args_so_far, mode, type,\n \t\t\t\t\targpos < n_named_args);\n \n-      args[i].pass_on_stack = MUST_PASS_IN_STACK (mode, type);\n+      args[i].pass_on_stack = targetm.calls.must_pass_in_stack (mode, type);\n \n       /* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]),\n \t it means that we are to pass this arg in the register(s) designated\n@@ -4445,24 +4445,33 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   return sibcall_failure;\n }\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   We cannot do so in the following cases:\n+/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n \n-   - if the type has variable size\n-   - if the type is marked as addressable (it is required to be constructed\n-     into the stack)\n-   - if the padding and mode of the type is such that a copy into a register\n-     would put it into the wrong part of the register.\n+bool\n+must_pass_in_stack_var_size (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     tree type)\n+{\n+  if (!type)\n+    return false;\n+\n+  /* If the type has variable size...  */\n+  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    return true;\n \n-   Which padding can't be supported depends on the byte endianness.\n+  /* If the type is marked as addressable (it is required\n+     to be constructed into the stack)...  */\n+  if (TREE_ADDRESSABLE (type))\n+    return true;\n+\n+  return false;\n+}\n \n-   A value in a register is implicitly padded at the most significant end.\n-   On a big-endian machine, that is the lower end in memory.\n-   So a value padded in memory at the upper end can't go in a register.\n-   For a little-endian machine, the reverse is true.  */\n+/* Another version of the TARGET_MUST_PASS_IN_STACK hook.  This one \n+   takes trailing padding of a structure into account.  */\n+/* ??? Should be able to merge these two by examining BLOCK_REG_PADDING.  */\n \n bool\n-default_must_pass_in_stack (enum machine_mode mode, tree type)\n+must_pass_in_stack_var_size_or_pad (enum machine_mode mode, tree type)\n {\n   if (!type)\n     return false;"}, {"sha": "422d6c6a44c7bbb9dad1d61d072f84501e0a4855", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -5842,7 +5842,8 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n \treturn alpha_arg_info_reg_val (cum);\n \n       num_args = cum.num_args;\n-      if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n+      if (num_args >= 6\n+\t  || targetm.calls.must_pass_in_stack (mode, type))\n \treturn NULL_RTX;\n     }\n #elif TARGET_ABI_UNICOSMK\n@@ -5885,8 +5886,9 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n \n       size = ALPHA_ARG_SIZE (mode, type, named);\n       num_args = cum.num_reg_words;\n-      if (MUST_PASS_IN_STACK (mode, type)\n-\t  || cum.num_reg_words + size > 6 || cum.force_stack)\n+      if (cum.force_stack\n+\t  || cum.num_reg_words + size > 6\n+\t  || targetm.calls.must_pass_in_stack (mode, type))\n \treturn NULL_RTX;\n       else if (type && TYPE_MODE (type) == BLKmode)\n \t{\n@@ -5918,7 +5920,7 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n       /* VOID is passed as a special flag for \"last argument\".  */\n       if (type == void_type_node)\n \tbasereg = 16;\n-      else if (MUST_PASS_IN_STACK (mode, type))\n+      else if (targetm.calls.must_pass_in_stack (mode, type))\n \treturn NULL_RTX;\n       else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n \tbasereg = 16;\n@@ -6232,7 +6234,7 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n \n   /* If the type could not be passed in registers, skip the block\n      reserved for the registers.  */\n-  if (MUST_PASS_IN_STACK (TYPE_MODE (type), type))\n+  if (targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n       t = fold_convert (TREE_TYPE (offset), build_int_2 (6*8, 0));\n       t = build (MODIFY_EXPR, TREE_TYPE (offset), offset,\n@@ -9285,6 +9287,24 @@ alpha_use_linkage (rtx linkage ATTRIBUTE_UNUSED,\n \f\n #if TARGET_ABI_UNICOSMK\n \n+/* This evaluates to true if we do not know how to pass TYPE solely in\n+   registers.  This is the case for all arguments that do not fit in two\n+   registers.  */\n+\n+static bool\n+unicosmk_must_pass_in_stack (enum machine_mode mode, tree type)\n+{\n+  if (type == NULL)\n+    return false;\n+\n+  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    return true;\n+  if (TREE_ADDRESSABLE (type))\n+    return true;\n+\n+  return ALPHA_ARG_SIZE (mode, type, 0) > 2;\n+}\n+\n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n \n@@ -10078,6 +10098,8 @@ alpha_init_libfuncs (void)\n # define TARGET_ASM_UNIQUE_SECTION unicosmk_unique_section\n # undef TARGET_ASM_GLOBALIZE_LABEL\n # define TARGET_ASM_GLOBALIZE_LABEL hook_void_FILEptr_constcharptr\n+# undef TARGET_MUST_PASS_IN_STACK\n+# define TARGET_MUST_PASS_IN_STACK unicosmk_must_pass_in_stack\n #endif\n \n #undef TARGET_ASM_ALIGNED_HI_OP"}, {"sha": "e142e5e177ae151efe16b03529d020c88125fbe0", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1040,10 +1040,9 @@ extern int alpha_memory_latency;\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n-    (CUM) = 6;\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    (CUM) += ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\n+  ((CUM) += \t\t\t\t\t\t\t\t\\\n+   (targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\t\\\n+    ? 6 : ALPHA_ARG_SIZE (MODE, TYPE, NAMED))\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,"}, {"sha": "7c9a6073fa653e03452922d424c17ac307905d67", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -124,15 +124,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define STACK_PARMS_IN_REG_PARM_AREA\n \n-/* This evaluates to nonzero if we do not know how to pass TYPE solely in\n-   registers. This is the case for all arguments that do not fit in two\n-   registers.  */\n-\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\t\t\\\n-  ((TYPE) != 0                                          \t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST      \t\t\\\n-       || (TREE_ADDRESSABLE (TYPE) || ALPHA_ARG_SIZE (MODE, TYPE, 0) > 2)))\n-\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n@@ -198,8 +189,9 @@ do {\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   size = ALPHA_ARG_SIZE (MODE, TYPE, NAMED);\t\t\t\\\n                                                                 \\\n-  if (size > 2 || MUST_PASS_IN_STACK (MODE, TYPE)\t\t\\\n-      || (CUM).num_reg_words + size > 6)\t\t\t\\\n+  if (size > 2\t\t\t\t\t\t\t\\\n+      || (CUM).num_reg_words + size > 6\t\t\t\t\\\n+      || targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\\\n     (CUM).force_stack = 1;\t\t\t\t\t\\\n                                                                 \\\n   if (! (CUM).force_stack)\t\t\t\t\t\\"}, {"sha": "b062d616c0085e2783d31be3efe90e2d2bceb3d9", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -179,7 +179,7 @@ typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n \n #undef FUNCTION_ARG_ADVANCE\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n+  if (targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\t\\\n     (CUM).num_args += 6;\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "bc384ee2e14960022a919419ec903483e12988b8", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -575,7 +575,7 @@ c4x_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname)\n \n \t  if ((mode = TYPE_MODE (type)))\n \t    {\n-\t      if (! MUST_PASS_IN_STACK (mode, type))\n+\t      if (! targetm.calls.must_pass_in_stack (mode, type))\n \t\t{\n \t\t  /* Look for float, double, or long double argument.  */\n \t\t  if (mode == QFmode || mode == HFmode)\n@@ -612,7 +612,7 @@ c4x_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (! TARGET_MEMPARM \n       && named\n       && type\n-      && ! MUST_PASS_IN_STACK (mode, type))\n+      && ! targetm.calls.must_pass_in_stack (mode, type))\n     {\n       /* Look for float, double, or long double argument.  */\n       if (mode == QFmode || mode == HFmode)\n@@ -678,7 +678,7 @@ c4x_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (! TARGET_MEMPARM \n       && named \n       && type\n-      && ! MUST_PASS_IN_STACK (mode, type))\n+      && ! targetm.calls.must_pass_in_stack (mode, type))\n     {\n       /* Look for float, double, or long double argument.  */\n       if (mode == QFmode || mode == HFmode)"}, {"sha": "252992b0376eb072a78c342b5c8fa4562acb3e57", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -961,7 +961,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n  (((CUM).regs == (CRIS_MAX_ARGS_IN_REGS - 1)\t\t\t\\\n-   && !MUST_PASS_IN_STACK (MODE, TYPE)\t\t\t\t\\\n+   && !targetm.calls.must_pass_in_stack (MODE, TYPE)\t\t\\\n    && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 4\t\t\t\\\n    && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) <= 8)\t\t\t\\\n   ? 1 : 0)\n@@ -970,7 +970,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n    bytes long.  If you tweak this, don't forget to adjust\n    cris_expand_builtin_va_arg.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n- (MUST_PASS_IN_STACK (MODE, TYPE)\t\t\t\t\t\\\n+ (targetm.calls.must_pass_in_stack (MODE, TYPE)\t\t\t\t\\\n   || CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 8)\t\t\t\t\\\n \n /* Contrary to what you'd believe, defining FUNCTION_ARG_CALLEE_COPIES"}, {"sha": "017acfd40d28c360f6547b312bf29a32a21ad5cd", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -124,6 +124,7 @@ static struct fr30_frame_info \tzero_frame_info;\n static void fr30_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static tree fr30_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+static bool fr30_must_pass_in_stack (enum machine_mode, tree);\n \n #define FRAME_POINTER_MASK \t(1 << (FRAME_POINTER_REGNUM))\n #define RETURN_POINTER_MASK \t(1 << (RETURN_POINTER_REGNUM))\n@@ -152,9 +153,11 @@ static tree fr30_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n #undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n-\n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS fr30_setup_incoming_varargs\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK fr30_must_pass_in_stack\n+\n #undef  TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR fr30_gimplify_va_arg_expr\n \n@@ -664,14 +667,27 @@ fr30_print_operand (FILE *file, rtx x, int code)\n /*}}}*/\n /*{{{  Function arguments */ \n \n+/* Return true if we should pass an argument on the stack rather than\n+   in registers.  */\n+\n+static bool\n+fr30_must_pass_in_stack (enum machine_mode mode, tree type)\n+{\n+  if (mode == BLKmode)\n+    return true;\n+  if (type == NULL)\n+    return false;\n+  return AGGREGATE_TYPE_P (type);\n+}\n+\n /* Compute the number of word sized registers needed to hold a\n    function argument of mode INT_MODE and tree type TYPE.  */\n int\n fr30_num_arg_regs (enum machine_mode mode, tree type)\n {\n   int size;\n \n-  if (MUST_PASS_IN_STACK (mode, type))\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n \n   if (type && mode == BLKmode)"}, {"sha": "b8bec8e4fc472b628328d65733213d01939548c7", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -651,46 +651,13 @@ enum reg_class\n /*}}}*/ \f\n /*{{{  Function Arguments in Registers.  */ \n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   We cannot do so in the following cases:\n-\n-   - if the type has variable size\n-   - if the type is marked as addressable (it is required to be constructed\n-     into the stack)\n-   - if the type is a structure or union.  */\n-\n-#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n-   (((MODE) == BLKmode)\t\t\t\t\t\t\\\n-    || ((TYPE) != NULL\t\t\t\t\t\t\\\n-         && TYPE_SIZE (TYPE) != NULL\t\t\t\t\\\n-         && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-\t     || TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\\\n-\t     || TREE_CODE (TYPE) == UNION_TYPE\t\t\t\\\n-\t     || TREE_CODE (TYPE) == QUAL_UNION_TYPE\t\t\\\n-             || TREE_ADDRESSABLE (TYPE))))\n-\n /* The number of register assigned to holding function arguments.  */\n      \n #define FR30_NUM_ARG_REGS\t 4\n \n-/* A C expression that controls whether a function argument is passed in a\n-   register, and which register.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine where\n-   some arguments are usually passed in registers, is to cause nameless\n-   arguments to be passed on the stack instead.  This is done by making\n-   `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n-   this macro to determine if this argument is of a type that must be passed in\n-   the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns nonzero for such an argument, the compiler will abort.  If\n-   `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n-   stack and then loaded into a register.  */\n-     \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n   (  (NAMED) == 0                    ? NULL_RTX\t\t\t\\\n-   : MUST_PASS_IN_STACK (MODE, TYPE) ? NULL_RTX\t\t\t\\\n+   : targetm.calls.must_pass_in_stack (MODE, TYPE) ? NULL_RTX\t\\\n    : (CUM) >= FR30_NUM_ARG_REGS      ? NULL_RTX\t\t\t\\\n    : gen_rtx_REG (MODE, CUM + FIRST_ARG_REGNUM))\n \n@@ -727,18 +694,8 @@ enum reg_class\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\\\n   fr30_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n \n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.  The\n-   pointer is passed in whatever way is appropriate for passing a pointer to\n-   that type.\n-\n-   On machines where `REG_PARM_STACK_SPACE' is not defined, a suitable\n-   definition of this macro might be:\n-        #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  \\\n-          MUST_PASS_IN_STACK (MODE, TYPE)  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  MUST_PASS_IN_STACK (MODE, TYPE)\n+  targetm.calls.must_pass_in_stack (MODE, TYPE)\n \n /* A C statement (sans semicolon) for initializing the variable CUM for the\n    state at the beginning of the argument list.  The variable has type"}, {"sha": "4d05bd45f38eb00a6567ea673aeec8873cb2adf6", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -287,6 +287,7 @@ static void frv_output_const_unspec\t\t(FILE *,\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n static tree frv_gimplify_va_arg_expr\t\t(tree, tree, tree *, tree *);\n+static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n@@ -327,6 +328,8 @@ static tree frv_gimplify_va_arg_expr\t\t(tree, tree, tree *, tree *);\n \n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX frv_struct_value_rtx\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK frv_must_pass_in_stack\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS frv_expand_builtin_saveregs\n@@ -3026,6 +3029,19 @@ frv_init_cumulative_args (CUMULATIVE_ARGS *cum,\n }\n \n \f\n+/* Return true if we should pass an argument on the stack rather than\n+   in registers.  */\n+\n+static bool\n+frv_must_pass_in_stack (enum machine_mode mode, tree type)\n+{\n+  if (mode == BLKmode)\n+    return true;\n+  if (type == NULL)\n+    return false;\n+  return AGGREGATE_TYPE_P (type);\n+}\n+\n /* If defined, a C expression that gives the alignment boundary, in bits, of an\n    argument with the specified mode and type.  If it is not defined,\n    `PARM_BOUNDARY' is used for all arguments.  */\n@@ -3037,37 +3053,6 @@ frv_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return BITS_PER_WORD;\n }\n \n-\f\n-/* A C expression that controls whether a function argument is passed in a\n-   register, and which register.\n-\n-   The arguments are CUM, of type CUMULATIVE_ARGS, which summarizes (in a way\n-   defined by INIT_CUMULATIVE_ARGS and FUNCTION_ARG_ADVANCE) all of the previous\n-   arguments so far passed in registers; MODE, the machine mode of the argument;\n-   TYPE, the data type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED, which is 1 for an\n-   ordinary argument and 0 for nameless arguments that correspond to `...' in the\n-   called function's prototype.\n-\n-   The value of the expression should either be a `reg' RTX for the hard\n-   register in which to pass the argument, or zero to pass the argument on the\n-   stack.\n-\n-   For machines like the VAX and 68000, where normally all arguments are\n-   pushed, zero suffices as a definition.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine where\n-   some arguments are usually passed in registers, is to cause nameless\n-   arguments to be passed on the stack instead.  This is done by making\n-   `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n-   this macro to determine if this argument is of a type that must be passed in\n-   the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns nonzero for such an argument, the compiler will abort.  If\n-   `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n-   stack and then loaded into a register.  */\n-\n rtx\n frv_function_arg (CUMULATIVE_ARGS *cum,\n                   enum machine_mode mode,\n@@ -3177,25 +3162,13 @@ frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n }\n \n \f\n-\n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.  The\n-   pointer is passed in whatever way is appropriate for passing a pointer to\n-   that type.\n-\n-   On machines where `REG_PARM_STACK_SPACE' is not defined, a suitable\n-   definition of this macro might be\n-        #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  \\\n-          MUST_PASS_IN_STACK (MODE, TYPE)  */\n-\n int\n frv_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n                                     enum machine_mode mode,\n                                     tree type,\n                                     int named ATTRIBUTE_UNUSED)\n {\n-  return MUST_PASS_IN_STACK (mode, type);\n+  return targetm.calls.must_pass_in_stack (mode, type);\n }\n \n /* If defined, a C expression that indicates when it is the called function's"}, {"sha": "493ebc76a4a830adb86c49ea65af983d48287b6b", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1860,58 +1860,10 @@ struct machine_function GTY(())\n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n \n \f\n-/* Function Arguments in Registers.  */\n-\n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   We cannot do so in the following cases:\n-\n-   - if the type has variable size\n-   - if the type is marked as addressable (it is required to be constructed\n-     into the stack)\n-   - if the type is a structure or union.  */\n-\n-#define MUST_PASS_IN_STACK(MODE,TYPE)                           \\\n-   (((MODE) == BLKmode)                                         \\\n-    || ((TYPE) != 0                                             \\\n-         && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST        \\\n-             || TREE_CODE (TYPE) == RECORD_TYPE                 \\\n-             || TREE_CODE (TYPE) == UNION_TYPE                  \\\n-             || TREE_CODE (TYPE) == QUAL_UNION_TYPE             \\\n-             || TREE_ADDRESSABLE (TYPE))))\n-\n /* The number of register assigned to holding function arguments.  */\n \n #define FRV_NUM_ARG_REGS        6\n \n-/* A C expression that controls whether a function argument is passed in a\n-   register, and which register.\n-\n-   The arguments are CUM, of type CUMULATIVE_ARGS, which summarizes (in a way\n-   defined by INIT_CUMULATIVE_ARGS and FUNCTION_ARG_ADVANCE) all of the previous\n-   arguments so far passed in registers; MODE, the machine mode of the argument;\n-   TYPE, the data type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED, which is 1 for an\n-   ordinary argument and 0 for nameless arguments that correspond to `...' in the\n-   called function's prototype.\n-\n-   The value of the expression should either be a `reg' RTX for the hard\n-   register in which to pass the argument, or zero to pass the argument on the\n-   stack.\n-\n-   For machines like the VAX and 68000, where normally all arguments are\n-   pushed, zero suffices as a definition.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine where\n-   some arguments are usually passed in registers, is to cause nameless\n-   arguments to be passed on the stack instead.  This is done by making\n-   `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n-   this macro to determine if this argument is of a type that must be passed in\n-   the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns nonzero for such an argument, the compiler will abort.  If\n-   `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n-   stack and then loaded into a register.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)                    \\\n   frv_function_arg (&CUM, MODE, TYPE, NAMED, FALSE)\n \n@@ -1949,16 +1901,6 @@ struct machine_function GTY(())\n \n /* extern int frv_function_arg_partial_nregs (CUMULATIVE_ARGS, int, Tree, int);  */\n \n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.  The\n-   pointer is passed in whatever way is appropriate for passing a pointer to\n-   that type.\n-\n-   On machines where `REG_PARM_STACK_SPACE' is not defined, a suitable\n-   definition of this macro might be\n-        #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  \\\n-          MUST_PASS_IN_STACK (MODE, TYPE)  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   frv_function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n "}, {"sha": "7fb122dc6d8cbcff7d9d66d676fd1eb8c7461d14", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -216,7 +216,6 @@ extern int x86_field_alignment (tree, int);\n #endif\n \n extern rtx ix86_tls_get_addr (void);\n-extern bool ix86_must_pass_in_stack (enum machine_mode mode, tree);\n \n extern void ix86_expand_vector_init (rtx, rtx);\n /* In winnt.c  */"}, {"sha": "9b6e30e8fd86e734c0a6e6bcd0584df983327b84", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -928,6 +928,7 @@ static int extended_reg_mentioned_1 (rtx *, void *);\n static bool ix86_rtx_costs (rtx, int, int, int *);\n static int min_insn_size (rtx);\n static tree ix86_md_asm_clobbers (tree clobbers);\n+static bool ix86_must_pass_in_stack (enum machine_mode mode, tree type);\n \n #if defined (DO_GLOBAL_CTORS_BODY) && defined (HAS_INIT_SECTION)\n static void ix86_svr3_asm_out_constructor (rtx, int);\n@@ -1071,6 +1072,8 @@ static void init_ext_80387_constants (void);\n #define TARGET_STRUCT_VALUE_RTX ix86_struct_value_rtx\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS ix86_setup_incoming_varargs\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK ix86_must_pass_in_stack\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n@@ -1905,6 +1908,16 @@ ix86_function_arg_regno_p (int regno)\n   return false;\n }\n \n+/* Return if we do not know how to pass TYPE solely in registers.  */\n+\n+static bool\n+ix86_must_pass_in_stack (enum machine_mode mode, tree type)\n+{\n+  if (must_pass_in_stack_var_size_or_pad (mode, type))\n+    return true;\n+  return (!TARGET_64BIT && type && mode == TImode);\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n@@ -2060,7 +2073,7 @@ classify_argument (enum machine_mode mode, tree type,\n     return 0;\n \n   if (mode != VOIDmode\n-      && MUST_PASS_IN_STACK (mode, type))\n+      && targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n \n   if (type && AGGREGATE_TYPE_P (type))\n@@ -15848,15 +15861,6 @@ x86_emit_floatuns (rtx operands[2])\n   emit_label (donelab);\n }\n \n-/* Return if we do not know how to pass TYPE solely in registers.  */\n-bool\n-ix86_must_pass_in_stack (enum machine_mode mode, tree type)\n-{\n-   if (default_must_pass_in_stack (mode, type))\n-     return true;\n-   return (!TARGET_64BIT && type && mode == TImode);\n-}\n-\n /* Initialize vector TARGET via VALS.  */\n void\n ix86_expand_vector_init (rtx target, rtx vals)"}, {"sha": "33cd861819fd9e25e27e385a04ad6c97ce51373b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1662,13 +1662,6 @@ enum reg_class\n    which.  */\n #define REG_PARM_STACK_SPACE(FNDECL) 0\n \n-/* Define as a C expression that evaluates to nonzero if we do not know how\n-   to pass TYPE solely in registers.  The file expr.h defines a\n-   definition that is usually appropriate, refer to expr.h for additional\n-   documentation. If `REG_PARM_STACK_SPACE' is defined, the argument will be\n-   computed in the stack and then loaded into a register.  */\n-#define MUST_PASS_IN_STACK(MODE, TYPE)  ix86_must_pass_in_stack ((MODE), (TYPE))\n-\n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),"}, {"sha": "51e410eb2c8058d27479a3989d9a81e2687da229", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -402,11 +402,12 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_STRUCT_VALUE_RTX ia64_struct_value_rtx\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ia64_return_in_memory\n-\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS ia64_setup_incoming_varargs\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ia64_gimplify_va_arg"}, {"sha": "0e649e3442e39e7aeb99b8991e7d345c44d3b4ed", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1328,13 +1328,6 @@ enum reg_class\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n   ia64_function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-\n-#define MUST_PASS_IN_STACK(MODE, TYPE) \\\n-  ((TYPE) != 0\t\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far.  */"}, {"sha": "ac9b5d138ee7896aad01d7228108642884166703", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -2498,7 +2498,7 @@ function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   /* We must pass by reference if we would be both passing in registers\n      and the stack.  This is because any subsequent partial arg would be\n      handled incorrectly in this case.  */\n-  if (cum && MUST_PASS_IN_STACK (mode, type))\n+  if (cum && targetm.calls.must_pass_in_stack (mode, type))\n      {\n        /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n \t  get double copies of any offsets generated for small structs"}, {"sha": "9bc3313badcaa1589da3b411bc490d516331f816", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -137,12 +137,13 @@ static tree m32r_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n #undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n-\n #undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY m32r_return_in_memory\n-\n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS m32r_setup_incoming_varargs\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+\n #undef  TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR m32r_gimplify_va_arg_expr\n "}, {"sha": "6300967afc03802a2adc746e1065f445082a8f06", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1033,12 +1033,6 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    SIZE is the number of bytes of arguments passed on the stack.  */\n #define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself"}, {"sha": "ede6f93a3dbf27e641ad8a589bae38e5585ea326", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -38,7 +38,6 @@ extern int          mcore_naked_function_p       \t(void);\n #ifdef HAVE_MACHINE_MODES\n extern int          mcore_function_arg_partial_nregs\t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n extern int          mcore_num_arg_regs           \t(enum machine_mode, tree);\n-extern int          mcore_must_pass_on_stack     \t(enum machine_mode, tree);\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef RTX_CODE"}, {"sha": "7bad189422edd3d8c4eb6c67cc2603458ded5394", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -192,6 +192,8 @@ static bool       mcore_return_in_memory\t(tree, tree);\n \n #undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY\t\tmcore_return_in_memory\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK\tmust_pass_in_stack_var_size\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tmcore_setup_incoming_varargs\n@@ -3001,20 +3003,6 @@ mcore_override_options (void)\n     target_flags |= M340_BIT;\n }\n \f\n-int\n-mcore_must_pass_on_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n-{\n-  if (type == NULL)\n-    return 0;\n-\n-  /* If the argument can have its address taken, it must\n-     be placed on the stack.  */\n-  if (TREE_ADDRESSABLE (type))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Compute the number of word sized registers needed to \n    hold a function argument of mode MODE and type TYPE.  */\n \n@@ -3023,7 +3011,7 @@ mcore_num_arg_regs (enum machine_mode mode, tree type)\n {\n   int size;\n \n-  if (MUST_PASS_IN_STACK (mode, type))\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n \n   if (type && mode == BLKmode)\n@@ -3118,7 +3106,7 @@ mcore_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   if (! named)\n     return 0;\n \n-  if (MUST_PASS_IN_STACK (mode, type))\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n \n   arg_reg = ROUND_REG (cum, mode);\n@@ -3146,7 +3134,7 @@ mcore_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   if (named == 0)\n     return 0;\n \n-  if (MUST_PASS_IN_STACK (mode, type))\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n       \n   /* REG is not the *hardware* register number of the register that holds"}, {"sha": "b026c1416b92810dd10ab8e6bdc16614a694705f", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -662,9 +662,6 @@ extern const enum reg_class reg_class_from_letter[];\n    On the MCore, only r4 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  ((REGNO) == FIRST_RET_REG)\n \n-#define\tMUST_PASS_IN_STACK(MODE,TYPE)  \\\n-  mcore_must_pass_on_stack (MODE, TYPE)\n-\n /* 1 if N is a possible register number for function argument passing.  */\n #define FUNCTION_ARG_REGNO_P(REGNO)  \\\n   ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n@@ -721,7 +718,7 @@ extern const enum reg_class reg_class_from_letter[];\n    the argument itself.  The pointer is passed in whatever way is\n    appropriate for passing a pointer to that type.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  MUST_PASS_IN_STACK (MODE, TYPE)\n+  targetm.calls.must_pass_in_stack (MODE, TYPE)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used."}, {"sha": "cb470b4c2240e00ddede2740cb3b455f0ff6d915", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -738,6 +738,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_SETUP_INCOMING_VARARGS mips_setup_incoming_varargs\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING mips_strict_argument_naming\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -3552,7 +3554,7 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \teven_reg_p = true;\n     }\n \n-  if (mips_abi != ABI_EABI && MUST_PASS_IN_STACK (mode, type))\n+  if (mips_abi != ABI_EABI && targetm.calls.must_pass_in_stack (mode, type))\n     /* This argument must be passed on the stack.  Eat up all the\n        remaining registers.  */\n     info->reg_offset = MAX_ARGS_IN_REGISTERS;\n@@ -4284,7 +4286,7 @@ mips_va_arg (tree valist, tree type)\n \n       /* If arguments of type TYPE must be passed on the stack,\n \t set MIN_OFFSET to the offset of the first stack parameter.  */\n-      if (!MUST_PASS_IN_STACK (TYPE_MODE (type), type))\n+      if (!targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n \tmin_offset = 0;\n       else if (TARGET_NEWABI)\n \tmin_offset = current_function_pretend_args_size;"}, {"sha": "04e6ee4e8c6b4b614624174829d8d0332aba435e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -2364,14 +2364,6 @@ typedef struct mips_args {\n   (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\\n    && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n \n-/* Modified version of the macro in expr.h.  Only return true if\n-   the type has a variable size or if the front end requires it\n-   to be passed by reference.  */\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* True if using EABI and varargs can be passed in floating-point\n    registers.  Under these conditions, we need a more complex form\n    of va_list, which tracks GPR, FPR and stack arguments separately.  */"}, {"sha": "569acc20183d6ad56c367585c9d231b534851f54", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -578,7 +578,7 @@ mmix_function_arg (const CUMULATIVE_ARGS *argsp,\n       : NULL_RTX;\n \n   return (argsp->regs < MMIX_MAX_ARGS_IN_REGS\n-\t  && !MUST_PASS_IN_STACK (mode, type)\n+\t  && !targetm.calls.must_pass_in_stack (mode, type)\n \t  && (GET_MODE_BITSIZE (mode) <= 64\n \t      || argsp->lib\n \t      || TARGET_LIBFUNC))\n@@ -599,10 +599,10 @@ mmix_function_arg_pass_by_reference (const CUMULATIVE_ARGS *argsp,\n \t\t\t\t     tree type,\n \t\t\t\t     int named ATTRIBUTE_UNUSED)\n {\n-  /* FIXME: Check: I'm not sure the MUST_PASS_IN_STACK check is\n+  /* FIXME: Check: I'm not sure the must_pass_in_stack check is\n      necessary.  */\n   return\n-    MUST_PASS_IN_STACK (mode, type)\n+    targetm.calls.must_pass_in_stack (mode, type)\n     || (MMIX_FUNCTION_ARG_SIZE (mode, type) > 8\n \t&& !TARGET_LIBFUNC\n \t&& !argsp->lib);"}, {"sha": "5d68fa716c55aa2ac73586cdb9752521db5c9a29", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -740,7 +740,7 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n  ((CUM).regs\t\t\t\t\t\t\t\\\n-  = ((MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n+  = ((targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\\\n      || (MMIX_FUNCTION_ARG_SIZE (MODE, TYPE) > 8\t\t\\\n \t && !TARGET_LIBFUNC && !(CUM).lib))\t\t\t\\\n   ? (MMIX_MAX_ARGS_IN_REGS) + 1\t\t\t\t\t\\"}, {"sha": "bbc27bdf877b7fdb0927a37dbbf988c34005622a", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -265,6 +265,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_STRUCT_VALUE_RTX pa_struct_value_rtx\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY pa_return_in_memory\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS hppa_builtin_saveregs"}, {"sha": "dd6f356f3d09dbef283e87268d8000aad1b3e59f", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -890,12 +890,6 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-#define MUST_PASS_IN_STACK(MODE,TYPE) \\\n-  ((TYPE) != 0\t\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */"}, {"sha": "38196d7f324af8c430219c483ab0a8cffa774542", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -183,13 +183,6 @@\n #define AGGREGATE_PADDING_FIXED 1\n #define AGGREGATES_PAD_UPWARD_ALWAYS 1\n \n-/* We don't want anything in the reg parm area being passed on the\n-   stack.  */\n-#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n-   ((TYPE) != 0\t\t\t\t\t\t\t\\\n-    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n-\t|| TREE_ADDRESSABLE (TYPE)))\n-\n /* Specify padding for the last element of a block move between\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */"}, {"sha": "5ebc19c818b6a8f75bfd01bf7a80e81187d0f326", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -259,16 +259,6 @@\n #define AGGREGATE_PADDING_FIXED TARGET_64BIT\n #define AGGREGATES_PAD_UPWARD_ALWAYS 0\n \n-/* We don't want anything in the reg parm area being passed on the\n-   stack.  */\n-#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n-  ((TARGET_64BIT\t\t\t\t\t\t\\\n-    && (TYPE) != 0\t\t\t\t\t\t\\\n-    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n-\t|| TREE_ADDRESSABLE (TYPE)))\t\t\t\t\\\n-   || (!TARGET_64BIT\t\t\t\t\t\t\\\n-       && default_must_pass_in_stack ((MODE), (TYPE))))\n-\n /* Specify padding for the last element of a block move between\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */"}, {"sha": "ea81e8ba73489b3afc40d565a6b16b15aec5f6c5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -744,6 +744,7 @@ static tree get_prev_label (tree function_name);\n \n static tree rs6000_build_builtin_va_list (void);\n static tree rs6000_gimplify_va_arg (tree, tree, tree *, tree *);\n+static bool rs6000_must_pass_in_stack (enum machine_mode, tree);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -948,6 +949,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED hook_bool_CUMULATIVE_ARGS_true\n #undef TARGET_SPLIT_COMPLEX_ARG\n #define TARGET_SPLIT_COMPLEX_ARG hook_bool_tree_true\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK rs6000_must_pass_in_stack\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST rs6000_build_builtin_va_list\n@@ -4525,6 +4528,17 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n       }\n }\n \f\n+/* Return true if TYPE must be passed on the stack and not in registers.  */\n+\n+static bool\n+rs6000_must_pass_in_stack (enum machine_mode mode, tree type)\n+{\n+  if (DEFAULT_ABI == ABI_AIX || TARGET_64BIT)\n+    return must_pass_in_stack_var_size (mode, type);\n+  else\n+    return must_pass_in_stack_var_size_or_pad (mode, type);\n+}\n+\n /* If defined, a C expression which determines whether, and in which\n    direction, to pad out an argument with extra space.  The value\n    should be of type `enum direction': either `upward' to pad above\n@@ -5261,7 +5275,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       save_area = virtual_incoming_args_rtx;\n       cfun->machine->sysv_varargs_p = 0;\n \n-      if (MUST_PASS_IN_STACK (mode, type))\n+      if (targetm.calls.must_pass_in_stack (mode, type))\n \tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (type), type);\n     }\n "}, {"sha": "4003f1676d6f682b0bafceea570a85eec5dea1f5", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -436,6 +436,8 @@ static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n #define TARGET_STRICT_ARGUMENT_NAMING sh_strict_argument_naming\n #undef TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED sh_pretend_outgoing_varargs_named\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n@@ -6316,7 +6318,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   HOST_WIDE_INT size, rsize;\n   tree tmp, pptr_type_node;\n   tree addr, lab_over, result = NULL;\n-  int pass_by_ref = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n+  int pass_by_ref = targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n \n   if (pass_by_ref)\n     type = build_pointer_type (type);"}, {"sha": "a76bda1238ffd6ac4ced8b7c162d3ffd2314b44c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1725,14 +1725,6 @@ extern enum reg_class reg_class_from_letter[];\n    On SHcompact, the call trampoline pops arguments off the stack.  */\n #define CALL_POPS_ARGS(CUM) (TARGET_SHCOMPACT ? (CUM).stack_regs * 8 : 0)\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   Values that come in registers with inconvenient padding are stored\n-   to memory at the function start.  */\n-\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n /* Some subroutine macros specific to this machine.  */\n \n #define BASE_RETURN_VALUE_REG(MODE) \\\n@@ -2046,7 +2038,7 @@ struct sh_args {\n    registers are passed by reference, so that an SHmedia trampoline\n    loads them into the full 64-bits registers.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \\\n-  (MUST_PASS_IN_STACK ((MODE), (TYPE)) \\\n+  (targetm.calls.must_pass_in_stack ((MODE), (TYPE)) \\\n    || SHCOMPACT_BYREF ((CUM), (MODE), (TYPE), (NAMED)))\n \n #define SHCOMPACT_BYREF(CUM, MODE, TYPE, NAMED) \\"}, {"sha": "8f73f1b15f6af9f78ae4d8954ba04ec88b91c571", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -434,6 +434,8 @@ enum processor_type sparc_cpu;\n #define TARGET_STRUCT_VALUE_RTX sparc_struct_value_rtx\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY sparc_return_in_memory\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS sparc_builtin_saveregs"}, {"sha": "18de27f86ab9e9beeb6e9d7ab42bd7681209db2d", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1713,13 +1713,6 @@ init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (FNDECL));\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n function_arg_advance (& (CUM), (MODE), (TYPE), (NAMED))\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument."}, {"sha": "7f2a2feb7fe80dd3060d31de912e26559b278784", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -1229,7 +1229,7 @@ xstormy16_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n {\n   if (mode == VOIDmode)\n     return const0_rtx;\n-  if (MUST_PASS_IN_STACK (mode, type)\n+  if (targetm.calls.must_pass_in_stack (mode, type)\n       || cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n     return 0;\n   return gen_rtx_REG (mode, cum + 2);\n@@ -1325,7 +1325,7 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n   count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n \t\t NULL_TREE);\n \n-  must_stack = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n+  must_stack = targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n   size_tree = round_up (size_in_bytes (type), UNITS_PER_WORD);\n   gimplify_expr (&size_tree, pre_p, NULL, is_gimple_val, fb_rvalue);\n   "}, {"sha": "b3bd840ce04649596d2bd107141cff2417e7e310", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -255,6 +255,8 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #define TARGET_RETURN_IN_MEMORY xtensa_return_in_memory\n #undef TARGET_SPLIT_COMPLEX_ARG\n #define TARGET_SPLIT_COMPLEX_ARG hook_bool_tree_true\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS xtensa_builtin_saveregs\n@@ -2540,13 +2542,13 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   /* Check if the argument is in registers:\n \n      if ((AP).__va_ndx <= __MAX_ARGS_IN_REGISTERS * 4\n-         && !MUST_PASS_IN_STACK (type))\n+         && !must_pass_in_stack (type))\n         __array = (AP).__va_reg; */\n \n   array = create_tmp_var (ptr_type_node, NULL);\n \n   lab_over = NULL;\n-  if (!MUST_PASS_IN_STACK (VOIDmode, type))\n+  if (!targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n       lab_false = create_artificial_label ();\n       lab_over = create_artificial_label ();"}, {"sha": "1321448dcd129c3f0ce7b77f5d9a083ed9310076", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -774,22 +774,6 @@ typedef struct xtensa_args\n       ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n       : GET_MODE_ALIGNMENT (MODE)))\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   We cannot do so in the following cases:\n-\n-   - if the type has variable size\n-   - if the type is marked as addressable (it is required to be constructed\n-     into the stack)\n-\n-   This differs from the default in that it does not check if the padding\n-   and mode of the type are such that a copy into a register would put it\n-   into the wrong part of the register.  */\n-\n-#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n-\n /* Profiling Xtensa code is typically done with the built-in profiling\n    feature of Tensilica's instruction set simulator, which does not\n    require any compiler support.  Profiling code on a real (i.e.,"}, {"sha": "28dfe7d9e75d3ed6e1eac0d7ac694a8d7204fcae", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -3669,9 +3669,9 @@ where some arguments are usually passed in registers, is to cause\n nameless arguments to be passed on the stack instead.  This is done\n by making @code{FUNCTION_ARG} return 0 whenever @var{named} is 0.\n \n-@cindex @code{MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}\n+@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}\n @cindex @code{REG_PARM_STACK_SPACE}, and @code{FUNCTION_ARG}\n-You may use the macro @code{MUST_PASS_IN_STACK (@var{mode}, @var{type})}\n+You may use the hook @code{targetm.calls.must_pass_in_stack}\n in the definition of this macro to determine if this argument is of a\n type that must be passed in the stack.  If @code{REG_PARM_STACK_SPACE}\n is not defined and @code{FUNCTION_ARG} returns nonzero for such an\n@@ -3680,12 +3680,12 @@ defined, the argument will be computed in the stack and then loaded into\n a register.\n @end defmac\n \n-@defmac MUST_PASS_IN_STACK (@var{mode}, @var{type})\n-Define as a C expression that evaluates to nonzero if we do not know how\n-to pass TYPE solely in registers.  The file @file{expr.h} defines a\n+@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, tree @var{type})\n+This target hook should return @code{true} if we should not pass @var{type}\n+solely in registers.  The file @file{expr.h} defines a\n definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation.\n-@end defmac\n+@end deftypefn\n \n @defmac FUNCTION_INCOMING_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})\n Define this macro if the target machine has ``register windows'', so\n@@ -3734,7 +3734,7 @@ definition of this macro might be\n @smallexample\n #define FUNCTION_ARG_PASS_BY_REFERENCE\\\n (CUM, MODE, TYPE, NAMED)  \\\n-  MUST_PASS_IN_STACK (MODE, TYPE)\n+  targetm.calls.must_pass_in_stack (MODE, TYPE)\n @end smallexample\n @c this is *still* too long.  --mew 5feb93\n @end defmac"}, {"sha": "687b6e3943f47fe0e68ffa9511753e7ebf426386", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -218,12 +218,6 @@ do {\t\t\t\t\t\t\t\\\n tree split_complex_types (tree);\n tree split_complex_values (tree);\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-extern bool default_must_pass_in_stack (enum machine_mode, tree);\n-#ifndef MUST_PASS_IN_STACK\n-#define MUST_PASS_IN_STACK(MODE,TYPE) default_must_pass_in_stack(MODE, TYPE)\n-#endif\n-\n /* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n    Normally move_insn, so Pmode stack pointer.  */\n "}, {"sha": "19698f99214bea47d27da61811b3eb2694f2d109", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -2356,7 +2356,8 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \n   /* If this parameter was passed both in registers and in the stack, use\n      the copy on the stack.  */\n-  if (MUST_PASS_IN_STACK (data->promoted_mode, data->passed_type))\n+  if (targetm.calls.must_pass_in_stack (data->promoted_mode,\n+\t\t\t\t\tdata->passed_type))\n     entry_parm = 0;\n \n   if (entry_parm)"}, {"sha": "ce8f3ecd825b21ff11a04f916bf77fca2fce41a3", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -584,7 +584,8 @@ extern int snprintf (char *, size_t, const char *, ...);\n \tPROMOTE_FUNCTION_RETURN PROMOTE_PROTOTYPES STRUCT_VALUE_REGNUM\t\\\n \tSETUP_INCOMING_VARARGS EXPAND_BUILTIN_SAVEREGS\t\t\t\\\n \tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\t\t\\\n-\tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\n+\tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\t\\\n+\tMUST_PASS_IN_STACK\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "329e44b9b97c1ede5ab4fdbe920c06f82c1b91cb", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -364,6 +364,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_LATE_RTL_PROLOGUE_EPILOGUE false\n \n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n+\n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_RETURN,\t\t\t\t\\\n@@ -376,6 +378,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n    TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n+   TARGET_MUST_PASS_IN_STACK\t\t\t\t\t\\\n    }\n \n "}, {"sha": "2c38dc5dcc6af23d2025381a14afe47028f8e8ca", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -462,6 +462,12 @@ struct gcc_target\n     /* Given a complex type T, return true if a parameter of type T\n        should be passed as two scalars.  */\n     bool (* split_complex_arg) (tree type);\n+\n+    /* Return true if type T, mode MODE, may not be passed in registers,\n+       but must be passed on the stack.  */\n+    /* ??? This predicate should be applied strictly after pass-by-reference.\n+       Need audit to verify that this is the case.  */\n+    bool (* must_pass_in_stack) (enum machine_mode mode, tree t);\n   } calls;\n \n   /* Functions specific to the C++ frontend.  */"}, {"sha": "d2b06b3da15e7b6559f6f2edf01f43d029120df3", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9841365eb7e2908f9ba6b18a85910ee9024a54/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fe9841365eb7e2908f9ba6b18a85910ee9024a54", "patch": "@@ -3567,6 +3567,8 @@ extern int call_expr_flags (tree);\n \n extern int setjmp_call_p (tree);\n extern bool alloca_call_p (tree);\n+extern bool must_pass_in_stack_var_size (enum machine_mode, tree);\n+extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, tree);\n \n /* In attribs.c.  */\n "}]}