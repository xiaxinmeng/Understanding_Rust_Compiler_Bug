{"sha": "926ce8bd97ca33f20282e7fcaa83741e67aaed16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI2Y2U4YmQ5N2NhMzNmMjAyODJlN2ZjYWE4Mzc0MWU2N2FhZWQxNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-19T23:28:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-19T23:28:11Z"}, "message": "cvt.c: Remove uses of \"register\" specifier in declarations of arguments and local...\n\n\t* cvt.c: Remove uses of \"register\" specifier in\n\tdeclarations of arguments and local variables.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* expr.c: Likewise.\n\t* friend.c: Likewise.\n\t* lex.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* repo.c: Likewise.\n\t* search.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r74855", "tree": {"sha": "db50c20cd761100b68a6e16b3181750fe3f14753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db50c20cd761100b68a6e16b3181750fe3f14753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/926ce8bd97ca33f20282e7fcaa83741e67aaed16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/926ce8bd97ca33f20282e7fcaa83741e67aaed16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/926ce8bd97ca33f20282e7fcaa83741e67aaed16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/926ce8bd97ca33f20282e7fcaa83741e67aaed16/comments", "author": null, "committer": null, "parents": [{"sha": "49a27995217d813ec99f6c8b4be15c04cf668c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a27995217d813ec99f6c8b4be15c04cf668c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a27995217d813ec99f6c8b4be15c04cf668c57"}], "stats": {"total": 233, "additions": 123, "deletions": 110}, "files": [{"sha": "f57eb1b7875f9ead5a34d46ffe503e25121712a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -1,3 +1,19 @@\n+2003-12-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cvt.c: Remove uses of \"register\" specifier in\n+\tdeclarations of arguments and local variables.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* friend.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* repo.c: Likewise.\n+\t* search.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2003-12-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/12795"}, {"sha": "6f4af7dcafc685949578b8c834d0cc4f75a7b82e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -76,8 +76,8 @@ static void warn_ref_binding (tree, tree, tree);\n static tree\n cp_convert_to_pointer (tree type, tree expr, bool force)\n {\n-  register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form;\n+  tree intype = TREE_TYPE (expr);\n+  enum tree_code form;\n   tree rval;\n \n   if (IS_AGGR_TYPE (intype))\n@@ -306,8 +306,8 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n static tree\n convert_to_pointer_force (tree type, tree expr)\n {\n-  register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form = TREE_CODE (intype);\n+  tree intype = TREE_TYPE (expr);\n+  enum tree_code form = TREE_CODE (intype);\n   \n   if (form == POINTER_TYPE)\n     {\n@@ -449,8 +449,8 @@ tree\n convert_to_reference (tree reftype, tree expr, int convtype,\n                       int flags, tree decl)\n {\n-  register tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n-  register tree intype;\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n+  tree intype;\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n@@ -612,8 +612,8 @@ cp_convert (tree type, tree expr)\n tree\n ocp_convert (tree type, tree expr, int convtype, int flags)\n {\n-  register tree e = expr;\n-  register enum tree_code code = TREE_CODE (type);\n+  tree e = expr;\n+  enum tree_code code = TREE_CODE (type);\n \n   if (error_operand_p (e) || type == error_mark_node)\n     return error_mark_node;\n@@ -944,8 +944,8 @@ convert (tree type, tree expr)\n tree\n convert_force (tree type, tree expr, int convtype)\n {\n-  register tree e = expr;\n-  register enum tree_code code = TREE_CODE (type);\n+  tree e = expr;\n+  enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n     return fold (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,"}, {"sha": "671e420c60bd27c0906604e40489ffd40b22566f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -425,7 +425,7 @@ pop_labels (tree block)\n tree\n poplevel (int keep, int reverse, int functionbody)\n {\n-  register tree link;\n+  tree link;\n   /* The chain of decls was accumulated in reverse order.\n      Put it into forward order, just for cleanliness.  */\n   tree decls;\n@@ -1556,8 +1556,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n   /* Deal with C++: must preserve virtual function table size.  */\n   if (TREE_CODE (olddecl) == TYPE_DECL)\n     {\n-      register tree newtype = TREE_TYPE (newdecl);\n-      register tree oldtype = TREE_TYPE (olddecl);\n+      tree newtype = TREE_TYPE (newdecl);\n+      tree oldtype = TREE_TYPE (olddecl);\n \n       if (newtype != error_mark_node && oldtype != error_mark_node\n \t  && TYPE_LANG_SPECIFIC (newtype) && TYPE_LANG_SPECIFIC (oldtype))\n@@ -1939,7 +1939,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n tree\n implicitly_declare (tree functionid)\n {\n-  register tree decl;\n+  tree decl;\n \n   /* We used to reuse an old implicit decl here,\n      but this loses with inline functions because it can clobber\n@@ -2348,7 +2348,7 @@ define_label (location_t location, tree name)\n {\n   tree decl = lookup_label (name);\n   struct named_label_list *ent;\n-  register struct cp_binding_level *p;\n+  struct cp_binding_level *p;\n \n   timevar_push (TV_NAME_LOOKUP);\n   for (ent = named_labels; ent; ent = ent->next)\n@@ -2439,7 +2439,7 @@ tree\n finish_case_label (tree low_value, tree high_value)\n {\n   tree cond, r;\n-  register struct cp_binding_level *p;\n+  struct cp_binding_level *p;\n \n   if (processing_template_decl)\n     {\n@@ -3441,7 +3441,7 @@ check_tag_decl (tree declspecs)\n   int saw_friend = 0;\n   int saw_typedef = 0;\n   tree ob_modifier = NULL_TREE;\n-  register tree link;\n+  tree link;\n   /* If a class, struct, or enum type is declared by the DECLSPECS\n      (i.e, if a class-specifier, enum-specifier, or non-typename\n      elaborated-type-specifier appears in the DECLSPECS),\n@@ -3638,7 +3638,7 @@ start_decl (tree declarator,\n             tree prefix_attributes)\n {\n   tree decl;\n-  register tree type, tem;\n+  tree type, tem;\n   tree context;\n \n   /* This should only be done once on the top most decl.  */\n@@ -5286,7 +5286,7 @@ start_handler_parms (tree declspecs, tree declarator)\n int\n complete_array_type (tree type, tree initial_value, int do_default)\n {\n-  register tree maxindex = NULL_TREE;\n+  tree maxindex = NULL_TREE;\n   int value = 0;\n \n   if (initial_value)\n@@ -6350,7 +6350,7 @@ grokdeclarator (tree declarator,\n      and get it as a string, for an error message.  */\n   {\n     tree *next = &declarator;\n-    register tree decl;\n+    tree decl;\n     name = NULL;\n \n     while (next && *next)\n@@ -6674,8 +6674,8 @@ grokdeclarator (tree declarator,\n \n   for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n     {\n-      register int i;\n-      register tree id;\n+      int i;\n+      tree id;\n \n       /* Certain parse errors slip through.  For example,\n \t `int class;' is not caught by the parser. Try\n@@ -6779,7 +6779,7 @@ grokdeclarator (tree declarator,\n \terror (\"two or more data types in declaration of `%s'\", name);\n       else if (TREE_CODE (id) == IDENTIFIER_NODE)\n \t{\n-\t  register tree t = lookup_name (id, 1);\n+\t  tree t = lookup_name (id, 1);\n \t  if (!t || TREE_CODE (t) != TYPE_DECL)\n \t    error (\"`%s' fails to be a typedef or built in type\",\n \t\t   IDENTIFIER_POINTER (id));\n@@ -7098,7 +7098,7 @@ grokdeclarator (tree declarator,\n \t  if (decl_context == FIELD)\n \t    {\n \t      tree tmp = NULL_TREE;\n-\t      register int op = 0;\n+\t      int op = 0;\n \n \t      if (declarator)\n \t\t{\n@@ -7474,7 +7474,7 @@ grokdeclarator (tree declarator,\n \n \t  if (TREE_TYPE (declarator))\n \t    {\n-\t      register tree typemodlist;\n+\t      tree typemodlist;\n \t      int erred = 0;\n \t      int constp = 0;\n \t      int volatilep = 0;\n@@ -7993,7 +7993,7 @@ grokdeclarator (tree declarator,\n     }\n \n   {\n-    register tree decl;\n+    tree decl;\n \n     if (decl_context == PARM)\n       {\n@@ -9285,7 +9285,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t  bool globalize, bool template_header_p)\n {\n   enum tree_code code;\n-  register tree t;\n+  tree t;\n   struct cp_binding_level *b = current_binding_level;\n   tree context = NULL_TREE;\n \n@@ -9651,7 +9651,7 @@ xref_basetypes (tree ref, tree base_list)\n tree\n start_enum (tree name)\n {\n-  register tree enumtype = NULL_TREE;\n+  tree enumtype = NULL_TREE;\n   struct cp_binding_level *b = current_binding_level;\n \n   /* If this is the real definition for a previous forward reference,\n@@ -10387,8 +10387,8 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n static void\n store_parm_decls (tree current_function_parms)\n {\n-  register tree fndecl = current_function_decl;\n-  register tree parm;\n+  tree fndecl = current_function_decl;\n+  tree parm;\n \n   /* This is a chain of any other decls that came in among the parm\n      declarations.  If a parm is declared with  enum {foo, bar} x;\n@@ -10664,7 +10664,7 @@ finish_function_body (tree compstmt)\n tree\n finish_function (int flags)\n {\n-  register tree fndecl = current_function_decl;\n+  tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n   int inclass_inline = (flags & 2) != 0;\n   int nested;\n@@ -10960,10 +10960,10 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n tree\n finish_method (tree decl)\n {\n-  register tree fndecl = decl;\n+  tree fndecl = decl;\n   tree old_initial;\n \n-  register tree link;\n+  tree link;\n \n   if (decl == void_type_node)\n     return decl;"}, {"sha": "ae564f7d6c3d78c83a07ef9758783bb55d0571b0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -1037,8 +1037,7 @@ grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n tree\n grokbitfield (tree declarator, tree declspecs, tree width)\n {\n-  register tree value = grokdeclarator (declarator, declspecs, BITFIELD,\n-\t\t\t\t\t0, NULL);\n+  tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL);\n \n   if (! value) return NULL_TREE; /* friends went bad.  */\n "}, {"sha": "06a2e0c21468974025a4855ca7f5e66b025c2875", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -78,8 +78,8 @@ rtx\n cxx_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier)\n {\n   tree type = TREE_TYPE (exp);\n-  register enum machine_mode mode = TYPE_MODE (type);\n-  register enum tree_code code = TREE_CODE (exp);\n+  enum machine_mode mode = TYPE_MODE (type);\n+  enum tree_code code = TREE_CODE (exp);\n   rtx ret;\n \n   /* No sense saving up arithmetic to be done"}, {"sha": "46616b13608b9df770145eda003e6b6e7d84086c", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -39,7 +39,7 @@ int\n is_friend (tree type, tree supplicant)\n {\n   int declp;\n-  register tree list;\n+  tree list;\n   tree context;\n \n   if (supplicant == NULL_TREE || type == NULL_TREE)"}, {"sha": "d1a67b64d7fe6c6d8016e4bc0e99ffcc8301e7e1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -838,7 +838,7 @@ copy_type (tree type)\n tree\n cxx_make_type (enum tree_code code)\n {\n-  register tree t = make_node (code);\n+  tree t = make_node (code);\n \n   /* Create lang_type structure.  */\n   if (IS_AGGR_TYPE_CODE (code)"}, {"sha": "0c839a3d40768b60b209c3110a7bc3685a12baa2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -545,8 +545,8 @@ add_decl_to_level (tree decl, cxx_scope *b)\n tree\n pushdecl (tree x)\n {\n-  register tree t;\n-  register tree name;\n+  tree t;\n+  tree name;\n   int need_new_binding;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -1811,7 +1811,7 @@ make_anon_name (void)\n void\n clear_anon_tags (void)\n {\n-  register struct cp_binding_level *b;\n+  struct cp_binding_level *b;\n   static int last_cnt = 0;\n \n   /* Fast out if no new anon names were declared.  */\n@@ -1909,7 +1909,7 @@ push_using_decl (tree scope, tree name)\n tree\n pushdecl_with_scope (tree x, cxx_scope *level)\n {\n-  register struct cp_binding_level *b;\n+  struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -2335,7 +2335,7 @@ tree\n lookup_tag (enum tree_code form, tree name,\n             cxx_scope *binding_level, int thislevel_only)\n {\n-  register struct cp_binding_level *level;\n+  struct cp_binding_level *level;\n   /* Nonzero if, we should look past a template parameter level, even\n      if THISLEVEL_ONLY.  */\n   int allow_template_parms_p = 1;\n@@ -2344,7 +2344,7 @@ lookup_tag (enum tree_code form, tree name,\n   timevar_push (TV_NAME_LOOKUP);\n   for (level = binding_level; level; level = level->level_chain)\n     {\n-      register tree tail;\n+      tree tail;\n       if (type_is_anonymous && level->type_decls != NULL)\n         {\n           tree type = binding_table_find_anon_type (level->type_decls, name);\n@@ -2447,7 +2447,7 @@ lookup_tag (enum tree_code form, tree name,\n tree\n lookup_tag_reverse (tree type, tree name)\n {\n-  register struct cp_binding_level *level;\n+  struct cp_binding_level *level;\n \n   timevar_push (TV_NAME_LOOKUP);\n   for (level = current_binding_level; level; level = level->level_chain)\n@@ -2531,7 +2531,7 @@ pushlevel_class (void)\n void\n poplevel_class (void)\n {\n-  register struct cp_binding_level *level = class_binding_level;\n+  struct cp_binding_level *level = class_binding_level;\n   tree shadowed;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -3157,8 +3157,8 @@ do_namespace_alias (tree alias, tree namespace)\n tree\n pushdecl_namespace_level (tree x)\n {\n-  register struct cp_binding_level *b = current_binding_level;\n-  register tree t;\n+  struct cp_binding_level *b = current_binding_level;\n+  tree t;\n \n   timevar_push (TV_NAME_LOOKUP);\n   t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n@@ -3977,7 +3977,7 @@ lookup_name_current_level (tree name)\n static tree\n lookup_type_current_level (tree name)\n {\n-  register tree t = NULL_TREE;\n+  tree t = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (current_binding_level->kind != sk_namespace, \n@@ -4491,7 +4491,7 @@ maybe_process_template_type_declaration (tree type, int globalize,\n void\n pushtag (tree name, tree type, int globalize)\n {\n-  register struct cp_binding_level *b;\n+  struct cp_binding_level *b;\n \n   timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n@@ -4514,7 +4514,7 @@ pushtag (tree name, tree type, int globalize)\n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n-          register tree d = NULL_TREE;\n+          tree d = NULL_TREE;\n \t  int in_class = 0;\n \t  tree context = TYPE_CONTEXT (type);\n "}, {"sha": "a9a5b35c293b51de6c71e720c180823545485dd6", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -267,7 +267,7 @@ get_base_filename (const char *filename)\n static void\n open_repo_file (const char *filename)\n {\n-  register const char *p;\n+  const char *p;\n   const char *s = get_base_filename (filename);\n \n   if (s == NULL)"}, {"sha": "15927c69166e00886e132772d5ea5339fd58e4b4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -125,7 +125,7 @@ push_search_level (struct stack_level *stack, struct obstack *obstack)\n static struct search_level *\n pop_search_level (struct stack_level *obstack)\n {\n-  register struct search_level *stack = pop_stack_level (obstack);\n+  struct search_level *stack = pop_stack_level (obstack);\n \n   return stack;\n }\n@@ -422,7 +422,7 @@ get_dynamic_cast_base_type (tree subtype, tree target)\n tree\n lookup_field_1 (tree type, tree name, bool want_type)\n {\n-  register tree field;\n+  tree field;\n \n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n       || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM"}, {"sha": "74e73992e9314c093872c636641b3ee618fef171", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -1295,9 +1295,9 @@ break_out_target_exprs (tree t)\n tree\n build_min_nt (enum tree_code code, ...)\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n   va_list p;\n \n   va_start (p, code);\n@@ -1321,9 +1321,9 @@ build_min_nt (enum tree_code code, ...)\n tree\n build_min (enum tree_code code, tree tt, ...)\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n   va_list p;\n \n   va_start (p, tt);\n@@ -1352,9 +1352,9 @@ build_min (enum tree_code code, tree tt, ...)\n tree\n build_min_non_dep (enum tree_code code, tree non_dep, ...)\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n   va_list p;\n \n   va_start (p, non_dep);\n@@ -1454,7 +1454,7 @@ decl_namespace_context (tree decl)\n bool\n cp_tree_equal (tree t1, tree t2)\n {\n-  register enum tree_code code1, code2;\n+  enum tree_code code1, code2;\n \n   if (t1 == t2)\n     return true;"}, {"sha": "6c95c04357905091949f40559b3961dbba03a9c4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -579,8 +579,8 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n tree\n merge_types (tree t1, tree t2)\n {\n-  register enum tree_code code1;\n-  register enum tree_code code2;\n+  enum tree_code code1;\n+  enum tree_code code2;\n   tree attributes;\n \n   /* Save time if the two types are the same.  */\n@@ -1265,8 +1265,8 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n tree\n decay_conversion (tree exp)\n {\n-  register tree type;\n-  register enum tree_code code;\n+  tree type;\n+  enum tree_code code;\n \n   type = TREE_TYPE (exp);\n   code = TREE_CODE (type);\n@@ -1317,7 +1317,7 @@ decay_conversion (tree exp)\n     return build_unary_op (ADDR_EXPR, exp, 0);\n   if (code == ARRAY_TYPE)\n     {\n-      register tree adr;\n+      tree adr;\n       tree ptrtype;\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n@@ -2010,7 +2010,7 @@ build_x_indirect_ref (tree expr, const char *errorstring)\n tree\n build_indirect_ref (tree ptr, const char *errorstring)\n {\n-  register tree pointer, type;\n+  tree pointer, type;\n \n   if (ptr == error_mark_node)\n     return error_mark_node;\n@@ -2348,8 +2348,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n tree\n build_function_call (tree function, tree params)\n {\n-  register tree fntype, fndecl;\n-  register tree coerced_params;\n+  tree fntype, fndecl;\n+  tree coerced_params;\n   tree result;\n   tree name = NULL_TREE, assembler_name = NULL_TREE;\n   int is_method;\n@@ -2466,8 +2466,8 @@ build_function_call (tree function, tree params)\n tree\n convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n {\n-  register tree typetail, valtail;\n-  register tree result = NULL_TREE;\n+  tree typetail, valtail;\n+  tree result = NULL_TREE;\n   const char *called_thing = 0;\n   int i = 0;\n \n@@ -2492,8 +2492,8 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n        valtail;\n        valtail = TREE_CHAIN (valtail), i++)\n     {\n-      register tree type = typetail ? TREE_VALUE (typetail) : 0;\n-      register tree val = TREE_VALUE (valtail);\n+      tree type = typetail ? TREE_VALUE (typetail) : 0;\n+      tree val = TREE_VALUE (valtail);\n \n       if (val == error_mark_node)\n \treturn error_mark_node;\n@@ -2677,17 +2677,17 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t int convert_p ATTRIBUTE_UNUSED)\n {\n   tree op0, op1;\n-  register enum tree_code code0, code1;\n+  enum tree_code code0, code1;\n   tree type0, type1;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n      but in some special cases we change it.  */\n-  register enum tree_code resultcode = code;\n+  enum tree_code resultcode = code;\n \n   /* Data type in which the computation is to be performed.\n      In the simplest cases this is the common type of the arguments.  */\n-  register tree result_type = NULL;\n+  tree result_type = NULL;\n \n   /* Nonzero means operands have already been type-converted\n      in whatever way is necessary.\n@@ -3396,8 +3396,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     build_type = result_type;\n \n   {\n-    register tree result = build (resultcode, build_type, op0, op1);\n-    register tree folded;\n+    tree result = build (resultcode, build_type, op0, op1);\n+    tree folded;\n \n     folded = fold (result);\n     if (folded == result)\n@@ -3412,8 +3412,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n    of pointer PTROP and integer INTOP.  */\n \n static tree\n-cp_pointer_int_sum (enum tree_code resultcode, register tree ptrop,\n-\t\t    register tree intop)\n+cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n {\n   tree res_type = TREE_TYPE (ptrop);\n \n@@ -3431,9 +3430,9 @@ cp_pointer_int_sum (enum tree_code resultcode, register tree ptrop,\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (register tree op0, register tree op1, register tree ptrtype)\n+pointer_diff (tree op0, tree op1, tree ptrtype)\n {\n-  register tree result, folded;\n+  tree result, folded;\n   tree restype = ptrdiff_type_node;\n   tree target_type = TREE_TYPE (ptrtype);\n \n@@ -3630,8 +3629,8 @@ tree\n build_unary_op (enum tree_code code, tree xarg, int noconvert)\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n-  register tree arg = xarg;\n-  register tree argtype = 0;\n+  tree arg = xarg;\n+  tree argtype = 0;\n   const char *errstring = NULL;\n   tree val;\n \n@@ -3769,7 +3768,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t0);\n \n       {\n-\tregister tree inc;\n+\ttree inc;\n \ttree result_type = TREE_TYPE (arg);\n \n \targ = get_unwidened (arg, 0);\n@@ -4214,7 +4213,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n bool\n cxx_mark_addressable (tree exp)\n {\n-  register tree x = exp;\n+  tree x = exp;\n \n   while (1)\n     switch (TREE_CODE (x))\n@@ -4750,7 +4749,7 @@ build_const_cast (tree type, tree expr)\n tree\n build_c_cast (tree type, tree expr)\n {\n-  register tree value = expr;\n+  tree value = expr;\n   tree otype;\n \n   if (type == error_mark_node || expr == error_mark_node)\n@@ -4915,7 +4914,7 @@ build_c_cast (tree type, tree expr)\n tree\n build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n {\n-  register tree result;\n+  tree result;\n   tree newrhs = rhs;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n@@ -5589,8 +5588,8 @@ static tree\n convert_for_assignment (tree type, tree rhs,\n \t\t\tconst char *errtype, tree fndecl, int parmnum)\n {\n-  register tree rhstype;\n-  register enum tree_code coder;\n+  tree rhstype;\n+  enum tree_code coder;\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n@@ -5688,9 +5687,9 @@ tree\n convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \t\t\t    const char *errtype, tree fndecl, int parmnum)\n {\n-  register enum tree_code codel = TREE_CODE (type);\n-  register tree rhstype;\n-  register enum tree_code coder;\n+  enum tree_code codel = TREE_CODE (type);\n+  tree rhstype;\n+  enum tree_code coder;\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */\n@@ -5773,10 +5772,10 @@ c_expand_asm_operands (tree string, tree outputs, tree inputs, tree clobbers,\n \t\t       int vol, location_t locus)\n {\n   int noutputs = list_length (outputs);\n-  register int i;\n+  int i;\n   /* o[I] is the place that output number I should be written.  */\n-  register tree *o = alloca (noutputs * sizeof (tree));\n-  register tree tail;\n+  tree *o = alloca (noutputs * sizeof (tree));\n+  tree tail;\n \n   /* Record the contents of OUTPUTS before it is modified.  */\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)"}, {"sha": "571a1826a5b179cb2ad0c8476a1d5449eb4807d1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926ce8bd97ca33f20282e7fcaa83741e67aaed16/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=926ce8bd97ca33f20282e7fcaa83741e67aaed16", "patch": "@@ -306,7 +306,7 @@ cxx_incomplete_type_error (tree value, tree type)\n tree\n store_init_value (tree decl, tree init)\n {\n-  register tree value, type;\n+  tree value, type;\n \n   /* If variable's type was invalidly declared, just ignore it.  */\n \n@@ -470,8 +470,7 @@ digest_init (tree type, tree init, tree* tail)\n \t  if (TYPE_DOMAIN (type) != 0\n \t      && TREE_CONSTANT (TYPE_SIZE (type)))\n \t    {\n-\t      register int size\n-\t\t= TREE_INT_CST_LOW (TYPE_SIZE (type));\n+\t      int size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n \t      size = (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n \t      /* In C it is ok to subtract 1 from the length of the string\n \t\t because it's ok to ignore the terminating null char that is\n@@ -577,11 +576,11 @@ digest_init (tree type, tree init, tree* tail)\n static tree\n process_init_constructor (tree type, tree init, tree* elts)\n {\n-  register tree tail;\n+  tree tail;\n   /* List of the elements of the result constructor,\n      in reverse order.  */\n-  register tree members = NULL;\n-  register tree next1;\n+  tree members = NULL;\n+  tree next1;\n   tree result;\n   int allconstant = 1;\n   int allsimple = 1;\n@@ -605,8 +604,8 @@ process_init_constructor (tree type, tree init, tree* elts)\n \n   if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n     {\n-      register long len;\n-      register int i;\n+      long len;\n+      int i;\n \n       if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n@@ -696,7 +695,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n     }\n   else if (TREE_CODE (type) == RECORD_TYPE)\n     {\n-      register tree field;\n+      tree field;\n \n       if (tail)\n \t{\n@@ -817,7 +816,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t   /* If the initializer was empty, use default zero initialization.  */\n \t   && tail)\n     {\n-      register tree field = TYPE_FIELDS (type);\n+      tree field = TYPE_FIELDS (type);\n \n       /* Find the first named field.  ANSI decided in September 1990\n \t that only named fields count here.  */"}]}