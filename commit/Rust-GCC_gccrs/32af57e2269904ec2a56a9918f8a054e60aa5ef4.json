{"sha": "32af57e2269904ec2a56a9918f8a054e60aa5ef4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhZjU3ZTIyNjk5MDRlYzJhNTZhOTkxOGY4YTA1NGU2MGFhNWVmNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-10-10T09:52:46Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-10-10T09:52:46Z"}, "message": "frontend-passes.c: Include opts.h.\n\n2010-10-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* frontend-passes.c:  Include opts.h.\n\t(optimize_comparison):  Renamed from optimize_equality.\n\tChange second argument to operation to be compared.\n\tUse flag_finite_math_only to avoid comparing REAL and\n\tCOMPLEX only when NANs are honored.  Simplify comparing\n\tof string concatenations where left or right operands are\n\tequal.  Simplify all comparison operations, based on the result\n\tof gfc_dep_compare_expr.\n\t* dependency.c:  Include arith.h.\n\t(gfc_are_identical_variables):  Volatile variables should not\n\tcompare equal to themselves.\n\t(gfc_dep_compare_expr):  Handle string constants and string\n\tconcatenations.\n\n2010-10-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/character_comparison_4.f90:  New test.\n\t* gfortran.dg/character_comparison_5.f90:  New test.\n\t* gfortran.dg/character_comparison_6.f90:  New test.\n\nFrom-SVN: r165248", "tree": {"sha": "181b725b890dbb124284cde97e1b23d530440a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/181b725b890dbb124284cde97e1b23d530440a07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32af57e2269904ec2a56a9918f8a054e60aa5ef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32af57e2269904ec2a56a9918f8a054e60aa5ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32af57e2269904ec2a56a9918f8a054e60aa5ef4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32af57e2269904ec2a56a9918f8a054e60aa5ef4/comments", "author": null, "committer": null, "parents": [{"sha": "0e88eb86942d9693ac6f73f22bcbad387a40ae77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e88eb86942d9693ac6f73f22bcbad387a40ae77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e88eb86942d9693ac6f73f22bcbad387a40ae77"}], "stats": {"total": 275, "additions": 254, "deletions": 21}, "files": [{"sha": "55f57fc29cd3422d8b9a08d12715e4e0a52939ed", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -1,3 +1,19 @@\n+2010-10-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* frontend-passes.c:  Include opts.h.\n+\t(optimize_comparison):  Renamed from optimize_equality.\n+\tChange second argument to operation to be compared.\n+\tUse flag_finite_math_only to avoid comparing REAL and\n+\tCOMPLEX only when NANs are honored.  Simplify comparing\n+\tof string concatenations where left or right operands are\n+\tequal.  Simplify all comparison operations, based on the result\n+\tof gfc_dep_compare_expr.\n+\t* dependency.c:  Include arith.h.\n+\t(gfc_are_identical_variables):  Volatile variables should not\n+\tcompare equal to themselves.\n+\t(gfc_dep_compare_expr):  Handle string constants and string\n+\tconcatenations.\n+\n 2010-10-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* f95-lang.c (LANG_HOOKS_INIT_OPTIONS_STRUCT): Define."}, {"sha": "40969f6e2d403098a013e5e5d0d3a6aad9e5aa28", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"dependency.h\"\n #include \"constructor.h\"\n+#include \"arith.h\"\n \n /* static declarations */\n /* Enums  */\n@@ -125,6 +126,11 @@ gfc_are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n   if (e1->symtree->n.sym != e2->symtree->n.sym)\n     return false;\n \n+  /* Volatile variables should never compare equal to themselves.  */\n+\n+  if (e1->symtree->n.sym->attr.volatile_)\n+    return false;\n+\n   r1 = e1->ref;\n   r2 = e2->ref;\n \n@@ -306,6 +312,42 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n \t}\n     }\n \n+  /* Compare A // B vs. C // D.  */\n+\n+  if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_CONCAT\n+      && e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_CONCAT)\n+    {\n+      int l, r;\n+\n+      l = gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op1);\n+      r = gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op2);\n+\n+      if (l == -2)\n+\treturn -2;\n+\n+      if (l == 0)\n+\t{\n+\t  /* Watch out for 'A ' // x vs. 'A' // x.  */\n+\t  gfc_expr *e1_left = e1->value.op.op1;\n+\t  gfc_expr *e2_left = e2->value.op.op1;\n+\n+\t  if (e1_left->expr_type == EXPR_CONSTANT\n+\t      && e2_left->expr_type == EXPR_CONSTANT\n+\t      && e1_left->value.character.length\n+\t        != e2_left->value.character.length)\n+\t    return -2;\n+\t  else\n+\t    return r;\n+\t}\n+      else\n+\t{\n+\t  if (l != 0)\n+\t    return l;\n+\t  else\n+\t    return r;\n+\t}\n+    }\n+\n   /* Compare X vs. X-C.  */\n   if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n     {\n@@ -321,6 +363,10 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n   switch (e1->expr_type)\n     {\n     case EXPR_CONSTANT:\n+      /* Compare strings for equality.  */\n+      if (e1->ts.type == BT_CHARACTER && e2->ts.type == BT_CHARACTER)\n+\treturn gfc_compare_string (e1, e2);\n+\n       if (e1->ts.type != BT_INTEGER || e2->ts.type != BT_INTEGER)\n \treturn -2;\n "}, {"sha": "c08930297e16505ee65d0f762acb7f0385ec6ac8", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 105, "deletions": 20, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -25,14 +25,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"dependency.h\"\n #include \"constructor.h\"\n+#include \"opts.h\"\n \n /* Forward declarations.  */\n \n static void strip_function_call (gfc_expr *);\n static void optimize_namespace (gfc_namespace *);\n static void optimize_assignment (gfc_code *);\n static bool optimize_op (gfc_expr *);\n-static bool optimize_equality (gfc_expr *, bool);\n+static bool optimize_comparison (gfc_expr *, gfc_intrinsic_op);\n \n /* Entry point - run all passes for a namespace.  So far, only an\n    optimization pass is run.  */\n@@ -226,15 +227,13 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_GE_OS:\n     case INTRINSIC_LE:\n     case INTRINSIC_LE_OS:\n-      return optimize_equality (e, true);\n-\n     case INTRINSIC_NE:\n     case INTRINSIC_NE_OS:\n     case INTRINSIC_GT:\n     case INTRINSIC_GT_OS:\n     case INTRINSIC_LT:\n     case INTRINSIC_LT_OS:\n-      return optimize_equality (e, false);\n+      return optimize_comparison (e, op);\n \n     default:\n       break;\n@@ -246,10 +245,12 @@ optimize_op (gfc_expr *e)\n /* Optimize expressions for equality.  */\n \n static bool\n-optimize_equality (gfc_expr *e, bool equal)\n+optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n {\n   gfc_expr *op1, *op2;\n   bool change;\n+  int eq;\n+  bool result;\n \n   op1 = e->value.op.op1;\n   op2 = e->value.op.op2;\n@@ -276,7 +277,7 @@ optimize_equality (gfc_expr *e, bool equal)\n \n   if (change)\n     {\n-      optimize_equality (e, equal);\n+      optimize_comparison (e, op);\n       return true;\n     }\n \n@@ -287,22 +288,106 @@ optimize_equality (gfc_expr *e, bool equal)\n   if (e->rank > 0)\n     return false;\n \n-  /* Check for direct comparison between identical variables.  Don't compare\n-     REAL or COMPLEX because of NaN checks.  */\n-  if (op1->expr_type == EXPR_VARIABLE\n-      && op2->expr_type == EXPR_VARIABLE\n-      && op1->ts.type != BT_REAL && op2->ts.type != BT_REAL\n-      && op1->ts.type != BT_COMPLEX && op2->ts.type !=BT_COMPLEX\n-      && gfc_are_identical_variables (op1, op2))\n+  /* Don't compare REAL or COMPLEX expressions when honoring NaNs.  */\n+\n+  if (flag_finite_math_only\n+      || (op1->ts.type != BT_REAL && op2->ts.type != BT_REAL\n+\t  && op1->ts.type != BT_COMPLEX && op2->ts.type != BT_COMPLEX))\n     {\n-      /* Replace the expression by a constant expression.  The typespec\n-\t and where remains the way it is.  */\n-      gfc_free (op1);\n-      gfc_free (op2);\n-      e->expr_type = EXPR_CONSTANT;\n-      e->value.logical = equal;\n-      return true;\n+      eq = gfc_dep_compare_expr (op1, op2);\n+      if (eq == -2)\n+\t{\n+\t  /* Replace A // B < A // C with B < C, and A // B < C // B\n+\t     with A < C.  */\n+\t  if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER\n+\t      && op1->value.op.op == INTRINSIC_CONCAT\n+\t      && op2->value.op.op == INTRINSIC_CONCAT)\n+\t    {\n+\t      gfc_expr *op1_left = op1->value.op.op1;\n+\t      gfc_expr *op2_left = op2->value.op.op1;\n+\t      gfc_expr *op1_right = op1->value.op.op2;\n+\t      gfc_expr *op2_right = op2->value.op.op2;\n+\n+\t      if (gfc_dep_compare_expr (op1_left, op2_left) == 0)\n+\t\t{\n+\t\t  /* Watch out for 'A ' // x vs. 'A' // x.  */\n+\n+\t\t  if (op1_left->expr_type == EXPR_CONSTANT\n+\t\t\t&& op2_left->expr_type == EXPR_CONSTANT\n+\t\t\t&& op1_left->value.character.length\n+\t\t\t   != op2_left->value.character.length)\n+\t\t    return -2;\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_free (op1_left);\n+\t\t      gfc_free (op2_left);\n+\t\t      e->value.op.op1 = op1_right;\n+\t\t      e->value.op.op2 = op2_right;\n+\t\t      optimize_comparison (e, op);\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t      if (gfc_dep_compare_expr (op1_right, op2_right) == 0)\n+\t\t{\n+\t\t  gfc_free (op1_right);\n+\t\t  gfc_free (op2_right);\n+\t\t  e->value.op.op1 = op1_left;\n+\t\t  e->value.op.op2 = op2_left;\n+\t\t  optimize_comparison (e, op);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* eq can only be -1, 0 or 1 at this point.  */\n+\t  switch (op)\n+\t    {\n+\t    case INTRINSIC_EQ:\n+\t    case INTRINSIC_EQ_OS:\n+\t      result = eq == 0;\n+\t      break;\n+\t      \n+\t    case INTRINSIC_GE:\n+\t    case INTRINSIC_GE_OS:\n+\t      result = eq >= 0;\n+\t      break;\n+\n+\t    case INTRINSIC_LE:\n+\t    case INTRINSIC_LE_OS:\n+\t      result = eq <= 0;\n+\t      break;\n+\n+\t    case INTRINSIC_NE:\n+\t    case INTRINSIC_NE_OS:\n+\t      result = eq != 0;\n+\t      break;\n+\n+\t    case INTRINSIC_GT:\n+\t    case INTRINSIC_GT_OS:\n+\t      result = eq > 0;\n+\t      break;\n+\n+\t    case INTRINSIC_LT:\n+\t    case INTRINSIC_LT_OS:\n+\t      result = eq < 0;\n+\t      break;\n+\t      \n+\t    default:\n+\t      gfc_internal_error (\"illegal OP in optimize_comparison\");\n+\t      break;\n+\t    }\n+\n+\t  /* Replace the expression by a constant expression.  The typespec\n+\t     and where remains the way it is.  */\n+\t  gfc_free (op1);\n+\t  gfc_free (op2);\n+\t  e->expr_type = EXPR_CONSTANT;\n+\t  e->value.logical = result;\n+\t  return true;\n+\t}\n     }\n+\n   return false;\n }\n "}, {"sha": "dbb2a28cefb1a6ac83e0af4a1e4fca185b1ae7f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -1,8 +1,14 @@\n+2010-10-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/character_comparison_4.f90:  New test.\n+\t* gfortran.dg/character_comparison_5.f90:  New test.\n+\t* gfortran.dg/character_comparison_6.f90:  New test.\n+\n 2010-10-09  Richard Henderson  <rth@redhat.com>\n \n \t* lib/target-supports.exp\n \t(check_effective_target_automatic_stack_alignment): Always true.\n-\t\n+\n 2010-10-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/45956"}, {"sha": "1ff8b47073293a446933f8430a0a35671d48b300", "filename": "gcc/testsuite/gfortran.dg/character_comparison_4.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_4.f90?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c, d\n+  integer :: n\n+  integer :: i\n+  common /foo/ i\n+\n+  n = 0\n+  i = 0\n+  c = 'abcd'\n+  d = 'efgh'\n+\n+  n = n + 1 ; if ('a' // c == 'a' // c) call yes\n+  n = n + 1 ; if (c // 'a' == c // 'a') call yes\n+  n = n + 1; if ('b' // c > 'a' // d) call yes\n+  n = n + 1; if (c // 'b' > c // 'a') call yes\n+\n+  if ('a' // c /= 'a' // c) call abort\n+  if ('a' // c // 'b' == 'a' // c // 'a') call abort\n+  if ('b' // c == 'a' // c) call abort\n+  if (c // 'a' ==  c // 'b') call abort\n+  if (c // 'a ' /=  c // 'a') call abort\n+  if (c // 'b' /=  c // 'b ') call abort\n+\n+  if (n /= i) call abort\n+end program main\n+\n+subroutine yes\n+  implicit none\n+  common /foo/ i\n+  integer :: i\n+  i = i + 1\n+end subroutine yes\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "b9ad9215794b7238a0fadc5aa0a960243d72a9b5", "filename": "gcc/testsuite/gfortran.dg/character_comparison_5.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_5.f90?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c, d\n+  integer :: n\n+  integer :: i\n+  common /foo/ i\n+\n+  n = 0\n+  i = 0\n+  c = 'abcd'\n+  d = 'efgh'\n+  if (c // 'a' >= d // 'a') call abort\n+  if ('a' // c >= 'a' // d) call abort\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_concat_string\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "78f647705a20d4178ffe8c32550555f48e7e518f", "filename": "gcc/testsuite/gfortran.dg/character_comparison_6.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32af57e2269904ec2a56a9918f8a054e60aa5ef4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_6.f90?ref=32af57e2269904ec2a56a9918f8a054e60aa5ef4", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c\n+  integer :: n\n+  integer :: i\n+  common /foo/ i\n+\n+  n = 0\n+  i = 0\n+  c = 'abcd'\n+  if ('a ' // c == 'a' // c) call abort\n+  if ('a' // c == 'a ' // c) call abort\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_concat_string\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}]}