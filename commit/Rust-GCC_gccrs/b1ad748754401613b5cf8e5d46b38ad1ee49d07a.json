{"sha": "b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "node_id": "C_kwDOANBUbNoAKGIxYWQ3NDg3NTQ0MDE2MTNiNWNmOGU1ZDQ2YjM4YWQxZWU0OWQwN2E", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-01-04T16:45:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-01-05T00:46:00Z"}, "message": "libstdc++: Only use std::atomic<tzdb_list::_Node*> if lock free [PR108228]\n\nThis fixes linker errors for hppa-hp-hpux11.11 due to an undefined weak\nsymbol and the use of atomic operations that require libatomic.\n\nThe weak symbol can simply be defined, which we already do for darwin.\n\nThe std::atomic<_Node*> is only an optimization, so can be avoided for\ntargets where the underlying atomic ops aren't available without help\nfrom libatomic. The accesses to the std::atomic<_Node*> can be\nabstracted behind a new API for getting and setting the cached value,\nand then the atomics can be used conditionally.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/108228\n\tPR libstdc++/108235\n\t* config/abi/pre/gnu.ver: Move zoneinfo_dir_override export to\n\tthe latest symbol version.\n\t* src/c++20/tzdb.cc (USE_ATOMIC_SHARED_PTR): Define to 0 if\n\tatomic<_Node*> is not always lock free.\n\t(USE_ATOMIC_LIST_HEAD): New macro.\n\t[__hpux__] (__gnu_cxx::zoneinfo_dir_override()): Provide\n\tdefinition of weak symbol.\n\t(tzdb_list::_Node::_S_head): Rename to _S_head_cache.\n\t(tzdb_list::_Node::_S_list_head): New function for accessing\n\tlist head efficiently.\n\t(tzdb_list::_Node::_S_cache_list_head): New function for\n\tupdating _S_list_head.", "tree": {"sha": "24be05aa3e7aee607b59f8c6479c51387813b6a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24be05aa3e7aee607b59f8c6479c51387813b6a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ad748754401613b5cf8e5d46b38ad1ee49d07a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e36e57b032b2d70eaa1294d5921e4fd8ce12a74d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36e57b032b2d70eaa1294d5921e4fd8ce12a74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36e57b032b2d70eaa1294d5921e4fd8ce12a74d"}], "stats": {"total": 101, "additions": 64, "deletions": 37}, "files": [{"sha": "a5559a1c374311c6248ad34d1cea9a266b709685", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ad748754401613b5cf8e5d46b38ad1ee49d07a/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ad748754401613b5cf8e5d46b38ad1ee49d07a/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "patch": "@@ -1104,9 +1104,6 @@ GLIBCXX_3.4 {\n     # std::uncaught_exception()\n     _ZSt18uncaught_exceptionv;\n \n-    # __gnu_cxx::zoneinfo_dir_override()\n-    _ZN9__gnu_cxx21zoneinfo_dir_overrideEv;\n-\n   # DO NOT DELETE THIS LINE.  Port-specific symbols, if any, will be here.\n \n   local:\n@@ -2505,6 +2502,7 @@ GLIBCXX_3.4.31 {\n     _ZNKSt6chrono9tzdb_list14const_iteratordeEv;\n     _ZNSt6chrono9tzdb_list14const_iteratorppEv;\n     _ZNSt6chrono9tzdb_list14const_iteratorppEi;\n+    _ZN9__gnu_cxx21zoneinfo_dir_overrideEv;\n \n } GLIBCXX_3.4.30;\n "}, {"sha": "6772517d55aedefeb96e593b6e21296a58c213ec", "filename": "libstdc++-v3/src/c++20/tzdb.cc", "status": "modified", "additions": 63, "deletions": 34, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ad748754401613b5cf8e5d46b38ad1ee49d07a/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ad748754401613b5cf8e5d46b38ad1ee49d07a/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc?ref=b1ad748754401613b5cf8e5d46b38ad1ee49d07a", "patch": "@@ -34,14 +34,22 @@\n #include <mutex>      // mutex\n #include <filesystem> // filesystem::read_symlink\n \n-#ifdef __GTHREADS\n-# if _WIN32\n+#ifndef __GTHREADS\n+# define USE_ATOMIC_SHARED_PTR 0\n+#elif _WIN32\n // std::mutex cannot be constinit, so Windows must use atomic<shared_ptr<>>.\n-#  define USE_ATOMIC_SHARED_PTR 1\n-# else\n+# define USE_ATOMIC_SHARED_PTR 1\n+#elif ATOMIC_POINTER_LOCK_FREE < 2\n+# define USE_ATOMIC_SHARED_PTR 0\n+#else\n // TODO benchmark atomic<shared_ptr<>> vs mutex.\n-#  define USE_ATOMIC_SHARED_PTR 1\n-# endif\n+# define USE_ATOMIC_SHARED_PTR 1\n+#endif\n+\n+#if defined __GTHREADS && ATOMIC_POINTER_LOCK_FREE == 2\n+# define USE_ATOMIC_LIST_HEAD 1\n+#else\n+# define USE_ATOMIC_LIST_HEAD 0\n #endif\n \n #if ! __cpp_constinit\n@@ -64,7 +72,7 @@ namespace __gnu_cxx\n #else\n   [[gnu::weak]] const char* zoneinfo_dir_override();\n \n-#ifdef __APPLE__\n+#if defined(__APPLE__) || defined(__hpux__)\n   // Need a weak definition for Mach-O.\n   [[gnu::weak]] const char* zoneinfo_dir_override()\n   { return _GLIBCXX_ZONEINFO_DIR; }\n@@ -76,6 +84,15 @@ namespace std::chrono\n {\n   namespace\n   {\n+#if ! USE_ATOMIC_SHARED_PTR\n+#ifndef __GTHREADS\n+    // Dummy no-op mutex type for single-threaded targets.\n+    struct mutex { void lock() { } void unlock() { } };\n+#endif\n+    /// XXX std::mutex::mutex() not constexpr on Windows, so can't be constinit\n+    constinit mutex list_mutex;\n+#endif\n+\n     struct Rule;\n   }\n \n@@ -103,8 +120,29 @@ namespace std::chrono\n     // This is the owning reference to the first tzdb in the list.\n     static head_ptr _S_head_owner;\n \n+#if USE_ATOMIC_LIST_HEAD\n     // Lock-free access to the head of the list.\n-    static atomic<_Node*> _S_head;\n+    static atomic<_Node*> _S_head_cache;\n+\n+    static _Node*\n+    _S_list_head(memory_order ord) noexcept\n+    { return _S_head_cache.load(ord); }\n+\n+    static void\n+    _S_cache_list_head(_Node* new_head) noexcept\n+    { _S_head_cache = new_head; }\n+#else\n+    static _Node*\n+    _S_list_head(memory_order)\n+    {\n+      lock_guard<mutex> l(list_mutex);\n+      return _S_head_owner.get();\n+    }\n+\n+    static void\n+    _S_cache_list_head(_Node*) noexcept\n+    { }\n+#endif\n \n     static const tzdb& _S_init_tzdb();\n     static const tzdb& _S_replace_head(shared_ptr<_Node>, shared_ptr<_Node>);\n@@ -122,8 +160,10 @@ namespace std::chrono\n   // Shared pointer to the first Node in the list.\n   constinit tzdb_list::_Node::head_ptr tzdb_list::_Node::_S_head_owner{nullptr};\n \n+#if USE_ATOMIC_LIST_HEAD\n   // Lock-free access to the first Node in the list.\n-  constinit atomic<tzdb_list::_Node*> tzdb_list::_Node::_S_head{nullptr};\n+  constinit atomic<tzdb_list::_Node*> tzdb_list::_Node::_S_head_cache{nullptr};\n+#endif\n \n   // The data structures defined in this file (Rule, on_day, at_time etc.)\n   // are used to represent the information parsed from the tzdata.zi file\n@@ -135,15 +175,6 @@ namespace std::chrono\n \n   namespace\n   {\n-#if ! USE_ATOMIC_SHARED_PTR\n-#ifndef __GTHREADS\n-    // Dummy no-op mutex type for single-threaded targets.\n-    struct mutex { void lock() { } void unlock() { } };\n-#endif\n-    /// XXX std::mutex::mutex() not constexpr on Windows, so can't be constinit\n-    constinit mutex list_mutex;\n-#endif\n-\n     // Used for reading a possibly-quoted string from a stream.\n     struct quoted\n     {\n@@ -1101,30 +1132,28 @@ namespace std::chrono\n   tzdb_list::_Node::_S_replace_head(shared_ptr<_Node> curr [[maybe_unused]],\n \t\t\t\t    shared_ptr<_Node> new_head)\n   {\n+    _Node* new_head_ptr = new_head.get();\n #if USE_ATOMIC_SHARED_PTR\n-    new_head->next = curr;\n+    new_head_ptr->next = curr;\n     while (!_S_head_owner.compare_exchange_strong(curr, new_head))\n       {\n-\tif (curr->db.version == new_head->db.version)\n+\tif (curr->db.version == new_head_ptr->db.version)\n \t  return curr->db;\n-\tnew_head->next = curr;\n+\tnew_head_ptr->next = curr;\n       }\n-    // XXX small window here where _S_head still points to previous tzdb.\n-    _Node::_S_head = new_head.get();\n-    return new_head->db;\n+    // XXX small window here where _S_head_cache still points to previous tzdb.\n #else\n     lock_guard<mutex> l(list_mutex);\n-    if (const _Node* h = _S_head)\n+    if (const _Node* h = _S_head_owner.get())\n       {\n-\tif (h->db.version == new_head->db.version)\n+\tif (h->db.version == new_head_ptr->db.version)\n \t  return h->db;\n-\tnew_head->next = _S_head_owner;\n+\tnew_head_ptr->next = _S_head_owner;\n       }\n-    auto* pnode = new_head.get();\n     _S_head_owner = std::move(new_head);\n-    _S_head = pnode;\n-    return pnode->db;\n #endif\n+    _S_cache_list_head(new_head_ptr);\n+    return new_head_ptr->db;\n   }\n \n   // Called to populate the list for the first time. If reload_tzdb() fails,\n@@ -1207,7 +1236,7 @@ namespace std::chrono\n   get_tzdb_list()\n   {\n     using Node = tzdb_list::_Node;\n-    if (Node::_S_head.load(memory_order::acquire) == nullptr) [[unlikely]]\n+    if (Node::_S_list_head(memory_order::acquire) == nullptr) [[unlikely]]\n       Node::_S_init_tzdb(); // populates list\n     return Node::_S_the_list;\n   }\n@@ -1217,7 +1246,7 @@ namespace std::chrono\n   get_tzdb()\n   {\n     using Node = tzdb_list::_Node;\n-    if (auto* __p = Node::_S_head.load(memory_order::acquire)) [[likely]]\n+    if (auto* __p = Node::_S_list_head(memory_order::acquire)) [[likely]]\n       return __p->db;\n     return Node::_S_init_tzdb(); // populates list\n   }\n@@ -1236,7 +1265,7 @@ namespace std::chrono\n     if (head != nullptr && head->db.version == version)\n       return head->db;\n #else\n-    if (Node::_S_head.load(memory_order::relaxed) != nullptr) [[likely]]\n+    if (Node::_S_list_head(memory_order::relaxed) != nullptr) [[likely]]\n     {\n       lock_guard<mutex> l(list_mutex);\n       const tzdb& current = Node::_S_head_owner->db;\n@@ -1346,7 +1375,7 @@ namespace std::chrono\n   const tzdb&\n   tzdb_list::front() const noexcept\n   {\n-    return _Node::_S_head.load()->db;\n+    return _Node::_S_list_head(memory_order::seq_cst)->db;\n   }\n \n   // Implementation of std::chrono::tzdb_list::begin()."}]}