{"sha": "13fa2acbf0fe378a034920f214b727005fe4d0ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNmYTJhY2JmMGZlMzc4YTAzNDkyMGYyMTRiNzI3MDA1ZmU0ZDBlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-23T10:27:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-23T10:27:00Z"}, "message": "[multiple changes]\n\n2014-10-23  Vincent Celier  <celier@adacore.com>\n\n\t* gnatls.adb: If --RTS= was not used, check if there is a default\n\truntime. If there is none, in verbose mode, indicate that the\n\tdefault runtime is not available and show only the current\n\tdirectory in the source and the object search paths.\n\n2014-10-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): A thunk procedure with a\n\tparameter of a limited view does not need a freeze node.\n\n2014-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch7.adb (Analyze_Package_Body_Helper):\n\tThe logic which hides local entities from external\n\tvisibility is now contained in routine Hide_Public_Entities.\n\t(Hide_Public_Entities): New routine. Object and subprogram\n\trenamings are now hidden from external visibility the same way\n\tobjects are.\n\n2014-10-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): The prefix of attribute Elaborated\n\tdoes not require freezing, in particular if it denotes a generic\n\tfunction.\n\nFrom-SVN: r216585", "tree": {"sha": "0e463aeb8578fad198193c51038fcacb0db1e299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e463aeb8578fad198193c51038fcacb0db1e299"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13fa2acbf0fe378a034920f214b727005fe4d0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13fa2acbf0fe378a034920f214b727005fe4d0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13fa2acbf0fe378a034920f214b727005fe4d0ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13fa2acbf0fe378a034920f214b727005fe4d0ef/comments", "author": null, "committer": null, "parents": [{"sha": "b04d926e216ec1c7bd66080fd891dafc1baed9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b04d926e216ec1c7bd66080fd891dafc1baed9c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b04d926e216ec1c7bd66080fd891dafc1baed9c5"}], "stats": {"total": 690, "additions": 412, "deletions": 278}, "files": [{"sha": "38edfbe07304e2726aabd12550a24f4ed2fc7862", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=13fa2acbf0fe378a034920f214b727005fe4d0ef", "patch": "@@ -1,3 +1,30 @@\n+2014-10-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatls.adb: If --RTS= was not used, check if there is a default\n+\truntime. If there is none, in verbose mode, indicate that the\n+\tdefault runtime is not available and show only the current\n+\tdirectory in the source and the object search paths.\n+\n+2014-10-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): A thunk procedure with a\n+\tparameter of a limited view does not need a freeze node.\n+\n+2014-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper):\n+\tThe logic which hides local entities from external\n+\tvisibility is now contained in routine Hide_Public_Entities.\n+\t(Hide_Public_Entities): New routine. Object and subprogram\n+\trenamings are now hidden from external visibility the same way\n+\tobjects are.\n+\n+2014-10-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): The prefix of attribute Elaborated\n+\tdoes not require freezing, in particular if it denotes a generic\n+\tfunction.\n+\n 2014-10-23  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma/Pragma_Inline & Pragma_Inline_Always):"}, {"sha": "808b00937b5bd62ae2f727a89a59148c42246d94", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=13fa2acbf0fe378a034920f214b727005fe4d0ef", "patch": "@@ -65,6 +65,9 @@ procedure Gnatls is\n \n    No_Obj : aliased String := \"<no_obj>\";\n \n+   No_Runtime : Boolean := False;\n+   --  Set to True if there is no default runtime and --RTS= is not specified\n+\n    type File_Status is (\n      OK,                  --  matching timestamp\n      Checksum_OK,         --  only matching checksum\n@@ -1631,10 +1634,37 @@ begin\n \n    Osint.Add_Default_Search_Dirs;\n \n+   --  If --RTS= is not specified, check if there is a default runtime\n+\n+   if RTS_Specified = null then\n+      declare\n+         Text : Source_Buffer_Ptr;\n+         Hi   : Source_Ptr;\n+\n+      begin\n+         Name_Buffer (1 .. 10) := \"system.ads\";\n+         Name_Len := 10;\n+\n+         Read_Source_File (Name_Find, Lo => 0, Hi => Hi, Src => Text);\n+\n+         if Text = null then\n+            No_Runtime := True;\n+         end if;\n+      end;\n+   end if;\n+\n    if Verbose_Mode then\n       Write_Eol;\n       Display_Version (\"GNATLS\", \"1997\");\n       Write_Eol;\n+\n+      if No_Runtime then\n+         Write_Str\n+           (\"Default runtime not available. Use --RTS= with a valid runtime\");\n+         Write_Eol;\n+         Write_Eol;\n+      end if;\n+\n       Write_Str (\"Source Search Path:\");\n       Write_Eol;\n \n@@ -1643,14 +1673,15 @@ begin\n \n          if Dir_In_Src_Search_Path (J)'Length = 0 then\n             Write_Str (\"<Current_Directory>\");\n-         else\n+            Write_Eol;\n+\n+         elsif not No_Runtime then\n             Write_Str\n               (Normalize\n                  (To_Host_Dir_Spec\n-                    (Dir_In_Src_Search_Path (J).all, True).all));\n+                      (Dir_In_Src_Search_Path (J).all, True).all));\n+            Write_Eol;\n          end if;\n-\n-         Write_Eol;\n       end loop;\n \n       Write_Eol;\n@@ -1663,14 +1694,15 @@ begin\n \n          if Dir_In_Obj_Search_Path (J)'Length = 0 then\n             Write_Str (\"<Current_Directory>\");\n-         else\n+            Write_Eol;\n+\n+         elsif not No_Runtime then\n             Write_Str\n               (Normalize\n                  (To_Host_Dir_Spec\n-                    (Dir_In_Obj_Search_Path (J).all, True).all));\n+                      (Dir_In_Obj_Search_Path (J).all, True).all));\n+            Write_Eol;\n          end if;\n-\n-         Write_Eol;\n       end loop;\n \n       Write_Eol;"}, {"sha": "071399bbc140ebd3182ed8fae0372f9c95a7a6d2", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=13fa2acbf0fe378a034920f214b727005fe4d0ef", "patch": "@@ -11164,7 +11164,16 @@ package body Sem_Attr is\n       --  Normally the Freezing is done by Resolve but sometimes the Prefix\n       --  is not resolved, in which case the freezing must be done now.\n \n-      Freeze_Expression (P);\n+      --  For an elaboration check on a subprogram, we do not freeze its type.\n+      --  It may be declared in an unrelated scope, in particular in the case\n+      --  of a generic function whose type may remain unelaborated.\n+\n+      if Attr_Id = Attribute_Elaborated then\n+         null;\n+\n+      else\n+         Freeze_Expression (P);\n+      end if;\n \n       --  Finally perform static evaluation on the attribute reference\n "}, {"sha": "8940d82570472b1106d236d42b79d2278a72a43a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=13fa2acbf0fe378a034920f214b727005fe4d0ef", "patch": "@@ -9946,7 +9946,9 @@ package body Sem_Ch6 is\n                         --  (Note that the same is done for controlling access\n                         --  parameter cases in function Access_Definition.)\n \n-                        Set_Has_Delayed_Freeze (Current_Scope);\n+                        if not Is_Thunk (Current_Scope) then\n+                           Set_Has_Delayed_Freeze (Current_Scope);\n+                        end if;\n                      end if;\n                   end if;\n "}, {"sha": "f15b8ff547e184fff5888124d68bc2791c01b02b", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 332, "deletions": 268, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13fa2acbf0fe378a034920f214b727005fe4d0ef/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=13fa2acbf0fe378a034920f214b727005fe4d0ef", "patch": "@@ -220,19 +220,323 @@ package body Sem_Ch7 is\n    ---------------------------------\n \n    procedure Analyze_Package_Body_Helper (N : Node_Id) is\n-      HSS              : Node_Id;\n-      Body_Id          : Entity_Id;\n-      Spec_Id          : Entity_Id;\n-      Last_Spec_Entity : Entity_Id;\n-      New_N            : Node_Id;\n-      Pack_Decl        : Node_Id;\n+      procedure Hide_Public_Entities (Decls : List_Id);\n+      --  Attempt to hide all public entities found in declarative list Decls\n+      --  by resetting their Is_Public flag to False depending on whether the\n+      --  entities are not referenced by inlined or generic bodies. This kind\n+      --  of processing is a conservative approximation and may still leave\n+      --  certain entities externally visible.\n \n       procedure Install_Composite_Operations (P : Entity_Id);\n       --  Composite types declared in the current scope may depend on types\n       --  that were private at the point of declaration, and whose full view\n       --  is now in scope. Indicate that the corresponding operations on the\n       --  composite type are available.\n \n+      --------------------------\n+      -- Hide_Public_Entities --\n+      --------------------------\n+\n+      procedure Hide_Public_Entities (Decls : List_Id) is\n+         function Contains_Subp_Or_Const_Refs (N : Node_Id) return Boolean;\n+         --  Subsidiary to routine Has_Referencer. Determine whether a node\n+         --  contains a reference to a subprogram or a non-static constant.\n+         --  WARNING: this is a very expensive routine as it performs a full\n+         --  tree traversal.\n+\n+         function Has_Referencer\n+           (Decls     : List_Id;\n+            Top_Level : Boolean := False) return Boolean;\n+         --  A \"referencer\" is a construct which may reference a previous\n+         --  declaration. Examine all declarations in list Decls in reverse\n+         --  and determine whether once such referencer exists. All entities\n+         --  in the range Last (Decls) .. Referencer are hidden from external\n+         --  visibility.\n+\n+         ---------------------------------\n+         -- Contains_Subp_Or_Const_Refs --\n+         ---------------------------------\n+\n+         function Contains_Subp_Or_Const_Refs (N : Node_Id) return Boolean is\n+            Reference_Seen : Boolean := False;\n+\n+            function Is_Subp_Or_Const_Ref\n+              (N : Node_Id) return Traverse_Result;\n+            --  Determine whether a node denotes a reference to a subprogram or\n+            --  a non-static constant.\n+\n+            --------------------------\n+            -- Is_Subp_Or_Const_Ref --\n+            --------------------------\n+\n+            function Is_Subp_Or_Const_Ref\n+              (N : Node_Id) return Traverse_Result\n+            is\n+               Val : Node_Id;\n+\n+            begin\n+               --  Detect a reference of the form\n+               --    Subp_Call\n+\n+               if Nkind (N) in N_Subprogram_Call\n+                 and then Is_Entity_Name (Name (N))\n+               then\n+                  Reference_Seen := True;\n+                  return Abandon;\n+\n+               --  Detect a reference of the form\n+               --    Subp'Some_Attribute\n+\n+               elsif Nkind (N) = N_Attribute_Reference\n+                 and then Is_Entity_Name (Prefix (N))\n+                 and then Is_Subprogram (Entity (Prefix (N)))\n+               then\n+                  Reference_Seen := True;\n+                  return Abandon;\n+\n+               --  Detect the use of a non-static constant\n+\n+               elsif Is_Entity_Name (N)\n+                 and then Present (Entity (N))\n+                 and then Ekind (Entity (N)) = E_Constant\n+               then\n+                  Val := Constant_Value (Entity (N));\n+\n+                  if Present (Val)\n+                    and then not Compile_Time_Known_Value (Val)\n+                  then\n+                     Reference_Seen := True;\n+                     return Abandon;\n+                  end if;\n+               end if;\n+\n+               return OK;\n+            end Is_Subp_Or_Const_Ref;\n+\n+            procedure Find_Subp_Or_Const_Ref is\n+              new Traverse_Proc (Is_Subp_Or_Const_Ref);\n+\n+         --  Start of processing for Contains_Subp_Or_Const_Refs\n+\n+         begin\n+            Find_Subp_Or_Const_Ref (N);\n+\n+            return Reference_Seen;\n+         end Contains_Subp_Or_Const_Refs;\n+\n+         --------------------\n+         -- Has_Referencer --\n+         --------------------\n+\n+         function Has_Referencer\n+           (Decls     : List_Id;\n+            Top_Level : Boolean := False) return Boolean\n+         is\n+            Decl    : Node_Id;\n+            Decl_Id : Entity_Id;\n+            Spec    : Node_Id;\n+\n+            Has_Non_Subp_Const_Referencer : Boolean := False;\n+            --  Flag set for inlined subprogram bodies that do not contain\n+            --  references to other subprograms or non-static constants.\n+\n+         begin\n+            if No (Decls) then\n+               return False;\n+            end if;\n+\n+            --  Examine all declarations in reverse order, hiding all entities\n+            --  from external visibility until a referencer has been found. The\n+            --  algorithm recurses into nested packages.\n+\n+            Decl := Last (Decls);\n+            while Present (Decl) loop\n+\n+               --  A stub is always considered a referencer\n+\n+               if Nkind (Decl) in N_Body_Stub then\n+                  return True;\n+\n+               --  Package declaration\n+\n+               elsif Nkind (Decl) = N_Package_Declaration\n+                 and then not Has_Non_Subp_Const_Referencer\n+               then\n+                  Spec := Specification (Decl);\n+\n+                  --  Inspect the declarations of a non-generic package to try\n+                  --  and hide more entities from external visibility.\n+\n+                  if not Is_Generic_Unit (Defining_Entity (Spec)) then\n+                     if Has_Referencer (Private_Declarations (Spec))\n+                       or else Has_Referencer (Visible_Declarations (Spec))\n+                     then\n+                        return True;\n+                     end if;\n+                  end if;\n+\n+               --  Package body\n+\n+               elsif Nkind (Decl) = N_Package_Body\n+                 and then Present (Corresponding_Spec (Decl))\n+               then\n+                  Decl_Id := Corresponding_Spec (Decl);\n+\n+                  --  A generic package body is a referencer. It would seem\n+                  --  that we only have to consider generics that can be\n+                  --  exported, i.e. where the corresponding spec is the\n+                  --  spec of the current package, but because of nested\n+                  --  instantiations, a fully private generic body may export\n+                  --  other private body entities. Furthermore, regardless of\n+                  --  whether there was a previous inlined subprogram, (an\n+                  --  instantiation of) the generic package may reference any\n+                  --  entity declared before it.\n+\n+                  if Is_Generic_Unit (Decl_Id) then\n+                     return True;\n+\n+                  --  Inspect the declarations of a non-generic package body to\n+                  --  try and hide more entities from external visibility.\n+\n+                  elsif not Has_Non_Subp_Const_Referencer\n+                    and then Has_Referencer (Declarations (Decl))\n+                  then\n+                     return True;\n+                  end if;\n+\n+               --  Subprogram body\n+\n+               elsif Nkind (Decl) = N_Subprogram_Body then\n+                  if Present (Corresponding_Spec (Decl)) then\n+                     Decl_Id := Corresponding_Spec (Decl);\n+\n+                     --  A generic subprogram body acts as a referencer\n+\n+                     if Is_Generic_Unit (Decl_Id) then\n+                        return True;\n+                     end if;\n+\n+                     --  An inlined subprogram body acts as a referencer\n+\n+                     if Is_Inlined (Decl_Id)\n+                       or else Has_Pragma_Inline (Decl_Id)\n+                     then\n+                        --  Inspect the statements of the subprogram body\n+                        --  to determine whether the body references other\n+                        --  subprograms and/or non-static constants.\n+\n+                        if Top_Level\n+                          and then not Contains_Subp_Or_Const_Refs (Decl)\n+                        then\n+                           Has_Non_Subp_Const_Referencer := True;\n+                        else\n+                           return True;\n+                        end if;\n+                     end if;\n+\n+                  --  Otherwise this is a stand alone subprogram body\n+\n+                  else\n+                     Decl_Id := Defining_Entity (Decl);\n+\n+                     --  An inlined body acts as a referencer. Note that an\n+                     --  inlined subprogram remains Is_Public as gigi requires\n+                     --  the flag to be set.\n+\n+                     --  Note that we test Has_Pragma_Inline here rather than\n+                     --  Is_Inlined. We are compiling this for a client, and\n+                     --  it is the client who will decide if actual inlining\n+                     --  should occur, so we need to assume that the procedure\n+                     --  could be inlined for the purpose of accessing global\n+                     --  entities.\n+\n+                     if Has_Pragma_Inline (Decl_Id) then\n+                        if Top_Level\n+                          and then not Contains_Subp_Or_Const_Refs (Decl)\n+                        then\n+                           Has_Non_Subp_Const_Referencer := True;\n+                        else\n+                           return True;\n+                        end if;\n+                     else\n+                        Set_Is_Public (Decl_Id, False);\n+                     end if;\n+                  end if;\n+\n+               --  Exceptions, objects and renamings do not need to be public\n+               --  if they are not followed by a construct which can reference\n+               --  and export them. The Is_Public flag is reset on top level\n+               --  entities only as anything nested is local to its context.\n+\n+               elsif Nkind_In (Decl, N_Exception_Declaration,\n+                                     N_Object_Declaration,\n+                                     N_Object_Renaming_Declaration,\n+                                     N_Subprogram_Declaration,\n+                                     N_Subprogram_Renaming_Declaration)\n+               then\n+                  Decl_Id := Defining_Entity (Decl);\n+\n+                  if Top_Level\n+                    and then not Is_Imported (Decl_Id)\n+                    and then not Is_Exported (Decl_Id)\n+                    and then No (Interface_Name (Decl_Id))\n+                    and then\n+                      (not Has_Non_Subp_Const_Referencer\n+                        or else Nkind (Decl) = N_Subprogram_Declaration)\n+                  then\n+                     Set_Is_Public (Decl_Id, False);\n+                  end if;\n+               end if;\n+\n+               Prev (Decl);\n+            end loop;\n+\n+            return Has_Non_Subp_Const_Referencer;\n+         end Has_Referencer;\n+\n+         --  Local variables\n+\n+         Discard : Boolean := True;\n+         pragma Unreferenced (Discard);\n+\n+      --  Start of processing for Hide_Public_Entities\n+\n+      begin\n+         --  The algorithm examines the top level declarations of a package\n+         --  body in reverse looking for a construct that may export entities\n+         --  declared prior to it. If such a scenario is encountered, then all\n+         --  entities in the range Last (Decls) .. construct are hidden from\n+         --  external visibility. Consider:\n+\n+         --    package Pack is\n+         --       generic\n+         --       package Gen is\n+         --       end Gen;\n+         --    end Pack;\n+\n+         --    package body Pack is\n+         --       External_Obj : ...;      --  (1)\n+\n+         --       package body Gen is      --  (2)\n+         --          ... External_Obj ...  --  (3)\n+         --       end Gen;\n+\n+         --       Local_Obj : ...;         --  (4)\n+         --    end Pack;\n+\n+         --  In this example Local_Obj (4) must not be externally visible as\n+         --  it cannot be exported by anything in Pack. The body of generic\n+         --  package Gen (2) on the other hand acts as a \"referencer\" and may\n+         --  export anything declared before it. Since the compiler does not\n+         --  perform flow analysis, it is not possible to determine precisely\n+         --  which entities will be exported when Gen is instantiated. In the\n+         --  example above External_Obj (1) is exported at (3), but this may\n+         --  not always be the case. The algorithm takes a conservative stance\n+         --  and leaves entity External_Obj public.\n+\n+         Discard := Has_Referencer (Decls, Top_Level => True);\n+      end Hide_Public_Entities;\n+\n       ----------------------------------\n       -- Install_Composite_Operations --\n       ----------------------------------\n@@ -256,6 +560,15 @@ package body Sem_Ch7 is\n          end loop;\n       end Install_Composite_Operations;\n \n+      --  Local variables\n+\n+      Body_Id          : Entity_Id;\n+      HSS              : Node_Id;\n+      Last_Spec_Entity : Entity_Id;\n+      New_N            : Node_Id;\n+      Pack_Decl        : Node_Id;\n+      Spec_Id          : Entity_Id;\n+\n    --  Start of processing for Analyze_Package_Body_Helper\n \n    begin\n@@ -557,272 +870,23 @@ package body Sem_Ch7 is\n          Check_References (Spec_Id);\n       end if;\n \n-      --  The processing so far has made all entities of the package body\n-      --  public (i.e. externally visible to the linker). This is in general\n-      --  necessary, since inlined or generic bodies, for which code is\n-      --  generated in other units, may need to see these entities. The\n-      --  following loop runs backwards from the end of the entities of the\n-      --  package body making these entities invisible until we reach a\n-      --  referencer, i.e. a declaration that could reference a previous\n-      --  declaration, a generic body or an inlined body, or a stub (which may\n-      --  contain either of these). This is of course an approximation, but it\n-      --  is conservative and definitely correct.\n-\n-      --  We only do this at the outer (library) level non-generic packages.\n-      --  The reason is simply to cut down on the number of global symbols\n-      --  generated, which has a double effect: (1) to make the compilation\n-      --  process more efficient and (2) to give the code generator more\n-      --  freedom to optimize within each unit, especially subprograms.\n+      --  At this point all entities of the package body are externally visible\n+      --  to the linker as their Is_Public flag is set to True. This proactive\n+      --  approach is necessary because an inlined or a generic body for which\n+      --  code is generated in other units may need to see these entities. Cut\n+      --  down the number of global symbols that do not neet public visibility\n+      --  as this has two beneficial effects:\n+      --    (1) It makes the compilation process more efficient.\n+      --    (2) It gives the code generatormore freedom to optimize within each\n+      --        unit, especially subprograms.\n+\n+      --  This is done only for top level library packages or child units as\n+      --  the algorithm does a top down traversal of the package body.\n \n       if (Scope (Spec_Id) = Standard_Standard or else Is_Child_Unit (Spec_Id))\n         and then not Is_Generic_Unit (Spec_Id)\n-        and then Present (Declarations (N))\n       then\n-         Make_Non_Public_Where_Possible : declare\n-\n-            function Has_Referencer\n-              (L     : List_Id;\n-               Outer : Boolean) return  Boolean;\n-            --  Traverse given list of declarations in reverse order. Return\n-            --  True if a referencer is present. Return False if none is found.\n-            --\n-            --  The Outer parameter is True for the outer level call and False\n-            --  for inner level calls for nested packages. If Outer is True,\n-            --  then any entities up to the point of hitting a referencer get\n-            --  their Is_Public flag cleared, so that the entities will be\n-            --  treated as static entities in the C sense, and need not have\n-            --  fully qualified names. Furthermore, if the referencer is an\n-            --  inlined subprogram that doesn't reference other subprograms,\n-            --  we keep clearing the Is_Public flag on subprograms. For inner\n-            --  levels, we need all names to be fully qualified to deal with\n-            --  the same name appearing in parallel packages (right now this\n-            --  is tied to their being external).\n-\n-            --------------------\n-            -- Has_Referencer --\n-            --------------------\n-\n-            function Has_Referencer\n-              (L     : List_Id;\n-               Outer : Boolean) return  Boolean\n-            is\n-               Has_Referencer_Except_For_Subprograms : Boolean := False;\n-\n-               D : Node_Id;\n-               E : Entity_Id;\n-               K : Node_Kind;\n-               S : Entity_Id;\n-\n-               function Check_Subprogram_Ref (N : Node_Id)\n-                 return Traverse_Result;\n-               --  Look for references to subprograms\n-\n-               --------------------------\n-               -- Check_Subprogram_Ref --\n-               --------------------------\n-\n-               function Check_Subprogram_Ref (N : Node_Id)\n-                 return Traverse_Result\n-               is\n-                  V : Node_Id;\n-\n-               begin\n-                  --  Check name of procedure or function calls\n-\n-                  if Nkind (N) in N_Subprogram_Call\n-                    and then Is_Entity_Name (Name (N))\n-                  then\n-                     return Abandon;\n-                  end if;\n-\n-                  --  Check prefix of attribute references\n-\n-                  if Nkind (N) = N_Attribute_Reference\n-                    and then Is_Entity_Name (Prefix (N))\n-                    and then Present (Entity (Prefix (N)))\n-                    and then Ekind (Entity (Prefix (N))) in Subprogram_Kind\n-                  then\n-                     return Abandon;\n-                  end if;\n-\n-                  --  Check value of constants\n-\n-                  if Nkind (N) = N_Identifier\n-                    and then Present (Entity (N))\n-                    and then Ekind (Entity (N)) = E_Constant\n-                  then\n-                     V := Constant_Value (Entity (N));\n-\n-                     if Present (V)\n-                       and then not Compile_Time_Known_Value_Or_Aggr (V)\n-                     then\n-                        return Abandon;\n-                     end if;\n-                  end if;\n-\n-                  return OK;\n-               end Check_Subprogram_Ref;\n-\n-               function Check_Subprogram_Refs is\n-                 new Traverse_Func (Check_Subprogram_Ref);\n-\n-            --  Start of processing for Has_Referencer\n-\n-            begin\n-               if No (L) then\n-                  return False;\n-               end if;\n-\n-               D := Last (L);\n-               while Present (D) loop\n-                  K := Nkind (D);\n-\n-                  if K in N_Body_Stub then\n-                     return True;\n-\n-                  --  Processing for subprogram bodies\n-\n-                  elsif K = N_Subprogram_Body then\n-                     if Acts_As_Spec (D) then\n-                        E := Defining_Entity (D);\n-\n-                        --  An inlined body acts as a referencer. Note also\n-                        --  that we never reset Is_Public for an inlined\n-                        --  subprogram. Gigi requires Is_Public to be set.\n-\n-                        --  Note that we test Has_Pragma_Inline here rather\n-                        --  than Is_Inlined. We are compiling this for a\n-                        --  client, and it is the client who will decide if\n-                        --  actual inlining should occur, so we need to assume\n-                        --  that the procedure could be inlined for the purpose\n-                        --  of accessing global entities.\n-\n-                        if Has_Pragma_Inline (E) then\n-                           if Outer and then Check_Subprogram_Refs (D) = OK\n-                           then\n-                              Has_Referencer_Except_For_Subprograms := True;\n-                           else\n-                              return True;\n-                           end if;\n-                        else\n-                           Set_Is_Public (E, False);\n-                        end if;\n-\n-                     else\n-                        E := Corresponding_Spec (D);\n-\n-                        if Present (E) then\n-\n-                           --  A generic subprogram body acts as a referencer\n-\n-                           if Is_Generic_Unit (E) then\n-                              return True;\n-                           end if;\n-\n-                           if Has_Pragma_Inline (E) or else Is_Inlined (E) then\n-                              if Outer and then Check_Subprogram_Refs (D) = OK\n-                              then\n-                                 Has_Referencer_Except_For_Subprograms := True;\n-                              else\n-                                 return True;\n-                              end if;\n-                           end if;\n-                        end if;\n-                     end if;\n-\n-                  --  Processing for package bodies\n-\n-                  elsif K = N_Package_Body\n-                    and then Present (Corresponding_Spec (D))\n-                  then\n-                     E := Corresponding_Spec (D);\n-\n-                     --  Generic package body is a referencer. It would seem\n-                     --  that we only have to consider generics that can be\n-                     --  exported, i.e. where the corresponding spec is the\n-                     --  spec of the current package, but because of nested\n-                     --  instantiations, a fully private generic body may\n-                     --  export other private body entities. Furthermore,\n-                     --  regardless of whether there was a previous inlined\n-                     --  subprogram, (an instantiation of) the generic package\n-                     --  may reference any entity declared before it.\n-\n-                     if Is_Generic_Unit (E) then\n-                        return True;\n-\n-                     --  For non-generic package body, recurse into body unless\n-                     --  this is an instance, we ignore instances since they\n-                     --  cannot have references that affect outer entities.\n-\n-                     elsif not Is_Generic_Instance (E)\n-                       and then not Has_Referencer_Except_For_Subprograms\n-                     then\n-                        if Has_Referencer\n-                             (Declarations (D), Outer => False)\n-                        then\n-                           return True;\n-                        end if;\n-                     end if;\n-\n-                  --  Processing for package specs, recurse into declarations.\n-                  --  Again we skip this for the case of generic instances.\n-\n-                  elsif K = N_Package_Declaration\n-                    and then not Has_Referencer_Except_For_Subprograms\n-                  then\n-                     S := Specification (D);\n-\n-                     if not Is_Generic_Unit (Defining_Entity (S)) then\n-                        if Has_Referencer\n-                             (Private_Declarations (S), Outer => False)\n-                        then\n-                           return True;\n-                        elsif Has_Referencer\n-                               (Visible_Declarations (S), Outer => False)\n-                        then\n-                           return True;\n-                        end if;\n-                     end if;\n-\n-                  --  Objects and exceptions need not be public if we have not\n-                  --  encountered a referencer so far. We only reset the flag\n-                  --  for outer level entities that are not imported/exported,\n-                  --  and which have no interface name.\n-\n-                  elsif Nkind_In (K, N_Object_Declaration,\n-                                     N_Exception_Declaration,\n-                                     N_Subprogram_Declaration)\n-                  then\n-                     E := Defining_Entity (D);\n-\n-                     if Outer\n-                       and then (not Has_Referencer_Except_For_Subprograms\n-                                  or else K = N_Subprogram_Declaration)\n-                       and then not Is_Imported (E)\n-                       and then not Is_Exported (E)\n-                       and then No (Interface_Name (E))\n-                     then\n-                        Set_Is_Public (E, False);\n-                     end if;\n-                  end if;\n-\n-                  Prev (D);\n-               end loop;\n-\n-               return Has_Referencer_Except_For_Subprograms;\n-            end Has_Referencer;\n-\n-         --  Start of processing for Make_Non_Public_Where_Possible\n-\n-         begin\n-            declare\n-               Discard : Boolean;\n-               pragma Warnings (Off, Discard);\n-\n-            begin\n-               Discard := Has_Referencer (Declarations (N), Outer => True);\n-            end;\n-         end Make_Non_Public_Where_Possible;\n+         Hide_Public_Entities (Declarations (N));\n       end if;\n \n       --  If expander is not active, then here is where we turn off the"}]}