{"sha": "0ce6f9fb5c19b089c871725873ae7745b1048463", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNlNmY5ZmI1YzE5YjA4OWM4NzE3MjU4NzNhZTc3NDViMTA0ODQ2Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T01:28:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T01:28:25Z"}, "message": "(use_movqi, const_method): New functions.\n\n(const_int_cost, output_move_const_into_data_reg): Likewise.\n(singlemove_string): Call output_move_const_into_data_reg.\n\nFrom-SVN: r8750", "tree": {"sha": "6e30e6660403807521e7740a955ddf2937166138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e30e6660403807521e7740a955ddf2937166138"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ce6f9fb5c19b089c871725873ae7745b1048463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce6f9fb5c19b089c871725873ae7745b1048463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce6f9fb5c19b089c871725873ae7745b1048463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce6f9fb5c19b089c871725873ae7745b1048463/comments", "author": null, "committer": null, "parents": [{"sha": "97c2a83f6cb8fbfd08366b070392fc51e307445b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c2a83f6cb8fbfd08366b070392fc51e307445b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c2a83f6cb8fbfd08366b070392fc51e307445b"}], "stats": {"total": 124, "additions": 113, "deletions": 11}, "files": [{"sha": "836dab30c2ec16daaefc20956e3414736214834e", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 113, "deletions": 11, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce6f9fb5c19b089c871725873ae7745b1048463/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce6f9fb5c19b089c871725873ae7745b1048463/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=0ce6f9fb5c19b089c871725873ae7745b1048463", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 68000 family.\n-   Copyright (C) 1987, 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -886,6 +886,116 @@ legitimize_pic_address (orig, mode, reg)\n }\n \n \f\n+typedef enum { MOVL, SWAP, NEGW, NOTW, NOTB, MOVQ } CONST_METHOD;\n+\n+use_movq (i)\n+     int i;\n+{\n+  return (i >= -128 && i <= 127);\n+}\n+\n+CONST_METHOD\n+const_method (constant)\n+     rtx constant;\n+{\n+  int i;\n+  unsigned u;\n+\n+  i = INTVAL (constant);\n+  if (use_movq (i))\n+    return MOVQ;\n+  /* if -256 < N < 256 but N is not in range for a moveq\n+     N^ff will be, so use moveq #N^ff, dreg; not.b dreg. */\n+  if (use_movq (i ^ 0xff))\n+    return NOTB;\n+  /* Likewise, try with not.w */\n+  if (use_movq (i ^ 0xffff))\n+    return NOTW;\n+  /* This is the only value where neg.w is usefull */\n+  if (i == -65408)\n+    return NEGW;\n+  /* Try also with swap */\n+  u = i;\n+  if (use_movq ((u >> 16) | (u << 16)))\n+    return SWAP;\n+  /* Otherwise, use move.l */\n+  return MOVL;\n+}\n+\n+const_int_cost (constant)\n+     rtx constant;\n+{\n+  switch (const_method (constant))\n+    {\n+      case MOVQ :\n+      /* Constants between -128 and 127 are cheap due to moveq */\n+\treturn 0;\n+      case NOTB :\n+      case NOTW :\n+      case NEGW :\n+      case SWAP :\n+      /* Constants easily generated by moveq + not.b/not.w/neg.w/swap  */\n+        return 1;\n+      case MOVL :\n+\treturn 2;\n+      default :\n+        abort ();\n+    }\n+}\n+\n+char *\n+output_move_const_into_data_reg (operands)\n+     rtx *operands;\n+{\n+  int i;\n+\n+  i = INTVAL (operands[1]);\n+  switch (const_method (operands[1]))\n+    {\n+    case MOVQ :\n+#if defined (MOTOROLA) && !defined (CRDS)\n+      return \"moveq%.l %1,%0\";\n+#else\n+      return \"moveq %1,%0\";\n+#endif\n+    case NOTB :\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, i ^ 0xff);\n+#if defined (MOTOROLA) && !defined (CRDS)\n+      return \"moveq%.l %1,%0\\n\\tnot%.b %0\";\n+#else\n+      return \"moveq %1,%0\\n\\tnot%.b %0\";\n+#endif\t \n+    case NOTW :\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, i ^ 0xffff);\n+#if defined (MOTOROLA) && !defined (CRDS)\n+      return \"moveq%.l %1,%0\\n\\tnot%.w %0\";\n+#else\n+      return \"moveq %1,%0\\n\\tnot%.w %0\";\n+#endif\t \n+    case NEGW :\n+#if defined (MOTOROLA) && !defined (CRDS)\n+      return \"moveq%.l %#-128,%0\\n\\tneg%.w %0\";\n+#else\n+      return \"moveq %#-128,%0\\n\\tneg%.w %0\";\n+#endif\t \n+    case SWAP :\n+      {\n+\tunsigned u = i;\n+\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode, (u << 16) | (u >> 16));\n+#if defined (MOTOROLA) && !defined (CRDS)\n+\treturn \"moveq%.l %1,%0\\n\\tswap %0\";\n+#else\n+\treturn \"moveq %1,%0\\n\\tswap %0\";\n+#endif\t \n+      }\n+    case MOVL :\n+\treturn \"move%.l %1,%0\";\n+    default :\n+\tabort ();\n+    }\n+}\n+\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */\n \n@@ -898,16 +1008,8 @@ singlemove_string (operands)\n     return \"fpmoves %1,%0\";\n #endif\n   if (DATA_REG_P (operands[0])\n-      && GET_CODE (operands[1]) == CONST_INT\n-      && INTVAL (operands[1]) < 128\n-      && INTVAL (operands[1]) >= -128)\n-    {\n-#if defined (MOTOROLA) && !defined (CRDS)\n-      return \"moveq%.l %1,%0\";\n-#else\n-      return \"moveq %1,%0\";\n-#endif\n-    }\n+      && GET_CODE (operands[1]) == CONST_INT)\n+      return output_move_const_into_data_reg (operands);\n   if (operands[1] != const0_rtx)\n     return \"move%.l %1,%0\";\n   if (! ADDRESS_REG_P (operands[0]))"}]}