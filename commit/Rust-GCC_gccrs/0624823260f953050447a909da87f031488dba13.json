{"sha": "0624823260f953050447a909da87f031488dba13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyNDgyMzI2MGY5NTMwNTA0NDdhOTA5ZGE4N2YwMzE0ODhkYmExMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-04T21:26:58Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-05T06:06:17Z"}, "message": "libcc1: share basic context code\n\nBoth plugins in libcc1 share a fair amount of boilerplate.  They both\nshare error-emission code, context management code, and tree GC code.\nThis patch unifies these two bodies of code, avoiding needless\nduplication.\n\nlibcc1\n\n\t* libcc1plugin.cc: Move code to context.cc.\n\t* libcp1plugin.cc: Move code to context.cc.\n\t* context.hh: New file.\n\t* context.cc: New file.\n\t* Makefile.in: Rebuild.\n\t* Makefile.am (AM_CPPFLAGS): Add more gcc flags.\n\t(CPPFLAGS_FOR_C, CPPFLAGS_FOR_CXX): Update.\n\t(libcc1plugin_la_SOURCES): Add context.hh, context.cc.\n\t(libcp1plugin_la_SOURCES): Likewise.", "tree": {"sha": "0bfb6977bc5cc58a57f2d2df6f5dea9c0f477e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bfb6977bc5cc58a57f2d2df6f5dea9c0f477e82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0624823260f953050447a909da87f031488dba13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0624823260f953050447a909da87f031488dba13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0624823260f953050447a909da87f031488dba13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0624823260f953050447a909da87f031488dba13/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ed83e1d03b4864b5f50b6a8735ed8e3a3635193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed83e1d03b4864b5f50b6a8735ed8e3a3635193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ed83e1d03b4864b5f50b6a8735ed8e3a3635193"}], "stats": {"total": 741, "additions": 321, "deletions": 420}, "files": [{"sha": "9ec021030e2d16b4e20e5dbd6374052625fa99e2", "filename": "libcc1/Makefile.am", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FMakefile.am?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -19,11 +19,10 @@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n gcc_build_dir = ../gcc\n AM_CPPFLAGS = -I $(srcdir)/../include -I $(srcdir)/../libgcc \\\n-\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC)\n-CPPFLAGS_FOR_C_FAMILY = -I $(srcdir)/../gcc/c-family \\\n-\t-I $(srcdir)/../libcpp/include\n-CPPFLAGS_FOR_C = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/c\n-CPPFLAGS_FOR_CXX = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/cp\n+\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC) \\\n+\t-I $(srcdir)/../gcc/c-family -I $(srcdir)/../libcpp/include\n+CPPFLAGS_FOR_C = -I $(srcdir)/../gcc/c\n+CPPFLAGS_FOR_CXX = -I $(srcdir)/../gcc/cp\n AM_CXXFLAGS = $(WARN_FLAGS) $(WERROR) $(visibility) $(CET_HOST_FLAGS)\n if DARWIN_DYNAMIC_LOOKUP\n AM_CXXFLAGS += -Wl,-undefined,dynamic_lookup\n@@ -55,7 +54,8 @@ marshall_c_source = marshall-c.hh\n marshall_cxx_source = marshall-cp.hh\n \n libcc1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1plugin.sym\n-libcc1plugin_la_SOURCES = libcc1plugin.cc $(shared_source) $(marshall_c_source)\n+libcc1plugin_la_SOURCES = libcc1plugin.cc context.cc context.hh \\\n+\t$(shared_source) $(marshall_c_source)\n libcc1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_C)\n libcc1plugin_la_LIBADD = $(libiberty)\n libcc1plugin_la_DEPENDENCIES = $(libiberty_dep)\n@@ -64,7 +64,8 @@ libcc1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(CXXFLAGS) $(libcc1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n \n libcp1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcp1plugin.sym\n-libcp1plugin_la_SOURCES = libcp1plugin.cc $(shared_source) $(marshall_cxx_source)\n+libcp1plugin_la_SOURCES = libcp1plugin.cc context.cc context.hh \\\n+\t$(shared_source) $(marshall_cxx_source)\n libcp1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_CXX)\n libcp1plugin_la_LIBADD = $(libiberty)\n libcp1plugin_la_DEPENDENCIES = $(libiberty_dep)"}, {"sha": "395f01a98215811b0d910b3078f70074e3fd5438", "filename": "libcc1/Makefile.in", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FMakefile.in?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -148,12 +148,12 @@ am_libcc1_la_OBJECTS = findcomp.lo libcc1.lo libcp1.lo compiler.lo \\\n \tnames.lo $(am__objects_1) $(am__objects_2) $(am__objects_2)\n libcc1_la_OBJECTS = $(am_libcc1_la_OBJECTS)\n @ENABLE_PLUGIN_TRUE@am_libcc1_la_rpath = -rpath $(cc1libdir)\n-am_libcc1plugin_la_OBJECTS = libcc1plugin.lo $(am__objects_1) \\\n-\t$(am__objects_2)\n+am_libcc1plugin_la_OBJECTS = libcc1plugin.lo context.lo \\\n+\t$(am__objects_1) $(am__objects_2)\n libcc1plugin_la_OBJECTS = $(am_libcc1plugin_la_OBJECTS)\n @ENABLE_PLUGIN_TRUE@am_libcc1plugin_la_rpath = -rpath $(plugindir)\n-am_libcp1plugin_la_OBJECTS = libcp1plugin.lo $(am__objects_1) \\\n-\t$(am__objects_2)\n+am_libcp1plugin_la_OBJECTS = libcp1plugin.lo context.lo \\\n+\t$(am__objects_1) $(am__objects_2)\n libcp1plugin_la_OBJECTS = $(am_libcp1plugin_la_OBJECTS)\n @ENABLE_PLUGIN_TRUE@am_libcp1plugin_la_rpath = -rpath $(plugindir)\n AM_V_P = $(am__v_P_@AM_V@)\n@@ -379,13 +379,11 @@ visibility = @visibility@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n gcc_build_dir = ../gcc\n AM_CPPFLAGS = -I $(srcdir)/../include -I $(srcdir)/../libgcc \\\n-\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC)\n+\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC) \\\n+\t-I $(srcdir)/../gcc/c-family -I $(srcdir)/../libcpp/include\n \n-CPPFLAGS_FOR_C_FAMILY = -I $(srcdir)/../gcc/c-family \\\n-\t-I $(srcdir)/../libcpp/include\n-\n-CPPFLAGS_FOR_C = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/c\n-CPPFLAGS_FOR_CXX = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/cp\n+CPPFLAGS_FOR_C = -I $(srcdir)/../gcc/c\n+CPPFLAGS_FOR_CXX = -I $(srcdir)/../gcc/cp\n AM_CXXFLAGS = $(WARN_FLAGS) $(WERROR) $(visibility) $(CET_HOST_FLAGS) \\\n \t$(am__append_1)\n # Can be simplified when libiberty becomes a normal convenience library.\n@@ -408,7 +406,9 @@ shared_source = callbacks.cc callbacks.hh connection.cc connection.hh \\\n marshall_c_source = marshall-c.hh\n marshall_cxx_source = marshall-cp.hh\n libcc1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1plugin.sym\n-libcc1plugin_la_SOURCES = libcc1plugin.cc $(shared_source) $(marshall_c_source)\n+libcc1plugin_la_SOURCES = libcc1plugin.cc context.cc context.hh \\\n+\t$(shared_source) $(marshall_c_source)\n+\n libcc1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_C)\n libcc1plugin_la_LIBADD = $(libiberty)\n libcc1plugin_la_DEPENDENCIES = $(libiberty_dep)\n@@ -417,7 +417,9 @@ libcc1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(CXXFLAGS) $(libcc1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n \n libcp1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcp1plugin.sym\n-libcp1plugin_la_SOURCES = libcp1plugin.cc $(shared_source) $(marshall_cxx_source)\n+libcp1plugin_la_SOURCES = libcp1plugin.cc context.cc context.hh \\\n+\t$(shared_source) $(marshall_cxx_source)\n+\n libcp1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_CXX)\n libcp1plugin_la_LIBADD = $(libiberty)\n libcp1plugin_la_DEPENDENCIES = $(libiberty_dep)\n@@ -579,6 +581,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/callbacks.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/compiler.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/connection.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/context.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findcomp.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcc1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcc1plugin.Plo@am__quote@"}, {"sha": "3d5ff921df8af4baa3627c4b892e9ab0f4a73194", "filename": "libcc1/context.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2Fcontext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2Fcontext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fcontext.cc?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -0,0 +1,171 @@\n+/* Generic plugin context\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <cc1plugin-config.h>\n+\n+#undef PACKAGE_NAME\n+#undef PACKAGE_STRING\n+#undef PACKAGE_TARNAME\n+#undef PACKAGE_VERSION\n+\n+#include \"../gcc/config.h\"\n+\n+#undef PACKAGE_NAME\n+#undef PACKAGE_STRING\n+#undef PACKAGE_TARNAME\n+#undef PACKAGE_VERSION\n+\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"stringpool.h\"\n+#include \"hash-set.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+\n+#include \"gcc-interface.h\"\n+\n+#include \"context.hh\"\n+#include \"marshall.hh\"\n+\n+\f\n+\n+#ifdef __GNUC__\n+#pragma GCC visibility push(default)\n+#endif\n+int plugin_is_GPL_compatible;\n+#ifdef __GNUC__\n+#pragma GCC visibility pop\n+#endif\n+\n+cc1_plugin::plugin_context *cc1_plugin::current_context;\n+\n+\f\n+\n+// This is put into the lang hooks when the plugin starts.\n+\n+static void\n+plugin_print_error_function (diagnostic_context *context, const char *file,\n+\t\t\t     diagnostic_info *diagnostic)\n+{\n+  if (current_function_decl != NULL_TREE\n+      && DECL_NAME (current_function_decl) != NULL_TREE\n+      && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n+\t\t GCC_FE_WRAPPER_FUNCTION) == 0)\n+    return;\n+  lhd_print_error_function (context, file, diagnostic);\n+}\n+\n+\f\n+\n+location_t\n+cc1_plugin::plugin_context::get_location_t (const char *filename,\n+\t\t\t\t\t    unsigned int line_number)\n+{\n+  if (filename == NULL)\n+    return UNKNOWN_LOCATION;\n+\n+  filename = intern_filename (filename);\n+  linemap_add (line_table, LC_ENTER, false, filename, line_number);\n+  location_t loc = linemap_line_start (line_table, line_number, 0);\n+  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+  return loc;\n+}\n+\n+// Add a file name to FILE_NAMES and return the canonical copy.\n+const char *\n+cc1_plugin::plugin_context::intern_filename (const char *filename)\n+{\n+  const char **slot = file_names.find_slot (filename, INSERT);\n+  if (*slot == NULL)\n+    {\n+      /* The file name must live as long as the line map, which\n+\t effectively means as long as this compilation.  So, we copy\n+\t the string here but never free it.  */\n+      *slot = xstrdup (filename);\n+    }\n+  return *slot;\n+}\n+\n+void\n+cc1_plugin::plugin_context::mark ()\n+{\n+  for (const auto &item : address_map)\n+    {\n+      ggc_mark (item->decl);\n+      ggc_mark (item->address);\n+    }\n+\n+  for (const auto &item : preserved)\n+    ggc_mark (&item);\n+}\n+\n+\f\n+\n+// Perform GC marking.\n+\n+static void\n+gc_mark (void *, void *)\n+{\n+  if (cc1_plugin::current_context != NULL)\n+    cc1_plugin::current_context->mark ();\n+}\n+\n+void\n+cc1_plugin::generic_plugin_init (struct plugin_name_args *plugin_info,\n+\t\t\t\t unsigned int version)\n+{\n+  long fd = -1;\n+  for (int i = 0; i < plugin_info->argc; ++i)\n+    {\n+      if (strcmp (plugin_info->argv[i].key, \"fd\") == 0)\n+\t{\n+\t  char *tail;\n+\t  errno = 0;\n+\t  fd = strtol (plugin_info->argv[i].value, &tail, 0);\n+\t  if (*tail != '\\0' || errno != 0)\n+\t    fatal_error (input_location,\n+\t\t\t \"%s: invalid file descriptor argument to plugin\",\n+\t\t\t plugin_info->base_name);\n+\t  break;\n+\t}\n+    }\n+  if (fd == -1)\n+    fatal_error (input_location,\n+\t\t \"%s: required plugin argument %<fd%> is missing\",\n+\t\t plugin_info->base_name);\n+\n+  current_context = new plugin_context (fd);\n+\n+  // Handshake.\n+  cc1_plugin::protocol_int h_version;\n+  if (!current_context->require ('H')\n+      || ! ::cc1_plugin::unmarshall (current_context, &h_version))\n+    fatal_error (input_location,\n+\t\t \"%s: handshake failed\", plugin_info->base_name);\n+  if (h_version != version)\n+    fatal_error (input_location,\n+\t\t \"%s: unknown version in handshake\", plugin_info->base_name);\n+\n+  register_callback (plugin_info->base_name, PLUGIN_GGC_MARKING,\n+\t\t     gc_mark, NULL);\n+\n+  lang_hooks.print_error_function = plugin_print_error_function;\n+}"}, {"sha": "21a8262ad4be4b693520819b9620c46821abe2b0", "filename": "libcc1/context.hh", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2Fcontext.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2Fcontext.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fcontext.hh?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -0,0 +1,121 @@\n+/* Generic plugin context\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CC1_PLUGIN_CONTEXT_HH\n+#define CC1_PLUGIN_CONTEXT_HH\n+\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+#include \"connection.hh\"\n+\n+namespace cc1_plugin\n+{\n+  static inline unsigned long long\n+  convert_out (tree t)\n+  {\n+    return (unsigned long long) (uintptr_t) t;\n+  }\n+\n+  static inline tree\n+  convert_in (unsigned long long v)\n+  {\n+    return (tree) (uintptr_t) v;\n+  }\n+\n+  struct decl_addr_value\n+  {\n+    tree decl;\n+    tree address;\n+  };\n+\n+  struct decl_addr_hasher : free_ptr_hash<decl_addr_value>\n+  {\n+    static hashval_t hash (const decl_addr_value *e)\n+    {\n+      return DECL_UID (e->decl);\n+    }\n+\n+    static bool equal (const decl_addr_value *p1,\n+\t\t       const decl_addr_value *p2)\n+    {\n+      return p1->decl == p2->decl;\n+    }\n+  };\n+\n+  struct string_hasher : nofree_ptr_hash<const char>\n+  {\n+    static inline hashval_t hash (const char *s)\n+    {\n+      return htab_hash_string (s);\n+    }\n+\n+    static inline bool equal (const char *p1, const char *p2)\n+    {\n+      return strcmp (p1, p2) == 0;\n+    }\n+  };\n+\n+  struct plugin_context : public cc1_plugin::connection\n+  {\n+    plugin_context (int fd)\n+      : cc1_plugin::connection (fd),\n+\taddress_map (30),\n+\tpreserved (30),\n+\tfile_names (30)\n+    {\n+    }\n+\n+    // Map decls to addresses.\n+    hash_table<decl_addr_hasher> address_map;\n+\n+    // A collection of trees that are preserved for the GC.\n+    hash_table< nofree_ptr_hash<tree_node> > preserved;\n+\n+    // File name cache.\n+    hash_table<string_hasher> file_names;\n+\n+    // Perform GC marking.\n+    void mark ();\n+\n+    // Preserve a tree during the plugin's operation.\n+    tree preserve (tree t)\n+    {\n+      tree_node **slot = preserved.find_slot (t, INSERT);\n+      *slot = t;\n+      return t;\n+    }\n+\n+    location_t get_location_t (const char *filename,\n+\t\t\t       unsigned int line_number);\n+\n+  private:\n+\n+    // Add a file name to FILE_NAMES and return the canonical copy.\n+    const char *intern_filename (const char *filename);\n+  };\n+\n+  extern plugin_context *current_context;\n+\n+  void generic_plugin_init (struct plugin_name_args *plugin_info,\n+\t\t\t    unsigned int version);\n+}\n+\n+#endif // CC1_PLUGIN_CONTEXT_HH"}, {"sha": "d6951ab1a4d2047d5c71960c51568d66064437ae", "filename": "libcc1/libcc1plugin.cc", "status": "modified", "additions": 3, "deletions": 201, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2Flibcc1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2Flibcc1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1plugin.cc?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -66,87 +66,11 @@\n #include \"marshall.hh\"\n #include \"rpc.hh\"\n #include \"gcc-c-interface.h\"\n+#include \"context.hh\"\n \n #include <vector>\n \n-#ifdef __GNUC__\n-#pragma GCC visibility push(default)\n-#endif\n-int plugin_is_GPL_compatible;\n-#ifdef __GNUC__\n-#pragma GCC visibility pop\n-#endif\n-\n-\f\n-\n-// This is put into the lang hooks when the plugin starts.\n-\n-static void\n-plugin_print_error_function (diagnostic_context *context, const char *file,\n-\t\t\t     diagnostic_info *diagnostic)\n-{\n-  if (current_function_decl != NULL_TREE\n-      && DECL_NAME (current_function_decl) != NULL_TREE\n-      && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n-\t\t GCC_FE_WRAPPER_FUNCTION) == 0)\n-    return;\n-  lhd_print_error_function (context, file, diagnostic);\n-}\n-\n-\f\n-\n-static unsigned long long\n-convert_out (tree t)\n-{\n-  return (unsigned long long) (uintptr_t) t;\n-}\n-\n-static tree\n-convert_in (unsigned long long v)\n-{\n-  return (tree) (uintptr_t) v;\n-}\n-\n-\f\n-\n-struct decl_addr_value\n-{\n-  tree decl;\n-  tree address;\n-};\n-\n-struct decl_addr_hasher : free_ptr_hash<decl_addr_value>\n-{\n-  static inline hashval_t hash (const decl_addr_value *);\n-  static inline bool equal (const decl_addr_value *, const decl_addr_value *);\n-};\n-\n-inline hashval_t\n-decl_addr_hasher::hash (const decl_addr_value *e)\n-{\n-  return IDENTIFIER_HASH_VALUE (DECL_NAME (e->decl));\n-}\n-\n-inline bool\n-decl_addr_hasher::equal (const decl_addr_value *p1, const decl_addr_value *p2)\n-{\n-  return p1->decl == p2->decl;\n-}\n-\n-\f\n-\n-struct string_hasher : nofree_ptr_hash<const char>\n-{\n-  static inline hashval_t hash (const char *s)\n-  {\n-    return htab_hash_string (s);\n-  }\n-\n-  static inline bool equal (const char *p1, const char *p2)\n-  {\n-    return strcmp (p1, p2) == 0;\n-  }\n-};\n+using namespace cc1_plugin;\n \n \f\n \n@@ -166,85 +90,6 @@ pushdecl_safe (tree decl)\n \n \f\n \n-struct plugin_context : public cc1_plugin::connection\n-{\n-  plugin_context (int fd);\n-\n-  // Map decls to addresses.\n-  hash_table<decl_addr_hasher> address_map;\n-\n-  // A collection of trees that are preserved for the GC.\n-  hash_table< nofree_ptr_hash<tree_node> > preserved;\n-\n-  // File name cache.\n-  hash_table<string_hasher> file_names;\n-\n-  // Perform GC marking.\n-  void mark ();\n-\n-  // Preserve a tree during the plugin's operation.\n-  tree preserve (tree t)\n-  {\n-    tree_node **slot = preserved.find_slot (t, INSERT);\n-    *slot = t;\n-    return t;\n-  }\n-\n-  location_t get_location_t (const char *filename,\n-\t\t\t     unsigned int line_number)\n-  {\n-    if (filename == NULL)\n-      return UNKNOWN_LOCATION;\n-\n-    filename = intern_filename (filename);\n-    linemap_add (line_table, LC_ENTER, false, filename, line_number);\n-    location_t loc = linemap_line_start (line_table, line_number, 0);\n-    linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-    return loc;\n-  }\n-\n-private:\n-\n-  // Add a file name to FILE_NAMES and return the canonical copy.\n-  const char *intern_filename (const char *filename)\n-  {\n-    const char **slot = file_names.find_slot (filename, INSERT);\n-    if (*slot == NULL)\n-      {\n-\t/* The file name must live as long as the line map, which\n-\t   effectively means as long as this compilation.  So, we copy\n-\t   the string here but never free it.  */\n-\t*slot = xstrdup (filename);\n-      }\n-    return *slot;\n-  }\n-};\n-\n-static plugin_context *current_context;\n-\n-\f\n-\n-plugin_context::plugin_context (int fd)\n-  : cc1_plugin::connection (fd),\n-    address_map (30),\n-    preserved (30),\n-    file_names (30)\n-{\n-}\n-\n-void\n-plugin_context::mark ()\n-{\n-  for (const auto &item : address_map)\n-    {\n-      ggc_mark (item->decl);\n-      ggc_mark (item->address);\n-    }\n-\n-  for (const auto &item : preserved)\n-    ggc_mark (&item);\n-}\n-\n static void\n plugin_binding_oracle (enum c_oracle_request kind, tree identifier)\n {\n@@ -899,15 +744,6 @@ plugin_error (cc1_plugin::connection *,\n \n \f\n \n-// Perform GC marking.\n-\n-static void\n-gc_mark (void *, void *)\n-{\n-  if (current_context != NULL)\n-    current_context->mark ();\n-}\n-\n #ifdef __GNUC__\n #pragma GCC visibility push(default)\n #endif\n@@ -916,46 +752,12 @@ int\n plugin_init (struct plugin_name_args *plugin_info,\n \t     struct plugin_gcc_version *)\n {\n-  long fd = -1;\n-  for (int i = 0; i < plugin_info->argc; ++i)\n-    {\n-      if (strcmp (plugin_info->argv[i].key, \"fd\") == 0)\n-\t{\n-\t  char *tail;\n-\t  errno = 0;\n-\t  fd = strtol (plugin_info->argv[i].value, &tail, 0);\n-\t  if (*tail != '\\0' || errno != 0)\n-\t    fatal_error (input_location,\n-\t\t\t \"%s: invalid file descriptor argument to plugin\",\n-\t\t\t plugin_info->base_name);\n-\t  break;\n-\t}\n-    }\n-  if (fd == -1)\n-    fatal_error (input_location,\n-\t\t \"%s: required plugin argument %<fd%> is missing\",\n-\t\t plugin_info->base_name);\n-\n-  current_context = new plugin_context (fd);\n-\n-  // Handshake.\n-  cc1_plugin::protocol_int version;\n-  if (!current_context->require ('H')\n-      || ! ::cc1_plugin::unmarshall (current_context, &version))\n-    fatal_error (input_location,\n-\t\t \"%s: handshake failed\", plugin_info->base_name);\n-  if (version != GCC_C_FE_VERSION_1)\n-    fatal_error (input_location,\n-\t\t \"%s: unknown version in handshake\", plugin_info->base_name);\n+  generic_plugin_init (plugin_info, GCC_C_FE_VERSION_1);\n \n   register_callback (plugin_info->base_name, PLUGIN_PRAGMAS,\n \t\t     plugin_init_extra_pragmas, NULL);\n   register_callback (plugin_info->base_name, PLUGIN_PRE_GENERICIZE,\n \t\t     rewrite_decls_to_addresses, NULL);\n-  register_callback (plugin_info->base_name, PLUGIN_GGC_MARKING,\n-\t\t     gc_mark, NULL);\n-\n-  lang_hooks.print_error_function = plugin_print_error_function;\n \n #define GCC_METHOD0(R, N)\t\t\t\\\n   {\t\t\t\t\t\t\\"}, {"sha": "64cde651139cac6b253e2b4df1d84cf99f77f5c1", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 3, "deletions": 200, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0624823260f953050447a909da87f031488dba13/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0624823260f953050447a909da87f031488dba13/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=0624823260f953050447a909da87f031488dba13", "patch": "@@ -38,7 +38,6 @@\n #include \"stringpool.h\"\n \n #include \"gcc-interface.h\"\n-#include \"hash-set.h\"\n #include \"machmode.h\"\n #include \"vec.h\"\n #include \"double-int.h\"\n@@ -69,172 +68,19 @@\n #include \"connection.hh\"\n #include \"marshall-cp.hh\"\n #include \"rpc.hh\"\n+#include \"context.hh\"\n \n #include <vector>\n \n-#ifdef __GNUC__\n-#pragma GCC visibility push(default)\n-#endif\n-int plugin_is_GPL_compatible;\n-#ifdef __GNUC__\n-#pragma GCC visibility pop\n-#endif\n+using namespace cc1_plugin;\n \n \f\n \n static_assert (GCC_CP_SYMBOL_MASK >= GCC_CP_SYMBOL_END,\n \t       \"GCC_CP_SYMBOL_MASK >= GCC_CP_SYMBOL_END\");\n \n-// This is put into the lang hooks when the plugin starts.\n-\n-static void\n-plugin_print_error_function (diagnostic_context *context, const char *file,\n-\t\t\t     diagnostic_info *diagnostic)\n-{\n-  if (current_function_decl != NULL_TREE\n-      && DECL_NAME (current_function_decl) != NULL_TREE\n-      && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n-\t\t GCC_FE_WRAPPER_FUNCTION) == 0)\n-    return;\n-  lhd_print_error_function (context, file, diagnostic);\n-}\n-\n \f\n \n-static unsigned long long\n-convert_out (tree t)\n-{\n-  return (unsigned long long) (uintptr_t) t;\n-}\n-\n-static tree\n-convert_in (unsigned long long v)\n-{\n-  return (tree) (uintptr_t) v;\n-}\n-\n-\f\n-\n-struct decl_addr_value\n-{\n-  tree decl;\n-  tree address;\n-};\n-\n-struct decl_addr_hasher : free_ptr_hash<decl_addr_value>\n-{\n-  static inline hashval_t hash (const decl_addr_value *);\n-  static inline bool equal (const decl_addr_value *, const decl_addr_value *);\n-};\n-\n-inline hashval_t\n-decl_addr_hasher::hash (const decl_addr_value *e)\n-{\n-  return DECL_UID (e->decl);\n-}\n-\n-inline bool\n-decl_addr_hasher::equal (const decl_addr_value *p1, const decl_addr_value *p2)\n-{\n-  return p1->decl == p2->decl;\n-}\n-\n-\f\n-\n-struct string_hasher : nofree_ptr_hash<const char>\n-{\n-  static inline hashval_t hash (const char *s)\n-  {\n-    return htab_hash_string (s);\n-  }\n-\n-  static inline bool equal (const char *p1, const char *p2)\n-  {\n-    return strcmp (p1, p2) == 0;\n-  }\n-};\n-\n-\f\n-\n-struct plugin_context : public cc1_plugin::connection\n-{\n-  plugin_context (int fd);\n-\n-  // Map decls to addresses.\n-  hash_table<decl_addr_hasher> address_map;\n-\n-  // A collection of trees that are preserved for the GC.\n-  hash_table< nofree_ptr_hash<tree_node> > preserved;\n-\n-  // File name cache.\n-  hash_table<string_hasher> file_names;\n-\n-  // Perform GC marking.\n-  void mark ();\n-\n-  // Preserve a tree during the plugin's operation.\n-  tree preserve (tree t)\n-  {\n-    tree_node **slot = preserved.find_slot (t, INSERT);\n-    *slot = t;\n-    return t;\n-  }\n-\n-  location_t get_location_t (const char *filename,\n-\t\t\t     unsigned int line_number)\n-  {\n-    if (filename == NULL)\n-      return UNKNOWN_LOCATION;\n-\n-    filename = intern_filename (filename);\n-    linemap_add (line_table, LC_ENTER, false, filename, line_number);\n-    location_t loc = linemap_line_start (line_table, line_number, 0);\n-    linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-    return loc;\n-  }\n-\n-private:\n-\n-  // Add a file name to FILE_NAMES and return the canonical copy.\n-  const char *intern_filename (const char *filename)\n-  {\n-    const char **slot = file_names.find_slot (filename, INSERT);\n-    if (*slot == NULL)\n-      {\n-\t/* The file name must live as long as the line map, which\n-\t   effectively means as long as this compilation.  So, we copy\n-\t   the string here but never free it.  */\n-\t*slot = xstrdup (filename);\n-      }\n-    return *slot;\n-  }\n-};\n-\n-static plugin_context *current_context;\n-\n-\f\n-\n-plugin_context::plugin_context (int fd)\n-  : cc1_plugin::connection (fd),\n-    address_map (30),\n-    preserved (30),\n-    file_names (30)\n-{\n-}\n-\n-void\n-plugin_context::mark ()\n-{\n-  for (const auto &item : address_map)\n-    {\n-      ggc_mark (item->decl);\n-      ggc_mark (item->address);\n-    }\n-\n-  for (const auto &item : preserved)\n-    ggc_mark (&item);\n-}\n-\n static void\n plugin_binding_oracle (enum cp_oracle_request kind, tree identifier)\n {\n@@ -3645,15 +3491,6 @@ plugin_add_static_assert (cc1_plugin::connection *self,\n \n \f\n \n-// Perform GC marking.\n-\n-static void\n-gc_mark (void *, void *)\n-{\n-  if (current_context != NULL)\n-    current_context->mark ();\n-}\n-\n #ifdef __GNUC__\n #pragma GCC visibility push(default)\n #endif\n@@ -3662,46 +3499,12 @@ int\n plugin_init (struct plugin_name_args *plugin_info,\n \t     struct plugin_gcc_version *)\n {\n-  long fd = -1;\n-  for (int i = 0; i < plugin_info->argc; ++i)\n-    {\n-      if (strcmp (plugin_info->argv[i].key, \"fd\") == 0)\n-\t{\n-\t  char *tail;\n-\t  errno = 0;\n-\t  fd = strtol (plugin_info->argv[i].value, &tail, 0);\n-\t  if (*tail != '\\0' || errno != 0)\n-\t    fatal_error (input_location,\n-\t\t\t \"%s: invalid file descriptor argument to plugin\",\n-\t\t\t plugin_info->base_name);\n-\t  break;\n-\t}\n-    }\n-  if (fd == -1)\n-    fatal_error (input_location,\n-\t\t \"%s: required plugin argument %<fd%> is missing\",\n-\t\t plugin_info->base_name);\n-\n-  current_context = new plugin_context (fd);\n-\n-  // Handshake.\n-  cc1_plugin::protocol_int version;\n-  if (!current_context->require ('H')\n-      || ! ::cc1_plugin::unmarshall (current_context, &version))\n-    fatal_error (input_location,\n-\t\t \"%s: handshake failed\", plugin_info->base_name);\n-  if (version != GCC_CP_FE_VERSION_0)\n-    fatal_error (input_location,\n-\t\t \"%s: unknown version in handshake\", plugin_info->base_name);\n+  generic_plugin_init (plugin_info, GCC_CP_FE_VERSION_0);\n \n   register_callback (plugin_info->base_name, PLUGIN_PRAGMAS,\n \t\t     plugin_init_extra_pragmas, NULL);\n   register_callback (plugin_info->base_name, PLUGIN_PRE_GENERICIZE,\n \t\t     rewrite_decls_to_addresses, NULL);\n-  register_callback (plugin_info->base_name, PLUGIN_GGC_MARKING,\n-\t\t     gc_mark, NULL);\n-\n-  lang_hooks.print_error_function = plugin_print_error_function;\n \n #define GCC_METHOD0(R, N)\t\t\t\\\n   {\t\t\t\t\t\t\\"}]}