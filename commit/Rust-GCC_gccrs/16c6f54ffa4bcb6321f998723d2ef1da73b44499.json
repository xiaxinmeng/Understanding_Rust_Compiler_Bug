{"sha": "16c6f54ffa4bcb6321f998723d2ef1da73b44499", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZjNmY1NGZmYTRiY2I2MzIxZjk5ODcyM2QyZWYxZGE3M2I0NDQ5OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-16T12:16:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-16T12:16:54Z"}, "message": "i386.c (ix86_adjust_stack_and_probe): Adjust and use an lea instruction when possible.\n\n\t* config/i386/i386.c (ix86_adjust_stack_and_probe): Adjust and use\n\tan lea instruction when possible.\n\t(output_adjust_stack_and_probe): Rotate the loop and simplify.\n\t(ix86_emit_probe_stack_range): Adjust.\n\t(output_probe_stack_range): Rotate the loop and simplify.\n\nFrom-SVN: r230412", "tree": {"sha": "5e0ba2ae457edfe8f41b910c9b8ec34c6d1eb5b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e0ba2ae457edfe8f41b910c9b8ec34c6d1eb5b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16c6f54ffa4bcb6321f998723d2ef1da73b44499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16c6f54ffa4bcb6321f998723d2ef1da73b44499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16c6f54ffa4bcb6321f998723d2ef1da73b44499", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16c6f54ffa4bcb6321f998723d2ef1da73b44499/comments", "author": null, "committer": null, "parents": [{"sha": "ae5e29239e28818f807cf11775c95c4243d9a256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5e29239e28818f807cf11775c95c4243d9a256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5e29239e28818f807cf11775c95c4243d9a256"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "de7c21c69578e8dfbf7754dd50b6298940188994", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16c6f54ffa4bcb6321f998723d2ef1da73b44499/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16c6f54ffa4bcb6321f998723d2ef1da73b44499/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16c6f54ffa4bcb6321f998723d2ef1da73b44499", "patch": "@@ -1,3 +1,11 @@\n+2015-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/i386/i386.c (ix86_adjust_stack_and_probe): Adjust and use\n+\tan lea instruction when possible.\n+\t(output_adjust_stack_and_probe): Rotate the loop and simplify.\n+\t(ix86_emit_probe_stack_range): Adjust.\n+\t(output_probe_stack_range): Rotate the loop and simplify.\n+\n 2015-11-16  Christian Bruel  <christian.bruel@st.com>\n \n \t* config/arm/arm_neon.h: Remove #ifndef check on __ARM_NEON."}, {"sha": "6173daed0c43a75ee76ed8c32e1ecbcaf3071aa5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16c6f54ffa4bcb6321f998723d2ef1da73b44499/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16c6f54ffa4bcb6321f998723d2ef1da73b44499/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=16c6f54ffa4bcb6321f998723d2ef1da73b44499", "patch": "@@ -12139,10 +12139,10 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n   rtx size_rtx = GEN_INT (size), last;\n \n   /* See if we have a constant small number of probes to generate.  If so,\n-     that's the easy case.  The run-time loop is made up of 11 insns in the\n+     that's the easy case.  The run-time loop is made up of 9 insns in the\n      generic case while the compile-time loop is made up of 3+2*(n-1) insns\n      for n # of intervals.  */\n-  if (size <= 5 * PROBE_INTERVAL)\n+  if (size <= 4 * PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT i, adjust;\n       bool first_probe = true;\n@@ -12209,19 +12209,27 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \t\t\t\t\t     - (PROBE_INTERVAL + dope))));\n \n       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */\n-      emit_move_insn (sr.reg, GEN_INT (-rounded_size));\n-      emit_insn (gen_rtx_SET (sr.reg,\n-\t\t\t      gen_rtx_PLUS (Pmode, sr.reg,\n-\t\t\t\t\t    stack_pointer_rtx)));\n+      if (rounded_size <= (HOST_WIDE_INT_1 << 31))\n+\temit_insn (gen_rtx_SET (sr.reg,\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t       -rounded_size)));\n+      else\n+\t{\n+\t  emit_move_insn (sr.reg, GEN_INT (-rounded_size));\n+\t  emit_insn (gen_rtx_SET (sr.reg,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, sr.reg,\n+\t\t\t\t\t\tstack_pointer_rtx)));\n+\t}\n \n \n       /* Step 3: the loop\n \n-\t while (SP != LAST_ADDR)\n+\t do\n \t   {\n \t     SP = SP + PROBE_INTERVAL\n \t     probe at SP\n \t   }\n+\t while (SP != LAST_ADDR)\n \n \t adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for\n \t values of N from 1 until it is equal to ROUNDED_SIZE.  */\n@@ -12277,36 +12285,33 @@ const char *\n output_adjust_stack_and_probe (rtx reg)\n {\n   static int labelno = 0;\n-  char loop_lab[32], end_lab[32];\n+  char loop_lab[32];\n   rtx xops[2];\n \n-  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n-  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n \n+  /* Loop.  */\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n \n-  /* Jump to END_LAB if SP == LAST_ADDR.  */\n-  xops[0] = stack_pointer_rtx;\n-  xops[1] = reg;\n-  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n-  fputs (\"\\tje\\t\", asm_out_file);\n-  assemble_name_raw (asm_out_file, end_lab);\n-  fputc ('\\n', asm_out_file);\n-\n   /* SP = SP + PROBE_INTERVAL.  */\n+  xops[0] = stack_pointer_rtx;\n   xops[1] = GEN_INT (PROBE_INTERVAL);\n   output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n \n   /* Probe at SP.  */\n   xops[1] = const0_rtx;\n   output_asm_insn (\"or%z0\\t{%1, (%0)|DWORD PTR [%0], %1}\", xops);\n \n-  fprintf (asm_out_file, \"\\tjmp\\t\");\n+  /* Test if SP == LAST_ADDR.  */\n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = reg;\n+  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n+\n+  /* Branch.  */\n+  fputs (\"\\tjne\\t\", asm_out_file);\n   assemble_name_raw (asm_out_file, loop_lab);\n   fputc ('\\n', asm_out_file);\n \n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n-\n   return \"\";\n }\n \n@@ -12317,10 +12322,10 @@ static void\n ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n {\n   /* See if we have a constant small number of probes to generate.  If so,\n-     that's the easy case.  The run-time loop is made up of 7 insns in the\n+     that's the easy case.  The run-time loop is made up of 6 insns in the\n      generic case while the compile-time loop is made up of n insns for n #\n      of intervals.  */\n-  if (size <= 7 * PROBE_INTERVAL)\n+  if (size <= 6 * PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT i;\n \n@@ -12364,11 +12369,12 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \n       /* Step 3: the loop\n \n-\t while (TEST_ADDR != LAST_ADDR)\n+\t do\n \t   {\n \t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n \t     probe at TEST_ADDR\n \t   }\n+\t while (TEST_ADDR != LAST_ADDR)\n \n          probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n          until it is equal to ROUNDED_SIZE.  */\n@@ -12400,23 +12406,16 @@ const char *\n output_probe_stack_range (rtx reg, rtx end)\n {\n   static int labelno = 0;\n-  char loop_lab[32], end_lab[32];\n+  char loop_lab[32];\n   rtx xops[3];\n \n-  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n-  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n \n+  /* Loop.  */\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n \n-  /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */\n-  xops[0] = reg;\n-  xops[1] = end;\n-  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n-  fputs (\"\\tje\\t\", asm_out_file);\n-  assemble_name_raw (asm_out_file, end_lab);\n-  fputc ('\\n', asm_out_file);\n-\n   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[0] = reg;\n   xops[1] = GEN_INT (PROBE_INTERVAL);\n   output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n \n@@ -12426,12 +12425,16 @@ output_probe_stack_range (rtx reg, rtx end)\n   xops[2] = const0_rtx;\n   output_asm_insn (\"or%z0\\t{%2, (%0,%1)|DWORD PTR [%0+%1], %2}\", xops);\n \n-  fprintf (asm_out_file, \"\\tjmp\\t\");\n+  /* Test if TEST_ADDR == LAST_ADDR.  */\n+  xops[0] = reg;\n+  xops[1] = end;\n+  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n+\n+  /* Branch.  */\n+  fputs (\"\\tjne\\t\", asm_out_file);\n   assemble_name_raw (asm_out_file, loop_lab);\n   fputc ('\\n', asm_out_file);\n \n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n-\n   return \"\";\n }\n "}]}