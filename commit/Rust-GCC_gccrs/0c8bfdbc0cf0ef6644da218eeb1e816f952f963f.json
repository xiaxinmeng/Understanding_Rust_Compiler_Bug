{"sha": "0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM4YmZkYmMwY2YwZWY2NjQ0ZGEyMThlZWIxZTgxNmY5NTJmOTYzZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-01T09:56:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-01T09:56:40Z"}, "message": "* decl2.c (arg_assoc): Handle template-id expressions as arguments.\n\nFrom-SVN: r22156", "tree": {"sha": "4991749b846f4c80e4d6b174c3357b1c436bc8d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4991749b846f4c80e4d6b174c3357b1c436bc8d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/comments", "author": null, "committer": null, "parents": [{"sha": "99d7f99a7feb8aba91a4fdf61c820317fd425b57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d7f99a7feb8aba91a4fdf61c820317fd425b57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d7f99a7feb8aba91a4fdf61c820317fd425b57"}], "stats": {"total": 83, "additions": 79, "deletions": 4}, "files": [{"sha": "37c16b3f6cf6d485334689c9ba476088e26e1521", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "patch": "@@ -1,3 +1,7 @@\n+1998-09-01  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl2.c (arg_assoc): Handle template-id expressions as arguments.\n+\n 1998-08-31  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl.c (finish_enum): Handle member enums of classes declared in"}, {"sha": "7d54deca6f6534b49934fcb85bfe9c61344211a1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "patch": "@@ -4583,11 +4583,71 @@ arg_assoc (k, n)\n   while (TREE_CODE (n) == TREE_LIST)\n     n = TREE_VALUE (n);\n \n-  my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n+  if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n+    {\n+      /* [basic.lookup.koenig]\n+\n+\t If T is a template-id, its associated namespaces and classes\n+\t are the namespace in which the template is defined; for\n+\t member templates, the member template's class; the namespaces\n+\t and classes associated with the types of the template\n+\t arguments provided for template type parameters (excluding\n+\t template template parameters); the namespaces in which any\n+\t template template arguments are defined; and the classes in\n+\t which any member templates used as template template\n+\t arguments are defined.  [Note: non-type template arguments do\n+\t not contribute to the set of associated namespaces.  ]   */\n+      tree template = TREE_OPERAND (n, 0);\n+      tree args = TREE_OPERAND (n, 1);\n+      tree ctx;\n+      tree arg;\n+\n+      /* First, the template.  There may actually be more than one if\n+\t this is an overloaded function template.  But, in that case,\n+\t we only need the first; all the functions will be in the same\n+\t namespace.  */\n+      template = OVL_CURRENT (template);\n+\n+      ctx = CP_DECL_CONTEXT (template);\n+       \n+      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t{\n+\t  if (arg_assoc_namespace (k, ctx) == 1)\n+\t    return 1;\n+\t}\n+      /* It must be a member template.  */\n+      else if (arg_assoc_class (k, ctx) == 1)\n+\treturn 1;\n \n-  for (; n; n = TREE_CHAIN (n))\n-    if (arg_assoc (k, OVL_FUNCTION (n)))\n-      return 1;\n+      /* Now the arguments.  */\n+      for (arg = args; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+\t{\n+\t  tree t = TREE_VALUE (arg);\n+\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    {\n+\t      ctx = CP_DECL_CONTEXT (t);\n+\t      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t\t{\n+\t\t  if (arg_assoc_namespace (k, ctx) == 1)\n+\t\t    return 1;\n+\t\t}\n+\t      else if (arg_assoc_class (k, ctx) == 1)\n+\t\treturn 1;\n+\t    }\n+\t  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n+\t\t   && arg_assoc_type (t) == 1)\n+\t    return 1;\n+\t}\n+    }\n+  else\n+    {\n+      my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n+      \n+      for (; n; n = OVL_CHAIN (n))\n+\tif (arg_assoc (k, OVL_FUNCTION (n)))\n+\t  return 1;\n+    }\n \n   return 0;\n }"}, {"sha": "442ab59830c529ada78b414518f16b8f927f2d91", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash24.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c8bfdbc0cf0ef6644da218eeb1e816f952f963f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash24.C?ref=0c8bfdbc0cf0ef6644da218eeb1e816f952f963f", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+template<typename T, template <class> class U> void template_fn (T);\n+template<typename T, typename U> void callme ( void (*)(T));\n+\n+template<typename T> struct S1;\n+\n+int main()\n+{\n+  callme( template_fn<double, S1>); // ERROR - no matching function\n+}"}]}