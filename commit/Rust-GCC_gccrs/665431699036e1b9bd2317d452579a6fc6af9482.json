{"sha": "665431699036e1b9bd2317d452579a6fc6af9482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1NDMxNjk5MDM2ZTFiOWJkMjMxN2Q0NTI1NzlhNmZjNmFmOTQ4Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-02-26T23:37:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-02-26T23:37:04Z"}, "message": "typeck.c (complete_type_or_else): Add VALUE arg, for helpful diagnostics.\n\n\t* typeck.c (complete_type_or_else): Add VALUE arg, for helpful\n\tdiagnostics.\n\tcp-tree.h (complete_type_or_else): Added VALUE parameter.\n\t* init.c (build_new_1): Extra arg to complete_type_or_else.\n\t(build_delete): Likewise.\n\t* typeck.c (require_complete_type): Likewise.\n\t(pointer_int_sum): Likewise.\n\t(pointer_diff): Likewise.\n\t(build_component_ref): Likewise.\n\t* typeck2.c (incomplete_type_error): Always use cp_error.\n\tShow declaration of undefined type, if appropriate.\n\tDeal with UNKNOWN_TYPE nodes.\n\t* typeck.c (require_complete_type): Use TYPE_SIZE as\n\tsize_zero_node to mean incomplete type.\n\t(require_complete_type_in_void): New function.\n\t(build_compound_expr): Call complete_type_in_void for LHS.\n\t(build_c_cast): Call complete_type_in_void for void cast.\n\t* cvt.c (ocp_convert): Call complete_type_in_void for void cast.\n\t* decl.c (cplus_expand_expr_stmt): Void expression checks moved to\n\trequire_complete_type_in_void. Call it.\n\t* cp-tree.h (require_complete_type_in_void): Prototype new function.\n\t* typeck.c (convert_arguments): Use alternative format for function\n\tdecls. Don't require_complete_type here. Simplify diagnostic printing.\n\t(convert_for_initialization): Don't require_complete_type on RHS yet.\n\t* call.c (convert_arg_to_ellipsis): Call require_complete_type.\n\t* call.c (build_over_call): Cope with qualified void return type.\n\t* semantics.c (finish_call_expr): Likewise\n\t* typeck.c (build_function_call_real): Likewise\n\t(c_expand_return): Likewise\n\t* decl2.c (reparse_absdcl_as_expr): Cope with qualified void type.\n\t* call.c (print_z_candidates): Use alternate print format, to be\n\tconsistant with (pt.c) print_candidates.\n\tmethod.c (hack_identifier): List candidate members.\n\tsearch.c (lookup_field): Build ambiguous list, and show it, if\n\tambiguous.\n\nFrom-SVN: r25474", "tree": {"sha": "95146880bbae3e437264ebcc433d39108ea8419e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95146880bbae3e437264ebcc433d39108ea8419e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/665431699036e1b9bd2317d452579a6fc6af9482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665431699036e1b9bd2317d452579a6fc6af9482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/665431699036e1b9bd2317d452579a6fc6af9482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665431699036e1b9bd2317d452579a6fc6af9482/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99f25d8ea84021f7c7887a65085342760abd0c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99f25d8ea84021f7c7887a65085342760abd0c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99f25d8ea84021f7c7887a65085342760abd0c5a"}], "stats": {"total": 380, "additions": 272, "deletions": 108}, "files": [{"sha": "8e82f27c5c3346a95188981522fe0b6e70f905d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -1,3 +1,46 @@\n+1999-02-26  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* typeck.c (complete_type_or_else): Add VALUE arg, for helpful\n+\tdiagnostics.\n+\tcp-tree.h (complete_type_or_else): Added VALUE parameter.\n+\t* init.c (build_new_1): Extra arg to complete_type_or_else.\n+\t(build_delete): Likewise.\n+\t* typeck.c (require_complete_type): Likewise.\n+\t(pointer_int_sum): Likewise.\n+\t(pointer_diff): Likewise.\n+\t(build_component_ref): Likewise.\n+\t\n+\t* typeck2.c (incomplete_type_error): Always use cp_error.\n+\tShow declaration of undefined type, if appropriate.\n+\tDeal with UNKNOWN_TYPE nodes.\n+\t\n+\t* typeck.c (require_complete_type): Use TYPE_SIZE as\n+\tsize_zero_node to mean incomplete type.\n+\t(require_complete_type_in_void): New function.\n+\t(build_compound_expr): Call complete_type_in_void for LHS.\n+\t(build_c_cast): Call complete_type_in_void for void cast.\n+\t* cvt.c (ocp_convert): Call complete_type_in_void for void cast.\n+\t* decl.c (cplus_expand_expr_stmt): Void expression checks moved to\n+\trequire_complete_type_in_void. Call it.\n+\t* cp-tree.h (require_complete_type_in_void): Prototype new function.\n+\n+\t* typeck.c (convert_arguments): Use alternative format for function \n+\tdecls. Don't require_complete_type here. Simplify diagnostic printing.\n+\t(convert_for_initialization): Don't require_complete_type on RHS yet.\n+\t* call.c (convert_arg_to_ellipsis): Call require_complete_type.\n+\t\n+\t* call.c (build_over_call): Cope with qualified void return type.\n+\t* semantics.c (finish_call_expr): Likewise\n+\t* typeck.c (build_function_call_real): Likewise\n+\t(c_expand_return): Likewise\n+\t* decl2.c (reparse_absdcl_as_expr): Cope with qualified void type.\n+\t\n+\t* call.c (print_z_candidates): Use alternate print format, to be\n+\tconsistant with (pt.c) print_candidates.\n+\tmethod.c (hack_identifier): List candidate members.\n+\tsearch.c (lookup_field): Build ambiguous list, and show it, if\n+\tambiguous.\n+\n 1999-02-26  Mark Mitchell  <mark@markmitchell.com>\n \n \t* typeck.c (decay_conversion): Don't confuse constant array"}, {"sha": "9bf503551865c449887f7de0a4b7cee92280794e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -2078,7 +2078,7 @@ print_z_candidates (candidates)\n       else if (TYPE_P (candidates->fn))\n \tcp_error (\"%s %T <conversion>\", str, candidates->fn);\n       else\n-\tcp_error_at (\"%s %+D%s\", str, candidates->fn,\n+\tcp_error_at (\"%s %+#D%s\", str, candidates->fn,\n \t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n       str = \"               \"; \n     }\n@@ -3175,6 +3175,8 @@ convert_arg_to_ellipsis (arg)\n     /* Convert `short' and `char' to full-size `int'.  */\n     arg = default_conversion (arg);\n \n+  arg = require_complete_type (arg);\n+  \n   return arg;\n }\n \n@@ -3515,7 +3517,7 @@ build_over_call (cand, args, flags)\n       }\n \n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n-  if (TREE_TYPE (fn) == void_type_node)\n+  if (TREE_CODE (TREE_TYPE (fn)) == VOID_TYPE)\n     return fn;\n   fn = require_complete_type (fn);\n   if (IS_AGGR_TYPE (TREE_TYPE (fn)))"}, {"sha": "c533e3e048436c39781eb17adeacae51c9ead602", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -4888,8 +4888,6 @@ push_nested_class (type, modify)\n {\n   tree context;\n \n-  my_friendly_assert (!type || TREE_CODE (type) != NAMESPACE_DECL, 980711);\n-\n   /* A namespace might be passed in error cases, like A::B:C.  */\n   if (type == NULL_TREE || type == error_mark_node || ! IS_AGGR_TYPE (type)\n       || TREE_CODE (type) == NAMESPACE_DECL"}, {"sha": "59a067efeb74aeb91e4551cfce99c505cdfee0c5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -3324,8 +3324,9 @@ extern int string_conv_p\t\t\tPROTO((tree, tree, int));\n extern tree condition_conversion\t\tPROTO((tree));\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n+extern tree require_complete_type_in_void\tPROTO((tree));\n extern tree complete_type\t\t\tPROTO((tree));\n-extern tree complete_type_or_else               PROTO((tree));\n+extern tree complete_type_or_else               PROTO((tree, tree));\n extern int type_unknown_p\t\t\tPROTO((tree));\n extern int fntype_p\t\t\t\tPROTO((tree));\n extern tree commonparms\t\t\t\tPROTO((tree, tree));"}, {"sha": "9f29c6586975be28a6e3480818bc6783c0ef3a42", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -687,10 +687,11 @@ ocp_convert (type, expr, convtype, flags)\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     {\n-      if (type_unknown_p (e))\n-\terror (\"address of overloaded function with no contextual type information\");\n+      e = require_complete_type_in_void (e);\n+      if (e != error_mark_node)\n+        e = build1 (CONVERT_EXPR, void_type_node, e);\n \n-      return build1 (CONVERT_EXPR, type, e);\n+      return e;\n     }\n \n #if 0"}, {"sha": "231a598c55a4b3ef115cf88d4393cfe26d83d9eb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -14380,38 +14380,30 @@ cplus_expand_expr_stmt (exp)\n   /* Arrange for all temps to disappear.  */\n   expand_start_target_temps ();\n \n-  if (TREE_TYPE (exp) == unknown_type_node)\n+  exp = require_complete_type_in_void (exp);\n+  \n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n     {\n-      if (TREE_CODE (exp) == COMPONENT_REF)\n-\terror (\"invalid reference to a member function name, did you forget the ()?\");\n-      else\n-\terror (\"address of overloaded function with no contextual type information\");\n+      cp_warning (\"reference, not call, to function `%D'\", exp);\n+      warning (\"at this point in file\");\n     }\n-  else\n-    {\n-      if (TREE_CODE (exp) == FUNCTION_DECL)\n-\t{\n-\t  cp_warning (\"reference, not call, to function `%D'\", exp);\n-\t  warning (\"at this point in file\");\n-\t}\n \n #if 0\n-      /* We should do this eventually, but right now this causes regex.o from\n-\t libg++ to miscompile, and tString to core dump.  */\n-      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n+  /* We should do this eventually, but right now this causes regex.o from\n+     libg++ to miscompile, and tString to core dump.  */\n+  exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n #endif\n \n-      /* Strip unused implicit INDIRECT_REFs of references.  */\n-      if (TREE_CODE (exp) == INDIRECT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n-\texp = TREE_OPERAND (exp, 0);\n+  /* Strip unused implicit INDIRECT_REFs of references.  */\n+  if (TREE_CODE (exp) == INDIRECT_REF\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n+    exp = TREE_OPERAND (exp, 0);\n \n-      /* If we don't do this, we end up down inside expand_expr\n-\t trying to do TYPE_MODE on the ERROR_MARK, and really\n-\t go outside the bounds of the type.  */\n-      if (exp != error_mark_node)\n-\texpand_expr_stmt (break_out_cleanups (exp));\n-    }\n+  /* If we don't do this, we end up down inside expand_expr\n+     trying to do TYPE_MODE on the ERROR_MARK, and really\n+     go outside the bounds of the type.  */\n+  if (exp != error_mark_node)\n+    expand_expr_stmt (break_out_cleanups (exp));\n \n   /* Clean up any pending cleanups.  This happens when a function call\n      returns a cleanup-needing value that nobody uses.  */"}, {"sha": "d53dc70cf3004f4491c4bb582835fefde7f82722", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -3506,7 +3506,9 @@ reparse_absdcl_as_expr (type, decl)\n \n   decl = build_x_function_call (decl, NULL_TREE, current_class_ref);\n \n-  if (TREE_CODE (decl) == CALL_EXPR && TREE_TYPE (decl) != void_type_node)\n+  if (TREE_CODE (decl) == CALL_EXPR\n+      && (! TREE_TYPE (decl)\n+          || TREE_CODE (TREE_TYPE (decl)) != VOID_TYPE))\n     decl = require_complete_type (decl);\n \n   return decl;"}, {"sha": "ea424b617801f1d81428368dd45bea745e4fdb8c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -2163,7 +2163,7 @@ build_new_1 (exp)\n       true_type = TREE_TYPE (true_type);\n     }\n \n-  if (!complete_type_or_else (true_type))\n+  if (!complete_type_or_else (true_type, exp))\n     return error_mark_node;\n \n   if (has_array)\n@@ -3014,7 +3014,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      if (!complete_type_or_else (type))\n+      if (type != void_type_node && !complete_type_or_else (type, addr))\n \treturn error_mark_node;\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \tgoto handle_array;"}, {"sha": "85463321899ed6398d6bbbc3778dbafe599865f7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -2023,6 +2023,7 @@ hack_identifier (value, name)\n     {\n       error (\"request for member `%s' is ambiguous in multiple inheritance lattice\",\n \t     IDENTIFIER_POINTER (name));\n+      print_candidates (value);\n       return error_mark_node;\n     }\n "}, {"sha": "3b88c400197b688fbdf84cb99172f2c8810768e8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -870,6 +870,7 @@ lookup_field (xbasetype, name, protect, want_type)\n   tree entry, binfo, binfo_h;\n   tree own_access = access_default_node;\n   int vbase_name_p = VBASE_NAME_P (name);\n+  tree ambiguous = NULL_TREE;\n \n   /* rval_binfo is the binfo associated with the found member, note,\n      this can be set with useful information, even when rval is not\n@@ -986,6 +987,7 @@ lookup_field (xbasetype, name, protect, want_type)\n       tree binfos = BINFO_BASETYPES (binfo);\n       int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n       tree nval;\n+      int idx = -1;\n \n       /* Process and/or queue base types.  */\n       for (i = 0; i < n_baselinks; i++)\n@@ -1040,7 +1042,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n       nval = lookup_field_1 (type, name);\n \n-      if (nval || lookup_fnfields_here (type, name)>=0)\n+      if (nval || (idx = lookup_fnfields_here (type, name)) >= 0)\n \t{\n \t  if (nval && nval == rval && SHARED_MEMBER_P (nval))\n \t    {\n@@ -1074,10 +1076,20 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    }\n \t  else\n \t    {\n-\t      /* This is ambiguous.  */\n-\t      errstr = \"request for member `%D' is ambiguous\";\n-\t      protect += 2;\n-\t      break;\n+\t      /* This is ambiguous. Remember it. */\n+\t      if (! ambiguous)\n+\t        {\n+\t          errstr = \"request for member `%D' is ambiguous\";\n+\t          protect += 2;\n+\t          if (rval)\n+\t            ambiguous = scratch_tree_cons (NULL_TREE, rval, ambiguous);\n+\t        }\n+\t      if (! nval)\n+\t        {\n+\t          nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n+\t          nval = OVL_CURRENT (nval);\n+\t        }\n+              ambiguous = scratch_tree_cons (NULL_TREE, nval, ambiguous);\n \t    }\n \t}\n     }\n@@ -1176,6 +1188,8 @@ lookup_field (xbasetype, name, protect, want_type)\n   if (errstr && protect)\n     {\n       cp_error (errstr, name, type);\n+      if (ambiguous)\n+        print_candidates (ambiguous);\n       rval = error_mark_node;\n     }\n "}, {"sha": "076197a70c8f75d6745c0f06294e814dbe8a0488", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -855,7 +855,8 @@ finish_call_expr (fn, args, koenig)\n   result = build_x_function_call (fn, args, current_class_ref);\n \n   if (TREE_CODE (result) == CALL_EXPR\n-      && TREE_TYPE (result) != void_type_node)\n+      && (! TREE_TYPE (result)\n+          || TREE_CODE (TREE_TYPE (result)) != VOID_TYPE))\n     result = require_complete_type (result);\n \n   return result;"}, {"sha": "463fcd4abc4dcace21a5c293d72071c98e627c7a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 129, "deletions": 27, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -90,7 +90,7 @@ require_complete_type (value)\n {\n   tree type;\n \n-  if (processing_template_decl)\n+  if (processing_template_decl || value == error_mark_node)\n     return value;\n \n   if (TREE_CODE (value) == OVERLOAD)\n@@ -100,7 +100,7 @@ require_complete_type (value)\n \n   /* First, detect a valid value with a complete type.  */\n   if (TYPE_SIZE (type) != 0\n-      && type != void_type_node\n+      && TYPE_SIZE (type) != size_zero_node\n       && ! (TYPE_LANG_SPECIFIC (type)\n \t    && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))\n \t    && TYPE_SIZE (SIGNATURE_TYPE (type)) == 0))\n@@ -122,12 +122,105 @@ require_complete_type (value)\n       return require_complete_type (value);\n     }\n \n-  if (complete_type_or_else (type))\n+  if (complete_type_or_else (type, value))\n     return value;\n   else\n     return error_mark_node;\n }\n \n+/* Makes sure EXPR is a complete type when used in a void context, like a\n+   whole expression, or lhs of a comma operator. Issue a diagnostic and\n+   return error_mark_node on failure. This is a little tricky, because some\n+   valid void types look stunningly similar to invalid void types. We err on\n+   the side of caution */\n+\n+tree\n+require_complete_type_in_void (expr)\n+     tree expr;\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    case COND_EXPR:\n+      {\n+        tree op;\n+        \n+        op = TREE_OPERAND (expr,2);\n+        op = require_complete_type_in_void (op);\n+        TREE_OPERAND (expr,2) = op;\n+        if (op == error_mark_node)\n+          {\n+            expr = op;\n+            break;\n+          }\n+        \n+        /* fallthrough */\n+      }\n+    \n+    case COMPOUND_EXPR:\n+      {\n+        tree op;\n+        \n+        op = TREE_OPERAND (expr,1);\n+        op = require_complete_type_in_void (op);\n+        TREE_OPERAND (expr,1) = op;\n+        if (op == error_mark_node)\n+          {\n+            expr = op;\n+            break;\n+          }\n+        \n+        break;\n+      }\n+    \n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      {\n+        tree op;\n+        \n+        op = TREE_OPERAND (expr,0);\n+        op = require_complete_type_in_void (op);\n+        TREE_OPERAND (expr,0) = op;\n+        if (op == error_mark_node)\n+          {\n+            expr = op;\n+            break;\n+          }\n+        break;\n+      }\n+    \n+    case CALL_EXPR:   /* function call return can be ignored */\n+    case RTL_EXPR:    /* RTL nodes have no value */\n+    case DELETE_EXPR: /* delete expressions have no type */\n+    case VEC_DELETE_EXPR:\n+    case INTEGER_CST: /* used for null pointer */\n+    case EXIT_EXPR:   /* have no return */\n+    case LOOP_EXPR:   /* have no return */\n+    case BIND_EXPR:   /* have no return */\n+    case THROW_EXPR:  /* have no return */\n+    case MODIFY_EXPR: /* sometimes this has a void type, but that's ok */\n+    case CONVERT_EXPR:  /* sometimes has a void type */\n+      break;\n+    \n+    case INDIRECT_REF:\n+      {\n+        tree op = TREE_OPERAND (expr,0);\n+        \n+        /* Calling a function returning a reference has an implicit\n+           dereference applied. We don't want to make that an error. */\n+        if (TREE_CODE (op) == CALL_EXPR\n+            && TREE_CODE (TREE_TYPE (op)) == REFERENCE_TYPE)\n+          break;\n+        /* else fallthrough */\n+      }\n+    \n+    default:\n+      expr = require_complete_type (expr);\n+      break;\n+    }\n+\n+  return expr;\n+}\n+\n /* Try to complete TYPE, if it is incomplete.  For example, if TYPE is\n    a template instantiation, do the instantiation.  Returns TYPE,\n    whether or not it could be completed, unless something goes\n@@ -161,20 +254,21 @@ complete_type (type)\n }\n \n /* Like complete_type, but issue an error if the TYPE cannot be\n-   completed.  Returns NULL_TREE if the type cannot be made \n-   complete.  */\n+   completed.  VALUE is used for informative diagnostics.\n+   Returns NULL_TREE if the type cannot be made complete.  */\n \n tree\n-complete_type_or_else (type)\n+complete_type_or_else (type, value)\n      tree type;\n+     tree value;\n {\n   type = complete_type (type);\n   if (type == error_mark_node)\n     /* We already issued an error.  */\n     return NULL_TREE;\n-  else if (!TYPE_SIZE (type))\n+  else if (!TYPE_SIZE (type) || TYPE_SIZE (type) == size_zero_node)\n     {\n-      incomplete_type_error (NULL_TREE, type);\n+      incomplete_type_error (value, type);\n       return NULL_TREE;\n     }\n   else\n@@ -1997,7 +2091,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       return error_mark_node;\n     }\n \n-  if (!complete_type_or_else (basetype))\n+  if (!complete_type_or_else (basetype, datum))\n     return error_mark_node;\n \n   if (TREE_CODE (component) == BIT_NOT_EXPR)\n@@ -2928,7 +3022,7 @@ build_function_call_real (function, params, require_complete, flags)\n \n     if (require_complete)\n       {\n-\tif (value_type == void_type_node)\n+\tif (TREE_CODE (value_type) == VOID_TYPE)\n \t  return result;\n \tresult = require_complete_type (result);\n       }\n@@ -3003,7 +3097,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (\"too many arguments to %s `%+D'\", called_thing,\n+\t      cp_error_at (\"too many arguments to %s `%+#D'\", called_thing,\n \t\t\t   fndecl);\n \t      error (\"at this point in file\");\n \t    }\n@@ -3032,8 +3126,6 @@ convert_arguments (typelist, values, fndecl, flags)\n \t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n \t    val = default_conversion (val);\n-\n-\t  val = require_complete_type (val);\n \t}\n \n       if (val == error_mark_node)\n@@ -3108,9 +3200,8 @@ convert_arguments (typelist, values, fndecl, flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      char *buf = (char *)alloca (32 + strlen (called_thing));\n-\t      sprintf (buf, \"too few arguments to %s `%%#D'\", called_thing);\n-\t      cp_error_at (buf, fndecl);\n+\t      cp_error_at (\"too few arguments to %s `%+#D'\",\n+\t                   called_thing, fndecl);\n \t      error (\"at this point in file\");\n \t    }\n \t  else\n@@ -3990,7 +4081,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n   register tree result_type = TREE_TYPE (ptrop);\n \n-  if (!complete_type_or_else (result_type))\n+  if (!complete_type_or_else (result_type, ptrop))\n     return error_mark_node;\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n@@ -4082,7 +4173,7 @@ pointer_diff (op0, op1, ptrtype)\n   tree restype = ptrdiff_type_node;\n   tree target_type = TREE_TYPE (ptrtype);\n \n-  if (!complete_type_or_else (target_type))\n+  if (!complete_type_or_else (target_type, NULL_TREE))\n     return error_mark_node;\n \n   if (pedantic || warn_pointer_arith)\n@@ -5272,6 +5363,7 @@ build_compound_expr (list)\n      tree list;\n {\n   register tree rest;\n+  tree first;\n \n   if (TREE_READONLY_DECL_P (TREE_VALUE (list)))\n     TREE_VALUE (list) = decl_constant_value (TREE_VALUE (list));\n@@ -5291,14 +5383,21 @@ build_compound_expr (list)\n \treturn TREE_VALUE (list);\n     }\n \n+  first = TREE_VALUE (list);\n+  first = require_complete_type_in_void (first);\n+  if (first == error_mark_node)\n+    return error_mark_node;\n+  \n   rest = build_compound_expr (TREE_CHAIN (list));\n+  if (rest == error_mark_node)\n+    return error_mark_node;\n \n   /* When pedantic, a compound expression cannot be a constant expression.  */\n-  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)) && ! pedantic)\n+  if (! TREE_SIDE_EFFECTS (first) && ! pedantic)\n     return rest;\n \n   return build (COMPOUND_EXPR, TREE_TYPE (rest),\n-\t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n+\t\tbreak_out_cleanups (first), rest);\n }\n \n tree\n@@ -5670,7 +5769,13 @@ build_c_cast (type, expr)\n     warning (\"cast to pointer from integer of different size\");\n #endif\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TREE_CODE (type) == VOID_TYPE)\n+    {\n+      value = require_complete_type_in_void (value);\n+      if (value != error_mark_node)\n+        value = build1 (CONVERT_EXPR, void_type_node, value);\n+    }\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n     value = (convert_from_reference\n \t     (convert_to_reference (type, value, CONV_C_CAST,\n \t\t\t\t    LOOKUP_COMPLAIN, NULL_TREE)));\n@@ -6954,11 +7059,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       return rhs;\n     }      \n \n-  rhs = require_complete_type (rhs);\n-  if (rhs == error_mark_node)\n-    return error_mark_node;\n-\n-  if (exp != 0) exp = require_complete_type (exp);\n+  if (exp != 0)\n+    exp = require_complete_type (exp);\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n@@ -7158,7 +7260,7 @@ c_expand_return (retval)\n   if (retval == result\n       || DECL_CONSTRUCTOR_P (current_function_decl))\n     /* It's already done for us.  */;\n-  else if (TREE_TYPE (retval) == void_type_node)\n+  else if (TREE_CODE (TREE_TYPE (retval)) == VOID_TYPE)\n     {\n       pedwarn (\"return of void value in function returning non-void\");\n       expand_expr_stmt (retval);"}, {"sha": "f002bc06c754605d8d99fb2966a04a6a79e57aa4", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665431699036e1b9bd2317d452579a6fc6af9482/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=665431699036e1b9bd2317d452579a6fc6af9482", "patch": "@@ -1,6 +1,6 @@\n /* Report error messages, build initializers, and perform\n    some front-end optimizations for C++ compiler.\n-   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -213,55 +213,62 @@ incomplete_type_error (value, type)\n      tree value;\n      tree type;\n {\n-  char *errmsg = 0;\n-\n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n-  if (value != 0 && (TREE_CODE (value) == VAR_DECL\n-\t\t     || TREE_CODE (value) == PARM_DECL))\n-    cp_error (\"`%D' has incomplete type\", value);\n-  else\n-    {\n-    retry:\n-      /* We must print an error message.  Be clever about what it says.  */\n-\n-      switch (TREE_CODE (type))\n-\t{\n-\tcase RECORD_TYPE:\n-\tcase UNION_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\t  errmsg = \"invalid use of undefined type `%#T'\";\n-\t  break;\n+retry:\n+  /* We must print an error message.  Be clever about what it says.  */\n \n-\tcase VOID_TYPE:\n-\t  error (\"invalid use of void expression\");\n-\t  return;\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      cp_error (\"invalid use of undefined type `%#T'\", type);\n+      cp_error_at (\"forward declaration of `%#T'\", type);\n+      break;\n \n-\tcase ARRAY_TYPE:\n-\t  if (TYPE_DOMAIN (type))\n-\t    {\n-\t      type = TREE_TYPE (type);\n-\t      goto retry;\n-\t    }\n-\t  error (\"invalid use of array with unspecified bounds\");\n-\t  return;\n+    case VOID_TYPE:\n+      cp_error (\"invalid use of void expression\");\n+      break;\n \n-\tcase OFFSET_TYPE:\n-\t  error (\"invalid use of member type (did you forget the `&' ?)\");\n-\t  return;\n+    case ARRAY_TYPE:\n+      if (TYPE_DOMAIN (type))\n+        {\n+          type = TREE_TYPE (type);\n+          goto retry;\n+        }\n+      cp_error (\"invalid use of array with unspecified bounds\");\n+      break;\n \n-\tcase TEMPLATE_TYPE_PARM:\n-\t  error (\"invalid use of template type parameter\");\n-\t  return;\n+    case OFFSET_TYPE:\n+    bad_member:\n+      cp_error (\"invalid use of member (did you forget the `&' ?)\");\n+      break;\n \n-\tdefault:\n-\t  my_friendly_abort (108);\n-\t}\n+    case TEMPLATE_TYPE_PARM:\n+      cp_error (\"invalid use of template type parameter\");\n+      break;\n \n-      cp_error (errmsg, type);\n+    case UNKNOWN_TYPE:\n+      if (value && TREE_CODE (value) == COMPONENT_REF)\n+        goto bad_member;\n+      else if (value && TREE_CODE (value) == ADDR_EXPR)\n+        cp_error (\"address of overloaded function with no contextual type information\");\n+      else if (value && TREE_CODE (value) == OVERLOAD)\n+        cp_error (\"overloaded function with no contextual type information\");\n+      else\n+        cp_error (\"insufficient contextual information to determine type\");\n+      break;\n+    \n+    default:\n+      my_friendly_abort (108);\n     }\n+\n+  if (value != 0 && (TREE_CODE (value) == VAR_DECL\n+\t\t     || TREE_CODE (value) == PARM_DECL))\n+    cp_error_at (\"incomplete `%D' defined here\", value);\n }\n \n /* Like error(), but don't call report_error_function().  */"}]}