{"sha": "38173d38cc4d944f209f1b2e0101fb176ac21e84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxNzNkMzhjYzRkOTQ0ZjIwOWYxYjJlMDEwMWZiMTc2YWMyMWU4NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-04-08T08:59:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-04-08T08:59:34Z"}, "message": "function.h (incomming_args): Break out of struct function.\n\n\n\t* function.h (incomming_args): Break out of struct function.\n\t(function_subsections): Break out of struct function.\n\t(rtl_data): Add args, subsections fields. Break out outgoing_args_size,\n\treturn_rtx and hard_reg_initial_vals from struct function.\n\tKill inl_max_label_num.\n\t(current_function_pops_args, current_function_args_info,\n\tcurrent_function_args_size, current_function_args_size,\n\tcurrent_function_pretend_args_size,\n\tcurrent_function_outgoing_args_size,\n\tcurrent_function_internal_arg_pointer, current_function_return_rtx):\n\tKill compatibility accestor macros.\n\t* builtins.c (expand_builtin_apply_args_1): Update.\n\t(expand_builtin_next_arg): Update.\n\t* df-scan.c (df_get_call_refs): Update.\n\t* dbxout.c (dbxout_function_end): Update.\n\t* dwarf2out.c (dwarf2out_switch_text_section): Update.\n\t(output_line_info): Update.\n\t(secname_for_decl): Update.\n\t(dwarf2out_var_location): Update.\n\t* function.c (free_after_compilation): Update.\n\t(assign_parm_find_stack_rtl): Update.\n\t(assign_parms): Update.\n\t(expand_dummy_function_end): Update.\n\t(expand_function_end): Update.\n\t* calls.c (mem_overlaps_already_clobbered_arg_p): Update.\n\t(expand_call): Update.\n\t(emit_library_call_value_1): Update.\n\t(store_one_arg): Update.\n\t* varasm.c (initialize_cold_section_name): Update.\n\t(unlikely_text_section): Update.\n\t(unlikely_text_section_p): Update.\n\t(assemble_start_function): Update.\n\t(assemble_end_function): Update.\n\t(default_section_type_flags): Update.\n\t(switch_to_section): Update.\n\t* integrate.c (set_decl_abstract_flags): Update.\n\t(get_hard_reg_initial_val): Update.\n\t(has_hard_reg_initial_val): Update.\n\t(allocate_initial_values): Update.\n\t* resource.c (init_resource_info): Update.\n\t* config/alpha/alpha.c (NUM_ARGS): Update.\n\t(direct_return): Update.\n\t(alpha_va_start): Update.\n\t(alpha_sa_size): Update.\n\t(alpha_initial_elimination_offset): Update.\n\t(alpha_expand_prologue): Update.\n\t(alpha_start_function): Update.\n\t(alpha_expand_epilogue): Update.\n\t(unicosmk_initial_elimination_offset):\n\t* config/alpha/alpha.md (call expander): Update.\n\t* config/s390/s390.c (s390_register_info): Update.\n\t(s390_register_info): Update.\n\t(s390_frame_info): Update.\n\t(s390_initial_elimination_offset): Update.\n\t(s390_build_builtin_va_list): Update.\n\t(s390_va_start): Update.\n\t* config/spu/spu.c (direct_return): Update.\n\t(spu_expand_prologue): Update.\n\t(spu_initial_elimination_offset): Update.\n\t(spu_build_builtin_va_list): Update.\n\t(spu_va_start): Update.\n\t* config/sparc/sparc.c (sparc_init_modes): Update.\n\t(sparc_compute_frame_size): Update.\n\t(function_value): Update.\n\t* config/m32r/m32r.c (m32r_compute_frame_size): Update.\n\t* config/i386/i386.md (return expander): Update.\n\t* config/i386/i386.c (ix86_va_start): Update.\n\t(ix86_can_use_return_insn_p): Update.\n\t(ix86_compute_frame_layout): Update.\n\t(ix86_expand_epilogue): Update.\n\t* config/sh/sh.c (output_stack_adjust): Update.\n\t(calc_live_regs): Update.\n\t(sh_expand_prologue): Update.\n\t(sh_builtin_saveregs): Update.\n\t(sh_va_start): Update.\n\t(initial_elimination_offset): Update.\n\t(sh_allocate_initial_value): Update.\n\t(sh_function_ok_for_sibcall): Update.\n\t(sh_get_pr_initial_val): Update.\n\t* config/sh/sh.md (return expander): Update.\n\t* config/avr/avr.c (frame_pointer_required_p): UPdate.\n\t* config/crx/crx.c (crx_compute_frame): UPdate.\n\t(crx_initial_elimination_offset): UPdate.\n\t* config/xtensa/xtensa.c (compute_frame_size): Update\n\t(xtensa_builtin_saveregs): Update.\n\t(xtensa_va_start): Update.\n\t(order_regs_for_local_alloc): Update.\n\t* config/stormy16/stormy16.c (xstormy16_compute_stack_layout): Update.\n\t(xstormy16_expand_builtin_va_start): Update.\n\t* config/fr30/fr30.c (fr30_compute_frame_size): Update.\n\t* config/m68hc11/m68hc11.md (return expanders): Update.\n\t* config/m68hc11/m68hc11.c (expand_prologue): Update.\n\t(expand_epilogue): Update.\n\t* config/cris/cris.c (cris_initial_frame_pointer_offset): Update.\n\t(cris_simple_epilogue): Update.\n\t(cris_expand_prologue): Update.\n\t(cris_expand_epilogue): Update.\n\t* config/iq2000/iq2000.c (iq2000_va_start): Update.\n\t(compute_frame_size): Update.\n\t* config/mt/mt.c (mt_compute_frame_size): Update.\n\t* config/mn10300/mn10300.c (expand_prologue): Update.\n\t(expand_epilogue): Update.\n\t(initial_offset): Update.\n\t(mn10300_builtin_saveregs):\n\t* config/mn10300/mn10300.md (return expander): Update.\n\t* config/ia64/ia64.c (ia64_compute_frame_size): Update.\n\t(ia64_initial_elimination_offset): Update.\n\t(ia64_initial_elimination_offset): Update.\n\t(ia64_expand_prologue): Update.\n\t* config/m68k/m68k.md (return expander): Update.\n\t* config/rs6000/rs6000.c (rs6000_va_start): Update.\n\t(rs6000_stack_info): Update.\n\t* config/mcore/mcore.c (layout_mcore_frame): Update.\n\t(mcore_expand_prolog): Update.\n\t* config/arc/arc.c (arc_compute_frame_size): Update.\n\t* config/score/score3.c (score3_compute_frame_size): Update.\n\t* config/score/score7.c (score7_compute_frame_size): Update.\n\t* config/arm/arm.c (use_return_insn): Update.\n\t(thumb_find_work_register): Update.\n\t(arm_compute_save_reg_mask): Update.\n\t(arm_output_function_prologue): Update.\n\t(arm_output_epilogue): Update.\n\t(arm_size_return_regs): Update.\n\t(arm_get_frame_offsets): Update.\n\t(arm_expand_prologue): Update.\n\t(thumb_exit): Update.\n\t(thumb_unexpanded_epilogue): Update.\n\t(thumb1_output_function_prologue): Update.\n\t* config/pa/pa.md (return expander): Update.\n\t* config/pa/pa.c (compute_frame_size): Update.\n\t(hppa_builtin_saveregs): Update.\n\t* config/mips/mips.c (mips_va_start): Update.\n\t(mips16_build_function_stub): Update.\n\t(mips_compute_frame_info): Update.\n\t(mips_restore_gp): Update.\n\t(mips_output_function_prologue): Update.\n\t(mips_expand_prologue): Update.\n\t* config/v850/v850.c (compute_frame_size): Update.\n\t(expand_prologue): * config/mmix/mmix.c (along): update.\n\t(mmix_initial_elimination_offset): update.\n\t(mmix_reorg): update.\n\t(mmix_use_simple_return): update.\n\t(mmix_expand_prologue): update.\n\t(mmix_expand_epilogue): Update.\n\t* config/bfin/bfin.c (bfin_initial_elimination_offset): Update.\n\t(emit_link_insn): Update.\n\nFrom-SVN: r134087", "tree": {"sha": "72b27dbbc1af80f97285e66868faf1c622ad35d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b27dbbc1af80f97285e66868faf1c622ad35d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38173d38cc4d944f209f1b2e0101fb176ac21e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38173d38cc4d944f209f1b2e0101fb176ac21e84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38173d38cc4d944f209f1b2e0101fb176ac21e84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38173d38cc4d944f209f1b2e0101fb176ac21e84/comments", "author": null, "committer": null, "parents": [{"sha": "02ba6f3c841d89ddf6d2ab6ce8e54b69ed36bf10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ba6f3c841d89ddf6d2ab6ce8e54b69ed36bf10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ba6f3c841d89ddf6d2ab6ce8e54b69ed36bf10"}], "stats": {"total": 1080, "additions": 614, "deletions": 466}, "files": [{"sha": "076abb30357e2ec210257e9a54f6cb9322466a6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1,3 +1,152 @@\n+2008-04-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* function.h (incomming_args): Break out of struct function.\n+\t(function_subsections): Break out of struct function.\n+\t(rtl_data): Add args, subsections fields. Break out outgoing_args_size,\n+\treturn_rtx and hard_reg_initial_vals from struct function.\n+\tKill inl_max_label_num.\n+\t(current_function_pops_args, current_function_args_info,\n+\tcurrent_function_args_size, current_function_args_size,\n+\tcurrent_function_pretend_args_size,\n+\tcurrent_function_outgoing_args_size,\n+\tcurrent_function_internal_arg_pointer, current_function_return_rtx):\n+\tKill compatibility accestor macros.\n+\t* builtins.c (expand_builtin_apply_args_1): Update.\n+\t(expand_builtin_next_arg): Update.\n+\t* df-scan.c (df_get_call_refs): Update.\n+\t* dbxout.c (dbxout_function_end): Update.\n+\t* dwarf2out.c (dwarf2out_switch_text_section): Update.\n+\t(output_line_info): Update.\n+\t(secname_for_decl): Update.\n+\t(dwarf2out_var_location): Update.\n+\t* function.c (free_after_compilation): Update.\n+\t(assign_parm_find_stack_rtl): Update.\n+\t(assign_parms): Update.\n+\t(expand_dummy_function_end): Update.\n+\t(expand_function_end): Update.\n+\t* calls.c (mem_overlaps_already_clobbered_arg_p): Update.\n+\t(expand_call): Update.\n+\t(emit_library_call_value_1): Update.\n+\t(store_one_arg): Update.\n+\t* varasm.c (initialize_cold_section_name): Update.\n+\t(unlikely_text_section): Update.\n+\t(unlikely_text_section_p): Update.\n+\t(assemble_start_function): Update.\n+\t(assemble_end_function): Update.\n+\t(default_section_type_flags): Update.\n+\t(switch_to_section): Update.\n+\t* integrate.c (set_decl_abstract_flags): Update.\n+\t(get_hard_reg_initial_val): Update.\n+\t(has_hard_reg_initial_val): Update.\n+\t(allocate_initial_values): Update.\n+\t* resource.c (init_resource_info): Update.\n+\t* config/alpha/alpha.c (NUM_ARGS): Update.\n+\t(direct_return): Update.\n+\t(alpha_va_start): Update.\n+\t(alpha_sa_size): Update.\n+\t(alpha_initial_elimination_offset): Update.\n+\t(alpha_expand_prologue): Update.\n+\t(alpha_start_function): Update.\n+\t(alpha_expand_epilogue): Update.\n+\t(unicosmk_initial_elimination_offset):\n+\t* config/alpha/alpha.md (call expander): Update.\n+\t* config/s390/s390.c (s390_register_info): Update.\n+\t(s390_register_info): Update.\n+\t(s390_frame_info): Update.\n+\t(s390_initial_elimination_offset): Update.\n+\t(s390_build_builtin_va_list): Update.\n+\t(s390_va_start): Update.\n+\t* config/spu/spu.c (direct_return): Update.\n+\t(spu_expand_prologue): Update.\n+\t(spu_initial_elimination_offset): Update.\n+\t(spu_build_builtin_va_list): Update.\n+\t(spu_va_start): Update.\n+\t* config/sparc/sparc.c (sparc_init_modes): Update.\n+\t(sparc_compute_frame_size): Update.\n+\t(function_value): Update.\n+\t* config/m32r/m32r.c (m32r_compute_frame_size): Update.\n+\t* config/i386/i386.md (return expander): Update.\n+\t* config/i386/i386.c (ix86_va_start): Update.\n+\t(ix86_can_use_return_insn_p): Update.\n+\t(ix86_compute_frame_layout): Update.\n+\t(ix86_expand_epilogue): Update.\n+\t* config/sh/sh.c (output_stack_adjust): Update.\n+\t(calc_live_regs): Update.\n+\t(sh_expand_prologue): Update.\n+\t(sh_builtin_saveregs): Update.\n+\t(sh_va_start): Update.\n+\t(initial_elimination_offset): Update.\n+\t(sh_allocate_initial_value): Update.\n+\t(sh_function_ok_for_sibcall): Update.\n+\t(sh_get_pr_initial_val): Update.\n+\t* config/sh/sh.md (return expander): Update.\n+\t* config/avr/avr.c (frame_pointer_required_p): UPdate.\n+\t* config/crx/crx.c (crx_compute_frame): UPdate.\n+\t(crx_initial_elimination_offset): UPdate.\n+\t* config/xtensa/xtensa.c (compute_frame_size): Update\n+\t(xtensa_builtin_saveregs): Update.\n+\t(xtensa_va_start): Update.\n+\t(order_regs_for_local_alloc): Update.\n+\t* config/stormy16/stormy16.c (xstormy16_compute_stack_layout): Update.\n+\t(xstormy16_expand_builtin_va_start): Update.\n+\t* config/fr30/fr30.c (fr30_compute_frame_size): Update.\n+\t* config/m68hc11/m68hc11.md (return expanders): Update.\n+\t* config/m68hc11/m68hc11.c (expand_prologue): Update.\n+\t(expand_epilogue): Update.\n+\t* config/cris/cris.c (cris_initial_frame_pointer_offset): Update.\n+\t(cris_simple_epilogue): Update.\n+\t(cris_expand_prologue): Update.\n+\t(cris_expand_epilogue): Update.\n+\t* config/iq2000/iq2000.c (iq2000_va_start): Update.\n+\t(compute_frame_size): Update.\n+\t* config/mt/mt.c (mt_compute_frame_size): Update.\n+\t* config/mn10300/mn10300.c (expand_prologue): Update.\n+\t(expand_epilogue): Update.\n+\t(initial_offset): Update.\n+\t(mn10300_builtin_saveregs):\n+\t* config/mn10300/mn10300.md (return expander): Update.\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Update.\n+\t(ia64_initial_elimination_offset): Update.\n+\t(ia64_initial_elimination_offset): Update.\n+\t(ia64_expand_prologue): Update.\n+\t* config/m68k/m68k.md (return expander): Update.\n+\t* config/rs6000/rs6000.c (rs6000_va_start): Update.\n+\t(rs6000_stack_info): Update.\n+\t* config/mcore/mcore.c (layout_mcore_frame): Update.\n+\t(mcore_expand_prolog): Update.\n+\t* config/arc/arc.c (arc_compute_frame_size): Update.\n+\t* config/score/score3.c (score3_compute_frame_size): Update.\n+\t* config/score/score7.c (score7_compute_frame_size): Update.\n+\t* config/arm/arm.c (use_return_insn): Update.\n+\t(thumb_find_work_register): Update.\n+\t(arm_compute_save_reg_mask): Update.\n+\t(arm_output_function_prologue): Update.\n+\t(arm_output_epilogue): Update.\n+\t(arm_size_return_regs): Update.\n+\t(arm_get_frame_offsets): Update.\n+\t(arm_expand_prologue): Update.\n+\t(thumb_exit): Update.\n+\t(thumb_unexpanded_epilogue): Update.\n+\t(thumb1_output_function_prologue): Update.\n+\t* config/pa/pa.md (return expander): Update.\n+\t* config/pa/pa.c (compute_frame_size): Update.\n+\t(hppa_builtin_saveregs): Update.\n+\t* config/mips/mips.c (mips_va_start): Update.\n+\t(mips16_build_function_stub): Update.\n+\t(mips_compute_frame_info): Update.\n+\t(mips_restore_gp): Update.\n+\t(mips_output_function_prologue): Update.\n+\t(mips_expand_prologue): Update.\n+\t* config/v850/v850.c (compute_frame_size): Update.\n+\t(expand_prologue): * config/mmix/mmix.c (along): update.\n+\t(mmix_initial_elimination_offset): update.\n+\t(mmix_reorg): update.\n+\t(mmix_use_simple_return): update.\n+\t(mmix_expand_prologue): update.\n+\t(mmix_expand_epilogue): Update.\n+\t* config/bfin/bfin.c (bfin_initial_elimination_offset): Update.\n+\t(emit_link_insn): Update.\n+\n 2008-04-08  Anatoly Sokolov <aesok@post.ru>\n \n \t* config/avr/avr.h (TARGET_CPU_CPP_BUILTINS): Define "}, {"sha": "d5c4f9222c92a10396f1cc36658c8556311a25ae", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1351,7 +1351,7 @@ expand_builtin_apply_args_1 (void)\n      as we might have pretended they were passed.  Make sure it's a valid\n      operand, as emit_move_insn isn't expected to handle a PLUS.  */\n   tem\n-    = force_operand (plus_constant (tem, current_function_pretend_args_size),\n+    = force_operand (plus_constant (tem, crtl->args.pretend_args_size),\n \t\t     NULL_RTX);\n #endif\n   emit_move_insn (adjust_address (registers, Pmode, 0), tem);\n@@ -4600,7 +4600,7 @@ static rtx\n expand_builtin_args_info (tree exp)\n {\n   int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n-  int *word_ptr = (int *) &current_function_args_info;\n+  int *word_ptr = (int *) &crtl->args.info;\n \n   gcc_assert (sizeof (CUMULATIVE_ARGS) % sizeof (int) == 0);\n \n@@ -4632,8 +4632,8 @@ expand_builtin_next_arg (void)\n   /* Checking arguments is already done in fold_builtin_next_arg\n      that must be called before this function.  */\n   return expand_binop (ptr_mode, add_optab,\n-\t\t       current_function_internal_arg_pointer,\n-\t\t       current_function_arg_offset_rtx,\n+\t\t       crtl->args.internal_arg_pointer,\n+\t\t       crtl->args.arg_offset_rtx,\n \t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n }\n "}, {"sha": "b747fd4057a8cf2cfe7a2448e7cc13d256f04f83", "filename": "gcc/calls.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1513,16 +1513,16 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n {\n   HOST_WIDE_INT i;\n \n-  if (addr == current_function_internal_arg_pointer)\n+  if (addr == crtl->args.internal_arg_pointer)\n     i = 0;\n   else if (GET_CODE (addr) == PLUS\n-\t   && XEXP (addr, 0) == current_function_internal_arg_pointer\n+\t   && XEXP (addr, 0) == crtl->args.internal_arg_pointer\n \t   && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n     i = INTVAL (XEXP (addr, 1));\n   /* Return true for arg pointer based indexed addressing.  */\n   else if (GET_CODE (addr) == PLUS\n-\t   && (XEXP (addr, 0) == current_function_internal_arg_pointer\n-\t       || XEXP (addr, 1) == current_function_internal_arg_pointer))\n+\t   && (XEXP (addr, 0) == crtl->args.internal_arg_pointer\n+\t       || XEXP (addr, 1) == crtl->args.internal_arg_pointer))\n     return true;\n   else\n     return false;\n@@ -2281,16 +2281,16 @@ expand_call (tree exp, rtx target, int ignore)\n       || (fndecl && decl_function_context (fndecl) == current_function_decl)\n       /* If this function requires more stack slots than the current\n \t function, we cannot change it into a sibling call.\n-\t current_function_pretend_args_size is not part of the\n+\t crtl->args.pretend_args_size is not part of the\n \t stack allocated by our caller.  */\n-      || args_size.constant > (current_function_args_size\n-\t\t\t       - current_function_pretend_args_size)\n+      || args_size.constant > (crtl->args.size\n+\t\t\t       - crtl->args.pretend_args_size)\n       /* If the callee pops its own arguments, then it must pop exactly\n \t the same number of arguments as the current function.  */\n       || (RETURN_POPS_ARGS (fndecl, funtype, args_size.constant)\n \t  != RETURN_POPS_ARGS (current_function_decl,\n \t\t\t       TREE_TYPE (current_function_decl),\n-\t\t\t       current_function_args_size))\n+\t\t\t       crtl->args.size))\n       || !lang_hooks.decls.ok_for_sibcall (fndecl))\n     try_tail_call = 0;\n \n@@ -2395,9 +2395,9 @@ expand_call (tree exp, rtx target, int ignore)\n \t  argblock = virtual_incoming_args_rtx;\n \t  argblock\n #ifdef STACK_GROWS_DOWNWARD\n-\t    = plus_constant (argblock, current_function_pretend_args_size);\n+\t    = plus_constant (argblock, crtl->args.pretend_args_size);\n #else\n-\t    = plus_constant (argblock, -current_function_pretend_args_size);\n+\t    = plus_constant (argblock, -crtl->args.pretend_args_size);\n #endif\n \t  stored_args_map = sbitmap_alloc (args_size.constant);\n \t  sbitmap_zero (stored_args_map);\n@@ -2434,8 +2434,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t     the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow\n \t     checking).  */\n \n-\t  if (needed > current_function_outgoing_args_size)\n-\t    current_function_outgoing_args_size = needed;\n+\t  if (needed > crtl->outgoing_args_size)\n+\t    crtl->outgoing_args_size = needed;\n \n \t  if (must_preallocate)\n \t    {\n@@ -3551,8 +3551,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (!OUTGOING_REG_PARM_STACK_SPACE)\n     args_size.constant -= reg_parm_stack_space;\n \n-  if (args_size.constant > current_function_outgoing_args_size)\n-    current_function_outgoing_args_size = args_size.constant;\n+  if (args_size.constant > crtl->outgoing_args_size)\n+    crtl->outgoing_args_size = args_size.constant;\n \n   if (ACCUMULATE_OUTGOING_ARGS)\n     {\n@@ -4325,13 +4325,13 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t  rtx x = arg->value;\n \t  int i = 0;\n \n-\t  if (XEXP (x, 0) == current_function_internal_arg_pointer\n+\t  if (XEXP (x, 0) == crtl->args.internal_arg_pointer\n \t      || (GET_CODE (XEXP (x, 0)) == PLUS\n \t\t  && XEXP (XEXP (x, 0), 0) ==\n-\t\t     current_function_internal_arg_pointer\n+\t\t     crtl->args.internal_arg_pointer\n \t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n \t    {\n-\t      if (XEXP (x, 0) != current_function_internal_arg_pointer)\n+\t      if (XEXP (x, 0) != crtl->args.internal_arg_pointer)\n \t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n \n \t      /* expand_call should ensure this.  */"}, {"sha": "02d3b684ae8e864f6b4bf0cfc262e534dc3bbc0b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -189,9 +189,9 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_size =\n \n /* Get the number of args of a function in one of two ways.  */\n #if TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK\n-#define NUM_ARGS current_function_args_info.num_args\n+#define NUM_ARGS crtl->args.info.num_args\n #else\n-#define NUM_ARGS current_function_args_info\n+#define NUM_ARGS crtl->args.info\n #endif\n \n #define REG_PV 27\n@@ -643,8 +643,8 @@ direct_return (void)\n \t  && reload_completed\n \t  && alpha_sa_size () == 0\n \t  && get_frame_size () == 0\n-\t  && current_function_outgoing_args_size == 0\n-\t  && current_function_pretend_args_size == 0);\n+\t  && crtl->outgoing_args_size == 0\n+\t  && crtl->args.pretend_args_size == 0);\n }\n \n /* Return the ADDR_VEC associated with a tablejump insn.  */\n@@ -6082,7 +6082,7 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   if (NUM_ARGS < 6)\n     offset = TARGET_ABI_OPEN_VMS ? UNITS_PER_WORD : 6 * UNITS_PER_WORD;\n   else\n-    offset = -6 * UNITS_PER_WORD + current_function_pretend_args_size;\n+    offset = -6 * UNITS_PER_WORD + crtl->args.pretend_args_size;\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n@@ -7148,7 +7148,7 @@ alpha_sa_size (void)\n \n       alpha_procedure_type\n \t= (sa_size || get_frame_size() != 0\n-\t   || current_function_outgoing_args_size\n+\t   || crtl->outgoing_args_size\n \t   || current_function_stdarg || current_function_calls_alloca\n \t   || frame_pointer_needed)\n \t  ? PT_STACK : PT_REGISTER;\n@@ -7184,7 +7184,7 @@ alpha_sa_size (void)\n \t= (frame_pointer_needed\n \t   || current_function_has_nonlocal_label\n \t   || alpha_procedure_type == PT_STACK\n-\t   || current_function_outgoing_args_size)\n+\t   || crtl->outgoing_args_size)\n \t  ? REG_PV : HARD_FRAME_POINTER_REGNUM;\n \n       /* If we want to copy PV into FP, we need to find some register\n@@ -7229,7 +7229,7 @@ alpha_initial_elimination_offset (unsigned int from,\n   HOST_WIDE_INT ret;\n \n   ret = alpha_sa_size ();\n-  ret += ALPHA_ROUND (current_function_outgoing_args_size);\n+  ret += ALPHA_ROUND (crtl->outgoing_args_size);\n \n   switch (from)\n     {\n@@ -7238,8 +7238,8 @@ alpha_initial_elimination_offset (unsigned int from,\n \n     case ARG_POINTER_REGNUM:\n       ret += (ALPHA_ROUND (get_frame_size ()\n-\t\t\t   + current_function_pretend_args_size)\n-\t      - current_function_pretend_args_size);\n+\t\t\t   + crtl->args.pretend_args_size)\n+\t      - crtl->args.pretend_args_size);\n       break;\n \n     default:\n@@ -7447,23 +7447,23 @@ alpha_expand_prologue (void)\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n-\t\t\t      + current_function_pretend_args_size);\n+\t\t\t      + crtl->args.pretend_args_size);\n   else if (TARGET_ABI_UNICOSMK)\n     /* We have to allocate space for the DSIB if we generate a frame.  */\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n \t\t + ALPHA_ROUND (frame_size\n-\t\t\t\t+ current_function_outgoing_args_size);\n+\t\t\t\t+ crtl->outgoing_args_size);\n   else\n-    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n \t\t  + sa_size\n \t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + current_function_pretend_args_size));\n+\t\t\t\t + crtl->args.pretend_args_size));\n \n   if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8;\n   else\n-    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n+    reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n   alpha_sa_mask (&imask, &fmask);\n \n@@ -7677,14 +7677,14 @@ alpha_expand_prologue (void)\n \tFRP (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n \n       /* If we have to allocate space for outgoing args, do it now.  */\n-      if (current_function_outgoing_args_size != 0)\n+      if (crtl->outgoing_args_size != 0)\n \t{\n \t  rtx seq\n \t    = emit_move_insn (stack_pointer_rtx,\n \t\t\t      plus_constant\n \t\t\t      (hard_frame_pointer_rtx,\n \t\t\t       - (ALPHA_ROUND\n-\t\t\t\t  (current_function_outgoing_args_size))));\n+\t\t\t\t  (crtl->outgoing_args_size))));\n \n \t  /* Only set FRAME_RELATED_P on the stack adjustment we just emitted\n \t     if ! frame_pointer_needed. Setting the bit will change the CFA\n@@ -7696,7 +7696,7 @@ alpha_expand_prologue (void)\n \t       frame_pointer_needed\n \t       => vms_unwind_regno == HARD_FRAME_POINTER_REGNUM\n \t     and\n-\t       current_function_outgoing_args_size != 0\n+\t       crtl->outgoing_args_size != 0\n \t       => alpha_procedure_type != PT_NULL,\n \n \t     so when we are not setting the bit here, we are guaranteed to\n@@ -7773,22 +7773,22 @@ alpha_start_function (FILE *file, const char *fnname,\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n-\t\t\t      + current_function_pretend_args_size);\n+\t\t\t      + crtl->args.pretend_args_size);\n   else if (TARGET_ABI_UNICOSMK)\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n \t\t + ALPHA_ROUND (frame_size\n-\t\t\t      + current_function_outgoing_args_size);\n+\t\t\t      + crtl->outgoing_args_size);\n   else\n-    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n \t\t  + sa_size\n \t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + current_function_pretend_args_size));\n+\t\t\t\t + crtl->args.pretend_args_size));\n \n   if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8;\n   else\n-    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n+    reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n   alpha_sa_mask (&imask, &fmask);\n \n@@ -7858,7 +7858,7 @@ alpha_start_function (FILE *file, const char *fnname,\n     }\n \n   /* Set up offsets to alpha virtual arg/local debugging pointer.  */\n-  alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n+  alpha_auto_offset = -frame_size + crtl->args.pretend_args_size;\n   alpha_arg_offset = -frame_size + 48;\n \n   /* Describe our frame.  If the frame size is larger than an integer,\n@@ -7877,7 +7877,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \t     (frame_pointer_needed\n \t      ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM),\n \t     frame_size >= max_frame_size ? 0 : frame_size,\n-\t     current_function_pretend_args_size);\n+\t     crtl->args.pretend_args_size);\n \n   /* Describe which registers were spilled.  */\n   if (TARGET_ABI_UNICOSMK)\n@@ -7972,17 +7972,17 @@ alpha_expand_epilogue (void)\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n-\t\t\t      + current_function_pretend_args_size);\n+\t\t\t      + crtl->args.pretend_args_size);\n   else if (TARGET_ABI_UNICOSMK)\n     frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n \t\t + ALPHA_ROUND (frame_size\n-\t\t\t      + current_function_outgoing_args_size);\n+\t\t\t      + crtl->outgoing_args_size);\n   else\n-    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n \t\t  + sa_size\n \t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + current_function_pretend_args_size));\n+\t\t\t\t + crtl->args.pretend_args_size));\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n@@ -7992,7 +7992,7 @@ alpha_expand_epilogue (void)\n           reg_offset = 0;\n     }\n   else\n-    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n+    reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n   alpha_sa_mask (&imask, &fmask);\n \n@@ -9775,12 +9775,12 @@ unicosmk_initial_elimination_offset (int from, int to)\n   else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return 0;\n   else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return (ALPHA_ROUND (current_function_outgoing_args_size)\n+    return (ALPHA_ROUND (crtl->outgoing_args_size)\n \t    + ALPHA_ROUND (get_frame_size()));\n   else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return (ALPHA_ROUND (fixed_size)\n \t    + ALPHA_ROUND (get_frame_size()\n-\t\t\t   + current_function_outgoing_args_size));\n+\t\t\t   + crtl->outgoing_args_size));\n   else\n     gcc_unreachable ();\n }"}, {"sha": "5f2431e2978e53d8cf934b9c14aa17029cb1d432", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -662,7 +662,7 @@ extern int alpha_memory_latency;\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size.  */\n+   found in the variable crtl->outgoing_args_size.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n@@ -915,7 +915,7 @@ do {\t\t\t\t\t\t\\\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 28)\n #define EH_RETURN_HANDLER_RTX \\\n   gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, \\\n-\t\t\t\t     current_function_outgoing_args_size))\n+\t\t\t\t     crtl->outgoing_args_size))\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "768ff38b8bb11059382e51cf1192fe79bcbed316", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -474,11 +474,11 @@\n    && INTVAL (operands[2])\n \t< (0x7fff8000\n \t   - FIRST_PSEUDO_REGISTER * UNITS_PER_WORD\n-\t   - ALPHA_ROUND(current_function_outgoing_args_size)\n+\t   - ALPHA_ROUND(crtl->outgoing_args_size)\n \t   - (ALPHA_ROUND (get_frame_size ()\n \t\t\t   + max_reg_num () * UNITS_PER_WORD\n-\t\t\t   + current_function_pretend_args_size)\n-\t      - current_function_pretend_args_size))\"\n+\t\t\t   + crtl->args.pretend_args_size)\n+\t      - crtl->args.pretend_args_size))\"\n   \"@\n    lda %0,%2(%1)\n    ldah %0,%h2(%1)"}, {"sha": "b2fb213b9d1851561a949fe7f9aa6bfaa62bf0ce", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -143,14 +143,14 @@ along with GCC; see the file COPYING3.  If not see\n     case ARG_POINTER_REGNUM:\t\t\t\t\t\t\\\n       (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()\t\\\n \t\t\t       + get_frame_size ()\t\t\t\\\n-\t\t\t       + current_function_pretend_args_size)\t\\\n-\t\t  - current_function_pretend_args_size);\t\t\\\n+\t\t\t       + crtl->args.pretend_args_size)\t\\\n+\t\t  - crtl->args.pretend_args_size);\t\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     default:\t\t\t\t\t\t\t\t\\\n       gcc_unreachable ();\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-    (OFFSET) += ALPHA_ROUND (current_function_outgoing_args_size);\t\\\n+    (OFFSET) += ALPHA_ROUND (crtl->outgoing_args_size);\t\\\n }\n \f\n /* Define a data type for recording info about an argument list"}, {"sha": "7b7d580471f2a7f29a2357910685efea39e1fc16", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1079,11 +1079,11 @@ arc_compute_frame_size (int size /* # of var. bytes allocated.  */)\n   int interrupt_p;\n \n   var_size\t= size;\n-  args_size\t= current_function_outgoing_args_size;\n-  pretend_size\t= current_function_pretend_args_size;\n+  args_size\t= crtl->outgoing_args_size;\n+  pretend_size\t= crtl->args.pretend_args_size;\n   extra_size\t= FIRST_PARM_OFFSET (0);\n   total_size\t= extra_size + pretend_size + args_size + var_size;\n-  reg_offset\t= FIRST_PARM_OFFSET(0) + current_function_outgoing_args_size;\n+  reg_offset\t= FIRST_PARM_OFFSET(0) + crtl->outgoing_args_size;\n   reg_size\t= 0;\n   gmask\t\t= 0;\n \n@@ -2282,8 +2282,8 @@ static void\n arc_va_start (tree valist, rtx nextarg)\n {\n   /* See arc_setup_incoming_varargs for reasons for this oddity.  */\n-  if (current_function_args_info < 8\n-      && (current_function_args_info & 1))\n+  if (crtl->args.info < 8\n+      && (crtl->args.info & 1))\n     nextarg = plus_constant (nextarg, UNITS_PER_WORD);\n \n   std_expand_builtin_va_start (valist, nextarg);"}, {"sha": "06aa4035d1b51c6f3598ad4d99f2de2750b1bbd3", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -531,7 +531,7 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed\n+   `crtl->outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n #define ACCUMULATE_OUTGOING_ARGS 1"}, {"sha": "78aac134dafc30d44ed1fc81bef2ebdb903877f6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1653,7 +1653,7 @@ use_return_insn (int iscond, rtx sibling)\n   stack_adjust = offsets->outgoing_args - offsets->saved_regs;\n \n   /* As do variadic functions.  */\n-  if (current_function_pretend_args_size\n+  if (crtl->args.pretend_args_size\n       || cfun->machine->uses_anonymous_args\n       /* Or if the function calls __builtin_eh_return () */\n       || current_function_calls_eh_return\n@@ -3544,15 +3544,15 @@ thumb_find_work_register (unsigned long pushed_regs_mask)\n      the variable argument list and so we can be sure that it will be\n      pushed right at the start of the function.  Hence it will be available\n      for the rest of the prologue.\n-     (*): ie current_function_pretend_args_size is greater than 0.  */\n+     (*): ie crtl->args.pretend_args_size is greater than 0.  */\n   if (cfun->machine->uses_anonymous_args\n-      && current_function_pretend_args_size > 0)\n+      && crtl->args.pretend_args_size > 0)\n     return LAST_ARG_REGNUM;\n \n   /* The other case is when we have fixed arguments but less than 4 registers\n      worth.  In this case r3 might be used in the body of the function, but\n      it is not being used to convey an argument into the function.  In theory\n-     we could just check current_function_args_size to see how many bytes are\n+     we could just check crtl->args.size to see how many bytes are\n      being passed in argument registers, but it seems that it is unreliable.\n      Sometimes it will have the value 0 when in fact arguments are being\n      passed.  (See testcase execute/20021111-1.c for an example).  So we also\n@@ -3562,8 +3562,8 @@ thumb_find_work_register (unsigned long pushed_regs_mask)\n      when a function has an unused argument in r3.  But it is better to be\n      safe than to be sorry.  */\n   if (! cfun->machine->uses_anonymous_args\n-      && current_function_args_size >= 0\n-      && current_function_args_size <= (LAST_ARG_REGNUM * UNITS_PER_WORD)\n+      && crtl->args.size >= 0\n+      && crtl->args.size <= (LAST_ARG_REGNUM * UNITS_PER_WORD)\n       && cfun->args_info.nregs < 4)\n     return LAST_ARG_REGNUM;\n \n@@ -10833,7 +10833,7 @@ arm_compute_save_reg_mask (void)\n \n   if (TARGET_REALLY_IWMMXT\n       && ((bit_count (save_reg_mask)\n-\t   + ARM_NUM_INTS (current_function_pretend_args_size)) % 2) != 0)\n+\t   + ARM_NUM_INTS (crtl->args.pretend_args_size)) % 2) != 0)\n     {\n       /* The total number of registers that are going to be pushed\n \t onto the stack is odd.  We need to ensure that the stack\n@@ -11258,8 +11258,8 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n     asm_fprintf (f, \"\\t%@ Stack Align: May be called with mis-aligned SP.\\n\");\n \n   asm_fprintf (f, \"\\t%@ args = %d, pretend = %d, frame = %wd\\n\",\n-\t       current_function_args_size,\n-\t       current_function_pretend_args_size, frame_size);\n+\t       crtl->args.size,\n+\t       crtl->args.pretend_args_size, frame_size);\n \n   asm_fprintf (f, \"\\t%@ frame_needed = %d, uses_anonymous_args = %d\\n\",\n \t       frame_pointer_needed,\n@@ -11626,7 +11626,7 @@ arm_output_epilogue (rtx sibling)\n \t  && (TARGET_ARM || ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n \t  && !IS_STACKALIGN (func_type)\n \t  && really_return\n-\t  && current_function_pretend_args_size == 0\n+\t  && crtl->args.pretend_args_size == 0\n \t  && saved_regs_mask & (1 << LR_REGNUM)\n \t  && !current_function_calls_eh_return)\n \t{\n@@ -11661,11 +11661,11 @@ arm_output_epilogue (rtx sibling)\n \t    print_multi_reg (f, \"pop\\t\", SP_REGNUM, saved_regs_mask, 0);\n \t}\n \n-      if (current_function_pretend_args_size)\n+      if (crtl->args.pretend_args_size)\n \t{\n \t  /* Unwind the pre-pushed regs.  */\n \t  operands[0] = operands[1] = stack_pointer_rtx;\n-\t  operands[2] = GEN_INT (current_function_pretend_args_size);\n+\t  operands[2] = GEN_INT (crtl->args.pretend_args_size);\n \t  output_add_immediate (operands);\n \t}\n     }\n@@ -11890,8 +11890,8 @@ arm_size_return_regs (void)\n {\n   enum machine_mode mode;\n \n-  if (current_function_return_rtx != 0)\n-    mode = GET_MODE (current_function_return_rtx);\n+  if (crtl->return_rtx != 0)\n+    mode = GET_MODE (crtl->return_rtx);\n   else\n     mode = DECL_MODE (DECL_RESULT (current_function_decl));\n \n@@ -12050,7 +12050,7 @@ arm_get_frame_offsets (void)\n   leaf = leaf_function_p ();\n \n   /* Space for variadic functions.  */\n-  offsets->saved_args = current_function_pretend_args_size;\n+  offsets->saved_args = crtl->args.pretend_args_size;\n \n   /* In Thumb mode this is incorrect, but never used.  */\n   offsets->frame = offsets->saved_args + (frame_pointer_needed ? 4 : 0);\n@@ -12119,7 +12119,7 @@ arm_get_frame_offsets (void)\n       /* Try to align stack by pushing an extra reg.  Don't bother doing this\n          when there is a stack frame as the alignment will be rolled into\n \t the normal stack adjustment.  */\n-      if (frame_size + current_function_outgoing_args_size == 0)\n+      if (frame_size + crtl->outgoing_args_size == 0)\n \t{\n \t  int reg = -1;\n \n@@ -12150,7 +12150,7 @@ arm_get_frame_offsets (void)\n \n   offsets->locals_base = offsets->soft_frame + frame_size;\n   offsets->outgoing_args = (offsets->locals_base\n-\t\t\t    + current_function_outgoing_args_size);\n+\t\t\t    + crtl->outgoing_args_size);\n \n   if (ARM_DOUBLEWORD_ALIGN)\n     {\n@@ -12399,7 +12399,7 @@ arm_expand_prologue (void)\n     return;\n \n   /* Make a copy of c_f_p_a_s as we may need to modify it locally.  */\n-  args_to_push = current_function_pretend_args_size;\n+  args_to_push = crtl->args.pretend_args_size;\n \n   /* Compute which register we will have to save onto the stack.  */\n   offsets = arm_get_frame_offsets ();\n@@ -12599,7 +12599,7 @@ arm_expand_prologue (void)\n \t      if (!df_regs_ever_live_p (3)\n \t\t  || saved_pretend_args)\n \t\tinsn = gen_rtx_REG (SImode, 3);\n-\t      else /* if (current_function_pretend_args_size == 0) */\n+\t      else /* if (crtl->args.pretend_args_size == 0) */\n \t\t{\n \t\t  insn = plus_constant (hard_frame_pointer_rtx, 4);\n \t\t  insn = gen_frame_mem (SImode, insn);\n@@ -16288,8 +16288,8 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n \t ever used in the function, not just if the register is used\n \t to hold a return value.  */\n \n-      if (current_function_return_rtx != 0)\n-\tmode = GET_MODE (current_function_return_rtx);\n+      if (crtl->return_rtx != 0)\n+\tmode = GET_MODE (crtl->return_rtx);\n       else\n \tmode = DECL_MODE (DECL_RESULT (current_function_decl));\n \n@@ -16705,7 +16705,7 @@ thumb_unexpanded_epilogue (void)\n   had_to_push_lr = (live_regs_mask & (1 << LR_REGNUM)) != 0;\n   live_regs_mask &= 0xff;\n \n-  if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n+  if (crtl->args.pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n       /* Pop the return address into the PC.  */\n       if (had_to_push_lr)\n@@ -16762,7 +16762,7 @@ thumb_unexpanded_epilogue (void)\n       /* Remove the argument registers that were pushed onto the stack.  */\n       asm_fprintf (asm_out_file, \"\\tadd\\t%r, %r, #%d\\n\",\n \t\t   SP_REGNUM, SP_REGNUM,\n-\t\t   current_function_pretend_args_size);\n+\t\t   crtl->args.pretend_args_size);\n \n       thumb_exit (asm_out_file, regno);\n     }\n@@ -17105,20 +17105,20 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n     }\n \n-  if (current_function_pretend_args_size)\n+  if (crtl->args.pretend_args_size)\n     {\n       /* Output unwind directive for the stack adjustment.  */\n       if (ARM_EABI_UNWIND_TABLES)\n \tfprintf (f, \"\\t.pad #%d\\n\",\n-\t\t current_function_pretend_args_size);\n+\t\t crtl->args.pretend_args_size);\n \n       if (cfun->machine->uses_anonymous_args)\n \t{\n \t  int num_pushes;\n \n \t  fprintf (f, \"\\tpush\\t{\");\n \n-\t  num_pushes = ARM_NUM_INTS (current_function_pretend_args_size);\n+\t  num_pushes = ARM_NUM_INTS (crtl->args.pretend_args_size);\n \n \t  for (regno = LAST_ARG_REGNUM + 1 - num_pushes;\n \t       regno <= LAST_ARG_REGNUM;\n@@ -17131,7 +17131,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       else\n \tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\",\n \t\t     SP_REGNUM, SP_REGNUM,\n-\t\t     current_function_pretend_args_size);\n+\t\t     crtl->args.pretend_args_size);\n \n       /* We don't need to record the stores for unwinding (would it\n \t help the debugger any if we did?), but record the change in\n@@ -17140,7 +17140,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t{\n \t  char *l = dwarf2out_cfi_label ();\n \n-\t  cfa_offset = cfa_offset + current_function_pretend_args_size;\n+\t  cfa_offset = cfa_offset + crtl->args.pretend_args_size;\n \t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n \t}\n     }\n@@ -17202,7 +17202,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \toffset = 0;\n \n       asm_fprintf (f, \"\\tadd\\t%r, %r, #%d\\n\", work_register, SP_REGNUM,\n-\t\t   offset + 16 + current_function_pretend_args_size);\n+\t\t   offset + 16 + crtl->args.pretend_args_size);\n \n       asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n \t\t   offset + 4);"}, {"sha": "a340441d3862e29724e617caf00723215c4a13c0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1409,7 +1409,7 @@ do {\t\t\t\t\t\t\t\t\t      \\\n    couldn't convert a direct call into an indirect one.  */\n #define CALLER_INTERWORKING_SLOT_SIZE\t\t\t\\\n   (TARGET_CALLER_INTERWORKING\t\t\t\t\\\n-   && current_function_outgoing_args_size != 0\t\t\\\n+   && crtl->outgoing_args_size != 0\t\t\\\n    ? UNITS_PER_WORD : 0)\n \n /* Offset within stack frame to start allocating local variables at.\n@@ -1426,7 +1426,7 @@ do {\t\t\t\t\t\t\t\t\t      \\\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size.  */\n+   found in the variable crtl->outgoing_args_size.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */"}, {"sha": "c440729b4226de08b2ae9fba04e06ec5849eebf9", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -2736,7 +2736,7 @@ int\n frame_pointer_required_p (void)\n {\n   return (current_function_calls_alloca\n-\t  || current_function_args_info.nregs == 0\n+\t  || crtl->args.info.nregs == 0\n   \t  || get_frame_size () > 0);\n }\n "}, {"sha": "cc558d760a2578d2ebc93498e9b69c0050240cb4", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -779,9 +779,9 @@ bfin_initial_elimination_offset (int from, int to)\n \n   if (to == STACK_POINTER_REGNUM)\n     {\n-      if (current_function_outgoing_args_size >= FIXED_STACK_AREA)\n-\toffset += current_function_outgoing_args_size;\n-      else if (current_function_outgoing_args_size)\n+      if (crtl->outgoing_args_size >= FIXED_STACK_AREA)\n+\toffset += crtl->outgoing_args_size;\n+      else if (crtl->outgoing_args_size)\n \toffset += FIXED_STACK_AREA;\n \n       offset += get_frame_size ();\n@@ -945,10 +945,10 @@ emit_link_insn (rtx spreg, HOST_WIDE_INT frame_size)\n static HOST_WIDE_INT\n arg_area_size (void)\n {\n-  if (current_function_outgoing_args_size)\n+  if (crtl->outgoing_args_size)\n     {\n-      if (current_function_outgoing_args_size >= FIXED_STACK_AREA)\n-\treturn current_function_outgoing_args_size;\n+      if (crtl->outgoing_args_size >= FIXED_STACK_AREA)\n+\treturn crtl->outgoing_args_size;\n       else\n \treturn FIXED_STACK_AREA;\n     }"}, {"sha": "33ab81d728da98837a0782872c9a76a1e1ad19b1", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -287,7 +287,7 @@ extern const char *bfin_library_id_string;\n \t  \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size. */ \n+   found in the variable crtl->outgoing_args_size. */ \n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value should be nonzero if functions must have frame pointers."}, {"sha": "85a944b9e95d1d3e7b9943a4aa64e8bbf16b22ad", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1206,7 +1206,7 @@ cris_initial_frame_pointer_offset (void)\n   offs += get_frame_size ();\n \n   /* And more; the accumulated args size.  */\n-  offs += current_function_outgoing_args_size;\n+  offs += crtl->outgoing_args_size;\n \n   /* Then round it off, in case we use aligned stack.  */\n   if (TARGET_STACK_ALIGN)\n@@ -1700,9 +1700,9 @@ cris_simple_epilogue (void)\n   if (! reload_completed\n       || frame_pointer_needed\n       || get_frame_size () != 0\n-      || current_function_pretend_args_size\n-      || current_function_args_size\n-      || current_function_outgoing_args_size\n+      || crtl->args.pretend_args_size\n+      || crtl->args.size\n+      || crtl->outgoing_args_size\n       || current_function_calls_eh_return\n \n       /* If we're not supposed to emit prologue and epilogue, we must\n@@ -2731,14 +2731,14 @@ cris_expand_prologue (void)\n   int regno;\n   int size = get_frame_size ();\n   /* Shorten the used name for readability.  */\n-  int cfoa_size = current_function_outgoing_args_size;\n+  int cfoa_size = crtl->outgoing_args_size;\n   int last_movem_reg = -1;\n   int framesize = 0;\n   rtx mem, insn;\n   int return_address_on_stack = cris_return_address_on_stack ();\n   int got_really_used = false;\n   int n_movem_regs = 0;\n-  int pretend = current_function_pretend_args_size;\n+  int pretend = crtl->args.pretend_args_size;\n \n   /* Don't do anything if no prologues or epilogues are wanted.  */\n   if (!TARGET_PROLOGUE_EPILOGUE)\n@@ -2765,7 +2765,7 @@ cris_expand_prologue (void)\n     {\n       /* See also cris_setup_incoming_varargs where\n \t cfun->machine->stdarg_regs is set.  There are other setters of\n-\t current_function_pretend_args_size than stdarg handling, like\n+\t crtl->args.pretend_args_size than stdarg handling, like\n \t for an argument passed with parts in R13 and stack.  We must\n \t not store R13 into the pretend-area for that case, as GCC does\n \t that itself.  \"Our\" store would be marked as redundant and GCC\n@@ -2799,7 +2799,7 @@ cris_expand_prologue (void)\n \t     get confused.  */\n \t}\n \n-      /* For other setters of current_function_pretend_args_size, we\n+      /* For other setters of crtl->args.pretend_args_size, we\n \t just adjust the stack by leaving the remaining size in\n \t \"pretend\", handled below.  */\n     }\n@@ -3012,8 +3012,8 @@ cris_expand_epilogue (void)\n   int regno;\n   int size = get_frame_size ();\n   int last_movem_reg = -1;\n-  int argspace_offset = current_function_outgoing_args_size;\n-  int pretend =\t current_function_pretend_args_size;\n+  int argspace_offset = crtl->outgoing_args_size;\n+  int pretend =\t crtl->args.pretend_args_size;\n   rtx mem;\n   bool return_address_on_stack = cris_return_address_on_stack ();\n   /* A reference may have been optimized out"}, {"sha": "9e8c3a97cf15a145ba8b3078ae280ee78727004b", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -318,7 +318,7 @@ crx_compute_frame (void)\n   local_vars_size += padding_locals;\n \n   size_for_adjusting_sp = local_vars_size + (ACCUMULATE_OUTGOING_ARGS ?\n-\t\t\t\t     current_function_outgoing_args_size : 0);\n+\t\t\t\t     crtl->outgoing_args_size : 0);\n }\n \n /* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET. */\n@@ -334,13 +334,13 @@ crx_initial_elimination_offset (int from, int to)\n \n   if ((from) == FRAME_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n     return (ACCUMULATE_OUTGOING_ARGS ?\n-\t    current_function_outgoing_args_size : 0);\n+\t    crtl->outgoing_args_size : 0);\n   else if ((from) == ARG_POINTER_REGNUM && (to) == FRAME_POINTER_REGNUM)\n     return (sum_regs + local_vars_size);\n   else if ((from) == ARG_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n     return (sum_regs + local_vars_size +\n \t    (ACCUMULATE_OUTGOING_ARGS ?\n-\t     current_function_outgoing_args_size : 0));\n+\t     crtl->outgoing_args_size : 0));\n   else\n     abort ();\n }"}, {"sha": "78f7775c65829d38db3293b8685ebf5b6458d115", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -181,8 +181,8 @@ fr30_compute_frame_size (int from_reg, int to_reg)\n   unsigned int \tgmask;\n \n   var_size\t= WORD_ALIGN (get_frame_size ());\n-  args_size\t= WORD_ALIGN (current_function_outgoing_args_size);\n-  pretend_size\t= current_function_pretend_args_size;\n+  args_size\t= WORD_ALIGN (crtl->outgoing_args_size);\n+  pretend_size\t= crtl->args.pretend_args_size;\n \n   reg_size\t= 0;\n   gmask\t\t= 0;"}, {"sha": "0f7592d490ab41065c6b47703b0af7417e13c206", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -534,7 +534,7 @@ enum reg_class\n    register.  See `FIXED_REGISTERS' for more information.  */\n /* #define FRAME_POINTER_REQUIRED 0 */\n #define FRAME_POINTER_REQUIRED \\\n-     (flag_omit_frame_pointer == 0 || current_function_pretend_args_size > 0)\n+     (flag_omit_frame_pointer == 0 || crtl->args.pretend_args_size > 0)\n \n /* If defined, this macro specifies a table of register pairs used to eliminate\n    unneeded registers that point into the stack frame.  If it is not defined,\n@@ -586,7 +586,7 @@ enum reg_class\n \n /* If defined, the maximum amount of space required for outgoing arguments will\n    be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed onto the\n+   `crtl->outgoing_args_size'.  No space will be pushed onto the\n    stack for each call; instead, the function prologue should increase the\n    stack frame size by this amount.\n "}, {"sha": "6c86ef569f2b72b73bfa83b7d29d8d3d7aac2cbb", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1620,7 +1620,7 @@ typedef struct frv_stack {\n \n /* If defined, the maximum amount of space required for outgoing arguments will\n    be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed onto the\n+   `crtl->outgoing_args_size'.  No space will be pushed onto the\n    stack for each call; instead, the function prologue should increase the\n    stack frame size by this amount.\n "}, {"sha": "6fcbe6637e19cab3b64a695e8bf438c66f8e0ebd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -5204,9 +5204,9 @@ ix86_va_start (tree valist, rtx nextarg)\n   sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n-  words = current_function_args_info.words;\n-  n_gpr = current_function_args_info.regno;\n-  n_fpr = current_function_args_info.sse_regno;\n+  words = crtl->args.info.words;\n+  n_gpr = crtl->args.info.regno;\n+  n_fpr = crtl->args.info.sse_regno;\n \n   if (cfun->va_list_gpr_size)\n     {\n@@ -5750,8 +5750,8 @@ ix86_can_use_return_insn_p (void)\n \n   /* Don't allow more than 32 pop, since that's all we can do\n      with one instruction.  */\n-  if (current_function_pops_args\n-      && current_function_args_size >= 32768)\n+  if (crtl->args.pops_args\n+      && crtl->args.size >= 32768)\n     return 0;\n \n   ix86_compute_frame_layout (&frame);\n@@ -6182,14 +6182,14 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   /* Add outgoing arguments area.  Can be skipped if we eliminated\n      all the function calls as dead code.\n      Skipping is however impossible when function calls alloca.  Alloca\n-     expander assumes that last current_function_outgoing_args_size\n+     expander assumes that last crtl->outgoing_args_size\n      of stack frame are unused.  */\n   if (ACCUMULATE_OUTGOING_ARGS\n       && (!current_function_is_leaf || current_function_calls_alloca\n \t  || ix86_current_function_calls_tls_descriptor))\n     {\n-      offset += current_function_outgoing_args_size;\n-      frame->outgoing_arguments_size = current_function_outgoing_args_size;\n+      offset += crtl->outgoing_args_size;\n+      frame->outgoing_arguments_size = crtl->outgoing_args_size;\n     }\n   else\n     frame->outgoing_arguments_size = 0;\n@@ -6750,15 +6750,15 @@ ix86_expand_epilogue (int style)\n   if (style == 0)\n     return;\n \n-  if (current_function_pops_args && current_function_args_size)\n+  if (crtl->args.pops_args && crtl->args.size)\n     {\n-      rtx popc = GEN_INT (current_function_pops_args);\n+      rtx popc = GEN_INT (crtl->args.pops_args);\n \n       /* i386 can only pop 64K bytes.  If asked to pop more, pop\n \t return address, do explicit add, and jump indirectly to the\n \t caller.  */\n \n-      if (current_function_pops_args >= 65536)\n+      if (crtl->args.pops_args >= 65536)\n \t{\n \t  rtx ecx = gen_rtx_REG (SImode, CX_REG);\n "}, {"sha": "bb6fa18d99d7504a99c170c03276055d4086d533", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1603,7 +1603,7 @@ enum reg_class\n \n /* If defined, the maximum amount of space required for outgoing arguments will\n    be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed onto the\n+   `crtl->outgoing_args_size'.  No space will be pushed onto the\n    stack for each call; instead, the function prologue should increase the stack\n    frame size by this amount.  */\n "}, {"sha": "10f172e2c753491fd41d9233648fe44bb19439cf", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -14806,9 +14806,9 @@\n   [(return)]\n   \"ix86_can_use_return_insn_p ()\"\n {\n-  if (current_function_pops_args)\n+  if (crtl->args.pops_args)\n     {\n-      rtx popc = GEN_INT (current_function_pops_args);\n+      rtx popc = GEN_INT (crtl->args.pops_args);\n       emit_jump_insn (gen_return_pop_internal (popc));\n       DONE;\n     }"}, {"sha": "0658b539702381c238bce4350c35f670b18be809", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -2575,12 +2575,12 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n      the stack, then the FR save area will be unaligned.  We round the\n      size of this area up to keep things 16 byte aligned.  */\n   if (spilled_fr_p)\n-    pretend_args_size = IA64_STACK_ALIGN (current_function_pretend_args_size);\n+    pretend_args_size = IA64_STACK_ALIGN (crtl->args.pretend_args_size);\n   else\n-    pretend_args_size = current_function_pretend_args_size;\n+    pretend_args_size = crtl->args.pretend_args_size;\n \n   total_size = (spill_size + extra_spill_size + size + pretend_args_size\n-\t\t+ current_function_outgoing_args_size);\n+\t\t+ crtl->outgoing_args_size);\n   total_size = IA64_STACK_ALIGN (total_size);\n \n   /* We always use the 16-byte scratch area provided by the caller, but\n@@ -2616,14 +2616,14 @@ ia64_initial_elimination_offset (int from, int to)\n \t    offset = -current_frame_info.total_size;\n \t  else\n \t    offset = -(current_frame_info.total_size\n-\t\t       - current_function_outgoing_args_size - 16);\n+\t\t       - crtl->outgoing_args_size - 16);\n \t  break;\n \n \tcase STACK_POINTER_REGNUM:\n \t  if (current_function_is_leaf)\n \t    offset = 0;\n \t  else\n-\t    offset = 16 + current_function_outgoing_args_size;\n+\t    offset = 16 + crtl->outgoing_args_size;\n \t  break;\n \n \tdefault:\n@@ -2637,12 +2637,12 @@ ia64_initial_elimination_offset (int from, int to)\n       switch (to)\n \t{\n \tcase HARD_FRAME_POINTER_REGNUM:\n-\t  offset = 16 - current_function_pretend_args_size;\n+\t  offset = 16 - crtl->args.pretend_args_size;\n \t  break;\n \n \tcase STACK_POINTER_REGNUM:\n \t  offset = (current_frame_info.total_size\n-\t\t    + 16 - current_function_pretend_args_size);\n+\t\t    + 16 - crtl->args.pretend_args_size);\n \t  break;\n \n \tdefault:\n@@ -2994,7 +2994,7 @@ ia64_expand_prologue (void)\n   /* We don't need an alloc instruction if we've used no outputs or locals.  */\n   if (current_frame_info.n_local_regs == 0\n       && current_frame_info.n_output_regs == 0\n-      && current_frame_info.n_input_regs <= current_function_args_info.int_regs\n+      && current_frame_info.n_input_regs <= crtl->args.info.int_regs\n       && !TEST_HARD_REG_BIT (current_frame_info.mask, AR_PFS_REGNUM))\n     {\n       /* If there is no alloc, but there are input registers used, then we"}, {"sha": "60934f2f38b9fa60caa3a6d68dc44ab0bbf08de7", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1029,7 +1029,7 @@ enum reg_class\n \n /* If defined, the maximum amount of space required for outgoing arguments will\n    be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  */\n+   `crtl->outgoing_args_size'.  */\n \n #define ACCUMULATE_OUTGOING_ARGS 1\n "}, {"sha": "1baf6eb73bbc79b3a424f812f2deb26b9157760d", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1368,7 +1368,7 @@ iq2000_va_start (tree valist, rtx nextarg)\n   /* Find out how many non-float named formals.  */\n   int gpr_save_area_size;\n   /* Note UNITS_PER_WORD is 4 bytes.  */\n-  int_arg_words = current_function_args_info.arg_words;\n+  int_arg_words = crtl->args.info.arg_words;\n \n   if (int_arg_words < 8 )\n     /* Adjust for the prologue's economy measure.  */\n@@ -1615,7 +1615,7 @@ compute_frame_size (HOST_WIDE_INT size)\n   mask = 0;\n   extra_size = IQ2000_STACK_ALIGN ((0));\n   var_size = IQ2000_STACK_ALIGN (size);\n-  args_size = IQ2000_STACK_ALIGN (current_function_outgoing_args_size);\n+  args_size = IQ2000_STACK_ALIGN (crtl->outgoing_args_size);\n \n   /* If a function dynamically allocates the stack and\n      has 0 for STACK_DYNAMIC_OFFSET then allocate some stack space.  */\n@@ -1660,7 +1660,7 @@ compute_frame_size (HOST_WIDE_INT size)\n       && ! profile_flag)\n     total_size = extra_size = 0;\n \n-  total_size += IQ2000_STACK_ALIGN (current_function_pretend_args_size);\n+  total_size += IQ2000_STACK_ALIGN (crtl->args.pretend_args_size);\n \n   /* Save other computed information.  */\n   cfun->machine->total_size = total_size;"}, {"sha": "cdbf5a2b3f2f2718aa92a78123563cf97342bb3c", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -303,7 +303,7 @@ enum reg_class\n #define FRAME_GROWS_DOWNWARD 0\n \n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n-  (current_function_outgoing_args_size)\n+  (crtl->outgoing_args_size)\n \n /* Use the default value zero.  */\n /* #define STACK_POINTER_OFFSET 0 */"}, {"sha": "ea4e7f85c5c2f10da5451f142de87fdc32795781", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1276,8 +1276,8 @@ m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n                                   | current_function_profile);\n \n   var_size\t= M32R_STACK_ALIGN (size);\n-  args_size\t= M32R_STACK_ALIGN (current_function_outgoing_args_size);\n-  pretend_size\t= current_function_pretend_args_size;\n+  args_size\t= M32R_STACK_ALIGN (crtl->outgoing_args_size);\n+  pretend_size\t= crtl->args.pretend_args_size;\n   extra_size\t= FIRST_PARM_OFFSET (0);\n   total_size\t= extra_size + pretend_size + args_size + var_size;\n   reg_size\t= 0;"}, {"sha": "d1ac1c81d218b4fe924f9478c26350db9b3a1162", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -717,7 +717,7 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n /* The frame pointer points at the same place as the stack pointer, except if\n    alloca has been called.  */\n #define STARTING_FRAME_OFFSET \\\n-  M32R_STACK_ALIGN (current_function_outgoing_args_size)\n+  M32R_STACK_ALIGN (crtl->outgoing_args_size)\n \n /* Offset from the stack pointer register to the first location at which\n    outgoing arguments are placed.  */\n@@ -818,9 +818,9 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n       if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n \t(OFFSET) = 0;\t\t\t\t\t\t\t\t\\\n       else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n-\t(OFFSET) = size - current_function_pretend_args_size;\t\t\t\\\n+\t(OFFSET) = size - crtl->args.pretend_args_size;\t\t\t\\\n       else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-\t(OFFSET) = size - current_function_pretend_args_size;\t\t\t\\\n+\t(OFFSET) = size - crtl->args.pretend_args_size;\t\t\t\\\n       else\t\t\t\t\t\t\t\t\t\\\n \tgcc_unreachable ();\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\t\\\n@@ -830,7 +830,7 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed\n+   `crtl->outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n #define ACCUMULATE_OUTGOING_ARGS 1"}, {"sha": "83b73b2414aa9c808bdafa5db5cf5cff91d09fca", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1597,7 +1597,7 @@ expand_prologue (void)\n      If the first argument is a 32-bit quantity, the D+X registers\n      are used.  Use Y to compute the frame.  Otherwise, X is cheaper.\n      For 68HC12, this scratch register is not used.  */\n-  if (current_function_args_info.nregs == 2)\n+  if (crtl->args.info.nregs == 2)\n     scratch = iy_reg;\n   else\n     scratch = ix_reg;\n@@ -1685,12 +1685,12 @@ expand_epilogue (void)\n   /* If we are returning a value in two registers, we have to preserve the\n      X register and use the Y register to restore the stack and the saved\n      registers.  Otherwise, use X because it's faster (and smaller).  */\n-  if (current_function_return_rtx == 0)\n+  if (crtl->return_rtx == 0)\n     return_size = 0;\n-  else if (GET_CODE (current_function_return_rtx) == MEM)\n+  else if (GET_CODE (crtl->return_rtx) == MEM)\n     return_size = HARD_REG_SIZE;\n   else\n-    return_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));\n+    return_size = GET_MODE_SIZE (GET_MODE (crtl->return_rtx));\n \n   if (return_size > HARD_REG_SIZE && return_size <= 2 * HARD_REG_SIZE)\n     scratch = iy_reg;"}, {"sha": "8a7a5d0a0bf96c8f7950a1469edd33be5b6d4ec2", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -6722,8 +6722,8 @@\n {\n   int ret_size = 0;\n \n-  if (current_function_return_rtx)\n-    ret_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));\n+  if (crtl->return_rtx)\n+    ret_size = GET_MODE_SIZE (GET_MODE (crtl->return_rtx));\n \n   /* Emit use notes only when HAVE_return is true.  */\n   if (m68hc11_total_frame_size () != 0)\n@@ -6768,8 +6768,8 @@\n     {\n       int ret_size = 0;\n \n-      if (current_function_return_rtx)\n-        ret_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));\n+      if (crtl->return_rtx)\n+        ret_size = GET_MODE_SIZE (GET_MODE (crtl->return_rtx));\n \n       if (ret_size == 0)\n         return \\\"jmp\\\\t__return_void\\\";"}, {"sha": "523b039acd0034f8887373b963750ecea59cf9a1", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -7153,9 +7153,9 @@\n       return \"sleep\";\n \n     default:\n-      if (current_function_pops_args)\n+      if (crtl->args.pops_args)\n \t{\n-\t  operands[0] = GEN_INT (current_function_pops_args);\n+\t  operands[0] = GEN_INT (crtl->args.pops_args);\n \t  return \"rtd %0\";\n \t}\n       else"}, {"sha": "d9d3398b498e2a5647310d5a35f00ffb432b0607", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1651,7 +1651,7 @@ layout_mcore_frame (struct mcore_frame * infp)\n \n   /* Might have to spill bytes to re-assemble a big argument that\n      was passed partially in registers and partially on the stack.  */\n-  nbytes = current_function_pretend_args_size;\n+  nbytes = crtl->args.pretend_args_size;\n   \n   /* Determine how much space for spilled anonymous args (e.g., stdarg).  */\n   if (current_function_anonymous_args)\n@@ -1665,7 +1665,7 @@ layout_mcore_frame (struct mcore_frame * infp)\n \n   /* And the rest of it... locals and space for overflowed outbounds.  */\n   infp->local_size = get_frame_size ();\n-  infp->outbound_size = current_function_outgoing_args_size;\n+  infp->outbound_size = crtl->outgoing_args_size;\n \n   /* Make sure we have a whole number of words for the locals.  */\n   if (infp->local_size % STACK_BYTES)\n@@ -1962,7 +1962,7 @@ mcore_expand_prolog (void)\n   /* If we have a parameter passed partially in regs and partially in memory,\n      the registers will have been stored to memory already in function.c.  So\n      we only need to do something here for varargs functions.  */\n-  if (fi.arg_size != 0 && current_function_pretend_args_size == 0)\n+  if (fi.arg_size != 0 && crtl->args.pretend_args_size == 0)\n     {\n       int offset;\n       int rn = FIRST_PARM_REG + NPARM_REGS - 1;"}, {"sha": "7ea9ac41fe111d1e2415a80cf8fdbba3d40e860c", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -538,7 +538,7 @@ extern const enum reg_class reg_class_from_letter[];\n \n /* If defined, the maximum amount of space required for outgoing arguments\n    will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed\n+   `crtl->outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n #define ACCUMULATE_OUTGOING_ARGS 1"}, {"sha": "b9c49500dc4a1d4e777a1c73733dfa8cc8c8a496", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -4784,7 +4784,7 @@ mips_va_start (tree valist, rtx nextarg)\n       int fpr_save_area_size;\n       int fpr_offset;\n \n-      cum = &current_function_args_info;\n+      cum = &crtl->args.info;\n       gpr_save_area_size\n \t= (MAX_ARGS_IN_REGISTERS - cum->num_gprs) * UNITS_PER_WORD;\n       fpr_save_area_size\n@@ -5160,7 +5160,7 @@ mips16_build_function_stub (void)\n   fprintf (asm_out_file, \"\\t# Stub function for %s (\",\n \t   current_function_name ());\n   separator = \"\";\n-  for (f = (unsigned int) current_function_args_info.fp_code; f != 0; f >>= 2)\n+  for (f = (unsigned int) crtl->args.info.fp_code; f != 0; f >>= 2)\n     {\n       fprintf (asm_out_file, \"%s%s\", separator,\n \t       (f & 3) == 1 ? \"float\" : \"double\");\n@@ -5196,7 +5196,7 @@ mips16_build_function_stub (void)\n   fprintf (asm_out_file, \"\\n\");\n \n   /* Move the arguments from floating-point registers to general registers.  */\n-  mips_output_args_xfer (current_function_args_info.fp_code, 'f');\n+  mips_output_args_xfer (crtl->args.info.fp_code, 'f');\n \n   /* Jump to the MIPS16 function.  */\n   fprintf (asm_out_file, \"\\tjr\\t%s\\n\", reg_names[GP_REG_FIRST + 1]);\n@@ -7846,7 +7846,7 @@ mips_compute_frame_info (void)\n     }\n   else\n     {\n-      frame->args_size = current_function_outgoing_args_size;\n+      frame->args_size = crtl->outgoing_args_size;\n       frame->cprestore_size = STARTING_FRAME_OFFSET - frame->args_size;\n     }\n   offset = frame->args_size + frame->cprestore_size;\n@@ -7912,7 +7912,7 @@ mips_compute_frame_info (void)\n   frame->arg_pointer_offset = offset;\n \n   /* Move above the callee-allocated area for pretend stack arguments.  */\n-  offset += current_function_pretend_args_size;\n+  offset += crtl->args.pretend_args_size;\n   frame->total_size = offset;\n \n   /* Work out the offsets of the save areas from the top of the frame.  */\n@@ -8059,7 +8059,7 @@ mips_restore_gp (void)\n \n   base = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n   address = mips_add_offset (pic_offset_table_rtx, base,\n-\t\t\t     current_function_outgoing_args_size);\n+\t\t\t     crtl->outgoing_args_size);\n   mips_emit_move (pic_offset_table_rtx, gen_frame_mem (Pmode, address));\n   if (!TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n@@ -8149,7 +8149,7 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      floating-point arguments.  */\n   if (TARGET_MIPS16\n       && TARGET_HARD_FLOAT_ABI\n-      && current_function_args_info.fp_code != 0)\n+      && crtl->args.info.fp_code != 0)\n     mips16_build_function_stub ();\n \n   /* Select the MIPS16 mode for this function.  */\n@@ -8486,7 +8486,7 @@ mips_expand_prologue (void)\n \n   /* Initialize the $gp save slot.  */\n   if (frame->cprestore_size > 0)\n-    emit_insn (gen_cprestore (GEN_INT (current_function_outgoing_args_size)));\n+    emit_insn (gen_cprestore (GEN_INT (crtl->outgoing_args_size)));\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */"}, {"sha": "3a0e58c96e6d259460c29e531c7c4014c1e219b1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1883,7 +1883,7 @@ enum reg_class\n    See mips_compute_frame_info for details about the frame layout.  */\n \n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n-  (current_function_outgoing_args_size\t\t\t\t\t\\\n+  (crtl->outgoing_args_size\t\t\t\t\t\\\n    + (TARGET_CALL_CLOBBERED_GP ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n #define RETURN_ADDR_RTX mips_return_addr\n@@ -1935,7 +1935,7 @@ enum reg_class\n    allocate the area reserved for arguments passed in registers.\n    If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n    of this macro is to determine whether the space is included in\n-   `current_function_outgoing_args_size'.  */\n+   `crtl->outgoing_args_size'.  */\n #define OUTGOING_REG_PARM_STACK_SPACE 1\n \n #define STACK_BOUNDARY (TARGET_NEWABI ? 128 : 64)"}, {"sha": "3a408438c626d9b41fb81d9a7ff06de7f6791308", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -95,10 +95,10 @@ along with GCC; see the file COPYING3.  If not see\n /* The %d in \"POP %d,0\".  */\n #define MMIX_POP_ARGUMENT()\t\t\t\t\t\t\\\n  ((! TARGET_ABI_GNU\t\t\t\t\t\t\t\\\n-   && current_function_return_rtx != NULL\t\t\t\t\\\n+   && crtl->return_rtx != NULL\t\t\t\t\\\n    && ! current_function_returns_struct)\t\t\t\t\\\n-  ? (GET_CODE (current_function_return_rtx) == PARALLEL\t\t\t\\\n-     ? GET_NUM_ELEM (XVEC (current_function_return_rtx, 0)) : 1)\t\\\n+  ? (GET_CODE (crtl->return_rtx) == PARALLEL\t\t\t\\\n+     ? GET_NUM_ELEM (XVEC (crtl->return_rtx, 0)) : 1)\t\\\n   : 0)\n \n /* The canonical saved comparison operands for non-cc0 machines, set in\n@@ -531,7 +531,7 @@ mmix_initial_elimination_offset (int fromreg, int toreg)\n {\n   int regno;\n   int fp_sp_offset\n-    = (get_frame_size () + current_function_outgoing_args_size + 7) & ~7;\n+    = (get_frame_size () + crtl->outgoing_args_size + 7) & ~7;\n \n   /* There is no actual offset between these two virtual values, but for\n      the frame-pointer, we have the old one in the stack position below\n@@ -795,9 +795,9 @@ mmix_reorg (void)\n      wasteful to optimize for unused parameter registers.  As of\n      2002-04-30, df_regs_ever_live_p (n) seems to be set for only-reads too, but\n      that might change.  */\n-  if (!TARGET_ABI_GNU && regno < current_function_args_info.regs - 1)\n+  if (!TARGET_ABI_GNU && regno < crtl->args.info.regs - 1)\n     {\n-      regno = current_function_args_info.regs - 1;\n+      regno = crtl->args.info.regs - 1;\n \n       /* We don't want to let this cause us to go over the limit and make\n \t incoming parameter registers be misnumbered and treating the last\n@@ -1838,8 +1838,8 @@ mmix_use_simple_return (void)\n   int regno;\n \n   int stack_space_to_allocate\n-    = (current_function_outgoing_args_size\n-       + current_function_pretend_args_size\n+    = (crtl->outgoing_args_size\n+       + crtl->args.pretend_args_size\n        + get_frame_size () + 7) & ~7;\n \n   if (!TARGET_USE_RETURN_INSN || !reload_completed)\n@@ -1875,8 +1875,8 @@ mmix_expand_prologue (void)\n   HOST_WIDE_INT locals_size = get_frame_size ();\n   int regno;\n   HOST_WIDE_INT stack_space_to_allocate\n-    = (current_function_outgoing_args_size\n-       + current_function_pretend_args_size\n+    = (crtl->outgoing_args_size\n+       + crtl->args.pretend_args_size\n        + locals_size + 7) & ~7;\n   HOST_WIDE_INT offset = -8;\n \n@@ -1909,12 +1909,12 @@ mmix_expand_prologue (void)\n     internal_error (\"stack frame not a multiple of 8 bytes: %wd\",\n \t\t    stack_space_to_allocate);\n \n-  if (current_function_pretend_args_size)\n+  if (crtl->args.pretend_args_size)\n     {\n       int mmix_first_vararg_reg\n \t= (MMIX_FIRST_INCOMING_ARG_REGNUM\n \t   + (MMIX_MAX_ARGS_IN_REGS\n-\t      - current_function_pretend_args_size / 8));\n+\t      - crtl->args.pretend_args_size / 8));\n \n       for (regno\n \t     = MMIX_FIRST_INCOMING_ARG_REGNUM + MMIX_MAX_ARGS_IN_REGS - 1;\n@@ -2110,12 +2110,12 @@ mmix_expand_epilogue (void)\n   HOST_WIDE_INT locals_size = get_frame_size ();\n   int regno;\n   HOST_WIDE_INT stack_space_to_deallocate\n-    = (current_function_outgoing_args_size\n-       + current_function_pretend_args_size\n+    = (crtl->outgoing_args_size\n+       + crtl->args.pretend_args_size\n        + locals_size + 7) & ~7;\n \n   /* The first address to access is beyond the outgoing_args area.  */\n-  HOST_WIDE_INT offset = current_function_outgoing_args_size;\n+  HOST_WIDE_INT offset = crtl->outgoing_args_size;\n \n   /* Add the space for global non-register-stack registers.\n      It is assumed that the frame-pointer register can be one of these"}, {"sha": "1effca344739681652e1e0ef9aa275538b29a005", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -585,10 +585,10 @@ int\n can_use_return_insn (void)\n {\n   /* size includes the fixed stack space needed for function calls.  */\n-  int size = get_frame_size () + current_function_outgoing_args_size;\n+  int size = get_frame_size () + crtl->outgoing_args_size;\n \n   /* And space for the return pointer.  */\n-  size += current_function_outgoing_args_size ? 4 : 0;\n+  size += crtl->outgoing_args_size ? 4 : 0;\n \n   return (reload_completed\n \t  && size == 0\n@@ -697,8 +697,8 @@ expand_prologue (void)\n   HOST_WIDE_INT size;\n \n   /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + current_function_outgoing_args_size;\n-  size += (current_function_outgoing_args_size ? 4 : 0);\n+  size = get_frame_size () + crtl->outgoing_args_size;\n+  size += (crtl->outgoing_args_size ? 4 : 0);\n \n   /* If we use any of the callee-saved registers, save them now.  */\n   mn10300_gen_multiple_store (mn10300_get_live_callee_saved_regs ());\n@@ -956,8 +956,8 @@ expand_epilogue (void)\n   HOST_WIDE_INT size;\n \n   /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + current_function_outgoing_args_size;\n-  size += (current_function_outgoing_args_size ? 4 : 0);\n+  size = get_frame_size () + crtl->outgoing_args_size;\n+  size += (crtl->outgoing_args_size ? 4 : 0);\n \n   if (TARGET_AM33_2 && fp_regs_to_save ())\n     {\n@@ -1408,21 +1408,21 @@ initial_offset (int from, int to)\n \t  || frame_pointer_needed)\n \treturn (get_frame_size () + REG_SAVE_BYTES\n \t\t+ 4 * fp_regs_to_save ()\n-\t\t+ (current_function_outgoing_args_size\n-\t\t   ? current_function_outgoing_args_size + 4 : 0));\n+\t\t+ (crtl->outgoing_args_size\n+\t\t   ? crtl->outgoing_args_size + 4 : 0));\n       else\n \treturn (get_frame_size ()\n-\t\t+ (current_function_outgoing_args_size\n-\t\t   ? current_function_outgoing_args_size + 4 : 0));\n+\t\t+ (crtl->outgoing_args_size\n+\t\t   ? crtl->outgoing_args_size + 4 : 0));\n     }\n \n   /* The difference between the frame pointer and stack pointer is the sum\n      of the size of this function's frame and the fixed stack space needed\n      for function calls (if any).  */\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return (get_frame_size ()\n-\t    + (current_function_outgoing_args_size\n-\t       ? current_function_outgoing_args_size + 4 : 0));\n+\t    + (crtl->outgoing_args_size\n+\t       ? crtl->outgoing_args_size + 4 : 0));\n \n   gcc_unreachable ();\n }\n@@ -1452,21 +1452,21 @@ mn10300_builtin_saveregs (void)\n   alias_set_type set = get_varargs_alias_set ();\n \n   if (argadj)\n-    offset = plus_constant (current_function_arg_offset_rtx, argadj);\n+    offset = plus_constant (crtl->args.arg_offset_rtx, argadj);\n   else\n-    offset = current_function_arg_offset_rtx;\n+    offset = crtl->args.arg_offset_rtx;\n \n-  mem = gen_rtx_MEM (SImode, current_function_internal_arg_pointer);\n+  mem = gen_rtx_MEM (SImode, crtl->args.internal_arg_pointer);\n   set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \n   mem = gen_rtx_MEM (SImode,\n-\t\t     plus_constant (current_function_internal_arg_pointer, 4));\n+\t\t     plus_constant (crtl->args.internal_arg_pointer, 4));\n   set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n \n   return copy_to_reg (expand_binop (Pmode, add_optab,\n-\t\t\t\t    current_function_internal_arg_pointer,\n+\t\t\t\t    crtl->args.internal_arg_pointer,\n \t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n }\n "}, {"sha": "7f34986d40d5c1c8b855623cb2299bd4c0345f7d", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -2589,7 +2589,7 @@\n {\n   rtx sp_reg = gen_rtx_REG (SImode, SP_REG);\n   int need_stack_space = (get_frame_size () == 0\n-\t\t\t  && current_function_outgoing_args_size == 0);\n+\t\t\t  && crtl->outgoing_args_size == 0);\n \n   if (need_stack_space)\n     emit_move_insn (sp_reg, plus_constant (sp_reg, -4));"}, {"sha": "272e028b9023de39fd64960b91315485aee74e7c", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -866,8 +866,8 @@ mt_compute_frame_size (int size)\n   unsigned int  reg_mask;\n \n   var_size      = size;\n-  args_size     = current_function_outgoing_args_size;\n-  pretend_size  = current_function_pretend_args_size;\n+  args_size     = crtl->outgoing_args_size;\n+  pretend_size  = crtl->args.pretend_args_size;\n   extra_size    = FIRST_PARM_OFFSET (0);\n   total_size    = extra_size + pretend_size + args_size + var_size;\n   reg_size      = 0;"}, {"sha": "67a8185573dbfb528b143498e2303b88754784be", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -436,7 +436,7 @@ enum save_direction\n    subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n    Otherwise, it is found by adding the length of the first slot to\n    the value `STARTING_FRAME_OFFSET'.  */\n-#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n+#define STARTING_FRAME_OFFSET crtl->outgoing_args_size\n \n /* Offset from the argument pointer register to the first argument's address.\n    On some machines it may depend on the data type of the function.\n@@ -527,7 +527,7 @@ extern struct mt_frame_info current_frame_info;\n \n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  */\n+   `crtl->outgoing_args_size'.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Define this if it is the responsibility of the caller to"}, {"sha": "3fff521df558ad1ab5b1c2cd7b4c904e61b88824", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -3570,7 +3570,7 @@ compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n      size of the current function's stack frame.  We don't need to align\n      for the outgoing arguments as their alignment is set by the final\n      rounding for the frame as a whole.  */\n-  size += current_function_outgoing_args_size;\n+  size += crtl->outgoing_args_size;\n \n   /* Allocate space for the fixed frame marker.  This space must be\n      allocated for any function that makes calls or allocates\n@@ -5935,19 +5935,19 @@ hppa_builtin_saveregs (void)\n \t\t? UNITS_PER_WORD : 0);\n \n   if (argadj)\n-    offset = plus_constant (current_function_arg_offset_rtx, argadj);\n+    offset = plus_constant (crtl->args.arg_offset_rtx, argadj);\n   else\n-    offset = current_function_arg_offset_rtx;\n+    offset = crtl->args.arg_offset_rtx;\n \n   if (TARGET_64BIT)\n     {\n       int i, off;\n \n       /* Adjust for varargs/stdarg differences.  */\n       if (argadj)\n-\toffset = plus_constant (current_function_arg_offset_rtx, -argadj);\n+\toffset = plus_constant (crtl->args.arg_offset_rtx, -argadj);\n       else\n-\toffset = current_function_arg_offset_rtx;\n+\toffset = crtl->args.arg_offset_rtx;\n \n       /* We need to save %r26 .. %r19 inclusive starting at offset -64\n \t from the incoming arg pointer and growing to larger addresses.  */\n@@ -5971,7 +5971,7 @@ hppa_builtin_saveregs (void)\n \n   /* Store general registers on the stack.  */\n   dest = gen_rtx_MEM (BLKmode,\n-\t\t      plus_constant (current_function_internal_arg_pointer,\n+\t\t      plus_constant (crtl->args.internal_arg_pointer,\n \t\t\t\t     -16));\n   set_mem_alias_set (dest, get_varargs_alias_set ());\n   set_mem_align (dest, BITS_PER_WORD);\n@@ -5989,7 +5989,7 @@ hppa_builtin_saveregs (void)\n   emit_insn (gen_blockage ());\n \n   return copy_to_reg (expand_binop (Pmode, add_optab,\n-\t\t\t\t    current_function_internal_arg_pointer,\n+\t\t\t\t    crtl->args.internal_arg_pointer,\n \t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n }\n "}, {"sha": "48e595ac5ae2dd59da39cc436111917259a586bf", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -566,12 +566,12 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    marker, although the runtime documentation only describes a 16\n    byte marker.  For compatibility, we allocate 48 bytes.  */\n #define STACK_POINTER_OFFSET \\\n-  (TARGET_64BIT ? -(current_function_outgoing_args_size + 48): -32)\n+  (TARGET_64BIT ? -(crtl->outgoing_args_size + 48): -32)\n \n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n   (TARGET_64BIT\t\t\t\t\\\n    ? (STACK_POINTER_OFFSET)\t\t\\\n-   : ((STACK_POINTER_OFFSET) - current_function_outgoing_args_size))\n+   : ((STACK_POINTER_OFFSET) - crtl->outgoing_args_size))\n \n /* Value is 1 if returning from a function call automatically\n    pops the arguments described by the number-of-args field in the call.\n@@ -791,7 +791,7 @@ extern int may_call_alloca;\n \n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n-  || current_function_calls_alloca || current_function_outgoing_args_size)\n+  || current_function_calls_alloca || crtl->outgoing_args_size)\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\\"}, {"sha": "2aca58d161ffff50dc91b7757a03ffafc4ef2997", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -7628,7 +7628,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n+\t  gcc_assert (INTVAL (nb) <= crtl->outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -8127,7 +8127,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n+\t  gcc_assert (INTVAL (nb) <= crtl->outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -8645,7 +8645,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n+\t  gcc_assert (INTVAL (nb) <= crtl->outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -8726,7 +8726,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n+\t  gcc_assert (INTVAL (nb) <= crtl->outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,"}, {"sha": "9479fc312ca5cf66416d13231e3297832c1f52b4", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -173,12 +173,12 @@\n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (FRAME_GROWS_DOWNWARD\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n-   : (RS6000_ALIGN (current_function_outgoing_args_size, 16)\t\t\\\n+   : (RS6000_ALIGN (crtl->outgoing_args_size, 16)\t\t\\\n       + RS6000_SAVE_AREA))\n \n #undef STACK_DYNAMIC_OFFSET\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (current_function_outgoing_args_size, 16)\t\t\\\n+  (RS6000_ALIGN (crtl->outgoing_args_size, 16)\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n /* These are used by -fbranch-probabilities */"}, {"sha": "eda6df0ddf355fc40c6fe92bf0605fe579d7c283", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -6656,10 +6656,10 @@ rs6000_va_start (tree valist, rtx nextarg)\n   sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n-  words = current_function_args_info.words;\n-  n_gpr = MIN (current_function_args_info.sysv_gregno - GP_ARG_MIN_REG,\n+  words = crtl->args.info.words;\n+  n_gpr = MIN (crtl->args.info.sysv_gregno - GP_ARG_MIN_REG,\n \t       GP_ARG_NUM_REG);\n-  n_fpr = MIN (current_function_args_info.fregno - FP_ARG_MIN_REG,\n+  n_fpr = MIN (crtl->args.info.fregno - FP_ARG_MIN_REG,\n \t       FP_ARG_NUM_REG);\n \n   if (TARGET_DEBUG_ARG)\n@@ -14207,7 +14207,7 @@ compute_vrsave_mask (void)\n      them in again.  More importantly, the mask we compute here is\n      used to generate CLOBBERs in the set_vrsave insn, and we do not\n      wish the argument registers to die.  */\n-  for (i = cfun->args_info.vregno - 1; i >= ALTIVEC_ARG_MIN_REG; --i)\n+  for (i = crtl->args.info.vregno - 1; i >= ALTIVEC_ARG_MIN_REG; --i)\n     mask &= ~ALTIVEC_REG_BIT (i);\n \n   /* Similarly, remove the return value from the set.  */\n@@ -14496,7 +14496,7 @@ rs6000_stack_info (void)\n   info_ptr->reg_size     = reg_size;\n   info_ptr->fixed_size   = RS6000_SAVE_AREA;\n   info_ptr->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n-  info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size,\n+  info_ptr->parm_size    = RS6000_ALIGN (crtl->outgoing_args_size,\n \t\t\t\t\t TARGET_ALTIVEC ? 16 : 8);\n   if (FRAME_GROWS_DOWNWARD)\n     info_ptr->vars_size"}, {"sha": "62f1d38f9a7a73a5fe295fa2f76b129090422a82", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1288,7 +1288,7 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (FRAME_GROWS_DOWNWARD\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n-   : (RS6000_ALIGN (current_function_outgoing_args_size,\t\t\\\n+   : (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\\\n \t\t    TARGET_ALTIVEC ? 16 : 8)\t\t\t\t\\\n       + RS6000_SAVE_AREA))\n \n@@ -1299,7 +1299,7 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n    length of the outgoing arguments.  The default is correct for most\n    machines.  See `function.c' for details.  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (current_function_outgoing_args_size,\t\t\t\\\n+  (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\\\n \t\t TARGET_ALTIVEC ? 16 : 8)\t\t\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n@@ -1334,7 +1334,7 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size.  */\n+   found in the variable crtl->outgoing_args_size.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically"}, {"sha": "f2a1947f5ae2b559f61462e833f323b029b31f87", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -6620,9 +6620,9 @@ s390_register_info (int clobbered_regs[])\n     {\n       /* Varargs functions need to save gprs 2 to 6.  */\n       if (cfun->va_list_gpr_size\n-\t  && current_function_args_info.gprs < GP_ARG_NUM_REG)\n+\t  && crtl->args.info.gprs < GP_ARG_NUM_REG)\n \t{\n-\t  int min_gpr = current_function_args_info.gprs;\n+\t  int min_gpr = crtl->args.info.gprs;\n \t  int max_gpr = min_gpr + cfun->va_list_gpr_size;\n \t  if (max_gpr > GP_ARG_NUM_REG)\n \t    max_gpr = GP_ARG_NUM_REG;\n@@ -6644,9 +6644,9 @@ s390_register_info (int clobbered_regs[])\n \n       /* Mark f0, f2 for 31 bit and f0-f4 for 64 bit to be saved.  */\n       if (TARGET_HARD_FLOAT && cfun->va_list_fpr_size\n-\t  && current_function_args_info.fprs < FP_ARG_NUM_REG)\n+\t  && crtl->args.info.fprs < FP_ARG_NUM_REG)\n \t{\n-\t  int min_fpr = current_function_args_info.fprs;\n+\t  int min_fpr = crtl->args.info.fprs;\n \t  int max_fpr = min_fpr + cfun->va_list_fpr_size;\n \t  if (max_fpr > FP_ARG_NUM_REG)\n \t    max_fpr = FP_ARG_NUM_REG;\n@@ -6744,7 +6744,7 @@ s390_frame_info (void)\n \n   if (!TARGET_PACKED_STACK)\n     cfun_frame_layout.frame_size += (STACK_POINTER_OFFSET\n-\t\t\t\t     + current_function_outgoing_args_size\n+\t\t\t\t     + crtl->outgoing_args_size\n \t\t\t\t     + cfun_frame_layout.high_fprs * 8);\n   else\n     {\n@@ -6772,7 +6772,7 @@ s390_frame_info (void)\n \t\t\t\t       STACK_BOUNDARY / BITS_PER_UNIT - 1)\n \t\t\t\t      & ~(STACK_BOUNDARY / BITS_PER_UNIT - 1));\n \n-      cfun_frame_layout.frame_size += current_function_outgoing_args_size;\n+      cfun_frame_layout.frame_size += crtl->outgoing_args_size;\n     }\n }\n \n@@ -6986,7 +6986,7 @@ s390_initial_elimination_offset (int from, int to)\n     case FRAME_POINTER_REGNUM:\n       offset = (get_frame_size() \n \t\t+ STACK_POINTER_OFFSET\n-\t\t+ current_function_outgoing_args_size);\n+\t\t+ crtl->outgoing_args_size);\n       break;\n \n     case ARG_POINTER_REGNUM:\n@@ -8011,9 +8011,9 @@ s390_build_builtin_va_list (void)\n    The following global variables are used to initialize\n    the va_list structure:\n \n-     current_function_args_info:\n+     crtl->args.info:\n        holds number of gprs and fprs used for named arguments.\n-     current_function_arg_offset_rtx:\n+     crtl->args.arg_offset_rtx:\n        holds the offset of the first anonymous stack argument\n        (relative to the virtual arg pointer).  */\n \n@@ -8038,8 +8038,8 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   /* Count number of gp and fp argument registers used.  */\n \n-  n_gpr = current_function_args_info.gprs;\n-  n_fpr = current_function_args_info.fprs;\n+  n_gpr = crtl->args.info.gprs;\n+  n_fpr = crtl->args.info.fprs;\n \n   if (cfun->va_list_gpr_size)\n     {\n@@ -8063,7 +8063,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     {\n       t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n \n-      off = INTVAL (current_function_arg_offset_rtx);\n+      off = INTVAL (crtl->args.arg_offset_rtx);\n       off = off < 0 ? 0 : off;\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\","}, {"sha": "9cba97ec69b3a288adf0ae252b0eae619846448b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -521,9 +521,9 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n \n /* Offset from the stack pointer register to an item dynamically\n    allocated on the stack, e.g., by `alloca'.  */\n-extern int current_function_outgoing_args_size;\n+extern int crtl->outgoing_args_size;\n #define STACK_DYNAMIC_OFFSET(FUNDECL) \\\n-  (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n+  (STACK_POINTER_OFFSET + crtl->outgoing_args_size)\n \n /* Offset of first parameter from the argument pointer register value.\n    We have a fake argument pointer register that points directly to"}, {"sha": "ffb5af891eed53792b83975beff3f94ec977d475", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -508,7 +508,7 @@ extern enum reg_class score_char_to_class[256];\n \n /* The offset of the first local variable from the beginning of the frame.\n    See compute_frame_size for details about the frame layout.  */\n-#define STARTING_FRAME_OFFSET           current_function_outgoing_args_size\n+#define STARTING_FRAME_OFFSET           crtl->outgoing_args_size\n \n /* The argument pointer always points to the first argument.  */\n #define FIRST_PARM_OFFSET(FUNDECL)      0\n@@ -578,7 +578,7 @@ extern enum reg_class score_char_to_class[256];\n    allocate the area reserved for arguments passed in registers.\n    If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n    of this macro is to determine whether the space is included in\n-   `current_function_outgoing_args_size'.  */\n+   `crtl->outgoing_args_size'.  */\n #define OUTGOING_REG_PARM_STACK_SPACE   1\n \n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0"}, {"sha": "1399bee15cb8eeb570f36b388524eb5a360ff609", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -183,7 +183,7 @@ score3_compute_frame_size (HOST_WIDE_INT size)\n   f->gp_reg_size = 0;\n   f->mask = 0;\n   f->var_size = SCORE3_STACK_ALIGN (size);\n-  f->args_size = current_function_outgoing_args_size;\n+  f->args_size = crtl->outgoing_args_size;\n   f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n \n   if (f->var_size == 0 && current_function_is_leaf)"}, {"sha": "2796e2e0d24d276952292e083c0ee697592e191c", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -183,7 +183,7 @@ score7_compute_frame_size (HOST_WIDE_INT size)\n   f->gp_reg_size = 0;\n   f->mask = 0;\n   f->var_size = SCORE7_STACK_ALIGN (size);\n-  f->args_size = current_function_outgoing_args_size;\n+  f->args_size = crtl->outgoing_args_size;\n   f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n   if (f->var_size == 0 && current_function_is_leaf)\n     f->args_size = f->cprestore_size = 0;"}, {"sha": "d020ccda5828fb1c53176704f80f31536f190a86", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -5629,10 +5629,10 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t      if (epilogue_p > 0)\n \t\t{\n \t\t  int nreg = 0;\n-\t\t  if (current_function_return_rtx)\n+\t\t  if (crtl->return_rtx)\n \t\t    {\n \t\t      enum machine_mode mode;\n-\t\t      mode = GET_MODE (current_function_return_rtx);\n+\t\t      mode = GET_MODE (crtl->return_rtx);\n \t\t      if (BASE_RETURN_VALUE_REG (mode) == FIRST_RET_REG)\n \t\t\tnreg = HARD_REGNO_NREGS (FIRST_RET_REG, mode);\n \t\t    }\n@@ -5970,7 +5970,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n   /* Force PR to be live if the prologue has to call the SHmedia\n      argument decoder or register saver.  */\n   if (TARGET_SHCOMPACT\n-      && ((current_function_args_info.call_cookie\n+      && ((crtl->args.info.call_cookie\n \t   & ~ CALL_COOKIE_RET_TRAMP (1))\n \t  || current_function_saves_all_registers))\n     pr_live = 1;\n@@ -5997,7 +5997,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t  : (/* Only push those regs which are used and need to be saved.  */\n \t     (TARGET_SHCOMPACT\n \t      && flag_pic\n-\t      && current_function_args_info.call_cookie\n+\t      && crtl->args.info.call_cookie\n \t      && reg == PIC_OFFSET_TABLE_REGNUM)\n \t     || (df_regs_ever_live_p (reg)\n \t\t && (!call_really_used_regs[reg]\n@@ -6245,45 +6245,45 @@ sh_expand_prologue (void)\n \n   /* We have pretend args if we had an object sent partially in registers\n      and partially on the stack, e.g. a large structure.  */\n-  pretend_args = current_function_pretend_args_size;\n+  pretend_args = crtl->args.pretend_args_size;\n   if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl)\n       && (NPARM_REGS(SImode)\n-\t  > current_function_args_info.arg_count[(int) SH_ARG_INT]))\n+\t  > crtl->args.info.arg_count[(int) SH_ARG_INT]))\n     pretend_args = 0;\n   output_stack_adjust (-pretend_args\n-\t\t       - current_function_args_info.stack_regs * 8,\n+\t\t       - crtl->args.info.stack_regs * 8,\n \t\t       stack_pointer_rtx, 0, NULL);\n \n-  if (TARGET_SHCOMPACT && flag_pic && current_function_args_info.call_cookie)\n+  if (TARGET_SHCOMPACT && flag_pic && crtl->args.info.call_cookie)\n     /* We're going to use the PIC register to load the address of the\n        incoming-argument decoder and/or of the return trampoline from\n        the GOT, so make sure the PIC register is preserved and\n        initialized.  */\n     df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n   if (TARGET_SHCOMPACT\n-      && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n+      && (crtl->args.info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n     {\n       int reg;\n \n       /* First, make all registers with incoming arguments that will\n \t be pushed onto the stack live, so that register renaming\n \t doesn't overwrite them.  */\n       for (reg = 0; reg < NPARM_REGS (SImode); reg++)\n-\tif (CALL_COOKIE_STACKSEQ_GET (current_function_args_info.call_cookie)\n+\tif (CALL_COOKIE_STACKSEQ_GET (crtl->args.info.call_cookie)\n \t    >= NPARM_REGS (SImode) - reg)\n \t  for (; reg < NPARM_REGS (SImode); reg++)\n \t    emit_insn (gen_shcompact_preserve_incoming_args\n \t\t       (gen_rtx_REG (SImode, FIRST_PARM_REG + reg)));\n \telse if (CALL_COOKIE_INT_REG_GET\n-\t\t (current_function_args_info.call_cookie, reg) == 1)\n+\t\t (crtl->args.info.call_cookie, reg) == 1)\n \t  emit_insn (gen_shcompact_preserve_incoming_args\n \t\t     (gen_rtx_REG (SImode, FIRST_PARM_REG + reg)));\n \n       emit_move_insn (gen_rtx_REG (Pmode, MACL_REG),\n \t\t      stack_pointer_rtx);\n       emit_move_insn (gen_rtx_REG (SImode, R0_REG),\n-\t\t      GEN_INT (current_function_args_info.call_cookie));\n+\t\t      GEN_INT (crtl->args.info.call_cookie));\n       emit_move_insn (gen_rtx_REG (SImode, MACH_REG),\n \t\t      gen_rtx_REG (SImode, R0_REG));\n     }\n@@ -6308,7 +6308,7 @@ sh_expand_prologue (void)\n \t      rtx insn;\n \n \t      if (i >= (NPARM_REGS(SImode)\n-\t\t\t- current_function_args_info.arg_count[(int) SH_ARG_INT]\n+\t\t\t- crtl->args.info.arg_count[(int) SH_ARG_INT]\n \t\t\t))\n \t\tbreak;\n \t      insn = push (rn);\n@@ -6568,7 +6568,7 @@ sh_expand_prologue (void)\n     frame_insn (GEN_MOV (hard_frame_pointer_rtx, stack_pointer_rtx));\n \n   if (TARGET_SHCOMPACT\n-      && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n+      && (crtl->args.info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n     {\n       /* This must NOT go through the PLT, otherwise mach and macl\n \t may be clobbered.  */\n@@ -6837,9 +6837,9 @@ sh_expand_epilogue (bool sibcall_p)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n \n-  output_stack_adjust (current_function_pretend_args_size\n+  output_stack_adjust (crtl->args.pretend_args_size\n \t\t       + save_size + d_rounding\n-\t\t       + current_function_args_info.stack_regs * 8,\n+\t\t       + crtl->args.info.stack_regs * 8,\n \t\t       stack_pointer_rtx, e, NULL);\n \n   if (current_function_calls_eh_return)\n@@ -6956,11 +6956,11 @@ static rtx\n sh_builtin_saveregs (void)\n {\n   /* First unnamed integer register.  */\n-  int first_intreg = current_function_args_info.arg_count[(int) SH_ARG_INT];\n+  int first_intreg = crtl->args.info.arg_count[(int) SH_ARG_INT];\n   /* Number of integer registers we need to save.  */\n   int n_intregs = MAX (0, NPARM_REGS (SImode) - first_intreg);\n   /* First unnamed SFmode float reg */\n-  int first_floatreg = current_function_args_info.arg_count[(int) SH_ARG_FLOAT];\n+  int first_floatreg = crtl->args.info.arg_count[(int) SH_ARG_FLOAT];\n   /* Number of SFmode float regs to save.  */\n   int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n   rtx regbuf, fpregs;\n@@ -6975,25 +6975,25 @@ sh_builtin_saveregs (void)\n \n \t  while (pushregs < NPARM_REGS (SImode) - 1\n \t\t && (CALL_COOKIE_INT_REG_GET\n-\t\t\t(current_function_args_info.call_cookie,\n+\t\t\t(crtl->args.info.call_cookie,\n \t\t\t NPARM_REGS (SImode) - pushregs)\n \t\t     == 1))\n \t    {\n-\t      current_function_args_info.call_cookie\n+\t      crtl->args.info.call_cookie\n \t\t&= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode)\n \t\t\t\t\t  - pushregs, 1);\n \t      pushregs++;\n \t    }\n \n \t  if (pushregs == NPARM_REGS (SImode))\n-\t    current_function_args_info.call_cookie\n+\t    crtl->args.info.call_cookie\n \t      |= (CALL_COOKIE_INT_REG (0, 1)\n \t\t  | CALL_COOKIE_STACKSEQ (pushregs - 1));\n \t  else\n-\t    current_function_args_info.call_cookie\n+\t    crtl->args.info.call_cookie\n \t      |= CALL_COOKIE_STACKSEQ (pushregs);\n \n-\t  current_function_pretend_args_size += 8 * n_intregs;\n+\t  crtl->args.pretend_args_size += 8 * n_intregs;\n \t}\n       if (TARGET_SHCOMPACT)\n \treturn const0_rtx;\n@@ -7191,7 +7191,7 @@ sh_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  nfp = current_function_args_info.arg_count[SH_ARG_FLOAT];\n+  nfp = crtl->args.info.arg_count[SH_ARG_FLOAT];\n   if (nfp < 8)\n     nfp = 8 - nfp;\n   else\n@@ -7206,7 +7206,7 @@ sh_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  nint = current_function_args_info.arg_count[SH_ARG_INT];\n+  nint = crtl->args.info.arg_count[SH_ARG_INT];\n   if (nint < 4)\n     nint = 4 - nint;\n   else\n@@ -7920,11 +7920,11 @@ initial_elimination_offset (int from, int to)\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return total_saved_regs_space + total_auto_space\n-      + current_function_args_info.byref_regs * 8;\n+      + crtl->args.info.byref_regs * 8;\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return total_saved_regs_space + total_auto_space\n-      + current_function_args_info.byref_regs * 8;\n+      + crtl->args.info.byref_regs * 8;\n \n   /* Initial gap between fp and sp is 0.  */\n   if (from == HARD_FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n@@ -9206,7 +9206,7 @@ sh_allocate_initial_value (rtx hard_reg)\n       if (current_function_is_leaf\n \t  && ! sh_pr_n_sets ()\n \t  && ! (TARGET_SHCOMPACT\n-\t\t&& ((current_function_args_info.call_cookie\n+\t\t&& ((crtl->args.info.call_cookie\n \t\t     & ~ CALL_COOKIE_RET_TRAMP (1))\n \t\t    || current_function_saves_all_registers)))\n \tx = hard_reg;\n@@ -9805,7 +9805,7 @@ sh_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   return (1\n \t  && (! TARGET_SHCOMPACT\n-\t      || current_function_args_info.stack_regs == 0)\n+\t      || crtl->args.info.stack_regs == 0)\n \t  && ! sh_cfun_interrupt_handler_p ()\n \t  && (! flag_pic\n \t      || (decl && ! TREE_PUBLIC (decl))\n@@ -10602,7 +10602,7 @@ sh_get_pr_initial_val (void)\n      PR register on SHcompact, because it might be clobbered by the prologue.\n      We check first if that is known to be the case.  */\n   if (TARGET_SHCOMPACT\n-      && ((current_function_args_info.call_cookie\n+      && ((crtl->args.info.call_cookie\n \t   & ~ CALL_COOKIE_RET_TRAMP (1))\n \t  || current_function_saves_all_registers))\n     return gen_frame_mem (SImode, return_address_pointer_rtx);"}, {"sha": "cfcf1b23d1962cdb0c72374df5b60138a6ca0a8a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -9383,7 +9383,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n     }\n \n   if (TARGET_SHCOMPACT\n-      && (current_function_args_info.call_cookie & CALL_COOKIE_RET_TRAMP (1)))\n+      && (crtl->args.info.call_cookie & CALL_COOKIE_RET_TRAMP (1)))\n     {\n       emit_jump_insn (gen_shcompact_return_tramp ());\n       DONE;\n@@ -9393,7 +9393,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n (define_insn \"*return_i\"\n   [(return)]\n   \"TARGET_SH1 && ! (TARGET_SHCOMPACT\n-\t\t    && (current_function_args_info.call_cookie\n+\t\t    && (crtl->args.info.call_cookie\n \t\t\t& CALL_COOKIE_RET_TRAMP (1)))\n    && reload_completed\n    && lookup_attribute (\\\"trap_exit\\\",\n@@ -9420,7 +9420,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n (define_expand \"shcompact_return_tramp\"\n   [(return)]\n   \"TARGET_SHCOMPACT\n-   && (current_function_args_info.call_cookie & CALL_COOKIE_RET_TRAMP (1))\"\n+   && (crtl->args.info.call_cookie & CALL_COOKIE_RET_TRAMP (1))\"\n   \"\n {\n   rtx reg = gen_rtx_REG (Pmode, R0_REG);\n@@ -9433,7 +9433,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n (define_insn \"shcompact_return_tramp_i\"\n   [(parallel [(return) (use (reg:SI R0_REG))])]\n   \"TARGET_SHCOMPACT\n-   && (current_function_args_info.call_cookie & CALL_COOKIE_RET_TRAMP (1))\"\n+   && (crtl->args.info.call_cookie & CALL_COOKIE_RET_TRAMP (1))\"\n   \"jmp\t@r0%#\"\n   [(set_attr \"type\" \"jump_ind\")\n    (set_attr \"needs_delay_slot\" \"yes\")])"}, {"sha": "962ed9fe3bce667a9237112b33a792e845fb7e9b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -3769,7 +3769,7 @@ sparc_init_modes (void)\n HOST_WIDE_INT\n sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n {\n-  int outgoing_args_size = (current_function_outgoing_args_size\n+  int outgoing_args_size = (crtl->outgoing_args_size\n \t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n   int n_regs = 0;  /* N_REGS is the number of 4-byte regs saved thus far.  */\n   int i;\n@@ -3799,7 +3799,7 @@ sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n   if (leaf_function_p\n       && n_regs == 0\n       && size == 0\n-      && current_function_outgoing_args_size == 0)\n+      && crtl->outgoing_args_size == 0)\n     actual_fsize = apparent_fsize = 0;\n   else\n     {\n@@ -5675,7 +5675,7 @@ function_value (const_tree type, enum machine_mode mode, int incoming_p)\n static rtx\n sparc_builtin_saveregs (void)\n {\n-  int first_reg = current_function_args_info.words;\n+  int first_reg = crtl->args.info.words;\n   rtx address;\n   int regno;\n "}, {"sha": "eed016470b1229ad9b177119486ea8667fda4d5b", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1678,7 +1678,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n-  || current_function_calls_alloca || current_function_outgoing_args_size)\n+  || current_function_calls_alloca || crtl->outgoing_args_size)\n \n /* Define registers used by the epilogue and return instruction.  */\n #define EPILOGUE_USES(REGNO) ((REGNO) == 31 \\"}, {"sha": "8096b6fe4fe34e70c29aa8da9d47635ab8d9e8a9", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1686,8 +1686,8 @@ direct_return (void)\n       if (cfun->static_chain_decl == 0\n \t  && (spu_saved_regs_size ()\n \t      + get_frame_size ()\n-\t      + current_function_outgoing_args_size\n-\t      + current_function_pretend_args_size == 0)\n+\t      + crtl->outgoing_args_size\n+\t      + crtl->args.pretend_args_size == 0)\n \t  && current_function_is_leaf)\n \treturn 1;\n     }\n@@ -1705,7 +1705,7 @@ direct_return (void)\n  prev SP | back chain  | \n          +-------------+\n          |  var args   | \n-         |  reg save   | current_function_pretend_args_size bytes\n+         |  reg save   | crtl->args.pretend_args_size bytes\n          +-------------+\n          |    ...      | \n          | saved regs  | spu_saved_regs_size() bytes\n@@ -1715,7 +1715,7 @@ direct_return (void)\n          +-------------+\n          |    ...      | \n          |  outgoing   | \n-         |    args     | current_function_outgoing_args_size bytes\n+         |    args     | crtl->outgoing_args_size bytes\n          +-------------+\n          | $lr of next |\n          |   frame     | \n@@ -1749,8 +1749,8 @@ spu_expand_prologue (void)\n \n   saved_regs_size = spu_saved_regs_size ();\n   total_size = size + saved_regs_size\n-    + current_function_outgoing_args_size\n-    + current_function_pretend_args_size;\n+    + crtl->outgoing_args_size\n+    + crtl->args.pretend_args_size;\n \n   if (!current_function_is_leaf\n       || current_function_calls_alloca || total_size > 0)\n@@ -1766,7 +1766,7 @@ spu_expand_prologue (void)\n \n   if (total_size > 0)\n     {\n-      offset = -current_function_pretend_args_size;\n+      offset = -crtl->args.pretend_args_size;\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n \tif (need_to_save_reg (regno, 1))\n \t  {\n@@ -1840,7 +1840,7 @@ spu_expand_prologue (void)\n \t{\n \t  rtx fp_reg = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n \t  HOST_WIDE_INT fp_offset = STACK_POINTER_OFFSET\n-\t    + current_function_outgoing_args_size;\n+\t    + crtl->outgoing_args_size;\n \t  /* Set the new frame_pointer */\n \t  insn = frame_emit_add_imm (fp_reg, sp_reg, fp_offset, scratch_reg_0);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -1874,8 +1874,8 @@ spu_expand_epilogue (bool sibcall_p)\n \n   saved_regs_size = spu_saved_regs_size ();\n   total_size = size + saved_regs_size\n-    + current_function_outgoing_args_size\n-    + current_function_pretend_args_size;\n+    + crtl->outgoing_args_size\n+    + crtl->args.pretend_args_size;\n \n   if (!current_function_is_leaf\n       || current_function_calls_alloca || total_size > 0)\n@@ -1891,7 +1891,7 @@ spu_expand_epilogue (bool sibcall_p)\n \n       if (saved_regs_size > 0)\n \t{\n-\t  offset = -current_function_pretend_args_size;\n+\t  offset = -crtl->args.pretend_args_size;\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n \t    if (need_to_save_reg (regno, 1))\n \t      {\n@@ -3045,15 +3045,15 @@ spu_initial_elimination_offset (int from, int to)\n {\n   int saved_regs_size = spu_saved_regs_size ();\n   int sp_offset = 0;\n-  if (!current_function_is_leaf || current_function_outgoing_args_size\n+  if (!current_function_is_leaf || crtl->outgoing_args_size\n       || get_frame_size () || saved_regs_size)\n     sp_offset = STACK_POINTER_OFFSET;\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return (sp_offset + current_function_outgoing_args_size);\n+    return (sp_offset + crtl->outgoing_args_size);\n   else if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return 0;\n   else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return sp_offset + current_function_outgoing_args_size\n+    return sp_offset + crtl->outgoing_args_size\n       + get_frame_size () + saved_regs_size + STACK_POINTER_OFFSET;\n   else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return get_frame_size () + saved_regs_size + sp_offset;\n@@ -3211,10 +3211,10 @@ spu_build_builtin_va_list (void)\n    The following global variables are used to initialize\n    the va_list structure:\n \n-     current_function_args_info;\n+     crtl->args.info;\n        the CUMULATIVE_ARGS for this function\n \n-     current_function_arg_offset_rtx:\n+     crtl->args.arg_offset_rtx:\n        holds the offset of the first anonymous stack argument\n        (relative to the virtual arg pointer).  */\n \n@@ -3235,7 +3235,7 @@ spu_va_start (tree valist, rtx nextarg)\n \n   /* Find the __args area.  */\n   t = make_tree (TREE_TYPE (args), nextarg);\n-  if (current_function_pretend_args_size > 0)\n+  if (crtl->args.pretend_args_size > 0)\n     t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (args), t,\n \t\tsize_int (-STACK_POINTER_OFFSET));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, t);\n@@ -3245,7 +3245,7 @@ spu_va_start (tree valist, rtx nextarg)\n   /* Find the __skip area.  */\n   t = make_tree (TREE_TYPE (skip), virtual_incoming_args_rtx);\n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (skip), t,\n-\t      size_int (current_function_pretend_args_size\n+\t      size_int (crtl->args.pretend_args_size\n \t\t\t - STACK_POINTER_OFFSET));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (skip), skip, t);\n   TREE_SIDE_EFFECTS (t) = 1;"}, {"sha": "99aea1ce6603fe468a5e30a7b57f057edfb51895", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1005,13 +1005,13 @@ xstormy16_compute_stack_layout (void)\n \t\t       + layout.register_save_size \n \t\t       + layout.stdarg_save_size);\n   \n-  if (current_function_args_size <= 2048 && current_function_args_size != -1)\n+  if (crtl->args.size <= 2048 && crtl->args.size != -1)\n     {\n       if (layout.frame_size + INCOMING_FRAME_SP_OFFSET \n-\t  + current_function_args_size <= 2048)\n+\t  + crtl->args.size <= 2048)\n \tlayout.fp_minus_ap = layout.frame_size + INCOMING_FRAME_SP_OFFSET;\n       else\n-\tlayout.fp_minus_ap = 2048 - current_function_args_size;\n+\tlayout.fp_minus_ap = 2048 - crtl->args.size;\n     }\n   else\n     layout.fp_minus_ap = (layout.stdarg_save_size \n@@ -1356,7 +1356,7 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (count), count, \n \t      build_int_cst (NULL_TREE,\n-\t\t\t     current_function_args_info * UNITS_PER_WORD));\n+\t\t\t     crtl->args.info * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }"}, {"sha": "c99841a31a44b17385439dec679b5ec03fc93553", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1488,7 +1488,7 @@ compute_frame_size (int size, long * p_reg_saved)\n {\n   return (size\n \t  + compute_register_save_size (p_reg_saved)\n-\t  + current_function_outgoing_args_size);\n+\t  + crtl->outgoing_args_size);\n }\n \n \f\n@@ -1525,7 +1525,7 @@ expand_prologue (void)\n     }\n \n   /* Save arg registers to the stack if necessary.  */\n-  else if (current_function_args_info.anonymous_args)\n+  else if (crtl->args.info.anonymous_args)\n     {\n       if (TARGET_PROLOG_FUNCTION && TARGET_V850E && !TARGET_DISABLE_CALLT)\n \temit_insn (gen_save_r6_r9_v850e ());"}, {"sha": "50119c2a197594c124487925591f13a217db5933", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -557,7 +557,7 @@ enum reg_class\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n-    (OFFSET) = get_frame_size () + current_function_outgoing_args_size;\t\\\n+    (OFFSET) = get_frame_size () + crtl->outgoing_args_size;\t\\\n   else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n    (OFFSET) = compute_frame_size (get_frame_size (), (long *)0);\t\\\n   else\t\t\t\t\t\t\t\t\t\\"}, {"sha": "a5ca463524889aa2a9cf11cae50aa90945c60a0d", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -2292,7 +2292,7 @@ compute_frame_size (int size)\n \n   xtensa_current_frame_size =\n     XTENSA_STACK_ALIGN (size\n-\t\t\t+ current_function_outgoing_args_size\n+\t\t\t+ crtl->outgoing_args_size\n \t\t\t+ (WINDOW_SIZE * UNITS_PER_WORD));\n   return xtensa_current_frame_size;\n }\n@@ -2485,7 +2485,7 @@ static rtx\n xtensa_builtin_saveregs (void)\n {\n   rtx gp_regs;\n-  int arg_words = current_function_args_info.arg_words;\n+  int arg_words = crtl->args.info.arg_words;\n   int gp_left = MAX_ARGS_IN_REGISTERS - arg_words;\n \n   if (gp_left <= 0)\n@@ -2522,7 +2522,7 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   tree t, u;\n   int arg_words;\n \n-  arg_words = current_function_args_info.arg_words;\n+  arg_words = crtl->args.info.arg_words;\n \n   f_stk = TYPE_FIELDS (va_list_type_node);\n   f_reg = TREE_CHAIN (f_stk);\n@@ -2868,7 +2868,7 @@ order_regs_for_local_alloc (void)\n \n       /* Use the AR registers in increasing order (skipping a0 and a1)\n \t but save the incoming argument registers for a last resort.  */\n-      num_arg_regs = current_function_args_info.arg_words;\n+      num_arg_regs = crtl->args.info.arg_words;\n       if (num_arg_regs > MAX_ARGS_IN_REGISTERS)\n \tnum_arg_regs = MAX_ARGS_IN_REGISTERS;\n       for (i = GP_ARG_FIRST; i < 16 - num_arg_regs; i++)"}, {"sha": "b78b25f5aa868a4bdf4cb0bf73a1cf761ee169dd", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -525,7 +525,7 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n \n /* Offset within stack frame to start allocating local variables at.  */\n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n-  current_function_outgoing_args_size\n+  crtl->outgoing_args_size\n \n /* The ARG_POINTER and FRAME_POINTER are not real Xtensa registers, so\n    they are eliminated to either the stack pointer or hard frame pointer.  */\n@@ -556,7 +556,7 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n \n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n-   'current_function_outgoing_args_size'.  No space will be pushed\n+   'crtl->outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue\n    should increase the stack frame size by this amount.  */\n #define ACCUMULATE_OUTGOING_ARGS 1"}, {"sha": "0d30427eeae18f3624a47caa5e130e5faf31f7fe", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -931,11 +931,11 @@ dbxout_function_end (tree decl)\n   if (flag_reorder_blocks_and_partition)\n     {\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (cfun->hot_section_end_label, \n-\t\t\t\t    cfun->hot_section_label);\n+      dbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label, \n+\t\t\t\t    crtl->subsections.hot_section_label);\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (cfun->cold_section_end_label, \n-\t\t\t\t    cfun->cold_section_label);\n+      dbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label, \n+\t\t\t\t    crtl->subsections.cold_section_label);\n     }\n   else\n     {"}, {"sha": "f50097ac26c048c27353e07be24091a8062f70e2", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -3230,7 +3230,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t  && (!is_sibling_call\n \t      || !bitmap_bit_p (df->exit_block_uses, ui)\n \t      || refers_to_regno_p (ui, ui+1, \n-\t\t\t\t    current_function_return_rtx, NULL)))\n+\t\t\t\t    crtl->return_rtx, NULL)))\n         df_ref_record (collection_rec, regno_reg_rtx[ui], \n \t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags, -1, -1);\n     }"}, {"sha": "2d8736de0fca320f7c4546c26e99e69b83c676b8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -2744,10 +2744,10 @@ dwarf2out_switch_text_section (void)\n \n   fde = &fde_table[fde_table_in_use - 1];\n   fde->dw_fde_switched_sections = true;\n-  fde->dw_fde_hot_section_label = cfun->hot_section_label;\n-  fde->dw_fde_hot_section_end_label = cfun->hot_section_end_label;\n-  fde->dw_fde_unlikely_section_label = cfun->cold_section_label;\n-  fde->dw_fde_unlikely_section_end_label = cfun->cold_section_end_label;\n+  fde->dw_fde_hot_section_label = crtl->subsections.hot_section_label;\n+  fde->dw_fde_hot_section_end_label = crtl->subsections.hot_section_end_label;\n+  fde->dw_fde_unlikely_section_label = crtl->subsections.cold_section_label;\n+  fde->dw_fde_unlikely_section_end_label = crtl->subsections.cold_section_end_label;\n   have_multiple_function_sections = true;\n \n   /* Reset the current label on switching text sections, so that we\n@@ -8222,7 +8222,7 @@ output_line_info (void)\n   current_line = 1;\n \n   if (cfun && in_cold_section_p)\n-    strcpy (prev_line_label, cfun->cold_section_label);\n+    strcpy (prev_line_label, crtl->subsections.cold_section_label);\n   else\n     strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n@@ -10792,7 +10792,7 @@ secname_for_decl (const_tree decl)\n       secname = TREE_STRING_POINTER (sectree);\n     }\n   else if (cfun && in_cold_section_p)\n-    secname = cfun->cold_section_label;\n+    secname = crtl->subsections.cold_section_label;\n   else\n     secname = text_section_label;\n \n@@ -14611,7 +14611,7 @@ dwarf2out_var_location (rtx loc_note)\n   newloc->next = NULL;\n \n   if (cfun && in_cold_section_p)\n-    newloc->section_label = cfun->cold_section_label;\n+    newloc->section_label = crtl->subsections.cold_section_label;\n   else\n     newloc->section_label = text_section_label;\n "}, {"sha": "6a2e98728eee52b02538fca03bac2a905c29da6c", "filename": "gcc/function.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -289,9 +289,6 @@ free_after_compilation (struct function *f)\n   f->machine = NULL;\n   f->cfg = NULL;\n \n-  f->arg_offset_rtx = NULL;\n-  f->return_rtx = NULL;\n-  f->internal_arg_pointer = NULL;\n   f->epilogue_delay_list = NULL;\n }\n \f\n@@ -1143,18 +1140,18 @@ static int cfa_offset;\n    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,\n    stack space for register parameters is not pushed by the caller, but\n    rather part of the fixed stack areas and hence not included in\n-   `current_function_outgoing_args_size'.  Nevertheless, we must allow\n+   `crtl->outgoing_args_size'.  Nevertheless, we must allow\n    for it when allocating stack dynamic objects.  */\n \n #if defined(REG_PARM_STACK_SPACE)\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n ((ACCUMULATE_OUTGOING_ARGS\t\t\t\t\t\t      \\\n-  ? (current_function_outgoing_args_size\t\t\t\t      \\\n+  ? (crtl->outgoing_args_size\t\t\t\t      \\\n      + (OUTGOING_REG_PARM_STACK_SPACE ? 0 : REG_PARM_STACK_SPACE (FNDECL)))   \\\n   : 0) + (STACK_POINTER_OFFSET))\n #else\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)\t      \\\n+((ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0)\t      \\\n  + (STACK_POINTER_OFFSET))\n #endif\n #endif\n@@ -2263,7 +2260,7 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n   else\n     offset_rtx = ARGS_SIZE_RTX (data->locate.offset);\n \n-  stack_parm = current_function_internal_arg_pointer;\n+  stack_parm = crtl->args.internal_arg_pointer;\n   if (offset_rtx != const0_rtx)\n     stack_parm = gen_rtx_PLUS (Pmode, stack_parm, offset_rtx);\n   stack_parm = gen_rtx_MEM (data->promoted_mode, stack_parm);\n@@ -2949,7 +2946,7 @@ assign_parms (tree fndecl)\n   struct assign_parm_data_all all;\n   tree fnargs, parm;\n \n-  current_function_internal_arg_pointer\n+  crtl->args.internal_arg_pointer\n     = targetm.calls.internal_arg_pointer ();\n \n   assign_parms_initialize_all (&all);\n@@ -3029,48 +3026,48 @@ assign_parms (tree fndecl)\n     }\n \n   /* We have aligned all the args, so add space for the pretend args.  */\n-  current_function_pretend_args_size = all.pretend_args_size;\n+  crtl->args.pretend_args_size = all.pretend_args_size;\n   all.stack_args_size.constant += all.extra_pretend_bytes;\n-  current_function_args_size = all.stack_args_size.constant;\n+  crtl->args.size = all.stack_args_size.constant;\n \n   /* Adjust function incoming argument size for alignment and\n      minimum length.  */\n \n #ifdef REG_PARM_STACK_SPACE\n-  current_function_args_size = MAX (current_function_args_size,\n+  crtl->args.size = MAX (crtl->args.size,\n \t\t\t\t    REG_PARM_STACK_SPACE (fndecl));\n #endif\n \n-  current_function_args_size = CEIL_ROUND (current_function_args_size,\n+  crtl->args.size = CEIL_ROUND (crtl->args.size,\n \t\t\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n \n #ifdef ARGS_GROW_DOWNWARD\n-  current_function_arg_offset_rtx\n+  crtl->args.arg_offset_rtx\n     = (all.stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n        : expand_expr (size_diffop (all.stack_args_size.var,\n \t\t\t\t   size_int (-all.stack_args_size.constant)),\n \t\t      NULL_RTX, VOIDmode, 0));\n #else\n-  current_function_arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n+  crtl->args.arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n #endif\n \n   /* See how many bytes, if any, of its args a function should try to pop\n      on return.  */\n \n-  current_function_pops_args = RETURN_POPS_ARGS (fndecl, TREE_TYPE (fndecl),\n-\t\t\t\t\t\t current_function_args_size);\n+  crtl->args.pops_args = RETURN_POPS_ARGS (fndecl, TREE_TYPE (fndecl),\n+\t\t\t\t\t\t crtl->args.size);\n \n   /* For stdarg.h function, save info about\n      regs and stack space used by the named args.  */\n \n-  current_function_args_info = all.args_so_far;\n+  crtl->args.info = all.args_so_far;\n \n   /* Set the rtx used for the function return value.  Put this in its\n      own variable so any optimizers that need this information don't have\n      to include tree.h.  Do this here so it gets done when an inlined\n      function gets output.  */\n \n-  current_function_return_rtx\n+  crtl->return_rtx\n     = (DECL_RTL_SET_P (DECL_RESULT (fndecl))\n        ? DECL_RTL (DECL_RESULT (fndecl)) : NULL_RTX);\n \n@@ -3091,10 +3088,10 @@ assign_parms (tree fndecl)\n \t  real_decl_rtl = targetm.calls.function_value (TREE_TYPE (decl_result),\n \t\t\t\t\t\t\tfndecl, true);\n \t  REG_FUNCTION_VALUE_P (real_decl_rtl) = 1;\n-\t  /* The delay slot scheduler assumes that current_function_return_rtx\n+\t  /* The delay slot scheduler assumes that crtl->return_rtx\n \t     holds the hard register containing the return value, not a\n \t     temporary pseudo.  */\n-\t  current_function_return_rtx = real_decl_rtl;\n+\t  crtl->return_rtx = real_decl_rtl;\n \t}\n     }\n }\n@@ -4291,7 +4288,7 @@ expand_dummy_function_end (void)\n void\n diddle_return_value (void (*doit) (rtx, void *), void *arg)\n {\n-  rtx outgoing = current_function_return_rtx;\n+  rtx outgoing = crtl->return_rtx;\n \n   if (! outgoing)\n     return;\n@@ -4452,15 +4449,15 @@ expand_function_end (void)\n \t  ? REGNO (decl_rtl) >= FIRST_PSEUDO_REGISTER\n \t  : DECL_REGISTER (decl_result))\n \t{\n-\t  rtx real_decl_rtl = current_function_return_rtx;\n+\t  rtx real_decl_rtl = crtl->return_rtx;\n \n \t  /* This should be set in assign_parms.  */\n \t  gcc_assert (REG_FUNCTION_VALUE_P (real_decl_rtl));\n \n \t  /* If this is a BLKmode structure being returned in registers,\n \t     then use the mode computed in expand_return.  Note that if\n \t     decl_rtl is memory, then its mode may have been changed,\n-\t     but that current_function_return_rtx has not.  */\n+\t     but that crtl->return_rtx has not.  */\n \t  if (GET_MODE (real_decl_rtl) == BLKmode)\n \t    PUT_MODE (real_decl_rtl, GET_MODE (decl_rtl));\n \n@@ -4557,7 +4554,7 @@ expand_function_end (void)\n \n       /* Show return register used to hold result (in this case the address\n \t of the result.  */\n-      current_function_return_rtx = outgoing;\n+      crtl->return_rtx = outgoing;\n     }\n \n   /* Emit the actual code to clobber return register.  */"}, {"sha": "edc7216e7519e702f9d45c1a1320443491e896e7", "filename": "gcc/function.h", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -171,12 +171,78 @@ struct varasm_status GTY(())\n   unsigned int deferred_constants;\n };\n \n+/* Information mainlined about RTL representation of incoming arguments.  */\n+struct incoming_args GTY(())\n+{\n+  /* Number of bytes of args popped by function being compiled on its return.\n+     Zero if no bytes are to be popped.\n+     May affect compilation of return insn or of function epilogue.  */\n+  int pops_args;\n+\n+  /* If function's args have a fixed size, this is that size, in bytes.\n+     Otherwise, it is -1.\n+     May affect compilation of return insn or of function epilogue.  */\n+  int size;\n+\n+  /* # bytes the prologue should push and pretend that the caller pushed them.\n+     The prologue must do this, but only if parms can be passed in\n+     registers.  */\n+  int pretend_args_size;\n+\n+  /* This is the offset from the arg pointer to the place where the first\n+     anonymous arg can be found, if there is one.  */\n+  rtx arg_offset_rtx;\n+\n+  /* Quantities of various kinds of registers\n+     used for the current function's args.  */\n+  CUMULATIVE_ARGS info;\n+\n+  /* The arg pointer hard register, or the pseudo into which it was copied.  */\n+  rtx internal_arg_pointer;\n+};\n+\n+/* Data for function partitioning.  */\n+struct function_subsections GTY(())\n+{\n+  /* Assembly labels for the hot and cold text sections, to\n+     be used by debugger functions for determining the size of text\n+     sections.  */\n+\n+  const char *hot_section_label;\n+  const char *cold_section_label;\n+  const char *hot_section_end_label;\n+  const char *cold_section_end_label;\n+\n+  /* String to be used for name of cold text sections, via\n+     targetm.asm_out.named_section.  */\n+\n+  const char *unlikely_text_section_name;\n+};\n+\n /* Datastructures maintained for currently processed function in RTL form.  */\n struct rtl_data GTY(())\n {\n   struct expr_status expr;\n   struct emit_status emit;\n   struct varasm_status varasm;\n+  struct incoming_args args;\n+  struct function_subsections subsections;\n+\n+  /* For function.c  */\n+\n+  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n+     defined, the needed space is pushed by the prologue.  */\n+  int outgoing_args_size;\n+\n+  /* If nonzero, an RTL expression for the location at which the current\n+     function returns its result.  If the current function returns its\n+     result in a register, current_function_return_rtx will always be\n+     the hard register containing the result.  */\n+  rtx return_rtx;\n+\n+  /* Opaque pointer used by get_hard_reg_initial_val and\n+     has_hard_reg_initial_val (see integrate.[hc]).  */\n+  struct initial_value_struct *hard_reg_initial_vals;\n \n   /* List (chain of EXPR_LIST) of labels heading the current handlers for\n      nonlocal gotos.  */\n@@ -222,8 +288,6 @@ struct rtl_data GTY(())\n   /* Current nesting level for temporaries.  */\n   int x_temp_slot_level;\n \n-  /* Highest label number in current function.  */\n-  int inl_max_label_num;\n };\n \n #define return_label (crtl->x_return_label)\n@@ -271,46 +335,6 @@ struct function GTY(())\n   /* Function containing this function, if any.  */\n   struct function *outer;\n \n-  /* Number of bytes of args popped by function being compiled on its return.\n-     Zero if no bytes are to be popped.\n-     May affect compilation of return insn or of function epilogue.  */\n-  int pops_args;\n-\n-  /* If function's args have a fixed size, this is that size, in bytes.\n-     Otherwise, it is -1.\n-     May affect compilation of return insn or of function epilogue.  */\n-  int args_size;\n-\n-  /* # bytes the prologue should push and pretend that the caller pushed them.\n-     The prologue must do this, but only if parms can be passed in\n-     registers.  */\n-  int pretend_args_size;\n-\n-  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n-     defined, the needed space is pushed by the prologue.  */\n-  int outgoing_args_size;\n-\n-  /* This is the offset from the arg pointer to the place where the first\n-     anonymous arg can be found, if there is one.  */\n-  rtx arg_offset_rtx;\n-\n-  /* Quantities of various kinds of registers\n-     used for the current function's args.  */\n-  CUMULATIVE_ARGS args_info;\n-\n-  /* If nonzero, an RTL expression for the location at which the current\n-     function returns its result.  If the current function returns its\n-     result in a register, current_function_return_rtx will always be\n-     the hard register containing the result.  */\n-  rtx return_rtx;\n-\n-  /* The arg pointer hard register, or the pseudo into which it was copied.  */\n-  rtx internal_arg_pointer;\n-\n-  /* Opaque pointer used by get_hard_reg_initial_val and\n-     has_hard_reg_initial_val (see integrate.[hc]).  */\n-  struct initial_value_struct *hard_reg_initial_vals;\n-\n   /* A PARM_DECL that should contain the static chain for this function.\n      It will be initialized at the beginning of the function.  */\n   tree static_chain_decl;\n@@ -359,20 +383,6 @@ struct function GTY(())\n   /* The variables unexpanded so far.  */\n   tree unexpanded_var_list;\n \n-  /* Assembly labels for the hot and cold text sections, to\n-     be used by debugger functions for determining the size of text\n-     sections.  */\n-\n-  const char *hot_section_label;\n-  const char *cold_section_label;\n-  const char *hot_section_end_label;\n-  const char *cold_section_end_label;\n-\n-  /* String to be used for name of cold text sections, via\n-     targetm.asm_out.named_section.  */\n-\n-  const char *unlikely_text_section_name;\n-\n   /* A variable living at the top of the frame that holds a known value.\n      Used for detecting stack clobbers.  */\n   tree stack_protect_guard;\n@@ -530,22 +540,14 @@ extern void pop_cfun (void);\n extern void instantiate_decl_rtl (rtx x);\n \n /* For backward compatibility... eventually these should all go away.  */\n-#define current_function_pops_args (cfun->pops_args)\n #define current_function_returns_struct (cfun->returns_struct)\n #define current_function_returns_pcc_struct (cfun->returns_pcc_struct)\n #define current_function_calls_setjmp (cfun->calls_setjmp)\n #define current_function_calls_alloca (cfun->calls_alloca)\n #define current_function_accesses_prior_frames (cfun->accesses_prior_frames)\n #define current_function_calls_eh_return (cfun->calls_eh_return)\n #define current_function_is_thunk (cfun->is_thunk)\n-#define current_function_args_info (cfun->args_info)\n-#define current_function_args_size (cfun->args_size)\n-#define current_function_pretend_args_size (cfun->pretend_args_size)\n-#define current_function_outgoing_args_size (cfun->outgoing_args_size)\n-#define current_function_arg_offset_rtx (cfun->arg_offset_rtx)\n #define current_function_stdarg (cfun->stdarg)\n-#define current_function_internal_arg_pointer (cfun->internal_arg_pointer)\n-#define current_function_return_rtx (cfun->return_rtx)\n #define current_function_profile (cfun->profile)\n #define current_function_funcdef_no (cfun->funcdef_no)\n #define current_function_limit_stack (cfun->limit_stack)"}, {"sha": "4ed42ef896a281d5bc8f213d9d9bb20e1278ce6e", "filename": "gcc/integrate.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -206,9 +206,9 @@ set_decl_abstract_flags (tree decl, int setting)\n    the function.  */\n \n rtx\n-get_hard_reg_initial_reg (struct function *fun, rtx reg)\n+get_hard_reg_initial_reg (rtx reg)\n {\n-  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n+  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n   int i;\n \n   if (ivs == 0)\n@@ -234,14 +234,14 @@ get_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n   if (rv)\n     return rv;\n \n-  ivs = cfun->hard_reg_initial_vals;\n+  ivs = crtl->hard_reg_initial_vals;\n   if (ivs == 0)\n     {\n       ivs = ggc_alloc (sizeof (initial_value_struct));\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n       ivs->entries = ggc_alloc (5 * sizeof (initial_value_pair));\n-      cfun->hard_reg_initial_vals = ivs;\n+      crtl->hard_reg_initial_vals = ivs;\n     }\n \n   if (ivs->num_entries >= ivs->max_entries)\n@@ -268,7 +268,7 @@ has_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n   struct initial_value_struct *ivs;\n   int i;\n \n-  ivs = cfun->hard_reg_initial_vals;\n+  ivs = crtl->hard_reg_initial_vals;\n   if (ivs != 0)\n     for (i = 0; i < ivs->num_entries; i++)\n       if (GET_MODE (ivs->entries[i].hard_reg) == mode\n@@ -281,7 +281,7 @@ has_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n unsigned int\n emit_initial_value_sets (void)\n {\n-  struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n+  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n   int i;\n   rtx seq;\n \n@@ -324,7 +324,7 @@ allocate_initial_values (rtx *reg_equiv_memory_loc)\n {\n   if (targetm.allocate_initial_value)\n     {\n-      struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n+      struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n       int i;\n \n       if (ivs == 0)"}, {"sha": "9651a997469f491b1ec193fdc7ae0c08b0425c7b", "filename": "gcc/integrate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -24,7 +24,7 @@ extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);\n extern rtx has_hard_reg_initial_val (enum machine_mode, unsigned int);\n /* If a pseudo represents an initial hard reg (or expression), return\n    it, else return NULL_RTX.  */\n-extern rtx get_hard_reg_initial_reg (struct function *, rtx);\n+extern rtx get_hard_reg_initial_reg (rtx);\n /* Called from rest_of_compilation.  */\n extern unsigned int emit_initial_value_sets (void);\n extern void allocate_initial_values (rtx *);"}, {"sha": "33e5a297c1d190deeb8fb1f59548597b93976181", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1415,7 +1415,7 @@ block_alloc (int b)\n \n \t\t  /* Avoid making a call-saved register unnecessarily\n                      clobbered.  */\n-\t\t  hard_reg = get_hard_reg_initial_reg (cfun, r1);\n+\t\t  hard_reg = get_hard_reg_initial_reg (r1);\n \t\t  if (hard_reg != NULL_RTX)\n \t\t    {\n \t\t      if (REG_P (hard_reg)"}, {"sha": "05308491f61fe10e71ab733e3b3858dde3a707d8", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -1150,8 +1150,8 @@ init_resource_info (rtx epilogue_insn)\n   else\n     SET_HARD_REG_BIT (end_of_function_needs.regs, STACK_POINTER_REGNUM);\n \n-  if (current_function_return_rtx != 0)\n-    mark_referenced_resources (current_function_return_rtx,\n+  if (crtl->return_rtx != 0)\n+    mark_referenced_resources (crtl->return_rtx,\n \t\t\t       &end_of_function_needs, 1);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)"}, {"sha": "b3d3bb1ce75f24bf165b5e9ece7ee08ce608288a", "filename": "gcc/varasm.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38173d38cc4d944f209f1b2e0101fb176ac21e84/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=38173d38cc4d944f209f1b2e0101fb176ac21e84", "patch": "@@ -611,7 +611,7 @@ initialize_cold_section_name (void)\n   tree dsn;\n \n   gcc_assert (cfun && current_function_decl);\n-  if (cfun->unlikely_text_section_name)\n+  if (crtl->subsections.unlikely_text_section_name)\n     return;\n \n   dsn = DECL_SECTION_NAME (current_function_decl);\n@@ -623,10 +623,10 @@ initialize_cold_section_name (void)\n       stripped_name = targetm.strip_name_encoding (name);\n \n       buffer = ACONCAT ((stripped_name, \"_unlikely\", NULL));\n-      cfun->unlikely_text_section_name = ggc_strdup (buffer);\n+      crtl->subsections.unlikely_text_section_name = ggc_strdup (buffer);\n     }\n   else\n-    cfun->unlikely_text_section_name =  UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n+    crtl->subsections.unlikely_text_section_name =  UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n }\n \n /* Tell assembler to switch to unlikely-to-be-executed text section.  */\n@@ -636,10 +636,10 @@ unlikely_text_section (void)\n {\n   if (cfun)\n     {\n-      if (!cfun->unlikely_text_section_name)\n+      if (!crtl->subsections.unlikely_text_section_name)\n \tinitialize_cold_section_name ();\n \n-      return get_named_section (NULL, cfun->unlikely_text_section_name, 0);\n+      return get_named_section (NULL, crtl->subsections.unlikely_text_section_name, 0);\n     }\n   else\n     return get_named_section (NULL, UNLIKELY_EXECUTED_TEXT_SECTION_NAME, 0);\n@@ -656,7 +656,7 @@ unlikely_text_section_p (section *sect)\n   const char *name;\n \n   if (cfun)\n-    name = cfun->unlikely_text_section_name;\n+    name = crtl->subsections.unlikely_text_section_name;\n   else\n     name = UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n \n@@ -1587,27 +1587,27 @@ assemble_start_function (tree decl, const char *fnname)\n   char tmp_label[100];\n   bool hot_label_written = false;\n \n-  cfun->unlikely_text_section_name = NULL;\n+  crtl->subsections.unlikely_text_section_name = NULL;\n \n   first_function_block_is_cold = false;\n   if (flag_reorder_blocks_and_partition)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"LHOTB\", const_labelno);\n-      cfun->hot_section_label = ggc_strdup (tmp_label);\n+      crtl->subsections.hot_section_label = ggc_strdup (tmp_label);\n       ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"LCOLDB\", const_labelno);\n-      cfun->cold_section_label = ggc_strdup (tmp_label);\n+      crtl->subsections.cold_section_label = ggc_strdup (tmp_label);\n       ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"LHOTE\", const_labelno);\n-      cfun->hot_section_end_label = ggc_strdup (tmp_label);\n+      crtl->subsections.hot_section_end_label = ggc_strdup (tmp_label);\n       ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"LCOLDE\", const_labelno);\n-      cfun->cold_section_end_label = ggc_strdup (tmp_label);\n+      crtl->subsections.cold_section_end_label = ggc_strdup (tmp_label);\n       const_labelno++;\n     }\n   else\n     {\n-      cfun->hot_section_label = NULL;\n-      cfun->cold_section_label = NULL;\n-      cfun->hot_section_end_label = NULL;\n-      cfun->cold_section_end_label = NULL;\n+      crtl->subsections.hot_section_label = NULL;\n+      crtl->subsections.cold_section_label = NULL;\n+      crtl->subsections.hot_section_end_label = NULL;\n+      crtl->subsections.cold_section_end_label = NULL;\n     }\n \n   /* The following code does not need preprocessing in the assembler.  */\n@@ -1628,7 +1628,7 @@ assemble_start_function (tree decl, const char *fnname)\n     {\n       switch_to_section (unlikely_text_section ());\n       assemble_align (DECL_ALIGN (decl));\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_label);\n+      ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.cold_section_label);\n \n       /* When the function starts with a cold section, we need to explicitly\n \t align the hot section and write out the hot section label.\n@@ -1638,7 +1638,7 @@ assemble_start_function (tree decl, const char *fnname)\n \t{\n \t  switch_to_section (text_section);\n \t  assemble_align (DECL_ALIGN (decl));\n-\t  ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_label);\n \t  hot_label_written = true;\n \t  first_function_block_is_cold = true;\n \t}\n@@ -1652,9 +1652,9 @@ assemble_start_function (tree decl, const char *fnname)\n \n       initialize_cold_section_name ();\n \n-      if (cfun->unlikely_text_section_name\n+      if (crtl->subsections.unlikely_text_section_name\n \t  && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t     cfun->unlikely_text_section_name) == 0)\n+\t\t     crtl->subsections.unlikely_text_section_name) == 0)\n \tfirst_function_block_is_cold = true;\n     }\n \n@@ -1665,7 +1665,7 @@ assemble_start_function (tree decl, const char *fnname)\n   switch_to_section (function_section (decl));\n   if (flag_reorder_blocks_and_partition\n       && !hot_label_written)\n-    ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n+    ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_label);\n \n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT);\n@@ -1743,12 +1743,12 @@ assemble_end_function (tree decl, const char *fnname ATTRIBUTE_UNUSED)\n \n       save_text_section = in_section;\n       switch_to_section (unlikely_text_section ());\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_end_label);\n+      ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.cold_section_end_label);\n       if (first_function_block_is_cold)\n \tswitch_to_section (text_section);\n       else\n \tswitch_to_section (function_section (decl));\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_end_label);\n+      ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_end_label);\n       switch_to_section (save_text_section);\n     }\n }\n@@ -5540,8 +5540,8 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n     flags = 0;\n   else if (current_function_decl\n \t   && cfun\n-\t   && cfun->unlikely_text_section_name\n-\t   && strcmp (name, cfun->unlikely_text_section_name) == 0)\n+\t   && crtl->subsections.unlikely_text_section_name\n+\t   && strcmp (name, crtl->subsections.unlikely_text_section_name) == 0)\n     flags = SECTION_CODE;\n   else if (!decl\n \t   && (!current_function_decl || !cfun)\n@@ -6316,10 +6316,10 @@ switch_to_section (section *new_section)\n     {\n     case SECTION_NAMED:\n       if (cfun\n-\t  && !cfun->unlikely_text_section_name\n+\t  && !crtl->subsections.unlikely_text_section_name\n \t  && strcmp (new_section->named.name,\n \t\t     UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n-\tcfun->unlikely_text_section_name = UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n+\tcrtl->subsections.unlikely_text_section_name = UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n \n       targetm.asm_out.named_section (new_section->named.name,\n \t\t\t\t     new_section->named.common.flags,"}]}