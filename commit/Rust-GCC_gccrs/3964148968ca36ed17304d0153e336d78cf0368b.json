{"sha": "3964148968ca36ed17304d0153e336d78cf0368b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2NDE0ODk2OGNhMzZlZDE3MzA0ZDAxNTNlMzM2ZDc4Y2YwMzY4Yg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2007-09-27T11:29:10Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-09-27T11:29:10Z"}, "message": "simplify-rtx.c (comparison_result): New.\n\n2007-09-04  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* simplify-rtx.c (comparison_result): New.\n\t(simplify_const_relational_operation): Use it instead of the five\n\t\"equal|op[01]ltu?\" variables; consequently remove redundant \"else\"s.\n\tImprove bounds-checking optimizations; remove subsumed POPCOUNT\n\toptimizations.  Extract nonzero_address_p optimizations into a\n\tseparate \"if\" together with optimizations where op1 is const0_rtx.\n\tOptimize comparing an IOR with zero.  Simplify op0 RELOP op0 for\n\tfloating-point arguments too when appropriate.  Hoist test for ABS\n\toutside the final switch statement.\n\t* cse.c (fold_rtx): Don't look for an IOR equivalent of\n\tfolded_arg0 if we found a constant equivalent.\tRemove\n\ttransformations done in simplify-rtx.c for \"op0 RELOP op0\".\n\nFrom-SVN: r128833", "tree": {"sha": "23a8d0eec53000f05fefd8da7b1e7706f47ec2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23a8d0eec53000f05fefd8da7b1e7706f47ec2f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3964148968ca36ed17304d0153e336d78cf0368b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3964148968ca36ed17304d0153e336d78cf0368b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3964148968ca36ed17304d0153e336d78cf0368b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3964148968ca36ed17304d0153e336d78cf0368b/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6208170481d560900fd19e3b393c746fd8c0a6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6208170481d560900fd19e3b393c746fd8c0a6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6208170481d560900fd19e3b393c746fd8c0a6e2"}], "stats": {"total": 515, "additions": 288, "deletions": 227}, "files": [{"sha": "6c177147c26686c907cb55c56fede45859e309ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3964148968ca36ed17304d0153e336d78cf0368b", "patch": "@@ -1,3 +1,18 @@\n+2007-09-04  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* simplify-rtx.c (comparison_result): New.\n+\t(simplify_const_relational_operation): Use it instead of the five\n+\t\"equal|op[01]ltu?\" variables; consequently remove redundant \"else\"s.\n+\tImprove bounds-checking optimizations; remove subsumed POPCOUNT\n+\toptimizations.  Extract nonzero_address_p optimizations into a\n+\tseparate \"if\" together with optimizations where op1 is const0_rtx.\n+\tOptimize comparing an IOR with zero.  Simplify op0 RELOP op0 for\n+\tfloating-point arguments too when appropriate.  Hoist test for ABS\n+\toutside the final switch statement.\n+\t* cse.c (fold_rtx): Don't look for an IOR equivalent of\n+\tfolded_arg0 if we found a constant equivalent.\tRemove\n+\ttransformations done in simplify-rtx.c for \"op0 RELOP op0\".\n+\n 2007-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* builtins.c (expand_builtin, expand_builtin_object_size,"}, {"sha": "21846f308d60cc5e71623a875eeed9b9c4797318", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 66, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=3964148968ca36ed17304d0153e336d78cf0368b", "patch": "@@ -3252,45 +3252,20 @@ fold_rtx (rtx x, rtx insn)\n \t\t    }\n \t\t}\n \n-\t      /* Some addresses are known to be nonzero.  We don't know\n-\t\t their sign, but equality comparisons are known.  */\n-\t      if (const_arg1 == const0_rtx\n-\t\t  && nonzero_address_p (folded_arg0))\n-\t\t{\n-\t\t  if (code == EQ)\n-\t\t    return false_rtx;\n-\t\t  else if (code == NE)\n-\t\t    return true_rtx;\n-\t\t}\n-\n \t      /* See if the two operands are the same.  */\n \n-\t      if (folded_arg0 == folded_arg1\n-\t\t  || (REG_P (folded_arg0)\n-\t\t      && REG_P (folded_arg1)\n-\t\t      && (REG_QTY (REGNO (folded_arg0))\n-\t\t\t  == REG_QTY (REGNO (folded_arg1))))\n+\t      if ((REG_P (folded_arg0)\n+\t\t   && REG_P (folded_arg1)\n+\t\t   && (REG_QTY (REGNO (folded_arg0))\n+\t\t       == REG_QTY (REGNO (folded_arg1))))\n \t\t  || ((p0 = lookup (folded_arg0,\n \t\t\t\t    SAFE_HASH (folded_arg0, mode_arg0),\n \t\t\t\t    mode_arg0))\n \t\t      && (p1 = lookup (folded_arg1,\n \t\t\t\t       SAFE_HASH (folded_arg1, mode_arg0),\n \t\t\t\t       mode_arg0))\n \t\t      && p0->first_same_value == p1->first_same_value))\n-\t\t{\n-\t\t  /* Sadly two equal NaNs are not equivalent.  */\n-\t\t  if (!HONOR_NANS (mode_arg0))\n-\t\t    return ((code == EQ || code == LE || code == GE\n-\t\t\t     || code == LEU || code == GEU || code == UNEQ\n-\t\t\t     || code == UNLE || code == UNGE\n-\t\t\t     || code == ORDERED)\n-\t\t\t    ? true_rtx : false_rtx);\n-\t\t  /* Take care for the FP compares we can resolve.  */\n-\t\t  if (code == UNEQ || code == UNLE || code == UNGE)\n-\t\t    return true_rtx;\n-\t\t  if (code == LTGT || code == LT || code == GT)\n-\t\t    return false_rtx;\n-\t\t}\n+\t\tfolded_arg1 = folded_arg0;\n \n \t      /* If FOLDED_ARG0 is a register, see if the comparison we are\n \t\t doing now is either the same as we did before or the reverse\n@@ -3323,8 +3298,7 @@ fold_rtx (rtx x, rtx insn)\n       /* If we are comparing against zero, see if the first operand is\n \t equivalent to an IOR with a constant.  If so, we may be able to\n \t determine the result of this comparison.  */\n-\n-      if (const_arg1 == const0_rtx)\n+      if (const_arg1 == const0_rtx && !const_arg0)\n \t{\n \t  rtx y = lookup_as_function (folded_arg0, IOR);\n \t  rtx inner_const;\n@@ -3333,40 +3307,7 @@ fold_rtx (rtx x, rtx insn)\n \t      && (inner_const = equiv_constant (XEXP (y, 1))) != 0\n \t      && GET_CODE (inner_const) == CONST_INT\n \t      && INTVAL (inner_const) != 0)\n-\t    {\n-\t      int sign_bitnum = GET_MODE_BITSIZE (mode_arg0) - 1;\n-\t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n-\t\t\t      && (INTVAL (inner_const)\n-\t\t\t\t  & ((HOST_WIDE_INT) 1 << sign_bitnum)));\n-\t      rtx true_rtx = const_true_rtx, false_rtx = const0_rtx;\n-\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-\t      if (SCALAR_FLOAT_MODE_P (mode))\n-\t\t{\n-\t\t  true_rtx = (CONST_DOUBLE_FROM_REAL_VALUE\n-\t\t\t  (FLOAT_STORE_FLAG_VALUE (mode), mode));\n-\t\t  false_rtx = CONST0_RTX (mode);\n-\t\t}\n-#endif\n-\n-\t      switch (code)\n-\t\t{\n-\t\tcase EQ:\n-\t\t  return false_rtx;\n-\t\tcase NE:\n-\t\t  return true_rtx;\n-\t\tcase LT:  case LE:\n-\t\t  if (has_sign)\n-\t\t    return true_rtx;\n-\t\t  break;\n-\t\tcase GT:  case GE:\n-\t\t  if (has_sign)\n-\t\t    return false_rtx;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t    folded_arg0 = gen_rtx_IOR (mode_arg0, XEXP (y, 0), inner_const);\n \t}\n \n       {"}, {"sha": "3c947bcd885591219edcfa5c014ed78029325790", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 266, "deletions": 161, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3964148968ca36ed17304d0153e336d78cf0368b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3964148968ca36ed17304d0153e336d78cf0368b", "patch": "@@ -3952,6 +3952,69 @@ simplify_relational_operation_1 (enum rtx_code code, enum machine_mode mode,\n   return NULL_RTX;\n }\n \n+enum \n+{\n+  CR_EQ = 1,\n+  CR_LT = 2,\n+  CR_GT = 4,\n+  CR_LTU = 8,\n+  CR_GTU = 16\n+};\n+\n+\n+/* Convert the known results for EQ, LT, GT, LTU, GTU contained in\n+   KNOWN_RESULT to a CONST_INT, based on the requested comparison CODE\n+   For KNOWN_RESULT to make sense it should be either CR_EQ, or the \n+   logical OR of one of (CR_LT, CR_GT) and one of (CR_LTU, CR_GTU).\n+   For floating-point comparisons, assume that the operands were ordered.  */\n+\n+static rtx\n+comparison_result (enum rtx_code code, int known_results)\n+{\n+  /* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set\n+     as appropriate.  */\n+  switch (code)\n+    {\n+    case EQ:\n+    case UNEQ:\n+      return (known_results & CR_EQ) ? const_true_rtx : const0_rtx;\n+    case NE:\n+    case LTGT:\n+      return (known_results & CR_EQ) ? const0_rtx : const_true_rtx;\n+\n+    case LT:\n+    case UNLT:\n+      return (known_results & CR_LT) ? const_true_rtx : const0_rtx;\n+    case GE:\n+    case UNGE:\n+      return (known_results & CR_LT) ? const0_rtx : const_true_rtx;\n+\n+    case GT:\n+    case UNGT:\n+      return (known_results & CR_GT) ? const_true_rtx : const0_rtx;\n+    case LE:\n+    case UNLE:\n+      return (known_results & CR_GT) ? const0_rtx : const_true_rtx;\n+\n+    case LTU:\n+      return (known_results & CR_LTU) ? const_true_rtx : const0_rtx;\n+    case GEU:\n+      return (known_results & CR_LTU) ? const0_rtx : const_true_rtx;\n+\n+    case GTU:\n+      return (known_results & CR_GTU) ? const_true_rtx : const0_rtx;\n+    case LEU:\n+      return (known_results & CR_GTU) ? const0_rtx : const_true_rtx;\n+\n+    case ORDERED:\n+      return const_true_rtx;\n+    case UNORDERED:\n+      return const0_rtx;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Check if the given comparison (done in the given MODE) is actually a\n    tautology or a contradiction.\n    If no simplification is possible, this function returns zero.\n@@ -3962,7 +4025,6 @@ simplify_const_relational_operation (enum rtx_code code,\n \t\t\t\t     enum machine_mode mode,\n \t\t\t\t     rtx op0, rtx op1)\n {\n-  int equal, op0lt, op0ltu, op1lt, op1ltu;\n   rtx tem;\n   rtx trueop0;\n   rtx trueop1;\n@@ -4027,17 +4089,22 @@ simplify_const_relational_operation (enum rtx_code code,\n     return const0_rtx;\n \n   /* For modes without NaNs, if the two operands are equal, we know the\n-     result except if they have side-effects.  */\n-  if (! HONOR_NANS (GET_MODE (trueop0))\n+     result except if they have side-effects.  Even with NaNs we know\n+     the result of unordered comparisons and, if signaling NaNs are\n+     irrelevant, also the result of LT/GT/LTGT.  */\n+  if ((! HONOR_NANS (GET_MODE (trueop0))\n+       || code == UNEQ || code == UNLE || code == UNGE\n+       || ((code == LT || code == GT || code == LTGT)\n+\t   && ! HONOR_SNANS (GET_MODE (trueop0))))\n       && rtx_equal_p (trueop0, trueop1)\n       && ! side_effects_p (trueop0))\n-    equal = 1, op0lt = 0, op0ltu = 0, op1lt = 0, op1ltu = 0;\n+    return comparison_result (code, CR_EQ);\n \n   /* If the operands are floating-point constants, see if we can fold\n      the result.  */\n-  else if (GET_CODE (trueop0) == CONST_DOUBLE\n-\t   && GET_CODE (trueop1) == CONST_DOUBLE\n-\t   && SCALAR_FLOAT_MODE_P (GET_MODE (trueop0)))\n+  if (GET_CODE (trueop0) == CONST_DOUBLE\n+      && GET_CODE (trueop1) == CONST_DOUBLE\n+      && SCALAR_FLOAT_MODE_P (GET_MODE (trueop0)))\n     {\n       REAL_VALUE_TYPE d0, d1;\n \n@@ -4068,17 +4135,17 @@ simplify_const_relational_operation (enum rtx_code code,\n \t    return 0;\n \t  }\n \n-      equal = REAL_VALUES_EQUAL (d0, d1);\n-      op0lt = op0ltu = REAL_VALUES_LESS (d0, d1);\n-      op1lt = op1ltu = REAL_VALUES_LESS (d1, d0);\n+      return comparison_result (code,\n+\t\t\t\t(REAL_VALUES_EQUAL (d0, d1) ? CR_EQ :\n+\t\t\t\t REAL_VALUES_LESS (d0, d1) ? CR_LT : CR_GT));\n     }\n \n   /* Otherwise, see if the operands are both integers.  */\n-  else if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)\n-\t   && (GET_CODE (trueop0) == CONST_DOUBLE\n-\t       || GET_CODE (trueop0) == CONST_INT)\n-\t   && (GET_CODE (trueop1) == CONST_DOUBLE\n-\t       || GET_CODE (trueop1) == CONST_INT))\n+  if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)\n+       && (GET_CODE (trueop0) == CONST_DOUBLE\n+\t   || GET_CODE (trueop0) == CONST_INT)\n+       && (GET_CODE (trueop1) == CONST_DOUBLE\n+\t   || GET_CODE (trueop1) == CONST_INT))\n     {\n       int width = GET_MODE_BITSIZE (mode);\n       HOST_WIDE_INT l0s, h0s, l1s, h1s;\n@@ -4123,192 +4190,230 @@ simplify_const_relational_operation (enum rtx_code code,\n       if (width != 0 && width <= HOST_BITS_PER_WIDE_INT)\n \th0u = h1u = 0, h0s = HWI_SIGN_EXTEND (l0s), h1s = HWI_SIGN_EXTEND (l1s);\n \n-      equal = (h0u == h1u && l0u == l1u);\n-      op0lt = (h0s < h1s || (h0s == h1s && l0u < l1u));\n-      op1lt = (h1s < h0s || (h1s == h0s && l1u < l0u));\n-      op0ltu = (h0u < h1u || (h0u == h1u && l0u < l1u));\n-      op1ltu = (h1u < h0u || (h1u == h0u && l1u < l0u));\n+      if (h0u == h1u && l0u == l1u)\n+        return comparison_result (code, CR_EQ);\n+      else\n+\t{\n+\t  int cr;\n+          cr = (h0s < h1s || (h0s == h1s && l0u < l1u)) ? CR_LT : CR_GT;\n+          cr |= (h0u < h1u || (h0u == h1u && l0u < l1u)) ? CR_LTU : CR_GTU;\n+          return comparison_result (code, cr);\n+\t}\n     }\n \n-  /* Otherwise, there are some code-specific tests we can make.  */\n-  else\n+  /* Optimize comparisons with upper and lower bounds.  */\n+  if (SCALAR_INT_MODE_P (mode)\n+      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+      && GET_CODE (trueop1) == CONST_INT)\n     {\n-      /* Optimize comparisons with upper and lower bounds.  */\n-      if (SCALAR_INT_MODE_P (mode)\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  rtx mmin, mmax;\n-\t  int sign;\n-\n-\t  if (code == GEU\n-\t      || code == LEU\n-\t      || code == GTU\n-\t      || code == LTU)\n-\t    sign = 0;\n-\t  else\n-\t    sign = 1;\n-\n-\t  get_mode_bounds (mode, sign, mode, &mmin, &mmax);\n-\n-\t  tem = NULL_RTX;\n-\t  switch (code)\n-\t    {\n-\t    case GEU:\n-\t    case GE:\n-\t      /* x >= min is always true.  */\n-\t      if (rtx_equal_p (trueop1, mmin))\n-\t\ttem = const_true_rtx;\n-\t      else \n-\t      break;\n-\n-\t    case LEU:\n-\t    case LE:\n-\t      /* x <= max is always true.  */\n-\t      if (rtx_equal_p (trueop1, mmax))\n-\t\ttem = const_true_rtx;\n-\t      break;\n-\n-\t    case GTU:\n-\t    case GT:\n-\t      /* x > max is always false.  */\n-\t      if (rtx_equal_p (trueop1, mmax))\n-\t\ttem = const0_rtx;\n-\t      break;\n-\n-\t    case LTU:\n-\t    case LT:\n-\t      /* x < min is always false.  */\n-\t      if (rtx_equal_p (trueop1, mmin))\n-\t\ttem = const0_rtx;\n-\t      break;\n+      int sign;\n+      unsigned HOST_WIDE_INT nonzero = nonzero_bits (trueop0, mode);\n+      HOST_WIDE_INT val = INTVAL (trueop1);\n+      HOST_WIDE_INT mmin, mmax;\n+\n+      if (code == GEU\n+\t  || code == LEU\n+\t  || code == GTU\n+\t  || code == LTU)\n+\tsign = 0;\n+      else\n+\tsign = 1;\n \n-\t    default:\n-\t      break;\n-\t    }\n-\t  if (tem == const0_rtx\n-\t      || tem == const_true_rtx)\n-\t    return tem;\n+      /* Get a reduced range if the sign bit is zero.  */\n+      if (nonzero <= (GET_MODE_MASK (mode) >> 1))\n+\t{\n+\t  mmin = 0;\n+\t  mmax = nonzero;\n+\t}\n+      else\n+\t{\n+\t  rtx mmin_rtx, mmax_rtx;\n+          unsigned int sign_copies = num_sign_bit_copies (trueop0, mode);\n+          get_mode_bounds (mode, sign, mode, &mmin_rtx, &mmax_rtx);\n+\n+\t  /* Since unsigned mmin will never be interpreted as negative, use\n+\t     INTVAL (and an arithmetic right shift).  */\n+\t  mmin = INTVAL (mmin_rtx) >> (sign_copies - 1);\n+\t  /* Since signed mmax will always be positive, use UINTVAL (and\n+\t     a logical right shift).  */\n+\t  mmax = UINTVAL (mmax_rtx) >> (sign_copies - 1);\n \t}\n \n       switch (code)\n \t{\n+\t/* x >= y is always true for y <= mmin, always false for y > mmax.  */\n+\tcase GEU:\n+\t  if ((unsigned HOST_WIDE_INT) val <= (unsigned HOST_WIDE_INT) mmin)\n+\t    return const_true_rtx;\n+\t  if ((unsigned HOST_WIDE_INT) val > (unsigned HOST_WIDE_INT) mmax)\n+\t    return const0_rtx;\n+\t  break;\n+\tcase GE:\n+\t  if (val <= mmin)\n+\t    return const_true_rtx;\n+\t  if (val > mmax)\n+\t    return const0_rtx;\n+\t  break;\n+\n+\t/* x <= y is always true for y >= mmax, always false for y < mmin.  */\n+\tcase LEU:\n+\t  if ((unsigned HOST_WIDE_INT) val >= (unsigned HOST_WIDE_INT) mmax)\n+\t    return const_true_rtx;\n+\t  if ((unsigned HOST_WIDE_INT) val < (unsigned HOST_WIDE_INT) mmin)\n+\t    return const0_rtx;\n+\t  break;\n+\tcase LE:\n+\t  if (val >= mmax)\n+\t    return const_true_rtx;\n+\t  if (val < mmin)\n+\t    return const0_rtx;\n+\t  break;\n+\n \tcase EQ:\n-\t  if (trueop1 == const0_rtx && nonzero_address_p (op0))\n+\t  /* x == y is always false for y out of range.  */\n+\t  if (val < mmin || val > mmax)\n+\t    return const0_rtx;\n+\t  break;\n+\n+\t/* x > y is always false for y >= mmax, always true for y < mmin.  */\n+\tcase GTU:\n+\t  if ((unsigned HOST_WIDE_INT) val >= (unsigned HOST_WIDE_INT) mmax)\n+\t    return const0_rtx;\n+\t  if ((unsigned HOST_WIDE_INT) val < (unsigned HOST_WIDE_INT) mmin)\n+\t    return const_true_rtx;\n+\t  break;\n+\tcase GT:\n+\t  if (val >= mmax)\n+\t    return const0_rtx;\n+\t  if (val < mmin)\n+\t    return const_true_rtx;\n+\t  break;\n+\n+\t/* x < y is always false for y <= mmin, always true for y > mmax.  */\n+\tcase LTU:\n+\t  if ((unsigned HOST_WIDE_INT) val <= (unsigned HOST_WIDE_INT) mmin)\n+\t    return const0_rtx;\n+\t  if ((unsigned HOST_WIDE_INT) val > (unsigned HOST_WIDE_INT) mmax)\n+\t    return const_true_rtx;\n+\t  break;\n+\tcase LT:\n+\t  if (val <= mmin)\n \t    return const0_rtx;\n+\t  if (val > mmax)\n+\t    return const_true_rtx;\n \t  break;\n \n \tcase NE:\n-\t  if (trueop1 == const0_rtx && nonzero_address_p (op0))\n+\t  /* x != y is always true for y out of range.  */\n+\t  if (val < mmin || val > mmax)\n \t    return const_true_rtx;\n \t  break;\n \n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* Optimize integer comparisons with zero.  */\n+  if (trueop1 == const0_rtx)\n+    {\n+      /* Some addresses are known to be nonzero.  We don't know\n+         their sign, but equality comparisons are known.  */\n+      if (nonzero_address_p (trueop0))\n+        {\n+\t  if (code == EQ || code == LEU)\n+\t    return const0_rtx;\n+\t  if (code == NE || code == GTU)\n+\t    return const_true_rtx;\n+        }\n+\n+      /* See if the first operand is an IOR with a constant.  If so, we\n+\t may be able to determine the result of this comparison.  */\n+      if (GET_CODE (op0) == IOR)\n+        {\n+\t  rtx inner_const = avoid_constant_pool_reference (XEXP (op0, 1));\n+\t  if (GET_CODE (inner_const) == CONST_INT && inner_const != const0_rtx)\n+\t    {\n+              int sign_bitnum = GET_MODE_BITSIZE (mode) - 1;\n+              int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n+                              && (INTVAL (inner_const)\n+                                  & ((HOST_WIDE_INT) 1 << sign_bitnum)));\n+\n+              switch (code)\n+                {\n+                case EQ:\n+\t\tcase LEU:\n+                  return const0_rtx;\n+                case NE:\n+\t\tcase GTU:\n+                  return const_true_rtx;\n+                case LT:\n+\t        case LE:\n+                  if (has_sign)\n+                    return const_true_rtx;\n+                  break;\n+                case GT:\n+\t\tcase GE:\n+                  if (has_sign)\n+                    return const0_rtx;\n+                  break;\n+                default:\n+                  break;\n+                }\n+            }\n+\t}\n+    }\n+\n+  /* Optimize comparison of ABS with zero.  */\n+  if (trueop1 == CONST0_RTX (mode)\n+      && (GET_CODE (trueop0) == ABS\n+\t  || (GET_CODE (trueop0) == FLOAT_EXTEND\n+\t      && GET_CODE (XEXP (trueop0, 0)) == ABS)))\n+    {\n+      switch (code)\n+\t{\n \tcase LT:\n \t  /* Optimize abs(x) < 0.0.  */\n-\t  if (trueop1 == CONST0_RTX (mode)\n-\t      && !HONOR_SNANS (mode)\n+\t  if (!HONOR_SNANS (mode)\n \t      && (!INTEGRAL_MODE_P (mode)\n \t\t  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))\n \t    {\n-\t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n-\t\t\t\t\t\t       : trueop0;\n-\t      if (GET_CODE (tem) == ABS)\n-\t\t{\n-\t\t  if (INTEGRAL_MODE_P (mode)\n-\t\t      && (issue_strict_overflow_warning\n-\t\t\t  (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n-\t\t    warning (OPT_Wstrict_overflow,\n-\t\t\t     (\"assuming signed overflow does not occur when \"\n-\t\t\t      \"assuming abs (x) < 0 is false\"));\n-\t\t  return const0_rtx;\n-\t\t}\n+\t      if (INTEGRAL_MODE_P (mode)\n+\t\t  && (issue_strict_overflow_warning\n+\t\t      (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n+\t\twarning (OPT_Wstrict_overflow,\n+\t\t\t (\"assuming signed overflow does not occur when \"\n+\t\t\t  \"assuming abs (x) < 0 is false\"));\n+\t       return const0_rtx;\n \t    }\n-\n-\t  /* Optimize popcount (x) < 0.  */\n-\t  if (GET_CODE (trueop0) == POPCOUNT && trueop1 == const0_rtx)\n-\t    return const_true_rtx;\n \t  break;\n \n \tcase GE:\n \t  /* Optimize abs(x) >= 0.0.  */\n-\t  if (trueop1 == CONST0_RTX (mode)\n-\t      && !HONOR_NANS (mode)\n+\t  if (!HONOR_NANS (mode)\n \t      && (!INTEGRAL_MODE_P (mode)\n \t\t  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))\n \t    {\n-\t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n-\t\t\t\t\t\t       : trueop0;\n-\t      if (GET_CODE (tem) == ABS)\n-\t\t{\n-\t\t  if (INTEGRAL_MODE_P (mode)\n-\t\t      && (issue_strict_overflow_warning\n-\t\t\t  (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n-\t\t    warning (OPT_Wstrict_overflow,\n-\t\t\t     (\"assuming signed overflow does not occur when \"\n-\t\t\t      \"assuming abs (x) >= 0 is true\"));\n-\t\t  return const_true_rtx;\n-\t\t}\n+\t      if (INTEGRAL_MODE_P (mode)\n+\t          && (issue_strict_overflow_warning\n+\t    \t  (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n+\t        warning (OPT_Wstrict_overflow,\n+\t\t\t (\"assuming signed overflow does not occur when \"\n+\t\t\t  \"assuming abs (x) >= 0 is true\"));\n+\t      return const_true_rtx;\n \t    }\n-\n-\t  /* Optimize popcount (x) >= 0.  */\n-\t  if (GET_CODE (trueop0) == POPCOUNT && trueop1 == const0_rtx)\n-\t    return const_true_rtx;\n \t  break;\n \n \tcase UNGE:\n \t  /* Optimize ! (abs(x) < 0.0).  */\n-\t  if (trueop1 == CONST0_RTX (mode))\n-\t    {\n-\t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n-\t\t\t\t\t\t       : trueop0;\n-\t      if (GET_CODE (tem) == ABS)\n-\t\treturn const_true_rtx;\n-\t    }\n-\t  break;\n+\t  return const_true_rtx;\n \n \tdefault:\n \t  break;\n \t}\n-\n-      return 0;\n     }\n \n-  /* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set\n-     as appropriate.  */\n-  switch (code)\n-    {\n-    case EQ:\n-    case UNEQ:\n-      return equal ? const_true_rtx : const0_rtx;\n-    case NE:\n-    case LTGT:\n-      return ! equal ? const_true_rtx : const0_rtx;\n-    case LT:\n-    case UNLT:\n-      return op0lt ? const_true_rtx : const0_rtx;\n-    case GT:\n-    case UNGT:\n-      return op1lt ? const_true_rtx : const0_rtx;\n-    case LTU:\n-      return op0ltu ? const_true_rtx : const0_rtx;\n-    case GTU:\n-      return op1ltu ? const_true_rtx : const0_rtx;\n-    case LE:\n-    case UNLE:\n-      return equal || op0lt ? const_true_rtx : const0_rtx;\n-    case GE:\n-    case UNGE:\n-      return equal || op1lt ? const_true_rtx : const0_rtx;\n-    case LEU:\n-      return equal || op0ltu ? const_true_rtx : const0_rtx;\n-    case GEU:\n-      return equal || op1ltu ? const_true_rtx : const0_rtx;\n-    case ORDERED:\n-      return const_true_rtx;\n-    case UNORDERED:\n-      return const0_rtx;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return 0;\n }\n \f\n /* Simplify CODE, an operation with result mode MODE and three operands,"}]}