{"sha": "79e267f9fb23da4e9553a97dc45ea757545cf521", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllMjY3ZjlmYjIzZGE0ZTk1NTNhOTdkYzQ1ZWE3NTc1NDVjZjUyMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-01-09T15:25:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-03T10:01:37Z"}, "message": "[Ada] Improve 'Val implementation for some enumeration types\n\n2020-06-03  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads (Enum_Pos_To_Rep): Adjust description.\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Pred>:\n\tReimplement in the case of an enumeration type with non-standard\n\tbut contiguous representation.\n\t<Succ>: Likewise.\n\t<Val>: Likewise.\n\t* exp_ch3.adb (Expand_Freeze_Enumeration_Type): Count the\n\tliterals in the first loop.  If the representation is\n\tcontiguous, just build the index type of the array type and set\n\tEnum_Pos_To_Rep to it.", "tree": {"sha": "4db89173cb6248ef10d3e68f46313581d9f95d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db89173cb6248ef10d3e68f46313581d9f95d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79e267f9fb23da4e9553a97dc45ea757545cf521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e267f9fb23da4e9553a97dc45ea757545cf521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e267f9fb23da4e9553a97dc45ea757545cf521", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e267f9fb23da4e9553a97dc45ea757545cf521/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075116992690d6f29530a0a7f08cf2f7d5652a93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/075116992690d6f29530a0a7f08cf2f7d5652a93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/075116992690d6f29530a0a7f08cf2f7d5652a93"}], "stats": {"total": 366, "additions": 208, "deletions": 158}, "files": [{"sha": "810a112ca280791d8a78a58fb021787e6b993209", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=79e267f9fb23da4e9553a97dc45ea757545cf521", "patch": "@@ -1217,14 +1217,16 @@ package Einfo is\n --       for the same literal.\n \n --    Enum_Pos_To_Rep (Node23)\n---       Defined in enumeration types (but not enumeration subtypes). Set to\n---       Empty unless the enumeration type has a non-standard representation\n---       (i.e. at least one literal has a representation value different from\n---       its pos value). In this case, Enum_Pos_To_Rep is the entity for an\n---       array constructed when the type is frozen that maps Pos values to\n---       corresponding Rep values. The index type of this array is Natural,\n---       and the component type is a suitable integer type that holds the\n---       full range of representation values.\n+--       Defined in enumeration types, but not enumeration subtypes. Set to\n+--       Empty unless the enumeration type has a non-standard representation,\n+--       i.e. at least one literal has a representation value different from\n+--       its position value. In this case, the alternative is the following:\n+--       if the representation is not contiguous, then Enum_Pos_To_Rep is the\n+--       entity for an array constant built when the type is frozen that maps\n+--       Pos values to corresponding Rep values, whose index type is Natural\n+--       and whose component type is the enumeration type itself; or else, if\n+--       the representation is contiguous, then Enum_Pos_To_Rep is the entity\n+--       of the index type defined above.\n \n --    Equivalent_Type (Node18)\n --       Defined in class wide types and subtypes, access to protected"}, {"sha": "8ca5eb15158419bd90b12d2422104b83f08c787e", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 133, "deletions": 104, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=79e267f9fb23da4e9553a97dc45ea757545cf521", "patch": "@@ -5246,46 +5246,48 @@ package body Exp_Attr is\n \n       when Attribute_Pred => Pred : declare\n          Etyp : constant Entity_Id := Base_Type (Ptyp);\n+         Ityp : Entity_Id;\n \n       begin\n-\n          --  For enumeration types with non-standard representations, we\n-         --  expand typ'Pred (x) into\n+         --  expand typ'Pred (x) into:\n \n          --    Pos_To_Rep (Rep_To_Pos (x) - 1)\n \n-         --    If the representation is contiguous, we compute instead\n-         --    Lit1 + Rep_to_Pos (x -1), to catch invalid representations.\n-         --    The conversion function Enum_Pos_To_Rep is defined on the\n-         --    base type, not the subtype, so we have to use the base type\n-         --    explicitly for this and other enumeration attributes.\n+         --  if the representation is non-contiguous, and just x - 1 if it is\n+         --  after having dealt with constraint checking.\n \n-         if Is_Enumeration_Type (Ptyp)\n+         if Is_Enumeration_Type (Etyp)\n            and then Present (Enum_Pos_To_Rep (Etyp))\n          then\n             if Has_Contiguous_Rep (Etyp) then\n-               Rewrite (N,\n-                  Unchecked_Convert_To (Ptyp,\n-                     Make_Op_Add (Loc,\n-                        Left_Opnd  =>\n-                         Make_Integer_Literal (Loc,\n-                           Enumeration_Rep (First_Literal (Ptyp))),\n-                        Right_Opnd =>\n-                          Make_Function_Call (Loc,\n-                            Name =>\n-                              New_Occurrence_Of\n-                               (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n+               if not Range_Checks_Suppressed (Ptyp) then\n+                  Set_Do_Range_Check (First (Exprs), False);\n+                  Expand_Pred_Succ_Attribute (N);\n+               end if;\n+\n+               if Is_Unsigned_Type (Etyp) then\n+                  if Esize (Typ) <= Standard_Integer_Size then\n+                     Ityp := RTE (RE_Unsigned);\n+                  else\n+                     Ityp := RTE (RE_Long_Long_Unsigned);\n+                  end if;\n \n-                            Parameter_Associations =>\n-                              New_List (\n-                                Unchecked_Convert_To (Ptyp,\n-                                  Make_Op_Subtract (Loc,\n-                                    Left_Opnd =>\n-                                     Unchecked_Convert_To (Standard_Integer,\n-                                       Relocate_Node (First (Exprs))),\n-                                    Right_Opnd =>\n-                                      Make_Integer_Literal (Loc, 1))),\n-                                Rep_To_Pos_Flag (Ptyp, Loc))))));\n+               else\n+                  if Esize (Etyp) <= Standard_Integer_Size then\n+                     Ityp := Standard_Integer;\n+                  else\n+                     Ityp := Standard_Long_Long_Integer;\n+                  end if;\n+               end if;\n+\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Etyp,\n+                    Make_Op_Subtract (Loc,\n+                       Left_Opnd  =>\n+                         Unchecked_Convert_To (Ityp, First (Exprs)),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc, 1))));\n \n             else\n                --  Add Boolean parameter True, to request program error if\n@@ -5309,7 +5311,9 @@ package body Exp_Attr is\n                     Right_Opnd => Make_Integer_Literal (Loc, 1)))));\n             end if;\n \n-            Analyze_And_Resolve (N, Typ);\n+            --  Suppress checks since they have all been done above\n+\n+            Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n \n          --  For floating-point, we transform 'Pred into a call to the Pred\n          --  floating-point attribute function in Fat_xxx (xxx is root type).\n@@ -6222,42 +6226,49 @@ package body Exp_Attr is\n \n       when Attribute_Succ => Succ : declare\n          Etyp : constant Entity_Id := Base_Type (Ptyp);\n+         Ityp : Entity_Id;\n \n       begin\n          --  For enumeration types with non-standard representations, we\n-         --  expand typ'Succ (x) into\n+         --  expand typ'Pred (x) into:\n \n          --    Pos_To_Rep (Rep_To_Pos (x) + 1)\n \n-         --    If the representation is contiguous, we compute instead\n-         --    Lit1 + Rep_to_Pos (x+1), to catch invalid representations.\n+         --  if the representation is non-contiguous, and just x + 1 if it is\n+         --  after having dealt with constraint checking.\n \n-         if Is_Enumeration_Type (Ptyp)\n+         if Is_Enumeration_Type (Etyp)\n            and then Present (Enum_Pos_To_Rep (Etyp))\n          then\n             if Has_Contiguous_Rep (Etyp) then\n+               if not Range_Checks_Suppressed (Ptyp) then\n+                  Set_Do_Range_Check (First (Exprs), False);\n+                  Expand_Pred_Succ_Attribute (N);\n+               end if;\n+\n+               if Is_Unsigned_Type (Etyp) then\n+                  if Esize (Typ) <= Standard_Integer_Size then\n+                     Ityp := RTE (RE_Unsigned);\n+                  else\n+                     Ityp := RTE (RE_Long_Long_Unsigned);\n+                  end if;\n+\n+               else\n+                  if Esize (Etyp) <= Standard_Integer_Size then\n+                     Ityp := Standard_Integer;\n+                  else\n+                     Ityp := Standard_Long_Long_Integer;\n+                  end if;\n+               end if;\n+\n                Rewrite (N,\n-                  Unchecked_Convert_To (Ptyp,\n-                     Make_Op_Add (Loc,\n-                        Left_Opnd  =>\n-                         Make_Integer_Literal (Loc,\n-                           Enumeration_Rep (First_Literal (Ptyp))),\n-                        Right_Opnd =>\n-                          Make_Function_Call (Loc,\n-                            Name =>\n-                              New_Occurrence_Of\n-                               (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n+                 Unchecked_Convert_To (Etyp,\n+                    Make_Op_Add (Loc,\n+                       Left_Opnd  =>\n+                         Unchecked_Convert_To (Ityp, First (Exprs)),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc, 1))));\n \n-                            Parameter_Associations =>\n-                              New_List (\n-                                Unchecked_Convert_To (Ptyp,\n-                                  Make_Op_Add (Loc,\n-                                  Left_Opnd =>\n-                                    Unchecked_Convert_To (Standard_Integer,\n-                                      Relocate_Node (First (Exprs))),\n-                                  Right_Opnd =>\n-                                    Make_Integer_Literal (Loc, 1))),\n-                                Rep_To_Pos_Flag (Ptyp, Loc))))));\n             else\n                --  Add Boolean parameter True, to request program error if\n                --  we have a bad representation on our hands. Add False if\n@@ -6280,7 +6291,9 @@ package body Exp_Attr is\n                        Right_Opnd => Make_Integer_Literal (Loc, 1)))));\n             end if;\n \n-            Analyze_And_Resolve (N, Typ);\n+            --  Suppress checks since they have all been done above\n+\n+            Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n \n          --  For floating-point, we transform 'Succ into a call to the Succ\n          --  floating-point attribute function in Fat_xxx (xxx is root type)\n@@ -6536,70 +6549,86 @@ package body Exp_Attr is\n       when Attribute_Val => Val : declare\n          Etyp : constant Entity_Id := Base_Type (Ptyp);\n          Expr : constant Node_Id := First (Exprs);\n+         Ityp : Entity_Id;\n+         Rtyp : Entity_Id;\n \n       begin\n          --  Case of enumeration type\n \n          if Is_Enumeration_Type (Etyp) then\n \n-            --  Non-standard enumeration type\n+            --  Non-contiguous non-standard enumeration type\n \n-            if Present (Enum_Pos_To_Rep (Etyp)) then\n-               if Has_Contiguous_Rep (Etyp) then\n-                  declare\n-                     Rep_Node : constant Node_Id :=\n-                       Unchecked_Convert_To (Etyp,\n-                          Make_Op_Add (Loc,\n-                            Left_Opnd =>\n-                              Make_Integer_Literal (Loc,\n-                                Enumeration_Rep (First_Literal (Etyp))),\n-                            Right_Opnd =>\n-                               Convert_To (Standard_Integer, Expr)));\n+            if Present (Enum_Pos_To_Rep (Etyp))\n+              and then not Has_Contiguous_Rep (Etyp)\n+            then\n+               Rewrite (N,\n+                 Make_Indexed_Component (Loc,\n+                   Prefix =>\n+                     New_Occurrence_Of (Enum_Pos_To_Rep (Etyp), Loc),\n+                   Expressions => New_List (\n+                     Convert_To (Standard_Integer, Expr))));\n \n-                  begin\n-                     Rewrite (N,\n-                        Unchecked_Convert_To (Etyp,\n-                            Make_Op_Add (Loc,\n-                              Left_Opnd =>\n-                                Make_Integer_Literal (Loc,\n-                                  Enumeration_Rep (First_Literal (Etyp))),\n-                              Right_Opnd =>\n-                                Make_Function_Call (Loc,\n-                                  Name =>\n-                                    New_Occurrence_Of\n-                                      (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n-                                  Parameter_Associations => New_List (\n-                                    Rep_Node,\n-                                    Rep_To_Pos_Flag (Etyp, Loc))))));\n-                  end;\n+               Analyze_And_Resolve (N, Typ);\n \n-               else\n-                  Rewrite (N,\n-                    Make_Indexed_Component (Loc,\n-                      Prefix =>\n-                        New_Occurrence_Of (Enum_Pos_To_Rep (Etyp), Loc),\n-                      Expressions => New_List (\n-                        Convert_To (Standard_Integer, Expr))));\n-               end if;\n+            --  Standard or contiguous non-standard enumeration type\n \n-               Analyze_And_Resolve (N, Typ);\n+            else\n+               --  If the argument is marked as requiring a range check then\n+               --  generate it here, after looking through a conversion to\n+               --  universal integer, if any.\n+\n+               if Do_Range_Check (Expr) then\n+                  if Present (Enum_Pos_To_Rep (Etyp)) then\n+                     Rtyp := Enum_Pos_To_Rep (Etyp);\n+                  else\n+                     Rtyp := Etyp;\n+                  end if;\n \n-            --  Standard enumeration type\n+                  if Nkind (Expr) = N_Type_Conversion\n+                     and then Entity (Subtype_Mark (Expr)) = Universal_Integer\n+                  then\n+                     Generate_Range_Check\n+                       (Expression (Expr), Rtyp, CE_Range_Check_Failed);\n \n-            --  If the argument is marked as requiring a range check then\n-            --  generate it here, after looking through a conversion to\n-            --  universal integer, if any.\n+                  else\n+                     Generate_Range_Check (Expr, Rtyp, CE_Range_Check_Failed);\n+                  end if;\n \n-            elsif Do_Range_Check (Expr) then\n-               if Nkind (Expr) = N_Type_Conversion\n-                  and then Entity (Subtype_Mark (Expr)) = Universal_Integer\n-               then\n-                  Generate_Range_Check\n-                    (Expression (Expr), Etyp, CE_Range_Check_Failed);\n                   Set_Do_Range_Check (Expr, False);\n+               end if;\n \n-               else\n-                  Generate_Range_Check (Expr, Etyp, CE_Range_Check_Failed);\n+               --  Contiguous non-standard enumeration type\n+\n+               if Present (Enum_Pos_To_Rep (Etyp)) then\n+                  if Is_Unsigned_Type (Etyp) then\n+                     if Esize (Typ) <= Standard_Integer_Size then\n+                        Ityp := RTE (RE_Unsigned);\n+                     else\n+                        Ityp := RTE (RE_Long_Long_Unsigned);\n+                     end if;\n+\n+                  else\n+                     if Esize (Etyp) <= Standard_Integer_Size then\n+                        Ityp := Standard_Integer;\n+                     else\n+                        Ityp := Standard_Long_Long_Integer;\n+                     end if;\n+                  end if;\n+\n+                  Rewrite (N,\n+                    Unchecked_Convert_To (Etyp,\n+                      Make_Op_Add (Loc,\n+                        Left_Opnd =>\n+                          Make_Integer_Literal (Loc,\n+                            Enumeration_Rep (First_Literal (Etyp))),\n+                        Right_Opnd =>\n+                          Convert_To (Ityp, Expr))));\n+\n+                  --  Suppress checks since the range check was done above\n+                  --  and it guarantees that the addition cannot overflow.\n+\n+                  Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n                end if;\n             end if;\n "}, {"sha": "0d0944959f6f7aced81930279c25682989c32522", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e267f9fb23da4e9553a97dc45ea757545cf521/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=79e267f9fb23da4e9553a97dc45ea757545cf521", "patch": "@@ -4670,6 +4670,7 @@ package body Exp_Ch3 is\n       Ent           : Entity_Id;\n       Fent          : Entity_Id;\n       Is_Contiguous : Boolean;\n+      Index_Typ     : Entity_Id;\n       Ityp          : Entity_Id;\n       Last_Repval   : Uint;\n       Lst           : List_Id;\n@@ -4686,81 +4687,99 @@ package body Exp_Ch3 is\n \n       Ent := First_Literal (Typ);\n       Last_Repval := Enumeration_Rep (Ent);\n-\n+      Num := 1;\n       Next_Literal (Ent);\n+\n       while Present (Ent) loop\n          if Enumeration_Rep (Ent) - Last_Repval /= 1 then\n             Is_Contiguous := False;\n-            exit;\n          else\n             Last_Repval := Enumeration_Rep (Ent);\n          end if;\n \n+         Num := Num + 1;\n          Next_Literal (Ent);\n       end loop;\n \n       if Is_Contiguous then\n          Set_Has_Contiguous_Rep (Typ);\n-         Ent := First_Literal (Typ);\n-         Num := 1;\n-         Lst := New_List (New_Occurrence_Of (Ent, Sloc (Ent)));\n+\n+         --  Now build a subtype declaration\n+\n+         --    subtype typI is new Natural range 0 .. num - 1\n+\n+         Index_Typ :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), 'I'));\n+\n+         Append_Freeze_Action (Typ,\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier => Index_Typ,\n+             Subtype_Indication =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Occurrence_Of (Standard_Natural,  Loc),\n+                 Constraint  =>\n+                   Make_Range_Constraint (Loc,\n+                     Range_Expression =>\n+                       Make_Range (Loc,\n+                         Low_Bound  =>\n+                           Make_Integer_Literal (Loc, 0),\n+                         High_Bound =>\n+                           Make_Integer_Literal (Loc, Num - 1))))));\n+\n+         Set_Enum_Pos_To_Rep (Typ, Index_Typ);\n \n       else\n          --  Build list of literal references\n \n          Lst := New_List;\n-         Num := 0;\n-\n          Ent := First_Literal (Typ);\n          while Present (Ent) loop\n             Append_To (Lst, New_Occurrence_Of (Ent, Sloc (Ent)));\n-            Num := Num + 1;\n             Next_Literal (Ent);\n          end loop;\n-      end if;\n-\n-      --  Now build an array declaration\n \n-      --    typA : array (Natural range 0 .. num - 1) of ctype :=\n-      --             (v, v, v, v, v, ....)\n+         --  Now build an array declaration\n \n-      --  where ctype is the corresponding integer type. If the representation\n-      --  is contiguous, we only keep the first literal, which provides the\n-      --  offset for Pos_To_Rep computations.\n+         --    typA : constant array (Natural range 0 .. num - 1) of typ :=\n+         --             (v, v, v, v, v, ....)\n \n-      Arr :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Typ), 'A'));\n+         Arr :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), 'A'));\n \n-      Append_Freeze_Action (Typ,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Arr,\n-          Constant_Present    => True,\n-\n-          Object_Definition   =>\n-            Make_Constrained_Array_Definition (Loc,\n-              Discrete_Subtype_Definitions => New_List (\n-                Make_Subtype_Indication (Loc,\n-                  Subtype_Mark => New_Occurrence_Of (Standard_Natural, Loc),\n-                  Constraint   =>\n-                    Make_Range_Constraint (Loc,\n-                      Range_Expression =>\n-                        Make_Range (Loc,\n-                          Low_Bound  =>\n-                            Make_Integer_Literal (Loc, 0),\n-                          High_Bound =>\n-                            Make_Integer_Literal (Loc, Num - 1))))),\n-\n-              Component_Definition =>\n-                Make_Component_Definition (Loc,\n-                  Aliased_Present => False,\n-                  Subtype_Indication => New_Occurrence_Of (Typ, Loc))),\n+         Append_Freeze_Action (Typ,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Arr,\n+             Constant_Present    => True,\n+\n+             Object_Definition   =>\n+               Make_Constrained_Array_Definition (Loc,\n+                 Discrete_Subtype_Definitions => New_List (\n+                   Make_Subtype_Indication (Loc,\n+                     Subtype_Mark =>\n+                       New_Occurrence_Of (Standard_Natural, Loc),\n+                     Constraint   =>\n+                       Make_Range_Constraint (Loc,\n+                         Range_Expression =>\n+                           Make_Range (Loc,\n+                             Low_Bound  =>\n+                               Make_Integer_Literal (Loc, 0),\n+                             High_Bound =>\n+                               Make_Integer_Literal (Loc, Num - 1))))),\n+\n+                 Component_Definition =>\n+                   Make_Component_Definition (Loc,\n+                     Aliased_Present => False,\n+                     Subtype_Indication => New_Occurrence_Of (Typ, Loc))),\n \n-          Expression =>\n-            Make_Aggregate (Loc,\n-              Expressions => Lst)));\n+             Expression =>\n+               Make_Aggregate (Loc,\n+                 Expressions => Lst)));\n \n-      Set_Enum_Pos_To_Rep (Typ, Arr);\n+         Set_Enum_Pos_To_Rep (Typ, Arr);\n+      end if;\n \n       --  Now we build the function that converts representation values to\n       --  position values. This function has the form:"}]}