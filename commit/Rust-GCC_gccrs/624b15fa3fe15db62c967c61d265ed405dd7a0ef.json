{"sha": "624b15fa3fe15db62c967c61d265ed405dd7a0ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0YjE1ZmEzZmUxNWRiNjJjOTY3YzYxZDI2NWVkNDA1ZGQ3YTBlZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-11-24T15:57:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-11-24T15:57:08Z"}, "message": "fold-const.c (operand_equal_p): Remove kludge allowing ARG0 and ARG1 to be null...\n\n\t* fold-const.c (operand_equal_p): Remove kludge allowing ARG0 and\n\tARG1 to be null; instead define OP_SAME and OP_SAME_NULL and use them.\n\nFrom-SVN: r91170", "tree": {"sha": "89dec9bbd94c8955a9150dfd16540c5894834560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89dec9bbd94c8955a9150dfd16540c5894834560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/624b15fa3fe15db62c967c61d265ed405dd7a0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624b15fa3fe15db62c967c61d265ed405dd7a0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624b15fa3fe15db62c967c61d265ed405dd7a0ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624b15fa3fe15db62c967c61d265ed405dd7a0ef/comments", "author": null, "committer": null, "parents": [{"sha": "0492baf2cc32d89f32bab28a2a512132ccdd3f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0492baf2cc32d89f32bab28a2a512132ccdd3f19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0492baf2cc32d89f32bab28a2a512132ccdd3f19"}], "stats": {"total": 96, "additions": 42, "deletions": 54}, "files": [{"sha": "80baf0f40f186d708d866c73f0d7648cfb91420b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624b15fa3fe15db62c967c61d265ed405dd7a0ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624b15fa3fe15db62c967c61d265ed405dd7a0ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=624b15fa3fe15db62c967c61d265ed405dd7a0ef", "patch": "@@ -1,3 +1,8 @@\n+2004-11-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (operand_equal_p): Remove kludge allowing ARG0 and\n+\tARG1 to be null; instead define OP_SAME and OP_SAME_NULL and use them.\n+\n 2004-11-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* bitmap.c (INLINE): Do not define."}, {"sha": "167fc039ff6750913a0df54865d5cee151dd64c1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624b15fa3fe15db62c967c61d265ed405dd7a0ef/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624b15fa3fe15db62c967c61d265ed405dd7a0ef/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=624b15fa3fe15db62c967c61d265ed405dd7a0ef", "patch": "@@ -2331,17 +2331,8 @@ truth_value_p (enum tree_code code)\n int\n operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n {\n-  /* If one is specified and the other isn't, they aren't equal and if\n-     neither is specified, they are.\n-\n-     ??? This is temporary and is meant only to handle the cases of the\n-     optional operands for COMPONENT_REF and ARRAY_REF.  */\n-  if ((arg0 && !arg1) || (!arg0 && arg1))\n-    return 0;\n-  else if (!arg0 && !arg1)\n-    return 1;\n   /* If either is ERROR_MARK, they aren't equal.  */\n-  else if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n+  if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n     return 0;\n \n   /* If both types don't have the same signedness, then we can't consider\n@@ -2433,6 +2424,17 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n   if (flags & OEP_ONLY_CONST)\n     return 0;\n \n+/* Define macros to test an operan from arg0 and arg1 for equality and a\n+   variant that allows null and views null as being different from any\n+   non-null value.  In the latter case, if either is null, the both\n+   must be; otherwise, do the normal comparison.  */\n+#define OP_SAME(N) operand_equal_p (TREE_OPERAND (arg0, N),\t\\\n+\t\t\t\t    TREE_OPERAND (arg1, N), flags)\n+\n+#define OP_SAME_WITH_NULL(N)\t\t\t\t\\\n+  ((!TREE_OPERAND (arg0, N) || !TREE_OPERAND (arg1, N))\t\\\n+   ? TREE_OPERAND (arg0, N) == TREE_OPERAND (arg1, N) : OP_SAME (N))\n+\n   switch (TREE_CODE_CLASS (TREE_CODE (arg0)))\n     {\n     case tcc_unary:\n@@ -2453,15 +2455,12 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t  break;\n \t}\n \n-      return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg1, 0), flags);\n+      return OP_SAME (0);\n+\n \n     case tcc_comparison:\n     case tcc_binary:\n-      if (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t      TREE_OPERAND (arg1, 1), flags))\n+      if (OP_SAME (0) && OP_SAME (1))\n \treturn 1;\n \n       /* For commutative ops, allow the other order.  */\n@@ -2485,37 +2484,23 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \tcase MISALIGNED_INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n+\t  return OP_SAME (0);\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 3),\n-\t\t\t\t      TREE_OPERAND (arg1, 3), flags));\n-\n+\t  /* Operands 2 and 3 may be null.  */\n+\t  return (OP_SAME (0)\n+\t\t  && OP_SAME (1)\n+\t\t  && OP_SAME_WITH_NULL (2)\n+\t\t  && OP_SAME_WITH_NULL (3));\n \n \tcase COMPONENT_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n-\n+\t  /* Handle operand 2 the same as for ARRAY_REF.  */\n+\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME_WITH_NULL (2);\n \n \tcase BIT_FIELD_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n+\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME (2);\n+\n \tdefault:\n \t  return 0;\n \t}\n@@ -2525,33 +2510,28 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t{\n \tcase ADDR_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n+\t  return OP_SAME (0);\n \n \tcase TRUTH_ANDIF_EXPR:\n \tcase TRUTH_ORIF_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags)\n-\t\t && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t     TREE_OPERAND (arg1, 1), flags);\n+\t  return OP_SAME (0) && OP_SAME (1);\n \n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n+\t  if (OP_SAME (0) && OP_SAME (1))\n+\t    return 1;\n+\n+\t  /* Otherwise take into account this is a commutative operation.  */\n \t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t\t\t\t   TREE_OPERAND (arg1, 1), flags)\n \t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags))\n-\t\t || (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t     && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t TREE_OPERAND (arg1, 0), flags));\n+\t\t\t\t      TREE_OPERAND (arg1, 0), flags));\n \n \tcase CALL_EXPR:\n \t  /* If the CALL_EXPRs call different functions, then they\n \t     clearly can not be equal.  */\n-\t  if (! operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t TREE_OPERAND (arg1, 0), flags))\n+\t  if (!OP_SAME (0))\n \t    return 0;\n \n \t  {\n@@ -2597,6 +2577,9 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n     default:\n       return 0;\n     }\n+\n+#undef OP_SAME\n+#undef OP_SAME_WITH_NULL\n }\n \f\n /* Similar to operand_equal_p, but see if ARG0 might have been made by"}]}