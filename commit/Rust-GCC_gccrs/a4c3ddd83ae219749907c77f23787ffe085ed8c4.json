{"sha": "a4c3ddd83ae219749907c77f23787ffe085ed8c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRjM2RkZDgzYWUyMTk3NDk5MDdjNzdmMjM3ODdmZmUwODVlZDhjNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-06T20:38:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-06T20:38:40Z"}, "message": "loop.c (count_one_set): New static function, broken out of count_loop_regs_set\n\n\t* loop.c (count_one_set): New static function, broken out of\n\tcount_loop_regs_set\n\t(count_loop_regs_set): Call it.\n\t* global.c (mark_reg_store): Handle clobbers here by not calling\n\tset_preference.\n\t(mark_reg_clobber): Just call mark_reg_store after ensuring SETTER\n\tis in fact a clobber.\n\t* integrate.c (process_reg_param): New function, broken out of\n\texpand_inline_function.\n\t(expand_inline_function): Call it.\n\nFrom-SVN: r22875", "tree": {"sha": "70ebcacddadf10b0f128e66b293617a18c689562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70ebcacddadf10b0f128e66b293617a18c689562"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4c3ddd83ae219749907c77f23787ffe085ed8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c3ddd83ae219749907c77f23787ffe085ed8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c3ddd83ae219749907c77f23787ffe085ed8c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c3ddd83ae219749907c77f23787ffe085ed8c4/comments", "author": null, "committer": null, "parents": [{"sha": "9a07247c2ae0e5d745bbeca9a3b06aeb1cba0c55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a07247c2ae0e5d745bbeca9a3b06aeb1cba0c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a07247c2ae0e5d745bbeca9a3b06aeb1cba0c55"}], "stats": {"total": 342, "additions": 124, "deletions": 218}, "files": [{"sha": "85d9497c7df53221af91146b06c9c60427fdaf37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4c3ddd83ae219749907c77f23787ffe085ed8c4", "patch": "@@ -23,6 +23,18 @@ Tue Oct  6 17:00:42 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n Tue Oct  6 01:36:00 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n \n+\t* loop.c (count_one_set): New static function, broken out of\n+\tcount_loop_regs_set\n+\t(count_loop_regs_set): Call it.\n+\t* global.c (mark_reg_store): Handle clobbers here by not calling\n+\tset_preference.\n+\t(mark_reg_clobber): Just call mark_reg_store after ensuring SETTER\n+\tis in fact a clobber.\n+\t* integrate.c (process_reg_param): New function, broken out of\n+\texpand_inline_function.\n+\t(expand_inline_function): Call it.\n+\n+\n \t* i386.md (addsidi3_1): Delete unused variable temp.\n \t(addsidi3_2): Likewise.\n \t(clstrstrsi): Delete unused variable addr1."}, {"sha": "0bacc2381722a6197fedfa13c5e59d8e0854faad", "filename": "gcc/global.c", "status": "modified", "additions": 6, "deletions": 63, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a4c3ddd83ae219749907c77f23787ffe085ed8c4", "patch": "@@ -1323,16 +1323,13 @@ record_conflicts (allocno_vec, len)\n    if so, we do nothing.\n \n    SETTER is 0 if this register was modified by an auto-increment (i.e.,\n-   a REG_INC note was found for it).\n-\n-   CLOBBERs are processed here by calling mark_reg_clobber.  */ \n+   a REG_INC note was found for it).  */\n \n static void\n-mark_reg_store (orig_reg, setter)\n-     rtx orig_reg, setter;\n+mark_reg_store (reg, setter)\n+     rtx reg, setter;\n {\n   register int regno;\n-  register rtx reg = orig_reg;\n \n   /* WORD is which word of a multi-register group is being stored.\n      For the case where the store is actually into a SUBREG of REG.\n@@ -1349,16 +1346,9 @@ mark_reg_store (orig_reg, setter)\n   if (GET_CODE (reg) != REG)\n     return;\n \n-  if (setter && GET_CODE (setter) == CLOBBER)\n-    {\n-      /* A clobber of a register should be processed here too.  */\n-      mark_reg_clobber (orig_reg, setter);\n-      return;\n-    }\n-\n   regs_set[n_regs_set++] = reg;\n \n-  if (setter)\n+  if (setter && GET_CODE (setter) != CLOBBER)\n     set_preference (reg, SET_SRC (setter));\n \n   regno = REGNO (reg);\n@@ -1396,55 +1386,8 @@ static void\n mark_reg_clobber (reg, setter)\n      rtx reg, setter;\n {\n-  register int regno;\n-\n-  /* WORD is which word of a multi-register group is being stored.\n-     For the case where the store is actually into a SUBREG of REG.\n-     Except we don't use it; I believe the entire REG needs to be\n-     made live.  */\n-  int word = 0;\n-\n-  if (GET_CODE (setter) != CLOBBER)\n-    return;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    {\n-      word = SUBREG_WORD (reg);\n-      reg = SUBREG_REG (reg);\n-    }\n-\n-  if (GET_CODE (reg) != REG)\n-    return;\n-\n-  regs_set[n_regs_set++] = reg;\n-\n-  regno = REGNO (reg);\n-\n-  /* Either this is one of the max_allocno pseudo regs not allocated,\n-     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (reg_allocno[regno] >= 0)\n-\t{\n-\t  SET_ALLOCNO_LIVE (reg_allocno[regno]);\n-\t  record_one_conflict (regno);\n-\t}\n-    }\n-\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno] /* + word */;\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    {\n-      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (regno < last)\n-\t{\n-\t  record_one_conflict (regno);\n-\t  SET_HARD_REG_BIT (hard_regs_live, regno);\n-\t  regno++;\n-\t}\n-    }\n+  if (GET_CODE (setter) == CLOBBER)\n+    mark_reg_store (reg, setter);\n }\n \n /* Record that REG has conflicts with all the regs currently live."}, {"sha": "76ccf5f59b51a71820162d83d79bbace73641bcd", "filename": "gcc/integrate.c", "status": "modified", "additions": 58, "deletions": 91, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=a4c3ddd83ae219749907c77f23787ffe085ed8c4", "patch": "@@ -59,25 +59,31 @@ extern struct obstack *function_maybepermanent_obstack;\n    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))\n #endif\n \f\n-static rtx initialize_for_inline PROTO((tree, int, int, int, int));\n-static void finish_inline\tPROTO((tree, rtx));\n-static void adjust_copied_decl_tree PROTO((tree));\n-static tree copy_decl_list\tPROTO((tree));\n-static tree copy_decl_tree\tPROTO((tree));\n-static void copy_decl_rtls\tPROTO((tree));\n-static void save_constants\tPROTO((rtx *));\n-static void note_modified_parmregs PROTO((rtx, rtx));\n-static rtx copy_for_inline\tPROTO((rtx));\n-static void integrate_parm_decls PROTO((tree, struct inline_remap *, rtvec));\n-static void integrate_decl_tree\tPROTO((tree, int, struct inline_remap *));\n+static rtx initialize_for_inline\tPROTO((tree, int, int, int, int));\n+static void finish_inline\t\tPROTO((tree, rtx));\n+static void adjust_copied_decl_tree\tPROTO((tree));\n+static tree copy_decl_list\t\tPROTO((tree));\n+static tree copy_decl_tree\t\tPROTO((tree));\n+static void copy_decl_rtls\t\tPROTO((tree));\n+static void save_constants\t\tPROTO((rtx *));\n+static void note_modified_parmregs\tPROTO((rtx, rtx));\n+static rtx copy_for_inline\t\tPROTO((rtx));\n+static void integrate_parm_decls\tPROTO((tree, struct inline_remap *,\n+\t\t\t\t\t       rtvec));\n+static void integrate_decl_tree\t\tPROTO((tree, int,\n+\t\t\t\t\t       struct inline_remap *));\n static void save_constants_in_decl_trees PROTO ((tree));\n-static void subst_constants\tPROTO((rtx *, rtx, struct inline_remap *));\n-static void restore_constants\tPROTO((rtx *));\n-static void set_block_origin_self PROTO((tree));\n-static void set_decl_origin_self PROTO((tree));\n-static void set_block_abstract_flags PROTO((tree, int));\n+static void subst_constants\t\tPROTO((rtx *, rtx,\n+\t\t\t\t\t       struct inline_remap *));\n+static void restore_constants\t\tPROTO((rtx *));\n+static void set_block_origin_self\tPROTO((tree));\n+static void set_decl_origin_self\tPROTO((tree));\n+static void set_block_abstract_flags\tPROTO((tree, int));\n+static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n+\t\t\t\t\t       rtx));\n \n-void set_decl_abstract_flags\tPROTO((tree, int));\n+\n+void set_decl_abstract_flags\t\tPROTO((tree, int));\n static tree copy_and_set_decl_abstract_origin PROTO((tree));\n \f\n /* Returns the Ith entry in the label_map contained in MAP.  If the\n@@ -1300,6 +1306,38 @@ int global_const_equiv_map_size;\n    && REGNO (XEXP (X, 0)) >= FIRST_VIRTUAL_REGISTER\t\t\\\n    && REGNO (XEXP (X, 0)) <= LAST_VIRTUAL_REGISTER)\n \n+/* Called to set up a mapping for the case where a parameter is in a\n+   register.  If it is read-only and our argument is a constant, set up the\n+   constant equivalence.\n+\n+   If LOC is REG_USERVAR_P, the usual case, COPY must also have that flag set\n+   if it is a register.\n+\n+   Also, don't allow hard registers here; they might not be valid when\n+   substituted into insns.  */\n+static void\n+process_reg_param (map, loc, copy)\n+     struct inline_remap *map;\n+     rtx loc, copy;\n+{\n+  if ((GET_CODE (copy) != REG && GET_CODE (copy) != SUBREG)\n+      || (GET_CODE (copy) == REG && REG_USERVAR_P (loc)\n+\t  && ! REG_USERVAR_P (copy))\n+      || (GET_CODE (copy) == REG\n+\t  && REGNO (copy) < FIRST_PSEUDO_REGISTER))\n+    {\n+      rtx temp = copy_to_mode_reg (GET_MODE (loc), copy);\n+      REG_USERVAR_P (temp) = REG_USERVAR_P (loc);\n+      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t  && REGNO (temp) < map->const_equiv_map_size)\n+\t{\n+\t  map->const_equiv_map[REGNO (temp)] = copy;\n+\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t}\n+      copy = temp;\n+    }\n+  map->reg_map[REGNO (loc)] = copy;\n+}\n /* Integrate the procedure defined by FNDECL.  Note that this function\n    may wind up calling itself.  Since the static variables are not\n    reentrant, we do not assign them until after the possibility\n@@ -1610,87 +1648,16 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  ;\n \t}\n       else if (GET_CODE (loc) == REG)\n-\t{\n-\t  /* This is the good case where the parameter is in a register.\n-\t     If it is read-only and our argument is a constant, set up the\n-\t     constant equivalence.\n-\n-\t     If LOC is REG_USERVAR_P, the usual case, COPY must also have\n-\t     that flag set if it is a register.\n-\n-\t     Also, don't allow hard registers here; they might not be valid\n-\t     when substituted into insns.  */\n-\n-\t  if ((GET_CODE (copy) != REG && GET_CODE (copy) != SUBREG)\n-\t      || (GET_CODE (copy) == REG && REG_USERVAR_P (loc)\n-\t\t  && ! REG_USERVAR_P (copy))\n-\t      || (GET_CODE (copy) == REG\n-\t\t  && REGNO (copy) < FIRST_PSEUDO_REGISTER))\n-\t    {\n-\t      temp = copy_to_mode_reg (GET_MODE (loc), copy);\n-\t      REG_USERVAR_P (temp) = REG_USERVAR_P (loc);\n-\t      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n-\t\t  && REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = copy;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n-\t      copy = temp;\n-\t    }\n-\t  map->reg_map[REGNO (loc)] = copy;\n-\t}\n+\tprocess_reg_param (map, loc, copy);\n       else if (GET_CODE (loc) == CONCAT)\n \t{\n-\t  /* This is the good case where the parameter is in a\n-\t     pair of separate pseudos.\n-\t     If it is read-only and our argument is a constant, set up the\n-\t     constant equivalence.\n-\n-\t     If LOC is REG_USERVAR_P, the usual case, COPY must also have\n-\t     that flag set if it is a register.\n-\n-\t     Also, don't allow hard registers here; they might not be valid\n-\t     when substituted into insns.  */\n \t  rtx locreal = gen_realpart (GET_MODE (XEXP (loc, 0)), loc);\n \t  rtx locimag = gen_imagpart (GET_MODE (XEXP (loc, 0)), loc);\n \t  rtx copyreal = gen_realpart (GET_MODE (locreal), copy);\n \t  rtx copyimag = gen_imagpart (GET_MODE (locimag), copy);\n \n-\t  if ((GET_CODE (copyreal) != REG && GET_CODE (copyreal) != SUBREG)\n-\t      || (GET_CODE (copyreal) == REG && REG_USERVAR_P (locreal)\n-\t\t  && ! REG_USERVAR_P (copyreal))\n-\t      || (GET_CODE (copyreal) == REG\n-\t\t  && REGNO (copyreal) < FIRST_PSEUDO_REGISTER))\n-\t    {\n-\t      temp = copy_to_mode_reg (GET_MODE (locreal), copyreal);\n-\t      REG_USERVAR_P (temp) = REG_USERVAR_P (locreal);\n-\t      if ((CONSTANT_P (copyreal) || FIXED_BASE_PLUS_P (copyreal))\n-\t\t  && REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = copyreal;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n-\t      copyreal = temp;\n-\t    }\n-\t  map->reg_map[REGNO (locreal)] = copyreal;\n-\n-\t  if ((GET_CODE (copyimag) != REG && GET_CODE (copyimag) != SUBREG)\n-\t      || (GET_CODE (copyimag) == REG && REG_USERVAR_P (locimag)\n-\t\t  && ! REG_USERVAR_P (copyimag))\n-\t      || (GET_CODE (copyimag) == REG\n-\t\t  && REGNO (copyimag) < FIRST_PSEUDO_REGISTER))\n-\t    {\n-\t      temp = copy_to_mode_reg (GET_MODE (locimag), copyimag);\n-\t      REG_USERVAR_P (temp) = REG_USERVAR_P (locimag);\n-\t      if ((CONSTANT_P (copyimag) || FIXED_BASE_PLUS_P (copyimag))\n-\t\t  && REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = copyimag;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n-\t      copyimag = temp;\n-\t    }\n-\t  map->reg_map[REGNO (locimag)] = copyimag;\n+\t  process_reg_param (map, locreal, copyreal);\n+\t  process_reg_param (map, locimag, copyimag);\n \t}\n       else\n \tabort ();"}, {"sha": "f9a7d2e0a47cb1b0859bb704bf493902ed9414dc", "filename": "gcc/loop.c", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c3ddd83ae219749907c77f23787ffe085ed8c4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a4c3ddd83ae219749907c77f23787ffe085ed8c4", "patch": "@@ -3313,6 +3313,51 @@ find_single_use_in_loop (insn, x, usage)\n       }\n }\n \f\n+/* Count and record any set in X which is contained in INSN.  Update\n+   MAY_NOT_MOVE and LAST_SET for any register set in X.  */\n+\n+static void\n+count_one_set (insn, x, may_not_move, last_set)\n+     rtx insn, x;\n+     varray_type may_not_move;\n+     rtx *last_set;\n+{\n+  if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n+    /* Don't move a reg that has an explicit clobber.\n+       It's not worth the pain to try to do it correctly.  */\n+    VARRAY_CHAR (may_not_move, REGNO (XEXP (x, 0))) = 1;\n+\n+  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n+    {\n+      rtx dest = SET_DEST (x);\n+      while (GET_CODE (dest) == SUBREG\n+\t     || GET_CODE (dest) == ZERO_EXTRACT\n+\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t     || GET_CODE (dest) == STRICT_LOW_PART)\n+\tdest = XEXP (dest, 0);\n+      if (GET_CODE (dest) == REG)\n+\t{\n+\t  register int regno = REGNO (dest);\n+\t  /* If this is the first setting of this reg\n+\t     in current basic block, and it was set before,\n+\t     it must be set in two basic blocks, so it cannot\n+\t     be moved out of the loop.  */\n+\t  if (VARRAY_INT (n_times_set, regno) > 0 \n+\t      && last_set[regno] == 0)\n+\t    VARRAY_CHAR (may_not_move, regno) = 1;\n+\t  /* If this is not first setting in current basic block,\n+\t     see if reg was used in between previous one and this.\n+\t     If so, neither one can be moved.  */\n+\t  if (last_set[regno] != 0\n+\t      && reg_used_between_p (dest, last_set[regno], insn))\n+\t    VARRAY_CHAR (may_not_move, regno) = 1;\n+\t  if (VARRAY_INT (n_times_set, regno) < 127)\n+\t    ++VARRAY_INT (n_times_set, regno);\n+\t  last_set[regno] = insn;\n+\t}\n+    }\n+}\n+\n /* Increment N_TIMES_SET at the index of each register\n    that is modified by an insn between FROM and TO.\n    If the value of an element of N_TIMES_SET becomes 127 or more,\n@@ -3359,76 +3404,15 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t\tfind_single_use_in_loop (insn, REG_NOTES (insn), single_usage);\n \t    }\n \n-\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n-\t      && GET_CODE (XEXP (PATTERN (insn), 0)) == REG)\n-\t    /* Don't move a reg that has an explicit clobber.\n-\t       We might do so sometimes, but it's not worth the pain.  */\n-\t    VARRAY_CHAR (may_not_move, REGNO (XEXP (PATTERN (insn), 0))) = 1;\n-\n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    {\n-\t      dest = SET_DEST (PATTERN (insn));\n-\t      while (GET_CODE (dest) == SUBREG\n-\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n-\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\t\tdest = XEXP (dest, 0);\n-\t      if (GET_CODE (dest) == REG)\n-\t\t{\n-\t\t  register int regno = REGNO (dest);\n-\t\t  /* If this is the first setting of this reg\n-\t\t     in current basic block, and it was set before,\n-\t\t     it must be set in two basic blocks, so it cannot\n-\t\t     be moved out of the loop.  */\n-\t\t  if (VARRAY_INT (n_times_set, regno) > 0\n-\t\t      && last_set[regno] == 0)\n-\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t\t  /* If this is not first setting in current basic block,\n-\t\t     see if reg was used in between previous one and this.\n-\t\t     If so, neither one can be moved.  */\n-\t\t  if (last_set[regno] != 0\n-\t\t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t\t  if (VARRAY_INT (n_times_set, regno) < 127)\n-\t\t    ++VARRAY_INT (n_times_set, regno);\n-\t\t  last_set[regno] = insn;\n-\t\t}\n-\t    }\n+\t    count_one_set (insn, PATTERN (insn), may_not_move, last_set);\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t    {\n \t      register int i;\n \t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\t{\n-\t\t  register rtx x = XVECEXP (PATTERN (insn), 0, i);\n-\t\t  if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n-\t\t    /* Don't move a reg that has an explicit clobber.\n-\t\t       It's not worth the pain to try to do it correctly.  */\n-\t\t    VARRAY_CHAR (may_not_move, REGNO (XEXP (x, 0))) = 1;\n-\n-\t\t  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-\t\t    {\n-\t\t      dest = SET_DEST (x);\n-\t\t      while (GET_CODE (dest) == SUBREG\n-\t\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n-\t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\t\t\tdest = XEXP (dest, 0);\n-\t\t      if (GET_CODE (dest) == REG)\n-\t\t\t{\n-\t\t\t  register int regno = REGNO (dest);\n-\t\t\t  if (VARRAY_INT (n_times_set, regno) > 0 \n-\t\t\t      && last_set[regno] == 0)\n-\t\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t\t\t  if (last_set[regno] != 0\n-\t\t\t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t\t\t  if (VARRAY_INT (n_times_set, regno) < 127)\n-\t\t\t    ++VARRAY_INT (n_times_set, regno);\n-\t\t\t  last_set[regno] = insn;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t\tcount_one_set (insn, XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t       may_not_move, last_set);\n \t    }\n \t}\n "}]}