{"sha": "14c4815ece54b1e79459dad10d726fb755973761", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjNDgxNWVjZTU0YjFlNzk0NTlkYWQxMGQ3MjZmYjc1NTk3Mzc2MQ==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2010-11-09T07:36:26Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-11-09T07:36:26Z"}, "message": "gengtype.c (get_output_file_name): Declaration moved to gengtype.h.\n\n\n2010-11-09  Basile Starynkevitch  <basile@starynkevitch.net>\n\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\n\t* gengtype.c (get_output_file_name): Declaration moved to\n\tgengtype.h.\n\t(plugin_files, get_file_basename, get_file_realbasename)\n\t(get_file_langdir, error_at_line, gt_files, this_file)\n\t(system_h_file, read_input_list, create_field_all)\n\t(get_file_srcdir_relative_path, get_file_basename)\n\t(get_file_langdir, get_file_gtfilename)\n\t(get_output_file_with_visibility, get_output_file_name)\n\t(struct flist, put_mangled_filename, walk_type)\n\t(put_mangled_filename, finish_root_table, write_roots): Use\n\tinput_file-s.\n\t(lang_dir_names, num_lang_dirs): Remove static.\n\t(get_lang_bitmap, set_lang_bitmap): Moved to gengtype.h.\n\t(main): Use input_file-s.\n\n\t* gengtype.h:\n\t(struct input_file_st, input_file): New type.\n\t(struct fileloc): Use it.\n\t(gt_files, num_gt_files, this_file, system_h_file)\n\t(input_file_by_name, get_file_srcdir_relative_path): Use\n\tinput_file.\n\t(get_input_file_name): New function.\n\t(get_lang_bitmap, set_lang_bitmap): Moved from gengtype.c and\n        use input_file.\n\t(lang_dir_names, num_lang_dirs, get_output_file_with_visibility)\n\t(get_output_file_name): Ditto.\n\n\t* gengtype-lex.l (yybegin): Use input_file.\n\n\t* gengtype-parse.c (parse_error): Use input_file.\n\n\nCo-Authored-By: Jeremie Salvucci <jeremie.salvucci@free.fr>\n\nFrom-SVN: r166473", "tree": {"sha": "227ea04b374b375a8cc883b466664412b5110881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/227ea04b374b375a8cc883b466664412b5110881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14c4815ece54b1e79459dad10d726fb755973761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c4815ece54b1e79459dad10d726fb755973761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c4815ece54b1e79459dad10d726fb755973761", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c4815ece54b1e79459dad10d726fb755973761/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a5b7298d28035d8b64d1d37317cc73933e8b357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5b7298d28035d8b64d1d37317cc73933e8b357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5b7298d28035d8b64d1d37317cc73933e8b357"}], "stats": {"total": 426, "additions": 289, "deletions": 137}, "files": [{"sha": "4fc11ac9f4629ad627e25d9e6b54fd2c553ef73b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c4815ece54b1e79459dad10d726fb755973761/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c4815ece54b1e79459dad10d726fb755973761/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14c4815ece54b1e79459dad10d726fb755973761", "patch": "@@ -1,3 +1,38 @@\n+\n+2010-11-09  Basile Starynkevitch  <basile@starynkevitch.net>\n+\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\n+\t* gengtype.c (get_output_file_name): Declaration moved to\n+\tgengtype.h.\n+\t(plugin_files, get_file_basename, get_file_realbasename)\n+\t(get_file_langdir, error_at_line, gt_files, this_file)\n+\t(system_h_file, read_input_list, create_field_all)\n+\t(get_file_srcdir_relative_path, get_file_basename)\n+\t(get_file_langdir, get_file_gtfilename)\n+\t(get_output_file_with_visibility, get_output_file_name)\n+\t(struct flist, put_mangled_filename, walk_type)\n+\t(put_mangled_filename, finish_root_table, write_roots): Use\n+\tinput_file-s.\n+\t(lang_dir_names, num_lang_dirs): Remove static.\n+\t(get_lang_bitmap, set_lang_bitmap): Moved to gengtype.h.\n+\t(main): Use input_file-s.\n+\n+\t* gengtype.h:\n+\t(struct input_file_st, input_file): New type.\n+\t(struct fileloc): Use it.\n+\t(gt_files, num_gt_files, this_file, system_h_file)\n+\t(input_file_by_name, get_file_srcdir_relative_path): Use\n+\tinput_file.\n+\t(get_input_file_name): New function.\n+\t(get_lang_bitmap, set_lang_bitmap): Moved from gengtype.c and\n+        use input_file.\n+\t(lang_dir_names, num_lang_dirs, get_output_file_with_visibility)\n+\t(get_output_file_name): Ditto.\n+\n+\t* gengtype-lex.l (yybegin): Use input_file.\n+\n+\t* gengtype-parse.c (parse_error): Use input_file.\n+\n 2010-11-08  Xinliang David Li  <davidxl@google.com>\n \n \tPR tree-optimization/46316"}, {"sha": "d9f8da400d32a5fe654decfbf314bfb7177c0d36", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=14c4815ece54b1e79459dad10d726fb755973761", "patch": "@@ -202,7 +202,7 @@ yybegin (const char *fname)\n       perror (fname);\n       exit (1);\n     }\n-  lexer_line.file = fname;\n+  lexer_line.file = input_file_by_name (fname);\n   lexer_line.line = 1;\n }\n "}, {"sha": "0f2e0c6463b2290c1cd9c9bb77c90ea8e5419a95", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=14c4815ece54b1e79459dad10d726fb755973761", "patch": "@@ -135,7 +135,8 @@ parse_error (const char *msg, ...)\n {\n   va_list ap;\n \n-  fprintf (stderr, \"%s:%d: parse error: \", lexer_line.file, lexer_line.line);\n+  fprintf (stderr, \"%s:%d: parse error: \", \n+\t   get_input_file_name (lexer_line.file), lexer_line.line);\n \n   va_start (ap, msg);\n   vfprintf (stderr, msg, ap);"}, {"sha": "1a80cdff21878acb115c27e25ab5dfefc1ad6a6c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 166, "deletions": 131, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=14c4815ece54b1e79459dad10d726fb755973761", "patch": "@@ -128,7 +128,6 @@ struct type\n \n \n \n-const char *get_output_file_name (const char *);\n \n \n /* The list of output files.  */\n@@ -144,7 +143,7 @@ static char *inputlist;\n \n /* The plugin input files and their number; in that case only\n    a single file is produced.  */\n-static char **plugin_files;\n+static input_file **plugin_files;\n static size_t nb_plugin_files;\n \n /* The generated plugin output file and name.  */\n@@ -174,12 +173,11 @@ static const char* backup_dir;\t/* (-B) program option.  */\n \n static outf_p create_file (const char *, const char *);\n \n-static const char *get_file_basename (const char *);\n-static const char *get_file_realbasename (const char *);\n-static const char *get_file_srcdir_relative_path (const char *);\n+static const char *get_file_basename (const input_file *);\n+static const char *get_file_realbasename (const input_file *);\n \n static int get_prefix_langdir_index (const char *);\n-static const char *get_file_langdir (const char *);\n+static const char *get_file_langdir (const input_file *);\n \f\n \n /* Nonzero iff an error has occurred.  */\n@@ -197,9 +195,10 @@ error_at_line (const struct fileloc *pos, const char *msg, ...)\n {\n   va_list ap;\n \n+  gcc_assert (pos != NULL && pos->file != NULL);\n   va_start (ap, msg);\n \n-  fprintf (stderr, \"%s:%d: \", pos->file, pos->line);\n+  fprintf (stderr, \"%s:%d: \", get_input_file_name (pos->file), pos->line);\n   vfprintf (stderr, msg, ap);\n   fputc ('\\n', stderr);\n   hit_error = true;\n@@ -227,69 +226,24 @@ xasprintf (const char *format, ...)\n /* Input file handling. */\n \n /* Table of all input files.  */\n-static const char **gt_files;\n-static size_t num_gt_files;\n+const input_file **gt_files;\n+size_t num_gt_files;\n \n-/* A number of places use the name of this \"gengtype.h\" file for a\n+/* A number of places use the name of this \"gengtype.c\" file for a\n    location for things that we can't rely on the source to define.\n    Make sure we can still use pointer comparison on filenames.  */\n-const char this_file[] = __FILE__;\n+input_file* this_file;\n /* The \"system.h\" file is likewise specially useful.  */\n-const char system_h_file[] = \"system.h\";\n+input_file* system_h_file;\n \n /* Vector of per-language directories.  */\n-static const char **lang_dir_names;\n-static size_t num_lang_dirs;\n+const char **lang_dir_names;\n+size_t num_lang_dirs;\n \n /* An array of output files suitable for definitions.  There is one\n    BASE_FILES entry for each language.  */\n static outf_p *base_files;\n \n-/* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff\n-   INPUT_FILE is used by <lang>.\n-\n-   This function should be written to assume that a file _is_ used\n-   if the situation is unclear.  If it wrongly assumes a file _is_ used,\n-   a linker error will result.  If it wrongly assumes a file _is not_ used,\n-   some GC roots may be missed, which is a much harder-to-debug problem.\n-\n-   The relevant bitmap is stored immediately before the file's name in the\n-   buffer set up by read_input_list.  It may be unaligned, so we have to\n-   read it byte-by-byte.  */\n-\n-static lang_bitmap\n-get_lang_bitmap (const char *gtfile)\n-{\n-\n-  if (gtfile == this_file || gtfile == system_h_file)\n-    {\n-      /* Things defined in this \"gengtype.c\" file or in \"system.h\" are\n-\t universal (and there is no space for their lang_bitmap before\n-\t their file names).  */\n-      return (((lang_bitmap) 1) << num_lang_dirs) - 1;\n-    }\n-  else\n-    {\n-      lang_bitmap n = 0;\n-      int i;\n-      for (i = -(int) sizeof (lang_bitmap); i < 0; i++)\n-\tn = (n << CHAR_BIT) + (unsigned char) gtfile[i];\n-      return n;\n-    }\n-}\n-\n-/* Set the bitmap returned by get_lang_bitmap.  The only legitimate\n-   caller of this function is read_input_list.  */\n-static void\n-set_lang_bitmap (char *gtfile, lang_bitmap n)\n-{\n-  int i;\n-  for (i = -1; i >= -(int) sizeof (lang_bitmap); i--)\n-    {\n-      gtfile[i] = n & ((1U << CHAR_BIT) - 1);\n-      n >>= CHAR_BIT;\n-    }\n-}\n \n \n #if ENABLE_CHECKING\n@@ -482,11 +436,11 @@ read_input_list (const char *listname)\n       size_t nfiles = 0;\n       lang_bitmap curlangs = (1 << num_lang_dirs) - 1;\n \n-      epos.file = listname;\n+      epos.file = input_file_by_name (listname);\n       epos.line = 0;\n \n       lang_dir_names = XNEWVEC (const char *, num_lang_dirs);\n-      gt_files = XNEWVEC (const char *, num_gt_files);\n+      gt_files = XNEWVEC (const input_file *, num_gt_files);\n \n       for (;;)\n \t{\n@@ -517,13 +471,16 @@ read_input_list (const char *listname)\n \t  else\n \t    {\n \t      size_t i;\n+\t      input_file *inpf = input_file_by_name (line);\n \t      gcc_assert (nfiles <= num_gt_files);\n \t      for (i = 0; i < nfiles; i++)\n-\t\tif (strcmp (gt_files[i], line) == 0)\n+\t\t/* Since the input_file-s are uniquely hash-consed, we\n+\t\t   can just compare pointers! */\n+\t\tif (gt_files[i] == inpf)\n \t\t  {\n \t\t    /* Throw away the string we just read, and add the\n \t\t       current language to the existing string's bitmap.  */\n-\t\t    lang_bitmap bmap = get_lang_bitmap (gt_files[i]);\n+\t\t    lang_bitmap bmap = get_lang_bitmap (inpf);\n \t\t    if (bmap & curlangs)\n \t\t      error_at_line (&epos,\n \t\t\t\t     \"file %s specified more than once \"\n@@ -533,13 +490,13 @@ read_input_list (const char *listname)\n \t\t\t\t\t\t\t\t  1]);\n \n \t\t    bmap |= curlangs;\n-\t\t    set_lang_bitmap (CONST_CAST (char *, gt_files[i]), bmap);\n+\t\t    set_lang_bitmap (inpf, bmap);\n \t\t    here = committed;\n \t\t    goto next_line;\n \t\t  }\n \n-\t      set_lang_bitmap (line, curlangs);\n-\t      gt_files[nfiles++] = line;\n+\t      set_lang_bitmap (inpf, curlangs);\n+\t      gt_files[nfiles++] = inpf;\n \t    }\n \t}\n       /* Update the global counts now that we know accurately how many\n@@ -886,7 +843,7 @@ note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)\n /* Most-general structure field creator.  */\n static pair_p\n create_field_all (pair_p next, type_p type, const char *name, options_p opt,\n-\t\t  const char *file, int line)\n+\t\t  const input_file *inpf, int line)\n {\n   pair_p field;\n \n@@ -895,7 +852,7 @@ create_field_all (pair_p next, type_p type, const char *name, options_p opt,\n   field->type = type;\n   field->name = name;\n   field->opt = opt;\n-  field->line.file = file;\n+  field->line.file = inpf;\n   field->line.line = line;\n   return field;\n }\n@@ -1649,40 +1606,43 @@ open_base_files (void)\n   }\n }\n \n-/* For F a filename, return the real basename of F, with all the directory\n-   components skipped.  */\n+/* For INPF an input file, return the real basename of INPF, with all\n+   the directory components skipped.  */\n \n static const char *\n-get_file_realbasename (const char *f)\n+get_file_realbasename (const input_file *inpf)\n {\n+  const char *f = get_input_file_name (inpf);\n   const char *lastslash = strrchr (f, '/');\n \n   return (lastslash != NULL) ? lastslash + 1 : f;\n }\n \n-/* For F a filename, return the relative path to F from $(srcdir) if the\n-   latter is a prefix in F, NULL otherwise.  */\n+/* For INPF a filename, return the relative path to INPF from\n+   $(srcdir) if the latter is a prefix in INPF, NULL otherwise.  */\n \n-static const char *\n-get_file_srcdir_relative_path (const char *f)\n+const char *\n+get_file_srcdir_relative_path (const input_file *inpf)\n {\n+  const char *f = get_input_file_name (inpf);\n   if (strlen (f) > srcdir_len\n       && IS_DIR_SEPARATOR (f[srcdir_len])\n-      && memcmp (f, srcdir, srcdir_len) == 0)\n+      && strncmp (f, srcdir, srcdir_len) == 0)\n     return f + srcdir_len + 1;\n   else\n     return NULL;\n }\n \n-/* For F a filename, return the relative path to F from $(srcdir) if the\n-   latter is a prefix in F, or the real basename of F otherwise.  */\n+/*  For INPF an input_file, return the relative path to INPF from\n+    $(srcdir) if the latter is a prefix in INPF, or the real basename\n+    of INPF otherwise. */\n \n static const char *\n-get_file_basename (const char *f)\n+get_file_basename (const input_file *inpf)\n {\n-  const char *srcdir_path = get_file_srcdir_relative_path (f);\n+  const char *srcdir_path = get_file_srcdir_relative_path (inpf);\n \n-  return (srcdir_path != NULL) ? srcdir_path : get_file_realbasename (f);\n+  return (srcdir_path != NULL) ? srcdir_path : get_file_realbasename (inpf);\n }\n \n /* For F a filename, return the lang_dir_names relative index of the language\n@@ -1708,18 +1668,19 @@ get_prefix_langdir_index (const char *f)\n   return -1;\n }\n \n-/* For F a filename, return the name of language directory where F is located,\n-   if any, NULL otherwise.  */\n+/* For INPF an input file, return the name of language directory where\n+   F is located, if any, NULL otherwise.  */\n \n static const char *\n-get_file_langdir (const char *f)\n+get_file_langdir (const input_file *inpf)\n {\n-  /* Get the relative path to F from $(srcdir) and find the language by\n-     comparing the prefix with language directory names.  If F is not even\n-     srcdir relative, no point in looking further.  */\n+  /* Get the relative path to INPF from $(srcdir) and find the\n+     language by comparing the prefix with language directory names.\n+     If INPF is not even srcdir relative, no point in looking\n+     further.  */\n \n   int lang_index;\n-  const char *srcdir_relative_path = get_file_srcdir_relative_path (f);\n+  const char *srcdir_relative_path = get_file_srcdir_relative_path (inpf);\n   const char *r;\n \n   if (!srcdir_relative_path)\n@@ -1736,16 +1697,16 @@ get_file_langdir (const char *f)\n   return r;\n }\n \n-/* The gt- output file name for F.  */\n+/* The gt- output file name for INPF.  */\n \n static const char *\n-get_file_gtfilename (const char *f)\n+get_file_gtfilename (const input_file *inpf)\n {\n   /* Cook up an initial version of the gt- file name from the file real\n      basename and the language name, if any.  */\n \n-  const char *basename = get_file_realbasename (f);\n-  const char *langdir = get_file_langdir (f);\n+  const char *basename = get_file_realbasename (inpf);\n+  const char *langdir = get_file_langdir (inpf);\n \n   char *result =\n     (langdir ? xasprintf (\"gt-%s-%s\", langdir, basename)\n@@ -1767,11 +1728,12 @@ get_file_gtfilename (const char *f)\n }\n \n /* An output file, suitable for definitions, that can see declarations\n-   made in INPUT_FILE and is linked into every language that uses\n-   INPUT_FILE.  */\n+   made in INPF and is linked into every language that uses INPF.\n+   Since the the result is cached inside INPF, that argument cannot be\n+   declared constant, but is \"almost\" constant. */\n \n outf_p\n-get_output_file_with_visibility (const char *input_file)\n+get_output_file_with_visibility (input_file *inpf)\n {\n   outf_p r;\n   size_t len;\n@@ -1782,30 +1744,30 @@ get_output_file_with_visibility (const char *input_file)\n   /* This can happen when we need a file with visibility on a\n      structure that we've never seen.  We have to just hope that it's\n      globally visible.  */\n-  if (input_file == NULL)\n-    input_file = \"system.h\";\n+  if (inpf == NULL)\n+    inpf = system_h_file;\n \n   /* In plugin mode, return NULL unless the input_file is one of the\n      plugin_files.  */\n   if (plugin_files)\n     {\n       size_t i;\n       for (i = 0; i < nb_plugin_files; i++)\n-\tif (strcmp (input_file, plugin_files[i]) == 0)\n+\tif (inpf == plugin_files[i])\n \t  return plugin_output;\n \n       return NULL;\n     }\n \n   /* Determine the output file name.  */\n-  basename = get_file_basename (input_file);\n+  basename = get_file_basename (inpf);\n \n   len = strlen (basename);\n   if ((len > 2 && memcmp (basename + len - 2, \".c\", 2) == 0)\n       || (len > 2 && memcmp (basename + len - 2, \".y\", 2) == 0)\n       || (len > 3 && memcmp (basename + len - 3, \".in\", 3) == 0))\n     {\n-      output_name = get_file_gtfilename (input_file);\n+      output_name = get_file_gtfilename (inpf);\n       for_name = basename;\n     }\n   /* Some headers get used by more than one front-end; hence, it\n@@ -1858,13 +1820,13 @@ get_output_file_with_visibility (const char *input_file)\n }\n \n /* The name of an output file, suitable for definitions, that can see\n-   declarations made in INPUT_FILE and is linked into every language\n-   that uses INPUT_FILE.  */\n+   declarations made in INPF and is linked into every language that\n+   uses INPF.  */\n \n const char *\n-get_output_file_name (const char *input_file)\n+get_output_file_name (input_file* inpf)\n {\n-  outf_p o = get_output_file_with_visibility (input_file);\n+  outf_p o = get_output_file_with_visibility (inpf);\n   if (o)\n     return o->name;\n   return NULL;\n@@ -1956,7 +1918,7 @@ struct flist\n {\n   struct flist *next;\n   int started_p;\n-  const char *name;\n+  const input_file* file;\n   outf_p f;\n };\n \n@@ -2002,7 +1964,7 @@ static void write_local (outf_p output_header,\n \t\t\t type_p structures, type_p param_structs);\n static void write_enum_defn (type_p structures, type_p param_structs);\n static int contains_scalar_p (type_p t);\n-static void put_mangled_filename (outf_p, const char *);\n+static void put_mangled_filename (outf_p, const input_file *);\n static void finish_root_table (struct flist *flp, const char *pfx,\n \t\t\t       const char *tname, const char *lastname,\n \t\t\t       const char *name);\n@@ -2470,7 +2432,8 @@ walk_type (type_p t, struct walk_type_data *d)\n \t      {\n \t\tfprintf (stderr,\n \t\t\t \"%s:%d: warning: field `%s' is missing `tag' or `default' option\\n\",\n-\t\t\t d->line->file, d->line->line, f->name);\n+\t\t\t get_input_file_name (d->line->file), d->line->line, \n+\t\t\t f->name);\n \t\tcontinue;\n \t      }\n \t    else if (union_p && !(default_p || tagid))\n@@ -2637,7 +2600,7 @@ output_type_enum (outf_p of, type_p s)\n static outf_p\n get_output_file_for_structure (const_type_p s, type_p *param)\n {\n-  const char *fn;\n+  const input_file *fn;\n   int i;\n \n   gcc_assert (UNION_OR_STRUCT_P (s));\n@@ -2649,7 +2612,9 @@ get_output_file_for_structure (const_type_p s, type_p *param)\n \t&& UNION_OR_STRUCT_P (param[i]->u.p))\n       fn = param[i]->u.p->u.s.line.file;\n \n-  return get_output_file_with_visibility (fn);\n+  /* The call to get_output_file_with_visibility may update fn by\n+     caching its result inside, so we need the CONST_CAST.  */\n+  return get_output_file_with_visibility (CONST_CAST (input_file*, fn));\n }\n \n /* For S, a structure that's part of ORIG_S, and using parameters\n@@ -3220,12 +3185,15 @@ contains_scalar_p (type_p t)\n     }\n }\n \n-/* Mangle FN and print it to F.  */\n+/* Mangle INPF and print it to F.  */\n \n static void\n-put_mangled_filename (outf_p f, const char *fn)\n+put_mangled_filename (outf_p f, const input_file *inpf)\n {\n-  const char *name = get_output_file_name (fn);\n+  /* The call to get_output_file_name may indirectly update fn since\n+     get_output_file_with_visibility caches its result inside, so we\n+     need the CONST_CAST.  */\n+  const char *name = get_output_file_name (CONST_CAST (input_file*, inpf));\n   if (!f || !name)\n     return;\n   for (; *name != 0; name++)\n@@ -3255,15 +3223,15 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n   for (fli2 = flp; fli2 && base_files; fli2 = fli2->next)\n     if (fli2->started_p)\n       {\n-\tlang_bitmap bitmap = get_lang_bitmap (fli2->name);\n+\tlang_bitmap bitmap = get_lang_bitmap (fli2->file);\n \tint fnum;\n \n \tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n \t  if (bitmap & 1)\n \t    {\n \t      oprintf (base_files[fnum],\n \t\t       \"extern const struct %s gt_%s_\", tname, pfx);\n-\t      put_mangled_filename (base_files[fnum], fli2->name);\n+\t      put_mangled_filename (base_files[fnum], fli2->file);\n \t      oprintf (base_files[fnum], \"[];\\n\");\n \t    }\n       }\n@@ -3279,7 +3247,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n       {\n-\tlang_bitmap bitmap = get_lang_bitmap (fli2->name);\n+\tlang_bitmap bitmap = get_lang_bitmap (fli2->file);\n \tint fnum;\n \n \tfli2->started_p = 0;\n@@ -3288,7 +3256,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \t  if (bitmap & 1)\n \t    {\n \t      oprintf (base_files[fnum], \"  gt_%s_\", pfx);\n-\t      put_mangled_filename (base_files[fnum], fli2->name);\n+\t      put_mangled_filename (base_files[fnum], fli2->file);\n \t      oprintf (base_files[fnum], \",\\n\");\n \t    }\n       }\n@@ -3586,7 +3554,9 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = \n+\tget_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t     v->line.file));\n       struct flist *fli;\n       const char *length = NULL;\n       int deletable_p = 0;\n@@ -3618,8 +3588,8 @@ write_roots (pair_p variables, bool emit_pch)\n \t  fli->f = f;\n \t  fli->next = flp;\n \t  fli->started_p = 0;\n-\t  fli->name = v->line.file;\n-\t  gcc_assert (fli->name);\n+\t  fli->file = v->line.file;\n+\t  gcc_assert (fli->file);\n \t  flp = fli;\n \n \t  oprintf (f, \"\\n/* GC roots.  */\\n\\n\");\n@@ -3638,7 +3608,8 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n       struct flist *fli;\n       int skip_p = 0;\n       int length_p = 0;\n@@ -3674,7 +3645,8 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n       struct flist *fli;\n       int skip_p = 1;\n       options_p o;\n@@ -3709,7 +3681,8 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n       struct flist *fli;\n       const char *if_marked = NULL;\n       int length_p = 0;\n@@ -3757,7 +3730,8 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n       struct flist *fli;\n       int length_p = 0;\n       int if_marked_p = 0;\n@@ -3792,7 +3766,8 @@ write_roots (pair_p variables, bool emit_pch)\n \n   for (v = variables; v; v = v->next)\n     {\n-      outf_p f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n       struct flist *fli;\n       int skip_p = 0;\n       options_p o;\n@@ -4187,7 +4162,8 @@ dump_options (int indent, options_p opt)\n static void\n dump_fileloc (int indent, struct fileloc line)\n {\n-  printf (\"%*cfileloc: file = %s, line = %d\\n\", indent, ' ', line.file,\n+  printf (\"%*cfileloc: file = %s, line = %d\\n\", indent, ' ', \n+\t  get_input_file_name (line.file),\n \t  line.line);\n }\n \n@@ -4487,16 +4463,68 @@ parse_program_options (int argc, char **argv)\n       if (optind >= argc)\n \tfatal (\"no source files given in plugin mode\");\n       nb_plugin_files = argc - optind;\n-      plugin_files = XNEWVEC (char*, nb_plugin_files);\n+      plugin_files = XNEWVEC (input_file*, nb_plugin_files);\n       for (i = 0; i < (int) nb_plugin_files; i++)\n \t{\n \t  char *name = argv[i + optind];\n-\t  plugin_files[i] = name;\n+\t  plugin_files[i] = input_file_by_name (name);\n \t}\n     }\n }\n \n \n+\f\n+/******* Manage input files.  ******/\n+\n+/* Hash table of unique input file names.  */\n+static htab_t input_file_htab;\n+\n+/* Find or allocate a new input_file by hash-consing it.  */\n+input_file*\n+input_file_by_name (const char* name)\n+{\n+  PTR* slot;\n+  input_file* f = NULL;\n+  int namlen = 0;\n+  if (!name)\n+    return NULL;\n+  namlen = strlen (name);\n+  f = XCNEWVAR (input_file, sizeof (input_file)+namlen+2);\n+  f->inpbitmap = 0;\n+  f->inpoutf = NULL;\n+  strcpy (f->inpname, name);\n+  slot = htab_find_slot (input_file_htab, f, INSERT);\n+  gcc_assert (slot != NULL);\n+  if (*slot)\n+    {\n+      /* Already known input file.  */\n+      free (f);\n+      return (input_file*)(*slot);\n+    }\n+  /* New input file.  */\n+  *slot = f;\n+  return f;\n+    }\n+\n+/* Hash table support routines for input_file-s.  */\n+static hashval_t\n+htab_hash_inputfile (const void *p)\n+{\n+  const input_file *inpf = (const input_file *) p;\n+  gcc_assert (inpf);\n+  return htab_hash_string (get_input_file_name (inpf));\n+}\n+\n+static int\n+htab_eq_inputfile (const void *x, const void *y)\n+{\n+  const input_file *inpfx = (const input_file *) x;\n+  const input_file *inpfy = (const input_file *) y;\n+  gcc_assert (inpfx != NULL && inpfy != NULL);\n+  return !strcmp (get_input_file_name (inpfx), get_input_file_name (inpfy));\n+}\n+\n+\n int\n main (int argc, char **argv)\n {\n@@ -4506,6 +4534,12 @@ main (int argc, char **argv)\n \n   /* Mandatory common initializations.  */\n   progname = \"gengtype\";\t/* For fatal and messages.  */\n+  /* Create the hash-table used to hash-cons input files.  */\n+  input_file_htab =\n+    htab_create (800, htab_hash_inputfile, htab_eq_inputfile, NULL);\n+  /* Initialize our special input files.  */\n+  this_file = input_file_by_name (__FILE__);\n+  system_h_file = input_file_by_name (\"system.h\");\n   /* Set the scalar_is_char union number for predefined scalar types.  */\n   scalar_nonchar.u.scalar_is_char = FALSE;\n   scalar_char.u.scalar_is_char = TRUE;\n@@ -4552,8 +4586,9 @@ main (int argc, char **argv)\n       read_input_list (inputlist);\n       for (i = 0; i < num_gt_files; i++)\n \t{\n-\t  parse_file (gt_files[i]);\n-\t  DBGPRINTF (\"parsed file #%d %s\", (int) i, gt_files[i]);\n+\t  parse_file (get_input_file_name (gt_files[i]));\n+\t  DBGPRINTF (\"parsed file #%d %s\", \n+\t\t     (int) i, get_input_file_name (gt_files[i]));\n \t}\n       if (verbosity_level >= 1)\n \tprintf (\"%s parsed %d files\\n\", progname, (int) num_gt_files);\n@@ -4572,7 +4607,7 @@ main (int argc, char **argv)\n     {\n       size_t ix = 0;\n       /* In plugin mode, we should have read a state file, and have\n-         given at least one plugin file.  */\n+\t given at least one plugin file.  */\n       if (!read_state_filename)\n \tfatal (\"No read state given in plugin mode for %s\",\n \t       plugin_output_filename);\n@@ -4583,7 +4618,7 @@ main (int argc, char **argv)\n \n       /* Parse our plugin files.  */\n       for (ix = 0; ix < nb_plugin_files; ix++)\n-\tparse_file (plugin_files[ix]);\n+\tparse_file (get_input_file_name (plugin_files[ix]));\n \n       if (hit_error)\n \treturn 1;"}, {"sha": "77f121e6c580e51ea8245fcfe7d3fda8d58218ac", "filename": "gcc/gengtype.h", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c4815ece54b1e79459dad10d726fb755973761/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=14c4815ece54b1e79459dad10d726fb755973761", "patch": "@@ -25,14 +25,87 @@\n    represented by a bitmap.  */\n typedef unsigned lang_bitmap;\n \n+/* Variable length structure representing an input file.  A hash table\n+   ensure uniqueness for a given input file name.  The only function\n+   allocating input_file-s is input_file_by_name.  */\n+struct input_file_st \n+{\n+  struct outf* inpoutf;  /* Cached corresponding output file, computed\n+                            in get_output_file_with_visibility.  */\n+  lang_bitmap inpbitmap; /* The set of languages using this file.  */\n+  char inpname[1];       /* A variable-length array, ended by a null\n+                            char.  */\n+};\n+typedef struct input_file_st input_file;\n+\n /* A file position, mostly for error messages.\n    The FILE element may be compared using pointer equality.  */\n struct fileloc\n {\n-  const char *file;\n+  const input_file *file;\n   int line;\n };\n \n+\n+/* Table of all input files and its size.  */\n+extern const input_file** gt_files;\n+extern size_t num_gt_files;\n+\n+/* A number of places use the name of this \"gengtype.c\" file for a\n+   location for things that we can't rely on the source to define.  We\n+   also need to refer to the \"system.h\" file specifically.  These two\n+   pointers are initialized early in main.  */\n+extern input_file* this_file;\n+extern input_file* system_h_file;\n+\n+/* Retrieve or create the input_file for a given name, which is a file\n+   path.  This is the only function allocating input_file-s and it is\n+   hash-consing them.  */\n+input_file* input_file_by_name (const char* name);\n+\n+/* For F an input_file, return the relative path to F from $(srcdir)\n+   if the latter is a prefix in F, NULL otherwise.  */\n+const char *get_file_srcdir_relative_path (const input_file *inpf);\n+\n+/* Get the name of an input file.  */\n+static inline const char*\n+get_input_file_name (const input_file *inpf)\n+{\n+  if (inpf)\n+      return inpf->inpname;\n+  return NULL;\n+}\n+\n+/* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff\n+   INPUT_FILE is used by <lang>.\n+\n+   This function should be written to assume that a file _is_ used\n+   if the situation is unclear.  If it wrongly assumes a file _is_ used,\n+   a linker error will result.  If it wrongly assumes a file _is not_ used,\n+   some GC roots may be missed, which is a much harder-to-debug problem.\n+  */\n+\n+static inline lang_bitmap\n+get_lang_bitmap (const input_file* inpf)\n+{\n+  if (inpf == NULL)\n+    return 0;\n+  return inpf->inpbitmap;\n+}\n+\n+/* Set the bitmap returned by get_lang_bitmap.  The only legitimate\n+   callers of this function are read_input_list & read_state_*.  */\n+static inline void\n+set_lang_bitmap (input_file* inpf, lang_bitmap n)\n+{\n+  gcc_assert (inpf);\n+  inpf->inpbitmap = n;\n+}\n+\n+/* Vector of per-language directories.  */\n+extern const char **lang_dir_names;\n+extern size_t num_lang_dirs;\n+\n /* Data types handed around within, but opaque to, the lexer and parser.  */\n typedef struct pair *pair_p;\n typedef struct type *type_p;\n@@ -67,9 +140,17 @@ oprintf (outf_p o, const char *S, ...)\n   ATTRIBUTE_PRINTF_2;\n \n /* An output file, suitable for definitions, that can see declarations\n-   made in INPUT_FILE and is linked into every language that uses\n-   INPUT_FILE.  May return NULL in plugin mode.  */\n-extern outf_p get_output_file_with_visibility (const char *input_file);\n+   made in INPF and is linked into every language that uses INPF.  May\n+   return NULL in plugin mode.  The INPF argument is almost const, but\n+   since the result is cached in its inpoutf field it cannot be\n+   declared const.  */\n+outf_p get_output_file_with_visibility (input_file* inpf);\n+\n+/* The name of an output file, suitable for definitions, that can see\n+   declarations made in INPF and is linked into every language that\n+   uses INPF.  May return NULL.  */\n+const char *get_output_file_name (input_file *inpf);\n+\n \n /* Source directory.  */\n extern const char *srcdir;\t/* (-S) program argument. */"}]}