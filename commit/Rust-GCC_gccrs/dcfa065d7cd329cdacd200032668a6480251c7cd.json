{"sha": "dcfa065d7cd329cdacd200032668a6480251c7cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNmYTA2NWQ3Y2QzMjljZGFjZDIwMDAzMjY2OGE2NDgwMjUxYzdjZA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2008-04-08T06:50:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:50:34Z"}, "message": "exp_ch7.adb (Find_Final_List): Change the test for generating a selected component from an access type's...\n\n2008-04-08  Gary Dismukes  <dismukes@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb (Find_Final_List): Change the test for generating a\n\tselected component from an access type's Associated_Final_Chain to\n\tcheck for the presence of that field, rather than assuming it exists\n\tfor all named access types.\n\t(Make_Clean): New formal Chained_Cleanup_Action allowing to specify a\n\tprocedure to call at the end of the generated cleanup procedure.\n\t(Expand_Cleanup_Actions): When a new cleanup procedure is generated, and\n\tand an At_End_Proc already exists in the handled sequence of statements\n\tfor which cleanup actions are being expanded, the original cleanup\n\taction must be preserved.\n\nFrom-SVN: r134029", "tree": {"sha": "bd2575cfbe03f09f77f3d9f21eb0bcc61245288f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd2575cfbe03f09f77f3d9f21eb0bcc61245288f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcfa065d7cd329cdacd200032668a6480251c7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfa065d7cd329cdacd200032668a6480251c7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfa065d7cd329cdacd200032668a6480251c7cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfa065d7cd329cdacd200032668a6480251c7cd/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70f9118087173b00e6aed0bcd14a5e901955ddf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f9118087173b00e6aed0bcd14a5e901955ddf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f9118087173b00e6aed0bcd14a5e901955ddf0"}], "stats": {"total": 113, "additions": 74, "deletions": 39}, "files": [{"sha": "916f7af0a10b1fe1121c7170625b77f7fdd18a9f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfa065d7cd329cdacd200032668a6480251c7cd/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfa065d7cd329cdacd200032668a6480251c7cd/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=dcfa065d7cd329cdacd200032668a6480251c7cd", "patch": "@@ -137,18 +137,20 @@ package body Exp_Ch7 is\n       Is_Master                  : Boolean;\n       Is_Protected_Subprogram    : Boolean;\n       Is_Task_Allocation_Block   : Boolean;\n-      Is_Asynchronous_Call_Block : Boolean) return Node_Id;\n-   --  Expand the clean-up procedure for controlled and/or transient\n-   --  block, and/or task master or task body, or blocks used to\n-   --  implement task allocation or asynchronous entry calls, or\n-   --  procedures used to implement protected procedures. Clean is the\n-   --  entity for such a procedure. Mark is the entity for the secondary\n-   --  stack mark, if empty only controlled block clean-up will be\n-   --  performed. Flist is the entity for the local final list, if empty\n-   --  only transient scope clean-up will be performed. The flags\n-   --  Is_Task and Is_Master control the calls to the corresponding\n-   --  finalization actions for a task body or for an entity that is a\n-   --  task master.\n+      Is_Asynchronous_Call_Block : Boolean;\n+      Chained_Cleanup_Action     : Node_Id) return Node_Id;\n+   --  Expand the clean-up procedure for a controlled and/or transient block,\n+   --  and/or task master or task body, or a block used to  implement task\n+   --  allocation or asynchronous entry calls, or a procedure used to implement\n+   --  protected procedures. Clean is the entity for such a procedure. Mark\n+   --  is the entity for the secondary stack mark, if empty only controlled\n+   --  block clean-up will be performed. Flist is the entity for the local\n+   --  final list, if empty only transient scope clean-up will be performed.\n+   --  The flags Is_Task and Is_Master control the calls to the corresponding\n+   --  finalization actions for a task body or for an entity that is a task\n+   --  master. Finally if Chained_Cleanup_Action is present, it is a reference\n+   --  to a previous cleanup procedure, a call to which is appended at the\n+   --  end of the generated one.\n \n    procedure Set_Node_To_Be_Wrapped (N : Node_Id);\n    --  Set the field Node_To_Be_Wrapped of the current scope\n@@ -1120,6 +1122,9 @@ package body Exp_Ch7 is\n                                Nkind (N) = N_Block_Statement\n                                  and then Is_Asynchronous_Call_Block (N);\n \n+      Previous_At_End_Proc : constant Node_Id :=\n+                               At_End_Proc (Handled_Statement_Sequence (N));\n+\n       Clean     : Entity_Id;\n       Loc       : Source_Ptr;\n       Mark      : Entity_Id := Empty;\n@@ -1244,11 +1249,18 @@ package body Exp_Ch7 is\n           Is_Master,\n           Is_Protected,\n           Is_Task_Allocation,\n-          Is_Asynchronous_Call));\n+          Is_Asynchronous_Call,\n+          Previous_At_End_Proc));\n+\n+      --  The previous AT END procedure, if any, has been captured in Clean:\n+      --  reset it to Empty now because we check further on that we never\n+      --  overwrite an existing AT END call.\n+\n+      Set_At_End_Proc (Handled_Statement_Sequence (N), Empty);\n \n-      --  If exception handlers are present, wrap the Sequence of\n-      --  statements in a block because it is not possible to get\n-      --  exception handlers and an AT END call in the same scope.\n+      --  If exception handlers are present, wrap the Sequence of statements in\n+      --  a block because it is not possible to get exception handlers and an\n+      --  AT END call in the same scope.\n \n       if Present (Exception_Handlers (Handled_Statement_Sequence (N))) then\n \n@@ -1330,7 +1342,7 @@ package body Exp_Ch7 is\n         (Handled_Statement_Sequence (N), Sloc (First (Declarations (N))));\n \n       --  The declarations of the _Clean procedure and finalization chain\n-      --  replace the old declarations that have been moved inward\n+      --  replace the old declarations that have been moved inward.\n \n       Set_Declarations (N, New_Decls);\n       Analyze_Declarations (New_Decls);\n@@ -1342,9 +1354,9 @@ package body Exp_Ch7 is\n \n       begin\n          --  If the construct is a protected subprogram, then the call to\n-         --  the corresponding unprotected program appears in a block which\n-         --  is the last statement in the body, and it is this block that\n-         --  must be covered by the At_End handler.\n+         --  the corresponding unprotected subprogram appears in a block which\n+         --  is the last statement in the body, and it is this block that must\n+         --  be covered by the At_End handler.\n \n          if Is_Protected then\n             HSS := Handled_Statement_Sequence\n@@ -1353,6 +1365,10 @@ package body Exp_Ch7 is\n             HSS := Handled_Statement_Sequence (N);\n          end if;\n \n+         --  Never overwrite an existing AT END call\n+\n+         pragma Assert (No (At_End_Proc (HSS)));\n+\n          Set_At_End_Proc (HSS, New_Occurrence_Of (Clean, Loc));\n          Expand_At_End_Handler (HSS, Empty);\n       end;\n@@ -1708,10 +1724,16 @@ package body Exp_Ch7 is\n       R   : Node_Id;\n \n    begin\n+      --  If the restriction No_Finalization applies, then there's not any\n+      --  finalization list available to return, so return Empty.\n+\n+      if Restriction_Active (No_Finalization) then\n+         return Empty;\n+\n       --  Case of an internal component. The Final list is the record\n       --  controller of the enclosing record.\n \n-      if Present (Ref) then\n+      elsif Present (Ref) then\n          R := Ref;\n          loop\n             case Nkind (R) is\n@@ -1741,30 +1763,35 @@ package body Exp_Ch7 is\n                  Selector_Name => Make_Identifier (Loc, Name_uController)),\n              Selector_Name => Make_Identifier (Loc, Name_F));\n \n-      --  Case of a dynamically allocated object. The final list is the\n-      --  corresponding list controller (the next entity in the scope of the\n-      --  access type with the right type). If the type comes from a With_Type\n-      --  clause, no controller was created, we use the global chain instead.\n+      --  Case of a dynamically allocated object whose access type has an\n+      --  Associated_Final_Chain. The final list is the corresponding list\n+      --  controller (the next entity in the scope of the access type with\n+      --  the right type). If the type comes from a With_Type clause, no\n+      --  controller was created, we use the global chain instead. (The code\n+      --  related to with_type clauses should presumably be removed at some\n+      --  point since that feature is obsolete???)\n \n       --  An anonymous access type either has a list created for it when the\n       --  allocator is a for an access parameter or an access discriminant,\n       --  or else it uses the list of the enclosing dynamic scope, when the\n       --  context is a declaration or an assignment.\n \n       elsif Is_Access_Type (E)\n-        and then (Ekind (E) /= E_Anonymous_Access_Type\n-                    or else\n-                  Present (Associated_Final_Chain (E)))\n+        and then (Present (Associated_Final_Chain (E))\n+                   or else From_With_Type (E))\n       then\n-         if not From_With_Type (E) then\n+         if From_With_Type (E) then\n+            return New_Reference_To (RTE (RE_Global_Final_List), Sloc (E));\n+\n+         --  Use the access type's associated finalization chain\n+\n+         else\n             return\n               Make_Selected_Component (Loc,\n                 Prefix        =>\n                   New_Reference_To\n                     (Associated_Final_Chain (Base_Type (E)), Loc),\n                 Selector_Name => Make_Identifier (Loc, Name_F));\n-         else\n-            return New_Reference_To (RTE (RE_Global_Final_List), Sloc (E));\n          end if;\n \n       else\n@@ -2233,7 +2260,8 @@ package body Exp_Ch7 is\n       Is_Master                  : Boolean;\n       Is_Protected_Subprogram    : Boolean;\n       Is_Task_Allocation_Block   : Boolean;\n-      Is_Asynchronous_Call_Block : Boolean) return Node_Id\n+      Is_Asynchronous_Call_Block : Boolean;\n+      Chained_Cleanup_Action     : Node_Id) return Node_Id\n    is\n       Loc  : constant Source_Ptr := Sloc (Clean);\n       Stmt : constant List_Id    := New_List;\n@@ -2476,6 +2504,12 @@ package body Exp_Ch7 is\n                     New_Reference_To (Mark, Loc))));\n       end if;\n \n+      if Present (Chained_Cleanup_Action) then\n+         Append_To (Stmt,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => Chained_Cleanup_Action));\n+      end if;\n+\n       Sbody :=\n         Make_Subprogram_Body (Loc,\n           Specification =>\n@@ -3372,13 +3406,14 @@ package body Exp_Ch7 is\n \n          Insert_List_Before_And_Analyze (First (List_Containing (N)), Nodes);\n \n-         --  Generate the Finalization calls by finalizing the list\n-         --  controller right away. It will be re-finalized on scope\n-         --  exit but it doesn't matter. It cannot be done when the\n-         --  call initializes a renaming object though because in this\n-         --  case, the object becomes a pointer to the temporary and thus\n-         --  increases its life span. Ditto if this is a renaming of a\n-         --  component of an expression (such as a function call). .\n+         --  Generate the Finalization calls by finalizing the list controller\n+         --  right away. It will be re-finalized on scope exit but it doesn't\n+         --  matter. It cannot be done when the call initializes a renaming\n+         --  object though because in this case, the object becomes a pointer\n+         --  to the temporary and thus increases its life span. Ditto if this\n+         --  is a renaming of a component of an expression (such as a function\n+         --  call).\n+\n          --  Note that there is a problem if an actual in the call needs\n          --  finalization, because in that case the call itself is the master,\n          --  and the actual should be finalized on return from the call ???"}]}