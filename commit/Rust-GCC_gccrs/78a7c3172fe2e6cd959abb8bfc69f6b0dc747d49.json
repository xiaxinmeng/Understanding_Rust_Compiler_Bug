{"sha": "78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhN2MzMTcyZmUyZTZjZDk1OWFiYjhiZmM2OWY2YjBkYzc0N2Q0OQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2014-10-14T19:44:36Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2014-10-14T19:44:36Z"}, "message": "machmode.h (int_n_data_t): New.\n\n\t* machmode.h (int_n_data_t): New.\n\t(int_n_enabled_p): New.\n\t(int_n_data): New.\n\t* tree.c (int_n_enabled_p): New.\n\t(int_n_trees): New.\n\t(make_or_reuse_type): Check for all __intN types, not just\n\t__int128.\n\t(build_common_tree_nodes): Likewise.  Also fill in integer_typs[]\n\tentries.\n\t* tree.h (int128_integer_type_node): Remove.\n\t(int128_unsigned_type_node): Remove.\n\t(int_n_trees_t): New.\n\t(int_n_enabled_p): New.\n\t(int_n_trees): New.\n\t* toplev.c (standard_type_bitsize): New.\n\t(do_compile): Check which __intN types are enabled for the current\n\trun.\n\t* builtin-types.def (BT_INT128): Remove.\n\t(BT_UINT128): Remove.\n\t* machmode.def: Add macro to create __int128 for all targets.\n\t* stor-layout.c (mode_for_size): Support __intN types.\n\t(smallest_mode_for_size): Likewise.\n\t(initialize_sizetypes): Support __intN types.\n\t* genmodes.c (struct mode_data): Add int_n field.\n\t(blank_mode): Likewise.\n\t(INT_N): New.\n\t(make_int_n): New.\n\t(emit_insn_modes_h): Count __intN entries and define\n\tNUM_INT_N_ENTS.\n\t(emit_mode_int_n): New.\n\t(emit_insn_modes_c): Call it.\n\t* gimple.c (gimple_signed_or_unsigned_type): Check for all __intN\n\ttypes, not just __int128.\n\t* tree-core.h (integer_type_kind): Remove __int128-specific\n\tentries, reserve spots for __intN entries.\n\nlibstdc++-v3/\n\t* src/c++11/limits.cc: Add support for __intN types.\n\t* include/std/type_traits: Likewise.\n\t* include/std/limits: Likewise.\n\t* include/c_std/cstdlib: Likewise.\n\t* include/bits/cpp_type_traits.h: Likewise.\n\t* include/c_global/cstdlib: Likewise.\n\nc-family/\n\t* c-pretty-print.c (pp_c_integer_constant): Check for all __intN\n\ttypes, not just __int128.\n\t* c-cppbuiltin.c (c_cpp_builtins): Add builtins for all __intN\n\ttypes, not just __int128.\n\t(cpp_atomic_builtins): Round pointer sizes up.\n\t(type_suffix): Use type precision, not specific types.\n\t* c-common.c (c_common_reswords): Remove __int128 special case.\n\t(c_common_type_for_size): Check for all __intN types, not just\n\t__int128.\n\t(c_common_type_for_mode): Likewise.\n\t(c_common_signed_or_unsigned_type): Likewise.\n\t(c_build_bitfield_integer_type): Likewise.\n\t(c_common_nodes_and_builtins): Likewise.\n\t(keyword_begins_type_specifier): Likewise.\n\t* c-common.h (rid): Remove RID_INT128 and add RID_INT_N_* for all\n\t__intN variants.\n\nc/\n\t* c-parser.c (c_parse_init): Add RID entries for each __intN.\n\t(c_token_starts_typename): Check all __intN, not just __int128.\n\t(c_token_starts_declspecs): Likewise.\n\t(c_parser_declspecs): Likewise.\n\t(c_parser_attribute_any_word): Likewise.\n\t(c_parser_objc_selector): Likewise.\n\t* c-tree.h (c_typespec_keyword): cts_int128 -> cts_int_n.\n\t(struct c_declspecs): Add int_n_idx field to record *which* __intN\n\tis specified.\n\t* c-decl.c (declspecs_add_type): Check for all __intN, not just\n\t__int128.\n\t(finish_declspecs): Likewise.\n\ntestsuite/\n\t* g++.dg/abi/mangle64.C: New.\n\ncp/\n\t* typeck.c (cp_common_type): Check for all __intN types, not just\n\t__int128.\n\t* decl.c (grokdeclarator): Likewise.\n\t* rtti.c (emit_support_tinfos): Check for all __intN types, not just\n\t__int128.\n\t* parser.c (cp_lexer_next_token_is_decl_specifier_keyword): Check\n\tfor all __intN types, not just __int128.\n\t(cp_parser_simple_type_specifier): Likewise.\n\t* mangle.c (integer_type_codes): Remove int128-specific codes.\n\t* cp-tree.h (cp_decl_specifier_seq): Add int_n_idx to store which\n\t__intN was specified.\n\t* lex.c (init_reswords): Reserve all __intN keywords.\n\nlto/\n\t* lto-lang.c (lto_build_c_type_nodes): Check intN types for\n\tsize-type as well.\n\t(lto_init): Initialize all intN types, not just int128.\n\nFrom-SVN: r216220", "tree": {"sha": "e12f293c8d0e0b83e0dc6b0b250a64fb5d4bcd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e12f293c8d0e0b83e0dc6b0b250a64fb5d4bcd50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/comments", "author": null, "committer": null, "parents": [{"sha": "df3e34938d9b38a0906a8ebf491f8b73bda5346d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e34938d9b38a0906a8ebf491f8b73bda5346d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e34938d9b38a0906a8ebf491f8b73bda5346d"}], "stats": {"total": 1394, "additions": 1041, "deletions": 353}, "files": [{"sha": "6839a5ec1558060f1977a3cd36346a3b595c7b85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,43 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* machmode.h (int_n_data_t): New.\n+\t(int_n_enabled_p): New.\n+\t(int_n_data): New.\n+\t* tree.c (int_n_enabled_p): New.\n+\t(int_n_trees): New.\n+\t(make_or_reuse_type): Check for all __intN types, not just\n+\t__int128.\n+\t(build_common_tree_nodes): Likewise.  Also fill in integer_typs[]\n+\tentries.\n+\t* tree.h (int128_integer_type_node): Remove.\n+\t(int128_unsigned_type_node): Remove.\n+\t(int_n_trees_t): New.\n+\t(int_n_enabled_p): New.\n+\t(int_n_trees): New.\n+\t* toplev.c (standard_type_bitsize): New.\n+\t(do_compile): Check which __intN types are enabled for the current\n+\trun.\n+\t* builtin-types.def (BT_INT128): Remove.\n+\t(BT_UINT128): Remove.\n+\t* machmode.def: Add macro to create __int128 for all targets.\n+\t* stor-layout.c (mode_for_size): Support __intN types.\n+\t(smallest_mode_for_size): Likewise.\n+\t(initialize_sizetypes): Support __intN types.\n+\t* genmodes.c (struct mode_data): Add int_n field.\n+\t(blank_mode): Likewise.\n+\t(INT_N): New.\n+\t(make_int_n): New.\n+\t(emit_insn_modes_h): Count __intN entries and define\n+\tNUM_INT_N_ENTS.\n+\t(emit_mode_int_n): New.\n+\t(emit_insn_modes_c): Call it.\n+\t* gimple.c (gimple_signed_or_unsigned_type): Check for all __intN\n+\ttypes, not just __int128.\n+\t* tree-core.h (integer_type_kind): Remove __int128-specific\n+\tentries, reserve spots for __intN entries.\n+\n+\t* config/msp430/msp430-modes.def (PSI): Add.\n+\n 2014-10-14  Kito Cheng  <kito@0xlab.org>\n \n \t* ira.c: Fix typo in comment."}, {"sha": "6434bf2f19ef36483a2f1d79a3565bc4d12fbbca", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -65,8 +65,6 @@ DEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_ULONG, long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONGLONG, long_long_integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)\n-DEF_PRIMITIVE_TYPE (BT_INT128, int128_integer_type_node)\n-DEF_PRIMITIVE_TYPE (BT_UINT128, int128_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINTMAX, uintmax_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT16, uint16_type_node)"}, {"sha": "e630535198639a5d16c04ffb6c3419764f8bf74b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,22 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* c-pretty-print.c (pp_c_integer_constant): Check for all __intN\n+\ttypes, not just __int128.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Add builtins for all __intN\n+\ttypes, not just __int128.\n+\t(cpp_atomic_builtins): Round pointer sizes up.\n+\t(type_suffix): Use type precision, not specific types.\n+\t* c-common.c (c_common_reswords): Remove __int128 special case.\n+\t(c_common_type_for_size): Check for all __intN types, not just\n+\t__int128.\n+\t(c_common_type_for_mode): Likewise.\n+\t(c_common_signed_or_unsigned_type): Likewise.\n+\t(c_build_bitfield_integer_type): Likewise.\n+\t(c_common_nodes_and_builtins): Likewise.\n+\t(keyword_begins_type_specifier): Likewise.\n+\t* c-common.h (rid): Remove RID_INT128 and add RID_INT_N_* for all\n+\t__intN variants.\n+\n 2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* c-common.c: Use hash_table instead of hashtab."}, {"sha": "cd73e27272825a944d08f2f51d0e9b486a3bb432", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -61,12 +61,10 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \ttree short_integer_type_node;\n \ttree long_integer_type_node;\n \ttree long_long_integer_type_node;\n-\ttree int128_integer_type_node;\n \n \ttree short_unsigned_type_node;\n \ttree long_unsigned_type_node;\n \ttree long_long_unsigned_type_node;\n-\ttree int128_unsigned_type_node;\n \n \ttree truthvalue_type_node;\n \ttree truthvalue_false_node;\n@@ -468,7 +466,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },\n   { \"__inline__\",\tRID_INLINE,\t0 },\n-  { \"__int128\",\t\tRID_INT128,\t0 },\n   { \"__is_abstract\",\tRID_IS_ABSTRACT, D_CXXONLY },\n   { \"__is_base_of\",\tRID_IS_BASE_OF, D_CXXONLY },\n   { \"__is_class\",\tRID_IS_CLASS,\tD_CXXONLY },\n@@ -3449,6 +3446,8 @@ check_case_bounds (location_t loc, tree type, tree orig_type,\n tree\n c_common_type_for_size (unsigned int bits, int unsignedp)\n {\n+  int i;\n+\n   if (bits == TYPE_PRECISION (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n \n@@ -3465,10 +3464,11 @@ c_common_type_for_size (unsigned int bits, int unsignedp)\n     return (unsignedp ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n \n-  if (int128_integer_type_node\n-      && bits == TYPE_PRECISION (int128_integer_type_node))\n-    return (unsignedp ? int128_unsigned_type_node\n-\t    : int128_integer_type_node);\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& bits == int_n_data[i].bitsize)\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n \n   if (bits == TYPE_PRECISION (widest_integer_literal_type_node))\n     return (unsignedp ? widest_unsigned_literal_type_node\n@@ -3532,6 +3532,7 @@ tree\n c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n   tree t;\n+  int i;\n \n   if (mode == TYPE_MODE (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n@@ -3548,9 +3549,11 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (long_long_integer_type_node))\n     return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n \n-  if (int128_integer_type_node\n-      && mode == TYPE_MODE (int128_integer_type_node))\n-    return unsignedp ? int128_unsigned_type_node : int128_integer_type_node;\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& mode == int_n_data[i].m)\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n \n   if (mode == TYPE_MODE (widest_integer_literal_type_node))\n     return unsignedp ? widest_unsigned_literal_type_node\n@@ -3748,6 +3751,7 @@ tree\n c_common_signed_or_unsigned_type (int unsignedp, tree type)\n {\n   tree type1;\n+  int i;\n \n   /* This block of code emulates the behavior of the old\n      c_common_unsigned_type. In particular, it returns\n@@ -3766,10 +3770,14 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n     return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n   if (type1 == long_long_integer_type_node || type1 == long_long_unsigned_type_node)\n     return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n-  if (int128_integer_type_node\n-      && (type1 == int128_integer_type_node\n-\t  || type1 == int128_unsigned_type_node))\n-    return unsignedp ? int128_unsigned_type_node : int128_integer_type_node;\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& (type1 == int_n_trees[i].unsigned_type\n+\t    || type1 == int_n_trees[i].signed_type))\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n+\n   if (type1 == widest_integer_literal_type_node || type1 == widest_unsigned_literal_type_node)\n     return unsignedp ? widest_unsigned_literal_type_node : widest_integer_literal_type_node;\n #if HOST_BITS_PER_WIDE_INT >= 64\n@@ -3884,9 +3892,14 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n   if (TYPE_OK (long_long_integer_type_node))\n     return (unsignedp ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n-  if (int128_integer_type_node && TYPE_OK (int128_integer_type_node))\n-    return (unsignedp ? int128_unsigned_type_node\n-\t    : int128_integer_type_node);\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& TYPE_MODE (type) == int_n_data[i].m\n+\t&& TYPE_PRECISION (type) == int_n_data[i].bitsize)\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n+\n   if (TYPE_OK (widest_integer_literal_type_node))\n     return (unsignedp ? widest_unsigned_literal_type_node\n \t    : widest_integer_literal_type_node);\n@@ -3913,6 +3926,8 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n tree\n c_build_bitfield_integer_type (unsigned HOST_WIDE_INT width, int unsignedp)\n {\n+  int i;\n+\n   /* Extended integer types of the same width as a standard type have\n      lesser rank, so those of the same width as int promote to int or\n      unsigned int and are valid for printf formats expecting int or\n@@ -3930,10 +3945,11 @@ c_build_bitfield_integer_type (unsigned HOST_WIDE_INT width, int unsignedp)\n   if (width == TYPE_PRECISION (long_long_integer_type_node))\n     return (unsignedp ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n-  if (int128_integer_type_node\n-      && width == TYPE_PRECISION (int128_integer_type_node))\n-    return (unsignedp ? int128_unsigned_type_node\n-\t    : int128_integer_type_node);\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& width == int_n_data[i].bitsize)\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n   return build_nonstandard_integer_type (width, unsignedp);\n }\n \n@@ -5338,6 +5354,7 @@ c_common_nodes_and_builtins (void)\n   tree array_domain_type;\n   tree va_list_ref_type_node;\n   tree va_list_arg_type_node;\n+  int i;\n \n   build_common_tree_nodes (flag_signed_char, flag_short_double);\n \n@@ -5354,13 +5371,19 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n   record_builtin_type (RID_MAX, \"long unsigned int\",\n \t\t       long_unsigned_type_node);\n-  if (int128_integer_type_node != NULL_TREE)\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n     {\n-      record_builtin_type (RID_INT128, \"__int128\",\n-\t\t\t   int128_integer_type_node);\n-      record_builtin_type (RID_MAX, \"__int128 unsigned\",\n-\t\t\t   int128_unsigned_type_node);\n+      char name[25];\n+\n+      sprintf (name, \"__int%d\", int_n_data[i].bitsize);\n+      record_builtin_type ((enum rid)(RID_FIRST_INT_N + i), xstrdup (name),\n+\t\t\t   int_n_trees[i].signed_type);\n+      sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+      record_builtin_type (RID_MAX, xstrdup (name),\n+\t\t\t   int_n_trees[i].unsigned_type);\n     }\n+\n   if (c_dialect_cxx ())\n     record_builtin_type (RID_MAX, \"unsigned long\", long_unsigned_type_node);\n   record_builtin_type (RID_MAX, \"long long int\",\n@@ -5396,6 +5419,8 @@ c_common_nodes_and_builtins (void)\n \t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n+  /* Note that this is different than the __int128 type that's part of\n+     the generic __intN support.  */\n   if (targetm.scalar_mode_supported_p (TImode))\n     lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n \t\t\t\t\t   TYPE_DECL,\n@@ -11762,7 +11787,6 @@ keyword_begins_type_specifier (enum rid keyword)\n     case RID_FLOAT:\n     case RID_DOUBLE:\n     case RID_VOID:\n-    case RID_INT128:\n     case RID_UNSIGNED:\n     case RID_LONG:\n     case RID_SHORT:\n@@ -11785,6 +11809,10 @@ keyword_begins_type_specifier (enum rid keyword)\n     case RID_ENUM:\n       return true;\n     default:\n+      if (keyword >= RID_FIRST_INT_N\n+\t  && keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t  && int_n_enabled_p[keyword-RID_FIRST_INT_N])\n+\treturn true;\n       return false;\n     }\n }"}, {"sha": "fd94d64009a85c49fb76e7204e24e63984fc0281", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -91,7 +91,6 @@ enum rid\n \n   /* C */\n   RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,\n-  RID_INT128,\n   RID_ENUM,    RID_STRUCT, RID_UNION,    RID_IF,     RID_ELSE,\n   RID_WHILE,   RID_DO,     RID_FOR,      RID_SWITCH, RID_CASE,\n   RID_DEFAULT, RID_BREAK,  RID_CONTINUE, RID_RETURN, RID_GOTO,\n@@ -190,6 +189,23 @@ enum rid\n   RID_FIRST_ADDR_SPACE = RID_ADDR_SPACE_0,\n   RID_LAST_ADDR_SPACE = RID_ADDR_SPACE_15,\n \n+  /* __intN keywords.  The _N_M here doesn't correspond to the intN\n+     in the keyword; use the bitsize in int_n_t_data_t[M] for that.\n+     For example, if int_n_t_data_t[0].bitsize is 13, then RID_INT_N_0\n+     is for __int13.  */\n+\n+  /* Note that the range to use is RID_FIRST_INT_N through\n+     RID_FIRST_INT_N + NUM_INT_N_ENTS - 1 and c-parser.c has a list of\n+     all RID_INT_N_* in a case statement.  */\n+\n+  RID_INT_N_0,\n+  RID_INT_N_1,\n+  RID_INT_N_2,\n+  RID_INT_N_3,\n+\n+  RID_FIRST_INT_N = RID_INT_N_0,\n+  RID_LAST_INT_N = RID_INT_N_3,\n+\n   RID_MAX,\n \n   RID_FIRST_MODIFIER = RID_STATIC,"}, {"sha": "aa61b7eb5183ffaff1c95891015e91f785c2aae9", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -771,6 +771,8 @@ cpp_iec_559_complex_value (void)\n void\n c_cpp_builtins (cpp_reader *pfile)\n {\n+  int i;\n+\n   /* -undef turns off target-specific built-ins.  */\n   if (flag_undef)\n     return;\n@@ -889,6 +891,23 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_type_max (\"__PTRDIFF_MAX__\", ptrdiff_type_node);\n   builtin_define_type_max (\"__SIZE_MAX__\", size_type_node);\n \n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i])\n+      {\n+\tchar buf[35+20+20];\n+\n+\t/* These are used to configure the C++ library.  */\n+\n+\tif (!flag_iso || int_n_data[i].bitsize == POINTER_SIZE)\n+\t  {\n+\t    sprintf (buf, \"__GLIBCXX_TYPE_INT_N_%d=__int%d\", i, int_n_data[i].bitsize);\n+\t    cpp_define (parse_in, buf);\n+\n+\t    sprintf (buf, \"__GLIBCXX_BITSIZE_INT_N_%d=%d\", i, int_n_data[i].bitsize);\n+\t    cpp_define (parse_in, buf);\n+\t  }\n+      }\n+\n   /* stdint.h and the testsuite need to know these.  */\n   builtin_define_stdint_macros ();\n \n@@ -1169,9 +1188,14 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (flag_openmp)\n     cpp_define (pfile, \"_OPENMP=201307\");\n \n-  if (int128_integer_type_node != NULL_TREE)\n-    builtin_define_type_sizeof (\"__SIZEOF_INT128__\",\n-\t\t\t        int128_integer_type_node);\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i])\n+      {\n+\tchar buf[15+20];\n+\tsprintf(buf, \"__SIZEOF_INT%d__\", int_n_data[i].bitsize);\n+\tbuiltin_define_type_sizeof (buf,\n+\t\t\t\t    int_n_trees[i].signed_type);\n+      }\n   builtin_define_type_sizeof (\"__SIZEOF_WCHAR_T__\", wchar_type_node);\n   builtin_define_type_sizeof (\"__SIZEOF_WINT_T__\", wint_type_node);\n   builtin_define_type_sizeof (\"__SIZEOF_PTRDIFF_T__\",\n@@ -1445,12 +1469,15 @@ type_suffix (tree type)\n   static const char *const suffixes[] = { \"\", \"U\", \"L\", \"UL\", \"LL\", \"ULL\" };\n   int unsigned_suffix;\n   int is_long;\n+  int tp = TYPE_PRECISION (type);\n \n   if (type == long_long_integer_type_node\n-      || type == long_long_unsigned_type_node)\n+      || type == long_long_unsigned_type_node\n+      || tp > TYPE_PRECISION (long_integer_type_node))\n     is_long = 2;\n   else if (type == long_integer_type_node\n-\t   || type == long_unsigned_type_node)\n+\t   || type == long_unsigned_type_node\n+\t   || tp > TYPE_PRECISION (integer_type_node))\n     is_long = 1;\n   else if (type == integer_type_node\n \t   || type == unsigned_type_node"}, {"sha": "3b2dbc19ea69647636c34b31a4659858a9b5512b", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -920,6 +920,8 @@ pp_c_void_constant (c_pretty_printer *pp)\n static void\n pp_c_integer_constant (c_pretty_printer *pp, tree i)\n {\n+  int idx;\n+\n   /* We are going to compare the type of I to other types using\n      pointer comparison so we need to use its canonical type.  */\n   tree type =\n@@ -950,9 +952,17 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n   else if (type == long_long_integer_type_node\n \t   || type == long_long_unsigned_type_node)\n     pp_string (pp, \"ll\");\n-  else if (type == int128_integer_type_node\n-           || type == int128_unsigned_type_node)\n-    pp_string (pp, \"I128\");\n+  else for (idx = 0; idx < NUM_INT_N_ENTS; idx ++)\n+    if (int_n_enabled_p[idx])\n+      {\n+\tchar buf[2+20];\n+\tif (type == int_n_trees[idx].signed_type\n+\t    || type == int_n_trees[idx].unsigned_type)\n+\t  {\n+\t    sprintf (buf, \"I%d\", int_n_data[idx].bitsize);\n+\t    pp_string (pp, buf);\n+\t  }\n+      }\n }\n \n /* Print out a CHARACTER literal.  */"}, {"sha": "690c3153c743b52acd3b80203e0b7f624d7765bc", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,18 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* c-parser.c (c_parse_init): Add RID entries for each __intN.\n+\t(c_token_starts_typename): Check all __intN, not just __int128.\n+\t(c_token_starts_declspecs): Likewise.\n+\t(c_parser_declspecs): Likewise.\n+\t(c_parser_attribute_any_word): Likewise.\n+\t(c_parser_objc_selector): Likewise.\n+\t* c-tree.h (c_typespec_keyword): cts_int128 -> cts_int_n.\n+\t(struct c_declspecs): Add int_n_idx field to record *which* __intN\n+\tis specified.\n+\t* c-decl.c (declspecs_add_type): Check for all __intN, not just\n+\t__int128.\n+\t(finish_declspecs): Likewise.\n+\n 2014-10-13  Anthony Brandon  <anthony.brandon@gmail.com>\n \n         * c-parser.c (c_parser_all_labels): New function to replace"}, {"sha": "2900c711b0b904bbef62bd6205e1a4461094e20e", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -9369,10 +9369,11 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<void%> in \"\n \t\t\t   \"declaration specifiers\"));\n-\t      else if (specs->typespec_word == cts_int128)\n+\t      else if (specs->typespec_word == cts_int_n)\n \t\t  error_at (loc,\n-\t\t\t    (\"both %<long%> and %<__int128%> in \"\n-\t\t\t     \"declaration specifiers\"));\n+\t\t\t    (\"both %<long%> and %<__int%d%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    int_n_data[specs->int_n_idx].bitsize);\n \t      else if (specs->typespec_word == cts_bool)\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<_Bool%> in \"\n@@ -9417,10 +9418,11 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<short%> and %<void%> in \"\n \t\t\t   \"declaration specifiers\"));\n-\t      else if (specs->typespec_word == cts_int128)\n+\t      else if (specs->typespec_word == cts_int_n)\n \t\terror_at (loc,\n-\t\t\t  (\"both %<short%> and %<__int128%> in \"\n-\t\t\t   \"declaration specifiers\"));\n+\t\t\t  (\"both %<short%> and %<__int%d%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  int_n_data[specs->int_n_idx].bitsize);\n \t      else if (specs->typespec_word == cts_bool)\n \t\terror_at (loc,\n \t\t\t  (\"both %<short%> and %<_Bool%> in \"\n@@ -9594,11 +9596,12 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t      dupe = specs->saturating_p;\n \t      pedwarn (loc, OPT_Wpedantic,\n \t\t       \"ISO C does not support saturating types\");\n-\t      if (specs->typespec_word == cts_int128)\n+\t      if (specs->typespec_word == cts_int_n)\n \t        {\n \t\t  error_at (loc,\n-\t\t\t    (\"both %<_Sat%> and %<__int128%> in \"\n-\t\t\t     \"declaration specifiers\"));\n+\t\t\t    (\"both %<_Sat%> and %<__int%d%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    int_n_data[specs->int_n_idx].bitsize);\n \t        }\n \t      else if (specs->typespec_word == cts_auto_type)\n \t\terror_at (loc,\n@@ -9662,7 +9665,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n       else\n \t{\n \t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\", \"double\", \"_Decimal32\",\n-\t     \"__int128\", \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\" or\n+\t     \"__intN\", \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\" or\n \t     \"__auto_type\".  */\n \t  if (specs->typespec_word != cts_none)\n \t    {\n@@ -9703,31 +9706,41 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t  specs->locations[cdw_typespec] = loc;\n \t\t}\n \t      return specs;\n-\t    case RID_INT128:\n-\t      if (int128_integer_type_node == NULL_TREE)\n-\t\t{\n-\t\t  error_at (loc, \"%<__int128%> is not supported for this target\");\n-\t\t  return specs;\n-\t\t}\n-\t      if (!in_system_header_at (input_location))\n+\t    case RID_INT_N_0:\n+\t    case RID_INT_N_1:\n+\t    case RID_INT_N_2:\n+\t    case RID_INT_N_3:\n+\t      specs->int_n_idx = i - RID_INT_N_0;\n+\t      if (!in_system_header_at (input_location)\n+\t\t  /* As a special exception, allow a type that's used\n+\t\t     for __SIZE_TYPE__.  */\n+\t\t  && int_n_data[specs->int_n_idx].bitsize != POINTER_SIZE)\n \t\tpedwarn (loc, OPT_Wpedantic,\n-\t\t\t \"ISO C does not support %<__int128%> type\");\n+\t\t\t \"ISO C does not support %<__int%d%> types\",\n+\t\t\t int_n_data[specs->int_n_idx].bitsize);\n \n \t      if (specs->long_p)\n \t\terror_at (loc,\n-\t\t\t  (\"both %<__int128%> and %<long%> in \"\n-\t\t\t   \"declaration specifiers\"));\n+\t\t\t  (\"both %<__int%d%> and %<long%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  int_n_data[specs->int_n_idx].bitsize);\n \t      else if (specs->saturating_p)\n \t\terror_at (loc,\n-\t\t\t  (\"both %<_Sat%> and %<__int128%> in \"\n-\t\t\t   \"declaration specifiers\"));\n+\t\t\t  (\"both %<_Sat%> and %<__int%d%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  int_n_data[specs->int_n_idx].bitsize);\n \t      else if (specs->short_p)\n \t\terror_at (loc,\n-\t\t\t  (\"both %<__int128%> and %<short%> in \"\n-\t\t\t   \"declaration specifiers\"));\n+\t\t\t  (\"both %<__int%d%> and %<short%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  int_n_data[specs->int_n_idx].bitsize);\n+\t      else if (! int_n_enabled_p [specs->int_n_idx])\n+\t\terror_at (loc,\n+\t\t\t  \"%<__int%d%> is not supported on this target\",\n+\t\t\t  int_n_data[specs->int_n_idx].bitsize);\n \t      else\n \t\t{\n-\t\t  specs->typespec_word = cts_int128;\n+\t\t  specs->typespec_word = cts_int_n;\n \t\t  specs->locations[cdw_typespec] = loc;\n \t\t}\n \t      return specs;\n@@ -10295,12 +10308,12 @@ finish_declspecs (struct c_declspecs *specs)\n \t  specs->type = build_complex_type (specs->type);\n \t}\n       break;\n-    case cts_int128:\n+    case cts_int_n:\n       gcc_assert (!specs->long_p && !specs->short_p && !specs->long_long_p);\n       gcc_assert (!(specs->signed_p && specs->unsigned_p));\n       specs->type = (specs->unsigned_p\n-\t\t     ? int128_unsigned_type_node\n-\t\t     : int128_integer_type_node);\n+\t\t     ? int_n_trees[specs->int_n_idx].unsigned_type\n+\t\t     : int_n_trees[specs->int_n_idx].signed_type);\n       if (specs->complex_p)\n \t{\n \t  pedwarn (specs->locations[cdw_complex], OPT_Wpedantic,"}, {"sha": "fa146de35d08f7576f0307ac9fe81221920b4512", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -113,6 +113,16 @@ c_parse_init (void)\n       C_IS_RESERVED_WORD (id) = 1;\n       ridpointers [(int) c_common_reswords[i].rid] = id;\n     }\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i++)\n+    {\n+      /* We always create the symbols but they aren't always supported.  */\n+      char name[50];\n+      sprintf (name, \"__int%d\", int_n_data[i].bitsize);\n+      id = get_identifier (xstrdup (name));\n+      C_SET_RID_CODE (id, RID_FIRST_INT_N + i);\n+      C_IS_RESERVED_WORD (id) = 1;\n+    }\n }\n \f\n /* The C lexer intermediates between the lexer in cpplib and c-lex.c\n@@ -483,7 +493,6 @@ c_token_starts_typename (c_token *token)\n \t{\n \tcase RID_UNSIGNED:\n \tcase RID_LONG:\n-\tcase RID_INT128:\n \tcase RID_SHORT:\n \tcase RID_SIGNED:\n \tcase RID_COMPLEX:\n@@ -511,6 +520,10 @@ c_token_starts_typename (c_token *token)\n \tcase RID_AUTO_TYPE:\n \t  return true;\n \tdefault:\n+\t  if (token->keyword >= RID_FIRST_INT_N\n+\t      && token->keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t      && int_n_enabled_p[token->keyword - RID_FIRST_INT_N])\n+\t    return true;\n \t  return false;\n \t}\n     case CPP_LESS:\n@@ -641,7 +654,6 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_THREAD:\n \tcase RID_UNSIGNED:\n \tcase RID_LONG:\n-\tcase RID_INT128:\n \tcase RID_SHORT:\n \tcase RID_SIGNED:\n \tcase RID_COMPLEX:\n@@ -670,6 +682,10 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_AUTO_TYPE:\n \t  return true;\n \tdefault:\n+\t  if (token->keyword >= RID_FIRST_INT_N\n+\t      && token->keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t      && int_n_enabled_p[token->keyword - RID_FIRST_INT_N])\n+\t    return true;\n \t  return false;\n \t}\n     case CPP_LESS:\n@@ -2158,7 +2174,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n    type-specifier:\n      typeof-specifier\n      __auto_type\n-     __int128\n+     __intN\n      _Decimal32\n      _Decimal64\n      _Decimal128\n@@ -2312,7 +2328,6 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  /* Fall through.  */\n \tcase RID_UNSIGNED:\n \tcase RID_LONG:\n-\tcase RID_INT128:\n \tcase RID_SHORT:\n \tcase RID_SIGNED:\n \tcase RID_COMPLEX:\n@@ -2328,6 +2343,10 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_FRACT:\n \tcase RID_ACCUM:\n \tcase RID_SAT:\n+\tcase RID_INT_N_0:\n+\tcase RID_INT_N_1:\n+\tcase RID_INT_N_2:\n+\tcase RID_INT_N_3:\n \t  if (!typespec_ok)\n \t    goto out;\n \t  attrs_ok = true;\n@@ -3738,7 +3757,6 @@ c_parser_attribute_any_word (c_parser *parser)\n \tcase RID_STATIC:\n \tcase RID_UNSIGNED:\n \tcase RID_LONG:\n-\tcase RID_INT128:\n \tcase RID_CONST:\n \tcase RID_EXTERN:\n \tcase RID_REGISTER:\n@@ -3768,6 +3786,10 @@ c_parser_attribute_any_word (c_parser *parser)\n \tcase RID_TRANSACTION_CANCEL:\n \tcase RID_ATOMIC:\n \tcase RID_AUTO_TYPE:\n+\tcase RID_INT_N_0:\n+\tcase RID_INT_N_1:\n+\tcase RID_INT_N_2:\n+\tcase RID_INT_N_3:\n \t  ok = true;\n \t  break;\n \tdefault:\n@@ -8992,7 +9014,6 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_ALIGNOF:\n     case RID_UNSIGNED:\n     case RID_LONG:\n-    case RID_INT128:\n     case RID_CONST:\n     case RID_SHORT:\n     case RID_VOLATILE:\n@@ -9013,6 +9034,10 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_BOOL:\n     case RID_ATOMIC:\n     case RID_AUTO_TYPE:\n+    case RID_INT_N_0:\n+    case RID_INT_N_1:\n+    case RID_INT_N_2:\n+    case RID_INT_N_3:\n       c_parser_consume_token (parser);\n       return value;\n     default:"}, {"sha": "e6aca01923ba3dfc58e6654ba014ee38dec0ebbb", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -202,7 +202,7 @@ enum c_typespec_keyword {\n   cts_char,\n   cts_int,\n   cts_float,\n-  cts_int128,\n+  cts_int_n,\n   cts_double,\n   cts_dfloat32,\n   cts_dfloat64,\n@@ -269,6 +269,8 @@ struct c_declspecs {\n      specifier, in bytes, or -1 if no such specifiers with nonzero\n      alignment.  */\n   int align_log;\n+  /* For the __intN declspec, this stores the index into the int_n_* arrays.  */\n+  int int_n_idx;\n   /* The storage class specifier, or csc_none if none.  */\n   enum c_storage_class storage_class;\n   /* Any type specifier keyword used such as \"int\", not reflecting"}, {"sha": "00f5269fb687e706da7978636c690b50061df012", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,18 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* typeck.c (cp_common_type): Check for all __intN types, not just\n+\t__int128.\n+\t* decl.c (grokdeclarator): Likewise.\n+\t* rtti.c (emit_support_tinfos): Check for all __intN types, not just\n+\t__int128.\n+\t* parser.c (cp_lexer_next_token_is_decl_specifier_keyword): Check\n+\tfor all __intN types, not just __int128.\n+\t(cp_parser_simple_type_specifier): Likewise.\n+\t* mangle.c (integer_type_codes): Remove int128-specific codes.\n+\t* cp-tree.h (cp_decl_specifier_seq): Add int_n_idx to store which\n+\t__intN was specified.\n+\t* lex.c (init_reswords): Reserve all __intN keywords.\n+\n 2014-10-14  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* typeck.c (cp_build_unary_op) [TRUTH_NOT_EXPR]: Accept float vectors."}, {"sha": "ae135bee8706930296e455513377e5ce0f4e11ab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -4899,6 +4899,8 @@ typedef struct cp_decl_specifier_seq {\n   /* The storage class specified -- or sc_none if no storage class was\n      explicitly specified.  */\n   cp_storage_class storage_class;\n+  /* For the __intN declspec, this stores the index into the int_n_* arrays.  */\n+  int int_n_idx;\n   /* True iff TYPE_SPEC defines a class or enum.  */\n   BOOL_BITFIELD type_definition_p : 1;\n   /* True iff multiple types were (erroneously) specified for this\n@@ -4914,8 +4916,8 @@ typedef struct cp_decl_specifier_seq {\n   BOOL_BITFIELD any_type_specifiers_p : 1;\n   /* True iff \"int\" was explicitly provided.  */\n   BOOL_BITFIELD explicit_int_p : 1;\n-  /* True iff \"__int128\" was explicitly provided.  */\n-  BOOL_BITFIELD explicit_int128_p : 1;\n+  /* True iff \"__intN\" was explicitly provided.  */\n+  BOOL_BITFIELD explicit_intN_p : 1;\n   /* True iff \"char\" was explicitly provided.  */\n   BOOL_BITFIELD explicit_char_p : 1;\n   /* True iff ds_thread is set for __thread, not thread_local.  */"}, {"sha": "3eba4dcd1d683290cda768d14381a1b9b5dbda10", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -8802,7 +8802,7 @@ grokdeclarator (const cp_declarator *declarator,\n {\n   tree type = NULL_TREE;\n   int longlong = 0;\n-  int explicit_int128 = 0;\n+  int explicit_intN = 0;\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n@@ -8875,7 +8875,7 @@ grokdeclarator (const cp_declarator *declarator,\n   short_p = decl_spec_seq_has_spec_p (declspecs, ds_short);\n   long_p = decl_spec_seq_has_spec_p (declspecs, ds_long);\n   longlong = decl_spec_seq_has_spec_p (declspecs, ds_long_long);\n-  explicit_int128 = declspecs->explicit_int128_p;\n+  explicit_intN = declspecs->explicit_intN_p;\n   thread_p = decl_spec_seq_has_spec_p (declspecs, ds_thread);\n \n   if (decl_context == FUNCDEF)\n@@ -9221,16 +9221,18 @@ grokdeclarator (const cp_declarator *declarator,\n \n   ctype = NULL_TREE;\n \n-  if (explicit_int128)\n+  if (explicit_intN)\n     {\n-      if (int128_integer_type_node == NULL_TREE)\n-\t{\n-\t  error (\"%<__int128%> is not supported by this target\");\n-\t  explicit_int128 = false;\n-\t}\n+      if (! int_n_enabled_p[declspecs->int_n_idx])\n+       {\n+         error (\"%<__int%d%> is not supported by this target\",\n+\t\tint_n_data[declspecs->int_n_idx].bitsize);\n+         explicit_intN = false;\n+       }\n       else if (pedantic && ! in_system_header_at (input_location))\n-\tpedwarn (input_location, OPT_Wpedantic,\n-\t\t \"ISO C++ does not support %<__int128%> for %qs\", name);\n+       pedwarn (input_location, OPT_Wpedantic,\n+                \"ISO C++ does not support %<__int%d%> for %qs\",\n+\t\tint_n_data[declspecs->int_n_idx].bitsize,  name);\n     }\n \n   /* Now process the modifiers that were specified\n@@ -9262,7 +9264,7 @@ grokdeclarator (const cp_declarator *declarator,\n \terror (\"%<short%> invalid for %qs\", name);\n       else if ((long_p || short_p) && TREE_CODE (type) != INTEGER_TYPE)\n \terror (\"%<long%> or %<short%> invalid for %qs\", name);\n-      else if ((long_p || short_p || explicit_char || explicit_int) && explicit_int128)\n+      else if ((long_p || short_p || explicit_char || explicit_int) && explicit_intN)\n \terror (\"%<long%>, %<int%>, %<short%>, or %<char%> invalid for %qs\", name);\n       else if ((long_p || short_p) && explicit_char)\n \terror (\"%<long%> or %<short%> specified with char for %qs\", name);\n@@ -9278,7 +9280,7 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \t{\n \t  ok = 1;\n-\t  if (!explicit_int && !defaulted_int && !explicit_char && !explicit_int128 && pedantic)\n+\t  if (!explicit_int && !defaulted_int && !explicit_char && !explicit_intN && pedantic)\n \t    {\n \t      pedwarn (input_location, OPT_Wpedantic, \n \t\t       \"long, short, signed or unsigned used invalidly for %qs\",\n@@ -9320,8 +9322,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t  && TREE_CODE (type) == INTEGER_TYPE\n \t  && !same_type_p (TYPE_MAIN_VARIANT (type), wchar_type_node)))\n     {\n-      if (explicit_int128)\n-\ttype = int128_unsigned_type_node;\n+      if (explicit_intN)\n+\ttype = int_n_trees[declspecs->int_n_idx].unsigned_type;\n       else if (longlong)\n \ttype = long_long_unsigned_type_node;\n       else if (long_p)\n@@ -9337,8 +9339,8 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n   else if (signed_p && type == char_type_node)\n     type = signed_char_type_node;\n-  else if (explicit_int128)\n-    type = int128_integer_type_node;\n+  else if (explicit_intN)\n+    type = int_n_trees[declspecs->int_n_idx].signed_type;\n   else if (longlong)\n     type = long_long_integer_type_node;\n   else if (long_p)\n@@ -9354,7 +9356,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t \"complex double\", but if any modifiers at all are specified it is\n \t the complex form of TYPE.  E.g, \"complex short\" is\n \t \"complex short int\".  */\n-      else if (defaulted_int && ! longlong && ! explicit_int128\n+      else if (defaulted_int && ! longlong && ! explicit_intN\n \t       && ! (long_p || short_p || signed_p || unsigned_p))\n \ttype = complex_double_type_node;\n       else if (type == integer_type_node)"}, {"sha": "fd4f92411881188f96546bc8e5137c55220330b9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -193,6 +193,15 @@ init_reswords (void)\n       if (! (c_common_reswords[i].disable & mask))\n \tC_IS_RESERVED_WORD (id) = 1;\n     }\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i++)\n+    {\n+      char name[50];\n+      sprintf (name, \"__int%d\", int_n_data[i].bitsize);\n+      id = get_identifier (name);\n+      C_SET_RID_CODE (id, RID_FIRST_INT_N + i);\n+      C_IS_RESERVED_WORD (id) = 1;\n+    }\n }\n \n static void"}, {"sha": "55f508a272a0c09d4ef2adffd1594d8a440d671e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -154,8 +154,8 @@ integer_type_codes[itk_none] =\n   'm',  /* itk_unsigned_long */\n   'x',  /* itk_long_long */\n   'y',  /* itk_unsigned_long_long */\n-  'n',  /* itk_int128 */\n-  'o',  /* itk_unsigned_int128  */\n+  /* __intN types are handled separately */\n+  '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0'\n };\n \n static int decl_is_template_id (const tree, tree* const);\n@@ -2215,6 +2215,7 @@ write_builtin_type (tree type)\n \tiagain:\n \t  for (itk = 0; itk < itk_none; ++itk)\n \t    if (integer_types[itk] != NULL_TREE\n+\t\t&& integer_type_codes[itk] != '\\0'\n \t\t&& type == integer_types[itk])\n \t      {\n \t\t/* Print the corresponding single-letter code.  */"}, {"sha": "b5a3724378fcbe46a1f090379a0e3499473f2a99", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -947,7 +947,6 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n     case RID_SHORT:\n     case RID_INT:\n     case RID_LONG:\n-    case RID_INT128:\n     case RID_SIGNED:\n     case RID_UNSIGNED:\n     case RID_FLOAT:\n@@ -962,6 +961,10 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n       return true;\n \n     default:\n+      if (token->keyword >= RID_FIRST_INT_N\n+\t  && token->keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t  && int_n_enabled_p[token->keyword - RID_FIRST_INT_N])\n+\treturn true;\n       return false;\n     }\n }\n@@ -14664,6 +14667,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n {\n   tree type = NULL_TREE;\n   cp_token *token;\n+  int idx;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -14697,12 +14701,19 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \tdecl_specs->explicit_int_p = true;\n       type = integer_type_node;\n       break;\n-    case RID_INT128:\n-      if (!int128_integer_type_node)\n+    case RID_INT_N_0:\n+    case RID_INT_N_1:\n+    case RID_INT_N_2:\n+    case RID_INT_N_3:\n+      idx = token->keyword - RID_INT_N_0;\n+      if (! int_n_enabled_p [idx])\n \tbreak;\n       if (decl_specs)\n-        decl_specs->explicit_int128_p = true;\n-      type = int128_integer_type_node;\n+\t{\n+\t  decl_specs->explicit_intN_p = true;\n+\t  decl_specs->int_n_idx = idx;\n+\t}\n+      type = int_n_trees [idx].signed_type;\n       break;\n     case RID_LONG:\n       if (decl_specs)"}, {"sha": "0d6dd960003a2c2f21012bafb4b1ad54df1dc2d2", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1520,7 +1520,6 @@ emit_support_tinfos (void)\n     &integer_type_node, &unsigned_type_node,\n     &long_integer_type_node, &long_unsigned_type_node,\n     &long_long_integer_type_node, &long_long_unsigned_type_node,\n-    &int128_integer_type_node, &int128_unsigned_type_node,\n     &float_type_node, &double_type_node, &long_double_type_node,\n     &dfloat32_type_node, &dfloat64_type_node, &dfloat128_type_node,\n     &nullptr_type_node,\n@@ -1542,6 +1541,12 @@ emit_support_tinfos (void)\n   doing_runtime = 1;\n   for (ix = 0; fundamentals[ix]; ix++)\n     emit_support_tinfo_1 (*fundamentals[ix]);\n+  for (ix = 0; ix < NUM_INT_N_ENTS; ix ++)\n+    if (int_n_enabled_p[ix])\n+      {\n+\temit_support_tinfo_1 (int_n_trees[ix].signed_type);\n+\temit_support_tinfo_1 (int_n_trees[ix].unsigned_type);\n+      }\n }\n \n /* Finish a type info decl. DECL_PTR is a pointer to an unemitted"}, {"sha": "bc30a0800e1699330505d01156bf825222dba38b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -270,6 +270,7 @@ cp_common_type (tree t1, tree t2)\n   enum tree_code code1 = TREE_CODE (t1);\n   enum tree_code code2 = TREE_CODE (t2);\n   tree attributes;\n+  int i;\n \n \n   /* In what follows, we slightly generalize the rules given in [expr] so\n@@ -364,16 +365,19 @@ cp_common_type (tree t1, tree t2)\n \t\t    : long_long_integer_type_node);\n \t  return build_type_attribute_variant (t, attributes);\n \t}\n-      if (int128_integer_type_node != NULL_TREE\n-\t  && (same_type_p (TYPE_MAIN_VARIANT (t1),\n-\t\t\t   int128_integer_type_node)\n-\t      || same_type_p (TYPE_MAIN_VARIANT (t2),\n-\t\t\t      int128_integer_type_node)))\n+      for (i = 0; i < NUM_INT_N_ENTS; i ++)\n \t{\n-\t  tree t = ((TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t\t    ? int128_unsigned_type_node\n-\t\t    : int128_integer_type_node);\n-\t  return build_type_attribute_variant (t, attributes);\n+\t  if (int_n_enabled_p [i]\n+\t      && (same_type_p (TYPE_MAIN_VARIANT (t1),\n+\t\t\t       int_n_trees[i].signed_type)\n+\t\t  || same_type_p (TYPE_MAIN_VARIANT (t2),\n+\t\t\t\t  int_n_trees[i].signed_type)))\n+\t    {\n+\t      tree t = ((TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n+\t\t\t? int_n_trees[i].unsigned_type\n+\t\t\t: int_n_trees[i].signed_type);\n+\t      return build_type_attribute_variant (t, attributes);\n+\t    }\n \t}\n \n       /* Go through the same procedure, but for longs.  */"}, {"sha": "1a32cdefeab9095bf5a639a8215d1cd30f55a40e", "filename": "gcc/genmodes.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -74,6 +74,7 @@ struct mode_data\n   unsigned int fbit;\t\t/* the number of fractional bits */\n   bool need_bytesize_adj;\t/* true if this mode need dynamic size\n \t\t\t\t   adjustment */\n+  unsigned int int_n;\t\t/* If nonzero, then __int<INT_N> will be defined */\n };\n \n static struct mode_data *modes[MAX_MODE_CLASS];\n@@ -84,7 +85,7 @@ static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0,\n-  \"<unknown>\", 0, 0, 0, 0, false\n+  \"<unknown>\", 0, 0, 0, 0, false, 0\n };\n \n static htab_t modes_by_name;\n@@ -632,6 +633,34 @@ reset_float_format (const char *name, const char *format,\n   m->format = format;\n }\n \n+/* __intN support.  */\n+#define INT_N(M,PREC)\t\t\t\t\\\n+  make_int_n (#M, PREC, __FILE__, __LINE__)\n+static void ATTRIBUTE_UNUSED\n+make_int_n (const char *m, int bitsize,\n+            const char *file, unsigned int line)\n+{\n+  struct mode_data *component = find_mode (m);\n+  if (!component)\n+    {\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, m);\n+      return;\n+    }\n+  if (component->cl != MODE_INT\n+      && component->cl != MODE_PARTIAL_INT)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" is not class INT or PARTIAL_INT\", file, line, m);\n+      return;\n+    }\n+  if (component->int_n != 0)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" already has an intN\", file, line, m);\n+      return;\n+    }\n+\n+  component->int_n = bitsize;\n+}\n+\n /* Partial integer modes are specified by relation to a full integer\n    mode.  */\n #define PARTIAL_INT_MODE(M,PREC,NAME)\t\t\t\t\\\n@@ -1010,6 +1039,7 @@ emit_insn_modes_h (void)\n {\n   int c;\n   struct mode_data *m, *first, *last;\n+  int n_int_n_ents = 0;\n \n   printf (\"/* Generated automatically from machmode.def%s%s\\n\",\n \t   HAVE_EXTRA_MODES ? \" and \" : \"\",\n@@ -1071,6 +1101,13 @@ enum machine_mode\\n{\");\n   printf (\"#define CONST_MODE_IBIT%s\\n\", adj_ibit ? \"\" : \" const\");\n   printf (\"#define CONST_MODE_FBIT%s\\n\", adj_fbit ? \"\" : \" const\");\n   emit_max_int ();\n+\n+  for_all_modes (c, m)\n+    if (m->int_n)\n+      n_int_n_ents ++;\n+\n+  printf (\"#define NUM_INT_N_ENTS %d\\n\", n_int_n_ents);\n+\n   puts (\"\\n#if GCC_VERSION >= 4001\\n\");\n   emit_mode_size_inline ();\n   emit_mode_nunits_inline ();\n@@ -1520,6 +1557,53 @@ emit_mode_fbit (void)\n   print_closer ();\n }\n \n+/* Emit __intN for all modes.  */\n+\n+static void\n+emit_mode_int_n (void)\n+{\n+  int c;\n+  struct mode_data *m;\n+  struct mode_data **mode_sort;\n+  int n_modes = 0;\n+  int i, j;\n+\n+  print_decl (\"int_n_data_t\", \"int_n_data\", \"\");\n+\n+  n_modes = 0;\n+  for_all_modes (c, m)\n+    if (m->int_n)\n+      n_modes ++;\n+  mode_sort = XALLOCAVEC (struct mode_data *, n_modes);\n+\n+  n_modes = 0;\n+  for_all_modes (c, m)\n+    if (m->int_n)\n+      mode_sort[n_modes++] = m;\n+\n+  /* Yes, this is a bubblesort, but there are at most four (and\n+     usually only 1-2) entries to sort.  */\n+  for (i = 0; i<n_modes - 1; i++)\n+    for (j = i + 1; j < n_modes; j++)\n+      if (mode_sort[i]->int_n > mode_sort[j]->int_n)\n+\t{\n+\t  m = mode_sort[i];\n+\t  mode_sort[i] = mode_sort[j];\n+\t  mode_sort[j] = m;\n+\t}\n+\n+  for (i = 0; i < n_modes; i ++)\n+    {\n+      m = mode_sort[i];\n+      printf(\" {\\n\");\n+      tagged_printf (\"%u\", m->int_n, m->name);\n+      printf (\"%smode,\", m->name);\n+      printf(\" },\\n\");\n+    }\n+\n+  print_closer ();\n+}\n+\n \n static void\n emit_insn_modes_c (void)\n@@ -1539,6 +1623,7 @@ emit_insn_modes_c (void)\n   emit_mode_adjustments ();\n   emit_mode_ibit ();\n   emit_mode_fbit ();\n+  emit_mode_int_n ();\n }\n \n static void"}, {"sha": "da993214ef817bb880944d451a5d6e7df60d1f62", "filename": "gcc/gimple.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -2113,6 +2113,7 @@ static tree\n gimple_signed_or_unsigned_type (bool unsignedp, tree type)\n {\n   tree type1;\n+  int i;\n \n   type1 = TYPE_MAIN_VARIANT (type);\n   if (type1 == signed_char_type_node\n@@ -2130,10 +2131,15 @@ gimple_signed_or_unsigned_type (bool unsignedp, tree type)\n     return unsignedp\n            ? long_long_unsigned_type_node\n \t   : long_long_integer_type_node;\n-  if (int128_integer_type_node && (type1 == int128_integer_type_node || type1 == int128_unsigned_type_node))\n-    return unsignedp\n-           ? int128_unsigned_type_node\n-\t   : int128_integer_type_node;\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& (type1 == int_n_trees[i].unsigned_type\n+\t    || type1 == int_n_trees[i].signed_type))\n+\treturn unsignedp\n+\t  ? int_n_trees[i].unsigned_type\n+\t  : int_n_trees[i].signed_type;\n+\n #if HOST_BITS_PER_WIDE_INT >= 64\n   if (type1 == intTI_type_node || type1 == unsigned_intTI_type_node)\n     return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n@@ -2246,10 +2252,14 @@ gimple_signed_or_unsigned_type (bool unsignedp, tree type)\n     return (unsignedp\n \t    ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n-  if (int128_integer_type_node && TYPE_OK (int128_integer_type_node))\n-    return (unsignedp\n-\t    ? int128_unsigned_type_node\n-\t    : int128_integer_type_node);\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& TYPE_MODE (type) == int_n_data[i].m\n+\t&& TYPE_PRECISION (type) == int_n_data[i].bitsize)\n+\treturn unsignedp\n+\t  ? int_n_trees[i].unsigned_type\n+\t  : int_n_trees[i].signed_type;\n \n #if HOST_BITS_PER_WIDE_INT >= 64\n   if (TYPE_OK (intTI_type_node))"}, {"sha": "7ae4d8a54a3dce481cf72cf6bc4c1b3777074567", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,9 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* lto-lang.c (lto_build_c_type_nodes): Check intN types for\n+\tsize-type as well.\n+\t(lto_init): Initialize all intN types, not just int128.\n+\n 2014-10-06  Martin Liska  <mliska@suse.cz>\n \n \t* lto.c (stream_out): ARG_UNUSED added for last argument."}, {"sha": "3a295308aa64826a00bd036976972de63b1d71e8", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1150,7 +1150,26 @@ lto_build_c_type_nodes (void)\n       signed_size_type_node = long_long_integer_type_node;\n     }\n   else\n-    gcc_unreachable ();\n+    {\n+      int i;\n+\n+      signed_size_type_node = NULL_TREE;\n+      for (i = 0; i < NUM_INT_N_ENTS; i++)\n+\tif (int_n_enabled_p[i])\n+\t  {\n+\t    char name[50];\n+\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+\n+\t    if (strcmp (name, SIZE_TYPE) == 0)\n+\t      {\n+\t\tintmax_type_node = int_n_trees[i].signed_type;\n+\t\tuintmax_type_node = int_n_trees[i].unsigned_type;\n+\t\tsigned_size_type_node = int_n_trees[i].signed_type;\n+\t      }\n+\t  }\n+      if (signed_size_type_node == NULL_TREE)\n+\tgcc_unreachable ();\n+    }\n \n   wint_type_node = unsigned_type_node;\n   pid_type_node = integer_type_node;\n@@ -1161,6 +1180,8 @@ lto_build_c_type_nodes (void)\n static bool\n lto_init (void)\n {\n+  int i;\n+\n   /* We need to generate LTO if running in WPA mode.  */\n   flag_generate_lto = (flag_wpa != NULL);\n \n@@ -1232,8 +1253,13 @@ lto_init (void)\n   NAME_TYPE (complex_float_type_node, \"complex float\");\n   NAME_TYPE (complex_double_type_node, \"complex double\");\n   NAME_TYPE (complex_long_double_type_node, \"complex long double\");\n-  if (int128_integer_type_node)\n-    NAME_TYPE (int128_integer_type_node, \"__int128\");\n+  for (i = 0; i < NUM_INT_N_ENTS; i++)\n+    if (int_n_enabled_p[i])\n+      {\n+\tchar name[50];\n+\tsprintf (name, \"__int%d\", int_n_data[i].bitsize);\n+\tNAME_TYPE (int_n_trees[i].signed_type, name);\n+      }\n #undef NAME_TYPE\n \n   /* Initialize LTO-specific data structures.  */"}, {"sha": "bfa0605a966b6064b0871a008941a7ec155bff8b", "filename": "gcc/machmode.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -192,6 +192,13 @@ INT_MODE (TI, 16);\n \n /* No partial integer modes are defined by default.  */\n \n+/* The target normally defines any target-specific __intN types and\n+   their modes, but __int128 for TImode is fairly common so define it\n+   here.  The type will not be created unless the target supports\n+   TImode.  */\n+\n+INT_N (TI, 128);\n+\n /* Basic floating point modes.  SF and DF are the only modes provided\n    by default.  The names QF, HF, XF, and TF are reserved for targets\n    that need 1-word, 2-word, 80-bit, or 128-bit float types respectively."}, {"sha": "27a38d36aae4153325bbff534585b61cc17a94a4", "filename": "gcc/machmode.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -345,4 +345,16 @@ extern void init_adjust_machine_modes (void);\n   (SCALAR_INT_MODE_P (MODE) \\\n    && GET_MODE_PRECISION (MODE) <= HOST_BITS_PER_WIDE_INT)\n \n+typedef struct {\n+  /* These parts are initailized by genmodes output */\n+  unsigned int bitsize;\n+  enum machine_mode m;\n+  /* RID_* is RID_INTN_BASE + index into this array */\n+} int_n_data_t;\n+\n+/* This is also in tree.h.  genmodes.c guarantees the're sorted from\n+   smallest bitsize to largest bitsize. */\n+extern bool int_n_enabled_p[NUM_INT_N_ENTS];\n+extern const int_n_data_t int_n_data[NUM_INT_N_ENTS];\n+\n #endif /* not HAVE_MACHINE_MODES */"}, {"sha": "c7b524c574c7f9b6994933c4953e010a905ea772", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -313,6 +313,7 @@ enum machine_mode\n mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n {\n   enum machine_mode mode;\n+  int i;\n \n   if (limit && size > MAX_FIXED_MODE_SIZE)\n     return BLKmode;\n@@ -323,6 +324,12 @@ mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n     if (GET_MODE_PRECISION (mode) == size)\n       return mode;\n \n+  if (mclass == MODE_INT || mclass == MODE_PARTIAL_INT)\n+    for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+      if (int_n_data[i].bitsize == size\n+\t  && int_n_enabled_p[i])\n+\treturn int_n_data[i].m;\n+\n   return BLKmode;\n }\n \n@@ -349,16 +356,27 @@ mode_for_size_tree (const_tree size, enum mode_class mclass, int limit)\n enum machine_mode\n smallest_mode_for_size (unsigned int size, enum mode_class mclass)\n {\n-  enum machine_mode mode;\n+  enum machine_mode mode = VOIDmode;\n+  int i;\n \n   /* Get the first mode which has at least this size, in the\n      specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_PRECISION (mode) >= size)\n-      return mode;\n+      break;\n \n-  gcc_unreachable ();\n+  if (mclass == MODE_INT || mclass == MODE_PARTIAL_INT)\n+    for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+      if (int_n_data[i].bitsize >= size\n+\t  && int_n_data[i].bitsize < GET_MODE_PRECISION (mode)\n+\t  && int_n_enabled_p[i])\n+\tmode = int_n_data[i].m;\n+\n+  if (mode == VOIDmode)\n+    gcc_unreachable ();\n+\n+  return mode;\n }\n \n /* Find an integer mode of the exact same size, or BLKmode on failure.  */\n@@ -2550,7 +2568,24 @@ initialize_sizetypes (void)\n   else if (strcmp (SIZETYPE, \"short unsigned int\") == 0)\n     precision = SHORT_TYPE_SIZE;\n   else\n-    gcc_unreachable ();\n+    {\n+      int i;\n+\n+      precision = -1;\n+      for (i = 0; i < NUM_INT_N_ENTS; i++)\n+\tif (int_n_enabled_p[i])\n+\t  {\n+\t    char name[50];\n+\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+\n+\t    if (strcmp (name, SIZETYPE) == 0)\n+\t      {\n+\t\tprecision = int_n_data[i].bitsize;\n+\t      }\n+\t  }\n+      if (precision == -1)\n+\tgcc_unreachable ();\n+    }\n \n   bprecision\n     = MIN (precision + BITS_PER_UNIT_LOG + 1, MAX_FIXED_MODE_SIZE);"}, {"sha": "7ef5e8a76afe2329fd4f912f5edaffd3559f11e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,7 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* g++.dg/abi/mangle64.C: New.\n+\n 2014-10-14  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* g++.dg/ext/vector9.C: Test ! with float vectors."}, {"sha": "778cda70dd12d25e790ef7a0e994e30a23868ed4", "filename": "gcc/testsuite/g++.dg/abi/mangle64.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle64.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle64.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle64.C?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target msp430*-*-* } }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-skip-if \"\" { msp430*-*-* } { \"-mcpu=msp430\" } { \"\" } }\n+\n+__int20 x;\n+\n+__int20 foo (__int20 a, unsigned __int20 b)\n+{\n+  return a + b;\n+}\n+\n+// { dg-final { scan-assembler \"\\n_?_Z3foou5int20u6uint20\\[: \\t\\n\\]\" } }\n+"}, {"sha": "f7a5035fdce468f26f49a0532ab2b72002da6d11", "filename": "gcc/toplev.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1901,6 +1901,21 @@ finalize (bool no_backend)\n   lang_hooks.finish ();\n }\n \n+static bool\n+standard_type_bitsize (int bitsize)\n+{\n+  /* As a special exception, we always want __int128 enabled if possible.  */\n+  if (bitsize == 128)\n+    return false;\n+  if (bitsize == CHAR_TYPE_SIZE\n+      || bitsize == SHORT_TYPE_SIZE\n+      || bitsize == INT_TYPE_SIZE\n+      || bitsize == LONG_TYPE_SIZE\n+      || bitsize == LONG_LONG_TYPE_SIZE)\n+    return true;\n+  return false;\n+}\n+\n /* Initialize the compiler, and compile the input file.  */\n static void\n do_compile (void)\n@@ -1916,6 +1931,8 @@ do_compile (void)\n   /* Don't do any more if an error has already occurred.  */\n   if (!seen_error ())\n     {\n+      int i;\n+\n       timevar_start (TV_PHASE_SETUP);\n \n       /* This must be run always, because it is needed to compute the FP\n@@ -1924,6 +1941,16 @@ do_compile (void)\n       init_adjust_machine_modes ();\n       init_derived_machine_modes ();\n \n+      /* This must happen after the backend has a chance to process\n+\t command line options, but before the parsers are\n+\t initialized.  */\n+      for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+\tif (targetm.scalar_mode_supported_p (int_n_data[i].m)\n+\t    && ! standard_type_bitsize (int_n_data[i].bitsize))\n+\t  int_n_enabled_p[i] = true;\n+\telse\n+\t  int_n_enabled_p[i] = false;\n+\n       /* Set up the back-end if requested.  */\n       if (!no_backend)\n \tbackend_init ();"}, {"sha": "c9004fd9771a815b7690179bfd75918475fd1735", "filename": "gcc/tree-core.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -570,8 +570,16 @@ enum integer_type_kind {\n   itk_unsigned_long,\n   itk_long_long,\n   itk_unsigned_long_long,\n-  itk_int128,\n-  itk_unsigned_int128,\n+\n+  itk_intN_0,\n+  itk_unsigned_intN_0,\n+  itk_intN_1,\n+  itk_unsigned_intN_1,\n+  itk_intN_2,\n+  itk_unsigned_intN_2,\n+  itk_intN_3,\n+  itk_unsigned_intN_3,\n+\n   itk_none\n };\n "}, {"sha": "e7032065da01eb8dc25e87ea915fff50738e2531", "filename": "gcc/tree.c", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -236,6 +236,9 @@ static void attribute_hash_list (const_tree, inchash::hash &);\n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \n+bool int_n_enabled_p[NUM_INT_N_ENTS];\n+struct int_n_trees_t int_n_trees [NUM_INT_N_ENTS];\n+\n unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n \n /* Number of operands for each OpenMP clause.  */\n@@ -9445,6 +9448,8 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n static tree\n make_or_reuse_type (unsigned size, int unsignedp)\n {\n+  int i;\n+\n   if (size == INT_TYPE_SIZE)\n     return unsignedp ? unsigned_type_node : integer_type_node;\n   if (size == CHAR_TYPE_SIZE)\n@@ -9456,9 +9461,12 @@ make_or_reuse_type (unsigned size, int unsignedp)\n   if (size == LONG_LONG_TYPE_SIZE)\n     return (unsignedp ? long_long_unsigned_type_node\n             : long_long_integer_type_node);\n-  if (size == 128 && int128_integer_type_node)\n-    return (unsignedp ? int128_unsigned_type_node\n-            : int128_integer_type_node);\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (size == int_n_data[i].bitsize\n+\t&& int_n_enabled_p[i])\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t      : int_n_trees[i].signed_type);\n \n   if (unsignedp)\n     return make_unsigned_type (size);\n@@ -9574,6 +9582,8 @@ build_atomic_base (tree type, unsigned int align)\n void\n build_common_tree_nodes (bool signed_char, bool short_double)\n {\n+  int i;\n+\n   error_mark_node = make_node (ERROR_MARK);\n   TREE_TYPE (error_mark_node) = error_mark_node;\n \n@@ -9601,17 +9611,20 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n   long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n   long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n   long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-    /* TODO: This isn't correct, but as logic depends at the moment on\n-       host's instead of target's wide-integer.\n-       If there is a target not supporting TImode, but has an 128-bit\n-       integer-scalar register, this target check needs to be adjusted. */\n-    if (targetm.scalar_mode_supported_p (TImode))\n-      {\n-        int128_integer_type_node = make_signed_type (128);\n-        int128_unsigned_type_node = make_unsigned_type (128);\n-      }\n-#endif\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i ++)\n+    {\n+      int_n_trees[i].signed_type = make_signed_type (int_n_data[i].bitsize);\n+      int_n_trees[i].unsigned_type = make_unsigned_type (int_n_data[i].bitsize);\n+      TYPE_SIZE (int_n_trees[i].signed_type) = bitsize_int (int_n_data[i].bitsize);\n+      TYPE_SIZE (int_n_trees[i].unsigned_type) = bitsize_int (int_n_data[i].bitsize);\n+\n+      if (int_n_data[i].bitsize > LONG_LONG_TYPE_SIZE)\n+\t{\n+\t  integer_types[itk_intN_0 + i * 2] = int_n_trees[i].signed_type;\n+\t  integer_types[itk_unsigned_intN_0 + i * 2] = int_n_trees[i].unsigned_type;\n+\t}\n+    }\n \n   /* Define a boolean type.  This type only represents boolean values but\n      may be larger than char depending on the value of BOOL_TYPE_SIZE.  */\n@@ -9630,7 +9643,24 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n   else if (strcmp (SIZE_TYPE, \"short unsigned int\") == 0)\n     size_type_node = short_unsigned_type_node;\n   else\n-    gcc_unreachable ();\n+    {\n+      int i;\n+\n+      size_type_node = NULL_TREE;\n+      for (i = 0; i < NUM_INT_N_ENTS; i++)\n+\tif (int_n_enabled_p[i])\n+\t  {\n+\t    char name[50];\n+\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+\n+\t    if (strcmp (name, SIZE_TYPE) == 0)\n+\t      {\n+\t\tsize_type_node = int_n_trees[i].unsigned_type;\n+\t      }\n+\t  }\n+      if (size_type_node == NULL_TREE)\n+\tgcc_unreachable ();\n+    }\n \n   /* Fill in the rest of the sized types.  Reuse existing type nodes\n      when possible.  */"}, {"sha": "45f127fd644899e31f63c3432d7d84a6f9503955", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -3426,8 +3426,6 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define long_unsigned_type_node\t\tinteger_types[itk_unsigned_long]\n #define long_long_integer_type_node\tinteger_types[itk_long_long]\n #define long_long_unsigned_type_node\tinteger_types[itk_unsigned_long_long]\n-#define int128_integer_type_node\tinteger_types[itk_int128]\n-#define int128_unsigned_type_node\tinteger_types[itk_unsigned_int128]\n \n /* True if NODE is an erroneous expression.  */\n \n@@ -4800,6 +4798,17 @@ extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n extern tree array_ref_low_bound (tree);\n \n+\n+struct GTY(()) int_n_trees_t {\n+  /* These parts are initialized at runtime */\n+  tree signed_type;\n+  tree unsigned_type;\n+};\n+\n+/* This is also in machmode.h */\n+extern bool int_n_enabled_p[NUM_INT_N_ENTS];\n+extern GTY(()) struct int_n_trees_t int_n_trees[NUM_INT_N_ENTS];\n+\n /* Like bit_position, but return as an integer.  It must be representable in\n    that way (since it could be a signed value, we don't have the\n    option of returning -1 like int_size_in_byte can.  */"}, {"sha": "cc052f082b544d56e7548485f04a75ad05acb3e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -1,3 +1,12 @@\n+2014-10-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* src/c++11/limits.cc: Add support for __intN types.\n+\t* include/std/type_traits: Likewise.\n+\t* include/std/limits: Likewise.\n+\t* include/c_std/cstdlib: Likewise.\n+\t* include/bits/cpp_type_traits.h: Likewise.\n+\t* include/c_global/cstdlib: Likewise.\n+\n 2014-10-14  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/20_util/align/1.cc: Add dg-require-stdint."}, {"sha": "46067f18a1e8fa5ed19c3bfa332d16789e4b625f", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -141,7 +141,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Thirteen specializations (yes there are eleven standard integer\n   // types; <em>long long</em> and <em>unsigned long long</em> are\n-  // supported as extensions)\n+  // supported as extensions).  Up to four target-specific __int<N>\n+  // types are supported as well.\n   template<>\n     struct __is_integer<bool>\n     {\n@@ -251,6 +252,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef __true_type __type;\n     };\n \n+#define __INT_N(TYPE) \t\t\t\\\n+  template<>\t\t\t\t\\\n+    struct __is_integer<TYPE>\t\t\\\n+    {\t\t\t\t\t\\\n+      enum { __value = 1 };\t\t\\\n+      typedef __true_type __type;\t\\\n+    };\t\t\t\t\t\\\n+  template<>\t\t\t\t\\\n+    struct __is_integer<unsigned TYPE>\t\\\n+    {\t\t\t\t\t\\\n+      enum { __value = 1 };\t\t\\\n+      typedef __true_type __type;\t\\\n+    };\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+__INT_N(__GLIBCXX_TYPE_INT_N_0)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_1\n+__INT_N(__GLIBCXX_TYPE_INT_N_1)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_2\n+__INT_N(__GLIBCXX_TYPE_INT_N_2)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_3\n+__INT_N(__GLIBCXX_TYPE_INT_N_3)\n+#endif\n+\n+#undef __INT_N\n+\n   //\n   // Floating point types\n   //"}, {"sha": "f1b36f3db61d7df4848a0f074a9167b6da99ab70", "filename": "libstdc++-v3/include/c_global/cstdlib", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -174,10 +174,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   abs(long long __x) { return __builtin_llabs (__x); }\n #endif\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  inline __int128\n-  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+  inline __GLIBCXX_TYPE_INT_N_0\n+  abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }\n #endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  inline __GLIBCXX_TYPE_INT_N_1\n+  abs(__GLIBCXX_TYPE_INT_N_1 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+  inline __GLIBCXX_TYPE_INT_N_2\n+  abs(__GLIBCXX_TYPE_INT_N_2 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_3)\n+  inline __GLIBCXX_TYPE_INT_N_3\n+  abs(__GLIBCXX_TYPE_INT_N_3 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "38c942a3ceb4dbed4b46c0d2778b50aa24775520", "filename": "libstdc++-v3/include/c_std/cstdlib", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fcstdlib?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -169,9 +169,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   abs(long long __x) { return __builtin_llabs (__x); }\n #endif\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  inline __int128\n-  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+  inline __GLIBCXX_TYPE_INT_N_0\n+  abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  inline __GLIBCXX_TYPE_INT_N_1\n+  abs(__GLIBCXX_TYPE_INT_N_1 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+  inline __GLIBCXX_TYPE_INT_N_2\n+  abs(__GLIBCXX_TYPE_INT_N_2 __x) { return __x >= 0 ? __x : -__x; }\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_3)\n+  inline __GLIBCXX_TYPE_INT_N_3\n+  abs(__GLIBCXX_TYPE_INT_N_3 __x) { return __x >= 0 ? __x : -__x; }\n #endif\n \n   inline ldiv_t"}, {"sha": "d5add09655a0259c02ac7fd95f6b7bdb4beda95d", "filename": "libstdc++-v3/include/std/limits", "status": "modified", "additions": 184, "deletions": 145, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -125,21 +125,32 @@\n \n // You should not need to define any macros below this point.\n \n-#define __glibcxx_signed(T)\t((T)(-1) < 0)\n+#define __glibcxx_signed_b(T,B)\t((T)(-1) < 0)\n \n-#define __glibcxx_min(T) \\\n-  (__glibcxx_signed (T) ? -__glibcxx_max (T) - 1 : (T)0)\n+#define __glibcxx_min_b(T,B)\t\t\t\t\t\\\n+  (__glibcxx_signed_b (T,B) ? -__glibcxx_max_b (T,B) - 1 : (T)0)\n \n-#define __glibcxx_max(T) \\\n-  (__glibcxx_signed (T) ? \\\n-   (((((T)1 << (__glibcxx_digits (T) - 1)) - 1) << 1) + 1) : ~(T)0)\n+#define __glibcxx_max_b(T,B)\t\t\t\t\t\t\\\n+  (__glibcxx_signed_b (T,B) ?\t\t\t\t\t\t\\\n+   (((((T)1 << (__glibcxx_digits_b (T,B) - 1)) - 1) << 1) + 1) : ~(T)0)\n \n-#define __glibcxx_digits(T) \\\n-  (sizeof(T) * __CHAR_BIT__ - __glibcxx_signed (T))\n+#define __glibcxx_digits_b(T,B)\t\t\t\t\\\n+  (B - __glibcxx_signed_b (T,B))\n \n // The fraction 643/2136 approximates log10(2) to 7 significant digits.\n+#define __glibcxx_digits10_b(T,B)\t\t\\\n+  (__glibcxx_digits_b (T,B) * 643L / 2136)\n+\n+#define __glibcxx_signed(T) \\\n+  __glibcxx_signed_b (T, sizeof(T) * __CHAR_BIT__)\n+#define __glibcxx_min(T) \\\n+  __glibcxx_min_b (T, sizeof(T) * __CHAR_BIT__)\n+#define __glibcxx_max(T) \\\n+  __glibcxx_max_b (T, sizeof(T) * __CHAR_BIT__)\n+#define __glibcxx_digits(T) \\\n+  __glibcxx_digits_b (T, sizeof(T) * __CHAR_BIT__)\n #define __glibcxx_digits10(T) \\\n-  (__glibcxx_digits (T) * 643L / 2136)\n+  __glibcxx_digits10_b (T, sizeof(T) * __CHAR_BIT__)\n \n #define __glibcxx_max_digits10(T) \\\n   (2 + (T) * 643L / 2136)\n@@ -1399,153 +1410,181 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        = round_toward_zero;\n     };\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  /// numeric_limits<__int128> specialization.\n-  template<>\n-    struct numeric_limits<__int128>\n-    {\n-      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (__int128); }\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (__int128); }\n+#if !defined(__STRICT_ANSI__)\n+\n+#define __INT_N(TYPE, BITSIZE, EXT, UEXT)\t\t\t\\\n+  template<> \t\t\t\t\t\t\t\t\t\\\n+    struct numeric_limits<TYPE> \t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; \t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+\tmin() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min_b (TYPE, BITSIZE); } \\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max_b (TYPE, BITSIZE);; } \t\\\t\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int digits \t\t\t\t\t\\\n+       = BITSIZE - 1; \t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \t\t\t\t\\\n+       = (BITSIZE - 1) * 643L / 2136; \t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2; \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      EXT\t\t\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \t\t\\\n+       = denorm_absent; \t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; \t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      infinity() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\t\\\n+      { return static_cast<TYPE>(0); } \t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      quiet_NaN() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<TYPE>(0); } \t\t\t\t\t\t\\\n+       \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      signaling_NaN() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<TYPE>(0); } \t\t\t\t\t\t\\\n+       \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR TYPE \t\t\t\t\t\t\\\n+      denorm_min() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<TYPE>(0); } \t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false; \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool traps \t\t\t\t\t\\\n+       = __glibcxx_integral_traps; \t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \t\t\\\n+       = round_toward_zero; \t\t\t\t\t\t\t\\\n+    }; \t\t\t\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+  template<> \t\t\t\t\t\t\t\t\t\\\n+    struct numeric_limits<unsigned TYPE> \t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; \t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      min() _GLIBCXX_USE_NOEXCEPT { return 0; } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      max() _GLIBCXX_USE_NOEXCEPT { return  __glibcxx_max_b (TYPE, BITSIZE); }  \\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      UEXT\t\t\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int digits \t\t\t\t\t\\\n+       = BITSIZE; \t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \t\t\t\t\\\n+       = BITSIZE * 643L / 2136; \t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2; \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \t\t\\\n+       = denorm_absent; \t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; \t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      infinity() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\t\\\n+      { return static_cast<unsigned TYPE>(0); } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      quiet_NaN() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<unsigned TYPE>(0); } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      signaling_NaN() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<unsigned TYPE>(0); } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_CONSTEXPR unsigned TYPE \t\t\t\t\t\\\n+      denorm_min() _GLIBCXX_USE_NOEXCEPT \t\t\t\t\t\\\n+      { return static_cast<unsigned TYPE>(0); } \t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; \t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true; \t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps; \t\\\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; \t\t\\\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \t\t\\\n+       = round_toward_zero; \t\t\t\t\t\t\t\\\n+    };\n \n #if __cplusplus >= 201103L\n-      static constexpr __int128\n-      lowest() noexcept { return min(); }\n-#endif\n \n-      static _GLIBCXX_USE_CONSTEXPR int digits\n-       = __glibcxx_digits (__int128);\n-      static _GLIBCXX_USE_CONSTEXPR int digits10\n-       = __glibcxx_digits10 (__int128);\n-#if __cplusplus >= 201103L\n+#define __INT_N_201103(TYPE)\t\t\t\t\t\t\t\\\n+      static constexpr TYPE \t\t\t\t\t\t\t\\\n+      lowest() noexcept { return min(); }\t\t\t\t\t\\\n       static constexpr int max_digits10 = 0;\n-#endif\n-      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n-      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }\n-\n-      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n-\n-      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n-      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm\n-       = denorm_absent;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      infinity() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<__int128>(0); }\n-\n-      static _GLIBCXX_CONSTEXPR __int128\n-      quiet_NaN() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<__int128>(0); }\n-      \n-      static _GLIBCXX_CONSTEXPR __int128\n-      signaling_NaN() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<__int128>(0); }\n-      \n-      static _GLIBCXX_CONSTEXPR __int128\n-      denorm_min() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<__int128>(0); }\n-\n-      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n-\n-      static _GLIBCXX_USE_CONSTEXPR bool traps\n-       = __glibcxx_integral_traps;\n-      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n-      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style\n-       = round_toward_zero;\n-    };\n-\n-  /// numeric_limits<unsigned __int128> specialization.\n-  template<>\n-    struct numeric_limits<unsigned __int128>\n-    {\n-      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      min() _GLIBCXX_USE_NOEXCEPT { return 0; }\n \n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (unsigned __int128); }\n+#define __INT_N_U201103(TYPE)\t\t\t\t\t\t\t\\\n+      static constexpr unsigned TYPE \t\t\t\t\t\t\\\n+      lowest() noexcept { return min(); }\t\t\t\t\t\\\n+      static constexpr int max_digits10 = 0;\n \n-#if __cplusplus >= 201103L\n-      static constexpr unsigned __int128\n-      lowest() noexcept { return min(); }\n+#else\n+#define __INT_N_201103(TYPE)\n+#define __INT_N_U201103(TYPE)\n #endif\n \n-      static _GLIBCXX_USE_CONSTEXPR int digits\n-       = __glibcxx_digits (unsigned __int128);\n-      static _GLIBCXX_USE_CONSTEXPR int digits10\n-       = __glibcxx_digits10 (unsigned __int128);\n-#if __cplusplus >= 201103L\n-      static constexpr int max_digits10 = 0;\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+  __INT_N(__GLIBCXX_TYPE_INT_N_0, __GLIBCXX_BITSIZE_INT_N_0,\n+\t  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_0), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_0))\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_1\n+  __INT_N (__GLIBCXX_TYPE_INT_N_1, __GLIBCXX_BITSIZE_INT_N_1,\n+\t  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_1), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_1))\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_2\n+  __INT_N (__GLIBCXX_TYPE_INT_N_2, __GLIBCXX_BITSIZE_INT_N_2,\n+\t  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_2), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_2))\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_3\n+  __INT_N (__GLIBCXX_TYPE_INT_N_3, __GLIBCXX_BITSIZE_INT_N_3,\n+\t  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_3), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_3))\n #endif\n-      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n-      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }\n-\n-      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n-      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n-\n-      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n-      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm\n-       = denorm_absent;\n-      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      infinity() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<unsigned __int128>(0); }\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      quiet_NaN() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<unsigned __int128>(0); }\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      signaling_NaN() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<unsigned __int128>(0); }\n-\n-      static _GLIBCXX_CONSTEXPR unsigned __int128\n-      denorm_min() _GLIBCXX_USE_NOEXCEPT\n-      { return static_cast<unsigned __int128>(0); }\n \n-      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n-      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+#undef __INT_N\n+#undef __INT_N_201103\n+#undef __INT_N_U201103\n \n-      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n-      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n-      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style\n-       = round_toward_zero;\n-    };\n #endif\n \n   /// numeric_limits<float> specialization."}, {"sha": "b92bbf09287367a27bbe7d2288eab9e9204c1490", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -242,13 +242,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_integral_helper<unsigned long long>\n     : public true_type { };\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n+  // Conditionalizing on __STRICT_ANSI__ here will break any port that\n+  // uses one of these types for size_t.\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n   template<>\n-    struct __is_integral_helper<__int128>\n+    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_0>\n     : public true_type { };\n \n   template<>\n-    struct __is_integral_helper<unsigned __int128>\n+    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_0>\n+    : public true_type { };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  template<>\n+    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_1>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_1>\n+    : public true_type { };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+  template<>\n+    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_2>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_2>\n+    : public true_type { };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_3)\n+  template<>\n+    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_3>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_3>\n     : public true_type { };\n #endif\n \n@@ -1661,10 +1690,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n #endif\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+  template<>\n+    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_0>\n+    { typedef unsigned __GLIBCXX_TYPE_INT_N_0 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  template<>\n+    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_1>\n+    { typedef unsigned __GLIBCXX_TYPE_INT_N_1 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n   template<>\n-    struct __make_unsigned<__int128>\n-    { typedef unsigned __int128 __type; };\n+    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_2>\n+    { typedef unsigned __GLIBCXX_TYPE_INT_N_2 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_3)\n+  template<>\n+    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_3>\n+    { typedef unsigned __GLIBCXX_TYPE_INT_N_3 __type; };\n #endif\n \n   // Select between integral and enum: not possible to be both.\n@@ -1758,10 +1802,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n #endif\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+  template<>\n+    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_0>\n+    { typedef __GLIBCXX_TYPE_INT_N_0 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+  template<>\n+    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_1>\n+    { typedef __GLIBCXX_TYPE_INT_N_1 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+  template<>\n+    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_2>\n+    { typedef __GLIBCXX_TYPE_INT_N_2 __type; };\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_3)\n   template<>\n-    struct __make_signed<unsigned __int128>\n-    { typedef __int128 __type; };\n+    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_3>\n+    { typedef __GLIBCXX_TYPE_INT_N_3 __type; };\n #endif\n \n   // Select between integral and enum: not possible to be both."}, {"sha": "5cb2b0edf0ff614424273d922754f2df53428ac2", "filename": "libstdc++-v3/src/c++11/limits.cc", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Flimits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Flimits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Flimits.cc?ref=78a7c3172fe2e6cd959abb8bfc69f6b0dc747d49", "patch": "@@ -388,54 +388,66 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   const bool numeric_limits<unsigned long long>::tinyness_before;\n   const float_round_style numeric_limits<unsigned long long>::round_style;\n \n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  const bool numeric_limits<__int128>::is_specialized;\n-  const int  numeric_limits<__int128>::digits;\n-  const int  numeric_limits<__int128>::digits10;\n-  const int  numeric_limits<__int128>::max_digits10;\n-  const bool numeric_limits<__int128>::is_signed;\n-  const bool numeric_limits<__int128>::is_integer;\n-  const bool numeric_limits<__int128>::is_exact;\n-  const int  numeric_limits<__int128>::radix;\n-  const int  numeric_limits<__int128>::min_exponent;\n-  const int  numeric_limits<__int128>::min_exponent10;\n-  const int  numeric_limits<__int128>::max_exponent;\n-  const int  numeric_limits<__int128>::max_exponent10;\n-  const bool numeric_limits<__int128>::has_infinity;\n-  const bool numeric_limits<__int128>::has_quiet_NaN;\n-  const bool numeric_limits<__int128>::has_signaling_NaN;\n-  const float_denorm_style numeric_limits<__int128>::has_denorm;\n-  const bool numeric_limits<__int128>::has_denorm_loss;\n-  const bool numeric_limits<__int128>::is_iec559;\n-  const bool numeric_limits<__int128>::is_bounded;\n-  const bool numeric_limits<__int128>::is_modulo;\n-  const bool numeric_limits<__int128>::traps;\n-  const bool numeric_limits<__int128>::tinyness_before;\n-  const float_round_style numeric_limits<__int128>::round_style;\n-\n-  const bool numeric_limits<unsigned __int128>::is_specialized;\n-  const int  numeric_limits<unsigned __int128>::digits;\n-  const int  numeric_limits<unsigned __int128>::digits10;\n-  const int  numeric_limits<unsigned __int128>::max_digits10;\n-  const bool numeric_limits<unsigned __int128>::is_signed;\n-  const bool numeric_limits<unsigned __int128>::is_integer;\n-  const bool numeric_limits<unsigned __int128>::is_exact;\n-  const int  numeric_limits<unsigned __int128>::radix;\n-  const int  numeric_limits<unsigned __int128>::min_exponent;\n-  const int  numeric_limits<unsigned __int128>::min_exponent10;\n-  const int  numeric_limits<unsigned __int128>::max_exponent;\n-  const int  numeric_limits<unsigned __int128>::max_exponent10;\n-  const bool numeric_limits<unsigned __int128>::has_infinity;\n-  const bool numeric_limits<unsigned __int128>::has_quiet_NaN;\n-  const bool numeric_limits<unsigned __int128>::has_signaling_NaN;\n-  const float_denorm_style numeric_limits<unsigned __int128>::has_denorm;\n-  const bool numeric_limits<unsigned __int128>::has_denorm_loss;\n-  const bool numeric_limits<unsigned __int128>::is_iec559;\n-  const bool numeric_limits<unsigned __int128>::is_bounded;\n-  const bool numeric_limits<unsigned __int128>::is_modulo;\n-  const bool numeric_limits<unsigned __int128>::traps;\n-  const bool numeric_limits<unsigned __int128>::tinyness_before;\n-  const float_round_style numeric_limits<unsigned __int128>::round_style;\n+#define INT_N(__INT_N_TYPE)\t\t\t\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_specialized;\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::digits;\t\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::digits10;\t\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::max_digits10;\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_signed;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_integer;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_exact;\t\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::radix;\t\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::min_exponent;\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::min_exponent10;\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::max_exponent;\t\t\t\\\n+  const int  numeric_limits<__INT_N_TYPE>::max_exponent10;\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::has_infinity;\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::has_quiet_NaN;\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::has_signaling_NaN;\t\t\t\\\n+  const float_denorm_style numeric_limits<__INT_N_TYPE>::has_denorm;\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::has_denorm_loss;\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_iec559;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_bounded;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::is_modulo;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::traps;\t\t\t\t\\\n+  const bool numeric_limits<__INT_N_TYPE>::tinyness_before;\t\t\t\\\n+  const float_round_style numeric_limits<__INT_N_TYPE>::round_style;\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_specialized;\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::digits;\t\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::digits10;\t\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::max_digits10;\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_signed;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_integer;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_exact;\t\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::radix;\t\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::min_exponent;\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::min_exponent10;\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::max_exponent;\t\t\\\n+  const int  numeric_limits<unsigned __INT_N_TYPE>::max_exponent10;\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::has_infinity;\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::has_quiet_NaN;\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::has_signaling_NaN;\t\t\\\n+  const float_denorm_style numeric_limits<unsigned __INT_N_TYPE>::has_denorm;\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::has_denorm_loss;\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_iec559;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_bounded;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::is_modulo;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::traps;\t\t\t\\\n+  const bool numeric_limits<unsigned __INT_N_TYPE>::tinyness_before;\t\t\\\n+  const float_round_style numeric_limits<unsigned __INT_N_TYPE>::round_style;\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+  INT_N (__GLIBCXX_TYPE_INT_N_0)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_1\n+  INT_N (__GLIBCXX_TYPE_INT_N_1)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_2\n+  INT_N (__GLIBCXX_TYPE_INT_N_2)\n+#endif\n+#ifdef __GLIBCXX_TYPE_INT_N_3\n+  INT_N (__GLIBCXX_TYPE_INT_N_3)\n #endif\n \n   // float"}]}