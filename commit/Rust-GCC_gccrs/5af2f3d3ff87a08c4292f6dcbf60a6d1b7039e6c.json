{"sha": "5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmMmYzZDNmZjg3YTA4YzQyOTJmNmRjYmY2MGE2ZDFiNzAzOWU2Yw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-08-27T18:50:37Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-08-27T18:50:37Z"}, "message": "s390.c (struct machine_function): Remove member literal_pool_label.\n\n\t* config/s390/s390.c (struct machine_function): Remove member\n\tliteral_pool_label.\n\t(s390_optimize_prolog): Replace TEMP_REG argument with\n\tTEMP_USED and BASE_USED.  Do not check get_pool_size ().\n\t(general_s_operand): Accept all immediates before reload if\n\tALLOW_IMMEDIATE.  If not ALLOW_IMMEDIATE, reject literal pool\n\treferences.\n\t(s390_output_symbolic_const): Remove UNSPEC_LTREL_OFFSET handling.\n\t(find_constant_pool_ref): Ignore UNSPECV_POOL_ENTRY insns.\n\t(s390_alloc_pool): New function.\n\t(s390_new_pool): Call it.\n\t(s390_dump_pool): Add REMOTE_LABEL argument.\n\t(s390_chunkify_start): Add BASE_REG argument.  Do not check\n\tget_pool_size ().\n\t(s390_chunkify_finish): Add BASE_REG argument.  Adapt\n\ts390_dump_pool call.\n\t(s390_pool_count, s390_nr_constants): Remove.\n\t(s390_output_constant_pool): Remove.\n\t(s390_mainpool_start): New function.\n\t(s390_mainpool_finish): New function.\n\t(s390_mainpool_cancel): New function.\n\t(s390_reorg): Implement main literal pool handling.\n\t(s390_emit_prologue): Emit main_pool placeholder instead of\n\tliteral_pool_31 / literal_pool_64 insns.\n\t* config/s390/s390.h (s390_pool_count, s390_nr_constants): Remove.\n\t(ASM_OUTPUT_POOL_PROLOGUE, ASM_OUTPUT_SPECIAL_POOL_ENTRY): Remove.\n\t* config/s390/s390.md (UNSPEC_MAIN_BASE): New symbolic constant.\n\t(\"main_base_31_small\", \"main_base_31_large\"): New insns.\n\t(\"main_base_64\",  \"main_pool\"): New insns.\n\t(\"literal_pool_31\", \"literal_pool_64\"): Remove.\n\nFrom-SVN: r70853", "tree": {"sha": "e9a0c8f1f0cae9c87fa0998db829f25c9f9eca97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9a0c8f1f0cae9c87fa0998db829f25c9f9eca97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/comments", "author": null, "committer": null, "parents": [{"sha": "031b59ce354bedebe9ecd57e90be14026ba77523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/031b59ce354bedebe9ecd57e90be14026ba77523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/031b59ce354bedebe9ecd57e90be14026ba77523"}], "stats": {"total": 545, "additions": 347, "deletions": 198}, "files": [{"sha": "03b535a4b488c0f77f10327c2005d35b8f4468c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "patch": "@@ -1,3 +1,36 @@\n+2003-08-27  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct machine_function): Remove member\n+\tliteral_pool_label.\n+\t(s390_optimize_prolog): Replace TEMP_REG argument with \n+\tTEMP_USED and BASE_USED.  Do not check get_pool_size ().\n+\t(general_s_operand): Accept all immediates before reload if \n+\tALLOW_IMMEDIATE.  If not ALLOW_IMMEDIATE, reject literal pool \n+\treferences.\n+\t(s390_output_symbolic_const): Remove UNSPEC_LTREL_OFFSET handling.\n+\t(find_constant_pool_ref): Ignore UNSPECV_POOL_ENTRY insns.\n+\t(s390_alloc_pool): New function.\n+\t(s390_new_pool): Call it.\n+\t(s390_dump_pool): Add REMOTE_LABEL argument.\n+\t(s390_chunkify_start): Add BASE_REG argument.  Do not check \n+\tget_pool_size ().\n+\t(s390_chunkify_finish): Add BASE_REG argument.  Adapt \n+\ts390_dump_pool call.\n+\t(s390_pool_count, s390_nr_constants): Remove.\n+\t(s390_output_constant_pool): Remove.\n+\t(s390_mainpool_start): New function.\n+\t(s390_mainpool_finish): New function.\n+\t(s390_mainpool_cancel): New function.\n+\t(s390_reorg): Implement main literal pool handling.\n+\t(s390_emit_prologue): Emit main_pool placeholder instead of \n+\tliteral_pool_31 / literal_pool_64 insns.\n+\t* config/s390/s390.h (s390_pool_count, s390_nr_constants): Remove.\n+\t(ASM_OUTPUT_POOL_PROLOGUE, ASM_OUTPUT_SPECIAL_POOL_ENTRY): Remove.\n+\t* config/s390/s390.md (UNSPEC_MAIN_BASE): New symbolic constant.\n+\t(\"main_base_31_small\", \"main_base_31_large\"): New insns.\n+\t(\"main_base_64\",  \"main_pool\"): New insns.\n+\t(\"literal_pool_31\", \"literal_pool_64\"): Remove.\n+\n 2003-08-27  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* fixinc/inclhack.def (ptx_netswap): New disabled fix, ported from"}, {"sha": "bd3fc655890d00fd5979c03615f9d58623ddedaf", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 283, "deletions": 133, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "patch": "@@ -183,9 +183,6 @@ const char *s390_arch_string;\t\t/* for -march=<xxx> */\n \n struct machine_function GTY(())\n {\n-  /* Label of start of initial literal pool.  */\n-  rtx literal_pool_label;\n-\n   /* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */\n   int save_fprs_p;\n \n@@ -223,7 +220,7 @@ static void find_constant_pool_ref (rtx, rtx *);\n static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *, rtx);\n-static void s390_optimize_prolog (int);\n+static void s390_optimize_prolog (bool, bool);\n static int find_unused_clobbered_reg (void);\n static void s390_frame_info (void);\n static rtx save_fpr (rtx, int, int);\n@@ -1139,30 +1136,30 @@ general_s_operand (register rtx op, enum machine_mode mode,\n \n   switch (GET_CODE (op))\n     {\n-      /* Constants that we are sure will be forced to the\n-         literal pool in reload are OK as s-operand.  Note\n-\t that we cannot call s390_preferred_reload_class here\n-\t because it might not be known yet at this point\n-\t whether the current function is a leaf or not.  */\n+      /* Constants are OK as s-operand if ALLOW_IMMEDIATE\n+\t is true and we are still before reload.  */\n       case CONST_INT:\n       case CONST_DOUBLE:\n \tif (!allow_immediate || reload_completed)\n-\t  break;\n-\tif (!legitimate_reload_constant_p (op))\n-\t  return 1;\n-\tif (!TARGET_64BIT)\n-\t  return 1;\n-\tbreak;\n+\t  return 0;\n+\treturn 1;\n \n       /* Memory operands are OK unless they already use an\n \t index register.  */\n       case MEM:\n \tif (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n \t  return 1;\n-\tif (s390_decompose_address (XEXP (op, 0), &addr)\n-\t    && !addr.indx)\n-\t  return 1;\n-\tbreak;\n+\tif (!s390_decompose_address (XEXP (op, 0), &addr))\n+\t  return 0;\n+\tif (addr.indx)\n+\t  return 0;\n+\t/* Do not allow literal pool references unless ALLOW_IMMEDIATE \n+\t   is true.  This prevents compares between two literal pool \n+\t   entries from being accepted.  */\n+\tif (!allow_immediate \n+\t    && addr.base && REGNO (addr.base) == BASE_REGISTER)\n+\t  return 0;\n+\treturn 1;\n \n       default:\n \tbreak;\n@@ -3278,11 +3275,6 @@ s390_output_symbolic_const (FILE *file, rtx x)\n         output_operand_lossage (\"invalid UNSPEC as operand (1)\");\n       switch (XINT (x, 1))\n         {\n-        case UNSPEC_LTREL_OFFSET:\n-\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"-\");\n-\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n-\t  break;\n \tcase UNSPEC_GOTENT:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@GOTENT\");\n@@ -3876,6 +3868,10 @@ find_constant_pool_ref (rtx x, rtx *ref)\n   if (GET_CODE (x) == UNSPEC\n       && XINT (x, 1) == UNSPEC_LTREL_BASE)\n     return;\n+  /* Likewise POOL_ENTRY insns.  */\n+  if (GET_CODE (x) == UNSPEC_VOLATILE\n+      && XINT (x, 1) == UNSPECV_POOL_ENTRY)\n+    return;\n \n   if (GET_CODE (x) == SYMBOL_REF\n       && CONSTANT_POOL_ADDRESS_P (x))\n@@ -4071,8 +4067,12 @@ struct constant_pool\n   int size;\n };\n \n-static struct constant_pool * s390_chunkify_start (void);\n-static void s390_chunkify_finish (struct constant_pool *);\n+static struct constant_pool * s390_mainpool_start (void);\n+static void s390_mainpool_finish (struct constant_pool *, rtx base_reg);\n+static void s390_mainpool_cancel (struct constant_pool *);\n+\n+static struct constant_pool * s390_chunkify_start (rtx base_reg);\n+static void s390_chunkify_finish (struct constant_pool *, rtx base_reg);\n static void s390_chunkify_cancel (struct constant_pool *);\n \n static struct constant_pool *s390_start_pool (struct constant_pool **, rtx);\n@@ -4081,7 +4081,8 @@ static void s390_add_pool_insn (struct constant_pool *, rtx);\n static struct constant_pool *s390_find_pool (struct constant_pool *, rtx);\n static void s390_add_constant (struct constant_pool *, rtx, enum machine_mode);\n static rtx s390_find_constant (struct constant_pool *, rtx, enum machine_mode);\n-static rtx s390_dump_pool (struct constant_pool *);\n+static rtx s390_dump_pool (struct constant_pool *, bool);\n+static struct constant_pool *s390_alloc_pool (void);\n static void s390_free_pool (struct constant_pool *);\n \n /* Create new constant pool covering instructions starting at INSN\n@@ -4091,18 +4092,9 @@ static struct constant_pool *\n s390_start_pool (struct constant_pool **pool_list, rtx insn)\n {\n   struct constant_pool *pool, **prev;\n-  int i;\n \n-  pool = (struct constant_pool *) xmalloc (sizeof *pool);\n-  pool->next = NULL;\n-  for (i = 0; i < NR_C_MODES; i++)\n-    pool->constants[i] = NULL;\n-\n-  pool->label = gen_label_rtx ();\n+  pool = s390_alloc_pool ();\n   pool->first_insn = insn;\n-  pool->pool_insn = NULL_RTX;\n-  pool->insns = BITMAP_XMALLOC ();\n-  pool->size = 0;\n \n   for (prev = pool_list; *prev; prev = &(*prev)->next)\n     ;\n@@ -4208,10 +4200,11 @@ s390_find_constant (struct constant_pool *pool, rtx val,\n   return offset;\n }\n \n-/* Dump out the constants in POOL.  */\n+/* Dump out the constants in POOL.  If REMOTE_LABEL is true,\n+   do not emit the pool base label.  */\n \n static rtx\n-s390_dump_pool (struct constant_pool *pool)\n+s390_dump_pool (struct constant_pool *pool, bool remote_label)\n {\n   struct constant *c;\n   rtx insn;\n@@ -4225,8 +4218,11 @@ s390_dump_pool (struct constant_pool *pool)\n     insn = emit_insn_after (gen_pool_start_31 (), pool->pool_insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n-  insn = emit_label_after (pool->label, insn);\n-  INSN_ADDRESSES_NEW (insn, -1);\n+  if (!remote_label)\n+    {\n+      insn = emit_label_after (pool->label, insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n \n   /* Dump constants in descending alignment requirement order,\n      ensuring proper alignment for every constant.  */\n@@ -4272,6 +4268,28 @@ s390_dump_pool (struct constant_pool *pool)\n   return insn;\n }\n \n+/* Allocate new constant_pool structure.  */\n+\n+static struct constant_pool *\n+s390_alloc_pool (void)\n+{\n+  struct constant_pool *pool;\n+  int i;\n+\n+  pool = (struct constant_pool *) xmalloc (sizeof *pool);\n+  pool->next = NULL;\n+  for (i = 0; i < NR_C_MODES; i++)\n+    pool->constants[i] = NULL;\n+\n+  pool->label = gen_label_rtx ();\n+  pool->first_insn = NULL_RTX;\n+  pool->pool_insn = NULL_RTX;\n+  pool->insns = BITMAP_XMALLOC ();\n+  pool->size = 0;\n+\n+  return pool;\n+}\n+\n /* Free all memory used by POOL.  */\n \n static void\n@@ -4295,16 +4313,182 @@ s390_free_pool (struct constant_pool *pool)\n }\n \n \n-/* Chunkify the literal pool if required.  */\n+/* Collect main literal pool.  Return NULL on overflow.  */\n+\n+static struct constant_pool *\n+s390_mainpool_start (void)\n+{\n+  struct constant_pool *pool;\n+  rtx insn;\n+\n+  pool = s390_alloc_pool ();\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n+\t  && XINT (PATTERN (insn), 1) == UNSPECV_MAIN_POOL)\n+\t{\n+\t  if (pool->pool_insn)\n+\t    abort ();\n+\t  pool->pool_insn = insn;\n+\t}\n+\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx pool_ref = NULL_RTX;\n+\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  if (pool_ref)\n+\t    {\n+\t      rtx constant = get_pool_constant (pool_ref);\n+\t      enum machine_mode mode = get_pool_mode (pool_ref);\n+\t      s390_add_constant (pool, constant, mode);\n+\t    }\n+\t}\n+    }\n+\n+  if (!pool->pool_insn)\n+    abort ();\n+\n+  if (pool->size >= 4096)\n+    {\n+      s390_free_pool (pool);\n+      pool = NULL;\n+    }\n+\n+  return pool;\n+}\n+\n+/* POOL holds the main literal pool as collected by s390_mainpool_start.\n+   Modify the current function to output the pool constants as well as\n+   the pool register setup instruction.  BASE_REG is the register to\n+   be used as pool base register.  */\n+\n+static void\n+s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n+{\n+  rtx insn;\n+\n+  /* If the pool is empty, we're done.  */\n+  if (pool->size == 0)\n+    {\n+      remove_insn (pool->pool_insn);\n+      s390_free_pool (pool);\n+      return;\n+    }\n+\n+  /* We need correct insn addresses.  */\n+  shorten_branches (get_insns ());\n+\n+  /* In 64-bit, we use a LARL to load the pool register.  The pool is\n+     located in the .rodata section, so we emit it after the function.  */\n+  if (TARGET_64BIT)\n+    {\n+      insn = gen_main_base_64 (base_reg, pool->label);\n+      insn = emit_insn_after (insn, pool->pool_insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+      remove_insn (pool->pool_insn);\n+     \n+      insn = get_last_insn (); \n+      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n+      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n+\n+      s390_dump_pool (pool, 0);\n+    }\n+\n+  /* In 31-bit, if the total size of the function's code plus literal pool\n+     does not exceed 4096 bytes, we use BASR to set up a function base\n+     pointer, and emit the literal pool at the end of the function.  */\n+  else if (INSN_ADDRESSES (INSN_UID (get_last_insn ()))\n+\t   + pool->size + 8 /* alignment slop */ < 4096)\n+    {\n+      insn = gen_main_base_31_small (base_reg, pool->label);\n+      insn = emit_insn_after (insn, pool->pool_insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+      remove_insn (pool->pool_insn);\n+\n+      insn = emit_label_after (pool->label, insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+\n+      insn = get_last_insn ();\n+      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n+      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n+\n+      s390_dump_pool (pool, 1);\n+    }\n+\n+  /* Otherwise, we emit an inline literal pool and use BASR to branch\n+     over it, setting up the pool register at the same time.  */\n+  else\n+    {\n+      rtx pool_end = gen_label_rtx ();\n+\n+      insn = gen_main_base_31_large (base_reg, pool->label, pool_end);\n+      insn = emit_insn_after (insn, pool->pool_insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+      remove_insn (pool->pool_insn);\n+\n+      insn = emit_label_after (pool->label, insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+\n+      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n+      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n+\n+      insn = emit_label_after (pool_end, pool->pool_insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+\n+      s390_dump_pool (pool, 1);\n+    }\n+\n+\n+  /* Replace all literal pool references.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\treplace_ltrel_base (&PATTERN (insn), base_reg);\n+\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+        {\n+          rtx addr, pool_ref = NULL_RTX;\n+          find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+          if (pool_ref)\n+            {\n+              addr = s390_find_constant (pool, get_pool_constant (pool_ref),\n+                                               get_pool_mode (pool_ref));\n+              addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n+              replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+              INSN_CODE (insn) = -1;\n+            }\n+        }\n+    }\n+\n+\n+  /* Free the pool.  */\n+  s390_free_pool (pool);\n+}\n+\n+/* POOL holds the main literal pool as collected by s390_mainpool_start.\n+   We have decided we cannot use this pool, so revert all changes\n+   to the current function that were done by s390_mainpool_start.  */\n+static void\n+s390_mainpool_cancel (struct constant_pool *pool)\n+{\n+  /* We didn't actually change the instruction stream, so simply\n+     free the pool memory.  */\n+  s390_free_pool (pool);\n+}\n+\n+\n+/* Chunkify the literal pool.  BASE_REG is to be used as pool\n+   register.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n #define S390_POOL_CHUNK_MAX\t0xe00\n \n static struct constant_pool *\n-s390_chunkify_start (void)\n+s390_chunkify_start (rtx base_reg)\n {\n-  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\n   struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n   int extra_size = 0;\n   bitmap far_labels;\n@@ -4315,11 +4499,6 @@ s390_chunkify_start (void)\n     TARGET_64BIT? gen_reload_base_64 : gen_reload_base_31;\n \n \n-  /* Do we need to chunkify the literal pool?  */\n-\n-  if (get_pool_size () < S390_POOL_CHUNK_MAX)\n-    return NULL;\n-\n   /* We need correct insn addresses.  */\n \n   shorten_branches (get_insns ());\n@@ -4568,12 +4747,12 @@ s390_chunkify_start (void)\n \n /* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n    After we have decided to use this list, finish implementing\n-   all changes to the current function as required.  */\n+   all changes to the current function as required.  BASE_REG is\n+   to be used as pool base register.  */\n \n static void\n-s390_chunkify_finish (struct constant_pool *pool_list)\n+s390_chunkify_finish (struct constant_pool *pool_list, rtx base_reg)\n {\n-  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   struct constant_pool *curr_pool = NULL;\n   rtx insn;\n \n@@ -4607,7 +4786,7 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n   /* Dump out all literal pools.  */\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n-    s390_dump_pool (curr_pool);\n+    s390_dump_pool (curr_pool, 0);\n \n   /* Free pool list.  */\n \n@@ -4680,45 +4859,6 @@ s390_chunkify_cancel (struct constant_pool *pool_list)\n }\n \n \n-/* Index of constant pool chunk that is currently being processed.\n-   Set to -1 before function output has started.  */\n-int s390_pool_count = -1;\n-\n-/* Number of elements of current constant pool.  */\n-int s390_nr_constants;\n-\n-/* Output main constant pool to stdio stream FILE.  */\n-\n-void\n-s390_output_constant_pool (rtx start_label, rtx end_label)\n-{\n-  if (TARGET_64BIT)\n-    {\n-      readonly_data_section ();\n-      ASM_OUTPUT_ALIGN (asm_out_file, 3);\n-      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t      CODE_LABEL_NUMBER (start_label));\n-    }\n-  else\n-    {\n-      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t      CODE_LABEL_NUMBER (start_label));\n-      ASM_OUTPUT_ALIGN (asm_out_file, 2);\n-    }\n-\n-  s390_pool_count = 0;\n-  output_constant_pool (current_function_name, current_function_decl);\n-  s390_pool_count = -1;\n-  if (TARGET_64BIT)\n-    function_section (current_function_decl);\n-  else\n-    {\n-      ASM_OUTPUT_ALIGN (asm_out_file, 1);\n-      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t      CODE_LABEL_NUMBER (end_label));\n-    }\n-}\n-\n /* Output to FILE the constant pool entry EXP in mode MODE\n    with alignment ALIGN.  */\n \n@@ -4760,29 +4900,23 @@ s390_output_pool_entry (FILE *file, rtx exp, enum machine_mode mode,\n \n \n /* Rework the prolog/epilog to avoid saving/restoring\n-   registers unnecessarily.  If TEMP_REGNO is nonnegative,\n-   it specifies the number of a caller-saved register used\n-   as temporary scratch register by code emitted during\n-   machine dependent reorg.  */\n+   registers unnecessarily.  BASE_USED specifies whether\n+   the literal pool base register needs to be saved, \n+   TEMP_USED specifies whether the return register needs\n+   to be saved.  */\n \n static void\n-s390_optimize_prolog (int temp_regno)\n+s390_optimize_prolog (bool base_used, bool temp_used)\n {\n   int save_first, save_last, restore_first, restore_last;\n   int i, j;\n   rtx insn, new_insn, next_insn;\n \n   /* Recompute regs_ever_live data for special registers.  */\n-  regs_ever_live[BASE_REGISTER] = 0;\n-  regs_ever_live[RETURN_REGNUM] = 0;\n+  regs_ever_live[BASE_REGISTER] = base_used;\n+  regs_ever_live[RETURN_REGNUM] = temp_used;\n   regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n-  /* If there is (possibly) any pool entry, we need to\n-     load the base register.\n-     ??? FIXME: this should be more precise.  */\n-  if (get_pool_size ())\n-    regs_ever_live[BASE_REGISTER] = 1;\n-\n   /* In non-leaf functions, the prolog/epilog code relies\n      on RETURN_REGNUM being saved in any case.  We also need\n      to save the return register if __builtin_return_address (0)\n@@ -4791,10 +4925,6 @@ s390_optimize_prolog (int temp_regno)\n       || cfun->machine->save_return_addr_p)\n     regs_ever_live[RETURN_REGNUM] = 1;\n \n-  /* We need to save/restore the temporary register.  */\n-  if (temp_regno >= 0)\n-    regs_ever_live[temp_regno] = 1;\n-\n \n   /* Find first and last gpr to be saved.  */\n \n@@ -4919,14 +5049,27 @@ static void\n s390_reorg (void)\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  bool temp_used = 0;\n+  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n+  bool temp_used = false;\n+  bool base_used = false;\n+  bool pool_overflow = false;\n \n   /* Make sure all splits have been performed; splits after\n      machine_dependent_reorg might confuse insn length counts.  */\n   split_all_insns_noflow ();\n \n \n-  /* There are two problematic situations we need to correct:\n+  /* In small leaf functions, try to use an unused call-clobbered\n+     register as base register to avoid save/restore overhead.  */\n+  if (current_function_is_leaf && !regs_ever_live[5])\n+    base_reg = gen_rtx_REG (Pmode, 5);\n+\n+\n+  /* Install the main literal pool and the associated base\n+     register load insns.\n+\n+     In addition, there are two problematic situations we need \n+     to correct:\n \n      - the literal pool might be > 4096 bytes in size, so that\n        some of its elements cannot be directly accessed\n@@ -4957,31 +5100,48 @@ s390_reorg (void)\n \n   for (;;)\n     {\n-      struct constant_pool *pool_list;\n+      struct constant_pool *pool = NULL;\n+\n+      /* Collect the literal pool.  */\n+      if (!pool_overflow)\n+\t{\n+\t  pool = s390_mainpool_start ();\n+\t  if (!pool)\n+\t    pool_overflow = true;\n+\t}\n \n-      /* Try to chunkify the literal pool.  */\n-      pool_list = s390_chunkify_start ();\n+      /* If literal pool overflowed, start to chunkify it.  */\n+      if (pool_overflow)\n+        pool = s390_chunkify_start (base_reg);\n \n       /* Split out-of-range branches.  If this has created new\n \t literal pool entries, cancel current chunk list and\n \t recompute it.  */\n       if (s390_split_branches (temp_reg, &temp_used))\n         {\n-          if (pool_list)\n-            s390_chunkify_cancel (pool_list);\n+          if (pool_overflow)\n+            s390_chunkify_cancel (pool);\n+\t  else\n+            s390_mainpool_cancel (pool);\n \n           continue;\n         }\n \n       /* If we made it up to here, both conditions are satisfied.\n-\t Finish up pool chunkification if required.  */\n-      if (pool_list)\n-\ts390_chunkify_finish (pool_list);\n+\t Finish up literal pool related changes.  */\n+      if ((pool_overflow || pool->size > 0)\n+\t   && REGNO (base_reg) == BASE_REGISTER)\n+\tbase_used = true;\n+\n+      if (pool_overflow)\n+\ts390_chunkify_finish (pool, base_reg);\n+      else\n+\ts390_mainpool_finish (pool, base_reg);\n \n       break;\n     }\n \n-  s390_optimize_prolog (temp_used? RETURN_REGNUM : -1);\n+  s390_optimize_prolog (base_used, temp_used);\n }\n \n \n@@ -5305,7 +5465,6 @@ s390_emit_prologue (void)\n {\n   rtx insn, addr;\n   rtx temp_reg;\n-  rtx pool_start_label, pool_end_label;\n   int i;\n \n   /* Compute frame_info.  */\n@@ -5327,18 +5486,9 @@ s390_emit_prologue (void)\n \t\t    cfun->machine->first_save_gpr, cfun->machine->last_save_gpr);\n   emit_insn (insn);\n \n-  /* Dump constant pool and set constant pool register.  */\n-\n-  pool_start_label = gen_label_rtx();\n-  pool_end_label = gen_label_rtx();\n-  cfun->machine->literal_pool_label = pool_start_label;\n+  /* Dummy insn to mark literal pool slot.  */\n \n-  if (TARGET_64BIT)\n-    insn = emit_insn (gen_literal_pool_64 (gen_rtx_REG (Pmode, BASE_REGISTER),\n-\t\t\t   pool_start_label, pool_end_label));\n-  else\n-    insn = emit_insn (gen_literal_pool_31 (gen_rtx_REG (Pmode, BASE_REGISTER),\n-\t\t\t\t\t     pool_start_label, pool_end_label));\n+  emit_insn (gen_main_pool ());\n \n   /* Save fprs for variable args.  */\n "}, {"sha": "5cd1d46d666e4f47bb8bda5237b2767840fafff6", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "patch": "@@ -1012,35 +1012,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \n-/* Constant Pool for all symbols operands which are changed with\n-   force_const_mem during insn generation (expand_insn).  */\n-\n-extern int s390_pool_count;\n-extern int s390_nr_constants;\n-\n-#define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, fndecl, size)  \t        \\\n-{\t\t\t\t\t\t\t\t       \t\\\n-  struct pool_constant *pool;\t\t\t\t\t       \t\\\n-\t\t\t\t\t\t\t\t        \\\n-    if (s390_pool_count == -1)                                        \t\\\n-     {\t\t\t\t\t\t\t                \\\n-       s390_nr_constants = 0;\t\t\t\t                \\\n-       for (pool = first_pool; pool; pool = pool->next)\t                \\\n-\t if (pool->mark) s390_nr_constants++;\t\t                \\\n-       return;                                      \t                \\\n-     }                                                                  \\\n-}\n-\n-#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, EXP, MODE, ALIGN, LABELNO, WIN) \\\n-{\t\t\t\t\t\t\t\t\t    \\\n-  fprintf (FILE, \".LC%d:\\n\", LABELNO);\t\t\t\t\t    \\\n-  s390_output_pool_entry (FILE, EXP, MODE, ALIGN);\t\t\t    \\\n-  if (GET_MODE_SIZE (MODE) == 1)\t\t\t\t\t    \\\n-    ASM_OUTPUT_SKIP ((FILE), (unsigned HOST_WIDE_INT)1);\t\t    \\\n-  goto WIN;\t\t\t\t\t\t\t\t    \\\n-}\n-\n-\n /* Miscellaneous parameters.  */\n \n /* Define the codes that are matched by predicates in aux-output.c.  */"}, {"sha": "4cda1480cab3b5fa48b0c240edf58de20176fd3f", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=5af2f3d3ff87a08c4292f6dcbf60a6d1b7039e6c", "patch": "@@ -65,6 +65,7 @@\n \n    ; Literal pool\n    (UNSPEC_RELOAD_BASE\t\t210)\n+   (UNSPEC_MAIN_BASE\t\t211)\n \n    ; TLS relocation specifiers\n    (UNSPEC_TLSGD\t\t500)\n@@ -7232,6 +7233,36 @@\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n+(define_insn \"main_base_31_small\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n+  \"!TARGET_64BIT\"\n+  \"basr\\t%0,0\"\n+  [(set_attr \"op_type\" \"RR\")\n+   (set_attr \"type\"    \"la\")])\n+\n+(define_insn \"main_base_31_large\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))\n+   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+  \"!TARGET_64BIT\"\n+  \"bras\\t%0,%2\"\n+  [(set_attr \"op_type\" \"RI\")])\n+\n+(define_insn \"main_base_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n+  \"TARGET_64BIT\"\n+  \"larl\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"larl\")])\n+\n+(define_insn \"main_pool\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)]\n+  \"\"\n+  \"* abort ();\"\n+  [(set_attr \"op_type\" \"NN\")])\n+\n (define_insn \"reload_base_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n         (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n@@ -7290,42 +7321,6 @@\n    (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n \n-(define_insn \"literal_pool_31\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (label_ref (match_operand 1 \"\" \"\")))\n-   (use (label_ref (match_operand 2 \"\" \"\")))]\n-  \"\"\n-{\n-   if (s390_nr_constants)\n-     {\n-       output_asm_insn (\"bras\\t%0,%2\", operands);\n-       s390_output_constant_pool (operands[1], operands[2]);\n-     }\n-\n-   return \"\";\n-}\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"type\"    \"larl\")])\n-\n-(define_insn \"literal_pool_64\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n-   (set (match_operand:DI 0 \"register_operand\" \"=a\")\n-        (label_ref (match_operand 1 \"\" \"\")))\n-   (use (label_ref (match_operand 2 \"\" \"\")))]\n-  \"\"\n-{\n-   if (s390_nr_constants)\n-     {\n-       output_asm_insn (\"larl\\t%0,%1\", operands);\n-       s390_output_constant_pool (operands[1], operands[2]);\n-     }\n-\n-   return \"\";\n-}\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"type\"    \"larl\")])\n-\n ;; Instruction definition to extend a 31-bit pointer into a 64-bit\n ;; pointer. This is used for compatability.\n "}]}