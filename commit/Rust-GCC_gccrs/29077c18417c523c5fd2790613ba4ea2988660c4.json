{"sha": "29077c18417c523c5fd2790613ba4ea2988660c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkwNzdjMTg0MTdjNTIzYzVmZDI3OTA2MTNiYTRlYTI5ODg2NjBjNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:52:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:52:29Z"}, "message": "[multiple changes]\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* scn.adb (Check_End_Of_Line): Removed.\n\t(Error_Long_Line): Removed.\n\t(Determine_License): Use versions of above routines from Scanner.\n\t* scng.adb (Check_End_Of_Line): Moved to spec.\n\t(Error_Long_Line): Removed, no longer used.\n\t* scng.ads (Check_End_Of_Line): Moved here from body.\n\n2014-01-27  Tristan Gingold  <gingold@adacore.com>\n\n\t* exp_ch7.adb (Build_Cleanup_Statements): Call\n\tBuild_Protected_Subprogram_Call_Cleanup to insert the cleanup\n\tfor protected body.\n\t* exp_ch9.adb (Build_Protected_Subprogram_Body): Likewise.\n\t Remove Service_Name variable.\n\t(Build_Protected_SUbprogam_Call_Cleanup): New procedure that\n\tfactorize code from the above subprograms.\n\t* exp_ch9.ads (Build_Protected_Subprogram_Call_Cleanup): New procedure.\n\nFrom-SVN: r207143", "tree": {"sha": "e5e8e81614a2a9517430d8c729e77035019f2b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5e8e81614a2a9517430d8c729e77035019f2b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29077c18417c523c5fd2790613ba4ea2988660c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29077c18417c523c5fd2790613ba4ea2988660c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29077c18417c523c5fd2790613ba4ea2988660c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29077c18417c523c5fd2790613ba4ea2988660c4/comments", "author": null, "committer": null, "parents": [{"sha": "2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2757c5bf1817db84c51f0297ae8c27acfaea2ad3"}], "stats": {"total": 426, "additions": 207, "deletions": 219}, "files": [{"sha": "048cf2ae9f28c562211975dd30433a1107cca5c8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -1,3 +1,23 @@\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* scn.adb (Check_End_Of_Line): Removed.\n+\t(Error_Long_Line): Removed.\n+\t(Determine_License): Use versions of above routines from Scanner.\n+\t* scng.adb (Check_End_Of_Line): Moved to spec.\n+\t(Error_Long_Line): Removed, no longer used.\n+\t* scng.ads (Check_End_Of_Line): Moved here from body.\n+\n+2014-01-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Cleanup_Statements): Call\n+\tBuild_Protected_Subprogram_Call_Cleanup to insert the cleanup\n+\tfor protected body.\n+\t* exp_ch9.adb (Build_Protected_Subprogram_Body): Likewise.\n+\t Remove Service_Name variable.\n+\t(Build_Protected_SUbprogam_Call_Cleanup): New procedure that\n+\tfactorize code from the above subprograms.\n+\t* exp_ch9.ads (Build_Protected_Subprogram_Call_Cleanup): New procedure.\n+\n 2014-01-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb (Has_Option): Reimplemented."}, {"sha": "1e0c9bbd3fe829ef5a96d6198591205c90b96e63", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 7, "deletions": 74, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -511,7 +511,6 @@ package body Exp_Ch7 is\n          declare\n             Spec      : constant Node_Id := Parent (Corresponding_Spec (N));\n             Conc_Typ  : Entity_Id;\n-            Nam       : Node_Id;\n             Param     : Node_Id;\n             Param_Typ : Entity_Id;\n \n@@ -532,81 +531,15 @@ package body Exp_Ch7 is\n \n             pragma Assert (Present (Param));\n \n-            --  If the associated protected object has entries, a protected\n-            --  procedure has to service entry queues. In this case generate:\n+            --  Historical note: In earlier versions of GNAT, there was code\n+            --  at this point to generate stuff to service entry queues. But\n+            --  that was wrong thinking. This was useless and resulted in\n+            --  incoherencies between code generated with and without -gnatp.\n \n-            --    Service_Entries (_object._object'Access);\n+            --  All that is needed at this stage is a normal cleanup call\n \n-            if Nkind (Specification (N)) = N_Procedure_Specification\n-              and then Has_Entries (Conc_Typ)\n-            then\n-               case Corresponding_Runtime_Package (Conc_Typ) is\n-                  when System_Tasking_Protected_Objects_Entries =>\n-                     Nam := New_Reference_To (RTE (RE_Service_Entries), Loc);\n-\n-                  when System_Tasking_Protected_Objects_Single_Entry =>\n-                     Nam := New_Reference_To (RTE (RE_Service_Entry), Loc);\n-\n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n-\n-               Append_To (Stmts,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   => Nam,\n-                   Parameter_Associations => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix        => New_Reference_To (\n-                             Defining_Identifier (Param), Loc),\n-                           Selector_Name =>\n-                             Make_Identifier (Loc, Name_uObject)),\n-                       Attribute_Name => Name_Unchecked_Access))));\n-\n-            else\n-               --  Generate:\n-               --    Unlock (_object._object'Access);\n-\n-               case Corresponding_Runtime_Package (Conc_Typ) is\n-                  when System_Tasking_Protected_Objects_Entries =>\n-                     Nam := New_Reference_To (RTE (RE_Unlock_Entries), Loc);\n-\n-                  when System_Tasking_Protected_Objects_Single_Entry =>\n-                     Nam := New_Reference_To (RTE (RE_Unlock_Entry), Loc);\n-\n-                  when System_Tasking_Protected_Objects =>\n-                     Nam := New_Reference_To (RTE (RE_Unlock), Loc);\n-\n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n-\n-               Append_To (Stmts,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   => Nam,\n-                   Parameter_Associations => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix        =>\n-                             New_Reference_To\n-                               (Defining_Identifier (Param), Loc),\n-                           Selector_Name =>\n-                             Make_Identifier (Loc, Name_uObject)),\n-                       Attribute_Name => Name_Unchecked_Access))));\n-            end if;\n-\n-            --  Generate:\n-            --    Abort_Undefer;\n-\n-            if Abort_Allowed then\n-               Append_To (Stmts,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   =>\n-                     New_Reference_To (RTE (RE_Abort_Undefer), Loc),\n-                   Parameter_Associations => Empty_List));\n-            end if;\n+            Build_Protected_Subprogram_Call_Cleanup\n+              (Specification (N), Conc_Typ, Loc, Stmts);\n          end;\n \n       --  Add a call to Expunge_Unactivated_Tasks for dynamically allocated"}, {"sha": "96a09279ce42a4713baed8694adf87cc20d8155a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 86, "deletions": 18, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -4150,7 +4150,6 @@ package body Exp_Ch9 is\n       Sub_Body     : Node_Id;\n       Lock_Name    : Node_Id;\n       Lock_Stmt    : Node_Id;\n-      Service_Name : Node_Id;\n       R            : Node_Id;\n       Return_Stmt  : Node_Id := Empty;    -- init to avoid gcc 3 warning\n       Pre_Stmts    : List_Id := No_List;  -- init to avoid gcc 3 warning\n@@ -4235,15 +4234,12 @@ package body Exp_Ch9 is\n       case Corresponding_Runtime_Package (Pid) is\n          when System_Tasking_Protected_Objects_Entries =>\n             Lock_Name := New_Reference_To (RTE (RE_Lock_Entries), Loc);\n-            Service_Name := New_Reference_To (RTE (RE_Service_Entries), Loc);\n \n          when System_Tasking_Protected_Objects_Single_Entry =>\n             Lock_Name := New_Reference_To (RTE (RE_Lock_Entry), Loc);\n-            Service_Name := New_Reference_To (RTE (RE_Service_Entry), Loc);\n \n          when System_Tasking_Protected_Objects =>\n             Lock_Name := New_Reference_To (RTE (Lock_Kind), Loc);\n-            Service_Name := New_Reference_To (RTE (RE_Unlock), Loc);\n \n          when others =>\n             raise Program_Error;\n@@ -4282,20 +4278,7 @@ package body Exp_Ch9 is\n             Append (Unprot_Call, Stmts);\n          end if;\n \n-         Append (\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => Service_Name,\n-             Parameter_Associations =>\n-               New_List (New_Copy_Tree (Object_Parm))),\n-           Stmts);\n-\n-         if Abort_Allowed then\n-            Append (\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Abort_Undefer), Loc),\n-                Parameter_Associations => Empty_List),\n-              Stmts);\n-         end if;\n+         Build_Protected_Subprogram_Call_Cleanup (Op_Spec, Pid, Loc, Stmts);\n \n          if Nkind (Op_Spec) = N_Function_Specification then\n             Append (Return_Stmt, Stmts);\n@@ -4388,6 +4371,91 @@ package body Exp_Ch9 is\n       end if;\n    end Build_Protected_Subprogram_Call;\n \n+   ---------------------------------------------\n+   -- Build_Protected_Subprogram_Call_Cleanup --\n+   ---------------------------------------------\n+\n+   procedure Build_Protected_Subprogram_Call_Cleanup\n+     (Op_Spec   : Node_Id;\n+      Conc_Typ  : Node_Id;\n+      Loc       : Source_Ptr;\n+      Stmts     : List_Id)\n+   is\n+      Nam       : Node_Id;\n+\n+   begin\n+      --  If the associated protected object has entries, a protected\n+      --  procedure has to service entry queues. In this case generate:\n+\n+      --    Service_Entries (_object._object'Access);\n+\n+      if Nkind (Op_Spec) = N_Procedure_Specification\n+        and then Has_Entries (Conc_Typ)\n+      then\n+         case Corresponding_Runtime_Package (Conc_Typ) is\n+            when System_Tasking_Protected_Objects_Entries =>\n+               Nam := New_Reference_To (RTE (RE_Service_Entries), Loc);\n+\n+            when System_Tasking_Protected_Objects_Single_Entry =>\n+               Nam := New_Reference_To (RTE (RE_Service_Entry), Loc);\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => Nam,\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix        => Make_Identifier (Loc, Name_uObject),\n+                     Selector_Name => Make_Identifier (Loc, Name_uObject)),\n+                 Attribute_Name => Name_Unchecked_Access))));\n+\n+      else\n+         --  Generate:\n+         --    Unlock (_object._object'Access);\n+\n+         case Corresponding_Runtime_Package (Conc_Typ) is\n+            when System_Tasking_Protected_Objects_Entries =>\n+               Nam := New_Reference_To (RTE (RE_Unlock_Entries), Loc);\n+\n+            when System_Tasking_Protected_Objects_Single_Entry =>\n+               Nam := New_Reference_To (RTE (RE_Unlock_Entry), Loc);\n+\n+            when System_Tasking_Protected_Objects =>\n+               Nam := New_Reference_To (RTE (RE_Unlock), Loc);\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => Nam,\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix        => Make_Identifier (Loc, Name_uObject),\n+                     Selector_Name => Make_Identifier (Loc, Name_uObject)),\n+                 Attribute_Name => Name_Unchecked_Access))));\n+      end if;\n+\n+      --  Generate:\n+      --    Abort_Undefer;\n+\n+      if Abort_Allowed then\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Reference_To (RTE (RE_Abort_Undefer), Loc),\n+             Parameter_Associations => Empty_List));\n+      end if;\n+   end Build_Protected_Subprogram_Call_Cleanup;\n+\n    -------------------------\n    -- Build_Selected_Name --\n    -------------------------"}, {"sha": "db1e6904c7283b351846e563e078697a07b22b35", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -112,6 +112,16 @@ package Exp_Ch9 is\n    --  External is False if the call is to another protected subprogram within\n    --  the same object.\n \n+   procedure Build_Protected_Subprogram_Call_Cleanup\n+     (Op_Spec   : Node_Id;\n+      Conc_Typ  : Node_Id;\n+      Loc       : Source_Ptr;\n+      Stmts     : List_Id);\n+   --  Append to Stmts the cleanups after a call to a protected subprogram\n+   --  whose specification is Op_Spec. Conc_Typ is the concurrent type and Loc\n+   --  the sloc for appended statements. The cleanup will either unlock the\n+   --  protected object or serve pending entries.\n+\n    procedure Build_Task_Activation_Call (N : Node_Id);\n    --  This procedure is called for constructs that can be task activators,\n    --  i.e. task bodies, subprogram bodies, package bodies and blocks. If the"}, {"sha": "cc88ab9c1251b0939366e80e2806b81463225392", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,7 +25,6 @@\n \n with Atree;    use Atree;\n with Csets;    use Csets;\n-with Hostparm; use Hostparm;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n@@ -44,32 +43,11 @@ package body Scn is\n    --  make sure that we only post an error message for incorrect use of a\n    --  keyword as an identifier once for a given keyword).\n \n-   procedure Check_End_Of_Line;\n-   --  Called when end of line encountered. Checks that line is not too long,\n-   --  and that other style checks for the end of line are met.\n-\n    function Determine_License return License_Type;\n    --  Scan header of file and check that it has an appropriate GNAT-style\n    --  header with a proper license statement. Returns GPL, Unrestricted,\n    --  or Modified_GPL depending on header. If none of these, returns Unknown.\n \n-   procedure Error_Long_Line;\n-   --  Signal error of excessively long line\n-\n-   -----------------------\n-   -- Check_End_Of_Line --\n-   -----------------------\n-\n-   procedure Check_End_Of_Line is\n-      Len : constant Int := Int (Scan_Ptr) - Int (Current_Line_Start);\n-   begin\n-      if Style_Check then\n-         Style.Check_Line_Terminator (Len);\n-      elsif Len > Max_Line_Length then\n-         Error_Long_Line;\n-      end if;\n-   end Check_End_Of_Line;\n-\n    -----------------------\n    -- Determine_License --\n    -----------------------\n@@ -182,7 +160,7 @@ package body Scn is\n \n          Skip_EOL;\n \n-         Check_End_Of_Line;\n+         Scanner.Check_End_Of_Line;\n \n          if Source (Scan_Ptr) /= EOF then\n \n@@ -219,17 +197,6 @@ package body Scn is\n       return Scanner.Determine_Token_Casing;\n    end Determine_Token_Casing;\n \n-   ---------------------\n-   -- Error_Long_Line --\n-   ---------------------\n-\n-   procedure Error_Long_Line is\n-   begin\n-      Error_Msg\n-        (\"this line is too long\",\n-         Current_Line_Start + Source_Ptr (Max_Line_Length));\n-   end Error_Long_Line;\n-\n    ------------------------\n    -- Initialize_Scanner --\n    ------------------------"}, {"sha": "8b08949601afef07fbb6a9421dbcc5bedf323c65", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 76, "deletions": 90, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -259,6 +259,82 @@ package body Scng is\n       end case;\n    end Accumulate_Token_Checksum_GNAT_5_03;\n \n+   -----------------------\n+   -- Check_End_Of_Line --\n+   -----------------------\n+\n+   procedure Check_End_Of_Line is\n+      Len : constant Int :=\n+              Int (Scan_Ptr) -\n+                Int (Current_Line_Start) -\n+                  Wide_Char_Byte_Count;\n+\n+   --  Start of processing for Check_End_Of_Line\n+\n+   begin\n+      if Style_Check then\n+         Style.Check_Line_Terminator (Len);\n+      end if;\n+\n+      --  Deal with checking maximum line length\n+\n+      if Style_Check and Style_Check_Max_Line_Length then\n+         Style.Check_Line_Max_Length (Len);\n+\n+         --  If style checking is inactive, check maximum line length against\n+         --  standard value.\n+\n+      elsif Len > Max_Line_Length then\n+         Error_Msg\n+           (\"this line is too long\",\n+            Current_Line_Start + Source_Ptr (Max_Line_Length));\n+      end if;\n+\n+      --  Now one more checking circuit. Normally we are only enforcing a limit\n+      --  of physical characters, with tabs counting as one character. But if\n+      --  after tab expansion we would have a total line length that exceeded\n+      --  32766, that would really cause trouble, because column positions\n+      --  would exceed the maximum we allow for a column count. Note: the limit\n+      --  is 32766 rather than 32767, since we use a value of 32767 for special\n+      --  purposes (see Sinput). Now we really do not want to go messing with\n+      --  tabs in the normal case, so what we do is to check for a line that\n+      --  has more than 4096 physical characters. Any shorter line could not\n+      --  be a problem, even if it was all tabs.\n+\n+      if Len >= 4096 then\n+         declare\n+            Col : Natural;\n+            Ptr : Source_Ptr;\n+\n+         begin\n+            Col := 1;\n+            Ptr := Current_Line_Start;\n+            loop\n+               exit when Ptr = Scan_Ptr;\n+\n+               if Source (Ptr) = ASCII.HT then\n+                  Col := (Col - 1 + 8) / 8 * 8 + 1;\n+               else\n+                  Col := Col + 1;\n+               end if;\n+\n+               if Col > 32766 then\n+                  Error_Msg\n+                    (\"this line is longer than 32766 characters\",\n+                     Current_Line_Start);\n+                  raise Unrecoverable_Error;\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Reset wide character byte count for next line\n+\n+      Wide_Char_Byte_Count := 0;\n+   end Check_End_Of_Line;\n+\n    ----------------------------\n    -- Determine_Token_Casing --\n    ----------------------------\n@@ -336,10 +412,6 @@ package body Scng is\n       Wptr : Source_Ptr;\n       --  Used to remember start of last wide character scanned\n \n-      procedure Check_End_Of_Line;\n-      --  Called when end of line encountered. Checks that line is not too\n-      --  long, and that other style checks for the end of line are met.\n-\n       function Double_Char_Token (C : Character) return Boolean;\n       --  This function is used for double character tokens like := or <>. It\n       --  checks if the character following Source (Scan_Ptr) is C, and if so\n@@ -359,9 +431,6 @@ package body Scng is\n       --  past the illegal character, which may still leave us pointing to\n       --  junk, not much we can do if the escape sequence is messed up!\n \n-      procedure Error_Long_Line;\n-      --  Signal error of excessively long line\n-\n       procedure Error_No_Double_Underline;\n       --  Signal error of two underline or punctuation characters in a row.\n       --  Called with Scan_Ptr pointing to second underline/punctuation char.\n@@ -388,78 +457,6 @@ package body Scng is\n       --  Returns True if the scan pointer is pointing to the start of a wide\n       --  character sequence, does not modify the scan pointer in any case.\n \n-      -----------------------\n-      -- Check_End_Of_Line --\n-      -----------------------\n-\n-      procedure Check_End_Of_Line is\n-         Len : constant Int :=\n-                 Int (Scan_Ptr) -\n-                 Int (Current_Line_Start) -\n-                 Wide_Char_Byte_Count;\n-\n-      begin\n-         if Style_Check then\n-            Style.Check_Line_Terminator (Len);\n-         end if;\n-\n-         --  Deal with checking maximum line length\n-\n-         if Style_Check and Style_Check_Max_Line_Length then\n-            Style.Check_Line_Max_Length (Len);\n-\n-         --  If style checking is inactive, check maximum line length against\n-         --  standard value.\n-\n-         elsif Len > Max_Line_Length then\n-            Error_Long_Line;\n-         end if;\n-\n-         --  Now one more checking circuit. Normally we are only enforcing a\n-         --  limit of physical characters, with tabs counting as one character.\n-         --  But if after tab expansion we would have a total line length that\n-         --  exceeded 32766, that would really cause trouble, because column\n-         --  positions would exceed the maximum we allow for a column count.\n-         --  Note: the limit is 32766 rather than 32767, since we use a value\n-         --  of 32767 for special purposes (see Sinput). Now we really do not\n-         --  want to go messing with tabs in the normal case, so what we do is\n-         --  to check for a line that has more than 4096 physical characters.\n-         --  Any shorter line could not be a problem, even if it was all tabs.\n-\n-         if Len >= 4096 then\n-            declare\n-               Col : Natural;\n-               Ptr : Source_Ptr;\n-\n-            begin\n-               Col := 1;\n-               Ptr := Current_Line_Start;\n-               loop\n-                  exit when Ptr = Scan_Ptr;\n-\n-                  if Source (Ptr) = ASCII.HT then\n-                     Col := (Col - 1 + 8) / 8 * 8 + 1;\n-                  else\n-                     Col := Col + 1;\n-                  end if;\n-\n-                  if Col > 32766 then\n-                     Error_Msg\n-                       (\"this line is longer than 32766 characters\",\n-                        Current_Line_Start);\n-                     raise Unrecoverable_Error;\n-                  end if;\n-\n-                  Ptr := Ptr + 1;\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  Reset wide character byte count for next line\n-\n-         Wide_Char_Byte_Count := 0;\n-      end Check_End_Of_Line;\n-\n       -----------------------\n       -- Double_Char_Token --\n       -----------------------\n@@ -505,17 +502,6 @@ package body Scng is\n          Error_Msg (\"illegal wide character\", Wptr);\n       end Error_Illegal_Wide_Character;\n \n-      ---------------------\n-      -- Error_Long_Line --\n-      ---------------------\n-\n-      procedure Error_Long_Line is\n-      begin\n-         Error_Msg\n-           (\"this line is too long\",\n-            Current_Line_Start + Source_Ptr (Max_Line_Length));\n-      end Error_Long_Line;\n-\n       -------------------------------\n       -- Error_No_Double_Underline --\n       -------------------------------"}, {"sha": "32ecc67d0ad3e9b68cc12cfc89ba458e7810f4ba", "filename": "gcc/ada/scng.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscng.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29077c18417c523c5fd2790613ba4ea2988660c4/gcc%2Fada%2Fscng.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.ads?ref=29077c18417c523c5fd2790613ba4ea2988660c4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,6 +56,10 @@ generic\n \n package Scng is\n \n+   procedure Check_End_Of_Line;\n+   --  Called when end of line encountered. Checks that line is not too long,\n+   --  and that other style checks for the end of line are met.\n+\n    procedure Initialize_Scanner (Index : Source_File_Index);\n    --  Initialize lexical scanner for scanning a new file referenced by Index.\n    --  Initialize_Scanner does not call Scan."}]}