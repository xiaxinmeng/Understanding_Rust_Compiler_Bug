{"sha": "710b6cc1f06453523da058124cd1d63dfe05e350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwYjZjYzFmMDY0NTM1MjNkYTA1ODEyNGNkMWQ2M2RmZTA1ZTM1MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-06-12T18:57:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-06-12T18:57:00Z"}, "message": "mips.md (extended_mips16): Include GOT and constant-pool loads.\n\ngcc/\n\t* config/mips/mips.md (extended_mips16): Include GOT and constant-pool\n\tloads.\n\t(insn_count): New attribute, with most cases extracted from...\n\t(length): ...here.  Redefine most cases in terms of insn_count.\n\t(single_insn): Delete.\n\t(can_delay): Use insn_count to check for single instructions.\n\t(*mul<mode>3_r4300, mul<mode>3_r4000, *mul_acc_si, *mul_acc_si_r3900)\n\t(*msac_using_macc, *mul_sub_si, <u>mulsidi3_32bit_r4000)\n\t(<u>mulsidi3_64bit_r4000, <su>muldi3_highpart_internal)\n\t(<su>mulsi3_highpart_split, <su>muldi3_highpart_internal)\n\t(<u>mulditi3_r4000, *div<mode>3, *recip<mode>3, divmod<mode>4)\n\t(udivmod<mode>4, sqrt<mode>2, *rsqrt<mode>a, *rsqrt<mode>b)\n\t(fix_truncdfsi2_macro, fix_truncsfsi2_macro, *lea_high64)\n\t(*lea64, cprestore_<mode>, clear_hazard_<mode>, <unnamed insn>)\n\t(casesi_internal_mips16_<mode>, *tls_get_tp_<mode>_split)\n\t(tls_get_tp_mips16, *tls_get_tp_mips16_call_<mode>): Use \"insn_count\"\n\trather than \"length\".\n\t(tls_get_tp_<mode>): Likewise.  Remove redundant \"no_delay\" attribute.\n\t* config/mips/mips-ps-3d.md (mips_c_cond_4s, mips_cabs_cond_4s):\n\tUse \"insn_count\" rather than \"length\".\n\t* config/mips/mips-dsp.md\n\t(mips_l<SHORT:size><u>x_ext<GPR:mode>_<P:mode>)\n\t(mips_l<GPR:size>x_<P:mode>, *mips_lw<u>x_<P:mode>_ext): Remove\n\tlength attributes.\n\ngcc/testsuite/\n\t* gcc.target/mips/umips-branch-1.c, gcc.target/mips/umips-branch-2.c:\n\tNew tests.\n\nFrom-SVN: r200037", "tree": {"sha": "127335744264ccab49a1a4f40fc74ef39034a8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127335744264ccab49a1a4f40fc74ef39034a8d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/710b6cc1f06453523da058124cd1d63dfe05e350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710b6cc1f06453523da058124cd1d63dfe05e350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710b6cc1f06453523da058124cd1d63dfe05e350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710b6cc1f06453523da058124cd1d63dfe05e350/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1951f1016cd8eec62db59a76840bde6a61d53ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1951f1016cd8eec62db59a76840bde6a61d53ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1951f1016cd8eec62db59a76840bde6a61d53ad4"}], "stats": {"total": 360, "additions": 198, "deletions": 162}, "files": [{"sha": "43ed90c36eef1c52ac35b8745914e60412b4c6da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -1,3 +1,30 @@\n+2013-06-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.md (extended_mips16): Include GOT and constant-pool\n+\tloads.\n+\t(insn_count): New attribute, with most cases extracted from...\n+\t(length): ...here.  Redefine most cases in terms of insn_count.\n+\t(single_insn): Delete.\n+\t(can_delay): Use insn_count to check for single instructions.\n+\t(*mul<mode>3_r4300, mul<mode>3_r4000, *mul_acc_si, *mul_acc_si_r3900)\n+\t(*msac_using_macc, *mul_sub_si, <u>mulsidi3_32bit_r4000)\n+\t(<u>mulsidi3_64bit_r4000, <su>muldi3_highpart_internal)\n+\t(<su>mulsi3_highpart_split, <su>muldi3_highpart_internal)\n+\t(<u>mulditi3_r4000, *div<mode>3, *recip<mode>3, divmod<mode>4)\n+\t(udivmod<mode>4, sqrt<mode>2, *rsqrt<mode>a, *rsqrt<mode>b)\n+\t(fix_truncdfsi2_macro, fix_truncsfsi2_macro, *lea_high64)\n+\t(*lea64, cprestore_<mode>, clear_hazard_<mode>, <unnamed insn>)\n+\t(casesi_internal_mips16_<mode>, *tls_get_tp_<mode>_split)\n+\t(tls_get_tp_mips16, *tls_get_tp_mips16_call_<mode>): Use \"insn_count\"\n+\trather than \"length\".\n+\t(tls_get_tp_<mode>): Likewise.  Remove redundant \"no_delay\" attribute.\n+\t* config/mips/mips-ps-3d.md (mips_c_cond_4s, mips_cabs_cond_4s):\n+\tUse \"insn_count\" rather than \"length\".\n+\t* config/mips/mips-dsp.md\n+\t(mips_l<SHORT:size><u>x_ext<GPR:mode>_<P:mode>)\n+\t(mips_l<GPR:size>x_<P:mode>, *mips_lw<u>x_<P:mode>_ext): Remove\n+\tlength attributes.\n+\n 2013-06-12  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/57361"}, {"sha": "49a08689638fa101b6abbc69f01e856f2095dd29", "filename": "gcc/config/mips/mips-dsp.md", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -1131,8 +1131,7 @@\n   \"ISA_HAS_L<SHORT:SIZE><U>X\"\n   \"l<SHORT:size><u>x\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"<GPR:MODE>\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"<GPR:MODE>\")])\n \n (define_expand \"mips_lhx\"\n   [(match_operand:SI 0 \"register_operand\")\n@@ -1165,8 +1164,7 @@\n   \"ISA_HAS_L<GPR:SIZE>X\"\n   \"l<GPR:size>x\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"<GPR:MODE>\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"<GPR:MODE>\")])\n \n (define_insn \"*mips_lw<u>x_<P:mode>_ext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -1176,8 +1174,7 @@\n   \"ISA_HAS_LW<U>X && TARGET_64BIT\"\n   \"lw<u>x\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"DI\")])\n \n ;; Table 2-8. MIPS DSP ASE Instructions: Branch\n ;; BPOSGE32"}, {"sha": "a22c7829b7724c42955cd7776a81a5352c9d3f9f", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -481,7 +481,7 @@\n   operands[7] = simplify_gen_subreg (CCV2mode, operands[0], CCV4mode, 8);\n }\n   [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"length\" \"8\")\n+   (set_attr \"insn_count\" \"2\")\n    (set_attr \"mode\" \"FPSW\")])\n \n (define_insn_and_split \"mips_cabs_cond_4s\"\n@@ -510,7 +510,7 @@\n   operands[7] = simplify_gen_subreg (CCV2mode, operands[0], CCV4mode, 8);\n }\n   [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"length\" \"8\")\n+   (set_attr \"insn_count\" \"2\")\n    (set_attr \"mode\" \"FPSW\")])\n \n "}, {"sha": "ed60d0e44f2139cf8f66c1244a6f7227fbb839cd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 141, "deletions": 154, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -407,8 +407,12 @@\n \n ;; Is this an extended instruction in mips16 mode?\n (define_attr \"extended_mips16\" \"no,yes\"\n-  (if_then_else (ior (eq_attr \"move_type\" \"sll0\")\n-\t\t     (eq_attr \"jal\" \"direct\"))\n+  (if_then_else (ior ;; In general, constant-pool loads are extended\n+  \t\t     ;; instructions.  We don't yet optimize for 16-bit\n+\t\t     ;; PC-relative references.\n+  \t\t     (eq_attr \"move_type\" \"sll0,loadpool\")\n+\t\t     (eq_attr \"jal\" \"direct\")\n+\t\t     (eq_attr \"got\" \"load\"))\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n@@ -421,14 +425,89 @@\n \t                  (match_test \"TARGET_MICROMIPS\")))\n \t        (const_string \"yes\")\n \t        (const_string \"no\")))\n-  \n-;; Length of instruction in bytes.\n-(define_attr \"length\" \"\"\n-   (cond [(and (eq_attr \"extended_mips16\" \"yes\")\n-\t       (match_test \"TARGET_MIPS16\"))\n-\t  (const_int 4)\n \n-\t  (and (eq_attr \"compression\" \"micromips,all\")\n+;; The number of individual instructions that a non-branch pattern generates,\n+;; using units of BASE_INSN_LENGTH.\n+(define_attr \"insn_count\" \"\"\n+  (cond [;; \"Ghost\" instructions occupy no space.\n+\t (eq_attr \"type\" \"ghost\")\n+\t (const_int 0)\n+\n+\t ;; Extended instructions count as 2.\n+   \t (and (eq_attr \"extended_mips16\" \"yes\")\n+\t      (match_test \"TARGET_MIPS16\"))\n+\t (const_int 2)\n+\n+\t ;; A GOT load followed by an add of $gp.  This is not used for MIPS16.\n+\t (eq_attr \"got\" \"xgot_high\")\n+\t (const_int 2)\n+\n+\t ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n+\t ;; They are extended instructions on MIPS16 targets.\n+\t (eq_attr \"move_type\" \"shift_shift\")\n+\t (if_then_else (match_test \"TARGET_MIPS16\")\n+\t \t       (const_int 4)\n+\t \t       (const_int 2))\n+\n+\t ;; Check for doubleword moves that are decomposed into two\n+\t ;; instructions.  The individual instructions are unextended\n+\t ;; MIPS16 ones.\n+\t (and (eq_attr \"move_type\" \"mtc,mfc,mtlo,mflo,move\")\n+\t      (eq_attr \"dword_mode\" \"yes\"))\n+\t (const_int 2)\n+\n+\t ;; Constants, loads and stores are handled by external routines.\n+\t (and (eq_attr \"move_type\" \"const,constN\")\n+\t      (eq_attr \"dword_mode\" \"yes\"))\n+\t (symbol_ref \"mips_split_const_insns (operands[1])\")\n+\t (eq_attr \"move_type\" \"const,constN\")\n+\t (symbol_ref \"mips_const_insns (operands[1])\")\n+\t (eq_attr \"move_type\" \"load,fpload\")\n+\t (symbol_ref \"mips_load_store_insns (operands[1], insn)\")\n+\t (eq_attr \"move_type\" \"store,fpstore\")\n+\t (symbol_ref \"mips_load_store_insns (operands[0], insn)\n+\t\t      + (TARGET_FIX_24K ? 1 : 0)\")\n+\n+\t ;; In the worst case, a call macro will take 8 instructions:\n+\t ;;\n+\t ;;\tlui $25,%call_hi(FOO)\n+\t ;;\taddu $25,$25,$28\n+\t ;;\tlw $25,%call_lo(FOO)($25)\n+\t ;;\tnop\n+\t ;;\tjalr $25\n+\t ;;\tnop\n+\t ;;\tlw $gp,X($sp)\n+\t ;;\tnop\n+\t (eq_attr \"jal_macro\" \"yes\")\n+\t (const_int 8)\n+\n+\t ;; Various VR4120 errata require a nop to be inserted after a macc\n+\t ;; instruction.  The assembler does this for us, so account for\n+\t ;; the worst-case length here.\n+\t (and (eq_attr \"type\" \"imadd\")\n+\t      (match_test \"TARGET_FIX_VR4120\"))\n+\t (const_int 2)\n+\n+\t ;; VR4120 errata MD(4): if there are consecutive dmult instructions,\n+\t ;; the result of the second one is missed.  The assembler should work\n+\t ;; around this by inserting a nop after the first dmult.\n+\t (and (eq_attr \"type\" \"imul,imul3\")\n+\t      (eq_attr \"mode\" \"DI\")\n+\t      (match_test \"TARGET_FIX_VR4120\"))\n+\t (const_int 2)\n+\n+\t (eq_attr \"type\" \"idiv,idiv3\")\n+\t (symbol_ref \"mips_idiv_insns ()\")\n+\n+\t (not (eq_attr \"sync_mem\" \"none\"))\n+\t (symbol_ref \"mips_sync_loop_insns (insn, operands)\")]\n+\t(const_int 1)))\n+\n+;; Length of instruction in bytes.  The default is derived from \"insn_count\",\n+;; but there are special cases for branches (which must be handled here)\n+;; and for compressed single instructions.\n+(define_attr \"length\" \"\"\n+   (cond [(and (eq_attr \"compression\" \"micromips,all\")\n \t       (eq_attr \"dword_mode\" \"no\")\n \t       (match_test \"TARGET_MICROMIPS\"))\n \t  (const_int 2)\n@@ -581,95 +660,8 @@\n \t\t (const_int 20)\n \t\t (match_test \"Pmode == SImode\")\n \t\t (const_int 16)\n-\t\t ] (const_int 24))\n-\n-\t  ;; \"Ghost\" instructions occupy no space.\n-\t  (eq_attr \"type\" \"ghost\")\n-\t  (const_int 0)\n-\n-\t  ;; GOT loads are extended MIPS16 instructions and 4-byte\n-\t  ;; microMIPS instructions.\n-\t  (eq_attr \"got\" \"load\")\n-\t  (const_int 4)\n-\n-\t  ;; A GOT load followed by an add of $gp.\n-\t  (eq_attr \"got\" \"xgot_high\")\n-\t  (const_int 8)\n-\n-\t  ;; In general, constant-pool loads are extended instructions.\n-\t  (eq_attr \"move_type\" \"loadpool\")\n-\t  (const_int 4)\n-\n-\t  ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n-\t  ;; They are extended instructions on MIPS16 targets.\n-\t  (eq_attr \"move_type\" \"shift_shift\")\n-\t  (const_int 8)\n-\n-\t  ;; Check for doubleword moves that are decomposed into two\n-\t  ;; instructions.  The individual instructions are unextended\n-\t  ;; MIPS16 ones or 2-byte microMIPS ones.\n-\t  (and (eq_attr \"move_type\" \"mtc,mfc,mtlo,mflo,move\")\n-\t       (eq_attr \"dword_mode\" \"yes\"))\n-\t  (if_then_else (match_test \"TARGET_COMPRESSION\")\n-\t  \t\t(const_int 4)\n-\t  \t\t(const_int 8))\n-\n-\t  ;; Doubleword CONST{,N} moves are split into two word\n-\t  ;; CONST{,N} moves.\n-\t  (and (eq_attr \"move_type\" \"const,constN\")\n-\t       (eq_attr \"dword_mode\" \"yes\"))\n-\t  (symbol_ref \"mips_split_const_insns (operands[1]) * BASE_INSN_LENGTH\")\n-\n-\t  ;; Otherwise, constants, loads and stores are handled by external\n-\t  ;; routines.\n-\t  (eq_attr \"move_type\" \"const,constN\")\n-\t  (symbol_ref \"mips_const_insns (operands[1]) * BASE_INSN_LENGTH\")\n-\t  (eq_attr \"move_type\" \"load,fpload\")\n-\t  (symbol_ref \"mips_load_store_insns (operands[1], insn)\n-\t  \t       * BASE_INSN_LENGTH\")\n-\t  (eq_attr \"move_type\" \"store,fpstore\")\n-\t  (symbol_ref \"mips_load_store_insns (operands[0], insn)\n-\t\t       * BASE_INSN_LENGTH\n-\t\t       + (TARGET_FIX_24K ? NOP_INSN_LENGTH : 0)\")\n-\n-\t  ;; In the worst case, a call macro will take 8 instructions:\n-\t  ;;\n-\t  ;;\t lui $25,%call_hi(FOO)\n-\t  ;;\t addu $25,$25,$28\n-\t  ;;     lw $25,%call_lo(FOO)($25)\n-\t  ;;\t nop\n-\t  ;;\t jalr $25\n-\t  ;;\t nop\n-\t  ;;\t lw $gp,X($sp)\n-\t  ;;\t nop\n-\t  (eq_attr \"jal_macro\" \"yes\")\n-\t  (const_int 32)\n-\n-\t  ;; Various VR4120 errata require a nop to be inserted after a macc\n-\t  ;; instruction.  The assembler does this for us, so account for\n-\t  ;; the worst-case length here.\n-\t  (and (eq_attr \"type\" \"imadd\")\n-\t       (match_test \"TARGET_FIX_VR4120\"))\n-\t  (const_int 8)\n-\n-\t  ;; VR4120 errata MD(4): if there are consecutive dmult instructions,\n-\t  ;; the result of the second one is missed.  The assembler should work\n-\t  ;; around this by inserting a nop after the first dmult.\n-\t  (and (eq_attr \"type\" \"imul,imul3\")\n-\t       (and (eq_attr \"mode\" \"DI\")\n-\t\t    (match_test \"TARGET_FIX_VR4120\")))\n-\t  (const_int 8)\n-\n-\t  (eq_attr \"type\" \"idiv,idiv3\")\n-\t  (symbol_ref \"mips_idiv_insns () * BASE_INSN_LENGTH\")\n-\n-\t  (not (eq_attr \"sync_mem\" \"none\"))\n-\t  (symbol_ref \"mips_sync_loop_insns (insn, operands)\n-\t  \t       * BASE_INSN_LENGTH\")\n-\n-\t  (match_test \"TARGET_MIPS16\")\n-\t  (const_int 2)\n-\t  ] (const_int 4)))\n+\t\t ] (const_int 24))]\n+\t (symbol_ref \"get_attr_insn_count (insn) * BASE_INSN_LENGTH\")))\n \n ;; Attribute describing the processor.\n (define_enum_attr \"cpu\" \"processor\"\n@@ -702,16 +694,11 @@\n \t (const_string \"hilo\")]\n \t(const_string \"none\")))\n \n-;; Is it a single instruction?\n-(define_attr \"single_insn\" \"no,yes\"\n-  (symbol_ref \"(get_attr_length (insn) == (TARGET_MIPS16 ? 2 : 4)\n-\t\t? SINGLE_INSN_YES : SINGLE_INSN_NO)\"))\n-\n ;; Can the instruction be put into a delay slot?\n (define_attr \"can_delay\" \"no,yes\"\n   (if_then_else (and (eq_attr \"type\" \"!branch,call,jump\")\n-\t\t     (and (eq_attr \"hazard\" \"none\")\n-\t\t\t  (eq_attr \"single_insn\" \"yes\")))\n+\t\t     (eq_attr \"hazard\" \"none\")\n+\t\t     (match_test \"get_attr_insn_count (insn) == 1\"))\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n@@ -1420,7 +1407,7 @@\n   \"mul.<fmt>\\t%0,%1,%2\\;nop\"\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n (define_insn \"mulv2sf3\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n@@ -1575,7 +1562,7 @@\n   \"<d>mult\\t%1,%2\\;mflo\\t%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n ;; On the VR4120 and VR4130, it is better to use \"mtlo $0; macc\" instead\n ;; of \"mult; mflo\".  They have the same latency, but the first form gives\n@@ -1635,7 +1622,7 @@\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"accum_in\"\t\"3\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8\")])\n+   (set_attr \"insn_count\" \"1,2\")])\n \n ;; The same idea applies here.  The middle alternative needs one less\n ;; clobber than the final alternative, so we add \"*?\" as a counterweight.\n@@ -1654,7 +1641,7 @@\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"accum_in\"\t\"3\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,4,8\")])\n+   (set_attr \"insn_count\" \"1,1,2\")])\n \n ;; Split *mul_acc_si if both the source and destination accumulator\n ;; values are GPRs.\n@@ -1735,7 +1722,7 @@\n   \"\"\n   [(set_attr \"type\"     \"imadd\")\n    (set_attr \"accum_in\"\t\"1\")\n-   (set_attr \"length\"\t\"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n ;; Patterns generated by the define_peephole2 below.\n \n@@ -1871,7 +1858,7 @@\n   [(set_attr \"type\"     \"imadd\")\n    (set_attr \"accum_in\"\t\"1\")\n    (set_attr \"mode\"     \"SI\")\n-   (set_attr \"length\"   \"4,8\")])\n+   (set_attr \"insn_count\" \"1,2\")])\n \n ;; Split *mul_sub_si if both the source and destination accumulator\n ;; values are GPRs.\n@@ -1952,7 +1939,7 @@\n   \"mult<u>\\t%1,%2\\;mflo\\t%L0\\;mfhi\\t%M0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"length\" \"12\")])\n+   (set_attr \"insn_count\" \"3\")])\n \n (define_insn_and_split \"<u>mulsidi3_64bit\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -1971,10 +1958,10 @@\n }\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n \t(if_then_else (match_test \"ISA_HAS_EXT_INS\")\n-\t\t      (const_int 16)\n-\t\t      (const_int 28)))])\n+\t\t      (const_int 4)\n+\t\t      (const_int 7)))])\n \n (define_expand \"<u>mulsidi3_64bit_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\")\n@@ -2125,7 +2112,7 @@\n }\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n (define_expand \"<su>mulsi3_highpart_split\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -2224,7 +2211,7 @@\n }\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n (define_expand \"<su>muldi3_highpart_split\"\n   [(set (match_operand:DI 0 \"register_operand\")\n@@ -2287,7 +2274,7 @@\n   \"dmult<u>\\t%1,%2\\;mflo\\t%L0\\;mfhi\\t%M0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"length\" \"12\")])\n+   (set_attr \"insn_count\" \"3\")])\n \n ;; The R4650 supports a 32-bit multiply/ 64-bit accumulate\n ;; instruction.  The HI/LO registers are used as a 64-bit accumulator.\n@@ -2538,10 +2525,10 @@\n }\n   [(set_attr \"type\" \"fdiv\")\n    (set_attr \"mode\" \"<UNITMODE>\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n         (if_then_else (match_test \"TARGET_FIX_SB1\")\n-                      (const_int 8)\n-                      (const_int 4)))])\n+                      (const_int 2)\n+                      (const_int 1)))])\n \n (define_insn \"*recip<mode>3\"\n   [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n@@ -2556,10 +2543,10 @@\n }\n   [(set_attr \"type\" \"frdiv\")\n    (set_attr \"mode\" \"<UNITMODE>\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n         (if_then_else (match_test \"TARGET_FIX_SB1\")\n-                      (const_int 8)\n-                      (const_int 4)))])\n+                      (const_int 2)\n+                      (const_int 1)))])\n \n ;; VR4120 errata MD(A1): signed division instructions do not work correctly\n ;; with negative operands.  We use special libgcc functions instead.\n@@ -2589,7 +2576,8 @@\n }\n  [(set_attr \"type\" \"idiv\")\n   (set_attr \"mode\" \"<MODE>\")\n-  (set_attr \"length\" \"8\")])\n+  ;; Worst case for MIPS16.\n+  (set_attr \"insn_count\" \"3\")])\n \n ;; See the comment above \"divmod<mode>4\" for the MIPS16 handling.\n (define_insn_and_split \"udivmod<mode>4\"\n@@ -2609,9 +2597,10 @@\n     emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, LO_REGNUM));\n   DONE;\n }\n- [(set_attr \"type\" \"idiv\")\n-  (set_attr \"mode\" \"<MODE>\")\n-  (set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   ;; Worst case for MIPS16.\n+   (set_attr \"insn_count\" \"3\")])\n \n (define_expand \"<u>divmod<mode>4_split\"\n   [(set (match_operand:GPR 0 \"register_operand\")\n@@ -2671,10 +2660,10 @@\n }\n   [(set_attr \"type\" \"fsqrt\")\n    (set_attr \"mode\" \"<UNITMODE>\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n         (if_then_else (match_test \"TARGET_FIX_SB1\")\n-                      (const_int 8)\n-                      (const_int 4)))])\n+                      (const_int 2)\n+                      (const_int 1)))])\n \n (define_insn \"*rsqrt<mode>a\"\n   [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n@@ -2689,10 +2678,10 @@\n }\n   [(set_attr \"type\" \"frsqrt\")\n    (set_attr \"mode\" \"<UNITMODE>\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n         (if_then_else (match_test \"TARGET_FIX_SB1\")\n-                      (const_int 8)\n-                      (const_int 4)))])\n+                      (const_int 2)\n+                      (const_int 1)))])\n \n (define_insn \"*rsqrt<mode>b\"\n   [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n@@ -2707,10 +2696,10 @@\n }\n   [(set_attr \"type\" \"frsqrt\")\n    (set_attr \"mode\" \"<UNITMODE>\")\n-   (set (attr \"length\")\n+   (set (attr \"insn_count\")\n         (if_then_else (match_test \"TARGET_FIX_SB1\")\n-                      (const_int 8)\n-                      (const_int 4)))])\n+                      (const_int 2)\n+                      (const_int 1)))])\n \f\n ;;\n ;;  ....................\n@@ -3503,7 +3492,7 @@\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"cnv_mode\"\t\"D2I\")\n-   (set_attr \"length\"\t\"36\")])\n+   (set_attr \"insn_count\" \"9\")])\n \n (define_expand \"fix_truncsfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -3540,7 +3529,7 @@\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"cnv_mode\"\t\"S2I\")\n-   (set_attr \"length\"\t\"36\")])\n+   (set_attr \"insn_count\" \"9\")])\n \n \n (define_insn \"fix_truncdfdi2\"\n@@ -4018,7 +4007,7 @@\n   operands[2] = mips_unspec_address (operands[1], SYMBOL_64_HIGH);\n   operands[3] = mips_unspec_address (operands[1], SYMBOL_64_MID);\n }\n-  [(set_attr \"length\" \"20\")])\n+  [(set_attr \"insn_count\" \"5\")])\n \n ;; Use a scratch register to reduce the latency of the above pattern\n ;; on superscalar machines.  The optimized sequence is:\n@@ -4073,7 +4062,7 @@\n   operands[3] = mips_unspec_address (operands[1], SYMBOL_64_HIGH);\n   operands[4] = mips_unspec_address (operands[1], SYMBOL_64_LOW);\n }\n-  [(set_attr \"length\" \"24\")])\n+  [(set_attr \"insn_count\" \"6\")])\n \n ;; Split HIGHs into:\n ;;\n@@ -5083,7 +5072,7 @@\n     return \".cprestore\\t%1\";\n }\n   [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"4,12\")])\n+   (set_attr \"insn_count\" \"1,3\")])\n \n (define_insn \"use_cprestore_<mode>\"\n   [(set (reg:P CPRESTORE_SLOT_REGNUM)\n@@ -5144,7 +5133,7 @@\n          \"\\tjr.hb\\t$31\\n\"\n          \"\\tnop%>%)\";\n }\n-  [(set_attr \"length\" \"20\")])\n+  [(set_attr \"insn_count\" \"5\")])\n \n ;; Cache operations for R4000-style caches.\n (define_insn \"mips_cache\"\n@@ -5337,8 +5326,7 @@\n ;; not have and immediate).  We recognize a shift of a load in order\n ;; to make it simple enough for combine to understand.\n ;;\n-;; The length here is the worst case: the length of the split version\n-;; will be more accurate.\n+;; The instruction count here is the worst case.\n (define_insn_and_split \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n@@ -5351,7 +5339,8 @@\n   \"\"\n   [(set_attr \"type\"\t\"load\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"8\")])\n+   (set (attr \"insn_count\")\n+\t(symbol_ref \"mips_load_store_insns (operands[1], insn) + 2\"))])\n \n (define_insn \"rotr<mode>3\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5990,7 +5979,7 @@\n   \n   return \"j\\t%4\";\n }\n-  [(set_attr \"length\" \"32\")])\n+  [(set_attr \"insn_count\" \"16\")])\n \n ;; For TARGET_USE_GOT, we save the gp in the jmp_buf as well.\n ;; While it is possible to either pull it off the stack (in the\n@@ -6881,19 +6870,17 @@\n    (set (match_dup 0) (reg:P TLS_GET_TP_REGNUM))]\n   \"\"\n   [(set_attr \"type\" \"unknown\")\n-   ; Since rdhwr always generates a trap for now, putting it in a delay\n-   ; slot would make the kernel's emulation of it much slower.\n-   (set_attr \"can_delay\" \"no\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"insn_count\" \"2\")])\n \n (define_insn \"*tls_get_tp_<mode>_split\"\n   [(set (reg:P TLS_GET_TP_REGNUM)\n \t(unspec:P [(const_int 0)] UNSPEC_TLS_GET_TP))]\n   \"HAVE_AS_TLS && !TARGET_MIPS16\"\n   \".set\\tpush\\;.set\\tmips32r2\\t\\;rdhwr\\t$3,$29\\;.set\\tpop\"\n   [(set_attr \"type\" \"unknown\")\n-   ; See tls_get_tp_<mode>\n+   ; Since rdhwr always generates a trap for now, putting it in a delay\n+   ; slot would make the kernel's emulation of it much slower.\n    (set_attr \"can_delay\" \"no\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -6925,7 +6912,7 @@\n    (set (match_dup 0) (reg:P TLS_GET_TP_REGNUM))]\n   \"\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"8\")\n+   (set_attr \"insn_count\" \"4\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*tls_get_tp_mips16_call_<mode>\"\n@@ -6937,7 +6924,7 @@\n   \"HAVE_AS_TLS && TARGET_MIPS16\"\n   { return MIPS_CALL (\"jal\", operands, 0, -1); }\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"6\")\n+   (set_attr \"insn_count\" \"3\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; Named pattern for expanding thread pointer reference."}, {"sha": "02520dd8958d3515c3f85f8015a0f61539779cf1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -1,3 +1,8 @@\n+2013-06-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/umips-branch-1.c, gcc.target/mips/umips-branch-2.c:\n+\tNew tests.\n+\n 2013-06-12  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/57361"}, {"sha": "441abcaf3ad120e04baecbdc3f227368d4e897cb", "filename": "gcc/testsuite/gcc.target/mips/umips-branch-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-1.c?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"(-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+int MICROMIPS\n+foo (void)\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tjr?\\t\\\\\\$31\\n\\tmove\\t\\\\\\$2,\\\\\\$0\" } } */"}, {"sha": "156476311809a2b4527f93e604320947798fe235", "filename": "gcc/testsuite/gcc.target/mips/umips-branch-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b6cc1f06453523da058124cd1d63dfe05e350/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-branch-2.c?ref=710b6cc1f06453523da058124cd1d63dfe05e350", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"(-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+int MICROMIPS\n+foo (int *x)\n+{\n+  return x[5000];\n+}\n+\n+/* { dg-final { scan-assembler \"\\tjr?\\t\\\\\\$31\\n\\tlw\\t\\\\\\$2,20000\\\\(\\\\\\$4\\\\)\" } } */"}]}