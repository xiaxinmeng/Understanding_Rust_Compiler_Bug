{"sha": "7948ae37a7584683ef2169153be4d72bc883f205", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0OGFlMzdhNzU4NDY4M2VmMjE2OTE1M2JlNGQ3MmJjODgzZjIwNQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-09-25T09:33:17Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-09-25T09:33:17Z"}, "message": "ada-tree.h (TYPE_REPRESENTATIVE_ARRAY): New language specific node.\n\n        ada/\n        * gcc-interface/ada-tree.h (TYPE_REPRESENTATIVE_ARRAY): New language\n        specific node.  Representative array type for VECTOR_TYPE entities.\n        * gcc-interface/utils.c (handle_vector_type_attribute): New handler.\n        Turn an ARRAY_TYPE entity into a VECTOR_TYPE.\n        (gnat_types_compatible_p): Handle VECTOR_TYPEs.\n        (convert): Likewise.  Arrange to produce VECTOR_CST out of constant\n        array aggregates for VECTOR_TYPE entities.\n        (unchecked_convert): Likewise.\n        (maybe_vector_array): New function. If EXP has VECTOR_TYPE, return EXP\n        converted to the associated TYPE_REPRESENTATIVE_ARRAY.\n        (handle_pure_attribute, handle_sentinel_attribute,\n        handle_noreturn_attribute, handle_malloc_attribute,\n        handle_vector_size_attribute): Replace uses of qE format by qs.\n        Remove GCC_DIAG_STYLE definition.\n        * gcc-interface/trans.c (gnat_to_gnu) <N_Indexed_Component>: Convert\n        vector input to representative array type on entry.\n        <N_Op_Eq, etc>: Likewise.\n        * gcc-interface/gigi.h (maybe_vector_array): Declare.\n        (VECTOR_TYPE_P): New predicate.\n        * gcc-interface/misc.c (gnat_print_type): Handle VECTOR_TYPE.\n\n        testsuite/\n        * gnat.dg/sse_nolib.adb: New testcase.\n\nFrom-SVN: r152165", "tree": {"sha": "81ee28b57d956878c8da819d095fb9043c7fcc3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81ee28b57d956878c8da819d095fb9043c7fcc3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7948ae37a7584683ef2169153be4d72bc883f205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7948ae37a7584683ef2169153be4d72bc883f205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7948ae37a7584683ef2169153be4d72bc883f205", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7948ae37a7584683ef2169153be4d72bc883f205/comments", "author": null, "committer": null, "parents": [{"sha": "6e1ee24b2fcd554744a135d2b314fde2f48d674f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1ee24b2fcd554744a135d2b314fde2f48d674f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1ee24b2fcd554744a135d2b314fde2f48d674f"}], "stats": {"total": 356, "additions": 333, "deletions": 23}, "files": [{"sha": "09256663fc72d9bf5974b03872f59891263bb682", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -1,3 +1,27 @@\n+2009-09-22  Olivier Hainquqe  <hainque@adacore.com>\n+            Eric Botcazou <botcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_REPRESENTATIVE_ARRAY): New language\n+\tspecific node.\tRepresentative array type for VECTOR_TYPE entities.\n+\t* gcc-interface/utils.c (handle_vector_type_attribute): New handler.\n+\tTurn an ARRAY_TYPE entity into a VECTOR_TYPE.\t\n+\t(gnat_types_compatible_p): Handle VECTOR_TYPEs.\n+\t(convert): Likewise.  Arrange to produce VECTOR_CST out of constant\n+\tarray aggregates for VECTOR_TYPE entities.\n+\t(unchecked_convert): Likewise.\n+\t(maybe_vector_array): New function. If EXP has VECTOR_TYPE, return EXP\n+\tconverted to the associated TYPE_REPRESENTATIVE_ARRAY.\n+\t(handle_pure_attribute, handle_sentinel_attribute,\n+\thandle_noreturn_attribute, handle_malloc_attribute,\n+\thandle_vector_size_attribute): Replace uses of qE format by qs.\n+\tRemove GCC_DIAG_STYLE definition.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Indexed_Component>: Convert\n+\tvector input to representative array type on entry.\n+\t<N_Op_Eq, etc>: Likewise.\n+\t* gcc-interface/gigi.h (maybe_vector_array): Declare.\n+\t(VECTOR_TYPE_P): New predicate.\n+\t* gcc-interface/misc.c (gnat_print_type): Handle VECTOR_TYPE.\n+\n 2009-09-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada.h: Fix outdated comment."}, {"sha": "94b18bde6b52260faf777216319aff33315e991b", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -195,6 +195,10 @@ do {\t\t\t\t\t\t\t    \\\n    refer to the routine gnat_to_gnu_entity.  */\n #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n+/* For a VECTOR_TYPE, this is the representative array type.  */\n+#define TYPE_REPRESENTATIVE_ARRAY(NODE) \\\n+  TYPE_LANG_SLOT_1 (VECTOR_TYPE_CHECK (NODE))\n+\n /* For numerical types, this holds various RM-defined values.  */\n #define TYPE_RM_VALUES(NODE) TYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n "}, {"sha": "ea1a65d485be7958162fdee9cb7f8732a699b62d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -750,6 +750,10 @@ extern tree remove_conversions (tree exp, bool true_address);\n    likewise return an expression pointing to the underlying array.  */\n extern tree maybe_unconstrained_array (tree exp);\n \n+/* If EXP's type is a VECTOR_TYPE, return EXP converted to the associated\n+   TYPE_REPRESENTATIVE_ARRAY.  */\n+extern tree maybe_vector_array (tree exp);\n+\n /* Return an expression that does an unchecked conversion of EXPR to TYPE.\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n@@ -951,3 +955,6 @@ extern Nat get_target_double_scalar_alignment (void);\n #ifndef TARGET_MALLOC64\n #define TARGET_MALLOC64 0\n #endif\n+\n+/* Convenient shortcuts.  */\n+#define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)"}, {"sha": "67823789ab3084940c2325f5c637488065618a22", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -521,6 +521,11 @@ gnat_print_type (FILE *file, tree node, int indent)\n       print_node (file,\"actual bounds\", TYPE_ACTUAL_BOUNDS (node), indent + 4);\n       break;\n \n+    case VECTOR_TYPE:\n+      print_node (file,\"representative array\",\n+\t\t  TYPE_REPRESENTATIVE_ARRAY (node), indent + 4);\n+      break;\n+\n     case RECORD_TYPE:\n       if (TYPE_IS_FAT_POINTER_P (node) || TYPE_CONTAINS_TEMPLATE_P (node))\n \tprint_node (file, \"unconstrained array\","}, {"sha": "7037a6ef990b841c89fbfa7b2a0ecb61d7a338a0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -3832,6 +3832,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \tNode_Id *gnat_expr_array;\n \n \tgnu_array_object = maybe_implicit_deref (gnu_array_object);\n+\n+\t/* Convert vector inputs to their representative array type, to fit\n+\t   what the code below expects.  */\n+\tgnu_array_object = maybe_vector_array (gnu_array_object);\n+\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n \t/* If we got a padded type, remove it too.  */\n@@ -4077,6 +4082,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    && TYPE_CONTAINS_TEMPLATE_P (gnu_result_type))\n \t  gnu_aggr_type\n \t    = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_result_type)));\n+\telse if (TREE_CODE (gnu_result_type) == VECTOR_TYPE)\n+\t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n \n \tif (Null_Record_Present (gnat_node))\n \t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL_TREE);\n@@ -4272,6 +4279,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_rhs = gnat_to_gnu (Right_Opnd (gnat_node));\n \tgnu_type = gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n+\t/* Pending generic support for efficient vector logical operations in\n+\t   GCC, convert vectors to their representative array type view and\n+\t   fallthrough.  */\n+\tgnu_lhs = maybe_vector_array (gnu_lhs);\n+\tgnu_rhs = maybe_vector_array (gnu_rhs);\n+\n \t/* If this is a comparison operator, convert any references to\n \t   an unconstrained array value into a reference to the\n \t   actual array.  */"}, {"sha": "abc0b7b557ce085edc33c014b39686fa0bc0411c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 227, "deletions": 23, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -23,10 +23,6 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/* We have attribute handlers using C specific format specifiers in warning\n-   messages.  Make sure they are properly recognized.  */\n-#define GCC_DIAG_STYLE __gcc_cdiag__\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -101,6 +97,7 @@ static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_vector_size_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_vector_type_attribute (tree *, tree, tree, int, bool *);\n \n /* Fake handler for attributes we don't properly support, typically because\n    they'd require dragging a lot of the common-c front-end circuitry.  */\n@@ -122,6 +119,7 @@ const struct attribute_spec gnat_internal_attribute_table[] =\n   { \"type generic\", 0, 0,  false, true, true, handle_type_generic_attribute },\n \n   { \"vector_size\",  1, 1,  false, true, false,  handle_vector_size_attribute },\n+  { \"vector_type\",  0, 0,  false, true, false,  handle_vector_type_attribute },\n   { \"may_alias\",    0, 0, false, true, false, NULL },\n \n   /* ??? format and format_arg are heavy and not supported, which actually\n@@ -2269,6 +2267,14 @@ gnat_types_compatible_p (tree t1, tree t2)\n   if ((code = TREE_CODE (t1)) != TREE_CODE (t2))\n     return 0;\n \n+  /* Vector types are also compatible if they have the same number of subparts\n+     and the same form of (scalar) element type.  */\n+  if (code == VECTOR_TYPE\n+      && TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n+      && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n+      && TYPE_PRECISION (TREE_TYPE (t1)) == TYPE_PRECISION (TREE_TYPE (t2)))\n+    return 1;\n+\n   /* Array types are also compatible if they are constrained and have\n      the same component type and the same domain.  */\n   if (code == ARRAY_TYPE\n@@ -3981,6 +3987,16 @@ convert (tree type, tree expr)\n \t}\n       break;\n \n+    case VECTOR_CST:\n+      /* If we are converting a VECTOR_CST to a mere variant type, just make\n+\t a new one in the proper type.  */\n+      if (code == ecode && gnat_types_compatible_p (type, etype))\n+\t{\n+\t  expr = copy_node (expr);\n+\t  TREE_TYPE (expr) = type;\n+\t  return expr;\n+\t}\n+\n     case CONSTRUCTOR:\n       /* If we are converting a CONSTRUCTOR to a mere variant type, just make\n \t a new one in the proper type.  */\n@@ -4043,6 +4059,52 @@ convert (tree type, tree expr)\n \t      return expr;\n \t    }\n \t}\n+\n+      /* Likewise for a conversion between array type and vector type with a\n+         compatible representative array.  */\n+      else if (code == VECTOR_TYPE\n+\t       && ecode == ARRAY_TYPE\n+\t       && gnat_types_compatible_p (TYPE_REPRESENTATIVE_ARRAY (type),\n+\t\t\t\t\t   etype))\n+\t{\n+\t  VEC(constructor_elt,gc) *e = CONSTRUCTOR_ELTS (expr);\n+\t  unsigned HOST_WIDE_INT len = VEC_length (constructor_elt, e);\n+\t  VEC(constructor_elt,gc) *v;\n+\t  unsigned HOST_WIDE_INT ix;\n+\t  tree value;\n+\n+\t  /* Build a VECTOR_CST from a *constant* array constructor.  */\n+\t  if (TREE_CONSTANT (expr))\n+\t    {\n+\t      bool constant_p = true;\n+\n+\t      /* Iterate through elements and check if all constructor\n+\t\t elements are *_CSTs.  */\n+\t      FOR_EACH_CONSTRUCTOR_VALUE (e, ix, value)\n+\t\tif (!CONSTANT_CLASS_P (value))\n+\t\t  {\n+\t\t    constant_p = false;\n+\t\t    break;\n+\t\t  }\n+\n+\t      if (constant_p)\n+\t\treturn build_vector_from_ctor (type,\n+\t\t\t\t\t       CONSTRUCTOR_ELTS (expr));\n+\t    }\n+\n+\t  /* Otherwise, build a regular vector constructor.  */\n+\t  v = VEC_alloc (constructor_elt, gc, len);\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (e, ix, value)\n+\t    {\n+\t      constructor_elt *elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t      elt->index = NULL_TREE;\n+\t      elt->value = value;\n+\t    }\n+\t  expr = copy_node (expr);\n+\t  TREE_TYPE (expr) = type;\n+\t  CONSTRUCTOR_ELTS (expr) = v;\n+\t  return expr;\n+\t}\n       break;\n \n     case UNCONSTRAINED_ARRAY_REF:\n@@ -4071,10 +4133,11 @@ convert (tree type, tree expr)\n \tif (type == TREE_TYPE (op0))\n \t  return op0;\n \n-\t/* Otherwise, if we're converting between two aggregate types, we\n-\t   might be allowed to substitute the VIEW_CONVERT_EXPR target type\n-\t   in place or to just convert the inner expression.  */\n-\tif (AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype))\n+\t/* Otherwise, if we're converting between two aggregate or vector\n+\t   types, we might be allowed to substitute the VIEW_CONVERT_EXPR\n+\t   target type in place or to just convert the inner expression.  */\n+\tif ((AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype))\n+\t    || (VECTOR_TYPE_P (type) && VECTOR_TYPE_P (etype)))\n \t  {\n \t    /* If we are converting between mere variants, we can just\n \t       substitute the VIEW_CONVERT_EXPR in place.  */\n@@ -4117,11 +4180,16 @@ convert (tree type, tree expr)\n   if (TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n-  /* If we are converting between two aggregate types that are mere\n-     variants, just make a VIEW_CONVERT_EXPR.  */\n-  else if (code == ecode\n-\t   && AGGREGATE_TYPE_P (type)\n-\t   && gnat_types_compatible_p (type, etype))\n+  /* If we are converting between two aggregate or vector types that are mere\n+     variants, just make a VIEW_CONVERT_EXPR.  Likewise when we are converting\n+     to a vector type from its representative array type.  */\n+  else if ((code == ecode\n+\t    && (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n+\t    && gnat_types_compatible_p (type, etype))\n+\t   || (code == VECTOR_TYPE\n+\t       && ecode == ARRAY_TYPE\n+\t       && gnat_types_compatible_p (TYPE_REPRESENTATIVE_ARRAY (type),\n+\t\t\t\t\t   etype)))\n     return build1 (VIEW_CONVERT_EXPR, type, expr);\n \n   /* In all other cases of related types, make a NOP_EXPR.  */\n@@ -4237,6 +4305,15 @@ convert (tree type, tree expr)\n       return unchecked_convert (type, expr, false);\n \n     case UNCONSTRAINED_ARRAY_TYPE:\n+      /* If the input is a VECTOR_TYPE, convert to the representative\n+\t array type first.  */\n+      if (ecode == VECTOR_TYPE)\n+\t{\n+\t  expr = convert (TYPE_REPRESENTATIVE_ARRAY (etype), expr);\n+\t  etype = TREE_TYPE (expr);\n+\t  ecode = TREE_CODE (etype);\n+\t}\n+\n       /* If EXPR is a constrained array, take its address, convert it to a\n \t fat pointer, and then dereference it.  Likewise if EXPR is a\n \t record containing both a template and a constrained array.\n@@ -4366,6 +4443,20 @@ maybe_unconstrained_array (tree exp)\n \n   return exp;\n }\n+\n+/* If EXP's type is a VECTOR_TYPE, return EXP converted to the associated\n+   TYPE_REPRESENTATIVE_ARRAY.  */\n+\n+tree\n+maybe_vector_array (tree exp)\n+{\n+  tree etype = TREE_TYPE (exp);\n+\n+  if (VECTOR_TYPE_P (etype))\n+    exp = convert (TYPE_REPRESENTATIVE_ARRAY (etype), exp);\n+\n+  return exp;\n+}\n \f\n /* Return true if EXPR is an expression that can be folded as an operand\n    of a VIEW_CONVERT_EXPR.  See ada-tree.h for a complete rationale.  */\n@@ -4501,15 +4592,24 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       expr = unchecked_convert (type, expr, notrunc_p);\n     }\n \n-  /* We have a special case when we are converting between two\n-     unconstrained array types.  In that case, take the address,\n-     convert the fat pointer types, and dereference.  */\n+  /* We have a special case when we are converting between two unconstrained\n+     array types.  In that case, take the address, convert the fat pointer\n+     types, and dereference.  */\n   else if (TREE_CODE (etype) == UNCONSTRAINED_ARRAY_TYPE\n \t   && TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n     expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t   build1 (VIEW_CONVERT_EXPR, TREE_TYPE (type),\n \t\t\t\t   build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\t   expr)));\n+\n+  /* Another special case is when we are converting to a vector type from its\n+     representative array type; this a regular conversion.  */\n+  else if (TREE_CODE (type) == VECTOR_TYPE\n+\t   && TREE_CODE (etype) == ARRAY_TYPE\n+\t   && gnat_types_compatible_p (TYPE_REPRESENTATIVE_ARRAY (type),\n+\t\t\t\t       etype))\n+    expr = convert (type, expr);\n+\n   else\n     {\n       expr = maybe_unconstrained_array (expr);\n@@ -5060,7 +5160,8 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* ??? TODO: Support types.  */\n   else\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5175,7 +5276,8 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n   if (!params)\n     {\n       warning (OPT_Wattributes,\n-\t       \"%qE attribute requires prototypes with named arguments\", name);\n+\t       \"%qs attribute requires prototypes with named arguments\",\n+\t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n   else\n@@ -5186,7 +5288,8 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n       if (VOID_TYPE_P (TREE_VALUE (params)))\n         {\n \t  warning (OPT_Wattributes,\n-\t\t   \"%qE attribute only applies to variadic functions\", name);\n+\t\t   \"%qs attribute only applies to variadic functions\",\n+\t\t   IDENTIFIER_POINTER (name));\n \t  *no_add_attrs = true;\n \t}\n     }\n@@ -5233,7 +5336,8 @@ handle_noreturn_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t\t     TYPE_READONLY (TREE_TYPE (type)), 1));\n   else\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5252,7 +5356,8 @@ handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n     DECL_IS_MALLOC (*node) = 1;\n   else\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5311,7 +5416,8 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \n   if (!host_integerp (size, 1))\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n@@ -5345,7 +5451,8 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n       || !host_integerp (TYPE_SIZE_UNIT (type), 1)\n       || TREE_CODE (type) == BOOLEAN_TYPE)\n     {\n-      error (\"invalid vector type for attribute %qE\", name);\n+      error (\"invalid vector type for attribute %qs\",\n+\t     IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n@@ -5377,6 +5484,103 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"vector_type\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t      int ARG_UNUSED (flags),\n+\t\t\t      bool *no_add_attrs)\n+{\n+  /* Vector representative type and size.  */\n+  tree rep_type = *node;\n+  tree rep_size = TYPE_SIZE_UNIT (rep_type);\n+  tree rep_name;\n+\n+  /* Vector size in bytes and number of units.  */\n+  unsigned HOST_WIDE_INT vec_bytes, vec_units;\n+\n+  /* Vector element type and mode.  */\n+  tree elem_type;\n+  enum machine_mode elem_mode;\n+\n+  *no_add_attrs = true;\n+\n+  /* Get the representative array type, possibly nested within a\n+     padding record e.g. for alignment purposes.  */\n+\n+  if (TREE_CODE (rep_type) == RECORD_TYPE && TYPE_IS_PADDING_P (rep_type))\n+    rep_type = TREE_TYPE (TYPE_FIELDS (rep_type));\n+\n+  if (TREE_CODE (rep_type) != ARRAY_TYPE)\n+    {\n+      error (\"attribute %qs applies to array types only\",\n+\t     IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Silently punt on variable sizes.  We can't make vector types for them,\n+     need to ignore them on front-end generated subtypes of unconstrained\n+     bases, and this attribute is for binding implementors, not end-users, so\n+     we should never get there from legitimate explicit uses.  */\n+\n+  if (!host_integerp (rep_size, 1))\n+    return NULL_TREE;\n+\n+  /* Get the element type/mode and check this is something we know\n+     how to make vectors of.  */\n+\n+  elem_type = TREE_TYPE (rep_type);\n+  elem_mode = TYPE_MODE (elem_type);\n+\n+  if ((!INTEGRAL_TYPE_P (elem_type)\n+       && !SCALAR_FLOAT_TYPE_P (elem_type)\n+       && !FIXED_POINT_TYPE_P (elem_type))\n+      || (!SCALAR_FLOAT_MODE_P (elem_mode)\n+\t  && GET_MODE_CLASS (elem_mode) != MODE_INT\n+\t  && !ALL_SCALAR_FIXED_POINT_MODE_P (elem_mode))\n+      || !host_integerp (TYPE_SIZE_UNIT (elem_type), 1))\n+    {\n+      error (\"invalid element type for attribute %qs\",\n+\t     IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Sanity check the vector size and element type consistency.  */\n+\n+  vec_bytes = tree_low_cst (rep_size, 1);\n+\n+  if (vec_bytes % tree_low_cst (TYPE_SIZE_UNIT (elem_type), 1))\n+    {\n+      error (\"vector size not an integral multiple of component size\");\n+      return NULL;\n+    }\n+\n+  if (vec_bytes == 0)\n+    {\n+      error (\"zero vector size\");\n+      return NULL;\n+    }\n+\n+  vec_units = vec_bytes / tree_low_cst (TYPE_SIZE_UNIT (elem_type), 1);\n+  if (vec_units & (vec_units - 1))\n+    {\n+      error (\"number of components of the vector not a power of two\");\n+      return NULL_TREE;\n+    }\n+\n+  /* Build the vector type and replace.  */\n+\n+  *node = build_vector_type (elem_type, vec_units);\n+  rep_name = TYPE_NAME (rep_type);\n+  if (TREE_CODE (rep_name) == TYPE_DECL)\n+    rep_name = DECL_NAME (rep_name);\n+  TYPE_NAME (*node) = rep_name;\n+  TYPE_REPRESENTATIVE_ARRAY (*node) = rep_type;\n+\n+  return NULL_TREE;\n+}\n+\n /* ----------------------------------------------------------------------- *\n  *                              BUILTIN FUNCTIONS                          *\n  * ----------------------------------------------------------------------- */"}, {"sha": "9fcd65db5aaea3b319f3d7d292ce9d06de7a1e88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -1,3 +1,7 @@\n+2009-09-25  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gnat.dg/sse_nolib.adb: New testcase.\n+\n 2009-09-25  Revital Eres  <ERES@il.ibm.com>\n \n \t* gcc.target/powerpc/vsx-vectorize-8.c: New test."}, {"sha": "b024a216e94191af27c6953138972bac97d08eb0", "filename": "gcc/testsuite/gnat.dg/sse_nolib.adb", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Ftestsuite%2Fgnat.dg%2Fsse_nolib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7948ae37a7584683ef2169153be4d72bc883f205/gcc%2Ftestsuite%2Fgnat.dg%2Fsse_nolib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsse_nolib.adb?ref=7948ae37a7584683ef2169153be4d72bc883f205", "patch": "@@ -0,0 +1,49 @@\n+--  { dg-do run { target i?86-*-* x86_64-*-* } }\n+--  { dg-options \"-O1 -msse\" }\n+\n+with Ada.Unchecked_Conversion;\n+\n+procedure SSE_Nolib is\n+\n+   --  Base vector type definitions\n+\n+   package SSE_Types is\n+      VECTOR_ALIGN : constant := 16;\n+      VECTOR_BYTES : constant := 16;\n+            \n+      type m128 is private;\n+   private\n+      type m128 is array (1 .. 4) of Float;\n+      for m128'Alignment use VECTOR_ALIGN;\n+      pragma Machine_Attribute (m128, \"vector_type\");\n+      pragma Machine_Attribute (m128, \"may_alias\");\n+   end SSE_Types;\n+\n+   use SSE_Types;\n+\n+   --  Core operations\n+\n+   function mm_add_ss (A, B : m128) return m128;\n+   pragma Import (Intrinsic, mm_add_ss, \"__builtin_ia32_addss\");\n+\n+   --  User views / conversions or overlays\n+\n+   type Vf32_View is array (1 .. 4) of Float;\n+   for Vf32_View'Alignment use VECTOR_ALIGN;\n+\n+   function To_m128 is new Ada.Unchecked_Conversion (Vf32_View, m128);\n+   function To_m128 is new Ada.Unchecked_Conversion (m128, Vf32_View);\n+\n+   X, Y, Z : M128;\n+\n+   Vz : Vf32_View;\n+   for Vz'Address use Z'Address;\n+begin\n+   X := To_m128 ((1.0, 1.0, 2.0, 2.0));\n+   Y := To_m128 ((2.0, 2.0, 1.0, 1.0));\n+   Z := mm_add_ss (X, Y);\n+\n+   if Vz /= (3.0, 1.0, 2.0, 2.0) then\n+      raise Program_Error;\n+   end if;\n+end SSE_Nolib;"}]}