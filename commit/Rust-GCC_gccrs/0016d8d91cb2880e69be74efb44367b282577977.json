{"sha": "0016d8d91cb2880e69be74efb44367b282577977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAxNmQ4ZDkxY2IyODgwZTY5YmU3NGVmYjQ0MzY3YjI4MjU3Nzk3Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-08-02T10:59:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-08-02T10:59:35Z"}, "message": "[gen/AArch64] Generate helpers for substituting iterator values into pattern names\n\nGiven a pattern like:\n\n  (define_insn \"aarch64_frecpe<mode>\" ...)\n\nthe SVE ACLE implementation wants to generate the pattern for a\nparticular (non-constant) mode.  This patch automatically generates\nhelpers to do that, specifically:\n\n  // Return CODE_FOR_nothing on failure.\n  insn_code maybe_code_for_aarch64_frecpe (machine_mode);\n\n  // Assert that the code exists.\n  insn_code code_for_aarch64_frecpe (machine_mode);\n\n  // Return NULL_RTX on failure.\n  rtx maybe_gen_aarch64_frecpe (machine_mode, rtx, rtx);\n\n  // Assert that generation succeeds.\n  rtx gen_aarch64_frecpe (machine_mode, rtx, rtx);\n\nMany patterns don't have sensible names when all <...>s are removed.\nE.g. \"<optab><mode>2\" would give a base name \"2\".  The new functions\ntherefore require explicit opt-in, which should also help to reduce\ncode bloat.\n\nThe (arbitrary) opt-in syntax I went for was to prefix the pattern\nname with '@', similarly to the existing '*' marker.\n\nThe patch also makes config/aarch64 use the new routines in cases where\nthey obviously apply.  This was mostly straight-forward, but it seemed\nodd that we defined:\n\n   aarch64_reload_movcp<...><P:mode>\n\nbut then only used it with DImode, never SImode.  If we should be\nusing Pmode instead of DImode, then that's a simple change,\nbut should probably be a separate patch.\n\n2018-08-02  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/md.texi: Expand the documentation of instruction names\n\tto mention port-local uses.  Document '@' in pattern names.\n\t* read-md.h (overloaded_instance, overloaded_name): New structs.\n\t(mapping): Declare.\n\t(md_reader::handle_overloaded_name): New member function.\n\t(md_reader::get_overloads): Likewise.\n\t(md_reader::m_first_overload): New member variable.\n\t(md_reader::m_next_overload_ptr): Likewise.\n\t(md_reader::m_overloads_htab): Likewise.\n\t* read-md.c (md_reader::md_reader): Initialize m_first_overload,\n\tm_next_overload_ptr and m_overloads_htab.\n\t* read-rtl.c (iterator_group): Add \"type\" and \"get_c_token\" fields.\n\t(get_mode_token, get_code_token, get_int_token): New functions.\n\t(map_attr_string): Add an optional argument that passes back\n\tthe associated iterator.\n\t(overloaded_name_hash, overloaded_name_eq_p, named_rtx_p):\n\t(md_reader::handle_overloaded_name, add_overload_instance): New\n\tfunctions.\n\t(apply_iterators): Handle '@' names.  Report an error if '@'\n\tis used without iterators.\n\t(initialize_iterators): Initialize the new iterator_group fields.\n\t* genopinit.c (handle_overloaded_code_for)\n\t(handle_overloaded_gen): New functions.\n\t(main): Use them to print declarations of maybe_code_for_* and\n\tmaybe_gen_* functions, and inline definitions of code_for_* and gen_*.\n\t* genemit.c (print_overload_arguments, print_overload_test)\n\t(handle_overloaded_code_for, handle_overloaded_gen): New functions.\n\t(main): Use it to print definitions of maybe_code_for_* and\n\tmaybe_gen_* functions.\n\t* config/aarch64/aarch64.c (aarch64_split_128bit_move): Use\n\tgen_aarch64_mov{low,high}_di and gen_aarch64_movdi_{low,high}\n\tinstead of explicit mode checks.\n\t(aarch64_split_simd_combine): Likewise gen_aarch64_simd_combine.\n\t(aarch64_split_simd_move): Likewise gen_aarch64_split_simd_mov.\n\t(aarch64_emit_load_exclusive): Likewise gen_aarch64_load_exclusive.\n\t(aarch64_emit_store_exclusive): Likewise gen_aarch64_store_exclusive.\n\t(aarch64_expand_compare_and_swap): Likewise\n\tgen_aarch64_compare_and_swap and gen_aarch64_compare_and_swap_lse\n\t(aarch64_gen_atomic_cas): Likewise gen_aarch64_atomic_cas.\n\t(aarch64_emit_atomic_swap): Likewise gen_aarch64_atomic_swp.\n\t(aarch64_constant_pool_reload_icode): Delete.\n\t(aarch64_secondary_reload): Use code_for_aarch64_reload_movcp\n\tinstead of aarch64_constant_pool_reload_icode.  Use\n\tcode_for_aarch64_reload_mov instead of explicit mode checks.\n\t(rsqrte_type, get_rsqrte_type, rsqrts_type, get_rsqrts_type): Delete.\n\t(aarch64_emit_approx_sqrt): Use gen_aarch64_rsqrte instead of\n\tget_rsqrte_type and gen_aarch64_rsqrts instead of gen_rqrts_type.\n\t(recpe_type, get_recpe_type, recps_type, get_recps_type): Delete.\n\t(aarch64_emit_approx_div): Use gen_aarch64_frecpe instead of\n\tget_recpe_type and gen_aarch64_frecps instead of get_recps_type.\n\t(aarch64_atomic_load_op_code): Delete.\n\t(aarch64_emit_atomic_load_op): Likewise.\n\t(aarch64_gen_atomic_ldop): Use UNSPECV_ATOMIC_* instead of\n\taarch64_atomic_load_op_code.  Use gen_aarch64_atomic_load\n\tinstead of aarch64_emit_atomic_load_op.\n\t* config/aarch64/aarch64.md (aarch64_reload_movcp<GPF_TF:mode><P:mode>)\n\t(aarch64_reload_movcp<VALL:mode><P:mode>, aarch64_reload_mov<mode>)\n\t(aarch64_movdi_<mode>low, aarch64_movdi_<mode>high)\n\t(aarch64_mov<mode>high_di, aarch64_mov<mode>low_di): Add a '@'\n\tcharacter before the pattern name.\n\t* config/aarch64/aarch64-simd.md (aarch64_split_simd_mov<mode>)\n\t(aarch64_rsqrte<mode>, aarch64_rsqrts<mode>)\n\t(aarch64_simd_combine<mode>, aarch64_frecpe<mode>)\n\t(aarch64_frecps<mode>): Likewise.\n\t* config/aarch64/atomics.md (atomic_compare_and_swap<mode>)\n\t(aarch64_compare_and_swap<mode>, aarch64_compare_and_swap<mode>_lse)\n\t(aarch64_load_exclusive<mode>, aarch64_store_exclusive<mode>)\n\t(aarch64_atomic_swp<mode>, aarch64_atomic_cas<mode>)\n\t(aarch64_atomic_load<atomic_ldop><mode>): Likewise.\n\nFrom-SVN: r263251", "tree": {"sha": "c65a69b7b2e33e1f21911fa540f0ce7579294e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c65a69b7b2e33e1f21911fa540f0ce7579294e37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0016d8d91cb2880e69be74efb44367b282577977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0016d8d91cb2880e69be74efb44367b282577977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0016d8d91cb2880e69be74efb44367b282577977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0016d8d91cb2880e69be74efb44367b282577977/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a451882123524de1b9b175af97a1cdd32e5f25c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a451882123524de1b9b175af97a1cdd32e5f25c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a451882123524de1b9b175af97a1cdd32e5f25c1"}], "stats": {"total": 1096, "additions": 691, "deletions": 405}, "files": [{"sha": "23450e63e99a1ead8fc25145e52333adbc3b36d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -1,3 +1,75 @@\n+2018-08-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi: Expand the documentation of instruction names\n+\tto mention port-local uses.  Document '@' in pattern names.\n+\t* read-md.h (overloaded_instance, overloaded_name): New structs.\n+\t(mapping): Declare.\n+\t(md_reader::handle_overloaded_name): New member function.\n+\t(md_reader::get_overloads): Likewise.\n+\t(md_reader::m_first_overload): New member variable.\n+\t(md_reader::m_next_overload_ptr): Likewise.\n+\t(md_reader::m_overloads_htab): Likewise.\n+\t* read-md.c (md_reader::md_reader): Initialize m_first_overload,\n+\tm_next_overload_ptr and m_overloads_htab.\n+\t* read-rtl.c (iterator_group): Add \"type\" and \"get_c_token\" fields.\n+\t(get_mode_token, get_code_token, get_int_token): New functions.\n+\t(map_attr_string): Add an optional argument that passes back\n+\tthe associated iterator.\n+\t(overloaded_name_hash, overloaded_name_eq_p, named_rtx_p):\n+\t(md_reader::handle_overloaded_name, add_overload_instance): New\n+\tfunctions.\n+\t(apply_iterators): Handle '@' names.  Report an error if '@'\n+\tis used without iterators.\n+\t(initialize_iterators): Initialize the new iterator_group fields.\n+\t* genopinit.c (handle_overloaded_code_for)\n+\t(handle_overloaded_gen): New functions.\n+\t(main): Use them to print declarations of maybe_code_for_* and\n+\tmaybe_gen_* functions, and inline definitions of code_for_* and gen_*.\n+\t* genemit.c (print_overload_arguments, print_overload_test)\n+\t(handle_overloaded_code_for, handle_overloaded_gen): New functions.\n+\t(main): Use it to print definitions of maybe_code_for_* and\n+\tmaybe_gen_* functions.\n+\t* config/aarch64/aarch64.c (aarch64_split_128bit_move): Use\n+\tgen_aarch64_mov{low,high}_di and gen_aarch64_movdi_{low,high}\n+\tinstead of explicit mode checks.\n+\t(aarch64_split_simd_combine): Likewise gen_aarch64_simd_combine.\n+\t(aarch64_split_simd_move): Likewise gen_aarch64_split_simd_mov.\n+\t(aarch64_emit_load_exclusive): Likewise gen_aarch64_load_exclusive.\n+\t(aarch64_emit_store_exclusive): Likewise gen_aarch64_store_exclusive.\n+\t(aarch64_expand_compare_and_swap): Likewise\n+\tgen_aarch64_compare_and_swap and gen_aarch64_compare_and_swap_lse\n+\t(aarch64_gen_atomic_cas): Likewise gen_aarch64_atomic_cas.\n+\t(aarch64_emit_atomic_swap): Likewise gen_aarch64_atomic_swp.\n+\t(aarch64_constant_pool_reload_icode): Delete.\n+\t(aarch64_secondary_reload): Use code_for_aarch64_reload_movcp\n+\tinstead of aarch64_constant_pool_reload_icode.  Use\n+\tcode_for_aarch64_reload_mov instead of explicit mode checks.\n+\t(rsqrte_type, get_rsqrte_type, rsqrts_type, get_rsqrts_type): Delete.\n+\t(aarch64_emit_approx_sqrt): Use gen_aarch64_rsqrte instead of\n+\tget_rsqrte_type and gen_aarch64_rsqrts instead of gen_rqrts_type.\n+\t(recpe_type, get_recpe_type, recps_type, get_recps_type): Delete.\n+\t(aarch64_emit_approx_div): Use gen_aarch64_frecpe instead of\n+\tget_recpe_type and gen_aarch64_frecps instead of get_recps_type.\n+\t(aarch64_atomic_load_op_code): Delete.\n+\t(aarch64_emit_atomic_load_op): Likewise.\n+\t(aarch64_gen_atomic_ldop): Use UNSPECV_ATOMIC_* instead of\n+\taarch64_atomic_load_op_code.  Use gen_aarch64_atomic_load\n+\tinstead of aarch64_emit_atomic_load_op.\n+\t* config/aarch64/aarch64.md (aarch64_reload_movcp<GPF_TF:mode><P:mode>)\n+\t(aarch64_reload_movcp<VALL:mode><P:mode>, aarch64_reload_mov<mode>)\n+\t(aarch64_movdi_<mode>low, aarch64_movdi_<mode>high)\n+\t(aarch64_mov<mode>high_di, aarch64_mov<mode>low_di): Add a '@'\n+\tcharacter before the pattern name.\n+\t* config/aarch64/aarch64-simd.md (aarch64_split_simd_mov<mode>)\n+\t(aarch64_rsqrte<mode>, aarch64_rsqrts<mode>)\n+\t(aarch64_simd_combine<mode>, aarch64_frecpe<mode>)\n+\t(aarch64_frecps<mode>): Likewise.\n+\t* config/aarch64/atomics.md (atomic_compare_and_swap<mode>)\n+\t(aarch64_compare_and_swap<mode>, aarch64_compare_and_swap<mode>_lse)\n+\t(aarch64_load_exclusive<mode>, aarch64_store_exclusive<mode>)\n+\t(aarch64_atomic_swp<mode>, aarch64_atomic_cas<mode>)\n+\t(aarch64_atomic_load<atomic_ldop><mode>): Likewise.\n+\n 2018-08-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_float_const_representable_p):"}, {"sha": "5591c7b5a6bd7783c2b227add3e5a89d1a188f69", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -257,7 +257,7 @@\n   DONE;\n })\n \n-(define_expand \"aarch64_split_simd_mov<mode>\"\n+(define_expand \"@aarch64_split_simd_mov<mode>\"\n   [(set (match_operand:VQ 0)\n         (match_operand:VQ 1))]\n   \"TARGET_SIMD\"\n@@ -559,15 +559,15 @@\n   [(set_attr \"type\" \"neon<fp>_mul_<stype>_scalar<q>\")]\n )\n \n-(define_insn \"aarch64_rsqrte<mode>\"\n+(define_insn \"@aarch64_rsqrte<mode>\"\n   [(set (match_operand:VHSDF_HSDF 0 \"register_operand\" \"=w\")\n \t(unspec:VHSDF_HSDF [(match_operand:VHSDF_HSDF 1 \"register_operand\" \"w\")]\n \t\t     UNSPEC_RSQRTE))]\n   \"TARGET_SIMD\"\n   \"frsqrte\\\\t%<v>0<Vmtype>, %<v>1<Vmtype>\"\n   [(set_attr \"type\" \"neon_fp_rsqrte_<stype><q>\")])\n \n-(define_insn \"aarch64_rsqrts<mode>\"\n+(define_insn \"@aarch64_rsqrts<mode>\"\n   [(set (match_operand:VHSDF_HSDF 0 \"register_operand\" \"=w\")\n \t(unspec:VHSDF_HSDF [(match_operand:VHSDF_HSDF 1 \"register_operand\" \"w\")\n \t\t\t    (match_operand:VHSDF_HSDF 2 \"register_operand\" \"w\")]\n@@ -3145,7 +3145,7 @@\n }\n )\n \n-(define_expand \"aarch64_simd_combine<mode>\"\n+(define_expand \"@aarch64_simd_combine<mode>\"\n   [(match_operand:<VDBL> 0 \"register_operand\")\n    (match_operand:VDC 1 \"register_operand\")\n    (match_operand:VDC 2 \"register_operand\")]\n@@ -5878,7 +5878,7 @@\n )\n \n \n-(define_insn \"aarch64_frecpe<mode>\"\n+(define_insn \"@aarch64_frecpe<mode>\"\n   [(set (match_operand:VHSDF 0 \"register_operand\" \"=w\")\n \t(unspec:VHSDF [(match_operand:VHSDF 1 \"register_operand\" \"w\")]\n \t UNSPEC_FRECPE))]\n@@ -5896,7 +5896,7 @@\n   [(set_attr \"type\" \"neon_fp_recp<FRECP:frecp_suffix>_<GPF_F16:stype>\")]\n )\n \n-(define_insn \"aarch64_frecps<mode>\"\n+(define_insn \"@aarch64_frecps<mode>\"\n   [(set (match_operand:VHSDF_HSDF 0 \"register_operand\" \"=w\")\n \t(unspec:VHSDF_HSDF\n \t  [(match_operand:VHSDF_HSDF 1 \"register_operand\" \"w\")"}, {"sha": "13b5448aca88555222481f0955237b6fdcbb38b9", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 28, "deletions": 367, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -1981,33 +1981,17 @@ aarch64_split_128bit_move (rtx dst, rtx src)\n \t  src_lo = gen_lowpart (word_mode, src);\n \t  src_hi = gen_highpart (word_mode, src);\n \n-\t  if (mode == TImode)\n-\t    {\n-\t      emit_insn (gen_aarch64_movtilow_di (dst, src_lo));\n-\t      emit_insn (gen_aarch64_movtihigh_di (dst, src_hi));\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_insn (gen_aarch64_movtflow_di (dst, src_lo));\n-\t      emit_insn (gen_aarch64_movtfhigh_di (dst, src_hi));\n-\t    }\n+\t  emit_insn (gen_aarch64_movlow_di (mode, dst, src_lo));\n+\t  emit_insn (gen_aarch64_movhigh_di (mode, dst, src_hi));\n \t  return;\n \t}\n       else if (GP_REGNUM_P (dst_regno) && FP_REGNUM_P (src_regno))\n \t{\n \t  dst_lo = gen_lowpart (word_mode, dst);\n \t  dst_hi = gen_highpart (word_mode, dst);\n \n-\t  if (mode == TImode)\n-\t    {\n-\t      emit_insn (gen_aarch64_movdi_tilow (dst_lo, src));\n-\t      emit_insn (gen_aarch64_movdi_tihigh (dst_hi, src));\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_insn (gen_aarch64_movdi_tflow (dst_lo, src));\n-\t      emit_insn (gen_aarch64_movdi_tfhigh (dst_hi, src));\n-\t    }\n+\t  emit_insn (gen_aarch64_movdi_low (mode, dst_lo, src));\n+\t  emit_insn (gen_aarch64_movdi_high (mode, dst_hi, src));\n \t  return;\n \t}\n     }\n@@ -2050,36 +2034,7 @@ aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)\n \t      && register_operand (src1, src_mode)\n \t      && register_operand (src2, src_mode));\n \n-  rtx (*gen) (rtx, rtx, rtx);\n-\n-  switch (src_mode)\n-    {\n-    case E_V8QImode:\n-      gen = gen_aarch64_simd_combinev8qi;\n-      break;\n-    case E_V4HImode:\n-      gen = gen_aarch64_simd_combinev4hi;\n-      break;\n-    case E_V2SImode:\n-      gen = gen_aarch64_simd_combinev2si;\n-      break;\n-    case E_V4HFmode:\n-      gen = gen_aarch64_simd_combinev4hf;\n-      break;\n-    case E_V2SFmode:\n-      gen = gen_aarch64_simd_combinev2sf;\n-      break;\n-    case E_DImode:\n-      gen = gen_aarch64_simd_combinedi;\n-      break;\n-    case E_DFmode:\n-      gen = gen_aarch64_simd_combinedf;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (dst, src1, src2));\n+  emit_insn (gen_aarch64_simd_combine (src_mode, dst, src1, src2));\n   return;\n }\n \n@@ -2095,39 +2050,8 @@ aarch64_split_simd_move (rtx dst, rtx src)\n \n   if (REG_P (dst) && REG_P (src))\n     {\n-      rtx (*gen) (rtx, rtx);\n-\n       gcc_assert (VECTOR_MODE_P (src_mode));\n-\n-      switch (src_mode)\n-\t{\n-\tcase E_V16QImode:\n-\t  gen = gen_aarch64_split_simd_movv16qi;\n-\t  break;\n-\tcase E_V8HImode:\n-\t  gen = gen_aarch64_split_simd_movv8hi;\n-\t  break;\n-\tcase E_V4SImode:\n-\t  gen = gen_aarch64_split_simd_movv4si;\n-\t  break;\n-\tcase E_V2DImode:\n-\t  gen = gen_aarch64_split_simd_movv2di;\n-\t  break;\n-\tcase E_V8HFmode:\n-\t  gen = gen_aarch64_split_simd_movv8hf;\n-\t  break;\n-\tcase E_V4SFmode:\n-\t  gen = gen_aarch64_split_simd_movv4sf;\n-\t  break;\n-\tcase E_V2DFmode:\n-\t  gen = gen_aarch64_split_simd_movv2df;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      emit_insn (gen (dst, src));\n-      return;\n+      emit_insn (gen_aarch64_split_simd_mov (src_mode, dst, src));\n     }\n }\n \n@@ -7443,51 +7367,6 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n   return x;\n }\n \n-/* Return the reload icode required for a constant pool in mode.  */\n-static enum insn_code\n-aarch64_constant_pool_reload_icode (machine_mode mode)\n-{\n-  switch (mode)\n-    {\n-    case E_SFmode:\n-      return CODE_FOR_aarch64_reload_movcpsfdi;\n-\n-    case E_DFmode:\n-      return CODE_FOR_aarch64_reload_movcpdfdi;\n-\n-    case E_TFmode:\n-      return CODE_FOR_aarch64_reload_movcptfdi;\n-\n-    case E_V8QImode:\n-      return CODE_FOR_aarch64_reload_movcpv8qidi;\n-\n-    case E_V16QImode:\n-      return CODE_FOR_aarch64_reload_movcpv16qidi;\n-\n-    case E_V4HImode:\n-      return CODE_FOR_aarch64_reload_movcpv4hidi;\n-\n-    case E_V8HImode:\n-      return CODE_FOR_aarch64_reload_movcpv8hidi;\n-\n-    case E_V2SImode:\n-      return CODE_FOR_aarch64_reload_movcpv2sidi;\n-\n-    case E_V4SImode:\n-      return CODE_FOR_aarch64_reload_movcpv4sidi;\n-\n-    case E_V2DImode:\n-      return CODE_FOR_aarch64_reload_movcpv2didi;\n-\n-    case E_V2DFmode:\n-      return CODE_FOR_aarch64_reload_movcpv2dfdi;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  gcc_unreachable ();\n-}\n static reg_class_t\n aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  reg_class_t rclass,\n@@ -7515,7 +7394,7 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t  || targetm.vector_mode_supported_p (GET_MODE (x)))\n       && !aarch64_pcrelative_literal_loads)\n     {\n-      sri->icode = aarch64_constant_pool_reload_icode (mode);\n+      sri->icode = code_for_aarch64_reload_movcp (mode, DImode);\n       return NO_REGS;\n     }\n \n@@ -7525,10 +7404,7 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n       && FP_REGNUM_P (REGNO (x)) && !TARGET_SIMD\n       && reg_class_subset_p (rclass, FP_REGS))\n     {\n-      if (mode == TFmode)\n-        sri->icode = CODE_FOR_aarch64_reload_movtf;\n-      else if (mode == TImode)\n-        sri->icode = CODE_FOR_aarch64_reload_movti;\n+      sri->icode = code_for_aarch64_reload_mov (mode);\n       return NO_REGS;\n     }\n \n@@ -9894,43 +9770,6 @@ aarch64_builtin_reciprocal (tree fndecl)\n   return aarch64_builtin_rsqrt (DECL_FUNCTION_CODE (fndecl));\n }\n \n-typedef rtx (*rsqrte_type) (rtx, rtx);\n-\n-/* Select reciprocal square root initial estimate insn depending on machine\n-   mode.  */\n-\n-static rsqrte_type\n-get_rsqrte_type (machine_mode mode)\n-{\n-  switch (mode)\n-  {\n-    case E_DFmode:   return gen_aarch64_rsqrtedf;\n-    case E_SFmode:   return gen_aarch64_rsqrtesf;\n-    case E_V2DFmode: return gen_aarch64_rsqrtev2df;\n-    case E_V2SFmode: return gen_aarch64_rsqrtev2sf;\n-    case E_V4SFmode: return gen_aarch64_rsqrtev4sf;\n-    default: gcc_unreachable ();\n-  }\n-}\n-\n-typedef rtx (*rsqrts_type) (rtx, rtx, rtx);\n-\n-/* Select reciprocal square root series step insn depending on machine mode.  */\n-\n-static rsqrts_type\n-get_rsqrts_type (machine_mode mode)\n-{\n-  switch (mode)\n-  {\n-    case E_DFmode:   return gen_aarch64_rsqrtsdf;\n-    case E_SFmode:   return gen_aarch64_rsqrtssf;\n-    case E_V2DFmode: return gen_aarch64_rsqrtsv2df;\n-    case E_V2SFmode: return gen_aarch64_rsqrtsv2sf;\n-    case E_V4SFmode: return gen_aarch64_rsqrtsv4sf;\n-    default: gcc_unreachable ();\n-  }\n-}\n-\n /* Emit instruction sequence to compute either the approximate square root\n    or its approximate reciprocal, depending on the flag RECP, and return\n    whether the sequence was emitted or not.  */\n@@ -9975,7 +9814,7 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n \n   /* Estimate the approximate reciprocal square root.  */\n   rtx xdst = gen_reg_rtx (mode);\n-  emit_insn ((*get_rsqrte_type (mode)) (xdst, src));\n+  emit_insn (gen_aarch64_rsqrte (mode, xdst, src));\n \n   /* Iterate over the series twice for SF and thrice for DF.  */\n   int iterations = (GET_MODE_INNER (mode) == DFmode) ? 3 : 2;\n@@ -9994,7 +9833,7 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n       rtx x2 = gen_reg_rtx (mode);\n       emit_set_insn (x2, gen_rtx_MULT (mode, xdst, xdst));\n \n-      emit_insn ((*get_rsqrts_type (mode)) (x1, src, x2));\n+      emit_insn (gen_aarch64_rsqrts (mode, x1, src, x2));\n \n       if (iterations > 0)\n \temit_set_insn (xdst, gen_rtx_MULT (mode, xdst, x1));\n@@ -10019,42 +9858,6 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n   return true;\n }\n \n-typedef rtx (*recpe_type) (rtx, rtx);\n-\n-/* Select reciprocal initial estimate insn depending on machine mode.  */\n-\n-static recpe_type\n-get_recpe_type (machine_mode mode)\n-{\n-  switch (mode)\n-  {\n-    case E_SFmode:   return (gen_aarch64_frecpesf);\n-    case E_V2SFmode: return (gen_aarch64_frecpev2sf);\n-    case E_V4SFmode: return (gen_aarch64_frecpev4sf);\n-    case E_DFmode:   return (gen_aarch64_frecpedf);\n-    case E_V2DFmode: return (gen_aarch64_frecpev2df);\n-    default:         gcc_unreachable ();\n-  }\n-}\n-\n-typedef rtx (*recps_type) (rtx, rtx, rtx);\n-\n-/* Select reciprocal series step insn depending on machine mode.  */\n-\n-static recps_type\n-get_recps_type (machine_mode mode)\n-{\n-  switch (mode)\n-  {\n-    case E_SFmode:   return (gen_aarch64_frecpssf);\n-    case E_V2SFmode: return (gen_aarch64_frecpsv2sf);\n-    case E_V4SFmode: return (gen_aarch64_frecpsv4sf);\n-    case E_DFmode:   return (gen_aarch64_frecpsdf);\n-    case E_V2DFmode: return (gen_aarch64_frecpsv2df);\n-    default:         gcc_unreachable ();\n-  }\n-}\n-\n /* Emit the instruction sequence to compute the approximation for the division\n    of NUM by DEN in QUO and return whether the sequence was emitted or not.  */\n \n@@ -10082,7 +9885,7 @@ aarch64_emit_approx_div (rtx quo, rtx num, rtx den)\n \n   /* Estimate the approximate reciprocal.  */\n   rtx xrcp = gen_reg_rtx (mode);\n-  emit_insn ((*get_recpe_type (mode)) (xrcp, den));\n+  emit_insn (gen_aarch64_frecpe (mode, xrcp, den));\n \n   /* Iterate over the series twice for SF and thrice for DF.  */\n   int iterations = (GET_MODE_INNER (mode) == DFmode) ? 3 : 2;\n@@ -10096,7 +9899,7 @@ aarch64_emit_approx_div (rtx quo, rtx num, rtx den)\n   rtx xtmp = gen_reg_rtx (mode);\n   while (iterations--)\n     {\n-      emit_insn ((*get_recps_type (mode)) (xtmp, xrcp, den));\n+      emit_insn (gen_aarch64_frecps (mode, xtmp, xrcp, den));\n \n       if (iterations > 0)\n \temit_set_insn (xrcp, gen_rtx_MULT (mode, xrcp, xtmp));\n@@ -14247,19 +14050,7 @@ static void\n aarch64_emit_load_exclusive (machine_mode mode, rtx rval,\n \t\t\t     rtx mem, rtx model_rtx)\n {\n-  rtx (*gen) (rtx, rtx, rtx);\n-\n-  switch (mode)\n-    {\n-    case E_QImode: gen = gen_aarch64_load_exclusiveqi; break;\n-    case E_HImode: gen = gen_aarch64_load_exclusivehi; break;\n-    case E_SImode: gen = gen_aarch64_load_exclusivesi; break;\n-    case E_DImode: gen = gen_aarch64_load_exclusivedi; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (rval, mem, model_rtx));\n+  emit_insn (gen_aarch64_load_exclusive (mode, rval, mem, model_rtx));\n }\n \n /* Emit store exclusive.  */\n@@ -14268,19 +14059,7 @@ static void\n aarch64_emit_store_exclusive (machine_mode mode, rtx bval,\n \t\t\t      rtx rval, rtx mem, rtx model_rtx)\n {\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n-\n-  switch (mode)\n-    {\n-    case E_QImode: gen = gen_aarch64_store_exclusiveqi; break;\n-    case E_HImode: gen = gen_aarch64_store_exclusivehi; break;\n-    case E_SImode: gen = gen_aarch64_store_exclusivesi; break;\n-    case E_DImode: gen = gen_aarch64_store_exclusivedi; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (bval, rval, mem, model_rtx));\n+  emit_insn (gen_aarch64_store_exclusive (mode, bval, rval, mem, model_rtx));\n }\n \n /* Mark the previous jump instruction as unlikely.  */\n@@ -14299,23 +14078,6 @@ aarch64_expand_compare_and_swap (rtx operands[])\n {\n   rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n   machine_mode mode, cmp_mode;\n-  typedef rtx (*gen_cas_fn) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  int idx;\n-  gen_cas_fn gen;\n-  const gen_cas_fn split_cas[] =\n-  {\n-    gen_aarch64_compare_and_swapqi,\n-    gen_aarch64_compare_and_swaphi,\n-    gen_aarch64_compare_and_swapsi,\n-    gen_aarch64_compare_and_swapdi\n-  };\n-  const gen_cas_fn atomic_cas[] =\n-  {\n-    gen_aarch64_compare_and_swapqi_lse,\n-    gen_aarch64_compare_and_swaphi_lse,\n-    gen_aarch64_compare_and_swapsi_lse,\n-    gen_aarch64_compare_and_swapdi_lse\n-  };\n \n   bval = operands[0];\n   rval = operands[1];\n@@ -14358,21 +14120,14 @@ aarch64_expand_compare_and_swap (rtx operands[])\n       gcc_unreachable ();\n     }\n \n-  switch (mode)\n-    {\n-    case E_QImode: idx = 0; break;\n-    case E_HImode: idx = 1; break;\n-    case E_SImode: idx = 2; break;\n-    case E_DImode: idx = 3; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n   if (TARGET_LSE)\n-    gen = atomic_cas[idx];\n+    emit_insn (gen_aarch64_compare_and_swap_lse (mode, rval, mem, oldval,\n+\t\t\t\t\t\t newval, is_weak, mod_s,\n+\t\t\t\t\t\t mod_f));\n   else\n-    gen = split_cas[idx];\n+    emit_insn (gen_aarch64_compare_and_swap (mode, rval, mem, oldval, newval,\n+\t\t\t\t\t     is_weak, mod_s, mod_f));\n \n-  emit_insn (gen (rval, mem, oldval, newval, is_weak, mod_s, mod_f));\n \n   if (mode == QImode || mode == HImode)\n     emit_move_insn (operands[1], gen_lowpart (mode, rval));\n@@ -14435,26 +14190,15 @@ aarch64_gen_atomic_cas (rtx rval, rtx mem,\n \t\t\trtx expected, rtx desired,\n \t\t\trtx model)\n {\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n   machine_mode mode;\n \n   mode = GET_MODE (mem);\n \n-  switch (mode)\n-    {\n-    case E_QImode: gen = gen_aarch64_atomic_casqi; break;\n-    case E_HImode: gen = gen_aarch64_atomic_cashi; break;\n-    case E_SImode: gen = gen_aarch64_atomic_cassi; break;\n-    case E_DImode: gen = gen_aarch64_atomic_casdi; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   /* Move the expected value into the CAS destination register.  */\n   emit_insn (gen_rtx_SET (rval, expected));\n \n   /* Emit the CAS.  */\n-  emit_insn (gen (rval, mem, desired, model));\n+  emit_insn (gen_aarch64_atomic_cas (mode, rval, mem, desired, model));\n \n   /* Compare the expected value with the value loaded by the CAS, to establish\n      whether the swap was made.  */\n@@ -14601,91 +14345,7 @@ static void\n aarch64_emit_atomic_swap (machine_mode mode, rtx dst, rtx value,\n \t\t\t  rtx mem, rtx model)\n {\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n-\n-  switch (mode)\n-    {\n-    case E_QImode: gen = gen_aarch64_atomic_swpqi; break;\n-    case E_HImode: gen = gen_aarch64_atomic_swphi; break;\n-    case E_SImode: gen = gen_aarch64_atomic_swpsi; break;\n-    case E_DImode: gen = gen_aarch64_atomic_swpdi; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (dst, mem, value, model));\n-}\n-\n-/* Operations supported by aarch64_emit_atomic_load_op.  */\n-\n-enum aarch64_atomic_load_op_code\n-{\n-  AARCH64_LDOP_PLUS,\t/* A + B  */\n-  AARCH64_LDOP_XOR,\t/* A ^ B  */\n-  AARCH64_LDOP_OR,\t/* A | B  */\n-  AARCH64_LDOP_BIC\t/* A & ~B  */\n-};\n-\n-/* Emit an atomic load-operate.  */\n-\n-static void\n-aarch64_emit_atomic_load_op (enum aarch64_atomic_load_op_code code,\n-\t\t\t     machine_mode mode, rtx dst, rtx src,\n-\t\t\t     rtx mem, rtx model)\n-{\n-  typedef rtx (*aarch64_atomic_load_op_fn) (rtx, rtx, rtx, rtx);\n-  const aarch64_atomic_load_op_fn plus[] =\n-  {\n-    gen_aarch64_atomic_loadaddqi,\n-    gen_aarch64_atomic_loadaddhi,\n-    gen_aarch64_atomic_loadaddsi,\n-    gen_aarch64_atomic_loadadddi\n-  };\n-  const aarch64_atomic_load_op_fn eor[] =\n-  {\n-    gen_aarch64_atomic_loadeorqi,\n-    gen_aarch64_atomic_loadeorhi,\n-    gen_aarch64_atomic_loadeorsi,\n-    gen_aarch64_atomic_loadeordi\n-  };\n-  const aarch64_atomic_load_op_fn ior[] =\n-  {\n-    gen_aarch64_atomic_loadsetqi,\n-    gen_aarch64_atomic_loadsethi,\n-    gen_aarch64_atomic_loadsetsi,\n-    gen_aarch64_atomic_loadsetdi\n-  };\n-  const aarch64_atomic_load_op_fn bic[] =\n-  {\n-    gen_aarch64_atomic_loadclrqi,\n-    gen_aarch64_atomic_loadclrhi,\n-    gen_aarch64_atomic_loadclrsi,\n-    gen_aarch64_atomic_loadclrdi\n-  };\n-  aarch64_atomic_load_op_fn gen;\n-  int idx = 0;\n-\n-  switch (mode)\n-    {\n-    case E_QImode: idx = 0; break;\n-    case E_HImode: idx = 1; break;\n-    case E_SImode: idx = 2; break;\n-    case E_DImode: idx = 3; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  switch (code)\n-    {\n-    case AARCH64_LDOP_PLUS: gen = plus[idx]; break;\n-    case AARCH64_LDOP_XOR: gen = eor[idx]; break;\n-    case AARCH64_LDOP_OR: gen = ior[idx]; break;\n-    case AARCH64_LDOP_BIC: gen = bic[idx]; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (dst, mem, src, model));\n+  emit_insn (gen_aarch64_atomic_swp (mode, dst, mem, value, model));\n }\n \n /* Emit an atomic load+operate.  CODE is the operation.  OUT_DATA is the\n@@ -14702,7 +14362,7 @@ aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data, rtx out_result,\n   machine_mode mode = GET_MODE (mem);\n   machine_mode wmode = (mode == DImode ? DImode : SImode);\n   const bool short_mode = (mode < SImode);\n-  aarch64_atomic_load_op_code ldop_code;\n+  int ldop_code;\n   rtx src;\n   rtx x;\n \n@@ -14749,15 +14409,15 @@ aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data, rtx out_result,\n       }\n       /* Fall-through.  */\n     case PLUS:\n-      ldop_code = AARCH64_LDOP_PLUS;\n+      ldop_code = UNSPECV_ATOMIC_LDOP_PLUS;\n       break;\n \n     case IOR:\n-      ldop_code = AARCH64_LDOP_OR;\n+      ldop_code = UNSPECV_ATOMIC_LDOP_OR;\n       break;\n \n     case XOR:\n-      ldop_code = AARCH64_LDOP_XOR;\n+      ldop_code = UNSPECV_ATOMIC_LDOP_XOR;\n       break;\n \n     case AND:\n@@ -14774,15 +14434,16 @@ aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data, rtx out_result,\n \tif (short_mode)\n \t  src = gen_lowpart (mode, src);\n       }\n-      ldop_code = AARCH64_LDOP_BIC;\n+      ldop_code = UNSPECV_ATOMIC_LDOP_BIC;\n       break;\n \n     default:\n       /* The operation can't be done with atomic instructions.  */\n       gcc_unreachable ();\n     }\n \n-  aarch64_emit_atomic_load_op (ldop_code, mode, out_data, src, mem, model_rtx);\n+  emit_insn (gen_aarch64_atomic_load (ldop_code, mode,\n+\t\t\t\t      out_data, mem, src, model_rtx));\n \n   /* If necessary, calculate the data in memory after the update by redoing the\n      operation from values in registers.  */"}, {"sha": "955bf1814b92d2bbf72d46bb2050998385174200", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -5989,7 +5989,7 @@\n ;; -------------------------------------------------------------------\n ;; Reload Scalar Floating point modes from constant pool.\n ;; The AArch64 port doesn't have __int128 constant move support.\n-(define_expand \"aarch64_reload_movcp<GPF_TF:mode><P:mode>\"\n+(define_expand \"@aarch64_reload_movcp<GPF_TF:mode><P:mode>\"\n  [(set (match_operand:GPF_TF 0 \"register_operand\" \"=w\")\n        (mem:GPF_TF (match_operand 1 \"aarch64_constant_pool_symref\" \"S\")))\n   (clobber (match_operand:P 2 \"register_operand\" \"=&r\"))]\n@@ -6002,7 +6002,7 @@\n )\n \n ;; Reload Vector modes from constant pool.\n-(define_expand \"aarch64_reload_movcp<VALL:mode><P:mode>\"\n+(define_expand \"@aarch64_reload_movcp<VALL:mode><P:mode>\"\n  [(set (match_operand:VALL 0 \"register_operand\" \"=w\")\n        (mem:VALL (match_operand 1 \"aarch64_constant_pool_symref\" \"S\")))\n   (clobber (match_operand:P 2 \"register_operand\" \"=&r\"))]\n@@ -6014,7 +6014,7 @@\n  }\n )\n \n-(define_expand \"aarch64_reload_mov<mode>\"\n+(define_expand \"@aarch64_reload_mov<mode>\"\n   [(set (match_operand:TX 0 \"register_operand\" \"=w\")\n         (match_operand:TX 1 \"register_operand\" \"w\"))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))\n@@ -6034,7 +6034,7 @@\n ;; after or during reload as we don't want these patterns to start\n ;; kicking in during the combiner.\n \n-(define_insn \"aarch64_movdi_<mode>low\"\n+(define_insn \"@aarch64_movdi_<mode>low\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:TX 1 \"register_operand\" \"w\")\n \t\t\t (const_int 64) (const_int 0)))]\n@@ -6044,7 +6044,7 @@\n    (set_attr \"length\" \"4\")\n   ])\n \n-(define_insn \"aarch64_movdi_<mode>high\"\n+(define_insn \"@aarch64_movdi_<mode>high\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:TX 1 \"register_operand\" \"w\")\n \t\t\t (const_int 64) (const_int 64)))]\n@@ -6054,7 +6054,7 @@\n    (set_attr \"length\" \"4\")\n   ])\n \n-(define_insn \"aarch64_mov<mode>high_di\"\n+(define_insn \"@aarch64_mov<mode>high_di\"\n   [(set (zero_extract:TX (match_operand:TX 0 \"register_operand\" \"+w\")\n                          (const_int 64) (const_int 64))\n         (zero_extend:TX (match_operand:DI 1 \"register_operand\" \"r\")))]\n@@ -6064,7 +6064,7 @@\n    (set_attr \"length\" \"4\")\n   ])\n \n-(define_insn \"aarch64_mov<mode>low_di\"\n+(define_insn \"@aarch64_mov<mode>low_di\"\n   [(set (match_operand:TX 0 \"register_operand\" \"=w\")\n         (zero_extend:TX (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"TARGET_FLOAT && (reload_completed || reload_in_progress)\""}, {"sha": "36c06756a1f94cadae097b3aad654fbeba1cf2f3", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -20,7 +20,7 @@\n \n ;; Instruction patterns.\n \n-(define_expand \"atomic_compare_and_swap<mode>\"\n+(define_expand \"@atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t\t;; bool out\n    (match_operand:ALLI 1 \"register_operand\" \"\")\t\t\t;; val out\n    (match_operand:ALLI 2 \"aarch64_sync_memory_operand\" \"\")\t;; memory\n@@ -36,7 +36,7 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_compare_and_swap<mode>\"\n+(define_insn_and_split \"@aarch64_compare_and_swap<mode>\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n    (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t   ;; val out\n@@ -61,7 +61,7 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_compare_and_swap<mode>\"\n+(define_insn_and_split \"@aarch64_compare_and_swap<mode>\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n    (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n@@ -85,7 +85,7 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_compare_and_swap<mode>_lse\"\n+(define_insn_and_split \"@aarch64_compare_and_swap<mode>_lse\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n    (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n@@ -111,7 +111,7 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_compare_and_swap<mode>_lse\"\n+(define_insn_and_split \"@aarch64_compare_and_swap<mode>_lse\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n    (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n@@ -496,7 +496,7 @@\n   }\n )\n \n-(define_insn \"aarch64_load_exclusive<mode>\"\n+(define_insn \"@aarch64_load_exclusive<mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n     (zero_extend:SI\n       (unspec_volatile:SHORT\n@@ -513,7 +513,7 @@\n   }\n )\n \n-(define_insn \"aarch64_load_exclusive<mode>\"\n+(define_insn \"@aarch64_load_exclusive<mode>\"\n   [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n     (unspec_volatile:GPI\n       [(match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"Q\")\n@@ -529,7 +529,7 @@\n   }\n )\n \n-(define_insn \"aarch64_store_exclusive<mode>\"\n+(define_insn \"@aarch64_store_exclusive<mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n     (unspec_volatile:SI [(const_int 0)] UNSPECV_SX))\n    (set (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"=Q\")\n@@ -586,7 +586,7 @@\n ;; ARMv8.1-A LSE instructions.\n \n ;; Atomic swap with memory.\n-(define_insn \"aarch64_atomic_swp<mode>\"\n+(define_insn \"@aarch64_atomic_swp<mode>\"\n  [(set (match_operand:ALLI 0 \"register_operand\" \"+&r\")\n    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n   (set (match_dup 1)\n@@ -609,7 +609,7 @@\n \n ;; Atomic compare-and-swap: HI and smaller modes.\n \n-(define_insn \"aarch64_atomic_cas<mode>\"\n+(define_insn \"@aarch64_atomic_cas<mode>\"\n  [(set (match_operand:SI 0 \"register_operand\" \"+&r\")\t\t  ;; out\n    (zero_extend:SI\n     (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\")))  ;; memory.\n@@ -634,7 +634,7 @@\n \n ;; Atomic compare-and-swap: SI and larger modes.\n \n-(define_insn \"aarch64_atomic_cas<mode>\"\n+(define_insn \"@aarch64_atomic_cas<mode>\"\n  [(set (match_operand:GPI 0 \"register_operand\" \"+&r\")\t      ;; out\n    (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))  ;; memory.\n   (set (match_dup 1)\n@@ -658,7 +658,7 @@\n \n ;; Atomic load-op: Load data, operate, store result, keep data.\n \n-(define_insn \"aarch64_atomic_load<atomic_ldop><mode>\"\n+(define_insn \"@aarch64_atomic_load<atomic_ldop><mode>\"\n  [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n   (set (match_dup 1)"}, {"sha": "e5851a6711d69c489c541d28909ec68c3cf451a5", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 117, "deletions": 8, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -115,26 +115,37 @@ A @code{define_insn} is an RTL expression containing four or five operands:\n \n @enumerate\n @item\n-An optional name.  The presence of a name indicates that this instruction\n-pattern can perform a certain standard job for the RTL-generation\n-pass of the compiler.  This pass knows certain names and will use\n-the instruction patterns with those names, if the names are defined\n-in the machine description.\n+An optional name @var{n}.  When a name is present, the compiler\n+automically generates a C++ function @samp{gen_@var{n}} that takes\n+the operands of the instruction as arguments and returns the instruction's\n+rtx pattern.  The compiler also assigns the instruction a unique code\n+@samp{CODE_FOR_@var{n}}, with all such codes belonging to an enum\n+called @code{insn_code}.\n+\n+These names serve one of two purposes.  The first is to indicate that the\n+instruction performs a certain standard job for the RTL-generation\n+pass of the compiler, such as a move, an addition, or a conditional\n+jump.  The second is to help the target generate certain target-specific\n+operations, such as when implementing target-specific intrinsic functions.\n+\n+It is better to prefix target-specific names with the name of the\n+target, to avoid any clash with current or future standard names.\n \n The absence of a name is indicated by writing an empty string\n where the name should go.  Nameless instruction patterns are never\n used for generating RTL code, but they may permit several simpler insns\n to be combined later on.\n \n-Names that are not thus known and used in RTL-generation have no\n-effect; they are equivalent to no name at all.\n-\n For the purpose of debugging the compiler, you may also specify a\n name beginning with the @samp{*} character.  Such a name is used only\n for identifying the instruction in RTL dumps; it is equivalent to having\n a nameless pattern for all other purposes.  Names beginning with the\n @samp{*} character are not required to be unique.\n \n+The name may also have the form @samp{@@@var{n}}.  This has the same\n+effect as a name @samp{@var{n}}, but in addition tells the compiler to\n+generate further helper functions; see @xref{Parameterized Names} for details.\n+\n @item\n The @dfn{RTL template}: This is a vector of incomplete RTL expressions\n which describe the semantics of the instruction (@pxref{RTL Template}).\n@@ -10530,6 +10541,7 @@ facilities to make this process easier.\n * Code Iterators::         Doing the same for codes.\n * Int Iterators::          Doing the same for integers.\n * Subst Iterators::\t   Generating variations of patterns for define_subst.\n+* Parameterized Names::\t   Specifying iterator values in C++ code.\n @end menu\n \n @node Mode Iterators\n@@ -10925,4 +10937,101 @@ replaced in the first copy of the original RTL-template.\n @var{subst-applied-value} is a value with which subst-attribute would be\n replaced in the second copy of the original RTL-template.\n \n+@node Parameterized Names\n+@subsection Parameterized Names\n+@cindex @samp{@@} in instruction pattern names\n+Ports sometimes need to apply iterators using C++ code, in order to\n+get the code or RTL pattern for a specific instruction.  For example,\n+suppose we have the @samp{neon_vq<absneg><mode>} pattern given above:\n+\n+@smallexample\n+(define_int_iterator QABSNEG [UNSPEC_VQABS UNSPEC_VQNEG])\n+\n+(define_int_attr absneg [(UNSPEC_VQABS \"abs\") (UNSPEC_VQNEG \"neg\")])\n+\n+(define_insn \"neon_vq<absneg><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n+\t(unspec:VDQIW [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+\t\t      QABSNEG))]\n+  @dots{}\n+)\n+@end smallexample\n+\n+A port might need to generate this pattern for a variable\n+@samp{QABSNEG} value and a variable @samp{VDQIW} mode.  There are two\n+ways of doing this.  The first is to build the rtx for the pattern\n+directly from C++ code; this is a valid technique and avoids any risk\n+of combinatorial explosion.  The second is to prefix the instruction\n+name with the special character @samp{@@}, which tells GCC to generate\n+the four additional functions below.  In each case, @var{name} is the\n+name of the instruction without the leading @samp{@@} character,\n+without the @samp{<@dots{}>} placeholders, and with any underscore\n+before a @samp{<@dots{}>} placeholder removed if keeping it would\n+lead to a double or trailing underscore.\n+\n+@table @samp\n+@item insn_code maybe_code_for_@var{name} (@var{i1}, @var{i2}, @dots{})\n+See whether replacing the first @samp{<@dots{}>} placeholder with\n+iterator value @var{i1}, the second with iterator value @var{i2}, and\n+so on, gives a valid instruction.  Return its code if so, otherwise\n+return @code{CODE_FOR_nothing}.\n+\n+@item insn_code code_for_@var{name} (@var{i1}, @var{i2}, @dots{})\n+Same, but abort the compiler if the requested instruction does not exist.\n+\n+@item rtx maybe_gen_@var{name} (@var{i1}, @var{i2}, @dots{}, @var{op0}, @var{op1}, @dots{})\n+Check for a valid instruction in the same way as\n+@code{maybe_code_for_@var{name}}.  If the instruction exists,\n+generate an instance of it using the operand values given by @var{op0},\n+@var{op1}, and so on, otherwise return null.\n+\n+@item rtx gen_@var{name} (@var{i1}, @var{i2}, @dots{}, @var{op0}, @var{op1}, @dots{})\n+Same, but abort the compiler if the requested instruction does not exist,\n+or if the instruction generator invoked the @code{FAIL} macro.\n+@end table\n+\n+For example, changing the pattern above to:\n+\n+@smallexample\n+(define_insn \"@@neon_vq<absneg><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n+\t(unspec:VDQIW [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+\t\t      QABSNEG))]\n+  @dots{}\n+)\n+@end smallexample\n+\n+would define the same patterns as before, but in addition would generate\n+the four functions below:\n+\n+@smallexample\n+insn_code maybe_code_for_neon_vq (int, machine_mode);\n+insn_code code_for_neon_vq (int, machine_mode);\n+rtx maybe_gen_neon_vq (int, machine_mode, rtx, rtx, rtx);\n+rtx gen_neon_vq (int, machine_mode, rtx, rtx, rtx);\n+@end smallexample\n+\n+Calling @samp{code_for_neon_vq (UNSPEC_VQABS, V8QImode)}\n+would then give @code{CODE_FOR_neon_vqabsv8qi}.\n+\n+It is possible to have multiple @samp{@@} patterns with the same\n+name and same types of iterator.  For example:\n+\n+@smallexample\n+(define_insn \"@@some_arithmetic_op<mode>\"\n+  [(set (match_operand:INTEGER_MODES 0 \"register_operand\") @dots{})]\n+  @dots{}\n+)\n+\n+(define_insn \"@@some_arithmetic_op<mode>\"\n+  [(set (match_operand:FLOAT_MODES 0 \"register_operand\") @dots{})]\n+  @dots{}\n+)\n+@end smallexample\n+\n+would produce a single set of functions that handles both\n+@code{INTEGER_MODES} and @code{FLOAT_MODES}.\n+\n @end ifset"}, {"sha": "922703021199384a9269be160ccc566d11687516", "filename": "gcc/genemit.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -752,6 +752,92 @@ output_peephole2_scratches (rtx split)\n     }\n }\n \n+/* Print \"arg<N>\" parameter declarations for each argument N of ONAME.  */\n+\n+static void\n+print_overload_arguments (overloaded_name *oname)\n+{\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    printf (\"%s%s arg%d\", i == 0 ? \"\" : \", \", oname->arg_types[i], i);\n+}\n+\n+/* Print code to test whether INSTANCE should be chosne, given that\n+   argument N of the overload is available as \"arg<N>\".  */\n+\n+static void\n+print_overload_test (overloaded_instance *instance)\n+{\n+  for (unsigned int i = 0; i < instance->arg_values.length (); ++i)\n+    printf (\"%sarg%d == %s\", i == 0 ? \"  if (\" : \"\\n      && \",\n+\t    i, instance->arg_values[i]);\n+  printf (\")\\n\");\n+}\n+\n+/* Emit a maybe_code_for_* function for ONAME.  */\n+\n+static void\n+handle_overloaded_code_for (overloaded_name *oname)\n+{\n+  /* Print the function prototype.  */\n+  printf (\"\\ninsn_code\\nmaybe_code_for_%s (\", oname->name);\n+  print_overload_arguments (oname);\n+  printf (\")\\n{\\n\");\n+\n+  /* Use a sequence of \"if\" statements for each instance.  */\n+  for (overloaded_instance *instance = oname->first_instance;\n+       instance; instance = instance->next)\n+    {\n+      print_overload_test (instance);\n+      printf (\"    return CODE_FOR_%s;\\n\", instance->name);\n+    }\n+\n+  /* Return null if no match was found.  */\n+  printf (\"  return CODE_FOR_nothing;\\n}\\n\");\n+}\n+\n+/* Emit a maybe_gen_* function for ONAME.  */\n+\n+static void\n+handle_overloaded_gen (overloaded_name *oname)\n+{\n+  /* All patterns must have the same number of operands.  */\n+  pattern_stats stats;\n+  get_pattern_stats (&stats, XVEC (oname->first_instance->insn, 1));\n+  for (overloaded_instance *instance = oname->first_instance->next;\n+       instance; instance = instance->next)\n+    {\n+      pattern_stats stats2;\n+      get_pattern_stats (&stats2, XVEC (instance->insn, 1));\n+      if (stats.num_generator_args != stats2.num_generator_args)\n+\tfatal_at (get_file_location (instance->insn),\n+\t\t  \"inconsistent number of operands for '%s'; \"\n+\t\t  \"this instance has %d, but previous instances had %d\",\n+\t\t  oname->name, stats2.num_generator_args,\n+\t\t  stats.num_generator_args);\n+    }\n+\n+  /* Print the function prototype.  */\n+  printf (\"\\nrtx\\nmaybe_gen_%s (\", oname->name);\n+  print_overload_arguments (oname);\n+  for (int i = 0; i < stats.num_generator_args; ++i)\n+    printf (\", rtx x%d\", i);\n+  printf (\")\\n{\\n\");\n+\n+  /* Use maybe_code_for_*, instead of duplicating the selection logic here.  */\n+  printf (\"  insn_code code = maybe_code_for_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    printf (\"%sarg%d\", i == 0 ? \"\" : \", \", i);\n+  printf (\");\\n\"\n+\t  \"  if (code != CODE_FOR_nothing)\\n\"\n+\t  \"    return GEN_FCN (code) (\");\n+  for (int i = 0; i < stats.num_generator_args; ++i)\n+    printf (\"%sx%d\", i == 0 ? \"\" : \", \", i);\n+  printf (\");\\n\"\n+\t  \"  else\\n\"\n+\t  \"    return NULL_RTX;\\n\"\n+\t  \"}\\n\");\n+}\n+\n int\n main (int argc, const char **argv)\n {\n@@ -840,6 +926,13 @@ from the machine description file `md'.  */\\n\\n\");\n   output_add_clobbers ();\n   output_added_clobbers_hard_reg_p ();\n \n+  for (overloaded_name *oname = rtx_reader_ptr->get_overloads ();\n+       oname; oname = oname->next)\n+    {\n+      handle_overloaded_code_for (oname);\n+      handle_overloaded_gen (oname);\n+    }\n+\n   fflush (stdout);\n   return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n }"}, {"sha": "79835cc5d887f68ceceb207ad4807bbfd54ea31f", "filename": "gcc/genopinit.c", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -104,6 +104,63 @@ open_outfile (const char *file_name)\n   return f;\n }\n \n+/* Declare the maybe_code_for_* function for ONAME, and provide\n+   an inline definition of the assserting code_for_* wrapper.  */\n+\n+static void\n+handle_overloaded_code_for (FILE *file, overloaded_name *oname)\n+{\n+  fprintf (file, \"\\nextern insn_code maybe_code_for_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%s%s\", i == 0 ? \"\" : \", \", oname->arg_types[i]);\n+  fprintf (file, \");\\n\");\n+\n+  fprintf (file, \"inline insn_code\\ncode_for_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%s%s arg%d\", i == 0 ? \"\" : \", \", oname->arg_types[i], i);\n+  fprintf (file, \")\\n{\\n  insn_code code = maybe_code_for_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%sarg%d\", i == 0 ? \"\" : \", \", i);\n+  fprintf (file,\n+\t   \");\\n\"\n+\t   \"  gcc_assert (code != CODE_FOR_nothing);\\n\"\n+\t   \"  return code;\\n\"\n+\t   \"}\\n\");\n+}\n+\n+/* Declare the maybe_gen_* function for ONAME, and provide\n+   an inline definition of the assserting gen_* wrapper.  */\n+\n+static void\n+handle_overloaded_gen (FILE *file, overloaded_name *oname)\n+{\n+  pattern_stats stats;\n+  get_pattern_stats (&stats, XVEC (oname->first_instance->insn, 1));\n+\n+  fprintf (file, \"\\nextern rtx maybe_gen_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%s%s\", i == 0 ? \"\" : \", \", oname->arg_types[i]);\n+  for (int i = 0; i < stats.num_generator_args; ++i)\n+    fprintf (file, \", rtx\");\n+  fprintf (file, \");\\n\");\n+\n+  fprintf (file, \"inline rtx\\ngen_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%s%s arg%d\", i == 0 ? \"\" : \", \", oname->arg_types[i], i);\n+  for (int i = 0; i < stats.num_generator_args; ++i)\n+    fprintf (file, \", rtx x%d\", i);\n+  fprintf (file, \")\\n{\\n  rtx res = maybe_gen_%s (\", oname->name);\n+  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+    fprintf (file, \"%sarg%d\", i == 0 ? \"\" : \", \", i);\n+  for (int i = 0; i < stats.num_generator_args; ++i)\n+    fprintf (file, \", x%d\", i);\n+  fprintf (file,\n+\t   \");\\n\"\n+\t   \"  gcc_assert (res);\\n\"\n+\t   \"  return res;\\n\"\n+\t   \"}\\n\");\n+}\n+\n int\n main (int argc, const char **argv)\n {\n@@ -220,7 +277,16 @@ main (int argc, const char **argv)\n \t   \"optab_to_code (optab op)\\n\"\n \t   \"{\\n\"\n \t   \"  return optab_to_code_[op];\\n\"\n-\t   \"}\\n\"\n+\t   \"}\\n\");\n+\n+  for (overloaded_name *oname = rtx_reader_ptr->get_overloads ();\n+       oname; oname = oname->next)\n+    {\n+      handle_overloaded_code_for (h_file, oname);\n+      handle_overloaded_gen (h_file, oname);\n+    }\n+\n+  fprintf (h_file,\n \t   \"#endif\\n\"\n \t   \"\\n\"\n \t   \"extern const struct convert_optab_libcall_d convlib_def[NUM_CONVLIB_OPTABS];\\n\""}, {"sha": "174e471a8dbad78dace4915389de4a011c4a24e3", "filename": "gcc/read-md.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -1003,7 +1003,10 @@ md_reader::md_reader (bool compact)\n   m_first_dir_md_include (NULL),\n   m_last_dir_md_include_ptr (&m_first_dir_md_include),\n   m_first_line (0),\n-  m_last_line (0)\n+  m_last_line (0),\n+  m_first_overload (NULL),\n+  m_next_overload_ptr (&m_first_overload),\n+  m_overloads_htab (NULL)\n {\n   /* Set the global singleton pointer.  */\n   md_reader_ptr = this;"}, {"sha": "56d54314f113ce8e4655b3900aca6df964869cfd", "filename": "gcc/read-md.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -91,6 +91,48 @@ struct enum_type {\n   unsigned int num_values;\n };\n \n+/* Describes one instance of an overloaded_name.  */\n+struct overloaded_instance {\n+  /* The next instance in the chain, or null if none.  */\n+  overloaded_instance *next;\n+\n+  /* The values that the overloaded_name arguments should have for this\n+     instance to be chosen.  Each value is a C token.  */\n+  vec<const char *> arg_values;\n+\n+  /* The full (non-overloaded) name of the pattern.  */\n+  const char *name;\n+\n+  /* The corresponding define_expand or define_insn.  */\n+  rtx insn;\n+};\n+\n+/* Describes a define_expand or define_insn whose name was preceded by '@'.\n+   Overloads are uniquely determined by their name and the types of their\n+   arguments; it's possible to have overloads with the same name but\n+   different argument types.  */\n+struct overloaded_name {\n+  /* The next overloaded name in the chain.  */\n+  overloaded_name *next;\n+\n+  /* The overloaded name (i.e. the name with \"@\" character and\n+     \"<...>\" placeholders removed).  */\n+  const char *name;\n+\n+  /* The C types of the iterators that determine the underlying pattern,\n+     in the same order as in the pattern name.  E.g. \"<mode>\" in the\n+     pattern name would give a \"machine_mode\" argument here.  */\n+  vec<const char *> arg_types;\n+\n+  /* The first instance associated with this overloaded_name.  */\n+  overloaded_instance *first_instance;\n+\n+  /* Where to chain new overloaded_instances.  */\n+  overloaded_instance **next_instance_ptr;\n+};\n+\n+struct mapping;\n+\n /* A class for reading .md files and RTL dump files.\n \n    Implemented in read-md.c.\n@@ -165,6 +207,7 @@ class md_reader\n \t\t\t\t      rtx x, unsigned int index,\n \t\t\t\t      const char *name);\n   struct mapping *read_mapping (struct iterator_group *group, htab_t table);\n+  overloaded_name *handle_overloaded_name (rtx, vec<mapping *> *);\n \n   const char *get_top_level_filename () const { return m_toplevel_fname; }\n   const char *get_filename () const { return m_read_md_filename; }\n@@ -174,6 +217,8 @@ class md_reader\n   struct obstack *get_string_obstack () { return &m_string_obstack; }\n   htab_t get_md_constants () { return m_md_constants; }\n \n+  overloaded_name *get_overloads () const { return m_first_overload; }\n+\n  private:\n   /* A singly-linked list of filenames.  */\n   struct file_name_list {\n@@ -253,6 +298,16 @@ class md_reader\n   /* If non-zero, filter the input to just this subset of lines.  */\n   int m_first_line;\n   int m_last_line;\n+\n+  /* The first overloaded_name.  */\n+  overloaded_name *m_first_overload;\n+\n+  /* Where to chain further overloaded_names,  */\n+  overloaded_name **m_next_overload_ptr;\n+\n+  /* A hash table of overloaded_names, keyed off their name and the types of\n+     their arguments.  */\n+  htab_t m_overloads_htab;\n };\n \n /* Global singleton; constrast with rtx_reader_ptr below.  */"}, {"sha": "723c3e174b55936501baa4943fdef20fa09ac47d", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 230, "deletions": 3, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0016d8d91cb2880e69be74efb44367b282577977/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=0016d8d91cb2880e69be74efb44367b282577977", "patch": "@@ -72,6 +72,9 @@ struct iterator_group {\n      iterators.  */\n   htab_t attrs, iterators;\n \n+  /* The C++ type of the iterator, such as \"machine_mode\" for modes.  */\n+  const char *type;\n+\n   /* Treat the given string as the name of a standard mode, etc., and\n      return its integer value.  */\n   int (*find_builtin) (const char *);\n@@ -80,6 +83,9 @@ struct iterator_group {\n      If the iterator applies to operands, the second argument gives the\n      operand index, otherwise it is ignored.  */\n   void (*apply_iterator) (rtx, unsigned int, int);\n+\n+  /* Return the C token for the given standard mode, code, etc.  */\n+  const char *(*get_c_token) (int);\n };\n \n /* Records one use of an iterator.  */\n@@ -163,6 +169,12 @@ apply_mode_iterator (rtx x, unsigned int, int mode)\n   PUT_MODE (x, (machine_mode) mode);\n }\n \n+static const char *\n+get_mode_token (int mode)\n+{\n+  return concat (\"E_\", GET_MODE_NAME (mode), \"mode\", NULL);\n+}\n+\n /* In compact dumps, the code of insns is prefixed with \"c\", giving \"cinsn\",\n    \"cnote\" etc, and CODE_LABEL is special-cased as \"clabel\".  */\n \n@@ -206,6 +218,15 @@ apply_code_iterator (rtx x, unsigned int, int code)\n   PUT_CODE (x, (enum rtx_code) code);\n }\n \n+static const char *\n+get_code_token (int code)\n+{\n+  char *name = xstrdup (GET_RTX_NAME (code));\n+  for (int i = 0; name[i]; ++i)\n+    name[i] = TOUPPER (name[i]);\n+  return name;\n+}\n+\n /* Implementations of the iterator_group callbacks for ints.  */\n \n /* Since GCC does not construct a table of valid constants,\n@@ -228,6 +249,14 @@ apply_int_iterator (rtx x, unsigned int index, int value)\n     XINT (x, index) = value;\n }\n \n+static const char *\n+get_int_token (int value)\n+{\n+  char buffer[HOST_BITS_PER_INT + 1];\n+  sprintf (buffer, \"%d\", value);\n+  return xstrdup (buffer);\n+}\n+\n #ifdef GENERATOR_FILE\n \n /* This routine adds attribute or does nothing depending on VALUE.  When\n@@ -317,10 +346,11 @@ find_subst_iter_by_attr (const char *attr)\n }\n \n /* Map attribute string P to its current value.  Return null if the attribute\n-   isn't known.  */\n+   isn't known.  If ITERATOR_OUT is nonnull, store the associated iterator\n+   there.  */\n \n static struct map_value *\n-map_attr_string (const char *p)\n+map_attr_string (const char *p, mapping **iterator_out = 0)\n {\n   const char *attr;\n   struct mapping *iterator;\n@@ -369,7 +399,11 @@ map_attr_string (const char *p)\n \t     iterator value.  */\n \t  for (v = m->values; v; v = v->next)\n \t    if (v->number == iterator->current_value->number)\n-\t      return v;\n+\t      {\n+\t\tif (iterator_out)\n+\t\t  *iterator_out = iterator;\n+\t\treturn v;\n+\t      }\n \t}\n     }\n   return NULL;\n@@ -545,6 +579,178 @@ add_current_iterators (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n+/* Return a hash value for overloaded_name UNCAST_ONAME.  There shouldn't\n+   be many instances of two overloaded_names having the same name but\n+   different arguments, so hashing on the name should be good enough in\n+   practice.  */\n+\n+static hashval_t\n+overloaded_name_hash (const void *uncast_oname)\n+{\n+  const overloaded_name *oname = (const overloaded_name *) uncast_oname;\n+  return htab_hash_string (oname->name);\n+}\n+\n+/* Return true if two overloaded_names are similar enough to share\n+   the same generated functions.  */\n+\n+static int\n+overloaded_name_eq_p (const void *uncast_oname1, const void *uncast_oname2)\n+{\n+  const overloaded_name *oname1 = (const overloaded_name *) uncast_oname1;\n+  const overloaded_name *oname2 = (const overloaded_name *) uncast_oname2;\n+  if (strcmp (oname1->name, oname2->name) != 0\n+      || oname1->arg_types.length () != oname2->arg_types.length ())\n+    return 0;\n+\n+  for (unsigned int i = 0; i < oname1->arg_types.length (); ++i)\n+    if (strcmp (oname1->arg_types[i], oname2->arg_types[i]) != 0)\n+      return 0;\n+\n+  return 1;\n+}\n+\n+/* Return true if X has an instruction name in XSTR (X, 0).  */\n+\n+static bool\n+named_rtx_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case DEFINE_EXPAND:\n+    case DEFINE_INSN:\n+    case DEFINE_INSN_AND_SPLIT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Check whether ORIGINAL is a named pattern whose name starts with '@'.\n+   If so, return the associated overloaded_name and add the iterator for\n+   each argument to ITERATORS.  Return null otherwise.  */\n+\n+overloaded_name *\n+md_reader::handle_overloaded_name (rtx original, vec<mapping *> *iterators)\n+{\n+  /* Check for the leading '@'.  */\n+  if (!named_rtx_p (original) || XSTR (original, 0)[0] != '@')\n+    return NULL;\n+\n+  /* Remove the '@', so that no other code needs to worry about it.  */\n+  const char *name = XSTR (original, 0);\n+  copy_md_ptr_loc (name + 1, name);\n+  name += 1;\n+  XSTR (original, 0) = name;\n+\n+  /* Build a copy of the name without the '<...>' attribute strings.\n+     Add the iterator associated with each such attribute string to ITERATORS\n+     and add an associated argument to TMP_ONAME.  */\n+  char *copy = ASTRDUP (name);\n+  char *base = copy, *start, *end;\n+  overloaded_name tmp_oname;\n+  tmp_oname.arg_types.create (current_iterators.length ());\n+  bool pending_underscore_p = false;\n+  while ((start = strchr (base, '<')) && (end = strchr (start, '>')))\n+    {\n+      *end = 0;\n+      mapping *iterator;\n+      if (!map_attr_string (start + 1, &iterator))\n+\tfatal_with_file_and_line (\"unknown iterator `%s'\", start + 1);\n+      *end = '>';\n+\n+      /* Remove a trailing underscore, so that we don't end a name\n+\t with \"_\" or turn \"_<...>_\" into \"__\".  */\n+      if (start != base && start[-1] == '_')\n+\t{\n+\t  start -= 1;\n+\t  pending_underscore_p = true;\n+\t}\n+\n+      /* Add the text between either the last '>' or the start of\n+\t the string and this '<'.  */\n+      obstack_grow (&m_string_obstack, base, start - base);\n+      base = end + 1;\n+\n+      /* If there's a character we need to keep after the '>', check\n+\t whether we should prefix it with a previously-dropped '_'.  */\n+      if (base[0] != 0 && base[0] != '<')\n+\t{\n+\t  if (pending_underscore_p && base[0] != '_')\n+\t    obstack_1grow (&m_string_obstack, '_');\n+\t  pending_underscore_p = false;\n+\t}\n+\n+      /* Record an argument for ITERATOR.  */\n+      iterators->safe_push (iterator);\n+      tmp_oname.arg_types.safe_push (iterator->group->type);\n+    }\n+  if (base == copy)\n+    fatal_with_file_and_line (\"no iterator attributes in name `%s'\", name);\n+\n+  size_t length = obstack_object_size (&m_string_obstack);\n+  if (length == 0)\n+    fatal_with_file_and_line (\"`%s' only contains iterator attributes\", name);\n+\n+  /* Get the completed name.  */\n+  obstack_grow (&m_string_obstack, base, strlen (base) + 1);\n+  char *new_name = XOBFINISH (&m_string_obstack, char *);\n+  tmp_oname.name = new_name;\n+\n+  if (!m_overloads_htab)\n+    m_overloads_htab = htab_create (31, overloaded_name_hash,\n+\t\t\t\t    overloaded_name_eq_p, NULL);\n+\n+  /* See whether another pattern had the same overload name and list\n+     of argument types.  Create a new permanent one if not.  */\n+  void **slot = htab_find_slot (m_overloads_htab, &tmp_oname, INSERT);\n+  overloaded_name *oname = (overloaded_name *) *slot;\n+  if (!oname)\n+    {\n+      *slot = oname = new overloaded_name;\n+      oname->name = tmp_oname.name;\n+      oname->arg_types = tmp_oname.arg_types;\n+      oname->next = NULL;\n+      oname->first_instance = NULL;\n+      oname->next_instance_ptr = &oname->first_instance;\n+\n+      *m_next_overload_ptr = oname;\n+      m_next_overload_ptr = &oname->next;\n+    }\n+  else\n+    {\n+      obstack_free (&m_string_obstack, new_name);\n+      tmp_oname.arg_types.release ();\n+    }\n+\n+  return oname;\n+}\n+\n+/* Add an instance of ONAME for instruction pattern X.  ITERATORS[I]\n+   gives the iterator associated with argument I of ONAME.  */\n+\n+static void\n+add_overload_instance (overloaded_name *oname, vec<mapping *> iterators, rtx x)\n+{\n+  /* Create the instance.  */\n+  overloaded_instance *instance = new overloaded_instance;\n+  instance->next = NULL;\n+  instance->arg_values.create (oname->arg_types.length ());\n+  for (unsigned int i = 0; i < iterators.length (); ++i)\n+    {\n+      int value = iterators[i]->current_value->number;\n+      const char *name = iterators[i]->group->get_c_token (value);\n+      instance->arg_values.quick_push (name);\n+    }\n+  instance->name = XSTR (x, 0);\n+  instance->insn = x;\n+\n+  /* Chain it onto the end of ONAME's list.  */\n+  *oname->next_instance_ptr = instance;\n+  oname->next_instance_ptr = &instance->next;\n+}\n+\n /* Expand all iterators in the current rtx, which is given as ORIGINAL.\n    Build a list of expanded rtxes in the EXPR_LIST pointed to by QUEUE.  */\n \n@@ -562,6 +768,10 @@ apply_iterators (rtx original, vec<rtx> *queue)\n     {\n       /* Raise an error if any attributes were used.  */\n       apply_attribute_uses ();\n+\n+      if (named_rtx_p (original) && XSTR (original, 0)[0] == '@')\n+\tfatal_with_file_and_line (\"'@' used without iterators\");\n+\n       queue->safe_push (original);\n       return;\n     }\n@@ -583,6 +793,11 @@ apply_iterators (rtx original, vec<rtx> *queue)\n   htab_traverse (substs.iterators, add_current_iterators, NULL);\n   gcc_assert (!current_iterators.is_empty ());\n \n+  /* Check whether this is a '@' overloaded pattern.  */\n+  auto_vec<mapping *, 16> iterators;\n+  overloaded_name *oname\n+    = rtx_reader_ptr->handle_overloaded_name (original, &iterators);\n+\n   for (;;)\n     {\n       /* Apply the current iterator values.  Accumulate a condition to\n@@ -616,6 +831,10 @@ apply_iterators (rtx original, vec<rtx> *queue)\n \t\t\t\t\t\t     v->number);\n \t    }\n \t}\n+\n+      if (oname)\n+\tadd_overload_instance (oname, iterators, x);\n+\n       /* Add the new rtx to the end of the queue.  */\n       queue->safe_push (x);\n \n@@ -692,28 +911,36 @@ initialize_iterators (void)\n   modes.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   modes.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n+  modes.type = \"machine_mode\";\n   modes.find_builtin = find_mode;\n   modes.apply_iterator = apply_mode_iterator;\n+  modes.get_c_token = get_mode_token;\n \n   codes.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   codes.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n+  codes.type = \"rtx_code\";\n   codes.find_builtin = find_code;\n   codes.apply_iterator = apply_code_iterator;\n+  codes.get_c_token = get_code_token;\n \n   ints.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   ints.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n+  ints.type = \"int\";\n   ints.find_builtin = find_int;\n   ints.apply_iterator = apply_int_iterator;\n+  ints.get_c_token = get_int_token;\n \n   substs.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   substs.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n+  substs.type = \"int\";\n   substs.find_builtin = find_int; /* We don't use it, anyway.  */\n #ifdef GENERATOR_FILE\n   substs.apply_iterator = apply_subst_iterator;\n #endif\n+  substs.get_c_token = get_int_token;\n \n   lower = add_mapping (&modes, modes.attrs, \"mode\");\n   upper = add_mapping (&modes, modes.attrs, \"MODE\");"}]}