{"sha": "11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFiZGQyYWU0ZWZiZmYwMmRkNzQyMmZiMmM1ZWJlMzkzMzJmNjA0Ng==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "2000-02-14T19:34:06Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-02-14T19:34:06Z"}, "message": "basic_block.h: Added prototype for reorder_basic_blocks.\n\n        * basic_block.h: Added prototype for reorder_basic_blocks.\n        * toplev.c: Changes to add -freorder-blocks and graph dump after\n        block reordering is done.\n        * flow.c (reorder_block_def): New structure for use during block\n        reordering.\n        (REORDER_BLOCK_*): New macros to access members of above structure.\n        (skip_insns_between_block, get_common_dest, chain_reorder_blocks,\n        make_reorder_chain, fixup_reorder_chain, reorder_basic_blocks): New\n        functions for block reordering.\n\nCo-Authored-By: Jason Eckhardt <jle@cygnus.com>\n\nFrom-SVN: r31968", "tree": {"sha": "27e971c2faa13257681d20434189cf284da1ce3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27e971c2faa13257681d20434189cf284da1ce3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/comments", "author": null, "committer": null, "parents": [{"sha": "89bcce1b025dc9dcc9930d734398206402c2016a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89bcce1b025dc9dcc9930d734398206402c2016a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89bcce1b025dc9dcc9930d734398206402c2016a"}], "stats": {"total": 768, "additions": 768, "deletions": 0}, "files": [{"sha": "bbde8c05fd0c67b31f1266ed1882dc2520eb6c79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "patch": "@@ -1,3 +1,16 @@\n+Mon Feb 14 13:31:01 2000  Stan Cox  <scox@cygnus.com>\n+                          Jason Eckhardt  <jle@cygnus.com>\n+\n+\t* basic_block.h: Added prototype for reorder_basic_blocks.\n+\t* toplev.c: Changes to add -freorder-blocks and graph dump after\n+\tblock reordering is done.\n+\t* flow.c (reorder_block_def): New structure for use during block\n+\treordering.\n+\t(REORDER_BLOCK_*): New macros to access members of above structure.\n+\t(skip_insns_between_block, get_common_dest, chain_reorder_blocks,\n+\tmake_reorder_chain, fixup_reorder_chain, reorder_basic_blocks): New\n+\tfunctions for block reordering.\n+\n Mon Feb 14 11:24:44 2000  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* gcc.texi (Passes): Fix typo."}, {"sha": "5ecdb776b38550ebfca68c484d587a6fe99d8282", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "patch": "@@ -443,4 +443,8 @@ extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n /* In predict.c */\n extern void estimate_probability        PARAMS ((struct loops *));\n \n+/* In flow.c */\n+extern void reorder_basic_blocks\tPARAMS ((void));\n+\n+\n #endif /* _BASIC_BLOCK_H */"}, {"sha": "781a65737bc534556016a4efab9810611cf35455", "filename": "gcc/flow.c", "status": "modified", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "patch": "@@ -134,6 +134,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"insn-flags.h\"\n+#include \"expr.h\"\n \n #include \"obstack.h\"\n \n@@ -7006,3 +7007,716 @@ flow_loop_outside_edge_p (loop, e)\n   return (e->src == ENTRY_BLOCK_PTR)\n     || ! TEST_BIT (loop->nodes, e->src->index);\n }\n+\n+\n+\n+typedef struct reorder_block_def {\n+  int flags;\n+  int index;\n+  basic_block add_jump;\n+  edge succ;\n+  rtx end;\n+  int block_begin;\n+  int block_end;\n+} *reorder_block_def;\n+\n+#define REORDER_BLOCK_HEAD\t0x1\n+#define REORDER_BLOCK_VISITED\t0x2\n+#define REORDER_MOVED_BLOCK_END 0x3\n+  \n+#define REORDER_BLOCK_FLAGS(bb) \\\n+  ((reorder_block_def) (bb)->aux)->flags\n+\n+#define REORDER_BLOCK_INDEX(bb) \\\n+  ((reorder_block_def) (bb)->aux)->index\n+\n+#define REORDER_BLOCK_ADD_JUMP(bb) \\\n+  ((reorder_block_def) (bb)->aux)->add_jump\n+\n+#define REORDER_BLOCK_SUCC(bb) \\\n+  ((reorder_block_def) (bb)->aux)->succ\n+\n+#define REORDER_BLOCK_OLD_END(bb) \\\n+  ((reorder_block_def) (bb)->aux)->end\n+\n+#define REORDER_BLOCK_BEGIN(bb) \\\n+  ((reorder_block_def) (bb)->aux)->block_begin\n+\n+#define REORDER_BLOCK_END(bb) \\\n+  ((reorder_block_def) (bb)->aux)->block_end\n+\n+\n+static int reorder_index;\n+static basic_block reorder_last_visited;\n+\n+#define REORDER_SKIP_BEFORE 0x1\n+#define REORDER_SKIP_AFTER 0x2\n+#define REORDER_SKIP_BLOCK_END 0x3\n+\n+/* Skip over insns BEFORE or AFTER BB which are typically associated with\n+   basic block BB.  */\n+\n+static rtx\n+skip_insns_between_block (bb, skip_type)\n+     basic_block bb;\n+     int skip_type;\n+{\n+  rtx insn, last_insn;\n+\n+  if (skip_type == REORDER_SKIP_BEFORE)\n+    {\n+      if (bb == ENTRY_BLOCK_PTR)\n+\treturn 0;\n+      last_insn = bb->head;\n+      for (insn = PREV_INSN (bb->head);\n+\t   insn && insn != BASIC_BLOCK (bb->index - 1)->end;\n+\t   last_insn = insn, insn = PREV_INSN (insn))\n+\t{\n+\t  if (NEXT_INSN (insn) != last_insn)\n+\t    break;\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END)\n+\t    continue;\n+\t  \n+\t  break;\n+\t}\n+    }\n+  else if (skip_type == REORDER_SKIP_AFTER\n+\t   || skip_type == REORDER_SKIP_BLOCK_END)\n+    {\n+      last_insn = bb->end;\n+\n+      if (bb == EXIT_BLOCK_PTR)\n+\treturn 0;\n+\n+      for (insn = NEXT_INSN (bb->end); \n+\t   insn;\n+\t   last_insn = insn, insn = NEXT_INSN (insn))\n+\t{\n+\t  if (bb->index + 1 != n_basic_blocks\n+\t      && insn == BASIC_BLOCK (bb->index + 1)->head)\n+\t    break;\n+\n+\t  if (GET_CODE (insn) == BARRIER\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || (GET_CODE (insn) == NOTE\n+\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n+\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n+\t    continue;\n+\t  if (GET_CODE (insn) == CODE_LABEL\n+\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN\n+\t\t\t       (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  if (skip_type == REORDER_SKIP_BLOCK_END)\n+    {\n+      int found_block_end = 0;\n+\n+      for (; insn; last_insn = insn, insn = NEXT_INSN (insn))\n+\t{\n+\t  if (bb->index + 1 != n_basic_blocks\n+\t      && insn == BASIC_BLOCK (bb->index + 1)->head)\n+\t    break;\n+\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t    {\n+\t      found_block_end = 1;\n+\t      continue;\n+\t    }\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n+\t    continue;\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && NOTE_LINE_NUMBER (insn) >= 0\n+\t      && NEXT_INSN (insn)\n+\t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_BLOCK_END)\n+\t    continue;\n+\t  break;\n+\t}\n+      if (! found_block_end)\n+\tlast_insn = 0;\n+    }\n+  return last_insn;\n+}\n+\n+\n+/* Return common destination for blocks BB0 and BB1.  */\n+\n+static basic_block\n+get_common_dest (bb0, bb1)\n+     basic_block bb0, bb1;\n+{\n+  edge e0, e1;\n+\n+  for (e0 = bb0->succ; e0; e0 = e0->succ_next)\n+    {\n+      for (e1 = bb1->succ; e1; e1 = e1->succ_next)\n+\t{\n+\t  if (e0->dest == e1->dest)\n+\t    {\n+\t      return e0->dest;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* Move the destination block for edge E after chain end block CEB\n+   Adding jumps and labels is deferred until fixup_reorder_chain.  */\n+\n+static basic_block\n+chain_reorder_blocks (e, ceb)\n+     edge e;\n+     basic_block ceb;\n+{\n+  basic_block sb = e->src;\n+  basic_block db = e->dest;\n+  rtx cebe_insn, cebbe_insn, dbh_insn, dbe_insn;\n+  edge ee, last_edge;\n+\n+  enum cond_types {NO_COND, PREDICT_THEN_WITH_ELSE, PREDICT_ELSE,\n+\t\t   PREDICT_THEN_NO_ELSE, PREDICT_NOT_THEN_NO_ELSE};\n+  enum cond_types cond_type;\n+  enum cond_block_types {NO_COND_BLOCK, THEN_BLOCK, ELSE_BLOCK,\n+\t\t\t NO_ELSE_BLOCK};\n+  enum cond_block_types cond_block_type;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n+\t     sb->index, db->index, ceb->index);\n+\n+  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n+  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n+  cebbe_insn = skip_insns_between_block (ceb, REORDER_SKIP_BLOCK_END);\n+\n+  {\n+    int block_begins = 0;\n+    rtx insn;\n+\n+    for (insn = dbh_insn; insn && insn != db->end; insn = NEXT_INSN (insn))\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\t  {\n+\t    block_begins += 1;\n+\t    break;\n+\t  }\n+      }\n+    REORDER_BLOCK_BEGIN (sb) = block_begins;\n+  }\n+\n+  if (cebbe_insn)\n+    {\n+      int block_ends = 0;\n+      rtx insn;\n+\n+      for (insn = cebe_insn; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (PREV_INSN (insn) == cebbe_insn)\n+\t    break;\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t    {\n+\t      block_ends += 1;\n+\t      continue;\n+\t    }\n+\t}\n+      REORDER_BLOCK_END (ceb) = block_ends;\n+    }\n+\n+  /* Blocks are in original order.  */\n+  if (sb->index == ceb->index\n+      && ceb->index + 1 == db->index && NEXT_INSN (cebe_insn))\n+    return db;\n+\n+  /* Get the type of block and type of condition.  */\n+  cond_type = NO_COND;\n+  cond_block_type = NO_COND_BLOCK;\n+  if (GET_CODE (sb->end) == JUMP_INSN && ! simplejump_p (sb->end)\n+      && condjump_p (sb->end))\n+    {\n+      if (e->flags & EDGE_FALLTHRU)\n+\tcond_block_type = THEN_BLOCK;\n+      else if (get_common_dest (sb->succ->dest, sb))\n+\tcond_block_type = NO_ELSE_BLOCK;\n+      else \n+\tcond_block_type = ELSE_BLOCK;\n+\n+      if (sb->succ->succ_next\n+\t  && get_common_dest (sb->succ->dest, sb))\n+\t{\n+\t  if (cond_block_type == THEN_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_THEN_NO_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n+\t    }\n+\t  else if (cond_block_type == NO_ELSE_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_THEN_NO_ELSE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (cond_block_type == THEN_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_ELSE;\n+\t    }\n+\t  else if (cond_block_type == ELSE_BLOCK\n+\t\t   && sb->succ->dest != EXIT_BLOCK_PTR)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n+\t    }\n+\t}\n+    }\n+  \n+  if (rtl_dump_file)\n+    {\n+      static const char * cond_type_str [] = {\"not cond jump\", \"predict then\",\n+\t\t\t\t\t      \"predict else\",\n+\t\t\t\t\t      \"predict then w/o else\",\n+\t\t\t\t\t      \"predict not then w/o else\"};\n+      static const char * cond_block_type_str [] = {\"not then or else block\",\n+\t\t\t\t\t\t    \"then block\",\n+\t\t\t\t\t\t    \"else block\",\n+\t\t\t\t\t\t    \"then w/o else block\"};\n+\n+      fprintf (rtl_dump_file, \"     %s (looking at %s)\\n\",\n+\t       cond_type_str[(int)cond_type],\n+\t       cond_block_type_str[(int)cond_block_type]);\n+    }\n+\n+  /* Reflect that then block will move and we'll jump to it.  */\n+  if (cond_block_type != THEN_BLOCK\n+      && (cond_type == PREDICT_ELSE\n+\t  || cond_type == PREDICT_NOT_THEN_NO_ELSE))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"    then jump from block %d to block %d\\n\",\n+\t\t sb->index, sb->succ->dest->index);\n+\n+      /* Jump to reordered then block.  */\n+      REORDER_BLOCK_ADD_JUMP (sb) = sb->succ->dest;\n+    }\n+  \n+  /* Reflect that then block will jump back when we have no else.  */\n+  if (cond_block_type != THEN_BLOCK\n+      && cond_type == PREDICT_NOT_THEN_NO_ELSE)\n+    {\n+      for (ee = sb->succ->dest->succ;\n+\t   ee && ! (ee->flags & EDGE_FALLTHRU);\n+\t   ee = ee->succ_next)\n+\tcontinue;\n+\n+      if (ee && ! (GET_CODE (sb->succ->dest->end) == JUMP_INSN\n+\t\t   && ! simplejump_p (sb->succ->dest->end)))\n+\t{\n+\t  REORDER_BLOCK_ADD_JUMP (sb->succ->dest) = ee->dest;\n+\t}\n+    }\n+\n+  /* Reflect that else block will jump back.  */\n+  if (cond_block_type == ELSE_BLOCK\n+      && (cond_type == PREDICT_THEN_WITH_ELSE || cond_type == PREDICT_ELSE))\n+    {\n+      last_edge=db->succ;\n+\n+      if (last_edge\n+\t  && last_edge->dest != EXIT_BLOCK_PTR\n+\t  && GET_CODE (last_edge->dest->head) == CODE_LABEL\n+\t  && ! (GET_CODE (db->end) == JUMP_INSN))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"     else jump from block %d to block %d\\n\",\n+\t\t     db->index, last_edge->dest->index);\n+\n+\t  REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n+\t}\n+    }\n+\n+  /* This block's successor has already been reordered. This can happen\n+     when we reorder a chain starting at a then or else.  */\n+  for (last_edge = db->succ;\n+       last_edge && ! (last_edge->flags & EDGE_FALLTHRU);\n+       last_edge = last_edge->succ_next)\n+    continue;\n+\n+  if (last_edge\n+      && last_edge->dest != EXIT_BLOCK_PTR\n+      && (REORDER_BLOCK_FLAGS (last_edge->dest)\n+\t  & REORDER_BLOCK_VISITED))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"     end of chain jump from block %d to block %d\\n\",\n+\t\t db->index, last_edge->dest->index);\n+\n+      REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n+    }\n+\n+  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n+  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n+  dbe_insn = skip_insns_between_block (db, REORDER_SKIP_AFTER);\n+\n+  /* Leave behind any lexical block markers.  */\n+  if (debug_info_level > DINFO_LEVEL_TERSE\n+      && ceb->index + 1 < db->index)\n+    {\n+      rtx insn, last_insn = get_last_insn ();\n+      insn = NEXT_INSN (ceb->end);\n+      if (! insn)\n+\tinsn = REORDER_BLOCK_OLD_END (ceb);\n+\n+      if (NEXT_INSN (cebe_insn) == 0)\n+\t  set_last_insn (cebe_insn);\n+      for (; insn && insn != db->head/*dbh_insn*/;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG))\n+\t    {\n+\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_BEG, cebe_insn);\n+\t      delete_insn (insn);\n+\t    }\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+\t    {\n+\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_END, cebe_insn);\n+\t      delete_insn (insn);\n+\t    }      \n+\t}\n+      set_last_insn (last_insn);\n+    }\n+\n+  /* Rechain predicted block.  */\n+  NEXT_INSN (cebe_insn) = dbh_insn;\n+  PREV_INSN (dbh_insn) = cebe_insn;\n+\n+  REORDER_BLOCK_OLD_END (db) = NEXT_INSN (dbe_insn);\n+  if (db->index != n_basic_blocks - 1)\n+    NEXT_INSN (dbe_insn) = 0;\n+\n+  return db;\n+}\n+\n+\n+/* Reorder blocks starting at block B.  */\n+\n+static void\n+make_reorder_chain (bb)\n+     basic_block bb;\n+{\n+  edge e;\n+  basic_block visited_edge = NULL;\n+  rtx block_end;\n+  int probability;\n+\n+  if (bb == EXIT_BLOCK_PTR)\n+    return;\n+\n+  /* Find the most probable block.  */\n+  e = bb->succ;\n+  block_end = bb->end;\n+  if (GET_CODE (block_end) == JUMP_INSN && condjump_p (block_end))\n+    {\n+      rtx note = find_reg_note (block_end, REG_BR_PROB, 0);\n+\n+      if (note) \n+\tprobability = XINT (XEXP (note, 0), 0);\n+      else\n+\tprobability = 0;\n+\n+      if (probability >= REG_BR_PROB_BASE / 2)\n+\te = bb->succ->succ_next;\n+    }\n+\n+  /* Add chosen successor to chain and recurse on it.  */\n+  if (e && e->dest != EXIT_BLOCK_PTR\n+      && e->dest != e->src\n+      && (! (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n+\t  || (REORDER_BLOCK_FLAGS (e->dest) == REORDER_BLOCK_HEAD)))\n+    {\n+      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n+\t{\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_HEAD;\n+\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n+\t}\n+\n+      if (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n+\tREORDER_BLOCK_FLAGS (e->dest) &= ~REORDER_BLOCK_HEAD;\n+\t\n+      REORDER_BLOCK_SUCC (bb) = e;\n+\n+      visited_edge = e->dest;\n+\n+      reorder_last_visited = chain_reorder_blocks (e, bb);\n+\n+      if (e->dest\n+\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n+\t\t& REORDER_BLOCK_VISITED))\n+\tmake_reorder_chain (e->dest);\n+    }\n+  else\n+    {\n+      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n+\t{\n+\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n+\t}\n+    }\n+\n+  /* Recurse on the successors.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest && e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      if (e->dest\n+\t  && e->dest != e->src\n+\t  && e->dest != visited_edge\n+\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n+\t\t& REORDER_BLOCK_VISITED))\n+\t{\n+\t  reorder_last_visited\n+\t    = chain_reorder_blocks (e, reorder_last_visited);\n+\t  make_reorder_chain (e->dest);\n+\t}\n+    }\n+}\n+\n+\n+/* Fixup jumps and labels after reordering basic blocks.  */ \n+\n+static void\n+fixup_reorder_chain ()\n+{\n+  int i, j;\n+  rtx insn;\n+\n+  /* Set the new last insn.  */\n+  for (i = 0;\n+       i < n_basic_blocks - 1\n+\t && REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) != n_basic_blocks;\n+       i++)\n+    continue;\n+\n+  for (insn = BASIC_BLOCK (i)->head;\n+       NEXT_INSN (insn) != 0;\n+       insn = NEXT_INSN (insn))\n+    continue;\n+\n+  set_last_insn (insn);\n+\n+  /* Add jumps and labels to fixup blocks.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      if (REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i)))\n+\t{\n+\t  rtx new_label = gen_label_rtx ();\n+\t  rtx label_insn, jump_insn, barrier_insn;\n+\n+\t  label_insn = emit_label_before (new_label,\n+\t\t\t  REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i))->head);\n+\t  REORDER_BLOCK_ADD_JUMP (BASIC_BLOCK (i))->head = label_insn;\t \n+\n+\t  jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n+\t\t\t\t\t    BASIC_BLOCK (i)->end);\n+\t  JUMP_LABEL (jump_insn) = label_insn;\n+\t  ++LABEL_NUSES (label_insn);\n+\t  barrier_insn = emit_barrier_after (jump_insn);\n+\t  if (GET_CODE (BASIC_BLOCK (i)->end) != JUMP_INSN)\n+\t    BASIC_BLOCK (i)->end = barrier_insn;\n+\t  /* Add block for jump.  Typically this is when a then is not\n+\t     predicted and we are jumping to the moved then block.  */\n+\t  else\t\n+\t    {\n+\t      basic_block b;\n+\n+\t      b = (basic_block) obstack_alloc (function_obstack, sizeof (*b));\n+\t      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\t      BASIC_BLOCK (n_basic_blocks - 1) = b;\n+\t      b->index = n_basic_blocks - 1;\n+\t      b->head = emit_note_before (NOTE_INSN_BASIC_BLOCK, jump_insn);\n+\t      NOTE_BASIC_BLOCK (b->head) = b;\n+\t      b->end = barrier_insn;\n+\t      \n+\t      {\n+\t\tbasic_block nb = BASIC_BLOCK (n_basic_blocks - 1);\n+\t\tnb->global_live_at_start\n+\t\t  = OBSTACK_ALLOC_REG_SET (function_obstack);\n+\t\tnb->global_live_at_end\n+\t\t  = OBSTACK_ALLOC_REG_SET (function_obstack);\n+\n+\t\tCOPY_REG_SET (nb->global_live_at_start,\n+\t\t\t      BASIC_BLOCK (i)->global_live_at_start);\n+\t\tCOPY_REG_SET (nb->global_live_at_end,\n+\t\t\t      BASIC_BLOCK (i)->global_live_at_start);\n+\t\tif (BASIC_BLOCK (i)->local_set)\n+\t\t  {\n+\t\t    OBSTACK_ALLOC_REG_SET (function_obstack);\n+\t\t    COPY_REG_SET (nb->local_set, BASIC_BLOCK (i)->local_set);\n+\t\t  }\n+\t\telse\n+\t\t  BASIC_BLOCK (nb->index)->local_set = 0;\n+\n+\t\tnb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+\t\tREORDER_BLOCK_INDEX (BASIC_BLOCK (n_basic_blocks - 1))\n+\t\t  = REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) + 1;\n+\t\t/* Relink to new block.  */\n+\t\tnb->succ = BASIC_BLOCK (i)->succ;\n+\n+\t\tmake_edge (0, BASIC_BLOCK (i), nb, 0);\n+\t\tBASIC_BLOCK (i)->succ->succ_next\n+\t\t  = BASIC_BLOCK (i)->succ->succ_next->succ_next;\n+\t\tnb->succ->succ_next = 0;\n+\t\t/* Fix reorder block index to reflect new block.  */\n+\t\tfor (j = 0; j < n_basic_blocks - 1; j++)\n+\t\t  {\n+\t\t    basic_block bbj = BASIC_BLOCK (j);\n+\t\t    basic_block bbi = BASIC_BLOCK (i);\n+\t\t    if (REORDER_BLOCK_INDEX (bbj)\n+\t\t\t>= REORDER_BLOCK_INDEX (bbi) + 1)\n+\t\t      REORDER_BLOCK_INDEX (bbj)++;\n+\t\t  }\n+\t      }\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Reorder basic blocks.  */\n+\n+void\n+reorder_basic_blocks ()\n+{\n+  int i, j;\n+  struct loops loops_info;\n+  int num_loops;\n+  rtx last_insn;\n+\n+  if (profile_arc_flag)\n+    return;\n+\n+  if (n_basic_blocks <= 1)\n+    return;\n+\n+  /* Exception edges are not currently handled.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      edge e;\n+\n+      for (e = BASIC_BLOCK (i)->succ; e && ! (e->flags & EDGE_EH);\n+\t   e = e->succ_next)\n+\tcontinue;\n+\n+      if (e && (e->flags & EDGE_EH))\n+\treturn;\n+    }\n+\n+  reorder_index = 0;\n+\n+  /* Find natural loops using the CFG.  */\n+  num_loops = flow_loops_find (&loops_info);\n+\n+  /* Dump loop information.  */\n+  flow_loops_dump (&loops_info, rtl_dump_file, 0);\n+\n+  /* Estimate using heuristics if no profiling info is available.  */\n+  if (! flag_branch_probabilities)\n+    estimate_probability (&loops_info);\n+\n+  reorder_last_visited = BASIC_BLOCK (0);\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+    }\n+      \n+  last_insn\n+    = NEXT_INSN (skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n+\t\t\t\t\t   REORDER_SKIP_AFTER));\n+\n+  make_reorder_chain (BASIC_BLOCK (0));\n+\n+  fixup_reorder_chain ();\n+\n+#ifdef ENABLE_CHECKING\n+    {\n+      rtx insn, last_insn;\n+      last_insn = get_insns ();\n+      for (insn = NEXT_INSN (get_insns ());\n+\t   insn && PREV_INSN (insn) == last_insn\n+\t     && NEXT_INSN (PREV_INSN (insn)) == insn;\n+\t   last_insn = insn,\n+\t     insn = NEXT_INSN (insn))\n+\tcontinue;\n+\n+      if (insn)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"insn chaining error at %d\\n\",\n+\t\t     INSN_UID (last_insn));\n+\t  abort();\n+\t}\n+    }\n+#endif\n+\n+  /* Put basic_block_info in new order.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      for (j = i; i != REORDER_BLOCK_INDEX (BASIC_BLOCK (j)); j++)\n+\tcontinue;\n+\n+      if (REORDER_BLOCK_INDEX (BASIC_BLOCK (j)) == i\n+\t  && i != j)\n+\t{\n+\t  basic_block tempbb;\n+\t  int temprbi;\n+\t  int rbi = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n+\n+\t  temprbi = BASIC_BLOCK (rbi)->index;\n+\t  BASIC_BLOCK (rbi)->index = BASIC_BLOCK (j)->index;\n+\t  BASIC_BLOCK (j)->index = temprbi;\n+\t  tempbb = BASIC_BLOCK (rbi);\n+\t  BASIC_BLOCK (rbi) = BASIC_BLOCK (j);\n+\t  BASIC_BLOCK (j) = tempbb;\n+\t}\n+    }\n+      \n+  NEXT_INSN (BASIC_BLOCK (n_basic_blocks - 1)->end) = last_insn;\n+\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      free (BASIC_BLOCK (i)->aux);\n+    }\n+\n+  /* Free loop information.  */\n+  flow_loops_free (&loops_info);\n+}\n+"}, {"sha": "7a3d02b118328cc873abbf1f39f01abf3811c2d4", "filename": "gcc/toplev.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bdd2ae4efbff02dd7422fb2c5ebe39332f6046/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=11bdd2ae4efbff02dd7422fb2c5ebe39332f6046", "patch": "@@ -249,6 +249,7 @@ int jump2_opt_dump = 0;\n #ifdef DELAY_SLOTS\n int dbr_sched_dump = 0;\n #endif\n+int reorder_blocks_dump = 0;\n int flag_print_asm_name = 0;\n #ifdef STACK_REGS\n int stack_reg_dump = 0;\n@@ -351,6 +352,10 @@ int flag_test_coverage = 0;\n \n int flag_branch_probabilities = 0;\n \n+/* Nonzero if basic blocks should be reordered. */\n+\n+int flag_reorder_blocks = 0;\n+\n /* Nonzero for -pedantic switch: warn about anything\n    that standard spec forbids.  */\n \n@@ -936,6 +941,8 @@ lang_independent_options f_options[] =\n    \"Create data files needed by gcov\" },\n   {\"branch-probabilities\", &flag_branch_probabilities, 1,\n    \"Use profiling information for branch probabilities\" },\n+  {\"reorder-blocks\", &flag_reorder_blocks, 1,\n+   \"Reorder basic blocks to improve code placement\" },\n   {\"fast-math\", &flag_fast_math, 1,\n    \"Improve FP speed by violating ANSI & IEEE rules\" },\n   {\"common\", &flag_no_common, 0,\n@@ -1329,6 +1336,7 @@ int flow2_time;\n int peephole2_time;\n int sched2_time;\n int dbr_sched_time;\n+int reorder_blocks_time;\n int shorten_branch_time;\n int stack_reg_time;\n int final_time;\n@@ -2022,6 +2030,7 @@ compile_file (name)\n   peephole2_time = 0;\n   sched2_time = 0;\n   dbr_sched_time = 0;\n+  reorder_blocks_time = 0;\n   shorten_branch_time = 0;\n   stack_reg_time = 0;\n   final_time = 0;\n@@ -2173,6 +2182,12 @@ compile_file (name)\n \tclean_graph_dump_file (dump_base_name, \".16.sched2\");\n     }\n #endif\n+  if (reorder_blocks_dump)\n+    {\n+      clean_dump_file (\".bbro\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".bbro\");\n+    }\n   if (jump2_opt_dump)\n     {\n       clean_dump_file (\".17.jump2\");\n@@ -2555,6 +2570,8 @@ compile_file (name)\n       if (sched2_dump)\n \tfinish_graph_dump_file (dump_base_name, \".16.sched2\");\n #endif\n+      if (reorder_blocks_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".bbro\");\n       if (jump2_opt_dump)\n \tfinish_graph_dump_file (dump_base_name, \".17.jump2\");\n #ifdef MACHINE_DEPENDENT_REORG\n@@ -2608,6 +2625,7 @@ compile_file (name)\n #ifdef DELAY_SLOTS\n       print_time (\"dbranch\", dbr_sched_time);\n #endif\n+      print_time (\"bbro\", reorder_blocks_time);\n       print_time (\"shorten-branch\", shorten_branch_time);\n #ifdef STACK_REGS\n       print_time (\"stack-reg\", stack_reg_time);\n@@ -3485,6 +3503,21 @@ rest_of_compilation (decl)\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n+  if (optimize > 0 && flag_reorder_blocks)\n+    {\n+      if (reorder_blocks_dump)\n+\topen_dump_file (\".bbro\", decl_printable_name (decl, 2));\n+\n+      TIMEVAR (reorder_blocks_time, reorder_basic_blocks ());\n+\n+      if (reorder_blocks_dump)\n+\t{\n+\t  close_dump_file (print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".bbro\", insns);\n+\t}\n+    }    \n+\n   /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n      Also do cross-jumping this time and delete no-op move insns.  */\n \n@@ -3889,6 +3922,7 @@ decode_d_option (arg)\n #ifdef DELAY_SLOTS\n \tdbr_sched_dump = 1;\n #endif\n+\treorder_blocks_dump = 1;\n \tflow_dump = 1;\n \tflow2_dump = 1;\n \tglobal_reg_dump = 1;\n@@ -3918,6 +3952,9 @@ decode_d_option (arg)\n       case 'b':\n \tbranch_prob_dump = 1;\n \tbreak;\n+      case 'B':\n+\treorder_blocks_dump = 1;\n+\tbreak;\n       case 'c':\n \tcombine_dump = 1;\n \tbreak;"}]}