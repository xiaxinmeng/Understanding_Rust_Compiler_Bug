{"sha": "f95361c8d027d09c645acba94a585c04a2486287", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk1MzYxYzhkMDI3ZDA5YzY0NWFjYmE5NGE1ODVjMDRhMjQ4NjI4Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-08-26T19:41:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-08-26T19:41:20Z"}, "message": "Major rework to have caller-saves emit load/store double insns when...\n\n\tMajor rework to have caller-saves emit load/store double insns when\n\tpossible and to avoid useless resaving of registers restored for\n\tsource accesses only.\n\t* caller-save.c (toplevel): All arrays are multi-dimensional to\n\thold information for multiple save/restore insns.  New variable\n\thard_regs_need_restore.\n\t(choose_hard_reg_mode): New argument `nregs' indicating how many\n\thard registers are desired.  All callers changed.\n\t(init_caller_save): Change initialization to handle multiple\n\tregister saves.  A call-used register can not be live across\n\tif we can not find a single register mode to save it in.\n\t(multiple register saves are optional)\n\t(init_save_areas): Change initialization of regno_save_mem to\n\thandle multiple register saves.\n\t(setup_save_areas): Allocate space for consecutive hard registers\n\tin aligned consecutive memory locations.   When allocating space\n\tfor consecutive hard registers, also initialize regno_save_mem\n\tfor each hard register stored as a single word.\n\t(save_call_clobbered_regs): Initialize hard_regs_need_restore.\n\tSet hard_regs_need_restore to hard_regs_saved after crossing\n\ta call.  Also recompute n_regs_saved.  At the end of a basic block\n\twe need only restore registers in hard_regs_need_restore.\n\t(set_reg_live, clear_reg_live): Do the right thing for\n\thard_regs_need_restore and hard_regs_saved.\n\t(restore_referenced_regs): Just return if X is a clobber.\n\tTest hard_regs_need_restore to determine when to restore a hard\n\tregister from the save area.\n\t(insert_save_restore): Now returns the number of extra registers\n\tsaved/restored.  New argument `maxrestore' which constrains how\n\tmany hard registers should be restored.  All callers changed.\n\tDo stores of consecutive registers with double store insns if\n\tpossible.  Else do them with single word insns. Likewise for\n\tloads, except constrained by maxrestore.  Set hard_regs_saved\n\tand hard_regs_need_restore appropriately to minimize useless\n\tsaves into the save area.  Test against\thard_regs_need_restore\n\twhen trying to restore multiple regs and similarly test against\n\thard_regs_saved when storing multiple regs.\n\nFrom-SVN: r1964", "tree": {"sha": "9f0dbd9c4362eb2f8bdf67191b74cf78d95533a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0dbd9c4362eb2f8bdf67191b74cf78d95533a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f95361c8d027d09c645acba94a585c04a2486287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95361c8d027d09c645acba94a585c04a2486287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95361c8d027d09c645acba94a585c04a2486287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95361c8d027d09c645acba94a585c04a2486287/comments", "author": null, "committer": null, "parents": [{"sha": "52d2830e7799bac04289afb5249b6d6920ecd018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d2830e7799bac04289afb5249b6d6920ecd018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d2830e7799bac04289afb5249b6d6920ecd018"}], "stats": {"total": 365, "additions": 272, "deletions": 93}, "files": [{"sha": "c0ebb27154e318d21b0e361e2e1351f346e4c731", "filename": "gcc/caller-save.c", "status": "modified", "additions": 272, "deletions": 93, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95361c8d027d09c645acba94a585c04a2486287/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95361c8d027d09c645acba94a585c04a2486287/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f95361c8d027d09c645acba94a585c04a2486287", "patch": "@@ -28,25 +28,30 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"reload.h\"\n #include \"expr.h\"\n \n-/* A mode for each hard register that we can save.  This mode is wide enough\n-   to save the entire contents of the register and will be used whenever the\n-   register must be saved because it is live.  */\n+/* Modes for each hard register that we can save.  The smallest mode is wide\n+   enough to save the entire contents of the register.  When saving the\n+   register because it is live we first try to save in multi-register modes.\n+   If that is not possible the save is done one register at a time.  */\n \n-static enum machine_mode regno_save_mode[FIRST_PSEUDO_REGISTER];\n+static enum machine_mode \n+  regno_save_mode[FIRST_PSEUDO_REGISTER][MOVE_MAX / UNITS_PER_WORD + 1];\n \n /* For each hard register, a place on the stack where it can be saved,\n    if needed.  */\n \n-static rtx regno_save_mem[FIRST_PSEUDO_REGISTER];\n+static rtx \n+  regno_save_mem[FIRST_PSEUDO_REGISTER][MOVE_MAX / UNITS_PER_WORD + 1];\n \n /* We will only make a register eligible for caller-save if it can be\n    saved in its widest mode with a simple SET insn as long as the memory\n    address is valid.  We record the INSN_CODE is those insns here since\n    when we emit them, the addresses might not be valid, so they might not\n    be recognized.  */\n \n-static enum insn_code reg_save_code[FIRST_PSEUDO_REGISTER];\n-static enum insn_code reg_restore_code[FIRST_PSEUDO_REGISTER];\n+static enum insn_code \n+  reg_save_code[FIRST_PSEUDO_REGISTER][MOVE_MAX / UNITS_PER_WORD + 1];\n+static enum insn_code \n+  reg_restore_code[FIRST_PSEUDO_REGISTER][MOVE_MAX / UNITS_PER_WORD + 1];\n \n /* Set of hard regs currently live (during scan of all insns).  */\n \n@@ -56,21 +61,24 @@ static HARD_REG_SET hard_regs_live;\n \n static HARD_REG_SET hard_regs_saved;\n \n+/* Set of hard regs which need to be restored before referenced.  */\n+\n+static HARD_REG_SET hard_regs_need_restore;\n+\n /* Number of registers currently in hard_regs_saved.  */\n \n int n_regs_saved;\n \n static void set_reg_live ();\n static void clear_reg_live ();\n static void restore_referenced_regs ();\n-static void insert_save_restore ();\n+static int insert_save_restore ();\n \f\n /* Return a machine mode that is legitimate for hard reg REGNO and large\n-   enough to save the whole register.  If we can't find one, \n-   return VOIDmode.  */\n+   enough to save nregs.  If we can't find one, return VOIDmode.  */\n \n static enum machine_mode\n-choose_hard_reg_mode (regno)\n+choose_hard_reg_mode (regno, nregs)\n      int regno;\n {\n   enum machine_mode found_mode = VOIDmode, mode;\n@@ -81,7 +89,7 @@ choose_hard_reg_mode (regno)\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (HARD_REGNO_NREGS (regno, mode) == 1\n+    if (HARD_REGNO_NREGS (regno, mode) == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode))\n       found_mode = mode;\n \n@@ -90,14 +98,14 @@ choose_hard_reg_mode (regno)\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (HARD_REGNO_NREGS (regno, mode) == 1\n+    if (HARD_REGNO_NREGS (regno, mode) == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode))\n       found_mode = mode;\n \n   if (found_mode != VOIDmode)\n     return found_mode;\n \n-  if (HARD_REGNO_NREGS (regno, CCmode) == 1\n+  if (HARD_REGNO_NREGS (regno, CCmode) == nregs\n       && HARD_REGNO_MODE_OK (regno, CCmode))\n     return CCmode;\n \n@@ -122,7 +130,7 @@ init_caller_save ()\n   rtx addr_reg;\n   int offset;\n   rtx address;\n-  int i;\n+  int i, j;\n \n   /* First find all the registers that we need to deal with and all\n      the modes that they can have.  If we can't find a mode to use,\n@@ -132,15 +140,18 @@ init_caller_save ()\n     {\n       if (call_used_regs[i] && ! call_fixed_regs[i])\n \t{\n-\t  regno_save_mode[i] = choose_hard_reg_mode (i);\n-\t  if (regno_save_mode[i] == VOIDmode)\n+\t  for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n \t    {\n-\t      call_fixed_regs[i] = 1;\n-\t      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t      regno_save_mode[i][j] = choose_hard_reg_mode (i, j);\n+\t      if (regno_save_mode[i][j] == VOIDmode && j == 1)\n+\t\t{\n+\t\t  call_fixed_regs[i] = 1;\n+\t\t  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t\t}\n \t    }\n \t}\n       else\n-\tregno_save_mode[i] = VOIDmode;\n+\tregno_save_mode[i][1] = VOIDmode;\n     }\n \n   /* The following code tries to approximate the conditions under which\n@@ -168,8 +179,8 @@ init_caller_save ()\n       address = gen_rtx (PLUS, Pmode, addr_reg, GEN_INT (offset));\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (regno_save_mode[i] != VOIDmode\n-\t    && ! strict_memory_address_p (regno_save_mode[i], address))\n+\tif (regno_save_mode[i][1] != VOIDmode\n+\t  && ! strict_memory_address_p (regno_save_mode[i][1], address))\n \t  break;\n \n       if (i == FIRST_PSEUDO_REGISTER)\n@@ -186,30 +197,31 @@ init_caller_save ()\n   start_sequence ();\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (regno_save_mode[i] != VOIDmode)\n-      {\n-\trtx mem = gen_rtx (MEM, regno_save_mode[i], address);\n-\trtx reg = gen_rtx (REG, regno_save_mode[i], i);\n-\trtx savepat = gen_rtx (SET, VOIDmode, mem, reg);\n-\trtx restpat = gen_rtx (SET, VOIDmode, reg, mem);\n-\trtx saveinsn = emit_insn (savepat);\n-\trtx restinsn = emit_insn (restpat);\n-\tint ok;\n-\n-\treg_save_code[i] = recog_memoized (saveinsn);\n-\treg_restore_code[i] = recog_memoized (restinsn);\n-\n-\t/* Now extract both insns and see if we can meet their constraints.  */\n-\tok = (reg_save_code[i] != -1 && reg_restore_code[i] != -1);\n-\tif (ok)\n-\t  {\n-\t    insn_extract (saveinsn);\n-\t    ok = constrain_operands (reg_save_code[i], 1);\n-\t    insn_extract (restinsn);\n-\t    ok &= constrain_operands (reg_restore_code[i], 1);\n-\t  }\n+    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+      if (regno_save_mode[i][j] != VOIDmode)\n+        {\n+\t  rtx mem = gen_rtx (MEM, regno_save_mode[i][j], address);\n+\t  rtx reg = gen_rtx (REG, regno_save_mode[i][j], i);\n+\t  rtx savepat = gen_rtx (SET, VOIDmode, mem, reg);\n+\t  rtx restpat = gen_rtx (SET, VOIDmode, reg, mem);\n+\t  rtx saveinsn = emit_insn (savepat);\n+\t  rtx restinsn = emit_insn (restpat);\n+\t  int ok;\n+\n+\t  reg_save_code[i][j] = recog_memoized (saveinsn);\n+\t  reg_restore_code[i][j] = recog_memoized (restinsn);\n+\n+\t  /* Now extract both insns and see if we can meet their constraints. */\n+\t  ok = (reg_save_code[i][j] != -1 && reg_restore_code[i][j] != -1);\n+\t  if (ok)\n+\t    {\n+\t      insn_extract (saveinsn);\n+\t      ok = constrain_operands (reg_save_code[i][j], 1);\n+\t      insn_extract (restinsn);\n+\t      ok &= constrain_operands (reg_restore_code[i][j], 1);\n+\t    }\n \n-\tif (! ok)\n+\tif (! ok && j == 1)\n \t  {\n \t    call_fixed_regs[i] = 1;\n \t    SET_HARD_REG_BIT (call_fixed_reg_set, i);\n@@ -226,10 +238,11 @@ init_caller_save ()\n void\n init_save_areas ()\n {\n-  int i;\n+  int i, j;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    regno_save_mem[i] = 0;\n+    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+      regno_save_mem[i][j] = 0;\n }\n \n /* Allocate save areas for any hard registers that might need saving.\n@@ -243,39 +256,104 @@ init_save_areas ()\n    We assume that our caller has set up the elimination table to the\n    worst (largest) possible offsets.\n \n-   Set *PCHANGED to 1 if we had to allocate some memory for the save area.  */\n+   Set *PCHANGED to 1 if we had to allocate some memory for the save area.  \n+\n+   Future work:\n+\n+     In the fallback case we should iterate backwards across all possible\n+     modes for the save, choosing the largest available one instead of \n+     falling back to the smallest mode immediately.  (eg TF -> DF -> SF).\n+\n+     We do not try to use \"move multiple\" instructions that exist\n+     on some machines (such as the 68k moveml).  It could be a win to try \n+     and use them when possible.  The hard part is doing it in a way that is\n+     machine independent since they might be saving non-consecutive \n+     registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */\n \n int\n setup_save_areas (pchanged)\n      int *pchanged;\n {\n+  int i, j, k;\n+  HARD_REG_SET hard_regs_used;\n   int ok = 1;\n-  int i;\n \n+\n+  /* Allocate space in the save area for the largest multi-register\n+     pseudos first, then work backwards to single register\n+     pseudos.  */\n+\n+  /* Find and record all call-used hard-registers in this function.  */\n+  CLEAR_HARD_REG_SET (hard_regs_used);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] >= 0 && reg_n_calls_crossed[i] > 0)\n       {\n \tint regno = reg_renumber[i];\n-\tint endregno\n+\tint endregno \n \t  = regno + HARD_REGNO_NREGS (regno, GET_MODE (regno_reg_rtx[i]));\n-\tint j;\n+\tint nregs = endregno - regno;\n \n-\tfor (j = regno; j < endregno; j++)\n-\t  if (call_used_regs[j] && regno_save_mem[j] == 0)\n+\tfor (j = 0; j < nregs; j++)\n+\t  {\n+\t    if (call_used_regs[regno+j]) \n+\t      SET_HARD_REG_BIT (hard_regs_used, regno+j);\n+\t  }\n+      }\n+\n+  /* Now run through all the call-used hard-registers and allocate\n+     space for them in the caller-save area.  Try to allocate space\n+     in a manner which allows multi-register saves/restores to be done.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    for (j = MOVE_MAX / UNITS_PER_WORD; j > 0; j--)\n+      {\n+\tint ok = 1;\n+\n+\t/* If no mode exists for this size, try another.  Also break out\n+\t   if we have already saved this hard register.  */\n+\tif (regno_save_mode[i][j] == VOIDmode || regno_save_mem[i][1] != 0)\n+\t  continue;\n+\n+\tfor (k = 0; k < j; k++)\n \t    {\n-\t      regno_save_mem[j]\n-\t\t= assign_stack_local (regno_save_mode[j],\n-\t\t\t\t      GET_MODE_SIZE (regno_save_mode[j]), 0);\n-\t      *pchanged = 1;\n+\t      int regno = i + k;\n+\t      ok &= (TEST_HARD_REG_BIT (hard_regs_used, regno) != 0);\n \t    }\n+\n+\t/* We have found an acceptable mode to store in. */\n+\tif (ok)\n+\t  {\n+\n+\t    regno_save_mem[i][j]\n+\t      = assign_stack_local (regno_save_mode[i][j],\n+\t\t\t\t    GET_MODE_SIZE (regno_save_mode[i][j]), 0);\n+\n+\t    /* Setup singe word save area just in case... */\n+\t    for (k = 0; k < j; k++)\n+\t      {\n+\t\tint offset;\n+\t\trtx temp;\n+\n+\t\tif (WORDS_BIG_ENDIAN) \n+\t\t  offset = k * UNITS_PER_WORD;\n+\t\telse\n+\t\t  offset =  - k * UNITS_PER_WORD;\n+\n+\t\ttemp \n+\t\t  = gen_rtx(MEM, regno_save_mode[i+k][1], \n+\t\t\t    XEXP (regno_save_mem[i][j], 0));\n+\t\tregno_save_mem[i+k][1] \n+\t\t  = adj_offsettable_operand(temp, offset);\n+\t      }\n+\t    *pchanged = 1;\n+\t  }\n       }\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (regno_save_mem[i] != 0)\n-      ok &= strict_memory_address_p (regno_save_mode[i],\n-\t\t\t\t     XEXP (eliminate_regs (regno_save_mem[i],\n-\t\t\t\t\t\t\t   0, NULL_RTX),\n-\t\t\t\t\t   0));\n+    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+      if (regno_save_mem[i][j] != 0)\n+\tok &= strict_memory_address_p (GET_MODE (regno_save_mem[i][j]),\n+\t\t\t\t       XEXP (eliminate_regs (regno_save_mem[i][j], 0, NULL_RTX), 0));\n \n   return ok;\n }\n@@ -313,6 +391,7 @@ save_call_clobbered_regs (insn_mode)\n #endif\n \n       CLEAR_HARD_REG_SET (hard_regs_saved);\n+      CLEAR_HARD_REG_SET (hard_regs_need_restore);\n       n_regs_saved = 0;\n \n       for (offset = 0, i = 0; offset < regset_size; offset++)\n@@ -328,6 +407,7 @@ save_call_clobbered_regs (insn_mode)\n \t\t\t\t\t\t   PSEUDO_REGNO_MODE (i));\n \t\t     j++)\n \t\t  SET_HARD_REG_BIT (hard_regs_live, j);\n+\n \t}\n \n       /* Now scan the insns in the block, keeping track of what hard\n@@ -366,11 +446,27 @@ save_call_clobbered_regs (insn_mode)\n \t\t are born in the CALL_INSN.  */\n \n \t      if (code == CALL_INSN)\n-\t\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t  if (call_used_regs[regno] && ! call_fixed_regs[regno]\n-\t\t      && TEST_HARD_REG_BIT (hard_regs_live, regno)\n-\t\t      && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\t    insert_save_restore (insn, 1, regno, insn_mode);\n+\t\t{\n+\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\t    if (call_used_regs[regno] && ! call_fixed_regs[regno]\n+\t\t        && TEST_HARD_REG_BIT (hard_regs_live, regno)\n+\t\t        && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t\t      regno += insert_save_restore (insn, 1, regno, \n+\t\t\t\t\t\t    insn_mode, 0);\n+#ifdef HARD_REG_SET\n+\t\t  hard_regs_need_restore = hard_regs_saved;\n+#else\n+\t\t  COPY_HARD_REG_SET (hard_regs_need_restore,\n+\t\t\t\t     hard_regs_saved);\n+#endif\n+\n+\t\t  /* Must recompute n_regs_saved.  */\n+\t\t  n_regs_saved = 0;\n+\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\t    if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t\t      n_regs_saved++;\n+\t\t  \n+\t\t}\n \t      \n \t      note_stores (PATTERN (insn), set_reg_live);\n \n@@ -389,10 +485,11 @@ save_call_clobbered_regs (insn_mode)\n \n       if (n_regs_saved)\n \tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t  if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t    insert_save_restore ((GET_CODE (insn) == JUMP_INSN\n-\t\t\t\t  ? insn : NEXT_INSN (insn)),\n-\t\t\t\t 0, regno, insn_mode);\n+\t  if (TEST_HARD_REG_BIT (hard_regs_need_restore, regno))\n+\t    regno += insert_save_restore ((GET_CODE (insn) == JUMP_INSN\n+\t\t\t\t  ? insn : NEXT_INSN (insn)), 0,\n+\t\t\t\t  regno, insn_mode, MOVE_MAX / UNITS_PER_WORD);\n+\n     }\n }\n \n@@ -422,7 +519,11 @@ set_reg_live (reg, setter)\n   endregno = regno + HARD_REGNO_NREGS (regno, mode);\n \n   for (i = regno; i < endregno; i++)\n-    SET_HARD_REG_BIT (hard_regs_live, i);\n+    {\n+      SET_HARD_REG_BIT (hard_regs_live, i);\n+      CLEAR_HARD_REG_BIT (hard_regs_saved, i);\n+      CLEAR_HARD_REG_BIT (hard_regs_need_restore, i);\n+    }\n }\n \n /* Here when a REG_DEAD note records the last use of a reg.  Clear\n@@ -442,7 +543,11 @@ clear_reg_live (reg)\n   endregno= regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \n   for (i = regno; i < endregno; i++)\n-    CLEAR_HARD_REG_BIT (hard_regs_live, i);\n+    {\n+      CLEAR_HARD_REG_BIT (hard_regs_live, i);\n+      CLEAR_HARD_REG_BIT (hard_regs_need_restore, i);\n+      CLEAR_HARD_REG_BIT (hard_regs_saved, i);\n+    }\n }      \n \f\n /* If any register currently residing in the save area is referenced in X,\n@@ -459,6 +564,9 @@ restore_referenced_regs (x, insn, insn_mode)\n   char *fmt;\n   int i, j;\n \n+  if (code == CLOBBER)\n+    return;\n+\n   if (code == REG)\n     {\n       int regno = REGNO (x);\n@@ -482,9 +590,10 @@ restore_referenced_regs (x, insn, insn_mode)\n \t{\n \t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n \n-\t  for (i = regno; i < endregno; i ++)\n-\t    if (TEST_HARD_REG_BIT (hard_regs_saved, i))\n-\t      insert_save_restore (insn, 0, i, insn_mode);\n+\t  for (i = regno; i < endregno; i++)\n+\t    if (TEST_HARD_REG_BIT (hard_regs_need_restore, i))\n+\t      i += insert_save_restore (insn, 0, i, insn_mode, \n+\t\t\t\tGET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n \t}\n \n       return;\n@@ -509,18 +618,21 @@ restore_referenced_regs (x, insn, insn_mode)\n    with a simple SET, so use it.  Set INSN_CODE to what we save there\n    since the address might not be valid so the insn might not be recognized.\n    These insns will be reloaded and have register elimination done by\n-   find_reload, so we need not worry about that here.  */\n+   find_reload, so we need not worry about that here.\n \n-static void\n-insert_save_restore (insn, save_p, regno, insn_mode)\n+   Return the extra number of registers saved.  */\n+\n+static int\n+insert_save_restore (insn, save_p, regno, insn_mode, maxrestore)\n      rtx insn;\n      int save_p;\n      int regno;\n      enum machine_mode insn_mode;\n+     int maxrestore;\n {\n   rtx pat;\n   enum insn_code code;\n-  int i;\n+  int i, numregs;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -529,7 +641,7 @@ insert_save_restore (insn, save_p, regno, insn_mode)\n      for this common case and abort here instead.  This will remove one\n      step in debugging such problems.  */\n \n-  if (regno_save_mem[regno] == 0)\n+  if (regno_save_mem[regno][1] == 0)\n     abort ();\n \n   /* If INSN is a CALL_INSN, we must insert our insns before any\n@@ -555,25 +667,92 @@ insert_save_restore (insn, save_p, regno, insn_mode)\n   /* Get the pattern to emit and update our status.  */\n   if (save_p)\n     {\n-      pat = gen_rtx (SET, VOIDmode, regno_save_mem[regno],\n-\t\t     gen_rtx (REG, regno_save_mode[regno], regno));\n-      code = reg_save_code[regno];\n-      SET_HARD_REG_BIT (hard_regs_saved, regno);\n-      n_regs_saved++;\n+      int i, j, k;\n+      int ok;\n+\n+      /* See if we can save several registers with a single instruction.  \n+\t Work backwards to the single register case.  */\n+      for (i = MOVE_MAX / UNITS_PER_WORD; i > 0; i--)\n+\t{\n+\t  ok = 1;\n+\t  if (regno_save_mem[regno][i] != 0)\n+\t    for (j = 0; j < i; j++)\n+\t      {\n+\t\tif (! call_used_regs[regno + j] && call_fixed_regs[regno + j]\n+\t\t    && ! TEST_HARD_REG_BIT (hard_regs_live, regno + j)\n+\t\t    && TEST_HARD_REG_BIT (hard_regs_saved, regno + j))\n+\t\t  ok = 0;\n+\t      }\n+\t  else \n+\t    continue;\n+\n+\t  /* Must do this one save at a time */\n+\t  if (! ok)\n+\t    continue;\n+\n+          pat = gen_rtx (SET, VOIDmode, regno_save_mem[regno][i],\n+\t\t     gen_rtx (REG, GET_MODE (regno_save_mem[regno][i]), regno));\n+          code = reg_save_code[regno][i];\n+\n+\t  /* Set hard_regs_saved for all the registers we saved.  */\n+\t  for (k = 0; k < i; k++)\n+\t    {\n+\t      SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n+\t      SET_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n+\t      n_regs_saved++;\n+\t    }\n+\n+\t  numregs = i;\n+\t  break;\n+        }\n     }\n   else\n     {\n-      pat = gen_rtx (SET, VOIDmode,\n-\t\t     gen_rtx (REG, regno_save_mode[regno], regno),\n-\t\t     regno_save_mem[regno]);\n-      code = reg_restore_code[regno];\n-      CLEAR_HARD_REG_BIT (hard_regs_saved, regno);\n-      n_regs_saved--;\n-    }\n+      int i, j, k;\n+      int ok;\n+\n+      /* See if we can restore `maxrestore' registers at once.  Work\n+\t backwards to the single register case.  */\n+      for (i = maxrestore; i > 0; i--)\n+\t{\n+\t  ok = 1;\n+\t  if (regno_save_mem[regno][i])\n+\t    for (j = 0; j < i; j++)\n+\t      {\n+\t  \tif (! TEST_HARD_REG_BIT (hard_regs_need_restore, regno + j))\n+\t\t  ok = 0;\n+\t      }\n+\t  else\n+\t    continue;\n+\n+\t  /* Must do this one restore at a time */\n+\t  if (! ok)\n+\t    continue;\n+\t    \n+          pat = gen_rtx (SET, VOIDmode,\n+\t\t         gen_rtx (REG, GET_MODE (regno_save_mem[regno][i]), \n+\t\t\t\t  regno), \n+\t\t\t regno_save_mem[regno][i]);\n+          code = reg_restore_code[regno][i];\n \n+\n+\t  /* Clear status for all registers we restored.  */\n+\t  for (k = 0; k < i; k++)\n+\t    {\n+\t      CLEAR_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n+\t      n_regs_saved--;\n+\t    }\n+\n+\t  numregs = i;\n+\t  break;\n+        }\n+    }\n   /* Emit the insn and set the code and mode.  */\n \n   insn = emit_insn_before (pat, insn);\n   PUT_MODE (insn, insn_mode);\n   INSN_CODE (insn) = code;\n+\n+  /* Tell our callers how many extra registers we saved/restored */\n+  return numregs - 1;\n }"}]}