{"sha": "bdcbe80c52f4cec942890eda8520d553edff998f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjYmU4MGM1MmY0Y2VjOTQyODkwZWRhODUyMGQ1NTNlZGZmOTk4Zg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2013-02-13T10:32:26Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-02-13T10:32:26Z"}, "message": "[asan] Avoid instrumenting duplicated memory access in the same basic block\n\nLike what Address Sanitizer does in LLVM, this patch avoids instrumented\nduplicated memory accesses in the same basic blocks.\n\nThe approach taken is very conservative, to keep the pass simple, for\na start.\n\nA memory access is considered to be a pair made of an expression tree\nrepresenting the beginning of the memory region that is accessed and\na the size of the access, in byte.  For now that size is either 1, 2,\n4, 8 or 16 bytes.\n\nThe patch builds a hash table of the memory accesses that have been\ninstrumented in the current basic block.  Then it walks the gimple\nstatements of the current basic block.  For each statement, it tests\nif the memory regions it references have already been instrumented.\nIf not, the statement is instrumented and each memory references that\nare actually instrumented are added to the hash table.  When a memory\nregion is accessed (usually through builtin functions like memset),\nthen what gets added to the hash table is actually two memory\naccesses: one for the beginning of the region, and the other for the\nits end.\n\nWhen the patch crosses a function call that is not a built-in function\nthat we ought to instrument, the hash table is cleared, because that\nfunction call can possibly e.g free some memory that was instrumented.\n\nLikewise, when a new basic block is visited, the hash table is\ncleared.  I guess we could be smarter than just unconditionally\nclearing the hash table in this later case, but this is what asan@llvm\ndoes, and for now, I thought starting in a conservative manner might\nhave some value.\n\nThe hash table is destroyed at the end of the pass.\n\nBootstrapped and tested against trunk on x86-64-unknown-linux-gnu.\n\ngcc/\n\t* Makefile.in (asan.o): Add new dependency on hash-table.h\n\t* asan.c (struct asan_mem_ref, struct mem_ref_hasher): New types.\n\t(asan_mem_ref_init, asan_mem_ref_get_end, get_mem_ref_hash_table)\n\t(has_stmt_been_instrumented_p, empty_mem_ref_hash_table)\n\t(free_mem_ref_resources, has_mem_ref_been_instrumented)\n\t(has_stmt_been_instrumented_p, update_mem_ref_hash_table)\n\t(get_mem_ref_of_assignment): New functions.\n\t(get_mem_refs_of_builtin_call): Extract from\n\tinstrument_builtin_call and tweak a little bit to make it fit with\n\tthe new signature.\n\t(instrument_builtin_call): Use the new\n\tget_mem_refs_of_builtin_call.  Use gimple_call_builtin_p instead\n\tof is_gimple_builtin_call.\n\t(instrument_derefs, instrument_mem_region_access): Insert the\n\tinstrumented memory reference into the hash table.\n\t(maybe_instrument_assignment): Renamed instrument_assignment into\n\tthis, and change it to advance the iterator when instrumentation\n\tactually happened and return true in that case.  This makes it\n\thomogeneous with maybe_instrument_assignment, and thus give a\n\tchance to callers to be more 'regular'.\n\t(transform_statements): Clear the memory reference hash table\n\twhenever we enter a new BB, when we cross a function call, or when\n\twe are done transforming statements.  Use\n\tmaybe_instrument_assignment instead of instrumentation.  No more\n\tneed to special case maybe_instrument_assignment and advance the\n\titerator after calling it; it's now handled just like\n\tmaybe_instrument_call.  Update comment.\n\ngcc/testsuite/\n\n\t* c-c++-common/asan/no-redundant-instrumentation-1.c: New test.\n\t* testsuite/c-c++-common/asan/no-redundant-instrumentation-2.c: Likewise.\n\t* testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c: Likewise.\n\t* testsuite/c-c++-common/asan/inc.c: Likewise.\n\nFrom-SVN: r196008", "tree": {"sha": "9909ad60494bd66f886a220fd49588379ae52078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9909ad60494bd66f886a220fd49588379ae52078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdcbe80c52f4cec942890eda8520d553edff998f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcbe80c52f4cec942890eda8520d553edff998f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdcbe80c52f4cec942890eda8520d553edff998f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcbe80c52f4cec942890eda8520d553edff998f/comments", "author": null, "committer": null, "parents": [{"sha": "a50bd22d718020333af9908f43d435fa6aa3f70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50bd22d718020333af9908f43d435fa6aa3f70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50bd22d718020333af9908f43d435fa6aa3f70e"}], "stats": {"total": 1430, "additions": 1020, "deletions": 410}, "files": [{"sha": "11cad1a82d011bbd1447b64f72f37275bc92b228", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -1,3 +1,34 @@\n+2013-02-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tAvoid instrumenting duplicated memory access in the same basic block\n+\t* Makefile.in (asan.o): Add new dependency on hash-table.h\n+\t* asan.c (struct asan_mem_ref, struct mem_ref_hasher): New types.\n+\t(asan_mem_ref_init, asan_mem_ref_get_end, get_mem_ref_hash_table)\n+\t(has_stmt_been_instrumented_p, empty_mem_ref_hash_table)\n+\t(free_mem_ref_resources, has_mem_ref_been_instrumented)\n+\t(has_stmt_been_instrumented_p, update_mem_ref_hash_table)\n+\t(get_mem_ref_of_assignment): New functions.\n+\t(get_mem_refs_of_builtin_call): Extract from\n+\tinstrument_builtin_call and tweak a little bit to make it fit with\n+\tthe new signature.\n+\t(instrument_builtin_call): Use the new\n+\tget_mem_refs_of_builtin_call.  Use gimple_call_builtin_p instead\n+\tof is_gimple_builtin_call.\n+\t(instrument_derefs, instrument_mem_region_access): Insert the\n+\tinstrumented memory reference into the hash table.\n+\t(maybe_instrument_assignment): Renamed instrument_assignment into\n+\tthis, and change it to advance the iterator when instrumentation\n+\tactually happened and return true in that case.  This makes it\n+\thomogeneous with maybe_instrument_assignment, and thus give a\n+\tchance to callers to be more 'regular'.\n+\t(transform_statements): Clear the memory reference hash table\n+\twhenever we enter a new BB, when we cross a function call, or when\n+\twe are done transforming statements.  Use\n+\tmaybe_instrument_assignment instead of instrumentation.  No more\n+\tneed to special case maybe_instrument_assignment and advance the\n+\titerator after calling it; it's now handled just like\n+\tmaybe_instrument_call.  Update comment.\n+\n 2013-02-13  Richard Biener  <rguenther@suse.de>\n \n \t* config/mn10300/mn10300.c (mn10300_scan_for_setlb_lcc):"}, {"sha": "f3bb1683bb566def82cf2d8f6ea686e9a47e2287", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -2226,7 +2226,8 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n asan.o : asan.c asan.h $(CONFIG_H) $(SYSTEM_H) $(GIMPLE_H) \\\n    output.h coretypes.h $(GIMPLE_PRETTY_PRINT_H) \\\n    tree-iterator.h $(TREE_FLOW_H) $(TREE_PASS_H) \\\n-   $(TARGET_H) $(EXPR_H) $(OPTABS_H) $(TM_P_H) langhooks.h\n+   $(TARGET_H) $(EXPR_H) $(OPTABS_H) $(TM_P_H) langhooks.h \\\n+   $(HASH_TABLE_H) alloc-pool.h\n tsan.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(GIMPLE_H) $(DIAGNOSTIC_H) langhooks.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(CGRAPH_H) $(GGC_H) \\"}, {"sha": "3cb9511232993b10d7a30a3f69ca3d0a27af8f93", "filename": "gcc/asan.c", "status": "modified", "additions": 849, "deletions": 409, "changes": 1258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"tm_p.h\"\n #include \"langhooks.h\"\n+#include \"hash-table.h\"\n+#include \"alloc-pool.h\"\n \n /* AddressSanitizer finds out-of-bounds and use-after-free bugs\n    with <2x slowdown on average.\n@@ -212,6 +214,620 @@ alias_set_type asan_shadow_set = -1;\n    alias set is used for all shadow memory accesses.  */\n static GTY(()) tree shadow_ptr_types[2];\n \n+/* Hashtable support for memory references used by gimple\n+   statements.  */\n+\n+/* This type represents a reference to a memory region.  */\n+struct asan_mem_ref\n+{\n+  /* The expression of the begining of the memory region.  */\n+  tree start;\n+\n+  /* The size of the access (can be 1, 2, 4, 8, 16 for now).  */\n+  char access_size;\n+};\n+\n+static alloc_pool asan_mem_ref_alloc_pool;\n+\n+/* This creates the alloc pool used to store the instances of\n+   asan_mem_ref that are stored in the hash table asan_mem_ref_ht.  */\n+\n+static alloc_pool\n+asan_mem_ref_get_alloc_pool ()\n+{\n+  if (asan_mem_ref_alloc_pool == NULL)\n+    asan_mem_ref_alloc_pool = create_alloc_pool (\"asan_mem_ref\",\n+\t\t\t\t\t\t sizeof (asan_mem_ref),\n+\t\t\t\t\t\t 10);\n+  return asan_mem_ref_alloc_pool;\n+    \n+}\n+\n+/* Initializes an instance of asan_mem_ref.  */\n+\n+static void\n+asan_mem_ref_init (asan_mem_ref *ref, tree start, char access_size)\n+{\n+  ref->start = start;\n+  ref->access_size = access_size;\n+}\n+\n+/* Allocates memory for an instance of asan_mem_ref into the memory\n+   pool returned by asan_mem_ref_get_alloc_pool and initialize it.\n+   START is the address of (or the expression pointing to) the\n+   beginning of memory reference.  ACCESS_SIZE is the size of the\n+   access to the referenced memory.  */\n+\n+static asan_mem_ref*\n+asan_mem_ref_new (tree start, char access_size)\n+{\n+  asan_mem_ref *ref =\n+    (asan_mem_ref *) pool_alloc (asan_mem_ref_get_alloc_pool ());\n+\n+  asan_mem_ref_init (ref, start, access_size);\n+  return ref;\n+}\n+\n+/* This builds and returns a pointer to the end of the memory region\n+   that starts at START and of length LEN.  */\n+\n+tree\n+asan_mem_ref_get_end (tree start, tree len)\n+{\n+  if (len == NULL_TREE || integer_zerop (len))\n+    return start;\n+\n+  return fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (start), start, len);\n+}\n+\n+/*  Return a tree expression that represents the end of the referenced\n+    memory region.  Beware that this function can actually build a new\n+    tree expression.  */\n+\n+tree\n+asan_mem_ref_get_end (const asan_mem_ref *ref, tree len)\n+{\n+  return asan_mem_ref_get_end (ref->start, len);\n+}\n+\n+struct asan_mem_ref_hasher\n+  : typed_noop_remove <asan_mem_ref>\n+{\n+  typedef asan_mem_ref value_type;\n+  typedef asan_mem_ref compare_type;\n+\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash a memory reference.  */\n+\n+inline hashval_t\n+asan_mem_ref_hasher::hash (const asan_mem_ref *mem_ref)\n+{\n+  hashval_t h = iterative_hash_expr (mem_ref->start, 0);\n+  h = iterative_hash_hashval_t (h, mem_ref->access_size);\n+  return h;\n+}\n+\n+/* Compare two memory references.  We accept the length of either\n+   memory references to be NULL_TREE.  */\n+\n+inline bool\n+asan_mem_ref_hasher::equal (const asan_mem_ref *m1,\n+\t\t\t    const asan_mem_ref *m2)\n+{\n+  return (m1->access_size == m2->access_size\n+\t  && operand_equal_p (m1->start, m2->start, 0));\n+}\n+\n+static hash_table <asan_mem_ref_hasher> asan_mem_ref_ht;\n+\n+/* Returns a reference to the hash table containing memory references.\n+   This function ensures that the hash table is created.  Note that\n+   this hash table is updated by the function\n+   update_mem_ref_hash_table.  */\n+\n+static hash_table <asan_mem_ref_hasher> &\n+get_mem_ref_hash_table ()\n+{\n+  if (!asan_mem_ref_ht.is_created ())\n+    asan_mem_ref_ht.create (10);\n+\n+  return asan_mem_ref_ht;\n+}\n+\n+/* Clear all entries from the memory references hash table.  */\n+\n+static void\n+empty_mem_ref_hash_table ()\n+{\n+  if (asan_mem_ref_ht.is_created ())\n+    asan_mem_ref_ht.empty ();\n+}\n+\n+/* Free the memory references hash table.  */\n+\n+static void\n+free_mem_ref_resources ()\n+{\n+  if (asan_mem_ref_ht.is_created ())\n+    asan_mem_ref_ht.dispose ();\n+\n+  if (asan_mem_ref_alloc_pool)\n+    {\n+      free_alloc_pool (asan_mem_ref_alloc_pool);\n+      asan_mem_ref_alloc_pool = NULL;\n+    }\n+}\n+\n+/* Return true iff the memory reference REF has been instrumented.  */\n+\n+static bool\n+has_mem_ref_been_instrumented (tree ref, char access_size)\n+{\n+  asan_mem_ref r;\n+  asan_mem_ref_init (&r, ref, access_size);\n+\n+  return (get_mem_ref_hash_table ().find (&r) != NULL);\n+}\n+\n+/* Return true iff the memory reference REF has been instrumented.  */\n+\n+static bool\n+has_mem_ref_been_instrumented (const asan_mem_ref *ref)\n+{\n+  return has_mem_ref_been_instrumented (ref->start, ref->access_size);\n+}\n+\n+/* Return true iff access to memory region starting at REF and of\n+   length LEN has been instrumented.  */\n+\n+static bool\n+has_mem_ref_been_instrumented (const asan_mem_ref *ref, tree len)\n+{\n+  /* First let's see if the address of the beginning of REF has been\n+     instrumented.  */\n+  if (!has_mem_ref_been_instrumented (ref))\n+    return false;\n+\n+  if (len != 0)\n+    {\n+      /* Let's see if the end of the region has been instrumented.  */\n+      if (!has_mem_ref_been_instrumented (asan_mem_ref_get_end (ref, len),\n+\t\t\t\t\t  ref->access_size))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Set REF to the memory reference present in a gimple assignment\n+   ASSIGNMENT.  Return true upon successful completion, false\n+   otherwise.  */\n+\n+static bool\n+get_mem_ref_of_assignment (const gimple assignment,\n+\t\t\t   asan_mem_ref *ref,\n+\t\t\t   bool *ref_is_store)\n+{\n+  gcc_assert (gimple_assign_single_p (assignment));\n+\n+  if (gimple_store_p (assignment))\n+    {\n+      ref->start = gimple_assign_lhs (assignment);\n+      *ref_is_store = true;\n+    }\n+  else if (gimple_assign_load_p (assignment))\n+    {\n+      ref->start = gimple_assign_rhs1 (assignment);\n+      *ref_is_store = false;\n+    }\n+  else\n+    return false;\n+\n+  ref->access_size = int_size_in_bytes (TREE_TYPE (ref->start));\n+  return true;\n+}\n+\n+/* Return the memory references contained in a gimple statement\n+   representing a builtin call that has to do with memory access.  */\n+\n+static bool\n+get_mem_refs_of_builtin_call (const gimple call,\n+\t\t\t      asan_mem_ref *src0,\n+\t\t\t      tree *src0_len,\n+\t\t\t      bool *src0_is_store,\n+\t\t\t      asan_mem_ref *src1,\n+\t\t\t      tree *src1_len,\n+\t\t\t      bool *src1_is_store,\n+\t\t\t      asan_mem_ref *dst,\n+\t\t\t      tree *dst_len,\n+\t\t\t      bool *dst_is_store,\n+\t\t\t      bool *dest_is_deref)\n+{\n+  gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n+\n+  tree callee = gimple_call_fndecl (call);\n+  tree source0 = NULL_TREE, source1 = NULL_TREE,\n+    dest = NULL_TREE, len = NULL_TREE;\n+  bool is_store = true, got_reference_p = false;\n+  char access_size = 1;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+      /* (s, s, n) style memops.  */\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+      source0 = gimple_call_arg (call, 0);\n+      source1 = gimple_call_arg (call, 1);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+      /* (src, dest, n) style memops.  */\n+    case BUILT_IN_BCOPY:\n+      source0 = gimple_call_arg (call, 0);\n+      dest = gimple_call_arg (call, 1);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+      /* (dest, src, n) style memops.  */\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+      dest = gimple_call_arg (call, 0);\n+      source0 = gimple_call_arg (call, 1);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+      /* (dest, n) style memops.  */\n+    case BUILT_IN_BZERO:\n+      dest = gimple_call_arg (call, 0);\n+      len = gimple_call_arg (call, 1);\n+      break;\n+\n+      /* (dest, x, n) style memops*/\n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n+      dest = gimple_call_arg (call, 0);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+    case BUILT_IN_STRLEN:\n+      source0 = gimple_call_arg (call, 0);\n+      len = gimple_call_lhs (call);\n+      break ;\n+\n+    /* And now the __atomic* and __sync builtins.\n+       These are handled differently from the classical memory memory\n+       access builtins above.  */\n+\n+    case BUILT_IN_ATOMIC_LOAD_1:\n+    case BUILT_IN_ATOMIC_LOAD_2:\n+    case BUILT_IN_ATOMIC_LOAD_4:\n+    case BUILT_IN_ATOMIC_LOAD_8:\n+    case BUILT_IN_ATOMIC_LOAD_16:\n+      is_store = false;\n+      /* fall through.  */\n+\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_1:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_2:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_4:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_8:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_1:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_2:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_4:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_8:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_OR_1:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_2:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_4:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_8:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_AND_1:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_2:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_4:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_8:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_1:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_2:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_4:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_8:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_1:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_2:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_4:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_8:\n+\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_1:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_2:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_4:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_8:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_1:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_2:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_4:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_8:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_OR_AND_FETCH_1:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_2:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_4:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_8:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_AND_AND_FETCH_1:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_2:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_4:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_8:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_1:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_2:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_4:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_8:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_1:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_2:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_4:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_8:\n+\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_1:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_2:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_16:\n+\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_1:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_2:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_16:\n+\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_1:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_2:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_4:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_8:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_16:\n+\n+    case BUILT_IN_SYNC_LOCK_RELEASE_1:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_2:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_4:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_8:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_16:\n+\n+    case BUILT_IN_ATOMIC_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_EXCHANGE_16:\n+\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n+\n+    case BUILT_IN_ATOMIC_STORE_1:\n+    case BUILT_IN_ATOMIC_STORE_2:\n+    case BUILT_IN_ATOMIC_STORE_4:\n+    case BUILT_IN_ATOMIC_STORE_8:\n+    case BUILT_IN_ATOMIC_STORE_16:\n+\n+    case BUILT_IN_ATOMIC_ADD_FETCH_1:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_2:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_4:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_8:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_SUB_FETCH_1:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_2:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_4:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_8:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_AND_FETCH_1:\n+    case BUILT_IN_ATOMIC_AND_FETCH_2:\n+    case BUILT_IN_ATOMIC_AND_FETCH_4:\n+    case BUILT_IN_ATOMIC_AND_FETCH_8:\n+    case BUILT_IN_ATOMIC_AND_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_NAND_FETCH_1:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_2:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_4:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_8:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_XOR_FETCH_1:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_2:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_4:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_8:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_OR_FETCH_1:\n+    case BUILT_IN_ATOMIC_OR_FETCH_2:\n+    case BUILT_IN_ATOMIC_OR_FETCH_4:\n+    case BUILT_IN_ATOMIC_OR_FETCH_8:\n+    case BUILT_IN_ATOMIC_OR_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_ADD_1:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_2:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_4:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_8:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_SUB_1:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_2:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_4:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_8:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_AND_1:\n+    case BUILT_IN_ATOMIC_FETCH_AND_2:\n+    case BUILT_IN_ATOMIC_FETCH_AND_4:\n+    case BUILT_IN_ATOMIC_FETCH_AND_8:\n+    case BUILT_IN_ATOMIC_FETCH_AND_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_NAND_1:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_2:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_4:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_8:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_XOR_1:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_2:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_4:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_8:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_OR_1:\n+    case BUILT_IN_ATOMIC_FETCH_OR_2:\n+    case BUILT_IN_ATOMIC_FETCH_OR_4:\n+    case BUILT_IN_ATOMIC_FETCH_OR_8:\n+    case BUILT_IN_ATOMIC_FETCH_OR_16:\n+      {\n+\tdest = gimple_call_arg (call, 0);\n+\t/* DEST represents the address of a memory location.\n+\t   instrument_derefs wants the memory location, so lets\n+\t   dereference the address DEST before handing it to\n+\t   instrument_derefs.  */\n+\tif (TREE_CODE (dest) == ADDR_EXPR)\n+\t  dest = TREE_OPERAND (dest, 0);\n+\telse if (TREE_CODE (dest) == SSA_NAME)\n+\t  dest = build2 (MEM_REF, TREE_TYPE (TREE_TYPE (dest)),\n+\t\t\t dest, build_int_cst (TREE_TYPE (dest), 0));\n+\telse\n+\t  gcc_unreachable ();\n+\n+\taccess_size = int_size_in_bytes (TREE_TYPE (dest));\n+      }\n+\n+    default:\n+      /* The other builtins memory access are not instrumented in this\n+\t function because they either don't have any length parameter,\n+\t or their length parameter is just a limit.  */\n+      break;\n+    }\n+\n+  if (len != NULL_TREE)\n+    {\n+      if (source0 != NULL_TREE)\n+\t{\n+\t  src0->start = source0;\n+\t  src0->access_size = access_size;\n+\t  *src0_len = len;\n+\t  *src0_is_store = false;\n+\t}\n+\n+      if (source1 != NULL_TREE)\n+\t{\n+\t  src1->start = source1;\n+\t  src1->access_size = access_size;\n+\t  *src1_len = len;\n+\t  *src1_is_store = false;\n+\t}\n+\n+      if (dest != NULL_TREE)\n+\t{\n+\t  dst->start = dest;\n+\t  dst->access_size = access_size;\n+\t  *dst_len = len;\n+\t  *dst_is_store = true;\n+\t}\n+\n+      got_reference_p = true;\n+    }\n+    else\n+      {\n+\tif (dest)\n+\t  {\n+\t    dst->start = dest;\n+\t    dst->access_size = access_size;\n+\t    *dst_len = NULL_TREE;\n+\t    *dst_is_store = is_store;\n+\t    *dest_is_deref = true;\n+\t    got_reference_p = true;\n+\t  }\n+      }\n+\n+    return got_reference_p;\n+}\n+\n+/* Return true iff a given gimple statement has been instrumented.\n+   Note that the statement is \"defined\" by the memory references it\n+   contains.  */\n+\n+static bool\n+has_stmt_been_instrumented_p (gimple stmt)\n+{\n+  if (gimple_assign_single_p (stmt))\n+    {\n+      bool r_is_store;\n+      asan_mem_ref r;\n+      asan_mem_ref_init (&r, NULL, 1);\n+\n+      if (get_mem_ref_of_assignment (stmt, &r, &r_is_store))\n+\treturn has_mem_ref_been_instrumented (&r);\n+    }\n+  else if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      asan_mem_ref src0, src1, dest;\n+      asan_mem_ref_init (&src0, NULL, 1);\n+      asan_mem_ref_init (&src1, NULL, 1);\n+      asan_mem_ref_init (&dest, NULL, 1);\n+\n+      tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n+      bool src0_is_store = false, src1_is_store = false,\n+\tdest_is_store = false, dest_is_deref = false;\n+      if (get_mem_refs_of_builtin_call (stmt,\n+\t\t\t\t\t&src0, &src0_len, &src0_is_store,\n+\t\t\t\t\t&src1, &src1_len, &src1_is_store,\n+\t\t\t\t\t&dest, &dest_len, &dest_is_store,\n+\t\t\t\t\t&dest_is_deref))\n+\t{\n+\t  if (src0.start != NULL_TREE\n+\t      && !has_mem_ref_been_instrumented (&src0, src0_len))\n+\t    return false;\n+\n+\t  if (src1.start != NULL_TREE\n+\t      && !has_mem_ref_been_instrumented (&src1, src1_len))\n+\t    return false;\n+\n+\t  if (dest.start != NULL_TREE\n+\t      && !has_mem_ref_been_instrumented (&dest, dest_len))\n+\t    return false;\n+\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/*  Insert a memory reference into the hash table.  */\n+\n+static void\n+update_mem_ref_hash_table (tree ref, char access_size)\n+{\n+  hash_table <asan_mem_ref_hasher> ht = get_mem_ref_hash_table ();\n+\n+  asan_mem_ref r;\n+  asan_mem_ref_init (&r, ref, access_size);\n+\n+  asan_mem_ref **slot = ht.find_slot (&r, INSERT);\n+  if (*slot == NULL)\n+    *slot = asan_mem_ref_new (ref, access_size);\n+}\n+\n /* Initialize shadow_ptr_types array.  */\n \n static void\n@@ -835,7 +1451,7 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n \n static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n-\t\t  location_t location, bool is_store)\n+\t\t   location_t location, bool is_store)\n {\n   tree type, base;\n   HOST_WIDE_INT size_in_bytes;\n@@ -878,8 +1494,14 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     }\n \n   base = build_fold_addr_expr (t);\n-  build_check_stmt (location, base, iter, /*before_p=*/true,\n-\t\t    is_store, size_in_bytes);\n+  if (!has_mem_ref_been_instrumented (base, size_in_bytes))\n+    {\n+      build_check_stmt (location, base, iter, /*before_p=*/true,\n+\t\t\tis_store, size_in_bytes);\n+      update_mem_ref_hash_table (base, size_in_bytes);\n+      update_mem_ref_hash_table (t, size_in_bytes);\n+    }\n+\n }\n \n /* Instrument an access to a contiguous memory region that starts at\n@@ -903,6 +1525,12 @@ instrument_mem_region_access (tree base, tree len,\n   gimple_stmt_iterator gsi = *iter;\n \n   basic_block fallthrough_bb = NULL, then_bb = NULL;\n+\n+  /* If the beginning of the memory region has already been\n+     instrumented, do not instrument it.  */\n+  if (has_mem_ref_been_instrumented (base, 1))\n+    goto after_first_instrumentation;\n+\n   if (!is_gimple_constant (len))\n     {\n       /* So, the length of the memory area to asan-protect is\n@@ -945,9 +1573,19 @@ instrument_mem_region_access (tree base, tree len,\n   else\n     *iter = gsi;\n \n+  update_mem_ref_hash_table (base, 1);\n+\n+ after_first_instrumentation:\n+\n   /* We want to instrument the access at the end of the memory region,\n      which is at (base + len - 1).  */\n \n+  /* If the end of the memory region has already been instrumented, do\n+     not instrument it. */\n+  tree end = asan_mem_ref_get_end (base, len);\n+  if (has_mem_ref_been_instrumented (end, 1))\n+    return;\n+\n   /* offset = len - 1;  */\n   len = unshare_expr (len);\n   tree offset;\n@@ -982,434 +1620,221 @@ instrument_mem_region_access (tree base, tree len,\n       g = gimple_build_assign_with_ops (MINUS_EXPR, t, len,\n \t\t\t\t\tbuild_int_cst (size_type_node, 1));\n       gimple_set_location (g, location);\n-      gimple_seq_add_stmt_without_update (&seq, g);\n-      offset = gimple_assign_lhs (g);\n-    }\n-\n-  /* _1 = base;  */\n-  base = unshare_expr (base);\n-  gimple region_end =\n-    gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t  base, NULL);\n-  gimple_set_location (region_end, location);\n-  gimple_seq_add_stmt_without_update (&seq, region_end);\n-  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n-  gsi_prev (&gsi);\n-\n-  /* _2 = _1 + offset;  */\n-  region_end =\n-    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t  gimple_assign_lhs (region_end),\n-\t\t\t\t  offset);\n-  gimple_set_location (region_end, location);\n-  gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n-\n-  /* instrument access at _2;  */\n-  build_check_stmt (location, gimple_assign_lhs (region_end),\n-\t\t    &gsi, /*before_p=*/false, is_store, 1);\n-}\n-\n-/* Instrument the call (to the builtin strlen function) pointed to by\n-   ITER.\n-\n-   This function instruments the access to the first byte of the\n-   argument, right before the call.  After the call it instruments the\n-   access to the last byte of the argument; it uses the result of the\n-   call to deduce the offset of that last byte.\n-\n-   Upon completion, iff the call has actullay been instrumented, this\n-   function returns TRUE and *ITER points to the statement logically\n-   following the built-in strlen function call *ITER was initially\n-   pointing to.  Otherwise, the function returns FALSE and *ITER\n-   remains unchanged.  */\n-\n-static bool\n-instrument_strlen_call (gimple_stmt_iterator *iter)\n-{\n-  gimple call = gsi_stmt (*iter);\n-  gcc_assert (is_gimple_call (call));\n-\n-  tree callee = gimple_call_fndecl (call);\n-  gcc_assert (is_builtin_fn (callee)\n-\t      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n-\t      && DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN);\n-\n-  tree len = gimple_call_lhs (call);\n-  if (len == NULL)\n-    /* Some passes might clear the return value of the strlen call;\n-       bail out in that case.  Return FALSE as we are not advancing\n-       *ITER.  */\n-    return false;\n-  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (len)));\n-\n-  location_t loc = gimple_location (call);\n-  tree str_arg = gimple_call_arg (call, 0);\n-\n-  /* Instrument the access to the first byte of str_arg.  i.e:\n-\n-     _1 = str_arg; instrument (_1); */\n-  gimple str_arg_ssa =\n-    gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t  make_ssa_name (build_pointer_type\n-\t\t\t\t\t\t (char_type_node), NULL),\n-\t\t\t\t  str_arg, NULL);\n-  gimple_set_location (str_arg_ssa, loc);\n-  gimple_stmt_iterator gsi = *iter;\n-  gsi_insert_before (&gsi, str_arg_ssa, GSI_NEW_STMT);\n-  build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), &gsi,\n-\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n-\n-  /* If we initially had an instruction like:\n-\n-\t int n = strlen (str)\n-\n-     we now want to instrument the access to str[n], after the\n-     instruction above.*/\n-\n-  /* So let's build the access to str[n] that is, access through the\n-     pointer_plus expr: (_1 + len).  */\n-  gimple stmt =\n-    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t  make_ssa_name (TREE_TYPE (str_arg),\n-\t\t\t\t\t\t NULL),\n-\t\t\t\t  gimple_assign_lhs (str_arg_ssa),\n-\t\t\t\t  len);\n-  gimple_set_location (stmt, loc);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-\n-  build_check_stmt (loc, gimple_assign_lhs (stmt), &gsi,\n-\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n-\n-  /* Ensure that iter points to the statement logically following the\n-     one it was initially pointing to.  */\n-  *iter = gsi;\n-  /* As *ITER has been advanced to point to the next statement, let's\n-     return true to inform transform_statements that it shouldn't\n-     advance *ITER anymore; otherwises it will skip that next\n-     statement, which wouldn't be instrumented.  */\n-  return true;\n-}\n-\n-/* Instrument the call to a built-in memory access function that is\n-   pointed to by the iterator ITER.\n-\n-   Upon completion, return TRUE iff *ITER has been advanced to the\n-   statement following the one it was originally pointing to.  */\n-\n-static bool\n-instrument_builtin_call (gimple_stmt_iterator *iter)\n-{\n-  gimple call = gsi_stmt (*iter);\n-\n-  gcc_checking_assert (is_gimple_builtin_call (call));\n-\n-  tree callee = gimple_call_fndecl (call);\n-  location_t loc = gimple_location (call);\n-  tree source0 = NULL_TREE, source1 = NULL_TREE,\n-    dest = NULL_TREE, len = NULL_TREE;\n-  bool is_store = true;\n-\n-  switch (DECL_FUNCTION_CODE (callee))\n-    {\n-      /* (s, s, n) style memops.  */\n-    case BUILT_IN_BCMP:\n-    case BUILT_IN_MEMCMP:\n-      source0 = gimple_call_arg (call, 0);\n-      source1 = gimple_call_arg (call, 1);\n-      len = gimple_call_arg (call, 2);\n-      break;\n-\n-      /* (src, dest, n) style memops.  */\n-    case BUILT_IN_BCOPY:\n-      source0 = gimple_call_arg (call, 0);\n-      dest = gimple_call_arg (call, 1);\n-      len = gimple_call_arg (call, 2);\n-      break;\n-\n-      /* (dest, src, n) style memops.  */\n-    case BUILT_IN_MEMCPY:\n-    case BUILT_IN_MEMCPY_CHK:\n-    case BUILT_IN_MEMMOVE:\n-    case BUILT_IN_MEMMOVE_CHK:\n-    case BUILT_IN_MEMPCPY:\n-    case BUILT_IN_MEMPCPY_CHK:\n-      dest = gimple_call_arg (call, 0);\n-      source0 = gimple_call_arg (call, 1);\n-      len = gimple_call_arg (call, 2);\n-      break;\n-\n-      /* (dest, n) style memops.  */\n-    case BUILT_IN_BZERO:\n-      dest = gimple_call_arg (call, 0);\n-      len = gimple_call_arg (call, 1);\n-      break;\n-\n-      /* (dest, x, n) style memops*/\n-    case BUILT_IN_MEMSET:\n-    case BUILT_IN_MEMSET_CHK:\n-      dest = gimple_call_arg (call, 0);\n-      len = gimple_call_arg (call, 2);\n-      break;\n-\n-    case BUILT_IN_STRLEN:\n-      return instrument_strlen_call (iter);\n-\n-    /* And now the __atomic* and __sync builtins.\n-       These are handled differently from the classical memory memory\n-       access builtins above.  */\n-\n-    case BUILT_IN_ATOMIC_LOAD_1:\n-    case BUILT_IN_ATOMIC_LOAD_2:\n-    case BUILT_IN_ATOMIC_LOAD_4:\n-    case BUILT_IN_ATOMIC_LOAD_8:\n-    case BUILT_IN_ATOMIC_LOAD_16:\n-      is_store = false;\n-      /* fall through.  */\n-\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_1:\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_2:\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_4:\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_8:\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_16:\n-\n-    case BUILT_IN_SYNC_FETCH_AND_SUB_1:\n-    case BUILT_IN_SYNC_FETCH_AND_SUB_2:\n-    case BUILT_IN_SYNC_FETCH_AND_SUB_4:\n-    case BUILT_IN_SYNC_FETCH_AND_SUB_8:\n-    case BUILT_IN_SYNC_FETCH_AND_SUB_16:\n-\n-    case BUILT_IN_SYNC_FETCH_AND_OR_1:\n-    case BUILT_IN_SYNC_FETCH_AND_OR_2:\n-    case BUILT_IN_SYNC_FETCH_AND_OR_4:\n-    case BUILT_IN_SYNC_FETCH_AND_OR_8:\n-    case BUILT_IN_SYNC_FETCH_AND_OR_16:\n-\n-    case BUILT_IN_SYNC_FETCH_AND_AND_1:\n-    case BUILT_IN_SYNC_FETCH_AND_AND_2:\n-    case BUILT_IN_SYNC_FETCH_AND_AND_4:\n-    case BUILT_IN_SYNC_FETCH_AND_AND_8:\n-    case BUILT_IN_SYNC_FETCH_AND_AND_16:\n-\n-    case BUILT_IN_SYNC_FETCH_AND_XOR_1:\n-    case BUILT_IN_SYNC_FETCH_AND_XOR_2:\n-    case BUILT_IN_SYNC_FETCH_AND_XOR_4:\n-    case BUILT_IN_SYNC_FETCH_AND_XOR_8:\n-    case BUILT_IN_SYNC_FETCH_AND_XOR_16:\n-\n-    case BUILT_IN_SYNC_FETCH_AND_NAND_1:\n-    case BUILT_IN_SYNC_FETCH_AND_NAND_2:\n-    case BUILT_IN_SYNC_FETCH_AND_NAND_4:\n-    case BUILT_IN_SYNC_FETCH_AND_NAND_8:\n-\n-    case BUILT_IN_SYNC_ADD_AND_FETCH_1:\n-    case BUILT_IN_SYNC_ADD_AND_FETCH_2:\n-    case BUILT_IN_SYNC_ADD_AND_FETCH_4:\n-    case BUILT_IN_SYNC_ADD_AND_FETCH_8:\n-    case BUILT_IN_SYNC_ADD_AND_FETCH_16:\n-\n-    case BUILT_IN_SYNC_SUB_AND_FETCH_1:\n-    case BUILT_IN_SYNC_SUB_AND_FETCH_2:\n-    case BUILT_IN_SYNC_SUB_AND_FETCH_4:\n-    case BUILT_IN_SYNC_SUB_AND_FETCH_8:\n-    case BUILT_IN_SYNC_SUB_AND_FETCH_16:\n-\n-    case BUILT_IN_SYNC_OR_AND_FETCH_1:\n-    case BUILT_IN_SYNC_OR_AND_FETCH_2:\n-    case BUILT_IN_SYNC_OR_AND_FETCH_4:\n-    case BUILT_IN_SYNC_OR_AND_FETCH_8:\n-    case BUILT_IN_SYNC_OR_AND_FETCH_16:\n+      gimple_seq_add_stmt_without_update (&seq, g);\n+      offset = gimple_assign_lhs (g);\n+    }\n \n-    case BUILT_IN_SYNC_AND_AND_FETCH_1:\n-    case BUILT_IN_SYNC_AND_AND_FETCH_2:\n-    case BUILT_IN_SYNC_AND_AND_FETCH_4:\n-    case BUILT_IN_SYNC_AND_AND_FETCH_8:\n-    case BUILT_IN_SYNC_AND_AND_FETCH_16:\n+  /* _1 = base;  */\n+  base = unshare_expr (base);\n+  gimple region_end =\n+    gimple_build_assign_with_ops (TREE_CODE (base),\n+\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t  base, NULL);\n+  gimple_set_location (region_end, location);\n+  gimple_seq_add_stmt_without_update (&seq, region_end);\n+  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+  gsi_prev (&gsi);\n \n-    case BUILT_IN_SYNC_XOR_AND_FETCH_1:\n-    case BUILT_IN_SYNC_XOR_AND_FETCH_2:\n-    case BUILT_IN_SYNC_XOR_AND_FETCH_4:\n-    case BUILT_IN_SYNC_XOR_AND_FETCH_8:\n-    case BUILT_IN_SYNC_XOR_AND_FETCH_16:\n+  /* _2 = _1 + offset;  */\n+  region_end =\n+    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n+\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t  gimple_assign_lhs (region_end),\n+\t\t\t\t  offset);\n+  gimple_set_location (region_end, location);\n+  gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n \n-    case BUILT_IN_SYNC_NAND_AND_FETCH_1:\n-    case BUILT_IN_SYNC_NAND_AND_FETCH_2:\n-    case BUILT_IN_SYNC_NAND_AND_FETCH_4:\n-    case BUILT_IN_SYNC_NAND_AND_FETCH_8:\n+  /* instrument access at _2;  */\n+  build_check_stmt (location, gimple_assign_lhs (region_end),\n+\t\t    &gsi, /*before_p=*/false, is_store, 1);\n \n-    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_1:\n-    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_2:\n-    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4:\n-    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8:\n-    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_16:\n+  update_mem_ref_hash_table (end, 1);\n+}\n \n-    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_1:\n-    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_2:\n-    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4:\n-    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8:\n-    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_16:\n+/* Instrument the call (to the builtin strlen function) pointed to by\n+   ITER.\n \n-    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_1:\n-    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_2:\n-    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_4:\n-    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_8:\n-    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_16:\n+   This function instruments the access to the first byte of the\n+   argument, right before the call.  After the call it instruments the\n+   access to the last byte of the argument; it uses the result of the\n+   call to deduce the offset of that last byte.\n \n-    case BUILT_IN_SYNC_LOCK_RELEASE_1:\n-    case BUILT_IN_SYNC_LOCK_RELEASE_2:\n-    case BUILT_IN_SYNC_LOCK_RELEASE_4:\n-    case BUILT_IN_SYNC_LOCK_RELEASE_8:\n-    case BUILT_IN_SYNC_LOCK_RELEASE_16:\n+   Upon completion, iff the call has actullay been instrumented, this\n+   function returns TRUE and *ITER points to the statement logically\n+   following the built-in strlen function call *ITER was initially\n+   pointing to.  Otherwise, the function returns FALSE and *ITER\n+   remains unchanged.  */\n \n-    case BUILT_IN_ATOMIC_EXCHANGE_1:\n-    case BUILT_IN_ATOMIC_EXCHANGE_2:\n-    case BUILT_IN_ATOMIC_EXCHANGE_4:\n-    case BUILT_IN_ATOMIC_EXCHANGE_8:\n-    case BUILT_IN_ATOMIC_EXCHANGE_16:\n+static bool\n+instrument_strlen_call (gimple_stmt_iterator *iter)\n+{\n+  gimple call = gsi_stmt (*iter);\n+  gcc_assert (is_gimple_call (call));\n \n-    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1:\n-    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2:\n-    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4:\n-    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8:\n-    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n+  tree callee = gimple_call_fndecl (call);\n+  gcc_assert (is_builtin_fn (callee)\n+\t      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN);\n \n-    case BUILT_IN_ATOMIC_STORE_1:\n-    case BUILT_IN_ATOMIC_STORE_2:\n-    case BUILT_IN_ATOMIC_STORE_4:\n-    case BUILT_IN_ATOMIC_STORE_8:\n-    case BUILT_IN_ATOMIC_STORE_16:\n+  tree len = gimple_call_lhs (call);\n+  if (len == NULL)\n+    /* Some passes might clear the return value of the strlen call;\n+       bail out in that case.  Return FALSE as we are not advancing\n+       *ITER.  */\n+    return false;\n+  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (len)));\n \n-    case BUILT_IN_ATOMIC_ADD_FETCH_1:\n-    case BUILT_IN_ATOMIC_ADD_FETCH_2:\n-    case BUILT_IN_ATOMIC_ADD_FETCH_4:\n-    case BUILT_IN_ATOMIC_ADD_FETCH_8:\n-    case BUILT_IN_ATOMIC_ADD_FETCH_16:\n+  location_t loc = gimple_location (call);\n+  tree str_arg = gimple_call_arg (call, 0);\n \n-    case BUILT_IN_ATOMIC_SUB_FETCH_1:\n-    case BUILT_IN_ATOMIC_SUB_FETCH_2:\n-    case BUILT_IN_ATOMIC_SUB_FETCH_4:\n-    case BUILT_IN_ATOMIC_SUB_FETCH_8:\n-    case BUILT_IN_ATOMIC_SUB_FETCH_16:\n+  /* Instrument the access to the first byte of str_arg.  i.e:\n \n-    case BUILT_IN_ATOMIC_AND_FETCH_1:\n-    case BUILT_IN_ATOMIC_AND_FETCH_2:\n-    case BUILT_IN_ATOMIC_AND_FETCH_4:\n-    case BUILT_IN_ATOMIC_AND_FETCH_8:\n-    case BUILT_IN_ATOMIC_AND_FETCH_16:\n+     _1 = str_arg; instrument (_1); */\n+  gimple str_arg_ssa =\n+    gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t  make_ssa_name (build_pointer_type\n+\t\t\t\t\t\t (char_type_node), NULL),\n+\t\t\t\t  str_arg, NULL);\n+  gimple_set_location (str_arg_ssa, loc);\n+  gimple_stmt_iterator gsi = *iter;\n+  gsi_insert_before (&gsi, str_arg_ssa, GSI_NEW_STMT);\n+  build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), &gsi,\n+\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n \n-    case BUILT_IN_ATOMIC_NAND_FETCH_1:\n-    case BUILT_IN_ATOMIC_NAND_FETCH_2:\n-    case BUILT_IN_ATOMIC_NAND_FETCH_4:\n-    case BUILT_IN_ATOMIC_NAND_FETCH_8:\n-    case BUILT_IN_ATOMIC_NAND_FETCH_16:\n+  /* If we initially had an instruction like:\n \n-    case BUILT_IN_ATOMIC_XOR_FETCH_1:\n-    case BUILT_IN_ATOMIC_XOR_FETCH_2:\n-    case BUILT_IN_ATOMIC_XOR_FETCH_4:\n-    case BUILT_IN_ATOMIC_XOR_FETCH_8:\n-    case BUILT_IN_ATOMIC_XOR_FETCH_16:\n+\t int n = strlen (str)\n \n-    case BUILT_IN_ATOMIC_OR_FETCH_1:\n-    case BUILT_IN_ATOMIC_OR_FETCH_2:\n-    case BUILT_IN_ATOMIC_OR_FETCH_4:\n-    case BUILT_IN_ATOMIC_OR_FETCH_8:\n-    case BUILT_IN_ATOMIC_OR_FETCH_16:\n+     we now want to instrument the access to str[n], after the\n+     instruction above.*/\n \n-    case BUILT_IN_ATOMIC_FETCH_ADD_1:\n-    case BUILT_IN_ATOMIC_FETCH_ADD_2:\n-    case BUILT_IN_ATOMIC_FETCH_ADD_4:\n-    case BUILT_IN_ATOMIC_FETCH_ADD_8:\n-    case BUILT_IN_ATOMIC_FETCH_ADD_16:\n+  /* So let's build the access to str[n] that is, access through the\n+     pointer_plus expr: (_1 + len).  */\n+  gimple stmt =\n+    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n+\t\t\t\t  make_ssa_name (TREE_TYPE (str_arg),\n+\t\t\t\t\t\t NULL),\n+\t\t\t\t  gimple_assign_lhs (str_arg_ssa),\n+\t\t\t\t  len);\n+  gimple_set_location (stmt, loc);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n \n-    case BUILT_IN_ATOMIC_FETCH_SUB_1:\n-    case BUILT_IN_ATOMIC_FETCH_SUB_2:\n-    case BUILT_IN_ATOMIC_FETCH_SUB_4:\n-    case BUILT_IN_ATOMIC_FETCH_SUB_8:\n-    case BUILT_IN_ATOMIC_FETCH_SUB_16:\n+  build_check_stmt (loc, gimple_assign_lhs (stmt), &gsi,\n+\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n \n-    case BUILT_IN_ATOMIC_FETCH_AND_1:\n-    case BUILT_IN_ATOMIC_FETCH_AND_2:\n-    case BUILT_IN_ATOMIC_FETCH_AND_4:\n-    case BUILT_IN_ATOMIC_FETCH_AND_8:\n-    case BUILT_IN_ATOMIC_FETCH_AND_16:\n+  /* Ensure that iter points to the statement logically following the\n+     one it was initially pointing to.  */\n+  *iter = gsi;\n+  /* As *ITER has been advanced to point to the next statement, let's\n+     return true to inform transform_statements that it shouldn't\n+     advance *ITER anymore; otherwises it will skip that next\n+     statement, which wouldn't be instrumented.  */\n+  return true;\n+}\n \n-    case BUILT_IN_ATOMIC_FETCH_NAND_1:\n-    case BUILT_IN_ATOMIC_FETCH_NAND_2:\n-    case BUILT_IN_ATOMIC_FETCH_NAND_4:\n-    case BUILT_IN_ATOMIC_FETCH_NAND_8:\n-    case BUILT_IN_ATOMIC_FETCH_NAND_16:\n+/* Instrument the call to a built-in memory access function that is\n+   pointed to by the iterator ITER.\n \n-    case BUILT_IN_ATOMIC_FETCH_XOR_1:\n-    case BUILT_IN_ATOMIC_FETCH_XOR_2:\n-    case BUILT_IN_ATOMIC_FETCH_XOR_4:\n-    case BUILT_IN_ATOMIC_FETCH_XOR_8:\n-    case BUILT_IN_ATOMIC_FETCH_XOR_16:\n+   Upon completion, return TRUE iff *ITER has been advanced to the\n+   statement following the one it was originally pointing to.  */\n \n-    case BUILT_IN_ATOMIC_FETCH_OR_1:\n-    case BUILT_IN_ATOMIC_FETCH_OR_2:\n-    case BUILT_IN_ATOMIC_FETCH_OR_4:\n-    case BUILT_IN_ATOMIC_FETCH_OR_8:\n-    case BUILT_IN_ATOMIC_FETCH_OR_16:\n-      {\n-\tdest = gimple_call_arg (call, 0);\n-\t/* So DEST represents the address of a memory location.\n-\t   instrument_derefs wants the memory location, so lets\n-\t   dereference the address DEST before handing it to\n-\t   instrument_derefs.  */\n-\tif (TREE_CODE (dest) == ADDR_EXPR)\n-\t  dest = TREE_OPERAND (dest, 0);\n-\telse if (TREE_CODE (dest) == SSA_NAME)\n-\t  dest = build2 (MEM_REF, TREE_TYPE (TREE_TYPE (dest)),\n-\t\t\t dest, build_int_cst (TREE_TYPE (dest), 0));\n-\telse\n-\t  gcc_unreachable ();\n+static bool\n+instrument_builtin_call (gimple_stmt_iterator *iter)\n+{\n+  bool iter_advanced_p = false;\n+  gimple call = gsi_stmt (*iter);\n \n-\tinstrument_derefs (iter, dest, loc, is_store);\n-\treturn false;\n-      }\n+  gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n \n-    default:\n-      /* The other builtins memory access are not instrumented in this\n-\t function because they either don't have any length parameter,\n-\t or their length parameter is just a limit.  */\n-      break;\n-    }\n+  tree callee = gimple_call_fndecl (call);\n+  location_t loc = gimple_location (call);\n \n-  if (len != NULL_TREE)\n+  if (DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN)\n+    iter_advanced_p = instrument_strlen_call (iter);\n+  else\n     {\n-      if (source0 != NULL_TREE)\n-\tinstrument_mem_region_access (source0, len, iter,\n-\t\t\t\t      loc, /*is_store=*/false);\n-      if (source1 != NULL_TREE)\n-\tinstrument_mem_region_access (source1, len, iter,\n-\t\t\t\t      loc, /*is_store=*/false);\n-      else if (dest != NULL_TREE)\n-\tinstrument_mem_region_access (dest, len, iter,\n-\t\t\t\t      loc, /*is_store=*/true);\n-\n-      *iter = gsi_for_stmt (call);\n-      return false;\n+      asan_mem_ref src0, src1, dest;\n+      asan_mem_ref_init (&src0, NULL, 1);\n+      asan_mem_ref_init (&src1, NULL, 1);\n+      asan_mem_ref_init (&dest, NULL, 1);\n+\n+      tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n+      bool src0_is_store = false, src1_is_store = false,\n+\tdest_is_store = false, dest_is_deref = false;\n+\n+      if (get_mem_refs_of_builtin_call (call,\n+\t\t\t\t\t&src0, &src0_len, &src0_is_store,\n+\t\t\t\t\t&src1, &src0_len, &src1_is_store,\n+\t\t\t\t\t&dest, &dest_len, &dest_is_store,\n+\t\t\t\t\t&dest_is_deref))\n+\t{\n+\t  if (dest_is_deref)\n+\t    {\n+\t      instrument_derefs (iter, dest.start, loc, dest_is_store);\n+\t      gsi_next (iter);\n+\t      iter_advanced_p = true;\n+\t    }\n+\t  else if (src0_len || src1_len || dest_len)\n+\t    {\n+\t      if (src0.start)\n+\t\tinstrument_mem_region_access (src0.start, src0_len,\n+\t\t\t\t\t      iter, loc, /*is_store=*/false);\n+\t      if (src1.start != NULL_TREE)\n+\t\tinstrument_mem_region_access (src1.start, src1_len,\n+\t\t\t\t\t      iter, loc, /*is_store=*/false);\n+\t      if (dest.start != NULL_TREE)\n+\t\tinstrument_mem_region_access (dest.start, dest_len,\n+\t\t\t\t\t      iter, loc, /*is_store=*/true);\n+\t      *iter = gsi_for_stmt (call);\n+\t      gsi_next (iter);\n+\t      iter_advanced_p = true;\n+\t    }\n+\t}\n     }\n-  return false;\n+  return iter_advanced_p;\n }\n \n /*  Instrument the assignment statement ITER if it is subject to\n-    instrumentation.  */\n+    instrumentation.  Return TRUE iff instrumentation actually\n+    happened.  In that case, the iterator ITER is advanced to the next\n+    logical expression following the one initially pointed to by ITER,\n+    and the relevant memory reference that which access has been\n+    instrumented is added to the memory references hash table.  */\n \n-static void\n-instrument_assignment (gimple_stmt_iterator *iter)\n+static bool\n+maybe_instrument_assignment (gimple_stmt_iterator *iter)\n {\n   gimple s = gsi_stmt (*iter);\n \n   gcc_assert (gimple_assign_single_p (s));\n \n+  tree ref_expr = NULL_TREE;\n+  bool is_store, is_instrumented = false;\n+\n   if (gimple_store_p (s))\n-    instrument_derefs (iter, gimple_assign_lhs (s),\n-\t\t       gimple_location (s), true);\n+    {\n+      ref_expr = gimple_assign_lhs (s);\n+      is_store = true;\n+      instrument_derefs (iter, ref_expr,\n+\t\t\t gimple_location (s),\n+\t\t\t is_store);\n+      is_instrumented = true;\n+    }\n+ \n   if (gimple_assign_load_p (s))\n-    instrument_derefs (iter, gimple_assign_rhs1 (s),\n-\t\t       gimple_location (s), false);\n+    {\n+      ref_expr = gimple_assign_rhs1 (s);\n+      is_store = false;\n+      instrument_derefs (iter, ref_expr,\n+\t\t\t gimple_location (s),\n+\t\t\t is_store);\n+      is_instrumented = true;\n+    }\n+\n+  if (is_instrumented)\n+    gsi_next (iter);\n+\n+  return is_instrumented;\n }\n \n /* Instrument the function call pointed to by the iterator ITER, if it\n@@ -1424,10 +1849,11 @@ static bool\n maybe_instrument_call (gimple_stmt_iterator *iter)\n {\n   gimple stmt = gsi_stmt (*iter);\n-  bool is_builtin = is_gimple_builtin_call (stmt);\n-  if (is_builtin\n-      && instrument_builtin_call (iter))\n+  bool is_builtin = gimple_call_builtin_p (stmt, BUILT_IN_NORMAL);\n+\n+  if (is_builtin && instrument_builtin_call (iter))\n     return true;\n+\n   if (gimple_call_noreturn_p (stmt))\n     {\n       if (is_builtin)\n@@ -1449,11 +1875,10 @@ maybe_instrument_call (gimple_stmt_iterator *iter)\n   return false;\n }\n \n-/* asan: this looks too complex. Can this be done simpler? */\n-/* Transform\n-   1) Memory references.\n-   2) BUILTIN_ALLOCA calls.\n-*/\n+/* Walk each instruction of all basic block and instrument those that\n+   represent memory references: loads, stores, or function calls.\n+   In a given basic block, this function avoids instrumenting memory\n+   references that have already been instrumented.  */\n \n static void\n transform_statements (void)\n@@ -1464,23 +1889,38 @@ transform_statements (void)\n \n   FOR_EACH_BB (bb)\n     {\n+      empty_mem_ref_hash_table ();\n+\n       if (bb->index >= saved_last_basic_block) continue;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i);)\n \t{\n \t  gimple s = gsi_stmt (i);\n \n-\t  if (gimple_assign_single_p (s))\n-\t    instrument_assignment (&i);\n-\t  else if (is_gimple_call (s))\n+\t  if (has_stmt_been_instrumented_p (s))\n+\t    gsi_next (&i);\n+\t  else if (gimple_assign_single_p (s)\n+\t\t   && maybe_instrument_assignment (&i))\n+\t    /*  Nothing to do as maybe_instrument_assignment advanced\n+\t\tthe iterator I.  */;\n+\t  else if (is_gimple_call (s) && maybe_instrument_call (&i))\n+\t    /*  Nothing to do as maybe_instrument_call\n+\t\tadvanced the iterator I.  */;\n+\t  else\n \t    {\n-\t      if (maybe_instrument_call (&i))\n-\t\t/* Avoid gsi_next (&i), because maybe_instrument_call\n-\t\t   advanced the I iterator already.  */\n-\t\tcontinue;\n+\t      /* No instrumentation happened.\n+\n+\t\t If the current instruction is a function call, let's\n+\t\t forget about the memory references that got\n+\t\t instrumented.  Otherwise we might miss some\n+\t\t instrumentation opportunities.  */\n+\t      if (is_gimple_call (s))\n+\t\tempty_mem_ref_hash_table ();\n+\n+\t      gsi_next (&i);\n \t    }\n-\t  gsi_next (&i);\n \t}\n     }\n+  free_mem_ref_resources ();\n }\n \n /* Build"}, {"sha": "ee182b0dda8de5fd96f43e11baa59b2f07118e0f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -1,3 +1,11 @@\n+2013-02-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tAvoid instrumenting duplicated memory access in the same basic block\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c: New test.\n+\t* testsuite/c-c++-common/asan/no-redundant-instrumentation-2.c: Likewise.\n+\t* testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c: Likewise.\n+\t* testsuite/c-c++-common/asan/inc.c: Likewise.\n+\n 2013-02-12  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR inline-asm/56148"}, {"sha": "b9c6734eae0e01159661cd8db8df73c3481ece86", "filename": "gcc/testsuite/c-c++-common/asan/inc.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+void\n+foo(int *a)\n+{\n+  (*a)++;\n+}\n+\n+int\n+main ()\n+{\n+  int a = 0;\n+  foo (&a);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 1 \"asan0\" } }  */\n+/* { dg-final { scan-tree-dump \"__builtin___asan_report_load4\" \"asan0\" } }  */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "cc98fdba9b87c34638bb3c9a4d767f7eda4463f0", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -0,0 +1,66 @@\n+/* This tests that when faced with two references to the same memory\n+   location in the same basic block, the second reference should not\n+   be instrumented by the Address Sanitizer.  */\n+\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+static char tab[4] = {0};\n+\n+static int\n+test0 ()\n+{\n+  /* __builtin___asan_report_store1 called 2 times for the two stores\n+     below.  */\n+  tab[0] = 1;\n+  tab[1] = 2;\n+\n+  /* __builtin___asan_report_load1 called 1 time for the store\n+     below.  */\n+  char t0 = tab[1];\n+\n+  /* This load should not be instrumented because it is to the same\n+     memory location as above.  */\n+  char t1 = tab[1];\n+\n+  return t0 + t1;\n+}\n+\n+static int\n+test1 ()\n+{\n+  /*__builtin___asan_report_store1 called 1 time here to instrument\n+    the initialization.  */\n+  char foo[4] = {1}; \n+\n+  /*__builtin___asan_report_store1 called 2 times here to instrument\n+    the store to the memory region of tab.  */\n+  __builtin_memset (tab, 3, sizeof (tab));\n+\n+  /* There is no instrumentation for the two memset calls below.  */\n+  __builtin_memset (tab, 4, sizeof (tab));\n+  __builtin_memset (tab, 5, sizeof (tab));\n+\n+  /* There are 2 calls to __builtin___asan_report_store1 and 2 calls\n+     to __builtin___asan_report_load1 to instrument the store to\n+     (subset of) the memory region of tab.  */\n+  __builtin_memcpy (&tab[1], foo, sizeof (tab) - 1);\n+\n+  /* This should not generate a __builtin___asan_report_load1 because\n+     the reference to tab[1] has been already instrumented above.  */\n+  return tab[1];\n+\n+  /* So for these function, there should be 7 calls to\n+     __builtin___asan_report_store1.  */\n+}\n+\n+int\n+main ()\n+{\n+  return test0 () && test1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 7 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 2 \"asan0\" }  } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "28525e0ff0d92d71bd36f8610069d34eba44ad62", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -0,0 +1,25 @@\n+/* This tests that when faced with two references to the same memory\n+   location in the same basic block, the second reference should not\n+   be instrumented by the Address Sanitizer.  But in case of access to\n+   overlapping regions we must be precise.  */\n+\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+int\n+main ()\n+{\n+  char tab[5];\n+\n+  /* Here, we instrument the access at offset 0 and access at offset\n+     4.  */\n+  __builtin_memset (tab, 1, sizeof (tab));\n+  /* We instrumented access at offset 0 above already, so only access\n+     at offset 3 is instrumented.  */\n+  __builtin_memset (tab, 1, 3);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 3 \"asan0\" }  } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "420a26309025a221660812a90761bcb0bb90ba94", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcbe80c52f4cec942890eda8520d553edff998f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c?ref=bdcbe80c52f4cec942890eda8520d553edff998f", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+char\n+foo (__INT32_TYPE__ *p)\n+{\n+  /* This generates a __builtin___asan_report_load1.  */\n+  __INT32_TYPE__ ret = *(char *) p;\n+  /* This generates a __builtin___asan_report_store4 depending on the.  */\n+  *p = 26;\n+  return ret; \n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store\" 1 \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}]}