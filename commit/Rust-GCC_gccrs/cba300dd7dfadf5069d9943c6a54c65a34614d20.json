{"sha": "cba300dd7dfadf5069d9943c6a54c65a34614d20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JhMzAwZGQ3ZGZhZGY1MDY5ZDk5NDNjNmE1NGM2NWEzNDYxNGQyMA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-01-10T09:42:10Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-01-10T09:42:10Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\nlibgcc/\n\tPR target/49868\n\tExtend __pgmx semantics to linearize memory.\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _xload_1, _movmemx.\n\t* config/avr/lib1funcs.S (__xload_1): New function.\n\t(__movmemx_qi, __movmemx_hi): New functions.\n\t(__xload_2, __xload_3, __xload_4): Rewrite to fit new __pgmx\n\tsemantics.\n\ngcc/\n\tPR target/49868\n\tExtend __pgmx semantics to linearize memory.\n\t* config/avr/avr.md (mov<mode>): Use avr_xload_libgcc_p to\n\tdetermine if code comes inline or from libgcc.\n\t(MOVMEM_r_d:HI): Add \"w\" to constraint for better preference.\n\t(movmem_qi, movmem_qi): Set constraint #2 to \"n\".\n\t(movmem_qi_elpm, movmem_hi_elpm): Remove insns.\n\t(movmemx_qi, movmemx_hi): New insns.\n\t(xload_<mode>_libgcc): Rewrite to new insn condition.\n\t(xload_<mode>): Remove insns.\n\t* config/avr/avr.c (avr_out_xload): Rewrite: Only need to handle\n\tcases that don't satisfy avr_xload_libgcc_p().\n\t(avr_addr_space_convert): Allow converting in any direction.\n\t(avr_addr_space_subset_p): Return always true.\n\t(avr_xload_libgcc_p): Rewrite to fit new __pgmx semantics.\n\t(avr_emit_movmemhi): Ditto.\n\t(avr_out_lpm): No need to handle ADDR_SPACE_PGMX any more.\n\t(avr_out_movmem): Ditto.\n\t(AVR_SYMBOL_FLAG_PROGMEM): New macro.\n\t(AVR_SYMBOL_SET_ADDR_SPACE): New macro.\n\t(AVR_SYMBOL_GET_ADDR_SPACE): New macro.\n\t(avr_encode_section_info): Encode 'progmem' in symbol flags.\n\t(output_reload_in_const): Don't zero-extend any 24-bit symbols.\n\nFrom-SVN: r183058", "tree": {"sha": "835d7eb99a52b9c049a452e8468cb7613fa1e7ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/835d7eb99a52b9c049a452e8468cb7613fa1e7ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cba300dd7dfadf5069d9943c6a54c65a34614d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba300dd7dfadf5069d9943c6a54c65a34614d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba300dd7dfadf5069d9943c6a54c65a34614d20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba300dd7dfadf5069d9943c6a54c65a34614d20/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c615478de5b0f61ee750b8e0d21b5219407aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c615478de5b0f61ee750b8e0d21b5219407aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c615478de5b0f61ee750b8e0d21b5219407aba"}], "stats": {"total": 611, "additions": 345, "deletions": 266}, "files": [{"sha": "14d3d4d6ecb5c5aafce858f14d01ab6c10c60199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -1,3 +1,29 @@\n+2012-01-10  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\tExtend __pgmx semantics to linearize memory.\n+\t* config/avr/avr.md (mov<mode>): Use avr_xload_libgcc_p to\n+\tdetermine if code comes inline or from libgcc.\n+\t(MOVMEM_r_d:HI): Add \"w\" to constraint for better preference.\n+\t(movmem_qi, movmem_qi): Set constraint #2 to \"n\".\n+\t(movmem_qi_elpm, movmem_hi_elpm): Remove insns.\n+\t(movmemx_qi, movmemx_hi): New insns.\n+\t(xload_<mode>_libgcc): Rewrite to new insn condition.\n+\t(xload_<mode>): Remove insns.\n+\t* config/avr/avr.c (avr_out_xload): Rewrite: Only need to handle\n+\tcases that don't satisfy avr_xload_libgcc_p().\n+\t(avr_addr_space_convert): Allow converting in any direction.\n+\t(avr_addr_space_subset_p): Return always true.\n+\t(avr_xload_libgcc_p): Rewrite to fit new __pgmx semantics.\n+\t(avr_emit_movmemhi): Ditto.\n+\t(avr_out_lpm): No need to handle ADDR_SPACE_PGMX any more.\n+\t(avr_out_movmem): Ditto.\n+\t(AVR_SYMBOL_FLAG_PROGMEM): New macro.\n+\t(AVR_SYMBOL_SET_ADDR_SPACE): New macro.\n+\t(AVR_SYMBOL_GET_ADDR_SPACE): New macro.\n+\t(avr_encode_section_info): Encode 'progmem' in symbol flags.\n+\t(output_reload_in_const): Don't zero-extend any 24-bit symbols.\n+\n 2012-01-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50913"}, {"sha": "8d0a57fd1df67b915baa273fe63e04155ce1a7d1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 131, "deletions": 173, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -62,6 +62,22 @@\n    This must be the rightmost field of machine dependent section flags.  */\n #define AVR_SECTION_PROGMEM (0xf * SECTION_MACH_DEP)\n \n+/* Similar 4-bit region for SYMBOL_REF_FLAGS.  */\n+#define AVR_SYMBOL_FLAG_PROGMEM (0xf * SYMBOL_FLAG_MACH_DEP)\n+\n+/* Similar 4-bit region in SYMBOL_REF_FLAGS:\n+   Set address-space AS in SYMBOL_REF_FLAGS of SYM  */\n+#define AVR_SYMBOL_SET_ADDR_SPACE(SYM,AS)                       \\\n+  do {                                                          \\\n+    SYMBOL_REF_FLAGS (sym) &= ~AVR_SYMBOL_FLAG_PROGMEM;         \\\n+    SYMBOL_REF_FLAGS (sym) |= (AS) * SYMBOL_FLAG_MACH_DEP;      \\\n+  } while (0)\n+\n+/* Read address-space from SYMBOL_REF_FLAGS of SYM  */\n+#define AVR_SYMBOL_GET_ADDR_SPACE(SYM)                          \\\n+  ((SYMBOL_REF_FLAGS (sym) & AVR_SYMBOL_FLAG_PROGMEM)           \\\n+   / SYMBOL_FLAG_MACH_DEP)\n+\n /* Known address spaces.  The order must be the same as in the respective\n    enum from avr.h (or designated initialized must be used).  */\n const avr_addrspace_t avr_addrspace[] =\n@@ -2427,8 +2443,7 @@ avr_xload_libgcc_p (enum machine_mode mode)\n   int n_bytes = GET_MODE_SIZE (mode);\n   \n   return (n_bytes > 1\n-          && avr_current_arch->n_segments > 1\n-          && !AVR_HAVE_ELPMX);\n+          || avr_current_arch->n_segments > 1);\n }\n \n \n@@ -2597,8 +2612,7 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n   int regno_dest;\n   int segment;\n   RTX_CODE code;\n-  \n-  addr_space_t as;\n+  addr_space_t as = MEM_ADDR_SPACE (src);\n \n   if (plen)\n     *plen = 0;\n@@ -2611,24 +2625,11 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n       return \"\";\n     }\n \n-  as = MEM_ADDR_SPACE (src);\n-\n   addr = XEXP (src, 0);\n   code = GET_CODE (addr);\n \n   gcc_assert (REG_P (dest));\n-  \n-  if (as == ADDR_SPACE_PGMX)\n-    {\n-      /* We are called from avr_out_xload because someone wrote\n-         __pgmx on a device with just one flash segment.  */\n-\n-      gcc_assert (LO_SUM == code);\n-\n-      addr = XEXP (addr, 1);\n-    }\n-  else\n-    gcc_assert (REG == code || POST_INC == code);\n+  gcc_assert (REG == code || POST_INC == code);\n \n   xop[0] = dest;\n   xop[1] = addr;\n@@ -2766,76 +2767,28 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n }\n \n \n-/* Worker function for xload_<mode> and xload_8 insns.  */\n+/* Worker function for xload_8 insn.  */\n \n const char*\n-avr_out_xload (rtx insn, rtx *op, int *plen)\n+avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n {\n-  rtx xop[5];\n-  rtx reg = op[0];\n-  int n_bytes = GET_MODE_SIZE (GET_MODE (reg));\n-  unsigned int regno = REGNO (reg);\n-\n-  if (avr_current_arch->n_segments == 1)\n-    return avr_out_lpm (insn, op, plen);\n+  rtx xop[4];\n \n-  xop[0] = reg;\n+  xop[0] = op[0];\n   xop[1] = op[1];\n   xop[2] = lpm_addr_reg_rtx;\n-  xop[3] = lpm_reg_rtx;\n-  xop[4] = tmp_reg_rtx;\n-  \n-  avr_asm_len (\"out __RAMPZ__,%1\", xop, plen, -1);\n-  \n-  if (1 == n_bytes)\n-    {\n-      if (AVR_HAVE_ELPMX)\n-        return avr_asm_len (\"elpm %0,%a2\", xop, plen, 1);\n-      else\n-        return avr_asm_len (\"elpm\" CR_TAB\n-                            \"mov %0,%3\", xop, plen, 2);\n-    }\n-\n-  gcc_assert (AVR_HAVE_ELPMX);\n-  \n-  if (!reg_overlap_mentioned_p (reg, lpm_addr_reg_rtx))\n-    {\n-      /* Insn clobbers the Z-register so we can use post-increment.  */\n-      \n-      avr_asm_len                    (\"elpm %A0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 2)  avr_asm_len (\"elpm %B0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 3)  avr_asm_len (\"elpm %C0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 4)  avr_asm_len (\"elpm %D0,%a2+\", xop, plen, 1);\n-\n-      return \"\";\n-    }\n+  xop[3] = AVR_HAVE_LPMX ? op[0] : lpm_reg_rtx;\n \n-  switch (n_bytes)\n-    {\n-    default:\n-      gcc_unreachable();\n-      \n-    case 2:\n-      gcc_assert (regno == REGNO (lpm_addr_reg_rtx));\n+  if (plen)\n+    *plen = 0;\n \n-      return avr_asm_len (\"elpm %4,%a2+\" CR_TAB\n-                          \"elpm %B0,%a2\" CR_TAB\n-                          \"mov %A0,%4\", xop, plen, 3);\n+  avr_asm_len (\"ld %3,%a2\" CR_TAB\n+               \"sbrs %1,7\", xop, plen, 2);\n \n-    case 3:\n-    case 4:\n-      gcc_assert (regno + 2 == REGNO (lpm_addr_reg_rtx));\n-      \n-      avr_asm_len (\"elpm %A0,%a2+\" CR_TAB\n-                   \"elpm %B0,%a2+\", xop, plen, 2);\n+  avr_asm_len (AVR_HAVE_LPMX ? \"lpm %3,%a2\" : \"lpm\", xop, plen, 1);\n \n-      if (n_bytes == 3)\n-        return avr_asm_len (\"elpm %C0,%a2\", xop, plen, 1);\n-      else\n-        return avr_asm_len (\"elpm %4,%a2+\" CR_TAB\n-                            \"elpm %D0,%a2\" CR_TAB\n-                            \"mov %C0,%4\", xop, plen, 3);\n-    }\n+  if (REGNO (xop[0]) != REGNO (xop[3]))\n+    avr_asm_len (\"mov %0,%3\", xop, plen, 1);\n   \n   return \"\";\n }\n@@ -6673,8 +6626,8 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       default_assemble_integer (avr_const_address_lo16 (x),\n                                 GET_MODE_SIZE (HImode), aligned_p);\n       \n-      fputs (\"\\t.warning\\t\\\"assembling 24-bit address needs binutils extension for hh8(\",\n-             asm_out_file);\n+      fputs (\"\\t.warning\\t\\\"assembling 24-bit address needs binutils\"\n+             \" extension for hh8(\", asm_out_file);\n       output_addr_const (asm_out_file, x);\n       fputs (\")\\\"\\n\", asm_out_file);\n       \n@@ -7277,6 +7230,23 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n     }\n \n   default_encode_section_info (decl, rtl, new_decl_p);\n+\n+  if (decl && DECL_P (decl)\n+      && TREE_CODE (decl) != FUNCTION_DECL\n+      && MEM_P (rtl)\n+      && SYMBOL_REF == GET_CODE (XEXP (rtl, 0)))\n+   {\n+      rtx sym = XEXP (rtl, 0);\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n+\n+      /* PSTR strings are in generic space but located in flash:\n+         patch address space.  */\n+      \n+      if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n+        as = ADDR_SPACE_PGM;\n+\n+      AVR_SYMBOL_SET_ADDR_SPACE (sym, as);\n+    }\n }\n \n \n@@ -9019,10 +8989,8 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n           xop[1] = src;\n           xop[2] = clobber_reg;\n \n-          if (n >= 2 + (avr_current_arch->n_segments > 1))\n-            avr_asm_len (\"mov %0,__zero_reg__\", xop, len, 1);\n-          else\n-            avr_asm_len (asm_code[n][ldreg_p], xop, len, ldreg_p ? 1 : 2);\n+          avr_asm_len (asm_code[n][ldreg_p], xop, len, ldreg_p ? 1 : 2);\n+          \n           continue;\n         }\n \n@@ -9596,51 +9564,57 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n     avr_edump (\"\\n%!: op = %r\\nfrom = %t\\nto = %t\\n\",\n                src, type_from, type_to);\n \n+  /* Up-casting from 16-bit to 24-bit pointer.  */\n+  \n   if (as_from != ADDR_SPACE_PGMX\n       && as_to == ADDR_SPACE_PGMX)\n     {\n-      rtx new_src;\n-      int n_segments = avr_current_arch->n_segments;\n-      RTX_CODE code = GET_CODE (src);\n+      int msb;\n+      rtx sym = src;\n+      rtx reg = gen_reg_rtx (PSImode);\n+\n+      while (CONST == GET_CODE (sym) || PLUS == GET_CODE (sym))\n+        sym = XEXP (sym, 0);\n+\n+      /* Look at symbol flags:  avr_encode_section_info set the flags\n+         also if attribute progmem was seen so that we get the right\n+         promotion for, e.g. PSTR-like strings that reside in generic space\n+         but are located in flash.  In that case we patch the incoming\n+         address space.  */\n \n-      if (CONST == code\n-          && PLUS == GET_CODE (XEXP (src, 0))\n-          && SYMBOL_REF == GET_CODE (XEXP (XEXP (src, 0), 0))\n-          && CONST_INT_P (XEXP (XEXP (src, 0), 1)))\n+      if (SYMBOL_REF == GET_CODE (sym)\n+          && ADDR_SPACE_PGM == AVR_SYMBOL_GET_ADDR_SPACE (sym))\n         {\n-          HOST_WIDE_INT offset = INTVAL (XEXP (XEXP (src, 0), 1));\n-          const char *name = XSTR (XEXP (XEXP (src, 0), 0), 0);\n-          \n-          new_src = gen_rtx_SYMBOL_REF (PSImode, ggc_strdup (name));\n-          new_src = gen_rtx_CONST (PSImode,\n-                                   plus_constant (new_src, offset));\n-          return new_src;\n+          as_from = ADDR_SPACE_PGM;\n         }\n \n-      if (SYMBOL_REF == code)\n-          {\n-            const char *name = XSTR (src, 0);\n-            \n-            return gen_rtx_SYMBOL_REF (PSImode, ggc_strdup (name));\n-          }\n-      \n+      /* Linearize memory: RAM has bit 23 set.  */\n+             \n+      msb = ADDR_SPACE_GENERIC_P (as_from)\n+        ? 0x80\n+        : avr_addrspace[as_from].segment % avr_current_arch->n_segments;\n+\n       src = force_reg (Pmode, src);\n       \n-      if (ADDR_SPACE_GENERIC_P (as_from)\n-          || as_from == ADDR_SPACE_PGM\n-          || n_segments == 1)\n-        {\n-          return gen_rtx_ZERO_EXTEND (PSImode, src);\n-        }\n-      else\n-        {\n-          int segment = avr_addrspace[as_from].segment % n_segments;\n+      emit_insn (msb == 0\n+                 ? gen_zero_extendhipsi2 (reg, src)\n+                 : gen_n_extendhipsi2 (reg, gen_int_mode (msb, QImode), src));\n+          \n+      return reg;\n+    }\n \n-          new_src = gen_reg_rtx (PSImode);\n-          emit_insn (gen_n_extendhipsi2 (new_src, GEN_INT (segment), src));\n+  /* Down-casting from 24-bit to 16-bit throws away the high byte.  */\n \n-          return new_src;\n-        }\n+  if (as_from == ADDR_SPACE_PGMX\n+      && as_to != ADDR_SPACE_PGMX)\n+    {\n+      rtx new_src = gen_reg_rtx (Pmode);\n+\n+      src = force_reg (PSImode, src);\n+      \n+      emit_move_insn (new_src,\n+                      simplify_gen_subreg (Pmode, src, PSImode, 0));\n+      return new_src;\n     }\n   \n   return src;\n@@ -9650,19 +9624,16 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n /* Implement `TARGET_ADDR_SPACE_SUBSET_P'.  */\n \n static bool\n-avr_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+avr_addr_space_subset_p (addr_space_t subset ATTRIBUTE_UNUSED,\n+                         addr_space_t superset ATTRIBUTE_UNUSED)\n {\n-  if (subset == ADDR_SPACE_PGMX\n-      && superset != ADDR_SPACE_PGMX)\n-    {\n-      return false;\n-    }\n+  /* Allow any kind of pointer mess.  */\n   \n   return true;\n }\n \n \n-/* Worker function for movmemhi insn.\n+/* Worker function for movmemhi expander.\n    XOP[0]  Destination as MEM:BLK\n    XOP[1]  Source      \"     \"\n    XOP[2]  # Bytes to copy\n@@ -9692,54 +9663,50 @@ avr_emit_movmemhi (rtx *xop)\n   a_src  = XEXP (xop[1], 0);\n   a_dest = XEXP (xop[0], 0);\n \n-  /* See if constant fits in 8 bits.  */\n-\n-  loop_mode = (count <= 0x100) ? QImode : HImode;\n-\n   if (PSImode == GET_MODE (a_src))\n     {\n+      gcc_assert (as == ADDR_SPACE_PGMX);\n+\n+      loop_mode = (count < 0x100) ? QImode : HImode;\n+      loop_reg = gen_rtx_REG (loop_mode, 24);\n+      emit_move_insn (loop_reg, gen_int_mode (count, loop_mode));\n+\n       addr1 = simplify_gen_subreg (HImode, a_src, PSImode, 0);\n       a_hi8 = simplify_gen_subreg (QImode, a_src, PSImode, 2);\n     }\n   else\n     {\n       int segment = avr_addrspace[as].segment % avr_current_arch->n_segments;\n       \n+      if (segment\n+          && avr_current_arch->n_segments > 1)\n+        {\n+          a_hi8 = GEN_INT (segment);\n+          emit_move_insn (rampz_rtx, a_hi8 = copy_to_mode_reg (QImode, a_hi8));\n+        }\n+      else if (!ADDR_SPACE_GENERIC_P (as))\n+        {\n+          as = ADDR_SPACE_PGM;\n+        }\n+      \n       addr1 = a_src;\n \n-      if (segment)\n-        a_hi8 = GEN_INT (segment);\n-    }\n-\n-  if (a_hi8\n-      && avr_current_arch->n_segments > 1)\n-    {\n-      emit_move_insn (rampz_rtx, a_hi8 = copy_to_mode_reg (QImode, a_hi8));\n-    }\n-  else if (!ADDR_SPACE_GENERIC_P (as))\n-    {\n-      as = ADDR_SPACE_PGM;\n+      loop_mode = (count <= 0x100) ? QImode : HImode;\n+      loop_reg = copy_to_mode_reg (loop_mode, gen_int_mode (count, loop_mode));\n     }\n \n   xas = GEN_INT (as);\n \n-  /* Create loop counter register */\n-\n-  loop_reg = copy_to_mode_reg (loop_mode, gen_int_mode (count, loop_mode));\n-\n-  /* Copy pointers into new pseudos - they will be changed */\n-\n-  addr0 = copy_to_mode_reg (HImode, a_dest);\n-  addr1 = copy_to_mode_reg (HImode, addr1);\n-\n   /* FIXME: Register allocator might come up with spill fails if it is left\n-        on its own.  Thus, we allocate the pointer registers by hand.  */\n+        on its own.  Thus, we allocate the pointer registers by hand:\n+        Z = source address\n+        X = destination address  */\n \n   emit_move_insn (lpm_addr_reg_rtx, addr1);\n   addr1 = lpm_addr_reg_rtx;\n \n   reg_x = gen_rtx_REG (HImode, REG_X);\n-  emit_move_insn (reg_x, addr0);\n+  emit_move_insn (reg_x, a_dest);\n   addr0 = reg_x;\n \n   /* FIXME: Register allocator does a bad job and might spill address\n@@ -9748,30 +9715,30 @@ avr_emit_movmemhi (rtx *xop)\n         load and store as seperate insns.  Instead, we perform the copy\n         by means of one monolithic insn.  */\n \n-  if (ADDR_SPACE_GENERIC_P (as))\n+  gcc_assert (TMP_REGNO == LPM_REGNO);\n+\n+  if (as != ADDR_SPACE_PGMX)\n     {\n+      /* Load instruction ([E]LPM or LD) is known at compile time:\n+         Do the copy-loop inline.  */\n+      \n       rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n         = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n \n       insn = fun (addr0, addr1, xas, loop_reg,\n                   addr0, addr1, tmp_reg_rtx, loop_reg);\n     }\n-  else if (as == ADDR_SPACE_PGM)\n-    {\n-      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n-        = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n-\n-      insn = fun (addr0, addr1, xas, loop_reg, addr0, addr1,\n-                  AVR_HAVE_LPMX ? tmp_reg_rtx : lpm_reg_rtx, loop_reg);\n-    }\n   else\n     {\n+      rtx loop_reg16 = gen_rtx_REG (HImode, 24);\n+      rtx r23 = gen_rtx_REG (QImode, 23);\n       rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n-        = QImode == loop_mode ? gen_movmem_qi_elpm : gen_movmem_hi_elpm;\n+        = QImode == loop_mode ? gen_movmemx_qi : gen_movmemx_hi;\n+\n+      emit_move_insn (r23, a_hi8);\n       \n       insn = fun (addr0, addr1, xas, loop_reg, addr0, addr1,\n-                  AVR_HAVE_ELPMX ? tmp_reg_rtx : lpm_reg_rtx, loop_reg,\n-                  a_hi8, a_hi8, GEN_INT (RAMPZ_ADDR));\n+                  lpm_reg_rtx, loop_reg16, r23, r23, GEN_INT (RAMPZ_ADDR));\n     }\n \n   set_mem_addr_space (SET_SRC (XVECEXP (insn, 0, 0)), as);\n@@ -9838,21 +9805,12 @@ avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n     case ADDR_SPACE_PGM3:\n     case ADDR_SPACE_PGM4:\n     case ADDR_SPACE_PGM5:\n-    case ADDR_SPACE_PGMX:\n \n       if (AVR_HAVE_ELPMX)\n         avr_asm_len (\"elpm %6,%a1+\", xop, plen, 1);\n       else\n         avr_asm_len (\"elpm\" CR_TAB\n                      \"adiw %1,1\", xop, plen, 2);\n-      \n-      if (as == ADDR_SPACE_PGMX\n-          && !AVR_HAVE_ELPMX)\n-        {\n-          avr_asm_len (\"adc %8,__zero_reg__\" CR_TAB\n-                       \"out __RAMPZ__,%8\", xop, plen, 2);\n-        }\n-      \n       break;\n     }\n "}, {"sha": "7ce211d211fe305ea4fb8130673ad217383a214e", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 35, "deletions": 71, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -390,6 +390,7 @@\n         (match_operand:QI 1 \"memory_operand\"    \"m\"))\n    (clobber (reg:HI REG_Z))]\n   \"can_create_pseudo_p()\n+   && !avr_xload_libgcc_p (QImode)\n    && avr_mem_pgmx_p (operands[1])\n    && REG_P (XEXP (operands[1], 0))\"\n   { gcc_unreachable(); }\n@@ -414,8 +415,7 @@\n         (match_operand:MOVMODE 1 \"memory_operand\"    \"m\"))\n    (clobber (reg:QI 21))\n    (clobber (reg:HI REG_Z))]\n-  \"QImode != <MODE>mode\n-   && can_create_pseudo_p()\n+  \"can_create_pseudo_p()\n    && avr_mem_pgmx_p (operands[1])\n    && REG_P (XEXP (operands[1], 0))\"\n   { gcc_unreachable(); }\n@@ -426,52 +426,39 @@\n     rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n     rtx addr_hi8 = simplify_gen_subreg (QImode, addr, PSImode, 2);\n     addr_space_t as = MEM_ADDR_SPACE (operands[1]);\n-    rtx hi8, insn;\n+    rtx insn;\n \n+    /* Split the address to R21:Z */\n     emit_move_insn (reg_z, simplify_gen_subreg (HImode, addr, PSImode, 0));\n+    emit_move_insn (gen_rtx_REG (QImode, 21), addr_hi8);\n \n-    if (avr_xload_libgcc_p (<MODE>mode))\n-      {\n-        emit_move_insn (gen_rtx_REG (QImode, 21), addr_hi8);\n-        insn = emit_insn (gen_xload_<mode>_libgcc ());\n-        emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, 22));\n-      }\n-    else if (avr_current_arch->n_segments == 1\n-             && GET_MODE_SIZE (<MODE>mode) > 2\n-             && !AVR_HAVE_LPMX)\n-      {\n-        rtx src = gen_rtx_MEM (<MODE>mode, reg_z);\n-\n-        as = ADDR_SPACE_PGM;\n-        insn = emit_insn (gen_load_<mode>_libgcc (src));\n-        emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, 22));\n-      }\n-    else\n-      {\n-        hi8 = gen_reg_rtx (QImode);\n-        emit_move_insn (hi8, addr_hi8);\n-        insn = emit_insn (gen_xload_<mode> (operands[0], hi8));\n-      }\n-\n+    /* Load with code from libgcc */\n+    insn = emit_insn (gen_xload_<mode>_libgcc ());\n     set_mem_addr_space (SET_SRC (single_set (insn)), as);\n \n+    /* Move to destination */\n+    emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, 22));\n+\n     DONE;\n   })\n \n ;; Move value from address space pgmx to a register\n ;; These insns must be prior to respective generic move insn.\n \n (define_insn \"xload_8\"\n-  [(set (match_operand:QI 0 \"register_operand\"                    \"=r\")\n-        (mem:QI (lo_sum:PSI (match_operand:QI 1 \"register_operand\" \"r\")\n+  [(set (match_operand:QI 0 \"register_operand\"                   \"=&r,r\")\n+        (mem:QI (lo_sum:PSI (match_operand:QI 1 \"register_operand\" \"r,r\")\n                             (reg:HI REG_Z))))]\n-  \"\"\n+  \"!avr_xload_libgcc_p (QImode)\"\n   {\n     return avr_out_xload (insn, operands, NULL);\n   }\n-  [(set_attr \"adjust_len\" \"xload\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"length\" \"3,4\")\n+   (set_attr \"adjust_len\" \"*,xload\")\n+   (set_attr \"isa\" \"lpmx,lpm\")\n+   (set_attr \"cc\" \"none\")])\n \n+;; \"xload_qi_libgcc\"\n ;; \"xload_hi_libgcc\"\n ;; \"xload_psi_libgcc\"\n ;; \"xload_si_libgcc\"\n@@ -482,35 +469,14 @@\n                                  (reg:HI REG_Z))))\n    (clobber (reg:QI 21))\n    (clobber (reg:HI REG_Z))]\n-  \"<MODE>mode != QImode\n-   && avr_xload_libgcc_p (<MODE>mode)\"\n+  \"avr_xload_libgcc_p (<MODE>mode)\"\n   {\n     rtx x_bytes = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n \n-    /* Devices with ELPM* also have CALL.  */\n-\n-    output_asm_insn (\"call __xload_%0\", &x_bytes);\n+    output_asm_insn (\"%~call __xload_%0\", &x_bytes);\n     return \"\";\n   }\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-;; \"xload_hi\"\n-;; \"xload_psi\"\n-;; \"xload_si\"\n-;; \"xload_sf\"\n-(define_insn \"xload_<mode>\"\n-  [(set (match_operand:MOVMODE 0 \"register_operand\"                    \"=r\")\n-        (mem:MOVMODE (lo_sum:PSI (match_operand:QI 1 \"register_operand\" \"r\")\n-                                 (reg:HI REG_Z))))\n-   (clobber (scratch:HI))\n-   (clobber (reg:HI REG_Z))]\n-  \"<MODE>mode != QImode\n-   && !avr_xload_libgcc_p (<MODE>mode)\"\n-  {\n-    return avr_out_xload (insn, operands, NULL);\n-  }\n-  [(set_attr \"adjust_len\" \"xload\")\n+  [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -521,7 +487,6 @@\n ;; \"movsi\"\n ;; \"movsf\"\n ;; \"movpsi\"\n-\n (define_expand \"mov<mode>\"\n   [(set (match_operand:MOVMODE 0 \"nonimmediate_operand\" \"\")\n         (match_operand:MOVMODE 1 \"general_operand\" \"\"))]\n@@ -548,7 +513,7 @@\n       if (!REG_P (addr))\n         src = replace_equiv_address (src, copy_to_mode_reg (PSImode, addr));\n \n-      if (QImode == <MODE>mode)\n+      if (!avr_xload_libgcc_p (<MODE>mode))\n         emit_insn (gen_xload8_A (dest, src));\n       else\n         emit_insn (gen_xload<mode>_A (dest, src));\n@@ -869,10 +834,10 @@\n   })\n \n (define_mode_attr MOVMEM_r_d [(QI \"r\")\n-                              (HI \"d\")])\n+                              (HI \"wd\")])\n \n-;; $0, $4 : & dest\n-;; $1, $5 : & src\n+;; $0, $4 : & dest (REG_X)\n+;; $1, $5 : & src  (REG_Z)\n ;; $2     : Address Space\n ;; $3, $7 : Loop register\n ;; $6     : Scratch register\n@@ -882,7 +847,7 @@\n (define_insn \"movmem_<mode>\"\n   [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"x\"))\n         (mem:BLK (match_operand:HI 1 \"register_operand\" \"z\")))\n-   (unspec [(match_operand:QI 2 \"const_int_operand\"     \"LP\")]\n+   (unspec [(match_operand:QI 2 \"const_int_operand\"     \"n\")]\n            UNSPEC_MOVMEM)\n    (use (match_operand:QIHI 3 \"register_operand\"       \"<MOVMEM_r_d>\"))\n    (clobber (match_operand:HI 4 \"register_operand\"     \"=0\"))\n@@ -897,29 +862,28 @@\n    (set_attr \"cc\" \"clobber\")])\n \n ;; Ditto and\n-;; $8, $9 : hh8 (& src)\n+;; $3, $7 : Loop register = R24\n+;; $8, $9 : hh8 (& src)   = R23\n ;; $10    : RAMPZ_ADDR\n \n-;; \"movmem_qi_elpm\"\n-;; \"movmem_hi_elpm\"\n-(define_insn \"movmem_<mode>_elpm\"\n+;; \"movmemx_qi\"\n+;; \"movmemx_hi\"\n+(define_insn \"movmemx_<mode>\"\n   [(set (mem:BLK (match_operand:HI 0 \"register_operand\"             \"x\"))\n         (mem:BLK (lo_sum:PSI (match_operand:QI 8 \"register_operand\" \"r\")\n                              (match_operand:HI 1 \"register_operand\" \"z\"))))\n    (unspec [(match_operand:QI 2 \"const_int_operand\"                 \"n\")]\n            UNSPEC_MOVMEM)\n-   (use (match_operand:QIHI 3 \"register_operand\"                   \"<MOVMEM_r_d>\"))\n+   (use (match_operand:QIHI 3 \"register_operand\"                   \"w\"))\n    (clobber (match_operand:HI 4 \"register_operand\"                 \"=0\"))\n    (clobber (match_operand:HI 5 \"register_operand\"                 \"=1\"))\n    (clobber (match_operand:QI 6 \"register_operand\"                 \"=&r\"))\n-   (clobber (match_operand:QIHI 7 \"register_operand\"               \"=3\"))\n+   (clobber (match_operand:HI 7 \"register_operand\"                 \"=3\"))\n    (clobber (match_operand:QI 9 \"register_operand\"                 \"=8\"))\n    (clobber (mem:QI (match_operand:QI 10 \"io_address_operand\"       \"n\")))]\n   \"\"\n-  {\n-    return avr_out_movmem (insn, operands, NULL);\n-  }\n-  [(set_attr \"adjust_len\" \"movmem\")\n+  \"%~call __movmemx_<mode>\"\n+  [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n \n "}, {"sha": "c29925f93fa7a4c6ff00b09cc5950bfc7fb2c29a", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -1,3 +1,13 @@\n+2012-01-10  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\tExtend __pgmx semantics to linearize memory.\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _xload_1, _movmemx.\n+\t* config/avr/lib1funcs.S (__xload_1): New function.\n+\t(__movmemx_qi, __movmemx_hi): New functions.\n+\t(__xload_2, __xload_3, __xload_4): Rewrite to fit new __pgmx\n+\tsemantics.\n+\t\n 2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sol2-unwind.h (sparc64_is_sighandler): Check that the"}, {"sha": "93ce2281534085a525f9d783867cae945619c208", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 141, "deletions": 21, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -2061,19 +2061,14 @@ ENDF __load_4\n #endif /* L_load_3 || L_load_3 */\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n-;; Loading n bytes from Flash; n = 2,3,4\n-;; R22... = Flash[R21:Z]\n+;; Loading n bytes from Flash or RAM;  n = 1,2,3,4\n+;; R22... = Flash[R21:Z] or RAM[Z] depending on R21.7\n ;; Clobbers: __tmp_reg__, R21, R30, R31\n \n-#if (defined (L_xload_2)            \\\n+#if (defined (L_xload_1)            \\\n+     || defined (L_xload_2)         \\\n      || defined (L_xload_3)         \\\n-     || defined (L_xload_4))        \\\n-    && defined (__AVR_HAVE_ELPM__)  \\\n-    && !defined (__AVR_HAVE_ELPMX__)\n-\n-#if !defined (__AVR_HAVE_RAMPZ__)\n-#error Need RAMPZ\n-#endif /* have RAMPZ */\n+     || defined (L_xload_4))\n \n ;; Destination\n #define D0  22\n@@ -2086,46 +2081,171 @@ ENDF __load_4\n #define HHI8  21\n \n .macro  .xload dest, n\n+#if defined (__AVR_HAVE_ELPMX__)\n+    elpm    \\dest, Z+\n+#elif defined (__AVR_HAVE_ELPM__)\n     elpm\n     mov     \\dest, r0\n .if \\dest != D0+\\n-1\n     adiw    r30, 1\n     adc     HHI8, __zero_reg__\n     out     __RAMPZ__, HHI8\n .endif\n-.endm\n+#elif defined (__AVR_HAVE_LPMX__)\n+    lpm     \\dest, Z+\n+#else\n+    lpm\n+    mov     \\dest, r0\n+.if \\dest != D0+\\n-1\n+    adiw    r30, 1\n+.endif\n+#endif\n+.endm ; .xload\n+\n+#if defined (L_xload_1)\n+DEFUN __xload_1\n+#if defined (__AVR_HAVE_LPMX__) && !defined (__AVR_HAVE_RAMPZ__)\n+    ld      D0, Z\n+    sbrs    HHI8, 7\n+    lpm     D0, Z\n+    ret\n+#else\n+    sbrc    HHI8, 7\n+    rjmp    1f\n+#if defined (__AVR_HAVE_RAMPZ__)\n+    out     __RAMPZ__, HHI8\n+#endif /* __AVR_HAVE_RAMPZ__ */\n+    .xload  D0, 1\n+    ret\n+1:  ld      D0, Z\n+    ret\n+#endif /* LPMx && ! RAMPZ */\n+ENDF __xload_1\n+#endif /* L_xload_1 */\n \n #if defined (L_xload_2)\n DEFUN __xload_2\n+    sbrc    HHI8, 7\n+    rjmp    1f\n+#if defined (__AVR_HAVE_RAMPZ__)\n     out     __RAMPZ__, HHI8\n-    .xload D0, 2\n-    .xload D1, 2\n+#endif /* __AVR_HAVE_RAMPZ__ */\n+    .xload  D0, 2\n+    .xload  D1, 2\n+    ret\n+1:  ld      D0, Z+\n+    ld      D1, Z+\n     ret\n ENDF __xload_2\n #endif /* L_xload_2 */\n \n #if defined (L_xload_3)\n DEFUN __xload_3\n+    sbrc    HHI8, 7\n+    rjmp    1f\n+#if defined (__AVR_HAVE_RAMPZ__)\n     out     __RAMPZ__, HHI8\n-    .xload D0, 3\n-    .xload D1, 3\n-    .xload D2, 3\n+#endif /* __AVR_HAVE_RAMPZ__ */\n+    .xload  D0, 3\n+    .xload  D1, 3\n+    .xload  D2, 3\n+    ret\n+1:  ld      D0, Z+\n+    ld      D1, Z+\n+    ld      D2, Z+\n     ret\n ENDF __xload_3\n #endif /* L_xload_3 */\n \n #if defined (L_xload_4)\n DEFUN __xload_4\n+    sbrc    HHI8, 7\n+    rjmp    1f\n+#if defined (__AVR_HAVE_RAMPZ__)\n     out     __RAMPZ__, HHI8\n-    .xload D0, 4\n-    .xload D1, 4\n-    .xload D2, 4\n-    .xload D3, 4\n+#endif /* __AVR_HAVE_RAMPZ__ */\n+    .xload  D0, 4\n+    .xload  D1, 4\n+    .xload  D2, 4\n+    .xload  D3, 4\n+    ret\n+1:  ld      D0, Z+\n+    ld      D1, Z+\n+    ld      D2, Z+\n+    ld      D3, Z+\n     ret\n ENDF __xload_4\n #endif /* L_xload_4 */\n \n-#endif /* L_xload_{2|3|4} && ELPM */\n+#endif /* L_xload_{1|2|3|4} */\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; memcopy from Address Space __pgmx to RAM\n+;; R23:Z = Source Address\n+;; X     = Destination Address\n+;; Clobbers: __tmp_reg__, R23, R24, R25, X, Z\n+\n+#if defined (L_movmemx)\n+\n+#define HHI8  23\n+#define LOOP  24\n+\n+DEFUN __movmemx_qi\n+    ;; #Bytes to copy fity in 8 Bits (1..255)\n+    ;; Zero-extend Loop Counter\n+    clr     LOOP+1\n+    ;; FALLTHRU\n+ENDF __movmemx_qi\n+\n+DEFUN __movmemx_hi\n+\n+;; Read from where?\n+    sbrc    HHI8, 7\n+    rjmp    1f\n+\n+;; Read from Flash\n+\n+#if defined (__AVR_HAVE_RAMPZ__)\n+    out     __RAMPZ__, HHI8\n+#endif\n+\n+0:  ;; Load 1 Byte from Flash...\n+\n+#if defined (__AVR_HAVE_ELPMX__)\n+    elpm    r0, Z+\n+#elif defined (__AVR_HAVE_ELPM__)\n+    elpm\n+    adiw    r30, 1\n+    adc     HHI8, __zero_reg__\n+    out     __RAMPZ__, HHI8\n+#elif defined (__AVR_HAVE_LPMX__)\n+    lpm     r0, Z+\n+#else\n+    lpm\n+    adiw    r30, 1\n+#endif\n+\n+    ;; ...and store that Byte to RAM Destination\n+    st      X+, r0\n+    sbiw    LOOP, 1\n+    brne    0b\n+    ret\n+\n+;; Read from RAM\n+\n+1:  ;; Read 1 Byte from RAM...\n+    ld      r0, Z+\n+    ;; and store that Byte to RAM Destination\n+    st      X+, r0\n+    sbiw    LOOP, 1\n+    brne    0b\n+    ret\n+ENDF __movmemx_hi\n+\n+#undef HHI8\n+#undef LOOP\n+\n+#endif /* L_movmemx */\n \n \f\n .section .text.libgcc.builtins, \"ax\", @progbits"}, {"sha": "43caa94ca2a272f4d25f1d0669588864a4b32df7", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba300dd7dfadf5069d9943c6a54c65a34614d20/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=cba300dd7dfadf5069d9943c6a54c65a34614d20", "patch": "@@ -27,7 +27,8 @@ LIB1ASMFUNCS = \\\n \t_tablejump \\\n \t_tablejump_elpm \\\n \t_load_3 _load_4 \\\n-\t_xload_2 _xload_3 _xload_4 \\\n+\t_xload_1 _xload_2 _xload_3 _xload_4 \\\n+\t_movmemx \\\n \t_copy_data \\\n \t_clear_bss \\\n \t_ctors \\"}]}