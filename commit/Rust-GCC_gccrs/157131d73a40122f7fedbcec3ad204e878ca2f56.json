{"sha": "157131d73a40122f7fedbcec3ad204e878ca2f56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3MTMxZDczYTQwMTIyZjdmZWRiY2VjM2FkMjA0ZTg3OGNhMmY1Ng==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "1998-12-11T11:18:26Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "1998-12-11T11:18:26Z"}, "message": "sh.c (print_operand): lookup interrupt_handler attribute instead of relying on static variable.\n\n* sh.c (print_operand): lookup interrupt_handler attribute instead\nof relying on static variable.\n* (calc_live_regs): Likewise.\n* (sh_pragma_insert_attributes): Create interrupt_handler\nattribute if a pragma was specified\n* (sh_valid_machine_decl_attribute): Don't set static flag.\n* sh.h (PRAGMA_INSERT_ATTRIBUTES): New.\n\nFrom-SVN: r24265", "tree": {"sha": "08e45a7cef0ba9d63098e6b579443435a90a4a90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08e45a7cef0ba9d63098e6b579443435a90a4a90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/157131d73a40122f7fedbcec3ad204e878ca2f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157131d73a40122f7fedbcec3ad204e878ca2f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157131d73a40122f7fedbcec3ad204e878ca2f56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157131d73a40122f7fedbcec3ad204e878ca2f56/comments", "author": null, "committer": null, "parents": [{"sha": "7d91fc530a176c8831245bfa38b758d6bfe79591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d91fc530a176c8831245bfa38b758d6bfe79591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d91fc530a176c8831245bfa38b758d6bfe79591"}], "stats": {"total": 67, "additions": 63, "deletions": 4}, "files": [{"sha": "4c3bfe0466cb56e05a85293ee79b7d2589dc51bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=157131d73a40122f7fedbcec3ad204e878ca2f56", "patch": "@@ -22,6 +22,16 @@\n \t(fix-header.o): Likewise.\n \t(scan-decls.o): Likewise.\n \n+Fri Dec 11 11:02:49 1998  Stan Cox  <scox@cygnus.com>\n+\n+\t* sh.c (print_operand): lookup interrupt_handler attribute instead\n+\tof relying on static variable. \n+\t* (calc_live_regs): Likewise.\n+\t* (sh_pragma_insert_attributes): Create interrupt_handler\n+\tattribute if a pragma was specified\n+\t* (sh_valid_machine_decl_attribute): Don't set static flag.\n+\t* sh.h (PRAGMA_INSERT_ATTRIBUTES): New.\n+\n Fri Dec 11 12:56:07 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload1.c (reload_combine): Use BASIC_BLOCK_LIVE_AT_START"}, {"sha": "2eb4674c7d0302736bb38091b4685e7768cc3ad8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=157131d73a40122f7fedbcec3ad204e878ca2f56", "patch": "@@ -226,13 +226,25 @@ print_operand (stream, x, code)\n       fprintf (stream, \"%s\", LOCAL_LABEL_PREFIX);\n       break;\n     case '@':\n+      {\n+\tint interrupt_handler;\n+\n+\tif ((lookup_attribute\n+\t     (\"interrupt_handler\",\n+\t      DECL_MACHINE_ATTRIBUTES (current_function_decl)))\n+\t    != NULL_TREE)\n+\t  interrupt_handler = 1;\n+\telse\n+\t  interrupt_handler = 0;\n+\t\n       if (trap_exit)\n \tfprintf (stream, \"trapa #%d\", trap_exit);\n-      else if (pragma_interrupt)\n+      else if (interrupt_handler)\n \tfprintf (stream, \"rte\");\n       else\n \tfprintf (stream, \"rts\");\n       break;\n+      }\n     case '#':\n       /* Output a nop if there's nothing in the delay slot.  */\n       if (dbr_sequence_length () == 0)\n@@ -3615,21 +3627,30 @@ calc_live_regs (count_ptr, live_regs_mask2)\n   int reg;\n   int live_regs_mask = 0;\n   int count;\n+  int interrupt_handler;\n+\n+  if ((lookup_attribute\n+       (\"interrupt_handler\",\n+\tDECL_MACHINE_ATTRIBUTES (current_function_decl)))\n+      != NULL_TREE)\n+    interrupt_handler = 1;\n+  else\n+    interrupt_handler = 0;\n \n   *live_regs_mask2 = 0;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n       if (regs_ever_live[reg] && regs_ever_live[reg+1]\n-\t  && (! call_used_regs[reg] || (pragma_interrupt && ! pragma_trapa))\n+\t  && (! call_used_regs[reg] || (interrupt_handler && ! pragma_trapa))\n \t  && ++count > 2)\n \t{\n \t  target_flags &= ~FPU_SINGLE_BIT;\n \t  break;\n \t}\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER - 1; reg >= 0; reg--)\n     {\n-      if ((pragma_interrupt && ! pragma_trapa)\n+      if ((interrupt_handler && ! pragma_trapa)\n \t  ? (/* Need to save all the regs ever live.  */\n \t     (regs_ever_live[reg]\n \t      || (call_used_regs[reg]\n@@ -3951,6 +3972,31 @@ sh_handle_pragma (p_getc, p_ungetc, pname)\n \n   return retval;\n }\n+\n+/* Generate 'handle_interrupt' attribute for decls */\n+\n+void\n+sh_pragma_insert_attributes (node, attributes, prefix)\n+     tree node;\n+     tree * attributes;\n+     tree * prefix;\n+{\n+  tree a;\n+\n+  if (! pragma_interrupt\n+      || TREE_CODE (node) != FUNCTION_DECL)\n+    return;\n+\n+  /* We are only interested in fields.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) != 'd')\n+    return;\n+\n+  /* Add a 'handle_interrupt' attribute.  */\n+  * attributes = tree_cons (get_identifier (\"interrupt_handler\"), NULL, * attributes);\n+\n+  return;\n+}\n+\n /* Return nonzero if ATTR is a valid attribute for DECL.\n    ATTRIBUTES are any existing attributes and ARGS are the arguments\n    supplied with ATTR.\n@@ -3979,7 +4025,6 @@ sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n \n   if (is_attribute_p (\"interrupt_handler\", attr))\n     {\n-      pragma_interrupt = 1;\n       return 1;\n     }\n "}, {"sha": "e2bf8c7bed962fe9bd1f41debb0d317c68381696", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157131d73a40122f7fedbcec3ad204e878ca2f56/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=157131d73a40122f7fedbcec3ad204e878ca2f56", "patch": "@@ -2062,6 +2062,10 @@ extern int sh_valid_machine_decl_attribute ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n+extern void sh_pragma_insert_attributes ();\n+#define PRAGMA_INSERT_ATTRIBUTES(node, pattr, prefix_attr) \\\n+  sh_pragma_insert_attributes (node, pattr, prefix_attr)\n+\n extern int sh_flag_remove_dead_before_cse;\n extern int rtx_equal_function_value_matters;\n extern struct rtx_def *fpscr_rtx;"}]}