{"sha": "54ba1f0dee5132daad89f2d238141f347fdc9655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRiYTFmMGRlZTUxMzJkYWFkODlmMmQyMzgxNDFmMzQ3ZmRjOTY1NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-02T18:22:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-02T18:22:13Z"}, "message": "dwarf2out.c (limbo_die_node): Add created_for member.\n\n        * dwarf2out.c (limbo_die_node): Add created_for member.\n        (new_die): New argument created_for.  Update all callers.\n        (mark_limbo_die_list): New.\n        (dwarf2out_init): Register limbo_die_list as a root.\n        (dwarf2out_finish): Force insert limbo dies into their function\n        context.\n\nFrom-SVN: r48478", "tree": {"sha": "a655f256c27ad302388f6f29f6d36ad52cd1da08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a655f256c27ad302388f6f29f6d36ad52cd1da08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54ba1f0dee5132daad89f2d238141f347fdc9655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ba1f0dee5132daad89f2d238141f347fdc9655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ba1f0dee5132daad89f2d238141f347fdc9655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ba1f0dee5132daad89f2d238141f347fdc9655/comments", "author": null, "committer": null, "parents": [{"sha": "adddf5bf279549cbbb52ad7096f9853a79f73136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adddf5bf279549cbbb52ad7096f9853a79f73136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adddf5bf279549cbbb52ad7096f9853a79f73136"}], "stats": {"total": 129, "additions": 87, "deletions": 42}, "files": [{"sha": "be53b578111ccdeb5062f13f9e3b38432e9dad0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ba1f0dee5132daad89f2d238141f347fdc9655/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ba1f0dee5132daad89f2d238141f347fdc9655/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54ba1f0dee5132daad89f2d238141f347fdc9655", "patch": "@@ -1,3 +1,12 @@\n+2002-01-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (limbo_die_node): Add created_for member.\n+\t(new_die): New argument created_for.  Update all callers.\n+\t(mark_limbo_die_list): New.\n+\t(dwarf2out_init): Register limbo_die_list as a root.\n+\t(dwarf2out_finish): Force insert limbo dies into their function\n+\tcontext.\n+\n 2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/5089"}, {"sha": "298005abb9aa100df4ac47d728e9b820951ac914", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 78, "deletions": 42, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ba1f0dee5132daad89f2d238141f347fdc9655/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ba1f0dee5132daad89f2d238141f347fdc9655/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=54ba1f0dee5132daad89f2d238141f347fdc9655", "patch": "@@ -1,5 +1,5 @@\n /* Output Dwarf2 format symbol table information from the GNU C compiler.\n-   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).\n    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).\n@@ -3177,6 +3177,7 @@ struct dw_ranges_struct\n typedef struct limbo_die_struct\n {\n   dw_die_ref die;\n+  tree created_for;\n   struct limbo_die_struct *next;\n }\n limbo_die_node;\n@@ -3510,7 +3511,8 @@ static void remove_AT\t\t\tPARAMS ((dw_die_ref,\n static inline void free_die\t\tPARAMS ((dw_die_ref));\n static void remove_children\t\tPARAMS ((dw_die_ref));\n static void add_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n-static dw_die_ref new_die\t\tPARAMS ((enum dwarf_tag, dw_die_ref));\n+static dw_die_ref new_die\t\tPARAMS ((enum dwarf_tag, dw_die_ref,\n+\t\t\t\t\t\t tree));\n static dw_die_ref lookup_type_die\tPARAMS ((tree));\n static void equate_type_number_to_die\tPARAMS ((tree, dw_die_ref));\n static dw_die_ref lookup_decl_die\tPARAMS ((tree));\n@@ -3657,6 +3659,7 @@ static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n \t\t\t\t\t\t const char *, const char *, const char *));\n static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n static char *gen_internal_sym \t\tPARAMS ((const char *));\n+static void mark_limbo_die_list\t\tPARAMS ((void *));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -5047,9 +5050,10 @@ splice_child_die (parent, child)\n /* Return a pointer to a newly created DIE node.  */\n \n static inline dw_die_ref\n-new_die (tag_value, parent_die)\n+new_die (tag_value, parent_die, t)\n      enum dwarf_tag tag_value;\n      dw_die_ref parent_die;\n+     tree t;\n {\n   dw_die_ref die = (dw_die_ref) xcalloc (1, sizeof (die_node));\n \n@@ -5063,6 +5067,7 @@ new_die (tag_value, parent_die)\n \n       limbo_node = (limbo_die_node *) xmalloc (sizeof (limbo_die_node));\n       limbo_node->die = die;\n+      limbo_node->created_for = t;\n       limbo_node->next = limbo_die_list;\n       limbo_die_list = limbo_node;\n     }\n@@ -7351,7 +7356,7 @@ base_type_die (type)\n       abort ();\n     }\n \n-  base_type_result = new_die (DW_TAG_base_type, comp_unit_die);\n+  base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);\n   if (demangle_name_func)\n     type_name = (*demangle_name_func) (type_name);\n \n@@ -7500,17 +7505,17 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t;\n       else if (is_const_type)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die);\n+\t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);\n \t  sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n \t}\n       else if (is_volatile_type)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die);\n+\t  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die, type);\n \t  sub_die = modified_type_die (type, 0, 0, context_die);\n \t}\n       else if (code == POINTER_TYPE)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die);\n+\t  mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die, type);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n #if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n@@ -7519,7 +7524,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t}\n       else if (code == REFERENCE_TYPE)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die);\n+\t  mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n #if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n@@ -8991,7 +8996,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t  && (! optimize || GET_CODE (SAVE_EXPR_RTL (bound)) == MEM))\n \t{\n \t  dw_die_ref ctx = lookup_decl_die (current_function_decl);\n-\t  dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n+\t  dw_die_ref decl_die = new_die (DW_TAG_variable, ctx, bound);\n \t  rtx loc = SAVE_EXPR_RTL (bound);\n \n \t  /* If the RTL for the SAVE_EXPR is memory, handle the case where\n@@ -9045,7 +9050,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n \telse\n \t  ctx = lookup_decl_die (current_function_decl);\n \n-\tdecl_die = new_die (DW_TAG_variable, ctx);\n+\tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n \tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n \tadd_AT_loc (decl_die, DW_AT_location, loc);\n@@ -9094,7 +9099,7 @@ add_subscript_info (type_die, type)\n       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,\n \t and (in GNU C only) variable bounds.  Handle all three forms\n          here.  */\n-      subrange_die = new_die (DW_TAG_subrange_type, type_die);\n+      subrange_die = new_die (DW_TAG_subrange_type, type_die, NULL);\n       if (domain)\n \t{\n \t  /* We have an array type with specified bounds.  */\n@@ -9611,7 +9616,7 @@ gen_array_type_die (type, context_die)\n   gen_type_die (TREE_TYPE (type), context_die);\n #endif\n \n-  array_die = new_die (DW_TAG_array_type, scope_die);\n+  array_die = new_die (DW_TAG_array_type, scope_die, type);\n \n #if 0\n   /* We default the array ordering.  SDB will probably do\n@@ -9659,7 +9664,7 @@ gen_set_type_die (type, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref type_die\n-    = new_die (DW_TAG_set_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_set_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, type_die);\n   add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);\n@@ -9672,7 +9677,7 @@ gen_entry_point_die (decl, context_die)\n      dw_die_ref context_die;\n {\n   tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die);\n+  dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die, decl);\n \n   if (origin != NULL)\n     add_abstract_origin_attribute (decl_die, origin);\n@@ -9709,7 +9714,7 @@ gen_inlined_enumeration_type_die (type, context_die)\n      tree type;\n      dw_die_ref context_die;\n {\n-  dw_die_ref type_die = new_die (DW_TAG_enumeration_type, context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_enumeration_type, context_die, type);\n \n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n@@ -9723,7 +9728,7 @@ gen_inlined_structure_type_die (type, context_die)\n      tree type;\n      dw_die_ref context_die;\n {\n-  dw_die_ref type_die = new_die (DW_TAG_structure_type, context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_structure_type, context_die, type);\n \n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n@@ -9737,7 +9742,7 @@ gen_inlined_union_type_die (type, context_die)\n      tree type;\n      dw_die_ref context_die;\n {\n-  dw_die_ref type_die = new_die (DW_TAG_union_type, context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_union_type, context_die, type);\n \n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n@@ -9759,7 +9764,7 @@ gen_enumeration_type_die (type, context_die)\n   if (type_die == NULL)\n     {\n       type_die = new_die (DW_TAG_enumeration_type,\n-\t\t\t  scope_die_for (type, context_die));\n+\t\t\t  scope_die_for (type, context_die), type);\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n     }\n@@ -9788,7 +9793,7 @@ gen_enumeration_type_die (type, context_die)\n       for (link = TYPE_FIELDS (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n \t{\n-\t  dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die);\n+\t  dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die, link);\n \n \t  add_name_attribute (enum_die,\n \t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n@@ -9827,7 +9832,7 @@ gen_formal_parameter_die (node, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref parm_die\n-    = new_die (DW_TAG_formal_parameter, context_die);\n+    = new_die (DW_TAG_formal_parameter, context_die, node);\n   tree origin;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node)))\n@@ -9870,10 +9875,10 @@ gen_formal_parameter_die (node, context_die)\n \n static void\n gen_unspecified_parameters_die (decl_or_type, context_die)\n-     tree decl_or_type ATTRIBUTE_UNUSED;\n+     tree decl_or_type;\n      dw_die_ref context_die;\n {\n-  new_die (DW_TAG_unspecified_parameters, context_die);\n+  new_die (DW_TAG_unspecified_parameters, context_die, decl_or_type);\n }\n \n /* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a\n@@ -10051,7 +10056,7 @@ gen_subprogram_die (decl, context_die)\n       if (old_die && old_die->die_parent == NULL)\n \tadd_child_die (context_die, old_die);\n \n-      subr_die = new_die (DW_TAG_subprogram, context_die);\n+      subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n   else if (old_die)\n@@ -10095,7 +10100,7 @@ gen_subprogram_die (decl, context_die)\n \t}\n       else\n \t{\n-\t  subr_die = new_die (DW_TAG_subprogram, context_die);\n+\t  subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n \t  add_AT_die_ref (subr_die, DW_AT_specification, old_die);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n@@ -10107,7 +10112,7 @@ gen_subprogram_die (decl, context_die)\n     }\n   else\n     {\n-      subr_die = new_die (DW_TAG_subprogram, context_die);\n+      subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n \n       if (TREE_PUBLIC (decl))\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n@@ -10297,7 +10302,7 @@ gen_variable_die (decl, context_die)\n      dw_die_ref context_die;\n {\n   tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref var_die = new_die (DW_TAG_variable, context_die);\n+  dw_die_ref var_die = new_die (DW_TAG_variable, context_die, decl);\n \n   dw_die_ref old_die = lookup_decl_die (decl);\n   int declaration = (DECL_EXTERNAL (decl)\n@@ -10374,7 +10379,7 @@ gen_label_die (decl, context_die)\n      dw_die_ref context_die;\n {\n   tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref lbl_die = new_die (DW_TAG_label, context_die);\n+  dw_die_ref lbl_die = new_die (DW_TAG_label, context_die, decl);\n   rtx insn;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -10418,7 +10423,7 @@ gen_lexical_block_die (stmt, context_die, depth)\n      dw_die_ref context_die;\n      int depth;\n {\n-  dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die);\n+  dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   if (! BLOCK_ABSTRACT (stmt))\n@@ -10463,7 +10468,7 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n   if (! BLOCK_ABSTRACT (stmt))\n     {\n       dw_die_ref subr_die\n-\t= new_die (DW_TAG_inlined_subroutine, context_die);\n+\t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n       tree decl = block_ultimate_origin (stmt);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -10489,7 +10494,7 @@ gen_field_die (decl, context_die)\n      tree decl;\n      dw_die_ref context_die;\n {\n-  dw_die_ref decl_die = new_die (DW_TAG_member, context_die);\n+  dw_die_ref decl_die = new_die (DW_TAG_member, context_die, decl);\n \n   add_name_and_src_coords_attributes (decl_die, decl);\n   add_type_attribute (decl_die, member_declared_type (decl),\n@@ -10527,7 +10532,7 @@ gen_pointer_type_die (type, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref ptr_die\n-    = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ptr_die);\n   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n@@ -10545,7 +10550,7 @@ gen_reference_type_die (type, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref ref_die\n-    = new_die (DW_TAG_reference_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_reference_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ref_die);\n   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);\n@@ -10561,7 +10566,8 @@ gen_ptr_to_mbr_type_die (type, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref ptr_die\n-    = new_die (DW_TAG_ptr_to_member_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_ptr_to_member_type,\n+\t       scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n@@ -10581,7 +10587,7 @@ gen_compile_unit_die (filename)\n   const char *language_string = lang_hooks.name;\n   int language;\n \n-  die = new_die (DW_TAG_compile_unit, NULL);\n+  die = new_die (DW_TAG_compile_unit, NULL, NULL);\n   add_name_attribute (die, filename);\n \n   if (wd != NULL && filename[0] != DIR_SEPARATOR)\n@@ -10629,7 +10635,7 @@ gen_string_type_die (type, context_die)\n      dw_die_ref context_die;\n {\n   dw_die_ref type_die\n-    = new_die (DW_TAG_string_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_string_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, type_die);\n \n@@ -10648,7 +10654,7 @@ gen_inheritance_die (binfo, context_die)\n      tree binfo;\n      dw_die_ref context_die;\n {\n-  dw_die_ref die = new_die (DW_TAG_inheritance, context_die);\n+  dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);\n \n   add_type_attribute (die, BINFO_TYPE (binfo), 0, 0, context_die);\n   add_data_member_location_attribute (die, binfo);\n@@ -10757,7 +10763,7 @@ gen_struct_or_union_type_die (type, context_die)\n \n       type_die = new_die (TREE_CODE (type) == RECORD_TYPE\n \t\t\t  ? DW_TAG_structure_type : DW_TAG_union_type,\n-\t\t\t  scope_die);\n+\t\t\t  scope_die, type);\n       equate_type_number_to_die (type, type_die);\n       if (old_die)\n \tadd_AT_die_ref (type_die, DW_AT_specification, old_die);\n@@ -10816,7 +10822,8 @@ gen_subroutine_type_die (type, context_die)\n {\n   tree return_type = TREE_TYPE (type);\n   dw_die_ref subr_die\n-    = new_die (DW_TAG_subroutine_type, scope_die_for (type, context_die));\n+    = new_die (DW_TAG_subroutine_type,\n+\t       scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n@@ -10838,7 +10845,7 @@ gen_typedef_die (decl, context_die)\n     return;\n \n   TREE_ASM_WRITTEN (decl) = 1;\n-  type_die = new_die (DW_TAG_typedef, context_die);\n+  type_die = new_die (DW_TAG_typedef, context_die, decl);\n   origin = decl_ultimate_origin (decl);\n   if (origin != NULL)\n     add_abstract_origin_attribute (type_die, origin);\n@@ -11373,6 +11380,15 @@ gen_decl_die (decl, context_die)\n       abort ();\n     }\n }\n+\n+static void\n+mark_limbo_die_list (ptr)\n+     void *ptr ATTRIBUTE_UNUSED;\n+{\n+  limbo_die_node *node;\n+  for (node = limbo_die_list; node ; node = node->next)\n+    ggc_mark_tree (node->created_for);\n+}\n \f\n /* Add Ada \"use\" clause information for SGI Workshop debugger.  */\n \n@@ -11385,7 +11401,7 @@ dwarf2out_add_library_unit_info (filename, context_list)\n \n   if (filename != NULL)\n     {\n-      dw_die_ref unit_die = new_die (DW_TAG_module, comp_unit_die);\n+      dw_die_ref unit_die = new_die (DW_TAG_module, comp_unit_die, NULL);\n       tree context_list_decl\n \t= build_decl (LABEL_DECL, get_identifier (context_list),\n \t\t      void_type_node);\n@@ -11733,7 +11749,7 @@ dwarf2out_start_source_file (lineno, filename)\n   if (flag_eliminate_dwarf2_dups)\n     {\n       /* Record the beginning of the file for break_out_includes.  */\n-      dw_die_ref bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die);\n+      dw_die_ref bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die, NULL);\n       add_AT_string (bincl_die, DW_AT_name, filename);\n     }\n \n@@ -11756,7 +11772,7 @@ dwarf2out_end_source_file (lineno)\n {\n   if (flag_eliminate_dwarf2_dups)\n     /* Record the end of the file for break_out_includes.  */\n-    new_die (DW_TAG_GNU_EINCL, comp_unit_die);\n+    new_die (DW_TAG_GNU_EINCL, comp_unit_die, NULL);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n@@ -11864,6 +11880,8 @@ dwarf2out_init (main_input_filename)\n   VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n   ggc_add_rtx_varray_root (&used_rtx_varray, 1);\n \n+  ggc_add_root (&limbo_die_list, 1, 1, mark_limbo_die_list);\n+\n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n \t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n@@ -11961,11 +11979,29 @@ dwarf2out_finish (input_filename)\n       if (die->die_parent == NULL)\n \t{\n \t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n+\t  tree context;\n \n \t  if (origin)\n \t    add_child_die (origin->die_parent, die);\n \t  else if (die == comp_unit_die)\n \t    ;\n+\t  else if (node->created_for\n+\t\t   && ((DECL_P (node->created_for)\n+\t\t        && (context = DECL_CONTEXT (node->created_for)))\n+\t\t       || (TYPE_P (node->created_for)\n+\t\t\t   && (context = TYPE_CONTEXT (node->created_for))))\n+\t\t   && TREE_CODE (context) == FUNCTION_DECL)\n+\t    {\n+\t      /* In certain situations, the lexical block containing a\n+\t\t nested function can be optimized away, which results\n+\t\t in the nested function die being orphaned.  Likewise\n+\t\t with the return type of that nested function.  Force\n+\t\t this to be a child of the containing function.  */\n+\t      origin = lookup_decl_die (context);\n+\t      if (! origin)\n+\t\tabort ();\n+\t      add_child_die (origin, die);\n+\t    }\n \t  else if (errorcount > 0 || sorrycount > 0)\n \t    /* It's OK to be confused by errors in the input.  */\n \t    add_child_die (comp_unit_die, die);"}]}