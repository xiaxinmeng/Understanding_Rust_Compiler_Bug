{"sha": "c988af2b8cb75ca28789f30a6bb650b38684cc0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4OGFmMmI4Y2I3NWNhMjg3ODlmMzBhNmJiNjUwYjM4Njg0Y2MwYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-11-16T19:10:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-11-16T19:10:09Z"}, "message": "Makefile.in (expr.o): Depend on $(TARGET_H).\n\n\t* Makefile.in (expr.o): Depend on $(TARGET_H).\n\t* target.h (return_in_msb): New target hook.\n\t* target-def.h (TARGET_RETURN_IN_MSB): New macro.\n\t(TARGET_CALLS): Include it.\n\t* calls.c (shift_returned_value): New function.\n\t(expand_call): Use it.\n\t* expr.c: Include target.h.\n\t(copy_blkmode_from_reg): Check targetm.calls.return_in_msb when\n\tdeciding what padding is needed.  Change the name of the local\n\tpadding variable from big_endian_correction to padding_correction.\n\t* stmt.c (shift_return_value): New function.\n\t(expand_return): Use it.  Adjust memory->register copy in the same\n\tway as copy_blkmode_from_reg.  Only change the return register's\n\tmode if it was originally BLKmode.\n\t* doc/tm.texi (TARGET_RETURN_IN_MSB): Document.\n\t* config/mips/mips.c (TARGET_RETURN_IN_MSB): Define.\n\t(mips_fpr_return_fields): New, split out from mips_function_value.\n\t(mips_return_in_msb, mips_return_fpr_pair): New functions.\n\t(mips_function_value): Rework to use the functions above.\n\t* config/mips/irix6-libc-compat.c: Delete.\n\t* config/mips/t-iris6 (LIB2FUNCS_STATIC_EXTRA): Undefine.\n\nFrom-SVN: r73652", "tree": {"sha": "9ef329c0c8bbcf96f5ead9aa89d71751793d4122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef329c0c8bbcf96f5ead9aa89d71751793d4122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c988af2b8cb75ca28789f30a6bb650b38684cc0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c988af2b8cb75ca28789f30a6bb650b38684cc0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c988af2b8cb75ca28789f30a6bb650b38684cc0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c988af2b8cb75ca28789f30a6bb650b38684cc0b/comments", "author": null, "committer": null, "parents": [{"sha": "e0c99e151e45babaac50125628ca9caf0f8c9008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c99e151e45babaac50125628ca9caf0f8c9008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c99e151e45babaac50125628ca9caf0f8c9008"}], "stats": {"total": 529, "additions": 301, "deletions": 228}, "files": [{"sha": "4105673b69f70cff7bc71fa8bf0c6002cb2d93e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -1,3 +1,27 @@\n+2003-11-16  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* Makefile.in (expr.o): Depend on $(TARGET_H).\n+\t* target.h (return_in_msb): New target hook.\n+\t* target-def.h (TARGET_RETURN_IN_MSB): New macro.\n+\t(TARGET_CALLS): Include it.\n+\t* calls.c (shift_returned_value): New function.\n+\t(expand_call): Use it.\n+\t* expr.c: Include target.h.\n+\t(copy_blkmode_from_reg): Check targetm.calls.return_in_msb when\n+\tdeciding what padding is needed.  Change the name of the local\n+\tpadding variable from big_endian_correction to padding_correction.\n+\t* stmt.c (shift_return_value): New function.\n+\t(expand_return): Use it.  Adjust memory->register copy in the same\n+\tway as copy_blkmode_from_reg.  Only change the return register's\n+\tmode if it was originally BLKmode.\n+\t* doc/tm.texi (TARGET_RETURN_IN_MSB): Document.\n+\t* config/mips/mips.c (TARGET_RETURN_IN_MSB): Define.\n+\t(mips_fpr_return_fields): New, split out from mips_function_value.\n+\t(mips_return_in_msb, mips_return_fpr_pair): New functions.\n+\t(mips_function_value): Rework to use the functions above.\n+\t* config/mips/irix6-libc-compat.c: Delete.\n+\t* config/mips/t-iris6 (LIB2FUNCS_STATIC_EXTRA): Undefine.\n+\n 2003-11-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/install.texi (--enable-checking): Update valgrind's URL."}, {"sha": "7edb2efedbb8a49a39fbde3c332ba39a078691d8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -1578,7 +1578,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h $(INSN_ATTR_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n-   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h\n+   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h"}, {"sha": "a3b86ade97951e35a3c0b4b2f82344e425f53e6d", "filename": "gcc/calls.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -148,6 +148,7 @@ static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n \t\t\t\t\t\t      int);\n static tree fix_unsafe_tree (tree);\n+static bool shift_returned_value (tree, rtx *);\n \n #ifdef REG_PARM_STACK_SPACE\n static rtx save_fixed_argument_area (int, rtx, int *, int *);\n@@ -2022,6 +2023,34 @@ fix_unsafe_tree (tree t)\n   return t;\n }\n \n+\n+/* If function value *VALUE was returned at the most significant end of a\n+   register, shift it towards the least significant end and convert it to\n+   TYPE's mode.  Return true and update *VALUE if some action was needed.\n+\n+   TYPE is the type of the function's return value, which is known not\n+   to have mode BLKmode.  */\n+\n+static bool\n+shift_returned_value (tree type, rtx *value)\n+{\n+  if (targetm.calls.return_in_msb (type))\n+    {\n+      HOST_WIDE_INT shift;\n+\n+      shift = (GET_MODE_BITSIZE (GET_MODE (*value))\n+\t       - BITS_PER_UNIT * int_size_in_bytes (type));\n+      if (shift > 0)\n+\t{\n+\t  *value = expand_binop (GET_MODE (*value), lshr_optab, *value,\n+\t\t\t\t GEN_INT (shift), 0, 1, OPTAB_WIDEN);\n+\t  *value = convert_to_mode (TYPE_MODE (type), *value, 0);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -3281,7 +3310,12 @@ expand_call (tree exp, rtx target, int ignore)\n \t  sibcall_failure = 1;\n \t}\n       else\n-\ttarget = copy_to_reg (valreg);\n+\t{\n+\t  if (shift_returned_value (TREE_TYPE (exp), &valreg))\n+\t    sibcall_failure = 1;\n+\n+\t  target = copy_to_reg (valreg);\n+\t}\n \n       if (targetm.calls.promote_function_return(funtype))\n \t{"}, {"sha": "7d4140808a527f0fc4fbe9af3b40f3c2566503b1", "filename": "gcc/config/mips/irix6-libc-compat.c", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c99e151e45babaac50125628ca9caf0f8c9008/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c99e151e45babaac50125628ca9caf0f8c9008/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c?ref=e0c99e151e45babaac50125628ca9caf0f8c9008", "patch": "@@ -1,84 +0,0 @@\n-/* Compensate for inconsistent structure return conventions on IRIX 6.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 2001  Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* GCC doesn't correctly implement the structure and union return\n-   conventions of the N32 and N64 ABIs on IRIX 6, as described in the\n-   MIPSpro N32 ABI Handbook, ch. 2, Calling Convention Implementations, p.7.\n-   The ABI requires that structures (or trailing parts of structures) smaller\n-   than 8 bytes (a 64-bit register) are left-justified, whereas GCC\n-   right-justifies them.\n-\n-   While GCC is internally consistent, calling routines compiled with a\n-   compiler that does implement the documented ABI (like SGIs MIPSpro C\n-   compiler) doesn't work.  This is primarily an issue for system libraries\n-   like libc.  Fortunately, there exist only very few routines that return\n-   structures by value, so until the underlying bug is fixed, it is possible\n-   to work around it by providing wrappers for the few affected routines.\n-\n-   These wrappers rely on the fact that e.g. libc contains weak versions of\n-   those routines, and the real implementation is provided by _-prefixed\n-   variants.  So we can provide our own versions, which will only be linked\n-   if the application uses any of the affected functions, calling the private\n-   variants and then shifting the result as required.\n-\n-   This is a rewrite of code created by Andy Polyakov.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-/* This must only be used for the N32 and N64 ABIs.  O32 is correct.  */\n-\n-#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64\n-\n-/* The affected return values need to be shifted by\n-\n-\tBITS_PER_WORD - (sizeof (value) * BITS_PER_UNIT).\n-\n-   Since only 32-bit results are involved, the shift count is always 32.  */\n-#define SHIFT_BITS\t32\n-\n-extern machreg_t _inet_makeaddr (machreg_t, machreg_t);\n-\n-/* <arpa/inet.h> has\n-\n-\tstruct in_addr inet_makeaddr (int, int);\t\t(IRIX 6.2)\n-\tstruct in_addr inet_makeaddr (in_addr_t, in_addr_t);\t(IRIX 6.5)  */\n-\n-extern machreg_t inet_makeaddr (machreg_t, machreg_t);\n-\n-machreg_t\n-inet_makeaddr (machreg_t net, machreg_t lna)\n-{\n-  return _inet_makeaddr (net, lna) >> SHIFT_BITS;\n-}\n-\n-#endif /* _ABIN32 || _ABI64 */"}, {"sha": "6096eddd24562c41bc039237c760f1c7b933a046", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 136, "deletions": 97, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -255,6 +255,11 @@ static void mips_select_section (tree, int, unsigned HOST_WIDE_INT)\n \t\t\t\t  ATTRIBUTE_UNUSED;\n static bool mips_in_small_data_p (tree);\n static void mips_encode_section_info (tree, rtx, int);\n+static int mips_fpr_return_fields (tree, tree *);\n+static bool mips_return_in_msb (tree);\n+static rtx mips_return_fpr_pair (enum machine_mode mode,\n+\t\t\t\t enum machine_mode mode1, HOST_WIDE_INT,\n+\t\t\t\t enum machine_mode mode2, HOST_WIDE_INT);\n static rtx mips16_gp_pseudo_reg (void);\n static void mips16_fp_args (FILE *, int, int);\n static void build_mips16_function_stub (FILE *);\n@@ -787,6 +792,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST mips_build_builtin_va_list\n+#undef TARGET_RETURN_IN_MSB\n+#define TARGET_RETURN_IN_MSB mips_return_in_msb\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -7120,6 +7127,96 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n   default_encode_section_info (decl, rtl, first);\n }\n \f\n+/* See whether VALTYPE is a record whose fields should be returned in\n+   floating-point registers.  If so, return the number of fields and\n+   list them in FIELDS (which should have two elements).  Return 0\n+   otherwise.\n+\n+   For n32 & n64, a structure with one or two fields is returned in\n+   floating-point registers as long as every field has a floating-point\n+   type.  */\n+\n+static int\n+mips_fpr_return_fields (tree valtype, tree *fields)\n+{\n+  tree field;\n+  int i;\n+\n+  if (!TARGET_NEWABI)\n+    return 0;\n+\n+  if (TREE_CODE (valtype) != RECORD_TYPE)\n+    return 0;\n+\n+  i = 0;\n+  for (field = TYPE_FIELDS (valtype); field != 0; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      if (TREE_CODE (TREE_TYPE (field)) != REAL_TYPE)\n+\treturn 0;\n+\n+      if (i == 2)\n+\treturn 0;\n+\n+      fields[i++] = field;\n+    }\n+  return i;\n+}\n+\n+\n+/* Implement TARGET_RETURN_IN_MSB.  For n32 & n64, we should return\n+   a value in the most significant part of $2/$3 if:\n+\n+      - the target is big-endian;\n+\n+      - the value has a structure or union type (we generalize this to\n+\tcover aggregates from other languages too); and\n+\n+      - the structure is not returned in floating-point registers.  */\n+\n+static bool\n+mips_return_in_msb (tree valtype)\n+{\n+  tree fields[2];\n+\n+  return (TARGET_NEWABI\n+\t  && TARGET_BIG_ENDIAN\n+\t  && AGGREGATE_TYPE_P (valtype)\n+\t  && mips_fpr_return_fields (valtype, fields) == 0);\n+}\n+\n+\n+/* Return a composite value in a pair of floating-point registers.\n+   MODE1 and OFFSET1 are the mode and byte offset for the first value,\n+   likewise MODE2 and OFFSET2 for the second.  MODE is the mode of the\n+   complete value.\n+\n+   For n32 & n64, $f0 always holds the first value and $f2 the second.\n+   Otherwise the values are packed together as closely as possible.  */\n+\n+static rtx\n+mips_return_fpr_pair (enum machine_mode mode,\n+\t\t      enum machine_mode mode1, HOST_WIDE_INT offset1,\n+\t\t      enum machine_mode mode2, HOST_WIDE_INT offset2)\n+{\n+  int inc;\n+\n+  inc = (TARGET_NEWABI ? 2 : FP_INC);\n+  return gen_rtx_PARALLEL\n+    (mode,\n+     gen_rtvec (2,\n+\t\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t   gen_rtx_REG (mode1, FP_RETURN),\n+\t\t\t\t   GEN_INT (offset1)),\n+\t\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t   gen_rtx_REG (mode2, FP_RETURN + inc),\n+\t\t\t\t   GEN_INT (offset2))));\n+\n+}\n+\n+\n /* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n    VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n    VALTYPE is null and MODE is the mode of the return value.  */\n@@ -7128,121 +7225,63 @@ rtx\n mips_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode)\n {\n-  int reg = GP_RETURN;\n-  enum mode_class mclass;\n-  int unsignedp = 1;\n-\n   if (valtype)\n     {\n+      tree fields[2];\n+      int unsignedp;\n+\n       mode = TYPE_MODE (valtype);\n       unsignedp = TREE_UNSIGNED (valtype);\n \n       /* Since we define PROMOTE_FUNCTION_RETURN, we must promote\n \t the mode just as PROMOTE_MODE does.  */\n       mode = promote_mode (valtype, mode, &unsignedp, 1);\n-    }\n-  mclass = GET_MODE_CLASS (mode);\n-\n-  if (mclass == MODE_FLOAT && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n-    reg = FP_RETURN;\n-\n-  else if (mclass == MODE_FLOAT && mode == TFmode)\n-    /* long doubles are really split between f0 and f2, not f1.  Eek.\n-       Use DImode for each component, since GCC wants integer modes\n-       for subregs.  */\n-    return gen_rtx_PARALLEL\n-      (VOIDmode,\n-       gen_rtvec (2,\n-\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t     gen_rtx_REG (DImode, FP_RETURN),\n-\t\t\t\t     GEN_INT (0)),\n-\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t     gen_rtx_REG (DImode, FP_RETURN + 2),\n-\t\t\t\t     GEN_INT (GET_MODE_SIZE (mode) / 2))));\n-\n-\n-  else if (mclass == MODE_COMPLEX_FLOAT\n-\t   && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)\n-    {\n-      enum machine_mode cmode = GET_MODE_INNER (mode);\n-\n-      return gen_rtx_PARALLEL\n-\t(VOIDmode,\n-\t gen_rtvec (2,\n-\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t       gen_rtx_REG (cmode, FP_RETURN),\n-\t\t\t\t       GEN_INT (0)),\n-\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t       gen_rtx_REG (cmode, FP_RETURN + FP_INC),\n-\t\t\t\t       GEN_INT (GET_MODE_SIZE (cmode)))));\n-    }\n-\n-  else if (valtype && TREE_CODE (valtype) == RECORD_TYPE\n-\t   && mips_abi != ABI_32\n-\t   && mips_abi != ABI_O64\n-\t   && mips_abi != ABI_EABI)\n-    {\n-      /* A struct with only one or two floating point fields is returned in\n-\t the floating point registers.  */\n-      tree field, fields[2];\n-      int i;\n-\n-      for (i = 0, field = TYPE_FIELDS (valtype); field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n \n-\t  if (TREE_CODE (TREE_TYPE (field)) != REAL_TYPE || i >= 2)\n-\t    break;\n+      /* Handle structures whose fields are returned in $f0/$f2.  */\n+      switch (mips_fpr_return_fields (valtype, fields))\n+\t{\n+\tcase 1:\n+\t  return gen_rtx_REG (mode, FP_RETURN);\n \n-\t  fields[i++] = field;\n+\tcase 2:\n+\t  return mips_return_fpr_pair (mode,\n+\t\t\t\t       TYPE_MODE (TREE_TYPE (fields[0])),\n+\t\t\t\t       int_byte_position (fields[0]),\n+\t\t\t\t       TYPE_MODE (TREE_TYPE (fields[1])),\n+\t\t\t\t       int_byte_position (fields[1]));\n \t}\n \n-      /* Must check i, so that we reject structures with no elements.  */\n-      if (! field)\n+      /* If a value is passed in the most significant part of a register, see\n+\t whether we have to round the mode up to a whole number of words.  */\n+      if (mips_return_in_msb (valtype))\n \t{\n-\t  if (i == 1)\n+\t  HOST_WIDE_INT size = int_size_in_bytes (valtype);\n+\t  if (size % UNITS_PER_WORD != 0)\n \t    {\n-\t      /* The structure has DImode, but we don't allow DImode values\n-\t\t in FP registers, so we use a PARALLEL even though it isn't\n-\t\t strictly necessary.  */\n-\t      enum machine_mode field_mode = TYPE_MODE (TREE_TYPE (fields[0]));\n-\n-\t      return gen_rtx_PARALLEL\n-\t\t(mode,\n-\t\t gen_rtvec (1,\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (field_mode,\n-\t\t\t\t\t\t\t    FP_RETURN),\n-\t\t\t\t\t       const0_rtx)));\n-\t    }\n-\n-\t  else if (i == 2)\n-\t    {\n-\t      enum machine_mode first_mode\n-\t\t= TYPE_MODE (TREE_TYPE (fields[0]));\n-\t      enum machine_mode second_mode\n-\t\t= TYPE_MODE (TREE_TYPE (fields[1]));\n-\t      HOST_WIDE_INT first_offset = int_byte_position (fields[0]);\n-\t      HOST_WIDE_INT second_offset = int_byte_position (fields[1]);\n-\n-\t      return gen_rtx_PARALLEL\n-\t\t(mode,\n-\t\t gen_rtvec (2,\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (first_mode,\n-\t\t\t\t\t\t\t    FP_RETURN),\n-\t\t\t\t\t       GEN_INT (first_offset)),\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (second_mode,\n-\t\t\t\t\t\t\t    FP_RETURN + 2),\n-\t\t\t\t\t       GEN_INT (second_offset))));\n+\t      size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n+\t      mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \t    }\n \t}\n     }\n \n-  return gen_rtx_REG (mode, reg);\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n+    return gen_rtx_REG (mode, FP_RETURN);\n+\n+  /* Handle long doubles for n32 & n64.  */\n+  if (mode == TFmode)\n+    return mips_return_fpr_pair (mode,\n+\t\t\t\t DImode, 0,\n+\t\t\t\t DImode, GET_MODE_SIZE (mode) / 2);\n+\n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)\n+    return mips_return_fpr_pair (mode,\n+\t\t\t\t GET_MODE_INNER (mode), 0,\n+\t\t\t\t GET_MODE_INNER (mode),\n+\t\t\t\t GET_MODE_SIZE (mode) / 2);\n+\n+  return gen_rtx_REG (mode, GP_RETURN);\n }\n \n /* The implementation of FUNCTION_ARG_PASS_BY_REFERENCE.  Return"}, {"sha": "6987925987da812a6233154f57ea57add55434d2", "filename": "gcc/config/mips/t-iris6", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fconfig%2Fmips%2Ft-iris6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fconfig%2Fmips%2Ft-iris6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-iris6?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -14,10 +14,6 @@ INSTALL_LIBGCC = install-multilib\n EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o\n CRTSTUFF_T_CFLAGS=-g1\n \n-# This is only needed in the static libgcc as a band-aid until gcc correctly\n-# implements the N32/N64 ABI structure passing conventions\n-LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/mips/irix6-libc-compat.c\n-\n LIB2FUNCS_EXTRA = $(srcdir)/config/mips/_tilib.c\n \n TPBIT = tp-bit.c"}, {"sha": "bfb97e3ee19d2410cb62e096f97a122a29c2bc6e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -3903,6 +3903,18 @@ need more space than is implied by @code{FUNCTION_VALUE_REGNO_P} for\n saving and restoring an arbitrary return value.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_RETURN_IN_MSB (tree @var{type})\n+This hook should return true if values of type @var{type} are returned\n+at the most significant end of a register (in other words, if they are\n+padded at the least significant end).  You can assume that @var{type}\n+is returned in a register; the caller is required to check this.\n+\n+Note that the register provided by @code{FUNCTION_VALUE} must be able\n+to hold the complete return value.  For example, if a 1-, 2- or 3-byte\n+structure is returned at the most significant end of a 4-byte register,\n+@code{FUNCTION_VALUE} should provide an @code{SImode} rtx.\n+@end deftypefn\n+\n @node Aggregate Return\n @subsection How Large Values Are Returned\n @cindex aggregates as return values"}, {"sha": "9424bb9d434a04f22fdea9b16b039738e7b95cef", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -47,6 +47,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"intl.h\"\n #include \"tm_p.h\"\n+#include \"target.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n@@ -2121,18 +2122,18 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n    set of registers starting with SRCREG into TGTBLK.  If TGTBLK\n    is null, a stack temporary is created.  TGTBLK is returned.\n \n-   The primary purpose of this routine is to handle functions\n-   that return BLKmode structures in registers.  Some machines\n-   (the PA for example) want to return all small structures\n-   in registers regardless of the structure's alignment.  */\n+   The purpose of this routine is to handle functions that return\n+   BLKmode structures in registers.  Some machines (the PA for example)\n+   want to return all small structures in registers regardless of the\n+   structure's alignment.  */\n \n rtx\n copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n {\n   unsigned HOST_WIDE_INT bytes = int_size_in_bytes (type);\n   rtx src = NULL, dst = NULL;\n   unsigned HOST_WIDE_INT bitsize = MIN (TYPE_ALIGN (type), BITS_PER_WORD);\n-  unsigned HOST_WIDE_INT bitpos, xbitpos, big_endian_correction = 0;\n+  unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0;\n \n   if (tgtblk == 0)\n     {\n@@ -2150,29 +2151,36 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n       && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n     srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n \n-  /* Structures whose size is not a multiple of a word are aligned\n-     to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n-     machine, this means we must skip the empty high order bytes when\n-     calculating the bit offset.  */\n-  if (BYTES_BIG_ENDIAN\n-      && bytes % UNITS_PER_WORD)\n-    big_endian_correction\n+  /* If the structure doesn't take up a whole number of words, see whether\n+     SRCREG is padded on the left or on the right.  If it's on the left,\n+     set PADDING_CORRECTION to the number of bits to skip.\n+\n+     In most ABIs, the structure will be returned at the least end of\n+     the register, which translates to right padding on little-endian\n+     targets and left padding on big-endian targets.  The opposite\n+     holds if the structure is returned at the most significant\n+     end of the register.  */\n+  if (bytes % UNITS_PER_WORD != 0\n+      && (targetm.calls.return_in_msb (type)\n+\t  ? !BYTES_BIG_ENDIAN\n+\t  : BYTES_BIG_ENDIAN))\n+    padding_correction\n       = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD) * BITS_PER_UNIT));\n \n   /* Copy the structure BITSIZE bites at a time.\n \n      We could probably emit more efficient code for machines which do not use\n      strict alignment, but it doesn't seem worth the effort at the current\n      time.  */\n-  for (bitpos = 0, xbitpos = big_endian_correction;\n+  for (bitpos = 0, xbitpos = padding_correction;\n        bitpos < bytes * BITS_PER_UNIT;\n        bitpos += bitsize, xbitpos += bitsize)\n     {\n       /* We need a new source operand each time xbitpos is on a\n-\t word boundary and when xbitpos == big_endian_correction\n+\t word boundary and when xbitpos == padding_correction\n \t (the first time through).  */\n       if (xbitpos % BITS_PER_WORD == 0\n-\t  || xbitpos == big_endian_correction)\n+\t  || xbitpos == padding_correction)\n \tsrc = operand_subword_force (srcreg, xbitpos / BITS_PER_WORD,\n \t\t\t\t     GET_MODE (srcreg));\n "}, {"sha": "3c8e2863eddfd64e9aec234b6d5ac8e1dd0f8518", "filename": "gcc/stmt.c", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -403,6 +403,7 @@ static bool check_unique_operand_names (tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree);\n static void expand_null_return_1 (rtx);\n static enum br_predictor return_prediction (rtx);\n+static rtx shift_return_value (rtx);\n static void expand_value_return (rtx);\n static int tail_recursion_args (tree, tree);\n static void expand_cleanups (tree, int, int);\n@@ -2902,6 +2903,34 @@ return_prediction (rtx val)\n   return PRED_NO_PREDICTION;\n }\n \n+\n+/* If the current function returns values in the most significant part\n+   of a register, shift return value VAL appropriately.  The mode of\n+   the function's return type is known not to be BLKmode.  */\n+\n+static rtx\n+shift_return_value (rtx val)\n+{\n+  tree type;\n+\n+  type = TREE_TYPE (DECL_RESULT (current_function_decl));\n+  if (targetm.calls.return_in_msb (type))\n+    {\n+      rtx target;\n+      HOST_WIDE_INT shift;\n+\n+      target = DECL_RTL (DECL_RESULT (current_function_decl));\n+      shift = (GET_MODE_BITSIZE (GET_MODE (target))\n+\t       - BITS_PER_UNIT * int_size_in_bytes (type));\n+      if (shift > 0)\n+\tval = expand_binop (GET_MODE (target), ashl_optab,\n+\t\t\t    gen_lowpart (GET_MODE (target), val),\n+\t\t\t    GEN_INT (shift), target, 1, OPTAB_WIDEN);\n+    }\n+  return val;\n+}\n+\n+\n /* Generate RTL to return from the current function, with value VAL.  */\n \n static void\n@@ -3066,7 +3095,7 @@ expand_return (tree retval)\n     {\n       int i;\n       unsigned HOST_WIDE_INT bitpos, xbitpos;\n-      unsigned HOST_WIDE_INT big_endian_correction = 0;\n+      unsigned HOST_WIDE_INT padding_correction = 0;\n       unsigned HOST_WIDE_INT bytes\n \t= int_size_in_bytes (TREE_TYPE (retval_rhs));\n       int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n@@ -3083,25 +3112,33 @@ expand_return (tree retval)\n \t  return;\n \t}\n \n-      /* Structures whose size is not a multiple of a word are aligned\n-\t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n-\t machine, this means we must skip the empty high order bytes when\n-\t calculating the bit offset.  */\n-      if (BYTES_BIG_ENDIAN\n-\t  && bytes % UNITS_PER_WORD)\n-\tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n-\t\t\t\t\t\t  * BITS_PER_UNIT));\n+      /* If the structure doesn't take up a whole number of words, see\n+\t whether the register value should be padded on the left or on\n+\t the right.  Set PADDING_CORRECTION to the number of padding\n+\t bits needed on the left side.\n+\n+\t In most ABIs, the structure will be returned at the least end of\n+\t the register, which translates to right padding on little-endian\n+\t targets and left padding on big-endian targets.  The opposite\n+\t holds if the structure is returned at the most significant\n+\t end of the register.  */\n+      if (bytes % UNITS_PER_WORD != 0\n+\t  && (targetm.calls.return_in_msb (TREE_TYPE (retval_rhs))\n+\t      ? !BYTES_BIG_ENDIAN\n+\t      : BYTES_BIG_ENDIAN))\n+\tpadding_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n+\t\t\t\t\t       * BITS_PER_UNIT));\n \n       /* Copy the structure BITSIZE bits at a time.  */\n-      for (bitpos = 0, xbitpos = big_endian_correction;\n+      for (bitpos = 0, xbitpos = padding_correction;\n \t   bitpos < bytes * BITS_PER_UNIT;\n \t   bitpos += bitsize, xbitpos += bitsize)\n \t{\n \t  /* We need a new destination pseudo each time xbitpos is\n-\t     on a word boundary and when xbitpos == big_endian_correction\n+\t     on a word boundary and when xbitpos == padding_correction\n \t     (the first time through).  */\n \t  if (xbitpos % BITS_PER_WORD == 0\n-\t      || xbitpos == big_endian_correction)\n+\t      || xbitpos == padding_correction)\n \t    {\n \t      /* Generate an appropriate register.  */\n \t      dst = gen_reg_rtx (word_mode);\n@@ -3128,21 +3165,25 @@ expand_return (tree retval)\n \t\t\t   BITS_PER_WORD);\n \t}\n \n-      /* Find the smallest integer mode large enough to hold the\n-\t entire structure and use that mode instead of BLKmode\n-\t on the USE insn for the return register.  */\n-      for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmpmode != VOIDmode;\n-\t   tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n-\t/* Have we found a large enough mode?  */\n-\tif (GET_MODE_SIZE (tmpmode) >= bytes)\n-\t  break;\n+      tmpmode = GET_MODE (result_rtl);\n+      if (tmpmode == BLKmode)\n+\t{\n+\t  /* Find the smallest integer mode large enough to hold the\n+\t     entire structure and use that mode instead of BLKmode\n+\t     on the USE insn for the return register.  */\n+\t  for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t       tmpmode != VOIDmode;\n+\t       tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n+\t    /* Have we found a large enough mode?  */\n+\t    if (GET_MODE_SIZE (tmpmode) >= bytes)\n+\t      break;\n \n-      /* No suitable mode found.  */\n-      if (tmpmode == VOIDmode)\n-\tabort ();\n+\t  /* No suitable mode found.  */\n+\t  if (tmpmode == VOIDmode)\n+\t    abort ();\n \n-      PUT_MODE (result_rtl, tmpmode);\n+\t  PUT_MODE (result_rtl, tmpmode);\n+\t}\n \n       if (GET_MODE_SIZE (tmpmode) < GET_MODE_SIZE (word_mode))\n \tresult_reg_mode = word_mode;\n@@ -3175,7 +3216,7 @@ expand_return (tree retval)\n       val = force_not_mem (val);\n       emit_queue ();\n       /* Return the calculated value, doing cleanups first.  */\n-      expand_value_return (val);\n+      expand_value_return (shift_return_value (val));\n     }\n   else\n     {"}, {"sha": "5007a562e8f9bb3dc3bb4f82b9db6c9ee8f97bf7", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -329,6 +329,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_STRUCT_VALUE_RTX default_struct_value_rtx\n #define TARGET_RETURN_IN_MEMORY default_return_in_memory\n+#define TARGET_RETURN_IN_MSB hook_bool_tree_false\n \n #define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs\n #define TARGET_SETUP_INCOMING_VARARGS default_setup_incoming_varargs\n@@ -341,6 +342,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_PROMOTE_PROTOTYPES,\t\t\t\t\t\\\n    TARGET_STRUCT_VALUE_RTX,\t\t\t\t\t\\\n    TARGET_RETURN_IN_MEMORY,\t\t\t\t\t\\\n+   TARGET_RETURN_IN_MSB,\t\t\t\t\t\\\n    TARGET_EXPAND_BUILTIN_SAVEREGS,\t\t\t\t\\\n    TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\"}, {"sha": "10be23702695c8b26f130b605771e658a607dd43", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c988af2b8cb75ca28789f30a6bb650b38684cc0b/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c988af2b8cb75ca28789f30a6bb650b38684cc0b", "patch": "@@ -429,6 +429,7 @@ struct gcc_target\n     bool (*promote_prototypes) (tree fntype);\n     rtx (*struct_value_rtx) (tree fndecl, int incoming);\n     bool (*return_in_memory) (tree type, tree fndecl);\n+    bool (*return_in_msb) (tree type);\n     rtx (*expand_builtin_saveregs) (void);\n     /* Returns pretend_argument_size.  */\n     void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,"}]}