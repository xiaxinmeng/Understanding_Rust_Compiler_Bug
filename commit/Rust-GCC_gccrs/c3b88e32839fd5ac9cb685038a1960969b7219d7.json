{"sha": "c3b88e32839fd5ac9cb685038a1960969b7219d7", "node_id": "C_kwDOANBUbNoAKGMzYjg4ZTMyODM5ZmQ1YWM5Y2I2ODUwMzhhMTk2MDk2OWI3MjE5ZDc", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-08T08:52:58Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-08T12:48:27Z"}, "message": "typecheck-resolve-type: Move all remaining definitions", "tree": {"sha": "1ecea85fe35a31e9bc996e1665fe6630ae7f0655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ecea85fe35a31e9bc996e1665fe6630ae7f0655"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3b88e32839fd5ac9cb685038a1960969b7219d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3b88e32839fd5ac9cb685038a1960969b7219d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3b88e32839fd5ac9cb685038a1960969b7219d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3b88e32839fd5ac9cb685038a1960969b7219d7/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1293ae35777427e1c87659ae21f9bca5f6395d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1293ae35777427e1c87659ae21f9bca5f6395d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1293ae35777427e1c87659ae21f9bca5f6395d6"}], "stats": {"total": 469, "additions": 247, "deletions": 222}, "files": [{"sha": "3c2a7c5c75b1e6a6153f0e78c661a38056209b2d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3b88e32839fd5ac9cb685038a1960969b7219d7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3b88e32839fd5ac9cb685038a1960969b7219d7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=c3b88e32839fd5ac9cb685038a1960969b7219d7", "patch": "@@ -23,6 +23,75 @@\n namespace Rust {\n namespace Resolver {\n \n+HIR::GenericArgs\n+TypeCheckResolveGenericArguments::resolve (HIR::TypePathSegment *segment)\n+{\n+  TypeCheckResolveGenericArguments resolver (segment->get_locus ());\n+  segment->accept_vis (resolver);\n+  return resolver.args;\n+}\n+\n+void\n+TypeCheckResolveGenericArguments::visit (HIR::TypePathSegmentGeneric &generic)\n+{\n+  args = generic.get_generic_args ();\n+}\n+\n+TyTy::BaseType *\n+TypeCheckType::Resolve (HIR::Type *type)\n+{\n+  TypeCheckType resolver (type->get_mappings ().get_hirid ());\n+  type->accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  resolver.context->insert_type (type->get_mappings (), resolver.translated);\n+  return resolver.translated;\n+}\n+\n+void\n+TypeCheckType::visit (HIR::BareFunctionType &fntype)\n+{\n+  TyTy::BaseType *return_type\n+    = fntype.has_return_type ()\n+\t? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n+\t: TyTy::TupleType::get_unit_type (fntype.get_mappings ().get_hirid ());\n+\n+  std::vector<TyTy::TyVar> params;\n+  for (auto &param : fntype.get_function_params ())\n+    {\n+      TyTy::BaseType *ptype = TypeCheckType::Resolve (param.get_type ().get ());\n+      params.push_back (TyTy::TyVar (ptype->get_ref ()));\n+    }\n+\n+  translated = new TyTy::FnPtr (fntype.get_mappings ().get_hirid (),\n+\t\t\t\tfntype.get_locus (), std::move (params),\n+\t\t\t\tTyTy::TyVar (return_type->get_ref ()));\n+}\n+\n+void\n+TypeCheckType::visit (HIR::TupleType &tuple)\n+{\n+  if (tuple.is_unit_type ())\n+    {\n+      auto unit_node_id = resolver->get_unit_type_node_id ();\n+      if (!context->lookup_builtin (unit_node_id, &translated))\n+\t{\n+\t  rust_error_at (tuple.get_locus (),\n+\t\t\t \"failed to lookup builtin unit type\");\n+\t}\n+      return;\n+    }\n+\n+  std::vector<TyTy::TyVar> fields;\n+  for (auto &elem : tuple.get_elems ())\n+    {\n+      auto field_ty = TypeCheckType::Resolve (elem.get ());\n+      fields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n+    }\n+\n+  translated = new TyTy::TupleType (tuple.get_mappings ().get_hirid (),\n+\t\t\t\t    tuple.get_locus (), fields);\n+}\n+\n void\n TypeCheckType::visit (HIR::TypePath &path)\n {\n@@ -565,6 +634,170 @@ TypeCheckType::visit (HIR::SliceType &type)\n     = new TyTy::SliceType (type.get_mappings ().get_hirid (), type.get_locus (),\n \t\t\t   TyTy::TyVar (base->get_ref ()));\n }\n+void\n+TypeCheckType::visit (HIR::ReferenceType &type)\n+{\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_base_type ().get ());\n+  translated\n+    = new TyTy::ReferenceType (type.get_mappings ().get_hirid (),\n+\t\t\t       TyTy::TyVar (base->get_ref ()), type.get_mut ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::RawPointerType &type)\n+{\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_base_type ().get ());\n+  translated\n+    = new TyTy::PointerType (type.get_mappings ().get_hirid (),\n+\t\t\t     TyTy::TyVar (base->get_ref ()), type.get_mut ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::InferredType &type)\n+{\n+  translated = new TyTy::InferType (type.get_mappings ().get_hirid (),\n+\t\t\t\t    TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t\t    type.get_locus ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::NeverType &type)\n+{\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = context->lookup_builtin (\"!\", &lookup);\n+  rust_assert (ok);\n+\n+  translated = lookup->clone ();\n+}\n+\n+TyTy::ParamType *\n+TypeResolveGenericParam::Resolve (HIR::GenericParam *param)\n+{\n+  TypeResolveGenericParam resolver;\n+  param->accept_vis (resolver);\n+\n+  if (resolver.resolved == nullptr)\n+    {\n+      rust_error_at (param->get_locus (), \"failed to setup generic parameter\");\n+      return nullptr;\n+    }\n+\n+  return resolver.resolved;\n+}\n+\n+void\n+TypeResolveGenericParam::visit (HIR::TypeParam &param)\n+{\n+  if (param.has_type ())\n+    TypeCheckType::Resolve (param.get_type ().get ());\n+\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  if (param.has_type_param_bounds ())\n+    {\n+      for (auto &bound : param.get_type_param_bounds ())\n+\t{\n+\t  switch (bound->get_bound_type ())\n+\t    {\n+\t      case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t\tHIR::TraitBound *b\n+\t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t\tTyTy::TypeBoundPredicate predicate\n+\t\t  = get_predicate_from_bound (b->get_path ());\n+\t\tif (!predicate.is_error ())\n+\t\t  specified_bounds.push_back (std::move (predicate));\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  resolved\n+    = new TyTy::ParamType (param.get_type_representation (), param.get_locus (),\n+\t\t\t   param.get_mappings ().get_hirid (), param,\n+\t\t\t   specified_bounds);\n+}\n+\n+void\n+ResolveWhereClauseItem::Resolve (HIR::WhereClauseItem &item)\n+{\n+  ResolveWhereClauseItem resolver;\n+  item.accept_vis (resolver);\n+}\n+\n+void\n+ResolveWhereClauseItem::visit (HIR::LifetimeWhereClauseItem &)\n+{}\n+\n+void\n+ResolveWhereClauseItem::visit (HIR::TypeBoundWhereClauseItem &item)\n+{\n+  auto &binding_type_path = item.get_bound_type ();\n+  TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n+\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  for (auto &bound : item.get_type_param_bounds ())\n+    {\n+      switch (bound->get_bound_type ())\n+\t{\n+\t  case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t    HIR::TraitBound *b = static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t    TyTy::TypeBoundPredicate predicate\n+\t      = get_predicate_from_bound (b->get_path ());\n+\t    if (!predicate.is_error ())\n+\t      specified_bounds.push_back (std::move (predicate));\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  binding->inherit_bounds (specified_bounds);\n+\n+  // When we apply these bounds we must lookup which type this binding\n+  // resolves to, as this is the type which will be used during resolution\n+  // of the block.\n+  NodeId ast_node_id = binding_type_path->get_mappings ().get_nodeid ();\n+\n+  // then lookup the reference_node_id\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+    {\n+      // FIXME\n+      rust_error_at (Location (),\n+\t\t     \"Failed to lookup type reference for node: %s\",\n+\t\t     binding_type_path->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n+    {\n+      // FIXME\n+      rust_error_at (Location (), \"where-clause reverse lookup failure\");\n+      return;\n+    }\n+\n+  // the base reference for this name _must_ have a type set\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (ref, &lookup))\n+    {\n+      rust_error_at (mappings->lookup_location (ref),\n+\t\t     \"Failed to resolve where-clause binding type: %s\",\n+\t\t     binding_type_path->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // FIXME\n+  // rust_assert (binding->is_equal (*lookup));\n+  lookup->inherit_bounds (specified_bounds);\n+}\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "151e87de601fab8f63320f642f3ca36945284d9d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 14, "deletions": 222, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3b88e32839fd5ac9cb685038a1960969b7219d7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3b88e32839fd5ac9cb685038a1960969b7219d7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=c3b88e32839fd5ac9cb685038a1960969b7219d7", "patch": "@@ -32,17 +32,9 @@ class TypeCheckResolveGenericArguments : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static HIR::GenericArgs resolve (HIR::TypePathSegment *segment)\n-  {\n-    TypeCheckResolveGenericArguments resolver (segment->get_locus ());\n-    segment->accept_vis (resolver);\n-    return resolver.args;\n-  };\n+  static HIR::GenericArgs resolve (HIR::TypePathSegment *segment);\n \n-  void visit (HIR::TypePathSegmentGeneric &generic) override\n-  {\n-    args = generic.get_generic_args ();\n-  }\n+  void visit (HIR::TypePathSegmentGeneric &generic) override;\n \n private:\n   TypeCheckResolveGenericArguments (Location locus)\n@@ -57,102 +49,18 @@ class TypeCheckType : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TyTy::BaseType *Resolve (HIR::Type *type)\n-  {\n-    TypeCheckType resolver (type->get_mappings ().get_hirid ());\n-    type->accept_vis (resolver);\n-    rust_assert (resolver.translated != nullptr);\n-    resolver.context->insert_type (type->get_mappings (), resolver.translated);\n-    return resolver.translated;\n-  }\n-\n-  void visit (HIR::BareFunctionType &fntype) override\n-  {\n-    TyTy::BaseType *return_type\n-      = fntype.has_return_type ()\n-\t  ? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n-\t  : TyTy::TupleType::get_unit_type (\n-\t    fntype.get_mappings ().get_hirid ());\n-\n-    std::vector<TyTy::TyVar> params;\n-    for (auto &param : fntype.get_function_params ())\n-      {\n-\tTyTy::BaseType *ptype\n-\t  = TypeCheckType::Resolve (param.get_type ().get ());\n-\tparams.push_back (TyTy::TyVar (ptype->get_ref ()));\n-      }\n-\n-    translated = new TyTy::FnPtr (fntype.get_mappings ().get_hirid (),\n-\t\t\t\t  fntype.get_locus (), std::move (params),\n-\t\t\t\t  TyTy::TyVar (return_type->get_ref ()));\n-  }\n-\n-  void visit (HIR::TupleType &tuple) override\n-  {\n-    if (tuple.is_unit_type ())\n-      {\n-\tauto unit_node_id = resolver->get_unit_type_node_id ();\n-\tif (!context->lookup_builtin (unit_node_id, &translated))\n-\t  {\n-\t    rust_error_at (tuple.get_locus (),\n-\t\t\t   \"failed to lookup builtin unit type\");\n-\t  }\n-\treturn;\n-      }\n-\n-    std::vector<TyTy::TyVar> fields;\n-    for (auto &elem : tuple.get_elems ())\n-      {\n-\tauto field_ty = TypeCheckType::Resolve (elem.get ());\n-\tfields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n-      }\n-\n-    translated = new TyTy::TupleType (tuple.get_mappings ().get_hirid (),\n-\t\t\t\t      tuple.get_locus (), fields);\n-  }\n+  static TyTy::BaseType *Resolve (HIR::Type *type);\n \n+  void visit (HIR::BareFunctionType &fntype) override;\n+  void visit (HIR::TupleType &tuple) override;\n   void visit (HIR::TypePath &path) override;\n-\n   void visit (HIR::QualifiedPathInType &path) override;\n-\n   void visit (HIR::ArrayType &type) override;\n-\n   void visit (HIR::SliceType &type) override;\n-\n-  void visit (HIR::ReferenceType &type) override\n-  {\n-    TyTy::BaseType *base\n-      = TypeCheckType::Resolve (type.get_base_type ().get ());\n-    translated = new TyTy::ReferenceType (type.get_mappings ().get_hirid (),\n-\t\t\t\t\t  TyTy::TyVar (base->get_ref ()),\n-\t\t\t\t\t  type.get_mut ());\n-  }\n-\n-  void visit (HIR::RawPointerType &type) override\n-  {\n-    TyTy::BaseType *base\n-      = TypeCheckType::Resolve (type.get_base_type ().get ());\n-    translated\n-      = new TyTy::PointerType (type.get_mappings ().get_hirid (),\n-\t\t\t       TyTy::TyVar (base->get_ref ()), type.get_mut ());\n-  }\n-\n-  void visit (HIR::InferredType &type) override\n-  {\n-    translated = new TyTy::InferType (type.get_mappings ().get_hirid (),\n-\t\t\t\t      TyTy::InferType::InferTypeKind::GENERAL,\n-\t\t\t\t      type.get_locus ());\n-  }\n-\n-  void visit (HIR::NeverType &type) override\n-  {\n-    TyTy::BaseType *lookup = nullptr;\n-    bool ok = context->lookup_builtin (\"!\", &lookup);\n-    rust_assert (ok);\n-\n-    translated = lookup->clone ();\n-  }\n-\n+  void visit (HIR::ReferenceType &type) override;\n+  void visit (HIR::RawPointerType &type) override;\n+  void visit (HIR::InferredType &type) override;\n+  void visit (HIR::NeverType &type) override;\n   void visit (HIR::TraitObjectType &type) override;\n \n private:\n@@ -177,55 +85,9 @@ class TypeResolveGenericParam : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TyTy::ParamType *Resolve (HIR::GenericParam *param)\n-  {\n-    TypeResolveGenericParam resolver;\n-    param->accept_vis (resolver);\n+  static TyTy::ParamType *Resolve (HIR::GenericParam *param);\n \n-    if (resolver.resolved == nullptr)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to setup generic parameter\");\n-\treturn nullptr;\n-      }\n-\n-    return resolver.resolved;\n-  }\n-\n-  void visit (HIR::TypeParam &param) override\n-  {\n-    if (param.has_type ())\n-      TypeCheckType::Resolve (param.get_type ().get ());\n-\n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n-    if (param.has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : param.get_type_param_bounds ())\n-\t  {\n-\t    switch (bound->get_bound_type ())\n-\t      {\n-\t\tcase HIR::TypeParamBound::BoundType::TRAITBOUND: {\n-\t\t  HIR::TraitBound *b\n-\t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n-\n-\t\t  TyTy::TypeBoundPredicate predicate\n-\t\t    = get_predicate_from_bound (b->get_path ());\n-\t\t  if (!predicate.is_error ())\n-\t\t    specified_bounds.push_back (std::move (predicate));\n-\t\t}\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    resolved = new TyTy::ParamType (param.get_type_representation (),\n-\t\t\t\t    param.get_locus (),\n-\t\t\t\t    param.get_mappings ().get_hirid (), param,\n-\t\t\t\t    specified_bounds);\n-  }\n+  void visit (HIR::TypeParam &param) override;\n \n private:\n   TypeResolveGenericParam () : TypeCheckBase (), resolved (nullptr) {}\n@@ -238,80 +100,10 @@ class ResolveWhereClauseItem : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static void Resolve (HIR::WhereClauseItem &item)\n-  {\n-    ResolveWhereClauseItem resolver;\n-    item.accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::LifetimeWhereClauseItem &) override {}\n-\n-  void visit (HIR::TypeBoundWhereClauseItem &item) override\n-  {\n-    auto &binding_type_path = item.get_bound_type ();\n-    TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n-\n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n-    for (auto &bound : item.get_type_param_bounds ())\n-      {\n-\tswitch (bound->get_bound_type ())\n-\t  {\n-\t    case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n-\t      HIR::TraitBound *b\n-\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n-\n-\t      TyTy::TypeBoundPredicate predicate\n-\t\t= get_predicate_from_bound (b->get_path ());\n-\t      if (!predicate.is_error ())\n-\t\tspecified_bounds.push_back (std::move (predicate));\n-\t    }\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-      }\n-    binding->inherit_bounds (specified_bounds);\n-\n-    // When we apply these bounds we must lookup which type this binding\n-    // resolves to, as this is the type which will be used during resolution\n-    // of the block.\n-    NodeId ast_node_id = binding_type_path->get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-      {\n-\t// FIXME\n-\trust_error_at (Location (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       binding_type_path->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n-      {\n-\t// FIXME\n-\trust_error_at (Location (), \"where-clause reverse lookup failure\");\n-\treturn;\n-      }\n-\n-    // the base reference for this name _must_ have a type set\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"Failed to resolve where-clause binding type: %s\",\n-\t\t       binding_type_path->as_string ().c_str ());\n-\treturn;\n-      }\n+  static void Resolve (HIR::WhereClauseItem &item);\n \n-    // FIXME\n-    // rust_assert (binding->is_equal (*lookup));\n-    lookup->inherit_bounds (specified_bounds);\n-  }\n+  void visit (HIR::LifetimeWhereClauseItem &) override;\n+  void visit (HIR::TypeBoundWhereClauseItem &item) override;\n \n private:\n   ResolveWhereClauseItem () : TypeCheckBase () {}"}]}