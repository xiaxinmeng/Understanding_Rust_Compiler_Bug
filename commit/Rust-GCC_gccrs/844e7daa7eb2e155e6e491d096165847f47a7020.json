{"sha": "844e7daa7eb2e155e6e491d096165847f47a7020", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0ZTdkYWE3ZWIyZTE1NWU2ZTQ5MWQwOTYxNjU4NDdmNDdhNzAyMA==", "commit": {"author": {"name": "Doug Rupp", "email": "rupp@adacore.com", "date": "2005-06-16T08:43:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:43:05Z"}, "message": "Make-lang.in: Add initialize.o when needed.\n\n2005-06-10  Doug Rupp  <rupp@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Jose Ruiz  <ruiz@adacore.com>\n\n\t* Make-lang.in: Add initialize.o when needed.\n\tRemove obsolete references to RT_FLAGS.\n\tAdd missing dependencies for sdefault.o\n\n\t* initialize.c: New file.\n\n\t* init.c [VMS] Declare ADA$ externs weak to fix build problem in IVMS.\n\t[VMS] cond_signal_table: Fix problem in declaration.\n\t[VMS] __gnat_error_handler: rewrite.\n\tMove all __gnat_initialize() routines to initialize.c\n\tSpecialize the former \"hpux\" section to \"hppa hpux\", as this is what the\n\tsection really is here for and we now have other hpux ports that need\n\tdifferent contents.\n\t(__gnat_adjust_context_for_raise) i386-linux: First version of this\n\tfunction for this target. Adjust PC by one in the machine context. This\n\tadjustment was previously done in the MD_FALLBACK_FRAME_STATE_FOR, but\n\tit is more reliable to do that in the signal handler itself.\n\t(__gnat_install_handler) i386-linux: Set SA_SIGINFO in the sigaction\n\tflags, so that the handler is passed the context structure to adjust\n\tprior to the raise.\n\t(__gnat_error_handler) i386-linux: Adjust the signature to match what a\n\tSA_SIGINFO sigaction should look like. Call\n\t__gnat_adjust_context_for_raise before actually raising. Cleanup unused\n\tMachine_State_Operations stuff.\n\tAdd conditional code so that the x86_64 is also supported.\n\nFrom-SVN: r101047", "tree": {"sha": "6f799614e4126cc77776191a6ce9d38ef36ebd7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f799614e4126cc77776191a6ce9d38ef36ebd7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/844e7daa7eb2e155e6e491d096165847f47a7020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844e7daa7eb2e155e6e491d096165847f47a7020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844e7daa7eb2e155e6e491d096165847f47a7020", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844e7daa7eb2e155e6e491d096165847f47a7020/comments", "author": {"login": "Cementitious", "id": 115579865, "node_id": "U_kgDOBuOb2Q", "avatar_url": "https://avatars.githubusercontent.com/u/115579865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cementitious", "html_url": "https://github.com/Cementitious", "followers_url": "https://api.github.com/users/Cementitious/followers", "following_url": "https://api.github.com/users/Cementitious/following{/other_user}", "gists_url": "https://api.github.com/users/Cementitious/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cementitious/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cementitious/subscriptions", "organizations_url": "https://api.github.com/users/Cementitious/orgs", "repos_url": "https://api.github.com/users/Cementitious/repos", "events_url": "https://api.github.com/users/Cementitious/events{/privacy}", "received_events_url": "https://api.github.com/users/Cementitious/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "217efe162dcacbed0b3eb31c68a1ea9070285137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/217efe162dcacbed0b3eb31c68a1ea9070285137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/217efe162dcacbed0b3eb31c68a1ea9070285137"}], "stats": {"total": 896, "additions": 505, "deletions": 391}, "files": [{"sha": "b9a56925aa1dab3d1a3f281c457966e984f730d0", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=844e7daa7eb2e155e6e491d096165847f47a7020", "patch": "@@ -1,6 +1,6 @@\n # Top level -*- makefile -*- fragment for GNU Ada (GNAT).\n #   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-#   2003, 2004 Free Software Foundation, Inc.\n+#   2003, 2004, 2005 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -105,7 +105,8 @@ ADA_TOOLS_FLAGS_TO_PASS=\\\n # Object files for gnat1 from C sources.\n GNAT1_C_OBJS = ada/b_gnat1.o ada/adadecode.o ada/adaint.o ada/cstreams.o \\\n  ada/cio.o ada/targtyps.o ada/decl.o ada/misc.o ada/utils.o ada/utils2.o \\\n- ada/trans.o ada/cuintp.o ada/argv.o ada/raise.o ada/init.o ada/tracebak.o\n+ ada/trans.o ada/cuintp.o ada/argv.o ada/raise.o ada/init.o ada/tracebak.o \\\n+ ada/initialize.o\n \n # Object files from Ada sources that are used by gnat1\n \n@@ -162,6 +163,7 @@ GNATBIND_OBJS = \\\n  ada/cstreams.o   \\\n  ada/final.o      \\\n  ada/init.o       \\\n+ ada/initialize.o \\\n  ada/seh_init.o   \\\n  ada/link.o       \\\n  ada/raise.o      \\\n@@ -942,7 +944,7 @@ ada/stamp-sdefault : $(srcdir)/version.c Makefile\n \n ada/sdefault.o : ada/sdefault.ads ada/sdefault.adb ada/types.ads \\\n    ada/unchdeal.ads ada/system.ads ada/s-exctab.ads ada/s-stalib.ads \\\n-   ada/unchconv.ads ada/osint.ads\n+   ada/unchconv.ads ada/osint.ads ada/g-os_lib.ads ada/g-string.ads\n \n ADA_TREE_H = ada/ada-tree.h ada/ada-tree.def\n \n@@ -1009,15 +1011,19 @@ ada/final.o    : ada/final.c $(CONFIG_H) $(SYSTEM_H) ada/raise.h\n ada/link.o     : ada/link.c\n \n ada/cio.o     : ada/cio.c $(CONFIG_H) $(SYSTEM_H) ada/adaint.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) $(RT_FLAGS) \\\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) \\\n \t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n ada/init.o    : ada/init.c $(CONFIG_H) $(SYSTEM_H) ada/adaint.h ada/raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) $(RT_FLAGS) \\\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) \\\n+\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+ada/initialize.o : ada/initialize.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) \\\n \t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n ada/raise.o   : ada/raise.c $(CONFIG_H) $(SYSTEM_H) ada/adaint.h ada/raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) $(RT_FLAGS) \\\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_ADA_CFLAGS) \\\n \t\t $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n # Need to keep the frame pointer in this file to pop the stack properly on"}, {"sha": "625e7ecea2c3ce86cce66b97c44380918a1c39f8", "filename": "gcc/ada/init.c", "status": "modified", "additions": 306, "deletions": 385, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=844e7daa7eb2e155e6e491d096165847f47a7020", "patch": "@@ -256,15 +256,6 @@ __gnat_set_globals (int main_priority,\n #endif\n }\n \n-/*********************/\n-/* __gnat_initialize */\n-/*********************/\n-\n-/* __gnat_initialize is called at the start of execution of an Ada program\n-   (the call is generated by the binder). The standard routine does nothing\n-   at all; the intention is that this be replaced by system specific\n-   code where initialization is required. */\n-\n /* Notes on the Zero Cost Exceptions scheme and its impact on the signal\n    handlers implemented below :\n \n@@ -291,7 +282,7 @@ __gnat_set_globals (int main_priority,\n    as the faulting instruction address in the corresponding signal context\n    pushed by the kernel. Leaving this address untouched may loose, because if\n    the triggering instruction happens to be the very first of a region, the\n-   later adjustments performed by the unwinder would yield an address outside\n+   later adjustements performed by the unwinder would yield an address outside\n    that region. We need to compensate for those adjustments at some point,\n    which we currently do in the GCC unwinding fallback macro.\n \n@@ -310,9 +301,9 @@ __gnat_set_globals (int main_priority,\n    of subtleties to account for.  See for instance the syscall(SYS_sigaction)\n    story in libjava/include/i386-signal.h.  */\n \n-/***********************************/\n-/* __gnat_initialize (AIX Version) */\n-/***********************************/\n+/***************/\n+/* AIX Section */\n+/***************/\n \n #if defined (_AIX)\n \n@@ -402,36 +393,11 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/***************************************/\n-/* __gnat_initialize (RTEMS version) */\n-/***************************************/\n-\n-#elif defined(__rtems__)\n-\n-extern void __gnat_install_handler (void);\n-\n-/* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n-\n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-   __gnat_install_handler ();\n-}\n-\n-/****************************************/\n-/* __gnat_initialize (Dec Unix Version) */\n-/****************************************/\n-\n-#elif defined(__alpha__) && defined(__osf__) && ! defined(__alpha_vxworks)\n+/*****************/\n+/* Tru64 section */\n+/*****************/\n \n-/* Note: it seems that __osf__ is defined for the Alpha VXWorks case. Not\n-   clear that this is reasonable, but in any case we have to be sure to\n-   exclude this case in the above test.  */\n+#elif defined(__alpha__) && defined(__osf__)\n \n #include <signal.h>\n #include <sys/siginfo.h>\n@@ -542,11 +508,6 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n /* Routines called by s-mastop-tru64.adb.  */\n \n #define SC_GP 29\n@@ -571,11 +532,11 @@ __gnat_machine_state_length (void)\n   return sizeof (struct sigcontext);\n }\n \n-/************************************/\n-/* __gnat_initialize (HPUX Version) */\n-/************************************/\n+/********************/\n+/* PA HP-UX section */\n+/********************/\n \n-#elif defined (__hpux__)\n+#elif defined (__hppa__) && defined (__hpux__)\n \n #include <signal.h>\n #include <sys/ucontext.h>\n@@ -676,19 +637,16 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/*****************************************/\n-/* __gnat_initialize (GNU/Linux Version) */\n-/*****************************************/\n+/*********************/\n+/* GNU/Linux Section */\n+/*********************/\n \n-#elif defined (linux) && defined (i386) && !defined (__RT__)\n+#elif defined (linux) && (defined (i386) || defined (__x86_64__))\n \n #include <signal.h>\n-#include <asm/sigcontext.h>\n+\n+#define __USE_GNU 1 /* required to get REG_EIP/RIP from glibc's ucontext.h */\n+#include <sys/ucontext.h>\n \n /* GNU/Linux, which uses glibc, does not define NULL in included\n    header files */\n@@ -697,35 +655,34 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n #define NULL ((void *) 0)\n #endif\n \n-struct Machine_State\n+static void __gnat_error_handler (int, siginfo_t *siginfo, void *ucontext);\n+\n+/* __gnat_adjust_context_for_raise - see comments along with the default\n+   version later in this file.  */\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n {\n-  unsigned long eip;\n-  unsigned long ebx;\n-  unsigned long esp;\n-  unsigned long ebp;\n-  unsigned long esi;\n-  unsigned long edi;\n-};\n+  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n \n-static void __gnat_error_handler (int);\n+#if defined (i386)\n+  mcontext->gregs[REG_EIP]++;\n+#elif defined (__x86_64__)\n+  mcontext->gregs[REG_RIP]++;\n+#endif\n+}\n \n static void\n-__gnat_error_handler (int sig)\n+__gnat_error_handler (int sig,\n+                      siginfo_t *siginfo ATTRIBUTE_UNUSED,\n+                      void *ucontext)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n   static int recurse = 0;\n \n-  struct sigcontext *info\n-    = (struct sigcontext *) (((char *) &sig) + sizeof (int));\n-\n-  /* The Linux kernel does not document how to get the machine state in a\n-     signal handler, but in fact the necessary data is in a sigcontext_struct\n-     value that is on the stack immediately above the signal number\n-     parameter, and the above messing accesses this value on the stack. */\n-\n-  struct Machine_State *mstate;\n-\n   switch (sig)\n     {\n     case SIGSEGV:\n@@ -781,19 +738,15 @@ __gnat_error_handler (int sig)\n       exception = &program_error;\n       msg = \"unhandled signal\";\n     }\n+  recurse = 0;\n \n-  mstate = (*Get_Machine_State_Addr) ();\n-  if (mstate)\n-    {\n-      mstate->eip = info->eip;\n-      mstate->ebx = info->ebx;\n-      mstate->esp = info->esp_at_signal;\n-      mstate->ebp = info->ebp;\n-      mstate->esi = info->esi;\n-      mstate->edi = info->edi;\n-    }\n+  /* We adjust the interrupted context here (and not in the\n+     MD_FALLBACK_FRAME_STATE_FOR macro) because recent versions of the Native\n+     POSIX Thread Library (NPTL) are compiled with DWARF 2 unwind information,\n+     and hence the later macro is never executed for signal frames. */\n+\n+  __gnat_adjust_context_for_raise (sig, ucontext);\n \n-  recurse = 0;\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -806,8 +759,8 @@ __gnat_install_handler (void)\n      exceptions.  Make sure that the handler isn't interrupted by another\n      signal that might cause a scheduling event! */\n \n-  act.sa_handler = __gnat_error_handler;\n-  act.sa_flags = SA_NODEFER | SA_RESTART;\n+  act.sa_sigaction = __gnat_error_handler;\n+  act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n   /* Do not install handlers if interrupt state is \"System\" */\n@@ -825,51 +778,9 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/******************************************/\n-/* __gnat_initialize (NT-mingw32 Version) */\n-/******************************************/\n-\n-#elif defined (__MINGW32__)\n-#include <windows.h>\n-\n-void\n-__gnat_install_handler (void)\n-{\n-}\n-\n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-   /* Initialize floating-point coprocessor. This call is needed because\n-      the MS libraries default to 64-bit precision instead of 80-bit\n-      precision, and we require the full precision for proper operation,\n-      given that we have set Max_Digits etc with this in mind */\n-   __gnat_init_float ();\n-\n-   /* Initialize a lock for a process handle list - see a-adaint.c for the\n-      implementation of __gnat_portable_no_block_spawn, __gnat_portable_wait */\n-   __gnat_plist_init();\n-\n-   /* Note that we do not activate this for the compiler itself to avoid a\n-      bootstrap path problem.  Older version of gnatbind will generate a call\n-      to __gnat_initialize() without argument. Therefore we cannot use eh in\n-      this case.  It will be possible to remove the following #ifdef at some\n-      point.  */\n-#ifdef IN_RTS\n-   /* Install the Structured Exception handler.  */\n-   if (eh)\n-     __gnat_install_SEH_handler (eh);\n-#endif\n-}\n-\n-/***************************************/\n-/* __gnat_initialize (Interix Version) */\n-/***************************************/\n+/*******************/\n+/* Interix Section */\n+/*******************/\n \n #elif defined (__INTERIX)\n \n@@ -934,58 +845,9 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-   __gnat_init_float ();\n-}\n-\n-/**************************************/\n-/* __gnat_initialize (LynxOS Version) */\n-/**************************************/\n-\n-#elif defined (__Lynx__)\n-\n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-   __gnat_init_float ();\n-}\n-\n-/*********************************/\n-/* __gnat_install_handler (Lynx) */\n-/*********************************/\n-\n-void\n-__gnat_install_handler (void)\n-{\n-  __gnat_handler_installed = 1;\n-}\n-\n-/****************************/\n-/* __gnat_initialize (OS/2) */\n-/****************************/\n-\n-#elif defined (__EMX__) /* OS/2 dependent initialization */\n-\n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/*********************************/\n-/* __gnat_install_handler (OS/2) */\n-/*********************************/\n-\n-void\n-__gnat_install_handler (void)\n-{\n-  __gnat_handler_installed = 1;\n-}\n-\n-/***********************************/\n-/* __gnat_initialize (SGI Version) */\n-/***********************************/\n+/****************/\n+/* IRIX Section */\n+/****************/\n \n #elif defined (sgi)\n \n@@ -1135,14 +997,9 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/*************************************************/\n-/* __gnat_initialize (Solaris and SunOS Version) */\n-/*************************************************/\n+/*******************/\n+/* Solaris Section */\n+/*******************/\n \n #elif defined (sun) && defined (__SVR4) && !defined (__vxworks)\n \n@@ -1243,17 +1100,14 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/***********************************/\n-/* __gnat_initialize (VMS Version) */\n-/***********************************/\n+/***************/\n+/* VMS Section */\n+/***************/\n \n #elif defined (VMS)\n \n+long __gnat_error_handler (int *, void *);\n+\n #ifdef __IA64\n #define lib_get_curr_invo_context LIB$I64_GET_CURR_INVO_CONTEXT\n #define lib_get_prev_invo_context LIB$I64_GET_PREV_INVO_CONTEXT\n@@ -1273,12 +1127,69 @@ extern long __gnat_error_prehandler (void);\n extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n #endif\n \n+/* Define macro symbols for the VMS conditions that become Ada exceptions.\n+   Most of these are also defined in the header file ssdef.h which has not\n+   yet been converted to be recoginized by Gnu C. */\n+\n+/* Defining these as macros, as opposed to external addresses, allows\n+   them to be used in a case statement (below */\n+#define SS$_ACCVIO            12\n+#define SS$_HPARITH         1284\n+#define SS$_STKOVF          1364\n+#define SS$_RESIGNAL        2328\n+\n+/* These codes are in standard message libraries */\n+extern int CMA$_EXIT_THREAD;\n+extern int SS$_DEBUG;\n+extern int SS$_INTDIV;\n+extern int LIB$_KEYNOTFOU;\n+extern int LIB$_ACTIMAGE;\n+extern int MTH$_FLOOVEMAT;       /* Some ACVC_21 CXA tests */\n+\n+/* These codes are non standard, which is to say the author is\n+   not sure if they are defined in the standar message libraries\n+   so keep them as macros for now. */\n+#define RDB$_STREAM_EOF 20480426\n+#define FDL$_UNPRIKW 11829410\n+\n+struct cond_except {\n+  const int *cond;\n+  const struct Exception_Data *except;\n+};\n+\n+struct descriptor_s {unsigned short len, mbz; __char_ptr32 adr; };\n+\n /* Conditions that don't have an Ada exception counterpart must raise\n    Non_Ada_Error.  Since this is defined in s-auxdec, it should only be\n    referenced by user programs, not the compiler or tools. Hence the\n    #ifdef IN_RTS. */\n \n #ifdef IN_RTS\n+\n+#define Status_Error ada__io_exceptions__status_error\n+extern struct Exception_Data Status_Error;\n+\n+#define Mode_Error ada__io_exceptions__mode_error\n+extern struct Exception_Data Mode_Error;\n+\n+#define Name_Error ada__io_exceptions__name_error\n+extern struct Exception_Data Name_Error;\n+\n+#define Use_Error ada__io_exceptions__use_error\n+extern struct Exception_Data Use_Error;\n+\n+#define Device_Error ada__io_exceptions__device_error\n+extern struct Exception_Data Device_Error;\n+\n+#define End_Error ada__io_exceptions__end_error\n+extern struct Exception_Data End_Error;\n+\n+#define Data_Error ada__io_exceptions__data_error\n+extern struct Exception_Data Data_Error;\n+\n+#define Layout_Error ada__io_exceptions__layout_error\n+extern struct Exception_Data Layout_Error;\n+\n #define Non_Ada_Error system__aux_dec__non_ada_error\n extern struct Exception_Data Non_Ada_Error;\n \n@@ -1287,38 +1198,97 @@ extern struct Exception_Data *Coded_Exception (Exception_Code);\n \n #define Base_Code_In system__vms_exception_table__base_code_in\n extern Exception_Code Base_Code_In (Exception_Code);\n-#endif\n \n-/* Define macro symbols for the VMS conditions that become Ada exceptions.\n-   Most of these are also defined in the header file ssdef.h which has not\n-   yet been converted to be recognized by Gnu C. Some, which couldn't be\n-   located, are assigned names based on the DEC test suite tests which\n-   raise them. */\n+/* DEC Ada exceptions are not defined in a header file, so they\n+   must be declared as external addresses */\n+\n+extern int ADA$_PROGRAM_ERROR __attribute__ ((weak));\n+extern int ADA$_LOCK_ERROR __attribute__ ((weak));\n+extern int ADA$_EXISTENCE_ERROR __attribute__ ((weak));\n+extern int ADA$_KEY_ERROR __attribute__ ((weak));\n+extern int ADA$_KEYSIZERR __attribute__ ((weak));\n+extern int ADA$_STAOVF __attribute__ ((weak));\n+extern int ADA$_CONSTRAINT_ERRO __attribute__ ((weak));\n+extern int ADA$_IOSYSFAILED __attribute__ ((weak));\n+extern int ADA$_LAYOUT_ERROR __attribute__ ((weak));\n+extern int ADA$_STORAGE_ERROR __attribute__ ((weak));\n+extern int ADA$_DATA_ERROR __attribute__ ((weak));\n+extern int ADA$_DEVICE_ERROR __attribute__ ((weak));\n+extern int ADA$_END_ERROR __attribute__ ((weak));\n+extern int ADA$_MODE_ERROR __attribute__ ((weak));\n+extern int ADA$_NAME_ERROR __attribute__ ((weak));\n+extern int ADA$_STATUS_ERROR __attribute__ ((weak));\n+extern int ADA$_NOT_OPEN __attribute__ ((weak));\n+extern int ADA$_ALREADY_OPEN __attribute__ ((weak));\n+extern int ADA$_USE_ERROR __attribute__ ((weak));\n+extern int ADA$_UNSUPPORTED __attribute__ ((weak));\n+extern int ADA$_FAC_MODE_MISMAT __attribute__ ((weak));\n+extern int ADA$_ORG_MISMATCH __attribute__ ((weak));\n+extern int ADA$_RFM_MISMATCH __attribute__ ((weak));\n+extern int ADA$_RAT_MISMATCH __attribute__ ((weak));\n+extern int ADA$_MRS_MISMATCH __attribute__ ((weak));\n+extern int ADA$_MRN_MISMATCH __attribute__ ((weak));\n+extern int ADA$_KEY_MISMATCH __attribute__ ((weak));\n+extern int ADA$_MAXLINEXC __attribute__ ((weak));\n+extern int ADA$_LINEXCMRS __attribute__ ((weak));\n+\n+/* DEC Ada specific conditions */\n+static const struct cond_except dec_ada_cond_except_table [] = {\n+  {&ADA$_PROGRAM_ERROR,   &program_error},\n+  {&ADA$_USE_ERROR,       &Use_Error},\n+  {&ADA$_KEYSIZERR,       &program_error},\n+  {&ADA$_STAOVF,          &storage_error},\n+  {&ADA$_CONSTRAINT_ERRO, &constraint_error},\n+  {&ADA$_IOSYSFAILED,     &Device_Error},\n+  {&ADA$_LAYOUT_ERROR,    &Layout_Error},\n+  {&ADA$_STORAGE_ERROR,   &storage_error},\n+  {&ADA$_DATA_ERROR,      &Data_Error},\n+  {&ADA$_DEVICE_ERROR,    &Device_Error},\n+  {&ADA$_END_ERROR,       &End_Error},\n+  {&ADA$_MODE_ERROR,      &Mode_Error},\n+  {&ADA$_NAME_ERROR,      &Name_Error},\n+  {&ADA$_STATUS_ERROR,    &Status_Error},\n+  {&ADA$_NOT_OPEN,        &Use_Error},\n+  {&ADA$_ALREADY_OPEN,    &Use_Error},\n+  {&ADA$_USE_ERROR,       &Use_Error},\n+  {&ADA$_UNSUPPORTED,     &Use_Error},\n+  {&ADA$_FAC_MODE_MISMAT, &Use_Error},\n+  {&ADA$_ORG_MISMATCH,    &Use_Error},\n+  {&ADA$_RFM_MISMATCH,    &Use_Error},\n+  {&ADA$_RAT_MISMATCH,    &Use_Error},\n+  {&ADA$_MRS_MISMATCH,    &Use_Error},\n+  {&ADA$_MRN_MISMATCH,    &Use_Error},\n+  {&ADA$_KEY_MISMATCH,    &Use_Error},\n+  {&ADA$_MAXLINEXC,       &constraint_error},\n+  {&ADA$_LINEXCMRS,       &constraint_error},\n+  {0,                     0}\n+};\n \n-#define SS$_ACCVIO            12\n-#define SS$_DEBUG           1132\n-#define SS$_INTDIV          1156\n-#define SS$_HPARITH         1284\n-#define SS$_STKOVF          1364\n-#define SS$_RESIGNAL        2328\n-#define MTH$_FLOOVEMAT   1475268       /* Some ACVC_21 CXA tests */\n-#define SS$_CE24VRU      3253636       /* Write to unopened file */\n-#define SS$_C980VTE      3246436       /* AST requests time slice */\n-#define CMA$_EXIT_THREAD 4227492\n-#define CMA$_EXCCOPLOS   4228108\n-#define CMA$_ALERTED     4227460\n+#if 0\n+   /* Already handled by a pragma Import_Exception\n+      in Aux_IO_Exceptions */\n+  {&ADA$_LOCK_ERROR,      &Lock_Error},\n+  {&ADA$_EXISTENCE_ERROR, &Existence_Error},\n+  {&ADA$_KEY_ERROR,       &Key_Error},\n+#endif\n \n-struct descriptor_s {unsigned short len, mbz; char *adr; };\n+#endif /* IN_RTS */\n \n-long __gnat_error_handler (int *, void *);\n+/* Non DEC Ada specific conditions. We could probably also put\n+   SS$_HPARITH here and possibly SS$_ACCVIO, SS$_STKOVF. */\n+static const struct cond_except cond_except_table [] = {\n+  {&MTH$_FLOOVEMAT, &constraint_error},\n+  {&SS$_INTDIV,     &constraint_error},\n+  {0,               0}\n+};\n \n /* To deal with VMS conditions and their mapping to Ada exceptions,\n    the __gnat_error_handler routine below is installed as an exception\n    vector having precedence over DEC frame handlers.  Some conditions\n    still need to be handled by such handlers, however, in which case\n    __gnat_error_handler needs to return SS$_RESIGNAL.  Consider for\n    instance the use of a third party library compiled with DECAda and\n-   performing its own exception handling internally.\n+   performing it's own exception handling internally.\n \n    To allow some user-level flexibility, which conditions should be\n    resignaled is controlled by a predicate function, provided with the\n@@ -1337,26 +1307,36 @@ long __gnat_error_handler (int *, void *);\n    ??? This is not a perfect solution to deal with the possible\n    interactions between the GNAT and the DECAda exception handling\n    models and better (more general) schemes are studied.  This is so\n-   just provided as a convenient workaround in the meantime, and\n+   just provided as a conveniency workaround in the meantime, and\n    should be use with caution since the implementation has been kept\n    very simple.  */\n \n typedef int\n resignal_predicate (int code);\n \n+const int *cond_resignal_table [] = {\n+  &CMA$_EXIT_THREAD,\n+  &SS$_DEBUG,\n+  &LIB$_KEYNOTFOU,\n+  &LIB$_ACTIMAGE,\n+  (int *) RDB$_STREAM_EOF,\n+  (int *) FDL$_UNPRIKW,\n+  0\n+};\n+\n /* Default GNAT predicate for resignaling conditions.  */\n \n static int\n __gnat_default_resignal_p (int code)\n {\n-  return\n-    code == CMA$_EXIT_THREAD\n-    || code == SS$_DEBUG /* Gdb attach, resignal to merge activate gdbstub. */\n-    || code == 1409786   /* Nickerson bug #33 ??? */\n-    || code == 1381050   /* Nickerson bug #33 ??? */\n-    || code == 20480426  /* RDB-E-STREAM_EOF */\n-    || code == 11829410  /* Resignalled as Use_Error for CE10VRC */\n-  ;\n+  int i, iexcept;\n+\n+  for (i = 0, iexcept = 0;\n+       cond_resignal_table [i] &&\n+       !(iexcept = LIB$MATCH_COND (&code, &cond_resignal_table [i]));\n+       i++);\n+\n+  return iexcept;\n }\n \n /* Static pointer to predicate that the __gnat_error_handler exception\n@@ -1376,18 +1356,47 @@ __gnat_set_resignal_predicate (resignal_predicate * predicate)\n     __gnat_resignal_p = predicate;\n }\n \n+/* Should match System.Parameters.Default_Exception_Msg_Max_Length */\n+#define Default_Exception_Msg_Max_Length 512\n+\n+/* Action routine for SYS$PUTMSG. There may be\n+   multiple conditions, each with text to be appended to\n+   MESSAGE and separated by line termination. */\n+\n+static int\n+copy_msg (msgdesc, message)\n+     struct descriptor_s *msgdesc;\n+     char *message;\n+{\n+  int len = strlen (message);\n+  int copy_len;\n+\n+  /* Check for buffer overflow and skip */\n+  if (len > 0 && len <= Default_Exception_Msg_Max_Length - 3)\n+    {\n+      strcat (message, \"\\r\\n\");\n+      len += 2;\n+    }\n+\n+  /* Check for buffer overflow and truncate if necessary */\n+  copy_len = (len + msgdesc->len <= Default_Exception_Msg_Max_Length - 1 ?\n+\t      msgdesc->len :\n+\t      len + msgdesc->len - Default_Exception_Msg_Max_Length);\n+  strncpy (&message [len], msgdesc->adr, copy_len);\n+  message [len + copy_len] = 0;\n+\n+  return 0;\n+}\n+\n long\n __gnat_error_handler (int *sigargs, void *mechargs)\n {\n   struct Exception_Data *exception = 0;\n   Exception_Code base_code;\n+  struct descriptor_s gnat_facility = {4,0,\"GNAT\"};\n+  char message [Default_Exception_Msg_Max_Length];\n \n   char *msg = \"\";\n-  char message[256];\n-  long prvhnd;\n-  struct descriptor_s msgdesc;\n-  int msg_flag = 0x000f; /* 1 bit for each of the four message parts */\n-  unsigned short outlen;\n   char curr_icb[544];\n   long curr_invo_handle;\n   long *mstate;\n@@ -1405,11 +1414,8 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n \n   if (exception)\n     {\n-      msgdesc.len = 256;\n-      msgdesc.mbz = 0;\n-      msgdesc.adr = message;\n-      SYS$GETMSG (sigargs[1], &outlen, &msgdesc, msg_flag, 0);\n-      message[outlen] = 0;\n+      message [0] = 0;\n+      SYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n       msg = message;\n \n       exception->Name_Length = 19;\n@@ -1440,11 +1446,6 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n \tmsg = \"stack overflow\";\n \tbreak;\n \n-      case SS$_INTDIV:\n-\texception = &constraint_error;\n-\tmsg = \"division by zero\";\n-\tbreak;\n-\n       case SS$_HPARITH:\n #ifndef IN_RTS\n \treturn SS$_RESIGNAL; /* toplev.c handles for compiler */\n@@ -1456,34 +1457,46 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n #endif\n \tbreak;\n \n-      case MTH$_FLOOVEMAT:\n-\texception = &constraint_error;\n-\tmsg = \"floating overflow in math library\";\n-\tbreak;\n-\n-      case SS$_CE24VRU:\n-\texception = &constraint_error;\n-\tmsg = \"\";\n-\tbreak;\n-\n-      case SS$_C980VTE:\n-\texception = &program_error;\n-\tmsg = \"\";\n-\tbreak;\n-\n       default:\n-#ifndef IN_RTS\n-\texception = &program_error;\n+#ifdef IN_RTS\n+\t{\n+\t  int i;\n+\n+\t  /* Scan the DEC Ada exception condition table for a match and fetch the\n+\t     associated GNAT exception pointer */\n+\t  for (i = 0;\n+\t       dec_ada_cond_except_table [i].cond &&\n+\t       !LIB$MATCH_COND (&sigargs [1], &dec_ada_cond_except_table [i].cond);\n+\t       i++);\n+\t  exception = (struct Exception_Data *) dec_ada_cond_except_table [i].except;\n+\n+\t  if (exception)\n+\t    /* DEC Ada exceptions never have a PC and PSL appended, but LIB$STOP\n+\t       (which is how we got here from Bliss code)\n+\t       allows slots for them and the result is 2 words of garbage on the\n+\t       end, so the count must be decremented. */\n+\t    sigargs [0] -= 2;\n+\t  else\n+\t    {\n+\t      /* Scan the VMS standard condition table for a match and fetch the\n+\t\t associated GNAT exception pointer */\n+\t      for (i = 0;\n+\t\t   cond_except_table [i].cond &&\n+\t\t   !LIB$MATCH_COND (&sigargs [1], &cond_except_table [i].cond);\n+\t\t   i++);\n+\t      exception =(struct Exception_Data *) cond_except_table [i].except;\n+\n+\t      if (!exception)\n+\t\t/* User programs expect Non_Ada_Error to be raised, reference\n+\t\t   DEC Ada test CXCONDHAN. */\n+\t\texception = &Non_Ada_Error;\n+\t    }\n+\t}\n #else\n-\t/* User programs expect Non_Ada_Error to be raised, reference\n-\t   DEC Ada test CXCONDHAN. */\n-\texception = &Non_Ada_Error;\n+\texception = &program_error;\n #endif\n-\tmsgdesc.len = 256;\n-\tmsgdesc.mbz = 0;\n-\tmsgdesc.adr = message;\n-\tSYS$GETMSG (sigargs[1], &outlen, &msgdesc, msg_flag, 0);\n-\tmessage[outlen] = 0;\n+\tmessage [0] = 0;\n+\tSYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n \tmsg = message;\n \tbreak;\n       }\n@@ -1516,17 +1529,13 @@ __gnat_install_handler (void)\n #else\n   SYS$SETEXV (1, __gnat_error_handler, 3, &prvhnd);\n #endif\n-  __gnat_handler_installed = 1;\n-}\n \n-void\n-__gnat_initialize(void *eh ATTRIBUTE_UNUSED)\n-{\n+  __gnat_handler_installed = 1;\n }\n \n-/*************************************************/\n-/* __gnat_initialize (FreeBSD version) */\n-/*************************************************/\n+/*******************/\n+/* FreeBSD Section */\n+/*******************/\n \n #elif defined (__FreeBSD__)\n \n@@ -1589,24 +1598,13 @@ __gnat_install_handler ()\n   (void) sigaction (SIGFPE,  &act, NULL);\n   (void) sigaction (SIGSEGV, &act, NULL);\n   (void) sigaction (SIGBUS,  &act, NULL);\n-}\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-   __gnat_install_handler ();\n-\n-   /* XXX - Initialize floating-point coprocessor. This call is\n-      needed because FreeBSD defaults to 64-bit precision instead\n-      of 80-bit precision?  We require the full precision for\n-      proper operation, given that we have set Max_Digits etc\n-      with this in mind */\n-   __gnat_init_float ();\n+  __gnat_handler_installed = 1;\n }\n \n-/***************************************/\n-/* __gnat_initialize (VXWorks Version) */\n-/***************************************/\n+/*******************/\n+/* VxWorks Section */\n+/*******************/\n \n #elif defined(__vxworks)\n \n@@ -1761,7 +1759,7 @@ __gnat_init_float (void)\n   asm (\"mtfsb0 26\");\n #endif\n \n-  /* Similarly for sparc64. Achieved by masking bits in the Trap Enable Mask\n+  /* Similarily for sparc64. Achieved by masking bits in the Trap Enable Mask\n      field of the Floating-point Status Register (see the Sparc Architecture\n      Manual Version 9, p 48).  */\n #if defined (sparc64)\n@@ -1781,69 +1779,9 @@ __gnat_init_float (void)\n #endif\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-  __gnat_init_float ();\n-\n-  /* On targets where we might be using the ZCX scheme, we need to register\n-     the frame tables.\n-\n-     For applications loaded as a set of \"modules\", the crtstuff objects\n-     linked in (crtbegin/end) are tailored to provide this service a-la C++\n-     constructor fashion, typically triggered by the VxWorks loader.  This is\n-     achieved by way of a special variable declaration in the crt object, the\n-     name of which has been deduced by analyzing the output of the \"munching\"\n-     step documented for C++.  The de-registration is handled symmetrically,\n-     a-la C++ destructor fashion and typically triggered by the dynamic\n-     unloader.  Note that since the tables shall be registered against a\n-     common datastructure, libgcc should be one of the modules (vs being\n-     partially linked against all the others at build time) and shall be\n-     loaded first.\n-\n-     For applications linked with the kernel, the scheme above would lead to\n-     duplicated symbols because the VxWorks kernel build \"munches\" by default.\n-     To prevent those conflicts, we link against crtbegin/endS objects that\n-     don't include the special variable and directly call the appropriate\n-     function here. We'll never unload that, so there is no de-registration to\n-     worry about.\n-\n-     For whole applications loaded as a single module, we may use one scheme\n-     or the other, except for the mixed Ada/C++ case in which the first scheme\n-     would fail for the same reason as in the linked-with-kernel situation.\n-\n-     We can differentiate by looking at the __module_has_ctors value provided\n-     by each class of crt objects. As of today, selecting the crt set with the\n-     ctors/dtors capabilities (first scheme above) is triggered by adding\n-     \"-dynamic\" to the gcc *link* command line options. Selecting the other\n-     set of crt objects is achieved by \"-static\" instead.\n-\n-     This is a first approach, tightly synchronized with a number of GCC\n-     configuration and crtstuff changes. We need to ensure that those changes\n-     are there to activate this circuitry.  */\n-\n-#if (__GNUC__ >= 3) && (defined (_ARCH_PPC) || defined (__ppc))\n- {\n-   /* The scheme described above is only useful for the actual ZCX case, and\n-      we don't want any reference to the crt provided symbols otherwise.  We\n-      may not link with any of the crt objects in the non-ZCX case, e.g. from\n-      documented procedures instructing the use of -nostdlib, and references\n-      to the ctors symbols here would just remain unsatisfied.\n-\n-      We have no way to avoid those references in the right conditions in this\n-      C module, because we have nothing like a IN_ZCX_RTS macro.  This aspect\n-      is then deferred to an Ada routine, which can do that based on a test\n-      against a constant System flag value.  */\n-\n-   extern void __gnat_vxw_setup_for_eh (void);\n-   __gnat_vxw_setup_for_eh ();\n- }\n-#endif\n-}\n-\n-/********************************/\n-/* __gnat_initialize for NetBSD */\n-/********************************/\n+/******************/\n+/* NetBSD Section */\n+/******************/\n \n #elif defined(__NetBSD__)\n \n@@ -1904,30 +1842,13 @@ __gnat_install_handler(void)\n   __gnat_handler_installed = 1;\n }\n \n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-  __gnat_install_handler ();\n-  __gnat_init_float ();\n-}\n-\n #else\n \n-/* For all other versions of GNAT, the initialize routine and handler\n-   installation do nothing */\n-\n-/***************************************/\n-/* __gnat_initialize (Default Version) */\n-/***************************************/\n-\n-void\n-__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n-{\n-}\n+/* For all other versions of GNAT, the handler does nothing */\n \n-/********************************************/\n-/* __gnat_install_handler (Default Version) */\n-/********************************************/\n+/*******************/\n+/* Default Section */\n+/*******************/\n \n void\n __gnat_install_handler (void)"}, {"sha": "4963e6646f0a19cd8d3291cce5a20939a620593b", "filename": "gcc/ada/initialize.c", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844e7daa7eb2e155e6e491d096165847f47a7020/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=844e7daa7eb2e155e6e491d096165847f47a7020", "patch": "@@ -0,0 +1,187 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                           I N I T I A L I Z E                            *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/*  This unit provides default implementation for __gnat_initialize ()\n+    which is called before the elaboration of the partition. It is provided\n+    in a separate file/object so that users can replace it easily.\n+    The default implementation should be null on most targets. */\n+\n+/* The following include is here to meet the published VxWorks requirement\n+   that the __vxworks header appear before any other include. */\n+#ifdef __vxworks\n+#include \"vxWorks.h\"\n+#endif\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"raise.h\"\n+\n+/******************************************/\n+/* __gnat_initialize (NT-mingw32 Version) */\n+/******************************************/\n+\n+#if defined (__MINGW32__)\n+#include <windows.h>\n+\n+extern void __gnat_init_float (void);\n+extern void __gnat_plist_init (void);\n+extern void __gnat_install_SEH_handler (void *);\n+\n+void\n+__gnat_initialize (void *eh)\n+{\n+   /* Initialize floating-point coprocessor. This call is needed because\n+      the MS libraries default to 64-bit precision instead of 80-bit\n+      precision, and we require the full precision for proper operation,\n+      given that we have set Max_Digits etc with this in mind */\n+   __gnat_init_float ();\n+\n+   /* Initialize a lock for a process handle list - see adaint.c for the\n+      implementation of __gnat_portable_no_block_spawn, __gnat_portable_wait */\n+   __gnat_plist_init();\n+\n+   /* Note that we do not activate this for the compiler itself to avoid a\n+      bootstrap path problem.  Older version of gnatbind will generate a call\n+      to __gnat_initialize() without argument. Therefore we cannot use eh in\n+      this case.  It will be possible to remove the following #ifdef at some\n+      point.  */\n+#ifdef IN_RTS\n+   /* Install the Structured Exception handler.  */\n+   if (eh)\n+     __gnat_install_SEH_handler (eh);\n+#endif\n+}\n+\n+/******************************************/\n+/* __gnat_initialize (init_float version) */\n+/******************************************/\n+\n+#elif defined (__INTERIX) || defined (__Lynx__) || \\\n+      defined (__FreeBSD__) || defined(__NetBSD__)\n+\n+extern void __gnat_init_float (void);\n+\n+void\n+__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n+{\n+   __gnat_init_float ();\n+}\n+\n+/***************************************/\n+/* __gnat_initialize (VxWorks Version) */\n+/***************************************/\n+\n+#elif defined(__vxworks)\n+\n+extern void __gnat_init_float (void);\n+\n+void\n+__gnat_initialize (void *eh)\n+{\n+  __gnat_init_float ();\n+\n+  /* On targets where we might be using the ZCX scheme, we need to register\n+     the frame tables.\n+\n+     For applications loaded as a set of \"modules\", the crtstuff objects\n+     linked in (crtbegin/end) are tailored to provide this service a-la C++\n+     constructor fashion, typically triggered by the VxWorks loader.  This is\n+     achieved by way of a special variable declaration in the crt object, the\n+     name of which has been deduced by analyzing the output of the \"munching\"\n+     step documented for C++.  The de-registration is handled symetrically,\n+     a-la C++ destructor fashion and typically triggered by the dynamic\n+     unloader.  Note that since the tables shall be registered against a\n+     common datastructure, libgcc should be one of the modules (vs beeing\n+     partially linked against all the others at build time) and shall be\n+     loaded first.\n+\n+     For applications linked with the kernel, the scheme above would lead to\n+     duplicated symbols because the VxWorks kernel build \"munches\" by default.\n+     To prevent those conflicts, we link against crtbegin/endS objects that\n+     don't include the special variable and directly call the appropriate\n+     function here. We'll never unload that, so there is no de-registration to\n+     worry about.\n+\n+     For whole applications loaded as a single module, we may use one scheme\n+     or the other, except for the mixed Ada/C++ case in which the first scheme\n+     would fail for the same reason as in the linked-with-kernel situation.\n+\n+     We can differentiate by looking at the __module_has_ctors value provided\n+     by each class of crt objects. As of today, selecting the crt set with the\n+     ctors/dtors capabilities (first scheme above) is triggered by adding\n+     \"-dynamic\" to the gcc *link* command line options. Selecting the other\n+     set of crt objects is achieved by \"-static\" instead.\n+\n+     This is a first approach, tightly synchronized with a number of GCC\n+     configuration and crtstuff changes. We need to ensure that those changes\n+     are there to activate this circuitry.  */\n+\n+#if (__GNUC__ >= 3) && (defined (_ARCH_PPC) || defined (__ppc))\n+ {\n+   /* The scheme described above is only useful for the actual ZCX case, and\n+      we don't want any reference to the crt provided symbols otherwise.  We\n+      may not link with any of the crt objects in the non-ZCX case, e.g. from\n+      documented procedures instructing the use of -nostdlib, and references\n+      to the ctors symbols here would just remain unsatisfied.\n+\n+      We have no way to avoid those references in the right conditions in this\n+      C module, because we have nothing like a IN_ZCX_RTS macro.  This aspect\n+      is then deferred to an Ada routine, which can do that based on a test\n+      against a constant System flag value.  */\n+\n+   extern void __gnat_vxw_setup_for_eh (void);\n+   __gnat_vxw_setup_for_eh ();\n+ }\n+#endif\n+}\n+\n+#else\n+\n+/* For all other versions of GNAT, the initialize routine and handler\n+   installation do nothing */\n+\n+/***************************************/\n+/* __gnat_initialize (Default Version) */\n+/***************************************/\n+\n+void\n+__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+#endif"}]}