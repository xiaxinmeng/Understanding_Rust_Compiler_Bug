{"sha": "deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViMDllZmYyZGVjZTRlZjgwMDVhNWI1YzhkMWU2MTUxNmIzN2JkMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2002-05-05T17:40:16Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2002-05-05T17:40:16Z"}, "message": "genautomata.c (form_the_same_automaton_unit_lists_from_regexp, [...]): New prototypes and functions.\n\n2002-05-05  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c (form_the_same_automaton_unit_lists_from_regexp,\n\tprocess_unit_to_form_the_same_automaton_unit_lists,\n\tform_the_same_automaton_unit_lists\n\tcheck_unit_distributions_to_automata): New prototypes and\n\tfunctions.\n\t(check_automata): Rename it into `check_automata_insn_issues'.\n\t(unit_decl): New fields `the_same_automaton_unit' and\n\t`the_same_automaton_message_reported_p'.\n\t(unit_decl_t): New typedef.\n\t(the_same_automaton_lists): New gloval variable.\n\t(unit_regexp, unit_set_el, units_array, units_cmp,\n\toutput_get_cpu_unit_code_func): Use the typedef.\n\t(evaluate_max_reserv_cycles): Increment\n\t`description->max_insn_reserv_cycles'.\n\t(initiate_states): Don't increment `max_cycles_num'.\n\t(transform_insn_regexps): Move code around transformation of\n\tregexps from `generate'.\n\t(generate): Remove call of `transform_insn_regexps'.\n\t(expand_automata): Call `transform_insn_regexps' and\n\t`check_unit_distributions_to_automata'.  Check errors before\n\t`generate'.\n\n\t* config/sparc/ultra3.md (us3_a0, us3_a1): Move the units into\n\tautomaton `ultrasparc3_1'.\n\nFrom-SVN: r53187", "tree": {"sha": "cb54881a8d4b9297d943f4c984deb4eb8a774797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb54881a8d4b9297d943f4c984deb4eb8a774797"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2443d4e110e88050c438b4db7cba7b47dfb90893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2443d4e110e88050c438b4db7cba7b47dfb90893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2443d4e110e88050c438b4db7cba7b47dfb90893"}], "stats": {"total": 339, "additions": 291, "deletions": 48}, "files": [{"sha": "e6f4b898630019bc4fb59a33a594a6bd4b0d7ffb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "patch": "@@ -1,3 +1,30 @@\n+2002-05-05  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (form_the_same_automaton_unit_lists_from_regexp,\n+\tprocess_unit_to_form_the_same_automaton_unit_lists,\n+\tform_the_same_automaton_unit_lists\n+\tcheck_unit_distributions_to_automata): New prototypes and\n+\tfunctions.\n+\t(check_automata): Rename it into `check_automata_insn_issues'.\n+\t(unit_decl): New fields `the_same_automaton_unit' and\n+\t`the_same_automaton_message_reported_p'.\n+\t(unit_decl_t): New typedef.\n+\t(the_same_automaton_lists): New gloval variable.\n+\t(unit_regexp, unit_set_el, units_array, units_cmp,\n+\toutput_get_cpu_unit_code_func): Use the typedef.\n+\t(evaluate_max_reserv_cycles): Increment\n+\t`description->max_insn_reserv_cycles'.\n+\t(initiate_states): Don't increment `max_cycles_num'.\n+\t(transform_insn_regexps): Move code around transformation of\n+\tregexps from `generate'.\n+\t(generate): Remove call of `transform_insn_regexps'.\n+\t(expand_automata): Call `transform_insn_regexps' and\n+\t`check_unit_distributions_to_automata'.  Check errors before\n+\t`generate'.\n+\n+\t* config/sparc/ultra3.md (us3_a0, us3_a1): Move the units into\n+\tautomaton `ultrasparc3_1'.\n+\t\n 2002-05-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-common.c (c_common_init): Set up CPP arithmetic."}, {"sha": "c835096391aaed48a9a5c164b1e29ad66d1793c4", "filename": "gcc/config/sparc/ultra3.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2Fconfig%2Fsparc%2Fultra3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2Fconfig%2Fsparc%2Fultra3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra3.md?ref=deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "patch": "@@ -26,8 +26,9 @@\n \n (define_automaton \"ultrasparc3_0,ultrasparc3_1\")\n \n-(define_cpu_unit \"us3_a0,us3_a1,us3_ms,us3_br,us3_fpm\" \"ultrasparc3_0\")\n-(define_cpu_unit \"us3_slot0,us3_slot1,us3_slot2,us3_slot3,us3_fpa\" \"ultrasparc3_1\")\n+(define_cpu_unit \"us3_ms,us3_br,us3_fpm\" \"ultrasparc3_0\")\n+(define_cpu_unit \"us3_a0,us3_a1,us3_slot0,\\\n+                  us3_slot1,us3_slot2,us3_slot3,us3_fpa\" \"ultrasparc3_1\")\n (define_cpu_unit \"us3_load_writeback\" \"ultrasparc3_1\")\n \n (define_reservation \"us3_slotany\" \"(us3_slot0 | us3_slot1 | us3_slot2 | us3_slot3)\")"}, {"sha": "3c7de3098148cec3338028b6c4acf59c3c18a53e", "filename": "gcc/genautomata.c", "status": "modified", "additions": 261, "deletions": 46, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb09eff2dece4ef8005a5b5c8d1e61516b37bd1/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=deb09eff2dece4ef8005a5b5c8d1e61516b37bd1", "patch": "@@ -195,6 +195,7 @@ struct automaton;\n struct state_ainsn_table;\n \n /* The following typedefs are for brevity.  */\n+typedef struct unit_decl *unit_decl_t;\n typedef struct decl *decl_t;\n typedef struct regexp *regexp_t;\n typedef struct unit_set_el *unit_set_el_t;\n@@ -355,6 +356,12 @@ static regexp_t regexp_transform_func\n static regexp_t transform_regexp            PARAMS ((regexp_t));\n static void transform_insn_regexps          PARAMS ((void));\n \n+static void process_unit_to_form_the_same_automaton_unit_lists\n+                                            PARAMS ((regexp_t, regexp_t, int));\n+static void form_the_same_automaton_unit_lists_from_regexp PARAMS ((regexp_t));\n+static void form_the_same_automaton_unit_lists PARAMS ((void));\n+static void check_unit_distributions_to_automata PARAMS ((void));\n+\n static int process_seq_for_forming_states   PARAMS ((regexp_t, automaton_t,\n \t\t\t\t\t\t     int));\n static void finish_forming_alt_state        PARAMS ((alt_state_t,\n@@ -507,7 +514,7 @@ static void make_default_insn_latency_attr     PARAMS ((void));\n static void make_bypass_attr                   PARAMS ((void));\n static const char *file_name_suffix            PARAMS ((const char *));\n static const char *base_file_name              PARAMS ((const char *));\n-static void check_automata\t               PARAMS ((void));\n+static void check_automata_insn_issues\t       PARAMS ((void));\n static void add_automaton_state                PARAMS ((state_t));\n static void form_important_insn_automata_lists PARAMS ((void));\n \n@@ -714,6 +721,15 @@ struct unit_decl\n   /* The following field value is nonzero if the unit is used in an\n      regexp.  */\n   char unit_is_used;\n+\n+  /* The following field value is used to form cyclic lists of units\n+     which should be in the same automaton because the unit is\n+     reserved not on all alternatives of a regexp on a cycle.  */\n+  unit_decl_t the_same_automaton_unit;\n+  /* The following field is TRUE if we already reported that the unit\n+     is not in the same automaton.  */\n+  int the_same_automaton_message_reported_p;\n+\n   /* The following field value is order number (0, 1, ...) of given\n      unit.  */\n   int unit_num;\n@@ -847,7 +863,7 @@ struct insn_reserv_decl\n      enters.  */\n   int state_alts;\n   /* The following member value is the list to automata which can be\n-     changed by the insn issue. */\n+     changed by the insn issue.  */\n   automata_list_el_t important_automata_list;\n   /* The following member is used to process insn once for output.  */\n   int processed_p;\n@@ -888,7 +904,7 @@ enum regexp_mode\n struct unit_regexp\n {\n   char *name;\n-  struct unit_decl *unit_decl;\n+  unit_decl_t unit_decl;\n };\n \n /* Define_reservation in a reservation.  */\n@@ -993,7 +1009,7 @@ struct description\n    presence_list, absence_list.  */\n struct unit_set_el\n {\n-  struct unit_decl *unit_decl;\n+  unit_decl_t unit_decl;\n   unit_set_el_t next_unit_set_el;\n };\n \n@@ -1063,7 +1079,7 @@ struct state\n };\n \n /* The following macro is an initial value of member\n-   `longest_path_length' of a state. */\n+   `longest_path_length' of a state.  */\n #define UNDEFINED_LONGEST_PATH_LENGTH -1\n \n /* Automaton arc.  */\n@@ -2988,6 +3004,7 @@ evaluate_max_reserv_cycles ()\n \t  description->max_insn_reserv_cycles = max_insn_cycles_num;\n       }\n     }\n+  description->max_insn_reserv_cycles++;\n }\n \n /* The following function calls functions for checking all\n@@ -3317,7 +3334,7 @@ finish_alt_states ()\n \n /* This page contains abstract data `state'.  */\n \n-/* Maximal length of reservations in cycles (> 1).  */\n+/* Maximal length of reservations in cycles (>= 1).  */\n static int max_cycles_num;\n \n /* Number of set elements (see type set_el_t) needed for\n@@ -3336,7 +3353,7 @@ static int els_in_reservs;\n static vla_ptr_t units_container;\n \n /* The start address of the array.  */\n-static struct unit_decl **units_array;\n+static unit_decl_t *units_array;\n \n /* Empty reservation of maximal length.  */\n static reserv_sets_t empty_reserv;\n@@ -3884,8 +3901,6 @@ initiate_states ()\n \tunits_array [decl->decl.unit.unit_num] = &decl->decl.unit;\n     }\n   max_cycles_num = description->max_insn_reserv_cycles;\n-  if (max_cycles_num == 0)\n-    max_cycles_num++;\n   els_in_cycle_reserv\n     = ((description->units_num + sizeof (set_el_t) * CHAR_BIT - 1)\n        / (sizeof (set_el_t) * CHAR_BIT));\n@@ -4781,6 +4796,10 @@ transform_insn_regexps ()\n   decl_t decl;\n   int i;\n \n+  transform_time = create_ticker ();\n+  add_advance_cycle_insn_decl ();\n+  fprintf (stderr, \"Reservation transformation...\");\n+  fflush (stderr);\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n@@ -4789,6 +4808,207 @@ transform_insn_regexps ()\n \t  = transform_regexp (copy_insn_regexp\n \t\t\t      (decl->decl.insn_reserv.regexp));\n     }\n+  fprintf (stderr, \"done\\n\");\n+  ticker_off (&transform_time);\n+  fflush (stderr);\n+}\n+\n+\f\n+\n+/* The following variable is an array indexed by cycle.  Each element\n+   contains cyclic list of units which should be in the same cycle.  */\n+static unit_decl_t *the_same_automaton_lists;\n+\n+/* The function processes all alternative reservations on CYCLE in\n+   given REGEXP to check the UNIT is not reserved on the all\n+   alternatives.  If it is true, the unit should be in the same\n+   automaton with other analogous units reserved on CYCLE in given\n+   REGEXP.  */\n+static void\n+process_unit_to_form_the_same_automaton_unit_lists (unit, regexp, cycle)\n+     regexp_t unit;\n+     regexp_t regexp;\n+     int cycle;\n+{\n+  int i, k;\n+  regexp_t seq, allof;\n+  unit_decl_t unit_decl, last;\n+\n+  if (regexp == NULL || regexp->mode != rm_oneof)\n+    abort ();\n+  unit_decl = unit->regexp.unit.unit_decl;\n+  for (i = regexp->regexp.oneof.regexps_num - 1; i >= 0; i--)\n+    {\n+      seq = regexp->regexp.oneof.regexps [i];\n+      if (seq->mode == rm_sequence)\n+\t{\n+\t  if (cycle >= seq->regexp.sequence.regexps_num)\n+\t    break;\n+\t  allof = seq->regexp.sequence.regexps [cycle];\n+\t  if (allof->mode == rm_allof)\n+\t    {\n+\t      for (k = 0; k < allof->regexp.allof.regexps_num; k++)\n+\t\tif (allof->regexp.allof.regexps [k]->mode == rm_unit\n+\t\t    && (allof->regexp.allof.regexps [k]->regexp.unit.unit_decl\n+\t\t\t== unit_decl))\n+\t\t  break;\n+\t      if (k >= allof->regexp.allof.regexps_num)\n+\t\tbreak;\n+\t    }\n+\t  else if (allof->mode == rm_unit\n+\t\t   && allof->regexp.unit.unit_decl != unit_decl)\n+\t    break;\n+\t}\n+      else if (cycle != 0)\n+\tbreak;\n+      else if (seq->mode == rm_allof)\n+\t{\n+\t  for (k = 0; k < seq->regexp.allof.regexps_num; k++)\n+\t    if (seq->regexp.allof.regexps [k]->mode == rm_unit\n+\t\t&& (seq->regexp.allof.regexps [k]->regexp.unit.unit_decl\n+\t\t    == unit_decl))\n+\t      break;\n+\t  if (k >= seq->regexp.allof.regexps_num)\n+\t    break;\n+\t}\n+      else if (seq->mode == rm_unit && seq->regexp.unit.unit_decl != unit_decl)\n+\tbreak;\n+    }\n+  if (i >= 0)\n+    {\n+      if (the_same_automaton_lists [cycle] == NULL)\n+\tthe_same_automaton_lists [cycle] = unit_decl;\n+      else\n+\t{\n+\t  for (last = the_same_automaton_lists [cycle];;)\n+\t    {\n+\t      if (last == unit_decl)\n+\t\treturn;\n+\t      if (last->the_same_automaton_unit\n+\t\t  == the_same_automaton_lists [cycle])\n+\t\tbreak;\n+\t      last = last->the_same_automaton_unit;\n+\t    }\n+\t  last->the_same_automaton_unit = unit_decl->the_same_automaton_unit;\n+\t  unit_decl->the_same_automaton_unit\n+\t    = the_same_automaton_lists [cycle];\n+\t}\n+    }\n+}\n+\n+/* The function processes given REGEXP to find units which should be\n+   in the same automaton.  */\n+static void\n+form_the_same_automaton_unit_lists_from_regexp (regexp)\n+     regexp_t regexp;\n+{\n+  int i, j, k;\n+  regexp_t seq, allof, unit;\n+\n+  if (regexp == NULL || regexp->mode != rm_oneof)\n+    return;\n+  for (i = 0; i < description->max_insn_reserv_cycles; i++)\n+    the_same_automaton_lists [i] = NULL;\n+  for (i = regexp->regexp.oneof.regexps_num - 1; i >= 0; i--)\n+    {\n+      seq = regexp->regexp.oneof.regexps [i];\n+      if (seq->mode == rm_sequence)\n+\tfor (j = 0; j < seq->regexp.sequence.regexps_num; j++)\n+\t  {\n+\t    allof = seq->regexp.sequence.regexps [j];\n+\t    if (allof->mode == rm_allof)\n+\t      for (k = 0; k < allof->regexp.allof.regexps_num; k++)\n+\t\t{\n+\t\t  unit = allof->regexp.allof.regexps [k];\n+\t\t  if (unit->mode == rm_unit)\n+\t\t    process_unit_to_form_the_same_automaton_unit_lists\n+\t\t      (unit, regexp, j);\n+\t\t  else if (allof->mode != rm_nothing)\n+\t\t    abort ();\n+\t\t}\n+\t    else if (allof->mode == rm_unit)\n+\t      process_unit_to_form_the_same_automaton_unit_lists\n+\t\t(allof, regexp, j);\n+\t    else if (allof->mode != rm_nothing)\n+\t      abort ();\n+\t  }\n+      else if (seq->mode == rm_allof)\n+\tfor (k = 0; k < seq->regexp.allof.regexps_num; k++)\n+\t  {\n+\t    unit = seq->regexp.allof.regexps [k];\n+\t    if (unit->mode == rm_unit)\n+\t      process_unit_to_form_the_same_automaton_unit_lists\n+\t\t(unit, regexp, 0);\n+\t    else if (unit->mode != rm_nothing)\n+\t      abort ();\n+\t  }\n+      else if (seq->mode == rm_unit)\n+\tprocess_unit_to_form_the_same_automaton_unit_lists (seq, regexp, 0);\n+      else if (seq->mode != rm_nothing)\n+\tabort ();\n+    }\n+}\n+\n+/* The function initializes data to search for units which should be\n+   in the same automaton and call function\n+   `form_the_same_automaton_unit_lists_from_regexp' for each insn\n+   reservation regexp.  */\n+static void\n+form_the_same_automaton_unit_lists ()\n+{\n+  decl_t decl;\n+  int i;\n+\n+  the_same_automaton_lists\n+    = (unit_decl_t *) xmalloc (description->max_insn_reserv_cycles\n+\t\t\t       * sizeof (unit_decl_t));\n+  for (i = 0; i < description->decls_num; i++)\n+    {\n+      decl = description->decls [i];\n+      if (decl->mode == dm_unit)\n+\t{\n+\t  decl->decl.unit.the_same_automaton_message_reported_p = FALSE;\n+\t  decl->decl.unit.the_same_automaton_unit = &decl->decl.unit;\n+\t}\n+    }\n+  for (i = 0; i < description->decls_num; i++)\n+    {\n+      decl = description->decls [i];\n+      if (decl->mode == dm_insn_reserv)\n+\tform_the_same_automaton_unit_lists_from_regexp\n+\t  (decl->decl.insn_reserv.transformed_regexp);\n+    }\n+  free (the_same_automaton_lists);\n+}\n+\n+/* The function finds units which should be in the same automaton and,\n+   if they are not, reports about it.  */\n+static void\n+check_unit_distributions_to_automata ()\n+{\n+  decl_t decl;\n+  unit_decl_t start_unit_decl, unit_decl;\n+  int i;\n+\n+  form_the_same_automaton_unit_lists ();\n+  for (i = 0; i < description->decls_num; i++)\n+    {\n+      decl = description->decls [i];\n+      if (decl->mode == dm_unit)\n+\t{\n+\t  start_unit_decl = &decl->decl.unit;\n+\t  if (!start_unit_decl->the_same_automaton_message_reported_p)\n+\t    for (unit_decl = start_unit_decl->the_same_automaton_unit;\n+\t\t unit_decl != start_unit_decl;\n+\t\t unit_decl = unit_decl->the_same_automaton_unit)\n+\t      if (start_unit_decl->automaton_decl != unit_decl->automaton_decl)\n+\t\t{\n+\t\t  error (\"Units `%s' and `%s' should be in the same automaton\",\n+\t\t\t start_unit_decl->name, unit_decl->name);\n+\t\t  unit_decl->the_same_automaton_message_reported_p = TRUE;\n+\t\t}\n+\t}\n+    }\n }\n \n \f\n@@ -5400,7 +5620,7 @@ init_equiv_class (states, states_num)\n    removing nonequivalent states and placing them in\n    *NEXT_ITERATION_CLASSES, increments *NEW_EQUIV_CLASS_NUM_PTR ans\n    assigns it to the state equivalence number.  If the class has been\n-   partitioned, the function returns nonzero value. */\n+   partitioned, the function returns nonzero value.  */\n static int\n partition_equiv_class (equiv_class_ptr, odd_iteration_flag,\n \t\t       next_iteration_classes, new_equiv_class_num_ptr)\n@@ -6286,7 +6506,7 @@ longest_path_length (state)\n \n   result = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n-    /* Ignore cycles containing one state and `cycle advance' arcs. */\n+    /* Ignore cycles containing one state and `cycle advance' arcs.  */\n     if (arc->to_state != state\n \t&& (arc->insn->insn_reserv_decl\n \t    != &advance_cycle_insn_decl->decl.insn_reserv))\n@@ -6305,7 +6525,7 @@ longest_path_length (state)\n static int max_dfa_issue_rate;\n \n /* The following function processes the longest path length staring\n-   from STATE to find MAX_DFA_ISSUE_RATE. */\n+   from STATE to find MAX_DFA_ISSUE_RATE.  */\n \n static void\n process_state_longest_path_length (state)\n@@ -6592,7 +6812,7 @@ output_reserved_units_table_name (f, automaton)\n /* Name of cache of insn dfa codes.  */\n #define DFA_INSN_CODES_VARIABLE_NAME \"dfa_insn_codes\"\n \n-/* Name of length of cache of insn dfa codes. */\n+/* Name of length of cache of insn dfa codes.  */\n #define DFA_INSN_CODES_LENGTH_VARIABLE_NAME \"dfa_insn_codes_length\"\n \n /* Names of the PHR interface functions: */\n@@ -7128,7 +7348,7 @@ min_issue_delay_pass_states (state, ainsn)\n   if (state->state_pass_num == curr_state_pass_num\n       || state->min_insn_issue_delay != -1)\n     /* We've entered into a loop or already have the correct value for\n-       given state and ainsn. */\n+       given state and ainsn.  */\n     return state->min_insn_issue_delay;\n   state->state_pass_num = curr_state_pass_num;\n   min_insn_issue_delay = -1;\n@@ -8072,8 +8292,8 @@ static int\n units_cmp (unit1, unit2)\n      const void *unit1, *unit2;\n {\n-  const struct unit_decl *u1 = *(struct unit_decl **) unit1;\n-  const struct unit_decl *u2 = *(struct unit_decl **) unit2;\n+  const unit_decl_t u1 = *(unit_decl_t *) unit1;\n+  const unit_decl_t u2 = *(unit_decl_t *) unit2;\n \n   return strcmp (u1->name, u2->name);\n }\n@@ -8102,7 +8322,7 @@ static void\n output_get_cpu_unit_code_func ()\n {\n   int i;\n-  struct unit_decl **units;\n+  unit_decl_t *units;\n   \n   fprintf (output_file, \"int\\n%s (%s)\\n\\tconst char *%s;\\n\",\n \t   GET_CPU_UNIT_CODE_FUNC_NAME, CPU_UNIT_NAME_PARAMETER_NAME,\n@@ -8113,12 +8333,10 @@ output_get_cpu_unit_code_func ()\n \t   LOW_VARIABLE_NAME, MIDDLE_VARIABLE_NAME, HIGH_VARIABLE_NAME);\n   fprintf (output_file, \"  static struct %s %s [] =\\n    {\\n\",\n \t   NAME_CODE_STRUCT_NAME, NAME_CODE_TABLE_NAME);\n-  units = (struct unit_decl **) xmalloc (sizeof (struct unit_decl *)\n-\t\t\t\t\t * description->units_num);\n-  memcpy (units, units_array,\n-\t  sizeof (struct unit_decl *) * description->units_num);\n-  qsort (units, description->units_num,\n-\t sizeof (struct unit_decl *), units_cmp);\n+  units = (unit_decl_t *) xmalloc (sizeof (unit_decl_t)\n+\t\t\t\t   * description->units_num);\n+  memcpy (units, units_array, sizeof (unit_decl_t) * description->units_num);\n+  qsort (units, description->units_num, sizeof (unit_decl_t), units_cmp);\n   for (i = 0; i < description->units_num; i++)\n     if (units [i]->query_p)\n       fprintf (output_file, \"      {\\\"%s\\\", %d},\\n\",\n@@ -8636,14 +8854,6 @@ generate ()\n   initiate_excl_sets ();\n   initiate_presence_absence_sets ();\n   automaton_generation_time = create_ticker ();\n-  transform_time = create_ticker ();\n-  add_advance_cycle_insn_decl ();\n-  fprintf (stderr, \"Reservation transformation...\");\n-  fflush (stderr);\n-  transform_insn_regexps ();\n-  fprintf (stderr, \"done\\n\");\n-  ticker_off (&transform_time);\n-  fflush (stderr);\n   create_automata ();\n   ticker_off (&automaton_generation_time);\n }\n@@ -8898,7 +9108,7 @@ initiate_automaton_gen (argc, argv)\n /* The following function checks existence at least one arc marked by\n    each insn.  */\n static void\n-check_automata ()\n+check_automata_insn_issues ()\n {\n   automaton_t automaton;\n   ainsn_t ainsn, reserv_ainsn;\n@@ -8967,7 +9177,7 @@ form_important_insn_automata_lists ()\n \n   VLA_PTR_CREATE (automaton_states, 1500,\n \t\t  \"automaton states for forming important insn automata sets\");\n-  /* Mark important ainsns. */\n+  /* Mark important ainsns.  */\n   for (automaton = description->first_automaton;\n        automaton != NULL;\n        automaton = automaton->next_automaton)\n@@ -8993,7 +9203,7 @@ form_important_insn_automata_lists ()\n \t}\n     }\n   VLA_PTR_DELETE (automaton_states);\n-  /* Create automata sets for the insns. */\n+  /* Create automata sets for the insns.  */\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n@@ -9047,21 +9257,26 @@ expand_automata ()\n   fprintf (stderr, \"done\\n\");\n   ticker_off (&check_time);\n   generation_time = create_ticker ();\n+  if (!have_error)\n+    {\n+      transform_insn_regexps ();\n+      check_unit_distributions_to_automata ();\n+    }\n   if (!have_error)\n     {\n       generate ();\n-      check_automata ();\n-      if (!have_error)\n-\t{\n-\t  form_important_insn_automata_lists ();\n-\t  fprintf (stderr, \"Generation of attributes...\");\n-\t  fflush (stderr);\n-\t  make_internal_dfa_insn_code_attr ();\n-\t  make_insn_alts_attr ();\n-\t  make_default_insn_latency_attr ();\n-\t  make_bypass_attr ();\n-\t  fprintf (stderr, \"done\\n\");\n-\t}\n+      check_automata_insn_issues ();\n+    }\n+  if (!have_error)\n+    {\n+      form_important_insn_automata_lists ();\n+      fprintf (stderr, \"Generation of attributes...\");\n+      fflush (stderr);\n+      make_internal_dfa_insn_code_attr ();\n+      make_insn_alts_attr ();\n+      make_default_insn_latency_attr ();\n+      make_bypass_attr ();\n+      fprintf (stderr, \"done\\n\");\n     }\n   ticker_off (&generation_time);\n   ticker_off (&all_time);"}]}