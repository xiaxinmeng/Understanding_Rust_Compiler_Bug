{"sha": "bfef8d0d62ede027e717a7ab1900bee71b54e708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlZjhkMGQ2MmVkZTAyN2U3MTdhN2FiMTkwMGJlZTcxYjU0ZTcwOA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-10-31T17:50:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:50:11Z"}, "message": "a-tags.ads, a-tags.adb:\n\n2006-10-31  Javier Miranda  <miranda@adacore.com>\n\n\t* a-tags.ads, a-tags.adb: \n\t(Predefined_DT): New function that improves readability of the code.\n\t(Get_Predefined_Prim_Op_Address, Set_Predefined_Prim_Op_Address,\n\tInherit_DT): Use the new function Predefined_DT to improve code\n\treadability.\n\t(Register_Interface_Tag): Update assertion.\n\t(Set_Interface_Table): Update assertion.\n\t(Interface_Ancestor_Tags): New subprogram required to implement AI-405:\n\tdetermining progenitor interfaces in Tags.\n\t(Inherit_CPP_DT): New subprogram.\n\n        * exp_disp.adb (Expand_Interface_Thunk): Suppress checks during the\n\tanalysis of the thunk code.\n        (Expand_Interface_Conversion): Handle run-time conversion of\n        access to class wide types.\n\t(Expand_Dispatching_Call): When generating the profile for the\n\tsubprogram itype for a dispatching operation, properly terminate the\n\tformal parameters chaind list (set the Next_Entity of the last formal\n\tto Empty).\n\t(Collect_All_Interfaces): Removed. This routine has been moved to\n\tsem_util and renamed as Collect_All_Abstract_Interfaces.\n\t(Set_All_DT_Position): Hidden entities associated with abstract\n\tinterface primitives are not taken into account in the check for\n\t3.9.3(10); this check is done with the aliased entity.\n\t(Make_DT, Set_All_DT_Position): Enable full ABI compatibility for\n\tinterfacing with CPP by default.\n\t(Expand_Interface_Conversion): Add missing support for static conversion\n\tfrom an interface to a tagged type.\n\t(Collect_All_Interfaces): Add new out formal containing the list of\n\tabstract interface types to cleanup the subprogram Make_DT.\n\t(Make_DT): Update the code to generate the table of interfaces in case\n\tof abstract interface types.\n\t(Is_Predefined_Dispatching_Alias): New function that returns true if\n\ta primitive is not a predefined dispatching primitive but it is an\n\talias of a predefined dispatching primitive.\n\t(Make_DT): If the ancestor of the type is a CPP_Class and we are\n\tcompiling under full ABI compatibility mode we avoid the generation of\n\tcalls to run-time services that fill the dispatch tables because under\n\tthis mode we currently inherit the dispatch tables in the IP subprogram.\n\t(Write_DT): Emit an \"is null\" indication for a null procedure primitive.\n\t(Expand_Interface_Conversion): Use an address as the type of the formal\n\tof the internally built function that handles the case in which the\n\ttarget type is an access type.\n\nFrom-SVN: r118244", "tree": {"sha": "a8db6c2b8b000b3fdd656234dd9be6d790c13218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8db6c2b8b000b3fdd656234dd9be6d790c13218"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfef8d0d62ede027e717a7ab1900bee71b54e708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfef8d0d62ede027e717a7ab1900bee71b54e708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfef8d0d62ede027e717a7ab1900bee71b54e708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfef8d0d62ede027e717a7ab1900bee71b54e708/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cb8344bd34b50012b5c43c7d34d01472f41e026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb8344bd34b50012b5c43c7d34d01472f41e026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb8344bd34b50012b5c43c7d34d01472f41e026"}], "stats": {"total": 1368, "additions": 745, "deletions": 623}, "files": [{"sha": "a0697e818b942f9081a5030889d76731f92e691c", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 120, "deletions": 34, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=bfef8d0d62ede027e717a7ab1900bee71b54e708", "patch": "@@ -411,6 +411,11 @@ package body Ada.Tags is\n    --  Length of string represented by the given pointer (treating the string\n    --  as a C-style string, which is Nul terminated).\n \n+   function Predefined_DT (T : Tag) return Tag;\n+   pragma Inline_Always (Predefined_DT);\n+   --  Displace the Tag to reference the dispatch table containing the\n+   --  predefined primitives.\n+\n    function Typeinfo_Ptr (T : Tag) return System.Address;\n    --  Returns the current value of the typeinfo_ptr component available in\n    --  the prologue of the dispatch table.\n@@ -596,7 +601,7 @@ package body Ada.Tags is\n    --  level of inheritance of both types, this can be computed in constant\n    --  time by the formula:\n \n-   --   Obj'tag.TSD.Ancestor_Tags (Obj'tag.TSD.Idepth - Typ'tag.TSD.Idepth)\n+   --   TSD (Obj'tag).Tags_Table (TSD (Obj'tag).Idepth - TSD (Typ'tag).Idepth)\n    --     = Typ'tag\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n@@ -668,6 +673,13 @@ package body Ada.Tags is\n          end loop;\n       end if;\n \n+      --  Check if T is an immediate ancestor. This is required to handle\n+      --  conversion of class-wide interfaces to tagged types.\n+\n+      if CW_Membership (Obj_DT, T) then\n+         return Obj_Base;\n+      end if;\n+\n       --  If the object does not implement the interface we must raise CE\n \n       raise Constraint_Error;\n@@ -842,11 +854,10 @@ package body Ada.Tags is\n      (T        : Tag;\n       Position : Positive) return System.Address\n    is\n-      Prim_Ops_DT : constant Tag := To_Tag (To_Address (T) - DT_Prologue_Size);\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n       pragma Assert (Position <= Default_Prim_Op_Count);\n-      return Prim_Ops_DT.Prims_Ptr (Position);\n+      return Predefined_DT (T).Prims_Ptr (Position);\n    end Get_Predefined_Prim_Op_Address;\n \n    -------------------------\n@@ -923,27 +934,59 @@ package body Ada.Tags is\n       return To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all;\n    end Get_Tagged_Kind;\n \n+   --------------------\n+   -- Inherit_CPP_DT --\n+   --------------------\n+\n+   procedure Inherit_CPP_DT\n+     (Old_T       : Tag;\n+      New_T       : Tag;\n+      Entry_Count : Natural)\n+   is\n+   begin\n+      New_T.Prims_Ptr (1 .. Entry_Count) := Old_T.Prims_Ptr (1 .. Entry_Count);\n+   end Inherit_CPP_DT;\n+\n    ----------------\n    -- Inherit_DT --\n    ----------------\n \n    procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural) is\n-      Old_T_Prim_Ops : Tag;\n-      New_T_Prim_Ops : Tag;\n-      Size           : Positive;\n+      subtype All_Predefined_Prims is\n+        Positive range 1 .. Default_Prim_Op_Count;\n+\n    begin\n       pragma Assert (Check_Signature (Old_T, Must_Be_Primary_Or_Secondary_DT));\n       pragma Assert (Check_Signature (New_T, Must_Be_Primary_Or_Secondary_DT));\n       pragma Assert (Check_Size (Old_T, New_T, Entry_Count));\n \n       if Old_T /= null then\n+\n+         --  Inherit the primitives of the parent\n+\n          New_T.Prims_Ptr (1 .. Entry_Count) :=\n            Old_T.Prims_Ptr (1 .. Entry_Count);\n-         Old_T_Prim_Ops := To_Tag (To_Address (Old_T) - DT_Prologue_Size);\n-         New_T_Prim_Ops := To_Tag (To_Address (New_T) - DT_Prologue_Size);\n-         Size := Default_Prim_Op_Count;\n-         New_T_Prim_Ops.Prims_Ptr (1 .. Size) :=\n-           Old_T_Prim_Ops.Prims_Ptr (1 .. Size);\n+\n+         --  Inherit the predefined primitives of the parent\n+\n+         --  NOTE: In the following assignment we have to unactivate a warning\n+         --  generated by the compiler because of the following declaration of\n+         --  the Dispatch_Table:\n+\n+         --      Prims_Ptr : Address_Array (1 .. 1);\n+\n+         --  This is a dummy declaration that is expanded by the frontend to\n+         --  the correct size of the dispatch table corresponding with each\n+         --  tagged type. As a consequence, if we try to use a constant to\n+         --  copy the predefined elements (ie.  Prims_Ptr (1 .. 15) := ...)\n+         --  the compiler generates a warning indicating that Constraint_Error\n+         --  will be raised at run-time (which is not true in this specific\n+         --  case).\n+\n+         pragma Warnings (Off);\n+         Predefined_DT (New_T).Prims_Ptr (All_Predefined_Prims) :=\n+           Predefined_DT (Old_T).Prims_Ptr (All_Predefined_Prims);\n+         pragma Warnings (On);\n       end if;\n    end Inherit_DT;\n \n@@ -994,6 +1037,35 @@ package body Ada.Tags is\n       New_TSD_Ptr.Tags_Table (0) := New_Tag;\n    end Inherit_TSD;\n \n+   -----------------------------\n+   -- Interface_Ancestor_Tags --\n+   -----------------------------\n+\n+   function Interface_Ancestor_Tags (T : Tag) return Tag_Array is\n+      Iface_Table : Interface_Data_Ptr;\n+\n+   begin\n+      Iface_Table := To_Interface_Data_Ptr (TSD (T).Ifaces_Table_Ptr);\n+\n+      if Iface_Table = null then\n+         declare\n+            Table : Tag_Array (1 .. 0);\n+         begin\n+            return Table;\n+         end;\n+      else\n+         declare\n+            Table : Tag_Array (1 .. Iface_Table.Nb_Ifaces);\n+         begin\n+            for J in 1 .. Iface_Table.Nb_Ifaces loop\n+               Table (J) := Iface_Table.Table (J).Iface_Tag;\n+            end loop;\n+\n+            return Table;\n+         end;\n+      end if;\n+   end Interface_Ancestor_Tags;\n+\n    ------------------\n    -- Internal_Tag --\n    ------------------\n@@ -1107,21 +1179,24 @@ package body Ada.Tags is\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count\n    is\n+      Parent_Slot : constant Positive := 1;\n+      --  The tag of the parent is always in the first slot of the table of\n+      --  ancestor tags.\n+\n+      Size_Slot : constant Positive := 1;\n+      --  The pointer to the _size primitive is always in the first slot of\n+      --  the dispatch table.\n+\n       Parent_Tag : Tag;\n       --  The tag of the parent type through the dispatch table\n \n-      Prim_Ops_DT : Tag;\n-      --  The table of primitive operations of the parent\n-\n       F : Acc_Size;\n-      --  Access to the _size primitive of the parent. We assume that it is\n-      --  always in the first slot of the dispatch table.\n+      --  Access to the _size primitive of the parent\n \n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      Parent_Tag  := TSD (T).Tags_Table (1);\n-      Prim_Ops_DT := To_Tag (To_Address (Parent_Tag) - DT_Prologue_Size);\n-      F           := To_Acc_Size (Prim_Ops_DT.Prims_Ptr (1));\n+      Parent_Tag := TSD (T).Tags_Table (Parent_Slot);\n+      F := To_Acc_Size (Predefined_DT (Parent_Tag).Prims_Ptr (Size_Slot));\n \n       --  Here we compute the size of the _parent field of the object\n \n@@ -1152,6 +1227,15 @@ package body Ada.Tags is\n       end if;\n    end Parent_Tag;\n \n+   -------------------\n+   -- Predefined_DT --\n+   -------------------\n+\n+   function Predefined_DT (T : Tag) return Tag is\n+   begin\n+      return To_Tag (To_Address (T) - DT_Prologue_Size);\n+   end Predefined_DT;\n+\n    ----------------------------\n    -- Register_Interface_Tag --\n    ----------------------------\n@@ -1165,14 +1249,13 @@ package body Ada.Tags is\n       Iface_Table : Interface_Data_Ptr;\n \n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       pragma Assert (Check_Signature (Interface_T, Must_Be_Interface));\n \n       New_T_TSD   := TSD (T);\n       Iface_Table := To_Interface_Data_Ptr (New_T_TSD.Ifaces_Table_Ptr);\n \n       pragma Assert (Position <= Iface_Table.Nb_Ifaces);\n-\n       Iface_Table.Table (Position).Iface_Tag := Interface_T;\n    end Register_Interface_Tag;\n \n@@ -1237,7 +1320,7 @@ package body Ada.Tags is\n \n    procedure Set_Interface_Table (T : Tag; Value : System.Address) is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       TSD (T).Ifaces_Table_Ptr := Value;\n    end Set_Interface_Table;\n \n@@ -1308,18 +1391,22 @@ package body Ada.Tags is\n       pragma Assert\n         (Check_Signature (Prim_DT, Must_Be_Primary_DT));\n \n-      Sec_Base := This + Offset_Value;\n-      Sec_DT   := To_Tag_Ptr (Sec_Base).all;\n-      Offset_To_Top :=\n-        To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n+      --  Save the offset to top field in the secondary dispatch table.\n \n-      pragma Assert\n-        (Check_Signature (Sec_DT, Must_Be_Secondary_DT));\n+      if Offset_Value /= 0 then\n+         Sec_Base := This + Offset_Value;\n+         Sec_DT   := To_Tag_Ptr (Sec_Base).all;\n+         Offset_To_Top :=\n+           To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n \n-      if Is_Static then\n-         Offset_To_Top.all := Offset_Value;\n-      else\n-         Offset_To_Top.all := SSE.Storage_Offset'Last;\n+         pragma Assert\n+           (Check_Signature (Sec_DT, Must_Be_Secondary_DT));\n+\n+         if Is_Static then\n+            Offset_To_Top.all := Offset_Value;\n+         else\n+            Offset_To_Top.all := SSE.Storage_Offset'Last;\n+         end if;\n       end if;\n \n       --  Save Offset_Value in the table of interfaces of the primary DT. This\n@@ -1373,11 +1460,10 @@ package body Ada.Tags is\n       Position : Positive;\n       Value    : System.Address)\n    is\n-      Prim_Ops_DT : constant Tag := To_Tag (To_Address (T) - DT_Prologue_Size);\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n       pragma Assert (Position >= 1 and then Position <= Default_Prim_Op_Count);\n-      Prim_Ops_DT.Prims_Ptr (Position) := Value;\n+      Predefined_DT (T).Prims_Ptr (Position) := Value;\n    end Set_Predefined_Prim_Op_Address;\n \n    -------------------------"}, {"sha": "24fedab7ff8b64cfb057ae1b9532459e39ff88e9", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=bfef8d0d62ede027e717a7ab1900bee71b54e708", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,11 +44,18 @@ package Ada.Tags is\n    --  In accordance with Ada 2005 AI-362\n \n    type Tag is private;\n+   pragma Preelaborable_Initialization (Tag);\n \n    No_Tag : constant Tag;\n \n    function Expanded_Name (T : Tag) return String;\n \n+   function Wide_Expanded_Name (T : Tag) return Wide_String;\n+   pragma Ada_05 (Wide_Expanded_Name);\n+\n+   function Wide_Wide_Expanded_Name (T : Tag) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Expanded_Name);\n+\n    function External_Tag (T : Tag) return String;\n \n    function Internal_Tag (External : String) return Tag;\n@@ -66,13 +73,12 @@ package Ada.Tags is\n    function Parent_Tag (T : Tag) return Tag;\n    pragma Ada_05 (Parent_Tag);\n \n-   Tag_Error : exception;\n+   type Tag_Array is array (Positive range <>) of Tag;\n \n-   function Wide_Expanded_Name (T : Tag) return Wide_String;\n-   pragma Ada_05 (Wide_Expanded_Name);\n+   function Interface_Ancestor_Tags (T : Tag) return Tag_Array;\n+   pragma Ada_05 (Interface_Ancestor_Tags);\n \n-   function Wide_Wide_Expanded_Name (T : Tag) return Wide_Wide_String;\n-   pragma Ada_05 (Wide_Wide_Expanded_Name);\n+   Tag_Error : exception;\n \n private\n    --  The following subprogram specifications are placed here instead of\n@@ -192,7 +198,7 @@ private\n    --      type I is interface;\n    --      type T is tagged ...\n    --\n-   --      function Test (O : in I'Class) is\n+   --      function Test (O : I'Class) is\n    --      begin\n    --         return O in T'Class.\n    --      end Test;\n@@ -257,6 +263,11 @@ private\n    --  return the tagged kind of a type in the context of concurrency and\n    --  limitedness.\n \n+   procedure Inherit_CPP_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n+   --  Entry point used to initialize the DT of a type knowing the tag\n+   --  of the direct CPP ancestor and the number of primitive ops that\n+   --  are inherited (Entry_Count).\n+\n    procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n    --  Entry point used to initialize the DT of a type knowing the tag\n    --  of the direct ancestor and the number of primitive ops that are"}, {"sha": "4c6fe26de40f49b6b06269cb17ada2ee6afc7b78", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 607, "deletions": 582, "changes": 1189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfef8d0d62ede027e717a7ab1900bee71b54e708/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=bfef8d0d62ede027e717a7ab1900bee71b54e708", "patch": "@@ -34,6 +34,7 @@ with Exp_Ch7;  use Exp_Ch7;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n+with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -414,15 +415,14 @@ package body Exp_Disp is\n        TSD_Entry_Size                 => 0,\n        TSD_Prologue_Size              => 0);\n \n-   procedure Collect_All_Interfaces (T : Entity_Id);\n-   --  Ada 2005 (AI-251): Collect the whole list of interfaces that are\n-   --  directly or indirectly implemented by T. Used to compute the size\n-   --  of the table of interfaces.\n-\n    function Default_Prim_Op_Position (E : Entity_Id) return Uint;\n    --  Ada 2005 (AI-251): Returns the fixed position in the dispatch table\n    --  of the default primitive operations.\n \n+   function Is_Predefined_Dispatching_Alias (Prim : Entity_Id) return Boolean;\n+   --  Returns true if Prim is not a predefined dispatching primitive but it is\n+   --  an alias of a predefined dispatching primitive (ie. through a renaming)\n+\n    function Original_View_In_Visible_Part (Typ : Entity_Id) return Boolean;\n    --  Check if the type has a private view or if the public view appears\n    --  in the visible part of a package spec.\n@@ -438,95 +438,6 @@ package body Exp_Disp is\n    --  Ada 2005 (AI-345): Determine the tagged kind of T and return a reference\n    --  to an RE_Tagged_Kind enumeration value.\n \n-   ----------------------------\n-   -- Collect_All_Interfaces --\n-   ----------------------------\n-\n-   procedure Collect_All_Interfaces (T : Entity_Id) is\n-\n-      procedure Add_Interface (Iface : Entity_Id);\n-      --  Add the interface it if is not already in the list\n-\n-      procedure Collect (Typ : Entity_Id);\n-      --  Subsidiary subprogram used to traverse the whole list\n-      --  of directly and indirectly implemented interfaces\n-\n-      -------------------\n-      -- Add_Interface --\n-      -------------------\n-\n-      procedure Add_Interface (Iface : Entity_Id) is\n-         Elmt : Elmt_Id;\n-\n-      begin\n-         Elmt := First_Elmt (Abstract_Interfaces (T));\n-         while Present (Elmt) and then Node (Elmt) /= Iface loop\n-            Next_Elmt (Elmt);\n-         end loop;\n-\n-         if No (Elmt) then\n-            Append_Elmt (Iface, Abstract_Interfaces (T));\n-         end if;\n-      end Add_Interface;\n-\n-      -------------\n-      -- Collect --\n-      -------------\n-\n-      procedure Collect (Typ : Entity_Id) is\n-         Ancestor : Entity_Id;\n-         Id       : Node_Id;\n-         Iface    : Entity_Id;\n-         Nod      : Node_Id;\n-\n-      begin\n-         if Ekind (Typ) = E_Record_Type_With_Private then\n-            Nod := Type_Definition (Parent (Full_View (Typ)));\n-         else\n-            Nod := Type_Definition (Parent (Typ));\n-         end if;\n-\n-         pragma Assert (False\n-            or else Nkind (Nod) = N_Derived_Type_Definition\n-            or else Nkind (Nod) = N_Record_Definition);\n-\n-         --  Include the ancestor if we are generating the whole list\n-         --  of interfaces. This is used to know the size of the table\n-         --  that stores the tag of all the ancestor interfaces.\n-\n-         Ancestor := Etype (Typ);\n-\n-         if Ancestor /= Typ then\n-            Collect (Ancestor);\n-         end if;\n-\n-         if Is_Interface (Ancestor) then\n-            Add_Interface (Ancestor);\n-         end if;\n-\n-         --  Traverse the graph of ancestor interfaces\n-\n-         if Is_Non_Empty_List (Interface_List (Nod)) then\n-            Id := First (Interface_List (Nod));\n-            while Present (Id) loop\n-               Iface := Etype (Id);\n-\n-               if Is_Interface (Iface) then\n-                  Add_Interface (Iface);\n-                  Collect (Iface);\n-               end if;\n-\n-               Next (Id);\n-            end loop;\n-         end if;\n-      end Collect;\n-\n-   --  Start of processing for Collect_All_Interfaces\n-\n-   begin\n-      Collect (T);\n-   end Collect_All_Interfaces;\n-\n    ------------------------------\n    -- Default_Prim_Op_Position --\n    ------------------------------\n@@ -601,8 +512,8 @@ package body Exp_Disp is\n \n       Ctrl_Arg   : constant Node_Id := Controlling_Argument (Call_Node);\n       Param_List : constant List_Id := Parameter_Associations (Call_Node);\n-      Subp       : Entity_Id        := Entity (Name (Call_Node));\n \n+      Subp            : Entity_Id;\n       CW_Typ          : Entity_Id;\n       New_Call        : Node_Id;\n       New_Call_Name   : Node_Id;\n@@ -620,9 +531,6 @@ package body Exp_Disp is\n       --  to Duplicate_Subexpr with an explicit dereference when From is an\n       --  access parameter.\n \n-      function Controlling_Type (Subp : Entity_Id) return Entity_Id;\n-      --  Returns the tagged type for which Subp is a primitive subprogram\n-\n       ---------------\n       -- New_Value --\n       ---------------\n@@ -631,55 +539,23 @@ package body Exp_Disp is\n          Res : constant Node_Id := Duplicate_Subexpr (From);\n       begin\n          if Is_Access_Type (Etype (From)) then\n-            return Make_Explicit_Dereference (Sloc (From), Res);\n+            return\n+              Make_Explicit_Dereference (Sloc (From),\n+                Prefix => Res);\n          else\n             return Res;\n          end if;\n       end New_Value;\n \n-      ----------------------\n-      -- Controlling_Type --\n-      ----------------------\n-\n-      function Controlling_Type (Subp : Entity_Id) return Entity_Id is\n-      begin\n-         if Ekind (Subp) = E_Function\n-           and then Has_Controlling_Result (Subp)\n-         then\n-            return Base_Type (Etype (Subp));\n-\n-         else\n-            declare\n-               Formal : Entity_Id;\n-\n-            begin\n-               Formal := First_Formal (Subp);\n-               while Present (Formal) loop\n-                  if Is_Controlling_Formal (Formal) then\n-                     if Is_Access_Type (Etype (Formal)) then\n-                        return Base_Type (Designated_Type (Etype (Formal)));\n-                     else\n-                        return Base_Type (Etype (Formal));\n-                     end if;\n-                  end if;\n-\n-                  Next_Formal (Formal);\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  Controlling type not found (should never happen)\n-\n-         return Empty;\n-      end Controlling_Type;\n-\n    --  Start of processing for Expand_Dispatching_Call\n \n    begin\n       Check_Restriction (No_Dispatching_Calls, Call_Node);\n \n-      --  If this is an inherited operation that was overridden, the body\n-      --  that is being called is its alias.\n+      --  Set subprogram. If this is an inherited operation that was\n+      --  overridden, the body that is being called is its alias.\n+\n+      Subp := Entity (Name (Call_Node));\n \n       if Present (Alias (Subp))\n         and then Is_Inherited_Operation (Subp)\n@@ -711,7 +587,7 @@ package body Exp_Disp is\n         or else (RTE_Available (RE_Interface_Tag)\n                   and then Etype (Ctrl_Arg) = RTE (RE_Interface_Tag))\n       then\n-         CW_Typ := Class_Wide_Type (Controlling_Type (Subp));\n+         CW_Typ := Class_Wide_Type (Find_Dispatching_Type (Subp));\n \n       elsif Is_Access_Type (Etype (Ctrl_Arg)) then\n          CW_Typ := Designated_Type (Etype (Ctrl_Arg));\n@@ -730,6 +606,8 @@ package body Exp_Disp is\n          Eq_Prim_Op := Find_Prim_Op (Typ, Name_Op_Eq);\n       end if;\n \n+      --  Why do we check the Root_Type instead of Typ???\n+\n       if Is_CPP_Class (Root_Type (Typ)) then\n \n          --  Create a new parameter list with the displaced 'this'\n@@ -888,6 +766,8 @@ package body Exp_Disp is\n                Next_Entity (New_Formal);\n                Next_Actual (Param);\n             end loop;\n+\n+            Set_Next_Entity (New_Formal, Empty);\n             Set_Last_Entity (Subp_Typ, Extra);\n \n             --  Copy extra formals\n@@ -942,7 +822,9 @@ package body Exp_Disp is\n       --  Generate:\n       --   Subp_Ptr_Typ!(Get_Prim_Op_Address (Ctrl._Tag, pos));\n \n-      if Is_Predefined_Dispatching_Operation (Subp) then\n+      if Is_Predefined_Dispatching_Operation (Subp)\n+        or else Is_Predefined_Dispatching_Alias (Subp)\n+      then\n          New_Call_Name :=\n            Unchecked_Convert_To (Subp_Ptr_Typ,\n              Make_DT_Access_Action (Typ,\n@@ -1056,14 +938,15 @@ package body Exp_Disp is\n       Is_Static : Boolean := True)\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n+      Etyp        : constant Entity_Id  := Etype (N);\n       Operand     : constant Node_Id    := Expression (N);\n       Operand_Typ : Entity_Id           := Etype (Operand);\n-      Iface_Typ   : Entity_Id           := Etype (N);\n-      Iface_Tag   : Entity_Id;\n       Fent        : Entity_Id;\n       Func        : Node_Id;\n+      Iface_Typ   : Entity_Id           := Etype (N);\n+      Iface_Tag   : Entity_Id;\n+      New_Itype   : Entity_Id;\n       P           : Node_Id;\n-      Null_Op_Nod : Node_Id;\n \n    begin\n       pragma Assert (Nkind (Operand) /= N_Attribute_Reference);\n@@ -1089,8 +972,9 @@ package body Exp_Disp is\n          Iface_Typ := Etype (Iface_Typ);\n       end if;\n \n-      pragma Assert (not Is_Class_Wide_Type (Iface_Typ)\n-        and then Is_Interface (Iface_Typ));\n+      pragma Assert (not Is_Static\n+        or else (not Is_Class_Wide_Type (Iface_Typ)\n+                  and then Is_Interface (Iface_Typ)));\n \n       if not Is_Static then\n \n@@ -1101,37 +985,69 @@ package body Exp_Disp is\n             return;\n          end if;\n \n+         --  Handle conversion of access to class-wide interface types. The\n+         --  target can be an access to object or an access to another class\n+         --  wide interfac (see -1- and -2- in the following example):\n+\n+         --     type Iface1_Ref is access all Iface1'Class;\n+         --     type Iface2_Ref is access all Iface1'Class;\n+\n+         --     Acc1 : Iface1_Ref := new ...\n+         --     Obj  : Obj_Ref    := Obj_Ref (Acc);    -- 1\n+         --     Acc2 : Iface2_Ref := Iface2_Ref (Acc); -- 2\n+\n+         if Is_Access_Type (Operand_Typ) then\n+            pragma Assert\n+              (Is_Class_Wide_Type (Directly_Designated_Type (Operand_Typ))\n+                 and then\n+               Is_Interface (Directly_Designated_Type (Operand_Typ)));\n+\n+            Rewrite (N,\n+              Unchecked_Convert_To (Etype (N),\n+                Make_Function_Call (Loc,\n+                  Name => New_Reference_To (RTE (RE_Displace), Loc),\n+                  Parameter_Associations => New_List (\n+\n+                    Unchecked_Convert_To (RTE (RE_Address),\n+                      Relocate_Node (Expression (N))),\n+\n+                    New_Occurrence_Of\n+                      (Node (First_Elmt (Access_Disp_Table (Iface_Typ))),\n+                       Loc)))));\n+\n+            Analyze (N);\n+            return;\n+         end if;\n+\n          Rewrite (N,\n            Make_Function_Call (Loc,\n              Name => New_Reference_To (RTE (RE_Displace), Loc),\n              Parameter_Associations => New_List (\n                Make_Attribute_Reference (Loc,\n                  Prefix => Relocate_Node (Expression (N)),\n                  Attribute_Name => Name_Address),\n+\n                New_Occurrence_Of\n                  (Node (First_Elmt (Access_Disp_Table (Iface_Typ))),\n                   Loc))));\n \n          Analyze (N);\n \n-         --  Change the type of the data returned by IW_Convert to\n-         --  indicate that this is a dispatching call.\n+         --  If the target is a class-wide interface we change the type of the\n+         --  data returned by IW_Convert to indicate that this is a dispatching\n+         --  call.\n \n-         declare\n-            New_Itype : Entity_Id;\n-\n-         begin\n-            New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n-            Set_Etype       (New_Itype, New_Itype);\n-            Init_Size_Align (New_Itype);\n-            Set_Directly_Designated_Type (New_Itype,\n-              Class_Wide_Type (Iface_Typ));\n+         New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n+         Set_Etype       (New_Itype, New_Itype);\n+         Init_Esize      (New_Itype);\n+         Init_Size_Align (New_Itype);\n+         Set_Directly_Designated_Type (New_Itype, Etyp);\n \n-            Rewrite (N, Make_Explicit_Dereference (Loc,\n+         Rewrite (N, Make_Explicit_Dereference (Loc,\n                           Unchecked_Convert_To (New_Itype,\n                             Relocate_Node (N))));\n-            Analyze (N);\n-         end;\n+         Analyze (N);\n+         Freeze_Itype (New_Itype, N);\n \n          return;\n       end if;\n@@ -1157,23 +1073,33 @@ package body Exp_Disp is\n          --  conversion that will be expanded in the code that returns\n          --  the value of the displaced actual. That is:\n \n-         --     function Func (O : Operand_Typ) return Iface_Typ is\n+         --     function Func (O : Address) return Iface_Typ is\n          --     begin\n-         --        if O = null then\n+         --        if O = Null_Address then\n          --           return null;\n          --        else\n-         --           return Iface_Typ!(O);\n+         --           return Iface_Typ!(Operand_Typ!(O).Iface_Tag'Address);\n          --        end if;\n          --     end Func;\n \n-         Fent :=\n-           Make_Defining_Identifier (Loc, New_Internal_Name ('F'));\n+         Fent := Make_Defining_Identifier (Loc, New_Internal_Name ('F'));\n+         Set_Is_Internal (Fent);\n+\n+         declare\n+            Desig_Typ : Entity_Id;\n+         begin\n+            Desig_Typ := Etype (Expression (N));\n \n-         --  Decorate the \"null\" in the if-statement condition\n+            if Is_Access_Type (Desig_Typ) then\n+               Desig_Typ := Directly_Designated_Type (Desig_Typ);\n+            end if;\n \n-         Null_Op_Nod := Make_Null (Loc);\n-         Set_Etype (Null_Op_Nod, Etype (Operand));\n-         Set_Analyzed (Null_Op_Nod);\n+            New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n+            Set_Etype       (New_Itype, New_Itype);\n+            Set_Scope       (New_Itype, Fent);\n+            Init_Size_Align (New_Itype);\n+            Set_Directly_Designated_Type (New_Itype, Desig_Typ);\n+         end;\n \n          Func :=\n            Make_Subprogram_Body (Loc,\n@@ -1186,7 +1112,8 @@ package body Exp_Disp is\n                      Defining_Identifier =>\n                        Make_Defining_Identifier (Loc, Name_uO),\n                      Parameter_Type =>\n-                       New_Reference_To (Etype (Operand), Loc))),\n+                       New_Reference_To (RTE (RE_Address), Loc))),\n+\n                  Result_Definition =>\n                    New_Reference_To (Etype (N), Loc)),\n \n@@ -1199,20 +1126,24 @@ package body Exp_Disp is\n                      Condition       =>\n                        Make_Op_Eq (Loc,\n                           Left_Opnd  => Make_Identifier (Loc, Name_uO),\n-                          Right_Opnd => Null_Op_Nod),\n+                          Right_Opnd => New_Reference_To\n+                                          (RTE (RE_Null_Address), Loc)),\n+\n                      Then_Statements => New_List (\n                        Make_Return_Statement (Loc,\n                          Make_Null (Loc))),\n+\n                      Else_Statements => New_List (\n                        Make_Return_Statement (Loc,\n                          Unchecked_Convert_To (Etype (N),\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix =>\n-                                Make_Selected_Component (Loc,\n-                                  Prefix => Make_Identifier (Loc, Name_uO),\n-                                  Selector_Name =>\n-                                    New_Occurrence_Of (Iface_Tag, Loc)),\n-                              Attribute_Name => Name_Address))))))));\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix =>\n+                               Make_Selected_Component (Loc,\n+                                 Prefix => Unchecked_Convert_To (New_Itype,\n+                                             Make_Identifier (Loc, Name_uO)),\n+                                 Selector_Name =>\n+                                   New_Occurrence_Of (Iface_Tag, Loc)),\n+                             Attribute_Name => Name_Address))))))));\n \n          --  Insert the new declaration in the nearest enclosing scope\n          --  that has declarations.\n@@ -1234,11 +1165,32 @@ package body Exp_Disp is\n \n          Analyze (Func);\n \n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name => New_Reference_To (Fent, Loc),\n-             Parameter_Associations => New_List (\n-               Relocate_Node (Expression (N)))));\n+         if Is_Access_Type (Etype (Expression (N))) then\n+\n+            --  Generate: Operand_Typ!(Expression.all)'Address\n+\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name => New_Reference_To (Fent, Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix  => Unchecked_Convert_To (Operand_Typ,\n+                                 Make_Explicit_Dereference (Loc,\n+                                   Relocate_Node (Expression (N)))),\n+                    Attribute_Name => Name_Address))));\n+\n+         else\n+            --  Generate: Operand_Typ!(Expression)'Address\n+\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name => New_Reference_To (Fent, Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix  => Unchecked_Convert_To (Operand_Typ,\n+                                 Relocate_Node (Expression (N))),\n+                    Attribute_Name => Name_Address))));\n+         end if;\n       end if;\n \n       Analyze (N);\n@@ -1484,7 +1436,7 @@ package body Exp_Disp is\n \n          --  Example:\n          --     type I is interface;\n-         --     procedure P (X : in I) is abstract;\n+         --     procedure P (X : I) is abstract;\n \n          --     type T is tagged null record;\n          --     procedure P (X : T);\n@@ -1665,7 +1617,11 @@ package body Exp_Disp is\n                         Parameter_Associations => Actuals)))));\n       end if;\n \n-      Analyze (New_Code);\n+      --  Analyze the code of the thunk with checks suppressed because we are\n+      --  in the middle of building the dispatch information itself and some\n+      --  characteristics of the type may not be fully available.\n+\n+      Analyze (New_Code, Suppress => All_Checks);\n       return New_Code;\n    end Expand_Interface_Thunk;\n \n@@ -1686,7 +1642,9 @@ package body Exp_Disp is\n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n \n-      if Is_Predefined_Dispatching_Operation (Prim) then\n+      if Is_Predefined_Dispatching_Operation (Prim)\n+        or else Is_Predefined_Dispatching_Alias (Prim)\n+      then\n          return\n            Make_DT_Access_Action (Typ,\n              Action => Set_Predefined_Prim_Op_Address,\n@@ -1734,7 +1692,9 @@ package body Exp_Disp is\n                      First_Tag_Component (Scope (DTC_Entity (Iface_Prim)));\n \n    begin\n-      if Is_Predefined_Dispatching_Operation (Prim) then\n+      if Is_Predefined_Dispatching_Operation (Prim)\n+        or else Is_Predefined_Dispatching_Alias (Prim)\n+      then\n          return\n            Make_DT_Access_Action (Typ,\n              Action => Set_Predefined_Prim_Op_Address,\n@@ -1829,6 +1789,31 @@ package body Exp_Disp is\n       return Result;\n    end Init_Predefined_Interface_Primitives;\n \n+   -------------------------------------\n+   -- Is_Predefined_Dispatching_Alias --\n+   -------------------------------------\n+\n+   function Is_Predefined_Dispatching_Alias (Prim : Entity_Id) return Boolean\n+   is\n+      E : Entity_Id;\n+\n+   begin\n+      if not Is_Predefined_Dispatching_Operation (Prim)\n+        and then Present (Alias (Prim))\n+      then\n+         E := Prim;\n+         while Present (Alias (E)) loop\n+            E := Alias (E);\n+         end loop;\n+\n+         if Is_Predefined_Dispatching_Operation (E) then\n+            return True;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Is_Predefined_Dispatching_Alias;\n+\n    ----------------------------------------\n    -- Make_Disp_Asynchronous_Select_Body --\n    ----------------------------------------\n@@ -2687,95 +2672,91 @@ package body Exp_Disp is\n       Size_Expr_Node    : Node_Id;\n       TSD_Num_Entries   : Int;\n \n-      Ancestor_Copy     : Entity_Id;\n       Empty_DT          : Boolean := False;\n-      Typ_Copy          : Entity_Id;\n+\n+      Ancestor_Ifaces   : Elist_Id;\n+      Typ_Ifaces        : Elist_Id;\n \n    begin\n       if not RTE_Available (RE_Tag) then\n          Error_Msg_CRT (\"tagged types\", Typ);\n          return New_List;\n       end if;\n \n-      --  Calculate the size of the DT and the TSD\n-\n-      if Is_Interface (Typ) then\n+      --  Calculate the size of the DT and the TSD. First we count the number\n+      --  of interfaces implemented by the ancestors\n \n-         --  Abstract interfaces need neither the DT nor the ancestors table.\n-         --  We reserve a single entry for its DT because at run-time the\n-         --  pointer to this dummy DT will be used as the tag of this abstract\n-         --  interface type.\n+      Parent_Num_Ifaces := 0;\n+      Num_Ifaces        := 0;\n \n-         Empty_DT        := True;\n-         Nb_Prim         := 1;\n-         TSD_Num_Entries := 0;\n-         Num_Ifaces      := 0;\n+      --  Count the abstract interfaces of the ancestors\n \n-      else\n-         --  Count the number of interfaces implemented by the ancestors\n+      if Typ /= Etype (Typ) then\n+         Collect_Abstract_Interfaces (Etype (Typ), Ancestor_Ifaces);\n \n-         Parent_Num_Ifaces := 0;\n-         Num_Ifaces        := 0;\n+         AI := First_Elmt (Ancestor_Ifaces);\n+         while Present (AI) loop\n+            Parent_Num_Ifaces := Parent_Num_Ifaces + 1;\n+            Next_Elmt (AI);\n+         end loop;\n+      end if;\n \n-         if Typ /= Etype (Typ) then\n-            Ancestor_Copy := New_Copy (Etype (Typ));\n-            Set_Parent (Ancestor_Copy, Parent (Etype (Typ)));\n-            Set_Abstract_Interfaces (Ancestor_Copy, New_Elmt_List);\n-            Collect_All_Interfaces (Ancestor_Copy);\n+      --  Count the number of additional interfaces implemented by Typ\n \n-            AI := First_Elmt (Abstract_Interfaces (Ancestor_Copy));\n-            while Present (AI) loop\n-               Parent_Num_Ifaces := Parent_Num_Ifaces + 1;\n-               Next_Elmt (AI);\n-            end loop;\n-         end if;\n+      Collect_Abstract_Interfaces (Typ, Typ_Ifaces);\n \n-         --  Count the number of additional interfaces implemented by Typ\n+      AI := First_Elmt (Typ_Ifaces);\n+      while Present (AI) loop\n+         Num_Ifaces := Num_Ifaces + 1;\n+         Next_Elmt (AI);\n+      end loop;\n \n-         Typ_Copy := New_Copy (Typ);\n-         Set_Parent (Typ_Copy, Parent (Typ));\n-         Set_Abstract_Interfaces (Typ_Copy, New_Elmt_List);\n-         Collect_All_Interfaces (Typ_Copy);\n+      --  Count ancestors to compute the inheritance depth. For private\n+      --  extensions, always go to the full view in order to compute the\n+      --  real inheritance depth.\n \n-         AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n-         while Present (AI) loop\n-            Num_Ifaces := Num_Ifaces + 1;\n-            Next_Elmt (AI);\n-         end loop;\n+      declare\n+         Parent_Type : Entity_Id := Typ;\n+         P           : Entity_Id;\n \n-         --  Count ancestors to compute the inheritance depth. For private\n-         --  extensions, always go to the full view in order to compute the\n-         --  real inheritance depth.\n+      begin\n+         I_Depth := 0;\n+         loop\n+            P := Etype (Parent_Type);\n \n-         declare\n-            Parent_Type : Entity_Id := Typ;\n-            P           : Entity_Id;\n+            if Is_Private_Type (P) then\n+               P := Full_View (Base_Type (P));\n+            end if;\n \n-         begin\n-            I_Depth := 0;\n-            loop\n-               P := Etype (Parent_Type);\n+            exit when P = Parent_Type;\n \n-               if Is_Private_Type (P) then\n-                  P := Full_View (Base_Type (P));\n-               end if;\n+            I_Depth := I_Depth + 1;\n+            Parent_Type := P;\n+         end loop;\n+      end;\n \n-               exit when P = Parent_Type;\n+      --  Abstract interfaces don't need the DT. We reserve a single entry\n+      --  for its DT because at run-time the pointer to this dummy DT will\n+      --  be used as the tag of this abstract interface type. The table of\n+      --  interfaces is required to give support to AI-405\n \n-               I_Depth := I_Depth + 1;\n-               Parent_Type := P;\n-            end loop;\n-         end;\n+      if Is_Interface (Typ) then\n+         Empty_DT := True;\n+         Nb_Prim  := 1;\n+         TSD_Num_Entries := 0;\n \n+      else\n          TSD_Num_Entries := I_Depth + 1;\n          Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n-         --  If the number of primitives of Typ is 0 (or we are compiling with\n-         --  the No_Dispatching_Calls restriction) we reserve a dummy single\n-         --  entry for its DT because at run-time the pointer to this dummy DT\n-         --  will be used as the tag of this tagged type.\n+         --  If the number of primitives of Typ is 0 (or we are compiling\n+         --  with the No_Dispatching_Calls restriction) we reserve a dummy\n+         --  single entry for its DT because at run-time the pointer to this\n+         --  dummy DT will be used as the tag of this tagged type.\n \n-         if Nb_Prim = 0 or else Restriction_Active (No_Dispatching_Calls) then\n+         if Nb_Prim = 0\n+           or else Restriction_Active (No_Dispatching_Calls)\n+         then\n             Empty_DT := True;\n             Nb_Prim  := 1;\n          end if;\n@@ -2789,9 +2770,7 @@ package body Exp_Disp is\n       Set_Ekind (DT_Ptr, E_Variable);\n       Set_Is_Statically_Allocated (DT_Ptr);\n \n-      if not Is_Interface (Typ)\n-        and then Num_Ifaces > 0\n-      then\n+      if Num_Ifaces > 0 then\n          Name_ITable := New_External_Name (Tname, 'I');\n          ITable      := Make_Defining_Identifier (Loc, Name_ITable);\n \n@@ -2936,21 +2915,23 @@ package body Exp_Disp is\n       --  Generate:\n       --    Set_Signature (DT_Ptr, Value);\n \n-      if Is_Interface (Typ) then\n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Signature,\n-             Args   => New_List (\n-               New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n-               New_Reference_To (RTE (RE_Abstract_Interface), Loc))));\n+      if RTE_Available (RE_Set_Signature) then\n+         if Is_Interface (Typ) then\n+            Append_To (Elab_Code,\n+              Make_DT_Access_Action (Typ,\n+                Action => Set_Signature,\n+                Args   => New_List (\n+                  New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+                  New_Reference_To (RTE (RE_Abstract_Interface), Loc))));\n \n-      elsif RTE_Available (RE_Set_Signature) then\n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Signature,\n-             Args   => New_List (\n-               New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n-               New_Reference_To (RTE (RE_Primary_DT), Loc))));\n+         else\n+            Append_To (Elab_Code,\n+              Make_DT_Access_Action (Typ,\n+                Action => Set_Signature,\n+                Args   => New_List (\n+                  New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+                  New_Reference_To (RTE (RE_Primary_DT), Loc))));\n+         end if;\n       end if;\n \n       --  Generate code to put the Address of the TSD in the dispatch table\n@@ -2968,10 +2949,7 @@ package body Exp_Disp is\n       --  Set the pointer to the Interfaces_Table (if any). Otherwise the\n       --  corresponding access component is set to null.\n \n-      if Is_Interface (Typ) then\n-         null;\n-\n-      elsif Num_Ifaces = 0 then\n+      if Num_Ifaces = 0 then\n          if RTE_Available (RE_Set_Interface_Table) then\n             Append_To (Elab_Code,\n               Make_DT_Access_Action (Typ,\n@@ -3121,155 +3099,168 @@ package body Exp_Disp is\n                Node2 => Make_Integer_Literal (Loc, Type_Access_Level (Typ)))));\n       end if;\n \n-      if Typ = Etype (Typ)\n-        or else Is_CPP_Class (Etype (Typ))\n-        or else Is_Interface (Typ)\n-      then\n-         Old_Tag1 :=\n-           Unchecked_Convert_To (Generalized_Tag,\n-             Make_Integer_Literal (Loc, 0));\n-         Old_Tag2 :=\n-           Unchecked_Convert_To (Generalized_Tag,\n-             Make_Integer_Literal (Loc, 0));\n+      --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n+      --  in the init proc, and we don't need to fill them in here.\n \n-      else\n-         Old_Tag1 :=\n-           New_Reference_To\n-             (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n-         Old_Tag2 :=\n-           New_Reference_To\n-             (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n-      end if;\n+      if Is_CPP_Class (Etype (Typ)) and then not Debug_Flag_QQ then\n+         null;\n \n-      if Typ /= Etype (Typ)\n-        and then not Is_Interface (Typ)\n-        and then not Restriction_Active (No_Dispatching_Calls)\n-      then\n-         --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n+         --  Otherwise we fill in the dispatch tables here\n \n-         if not Is_Interface (Etype (Typ)) then\n-            if Restriction_Active (No_Dispatching_Calls) then\n-               Append_To (Elab_Code,\n-                 Make_DT_Access_Action (Typ,\n-                   Action => Inherit_DT,\n-                   Args   => New_List (\n-                     Node1 => Old_Tag1,\n-                     Node2 => New_Reference_To (DT_Ptr, Loc),\n-                     Node3 => Make_Integer_Literal (Loc, Uint_0))));\n-            else\n-               Append_To (Elab_Code,\n-                 Make_DT_Access_Action (Typ,\n-                   Action => Inherit_DT,\n-                   Args   => New_List (\n-                     Node1 => Old_Tag1,\n-                     Node2 => New_Reference_To (DT_Ptr, Loc),\n-                     Node3 => Make_Integer_Literal (Loc,\n-                                DT_Entry_Count\n-                                  (First_Tag_Component (Etype (Typ)))))));\n-            end if;\n-         end if;\n+      else\n+         if Typ = Etype (Typ)\n+           or else Is_CPP_Class (Etype (Typ))\n+           or else Is_Interface (Typ)\n+         then\n+            Old_Tag1 :=\n+              Unchecked_Convert_To (Generalized_Tag,\n+                Make_Integer_Literal (Loc, 0));\n+            Old_Tag2 :=\n+              Unchecked_Convert_To (Generalized_Tag,\n+                Make_Integer_Literal (Loc, 0));\n \n-         --  Inherit the secondary dispatch tables of the ancestor\n+         else\n+            Old_Tag1 :=\n+              New_Reference_To\n+                (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n+            Old_Tag2 :=\n+              New_Reference_To\n+                (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n+         end if;\n \n-         if not Restriction_Active (No_Dispatching_Calls)\n-           and then not Is_CPP_Class (Etype (Typ))\n+         if Typ /= Etype (Typ)\n+           and then not Is_Interface (Typ)\n+           and then not Restriction_Active (No_Dispatching_Calls)\n          then\n-            declare\n-               Sec_DT_Ancestor : Elmt_Id :=\n-                                   Next_Elmt\n-                                     (First_Elmt\n-                                        (Access_Disp_Table (Etype (Typ))));\n-               Sec_DT_Typ      : Elmt_Id :=\n-                                   Next_Elmt\n-                                     (First_Elmt\n-                                        (Access_Disp_Table (Typ)));\n-\n-               procedure Copy_Secondary_DTs (Typ : Entity_Id);\n-               --  Local procedure required to climb through the ancestors and\n-               --  copy the contents of all their secondary dispatch tables.\n-\n-               ------------------------\n-               -- Copy_Secondary_DTs --\n-               ------------------------\n-\n-               procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n-                  E     : Entity_Id;\n-                  Iface : Elmt_Id;\n+            --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n \n-               begin\n-                  --  Climb to the ancestor (if any) handling private types\n+            if not Is_Interface (Etype (Typ)) then\n+               if Restriction_Active (No_Dispatching_Calls) then\n+                  Append_To (Elab_Code,\n+                    Make_DT_Access_Action (Typ,\n+                      Action => Inherit_DT,\n+                      Args   => New_List (\n+                        Node1 => Old_Tag1,\n+                        Node2 => New_Reference_To (DT_Ptr, Loc),\n+                        Node3 => Make_Integer_Literal (Loc, Uint_0))));\n+               else\n+                  Append_To (Elab_Code,\n+                    Make_DT_Access_Action (Typ,\n+                      Action => Inherit_DT,\n+                      Args   => New_List (\n+                        Node1 => Old_Tag1,\n+                        Node2 => New_Reference_To (DT_Ptr, Loc),\n+                        Node3 => Make_Integer_Literal (Loc,\n+                                   DT_Entry_Count\n+                                     (First_Tag_Component (Etype (Typ)))))));\n+               end if;\n+            end if;\n \n-                  if Present (Full_View (Etype (Typ))) then\n-                     if Full_View (Etype (Typ)) /= Typ then\n-                        Copy_Secondary_DTs (Full_View (Etype (Typ)));\n-                     end if;\n+            --  Inherit the secondary dispatch tables of the ancestor\n \n-                  elsif Etype (Typ) /= Typ then\n-                     Copy_Secondary_DTs (Etype (Typ));\n-                  end if;\n+            if not Restriction_Active (No_Dispatching_Calls)\n+              and then not Is_CPP_Class (Etype (Typ))\n+            then\n+               declare\n+                  Sec_DT_Ancestor : Elmt_Id :=\n+                                      Next_Elmt\n+                                        (First_Elmt\n+                                           (Access_Disp_Table (Etype (Typ))));\n+                  Sec_DT_Typ      : Elmt_Id :=\n+                                      Next_Elmt\n+                                        (First_Elmt\n+                                           (Access_Disp_Table (Typ)));\n+\n+                  procedure Copy_Secondary_DTs (Typ : Entity_Id);\n+                  --  Local procedure required to climb through the ancestors\n+                  --  and copy the contents of all their secondary dispatch\n+                  --  tables.\n+\n+                  ------------------------\n+                  -- Copy_Secondary_DTs --\n+                  ------------------------\n+\n+                  procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n+                     E     : Entity_Id;\n+                     Iface : Elmt_Id;\n+\n+                  begin\n+                     --  Climb to the ancestor (if any) handling private types\n+\n+                     if Present (Full_View (Etype (Typ))) then\n+                        if Full_View (Etype (Typ)) /= Typ then\n+                           Copy_Secondary_DTs (Full_View (Etype (Typ)));\n+                        end if;\n \n-                  if Present (Abstract_Interfaces (Typ))\n-                    and then not Is_Empty_Elmt_List\n-                                   (Abstract_Interfaces (Typ))\n-                  then\n-                     Iface := First_Elmt (Abstract_Interfaces (Typ));\n-                     E     := First_Entity (Typ);\n-                     while Present (E)\n-                       and then Present (Node (Sec_DT_Ancestor))\n-                     loop\n-                        if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                           if not Is_Interface (Etype (Typ)) then\n-                              Append_To (Elab_Code,\n-                                Make_DT_Access_Action (Typ,\n-                                  Action => Inherit_DT,\n-                                  Args   => New_List (\n-                                    Node1 => Unchecked_Convert_To\n-                                               (RTE (RE_Tag),\n-                                                New_Reference_To\n-                                                  (Node (Sec_DT_Ancestor),\n-                                                   Loc)),\n-                                    Node2 => Unchecked_Convert_To\n-                                               (RTE (RE_Tag),\n-                                                New_Reference_To\n-                                                  (Node (Sec_DT_Typ), Loc)),\n-                                    Node3 => Make_Integer_Literal (Loc,\n-                                               DT_Entry_Count (E)))));\n-                           end if;\n+                     elsif Etype (Typ) /= Typ then\n+                        Copy_Secondary_DTs (Etype (Typ));\n+                     end if;\n \n-                           Next_Elmt (Sec_DT_Ancestor);\n-                           Next_Elmt (Sec_DT_Typ);\n-                           Next_Elmt (Iface);\n-                        end if;\n+                     if Present (Abstract_Interfaces (Typ))\n+                       and then not Is_Empty_Elmt_List\n+                                      (Abstract_Interfaces (Typ))\n+                     then\n+                        Iface := First_Elmt (Abstract_Interfaces (Typ));\n+                        E     := First_Entity (Typ);\n+                        while Present (E)\n+                          and then Present (Node (Sec_DT_Ancestor))\n+                        loop\n+                           if Is_Tag (E) and then Chars (E) /= Name_uTag then\n+                              if not Is_Interface (Etype (Typ)) then\n+                                 Append_To (Elab_Code,\n+                                   Make_DT_Access_Action (Typ,\n+                                     Action => Inherit_DT,\n+                                     Args   => New_List (\n+                                       Node1 => Unchecked_Convert_To\n+                                                  (RTE (RE_Tag),\n+                                                   New_Reference_To\n+                                                     (Node (Sec_DT_Ancestor),\n+                                                      Loc)),\n+                                       Node2 => Unchecked_Convert_To\n+                                                  (RTE (RE_Tag),\n+                                                   New_Reference_To\n+                                                     (Node (Sec_DT_Typ), Loc)),\n+                                       Node3 => Make_Integer_Literal (Loc,\n+                                                  DT_Entry_Count (E)))));\n+                              end if;\n+\n+                              Next_Elmt (Sec_DT_Ancestor);\n+                              Next_Elmt (Sec_DT_Typ);\n+                              Next_Elmt (Iface);\n+                           end if;\n \n-                        Next_Entity (E);\n-                     end loop;\n-                  end if;\n-               end Copy_Secondary_DTs;\n+                           Next_Entity (E);\n+                        end loop;\n+                     end if;\n+                  end Copy_Secondary_DTs;\n \n-            begin\n-               if Present (Node (Sec_DT_Ancestor)) then\n+               begin\n+                  if Present (Node (Sec_DT_Ancestor)) then\n \n-                  --  Handle private types\n+                     --  Handle private types\n \n-                  if Present (Full_View (Typ)) then\n-                     Copy_Secondary_DTs (Full_View (Typ));\n-                  else\n-                     Copy_Secondary_DTs (Typ);\n+                     if Present (Full_View (Typ)) then\n+                        Copy_Secondary_DTs (Full_View (Typ));\n+                     else\n+                        Copy_Secondary_DTs (Typ);\n+                     end if;\n                   end if;\n-               end if;\n-            end;\n+               end;\n+            end if;\n          end if;\n-      end if;\n \n-      --  Generate:\n-      --    Inherit_TSD (parent'tag, DT_Ptr);\n+         --  Generate:\n+         --    Inherit_TSD (parent'tag, DT_Ptr);\n \n-      Append_To (Elab_Code,\n-        Make_DT_Access_Action (Typ,\n-          Action => Inherit_TSD,\n-          Args   => New_List (\n-            Node1 => Old_Tag2,\n-            Node2 => New_Reference_To (DT_Ptr, Loc))));\n+         if not Is_Interface (Typ) then\n+            Append_To (Elab_Code,\n+              Make_DT_Access_Action (Typ,\n+                Action => Inherit_TSD,\n+                Args   => New_List (\n+                  Node1 => Old_Tag2,\n+                  Node2 => New_Reference_To (DT_Ptr, Loc))));\n+         end if;\n+      end if;\n \n       if not Is_Interface (Typ) then\n \n@@ -3434,9 +3425,7 @@ package body Exp_Disp is\n       --  Ada 2005 (AI-251): Register the tag of the interfaces into\n       --  the table of implemented interfaces.\n \n-      if not Is_Interface (Typ)\n-        and then Num_Ifaces > 0\n-      then\n+      if Num_Ifaces > 0 then\n          declare\n             Position : Int;\n \n@@ -3445,10 +3434,12 @@ package body Exp_Disp is\n             --  all its interfaces; otherwise this code is not needed because\n             --  Inherit_TSD has already inherited such interfaces.\n \n-            if Is_Interface (Etype (Typ)) then\n+            if Etype (Typ) /= Typ\n+              and then Is_Interface (Etype (Typ))\n+            then\n                Position := 1;\n \n-               AI := First_Elmt (Abstract_Interfaces (Ancestor_Copy));\n+               AI := First_Elmt (Ancestor_Ifaces);\n                while Present (AI) loop\n                   --  Generate:\n                   --    Register_Interface (DT_Ptr, Interface'Tag);\n@@ -3473,22 +3464,25 @@ package body Exp_Disp is\n             --  Register the interfaces that are not implemented by the\n             --  ancestor\n \n-            if Present (Abstract_Interfaces (Typ_Copy)) then\n-               AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n+            AI := First_Elmt (Typ_Ifaces);\n \n-               --  Skip the interfaces implemented by the ancestor\n+            --  Skip the interfaces implemented by the ancestor\n \n-               for Count in 1 .. Parent_Num_Ifaces loop\n-                  Next_Elmt (AI);\n-               end loop;\n+            for Count in 1 .. Parent_Num_Ifaces loop\n+               Next_Elmt (AI);\n+            end loop;\n \n-               --  Register the additional interfaces\n+            --  Register the additional interfaces\n \n-               Position := Parent_Num_Ifaces + 1;\n-               while Present (AI) loop\n-                  --  Generate:\n-                  --    Register_Interface (DT_Ptr, Interface'Tag);\n+            Position := Parent_Num_Ifaces + 1;\n+            while Present (AI) loop\n \n+               --  Generate:\n+               --    Register_Interface (DT_Ptr, Interface'Tag);\n+\n+               if not Is_Interface (Typ)\n+                 or else Typ /= Node (AI)\n+               then\n                   Append_To (Result,\n                     Make_DT_Access_Action (Typ,\n                       Action => Register_Interface_Tag,\n@@ -3502,9 +3496,10 @@ package body Exp_Disp is\n                         Node3 => Make_Integer_Literal (Loc, Position))));\n \n                   Position := Position + 1;\n-                  Next_Elmt (AI);\n-               end loop;\n-            end if;\n+               end if;\n+\n+               Next_Elmt (AI);\n+            end loop;\n \n             pragma Assert (Position = Num_Ifaces + 1);\n          end;\n@@ -3798,14 +3793,12 @@ package body Exp_Disp is\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n-                  if Present (Abstract_Interface_Alias (Prim)) then\n+                  if Present (Abstract_Interface_Alias (Prim))\n+                    and then Find_Dispatching_Type\n+                               (Abstract_Interface_Alias (Prim)) = Iface\n+                  then\n                      Prim_Alias := Abstract_Interface_Alias (Prim);\n-                  end if;\n \n-                  if Present (Prim_Alias)\n-                    and then Present (First_Entity (Prim_Alias))\n-                    and then Etype (First_Entity (Prim_Alias)) = Iface\n-                  then\n                      --  Generate:\n                      --    Ada.Tags.Set_Offset_Index (Tag (Iface_DT_Ptr),\n                      --      Secondary_DT_Pos, Primary_DT_pos);\n@@ -3819,9 +3812,7 @@ package body Exp_Disp is\n                            Make_Integer_Literal (Loc,\n                              DT_Position (Prim_Alias)),\n                            Make_Integer_Literal (Loc,\n-                             DT_Position (Prim)))));\n-\n-                     Prim_Alias := Empty;\n+                             DT_Position (Alias (Prim))))));\n                   end if;\n \n                   Next_Elmt (Prim_Elmt);\n@@ -3909,7 +3900,11 @@ package body Exp_Disp is\n \n       Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n       while Present (Prim_Elmt) loop\n-         if not Is_Predefined_Dispatching_Operation (Node (Prim_Elmt)) then\n+         Prim := Node (Prim_Elmt);\n+\n+         if not (Is_Predefined_Dispatching_Operation (Prim)\n+                   or else Is_Predefined_Dispatching_Alias (Prim))\n+         then\n             Nb_Prim := Nb_Prim + 1;\n          end if;\n \n@@ -3923,76 +3918,57 @@ package body Exp_Disp is\n          Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n          while Present (Prim_Elmt) loop\n             Prim := Node (Prim_Elmt);\n-            Prim_Pos := DT_Position (Prim);\n-\n-            if not Is_Predefined_Dispatching_Operation (Prim) then\n-               pragma Assert (UI_To_Int (Prim_Pos) <= Nb_Prim);\n-\n-               if Examined (UI_To_Int (Prim_Pos)) then\n-                  goto Continue;\n-               else\n-                  Examined (UI_To_Int (Prim_Pos)) := True;\n-               end if;\n \n-               --  The current primitive overrides an interface-level\n-               --  subprogram\n+            --  Look for primitive overriding an abstract interface subprogram\n \n-               if Present (Abstract_Interface_Alias (Prim)) then\n+            if Present (Abstract_Interface_Alias (Prim))\n+              and then not Examined (UI_To_Int (DT_Position (Alias (Prim))))\n+            then\n+               Prim_Pos := DT_Position (Alias (Prim));\n+               pragma Assert (UI_To_Int (Prim_Pos) <= Nb_Prim);\n+               Examined (UI_To_Int (Prim_Pos)) := True;\n \n-                  --  Set the primitive operation kind regardless of subprogram\n-                  --  type. Generate:\n-                  --    Ada.Tags.Set_Prim_Op_Kind (DT_Ptr, <position>, <kind>);\n+               --  Set the primitive operation kind regardless of subprogram\n+               --  type. Generate:\n+               --    Ada.Tags.Set_Prim_Op_Kind (DT_Ptr, <position>, <kind>);\n \n-                  Append_To (Assignments,\n-                    Make_DT_Access_Action (Typ,\n-                      Action =>\n-                        Set_Prim_Op_Kind,\n-                      Args =>\n-                        New_List (\n-                          New_Reference_To (DT_Ptr, Loc),\n-                          Make_Integer_Literal (Loc, Prim_Pos),\n-                          Prim_Op_Kind (Prim, Typ))));\n+               Append_To (Assignments,\n+                 Make_DT_Access_Action (Typ,\n+                   Action => Set_Prim_Op_Kind,\n+                   Args => New_List (\n+                             New_Reference_To (DT_Ptr, Loc),\n+                             Make_Integer_Literal (Loc, Prim_Pos),\n+                             Prim_Op_Kind (Alias (Prim), Typ))));\n \n-                  --  Retrieve the root of the alias chain if one is present\n+               --  Retrieve the root of the alias chain\n \n-                  if Present (Alias (Prim)) then\n-                     Prim_Als := Prim;\n-                     while Present (Alias (Prim_Als)) loop\n-                        Prim_Als := Alias (Prim_Als);\n-                     end loop;\n-                  else\n-                     Prim_Als := Empty;\n-                  end if;\n+               Prim_Als := Prim;\n+               while Present (Alias (Prim_Als)) loop\n+                  Prim_Als := Alias (Prim_Als);\n+               end loop;\n \n-                  --  In the case of an entry wrapper, set the entry index\n+               --  In the case of an entry wrapper, set the entry index\n \n-                  if Ekind (Prim) = E_Procedure\n-                    and then Present (Prim_Als)\n-                    and then Is_Primitive_Wrapper (Prim_Als)\n-                    and then Ekind (Wrapped_Entity (Prim_Als)) = E_Entry\n-                  then\n+               if Ekind (Prim) = E_Procedure\n+                 and then Is_Primitive_Wrapper (Prim_Als)\n+                 and then Ekind (Wrapped_Entity (Prim_Als)) = E_Entry\n+               then\n+                  --  Generate:\n+                  --    Ada.Tags.Set_Entry_Index\n+                  --      (DT_Ptr, <position>, <index>);\n \n-                     --  Generate:\n-                     --    Ada.Tags.Set_Entry_Index\n-                     --      (DT_Ptr, <position>, <index>);\n-\n-                     Append_To (Assignments,\n-                       Make_DT_Access_Action (Typ,\n-                         Action =>\n-                           Set_Entry_Index,\n-                         Args =>\n-                           New_List (\n-                             New_Reference_To (DT_Ptr, Loc),\n-                             Make_Integer_Literal (Loc, Prim_Pos),\n-                             Make_Integer_Literal (Loc,\n-                               Find_Entry_Index\n-                                 (Wrapped_Entity (Prim_Als))))));\n-                  end if;\n+                  Append_To (Assignments,\n+                    Make_DT_Access_Action (Typ,\n+                      Action => Set_Entry_Index,\n+                      Args => New_List (\n+                                New_Reference_To (DT_Ptr, Loc),\n+                                Make_Integer_Literal (Loc, Prim_Pos),\n+                                Make_Integer_Literal (Loc,\n+                                  Find_Entry_Index\n+                                    (Wrapped_Entity (Prim_Als))))));\n                end if;\n             end if;\n \n-            <<Continue>>\n-\n             Next_Elmt (Prim_Elmt);\n          end loop;\n       end;\n@@ -4118,20 +4094,6 @@ package body Exp_Disp is\n    -------------------------\n \n    procedure Set_All_DT_Position (Typ : Entity_Id) is\n-      Parent_Typ : constant Entity_Id := Etype (Typ);\n-      Root_Typ   : constant Entity_Id := Root_Type (Typ);\n-      First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n-      The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n-\n-      Adjusted   : Boolean := False;\n-      Finalized  : Boolean := False;\n-\n-      Count_Prim : Int;\n-      DT_Length  : Int;\n-      Nb_Prim    : Int;\n-      Parent_EC  : Int;\n-      Prim       : Entity_Id;\n-      Prim_Elmt  : Elmt_Id;\n \n       procedure Validate_Position (Prim : Entity_Id);\n       --  Check that the position assignated to Prim is completely safe\n@@ -4143,31 +4105,50 @@ package body Exp_Disp is\n       -----------------------\n \n       procedure Validate_Position (Prim : Entity_Id) is\n-         Prim_Elmt : Elmt_Id;\n+         Op_Elmt : Elmt_Id;\n+         Op      : Entity_Id;\n \n       begin\n-         Prim_Elmt :=  First_Elmt (Primitive_Operations (Typ));\n-         while Present (Prim_Elmt)\n-            and then Node (Prim_Elmt) /= Prim\n-         loop\n+         --  Aliased primitives are safe\n+\n+         if Present (Alias (Prim)) then\n+            return;\n+         end if;\n+\n+         Op_Elmt := First_Elmt (Primitive_Operations (Typ));\n+         while Present (Op_Elmt) loop\n+            Op := Node (Op_Elmt);\n+\n+            --  No need to check against itself\n+\n+            if Op = Prim then\n+               null;\n+\n             --  Primitive operations covering abstract interfaces are\n             --  allocated later\n \n-            if Present (Abstract_Interface_Alias (Node (Prim_Elmt))) then\n+            elsif Present (Abstract_Interface_Alias (Op)) then\n                null;\n \n             --  Predefined dispatching operations are completely safe. They\n             --  are allocated at fixed positions in a separate table.\n \n-            elsif Is_Predefined_Dispatching_Operation (Node (Prim_Elmt)) then\n+            elsif Is_Predefined_Dispatching_Operation (Op)\n+               or else Is_Predefined_Dispatching_Alias (Op)\n+            then\n                null;\n \n             --  Aliased subprograms are safe\n \n-            elsif Present (Alias (Prim)) then\n+            elsif Present (Alias (Op)) then\n                null;\n \n-            elsif DT_Position (Node (Prim_Elmt)) = DT_Position (Prim) then\n+            elsif DT_Position (Op) = DT_Position (Prim)\n+               and then not Is_Predefined_Dispatching_Operation (Op)\n+               and then not Is_Predefined_Dispatching_Operation (Prim)\n+               and then not Is_Predefined_Dispatching_Alias (Op)\n+               and then not Is_Predefined_Dispatching_Alias (Prim)\n+            then\n \n                --  Handle aliased subprograms\n \n@@ -4176,7 +4157,7 @@ package body Exp_Disp is\n                   Op_2 : Entity_Id;\n \n                begin\n-                  Op_1 := Node (Prim_Elmt);\n+                  Op_1 := Op;\n                   loop\n                      if Present (Overridden_Operation (Op_1)) then\n                         Op_1 := Overridden_Operation (Op_1);\n@@ -4204,10 +4185,27 @@ package body Exp_Disp is\n                end;\n             end if;\n \n-            Next_Elmt (Prim_Elmt);\n+            Next_Elmt (Op_Elmt);\n          end loop;\n       end Validate_Position;\n \n+      --  Local variables\n+\n+      Parent_Typ : constant Entity_Id := Etype (Typ);\n+      Root_Typ   : constant Entity_Id := Root_Type (Typ);\n+      First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n+      The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n+\n+      Adjusted   : Boolean := False;\n+      Finalized  : Boolean := False;\n+\n+      Count_Prim : Int;\n+      DT_Length  : Int;\n+      Nb_Prim    : Int;\n+      Parent_EC  : Int;\n+      Prim       : Entity_Id;\n+      Prim_Elmt  : Elmt_Id;\n+\n    --  Start of processing for Set_All_DT_Position\n \n    begin\n@@ -4225,7 +4223,7 @@ package body Exp_Disp is\n       --  C++ Case, check that pragma CPP_Class, CPP_Virtual and CPP_Vtable\n       --  give a coherent set of information\n \n-      if Is_CPP_Class (Root_Typ) then\n+      if Is_CPP_Class (Root_Typ) and then Debug_Flag_QQ then\n \n          --  Compute the number of primitive operations in the main Vtable\n          --  Set their position:\n@@ -4356,21 +4354,28 @@ package body Exp_Disp is\n          Prim_Elmt  := First_Prim;\n          Count_Prim := 0;\n          while Present (Prim_Elmt) loop\n-            Count_Prim := Count_Prim + 1;\n-            Prim       := Node (Prim_Elmt);\n+            Prim := Node (Prim_Elmt);\n+\n+            --  Predefined primitives have a separate dispatch table\n+\n+            if not (Is_Predefined_Dispatching_Operation (Prim)\n+                      or else Is_Predefined_Dispatching_Alias (Prim))\n+            then\n+               Count_Prim := Count_Prim + 1;\n+            end if;\n \n             --  Ada 2005 (AI-251)\n \n             if Present (Abstract_Interface_Alias (Prim))\n-              and then Is_Interface (Scope (DTC_Entity\n-                                      (Abstract_Interface_Alias (Prim))))\n+              and then Is_Interface\n+                         (Find_Dispatching_Type\n+                           (Abstract_Interface_Alias (Prim)))\n             then\n                Set_DTC_Entity (Prim,\n                   Find_Interface_Tag\n                     (T => Typ,\n-                     Iface => Scope (DTC_Entity\n-                                      (Abstract_Interface_Alias (Prim)))));\n-\n+                     Iface => Find_Dispatching_Type\n+                               (Abstract_Interface_Alias (Prim))));\n             else\n                Set_DTC_Entity (Prim, The_Tag);\n             end if;\n@@ -4385,11 +4390,27 @@ package body Exp_Disp is\n          end loop;\n \n          declare\n-            Fixed_Prim : array (Int range 0 .. Parent_EC + Count_Prim)\n-                           of Boolean := (others => False);\n-\n+            Fixed_Prim : array (Int range 0 .. Count_Prim) of Boolean\n+                           := (others => False);\n             E : Entity_Id;\n \n+            procedure Set_Fixed_Prim (Pos : Int);\n+            --  Sets to true an element of the Fixed_Prim table to indicate\n+            --  that this entry of the dispatch table of Typ is occupied.\n+\n+            --------------------\n+            -- Set_Fixed_Prim --\n+            --------------------\n+\n+            procedure Set_Fixed_Prim (Pos : Int) is\n+            begin\n+               pragma Assert (Pos >= 0 and then Pos <= Count_Prim);\n+               Fixed_Prim (Pos) := True;\n+            exception\n+               when Constraint_Error =>\n+                  raise Program_Error;\n+            end Set_Fixed_Prim;\n+\n          begin\n             --  Second stage: Register fixed entries\n \n@@ -4399,64 +4420,56 @@ package body Exp_Disp is\n                Prim := Node (Prim_Elmt);\n \n                --  Predefined primitives have a separate table and all its\n-               --  entries are at predefined fixed positions\n+               --  entries are at predefined fixed positions.\n \n                if Is_Predefined_Dispatching_Operation (Prim) then\n                   Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n \n-               --  Overriding interface primitives of an ancestor\n-\n-               elsif DT_Position (Prim) = No_Uint\n-                 and then Present (Abstract_Interface_Alias (Prim))\n-                 and then Present (DTC_Entity\n-                                   (Abstract_Interface_Alias (Prim)))\n-                 and then DT_Position (Abstract_Interface_Alias (Prim))\n-                                        /= No_Uint\n-                 and then Is_Inherited_Operation (Prim)\n-                 and then Is_Ancestor (Scope\n-                                       (DTC_Entity\n-                                        (Abstract_Interface_Alias (Prim))),\n-                                       Typ)\n+               elsif Is_Predefined_Dispatching_Alias (Prim) then\n+                  E := Alias (Prim);\n+                  while Present (Alias (E)) loop\n+                     E := Alias (E);\n+                  end loop;\n+\n+                  Set_DT_Position (Prim, Default_Prim_Op_Position (E));\n+\n+               --  Overriding primitives of ancestor abstract interfaces\n+\n+               elsif Present (Abstract_Interface_Alias (Prim))\n+                 and then Is_Ancestor\n+                           (Find_Dispatching_Type\n+                             (Abstract_Interface_Alias (Prim)),\n+                            Typ)\n                then\n-                  Set_DT_Position (Prim,\n-                    DT_Position (Abstract_Interface_Alias (Prim)));\n-                  Set_DT_Position (Alias (Prim),\n-                    DT_Position (Abstract_Interface_Alias (Prim)));\n-                  Fixed_Prim (UI_To_Int (DT_Position (Prim))) := True;\n+                  pragma Assert (DT_Position (Prim) = No_Uint\n+                    and then Present (DTC_Entity\n+                                       (Abstract_Interface_Alias (Prim))));\n+\n+                  E := Abstract_Interface_Alias (Prim);\n+                  Set_DT_Position (Prim, DT_Position (E));\n+\n+                  pragma Assert\n+                    (DT_Position (Alias (Prim)) = No_Uint\n+                       or else DT_Position (Alias (Prim)) = DT_Position (E));\n+                  Set_DT_Position (Alias (Prim), DT_Position (E));\n+                  Set_Fixed_Prim (UI_To_Int (DT_Position (Prim)));\n \n                --  Overriding primitives must use the same entry as the\n                --  overriden primitive\n \n-               elsif DT_Position (Prim) = No_Uint\n+               elsif not Present (Abstract_Interface_Alias (Prim))\n                  and then Present (Alias (Prim))\n+                 and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n+                 and then Is_Ancestor\n+                            (Find_Dispatching_Type (Alias (Prim)), Typ)\n                  and then Present (DTC_Entity (Alias (Prim)))\n-                 and then DT_Position (Alias (Prim)) /= No_Uint\n-                 and then Is_Inherited_Operation (Prim)\n-                 and then Is_Ancestor (Scope (DTC_Entity (Alias (Prim))), Typ)\n                then\n                   E := Alias (Prim);\n-                  while not (Present (DTC_Entity (E))\n-                              or else DT_Position (E) = No_Uint)\n-                    and then Present (Alias (E))\n-                  loop\n-                     E := Alias (E);\n-                  end loop;\n-\n-                  pragma Assert (Present (DTC_Entity (E))\n-                                   and then\n-                                 DT_Position (E) /= No_Uint);\n-\n                   Set_DT_Position (Prim, DT_Position (E));\n-                  Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n-\n-                  --  If this is not the last element in the chain continue\n-                  --  traversing the chain. This is required to properly\n-                  --  handling renamed primitives\n \n-                  while Present (Alias (E)) loop\n-                     E   := Alias (E);\n-                     Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n-                  end loop;\n+                  if not Is_Predefined_Dispatching_Alias (E) then\n+                     Set_Fixed_Prim (UI_To_Int (DT_Position (E)));\n+                  end if;\n                end if;\n \n                Next_Elmt (Prim_Elmt);\n@@ -4472,17 +4485,10 @@ package body Exp_Disp is\n \n                --  Skip primitives previously set entries\n \n-               if Is_Predefined_Dispatching_Operation (Prim) then\n-                  null;\n-\n-               elsif DT_Position (Prim) /= No_Uint then\n-                  null;\n-\n-               elsif Etype (DTC_Entity (Prim)) /= RTE (RE_Tag) then\n+               if DT_Position (Prim) /= No_Uint then\n                   null;\n \n-               --  Primitives covering interface primitives are\n-               --  handled later\n+               --  Primitives covering interface primitives are handled later\n \n                elsif Present (Abstract_Interface_Alias (Prim)) then\n                   null;\n@@ -4492,11 +4498,12 @@ package body Exp_Disp is\n \n                   loop\n                      Nb_Prim := Nb_Prim + 1;\n+                     pragma Assert (Nb_Prim <= Count_Prim);\n                      exit when not Fixed_Prim (Nb_Prim);\n                   end loop;\n \n                   Set_DT_Position (Prim, UI_From_Int (Nb_Prim));\n-                  Fixed_Prim (Nb_Prim) := True;\n+                  Set_Fixed_Prim (Nb_Prim);\n                end if;\n \n                Next_Elmt (Prim_Elmt);\n@@ -4512,12 +4519,16 @@ package body Exp_Disp is\n             Prim := Node (Prim_Elmt);\n \n             if DT_Position (Prim) = No_Uint\n-               and then Present (Abstract_Interface_Alias (Prim))\n+              and then Present (Abstract_Interface_Alias (Prim))\n             then\n+               pragma Assert (Present (Alias (Prim))\n+                 and then Find_Dispatching_Type (Alias (Prim)) = Typ);\n+\n                --  Check if this entry will be placed in the primary DT\n \n-               if Etype (DTC_Entity (Abstract_Interface_Alias (Prim)))\n-                    = RTE (RE_Tag)\n+               if Is_Ancestor (Find_Dispatching_Type\n+                                 (Abstract_Interface_Alias (Prim)),\n+                               Typ)\n                then\n                   pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n                   Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n@@ -4527,9 +4538,8 @@ package body Exp_Disp is\n                else\n                   pragma Assert\n                     (DT_Position (Abstract_Interface_Alias (Prim)) /= No_Uint);\n-\n                   Set_DT_Position (Prim,\n-                     DT_Position (Abstract_Interface_Alias (Prim)));\n+                    DT_Position (Abstract_Interface_Alias (Prim)));\n                end if;\n             end if;\n \n@@ -4562,7 +4572,8 @@ package body Exp_Disp is\n \n             --  Calculate real size of the dispatch table\n \n-            if not Is_Predefined_Dispatching_Operation (Prim)\n+            if not (Is_Predefined_Dispatching_Operation (Prim)\n+                      or else Is_Predefined_Dispatching_Alias (Prim))\n               and then UI_To_Int (DT_Position (Prim)) > DT_Length\n             then\n                DT_Length := UI_To_Int (DT_Position (Prim));\n@@ -4571,7 +4582,9 @@ package body Exp_Disp is\n             --  Ensure that the asignated position to non-predefined\n             --  dispatching operations in the dispatch table is correct.\n \n-            if not Is_Predefined_Dispatching_Operation (Prim) then\n+            if not (Is_Predefined_Dispatching_Operation (Prim)\n+                      or else Is_Predefined_Dispatching_Alias (Prim))\n+            then\n                Validate_Position (Prim);\n             end if;\n \n@@ -4587,12 +4600,16 @@ package body Exp_Disp is\n             --  for a visible abstract type, because it could never be over-\n             --  ridden. For explicit declarations this is checked at the\n             --  point of declaration, but for inherited operations it must\n-            --  be done when building the dispatch table. Input is excluded\n-            --  because\n+            --  be done when building the dispatch table.\n+\n+            --  Ada 2005 (AI-251): Hidden entities associated with abstract\n+            --  interface primitives are not taken into account because the\n+            --  check is done with the aliased primitive.\n \n             if Is_Abstract (Typ)\n               and then Is_Abstract (Prim)\n               and then Present (Alias (Prim))\n+              and then not Present (Abstract_Interface_Alias (Prim))\n               and then Is_Derived_Type (Typ)\n               and then In_Private_Part (Current_Scope)\n               and then\n@@ -4847,6 +4864,14 @@ package body Exp_Disp is\n \n          if Is_Abstract (Prim) then\n             Write_Str (\" is abstract;\");\n+\n+         --  Check if this is a null primitive\n+\n+         elsif Comes_From_Source (Prim)\n+           and then Ekind (Prim) = E_Procedure\n+           and then Null_Present (Parent (Prim))\n+         then\n+            Write_Str (\" is null;\");\n          end if;\n \n          Write_Eol;"}]}