{"sha": "30c931de07f8fcbe4ef3b550633c274fe7828975", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjOTMxZGUwN2Y4ZmNiZTRlZjNiNTUwNjMzYzI3NGZlNzgyODk3NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-03-23T07:53:31Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-03-23T07:53:31Z"}, "message": "re PR fortran/64952 (Missing temporary in assignment from elemental function)\n\n2015-03-23  Paul Thomas  <pault@gcc.gnu.org>\n\t    Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/64952\nfortran/\n\t* gfortran.h (struct symbol_attribute) : New field\n\t'array_outer_dependency'.\n\t* trans.h (struct gfc_ss_info): New field 'array_outer_dependency'.\n\t* module.c (enum ab_attribute): New value AB_ARRAY_OUTER_DEPENDENCY.\n\t(attr_bits): Append same value to initializer.\n\t(mio_symbol_attribute): Handle 'array_outer_dependency' attr\n\tin module read and write.\n\t* resolve.c (update_current_proc_outer_array_dependency): New function.\n\t(resolve_function, resolve_call): Add code to update current procedure's\n\t'array_outer_dependency' attribute.\n\t(resolve_variable): Mark current procedure with attribute\n\tarray_outer_dependency if the variable is an array coming from outside\n\tthe current namespace.\n\t(resolve_fl_procedure): Mark a procedure without body with attribute\n\t'array_outer_dependency'.\n\t* trans-array.c (gfc_conv_resolve_dependencies): If any ss is\n\tmarked as 'array_outer_dependency' generate a temporary.\n\t(gfc_walk_function_expr): If the function may reference external arrays,\n\tmark the head gfc_ss with flag 'array_outer_dependency'.\ntestsuite/\n\t* gfortran.dg/elemental_dependency_4.f90: New.\n\t* gfortran.dg/elemental_dependency_5.f90: New.\n\n\nCo-Authored-By: Mikael Morin <mikael@gcc.gnu.org>\n\nFrom-SVN: r221586", "tree": {"sha": "59f7139307675a6ddd88e7d11153ba3460ac0019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59f7139307675a6ddd88e7d11153ba3460ac0019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c931de07f8fcbe4ef3b550633c274fe7828975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c931de07f8fcbe4ef3b550633c274fe7828975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c931de07f8fcbe4ef3b550633c274fe7828975", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c931de07f8fcbe4ef3b550633c274fe7828975/comments", "author": null, "committer": null, "parents": [{"sha": "af3eb1106883dffe6b1164070a00ad0c14df1146", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3eb1106883dffe6b1164070a00ad0c14df1146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af3eb1106883dffe6b1164070a00ad0c14df1146"}], "stats": {"total": 353, "additions": 351, "deletions": 2}, "files": [{"sha": "473d3192a92a06e20a1c9ae625ccec5d36a0aa98", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -1,3 +1,27 @@\n+2015-03-23  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/64952\n+\t* gfortran.h (struct symbol_attribute) : New field\n+\t'array_outer_dependency'.\n+\t* trans.h (struct gfc_ss_info): New field 'array_outer_dependency'.\n+\t* module.c (enum ab_attribute): New value AB_ARRAY_OUTER_DEPENDENCY.\n+\t(attr_bits): Append same value to initializer.\n+\t(mio_symbol_attribute): Handle 'array_outer_dependency' attr\n+\tin module read and write.\n+\t* resolve.c (update_current_proc_outer_array_dependency): New function.\n+\t(resolve_function, resolve_call): Add code to update current procedure's\n+\t'array_outer_dependency' attribute.\n+\t(resolve_variable): Mark current procedure with attribute\n+\tarray_outer_dependency if the variable is an array coming from outside\n+\tthe current namespace.\n+\t(resolve_fl_procedure): Mark a procedure without body with attribute\n+\t'array_outer_dependency'.\n+\t* trans-array.c (gfc_conv_resolve_dependencies): If any ss is\n+\tmarked as 'array_outer_dependency' generate a temporary.\n+\t(gfc_walk_function_expr): If the function may reference external arrays,\n+\tmark the head gfc_ss with flag 'array_outer_dependency'.\n+\n 2015-03-22 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/59513"}, {"sha": "9be20109bf6dd4cbeee4ce0a73f71c94dd7046b2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -789,6 +789,13 @@ typedef struct\n      cannot alias.  Note that this is zero for PURE procedures.  */\n   unsigned implicit_pure:1;\n \n+  /* This is set for a procedure that contains expressions referencing\n+     arrays coming from outside its namespace.  \n+     This is used to force the creation of a temporary when the LHS of\n+     an array assignment may be used by an elemental procedure appearing\n+     on the RHS.  */\n+  unsigned array_outer_dependency:1;\n+\n   /* This is set if the subroutine doesn't return.  Currently, this\n      is only possible for intrinsic subroutines.  */\n   unsigned noreturn:1;"}, {"sha": "1abfc46d7a5e661016da505afccbe6f12be7f4e3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -1893,7 +1893,8 @@ typedef enum\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n-  AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY, AB_OMP_DECLARE_TARGET\n+  AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY, AB_OMP_DECLARE_TARGET,\n+  AB_ARRAY_OUTER_DEPENDENCY\n }\n ab_attribute;\n \n@@ -1949,6 +1950,7 @@ static const mstring attr_bits[] =\n     minit (\"IMPLICIT_PURE\", AB_IMPLICIT_PURE),\n     minit (\"UNLIMITED_POLY\", AB_UNLIMITED_POLY),\n     minit (\"OMP_DECLARE_TARGET\", AB_OMP_DECLARE_TARGET),\n+    minit (\"ARRAY_OUTER_DEPENDENCY\", AB_ARRAY_OUTER_DEPENDENCY),\n     minit (NULL, -1)\n };\n \n@@ -2129,6 +2131,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_VTAB, attr_bits);\n       if (attr->omp_declare_target)\n \tMIO_NAME (ab_attribute) (AB_OMP_DECLARE_TARGET, attr_bits);\n+      if (attr->array_outer_dependency)\n+\tMIO_NAME (ab_attribute) (AB_ARRAY_OUTER_DEPENDENCY, attr_bits);\n \n       mio_rparen ();\n \n@@ -2295,6 +2299,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_OMP_DECLARE_TARGET:\n \t      attr->omp_declare_target = 1;\n \t      break;\n+\t    case AB_ARRAY_OUTER_DEPENDENCY:\n+\t      attr->array_outer_dependency =1;\n+\t      break;\n \t    }\n \t}\n     }"}, {"sha": "2a24dfd8edab63c3fe2beb57a4d7c35fcb064bf2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -2866,6 +2866,32 @@ static bool check_pure_function (gfc_expr *e)\n }\n \n \n+/* Update current procedure's array_outer_dependency flag, considering\n+   a call to procedure SYM.  */\n+\n+static void\n+update_current_proc_array_outer_dependency (gfc_symbol *sym)\n+{\n+  /* Check to see if this is a sibling function that has not yet\n+     been resolved.  */\n+  gfc_namespace *sibling = gfc_current_ns->sibling;\n+  for (; sibling; sibling = sibling->sibling)\n+    {\n+      if (sibling->proc_name == sym)\n+\t{\n+\t  gfc_resolve (sibling);\n+\t  break;\n+\t}\n+    }\n+\n+  /* If SYM has references to outer arrays, so has the procedure calling\n+     SYM.  If SYM is a procedure pointer, we can assume the worst.  */\n+  if (sym->attr.array_outer_dependency\n+      || sym->attr.proc_pointer)\n+    gfc_current_ns->proc_name->attr.array_outer_dependency = 1;\n+}\n+\n+\n /* Resolve a function call, which means resolving the arguments, then figuring\n    out which entity the name refers to.  */\n \n@@ -3090,6 +3116,17 @@ resolve_function (gfc_expr *expr)\n \texpr->ts = expr->symtree->n.sym->result->ts;\n     }\n \n+  if (!expr->ref && !expr->value.function.isym)\n+    {\n+      if (expr->value.function.esym)\n+\tupdate_current_proc_array_outer_dependency (expr->value.function.esym);\n+      else\n+\tupdate_current_proc_array_outer_dependency (sym);\n+    }\n+  else if (expr->ref)\n+    /* typebound procedure: Assume the worst.  */\n+    gfc_current_ns->proc_name->attr.array_outer_dependency = 1;\n+\n   return t;\n }\n \n@@ -3427,6 +3464,12 @@ resolve_call (gfc_code *c)\n   if (!resolve_elemental_actual (NULL, c))\n     return false;\n \n+  if (!c->expr1)\n+    update_current_proc_array_outer_dependency (csym);\n+  else\n+    /* Typebound procedure: Assume the worst.  */\n+    gfc_current_ns->proc_name->attr.array_outer_dependency = 1;\n+\n   return t;\n }\n \n@@ -5058,6 +5101,13 @@ resolve_variable (gfc_expr *e)\n \t\t    && gfc_current_ns->parent->parent == sym->ns)))\n     sym->attr.host_assoc = 1;\n \n+  if (gfc_current_ns->proc_name\n+      && sym->attr.dimension\n+      && (sym->ns != gfc_current_ns\n+\t  || sym->attr.use_assoc\n+\t  || sym->attr.in_common))\n+    gfc_current_ns->proc_name->attr.array_outer_dependency = 1;\n+\n resolve_procedure:\n   if (t && !resolve_procedure_expression (e))\n     t = false;\n@@ -11494,6 +11544,11 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t}\n     }\n \n+  /* Assume that a procedure whose body is not known has references\n+     to external arrays.  */\n+  if (sym->attr.if_source != IFSRC_DECL)\n+    sym->attr.array_outer_dependency = 1;\n+\n   return true;\n }\n "}, {"sha": "0dbfdaab1b228fdb833b9150f3ea5c1b1f6fcd5d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -4391,6 +4391,12 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n     {\n       ss_expr = ss->info->expr;\n \n+      if (ss->info->array_outer_dependency)\n+\t{\n+\t  nDepend = 1;\n+\t  break;\n+\t}\n+\n       if (ss->info->type != GFC_SS_SECTION)\n \t{\n \t  if (flag_realloc_lhs\n@@ -9096,9 +9102,20 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n   /* Walk the parameters of an elemental function.  For now we always pass\n      by reference.  */\n   if (sym->attr.elemental || (comp && comp->attr.elemental))\n-    return gfc_walk_elemental_function_args (ss, expr->value.function.actual,\n+    {\n+      gfc_ss *old_ss = ss;\n+\n+      ss = gfc_walk_elemental_function_args (old_ss,\n+\t\t\t\t\t     expr->value.function.actual,\n \t\t\t\t\t     gfc_get_proc_ifc_for_expr (expr),\n \t\t\t\t\t     GFC_SS_REFERENCE);\n+      if (ss != old_ss\n+\t  && (comp\n+\t      || sym->attr.proc_pointer\n+\t      || sym->attr.if_source != IFSRC_DECL\n+\t      || sym->attr.array_outer_dependency))\n+\tss->info->array_outer_dependency = 1;\n+    }\n \n   /* Scalar functions are OK as these are evaluated outside the scalarization\n      loop.  Pass back and let the caller deal with it.  */"}, {"sha": "be1136382ae1ec9fac153a07562c05706fd89c9b", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -226,6 +226,10 @@ typedef struct gfc_ss_info\n   /* Suppresses precalculation of scalars in WHERE assignments.  */\n   unsigned where:1;\n \n+  /* This set for an elemental function that contains expressions for\n+     external arrays, thereby triggering creation of a temporary.  */\n+  unsigned array_outer_dependency:1;\n+\n   /* Tells whether the SS is for an actual argument which can be a NULL\n      reference.  In other words, the associated dummy argument is OPTIONAL.\n      Used to handle elemental procedures.  */"}, {"sha": "50d869112e2f0551e4bb2106a8a9dab351a7548f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -1,3 +1,10 @@\n+2015-03-23  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/64952\n+\t* gfortran.dg/elemental_dependency_4.f90: New.\n+\t* gfortran.dg/elemental_dependency_5.f90: New.\n+\n 2015-03-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65475"}, {"sha": "fc15e6418122720a2c3ad0b3c4fae4ff38316e38", "filename": "gcc/testsuite/gfortran.dg/elemental_dependency_4.f90", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_4.f90?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -0,0 +1,167 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! Tests the fix for PR64952, in which the assignment to 'array' should\n+! have generated a temporary because of the references to the lhs in\n+! the function 'Fred'.\n+!\n+! Original report, involving function 'Nick'\n+! Contributed by Nick Maclaren  <nmm1@cam.ac.uk> on clf\n+! https://groups.google.com/forum/#!topic/comp.lang.fortran/TvVY5j3GPmg\n+!\n+! Other tests are due to Mikael Morin  <mikael.morin@sfr.fr>\n+!\n+MODULE M\n+    INTEGER, PRIVATE :: i\n+    REAL :: arraym(5) = (/ (i+0.0, i = 1,5) /)\n+CONTAINS\n+    ELEMENTAL FUNCTION Bill (n, x)\n+        REAL :: Bill\n+        INTEGER, INTENT(IN) :: n\n+        REAL, INTENT(IN) :: x\n+        Bill = x+SUM(arraym(:n-1))+SUM(arraym(n+1:))\n+    END FUNCTION Bill\n+\n+    ELEMENTAL FUNCTION Charles (x)\n+        REAL :: Charles\n+        REAL, INTENT(IN) :: x\n+        Charles = x\n+    END FUNCTION Charles\n+END MODULE M\n+\n+ELEMENTAL FUNCTION Peter(n, x)\n+    USE M\n+    REAL :: Peter\n+    INTEGER, INTENT(IN) :: n\n+    REAL, INTENT(IN) :: x\n+    Peter = Bill(n, x)\n+END FUNCTION Peter\n+\n+PROGRAM Main\n+    use M\n+    INTEGER :: i, index(5) = (/ (i, i = 1,5) /)\n+    REAL :: array(5) = (/ (i+0.0, i = 1,5) /)\n+\n+    INTERFACE\n+        ELEMENTAL FUNCTION Peter(n, x)\n+            REAL :: Peter\n+            INTEGER, INTENT(IN) :: n\n+            REAL, INTENT(IN) :: x\n+        END FUNCTION Peter\n+    END INTERFACE\n+\n+    PROCEDURE(Robert2), POINTER :: missme => Null()\n+\n+    ! Original testcase\n+    array = Nick(index,array)\n+    If (any (array .ne. array(1))) call abort\n+\n+    array = (/ (i+0.0, i = 1,5) /)\n+    ! This should not create a temporary\n+    array = Charles(array)\n+    If (any (array .ne. index)) call abort\n+    ! { dg-final { scan-tree-dump-times \"array\\\\\\[\\[^\\\\\\]\\]*\\\\\\]\\\\s*=\\\\s*charles\\\\s*\\\\(&array\\\\\\[\\[^\\\\\\]\\]*\\\\\\]\\\\);\" 1 \"original\" } }\n+\n+    ! Check use association of the function works correctly.\n+    arraym = Bill(index,arraym)\n+    if (any (arraym .ne. arraym(1))) call abort\n+\n+    ! Check siblings interact correctly.\n+    array = (/ (i+0.0, i = 1,5) /)\n+    array = Henry(index)\n+    if (any (array .ne. array(1))) call abort\n+\n+    array = (/ (i+0.0, i = 1,5) /)\n+    ! This should not create a temporary\n+    array = index + Henry2(0) - array\n+    ! { dg-final { scan-tree-dump-times \"array\\\\\\[\\[^\\\\\\]\\]*\\\\\\]\\\\s*=\\\\s*\\\\(\\\\(real\\\\(kind=4\\\\)\\\\)\\\\s*index\\\\\\[\\[^\\\\\\]\\]*\\\\\\]\\\\s*\\\\+\\\\s*D.\\\\d*\\\\)\\\\s*-\\\\s*array\\\\\\[\\[^\\\\\\]\\]*\\\\\\];\" 1 \"original\" } }\n+    if (any (array .ne. 15.0)) call abort\n+\n+    arraym = (/ (i+0.0, i = 1,5) /)\n+    arraym = Peter(index, arraym)\n+    if (any (arraym .ne. 15.0)) call abort\n+\n+    array = (/ (i+0.0, i = 1,5) /)\n+    array = Robert(index)\n+    if (any (arraym .ne. 15.0)) call abort\n+\n+    missme => Robert2\n+    array = (/ (i+0.0, i = 1,5) /)\n+    array = David(index)\n+    if (any (arraym .ne. 15.0)) call abort\n+\n+    array = (/ (i+0.0, i = 1,5) /)\n+    array = James(index)\n+    if (any (arraym .ne. 15.0)) call abort\n+\n+    array = (/ (i+0.0, i = 1,5) /)\n+    array = Romeo(index)\n+    if (any (arraym .ne. 15.0)) call abort\n+\n+CONTAINS\n+    ELEMENTAL FUNCTION Nick (n, x)\n+        REAL :: Nick\n+        INTEGER, INTENT(IN) :: n\n+        REAL, INTENT(IN) :: x\n+        Nick = x+SUM(array(:n-1))+SUM(array(n+1:))\n+    END FUNCTION Nick\n+\n+! Note that the inverse order of Henry and Henry2 is trivial.\n+! This way round, Henry2 has to be resolved before Henry can\n+! be marked as having an inherited external array reference.\n+    ELEMENTAL FUNCTION Henry2 (n)\n+        REAL :: Henry2\n+        INTEGER, INTENT(IN) :: n\n+        Henry2 = n + SUM(array(:n-1))+SUM(array(n+1:))\n+    END FUNCTION Henry2\n+\n+    ELEMENTAL FUNCTION Henry (n)\n+        REAL :: Henry\n+        INTEGER, INTENT(IN) :: n\n+        Henry = Henry2(n)\n+    END FUNCTION Henry\n+\n+    PURE FUNCTION Robert2(n)\n+        REAL :: Robert2\n+        INTEGER, INTENT(IN) :: n\n+        Robert2 = Henry(n)\n+    END FUNCTION Robert2\n+\n+    ELEMENTAL FUNCTION Robert(n)\n+        REAL :: Robert\n+        INTEGER, INTENT(IN) :: n\n+        Robert = Robert2(n)\n+    END FUNCTION Robert\n+\n+    ELEMENTAL FUNCTION David (n)\n+        REAL :: David\n+        INTEGER, INTENT(IN) :: n\n+        David = missme(n)\n+    END FUNCTION David\n+\n+    ELEMENTAL SUBROUTINE James2 (o, i)\n+        REAL, INTENT(OUT) :: o\n+        INTEGER, INTENT(IN) :: i\n+        o = Henry(i)\n+    END SUBROUTINE James2\n+\n+    ELEMENTAL FUNCTION James(n)\n+        REAL :: James\n+        INTEGER, INTENT(IN) :: n\n+        CALL James2(James, n)\n+    END FUNCTION James\n+\n+    FUNCTION Romeo2(n)\n+        REAL :: Romeo2\n+        INTEGER, INTENT(in) :: n\n+        Romeo2 = Henry(n)\n+    END FUNCTION Romeo2\n+\n+    IMPURE ELEMENTAL FUNCTION Romeo(n)\n+        REAL :: Romeo\n+        INTEGER, INTENT(IN) :: n\n+        Romeo = Romeo2(n)\n+    END FUNCTION Romeo\n+END PROGRAM Main\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "42e92692d02e2a48fcda06a52f616224ba9e6722", "filename": "gcc/testsuite/gfortran.dg/elemental_dependency_5.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c931de07f8fcbe4ef3b550633c274fe7828975/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_dependency_5.f90?ref=30c931de07f8fcbe4ef3b550633c274fe7828975", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR64952.\n+!\n+! Original report by Nick Maclaren  <nmm1@cam.ac.uk> on clf\n+! https://groups.google.com/forum/#!topic/comp.lang.fortran/TvVY5j3GPmg\n+! See elemental_dependency_4.f90\n+!\n+! This test contributed by Mikael Morin  <mikael.morin@sfr.fr>\n+!\n+MODULE M\n+    INTEGER, PRIVATE :: i\n+\n+    TYPE, ABSTRACT :: t\n+      REAL :: f\n+    CONTAINS\n+      PROCEDURE(Fred_ifc), DEFERRED, PASS :: tbp\n+    END TYPE t\n+    TYPE, EXTENDS(t) :: t2\n+    CONTAINS\n+      PROCEDURE :: tbp => Fred\n+    END TYPE t2\n+\n+    TYPE(t2) :: array(5) = (/ (t2(i+0.0), i = 1,5) /)\n+\n+    INTERFACE\n+        ELEMENTAL FUNCTION Fred_ifc (x, n)\n+            IMPORT\n+            REAL :: Fred\n+            CLASS(T), INTENT(IN) :: x\n+            INTEGER, INTENT(IN) :: n\n+        END FUNCTION Fred_ifc\n+    END INTERFACE\n+\n+CONTAINS\n+    ELEMENTAL FUNCTION Fred (x, n)\n+        REAL :: Fred\n+        CLASS(T2), INTENT(IN) :: x\n+        INTEGER, INTENT(IN) :: n\n+        Fred = x%f+SUM(array(:n-1)%f)+SUM(array(n+1:)%f)\n+     END FUNCTION Fred\n+END MODULE M\n+\n+PROGRAM Main\n+    USE M\n+    INTEGER :: i, index(5) = (/ (i, i = 1,5) /)\n+    \n+    array%f = array%tbp(index)\n+    if (any (array%f .ne. array(1)%f)) call abort\n+\n+    array%f = index\n+    call Jack(array)\n+  CONTAINS\n+    SUBROUTINE Jack(dummy)\n+        CLASS(t) :: dummy(:)\n+        dummy%f = dummy%tbp(index)\n+        !print *, dummy%f\n+        if (any (dummy%f .ne. 15.0)) call abort\n+    END SUBROUTINE\n+END PROGRAM Main\n+"}]}