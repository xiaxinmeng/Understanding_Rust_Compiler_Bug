{"sha": "7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q0ZDRkMjJlNDU2ZmM5YTQ4MWJjNjE2NWE4N2Y3ZGNhNTBhYzkwZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T05:08:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T05:08:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r563", "tree": {"sha": "2f7996334519579e09af1ba11484f96e1f79d825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f7996334519579e09af1ba11484f96e1f79d825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e/comments", "author": null, "committer": null, "parents": [{"sha": "333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a"}], "stats": {"total": 59, "additions": 56, "deletions": 3}, "files": [{"sha": "4b86aa1fa41fd71842dd577a42e276f4e8b8deda", "filename": "gcc/fold-const.c", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "patch": "@@ -738,6 +738,46 @@ target_isinf (x)\n     }\n }\n \n+/* Check whether an IEEE double precision number is a NaN.  */\n+\n+int\n+target_isnan (x)\n+     REAL_VALUE_TYPE x;\n+{\n+  /* The IEEE 64-bit double format.  */\n+  union {\n+    REAL_VALUE_TYPE d;\n+    struct {\n+      unsigned sign      :  1;\n+      unsigned exponent  : 11;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } little_endian;\n+    struct {\n+      unsigned mantissa2;\n+      unsigned mantissa1 : 20;\n+      unsigned exponent  : 11;\n+      unsigned sign      :  1;\n+    } big_endian;    \n+  } u;\n+\n+  u.d = dconstm1;\n+  if (u.big_endian.sign == 1)\n+    {\n+      u.d = x;\n+      return (u.big_endian.exponent == 2047\n+\t      && (u.big_endian.mantissa1 != 0\n+\t\t  || u.big_endian.mantissa2 != 0));\n+    }\n+  else\n+    {\n+      u.d = x;\n+      return (u.little_endian.exponent == 2047\n+\t      && (u.little_endian.mantissa1 != 0\n+\t\t  || u.little_endian.mantissa2 != 0));\n+    }\n+}\n+\n /* Check for minus zero in an IEEE double precision number.  */\n \n int\n@@ -762,6 +802,15 @@ target_isinf (x)\n   return 0;\n }\n \n+/* Let's assume other float formats don't have NaNs.\n+   (This can be overridden by redefining REAL_VALUE_ISNAN.)  */\n+\n+target_isnan (x)\n+     REAL_VALUE_TYPE x;\n+{\n+  return 0;\n+}\n+\n /* Let's assume other float formats don't have minus zero.\n    (This can be overridden by redefining REAL_VALUE_MINUS_ZERO.)  */\n \n@@ -1408,9 +1457,13 @@ operand_equal_p (arg0, arg1, only_const)\n       && TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1))\n     return 1;\n \n+  /* Detect when real constants are equal.\n+     But reject weird values because we can't be sure what to do with them.  */\n   if (TREE_CODE (arg0) == TREE_CODE (arg1)\n       && TREE_CODE (arg0) == REAL_CST\n-      && REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1)))\n+      && REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1))\n+      && !REAL_VALUE_ISINF (TREE_REAL_CST (arg0))\n+      && !REAL_VALUE_ISNAN (TREE_REAL_CST (arg0)))\n     return 1;\n \n   if (only_const)\n@@ -1562,8 +1615,8 @@ invert_truthvalue (arg)\n \n   /* For floating-point comparisons, it isn't safe to invert the condition.\n      So just enclose a TRUTH_NOT_EXPR around what we have.  */\n-  if (TREE_CODE (type) == REAL_TYPE\n-      && TREE_CODE_CLASS (TREE_CODE (arg)) == '<')\n+  if (TREE_CODE_CLASS (TREE_CODE (arg)) == '<'\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REAL_TYPE)\n     return build1 (TRUTH_NOT_EXPR, type, arg);\n \n   switch (TREE_CODE (arg))"}]}