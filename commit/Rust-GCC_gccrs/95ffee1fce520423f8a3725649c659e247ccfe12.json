{"sha": "95ffee1fce520423f8a3725649c659e247ccfe12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmZmVlMWZjZTUyMDQyM2Y4YTM3MjU2NDljNjU5ZTI0N2NjZmUxMg==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2012-05-22T09:06:55Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2012-05-22T09:06:55Z"}, "message": "re PR target/53334 (ICE in extract_insn, at recog.c:2131)\n\nFix PR target/53334\n\n\n2012-05-22  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n\n\tPR target/53334\n\t* config/arm/arm-protos.h (arm_validize_comparison): Declare.\n\t* config/arm/arm.c (arm_validize_comparison): Define.\n\t* config/arm/arm.md (\"cbranchsi4\"): Cleanup expansion and use\n\tarm_validize_comparison.\n\t(\"cbranchdi4\"): Likewise.\n\t(\"cstoredi4\"): Likewise.\n\t(\"movsicc\"): Likewise.\n\t(\"movsfcc\"): Likewise.\n\t(\"movdfcc\"): Likewise.\n\nFrom-SVN: r187761", "tree": {"sha": "de16055277b7b505489b96f8ea473e055fc1ec5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de16055277b7b505489b96f8ea473e055fc1ec5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ffee1fce520423f8a3725649c659e247ccfe12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ffee1fce520423f8a3725649c659e247ccfe12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ffee1fce520423f8a3725649c659e247ccfe12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ffee1fce520423f8a3725649c659e247ccfe12/comments", "author": null, "committer": null, "parents": [{"sha": "7c2dbbdc486d717a674a7ec693236b91aff280cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c2dbbdc486d717a674a7ec693236b91aff280cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c2dbbdc486d717a674a7ec693236b91aff280cd"}], "stats": {"total": 155, "additions": 90, "deletions": 65}, "files": [{"sha": "496bb5fdc280177c75c925f5bdc5a12040bc8b97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95ffee1fce520423f8a3725649c659e247ccfe12", "patch": "@@ -1,7 +1,20 @@\n+2012-05-22  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n+\n+\tPR target/53334\n+\t* config/arm/arm-protos.h (arm_validize_comparison): Declare.\n+\t* config/arm/arm.c (arm_validize_comparison): Define.\n+\t* config/arm/arm.md (\"cbranchsi4\"): Cleanup expansion and use\n+\tarm_validize_comparison.\n+\t(\"cbranchdi4\"): Likewise.\n+\t(\"cstoredi4\"): Likewise.\n+\t(\"movsicc\"): Likewise.\n+\t(\"movsfcc\"): Likewise.\n+\t(\"movdfcc\"): Likewise.\n+\n 2012-05-22  Dimitrios Apostolou  <jimis@gmx.net>\n \n \t* df-scan.c (df_scan_alloc): Round up allocation pools size, reduce\n-\tthe mw_reg_pool size. \n+\tthe mw_reg_pool size.\n \n 2012-05-22  Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "4e6d7bbc67bf9ae4ddcddb9e3e98a5a61340db80", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=95ffee1fce520423f8a3725649c659e247ccfe12", "patch": "@@ -248,6 +248,7 @@ extern int vfp3_const_double_for_fract_bits (rtx);\n \n extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n \t\t\t\t\t   rtx);\n+extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n #endif /* RTX_CODE */\n \n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);"}, {"sha": "7a9819705e5b2e4748fd4613beeacc929783ff01", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=95ffee1fce520423f8a3725649c659e247ccfe12", "patch": "@@ -26185,4 +26185,54 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n   #undef BRANCH\n }\n \n+\n+/* Returns true if a valid comparison operation and makes \n+   the operands in a form that is valid.  */\n+bool\n+arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n+{\n+  enum rtx_code code = GET_CODE (*comparison);\n+  enum rtx_code canonical_code;\n+  enum machine_mode mode = (GET_MODE (*op1) == VOIDmode) \n+    ? GET_MODE (*op2) : GET_MODE (*op1);\n+\n+  gcc_assert (GET_MODE (*op1) != VOIDmode || GET_MODE (*op2) != VOIDmode);\n+\n+  if (code == UNEQ || code == LTGT)\n+    return false;\n+\n+  canonical_code = arm_canonicalize_comparison (code, op1, op2);\n+  PUT_CODE (*comparison, canonical_code);\n+\n+  switch (mode)\n+    {\n+    case SImode:\n+      if (!arm_add_operand (*op1, mode))\n+\t*op1 = force_reg (mode, *op1);\n+      if (!arm_add_operand (*op2, mode))\n+\t*op2 = force_reg (mode, *op2);\n+      return true;\n+\n+    case DImode:\n+      if (!cmpdi_operand (*op1, mode))\n+\t*op1 = force_reg (mode, *op1);\n+      if (!cmpdi_operand (*op2, mode))\n+\t*op2 = force_reg (mode, *op2);\n+      return true;\n+      \n+    case SFmode:\n+    case DFmode:\n+      if (!arm_float_compare_operand (*op1, mode))\n+\t*op1 = force_reg (mode, *op1);\n+      if (!arm_float_compare_operand (*op2, mode))\n+\t*op2 = force_reg (mode, *op2);\n+      return true;\n+    default:\n+      break;\n+    }\n+  \n+  return false;\n+\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "bbf63805c930fe45f9e88b3401c24f8b1fae5d21", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ffee1fce520423f8a3725649c659e247ccfe12/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=95ffee1fce520423f8a3725649c659e247ccfe12", "patch": "@@ -6977,12 +6977,12 @@\n \t        (match_operand:SI 2 \"nonmemory_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n-  \"TARGET_THUMB1 || TARGET_32BIT\"\n+  \"TARGET_EITHER\"\n   \"\n   if (!TARGET_THUMB1)\n     {\n-      if (!arm_add_operand (operands[2], SImode))\n-\toperands[2] = force_reg (SImode, operands[2]);\n+      if (!arm_validize_comparison (&operands[0], &operands[1], &operands[2]))\n+        FAIL;\n       emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n \t\t\t\t      operands[3]));\n       DONE;\n@@ -7054,33 +7054,13 @@\n \t      (pc)))]\n   \"TARGET_32BIT\"\n   \"{\n-     rtx swap = NULL_RTX;\n-     enum rtx_code code = GET_CODE (operands[0]);\n-\n      /* We should not have two constants.  */\n      gcc_assert (GET_MODE (operands[1]) == DImode\n \t\t || GET_MODE (operands[2]) == DImode);\n \n-    /* Flip unimplemented DImode comparisons to a form that\n-       arm_gen_compare_reg can handle.  */\n-     switch (code)\n-     {\n-     case GT:\n-       swap = gen_rtx_LT (VOIDmode, operands[2], operands[1]); break;\n-     case LE:\n-       swap = gen_rtx_GE (VOIDmode, operands[2], operands[1]); break;\n-     case GTU:\n-       swap = gen_rtx_LTU (VOIDmode, operands[2], operands[1]); break;\n-     case LEU:\n-       swap = gen_rtx_GEU (VOIDmode, operands[2], operands[1]); break;\n-     default:\n-       break;\n-     }\n-     if (swap)\n-       emit_jump_insn (gen_cbranch_cc (swap, operands[2], operands[1],\n-                                       operands[3]));\n-     else\n-       emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+     if (!arm_validize_comparison (&operands[0], &operands[1], &operands[2]))\t\t \n+       FAIL;\n+     emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n \t\t\t\t       operands[3]));\n      DONE;\n    }\"\n@@ -8065,33 +8045,15 @@\n \t  (match_operand:DI 3 \"cmpdi_operand\" \"\")]))]\n   \"TARGET_32BIT\"\n   \"{\n-     rtx swap = NULL_RTX;\n-     enum rtx_code code = GET_CODE (operands[1]);\n-\n      /* We should not have two constants.  */\n      gcc_assert (GET_MODE (operands[2]) == DImode\n \t\t || GET_MODE (operands[3]) == DImode);\n \n-    /* Flip unimplemented DImode comparisons to a form that\n-       arm_gen_compare_reg can handle.  */\n-     switch (code)\n-     {\n-     case GT:\n-       swap = gen_rtx_LT (VOIDmode, operands[3], operands[2]); break;\n-     case LE:\n-       swap = gen_rtx_GE (VOIDmode, operands[3], operands[2]); break;\n-     case GTU:\n-       swap = gen_rtx_LTU (VOIDmode, operands[3], operands[2]); break;\n-     case LEU:\n-       swap = gen_rtx_GEU (VOIDmode, operands[3], operands[2]); break;\n-     default:\n-       break;\n-     }\n-     if (swap)\n-       emit_insn (gen_cstore_cc (operands[0], swap, operands[3],\n-\t\t      \t         operands[2]));\n-     else\n-       emit_insn (gen_cstore_cc (operands[0], operands[1], operands[2],\n+     if (!arm_validize_comparison (&operands[1],\n+     \t\t\t\t   &operands[2],\n+\t\t\t\t   &operands[3]))\n+       FAIL;\n+     emit_insn (gen_cstore_cc (operands[0], operands[1], operands[2],\n \t\t      \t         operands[3]));\n      DONE;\n    }\"\n@@ -8186,12 +8148,14 @@\n   \"TARGET_32BIT\"\n   \"\n   {\n-    enum rtx_code code = GET_CODE (operands[1]);\n+    enum rtx_code code;\n     rtx ccreg;\n \n-    if (code == UNEQ || code == LTGT)\n+    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0), \n+       \t\t\t\t  &XEXP (operands[1], 1)))\n       FAIL;\n-\n+    \n+    code = GET_CODE (operands[1]);\n     ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n \t\t\t\t XEXP (operands[1], 1), NULL_RTX);\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n@@ -8202,22 +8166,18 @@\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"expandable_comparison_operator\" \"\")\n \t\t\t (match_operand:SF 2 \"s_register_operand\" \"\")\n-\t\t\t (match_operand:SF 3 \"nonmemory_operand\" \"\")))]\n+\t\t\t (match_operand:SF 3 \"arm_float_add_operand\" \"\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\n   {\n     enum rtx_code code = GET_CODE (operands[1]);\n     rtx ccreg;\n \n-    if (code == UNEQ || code == LTGT)\n-      FAIL;\n-\n-    /* When compiling for SOFT_FLOAT, ensure both arms are in registers. \n-       Otherwise, ensure it is a valid FP add operand */\n-    if ((!(TARGET_HARD_FLOAT && TARGET_FPA))\n-        || (!arm_float_add_operand (operands[3], SFmode)))\n-      operands[3] = force_reg (SFmode, operands[3]);\n+    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0), \n+       \t\t\t\t  &XEXP (operands[1], 1)))\n+       FAIL;\n \n+    code = GET_CODE (operands[1]);\n     ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n \t\t\t\t XEXP (operands[1], 1), NULL_RTX);\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n@@ -8235,9 +8195,10 @@\n     enum rtx_code code = GET_CODE (operands[1]);\n     rtx ccreg;\n \n-    if (code == UNEQ || code == LTGT)\n-      FAIL;\n-\n+    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0), \n+       \t\t\t\t  &XEXP (operands[1], 1)))\n+       FAIL;\n+    code = GET_CODE (operands[1]);\n     ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n \t\t\t\t XEXP (operands[1], 1), NULL_RTX);\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);"}]}