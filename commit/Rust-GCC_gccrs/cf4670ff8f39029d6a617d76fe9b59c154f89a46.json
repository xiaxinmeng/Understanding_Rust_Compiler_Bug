{"sha": "cf4670ff8f39029d6a617d76fe9b59c154f89a46", "node_id": "C_kwDOANBUbNoAKGNmNDY3MGZmOGYzOTAyOWQ2YTYxN2Q3NmZlOWI1OWMxNTRmODlhNDY", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-18T06:35:28Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-18T06:35:28Z"}, "message": "Merge commit '9dcfee4ef1a165b7fe525d71fc090a1bcae550cd' into HEAD", "tree": {"sha": "3f8469a01472a086ed046c73f933fc4cf798af67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f8469a01472a086ed046c73f933fc4cf798af67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf4670ff8f39029d6a617d76fe9b59c154f89a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4670ff8f39029d6a617d76fe9b59c154f89a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf4670ff8f39029d6a617d76fe9b59c154f89a46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4670ff8f39029d6a617d76fe9b59c154f89a46/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5752164328fb2f101a88c6d298dd517436a140ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5752164328fb2f101a88c6d298dd517436a140ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5752164328fb2f101a88c6d298dd517436a140ba"}, {"sha": "9dcfee4ef1a165b7fe525d71fc090a1bcae550cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcfee4ef1a165b7fe525d71fc090a1bcae550cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dcfee4ef1a165b7fe525d71fc090a1bcae550cd"}], "stats": {"total": 1170428, "additions": 1151689, "deletions": 18739}, "files": [{"sha": "b26e482eb543adae14c588335c0043525bb469cb", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,7 @@\n+2023-02-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* MAINTAINERS: I'm stepping down from my positions.\n+\n 2023-01-10  Philip Herron  <herron.philip@googlemail.com>\n \n \t* MAINTAINERS: Add Philip Herron as Rust front-end maintainer"}, {"sha": "a61d3ae06df526adbe5dfd79a4cac4a500f52203", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -230,7 +230,6 @@ docstring relicensing\tGerald Pfeifer\t\t<gerald@pfeifer.com>\n docstring relicensing\tJoseph Myers\t\t<joseph@codesourcery.com>\n predict.def\t\tJan Hubicka\t\t<hubicka@ucw.cz>\n gcov\t\t\tJan Hubicka\t\t<hubicka@ucw.cz>\n-gcov\t\t\tMartin Liska\t\t<mliska@suse.cz>\n gcov\t\t\tNathan Sidwell\t\t<nathan@acm.org>\n option handling\t\tJoseph Myers\t\t<joseph@codesourcery.com>\n middle-end\t\tJeff Law\t\t<jeffreyalaw@gmail.com>\n@@ -268,7 +267,6 @@ check in changes outside of the parts of the compiler they maintain.\n \t\t\tReviewers\n \n arc port\t\tClaudiu Zissulescu\t<claziss@synopsys.com>\n-callgraph\t\tMartin Liska\t\t<mliska@suse.cz>\n callgraph\t\tMartin Jambor\t\t<mjambor@suse.cz>\n C front end\t\tMarek Polacek\t\t<polacek@redhat.com>\n CTF, BTF\t\tDavid Faust\t\t<david.faust@oracle.com>\n@@ -519,6 +517,7 @@ Kriang Lerdsuwanakij\t\t\t\t<lerdsuwa@users.sourceforge.net>\n Renlin Li\t\t\t\t\t<renlin.li@arm.com>\n Xinliang David Li\t\t\t\t<davidxl@google.com>\n Chen Liqin\t\t\t\t\t<liqin.gcc@gmail.com>\n+Martin Liska\t\t\t\t\t<mliska@suse.cz>\n Jiangning Liu\t\t\t\t\t<jiangning.liu@arm.com>\n Sa Liu\t\t\t\t\t\t<saliu@de.ibm.com>\n Ralph Loader\t\t\t\t\t<rcl@ihug.co.nz>"}, {"sha": "9455b79565854c015b3d0c251136c80977c0b7f8", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,7 @@\n+2023-02-10  Flavio Cruz  <flaviocruz@gmail.com>\n+\n+\t* config-list.mk: Add x86_64-gnu to list of archs.\n+\n 2023-01-19  Gaius Mulley  <gaiusmod2@gmail.com>\n \n \t* gcc_update (files_and_dependencies): Add dependencies for"}, {"sha": "661b11c9bbdb69b1edf9d514737842ea29b9b939", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -96,7 +96,7 @@ LIST = aarch64-elf aarch64-freebsd13 aarch64-linux-gnu aarch64-rtems \\\n   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux \\\n   sparc64-netbsd sparc64-openbsd \\\n   v850e1-elf v850e-elf v850-elf v850-rtems vax-linux-gnu \\\n-  vax-netbsdelf visium-elf x86_64-apple-darwin \\\n+  vax-netbsdelf visium-elf x86_64-apple-darwin x86_64-gnu \\\n   x86_64-pc-linux-gnuOPT-with-fpmath=avx \\\n   x86_64-elfOPT-with-fpmath=sse x86_64-freebsd13 x86_64-netbsd \\\n   x86_64-w64-mingw32 \\"}, {"sha": "32e639ed8732ac774d907c90a7c942d71e48e52a", "filename": "contrib/make_sunver.pl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fmake_sunver.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fmake_sunver.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fmake_sunver.pl?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -213,7 +213,7 @@\n     if (/^[ \\t]*$/) { print; next; }\n \n     # Lines of the form '{'\n-    if (/^([ \\t]*){$/) {\n+    if (/^([ \\t]*)\\{$/) {\n \tif ($in_extern) {\n \t    print \"$1##{\\n\";\n \t} else {"}, {"sha": "27dccaca91e4865008121deaca352a3780b6e379", "filename": "contrib/regression/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fregression%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fregression%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fregression%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,7 @@\n+2023-02-16  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* objs-gcc.sh: Only bootstrap if source-directory contains gcc.\n+\n 2012-08-26  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* btest-gcc.sh (TESTLOGS): Make gfortran.sum optional."}, {"sha": "d205bab1736857799f31f49d48e26c8e86a1c14d", "filename": "contrib/regression/objs-gcc.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fregression%2Fobjs-gcc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/contrib%2Fregression%2Fobjs-gcc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fregression%2Fobjs-gcc.sh?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -106,7 +106,9 @@ if [ $H_REAL_TARGET = $H_REAL_HOST -a $H_REAL_TARGET = i686-pc-linux-gnu ]\n   make all-gdb all-dejagnu all-ld || exit 1\n   make install-gdb install-dejagnu install-ld || exit 1\n elif [ $H_REAL_TARGET = $H_REAL_HOST ] ; then\n-  make bootstrap || exit 1\n+  H_MAKE_TARGET=\n+  test -f $SOURCE/gcc/configure && H_MAKE_TARGET=bootstrap\n+  make $H_MAKE_TARGET || exit 1\n   make install || exit 1\n else\n   make || exit 1"}, {"sha": "416d2c2e3a4ba5f84e9ec04d8e4fd4b13240cb2d", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2,11 +2,11 @@\n  *\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  *\n- * It has been AutoGen-ed  January 18, 2023 at 09:06:47 PM by AutoGen 5.18.7\n+ * It has been AutoGen-ed  January 22, 2023 at 09:03:29 PM by AutoGen 5.18.12\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Wed Jan 18 21:06:47 GMT 2023\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Jan 22 21:03:29 CET 2023\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -8549,8 +8549,15 @@ tSCC* apzSolaris_Math_12Machs[] = {\n tSCC zSolaris_Math_12Select0[] =\n        \"#undef.*_GLIBCXX_USE_C99_MATH\";\n \n-#define    SOLARIS_MATH_12_TEST_CT  1\n+/*\n+ *  content bypass pattern - skip fix if pattern found\n+ */\n+tSCC zSolaris_Math_12Bypass0[] =\n+       \"__MATH_PREEMPTS_GLIBCXX_C99_MATH\";\n+\n+#define    SOLARIS_MATH_12_TEST_CT  2\n static tTestDesc aSolaris_Math_12Tests[] = {\n+  { TT_NEGREP,   zSolaris_Math_12Bypass0, (regex_t*)NULL },\n   { TT_EGREP,    zSolaris_Math_12Select0, (regex_t*)NULL }, };\n \n /*\n@@ -11162,7 +11169,7 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          312\n+#define REGEX_COUNT          313\n #define MACH_LIST_SIZE_LIMIT 187\n #define FIX_COUNT            274\n "}, {"sha": "45e0cbc0c10b9666ce1e1a901ee4463ea0528d7e", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4306,6 +4306,7 @@ fix = {\n     files     = math.h;\n     mach      = '*-*-solaris2*';\n     select    = '#undef.*_GLIBCXX_USE_C99_MATH';\n+    bypass    = '__MATH_PREEMPTS_GLIBCXX_C99_MATH';\n     sed       = \"/#undef[ \\t]*_GLIBCXX_USE_C99_MATH/d\";\n     test_text = << _EOText_\n #if __cplusplus >= 201103L"}, {"sha": "b8fbe647a76cc09584b7af9b1e4c88dd52fbb44c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1715, "deletions": 0, "changes": 1715, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,1718 @@\n+2023-02-16  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/invoke.texi (Optimize Options): Reword the explanation\n+\tgetting minimal, maximal and default values of a parameter.\n+\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* addresses.h: Mechanically drop 'static' from 'static inline'\n+\tfunctions via s/^static inline/inline/g.\n+\t* asan.h: Likewise.\n+\t* attribs.h: Likewise.\n+\t* basic-block.h: Likewise.\n+\t* bitmap.h: Likewise.\n+\t* cfghooks.h: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cselib.h: Likewise.\n+\t* data-streamer.h: Likewise.\n+\t* debug.h: Likewise.\n+\t* df.h: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* dominance.h: Likewise.\n+\t* dumpfile.h: Likewise.\n+\t* emit-rtl.h: Likewise.\n+\t* except.h: Likewise.\n+\t* expmed.h: Likewise.\n+\t* expr.h: Likewise.\n+\t* fixed-value.h: Likewise.\n+\t* gengtype.h: Likewise.\n+\t* gimple-expr.h: Likewise.\n+\t* gimple-iterator.h: Likewise.\n+\t* gimple-predict.h: Likewise.\n+\t* gimple-range-fold.h: Likewise.\n+\t* gimple-ssa.h: Likewise.\n+\t* gimple.h: Likewise.\n+\t* graphite.h: Likewise.\n+\t* hard-reg-set.h: Likewise.\n+\t* hash-map.h: Likewise.\n+\t* hash-set.h: Likewise.\n+\t* hash-table.h: Likewise.\n+\t* hwint.h: Likewise.\n+\t* input.h: Likewise.\n+\t* insn-addr.h: Likewise.\n+\t* internal-fn.h: Likewise.\n+\t* ipa-fnsummary.h: Likewise.\n+\t* ipa-icf-gimple.h: Likewise.\n+\t* ipa-inline.h: Likewise.\n+\t* ipa-modref.h: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* ira-int.h: Likewise.\n+\t* ira.h: Likewise.\n+\t* lra-int.h: Likewise.\n+\t* lra.h: Likewise.\n+\t* lto-streamer.h: Likewise.\n+\t* memmodel.h: Likewise.\n+\t* omp-general.h: Likewise.\n+\t* optabs-query.h: Likewise.\n+\t* optabs.h: Likewise.\n+\t* plugin.h: Likewise.\n+\t* pretty-print.h: Likewise.\n+\t* range.h: Likewise.\n+\t* read-md.h: Likewise.\n+\t* recog.h: Likewise.\n+\t* regs.h: Likewise.\n+\t* rtl-iter.h: Likewise.\n+\t* rtl.h: Likewise.\n+\t* sbitmap.h: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sel-sched-ir.h: Likewise.\n+\t* sese.h: Likewise.\n+\t* sparseset.h: Likewise.\n+\t* ssa-iterators.h: Likewise.\n+\t* system.h: Likewise.\n+\t* target-globals.h: Likewise.\n+\t* target.h: Likewise.\n+\t* timevar.h: Likewise.\n+\t* tree-chrec.h: Likewise.\n+\t* tree-data-ref.h: Likewise.\n+\t* tree-iterator.h: Likewise.\n+\t* tree-outof-ssa.h: Likewise.\n+\t* tree-phinodes.h: Likewise.\n+\t* tree-scalar-evolution.h: Likewise.\n+\t* tree-sra.h: Likewise.\n+\t* tree-ssa-alias.h: Likewise.\n+\t* tree-ssa-live.h: Likewise.\n+\t* tree-ssa-loop-manip.h: Likewise.\n+\t* tree-ssa-loop.h: Likewise.\n+\t* tree-ssa-operands.h: Likewise.\n+\t* tree-ssa-propagate.h: Likewise.\n+\t* tree-ssa-sccvn.h: Likewise.\n+\t* tree-ssa.h: Likewise.\n+\t* tree-ssanames.h: Likewise.\n+\t* tree-streamer.h: Likewise.\n+\t* tree-switch-conversion.h: Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* tree.h: Likewise.\n+\t* wide-int.h: Likewise.\n+\n+2023-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108657\n+\t* tree-ssa-dse.cc (initialize_ao_ref_for_dse): If lhs of stmt\n+\texists and is not a SSA_NAME, call ao_ref_init even if the stmt\n+\tis a call to internal or builtin function.\n+\n+2023-02-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/invoke.texi (C++ Dialect Options): Suggest adding a\n+\tusing-declaration to unhide functions.\n+\n+2023-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108783\n+\t* tree-ssa-reassoc.cc (eliminate_redundant_comparison): If lcode\n+\tis equal to TREE_CODE (t), op1 to newop1 and op2 to newop2, set\n+\tt to curr->op.  Otherwise, punt if either newop1 or newop2 are\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI SSA_NAMEs.\n+\n+2023-02-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108791\n+\t* tree-ssa-forwprop.cc (optimize_vector_load): Build\n+\tthe ADDR_EXPR of a TARGET_MEM_REF using a more meaningful\n+\ttype.\n+\n+2023-02-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/90458\n+\t* config/i386/i386.cc (ix86_compute_frame_layout): Disable the\n+\teffects of -fstack-clash-protection for TARGET_STACK_PROBE.\n+\t(ix86_expand_prologue): Likewise.\n+\n+2023-02-15  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n+\n+\t* config/bpf/bpf.cc (bpf_option_override): Fix doubled space.\n+\n+2023-02-15  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*cmpqi_ext<mode>_1): Use\n+\tint248_register_operand predicate in zero_extract sub-RTX.\n+\t(*cmpqi_ext<mode>_2): Ditto.\n+\t(*cmpqi_ext<mode>_3): Ditto.\n+\t(*cmpqi_ext<mode>_4): Ditto.\n+\t(*extzvqi_mem_rex64): Ditto.\n+\t(*extzvqi): Ditto.\n+\t(*insvqi_1_mem_rex64): Ditto.\n+\t(@insv<mode>_1): Ditto.\n+\t(*insvqi_1): Ditto.\n+\t(*insvqi_2): Ditto.\n+\t(*insvqi_3): Ditto.\n+\t(*extendqi<SWI24:mode>_ext_1): Ditto.\n+\t(*addqi_ext<mode>_1): Ditto.\n+\t(*addqi_ext<mode>_2): Ditto.\n+\t(*subqi_ext<mode>_2): Ditto.\n+\t(*testqi_ext<mode>_1): Ditto.\n+\t(*testqi_ext<mode>_2): Ditto.\n+\t(*andqi_ext<mode>_1): Ditto.\n+\t(*andqi_ext<mode>_1_cc): Ditto.\n+\t(*andqi_ext<mode>_2): Ditto.\n+\t(*<any_or:code>qi_ext<mode>_1): Ditto.\n+\t(*<any_or:code>qi_ext<mode>_2): Ditto.\n+\t(*xorqi_ext<mode>_1_cc): Ditto.\n+\t(*negqi_ext<mode>_2): Ditto.\n+\t(*ashlqi_ext<mode>_2): Ditto.\n+\t(*<any_shiftrt:insn>qi_ext<mode>_2): Ditto.\n+\n+2023-02-15  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/predicates.md (int248_register_operand):\n+\tRename from extr_register_operand.\n+\t* config/i386/i386.md (*extv<mode>): Update for renamed predicate.\n+\t(*extzx<mode>): Ditto.\n+\t(*ashl<dwi>3_doubleword_mask): Use int248_register_operand predicate.\n+\t(*ashl<mode>3_mask): Ditto.\n+\t(*<any_shiftrt:insn><mode>3_mask): Ditto.\n+\t(*<any_shiftrt:insn><dwi>3_doubleword_mask): Ditto.\n+\t(*<any_rotate:insn><mode>3_mask): Ditto.\n+\t(*<btsc><mode>_mask): Ditto.\n+\t(*btr<mode>_mask): Ditto.\n+\t(*jcc_bt<mode>_mask_1): Ditto.\n+\n+2023-02-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/26854\n+\t* df-core.cc (df_worklist_propagate_forward): Put later\n+\tblocks on worklist and only earlier blocks on pending.\n+\t(df_worklist_propagate_backward): Likewise.\n+\t(df_worklist_dataflow_doublequeue): Change the iteration\n+\tto process new blocks in the same iteration if that\n+\tmaintains the iteration order.\n+\n+2023-02-15  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR middle-end/106080\n+\t* gimple-ssa-warn-access.cc (is_auto_decl): Remove.  Use auto_var_p\n+\tinstead.\n+\n+2023-02-15  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/predicates.md: Refine codes.\n+\t* config/riscv/riscv-protos.h (RVV_VUNDEF): New macro.\n+\t* config/riscv/riscv-v.cc: Refine codes.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (enum ternop_type): New\n+\tenum.\n+\t(class imac): New class.\n+\t(enum widen_ternop_type): New enum.\n+\t(class iwmac): New class.\n+\t(BASE): New class.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmacc): Ditto.\n+\t(vnmsac): Ditto.\n+\t(vmadd): Ditto.\n+\t(vnmsub): Ditto.\n+\t(vwmacc): Ditto.\n+\t(vwmaccu): Ditto.\n+\t(vwmaccsu): Ditto.\n+\t(vwmaccus): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(function_builder::apply_predication): Adjust for multiply-add support.\n+\t(function_expander::add_vundef_operand): Refine codes.\n+\t(function_expander::use_ternop_insn): New function.\n+\t(function_expander::use_widen_ternop_insn): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h: New function.\n+\t* config/riscv/vector.md (@pred_mul_<optab><mode>): New pattern.\n+\t(pred_mul_<optab><mode>_undef_merge): Ditto.\n+\t(*pred_<madd_nmsub><mode>): Ditto.\n+\t(*pred_<macc_nmsac><mode>): Ditto.\n+\t(*pred_mul_<optab><mode>): Ditto.\n+\t(@pred_mul_<optab><mode>_scalar): Ditto.\n+\t(*pred_mul_<optab><mode>_undef_merge_scalar): Ditto.\n+\t(*pred_<madd_nmsub><mode>_scalar): Ditto.\n+\t(*pred_<macc_nmsac><mode>_scalar): Ditto.\n+\t(*pred_mul_<optab><mode>_scalar): Ditto.\n+\t(*pred_mul_<optab><mode>_undef_merge_extended_scalar): Ditto.\n+\t(*pred_<madd_nmsub><mode>_extended_scalar): Ditto.\n+\t(*pred_<macc_nmsac><mode>_extended_scalar): Ditto.\n+\t(*pred_mul_<optab><mode>_extended_scalar): Ditto.\n+\t(@pred_widen_mul_plus<su><mode>): Ditto.\n+\t(@pred_widen_mul_plus<su><mode>_scalar): Ditto.\n+\t(@pred_widen_mul_plussu<mode>): Ditto.\n+\t(@pred_widen_mul_plussu<mode>_scalar): Ditto.\n+\t(@pred_widen_mul_plusus<mode>_scalar): Ditto.\n+\n+2023-02-15  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/predicates.md (vector_mask_operand): Refine the codes.\n+\t(vector_all_trues_mask_operand): New predicate.\n+\t(vector_undef_operand): New predicate.\n+\t(ltge_operator): New predicate.\n+\t(comparison_except_ltge_operator): New predicate.\n+\t(comparison_except_eqge_operator): New predicate.\n+\t(ge_operator): New predicate.\n+\t* config/riscv/riscv-v.cc (has_vi_variant_p): Add compare support.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class icmp): New class.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmseq): Ditto.\n+\t(vmsne): Ditto.\n+\t(vmslt): Ditto.\n+\t(vmsgt): Ditto.\n+\t(vmsle): Ditto.\n+\t(vmsge): Ditto.\n+\t(vmsltu): Ditto.\n+\t(vmsgtu): Ditto.\n+\t(vmsleu): Ditto.\n+\t(vmsgeu): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc\n+\t(struct return_mask_def): Adjust for compare support.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(function_expander::use_compare_insn): New function.\n+\t* config/riscv/riscv-vector-builtins.h\n+\t(function_expander::add_integer_operand): Ditto.\n+\t* config/riscv/riscv.cc (riscv_print_operand): Add compare support.\n+\t* config/riscv/riscv.md: Add vector min/max attributes.\n+\t* config/riscv/vector-iterators.md (xnor): New iterator.\n+\t* config/riscv/vector.md (@pred_cmp<mode>): New pattern.\n+\t(*pred_cmp<mode>): Ditto.\n+\t(*pred_cmp<mode>_narrow): Ditto.\n+\t(@pred_ltge<mode>): Ditto.\n+\t(*pred_ltge<mode>): Ditto.\n+\t(*pred_ltge<mode>_narrow): Ditto.\n+\t(@pred_cmp<mode>_scalar): Ditto.\n+\t(*pred_cmp<mode>_scalar): Ditto.\n+\t(*pred_cmp<mode>_scalar_narrow): Ditto.\n+\t(@pred_eqne<mode>_scalar): Ditto.\n+\t(*pred_eqne<mode>_scalar): Ditto.\n+\t(*pred_eqne<mode>_scalar_narrow): Ditto.\n+\t(*pred_cmp<mode>_extended_scalar): Ditto.\n+\t(*pred_cmp<mode>_extended_scalar_narrow): Ditto.\n+\t(*pred_eqne<mode>_extended_scalar): Ditto.\n+\t(*pred_eqne<mode>_extended_scalar_narrow): Ditto.\n+\t(@pred_ge<mode>_scalar): Ditto.\n+\t(@pred_<optab><mode>): Ditto.\n+\t(@pred_n<optab><mode>): Ditto.\n+\t(@pred_<optab>n<mode>): Ditto.\n+\t(@pred_not<mode>): Ditto.\n+\n+2023-02-15  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/108679\n+\t* ipa-sra.cc (push_param_adjustments_for_index): Do not omit\n+\tcreation of non-scalar replacements even if IPA-CP knows their\n+\tcontents.\n+\n+2023-02-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108787\n+\tPR target/103109\n+\t* config/rs6000/rs6000.md (<u>maddditi4): Change into umaddditi4 only\n+\texpander, change operand 3 to be TImode, emit maddlddi4 and\n+\tumadddi4_highpart{,_le} with its low half and finally add the high\n+\thalf to the result.\n+\n+2023-02-15  Martin Liska  <mliska@suse.cz>\n+\n+\t* doc/invoke.texi: Document --param=asan-kernel-mem-intrinsic-prefix.\n+\n+2023-02-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* sanopt.cc (sanitize_asan_mark_unpoison): Use bitmap\n+\tfor with_poison and alias worklist to it.\n+\t(sanitize_asan_mark_poison): Likewise.\n+\n+2023-02-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/108738\n+\t* config/i386/i386-features.cc (scalar_chain::add_to_queue):\n+\tCombine bitmap test and set.\n+\t(scalar_chain::add_insn): Likewise.\n+\t(scalar_chain::analyze_register_chain): Remove redundant\n+\tattempt to add to queue and instead strengthen assert.\n+\tSink common attempts to mark the def dual-mode.\n+\t(scalar_chain::add_to_queue): Remove redundant insn bitmap\n+\tcheck.\n+\n+2023-02-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/108738\n+\t* config/i386/i386-features.cc (convert_scalars_to_vector):\n+\tSwitch candidates bitmaps to tree view before building the chains.\n+\n+2023-02-15  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* reload1.cc (gen_reload): Correct rtx parameter for fatal_insn\n+\t\"failure trying to reload\" call.\n+\n+2023-02-15  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* gdbinit.in (phrs): New command.\n+\t* sel-sched-dump.cc (debug_hard_reg_set): Remove debug-function.\n+\t* ira-color.cc (debug_hard_reg_set): New, calling print_hard_reg_set.\n+\n+2023-02-14  David Faust  <david.faust@oracle.com>\n+\n+\tPR target/108790\n+\t* config/bpf/constraints.md (q): New memory constraint.\n+\t* config/bpf/bpf.md (zero_extendhidi2): Use it here.\n+\t(zero_extendqidi2): Likewise.\n+\t(zero_extendsidi2): Likewise.\n+\t(*mov<MM:mode>): Likewise.\n+\n+2023-02-14  Andrew Pinski  <apinski@marvell.com>\n+\n+\tPR tree-optimization/108355\n+\tPR tree-optimization/96921\n+\t* match.pd: Add pattern for \"1 - bool_val\".\n+\n+2023-02-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.cc (vn_phi_compute_hash): Key skipping\n+\tbasic block index hashing on the availability of ->cclhs.\n+\t(vn_phi_eq): Avoid re-doing sanity checks for CSE but\n+\trely on ->cclhs availability.\n+\t(vn_phi_lookup): Set ->cclhs only when we are eventually\n+\tgoing to CSE the PHI.\n+\t(vn_phi_insert): Likewise.\n+\n+2023-02-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimplify.cc (gimplify_save_expr): Add missing guard.\n+\n+2023-02-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108782\n+\t* tree-vect-loop.cc (vect_phi_first_order_recurrence_p):\n+\tMake sure we're not vectorizing an inner loop.\n+\n+2023-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/108777\n+\t* params.opt (-param=asan-kernel-mem-intrinsic-prefix=): New param.\n+\t* asan.h (asan_memfn_rtl): Declare.\n+\t* asan.cc (asan_memfn_rtls): New variable.\n+\t(asan_memfn_rtl): New function.\n+\t* builtins.cc (expand_builtin): If\n+\tparam_asan_kernel_mem_intrinsic_prefix and function is\n+\tkernel-{,hw}address sanitized, emit calls to\n+\t__{,hw}asan_{memcpy,memmove,memset} rather than\n+\t{memcpy,memmove,memset}.  Use sanitize_flags_p (SANITIZE_ADDRESS)\n+\tinstead of flag_sanitize & SANITIZE_ADDRESS to check if\n+\tasan_intercepted_p functions shouldn't be expanded inline.\n+\n+2023-02-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/96373\n+\t* tree-vect-stmts.cc (vectorizable_operation): Predicate trapping\n+\toperations on the loop mask.  Reject partial vectors if this isn't\n+\tpossible.\n+\n+2023-02-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/108681\n+\t* lra-spills.cc (lra_final_code_change): Extend subreg replacement\n+\tcode to handle bare uses and clobbers.\n+\n+2023-02-13  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.cc (ira_update_equiv_info_by_shuffle_insn): Clear equiv\n+\tcaller_save_p flag when clearing defined_p flag.\n+\t(setup_reg_equiv): Ditto.\n+\t* lra-constraints.cc (lra_constraints): Ditto.\n+\n+2023-02-13  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/108516\n+\t* config/i386/predicates.md (extr_register_operand):\n+\tNew special predicate.\n+\t* config/i386/i386.md (*extv<mode>): Use extr_register_operand\n+\tas operand 1 predicate.\n+\t(*exzv<mode>): Ditto.\n+\t(*extendqi<SWI24:mode>_ext_1): New insn pattern.\n+\n+2023-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/28614\n+\t* tree-ssa-sccvn.cc (can_track_predicate_on_edge): Avoid\n+\twalking all edges in most cases.\n+\t(vn_nary_op_insert_pieces_predicated): Avoid repeated\n+\tcalls to can_track_predicate_on_edge unless checking is\n+\tenabled.\n+\t(process_bb): Instead call it once here for each edge\n+\twe register possibly multiple predicates on.\n+\n+2023-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108691\n+\t* tree-cfg.cc (notice_special_calls): When the CFG is built\n+\thonor gimple_call_ctrl_altering_p.\n+\t* cfgexpand.cc (expand_call_stmt): Clear cfun->calls_setjmp\n+\ttemporarily if the call is not control-altering.\n+\t* calls.cc (emit_call_1): Do not add REG_SETJMP if\n+\tcfun->calls_setjmp is not set.  Do not alter cfun->calls_setjmp.\n+\n+2023-02-13  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n+\n+\tPR target/108102\n+\t* config/s390/s390.cc (s390_bb_fallthru_entry_likely): Remove.\n+\t(struct s390_sched_state): Initialise to zero.\n+\t(s390_sched_variable_issue): For better debuggability also emit\n+\tthe current side.\n+\t(s390_sched_init): Unconditionally reset scheduler state.\n+\n+2023-02-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* ifcvt.h (noce_if_info::cond_inverted): New field.\n+\t* ifcvt.cc (cond_move_convert_if_block): Swap the then and else\n+\tvalues when cond_inverted is true.\n+\t(noce_find_if_block): Allow the condition to be inverted when\n+\thandling conditional moves.\n+\n+2023-02-13  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n+\n+\t* config/s390/predicates.md (execute_operation): Use\n+\tconstrain_operands instead of extract_constrain_insn in order to\n+\tdetermine wheter there exists a valid alternative.\n+\n+2023-02-13  Claudiu Zissulescu  <claziss@gmail.com>\n+\n+\t* common/config/arc/arc-common.cc (arc_option_optimization_table):\n+\tRemove millicode from list.\n+\n+2023-02-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* doc/invoke.texi: Document ira-simple-lra-insn-threshold.\n+\n+2023-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/106722\n+\t* tree-ssa-dce.cc (mark_last_stmt_necessary): Return\n+\twhether we marked a stmt.\n+\t(mark_control_dependent_edges_necessary): When\n+\tmark_last_stmt_necessary didn't mark any stmt make sure\n+\tto mark its control dependent edges.\n+\t(propagate_necessity): Likewise.\n+\n+2023-02-13  Kito Cheng  <kito.cheng@sifive.com>\n+\n+\t* config/riscv/riscv.h (RISCV_DWARF_VLENB): New.\n+\t(DWARF_FRAME_REGISTERS): New.\n+\t(DWARF_REG_TO_UNWIND_COLUMN): New.\n+\n+2023-02-12  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/sourcebuild.texi: Remove (broken) direct reference to\n+\t\"The GNU configure and build system\".\n+\n+2023-02-12  Jin Ma  <jinma@linux.alibaba.com>\n+\n+\t* config/riscv/riscv.cc (riscv_adjust_libcall_cfi_prologue): Change\n+\tgen_add3_insn to gen_rtx_SET.\n+\t(riscv_adjust_libcall_cfi_epilogue): Likewise.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class sat_op): New class.\n+\t(class vnclip): Ditto.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vaadd): Ditto.\n+\t(vasub): Ditto.\n+\t(vaaddu): Ditto.\n+\t(vasubu): Ditto.\n+\t(vsmul): Ditto.\n+\t(vssra): Ditto.\n+\t(vssrl): Ditto.\n+\t(vnclipu): Ditto.\n+\t(vnclip): Ditto.\n+\t* config/riscv/vector-iterators.md (su): Add instruction.\n+\t(aadd): Ditto.\n+\t(vaalu): Ditto.\n+\t* config/riscv/vector.md (@pred_<sat_op><mode>): New pattern.\n+\t(@pred_<sat_op><mode>_scalar): Ditto.\n+\t(*pred_<sat_op><mode>_scalar): Ditto.\n+\t(*pred_<sat_op><mode>_extended_scalar): Ditto.\n+\t(@pred_narrow_clip<v_su><mode>): Ditto.\n+\t(@pred_narrow_clip<v_su><mode>_scalar): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/constraints.md (Wbr): Remove unused constraint.\n+\t* config/riscv/predicates.md: Fix move operand predicate.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class vnshift): New class.\n+\t(class vncvt_x): Ditto.\n+\t(class vmerge): Ditto.\n+\t(class vmv_v): Ditto.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t(vnsrl): Ditto.\n+\t(vnsra): Ditto.\n+\t(vncvt_x): Ditto.\n+\t(vmerge): Ditto.\n+\t(vmv_v): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct narrow_alu_def): Ditto.\n+\t(struct move_def): Ditto.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_WEXTI_OPS): New variable.\n+\t(DEF_RVV_WEXTU_OPS): Ditto\n+\t* config/riscv/riscv-vector-builtins.def (x_x_w): Fix type for suffix.\n+\t(v_v): Ditto.\n+\t(v_x): Ditto.\n+\t(x_w): Ditto.\n+\t(x): Ditto.\n+\t* config/riscv/riscv.cc (riscv_print_operand): Refine ASM printting rule.\n+\t* config/riscv/vector-iterators.md (nmsac):New iterator.\n+\t(nmsub): New iterator.\n+\t* config/riscv/vector.md (@pred_merge<mode>): New pattern.\n+\t(@pred_merge<mode>_scalar): New pattern.\n+\t(*pred_merge<mode>_scalar): New pattern.\n+\t(*pred_merge<mode>_extended_scalar): New pattern.\n+\t(@pred_narrow_<optab><mode>): New pattern.\n+\t(@pred_narrow_<optab><mode>_scalar): New pattern.\n+\t(@pred_trunc<mode>): New pattern.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class vmadc): New class.\n+\t(class vmsbc): Ditto.\n+\t(BASE): Define new class.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmadc): New define.\n+\t(vmsbc): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct return_mask_def):\n+\tNew class.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(function_expander::use_exact_insn): Adjust for new support\n+\t* config/riscv/riscv-vector-builtins.h\n+\t(function_base::has_merge_operand_p): New function.\n+\t* config/riscv/vector-iterators.md: New iterator.\n+\t* config/riscv/vector.md (@pred_madc<mode>): New pattern.\n+\t(@pred_msbc<mode>): Ditto.\n+\t(@pred_madc<mode>_scalar): Ditto.\n+\t(@pred_msbc<mode>_scalar): Ditto.\n+\t(*pred_madc<mode>_scalar): Ditto.\n+\t(*pred_madc<mode>_extended_scalar): Ditto.\n+\t(*pred_msbc<mode>_scalar): Ditto.\n+\t(*pred_msbc<mode>_extended_scalar): Ditto.\n+\t(@pred_madc<mode>_overflow): Ditto.\n+\t(@pred_msbc<mode>_overflow): Ditto.\n+\t(@pred_madc<mode>_overflow_scalar): Ditto.\n+\t(@pred_msbc<mode>_overflow_scalar): Ditto.\n+\t(*pred_madc<mode>_overflow_scalar): Ditto.\n+\t(*pred_madc<mode>_overflow_extended_scalar): Ditto.\n+\t(*pred_msbc<mode>_overflow_scalar): Ditto.\n+\t(*pred_msbc<mode>_overflow_extended_scalar): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-protos.h (simm5_p): Add vadc/vsbc support.\n+\t* config/riscv/riscv-v.cc (simm32_p): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class vadc): New class.\n+\t(class vsbc): Ditto.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vadc): Ditto.\n+\t(vsbc): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc\n+\t(struct no_mask_policy_def): Ditto.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(rvv_arg_type_info::get_base_vector_type): Add vadc/vsbc support.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t(function_expander::use_exact_insn): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): Ditto.\n+\t(function_base::use_mask_predication_p): New function.\n+\t* config/riscv/vector-iterators.md: New iterator.\n+\t* config/riscv/vector.md (@pred_adc<mode>): New pattern.\n+\t(@pred_sbc<mode>): Ditto.\n+\t(@pred_adc<mode>_scalar): Ditto.\n+\t(@pred_sbc<mode>_scalar): Ditto.\n+\t(*pred_adc<mode>_scalar): Ditto.\n+\t(*pred_adc<mode>_extended_scalar): Ditto.\n+\t(*pred_sbc<mode>_scalar): Ditto.\n+\t(*pred_sbc<mode>_extended_scalar): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md: use \"zero\" reg.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class widen_binop): New\n+\tclass.\n+\t(class vwmulsu): Ditto.\n+\t(class vwcvt): Ditto.\n+\t(BASE): Add integer widening support.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto\n+\t* config/riscv/riscv-vector-builtins-functions.def (vwadd): New class.\n+\t(vwsub): New class.\n+\t(vwmul): New class.\n+\t(vwmulu): New class.\n+\t(vwmulsu): New class.\n+\t(vwaddu): New class.\n+\t(vwsubu): New class.\n+\t(vwcvt_x): New class.\n+\t(vwcvtu_x): New class.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct alu_def): New\n+\tclass.\n+\t(struct widen_alu_def): New class.\n+\t(SHAPE): New class.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: New class.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(rvv_arg_type_info::get_base_vector_type): Add integer widening support.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t* config/riscv/riscv-vector-builtins.def (x_x_v): Change into \"x_v\"\n+\t(x_v): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): Add integer\n+\twidening support.\n+\t* config/riscv/riscv-vsetvl.cc (change_insn): Fix reg_equal use bug.\n+\t* config/riscv/riscv.h (X0_REGNUM): New constant.\n+\t* config/riscv/vector-iterators.md: New iterators.\n+\t* config/riscv/vector.md\n+\t(@pred_dual_widen_<any_widen_binop:optab><any_extend:su><mode>): New\n+\tpattern.\n+\t(@pred_dual_widen_<any_widen_binop:optab><any_extend:su><mode>_scalar):\n+\tDitto.\n+\t(@pred_single_widen_<plus_minus:optab><any_extend:su><mode>): Ditto.\n+\t(@pred_single_widen_<plus_minus:optab><any_extend:su><mode>_scalar):\n+\tDitto.\n+\t(@pred_widen_mulsu<mode>): Ditto.\n+\t(@pred_widen_mulsu<mode>_scalar): Ditto.\n+\t(@pred_<optab><mode>): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\t    kito-cheng  <kito.cheng@sifive.com>\n+\n+\t* common/config/riscv/riscv-common.cc: Add flag for 'V' extension.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class vmulh): New class.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmulh): Add vmulh\n+\tAPI support.\n+\t(vmulhu): Ditto.\n+\t(vmulhsu): Ditto.\n+\t* config/riscv/riscv-vector-builtins-types.def (DEF_RVV_FULL_V_I_OPS):\n+\tNew macro.\n+\t(DEF_RVV_FULL_V_U_OPS): Ditto.\n+\t(vint8mf8_t): Ditto.\n+\t(vint8mf4_t): Ditto.\n+\t(vint8mf2_t): Ditto.\n+\t(vint8m1_t): Ditto.\n+\t(vint8m2_t): Ditto.\n+\t(vint8m4_t): Ditto.\n+\t(vint8m8_t): Ditto.\n+\t(vint16mf4_t): Ditto.\n+\t(vint16mf2_t): Ditto.\n+\t(vint16m1_t): Ditto.\n+\t(vint16m2_t): Ditto.\n+\t(vint16m4_t): Ditto.\n+\t(vint16m8_t): Ditto.\n+\t(vint32mf2_t): Ditto.\n+\t(vint32m1_t): Ditto.\n+\t(vint32m2_t): Ditto.\n+\t(vint32m4_t): Ditto.\n+\t(vint32m8_t): Ditto.\n+\t(vint64m1_t): Ditto.\n+\t(vint64m2_t): Ditto.\n+\t(vint64m4_t): Ditto.\n+\t(vint64m8_t): Ditto.\n+\t(vuint8mf8_t): Ditto.\n+\t(vuint8mf4_t): Ditto.\n+\t(vuint8mf2_t): Ditto.\n+\t(vuint8m1_t): Ditto.\n+\t(vuint8m2_t): Ditto.\n+\t(vuint8m4_t): Ditto.\n+\t(vuint8m8_t): Ditto.\n+\t(vuint16mf4_t): Ditto.\n+\t(vuint16mf2_t): Ditto.\n+\t(vuint16m1_t): Ditto.\n+\t(vuint16m2_t): Ditto.\n+\t(vuint16m4_t): Ditto.\n+\t(vuint16m8_t): Ditto.\n+\t(vuint32mf2_t): Ditto.\n+\t(vuint32m1_t): Ditto.\n+\t(vuint32m2_t): Ditto.\n+\t(vuint32m4_t): Ditto.\n+\t(vuint32m8_t): Ditto.\n+\t(vuint64m1_t): Ditto.\n+\t(vuint64m2_t): Ditto.\n+\t(vuint64m4_t): Ditto.\n+\t(vuint64m8_t): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_FULL_V_I_OPS): Ditto.\n+\t(DEF_RVV_FULL_V_U_OPS): Ditto.\n+\t(check_required_extensions): Add vmulh support.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h (RVV_REQUIRE_FULL_V): Ditto.\n+\t(enum rvv_base_type): Ditto.\n+\t* config/riscv/riscv.opt: Add 'V' extension flag.\n+\t* config/riscv/vector-iterators.md (su): New iterator.\n+\t* config/riscv/vector.md (@pred_mulh<v_su><mode>): New pattern.\n+\t(@pred_mulh<v_su><mode>_scalar): Ditto.\n+\t(*pred_mulh<v_su><mode>_scalar): Ditto.\n+\t(*pred_mulh<v_su><mode>_extended_scalar): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/iterators.md: Add sign_extend/zero_extend.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class ext): New class.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Add vsext/vzext support.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vsext): New macro\n+\tdefine.\n+\t(vzext): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct alu_def): Adjust\n+\tfor vsext/vzext support.\n+\t* config/riscv/riscv-vector-builtins-types.def (DEF_RVV_WEXTI_OPS): New\n+\tmacro define.\n+\t(DEF_RVV_QEXTI_OPS): Ditto.\n+\t(DEF_RVV_OEXTI_OPS): Ditto.\n+\t(DEF_RVV_WEXTU_OPS): Ditto.\n+\t(DEF_RVV_QEXTU_OPS): Ditto.\n+\t(DEF_RVV_OEXTU_OPS): Ditto.\n+\t(vint16mf4_t): Ditto.\n+\t(vint16mf2_t): Ditto.\n+\t(vint16m1_t): Ditto.\n+\t(vint16m2_t): Ditto.\n+\t(vint16m4_t): Ditto.\n+\t(vint16m8_t): Ditto.\n+\t(vint32mf2_t): Ditto.\n+\t(vint32m1_t): Ditto.\n+\t(vint32m2_t): Ditto.\n+\t(vint32m4_t): Ditto.\n+\t(vint32m8_t): Ditto.\n+\t(vint64m1_t): Ditto.\n+\t(vint64m2_t): Ditto.\n+\t(vint64m4_t): Ditto.\n+\t(vint64m8_t): Ditto.\n+\t(vuint16mf4_t): Ditto.\n+\t(vuint16mf2_t): Ditto.\n+\t(vuint16m1_t): Ditto.\n+\t(vuint16m2_t): Ditto.\n+\t(vuint16m4_t): Ditto.\n+\t(vuint16m8_t): Ditto.\n+\t(vuint32mf2_t): Ditto.\n+\t(vuint32m1_t): Ditto.\n+\t(vuint32m2_t): Ditto.\n+\t(vuint32m4_t): Ditto.\n+\t(vuint32m8_t): Ditto.\n+\t(vuint64m1_t): Ditto.\n+\t(vuint64m2_t): Ditto.\n+\t(vuint64m4_t): Ditto.\n+\t(vuint64m8_t): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_WEXTI_OPS): Ditto.\n+\t(DEF_RVV_QEXTI_OPS): Ditto.\n+\t(DEF_RVV_OEXTI_OPS): Ditto.\n+\t(DEF_RVV_WEXTU_OPS): Ditto.\n+\t(DEF_RVV_QEXTU_OPS): Ditto.\n+\t(DEF_RVV_OEXTU_OPS): Ditto.\n+\t(rvv_arg_type_info::get_base_vector_type): Add sign_exted/zero_extend\n+\tsupport.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): Ditto.\n+\t* config/riscv/vector-iterators.md (z): New attribute.\n+\t* config/riscv/vector.md (@pred_<optab><mode>_vf2): New pattern.\n+\t(@pred_<optab><mode>_vf4): Ditto.\n+\t(@pred_<optab><mode>_vf8): Ditto.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/iterators.md: Add saturating Addition && Subtraction.\n+\t* config/riscv/riscv-v.cc (has_vi_variant_p): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vsadd): New def.\n+\t(vssub): Ditto.\n+\t(vsaddu): Ditto.\n+\t(vssubu): Ditto.\n+\t* config/riscv/vector-iterators.md (sll.vi): Adjust for Saturating\n+\tsupport.\n+\t(sll.vv): Ditto.\n+\t(%3,%v4): Ditto.\n+\t(%3,%4): Ditto.\n+\t* config/riscv/vector.md (@pred_<optab><mode>): New pattern.\n+\t(@pred_<optab><mode>_scalar): New pattern.\n+\t(*pred_<optab><mode>_scalar): New pattern.\n+\t(*pred_<optab><mode>_extended_scalar): New pattern.\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/iterators.md: Add neg and not.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class unop): New class.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vadd): Rename binop\n+\tinto alu.\n+\t(vsub): Ditto.\n+\t(vand): Ditto.\n+\t(vor): Ditto.\n+\t(vxor): Ditto.\n+\t(vsll): Ditto.\n+\t(vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t(vmin): Ditto.\n+\t(vmax): Ditto.\n+\t(vminu): Ditto.\n+\t(vmaxu): Ditto.\n+\t(vmul): Ditto.\n+\t(vdiv): Ditto.\n+\t(vrem): Ditto.\n+\t(vdivu): Ditto.\n+\t(vremu): Ditto.\n+\t(vrsub): Ditto.\n+\t(vneg): Ditto.\n+\t(vnot): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct binop_def): Ditto.\n+\t(struct alu_def): Ditto.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc: Support unary C/C/++.\n+\t* config/riscv/vector-iterators.md: New iterator.\n+\t* config/riscv/vector.md (@pred_<optab><mode>): New pattern\n+\n+2023-02-12  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (pass_vsetvl::compute_probabilities): Skip exit block.\n+\n+2023-02-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR ipa/108605\n+\t* ipa-cp.cc (ipa_agg_value_from_jfunc): Return NULL_TREE also if\n+\titem->offset bit position is too large to be representable as\n+\tunsigned int byte position.\n+\n+2023-02-11  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/extend.texi (Other Builtins): Adjust link to WG14 N965.\n+\n+2023-02-10  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.cc (update_equiv_regs): Set up ira_reg_equiv for\n+\tvalid_combine only when ira_use_lra_p is true.\n+\n+2023-02-10  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* params.opt (ira-simple-lra-insn-threshold): Add new param.\n+\t* ira.cc (ira): Use the param to switch on simple LRA.\n+\n+2023-02-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108687\n+\t* gimple-range-cache.cc (ranger_cache::range_on_edge): Revert\n+\tback to RFD_NONE mode for calculations.\n+\t(ranger_cache::propagate_cache): Call the internal edge range API\n+\twith RFD_READ_ONLY instead of changing the external routine.\n+\n+2023-02-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108520\n+\t* gimple-range-infer.cc (check_assume_func): Invoke\n+\tgimple_range_global directly instead using global_range_query.\n+\t* value-query.cc (get_range_global): Add function context and\n+\tavoid calling nonnull_arg_p if not cfun.\n+\t(gimple_range_global): Add function context pointer.\n+\t* value-query.h (imple_range_global): Add function context.\n+\n+2023-02-10  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/constraints.md (Wdm): Adjust constraint.\n+\t(Wbr): New constraint.\n+\t* config/riscv/predicates.md (reg_or_int_operand): New predicate.\n+\t* config/riscv/riscv-protos.h (emit_pred_op): Remove function.\n+\t(emit_vlmax_op): New function.\n+\t(emit_nonvlmax_op): Ditto.\n+\t(simm32_p): Ditto.\n+\t(neg_simm5_p): Ditto.\n+\t(has_vi_variant_p): Ditto.\n+\t* config/riscv/riscv-v.cc (emit_pred_op): Adjust function.\n+\t(emit_vlmax_op): New function.\n+\t(emit_nonvlmax_op): Ditto.\n+\t(expand_const_vector): Adjust function.\n+\t(legitimize_move): Ditto.\n+\t(simm32_p): New function.\n+\t(simm5_p): Ditto.\n+\t(neg_simm5_p): Ditto.\n+\t(has_vi_variant_p): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class vrsub): New class.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmin): Remove\n+\tunsigned cases.\n+\t(vmax): Ditto.\n+\t(vminu): Remove signed cases.\n+\t(vmaxu): Ditto.\n+\t(vdiv): Remove unsigned cases.\n+\t(vrem): Ditto.\n+\t(vdivu): Remove signed cases.\n+\t(vremu): Ditto.\n+\t(vadd): Adjust.\n+\t(vsub): Ditto.\n+\t(vrsub): New class.\n+\t(vand): Adjust.\n+\t(vor): Ditto.\n+\t(vxor): Ditto.\n+\t(vmul): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_U_OPS): New macro.\n+\t* config/riscv/riscv.h: change VL/VTYPE as fixed reg.\n+\t* config/riscv/vector-iterators.md: New iterators.\n+\t* config/riscv/vector.md (@pred_broadcast<mode>): Adjust pattern for vx\n+\tsupport.\n+\t(@pred_<optab><mode>_scalar): New pattern.\n+\t(@pred_sub<mode>_reverse_scalar): Ditto.\n+\t(*pred_<optab><mode>_scalar): Ditto.\n+\t(*pred_<optab><mode>_extended_scalar): Ditto.\n+\t(*pred_sub<mode>_reverse_scalar): Ditto.\n+\t(*pred_sub<mode>_extended_reverse_scalar): Ditto.\n+\n+2023-02-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108724\n+\t* tree-vect-stmts.cc (vectorizable_operation): Avoid\n+\tusing word_mode vectors when vector lowering will\n+\tdecompose them to elementwise operations.\n+\n+2023-02-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tRevert:\n+\t2023-02-09  Martin Liska  <mliska@suse.cz>\n+\n+\tPR target/100758\n+\t* doc/extend.texi: Document that the function\n+\tdoes not work correctly for old VIA processors.\n+\n+2023-02-10  Andrew Pinski  <apinski@marvell.com>\n+\t    Andrew Macleod   <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108684\n+\t* tree-ssa-dce.cc (simple_dce_from_worklist):\n+\tCheck all ssa names and not just non-vdef ones\n+\tbefore accepting the inline-asm.\n+\tCall unlink_stmt_vdef on the statement before\n+\tremoving it.\n+\n+2023-02-09  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.h (struct ira_reg_equiv_s): Add new field caller_save_p.\n+\t* ira.cc (validate_equiv_mem): Check memref address variance.\n+\t(no_equiv): Clear caller_save_p flag.\n+\t(update_equiv_regs): Define caller save equivalence for\n+\tvalid_combine.\n+\t(setup_reg_equiv): Clear defined_p flag for caller save equivalence.\n+\t* lra-constraints.cc (lra_copy_reg_equiv): Add new arg\n+\tcall_save_p.  Use caller save equivalence depending on the arg.\n+\t(split_reg): Adjust the call.\n+\n+2023-02-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/100758\n+\t* common/config/i386/cpuinfo.h (get_zhaoxin_cpu): Formatting fixes.\n+\t(cpu_indicator_init): Call get_available_features for all CPUs with\n+\tmax_level >= 1, rather than just Intel, AMD or Zhaoxin.  Formatting\n+\tfixes.\n+\n+2023-02-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108688\n+\t* match.pd (bit_field_ref [bit_insert]): Simplify BIT_FIELD_REF\n+\tof BIT_INSERT_EXPR extracting exactly all inserted bits even\n+\twhen without mode precision.  Formatting fixes.\n+\n+2023-02-09  Andrew Pinski  <apinski@marvell.com>\n+\n+\tPR tree-optimization/108688\n+\t* match.pd (bit_field_ref [bit_insert]): Avoid generating\n+\tBIT_FIELD_REFs of non-mode-precision integral operands.\n+\n+2023-02-09  Martin Liska  <mliska@suse.cz>\n+\n+\tPR target/100758\n+\t* doc/extend.texi: Document that the function\n+\tdoes not work correctly for old VIA processors.\n+\n+2023-02-09  Andreas Schwab  <schwab@suse.de>\n+\n+\t* lto-wrapper.cc (merge_and_complain): Handle\n+\t-funwind-tables and -fasynchronous-unwind-tables.\n+\t(append_compiler_options): Likewise.\n+\n+2023-02-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/26854\n+\t* tree-into-ssa.cc (update_ssa): Turn blocks_to_update to tree\n+\tview around insert_updated_phi_nodes_for.\n+\t* tree-ssa-alias.cc (maybe_skip_until): Allocate visited bitmap\n+\tin tree view.\n+\t(walk_aliased_vdefs_1): Likewise.\n+\n+2023-02-08  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/include/gpl_v3.texi: Change fsf.org to www.fsf.org.\n+\n+2023-02-08  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\tPR target/108505\n+\t* config.gcc (tm_mlib_file): Define new variable.\n+\n+2023-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108692\n+\t* tree-vect-patterns.cc (vect_widened_op_tree): If rhs_code is\n+\twidened_code which is different from code, don't call\n+\tvect_look_through_possible_promotion but instead just check op is\n+\tSSA_NAME with integral type for which vect_is_simple_use is true\n+\tand call set_op on this_unprom.\n+\n+2023-02-08  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch_ra_sign_key): Remove\n+\tdeclaration.\n+\t* config/aarch64/aarch64.cc (aarch_ra_sign_key): Remove\n+\tdefinition.\n+\t* config/aarch64/aarch64.opt (aarch64_ra_sign_key): Rename\n+\tto 'aarch_ra_sign_key'.\n+\t* config/arm/aarch-common.cc (aarch_ra_sign_key): Remove\n+\tdeclaration.\n+\t* config/arm/arm-protos.h (aarch_ra_sign_key): Likewise.\n+\t* config/arm/arm.cc (enum aarch_key_type): Remove definition.\n+\t* config/arm/arm.opt: Define.\n+\n+2023-02-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/108316\n+\t* tree-vect-stmts.cc (get_load_store_type): When using\n+\tinternal functions for gather/scatter, make sure that the type\n+\tof the offset argument is consistent with the offset vector type.\n+\n+2023-02-08  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\tRevert:\n+\t2023-02-07  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.h (struct ira_reg_equiv_s): Add new field caller_save_p.\n+\t* ira.cc (validate_equiv_mem): Check memref address variance.\n+\t(update_equiv_regs): Define caller save equivalence for\n+\tvalid_combine.\n+\t(setup_reg_equiv): Clear defined_p flag for caller save equivalence.\n+\t* lra-constraints.cc (lra_copy_reg_equiv): Add new arg\n+\tcall_save_p.  Use caller save equivalence depending on the arg.\n+\t(split_reg): Adjust the call.\n+\n+2023-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.def (SAD_EXPR): Remove outdated comment about missing\n+\tWIDEN_MINUS_EXPR.\n+\n+2023-02-07  Marek Polacek  <polacek@redhat.com>\n+\n+\t* doc/invoke.texi: Update -fchar8_t documentation.\n+\n+2023-02-07  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.h (struct ira_reg_equiv_s): Add new field caller_save_p.\n+\t* ira.cc (validate_equiv_mem): Check memref address variance.\n+\t(update_equiv_regs): Define caller save equivalence for\n+\tvalid_combine.\n+\t(setup_reg_equiv): Clear defined_p flag for caller save equivalence.\n+\t* lra-constraints.cc (lra_copy_reg_equiv): Add new arg\n+\tcall_save_p.  Use caller save equivalence depending on the arg.\n+\t(split_reg): Adjust the call.\n+\n+2023-02-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/26854\n+\t* gimple-fold.cc (has_use_on_stmt): Look at stmt operands\n+\tinstead of immediate uses.\n+\n+2023-02-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/106923\n+\t* ipa-split.cc (execute_split_functions): Don't split returns_twice\n+\tfunctions.\n+\n+2023-02-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/106433\n+\t* cgraph.cc (set_const_flag_1): Recurse on simd clones too.\n+\t(cgraph_node::set_pure_flag): Call set_pure_flag_1 on simd clones too.\n+\n+2023-02-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* config/i386/x86-tune.def (X86_TUNE_AVX256_OPTIMAL): Turn off\n+\tfor znver4.\n+\n+2023-02-06  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/mkoffload.cc (gcn_stack_size): New global variable.\n+\t(process_asm): Create a constructor for GCN_STACK_SIZE.\n+\t(main): Parse the -mstack-size option.\n+\n+2023-02-06  Alex Coplan  <alex.coplan@arm.com>\n+\n+\tPR target/104921\n+\t* config/aarch64/aarch64-simd.md (aarch64_bfmlal<bt>_lane<q>v4sf):\n+\tUse correct constraint for operand 3.\n+\n+2023-02-06  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-sra.cc (adjust_parameter_descriptions): Fix a typo in a dump.\n+\n+2023-02-06  Xi Ruoyao  <xry111@xry111.site>\n+\n+\t* config/loongarch/loongarch.md (bytepick_w_ashift_amount):\n+\tNew define_int_iterator.\n+\t(bytepick_d_ashift_amount): Likewise.\n+\t(bytepick_imm): New define_int_attr.\n+\t(bytepick_w_lshiftrt_amount): Likewise.\n+\t(bytepick_d_lshiftrt_amount): Likewise.\n+\t(bytepick_w_<bytepick_imm>): New define_insn template.\n+\t(bytepick_w_<bytepick_imm>_extend): Likewise.\n+\t(bytepick_d_<bytepick_imm>): Likewise.\n+\t(bytepick_w): Remove unused define_insn.\n+\t(bytepick_d): Likewise.\n+\t(UNSPEC_BYTEPICK_W): Remove unused unspec.\n+\t(UNSPEC_BYTEPICK_D): Likewise.\n+\t* config/loongarch/predicates.md (const_0_to_3_operand):\n+\tRemove unused define_predicate.\n+\t(const_0_to_7_operand): Likewise.\n+\n+2023-02-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108655\n+\t* ubsan.cc (sanitize_unreachable_fn): For -funreachable-traps\n+\tor -fsanitize=unreachable -fsanitize-trap=unreachable return\n+\tBUILT_IN_UNREACHABLE_TRAP decl rather than BUILT_IN_TRAP.\n+\n+2023-02-05  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/install.texi (Specific): Remove PW32.\n+\n+2023-02-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108647\n+\t* range-op.cc (operator_equal::op1_range,\n+\toperator_not_equal::op1_range): Don't test op2 bound\n+\tequality if op2.undefined_p (), instead set_varying.\n+\t(operator_lt::op1_range, operator_le::op1_range,\n+\toperator_gt::op1_range, operator_ge::op1_range): Return false if\n+\top2.undefined_p ().\n+\t(operator_lt::op2_range, operator_le::op2_range,\n+\toperator_gt::op2_range, operator_ge::op2_range): Return false if\n+\top1.undefined_p ().\n+\n+2023-02-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/108639\n+\t* value-range.cc (irange::legacy_equal_p): Compare nonzero bits as\n+\twidest_int.\n+\t(irange::operator==): Same.\n+\n+2023-02-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/108647\n+\t* range-op-float.cc (foperator_lt::op1_range): Handle undefined ranges.\n+\t(foperator_lt::op2_range): Same.\n+\t(foperator_le::op1_range): Same.\n+\t(foperator_le::op2_range): Same.\n+\t(foperator_gt::op1_range): Same.\n+\t(foperator_gt::op2_range): Same.\n+\t(foperator_ge::op1_range): Same.\n+\t(foperator_ge::op2_range): Same.\n+\t(foperator_unordered_lt::op1_range): Same.\n+\t(foperator_unordered_lt::op2_range): Same.\n+\t(foperator_unordered_le::op1_range): Same.\n+\t(foperator_unordered_le::op2_range): Same.\n+\t(foperator_unordered_gt::op1_range): Same.\n+\t(foperator_unordered_gt::op2_range): Same.\n+\t(foperator_unordered_ge::op1_range): Same.\n+\t(foperator_unordered_ge::op2_range): Same.\n+\n+2023-02-03  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/107570\n+\t* tree-vrp.cc (remove_and_update_globals): Reset SCEV.\n+\n+2023-02-03  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* doc/gm2.texi (Internals): Remove from menu.\n+\t(Using): Comment out ifnohtml conditional.\n+\t(Documentation): Use gcc url.\n+\t(License): Node simplified.\n+\t(Copying): New node.  Include gpl_v3_without_node.\n+\t(Contributing): Node simplified.\n+\t(Internals): Commented out.\n+\t(Libraries): Node simplified.\n+\t(Indices): Ditto.\n+\t(Contents): Ditto.\n+\t(Functions): Ditto.\n+\n+2023-02-03  Christophe Lyon  <christophe.lyon@arm.com>\n+\n+\t* config/arm/mve.md (mve_vabavq_p_<supf><mode>): Add length\n+\tattribute.\n+\t(mve_vqshluq_m_n_s<mode>): Likewise.\n+\t(mve_vshlq_m_<supf><mode>): Likewise.\n+\t(mve_vsriq_m_n_<supf><mode>): Likewise.\n+\t(mve_vsubq_m_<supf><mode>): Likewise.\n+\n+2023-02-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/108384\n+\t* ipa-sra.cc (push_param_adjustments_for_index): Remove a size check\n+\twhen comparing to an IPA-CP value.\n+\t(dump_list_of_param_indices): New function.\n+\t(adjust_parameter_descriptions): Check for mismatching IPA-CP values.\n+\tDump removed candidates using dump_list_of_param_indices.\n+\t* ipa-param-manipulation.cc\n+\t(ipa_param_body_adjustments::modify_expression): Add assert checking\n+\tsizes of a VIEW_CONVERT_EXPR will match.\n+\t(ipa_param_body_adjustments::modify_assignment): Likewise.\n+\n+2023-02-03  Monk Chiang  <monk.chiang@sifive.com>\n+\n+\t* config/riscv/riscv.h: Remove VL_REGS, VTYPE_REGS class.\n+\t* config/riscv/riscv.cc: Ditto.\n+\n+2023-02-03  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector-iterators.md (sll.vi): Fix constraint bug.\n+\t(sll.vv): Ditto.\n+\t(%3,%4): Ditto.\n+\t(%3,%v4): Ditto.\n+\t* config/riscv/vector.md: Ditto.\n+\n+2023-02-03  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/predicates.md (pmode_reg_or_uimm5_operand): New predicate.\n+\t* config/riscv/riscv-vector-builtins-bases.cc: New class.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vsll): Ditto.\n+\t(vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc: Ditto.\n+\t* config/riscv/vector.md (@pred_<optab><mode>_scalar): New pattern.\n+\n+2023-02-02  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* toplev.cc (toplev::main): Only print the version information header\n+\tfrom toplevel main().\n+\n+2023-02-02  Paul-Antoine Arras  <pa@codesourcery.com>\n+\n+\t* config/gcn/gcn-valu.md (cond_<expander><mode>): Add\n+\tcond_{ashl|ashr|lshr}\n+\n+2023-02-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/108086\n+\t* rtl-ssa/insns.h (insn_info): Make m_num_defs a full unsigned int.\n+\tAdjust size-related commentary accordingly.\n+\n+2023-02-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/108508\n+\t* rtl-ssa/accesses.cc (function_info::split_clobber_group): When\n+\tthe splay tree search gives the first clobber in the second group,\n+\tmake sure that the root of the first clobber group is updated\n+\tcorrectly.  Enter the new clobber group into the definition splay\n+\ttree.\n+\n+2023-02-02  Jin Ma  <jinma@linux.alibaba.com>\n+\n+\t* common/config/riscv/riscv-common.cc (riscv_compute_multilib):\n+\tFix finding best match score.\n+\n+2023-02-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/106746\n+\tPR rtl-optimization/108463\n+\tPR target/108484\n+\t* cselib.cc (cselib_current_insn): Move declaration earlier.\n+\t(cselib_hasher::equal): For debug only locs, temporarily override\n+\tcselib_current_insn to their l->setting_insn for the\n+\trtx_equal_for_cselib_1 call, so that unsuccessful comparisons don't\n+\tpromote some debug locs.\n+\t* sched-deps.cc (sched_analyze_2) <case MEM>: For MEMs in DEBUG_INSNs\n+\twhen using cselib call cselib_lookup_from_insn on the address but\n+\tdon't substitute it.\n+\n+2023-02-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108625\n+\t* genmatch.cc (expr::gen_transform): Also disallow resimplification\n+\tfrom pushing to lseq with force_leaf.\n+\t(dt_simplify::gen_1): Likewise.\n+\n+2023-02-02  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/gcn-run.cc: Include libgomp-gcn.h.\n+\t(struct kernargs): Replace the common content with kernargs_abi.\n+\t(struct heap): Delete.\n+\t(main): Read GCN_STACK_SIZE envvar.\n+\tAllocate space for the device stacks.\n+\tWrite the new kernargs fields.\n+\t* config/gcn/gcn.cc (gcn_option_override): Remove stack_size_opt.\n+\t(default_requested_args): Remove PRIVATE_SEGMENT_BUFFER_ARG and\n+\tPRIVATE_SEGMENT_WAVE_OFFSET_ARG.\n+\t(gcn_addr_space_convert): Mask the QUEUE_PTR_ARG content.\n+\t(gcn_expand_prologue): Move the TARGET_PACKED_WORK_ITEMS to the top.\n+\tSet up the stacks from the values in the kernargs, not private.\n+\t(gcn_expand_builtin_1): Match the stack configuration in the prologue.\n+\t(gcn_hsa_declare_function_name): Turn off the private segment.\n+\t(gcn_conditional_register_usage): Ensure QUEUE_PTR is fixed.\n+\t* config/gcn/gcn.h (FIXED_REGISTERS): Fix the QUEUE_PTR register.\n+\t* config/gcn/gcn.opt (mstack-size): Change the description.\n+\n+2023-02-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR target/108443\n+\t* config/arm/arm.h (VALID_MVE_PRED_MODE): Add V2QI.\n+\t* config/arm/arm.cc (thumb2_legitimate_address_p): Use HImode for\n+\taddressing MVE predicate modes.\n+\t(mve_bool_vec_to_const): Change to represent correct MVE predicate\n+\tformat.\n+\t(arm_hard_regno_mode_ok): Use VALID_MVE_PRED_MODE instead of checking\n+\tmodes.\n+\t(arm_vector_mode_supported_p): Likewise.\n+\t(arm_mode_to_pred_mode): Add V2QI.\n+\t* config/arm/arm-builtins.cc (UNOP_PRED_UNONE_QUALIFIERS): New\n+\tqualifier.\n+\t(UNOP_PRED_PRED_QUALIFIERS): New qualifier\n+\t(BINOP_PRED_UNONE_PRED_QUALIFIERS): New qualifier.\n+\t(v2qi_UP): New macro.\n+\t(v4bi_UP): New macro.\n+\t(v8bi_UP): New macro.\n+\t(v16bi_UP): New macro.\n+\t(arm_expand_builtin_args): Make it able to expand the new predicate\n+\tmodes.\n+\t* config/arm/arm-modes.def (V2QI): New mode.\n+\t* config/arm/arm-simd-builtin-types.def (Pred1x16_t, Pred2x8_t\n+\tPred4x4_t): Remove unused predicate builtin types.\n+\t* config/arm/arm_mve.h (__arm_vctp16q, __arm_vctp32q, __arm_vctp64q,\n+\t__arm_vctp8q, __arm_vpnot, __arm_vctp8q_m, __arm_vctp64q_m,\n+\t__arm_vctp32q_m, __arm_vctp16q_m): Use predicate modes.\n+\t* config/arm/arm_mve_builtins.def (vctp16q, vctp32q, vctp64q, vctp8q,\n+\tvpnot, vctp8q_m, vctp16q_m, vctp32q_m, vctp64q_m): Likewise.\n+\t* config/arm/constraints.md (DB): Check for VALID_MVE_PRED_MODE instead\n+\tof MODE_VECTOR_BOOL.\n+\t* config/arm/iterators.md (MVE_7, MVE_7_HI): Add V2QI\n+\t(MVE_VPRED): Likewise.\n+\t(MVE_vpred): Add V2QI and map upper case predicate modes to lower case.\n+\t(MVE_vctp): New mode attribute.\n+\t(mode1): Remove.\n+\t(VCTPQ): Remove.\n+\t(VCTPQ_M): Remove.\n+\t* config/arm/mve.md (mve_vctp<mode1>qhi): Rename this...\n+\t(mve_vctp<MVE_vctp>q<MVE_vpred>): ... to this. And use new mode\n+\tattributes.\n+\t(mve_vpnothi): Rename this...\n+\t(mve_vpnotv16bi): ... to this.\n+\t(mve_vctp<mode1>q_mhi): Rename this...\n+\t(mve_vctp<MVE_vctp>q_m<MVE_vpred>):... to this.\n+\t(mve_vldrdq_gather_base_z_<supf>v2di,\n+\tmve_vldrdq_gather_offset_z_<supf>v2di,\n+\tmve_vldrdq_gather_shifted_offset_z_<supf>v2di,\n+\tmve_vstrdq_scatter_base_p_<supf>v2di,\n+\tmve_vstrdq_scatter_offset_p_<supf>v2di,\n+\tmve_vstrdq_scatter_offset_p_<supf>v2di_insn,\n+\tmve_vstrdq_scatter_shifted_offset_p_<supf>v2di,\n+\tmve_vstrdq_scatter_shifted_offset_p_<supf>v2di_insn,\n+\tmve_vstrdq_scatter_base_wb_p_<supf>v2di,\n+\tmve_vldrdq_gather_base_wb_z_<supf>v2di,\n+\tmve_vldrdq_gather_base_nowb_z_<supf>v2di,\n+\tmve_vldrdq_gather_base_wb_z_<supf>v2di_insn):  Use V2QI insead of HI for\n+\tpredicates.\n+\t* config/arm/unspecs.md (VCTP8Q, VCTP16Q, VCTP32Q, VCTP64Q): Replace\n+\tthese...\n+\t(VCTP): ... with this.\n+\t(VCTP8Q_M, VCTP16Q_M, VCTP32Q_M, VCTP64Q_M): Replace these...\n+\t(VCTP_M): ... with this.\n+\t* config/arm/vfp.md (*thumb2_movhi_vfp, *thumb2_movhi_fp16): Use\n+\tVALID_MVE_PRED_MODE instead of checking for MODE_VECTOR_BOOL class.\n+\n+2023-02-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR target/107674\n+\t* config/arm/arm.cc (arm_hard_regno_mode_ok): Use new MACRO.\n+\t(arm_modes_tieable_p): Make MVE predicate modes tieable.\n+\t* config/arm/arm.h (VALID_MVE_PRED_MODE):  New define.\n+\t* simplify-rtx.cc (simplify_context::simplify_subreg): Teach\n+\tsimplify_subreg to simplify subregs where the outermode is not scalar.\n+\n+2023-02-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR target/107674\n+\t* config/arm/arm-builtins.cc (arm_simd_builtin_type): Rewrite to use\n+\tnew qualifiers parameter and use unsigned short type for MVE predicate.\n+\t(arm_init_builtin): Call arm_simd_builtin_type with qualifiers\n+\tparameter.\n+\t(arm_init_crypto_builtins): Likewise.\n+\n+2023-02-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR ipa/107300\n+\t* builtins.def (BUILT_IN_UNREACHABLE_TRAP): New builtin.\n+\t* internal-fn.def (TRAP): Remove.\n+\t* internal-fn.cc (expand_TRAP): Remove.\n+\t* tree.cc (build_common_builtin_nodes): Define\n+\tBUILT_IN_UNREACHABLE_TRAP if not yet defined.\n+\t(builtin_decl_unreachable): Use BUILT_IN_UNREACHABLE_TRAP\n+\tinstead of BUILT_IN_TRAP.\n+\t* gimple.cc (gimple_build_builtin_unreachable): Remove\n+\temitting internal function for BUILT_IN_TRAP.\n+\t* asan.cc (maybe_instrument_call): Handle BUILT_IN_UNREACHABLE_TRAP.\n+\t* cgraph.cc (cgraph_edge::verify_corresponds_to_fndecl): Handle\n+\tBUILT_IN_UNREACHABLE_TRAP instead of BUILT_IN_TRAP.\n+\t* ipa-devirt.cc (possible_polymorphic_call_target_p): Handle\n+\tBUILT_IN_UNREACHABLE_TRAP.\n+\t* builtins.cc (expand_builtin, is_inexpensive_builtin): Likewise.\n+\t* tree-cfg.cc (verify_gimple_call,\n+\tpass_warn_function_return::execute): Likewise.\n+\t* attribs.cc (decl_attributes): Don't report exclusions on\n+\tBUILT_IN_UNREACHABLE_TRAP either.\n+\n+2023-02-02  liuhongt  <hongtao.liu@intel.com>\n+\n+\tPR tree-optimization/108601\n+\t* tree-vectorizer.h (vect_can_peel_nonlinear_iv_p): Removed.\n+\t* tree-vect-loop.cc\n+\t(vectorizable_nonlinear_induction): Remove\n+\tvect_can_peel_nonlinear_iv_p.\n+\t(vect_can_peel_nonlinear_iv_p): Don't peel\n+\tnonlinear iv(mult or shift) for epilog when vf is not\n+\tconstant and moved the defination to ..\n+\t* tree-vect-loop-manip.cc (vect_can_peel_nonlinear_iv_p):\n+\t.. Here.\n+\n+2023-02-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/108435\n+\t* tree-nested.cc (convert_nonlocal_omp_clauses)\n+\t<case OMP_CLAUSE_LASTPRIVATE>: If info->new_local_var_chain and *seq\n+\tis not a GIMPLE_BIND, wrap the sequence into a new GIMPLE_BIND\n+\tbefore calling declare_vars.\n+\t(convert_nonlocal_omp_clauses) <case OMP_CLAUSE_LINEAR>: Merge\n+\twith the OMP_CLAUSE_LASTPRIVATE handling except for whether\n+\tseq is initialized to &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause)\n+\tor &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause).\n+\n+2023-02-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* common/config/aarch64/aarch64-common.cc\n+\t(struct aarch64_option_extension): Add native_detect and document struct\n+\ta bit more.\n+\t(all_extensions): Set new field native_detect.\n+\t* config/aarch64/aarch64.cc (struct aarch64_option_extension): Delete\n+\tunused struct.\n+\n+2023-02-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-devirt.cc (odr_types_equivalent_p): Respect *warned\n+\tvalue if set.\n+\n+2023-02-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108356\n+\t* gimple-range-cache.cc (ranger_cache::range_on_edge): Always\n+\tdo a search of the DOM tree for a range.\n+\n+2023-02-01  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/108509\n+\t* cgraphunit.cc (walk_polymorphic_call_targets): Insert\n+\tony non-null values.\n+\t* ipa.cc (walk_polymorphic_call_targets): Likewise.\n+\n+2023-02-01  Martin Liska  <mliska@suse.cz>\n+\n+\tPR driver/108572\n+\t* gcc.cc (LINK_COMPRESS_DEBUG_SPEC): Report error only for\n+\t-gz=zstd.\n+\n+2023-02-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/108573\n+\t* ree.cc (combine_reaching_defs): Don't return false for paradoxical\n+\tsubregs in DEBUG_INSNs.\n+\n+2023-02-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* compare-elim.cc (find_flags_uses_in_insn): Guard use of SET_SRC.\n+\n+2023-02-01  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/s390.cc (s390_restore_gpr_p): New function.\n+\t(s390_preserve_gpr_arg_in_range_p): New function.\n+\t(s390_preserve_gpr_arg_p): New function.\n+\t(s390_preserve_fpr_arg_p): New function.\n+\t(s390_register_info_stdarg_fpr): Rename to ...\n+\t(s390_register_info_arg_fpr): ... this. Add -mpreserve-args handling.\n+\t(s390_register_info_stdarg_gpr): Rename to ...\n+\t(s390_register_info_arg_gpr): ... this. Add -mpreserve-args handling.\n+\t(s390_register_info): Use the renamed functions above.\n+\t(s390_optimize_register_info): Likewise.\n+\t(save_fpr): Generate CFI for -mpreserve-args.\n+\t(save_gprs): Generate CFI for -mpreserve-args. Drop return value.\n+\t(s390_emit_prologue): Adjust to changed calling convention of save_gprs.\n+\t(s390_optimize_prologue): Likewise.\n+\t* config/s390/s390.opt: New option -mpreserve-args\n+\n+2023-02-01  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/s390.cc (save_gprs): Use gen_frame_mem.\n+\t(restore_gprs): Likewise.\n+\t(s390_emit_stack_tie): Make the stack_tie to be dependent on the\n+\tframe pointer if a frame-pointer is used.\n+\t(s390_emit_prologue): Emit stack_tie when frame-pointer is needed.\n+\t* config/s390/s390.md (stack_tie): Add a register operand and\n+\trename to ...\n+\t(@stack_tie<mode>): ... this.\n+\n+2023-02-01  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* dwarf2cfi.cc (dwarf2out_frame_debug_cfa_restore): Add\n+\tEMIT_CFI parameter.\n+\t(dwarf2out_frame_debug): Add case for REG_CFA_NORESTORE.\n+\t* reg-notes.def (REG_CFA_NOTE): New reg note definition.\n+\n+2023-02-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108500\n+\t* dominance.cc (assign_dfs_numbers): Replace recursive DFS\n+\twith tree traversal algorithm.\n+\n+2023-02-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* doc/invoke.texi: Document -Wno-changes-meaning.\n+\n+2023-02-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/invoke.texi (Static Analyzer Options): Add notes about\n+\tlimitations of -fanalyzer.\n+\n+2023-01-31  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/constraints.md (vj): New.\n+\t(vk): Ditto\n+\t* config/riscv/iterators.md: Add more opcode.\n+\t* config/riscv/predicates.md (vector_arith_operand): New.\n+\t(vector_neg_arith_operand): New.\n+\t(vector_shift_operand): New.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class binop): New.\n+\t* config/riscv/riscv-vector-builtins-bases.h: (vadd): New.\n+\t(vsub): Ditto.\n+\t(vand): Ditto.\n+\t(vor): Ditto.\n+\t(vxor): Ditto.\n+\t(vsll): Ditto.\n+\t(vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t(vmin): Ditto.\n+\t(vmax): Ditto.\n+\t(vminu): Ditto.\n+\t(vmaxu): Ditto.\n+\t(vmul): Ditto.\n+\t(vdiv): Ditto.\n+\t(vrem): Ditto.\n+\t(vdivu): Ditto.\n+\t(vremu): Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vadd): New.\n+\t(vsub): Ditto.\n+\t(vand): Ditto.\n+\t(vor): Ditto.\n+\t(vxor): Ditto.\n+\t(vsll): Ditto.\n+\t(vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t(vmin): Ditto.\n+\t(vmax): Ditto.\n+\t(vminu): Ditto.\n+\t(vmaxu): Ditto.\n+\t(vmul): Ditto.\n+\t(vdiv): Ditto.\n+\t(vrem): Ditto.\n+\t(vdivu): Ditto.\n+\t(vremu): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct binop_def): New.\n+\t* config/riscv/riscv-vector-builtins-shapes.h (binop): New.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_I_OPS): New.\n+\t(DEF_RVV_U_OPS): New.\n+\t(rvv_arg_type_info::get_base_vector_type): Handle\n+\tRVV_BASE_shift_vector.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): Add\n+\tRVV_BASE_shift_vector.\n+\t* config/riscv/riscv.cc (riscv_print_operand): Handle 'V'.\n+\t* config/riscv/vector-iterators.md: Handle more opcode.\n+\t* config/riscv/vector.md (@pred_<optab><mode>): New.\n+\n+2023-01-31  Philipp Tomsich  <philipp.tomsich@vrull.eu>\n+\n+\tPR target/108589\n+\t* config/aarch64/aarch64.cc (aarch_macro_fusion_pair_p): Check\n+\tREG_P on SET_DEST.\n+\n+2023-01-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/108608\n+\t* tree-vect-loop.cc (vect_transform_reduction): Handle single\n+\tdef-use cycles that involve function calls rather than tree codes.\n+\n+2023-01-31  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108385\n+\t* gimple-range-gori.cc (gori_compute::compute_operand_range):\n+\tAllow VARYING computations to continue if there is a relation.\n+\t* range-op.cc (pointer_plus_operator::op2_range): New.\n+\n+2023-01-31  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108359\n+\t* range-op.cc (range_operator::wi_fold_in_parts_equiv): New.\n+\t(range_operator::fold_range): If op1 is equivalent to op2 then\n+\tinvoke new fold_in_parts_equiv to operate on sub-components.\n+\t* range-op.h (wi_fold_in_parts_equiv): New prototype.\n+\n+2023-01-31  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* gimple-range-gori.cc (gori_compute::compute_operand_range): Do\n+\tnot abort calculations if there is a valid relation available.\n+\t(gori_compute::refine_using_relation): Pass correct relation trio.\n+\t(gori_compute::compute_operand1_range): Create trio and use it.\n+\t(gori_compute::compute_operand2_range): Ditto.\n+\t* range-op.cc (operator_plus::op1_range): Use correct trio member.\n+\t(operator_minus::op1_range): Use correct trio member.\n+\t* value-relation.cc (value_relation::create_trio): New.\n+\t* value-relation.h (value_relation::create_trio): New prototype.\n+\n+2023-01-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108599\n+\t* config/i386/i386-expand.cc\n+\t(ix86_convert_const_wide_int_to_broadcast): Return nullptr if\n+\tCONST_WIDE_INT_NUNITS (op) times HOST_BITS_PER_WIDE_INT isn't\n+\tequal to bitsize of mode.\n+\n+2023-01-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/108596\n+\t* bb-reorder.cc (fix_up_fall_thru_edges): Handle the case where cur_bb\n+\tends with asm goto and has a crossing fallthrough edge to the same bb\n+\tthat contains at least one of its labels by restoring EDGE_CROSSING\n+\tflag even on possible edge from cur_bb to new_bb successor.\n+\n+2023-01-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/105593\n+\t* config/i386/avx512erintrin.h (_mm512_exp2a23_round_pd,\n+\t_mm512_exp2a23_round_ps, _mm512_rcp28_round_pd, _mm512_rcp28_round_ps,\n+\t_mm512_rsqrt28_round_pd, _mm512_rsqrt28_round_ps): Use\n+\t_mm512_undefined_pd () or _mm512_undefined_ps () instead of using\n+\tuninitialized automatic variable __W.\n+\n 2023-01-31  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/include/fdl.texi: Change fsf.org to www.fsf.org."}, {"sha": "ef309477de2d109d7117a31f0f8d607042f13549", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1 +1 @@\n-20230131\n+20230217"}, {"sha": "fdbbf4cc4ee7d553db189942668fcd0f2068df96", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,13 @@\n+2023-02-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.cc (gnat_gimplify_expr): Add missing guard.\n+\n+2023-02-14  Dongsheng Song  <dongsheng.song@gmail.com>\n+\n+\t* adaint.c [Linux]: Include <features.h>.\n+\t(__gnat_get_executable_load_address) [Linux]: Enable only for\n+\tglibc and uClibc.\n+\n 2023-01-16  Marc Poulhi\u00e8s  <poulhies@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update copyright years."}, {"sha": "8522094164e07f92afe345a49b35967237d65b5e", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3526,6 +3526,7 @@ __gnat_cpu_set (int cpu, size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n #if defined (__APPLE__)\n #include <mach-o/dyld.h>\n #elif defined (__linux__)\n+#include <features.h>\n #include <link.h>\n #endif\n \n@@ -3535,7 +3536,7 @@ __gnat_get_executable_load_address (void)\n #if defined (__APPLE__)\n   return _dyld_get_image_header (0);\n \n-#elif defined (__linux__)\n+#elif defined (__linux__) && (defined (__GLIBC__) || defined (__UCLIBC__))\n   struct link_map *map = _r_debug.r_map;\n   return (const void *)map->l_addr;\n "}, {"sha": "5fc1a26fedefa405ace7a8bb83055667e32850fb", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -9049,7 +9049,9 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \n       /* Propagate TREE_NO_WARNING from expression to temporary by using the\n \t SAVE_EXPR itself as an intermediate step.  See gimplify_save_expr.  */\n-      if (SAVE_EXPR_RESOLVED_P (expr))\n+      if (type == void_type_node)\n+\t;\n+      else if (SAVE_EXPR_RESOLVED_P (expr))\n \tTREE_NO_WARNING (op) = TREE_NO_WARNING (expr);\n       else\n \tTREE_NO_WARNING (expr) = TREE_NO_WARNING (op);"}, {"sha": "3519c241c6d7b1e83f3615ab6ab5b01741ffef59", "filename": "gcc/addresses.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Faddresses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Faddresses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faddresses.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ADDRESSES_H\n #define GCC_ADDRESSES_H\n \n-static inline enum reg_class\n+inline enum reg_class\n base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n \t\taddr_space_t as ATTRIBUTE_UNUSED,\n \t\tenum rtx_code outer_code ATTRIBUTE_UNUSED,\n@@ -51,7 +51,7 @@ base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n    REGNO_OK_FOR_BASE_P.\n    Arguments as for the REGNO_MODE_CODE_OK_FOR_BASE_P macro.  */\n \n-static inline bool\n+inline bool\n ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n \t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t addr_space_t as ATTRIBUTE_UNUSED,\n@@ -77,7 +77,7 @@ ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n /* Wrapper around ok_for_base_p_1, for use after register allocation is\n    complete.  Arguments as for the called function.  */\n \n-static inline bool\n+inline bool\n regno_ok_for_base_p (unsigned regno, machine_mode mode, addr_space_t as,\n \t\t     enum rtx_code outer_code, enum rtx_code index_code)\n {"}, {"sha": "15a3de715fb905608d1a5814630c6ead071c3971", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,95 @@\n+2023-02-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108806\n+\t* constraint-manager.cc (bounded_range::dump_to_pp): Use\n+\tbounded_range::singleton_p.\n+\t(constraint_manager::add_bounded_ranges): Handle singleton ranges\n+\tby adding an EQ_EXPR constraint.\n+\t(constraint_manager::impossible_derived_conditions_p): New.\n+\t(constraint_manager::eval_condition): Reject EQ_EXPR when it would\n+\timply impossible derived conditions.\n+\t(selftest::test_bits): New.\n+\t(selftest::run_constraint_manager_tests): Run it.\n+\t* constraint-manager.h (bounded_range::singleton_p): New.\n+\t(constraint_manager::impossible_derived_conditions_p): New decl.\n+\t* region-model.cc (region_model::get_rvalue_1): Handle\n+\tBIT_AND_EXPR, BIT_IOR_EXPR, and BIT_XOR_EXPR.\n+\n+2023-02-15  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108664\n+\tPR analyzer/108666\n+\tPR analyzer/108725\n+\t* diagnostic-manager.cc (epath_finder::get_best_epath): Add\n+\t\"target_stmt\" param.\n+\t(epath_finder::explore_feasible_paths): Likewise.\n+\t(epath_finder::process_worklist_item): Likewise.\n+\t(saved_diagnostic::calc_best_epath): Pass m_stmt to\n+\tepath_finder::get_best_epath.\n+\t* engine.cc (feasibility_state::maybe_update_for_edge): Move\n+\tper-stmt logic to...\n+\t(feasibility_state::update_for_stmt): ...this new function.\n+\t* exploded-graph.h (feasibility_state::update_for_stmt): New decl.\n+\t* feasible-graph.cc (feasible_node::get_state_at_stmt): New.\n+\t* feasible-graph.h: Include \"analyzer/exploded-graph.h\".\n+\t(feasible_node::get_state_at_stmt): New decl.\n+\t* infinite-recursion.cc\n+\t(infinite_recursion_diagnostic::check_valid_fpath_p): Update for\n+\tvfunc signature change.\n+\t* pending-diagnostic.h (pending_diagnostic::check_valid_fpath_p):\n+\tConvert first param to a reference.  Add stmt param.\n+\t* region-model.cc: Include \"analyzer/feasible-graph.h\".\n+\t(poisoned_value_diagnostic::poisoned_value_diagnostic): Add\n+\t\"check_expr\" param.\n+\t(poisoned_value_diagnostic::check_valid_fpath_p): New.\n+\t(poisoned_value_diagnostic::m_check_expr): New field.\n+\t(region_model::check_for_poison): Attempt to supply a check_expr\n+\tto the diagnostic\n+\t(region_model::deref_rvalue): Add NULL for new check_expr param\n+\tof poisoned_value_diagnostic.\n+\t(region_model::get_or_create_region_for_heap_alloc): Don't reuse\n+\tregions that are marked as TOUCHED.\n+\n+2023-02-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108745\n+\t* sm-malloc.cc (deref_before_check::emit): Reject the warning if\n+\tthe check occurs within a macro defintion.\n+\n+2023-02-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108733\n+\t* state-purge.cc (get_candidate_for_purging): Add ADDR_EXPR\n+\tand MEM_REF.\n+\n+2023-02-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108704\n+\t* state-purge.cc (state_purge_per_decl::process_point_backwards):\n+\tDon't stop processing the decl if it's fully overwritten by\n+\tthis stmt if it's also used by this stmt.\n+\n+2023-02-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108661\n+\t* sm-fd.cc (class kf_read): New.\n+\t(register_known_fd_functions): Register \"read\".\n+\t* sm-file.cc (class kf_fread): Update comment.\n+\n+2023-02-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108633\n+\t* sm-fd.cc (fd_state_machine::check_for_fd_attrs): Add missing\n+\t\"continue\".\n+\t(fd_state_machine::on_listen): Don't issue phase-mismatch or\n+\ttype-mismatch warnings for the \"invalid\" state.\n+\n+2023-02-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108616\n+\t* pending-diagnostic.cc (fixup_location_in_macro_p): Add \"alloca\"\n+\tto macros that we shouldn't unwind inside.\n+\n 2023-01-26  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/108524"}, {"sha": "2c9c435527ea6ddcf0d9539e86ce441540851665", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 165, "deletions": 1, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -421,7 +421,7 @@ dump_cst (pretty_printer *pp, tree cst, bool show_types)\n void\n bounded_range::dump_to_pp (pretty_printer *pp, bool show_types) const\n {\n-  if (tree_int_cst_equal (m_lower, m_upper))\n+  if (singleton_p ())\n     dump_cst (pp, m_lower, show_types);\n   else\n     {\n@@ -2118,6 +2118,17 @@ bool\n constraint_manager::add_bounded_ranges (const svalue *sval,\n \t\t\t\t\tconst bounded_ranges *ranges)\n {\n+  /* If RANGES is just a singleton, convert this to adding the constraint:\n+     \"SVAL == {the singleton}\".  */\n+  if (ranges->get_count () == 1\n+      && ranges->get_range (0).singleton_p ())\n+    {\n+      tree range_cst = ranges->get_range (0).m_lower;\n+      const svalue *range_sval\n+\t= m_mgr->get_or_create_constant_svalue (range_cst);\n+      return add_constraint (sval, EQ_EXPR, range_sval);\n+    }\n+\n   sval = sval->unwrap_any_unmergeable ();\n \n   /* Nothing can be known about unknown/poisoned values.  */\n@@ -2466,6 +2477,66 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n   return tristate::unknown ();\n }\n \n+/* Return true iff \"LHS == RHS\" is known to be impossible due to\n+   derived conditions.\n+\n+   Look for an EC containing an EC_VAL of the form (LHS OP CST).\n+   If found, see if (LHS OP CST) == EC_VAL is false.\n+   If so, we know this condition is false.\n+\n+   For example, if we already know that\n+     (X & CST_MASK) == Y\n+   and we're evaluating X == Z, we can test to see if\n+     (Z & CST_MASK) == EC_VAL\n+   and thus if:\n+     (Z & CST_MASK) == Y\n+   and reject this if we know that's false.  */\n+\n+bool\n+constraint_manager::impossible_derived_conditions_p (const svalue *lhs,\n+\t\t\t\t\t\t     const svalue *rhs) const\n+{\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      for (const svalue *ec_sval : ec->m_vars)\n+\tswitch (ec_sval->get_kind ())\n+\t  {\n+\t  default:\n+\t    break;\n+\t  case SK_BINOP:\n+\t    {\n+\t      const binop_svalue *iter_binop\n+\t\t= as_a <const binop_svalue *> (ec_sval);\n+\t      if (lhs == iter_binop->get_arg0 ()\n+\t\t  && iter_binop->get_type ())\n+\t\tif (iter_binop->get_arg1 ()->get_kind () == SK_CONSTANT)\n+\t\t  {\n+\t\t    /* Try evalating EC_SVAL with LHS\n+\t\t       as the value of EC_SVAL's lhs, and see if it's\n+\t\t       consistent with existing knowledge.  */\n+\t\t    const svalue *subst_bin_op\n+\t\t      = m_mgr->get_or_create_binop\n+\t\t      (iter_binop->get_type (),\n+\t\t       iter_binop->get_op (),\n+\t\t       rhs,\n+\t\t       iter_binop->get_arg1 ());\n+\t\t    tristate t = eval_condition (subst_bin_op,\n+\t\t\t\t\t\t EQ_EXPR,\n+\t\t\t\t\t\t ec_sval);\n+\t\t    if (t.is_false ())\n+\t\t      return true; /* Impossible.  */\n+\t\t  }\n+\t    }\n+\t    break;\n+\t  }\n+    }\n+  /* Not known to be impossible.  */\n+  return false;\n+}\n+\n+\n /* Evaluate the condition LHS OP RHS, without modifying this\n    constraint_manager (avoiding the creation of equiv_class instances).  */\n \n@@ -2516,6 +2587,10 @@ constraint_manager::eval_condition (const svalue *lhs,\n \treturn result_for_ecs;\n     }\n \n+  if (op == EQ_EXPR\n+      && impossible_derived_conditions_p (lhs, rhs))\n+    return false;\n+\n   /* If at least one is not in an EC, we have no constraints\n      comparing LHS and RHS yet.\n      They might still be comparable if one (or both) is a constant.\n@@ -4435,6 +4510,94 @@ test_bounded_ranges ()\n \t     mgr.get_or_create_point (ch1));\n }\n \n+/* Verify that we can handle sufficiently simple bitmasking operations.  */\n+\n+static void\n+test_bits (void)\n+{\n+  region_model_manager mgr;\n+\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+  tree int_0x80 = build_int_cst (integer_type_node, 0x80);\n+  tree int_0xff = build_int_cst (integer_type_node, 0xff);\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+\n+  tree x_bit_and_0x80 = build2 (BIT_AND_EXPR, integer_type_node, x, int_0x80);\n+  tree x_bit_and_0xff = build2 (BIT_AND_EXPR, integer_type_node, x, int_0xff);\n+\n+  /* \"x & 0x80 == 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 != 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, NE_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 == 0\".  */\n+  {\n+    region_model model (&mgr);\n+\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 != 0\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, NE_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* More that one bit in the mask.  */\n+\n+  /* \"x & 0xff == 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff != 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, NE_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff == 0\".  */\n+  {\n+    region_model model (&mgr);\n+\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff != 0\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, NE_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0xff);\n+  }\n+}\n+\n /* Run the selftests in this file, temporarily overriding\n    flag_analyzer_transitivity with TRANSITIVITY.  */\n \n@@ -4458,6 +4621,7 @@ run_constraint_manager_tests (bool transitivity)\n   test_purging ();\n   test_bounded_range ();\n   test_bounded_ranges ();\n+  test_bits ();\n \n   flag_analyzer_transitivity = saved_flag_analyzer_transitivity;\n }"}, {"sha": "3afbc7f848e9f4f3acd7919cc11b2e4a34970ed7", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -100,6 +100,11 @@ struct bounded_range\n \n   static int cmp (const bounded_range &a, const bounded_range &b);\n \n+  bool singleton_p () const\n+  {\n+    return tree_int_cst_equal (m_lower, m_upper);\n+  }\n+\n   tree m_lower;\n   tree m_upper;\n \n@@ -498,6 +503,8 @@ class constraint_manager\n   void add_constraint_internal (equiv_class_id lhs_id,\n \t\t\t\tenum constraint_op c_op,\n \t\t\t\tequiv_class_id rhs_id);\n+  bool impossible_derived_conditions_p (const svalue *lhs,\n+\t\t\t\t\tconst svalue *rhs) const;\n \n   region_model_manager *m_mgr;\n };"}, {"sha": "0a447f7ba26c2bbf7c43c0a29cb1ef91ad22e196", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -88,6 +88,7 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   get_best_epath (const exploded_node *target_enode,\n+\t\t  const gimple *target_stmt,\n \t\t  const pending_diagnostic &pd,\n \t\t  const char *desc, unsigned diag_idx,\n \t\t  std::unique_ptr<feasibility_problem> *out_problem);\n@@ -97,13 +98,15 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t  const gimple *target_stmt,\n \t\t\t  const pending_diagnostic &pd,\n \t\t\t  const char *desc, unsigned diag_idx);\n   bool\n   process_worklist_item (feasible_worklist *worklist,\n \t\t\t const trimmed_graph &tg,\n \t\t\t feasible_graph *fg,\n \t\t\t const exploded_node *target_enode,\n+\t\t\t const gimple *target_stmt,\n \t\t\t const pending_diagnostic &pd,\n \t\t\t unsigned diag_idx,\n \t\t\t std::unique_ptr<exploded_path> *out_best_path) const;\n@@ -128,6 +131,9 @@ class epath_finder\n /* Get the \"best\" exploded_path for reaching ENODE from the origin,\n    returning ownership of it to the caller.\n \n+   If TARGET_STMT is non-NULL, then check for reaching that stmt\n+   within ENODE.\n+\n    Ideally we want to report the shortest feasible path.\n    Return NULL if we could not find a feasible path\n    (when flag_analyzer_feasibility is true).\n@@ -141,6 +147,7 @@ class epath_finder\n \n std::unique_ptr<exploded_path>\n epath_finder::get_best_epath (const exploded_node *enode,\n+\t\t\t      const gimple *target_stmt,\n \t\t\t      const pending_diagnostic &pd,\n \t\t\t      const char *desc, unsigned diag_idx,\n \t\t\t      std::unique_ptr<feasibility_problem> *out_problem)\n@@ -165,7 +172,7 @@ epath_finder::get_best_epath (const exploded_node *enode,\n       if (logger)\n \tlogger->log (\"trying to find shortest feasible path\");\n       if (std::unique_ptr<exploded_path> epath\n-\t    = explore_feasible_paths (enode, pd, desc, diag_idx))\n+\t    = explore_feasible_paths (enode, target_stmt, pd, desc, diag_idx))\n \t{\n \t  if (logger)\n \t    logger->log (\"accepting %qs at EN: %i, SN: %i (sd: %i)\"\n@@ -335,6 +342,9 @@ class auto_checking_feasibility\n    TARGET_ENODE by iteratively building a feasible_graph, in which\n    every path to a feasible_node is feasible by construction.\n \n+   If TARGET_STMT is non-NULL, then check for reaching that stmt\n+   within TARGET_ENODE.\n+\n    We effectively explore the tree of feasible paths in order of shortest\n    path until we either find a feasible path to TARGET_ENODE, or hit\n    a limit and give up.\n@@ -378,6 +388,7 @@ class auto_checking_feasibility\n \n std::unique_ptr<exploded_path>\n epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t      const gimple *target_stmt,\n \t\t\t\t      const pending_diagnostic &pd,\n \t\t\t\t      const char *desc, unsigned diag_idx)\n {\n@@ -420,8 +431,8 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   {\n     auto_checking_feasibility sentinel (mgr);\n \n-    while (process_worklist_item (&worklist, tg, &fg, target_enode, pd,\n-\t\t\t\t  diag_idx, &best_path))\n+    while (process_worklist_item (&worklist, tg, &fg, target_enode, target_stmt,\n+\t\t\t\t  pd, diag_idx, &best_path))\n       {\n \t/* Empty; the work is done within process_worklist_item.  */\n       }\n@@ -465,6 +476,7 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t       const trimmed_graph &tg,\n \t\t       feasible_graph *fg,\n \t\t       const exploded_node *target_enode,\n+\t\t       const gimple *target_stmt,\n \t\t       const pending_diagnostic &pd,\n \t\t       unsigned diag_idx,\n \t\t       std::unique_ptr<exploded_path> *out_best_path) const\n@@ -523,7 +535,7 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t\t     \" (length: %i)\",\n \t\t\t     target_enode->m_index, diag_idx,\n \t\t\t     succ_fnode->get_path_length ());\n-\t      if (!pd.check_valid_fpath_p (succ_fnode))\n+\t      if (!pd.check_valid_fpath_p (*succ_fnode, target_stmt))\n \t\t{\n \t\t  if (logger)\n \t\t    logger->log (\"rejecting feasible path due to\"\n@@ -824,7 +836,8 @@ saved_diagnostic::calc_best_epath (epath_finder *pf)\n   LOG_SCOPE (logger);\n   m_problem = NULL;\n \n-  m_best_epath = pf->get_best_epath (m_enode, *m_d, m_d->get_kind (), m_idx,\n+  m_best_epath = pf->get_best_epath (m_enode, m_stmt,\n+\t\t\t\t     *m_d, m_d->get_kind (), m_idx,\n \t\t\t\t     &m_problem);\n \n   /* Handle failure to find a feasible path.  */"}, {"sha": "24ded2670197901c5d64efce85dd07ff7fa9a2f3", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4823,17 +4823,7 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n       auto_cfun sentinel (src_point.get_function ());\n       input_location = stmt->location;\n \n-      if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n-\tm_model.on_assignment (assign, NULL);\n-      else if (const gasm *asm_stmt = dyn_cast <const gasm *> (stmt))\n-\tm_model.on_asm_stmt (asm_stmt, NULL);\n-      else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n-\t{\n-\t  bool unknown_side_effects = m_model.on_call_pre (call, NULL);\n-\t  m_model.on_call_post (call, unknown_side_effects, NULL);\n-\t}\n-      else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n-\tm_model.on_return (return_, NULL);\n+      update_for_stmt (stmt);\n     }\n \n   const superedge *sedge = eedge->m_sedge;\n@@ -4910,6 +4900,24 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n   return true;\n }\n \n+/* Update this object for the effects of STMT.  */\n+\n+void\n+feasibility_state::update_for_stmt (const gimple *stmt)\n+{\n+  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n+    m_model.on_assignment (assign, NULL);\n+  else if (const gasm *asm_stmt = dyn_cast <const gasm *> (stmt))\n+    m_model.on_asm_stmt (asm_stmt, NULL);\n+  else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    {\n+      bool unknown_side_effects = m_model.on_call_pre (call, NULL);\n+      m_model.on_call_post (call, unknown_side_effects, NULL);\n+    }\n+  else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n+    m_model.on_return (return_, NULL);\n+}\n+\n /* Dump this object to PP.  */\n \n void"}, {"sha": "4a4ef9d12b486326c0a7154fa13f493746049d9d", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -973,6 +973,7 @@ class feasibility_state\n   bool maybe_update_for_edge (logger *logger,\n \t\t\t      const exploded_edge *eedge,\n \t\t\t      rejected_constraint **out_rc);\n+  void update_for_stmt (const gimple *stmt);\n \n   const region_model &get_model () const { return m_model; }\n   const auto_sbitmap &get_snodes_visited () const { return m_snodes_visited; }"}, {"sha": "d6ff1a3694ae60259add019bb69e8fdfac54c03b", "filename": "gcc/analyzer/feasible-graph.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -104,6 +104,36 @@ feasible_node::dump_dot (graphviz_out *gv,\n   pp_flush (pp);\n }\n \n+/* Attempt to get the region_model for this node's state at TARGET_STMT.\n+   Return true and write to *OUT if found.\n+   Return false if there's a problem.  */\n+\n+bool\n+feasible_node::get_state_at_stmt (const gimple *target_stmt,\n+\t\t\t\t  region_model *out) const\n+{\n+  if (!target_stmt)\n+    return false;\n+\n+  feasibility_state result (m_state);\n+\n+  /* Update state for the stmts that were processed in each enode.  */\n+  for (unsigned stmt_idx = 0; stmt_idx < m_inner_node->m_num_processed_stmts;\n+       stmt_idx++)\n+    {\n+      const gimple *stmt = m_inner_node->get_processed_stmt (stmt_idx);\n+      if (stmt == target_stmt)\n+\t{\n+\t  *out = result.get_model ();\n+\t  return true;\n+\t}\n+      result.update_for_stmt (stmt);\n+    }\n+\n+  /* TARGET_STMT not found; wrong node?  */\n+  return false;\n+}\n+\n /* Implementation of dump_dot vfunc for infeasible_node.\n    In particular, show the rejected constraint.  */\n "}, {"sha": "0da7265979beb4b3b6610c82ed524175a7e8316d", "filename": "gcc/analyzer/feasible-graph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Ffeasible-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Ffeasible-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_FEASIBLE_GRAPH_H\n #define GCC_ANALYZER_FEASIBLE_GRAPH_H\n \n+#include \"analyzer/exploded-graph.h\"\n+\n namespace ana {\n \n /* Forward decls.  */\n@@ -102,6 +104,9 @@ class feasible_node : public base_feasible_node\n \n   unsigned get_path_length () const { return m_path_length; }\n \n+  bool get_state_at_stmt (const gimple *target_stmt,\n+\t\t\t  region_model *out) const;\n+\n private:\n   feasibility_state m_state;\n   unsigned m_path_length;"}, {"sha": "1886534313eb6083955ecf99da005ab70c271686", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -203,18 +203,19 @@ class infinite_recursion_diagnostic\n   /* Reject paths in which conjured svalues have affected control flow\n      since m_prev_entry_enode.  */\n \n-  bool check_valid_fpath_p (const feasible_node *final_fnode)\n+  bool check_valid_fpath_p (const feasible_node &final_fnode,\n+\t\t\t    const gimple *)\n     const final override\n   {\n     /* Reject paths in which calls with unknown side effects have occurred\n        since m_prev_entry_enode.\n        Find num calls with side effects.  Walk backward until we reach the\n        pref */\n-    gcc_assert (final_fnode->get_inner_node () == m_new_entry_enode);\n+    gcc_assert (final_fnode.get_inner_node () == m_new_entry_enode);\n \n     /* FG is actually a tree.  Walk backwards from FINAL_FNODE until we\n        reach the prev_entry_enode (or the origin).  */\n-    const feasible_node *iter_fnode = final_fnode;\n+    const feasible_node *iter_fnode = &final_fnode;\n     while (iter_fnode->get_inner_node ()->m_index != 0)\n       {\n \tgcc_assert (iter_fnode->m_preds.length () == 1);"}, {"sha": "e36ed4fd9c1f9ea96f4c42811b252b99cb99f9ed", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -139,6 +139,12 @@ static bool\n fixup_location_in_macro_p (cpp_hashnode *macro)\n {\n   ht_identifier ident = macro->ident;\n+\n+  /* Don't unwind inside \"alloca\" macro, so that we don't suppress warnings\n+     from it (due to being in system headers).  */\n+  if (ht_ident_eq (ident, \"alloca\"))\n+    return true;\n+\n   /* Don't unwind inside <stdarg.h> macros, so that we don't suppress warnings\n      from them (due to being in system headers).  */\n   if (ht_ident_eq (ident, \"va_start\")"}, {"sha": "d9e9e7f89052b15fa148fc4e0409c1198dd98273", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -351,7 +351,8 @@ class pending_diagnostic\n   /* Vfunc to give diagnostic subclasses the opportunity to reject diagnostics\n      by imposing their own additional feasibility checks on the path to a\n      given feasible_node.  */\n-  virtual bool check_valid_fpath_p (const feasible_node *) const\n+  virtual bool check_valid_fpath_p (const feasible_node &,\n+\t\t\t\t    const gimple *) const\n   {\n     /* Default implementation: accept this path.  */\n     return true;"}, {"sha": "e3de74bbf45baf39469ee53be32facaf74b13b55", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-rich-location.h\"\n #include \"analyzer/checker-event.h\"\n #include \"analyzer/checker-path.h\"\n+#include \"analyzer/feasible-graph.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -468,9 +469,11 @@ class poisoned_value_diagnostic\n {\n public:\n   poisoned_value_diagnostic (tree expr, enum poison_kind pkind,\n-\t\t\t     const region *src_region)\n+\t\t\t     const region *src_region,\n+\t\t\t     tree check_expr)\n   : m_expr (expr), m_pkind (pkind),\n-    m_src_region (src_region)\n+    m_src_region (src_region),\n+    m_check_expr (check_expr)\n   {}\n \n   const char *get_kind () const final override { return \"poisoned_value_diagnostic\"; }\n@@ -563,10 +566,47 @@ class poisoned_value_diagnostic\n       interest->add_region_creation (m_src_region);\n   }\n \n+  /* Attempt to suppress false positives.\n+     Reject paths where the value of the underlying region isn't poisoned.\n+     This can happen due to state merging when exploring the exploded graph,\n+     where the more precise analysis during feasibility analysis finds that\n+     the region is in fact valid.\n+     To do this we need to get the value from the fgraph.  Unfortunately\n+     we can't simply query the state of m_src_region (from the enode),\n+     since it might be a different region in the fnode state (e.g. with\n+     heap-allocated regions, the numbering could be different).\n+     Hence we access m_check_expr, if available.  */\n+\n+  bool check_valid_fpath_p (const feasible_node &fnode,\n+\t\t\t    const gimple *emission_stmt)\n+    const final override\n+  {\n+    if (!m_check_expr)\n+      return true;\n+\n+    /* We've reached the enode, but not necessarily the right function_point.\n+       Try to get the state at the correct stmt.  */\n+    region_model emission_model (fnode.get_model ().get_manager());\n+    if (!fnode.get_state_at_stmt (emission_stmt, &emission_model))\n+      /* Couldn't get state; accept this diagnostic.  */\n+      return true;\n+\n+    const svalue *fsval = emission_model.get_rvalue (m_check_expr, NULL);\n+    /* Check to see if the expr is also poisoned in FNODE (and in the\n+       same way).  */\n+    const poisoned_svalue * fspval = fsval->dyn_cast_poisoned_svalue ();\n+    if (!fspval)\n+      return false;\n+    if (fspval->get_poison_kind () != m_pkind)\n+      return false;\n+    return true;\n+  }\n+\n private:\n   tree m_expr;\n   enum poison_kind m_pkind;\n   const region *m_src_region;\n+  tree m_check_expr;\n };\n \n /* A subclass of pending_diagnostic for complaining about shifts\n@@ -1050,9 +1090,22 @@ region_model::check_for_poison (const svalue *sval,\n       tree diag_arg = fixup_tree_for_diagnostic (expr);\n       if (src_region == NULL && pkind == POISON_KIND_UNINIT)\n \tsrc_region = get_region_for_poisoned_expr (expr);\n+\n+      /* Can we reliably get the poisoned value from \"expr\"?\n+\t This is for use by poisoned_value_diagnostic::check_valid_fpath_p.\n+\t Unfortunately, we might not have a reliable value for EXPR.\n+\t Hence we only query its value now, and only use it if we get the\n+\t poisoned value back again.  */\n+      tree check_expr = expr;\n+      const svalue *foo_sval = get_rvalue (expr, NULL);\n+      if (foo_sval == sval)\n+\tcheck_expr = expr;\n+      else\n+\tcheck_expr = NULL;\n       if (ctxt->warn (make_unique<poisoned_value_diagnostic> (diag_arg,\n \t\t\t\t\t\t\t      pkind,\n-\t\t\t\t\t\t\t      src_region)))\n+\t\t\t\t\t\t\t      src_region,\n+\t\t\t\t\t\t\t      check_expr)))\n \t{\n \t  /* We only want to report use of a poisoned value at the first\n \t     place it gets used; return an unknown value to avoid generating\n@@ -2200,6 +2253,9 @@ region_model::get_rvalue_1 (path_var pv, region_model_context *ctxt) const\n     /* Binary ops.  */\n     case PLUS_EXPR:\n     case MULT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n \t{\n \t  tree expr = pv.m_tree;\n \t  tree arg0 = TREE_OPERAND (expr, 0);\n@@ -2486,7 +2542,7 @@ region_model::deref_rvalue (const svalue *ptr_sval, tree ptr_tree,\n \t\t  = as_a <const poisoned_svalue *> (ptr_sval);\n \t\tenum poison_kind pkind = poisoned_sval->get_poison_kind ();\n \t\tctxt->warn (make_unique<poisoned_value_diagnostic>\n-\t\t\t      (ptr, pkind, NULL));\n+\t\t\t      (ptr, pkind, NULL, NULL));\n \t      }\n \t  }\n       }\n@@ -5010,6 +5066,16 @@ region_model::get_or_create_region_for_heap_alloc (const svalue *size_in_bytes,\n      this path.  */\n   auto_bitmap base_regs_in_use;\n   get_referenced_base_regions (base_regs_in_use);\n+\n+  /* Don't reuse regions that are marked as TOUCHED.  */\n+  for (store::cluster_map_t::iterator iter = m_store.begin ();\n+       iter != m_store.end (); ++iter)\n+    if ((*iter).second->touched_p ())\n+      {\n+\tconst region *base_reg = (*iter).first;\n+\tbitmap_set_bit (base_regs_in_use, base_reg->get_id ());\n+      }\n+\n   const region *reg\n     = m_mgr->get_or_create_region_for_heap_alloc (base_regs_in_use);\n   if (size_in_bytes)"}, {"sha": "d107390bc0058e807def257c1ba5c2a3d48de0a4", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1339,11 +1339,14 @@ fd_state_machine::check_for_fd_attrs (\n \t  if (!(is_valid_fd_p (state) || (state == m_stop)))\n \t    {\n \t      if (!is_constant_fd_p (state))\n-\t\tsm_ctxt->warn (node, stmt, arg,\n-\t\t\t       make_unique<fd_use_without_check>\n+\t\t{\n+\t\t  sm_ctxt->warn (node, stmt, arg,\n+\t\t\t\t make_unique<fd_use_without_check>\n \t\t\t\t (*this, diag_arg,\n \t\t\t\t  callee_fndecl, attr_name,\n \t\t\t\t  arg_idx));\n+\t\t  continue;\n+\t\t}\n \t    }\n \n \t  switch (fd_attr_access_dir)\n@@ -1906,6 +1909,7 @@ fd_state_machine::on_listen (const call_details &cd,\n   if (!(old_state == m_start\n \t|| old_state == m_constant_fd\n \t|| old_state == m_stop\n+\t|| old_state == m_invalid\n \t|| old_state == m_bound_stream_socket\n \t|| old_state == m_bound_unknown_socket\n \t/* Assume it's OK to call \"listen\" more than once.  */\n@@ -2655,6 +2659,38 @@ class kf_pipe : public known_function\n   unsigned m_num_args;\n };\n \n+/* Handler for \"read\".\n+     ssize_t read(int fildes, void *buf, size_t nbyte);\n+   See e.g. https://man7.org/linux/man-pages/man2/read.2.html   */\n+\n+class kf_read : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (1)\n+\t    && cd.arg_is_size_p (2));\n+  }\n+\n+  /* For now, assume that any call to \"read\" fully clobbers the buffer\n+     passed in.  This isn't quite correct (e.g. errors, partial reads;\n+     see PR analyzer/108689), but at least stops us falsely complaining\n+     about the buffer being uninitialized.  */\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (1);\n+    if (const region *reg = ptr_sval->maybe_get_region ())\n+      {\n+\tconst region *base_reg = reg->get_base_region ();\n+\tconst svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+\tmodel->set_value (base_reg, new_sval, cd.get_ctxt ());\n+      }\n+  }\n+};\n+\n+\n /* Populate KFM with instances of known functions relating to\n    file descriptors.  */\n \n@@ -2668,6 +2704,7 @@ register_known_fd_functions (known_function_manager &kfm)\n   kfm.add (\"listen\", make_unique<kf_listen> ());\n   kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n   kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n+  kfm.add (\"read\", make_unique<kf_read> ());\n   kfm.add (\"socket\", make_unique<kf_socket> ());\n }\n "}, {"sha": "d99a09b76c4601ea3723b3b4bfa2ac2e3d9b4583", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -560,7 +560,11 @@ class kf_fgets : public known_function\n   }\n };\n \n-/* Handler for \"fread\"\".  */\n+/* Handler for \"fread\".\n+     size_t fread(void *restrict buffer, size_t size, size_t count,\n+\t\t  FILE *restrict stream);\n+   See e.g. https://en.cppreference.com/w/c/io/fread\n+   and https://www.man7.org/linux/man-pages/man3/fread.3.html */\n \n class kf_fread : public known_function\n {\n@@ -574,6 +578,10 @@ class kf_fread : public known_function\n \t    && cd.arg_is_pointer_p (3));\n   }\n \n+  /* For now, assume that any call to \"fread\" fully clobbers the buffer\n+     passed in.  This isn't quite correct (e.g. errors, partial reads;\n+     see PR analyzer/108689), but at least stops us falsely complaining\n+     about the buffer being uninitialized.  */\n   void impl_call_pre (const call_details &cd) const final override\n   {\n     region_model *model = cd.get_model ();"}, {"sha": "c24fe7374812d11e3e691b752c7a6da5079d8c00", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1519,6 +1519,43 @@ class deref_before_check : public malloc_diagnostic\n \t!= &m_check_enode->get_point ().get_call_string ())\n       return false;\n \n+    /* Reject the warning if the check occurs within a macro defintion.\n+       This avoids false positives for such code as:\n+\n+\t#define throw_error \\\n+\t   do {             \\\n+\t     if (p)         \\\n+\t       cleanup (p); \\\n+\t     return;        \\\n+\t   } while (0)\n+\n+\tif (p->idx >= n)\n+\t  throw_error ();\n+\n+       where the usage of \"throw_error\" implicitly adds a check\n+       on 'p'.\n+\n+       We do warn when the check is in a macro expansion if we can get\n+       at the location of the condition and it is't part of the\n+       definition, so that we warn for checks such as:\n+\t   if (words[0][0] == '@')\n+\t     return;\n+\t   g_assert(words[0] != NULL); <--- here\n+       Unfortunately we don't have locations for individual gimple\n+       arguments, so in:\n+\t   g_assert (ptr);\n+       we merely have a gimple_cond\n+\t   if (p_2(D) == 0B)\n+       with no way of getting at the location of the condition separately\n+       from that of the gimple_cond (where the \"if\" is within the macro\n+       definition).  We reject the warning for such cases.\n+\n+       We do warn when the *deref* occurs in a macro, since this can be\n+       a source of real bugs; see e.g. PR 77425.  */\n+    location_t check_loc = m_check_enode->get_point ().get_location ();\n+    if (linemap_location_from_macro_definition_p (line_table, check_loc))\n+      return false;\n+\n     /* Reject the warning if the deref's BB doesn't dominate that\n        of the check, so that we don't warn e.g. for shared cleanup\n        code that checks a pointer for NULL, when that code is sometimes"}, {"sha": "3a73146d928b1ab775934e91842b102367747dd8", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -63,6 +63,8 @@ get_candidate_for_purging (tree node)\n       default:\n \treturn NULL_TREE;\n \n+      case ADDR_EXPR:\n+      case MEM_REF:\n       case COMPONENT_REF:\n \titer = TREE_OPERAND (iter, 0);\n \tcontinue;\n@@ -922,7 +924,20 @@ process_point_backwards (const function_point &point,\n       {\n \t/* This is somewhat equivalent to how the SSA case handles\n \t   def-stmts.  */\n-\tif (fully_overwrites_p (point.get_stmt (), m_decl, model))\n+\tif (fully_overwrites_p (point.get_stmt (), m_decl, model)\n+\t    /* ...but we mustn't be at a point that also consumes the\n+\t       current value of the decl when it's generating the new\n+\t       value, for cases such as\n+\t\t  struct st s;\n+\t\t  s = foo ();\n+\t\t  s = bar (s);\n+\t       where we want to make sure that we don't stop at the:\n+\t\t  s = bar (s);\n+\t       since otherwise we would erroneously purge the state of \"s\"\n+\t       after:\n+\t\t  s = foo ();\n+\t    */\n+\t    && !m_points_needing_decl.contains (point))\n \t  {\n \t    if (logger)\n \t      logger->log (\"stmt fully overwrites %qE; terminating\", m_decl);"}, {"sha": "f56d084bc7ab5c311fdfd837d83051e4213c3935", "filename": "gcc/asan.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fasan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fasan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -391,6 +391,46 @@ asan_memintrin (void)\n }\n \n \n+/* Support for --param asan-kernel-mem-intrinsic-prefix=1.  */\n+static GTY(()) rtx asan_memfn_rtls[3];\n+\n+rtx\n+asan_memfn_rtl (tree fndecl)\n+{\n+  int i;\n+  const char *f, *p;\n+  char buf[sizeof (\"__hwasan_memmove\")];\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_MEMCPY: i = 0; f = \"memcpy\"; break;\n+    case BUILT_IN_MEMSET: i = 1; f = \"memset\"; break;\n+    case BUILT_IN_MEMMOVE: i = 2; f = \"memmove\"; break;\n+    default: gcc_unreachable ();\n+    }\n+  if (asan_memfn_rtls[i] == NULL_RTX)\n+    {\n+      tree save_name = DECL_NAME (fndecl);\n+      tree save_assembler_name = DECL_ASSEMBLER_NAME (fndecl);\n+      rtx save_rtl = DECL_RTL (fndecl);\n+      if (flag_sanitize & SANITIZE_KERNEL_HWADDRESS)\n+\tp = \"__hwasan_\";\n+      else\n+\tp = \"__asan_\";\n+      strcpy (buf, p);\n+      strcat (buf, f);\n+      DECL_NAME (fndecl) = get_identifier (buf);\n+      DECL_ASSEMBLER_NAME_RAW (fndecl) = NULL_TREE;\n+      SET_DECL_RTL (fndecl, NULL_RTX);\n+      asan_memfn_rtls[i] = DECL_RTL (fndecl);\n+      DECL_NAME (fndecl) = save_name;\n+      DECL_ASSEMBLER_NAME_RAW (fndecl) = save_assembler_name;\n+      SET_DECL_RTL (fndecl, save_rtl);\n+    }\n+  return asan_memfn_rtls[i];\n+}\n+\n+\n /* Checks whether section SEC should be sanitized.  */\n \n static bool\n@@ -2951,6 +2991,7 @@ maybe_instrument_call (gimple_stmt_iterator *iter)\n \t  switch (DECL_FUNCTION_CODE (callee))\n \t    {\n \t    case BUILT_IN_UNREACHABLE:\n+\t    case BUILT_IN_UNREACHABLE_TRAP:\n \t    case BUILT_IN_TRAP:\n \t      /* Don't instrument these.  */\n \t      return false;"}, {"sha": "7d26b413ac51b6769a356b909902a5d02dfa010b", "filename": "gcc/asan.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -33,6 +33,7 @@ extern bool asan_expand_check_ifn (gimple_stmt_iterator *, bool);\n extern bool asan_expand_mark_ifn (gimple_stmt_iterator *);\n extern bool asan_expand_poison_ifn (gimple_stmt_iterator *, bool *,\n \t\t\t\t    hash_map<tree, tree> &);\n+extern rtx asan_memfn_rtl (tree);\n \n extern void hwasan_record_frame_init ();\n extern void hwasan_record_stack_var (rtx, rtx, poly_int64, poly_int64);\n@@ -139,7 +140,7 @@ extern bool asan_mark_p (gimple *stmt, enum asan_mark_flags flag);\n /* Return the size of padding needed to insert after a protected\n    decl of SIZE.  */\n \n-static inline unsigned int\n+inline unsigned int\n asan_red_zone_size (unsigned int size)\n {\n   unsigned int c = size & (ASAN_RED_ZONE_SIZE - 1);\n@@ -149,7 +150,7 @@ asan_red_zone_size (unsigned int size)\n /* Return how much a stack variable occupis on a stack\n    including a space for red zone.  */\n \n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n asan_var_and_redzone_size (unsigned HOST_WIDE_INT size)\n {\n   if (size <= 4)\n@@ -181,7 +182,7 @@ extern hash_set<tree> *asan_handled_variables;\n /* Return TRUE if builtin with given FCODE will be intercepted by\n    libasan.  */\n \n-static inline bool\n+inline bool\n asan_intercepted_p (enum built_in_function fcode)\n {\n   if (hwasan_sanitize_p ())\n@@ -212,7 +213,7 @@ asan_intercepted_p (enum built_in_function fcode)\n \n /* Return TRUE if we should instrument for use-after-scope sanity checking.  */\n \n-static inline bool\n+inline bool\n asan_sanitize_use_after_scope (void)\n {\n   return (flag_sanitize_address_use_after_scope\n@@ -221,7 +222,7 @@ asan_sanitize_use_after_scope (void)\n \n /* Return true if DECL should be guarded on the stack.  */\n \n-static inline bool\n+inline bool\n asan_protect_stack_decl (tree decl)\n {\n   return DECL_P (decl)\n@@ -232,7 +233,7 @@ asan_protect_stack_decl (tree decl)\n /* Return true when flag_sanitize & FLAG is non-zero.  If FN is non-null,\n    remove all flags mentioned in \"no_sanitize\" of DECL_ATTRIBUTES.  */\n \n-static inline bool\n+inline bool\n sanitize_flags_p (unsigned int flag, const_tree fn = current_function_decl)\n {\n   unsigned int result_flags = flag_sanitize & flag;\n@@ -251,7 +252,7 @@ sanitize_flags_p (unsigned int flag, const_tree fn = current_function_decl)\n \n /* Return true when coverage sanitization should happend for FN function.  */\n \n-static inline bool\n+inline bool\n sanitize_coverage_p (const_tree fn = current_function_decl)\n {\n   return (flag_sanitize_coverage"}, {"sha": "b1300018d1e8ed8e02ded1ea721dc192a6d32a49", "filename": "gcc/attribs.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fattribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fattribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -846,6 +846,7 @@ decl_attributes (tree *node, tree attributes, int flags,\n \t      || !DECL_P (*anode)\n \t      || DECL_BUILT_IN_CLASS (*anode) != BUILT_IN_NORMAL\n \t      || (DECL_FUNCTION_CODE (*anode) != BUILT_IN_UNREACHABLE\n+\t\t  && DECL_FUNCTION_CODE (*anode) != BUILT_IN_UNREACHABLE_TRAP\n \t\t  && (DECL_FUNCTION_CODE (*anode)\n \t\t      != BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE)))\n \t    {"}, {"sha": "84a43658a70dab576c212491df234aa1049016fc", "filename": "gcc/attribs.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -148,7 +148,7 @@ canonicalize_attr_name (const char *&s, T &l)\n /* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters\n    so that we have a canonical form of attribute names.  */\n \n-static inline tree\n+inline tree\n canonicalize_attr_name (tree attr_name)\n {\n   size_t l = IDENTIFIER_LENGTH (attr_name);\n@@ -163,7 +163,7 @@ canonicalize_attr_name (tree attr_name)\n /* Compare attribute identifiers ATTR1 and ATTR2 with length ATTR1_LEN and\n    ATTR2_LEN.  */\n \n-static inline bool\n+inline bool\n cmp_attribs (const char *attr1, size_t attr1_len,\n \t     const char *attr2, size_t attr2_len)\n {\n@@ -172,7 +172,7 @@ cmp_attribs (const char *attr1, size_t attr1_len,\n \n /* Compare attribute identifiers ATTR1 and ATTR2.  */\n \n-static inline bool\n+inline bool\n cmp_attribs (const char *attr1, const char *attr2)\n {\n   return cmp_attribs (attr1, strlen (attr1), attr2, strlen (attr2));\n@@ -181,7 +181,7 @@ cmp_attribs (const char *attr1, const char *attr2)\n /* Given an identifier node IDENT and a string ATTR_NAME, return true\n    if the identifier node is a valid attribute name for the string.  */\n \n-static inline bool\n+inline bool\n is_attribute_p (const char *attr_name, const_tree ident)\n {\n   return cmp_attribs (attr_name, strlen (attr_name),\n@@ -193,7 +193,7 @@ is_attribute_p (const char *attr_name, const_tree ident)\n    for standard attribute (NULL get_attribute_namespace) or \"gnu\"\n    namespace.  */\n \n-static inline bool\n+inline bool\n is_attribute_namespace_p (const char *attr_ns, const_tree attr)\n {\n   tree ident = get_attribute_namespace (attr);\n@@ -212,7 +212,7 @@ is_attribute_namespace_p (const char *attr_ns, const_tree attr)\n    occurrences are wanted.  ATTR_NAME must be in the form 'text' (not\n    '__text__').  */\n \n-static inline tree\n+inline tree\n lookup_attribute (const char *attr_name, tree list)\n {\n   if (CHECKING_P && attr_name[0] != '_')\n@@ -236,7 +236,7 @@ lookup_attribute (const char *attr_name, tree list)\n /* Similar to lookup_attribute, but also match the attribute namespace.\n    ATTR_NS \"\" stands for either standard attribute or \"gnu\" namespace.  */\n \n-static inline tree\n+inline tree\n lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n {\n   if (CHECKING_P && attr_name[0] != '_')\n@@ -269,7 +269,7 @@ lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n    starts with ATTR_NAME.  ATTR_NAME must be in the form 'text' (not\n    '__text__').  */\n \n-static inline tree\n+inline tree\n lookup_attribute_by_prefix (const char *attr_name, tree list)\n {\n   gcc_checking_assert (attr_name[0] != '_');"}, {"sha": "29191e56720b55b26e061bca1452118446f47e1a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -309,15 +309,15 @@ enum cfg_bb_flags\n \n /* Returns true if BB has precisely one successor.  */\n \n-static inline bool\n+inline bool\n single_succ_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->succs) == 1;\n }\n \n /* Returns true if BB has precisely one predecessor.  */\n \n-static inline bool\n+inline bool\n single_pred_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->preds) == 1;\n@@ -326,7 +326,7 @@ single_pred_p (const_basic_block bb)\n /* Returns the single successor edge of basic block BB.  Aborts if\n    BB does not have exactly one successor.  */\n \n-static inline edge\n+inline edge\n single_succ_edge (const_basic_block bb)\n {\n   gcc_checking_assert (single_succ_p (bb));\n@@ -336,7 +336,7 @@ single_succ_edge (const_basic_block bb)\n /* Returns the single predecessor edge of basic block BB.  Aborts\n    if BB does not have exactly one predecessor.  */\n \n-static inline edge\n+inline edge\n single_pred_edge (const_basic_block bb)\n {\n   gcc_checking_assert (single_pred_p (bb));\n@@ -346,7 +346,7 @@ single_pred_edge (const_basic_block bb)\n /* Returns the single successor block of basic block BB.  Aborts\n    if BB does not have exactly one successor.  */\n \n-static inline basic_block\n+inline basic_block\n single_succ (const_basic_block bb)\n {\n   return single_succ_edge (bb)->dest;\n@@ -355,7 +355,7 @@ single_succ (const_basic_block bb)\n /* Returns the single predecessor block of basic block BB.  Aborts\n    if BB does not have exactly one predecessor.*/\n \n-static inline basic_block\n+inline basic_block\n single_pred (const_basic_block bb)\n {\n   return single_pred_edge (bb)->src;\n@@ -368,7 +368,7 @@ struct edge_iterator {\n   vec<edge, va_gc> **container;\n };\n \n-static inline vec<edge, va_gc> *\n+inline vec<edge, va_gc> *\n ei_container (edge_iterator i)\n {\n   gcc_checking_assert (i.container);\n@@ -379,7 +379,7 @@ ei_container (edge_iterator i)\n #define ei_last(iter) ei_last_1 (&(iter))\n \n /* Return an iterator pointing to the start of an edge vector.  */\n-static inline edge_iterator\n+inline edge_iterator\n ei_start_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n@@ -392,7 +392,7 @@ ei_start_1 (vec<edge, va_gc> **ev)\n \n /* Return an iterator pointing to the last element of an edge\n    vector.  */\n-static inline edge_iterator\n+inline edge_iterator\n ei_last_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n@@ -404,38 +404,38 @@ ei_last_1 (vec<edge, va_gc> **ev)\n }\n \n /* Is the iterator `i' at the end of the sequence?  */\n-static inline bool\n+inline bool\n ei_end_p (edge_iterator i)\n {\n   return (i.index == EDGE_COUNT (ei_container (i)));\n }\n \n /* Is the iterator `i' at one position before the end of the\n    sequence?  */\n-static inline bool\n+inline bool\n ei_one_before_end_p (edge_iterator i)\n {\n   return (i.index + 1 == EDGE_COUNT (ei_container (i)));\n }\n \n /* Advance the iterator to the next element.  */\n-static inline void\n+inline void\n ei_next (edge_iterator *i)\n {\n   gcc_checking_assert (i->index < EDGE_COUNT (ei_container (*i)));\n   i->index++;\n }\n \n /* Move the iterator to the previous element.  */\n-static inline void\n+inline void\n ei_prev (edge_iterator *i)\n {\n   gcc_checking_assert (i->index > 0);\n   i->index--;\n }\n \n /* Return the edge pointed to by the iterator `i'.  */\n-static inline edge\n+inline edge\n ei_edge (edge_iterator i)\n {\n   return EDGE_I (ei_container (i), i.index);\n@@ -444,7 +444,7 @@ ei_edge (edge_iterator i)\n /* Return an edge pointed to by the iterator.  Do it safely so that\n    NULL is returned when the iterator is pointing at the end of the\n    sequence.  */\n-static inline edge\n+inline edge\n ei_safe_edge (edge_iterator i)\n {\n   return !ei_end_p (i) ? ei_edge (i) : NULL;\n@@ -454,7 +454,7 @@ ei_safe_edge (edge_iterator i)\n    *Edge P is set to the next edge if we are to continue to iterate\n    and NULL otherwise.  */\n \n-static inline bool\n+inline bool\n ei_cond (edge_iterator ei, edge *p)\n {\n   if (!ei_end_p (ei))\n@@ -505,14 +505,14 @@ ei_cond (edge_iterator ei, edge *p)\n \n /* Return true if BB is in a transaction.  */\n \n-static inline bool\n+inline bool\n bb_in_transaction (basic_block bb)\n {\n   return bb->flags & BB_IN_TRANSACTION;\n }\n \n /* Return true when one of the predecessor edges of BB is marked with EDGE_EH.  */\n-static inline bool\n+inline bool\n bb_has_eh_pred (basic_block bb)\n {\n   edge e;\n@@ -527,7 +527,7 @@ bb_has_eh_pred (basic_block bb)\n }\n \n /* Return true when one of the predecessor edges of BB is marked with EDGE_ABNORMAL.  */\n-static inline bool\n+inline bool\n bb_has_abnormal_pred (basic_block bb)\n {\n   edge e;\n@@ -542,7 +542,7 @@ bb_has_abnormal_pred (basic_block bb)\n }\n \n /* Return the fallthru edge in EDGES if it exists, NULL otherwise.  */\n-static inline edge\n+inline edge\n find_fallthru_edge (vec<edge, va_gc> *edges)\n {\n   edge e;\n@@ -557,7 +557,7 @@ find_fallthru_edge (vec<edge, va_gc> *edges)\n \n /* Check tha probability is sane.  */\n \n-static inline void\n+inline void\n check_probability (int prob)\n {\n   gcc_checking_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n@@ -566,7 +566,7 @@ check_probability (int prob)\n /* Given PROB1 and PROB2, return PROB1*PROB2/REG_BR_PROB_BASE. \n    Used to combine BB probabilities.  */\n \n-static inline int\n+inline int\n combine_probabilities (int prob1, int prob2)\n {\n   check_probability (prob1);\n@@ -578,15 +578,15 @@ combine_probabilities (int prob1, int prob2)\n    interface when potentially scaling up, so that SCALE is not\n    constrained to be < REG_BR_PROB_BASE.  */\n \n-static inline gcov_type\n+inline gcov_type\n apply_scale (gcov_type freq, gcov_type scale)\n {\n   return RDIV (freq * scale, REG_BR_PROB_BASE);\n }\n \n /* Apply probability PROB on frequency or count FREQ.  */\n \n-static inline gcov_type\n+inline gcov_type\n apply_probability (gcov_type freq, int prob)\n {\n   check_probability (prob);\n@@ -595,7 +595,7 @@ apply_probability (gcov_type freq, int prob)\n \n /* Return inverse probability for PROB.  */\n \n-static inline int\n+inline int\n inverse_probability (int prob1)\n {\n   check_probability (prob1);\n@@ -604,7 +604,7 @@ inverse_probability (int prob1)\n \n /* Return true if BB has at least one abnormal outgoing edge.  */\n \n-static inline bool\n+inline bool\n has_abnormal_or_eh_outgoing_edge_p (basic_block bb)\n {\n   edge e;\n@@ -620,7 +620,7 @@ has_abnormal_or_eh_outgoing_edge_p (basic_block bb)\n /* Return true when one of the predecessor edges of BB is marked with\n    EDGE_ABNORMAL_CALL or EDGE_EH.  */\n \n-static inline bool\n+inline bool\n has_abnormal_call_or_eh_pred_edge_p (basic_block bb)\n {\n   edge e;"}, {"sha": "43337d2e9d9ed8c1be2c230221f2c8e7204d9f8f", "filename": "gcc/bitmap.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -461,7 +461,7 @@ extern void dump_bitmap_statistics (void);\n /* Initialize a bitmap header.  OBSTACK indicates the bitmap obstack\n    to allocate from, NULL for GC'd bitmap.  */\n \n-static inline void\n+inline void\n bitmap_initialize (bitmap head, bitmap_obstack *obstack CXX_MEM_STAT_INFO)\n {\n   head->first = head->current = NULL;\n@@ -476,7 +476,7 @@ bitmap_initialize (bitmap head, bitmap_obstack *obstack CXX_MEM_STAT_INFO)\n /* Release a bitmap (but not its head).  This is suitable for pairing with\n    bitmap_initialize.  */\n \n-static inline void\n+inline void\n bitmap_release (bitmap head)\n {\n   bitmap_clear (head);\n@@ -532,7 +532,7 @@ struct bitmap_iterator\n /* Initialize a single bitmap iterator.  START_BIT is the first bit to\n    iterate from.  */\n \n-static inline void\n+inline void\n bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,\n \t\t   unsigned start_bit, unsigned *bit_no)\n {\n@@ -576,7 +576,7 @@ bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,\n /* Initialize an iterator to iterate over the intersection of two\n    bitmaps.  START_BIT is the bit to commence from.  */\n \n-static inline void\n+inline void\n bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n \t\t   unsigned start_bit, unsigned *bit_no)\n {\n@@ -645,7 +645,7 @@ bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n \n /* Initialize an iterator to iterate over the bits in MAP1 & ~MAP2.  */\n \n-static inline void\n+inline void\n bmp_iter_and_compl_init (bitmap_iterator *bi,\n \t\t\t const_bitmap map1, const_bitmap map2,\n \t\t\t unsigned start_bit, unsigned *bit_no)\n@@ -696,7 +696,7 @@ bmp_iter_and_compl_init (bitmap_iterator *bi,\n /* Advance to the next bit in BI.  We don't advance to the next\n    nonzero bit yet.  */\n \n-static inline void\n+inline void\n bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n {\n   bi->bits >>= 1;\n@@ -705,7 +705,7 @@ bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n \n /* Advance to first set bit in BI.  */\n \n-static inline void\n+inline void\n bmp_iter_next_bit (bitmap_iterator * bi, unsigned *bit_no)\n {\n #if (GCC_VERSION >= 3004)\n@@ -728,7 +728,7 @@ bmp_iter_next_bit (bitmap_iterator * bi, unsigned *bit_no)\n    already advanced past the just iterated bit.  Return true if there\n    is a bit to iterate.  */\n \n-static inline bool\n+inline bool\n bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */\n@@ -774,7 +774,7 @@ bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n    bitmaps.  We will have already advanced past the just iterated bit.\n    Return true if there is a bit to iterate.  */\n \n-static inline bool\n+inline bool\n bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */\n@@ -843,7 +843,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n    complemented bitmaps.  We will have already advanced past the just\n    iterated bit.  */\n \n-static inline bool\n+inline bool\n bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */"}, {"sha": "4d467c8c5c10a5f86875fd0a3dbca435ec4e63c9", "filename": "gcc/builtins.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -7326,7 +7326,24 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n      by ASan.  */\n \n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  if ((flag_sanitize & SANITIZE_ADDRESS) && asan_intercepted_p (fcode))\n+  if (param_asan_kernel_mem_intrinsic_prefix\n+      && sanitize_flags_p (SANITIZE_KERNEL_ADDRESS\n+\t\t\t   | SANITIZE_KERNEL_HWADDRESS))\n+    switch (fcode)\n+      {\n+\trtx save_decl_rtl, ret;\n+      case BUILT_IN_MEMCPY:\n+      case BUILT_IN_MEMMOVE:\n+      case BUILT_IN_MEMSET:\n+\tsave_decl_rtl = DECL_RTL (fndecl);\n+\tDECL_RTL (fndecl) = asan_memfn_rtl (fndecl);\n+\tret = expand_call (exp, target, ignore);\n+\tDECL_RTL (fndecl) = save_decl_rtl;\n+\treturn ret;\n+      default:\n+\tbreak;\n+      }\n+  if (sanitize_flags_p (SANITIZE_ADDRESS) && asan_intercepted_p (fcode))\n     return expand_call (exp, target, ignore);\n \n   /* When not optimizing, generate calls to library functions for a certain\n@@ -7844,6 +7861,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       break;\n \n     case BUILT_IN_TRAP:\n+    case BUILT_IN_UNREACHABLE_TRAP:\n       expand_builtin_trap ();\n       return const0_rtx;\n \n@@ -11310,6 +11328,7 @@ is_inexpensive_builtin (tree decl)\n       case BUILT_IN_VA_ARG_PACK_LEN:\n       case BUILT_IN_VA_COPY:\n       case BUILT_IN_TRAP:\n+      case BUILT_IN_UNREACHABLE_TRAP:\n       case BUILT_IN_SAVEREGS:\n       case BUILT_IN_POPCOUNTL:\n       case BUILT_IN_POPCOUNTLL:"}, {"sha": "4ad95a12f83ea663b64cfc9f90a5cec45bcb97a8", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1048,6 +1048,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_SETJMP, \"setjmp\", BT_FN_INT_PTR, ATTR_RT_NOTHRO\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRFMON, \"strfmon\", BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR, ATTR_FORMAT_STRFMON_NOTHROW_3_4)\n DEF_LIB_BUILTIN        (BUILT_IN_STRFTIME, \"strftime\", BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_TM_PTR, ATTR_FORMAT_STRFTIME_NOTHROW_3_0)\n DEF_GCC_BUILTIN        (BUILT_IN_TRAP, \"trap\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LEAF_COLD_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UNREACHABLE_TRAP, \"unreachable trap\", BT_FN_VOID, ATTR_CONST_NORETURN_NOTHROW_LEAF_COLD_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_UNREACHABLE, \"unreachable\", BT_FN_VOID, ATTR_CONST_NORETURN_NOTHROW_LEAF_COLD_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_UNWIND_INIT, \"unwind_init\", BT_FN_VOID, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_UPDATE_SETJMP_BUF, \"update_setjmp_buf\", BT_FN_VOID_PTR, ATTR_NULL)"}, {"sha": "5bc8fa5582cbfe7ef985f92c864f3e59b9c5feee", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,20 @@\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c-common.h: Mechanically drop static from static inline\n+\tfunctions via s/^static inline/inline/g.\n+\n+2023-02-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt: Add -Wno-changes-meaning.\n+\n+2023-01-31  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107593\n+\tPR c++/108597\n+\t* c-common.h (instantiation_dependent_expression_p): Declare.\n+\t* c-warn.cc (warn_duplicated_cond_add_or_warn): If the condition\n+\tis dependent, invalidate the chain.\n+\n 2023-01-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/105300"}, {"sha": "3cf7df691d15182dfd4cc4e836fa0cc6719ebe73", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -923,7 +923,7 @@ extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwis\n    minimum or op1 is not -1, because e.g. (long long) INT_MIN / -1 is\n    well defined INT_MAX + 1LL if long long is wider than int, but INT_MIN / -1\n    is UB.  */\n-static inline bool\n+inline bool\n may_shorten_divmod (tree op0, tree op1)\n {\n   tree type0 = TREE_TYPE (op0);\n@@ -1101,6 +1101,7 @@ extern tree lookup_label (tree);\n extern tree lookup_name (tree);\n extern bool lvalue_p (const_tree);\n extern int maybe_adjust_arg_pos_for_attribute (const_tree);\n+extern bool instantiation_dependent_expression_p (tree);\n \n extern bool vector_targets_convertible_p (const_tree t1, const_tree t2);\n extern bool vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note);\n@@ -1326,7 +1327,7 @@ extern const struct c_omp_directive *c_omp_categorize_directive (const char *,\n \t\t\t\t\t\t\t\t const char *);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n-static inline tree\n+inline tree\n c_tree_chain_next (tree t)\n {\n   /* TREE_CHAIN of a type is TYPE_STUB_DECL, which is different"}, {"sha": "29efce3f2c0cfb72c19ee3946939d866a58569bd", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2535,7 +2535,7 @@ warn_duplicated_cond_add_or_warn (location_t loc, tree cond, vec<tree> **chain)\n   if (*chain == NULL)\n     return;\n \n-  if (TREE_SIDE_EFFECTS (cond))\n+  if (TREE_SIDE_EFFECTS (cond) || instantiation_dependent_expression_p (cond))\n     {\n       /* Uh-oh!  This condition has a side-effect, thus invalidates\n \t the whole chain.  */"}, {"sha": "c0fea56a8f5cc4a1f2ed7c112db1639d80d3551d", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -494,6 +494,10 @@ Wcatch-value=\n C++ ObjC++ Var(warn_catch_value) Warning Joined RejectNegative UInteger LangEnabledBy(C++ ObjC++,Wall, 1, 0) IntegerRange(0, 3)\n Warn about catch handlers of non-reference type.\n \n+Wchanges-meaning\n+C++ ObjC++ Var(warn_changes_meaning) Warning Init(1)\n+Complain about a name being declared as a class member after a previous use of the same name.\n+\n Wchar-subscripts\n C ObjC C++ ObjC++ Var(warn_char_subscripts) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about subscripts whose type is \\\"char\\\"."}, {"sha": "26eeee2653d984746684ef3c7481b04e216aac84", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,51 @@\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c-parser.h: Mechanically drop static from static inline\n+\tfunctions via s/^static inline/inline/g.\n+\n+2023-02-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-convert.cc (c_convert): Allow conversion of a null pointer\n+\tconstant to nullptr_t.\n+\t* c-typeck.cc (null_pointer_constant_p): Remove static.\n+\t(convert_for_assignment): Allow conversion of a null pointer\n+\tconstant to nullptr_t.\n+\t(digest_init): Handle NULLPTR_TYPE among scalar conversions.\n+\t* c-tree.h (null_pointer_constant_p): Declare.\n+\n+2023-02-09  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* c-parser.cc (c_parser_omp_allocate): Parse align\n+\tclause and check for restrictions.\n+\n+2023-02-08  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-typeck.cc (check_constexpr_init): Remove argument\n+\tnull_pointer_constant.  Only check pointer initializers for being\n+\tnull.\n+\t(digest_init): Update calls to check_constexpr_init.\n+\n+2023-02-02  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-typeck.cc (build_binary_op): Allow comparisons between\n+\tpointers and nullptr_t values that are not null pointer constants.\n+\n+2023-02-02  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-typeck.cc: Include \"realmpfr.h\".\n+\t(constexpr_init_fits_real_type): Do not allow signaling NaN\n+\tconversions to different types with the same mode.  Handle\n+\tconversions from binary to decimal types.\n+\t(check_constexpr_init): Do not disallow real initializers for\n+\tcomplex types.  Do not disallow binary initializers for decimal\n+\tfloating types.\n+\n+2023-01-31  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107593\n+\tPR c++/108597\n+\t* c-objc-common.cc (instantiation_dependent_expression_p): New.\n+\n 2023-01-27  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.cc (c_parser_declaration_or_fndef): Do not allow braces"}, {"sha": "0f35dc4fe9a93bc14a5ba368c80de8f8e7e8d837", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -157,6 +157,19 @@ c_convert (tree type, tree expr, bool init_const)\n       ret = convert_to_pointer (type, e);\n       goto maybe_fold;\n \n+    case NULLPTR_TYPE:\n+      /* A null pointer constant or value of type nullptr_t may be\n+\t converted to nullptr_t.  The latter case has already been\n+\t handled.  build_c_cast will create an additional NOP_EXPR to\n+\t ensure the result of the conversion is not itself a null\n+\t pointer constant.  */\n+      if (null_pointer_constant_p (expr))\n+\t{\n+\t  ret = build_int_cst (type, 0);\n+\t  goto maybe_fold;\n+\t}\n+      break;\n+\n     case REAL_TYPE:\n       ret = convert_to_real (type, e);\n       goto maybe_fold;\n@@ -201,12 +214,14 @@ c_convert (tree type, tree expr, bool init_const)\n     }\n \n   /* If we are converting to nullptr_t, don't say \"non-scalar type\" because\n-     the nullptr_t type is a scalar type.  Only nullptr_t shall be converted\n-     to nullptr_t.  */\n+     the nullptr_t type is a scalar type.  Only nullptr_t or a null pointer\n+     constant shall be converted to nullptr_t.  */\n   if (code == NULLPTR_TYPE)\n     {\n       error (\"conversion from %qT to %qT\", TREE_TYPE (e), type);\n-      inform (input_location, \"only %qT can be converted to %qT\", type, type);\n+      inform (input_location,\n+\t      \"only %qT or a null pointer constant can be converted to %qT\",\n+\t      type, type);\n     }\n   else\n     error (\"conversion to non-scalar type requested\");"}, {"sha": "0350733250b9882f61917337c2014ea70b79c197", "filename": "gcc/c/c-objc-common.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-objc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-objc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -400,3 +400,11 @@ maybe_adjust_arg_pos_for_attribute (const_tree)\n {\n   return 0;\n }\n+\n+/* In C, no expression is dependent.  */\n+\n+bool\n+instantiation_dependent_expression_p (tree)\n+{\n+  return false;\n+}"}, {"sha": "43427886ad41dfbc3075ebdbdfb8f0ad5e8c9453", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -18814,32 +18814,71 @@ c_parser_oacc_wait (location_t loc, c_parser *parser, char *p_name)\n   return stmt;\n }\n \n-/* OpenMP 5.0:\n-   # pragma omp allocate (list)  [allocator(allocator)]  */\n+/* OpenMP 5.x:\n+   # pragma omp allocate (list)  clauses\n+\n+   OpenMP 5.0 clause:\n+   allocator (omp_allocator_handle_t expression)\n+\n+   OpenMP 5.1 additional clause:\n+   align (constant-expression)]  */\n \n static void\n c_parser_omp_allocate (location_t loc, c_parser *parser)\n {\n+  tree alignment = NULL_TREE;\n   tree allocator = NULL_TREE;\n   tree nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n-  if (c_parser_next_token_is (parser, CPP_COMMA)\n-      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n-    c_parser_consume_token (parser);\n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  do\n     {\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\tbreak;\n       matching_parens parens;\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       c_parser_consume_token (parser);\n-      if (strcmp (\"allocator\", p) != 0)\n-\terror_at (c_parser_peek_token (parser)->location,\n-\t\t  \"expected %<allocator%>\");\n-      else if (parens.require_open (parser))\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      if (strcmp (\"align\", p) != 0 && strcmp (\"allocator\", p) != 0)\n \t{\n-\t  location_t expr_loc = c_parser_peek_token (parser)->location;\n-\t  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n-\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n-\t  allocator = expr.value;\n-\t  allocator = c_fully_fold (allocator, false, NULL);\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"expected %<allocator%> or %<align%>\");\n+\t  break;\n+\t}\n+      if (!parens.require_open (parser))\n+\tbreak;\n+\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      expr_loc = c_parser_peek_token (parser)->location;\n+      if (p[2] == 'i' && alignment)\n+\t{\n+\t  error_at (expr_loc, \"too many %qs clauses\", \"align\");\n+\t  break;\n+\t}\n+      else if (p[2] == 'i')\n+\t{\n+\t  alignment = c_fully_fold (expr.value, false, NULL);\n+\t  if (TREE_CODE (alignment) != INTEGER_CST\n+\t      || !INTEGRAL_TYPE_P (TREE_TYPE (alignment))\n+\t      || tree_int_cst_sgn (alignment) != 1\n+\t      || !integer_pow2p (alignment))\n+\t    {\n+\t      error_at (expr_loc, \"%<align%> clause argument needs to be \"\n+\t\t\t\t  \"positive constant power of two integer \"\n+\t\t\t\t  \"expression\");\n+\t      alignment = NULL_TREE;\n+\t    }\n+\t}\n+      else if (allocator)\n+\t{\n+\t  error_at (expr_loc, \"too many %qs clauses\", \"allocator\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  allocator = c_fully_fold (expr.value, false, NULL);\n \t  tree orig_type\n \t    = expr.original_type ? expr.original_type : TREE_TYPE (allocator);\n \t  orig_type = TYPE_MAIN_VARIANT (orig_type);\n@@ -18848,20 +18887,23 @@ c_parser_omp_allocate (location_t loc, c_parser *parser)\n \t      || TYPE_NAME (orig_type)\n \t\t != get_identifier (\"omp_allocator_handle_t\"))\n \t    {\n-\t      error_at (expr_loc, \"%<allocator%> clause allocator expression \"\n-\t\t\t\t\"has type %qT rather than \"\n-\t\t\t\t\"%<omp_allocator_handle_t%>\",\n-\t\t\t\tTREE_TYPE (allocator));\n+\t      error_at (expr_loc,\n+\t\t\t\"%<allocator%> clause allocator expression has type \"\n+\t\t\t\"%qT rather than %<omp_allocator_handle_t%>\",\n+\t\t\tTREE_TYPE (allocator));\n \t      allocator = NULL_TREE;\n \t    }\n-\t  parens.skip_until_found_close (parser);\n \t}\n-    }\n+      parens.skip_until_found_close (parser);\n+    } while (true);\n   c_parser_skip_to_pragma_eol (parser);\n \n-  if (allocator)\n+  if (allocator || alignment)\n     for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n-      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = alignment;\n+      }\n \n   sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n }"}, {"sha": "545f0f4d9ebcbc70fc819f1ac6cd6ceb58bd94af", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -161,7 +161,7 @@ extern bool old_style_parameter_scope (void);\n /* Return true if the next token from PARSER has the indicated\n    TYPE.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n {\n   return c_parser_peek_token (parser)->type == type;\n@@ -170,7 +170,7 @@ c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n /* Return true if the next token from PARSER does not have the\n    indicated TYPE.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n {\n   return !c_parser_next_token_is (parser, type);\n@@ -179,7 +179,7 @@ c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n /* Return true if the next token from PARSER is the indicated\n    KEYWORD.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n {\n   return c_parser_peek_token (parser)->keyword == keyword;"}, {"sha": "e5eefe6bbba0af3cfda7a9f85b0fdca035b36c8e", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -728,6 +728,7 @@ extern location_t c_last_sizeof_loc;\n \n extern struct c_switch *c_switch_stack;\n \n+extern bool null_pointer_constant_p (const_tree);\n extern bool char_type_p (tree);\n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (location_t, tree);"}, {"sha": "e37b0973cd69a264687f2a177a73be23f03dcb60", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 88, "deletions": 63, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"realmpfr.h\"\n \n /* Possible cases of implicit conversions.  Used to select diagnostic messages\n    and control folding initializers in convert_for_assignment.  */\n@@ -88,7 +89,6 @@ static bool require_constant_value;\n static bool require_constant_elements;\n static bool require_constexpr_value;\n \n-static bool null_pointer_constant_p (const_tree);\n static tree qualify_type (tree, tree);\n static int tagged_types_tu_compatible_p (const_tree, const_tree, bool *,\n \t\t\t\t\t bool *);\n@@ -129,7 +129,7 @@ static int comptypes_internal (const_tree, const_tree, bool *, bool *);\n \f\n /* Return true if EXP is a null pointer constant, false otherwise.  */\n \n-static bool\n+bool\n null_pointer_constant_p (const_tree expr)\n {\n   /* This should really operate on c_expr structures, but they aren't\n@@ -7836,6 +7836,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n       in_late_binary_op = save;\n       return ret;\n     }\n+  else if (codel == NULLPTR_TYPE && null_pointer_constant)\n+    return convert (type, rhs);\n \n   switch (errtype)\n     {\n@@ -8121,17 +8123,26 @@ print_spelling (char *buffer)\n }\n \n /* Check whether INIT, a floating or integer constant, is\n-   representable in TYPE, a real floating type with the same radix.\n-   Return true if OK, false if not.  */\n+   representable in TYPE, a real floating type with the same radix or\n+   a decimal floating type initialized with a binary floating\n+   constant.  Return true if OK, false if not.  */\n static bool\n constexpr_init_fits_real_type (tree type, tree init)\n {\n   gcc_assert (TREE_CODE (type) == REAL_TYPE);\n   gcc_assert (TREE_CODE (init) == INTEGER_CST || TREE_CODE (init) == REAL_CST);\n   if (TREE_CODE (init) == REAL_CST\n       && TYPE_MODE (TREE_TYPE (init)) == TYPE_MODE (type))\n-    /* Same mode, no conversion required.  */\n-    return true;\n+    {\n+      /* Same mode, no conversion required except for the case of\n+\t signaling NaNs if the types are incompatible (e.g. double and\n+\t long double with the same mode).  */\n+      if (REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (init))\n+\t  && !comptypes (TYPE_MAIN_VARIANT (type),\n+\t\t\t TYPE_MAIN_VARIANT (TREE_TYPE (init))))\n+\treturn false;\n+      return true;\n+    }\n   if (TREE_CODE (init) == INTEGER_CST)\n     {\n       tree converted = build_real_from_int_cst (type, init);\n@@ -8140,6 +8151,33 @@ constexpr_init_fits_real_type (tree type, tree init)\n \t\t\t\t    TYPE_PRECISION (TREE_TYPE (init)));\n       return !fail && wi::eq_p (w, wi::to_wide (init));\n     }\n+  if (REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (init)))\n+    return false;\n+  if ((REAL_VALUE_ISINF (TREE_REAL_CST (init))\n+       && MODE_HAS_INFINITIES (TYPE_MODE (type)))\n+      || (REAL_VALUE_ISNAN (TREE_REAL_CST (init))\n+\t  && MODE_HAS_NANS (TYPE_MODE (type))))\n+    return true;\n+  if (DECIMAL_FLOAT_TYPE_P (type)\n+      && !DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init)))\n+    {\n+      /* This is valid if the real number represented by the\n+\t initializer can be exactly represented in the decimal\n+\t type.  Compare the values using MPFR.  */\n+      REAL_VALUE_TYPE t;\n+      real_convert (&t, TYPE_MODE (type), &TREE_REAL_CST (init));\n+      mpfr_t bin_val, dec_val;\n+      mpfr_init2 (bin_val, REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (init)))->p);\n+      mpfr_init2 (dec_val, REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (init)))->p);\n+      mpfr_from_real (bin_val, &TREE_REAL_CST (init), MPFR_RNDN);\n+      char string[256];\n+      real_to_decimal (string, &t, sizeof string, 0, 1);\n+      bool res = (mpfr_strtofr (dec_val, string, NULL, 10, MPFR_RNDN) == 0\n+\t\t  && mpfr_equal_p (bin_val, dec_val));\n+      mpfr_clear (bin_val);\n+      mpfr_clear (dec_val);\n+      return res;\n+    }\n   /* exact_real_truncate is not quite right here, since it doesn't\n      allow even an exact conversion to subnormal values.  */\n   REAL_VALUE_TYPE t;\n@@ -8149,23 +8187,20 @@ constexpr_init_fits_real_type (tree type, tree init)\n \n /* Check whether INIT (location LOC) is valid as a 'constexpr'\n    initializer for type TYPE, and give an error if not.  INIT has\n-   already been folded and verified to be constant.\n-   NULL_POINTER_CONSTANT, INT_CONST_EXPR and ARITH_CONST_EXPR say\n-   whether it is a null pointer constant, integer constant expression\n-   or arithmetic constant expression, respectively.  If TYPE is not a\n-   scalar type, this function does nothing.  */\n+   already been folded and verified to be constant.  INT_CONST_EXPR\n+   and ARITH_CONST_EXPR say whether it is an integer constant\n+   expression or arithmetic constant expression, respectively.  If\n+   TYPE is not a scalar type, this function does nothing.  */\n \n static void\n check_constexpr_init (location_t loc, tree type, tree init,\n-\t\t      bool null_pointer_constant, bool int_const_expr,\n-\t\t      bool arith_const_expr)\n+\t\t      bool int_const_expr, bool arith_const_expr)\n {\n   if (POINTER_TYPE_P (type))\n     {\n-      /* The initializer must be a null pointer constant.  */\n-      if (!null_pointer_constant)\n-\terror_at (loc, \"%<constexpr%> pointer initializer is not a \"\n-\t\t  \"null pointer constant\");\n+      /* The initializer must be null.  */\n+      if (TREE_CODE (init) != INTEGER_CST || !integer_zerop (init))\n+\terror_at (loc, \"%<constexpr%> pointer initializer is not null\");\n       return;\n     }\n   if (INTEGRAL_TYPE_P (type))\n@@ -8194,58 +8229,46 @@ check_constexpr_init (location_t loc, tree type, tree init,\n   if (TREE_CODE (type) == COMPLEX_TYPE\n       && TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n     return;\n-  /* Both the normative text and the relevant footnote are unclear, as\n-     of the C2x CD, about what exactly counts as a change of value in\n-     floating-point cases.  Here, we consider all conversions between\n-     binary and decimal types (even of infinities and NaNs, where\n-     quantum exponents are not involved) as involving a change of\n-     value, and likewise for conversions between real and complex\n-     types (even when the complex constant has imaginary part positive\n-     zero), and conversions of signaling NaN to a different machine\n-     mode.  But we allow exact conversions of integers to binary or\n-     decimal floating types, and exact conversions between different\n-     binary types or different decimal types, where \"exact\" in the\n-     decimal case requires the quantum exponent to be preserved.  */\n+  /* Following N3082, a real type cannot be initialized from a complex\n+     type and a binary type cannot be initialized from a decimal type\n+     (but initializing a decimal type from a binary type is OK).\n+     Signaling NaN initializers are OK only if the types are\n+     compatible (not just the same mode); all quiet NaN and infinity\n+     initializations are considered to preserve the value.  */\n   if (TREE_CODE (TREE_TYPE (init)) == COMPLEX_TYPE\n       && TREE_CODE (type) == REAL_TYPE)\n     {\n       error_at (loc, \"%<constexpr%> initializer for a real type is of \"\n \t\t\"complex type\");\n       return;\n     }\n-  if (TREE_CODE (type) == COMPLEX_TYPE\n-      && TREE_CODE (TREE_TYPE (init)) != COMPLEX_TYPE)\n-    {\n-      error_at (loc, \"%<constexpr%> initializer for a complex type is of \"\n-\t\t\"real type\");\n-      return;\n-    }\n   if (TREE_CODE (type) == REAL_TYPE\n-      && TREE_CODE (TREE_TYPE (init)) == REAL_TYPE)\n+      && TREE_CODE (TREE_TYPE (init)) == REAL_TYPE\n+      && DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init))\n+      && !DECIMAL_FLOAT_TYPE_P (type))\n     {\n-      if (DECIMAL_FLOAT_TYPE_P (type)\n-\t  && !DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init)))\n-\t{\n-\t  error_at (loc, \"%<constexpr%> initializer for a decimal \"\n-\t\t    \"floating-point type is of binary type\");\n-\t  return;\n-\t}\n-      else if (DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init))\n-\t       && !DECIMAL_FLOAT_TYPE_P (type))\n-\t{\n-\t  error_at (loc, \"%<constexpr%> initializer for a binary \"\n-\t\t    \"floating-point type is of decimal type\");\n-\t  return;\n-\t}\n+      error_at (loc, \"%<constexpr%> initializer for a binary \"\n+\t\t\"floating-point type is of decimal type\");\n+      return;\n     }\n   bool fits;\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n-      gcc_assert (TREE_CODE (init) == COMPLEX_CST);\n-      fits = (constexpr_init_fits_real_type (TREE_TYPE (type),\n-\t\t\t\t\t     TREE_REALPART (init))\n-\t      && constexpr_init_fits_real_type (TREE_TYPE (type),\n-\t\t\t\t\t\tTREE_IMAGPART (init)));\n+      switch (TREE_CODE (init))\n+\t{\n+\tcase INTEGER_CST:\n+\tcase REAL_CST:\n+\t  fits = constexpr_init_fits_real_type (TREE_TYPE (type), init);\n+\t  break;\n+\tcase COMPLEX_CST:\n+\t  fits = (constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t\t TREE_REALPART (init))\n+\t\t  && constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t\t    TREE_IMAGPART (init)));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   else\n     fits = constexpr_init_fits_real_type (type, init);\n@@ -8557,8 +8580,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t\t      \"initializer element is not a constant expression\");\n       else if (require_constexpr)\n \tcheck_constexpr_init (init_loc, type, inside_init,\n-\t\t\t      null_pointer_constant, int_const_expr,\n-\t\t\t      arith_const_expr);\n+\t\t\t      int_const_expr, arith_const_expr);\n \n       /* Added to enable additional -Wsuggest-attribute=format warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n@@ -8575,7 +8597,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE\n       || code == POINTER_TYPE || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE\n-      || code == COMPLEX_TYPE || code == VECTOR_TYPE)\n+      || code == COMPLEX_TYPE || code == VECTOR_TYPE || code == NULLPTR_TYPE)\n     {\n       tree unconverted_init = inside_init;\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n@@ -8613,8 +8635,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t\t      \"initializer element is not a constant expression\");\n       else if (require_constexpr)\n \tcheck_constexpr_init (init_loc, type, unconverted_init,\n-\t\t\t      null_pointer_constant, int_const_expr,\n-\t\t\t      arith_const_expr);\n+\t\t\t      int_const_expr, arith_const_expr);\n \n       return inside_init;\n     }\n@@ -12724,12 +12745,16 @@ build_binary_op (location_t location, enum tree_code code,\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n \t      || code1 == FIXED_POINT_TYPE || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n-      else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n+      else if (code0 == POINTER_TYPE\n+\t       && (code1 == NULLPTR_TYPE\n+\t\t   || null_pointer_constant_p (orig_op1)))\n \t{\n \t  maybe_warn_for_null_address (location, op0, code);\n \t  result_type = type0;\n \t}\n-      else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n+      else if (code1 == POINTER_TYPE\n+\t       && (code0 == NULLPTR_TYPE\n+\t\t   || null_pointer_constant_p (orig_op0)))\n \t{\n \t  maybe_warn_for_null_address (location, op1, code);\n \t  result_type = type1;"}, {"sha": "0242d52cfb35a90c2594e5f74579f45aecec76ce", "filename": "gcc/calls.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcalls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcalls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -506,11 +506,11 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (ecf_flags & ECF_NORETURN)\n     add_reg_note (call_insn, REG_NORETURN, const0_rtx);\n \n-  if (ecf_flags & ECF_RETURNS_TWICE)\n-    {\n-      add_reg_note (call_insn, REG_SETJMP, const0_rtx);\n-      cfun->calls_setjmp = 1;\n-    }\n+  if (ecf_flags & ECF_RETURNS_TWICE\n+      /* We rely on GIMPLE setting this flag and here use it to\n+\t catch formerly indirect and not control-altering calls.  */\n+      && cfun->calls_setjmp)\n+    add_reg_note (call_insn, REG_SETJMP, const0_rtx);\n \n   SIBLING_CALL_P (call_insn) = ((ecf_flags & ECF_SIBCALL) != 0);\n "}, {"sha": "ab143a6d2d3df70a0bdd7fbf842fd631c6888260", "filename": "gcc/cfgexpand.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfgexpand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfgexpand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2808,6 +2808,11 @@ expand_call_stmt (gcall *stmt)\n   /* Must come after copying location.  */\n   copy_warning (exp, stmt);\n \n+  /* For calls that do not alter control flow avoid REG_SETJMP notes.  */\n+  bool saved_calls_setjmp = cfun->calls_setjmp;\n+  if (!gimple_call_ctrl_altering_p (stmt))\n+    cfun->calls_setjmp = false;\n+\n   /* Ensure RTL is created for debug args.  */\n   if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n     {\n@@ -2846,6 +2851,8 @@ expand_call_stmt (gcall *stmt)\n     }\n \n   mark_transaction_restart_calls (stmt);\n+\n+  cfun->calls_setjmp = saved_calls_setjmp;\n }\n \n "}, {"sha": "7c87712c8d7290b1c6c64b9df03306845866b92f", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -206,7 +206,7 @@ extern void verify_flow_info (void);\n /* Check control flow invariants, if internal consistency checks are\n    enabled.  */\n \n-static inline void\n+inline void\n checking_verify_flow_info (void)\n {\n   /* TODO: Add a separate option for -fchecking=cfg.  */"}, {"sha": "e7ac2b5f3db55de3dbbab7bd2bfe08388f4ec533", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -280,21 +280,21 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n #define LOOP_C_FINITE\t\t(1 << 1)\n \n /* Set C to the LOOP constraint.  */\n-static inline void\n+inline void\n loop_constraint_set (class loop *loop, unsigned c)\n {\n   loop->constraints |= c;\n }\n \n /* Clear C from the LOOP constraint.  */\n-static inline void\n+inline void\n loop_constraint_clear (class loop *loop, unsigned c)\n {\n   loop->constraints &= ~c;\n }\n \n /* Check if C is set in the LOOP constraint.  */\n-static inline bool\n+inline bool\n loop_constraint_set_p (class loop *loop, unsigned c)\n {\n   return (loop->constraints & c) == c;\n@@ -508,7 +508,7 @@ extern void iv_analysis_done (void);\n extern class niter_desc *get_simple_loop_desc (class loop *loop);\n extern void free_simple_loop_desc (class loop *loop);\n \n-static inline class niter_desc *\n+inline class niter_desc *\n simple_loop_desc (class loop *loop)\n {\n   return loop->simple_loop_desc;\n@@ -518,15 +518,15 @@ simple_loop_desc (class loop *loop)\n \n /* Returns the loop with index NUM from FNs loop tree.  */\n \n-static inline class loop *\n+inline class loop *\n get_loop (struct function *fn, unsigned num)\n {\n   return (*loops_for_fn (fn)->larray)[num];\n }\n \n /* Returns the number of superloops of LOOP.  */\n \n-static inline unsigned\n+inline unsigned\n loop_depth (const class loop *loop)\n {\n   return vec_safe_length (loop->superloops);\n@@ -535,7 +535,7 @@ loop_depth (const class loop *loop)\n /* Returns the immediate superloop of LOOP, or NULL if LOOP is the outermost\n    loop.  */\n \n-static inline class loop *\n+inline class loop *\n loop_outer (const class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n@@ -548,7 +548,7 @@ loop_outer (const class loop *loop)\n \n /* Returns true if LOOP has at least one exit edge.  */\n \n-static inline bool\n+inline bool\n loop_has_exit_edges (const class loop *loop)\n {\n   return loop->exits->next->e != NULL;\n@@ -569,7 +569,7 @@ get_loops (struct function *fn)\n /* Returns the number of loops in FN (including the removed\n    ones and the fake loop that forms the root of the loop tree).  */\n \n-static inline unsigned\n+inline unsigned\n number_of_loops (struct function *fn)\n {\n   struct loops *loops = loops_for_fn (fn);\n@@ -582,41 +582,41 @@ number_of_loops (struct function *fn)\n /* Returns true if state of the loops satisfies all properties\n    described by FLAGS.  */\n \n-static inline bool\n+inline bool\n loops_state_satisfies_p (function *fn, unsigned flags)\n {\n   return (loops_for_fn (fn)->state & flags) == flags;\n }\n \n-static inline bool\n+inline bool\n loops_state_satisfies_p (unsigned flags)\n {\n   return loops_state_satisfies_p (cfun, flags);\n }\n \n /* Sets FLAGS to the loops state.  */\n \n-static inline void\n+inline void\n loops_state_set (function *fn, unsigned flags)\n {\n   loops_for_fn (fn)->state |= flags;\n }\n \n-static inline void\n+inline void\n loops_state_set (unsigned flags)\n {\n   loops_state_set (cfun, flags);\n }\n \n /* Clears FLAGS from the loops state.  */\n \n-static inline void\n+inline void\n loops_state_clear (function *fn, unsigned flags)\n {\n   loops_for_fn (fn)->state &= ~flags;\n }\n \n-static inline void\n+inline void\n loops_state_clear (unsigned flags)\n {\n   if (!current_loops)\n@@ -627,7 +627,7 @@ loops_state_clear (unsigned flags)\n /* Check loop structure invariants, if internal consistency checks are\n    enabled.  */\n \n-static inline void\n+inline void\n checking_verify_loop_structure (void)\n {\n   /* VERIFY_LOOP_STRUCTURE essentially asserts that no loops need fixups.\n@@ -897,7 +897,7 @@ extern void move_loop_invariants (void);\n extern auto_vec<basic_block> get_loop_hot_path (const class loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/\n-static inline class loop *\n+inline class loop *\n loop_outermost (class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n@@ -919,7 +919,7 @@ extern int bb_loop_depth (const_basic_block);\n \n /* Converts VAL to widest_int.  */\n \n-static inline widest_int\n+inline widest_int\n gcov_type_to_wide_int (gcov_type val)\n {\n   HOST_WIDE_INT a[2];"}, {"sha": "f352212e463f228f9bc1df11cd8582f5b525795e", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2764,6 +2764,9 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n       if (!set_const || alias->get_availability () > AVAIL_INTERPOSABLE)\n \tset_const_flag_1 (alias, set_const, looping, changed);\n     }\n+  for (struct cgraph_node *n = node->simd_clones; n != NULL;\n+       n = n->simdclone->next_clone)\n+    set_const_flag_1 (n, set_const, looping, changed);\n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n     if (e->caller->thunk\n \t&& (!set_const || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n@@ -2876,6 +2879,9 @@ cgraph_node::set_pure_flag (bool pure, bool looping)\n {\n   struct set_pure_flag_info info = {pure, looping, false};\n   call_for_symbol_thunks_and_aliases (set_pure_flag_1, &info, !pure, true);\n+  for (struct cgraph_node *n = simd_clones; n != NULL;\n+       n = n->simdclone->next_clone)\n+    set_pure_flag_1 (n, &info);\n   return info.changed;\n }\n \n@@ -3248,11 +3254,11 @@ cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n   node = node->ultimate_alias_target ();\n \n   /* Optimizers can redirect unreachable calls or calls triggering undefined\n-     behavior to __builtin_unreachable or __builtin_trap.  */\n+     behavior to __builtin_unreachable or __builtin_unreachable trap.  */\n \n   if (fndecl_built_in_p (callee->decl, BUILT_IN_NORMAL)\n       && (DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_UNREACHABLE\n-\t  || DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_TRAP))\n+\t  || DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_UNREACHABLE_TRAP))\n     return false;\n \n   if (callee->former_clone_of != node->decl"}, {"sha": "b5fc739f1b0602a871040292a5bb1d69a9ef305f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2650,7 +2650,7 @@ symtab_node::real_symbol_p (void)\n /* Return true if DECL should have entry in symbol table if used.\n    Those are functions and static & external variables.  */\n \n-static inline bool\n+inline bool\n decl_in_symtab_p (const_tree decl)\n {\n   return (TREE_CODE (decl) == FUNCTION_DECL\n@@ -3323,7 +3323,7 @@ cgraph_edge::frequency ()\n \n \n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n-static inline bool\n+inline bool\n decl_is_tm_clone (const_tree fndecl)\n {\n   cgraph_node *n = cgraph_node::get (fndecl);\n@@ -3539,7 +3539,7 @@ ipa_polymorphic_call_context::useless_p () const\n    the name documents the intent.  We require that no GC can occur\n    within the fprintf call.  */\n \n-static inline const char *\n+inline const char *\n xstrdup_for_dump (const char *transient_str)\n {\n   return ggc_strdup (transient_str);"}, {"sha": "a972900900b71bfe48db39783f0b17a3fb2d6ec7", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1000,7 +1000,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n     = possible_polymorphic_call_targets\n \t(edge, &final, &cache_token);\n \n-  if (!reachable_call_targets->add (cache_token))\n+  if (cache_token != NULL && !reachable_call_targets->add (cache_token))\n     {\n       if (symtab->dump_file)\n \tdump_possible_polymorphic_call_targets "}, {"sha": "20bc4e1291bba9b73798398fea659f1154afa205", "filename": "gcc/common/config/aarch64/aarch64-common.cc", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -140,20 +140,28 @@ aarch64_handle_option (struct gcc_options *opts,\n /* An ISA extension in the co-processor and main instruction set space.  */\n struct aarch64_option_extension\n {\n+  /* The extension name to pass on to the assembler.  */\n   const char *name;\n+  /* The smallest set of feature bits to toggle to enable this option.  */\n   aarch64_feature_flags flag_canonical;\n+  /* If this feature is turned on, these bits also need to be turned on.  */\n   aarch64_feature_flags flags_on;\n+  /* If this feature is turned off, these bits also need to be turned off.  */\n   aarch64_feature_flags flags_off;\n+  /* Indicates whether this feature is taken into account during native cpu\n+     detection.  */\n+  bool native_detect_p;\n };\n \n /* ISA extensions in AArch64.  */\n static constexpr aarch64_option_extension all_extensions[] =\n {\n-#define AARCH64_OPT_EXTENSION(NAME, IDENT, C, D, E, F) \\\n+#define AARCH64_OPT_EXTENSION(NAME, IDENT, C, D, E, FEATURE_STRING) \\\n   {NAME, AARCH64_FL_##IDENT, feature_deps::IDENT ().explicit_on, \\\n-   feature_deps::get_flags_off (feature_deps::root_off_##IDENT)},\n+   feature_deps::get_flags_off (feature_deps::root_off_##IDENT), \\\n+   FEATURE_STRING[0]},\n #include \"config/aarch64/aarch64-option-extensions.def\"\n-  {NULL, 0, 0, 0}\n+  {NULL, 0, 0, 0, false}\n };\n \n struct processor_name_to_arch\n@@ -326,9 +334,13 @@ aarch64_get_extension_string_for_isa_flags\n \toutstr += opt.name;\n       }\n \n-  /* Remove the features in current_flags & ~isa_flags.  */\n+  /* Remove the features in current_flags & ~isa_flags.  If the feature does\n+     not have an HWCAPs then it shouldn't be taken into account for feature\n+     detection because one way or another we can't tell if it's available\n+     or not.  */\n   for (auto &opt : all_extensions)\n-    if (opt.flag_canonical & current_flags & ~isa_flags)\n+    if (opt.native_detect_p\n+\t&& (opt.flag_canonical & current_flags & ~isa_flags))\n       {\n \tcurrent_flags &= ~opt.flags_off;\n \toutstr += \"+no\";"}, {"sha": "95f5dd6120110ea6d9e76b8766275848ca5185cf", "filename": "gcc/common/config/arc/arc-common.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -54,7 +54,6 @@ static const struct default_options arc_option_optimization_table[] =\n     { OPT_LEVELS_SIZE, OPT_fsection_anchors, NULL, 1 },\n     { OPT_LEVELS_SIZE, OPT_mcase_vector_pcrel, NULL, 1 },\n     { OPT_LEVELS_SIZE, OPT_msize_level_, NULL, 3 },\n-    { OPT_LEVELS_SIZE, OPT_mmillicode, NULL, 1 },\n     { OPT_LEVELS_SIZE, OPT_fif_conversion, NULL, 0 },\n     { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n     { OPT_LEVELS_3_PLUS_SPEED_ONLY, OPT_msize_level_, NULL, 0 },"}, {"sha": "5bde0cddb248de18434985451afb0a7418d1e328", "filename": "gcc/common/config/i386/cpuinfo.h", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -601,8 +601,8 @@ get_intel_cpu (struct __processor_model *cpu_model,\n \n static inline const char *\n get_zhaoxin_cpu (struct __processor_model *cpu_model,\n-\t\tstruct __processor_model2 *cpu_model2,\n-\t\tunsigned int *cpu_features2)\n+\t\t struct __processor_model2 *cpu_model2,\n+\t\t unsigned int *cpu_features2)\n {\n   const char *cpu = NULL;\n   unsigned int family = cpu_model2->__cpu_family;\n@@ -1016,6 +1016,10 @@ cpu_indicator_init (struct __processor_model *cpu_model,\n   extended_model = (eax >> 12) & 0xf0;\n   extended_family = (eax >> 20) & 0xff;\n \n+  /* Find available features. */\n+  get_available_features (cpu_model, cpu_model2, cpu_features2,\n+\t\t\t  ecx, edx);\n+\n   if (vendor == signature_INTEL_ebx)\n     {\n       /* Adjust model and family for Intel CPUS. */\n@@ -1030,9 +1034,6 @@ cpu_indicator_init (struct __processor_model *cpu_model,\n       cpu_model2->__cpu_family = family;\n       cpu_model2->__cpu_model = model;\n \n-      /* Find available features. */\n-      get_available_features (cpu_model, cpu_model2, cpu_features2,\n-\t\t\t      ecx, edx);\n       /* Get CPU type.  */\n       get_intel_cpu (cpu_model, cpu_model2, cpu_features2);\n       cpu_model->__cpu_vendor = VENDOR_INTEL;\n@@ -1049,32 +1050,24 @@ cpu_indicator_init (struct __processor_model *cpu_model,\n       cpu_model2->__cpu_family = family;\n       cpu_model2->__cpu_model = model;\n \n-      /* Find available features. */\n-      get_available_features (cpu_model, cpu_model2, cpu_features2,\n-\t\t\t      ecx, edx);\n       /* Get CPU type.  */\n       get_amd_cpu (cpu_model, cpu_model2, cpu_features2);\n       cpu_model->__cpu_vendor = VENDOR_AMD;\n     }\n   else if (vendor == signature_CENTAUR_ebx && family < 0x07)\n     cpu_model->__cpu_vendor = VENDOR_CENTAUR;\n   else if (vendor == signature_SHANGHAI_ebx\n-\t\t|| vendor == signature_CENTAUR_ebx)\n+\t   || vendor == signature_CENTAUR_ebx)\n     {\n       /* Adjust model and family for ZHAOXIN CPUS.  */\n       if (family == 0x07)\n-\t{\n-\t  model += extended_model;\n-\t}\n+\tmodel += extended_model;\n \n       cpu_model2->__cpu_family = family;\n       cpu_model2->__cpu_model = model;\n \n-      /* Find available features.  */\n-      get_available_features (cpu_model, cpu_model2, cpu_features2,\n-\t\t\t\t  ecx, edx);\n       /* Get CPU type.  */\n-      get_zhaoxin_cpu (cpu_model, cpu_model2,cpu_features2);\n+      get_zhaoxin_cpu (cpu_model, cpu_model2, cpu_features2);\n       cpu_model->__cpu_vendor = VENDOR_ZHAOXIN;\n     }\n   else if (vendor == signature_CYRIX_ebx)"}, {"sha": "ebc1ed7d7e4cc75a0e73d9eef1ce4de489421a62", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1177,6 +1177,7 @@ static const riscv_ext_flag_table_t riscv_ext_flag_table[] =\n   {\"f\", &gcc_options::x_target_flags, MASK_HARD_FLOAT},\n   {\"d\", &gcc_options::x_target_flags, MASK_DOUBLE_FLOAT},\n   {\"c\", &gcc_options::x_target_flags, MASK_RVC},\n+  {\"v\", &gcc_options::x_target_flags, MASK_FULL_V},\n   {\"v\", &gcc_options::x_target_flags, MASK_VECTOR},\n \n   {\"zicsr\",    &gcc_options::x_riscv_zi_subext, MASK_ZICSR},\n@@ -1700,7 +1701,10 @@ riscv_compute_multilib (\n \n       /* Record highest match score multi-lib setting.  */\n       if (match_score > max_match_score)\n-\tbest_match_multi_lib = i;\n+\t{\n+\t  best_match_multi_lib = i;\n+\t  max_match_score = match_score;\n+\t}\n     }\n \n   if (best_match_multi_lib == -1)"}, {"sha": "c59dc0cf5a53d93c8e26e03990ef923beb50c2b0", "filename": "gcc/compare-elim.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcompare-elim.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcompare-elim.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -254,7 +254,8 @@ find_flags_uses_in_insn (struct comparison *cmp, rtx_insn *insn)\n \tx = PATTERN (insn);\n \tif (GET_CODE (x) == PARALLEL)\n \t  x = XVECEXP (x, 0, 0);\n-\tx = SET_SRC (x);\n+\tif (GET_CODE (x) == SET)\n+\t  x = SET_SRC (x);\n \tif (GET_CODE (x) == IF_THEN_ELSE)\n \t  x = XEXP (x, 0);\n \tif (COMPARISON_P (x)"}, {"sha": "b7288d40e866fce9f9be0284eef003ebf5651ed9", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4406,6 +4406,7 @@ case \"${target}\" in\n \t\t\t\t\tcase ${arm_multilib} in\n \t\t\t\t\taprofile|rmprofile)\n \t\t\t\t\t\ttmake_profile_file=\"arm/t-multilib\"\n+\t\t\t\t\t\ttm_mlib_file=\"arm/arm-mlib.h\"\n \t\t\t\t\t\t;;\n \t\t\t\t\t@*)\n \t\t\t\t\t\tml=`echo \"X$arm_multilib\" | sed '1s,^X@,,'`\n@@ -4444,7 +4445,7 @@ case \"${target}\" in\n \t\t\t\t# through to the multilib selector\n \t\t\t\twith_float=\"soft\"\n \t\t\t\ttmake_file=\"${tmake_file} ${tmake_profile_file}\"\n-\t\t\t\ttm_file=\"$tm_file arm/arm-mlib.h\"\n+\t\t\t\ttm_file=\"$tm_file $tm_mlib_file\"\n \t\t\t\tTM_MULTILIB_CONFIG=\"$with_multilib_list\"\n \t\t\tfi\n \t\tfi"}, {"sha": "f75eb892f3daa7c2576efcedc8d944ab1e895cdb", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -662,8 +662,6 @@ enum simd_immediate_check {\n   AARCH64_CHECK_MOV  = AARCH64_CHECK_ORR | AARCH64_CHECK_BIC\n };\n \n-extern enum aarch_key_type aarch_ra_sign_key;\n-\n extern struct tune_params aarch64_tune_params;\n \n /* The available SVE predicate patterns, known in the ACLE as \"svpattern\".  */"}, {"sha": "dd5eed387f2095950729d4389afb4da9daf71037", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -9153,7 +9153,7 @@\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=w\")\n         (plus: V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n                     (unspec:V4SF [(match_operand:V8BF 2 \"register_operand\" \"w\")\n-                                  (match_operand:VBF 3 \"register_operand\" \"w\")\n+                                  (match_operand:VBF 3 \"register_operand\" \"x\")\n                                   (match_operand:SI 4 \"const_int_operand\" \"n\")]\n                      BF_MLA)))]\n   \"TARGET_BF16_SIMD\""}, {"sha": "5c40b6ed22a508723bd535a7460762c3a243d441", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2759,8 +2759,6 @@ static const struct processor all_cores[] =\n   {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n-enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n-\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n@@ -2808,14 +2806,6 @@ static const struct attribute_spec aarch64_attribute_table[] =\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n };\n \n-/* An ISA extension in the co-processor and main instruction set space.  */\n-struct aarch64_option_extension\n-{\n-  const char *const name;\n-  const unsigned long flags_on;\n-  const unsigned long flags_off;\n-};\n-\n typedef enum aarch64_cond_code\n {\n   AARCH64_EQ = 0, AARCH64_NE, AARCH64_CS, AARCH64_CC, AARCH64_MI, AARCH64_PL,\n@@ -25704,6 +25694,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)\n \t  && CONST_INT_P (XEXP (curr_src, 1))\n \t  && INTVAL (XEXP (curr_src, 1)) == polarity\n \t  && REG_P (XEXP (curr_src, 0))\n+\t  && REG_P (SET_DEST (prev_set))\n \t  && REGNO (SET_DEST (prev_set)) == REGNO (XEXP (curr_src, 0)))\n \treturn true;\n     }"}, {"sha": "1d7967db9c0ca867fd0699370ce67b5242235c7f", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -40,7 +40,7 @@ TargetVariable\n unsigned aarch_enable_bti = 2\n \n TargetVariable\n-enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A\n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A\n \n ; The TLS dialect names to use with -mtls-dialect.\n "}, {"sha": "5b96ff4c2e89722a2cad686bd78ce12721a02010", "filename": "gcc/config/arm/aarch-common.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Faarch-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Faarch-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -661,7 +661,6 @@ arm_md_asm_adjust (vec<rtx> &outputs, vec<rtx> & /*inputs*/,\n \n #define BRANCH_PROTECT_STR_MAX 255\n extern char *accepted_branch_protection_string;\n-extern enum aarch_key_type aarch_ra_sign_key;\n \n static enum aarch_parse_opt_result\n aarch_handle_no_branch_protection (char* str, char* rest)"}, {"sha": "9f5c568cbc3389daebcfad8ac79babdb02025039", "filename": "gcc/config/arm/arm-builtins.cc", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -384,6 +384,19 @@ arm_unop_unone_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n #define UNOP_UNONE_IMM_QUALIFIERS \\\n   (arm_unop_unone_imm_qualifiers)\n \n+static enum arm_type_qualifiers\n+arm_unop_pred_unone_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_predicate, qualifier_unsigned };\n+#define UNOP_PRED_UNONE_QUALIFIERS \\\n+  (arm_unop_pred_unone_qualifiers)\n+\n+static enum arm_type_qualifiers\n+arm_unop_pred_pred_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_predicate, qualifier_predicate };\n+#define UNOP_PRED_PRED_QUALIFIERS \\\n+  (arm_unop_pred_pred_qualifiers)\n+\n+\n static enum arm_type_qualifiers\n arm_binop_none_none_none_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_none };\n@@ -426,6 +439,12 @@ arm_binop_pred_unone_unone_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n #define BINOP_PRED_UNONE_UNONE_QUALIFIERS \\\n   (arm_binop_pred_unone_unone_qualifiers)\n \n+static enum arm_type_qualifiers\n+arm_binop_pred_unone_pred_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_predicate, qualifier_unsigned, qualifier_predicate };\n+#define BINOP_PRED_UNONE_PRED_QUALIFIERS \\\n+  (arm_binop_pred_unone_pred_qualifiers)\n+\n static enum arm_type_qualifiers\n arm_binop_unone_none_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_unsigned, qualifier_none, qualifier_immediate };\n@@ -851,6 +870,10 @@ arm_set_sat_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_void, qualifier_none };\n #define SET_SAT_QUALIFIERS (arm_set_sat_qualifiers)\n \n+#define v2qi_UP  E_V2QImode\n+#define v4bi_UP  E_V4BImode\n+#define v8bi_UP  E_V8BImode\n+#define v16bi_UP E_V16BImode\n #define v8qi_UP  E_V8QImode\n #define v4hi_UP  E_V4HImode\n #define v4hf_UP  E_V4HFmode\n@@ -1489,12 +1512,14 @@ arm_lookup_simd_builtin_type (machine_mode mode,\n }\n \n static tree\n-arm_simd_builtin_type (machine_mode mode, bool unsigned_p, bool poly_p)\n+arm_simd_builtin_type (machine_mode mode, arm_type_qualifiers qualifiers)\n {\n-  if (poly_p)\n+  if ((qualifiers & qualifier_poly) != 0)\n     return arm_lookup_simd_builtin_type (mode, qualifier_poly);\n-  else if (unsigned_p)\n+  else if ((qualifiers & qualifier_unsigned) != 0)\n     return arm_lookup_simd_builtin_type (mode, qualifier_unsigned);\n+  else if ((qualifiers & qualifier_predicate) != 0)\n+    return unsigned_intHI_type_node;\n   else\n     return arm_lookup_simd_builtin_type (mode, qualifier_none);\n }\n@@ -1755,9 +1780,7 @@ arm_init_builtin (unsigned int fcode, arm_builtin_datum *d,\n       else\n \t{\n \t  eltype\n-\t    = arm_simd_builtin_type (op_mode,\n-\t\t\t\t     (qualifiers & qualifier_unsigned) != 0,\n-\t\t\t\t     (qualifiers & qualifier_poly) != 0);\n+\t    = arm_simd_builtin_type (op_mode, qualifiers);\n \t  gcc_assert (eltype != NULL);\n \n \t  /* Add qualifiers.  */\n@@ -1929,10 +1952,10 @@ static void\n arm_init_crypto_builtins (void)\n {\n   tree V16UQI_type_node\n-    = arm_simd_builtin_type (V16QImode, true, false);\n+    = arm_simd_builtin_type (V16QImode, qualifier_unsigned);\n \n   tree V4USI_type_node\n-    = arm_simd_builtin_type (V4SImode, true, false);\n+    = arm_simd_builtin_type (V4SImode, qualifier_unsigned);\n \n   tree v16uqi_ftype_v16uqi\n     = build_function_type_list (V16UQI_type_node, V16UQI_type_node,\n@@ -2989,11 +3012,14 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n \t\top[argc] = convert_memory_address (Pmode, op[argc]);\n \n \t      /* MVE uses mve_pred16_t (aka HImode) for vectors of\n-\t\t predicates.  */\n-\t      if (GET_MODE_CLASS (mode[argc]) == MODE_VECTOR_BOOL)\n+\t\t predicates, but internally we use V16BI/V8BI/V4BI/V2QI for\n+\t\t MVE predicate modes.  */\n+\t      if (TARGET_HAVE_MVE && VALID_MVE_PRED_MODE (mode[argc]))\n \t\top[argc] = gen_lowpart (mode[argc], op[argc]);\n \n-\t      /*gcc_assert (GET_MODE (op[argc]) == mode[argc]); */\n+\t      gcc_assert (GET_MODE (op[argc]) == mode[argc]\n+\t\t\t  || (GET_MODE(op[argc]) == E_VOIDmode\n+\t\t\t      && CONSTANT_P (op[argc])));\n \t      if (!(*insn_data[icode].operand[opno].predicate)\n \t\t  (op[argc], mode[argc]))\n \t\top[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n@@ -3198,7 +3224,7 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n   else\n     emit_insn (insn);\n \n-  if (GET_MODE_CLASS (tmode) == MODE_VECTOR_BOOL)\n+  if (TARGET_HAVE_MVE && VALID_MVE_PRED_MODE (tmode))\n     {\n       rtx HItarget = gen_reg_rtx (HImode);\n       emit_move_insn (HItarget, gen_lowpart (HImode, target));"}, {"sha": "c7645c480f63ab4d85cad207099c318f8e69a07d", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -91,6 +91,7 @@ BOOL_MODE (B4I, 4, 1);\n VECTOR_BOOL_MODE (V16BI, 16, BI, 2);\n VECTOR_BOOL_MODE (V8BI, 8, B2I, 2);\n VECTOR_BOOL_MODE (V4BI, 4, B4I, 2);\n+VECTOR_MODE (INT, QI, 2);\n \n /* Fraction and accumulator vector modes.  */\n VECTOR_MODES (FRACT, 4);      /* V4QQ  V2HQ */"}, {"sha": "c8ae5e1e9c16b35cd04147f98b4cc97641a4bb3b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -585,7 +585,6 @@ struct cpu_option\n extern const arch_option all_architectures[];\n extern const cpu_option all_cores[];\n \n-extern enum aarch_key_type aarch_ra_sign_key;\n \n const cpu_option *arm_parse_cpu_option_name (const cpu_option *, const char *,\n \t\t\t\t\t     const char *, bool = true);"}, {"sha": "daa4bd95e307973e88a8590e5231fc410c840d4f", "filename": "gcc/config/arm/arm-simd-builtin-types.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -51,7 +51,3 @@\n   ENTRY (Bfloat16x2_t, V2BF, none, 32, bfloat16, 20)\n   ENTRY (Bfloat16x4_t, V4BF, none, 64, bfloat16, 20)\n   ENTRY (Bfloat16x8_t, V8BF, none, 128, bfloat16, 20)\n-\n-  ENTRY (Pred1x16_t, V16BI, predicate, 16, pred1, 16)\n-  ENTRY (Pred2x8_t, V8BI, predicate, 8, pred1, 15)\n-  ENTRY (Pred4x4_t, V4BI, predicate, 4, pred1, 15)"}, {"sha": "a46627bc375719c8ff30b6857ca864d71e130a4f", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2420,9 +2420,6 @@ const struct tune_params arm_fa726te_tune =\n   tune_params::SCHED_AUTOPREF_OFF\n };\n \n-/* Key type for Pointer Authentication extension.  */\n-enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n-\n char *accepted_branch_protection_string = NULL;\n \n /* Auto-generated CPU, FPU and architecture tables.  */\n@@ -8682,6 +8679,11 @@ thumb2_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n   bool use_ldrd;\n   enum rtx_code code = GET_CODE (x);\n \n+  /* If we are dealing with a MVE predicate mode, then treat it as a HImode as\n+     can store and load it like any other 16-bit value.  */\n+  if (TARGET_HAVE_MVE && VALID_MVE_PRED_MODE (mode))\n+    mode = HImode;\n+\n   if (TARGET_HAVE_MVE && VALID_MVE_MODE (mode))\n     return mve_vector_mem_operand (mode, x, strict_p);\n \n@@ -12960,7 +12962,7 @@ simd_valid_immediate (rtx op, machine_mode mode, int inverse,\n   /* Only support 128-bit vectors for MVE.  */\n   if (TARGET_HAVE_MVE\n       && (!vector\n-\t  || (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+\t  || VALID_MVE_PRED_MODE (mode)\n \t  || n_elts * innersize != 16))\n     return -1;\n \n@@ -13333,9 +13335,15 @@ neon_vdup_constant (rtx vals, bool generate)\n rtx\n mve_bool_vec_to_const (rtx const_vec)\n {\n-  int n_elts = GET_MODE_NUNITS ( GET_MODE (const_vec));\n-  int repeat = 16 / n_elts;\n-  int i;\n+  machine_mode mode = GET_MODE (const_vec);\n+\n+  if (!VECTOR_MODE_P (mode))\n+    return const_vec;\n+\n+  unsigned n_elts = GET_MODE_NUNITS (mode);\n+  unsigned el_prec = GET_MODE_PRECISION (GET_MODE_INNER (mode));\n+  unsigned shift_c = 16 / n_elts;\n+  unsigned i;\n   int hi_val = 0;\n \n   for (i = 0; i < n_elts; i++)\n@@ -13344,12 +13352,16 @@ mve_bool_vec_to_const (rtx const_vec)\n       unsigned HOST_WIDE_INT elpart;\n \n       gcc_assert (CONST_INT_P (el));\n-      elpart = INTVAL (el);\n+      elpart = INTVAL (el) & ((1U << el_prec) - 1);\n \n-      for (int j = 0; j < repeat; j++)\n-\thi_val |= elpart << (i * repeat + j);\n+      unsigned index = BYTES_BIG_ENDIAN ? n_elts - i - 1 : i;\n+\n+      hi_val |= elpart << (index * shift_c);\n     }\n-  return gen_int_mode (hi_val, HImode);\n+  /* We are using mov immediate to encode this constant which writes 32-bits\n+     so we need to make sure the top 16-bits are all 0, otherwise we can't\n+     guarantee we can actually write this immediate.  */\n+  return gen_int_mode (hi_val, SImode);\n }\n \n /* Return a non-NULL RTX iff VALS, which is a PARALLEL containing only\n@@ -13392,7 +13404,7 @@ neon_make_constant (rtx vals, bool generate)\n       && simd_immediate_valid_for_move (const_vec, mode, NULL, NULL))\n     /* Load using VMOV.  On Cortex-A8 this takes one cycle.  */\n     return const_vec;\n-  else if (TARGET_HAVE_MVE && (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL))\n+  else if (TARGET_HAVE_MVE && VALID_MVE_PRED_MODE(mode))\n     return mve_bool_vec_to_const (const_vec);\n   else if ((target = neon_vdup_constant (vals, generate)) != NULL_RTX)\n     /* Loaded using VDUP.  On Cortex-A8 the VDUP takes one NEON\n@@ -25656,10 +25668,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n     return false;\n \n   if (IS_VPR_REGNUM (regno))\n-    return mode == HImode\n-      || mode == V16BImode\n-      || mode == V8BImode\n-      || mode == V4BImode;\n+    return VALID_MVE_PRED_MODE (mode);\n \n   if (TARGET_THUMB1)\n     /* For the Thumb we only allow values bigger than SImode in\n@@ -25738,6 +25747,10 @@ arm_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   if (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2))\n     return true;\n \n+  if (TARGET_HAVE_MVE\n+      && (VALID_MVE_PRED_MODE (mode1) && VALID_MVE_PRED_MODE (mode2)))\n+    return true;\n+\n   /* We specifically want to allow elements of \"structure\" modes to\n      be tieable to the structure.  This more general condition allows\n      other rarer situations too.  */\n@@ -29582,14 +29595,12 @@ arm_vector_mode_supported_p (machine_mode mode)\n     return true;\n \n   if (TARGET_HAVE_MVE\n-      && (mode == V2DImode || mode == V4SImode || mode == V8HImode\n-\t  || mode == V16QImode\n-\t  || mode == V16BImode || mode == V8BImode || mode == V4BImode))\n-      return true;\n+      && (VALID_MVE_SI_MODE (mode) || VALID_MVE_PRED_MODE (mode)))\n+    return true;\n \n   if (TARGET_HAVE_MVE_FLOAT\n       && (mode == V2DFmode || mode == V4SFmode || mode == V8HFmode))\n-      return true;\n+    return true;\n \n   return false;\n }\n@@ -31408,6 +31419,7 @@ arm_mode_to_pred_mode (machine_mode mode)\n     case 16: return V16BImode;\n     case 8: return V8BImode;\n     case 4: return V4BImode;\n+    case 2: return V2QImode;\n     }\n   return opt_machine_mode ();\n }"}, {"sha": "7d40b8b7e00bc3b4dcff7ec685ba864ca3885052", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1104,6 +1104,11 @@ extern const int arm_arch_cde_coproc_bits[];\n    || (MODE) == V16QImode || (MODE) == V8HFmode || (MODE) == V4SFmode \\\n    || (MODE) == V2DFmode)\n \n+#define VALID_MVE_PRED_MODE(MODE) \\\n+  ((MODE) == HImode\t\t\t\t\t\t\t\\\n+   || (MODE) == V16BImode || (MODE) == V8BImode || (MODE) == V4BImode\t\\\n+   || (MODE) == V2QImode)\n+\n #define VALID_MVE_SI_MODE(MODE) \\\n   ((MODE) == V2DImode ||(MODE) == V4SImode || (MODE) == V8HImode \\\n    || (MODE) == V16QImode)"}, {"sha": "3a49b51ece0e3711d49ee5fb94e2bfdac3a05e38", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -30,6 +30,9 @@ enum aarch_function_type aarch_ra_sign_scope = AARCH_FUNCTION_NONE\n TargetVariable\n unsigned aarch_enable_bti = 0\n \n+TargetVariable\n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A\n+\n Enum\n Name(tls_type) Type(enum arm_tls_type)\n TLS dialect to use:"}, {"sha": "1262d66812102e1d47d591ccccae0c24008dad60", "filename": "gcc/config/arm/arm_mve.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm_mve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm_mve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_mve.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3528,35 +3528,35 @@ __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp16q (uint32_t __a)\n {\n-  return __builtin_mve_vctp16qhi (__a);\n+  return __builtin_mve_vctp16qv8bi (__a);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp32q (uint32_t __a)\n {\n-  return __builtin_mve_vctp32qhi (__a);\n+  return __builtin_mve_vctp32qv4bi (__a);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp64q (uint32_t __a)\n {\n-  return __builtin_mve_vctp64qhi (__a);\n+  return __builtin_mve_vctp64qv2qi (__a);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp8q (uint32_t __a)\n {\n-  return __builtin_mve_vctp8qhi (__a);\n+  return __builtin_mve_vctp8qv16bi (__a);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vpnot (mve_pred16_t __a)\n {\n-  return __builtin_mve_vpnothi (__a);\n+  return __builtin_mve_vpnotv16bi (__a);\n }\n \n __extension__ extern __inline uint8x16_t\n@@ -6696,28 +6696,28 @@ __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp8q_m (uint32_t __a, mve_pred16_t __p)\n {\n-  return __builtin_mve_vctp8q_mhi (__a, __p);\n+  return __builtin_mve_vctp8q_mv16bi (__a, __p);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp64q_m (uint32_t __a, mve_pred16_t __p)\n {\n-  return __builtin_mve_vctp64q_mhi (__a, __p);\n+  return __builtin_mve_vctp64q_mv2qi (__a, __p);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp32q_m (uint32_t __a, mve_pred16_t __p)\n {\n-  return __builtin_mve_vctp32q_mhi (__a, __p);\n+  return __builtin_mve_vctp32q_mv4bi (__a, __p);\n }\n \n __extension__ extern __inline mve_pred16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vctp16q_m (uint32_t __a, mve_pred16_t __p)\n {\n-  return __builtin_mve_vctp16q_mhi (__a, __p);\n+  return __builtin_mve_vctp16q_mv8bi (__a, __p);\n }\n \n __extension__ extern __inline uint64_t"}, {"sha": "5e5510f6e37f197ffc4c08a1166bd0d80262f65a", "filename": "gcc/config/arm/arm_mve_builtins.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm_mve_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Farm_mve_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_mve_builtins.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -71,11 +71,11 @@ VAR2 (UNOP_UNONE_NONE, vcvtaq_u, v8hi, v4si)\n VAR2 (UNOP_UNONE_IMM, vmvnq_n_u, v8hi, v4si)\n VAR1 (UNOP_UNONE_UNONE, vrev16q_u, v16qi)\n VAR1 (UNOP_UNONE_UNONE, vaddlvq_u, v4si)\n-VAR1 (UNOP_UNONE_UNONE, vctp16q, hi)\n-VAR1 (UNOP_UNONE_UNONE, vctp32q, hi)\n-VAR1 (UNOP_UNONE_UNONE, vctp64q, hi)\n-VAR1 (UNOP_UNONE_UNONE, vctp8q, hi)\n-VAR1 (UNOP_UNONE_UNONE, vpnot, hi)\n+VAR1 (UNOP_PRED_UNONE, vctp16q, v8bi)\n+VAR1 (UNOP_PRED_UNONE, vctp32q, v4bi)\n+VAR1 (UNOP_PRED_UNONE, vctp64q, v2qi)\n+VAR1 (UNOP_PRED_UNONE, vctp8q, v16bi)\n+VAR1 (UNOP_PRED_PRED, vpnot, v16bi)\n VAR2 (BINOP_NONE_NONE_NONE, vsubq_n_f, v8hf, v4sf)\n VAR2 (BINOP_NONE_NONE_NONE, vbrsrq_n_f, v8hf, v4sf)\n VAR2 (BINOP_NONE_NONE_IMM, vcvtq_n_to_f_s, v8hf, v4sf)\n@@ -265,10 +265,10 @@ VAR2 (BINOP_NONE_NONE_IMM, vshllbq_n_s, v16qi, v8hi)\n VAR2 (BINOP_NONE_NONE_IMM, vorrq_n_s, v8hi, v4si)\n VAR2 (BINOP_NONE_NONE_IMM, vbicq_n_s, v8hi, v4si)\n VAR1 (BINOP_UNONE_UNONE_UNONE, vrmlaldavhq_u, v4si)\n-VAR1 (BINOP_UNONE_UNONE_UNONE, vctp8q_m, hi)\n-VAR1 (BINOP_UNONE_UNONE_UNONE, vctp64q_m, hi)\n-VAR1 (BINOP_UNONE_UNONE_UNONE, vctp32q_m, hi)\n-VAR1 (BINOP_UNONE_UNONE_UNONE, vctp16q_m, hi)\n+VAR1 (BINOP_PRED_UNONE_PRED, vctp8q_m, v16bi)\n+VAR1 (BINOP_PRED_UNONE_PRED, vctp64q_m, v2qi)\n+VAR1 (BINOP_PRED_UNONE_PRED, vctp32q_m, v4bi)\n+VAR1 (BINOP_PRED_UNONE_PRED, vctp16q_m, v8bi)\n VAR1 (BINOP_UNONE_UNONE_UNONE, vaddlvaq_u, v4si)\n VAR1 (BINOP_NONE_NONE_NONE, vrmlsldavhxq_s, v4si)\n VAR1 (BINOP_NONE_NONE_NONE, vrmlsldavhq_s, v4si)"}, {"sha": "504cd938b26e2629183a883383a81bb4e775bb92", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -316,7 +316,7 @@\n  \"@internal\n   In ARM/Thumb-2 state with MVE a constant vector of booleans.\"\n  (and (match_code \"const_vector\")\n-      (match_test \"TARGET_HAVE_MVE && GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\")))\n+      (match_test \"TARGET_HAVE_MVE && VALID_MVE_PRED_MODE (mode)\")))\n \n (define_constraint \"Da\"\n  \"@internal"}, {"sha": "39895ad62aa3afd55d3cbc92c55b45bc56710bcb", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -272,8 +272,8 @@\n (define_mode_iterator MVE_2 [V16QI V8HI V4SI])\n (define_mode_iterator MVE_5 [V8HI V4SI])\n (define_mode_iterator MVE_6 [V8HI V4SI])\n-(define_mode_iterator MVE_7 [V16BI V8BI V4BI])\n-(define_mode_iterator MVE_7_HI [HI V16BI V8BI V4BI])\n+(define_mode_iterator MVE_7 [V16BI V8BI V4BI V2QI])\n+(define_mode_iterator MVE_7_HI [HI V16BI V8BI V4BI V2QI])\n \n ;;----------------------------------------------------------------------------\n ;; Code iterators\n@@ -949,9 +949,12 @@\n (define_mode_attr earlyclobber_32 [(V16QI \"=w\") (V8HI \"=w\") (V4SI \"=&w\")\n \t\t\t\t\t\t(V8HF \"=w\") (V4SF \"=&w\")])\n (define_mode_attr MVE_VPRED [(V16QI \"V16BI\") (V8HI \"V8BI\") (V4SI \"V4BI\")\n-                             (V2DI \"HI\") (V8HF \"V8BI\")   (V4SF \"V4BI\")])\n+\t\t\t     (V8HF \"V8BI\")   (V4SF \"V4BI\") (V2DI \"V2QI\")])\n (define_mode_attr MVE_vpred [(V16QI \"v16bi\") (V8HI \"v8bi\") (V4SI \"v4bi\")\n-                             (V2DI \"hi\") (V8HF \"v8bi\")   (V4SF \"v4bi\")])\n+\t\t\t     (V8HF \"v8bi\")   (V4SF \"v4bi\")\n+\t\t\t     (V16BI \"v16bi\") (V8BI \"v8bi\") (V4BI \"v4bi\")\n+\t\t\t     (V2QI \"v2qi\")])\n+(define_mode_attr MVE_vctp [(V16BI \"8\") (V8BI \"16\") (V4BI \"32\") (V2QI \"64\")])\n \n ;;----------------------------------------------------------------------------\n ;; Code attributes\n@@ -1461,11 +1464,6 @@\n \t\t       (VADCIQ_M_S \"s\") (SQRSHRL_64 \"64\") (SQRSHRL_48 \"48\")\n \t\t       (UQRSHLL_64 \"64\") (UQRSHLL_48 \"48\") (VSHLCQ_M_S \"s\")\n \t\t       (VSHLCQ_M_U \"u\")])\n-\n-(define_int_attr mode1 [(VCTP8Q \"8\") (VCTP16Q \"16\") (VCTP32Q \"32\")\n-\t\t\t(VCTP64Q \"64\") (VCTP8Q_M \"8\") (VCTP16Q_M \"16\")\n-\t\t\t(VCTP32Q_M \"32\") (VCTP64Q_M \"64\")])\n-\n ;; Both kinds of return insn.\n (define_code_iterator RETURNS [return simple_return])\n (define_code_attr return_str [(return \"\") (simple_return \"simple_\")])\n@@ -1557,8 +1555,6 @@\n (define_int_iterator VCVTNQ [VCVTNQ_S VCVTNQ_U])\n (define_int_iterator VCVTMQ [VCVTMQ_S VCVTMQ_U])\n (define_int_iterator VADDLVQ [VADDLVQ_U VADDLVQ_S])\n-(define_int_iterator VCTPQ [VCTP8Q VCTP16Q VCTP32Q VCTP64Q])\n-(define_int_iterator VCTPQ_M [VCTP8Q_M VCTP16Q_M VCTP32Q_M VCTP64Q_M])\n (define_int_iterator VCVTQ_N_TO_F [VCVTQ_N_TO_F_S VCVTQ_N_TO_F_U])\n (define_int_iterator VCREATEQ [VCREATEQ_U VCREATEQ_S])\n (define_int_iterator VSHRQ_N [VSHRQ_N_S VSHRQ_N_U])"}, {"sha": "369a58d9b75d01289bb2dac20eb016967680f53b", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -643,24 +643,24 @@\n ;;\n ;; [vctp8q vctp16q vctp32q vctp64q])\n ;;\n-(define_insn \"mve_vctp<mode1>qhi\"\n+(define_insn \"mve_vctp<MVE_vctp>q<MVE_vpred>\"\n   [\n-   (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n-\t(unspec:HI [(match_operand:SI 1 \"s_register_operand\" \"r\")]\n-\tVCTPQ))\n+   (set (match_operand:MVE_7 0 \"vpr_register_operand\" \"=Up\")\n+\t(unspec:MVE_7 [(match_operand:SI 1 \"s_register_operand\" \"r\")]\n+\tVCTP))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vctp.<mode1> %1\"\n+  \"vctp.<MVE_vctp> %1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n ;;\n ;; [vpnot])\n ;;\n-(define_insn \"mve_vpnothi\"\n+(define_insn \"mve_vpnotv16bi\"\n   [\n-   (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n-\t(unspec:HI [(match_operand:HI 1 \"vpr_register_operand\" \"0\")]\n+   (set (match_operand:V16BI 0 \"vpr_register_operand\" \"=Up\")\n+\t(unspec:V16BI [(match_operand:V16BI 1 \"vpr_register_operand\" \"0\")]\n \t VPNOT))\n   ]\n   \"TARGET_HAVE_MVE\"\n@@ -1959,15 +1959,15 @@\n ;;\n ;; [vctp8q_m vctp16q_m vctp32q_m vctp64q_m])\n ;;\n-(define_insn \"mve_vctp<mode1>q_mhi\"\n+(define_insn \"mve_vctp<MVE_vctp>q_m<MVE_vpred>\"\n   [\n-   (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n-\t(unspec:HI [(match_operand:SI 1 \"s_register_operand\" \"r\")\n-\t\t    (match_operand:HI 2 \"vpr_register_operand\" \"Up\")]\n-\t VCTPQ_M))\n+   (set (match_operand:MVE_7 0 \"vpr_register_operand\" \"=Up\")\n+\t(unspec:MVE_7 [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t    (match_operand:MVE_7 2 \"vpr_register_operand\" \"Up\")]\n+\t VCTP_M))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vpst\\;vctpt.<mode1> %1\"\n+  \"vpst\\;vctpt.<MVE_vctp> %1\"\n   [(set_attr \"type\" \"mve_move\")\n    (set_attr \"length\"\"8\")])\n \n@@ -4979,7 +4979,7 @@\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vabavt.<supf>%#<V_sz_elem>\\t%0, %q2, %q3\"\n   [(set_attr \"type\" \"mve_move\")\n-])\n+   (set_attr \"length\" \"8\")])\n \n ;;\n ;; [vqshluq_m_n_s])\n@@ -4995,7 +4995,8 @@\n   ]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\n\\tvqshlut.s%#<V_sz_elem>\\t%q0, %q2, %3\"\n-  [(set_attr \"type\" \"mve_move\")])\n+  [(set_attr \"type\" \"mve_move\")\n+   (set_attr \"length\" \"8\")])\n \n ;;\n ;; [vshlq_m_s, vshlq_m_u])\n@@ -5011,7 +5012,8 @@\n   ]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vshlt.<supf>%#<V_sz_elem>\\t%q0, %q2, %q3\"\n-  [(set_attr \"type\" \"mve_move\")])\n+  [(set_attr \"type\" \"mve_move\")\n+   (set_attr \"length\" \"8\")])\n \n ;;\n ;; [vsriq_m_n_s, vsriq_m_n_u])\n@@ -5027,7 +5029,8 @@\n   ]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vsrit.%#<V_sz_elem>\\t%q0, %q2, %3\"\n-  [(set_attr \"type\" \"mve_move\")])\n+  [(set_attr \"type\" \"mve_move\")\n+   (set_attr \"length\" \"8\")])\n \n ;;\n ;; [vsubq_m_u, vsubq_m_s])\n@@ -5043,7 +5046,8 @@\n   ]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vsubt.i%#<V_sz_elem>\\t%q0, %q2, %q3\"\n-  [(set_attr \"type\" \"mve_move\")])\n+  [(set_attr \"type\" \"mve_move\")\n+   (set_attr \"length\" \"8\")])\n \n ;;\n ;; [vcvtq_m_n_to_f_u, vcvtq_m_n_to_f_s])\n@@ -7664,7 +7668,7 @@\n   [(set (match_operand:V2DI 0 \"s_register_operand\" \"=&w\")\n \t(unspec:V2DI [(match_operand:V2DI 1 \"s_register_operand\" \"w\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t      (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t\t      (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \t VLDRDGBQ))\n   ]\n   \"TARGET_HAVE_MVE\"\n@@ -7705,7 +7709,7 @@\n  [(set (match_operand:V2DI 0 \"s_register_operand\" \"=&w\")\n        (unspec:V2DI [(match_operand:V2DI 1 \"memory_operand\" \"Us\")\n \t\t     (match_operand:V2DI 2 \"s_register_operand\" \"w\")\n-\t\t     (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t\t     (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \tVLDRDGOQ))\n  ]\n  \"TARGET_HAVE_MVE\"\n@@ -7746,7 +7750,7 @@\n   [(set (match_operand:V2DI 0 \"s_register_operand\" \"=&w\")\n \t(unspec:V2DI [(match_operand:V2DI 1 \"memory_operand\" \"Us\")\n \t\t      (match_operand:V2DI 2 \"s_register_operand\" \"w\")\n-\t\t      (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t\t      (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \t VLDRDGSOQ))\n   ]\n   \"TARGET_HAVE_MVE\"\n@@ -8364,7 +8368,7 @@\n \t\t[(match_operand:V2DI 0 \"s_register_operand\" \"w\")\n \t\t (match_operand:SI 1 \"mve_vldrd_immediate\" \"Ri\")\n \t\t (match_operand:V2DI 2 \"s_register_operand\" \"w\")\n-\t\t (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t\t (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \t VSTRDSBQ))\n   ]\n   \"TARGET_HAVE_MVE\"\n@@ -8407,7 +8411,7 @@\n   [(match_operand:V2DI 0 \"mve_scatter_memory\")\n    (match_operand:V2DI 1 \"s_register_operand\")\n    (match_operand:V2DI 2 \"s_register_operand\")\n-   (match_operand:HI 3 \"vpr_register_operand\")\n+   (match_operand:V2QI 3 \"vpr_register_operand\")\n    (unspec:V4SI [(const_int 0)] VSTRDSOQ)]\n   \"TARGET_HAVE_MVE\"\n {\n@@ -8425,7 +8429,7 @@\n \t  [(match_operand:SI 0 \"register_operand\" \"r\")\n \t   (match_operand:V2DI 1 \"s_register_operand\" \"w\")\n \t   (match_operand:V2DI 2 \"s_register_operand\" \"w\")\n-\t   (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t   (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \t  VSTRDSOQ))]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vstrdt.64\\t%q2, [%0, %q1]\"\n@@ -8466,7 +8470,7 @@\n   [(match_operand:V2DI 0 \"mve_scatter_memory\")\n    (match_operand:V2DI 1 \"s_register_operand\")\n    (match_operand:V2DI 2 \"s_register_operand\")\n-   (match_operand:HI 3 \"vpr_register_operand\")\n+   (match_operand:V2QI 3 \"vpr_register_operand\")\n    (unspec:V4SI [(const_int 0)] VSTRDSSOQ)]\n   \"TARGET_HAVE_MVE\"\n {\n@@ -8485,7 +8489,7 @@\n \t  [(match_operand:SI 0 \"register_operand\" \"r\")\n \t   (match_operand:V2DI 1 \"s_register_operand\" \"w\")\n \t   (match_operand:V2DI 2 \"s_register_operand\" \"w\")\n-\t   (match_operand:HI 3 \"vpr_register_operand\" \"Up\")]\n+\t   (match_operand:V2QI 3 \"vpr_register_operand\" \"Up\")]\n \t  VSTRDSSOQ))]\n   \"TARGET_HAVE_MVE\"\n   \"vpst\\;vstrdt.64\\t%q2, [%0, %q1, UXTW #3]\"\n@@ -9457,7 +9461,7 @@\n \t\t[(match_operand:V2DI 1 \"s_register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"mve_vldrd_immediate\" \"Ri\")\n \t\t (match_operand:V2DI 3 \"s_register_operand\" \"w\")\n-\t\t (match_operand:HI 4 \"vpr_register_operand\")]\n+\t\t (match_operand:V2QI 4 \"vpr_register_operand\")]\n \t VSTRDSBWBQ))\n    (set (match_operand:V2DI 0 \"s_register_operand\" \"=w\")\n \t(unspec:V2DI [(match_dup 1) (match_dup 2)]\n@@ -9748,7 +9752,7 @@\n   [(match_operand:V2DI 0 \"s_register_operand\")\n    (match_operand:V2DI 1 \"s_register_operand\")\n    (match_operand:SI 2 \"mve_vldrd_immediate\")\n-   (match_operand:HI 3 \"vpr_register_operand\")\n+   (match_operand:V2QI 3 \"vpr_register_operand\")\n    (unspec:V2DI [(const_int 0)] VLDRDGBWBQ)]\n   \"TARGET_HAVE_MVE\"\n {\n@@ -9764,7 +9768,7 @@\n   [(match_operand:V2DI 0 \"s_register_operand\")\n    (match_operand:V2DI 1 \"s_register_operand\")\n    (match_operand:SI 2 \"mve_vldrd_immediate\")\n-   (match_operand:HI 3 \"vpr_register_operand\")\n+   (match_operand:V2QI 3 \"vpr_register_operand\")\n    (unspec:V2DI [(const_int 0)] VLDRDGBWBQ)]\n   \"TARGET_HAVE_MVE\"\n {\n@@ -9798,7 +9802,7 @@\n   [(set (match_operand:V2DI 0 \"s_register_operand\" \"=&w\")\n \t(unspec:V2DI [(match_operand:V2DI 2 \"s_register_operand\" \"1\")\n \t\t      (match_operand:SI 3 \"mve_vldrd_immediate\" \"Ri\")\n-\t\t      (match_operand:HI 4 \"vpr_register_operand\" \"Up\")\n+\t\t      (match_operand:V2QI 4 \"vpr_register_operand\" \"Up\")\n \t\t      (mem:BLK (scratch))]\n \t VLDRDGBWBQ))\n    (set (match_operand:V2DI 1 \"s_register_operand\" \"=&w\")"}, {"sha": "84384ee798de363b874c41a16dc5daae34eccb94", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -579,10 +579,8 @@\n   VCVTMQ_S\n   VCVTMQ_U\n   VADDLVQ_U\n-  VCTP8Q\n-  VCTP16Q\n-  VCTP32Q\n-  VCTP64Q\n+  VCTP\n+  VCTP_M\n   VPNOT\n   VCREATEQ_F\n   VCVTQ_N_TO_F_S\n@@ -706,10 +704,6 @@\n   VADDLVAQ_S\n   VBICQ_N_U\n   VBICQ_N_S\n-  VCTP8Q_M\n-  VCTP16Q_M\n-  VCTP32Q_M\n-  VCTP64Q_M\n   VCVTBQ_F16_F32\n   VCVTTQ_F16_F32\n   VMLALDAVQ_U"}, {"sha": "f34f35e1185e2b0974df965affb113772ea9282d", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -88,7 +88,7 @@\n     case 2:\n       return \"mov%?\\t%0, %1\\t%@ movhi\";\n     case 1:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_VECTOR_BOOL)\n+      if (VALID_MVE_PRED_MODE (<MODE>mode))\n         operands[1] = mve_bool_vec_to_const (operands[1]);\n       else\n         operands[1] = gen_lowpart (HImode, operands[1]);\n@@ -192,7 +192,7 @@\n     case 2:\n       return \"mov%?\\t%0, %1\\t%@ movhi\";\n     case 1:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_VECTOR_BOOL)\n+      if (VALID_MVE_PRED_MODE (<MODE>mode))\n         operands[1] = mve_bool_vec_to_const (operands[1]);\n       else\n         operands[1] = gen_lowpart (HImode, operands[1]);"}, {"sha": "d8693f8cfbec7fed3963df51950640cf05b73bb7", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -258,7 +258,7 @@ bpf_option_override (void)\n     {\n       inform (input_location,\n               \"%<-fstack-protector%> does not work \"\n-              \" on this architecture\");\n+\t      \"on this architecture\");\n       flag_stack_protect = 0;\n     }\n }"}, {"sha": "f6be0a2123451289ddced0d9f37b5feaa916e2d7", "filename": "gcc/config/bpf/bpf.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fbpf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fbpf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -242,7 +242,7 @@\n \n (define_insn \"zero_extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,m\")))]\n+\t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,q\")))]\n   \"\"\n   \"@\n    and\\t%0,0xffff\n@@ -252,7 +252,7 @@\n \n (define_insn \"zero_extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"0,r,m\")))]\n+\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"0,r,q\")))]\n   \"\"\n   \"@\n    and\\t%0,0xff\n@@ -263,7 +263,7 @@\n (define_insn \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI\n-\t  (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n+\t  (match_operand:SI 1 \"nonimmediate_operand\" \"r,q\")))]\n   \"\"\n   \"@\n    * return bpf_has_alu32 ? \\\"mov32\\t%0,%1\\\" : \\\"mov\\t%0,%1\\;and\\t%0,0xffffffff\\\";\n@@ -302,8 +302,8 @@\n }\")\n \n (define_insn \"*mov<MM:mode>\"\n-  [(set (match_operand:MM 0 \"nonimmediate_operand\" \"=r, r,r,m,m\")\n-        (match_operand:MM 1 \"mov_src_operand\"      \" m,rI,B,r,I\"))]\n+  [(set (match_operand:MM 0 \"nonimmediate_operand\" \"=r, r,r,q,q\")\n+        (match_operand:MM 1 \"mov_src_operand\"      \" q,rI,B,r,I\"))]\n   \"\"\n   \"@\n    ldx<mop>\\t%0,%1"}, {"sha": "33f9177b8eb1aef13741f541751e663c872006c5", "filename": "gcc/config/bpf/constraints.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fbpf%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fconstraints.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -29,3 +29,14 @@\n (define_constraint \"S\"\n   \"A constant call address.\"\n   (match_code \"const,symbol_ref,label_ref,const_int\"))\n+\n+;;\n+;; Memory constraints.\n+;;\n+\n+; Just like 'm' but disallows const_int.\n+; Used for ldx[b,h,w,dw] and stx[b,h,w,dw] instructions.\n+(define_memory_constraint \"q\"\n+  \"Memory reference which is not a constant integer.\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE(XEXP(op, 0)) != CONST_INT\")))"}, {"sha": "4232a17b784528a0dc9e7179af1d6695675c02b0", "filename": "gcc/config/gcn/gcn-run.cc", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-run.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -35,6 +35,7 @@\n #include <signal.h>\n \n #include \"hsa.h\"\n+#include \"../../../libgomp/config/gcn/libgomp-gcn.h\"\n \n #ifndef HSA_RUNTIME_LIB\n #define HSA_RUNTIME_LIB \"libhsa-runtime64.so.1\"\n@@ -487,39 +488,16 @@ device_malloc (size_t size, hsa_region_t region)\n    automatically assign the exit value to *return_value.  */\n struct kernargs\n {\n-  /* Kernargs.  */\n-  int32_t argc;\n-  int64_t argv;\n-  int64_t out_ptr;\n-  int64_t heap_ptr;\n-\n-  /* Output data.  */\n-  struct output\n-  {\n-    int return_value;\n-    unsigned int next_output;\n-    struct printf_data\n-    {\n-      int written;\n-      char msg[128];\n-      int type;\n-      union\n-      {\n-\tint64_t ivalue;\n-\tdouble dvalue;\n-\tchar text[128];\n-      };\n-    } queue[1024];\n-    unsigned int consumed;\n-  } output_data;\n+  union {\n+    struct {\n+      int32_t argc;\n+      int64_t argv;\n+    } args;\n+    struct kernargs_abi abi;\n+  };\n+  struct output output_data;\n };\n \n-struct heap\n-{\n-  int64_t size;\n-  char data[0];\n-} heap;\n-\n /* Print any console output from the kernel.\n    We print all entries from \"consumed\" to the next entry without a \"written\"\n    flag, or \"next_output\" is reached.  The buffer is circular, but the\n@@ -687,6 +665,16 @@ main (int argc, char *argv[])\n   for (int i = 0; i < kernel_argc; i++)\n     args_size += strlen (kernel_argv[i]) + 1;\n \n+  /* The device stack can be adjusted via an environment variable.  */\n+  char *envvar = getenv (\"GCN_STACK_SIZE\");\n+  int stack_size = 1 * 1024 * 1024;  /* 1MB default.  */\n+  if (envvar)\n+    {\n+      int val = atoi (envvar);\n+      if (val)\n+\tstack_size = val;\n+    }\n+\n   /* Allocate device memory for both function parameters and the argv\n      data.  */\n   struct kernargs *kernargs = device_malloc (sizeof (*kernargs),\n@@ -702,11 +690,12 @@ main (int argc, char *argv[])\n   XHSA (hsa_fns.hsa_memory_assign_agent_fn (heap, device,\n \t\t\t\t\t    HSA_ACCESS_PERMISSION_RW),\n \t\"Assign heap to device agent\");\n+  void *stack = device_malloc (stack_size, heap_region);\n \n   /* Write the data to the target.  */\n-  kernargs->argc = kernel_argc;\n-  kernargs->argv = (int64_t) args->argv_data;\n-  kernargs->out_ptr = (int64_t) &kernargs->output_data;\n+  kernargs->args.argc = kernel_argc;\n+  kernargs->args.argv = (int64_t) args->argv_data;\n+  kernargs->abi.out_ptr = (int64_t) &kernargs->output_data;\n   kernargs->output_data.return_value = 0xcafe0000; /* Default return value. */\n   kernargs->output_data.next_output = 0;\n   for (unsigned i = 0; i < (sizeof (kernargs->output_data.queue)\n@@ -721,8 +710,11 @@ main (int argc, char *argv[])\n       memcpy (&args->strings[offset], kernel_argv[i], arg_len + 1);\n       offset += arg_len;\n     }\n-  kernargs->heap_ptr = (int64_t) heap;\n+  kernargs->abi.heap_ptr = (int64_t) heap;\n   hsa_fns.hsa_memory_copy_fn (&heap->size, &heap_size, sizeof (heap_size));\n+  kernargs->abi.arena_ptr = 0;\n+  kernargs->abi.stack_ptr = (int64_t) stack;\n+  kernargs->abi.stack_size_per_thread = stack_size;\n \n   /* Run constructors on the GPU.  */\n   run (init_array_kernel, kernargs);"}, {"sha": "47d9d87d58a395c1f06eaab1a07ca35af9dc48a9", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3489,6 +3489,29 @@\n     DONE;\n   })\n \n+(define_code_iterator cond_shiftop [ashift lshiftrt ashiftrt])\n+\n+(define_expand \"cond_<expander><mode>\"\n+  [(match_operand:V_INT_noHI 0 \"register_operand\")\n+   (match_operand:DI 1 \"register_operand\")\n+   (cond_shiftop:V_INT_noHI\n+     (match_operand:V_INT_noHI 2 \"gcn_alu_operand\")\n+     (match_operand:V_INT_noHI 3 \"gcn_alu_operand\"))\n+   (match_operand:V_INT_noHI 4 \"register_operand\")]\n+  \"\"\n+  {\n+    operands[1] = force_reg (DImode, operands[1]);\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+\n+    rtx shiftby = gen_reg_rtx (<VnSI>mode);\n+    convert_move (shiftby, operands[3], 0);\n+\n+    emit_insn (gen_v<expander><mode>3_exec (operands[0], operands[2],\n+                                            shiftby, operands[4],\n+                                            operands[1]));\n+    DONE;\n+  })\n+\n ;; }}}\n ;; {{{ Vector reductions\n "}, {"sha": "23ab01e75d81777843ab2e3ccdb24e80e0407a69", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 118, "deletions": 74, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -138,21 +138,6 @@ gcn_option_override (void)\n       : ISA_UNKNOWN);\n   gcc_assert (gcn_isa != ISA_UNKNOWN);\n \n-  /* The default stack size needs to be small for offload kernels because\n-     there may be many, many threads.  Also, a smaller stack gives a\n-     measureable performance boost.  But, a small stack is insufficient\n-     for running the testsuite, so we use a larger default for the stand\n-     alone case.  */\n-  if (stack_size_opt == -1)\n-    {\n-      if (flag_openacc || flag_openmp)\n-\t/* 512 bytes per work item = 32kB total.  */\n-\tstack_size_opt = 512 * 64;\n-      else\n-\t/* 1MB total.  */\n-\tstack_size_opt = 1048576;\n-    }\n-\n   /* Reserve 1Kb (somewhat arbitrarily) of LDS space for reduction results and\n      worker broadcasts.  */\n   if (gang_private_size_opt == -1)\n@@ -228,11 +213,9 @@ static const struct gcn_kernel_arg_type\n };\n \n static const long default_requested_args\n-\t= (1 << PRIVATE_SEGMENT_BUFFER_ARG)\n-\t  | (1 << DISPATCH_PTR_ARG)\n+\t= (1 << DISPATCH_PTR_ARG)\n \t  | (1 << QUEUE_PTR_ARG)\n \t  | (1 << KERNARG_SEGMENT_PTR_ARG)\n-\t  | (1 << PRIVATE_SEGMENT_WAVE_OFFSET_ARG)\n \t  | (1 << WORKGROUP_ID_X_ARG)\n \t  | (1 << WORK_ITEM_ID_X_ARG)\n \t  | (1 << WORK_ITEM_ID_Y_ARG)\n@@ -1865,10 +1848,14 @@ gcn_addr_space_convert (rtx op, tree from_type, tree to_type)\n \n   if (AS_LDS_P (as_from) && AS_FLAT_P (as_to))\n     {\n-      rtx queue = gen_rtx_REG (DImode,\n-\t\t\t       cfun->machine->args.reg[QUEUE_PTR_ARG]);\n+      /* The high bits of the QUEUE_PTR_ARG register are used by\n+\t GCN_BUILTIN_FIRST_CALL_THIS_THREAD_P, so mask them out.  */\n+      rtx queue_reg = gen_rtx_REG (DImode,\n+\t\t\t\t   cfun->machine->args.reg[QUEUE_PTR_ARG]);\n+      rtx queue_ptr = gen_reg_rtx (DImode);\n+      emit_insn (gen_anddi3 (queue_ptr, queue_reg, GEN_INT (0xffffffffffff)));\n       rtx group_seg_aperture_hi = gen_rtx_MEM (SImode,\n-\t\t\t\t     gen_rtx_PLUS (DImode, queue,\n+\t\t\t\t     gen_rtx_PLUS (DImode, queue_ptr,\n \t\t\t\t\t\t   gen_int_mode (64, SImode)));\n       rtx tmp = gen_reg_rtx (DImode);\n \n@@ -2521,6 +2508,11 @@ gcn_conditional_register_usage (void)\n       fixed_regs[cfun->machine->args.reg[DISPATCH_PTR_ARG]] = 1;\n       fixed_regs[cfun->machine->args.reg[DISPATCH_PTR_ARG] + 1] = 1;\n     }\n+  if (cfun->machine->args.reg[QUEUE_PTR_ARG] >= 0)\n+    {\n+      fixed_regs[cfun->machine->args.reg[QUEUE_PTR_ARG]] = 1;\n+      fixed_regs[cfun->machine->args.reg[QUEUE_PTR_ARG] + 1] = 1;\n+    }\n   if (cfun->machine->args.reg[WORKGROUP_ID_X_ARG] >= 0)\n     fixed_regs[cfun->machine->args.reg[WORKGROUP_ID_X_ARG]] = 1;\n   if (cfun->machine->args.reg[WORK_ITEM_ID_X_ARG] >= 0)\n@@ -3346,10 +3338,56 @@ gcn_expand_prologue ()\n     }\n   else\n     {\n-      rtx wave_offset = gen_rtx_REG (SImode,\n-\t\t\t\t     cfun->machine->args.\n-\t\t\t\t     reg[PRIVATE_SEGMENT_WAVE_OFFSET_ARG]);\n+      if (TARGET_PACKED_WORK_ITEMS)\n+\t{\n+\t  /* v0 conatins the X, Y and Z dimensions all in one.\n+\t     Expand them out for ABI compatibility.  */\n+\t  /* TODO: implement and use zero_extract.  */\n+\t  rtx v1 = gen_rtx_REG (V64SImode, VGPR_REGNO (1));\n+\t  emit_insn (gen_andv64si3 (v1, gen_rtx_REG (V64SImode, VGPR_REGNO (0)),\n+\t\t\t\t    gen_rtx_CONST_INT (VOIDmode, 0x3FF << 10)));\n+\t  emit_insn (gen_lshrv64si3 (v1, v1, gen_rtx_CONST_INT (VOIDmode, 10)));\n+\t  emit_insn (gen_prologue_use (v1));\n+\n+\t  rtx v2 = gen_rtx_REG (V64SImode, VGPR_REGNO (2));\n+\t  emit_insn (gen_andv64si3 (v2, gen_rtx_REG (V64SImode, VGPR_REGNO (0)),\n+\t\t\t\t    gen_rtx_CONST_INT (VOIDmode, 0x3FF << 20)));\n+\t  emit_insn (gen_lshrv64si3 (v2, v2, gen_rtx_CONST_INT (VOIDmode, 20)));\n+\t  emit_insn (gen_prologue_use (v2));\n+\t}\n+\n+      /* We no longer use the private segment for the stack (it's not\n+\t accessible to reverse offload), so we must calculate a wave offset\n+\t from the grid dimensions and stack size, which is calculated on the\n+\t host, and passed in the kernargs region.\n+\t See libgomp-gcn.h for details.  */\n+      rtx wave_offset = gen_rtx_REG (SImode, FIRST_PARM_REG);\n+\n+      rtx num_waves_mem = gcn_oacc_dim_size (1);\n+      rtx num_waves = gen_rtx_REG (SImode, FIRST_PARM_REG+1);\n+      set_mem_addr_space (num_waves_mem, ADDR_SPACE_SCALAR_FLAT);\n+      emit_move_insn (num_waves, num_waves_mem);\n+\n+      rtx workgroup_num = gcn_oacc_dim_pos (0);\n+      rtx wave_num = gen_rtx_REG (SImode, FIRST_PARM_REG+2);\n+      emit_move_insn(wave_num, gcn_oacc_dim_pos (1));\n \n+      rtx thread_id = gen_rtx_REG (SImode, FIRST_PARM_REG+3);\n+      emit_insn (gen_mulsi3 (thread_id, num_waves, workgroup_num));\n+      emit_insn (gen_addsi3_scc (thread_id, thread_id, wave_num));\n+\n+      rtx kernarg_reg = gen_rtx_REG (DImode, cfun->machine->args.reg\n+\t\t\t\t     [KERNARG_SEGMENT_PTR_ARG]);\n+      rtx stack_size_mem = gen_rtx_MEM (SImode,\n+\t\t\t\t\tgen_rtx_PLUS (DImode, kernarg_reg,\n+\t\t\t\t\t\t      GEN_INT (52)));\n+      set_mem_addr_space (stack_size_mem, ADDR_SPACE_SCALAR_FLAT);\n+      emit_move_insn (wave_offset, stack_size_mem);\n+\n+      emit_insn (gen_mulsi3 (wave_offset, wave_offset, thread_id));\n+\n+      /* The FLAT_SCRATCH_INIT is not usually needed, but can be enabled\n+\t via the function attributes.  */\n       if (cfun->machine->args.requested & (1 << FLAT_SCRATCH_INIT_ARG))\n \t{\n \t  rtx fs_init_lo =\n@@ -3386,10 +3424,12 @@ gcn_expand_prologue ()\n       HOST_WIDE_INT sp_adjust = (offsets->local_vars\n \t\t\t\t + offsets->outgoing_args_size);\n \n-      /* Initialise FP and SP from the buffer descriptor in s[0:3].  */\n-      emit_move_insn (fp_lo, gen_rtx_REG (SImode, 0));\n-      emit_insn (gen_andsi3_scc (fp_hi, gen_rtx_REG (SImode, 1),\n-\t\t\t\t gen_int_mode (0xffff, SImode)));\n+      /* Initialize FP and SP from space allocated on the host.  */\n+      rtx stack_addr_mem = gen_rtx_MEM (DImode,\n+\t\t\t\t\tgen_rtx_PLUS (DImode, kernarg_reg,\n+\t\t\t\t\t\t      GEN_INT (40)));\n+      set_mem_addr_space (stack_addr_mem, ADDR_SPACE_SCALAR_FLAT);\n+      emit_move_insn (fp, stack_addr_mem);\n       rtx scc = gen_rtx_REG (BImode, SCC_REG);\n       emit_insn (gen_addsi3_scalar_carry (fp_lo, fp_lo, wave_offset, scc));\n       emit_insn (gen_addcsi3_scalar_zero (fp_hi, fp_hi, scc));\n@@ -3445,25 +3485,6 @@ gcn_expand_prologue ()\n     emit_insn (gen_prologue_use (gen_rtx_REG (SImode, M0_REG)));\n   }\n \n-  if (TARGET_PACKED_WORK_ITEMS\n-      && cfun && cfun->machine && !cfun->machine->normal_function)\n-  {\n-    /* v0 conatins the X, Y and Z dimensions all in one.\n-       Expand them out for ABI compatibility.  */\n-    /* TODO: implement and use zero_extract.  */\n-    rtx v1 = gen_rtx_REG (V64SImode, VGPR_REGNO (1));\n-    emit_insn (gen_andv64si3 (v1, gen_rtx_REG (V64SImode, VGPR_REGNO (0)),\n-\t       gen_rtx_CONST_INT (VOIDmode, 0x3FF << 10)));\n-    emit_insn (gen_lshrv64si3 (v1, v1, gen_rtx_CONST_INT (VOIDmode, 10)));\n-    emit_insn (gen_prologue_use (v1));\n-\n-    rtx v2 = gen_rtx_REG (V64SImode, VGPR_REGNO (2));\n-    emit_insn (gen_andv64si3 (v2, gen_rtx_REG (V64SImode, VGPR_REGNO (0)),\n-\t       gen_rtx_CONST_INT (VOIDmode, 0x3FF << 20)));\n-    emit_insn (gen_lshrv64si3 (v2, v2, gen_rtx_CONST_INT (VOIDmode, 20)));\n-    emit_insn (gen_prologue_use (v2));\n-  }\n-\n   if (cfun && cfun->machine && !cfun->machine->normal_function && flag_openmp)\n     {\n       /* OpenMP kernels have an implicit call to gomp_gcn_enter_kernel.  */\n@@ -4504,26 +4525,53 @@ gcn_expand_builtin_1 (tree exp, rtx target, rtx /*subtarget */ ,\n \t   cf. struct hsa_kernel_dispatch_packet_s in the HSA doc.  */\n \trtx ptr;\n \tif (cfun->machine->args.reg[DISPATCH_PTR_ARG] >= 0\n-\t    && cfun->machine->args.reg[PRIVATE_SEGMENT_BUFFER_ARG] >= 0)\n+\t    && cfun->machine->args.reg[KERNARG_SEGMENT_PTR_ARG] >= 0)\n \t  {\n-\t    rtx size_rtx = gen_rtx_REG (DImode,\n-\t\t\t     cfun->machine->args.reg[DISPATCH_PTR_ARG]);\n-\t    size_rtx = gen_rtx_MEM (SImode,\n-\t\t\t\t    gen_rtx_PLUS (DImode, size_rtx,\n-\t\t\t\t\t\t  GEN_INT (6*2 + 3*4)));\n-\t    size_rtx = gen_rtx_MULT (SImode, size_rtx, GEN_INT (64));\n-\n-\t    ptr = gen_rtx_REG (DImode,\n-\t\t    cfun->machine->args.reg[PRIVATE_SEGMENT_BUFFER_ARG]);\n-\t    ptr = gen_rtx_AND (DImode, ptr, GEN_INT (0x0000ffffffffffff));\n-\t    ptr = gen_rtx_PLUS (DImode, ptr, size_rtx);\n-\t    if (cfun->machine->args.reg[PRIVATE_SEGMENT_WAVE_OFFSET_ARG] >= 0)\n-\t      {\n-\t\trtx off;\n-\t\toff = gen_rtx_REG (SImode,\n-\t\t      cfun->machine->args.reg[PRIVATE_SEGMENT_WAVE_OFFSET_ARG]);\n-\t\tptr = gen_rtx_PLUS (DImode, ptr, off);\n-\t      }\n+\t    rtx num_waves_mem = gcn_oacc_dim_size (1);\n+\t    rtx num_waves = gen_reg_rtx (SImode);\n+\t    set_mem_addr_space (num_waves_mem, ADDR_SPACE_SCALAR_FLAT);\n+\t    emit_move_insn (num_waves, num_waves_mem);\n+\n+\t    rtx workgroup_num = gcn_oacc_dim_pos (0);\n+\t    rtx wave_num = gen_reg_rtx (SImode);\n+\t    emit_move_insn(wave_num, gcn_oacc_dim_pos (1));\n+\n+\t    rtx thread_id = gen_reg_rtx (SImode);\n+\t    emit_insn (gen_mulsi3 (thread_id, num_waves, workgroup_num));\n+\t    emit_insn (gen_addsi3_scc (thread_id, thread_id, wave_num));\n+\n+\t    rtx kernarg_reg = gen_rtx_REG (DImode, cfun->machine->args.reg\n+\t\t\t\t\t   [KERNARG_SEGMENT_PTR_ARG]);\n+\t    rtx stack_size_mem = gen_rtx_MEM (SImode,\n+\t\t\t\t\t      gen_rtx_PLUS (DImode,\n+\t\t\t\t\t\t\t    kernarg_reg,\n+\t\t\t\t\t\t\t    GEN_INT (52)));\n+\t    set_mem_addr_space (stack_size_mem, ADDR_SPACE_SCALAR_FLAT);\n+\t    rtx stack_size = gen_reg_rtx (SImode);\n+\t    emit_move_insn (stack_size, stack_size_mem);\n+\n+\t    rtx wave_offset = gen_reg_rtx (SImode);\n+\t    emit_insn (gen_mulsi3 (wave_offset, stack_size, thread_id));\n+\n+\t    rtx stack_limit_offset = gen_reg_rtx (SImode);\n+\t    emit_insn (gen_addsi3 (stack_limit_offset, wave_offset,\n+\t\t\t\t   stack_size));\n+\n+\t    rtx stack_limit_offset_di = gen_reg_rtx (DImode);\n+\t    emit_move_insn (gen_rtx_SUBREG (SImode, stack_limit_offset_di, 4),\n+\t\t\t    const0_rtx);\n+\t    emit_move_insn (gen_rtx_SUBREG (SImode, stack_limit_offset_di, 0),\n+\t\t\t    stack_limit_offset);\n+\n+\t    rtx stack_addr_mem = gen_rtx_MEM (DImode,\n+\t\t\t\t\t      gen_rtx_PLUS (DImode,\n+\t\t\t\t\t\t\t    kernarg_reg,\n+\t\t\t\t\t\t\t    GEN_INT (40)));\n+\t    set_mem_addr_space (stack_addr_mem, ADDR_SPACE_SCALAR_FLAT);\n+\t    rtx stack_addr = gen_reg_rtx (DImode);\n+\t    emit_move_insn (stack_addr, stack_addr_mem);\n+\n+\t    ptr = gen_rtx_PLUS (DImode, stack_addr, stack_limit_offset_di);\n \t  }\n \telse\n \t  {\n@@ -4551,11 +4599,11 @@ gcn_expand_builtin_1 (tree exp, rtx target, rtx /*subtarget */ ,\n \t   whether it was the first call.  */\n \trtx result = gen_reg_rtx (BImode);\n \temit_move_insn (result, const0_rtx);\n-\tif (cfun->machine->args.reg[PRIVATE_SEGMENT_BUFFER_ARG] >= 0)\n+\tif (cfun->machine->args.reg[QUEUE_PTR_ARG] >= 0)\n \t  {\n \t    rtx not_first = gen_label_rtx ();\n \t    rtx reg = gen_rtx_REG (DImode,\n-\t\t\tcfun->machine->args.reg[PRIVATE_SEGMENT_BUFFER_ARG]);\n+\t\t\tcfun->machine->args.reg[QUEUE_PTR_ARG]);\n \t    reg = gcn_operand_part (DImode, reg, 1);\n \t    rtx cmp = force_reg (SImode,\n \t\t\t\t gen_rtx_LSHIFTRT (SImode, reg, GEN_INT (16)));\n@@ -6041,16 +6089,13 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n \t   \"\\t  .amdhsa_reserve_vcc\\t1\\n\"\n \t   \"\\t  .amdhsa_reserve_flat_scratch\\t0\\n\"\n \t   \"\\t  .amdhsa_reserve_xnack_mask\\t%i\\n\"\n-\t   \"\\t  .amdhsa_private_segment_fixed_size\\t%i\\n\"\n+\t   \"\\t  .amdhsa_private_segment_fixed_size\\t0\\n\"\n \t   \"\\t  .amdhsa_group_segment_fixed_size\\t%u\\n\"\n \t   \"\\t  .amdhsa_float_denorm_mode_32\\t3\\n\"\n \t   \"\\t  .amdhsa_float_denorm_mode_16_64\\t3\\n\",\n \t   vgpr,\n \t   sgpr,\n \t   xnack_enabled,\n-\t   /* workitem_private_segment_bytes_size needs to be\n-\t      one 64th the wave-front stack size.  */\n-\t   stack_size_opt / 64,\n \t   LDS_SIZE);\n   if (gcn_arch == PROCESSOR_GFX90a)\n     fprintf (file,\n@@ -6075,15 +6120,14 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n \t   \"            .kernarg_segment_size: %i\\n\"\n \t   \"            .kernarg_segment_align: %i\\n\"\n \t   \"            .group_segment_fixed_size: %u\\n\"\n-\t   \"            .private_segment_fixed_size: %i\\n\"\n+\t   \"            .private_segment_fixed_size: 0\\n\"\n \t   \"            .wavefront_size: 64\\n\"\n \t   \"            .sgpr_count: %i\\n\"\n \t   \"            .vgpr_count: %i\\n\"\n \t   \"            .max_flat_workgroup_size: 1024\\n\",\n \t   cfun->machine->kernarg_segment_byte_size,\n \t   cfun->machine->kernarg_segment_alignment,\n \t   LDS_SIZE,\n-\t   stack_size_opt / 64,\n \t   sgpr, vgpr);\n   if (gcn_arch == PROCESSOR_GFX90a)\n     fprintf (file, \"            .agpr_count: 0\\n\"); // AGPRs are not used, yet"}, {"sha": "4ff9a5d4d12c21c16aac6fe09376f651e9db760e", "filename": "gcc/config/gcn/gcn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -183,7 +183,7 @@\n \f\n #define FIXED_REGISTERS {\t\t\t    \\\n     /* Scalars.  */\t\t\t\t    \\\n-    1, 1, 0, 0, 1, 1, 1, 1, 1, 1,\t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t    \\\n /*\t\tfp    sp    lr.  */\t\t    \\\n     1, 1, 0, 0, 0, 0, 1, 1, 0, 0,\t\t    \\\n /*  exec_save, cc_save */\t\t\t    \\"}, {"sha": "c5c32bdc833d4d2b94dfc1c3065c67591c74e2d2", "filename": "gcc/config/gcn/gcn.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -69,7 +69,7 @@ int stack_size_opt = -1\n \n mstack-size=\n Target RejectNegative Joined UInteger Var(stack_size_opt) Init(-1)\n--mstack-size=<number>\tSet the private segment size per wave-front, in bytes.\n+Obsolete; use GCN_STACK_SIZE at runtime.\n \n int gang_private_size_opt = -1\n "}, {"sha": "9493f89fec3d2491abc3e62f50c4cb62d5a7df1f", "filename": "gcc/config/gcn/mkoffload.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -117,6 +117,8 @@ uint32_t elf_arch = EF_AMDGPU_MACH_AMDGCN_GFX803;  // Default GPU architecture.\n uint32_t elf_flags =\n     (EF_AMDGPU_FEATURE_XNACK_ANY_V4 | EF_AMDGPU_FEATURE_SRAMECC_ANY_V4);\n \n+static int gcn_stack_size = 0;  /* Zero means use default.  */\n+\n /* Delete tempfiles.  */\n \n void\n@@ -662,6 +664,18 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n     }\n   fprintf (cfile, \"\\n};\\n\\n\");\n \n+  /* Set the stack size if the user configured a value.  */\n+  if (gcn_stack_size)\n+    fprintf (cfile,\n+\t     \"static __attribute__((constructor))\\n\"\n+\t     \"void configure_stack_size (void)\\n\"\n+\t     \"{\\n\"\n+\t     \"  const char *val = getenv (\\\"GCN_STACK_SIZE\\\");\\n\"\n+\t     \"  if (!val || val[0] == '\\\\0')\\n\"\n+\t     \"    setenv (\\\"GCN_STACK_SIZE\\\", \\\"%d\\\", true);\\n\"\n+\t     \"}\\n\\n\",\n+\t     gcn_stack_size);\n+\n   obstack_free (&fns_os, NULL);\n   for (i = 0; i < dims_count; i++)\n     free (dims[i].name);\n@@ -920,6 +934,10 @@ main (int argc, char **argv)\n \telf_arch = EF_AMDGPU_MACH_AMDGCN_GFX908;\n       else if (strcmp (argv[i], \"-march=gfx90a\") == 0)\n \telf_arch = EF_AMDGPU_MACH_AMDGCN_GFX90a;\n+#define STR \"-mstack-size=\"\n+      else if (startswith (argv[i], STR))\n+\tgcn_stack_size = atoi (argv[i] + strlen (STR));\n+#undef STR\n     }\n \n   if (!(fopenacc ^ fopenmp))"}, {"sha": "eff913010091192e5837f16e1dfc54f6711d287d", "filename": "gcc/config/i386/i386-features.cc", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -314,14 +314,12 @@ scalar_chain::~scalar_chain ()\n void\n scalar_chain::add_to_queue (unsigned insn_uid)\n {\n-  if (bitmap_bit_p (insns, insn_uid)\n-      || bitmap_bit_p (queue, insn_uid))\n+  if (!bitmap_set_bit (queue, insn_uid))\n     return;\n \n   if (dump_file)\n     fprintf (dump_file, \"  Adding insn %d into chain's #%d queue\\n\",\n \t     insn_uid, chain_id);\n-  bitmap_set_bit (queue, insn_uid);\n }\n \n /* For DImode conversion, mark register defined by DEF as requiring\n@@ -362,10 +360,9 @@ void\n scalar_chain::analyze_register_chain (bitmap candidates, df_ref ref)\n {\n   df_link *chain;\n+  bool mark_def = false;\n \n-  gcc_assert (bitmap_bit_p (insns, DF_REF_INSN_UID (ref))\n-\t      || bitmap_bit_p (candidates, DF_REF_INSN_UID (ref)));\n-  add_to_queue (DF_REF_INSN_UID (ref));\n+  gcc_checking_assert (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)));\n \n   for (chain = DF_REF_CHAIN (ref); chain; chain = chain->next)\n     {\n@@ -398,24 +395,25 @@ scalar_chain::analyze_register_chain (bitmap candidates, df_ref ref)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  r%d use in insn %d isn't convertible\\n\",\n \t\t     DF_REF_REGNO (chain->ref), uid);\n-\t  mark_dual_mode_def (ref);\n+\t  mark_def = true;\n \t}\n     }\n+\n+  if (mark_def)\n+    mark_dual_mode_def (ref);\n }\n \n /* Add instruction into a chain.  */\n \n void\n scalar_chain::add_insn (bitmap candidates, unsigned int insn_uid)\n {\n-  if (bitmap_bit_p (insns, insn_uid))\n+  if (!bitmap_set_bit (insns, insn_uid))\n     return;\n \n   if (dump_file)\n     fprintf (dump_file, \"  Adding insn %d to chain #%d\\n\", insn_uid, chain_id);\n \n-  bitmap_set_bit (insns, insn_uid);\n-\n   rtx_insn *insn = DF_INSN_UID_GET (insn_uid)->insn;\n   rtx def_set = single_set (insn);\n   if (def_set && REG_P (SET_DEST (def_set))\n@@ -2283,30 +2281,33 @@ convert_scalars_to_vector (bool timode_p)\n       fprintf (dump_file, \"There are no candidates for optimization.\\n\");\n \n   for (unsigned i = 0; i <= 2; ++i)\n-    while (!bitmap_empty_p (&candidates[i]))\n-      {\n-\tunsigned uid = bitmap_first_set_bit (&candidates[i]);\n-\tscalar_chain *chain;\n-\n-\tif (cand_mode[i] == TImode)\n-\t  chain = new timode_scalar_chain;\n-\telse\n-\t  chain = new general_scalar_chain (cand_mode[i], cand_vmode[i]);\n-\n-\t/* Find instructions chain we want to convert to vector mode.\n-\t   Check all uses and definitions to estimate all required\n-\t   conversions.  */\n-\tchain->build (&candidates[i], uid);\n-\n-\tif (chain->compute_convert_gain () > 0)\n-\t  converted_insns += chain->convert ();\n-\telse\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Chain #%d conversion is not profitable\\n\",\n-\t\t     chain->chain_id);\n+    {\n+      bitmap_tree_view (&candidates[i]);\n+      while (!bitmap_empty_p (&candidates[i]))\n+\t{\n+\t  unsigned uid = bitmap_first_set_bit (&candidates[i]);\n+\t  scalar_chain *chain;\n \n-\tdelete chain;\n-      }\n+\t  if (cand_mode[i] == TImode)\n+\t    chain = new timode_scalar_chain;\n+\t  else\n+\t    chain = new general_scalar_chain (cand_mode[i], cand_vmode[i]);\n+\n+\t  /* Find instructions chain we want to convert to vector mode.\n+\t     Check all uses and definitions to estimate all required\n+\t     conversions.  */\n+\t  chain->build (&candidates[i], uid);\n+\n+\t  if (chain->compute_convert_gain () > 0)\n+\t    converted_insns += chain->convert ();\n+\t  else\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"Chain #%d conversion is not profitable\\n\",\n+\t\t       chain->chain_id);\n+\n+\t  delete chain;\n+\t}\n+    }\n \n   if (dump_file)\n     fprintf (dump_file, \"Total insns converted: %d\\n\", converted_insns);"}, {"sha": "22f444be23c8d3a35f0bbe5d80fbb953ffe4116a", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -6876,7 +6876,9 @@ ix86_compute_frame_layout (void)\n \t stack clash protections are enabled and the allocated frame is\n \t larger than the probe interval, then use pushes to save\n \t callee saved registers.  */\n-      || (flag_stack_clash_protection && to_allocate > get_probe_interval ()))\n+      || (flag_stack_clash_protection\n+\t  && !ix86_target_stack_probe ()\n+\t  && to_allocate > get_probe_interval ()))\n     frame->save_regs_using_mov = false;\n \n   if (ix86_using_red_zone ()\n@@ -8761,8 +8763,11 @@ ix86_expand_prologue (void)\n       sse_registers_saved = true;\n     }\n \n-  /* If stack clash protection is requested, then probe the stack.  */\n-  if (allocate >= 0 && flag_stack_clash_protection)\n+  /* If stack clash protection is requested, then probe the stack, unless it\n+     is already probed on the target.  */\n+  if (allocate >= 0\n+      && flag_stack_clash_protection\n+      && !ix86_target_stack_probe ())\n     {\n       ix86_adjust_stack_and_probe (allocate, int_registers_saved, false);\n       allocate = 0;"}, {"sha": "55042e7ae15b635c6d7ce82c1c1d024780ce468c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 155, "deletions": 105, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1459,7 +1459,7 @@\n \t  (match_operand:QI 0 \"nonimmediate_operand\" \"QBc,m\")\n \t  (subreg:QI\n \t    (zero_extract:SWI248\n-\t      (match_operand:SWI248 1 \"register_operand\" \"Q,Q\")\n+\t      (match_operand 1 \"int248_register_operand\" \"Q,Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)))]\n   \"ix86_match_ccmode (insn, CCmode)\"\n@@ -1473,7 +1473,7 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SWI248\n-\t      (match_operand:SWI248 0 \"register_operand\" \"Q\")\n+\t      (match_operand 0 \"int248_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n \t  (match_operand:QI 1 \"const0_operand\")))]\n@@ -1498,7 +1498,7 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SWI248\n-\t      (match_operand:SWI248 0 \"register_operand\" \"Q,Q\")\n+\t      (match_operand 0 \"int248_register_operand\" \"Q,Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n \t  (match_operand:QI 1 \"general_operand\" \"QnBc,m\")))]\n@@ -1513,12 +1513,12 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SWI248\n-\t      (match_operand:SWI248 0 \"register_operand\" \"Q\")\n+\t      (match_operand 0 \"int248_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n \t  (subreg:QI\n \t    (zero_extract:SWI248\n-\t      (match_operand:SWI248 1 \"register_operand\" \"Q\")\n+\t      (match_operand 1 \"int248_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)))]\n   \"ix86_match_ccmode (insn, CCmode)\"\n@@ -3159,7 +3159,7 @@\n \n (define_insn \"*extv<mode>\"\n   [(set (match_operand:SWI24 0 \"register_operand\" \"=R\")\n-\t(sign_extract:SWI24 (match_operand:SWI24 1 \"register_operand\" \"Q\")\n+\t(sign_extract:SWI24 (match_operand 1 \"int248_register_operand\" \"Q\")\n \t\t\t    (const_int 8)\n \t\t\t    (const_int 8)))]\n   \"\"\n@@ -3192,7 +3192,7 @@\n   [(set (match_operand:QI 0 \"norex_memory_operand\" \"=Bn\")\n \t(subreg:QI\n \t  (zero_extract:SWI248\n-\t    (match_operand:SWI248 1 \"register_operand\" \"Q\")\n+\t    (match_operand 1 \"int248_register_operand\" \"Q\")\n \t    (const_int 8)\n \t    (const_int 8)) 0))]\n   \"TARGET_64BIT && reload_completed\"\n@@ -3202,7 +3202,7 @@\n \n (define_insn \"*extzv<mode>\"\n   [(set (match_operand:SWI248 0 \"register_operand\" \"=R\")\n-\t(zero_extract:SWI248 (match_operand:SWI248 1 \"register_operand\" \"Q\")\n+\t(zero_extract:SWI248 (match_operand 1 \"int248_register_operand\" \"Q\")\n \t\t\t     (const_int 8)\n \t\t\t     (const_int 8)))]\n   \"\"\n@@ -3214,7 +3214,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=QBc,?R,m\")\n \t(subreg:QI\n \t  (zero_extract:SWI248\n-\t    (match_operand:SWI248 1 \"register_operand\" \"Q,Q,Q\")\n+\t    (match_operand 1 \"int248_register_operand\" \"Q,Q,Q\")\n \t    (const_int 8)\n \t    (const_int 8)) 0))]\n   \"\"\n@@ -3242,7 +3242,7 @@\n (define_peephole2\n   [(set (match_operand:QI 0 \"register_operand\")\n \t(subreg:QI\n-\t  (zero_extract:SWI248 (match_operand:SWI248 1 \"register_operand\")\n+\t  (zero_extract:SWI248 (match_operand 1 \"int248_register_operand\")\n \t\t\t       (const_int 8)\n \t\t\t       (const_int 8)) 0))\n    (set (match_operand:QI 2 \"norex_memory_operand\") (match_dup 0))]\n@@ -3289,7 +3289,7 @@\n \n (define_insn \"*insvqi_1_mem_rex64\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n@@ -3301,7 +3301,7 @@\n \n (define_insn \"@insv<mode>_1\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(match_operand:SWI248 1 \"general_operand\" \"QnBc,m\"))]\n@@ -3317,7 +3317,7 @@\n \n (define_insn \"*insvqi_1\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n@@ -3331,7 +3331,7 @@\n (define_peephole2\n   [(set (match_operand:QI 0 \"register_operand\")\n \t(match_operand:QI 1 \"norex_memory_operand\"))\n-   (set (zero_extract:SWI248 (match_operand:SWI248 2 \"register_operand\")\n+   (set (zero_extract:SWI248 (match_operand 2 \"int248_register_operand\")\n \t\t\t     (const_int 8)\n \t\t\t     (const_int 8))\n \t(subreg:SWI248 (match_dup 0) 0))]\n@@ -3347,7 +3347,7 @@\n   [(parallel [(set (match_operand:SWI48 0 \"general_reg_operand\")\n \t\t   (const_int 0))\n \t      (clobber (reg:CC FLAGS_REG))])\n-   (set (zero_extract:SWI248 (match_operand:SWI248 1 \"general_reg_operand\")\n+   (set (zero_extract:SWI248 (match_operand 1 \"int248_register_operand\")\n \t\t\t     (const_int 8)\n \t\t\t     (const_int 8))\n \t(const_int 0))]\n@@ -3360,7 +3360,7 @@\n (define_peephole2\n   [(set (match_operand:SWI48 0 \"general_reg_operand\")\n \t(match_operand:SWI48 1 \"const_int_operand\"))\n-   (set (zero_extract:SWI248 (match_operand:SWI248 2 \"general_reg_operand\")\n+   (set (zero_extract:SWI248 (match_operand 2 \"int248_register_operand\")\n \t\t\t     (const_int 8)\n \t\t\t     (const_int 8))\n \t(match_operand:SWI248 3 \"const_int_operand\"))]\n@@ -3378,11 +3378,11 @@\n \n (define_insn \"*insvqi_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(any_extract:SWI248\n-\t  (match_operand:SWI248 1 \"register_operand\" \"Q\")\n+\t  (match_operand 1 \"int248_register_operand\" \"Q\")\n \t  (const_int 8)\n \t  (const_int 8)))]\n   \"\"\n@@ -3392,7 +3392,7 @@\n \n (define_insn \"*insvqi_3\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(any_shiftrt:SWI248\n@@ -4777,6 +4777,19 @@\n      (if_then_else (eq_attr \"prefix_0f\" \"0\")\n \t(const_string \"0\")\n \t(const_string \"1\")))])\n+\n+(define_insn \"*extendqi<SWI24:mode>_ext_1\"\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"=R\")\n+\t(sign_extend:SWI24\n+\t  (subreg:QI\n+\t    (zero_extract:SWI248\n+\t      (match_operand 1 \"int248_register_operand\" \"Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)))]\n+  \"\"\n+  \"movs{b<SWI24:imodesuffix>|x}\\t{%h1, %0|%0, %h1}\"\n+   [(set_attr \"type\" \"imovx\")\n+    (set_attr \"mode\" \"<SWI24:MODE>\")])\n \f\n ;; Conversions between float and double.\n \n@@ -6628,6 +6641,22 @@\n \t(const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*addqi_ext<mode>_0\"\n+  [(set (match_operand:QI 0 \"nonimm_x64constmem_operand\" \"=QBc,m\")\n+\t(plus:QI\n+\t  (subreg:QI\n+\t    (zero_extract:SWI248\n+\t      (match_operand 2 \"int248_register_operand\" \"Q,Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)\n+\t  (match_operand:QI 1 \"nonimm_x64constmem_operand\" \"0,0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"add{b}\\t{%h2, %0|%0, %h2}\"\n+  [(set_attr \"isa\" \"*,nox64\")\n+   (set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_expand \"addqi_ext_1\"\n   [(parallel\n      [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\")\n@@ -6644,14 +6673,14 @@\n \n (define_insn \"*addqi_ext<mode>_1\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (plus:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0,0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0,0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_operand\" \"QnBc,m\")) 0))\n@@ -6683,19 +6712,19 @@\n \n (define_insn \"*addqi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (plus:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"%0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"%0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 2 \"register_operand\" \"Q\")\n+\t        (match_operand 2 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)) 0))\n   (clobber (reg:CC FLAGS_REG))]\n@@ -7252,21 +7281,37 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*subqi_ext<mode>_0\"\n+  [(set (match_operand:QI 0 \"nonimm_x64constmem_operand\" \"=QBc,m\")\n+\t(minus:QI\n+\t  (match_operand:QI 1 \"nonimm_x64constmem_operand\" \"0,0\")\n+\t  (subreg:QI\n+\t    (zero_extract:SWI248\n+\t      (match_operand 2 \"int248_register_operand\" \"Q,Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"sub{b}\\t{%h2, %0|%0, %h2}\"\n+  [(set_attr \"isa\" \"*,nox64\")\n+   (set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"*subqi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (minus:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 2 \"register_operand\" \"Q\")\n+\t        (match_operand 2 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)) 0))\n   (clobber (reg:CC FLAGS_REG))]\n@@ -9853,7 +9898,7 @@\n \t  (and:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 0 \"register_operand\" \"Q,Q\")\n+\t        (match_operand 0 \"int248_register_operand\" \"Q,Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 1 \"general_operand\" \"QnBc,m\"))\n@@ -9870,12 +9915,12 @@\n \t  (and:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 0 \"register_operand\" \"Q\")\n+\t        (match_operand 0 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"Q\")\n+\t        (match_operand 1 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0))\n \t  (const_int 0)))]\n@@ -10073,13 +10118,13 @@\n \t(match_op_dup 1\n \t  [(and:QI\n \t     (subreg:QI\n-\t       (zero_extract:SI (match_dup 2)\n+\t       (zero_extract:HI (match_dup 2)\n \t\t\t\t(const_int 8)\n \t\t\t\t(const_int 8)) 0)\n \t     (match_dup 3))\n \t   (const_int 0)]))]\n {\n-  operands[2] = gen_lowpart (SImode, operands[2]);\n+  operands[2] = gen_lowpart (HImode, operands[2]);\n   operands[3] = gen_int_mode (INTVAL (operands[3]) >> 8, QImode);\n })\n \n@@ -10404,21 +10449,21 @@\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && reload_completed\"\n   [(parallel\n-     [(set (zero_extract:SI (match_dup 0)\n+     [(set (zero_extract:HI (match_dup 0)\n \t\t\t    (const_int 8)\n \t\t\t    (const_int 8))\n-\t   (subreg:SI\n+\t   (subreg:HI\n \t     (xor:QI\n \t       (subreg:QI\n-\t\t (zero_extract:SI (match_dup 0)\n+\t\t (zero_extract:HI (match_dup 0)\n \t\t\t\t  (const_int 8)\n \t\t\t\t  (const_int 8)) 0)\n \t       (subreg:QI\n-\t\t (zero_extract:SI (match_dup 0)\n+\t\t (zero_extract:HI (match_dup 0)\n \t\t\t\t  (const_int 8)\n \t\t\t\t  (const_int 8)) 0)) 0))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\")\n+  \"operands[0] = gen_lowpart (HImode, operands[0]);\")\n \n (define_insn \"*anddi_2\"\n   [(set (reg FLAGS_REG)\n@@ -10515,6 +10560,22 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*andqi_ext<mode>_0\"\n+  [(set (match_operand:QI 0 \"nonimm_x64constmem_operand\" \"=QBc,m\")\n+\t(and:QI\n+\t  (subreg:QI\n+\t    (zero_extract:SWI248\n+\t      (match_operand 2 \"int248_register_operand\" \"Q,Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)\n+\t  (match_operand:QI 1 \"nonimm_x64constmem_operand\" \"0,0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"and{b}\\t{%h2, %0|%0, %h2}\"\n+  [(set_attr \"isa\" \"*,nox64\")\n+   (set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_expand \"andqi_ext_1\"\n   [(parallel\n      [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\")\n@@ -10531,14 +10592,14 @@\n \n (define_insn \"*andqi_ext<mode>_1\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (and:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0,0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0,0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_operand\" \"QnBc,m\")) 0))\n@@ -10558,13 +10619,13 @@\n \t  (and:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0,0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0,0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_operand\" \"QnBc,m\"))\n \t  (const_int 0)))\n    (set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n@@ -10585,19 +10646,19 @@\n \n (define_insn \"*andqi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (and:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"%0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"%0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 2 \"register_operand\" \"Q\")\n+\t        (match_operand 2 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)) 0))\n    (clobber (reg:CC FLAGS_REG))]\n@@ -10622,20 +10683,20 @@\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(~INTVAL (operands[2]) & ~(255 << 8))\"\n   [(parallel\n-     [(set (zero_extract:SI (match_dup 0)\n+     [(set (zero_extract:HI (match_dup 0)\n \t\t\t    (const_int 8)\n \t\t\t    (const_int 8))\n-\t   (subreg:SI\n+\t   (subreg:HI\n \t     (and:QI\n \t       (subreg:QI\n-\t\t (zero_extract:SI (match_dup 1)\n+\t\t (zero_extract:HI (match_dup 1)\n \t\t\t\t  (const_int 8)\n \t\t\t\t  (const_int 8)) 0)\n \t       (match_dup 2)) 0))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[0] = gen_lowpart (HImode, operands[0]);\n+  operands[1] = gen_lowpart (HImode, operands[1]);\n   operands[2] = gen_int_mode (INTVAL (operands[2]) >> 8, QImode);\n })\n \n@@ -11256,16 +11317,32 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*<code>qi_ext<mode>_0\"\n+  [(set (match_operand:QI 0 \"nonimm_x64constmem_operand\" \"=QBc,m\")\n+\t(any_or:QI\n+\t  (subreg:QI\n+\t    (zero_extract:SWI248\n+\t      (match_operand 2 \"int248_register_operand\" \"Q,Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)\n+\t  (match_operand:QI 1 \"nonimm_x64constmem_operand\" \"0,0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"<logic>{b}\\t{%h2, %0|%0, %h2}\"\n+  [(set_attr \"isa\" \"*,nox64\")\n+   (set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"*<code>qi_ext<mode>_1\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (any_or:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0,0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0,0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_operand\" \"QnBc,m\")) 0))\n@@ -11280,19 +11357,19 @@\n \n (define_insn \"*<code>qi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (any_or:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"%0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"%0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 2 \"register_operand\" \"Q\")\n+\t        (match_operand 2 \"int248_register_operand\" \"Q\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)) 0))\n    (clobber (reg:CC FLAGS_REG))]\n@@ -11318,13 +11395,13 @@\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(INTVAL (operands[2]) & ~(255 << 8))\"\n   [(parallel\n-     [(set (zero_extract:SI (match_dup 0)\n+     [(set (zero_extract:HI (match_dup 0)\n \t\t\t    (const_int 8)\n \t\t\t    (const_int 8))\n-\t   (subreg:SI\n+\t   (subreg:HI\n \t     (any_or:QI\n \t       (subreg:QI\n-\t\t (zero_extract:SI (match_dup 1)\n+\t\t (zero_extract:HI (match_dup 1)\n \t\t\t\t  (const_int 8)\n \t\t\t\t  (const_int 8)) 0)\n \t       (match_dup 2)) 0))\n@@ -11339,8 +11416,8 @@\n \temit_note (NOTE_INSN_DELETED);\n       DONE;\n     }\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[0] = gen_lowpart (HImode, operands[0]);\n+  operands[1] = gen_lowpart (HImode, operands[1]);\n   operands[2] = gen_int_mode (INTVAL (operands[2]) >> 8, QImode);\n })\n \n@@ -11393,13 +11470,13 @@\n \t  (xor:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0,0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0,0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_operand\" \"QnBc,m\"))\n \t  (const_int 0)))\n    (set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q,Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q,Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n@@ -11796,14 +11873,14 @@\n \n (define_insn \"*negqi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (neg:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)) 0))\n    (clobber (reg:CC FLAGS_REG))]\n@@ -12436,15 +12513,12 @@\n \t  (match_operand:<DWI> 1 \"register_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 2 \"int248_register_operand\" \"c\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n     || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n \t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -12831,15 +12905,12 @@\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\" \"c,r\")\n+\t      (match_operand 2 \"int248_register_operand\" \"c,r\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -13363,14 +13434,14 @@\n \n (define_insn \"*ashlqi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (ashift:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"nonmemory_operand\" \"cI\")) 0))\n@@ -13425,15 +13496,12 @@\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\" \"c,r\")\n+\t      (match_operand 2 \"int248_register_operand\" \"c,r\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -13476,15 +13544,12 @@\n \t  (match_operand:<DWI> 1 \"register_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 2 \"int248_register_operand\" \"c\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n     || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n \t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -14272,14 +14337,14 @@\n \n (define_insn \"*<insn>qi_ext<mode>_2\"\n   [(set (zero_extract:SWI248\n-\t  (match_operand:SWI248 0 \"register_operand\" \"+Q\")\n+\t  (match_operand 0 \"int248_register_operand\" \"+Q\")\n \t  (const_int 8)\n \t  (const_int 8))\n \t(subreg:SWI248\n \t  (any_shiftrt:QI\n \t    (subreg:QI\n \t      (zero_extract:SWI248\n-\t        (match_operand:SWI248 1 \"register_operand\" \"0\")\n+\t        (match_operand 1 \"int248_register_operand\" \"0\")\n \t\t(const_int 8)\n \t\t(const_int 8)) 0)\n \t    (match_operand:QI 2 \"nonmemory_operand\" \"cI\")) 0))\n@@ -14371,15 +14436,12 @@\n \t  (match_operand:SWI 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 2 \"int248_register_operand\" \"c\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -14399,13 +14461,10 @@\n \t  (match_operand:SWI 1 \"const_int_operand\")\n \t  (subreg:QI\n \t    (and\n-\t      (match_operand 2 \"register_operand\")\n+\t      (match_operand 2 \"int248_register_operand\")\n \t      (match_operand 3 \"const_int_operand\")) 0)))]\n  \"(INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode) - 1))\n-   == GET_MODE_BITSIZE (<MODE>mode) - 1\n-  && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-  && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t       4 << (TARGET_64BIT ? 1 : 0))\"\n+   == GET_MODE_BITSIZE (<MODE>mode) - 1\"\n  [(set (match_dup 4) (match_dup 1))\n   (set (match_dup 0)\n        (any_rotate:SWI (match_dup 4)\n@@ -14806,16 +14865,13 @@\n \t    (const_int 1)\n \t    (subreg:QI\n \t      (and\n-\t\t(match_operand 1 \"register_operand\")\n+\t\t(match_operand 1 \"int248_register_operand\")\n \t\t(match_operand 2 \"const_int_operand\")) 0))\n \t  (match_operand:SWI48 3 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_USE_BT\n    && (INTVAL (operands[2]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[1])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -14877,16 +14933,13 @@\n \t    (const_int -2)\n \t    (subreg:QI\n \t      (and\n-\t\t(match_operand 1 \"register_operand\")\n+\t\t(match_operand 1 \"int248_register_operand\")\n \t\t(match_operand 2 \"const_int_operand\")) 0))\n \t  (match_operand:SWI48 3 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_USE_BT\n    && (INTVAL (operands[2]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[1])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -15260,17 +15313,14 @@\n \t\t\t   (zero_extend:SI\n \t\t\t     (subreg:QI\n \t\t\t       (and\n-\t\t\t\t (match_operand 2 \"register_operand\")\n+\t\t\t\t (match_operand 2 \"int248_register_operand\")\n \t\t\t\t (match_operand 3 \"const_int_operand\")) 0)))])\n \t\t      (label_ref (match_operand 4))\n \t\t      (pc)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(TARGET_USE_BT || optimize_function_for_size_p (cfun))\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n-   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n-   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n-\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -23149,7 +23199,7 @@\n \t(match_operator 1 \"compare_operator\"\n \t  [(and:QI\n \t     (subreg:QI\n-\t       (zero_extract:SWI248 (match_operand:SWI248 2 \"QIreg_operand\")\n+\t       (zero_extract:SWI248 (match_operand 2 \"int248_register_operand\")\n \t\t\t\t    (const_int 8)\n \t\t\t\t    (const_int 8)) 0)\n \t     (match_operand 3 \"const_int_operand\"))"}, {"sha": "7b3db0cc851a8a96736c4556c2af2f403e3d910b", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -92,6 +92,14 @@\n   (and (match_code \"reg\")\n        (match_test \"MASK_REGNO_P (REGNO (op))\")))\n \n+;; Match a DI, SI or HImode register operand.\n+(define_special_predicate \"int248_register_operand\"\n+  (and (match_operand 0 \"register_operand\")\n+       (ior (and (match_test \"TARGET_64BIT\")\n+\t\t (match_test \"GET_MODE (op) == DImode\"))\n+\t    (match_test \"GET_MODE (op) == SImode\")\n+\t    (match_test \"GET_MODE (op) == HImode\"))))\n+\n ;; Match a DI, SI, HI or QImode nonimmediate_operand.\n (define_special_predicate \"int_nonimmediate_operand\"\n   (and (match_operand 0 \"nonimmediate_operand\")\n@@ -101,6 +109,13 @@\n \t    (match_test \"GET_MODE (op) == HImode\")\n \t    (match_test \"GET_MODE (op) == QImode\"))))\n \n+;; Match nonimmediate operand, but exclude non-constant addresses for x86_64.\n+(define_predicate \"nonimm_x64constmem_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_operand 0 \"memory_operand\")\n+\t    (ior (not (match_test \"TARGET_64BIT\"))\n+\t\t (match_test \"constant_address_p (XEXP (op, 0))\")))))\n+\n ;; Match register operands, but include memory operands for TARGET_SSE_MATH.\n (define_predicate \"register_ssemem_operand\"\n   (if_then_else"}, {"sha": "3054656a12c27e8cc7673be1c84af41548fb6e2c", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -551,7 +551,7 @@ DEF_TUNE (X86_TUNE_AVX128_OPTIMAL, \"avx128_optimal\", m_BDVER | m_BTVER2\n \n /* X86_TUNE_AVX256_OPTIMAL: Use 256-bit AVX instructions instead of 512-bit AVX\n    instructions in the auto-vectorizer.  */\n-DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512 | m_ZNVER4)\n+DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512)\n \n /* X86_TUNE_AVX256_SPLIT_REGS: if true, AVX512 ops are split into two AVX256 ops.  */\n DEF_TUNE (X86_TUNE_AVX512_SPLIT_REGS, \"avx512_split_regs\", m_ZNVER4)"}, {"sha": "3509c3c21c175db4964577be2be0dd94d3b0debb", "filename": "gcc/config/loongarch/loongarch.md", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Floongarch%2Floongarch.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Floongarch%2Floongarch.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -48,8 +48,6 @@\n   UNSPEC_EH_RETURN\n \n   ;; Bit operation\n-  UNSPEC_BYTEPICK_W\n-  UNSPEC_BYTEPICK_D\n   UNSPEC_BITREV_4B\n   UNSPEC_BITREV_8B\n \n@@ -544,6 +542,27 @@\n \t\t\t\t      (UNSPEC_FTINTRM \"0\")\n \t\t\t\t      (UNSPEC_FTINTRP \"0\")])\n \n+;; Iterator and attributes for bytepick.d\n+(define_int_iterator bytepick_w_ashift_amount [8 16 24])\n+(define_int_attr bytepick_w_lshiftrt_amount [(8 \"24\")\n+\t\t\t\t\t     (16 \"16\")\n+\t\t\t\t\t     (24 \"8\")])\n+(define_int_iterator bytepick_d_ashift_amount [8 16 24 32 40 48 56])\n+(define_int_attr bytepick_d_lshiftrt_amount [(8 \"56\")\n+\t\t\t\t\t     (16 \"48\")\n+\t\t\t\t\t     (24 \"40\")\n+\t\t\t\t\t     (32 \"32\")\n+\t\t\t\t\t     (40 \"24\")\n+\t\t\t\t\t     (48 \"16\")\n+\t\t\t\t\t     (56 \"8\")])\n+(define_int_attr bytepick_imm [(8 \"1\")\n+\t\t\t\t (16 \"2\")\n+\t\t\t\t (24 \"3\")\n+\t\t\t\t (32 \"4\")\n+\t\t\t\t (40 \"5\")\n+\t\t\t\t (48 \"6\")\n+\t\t\t\t (56 \"7\")])\n+\n ;;\n ;;  ....................\n ;;\n@@ -3364,24 +3383,35 @@\n   [(set_attr \"type\" \"unknown\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"bytepick_w\"\n+(define_insn \"bytepick_w_<bytepick_imm>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 3 \"const_0_to_3_operand\" \"n\")]\n-\t\t    UNSPEC_BYTEPICK_W))]\n+\t(ior:SI (lshiftrt (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int <bytepick_w_lshiftrt_amount>))\n+\t\t(ashift (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t(const_int bytepick_w_ashift_amount))))]\n   \"\"\n-  \"bytepick.w\\t%0,%1,%2,%z3\"\n+  \"bytepick.w\\t%0,%1,%2,<bytepick_imm>\"\n   [(set_attr \"mode\" \"SI\")])\n \n-(define_insn \"bytepick_d\"\n+(define_insn \"bytepick_w_<bytepick_imm>_extend\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t    (match_operand:DI 2 \"register_operand\" \"r\")\n-\t\t    (match_operand:DI 3 \"const_0_to_7_operand\" \"n\")]\n-\t\t    UNSPEC_BYTEPICK_D))]\n-  \"\"\n-  \"bytepick.d\\t%0,%1,%2,%z3\"\n+\t(sign_extend:DI\n+\t  (ior:SI (lshiftrt (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (const_int <bytepick_w_lshiftrt_amount>))\n+\t\t  (ashift (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int bytepick_w_ashift_amount)))))]\n+  \"TARGET_64BIT\"\n+  \"bytepick.w\\t%0,%1,%2,<bytepick_imm>\"\n+  [(set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"bytepick_d_<bytepick_imm>\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (lshiftrt (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int <bytepick_d_lshiftrt_amount>))\n+\t\t(ashift (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t(const_int bytepick_d_ashift_amount))))]\n+  \"TARGET_64BIT\"\n+  \"bytepick.d\\t%0,%1,%2,<bytepick_imm>\"\n   [(set_attr \"mode\" \"DI\")])\n \n (define_insn \"bitrev_4b\""}, {"sha": "95140280f1e648d2589733d0b00f74cb6a82841b", "filename": "gcc/config/loongarch/predicates.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fpredicates.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -91,14 +91,6 @@\n   (ior (match_operand 0 \"const_1_operand\")\n        (match_operand 0 \"register_operand\")))\n \n-(define_predicate \"const_0_to_3_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op), 0, 3)\")))\n-\n-(define_predicate \"const_0_to_7_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n-\n (define_predicate \"lu52i_mask_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"UINTVAL (op) == 0xfffffffffffff\")))"}, {"sha": "a051d466ae2793ab5c70eb9f70e24d59262d71a5", "filename": "gcc/config/riscv/constraints.md", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fconstraints.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -140,6 +140,16 @@\n   (and (match_code \"const_vector\")\n        (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, -16, 15)\")))\n \n+(define_constraint \"vj\"\n+  \"A vector negated 5-bit signed immediate.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, -15, 16)\")))\n+\n+(define_constraint \"vk\"\n+  \"A vector 5-bit unsigned immediate.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, 0, 31)\")))\n+\n (define_constraint \"Wc0\"\n   \"@internal\n  A constraint that matches a vector of immediate all zeros.\"\n@@ -152,7 +162,7 @@\n  (and (match_code \"const_vector\")\n       (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n-(define_constraint \"Wdm\"\n+(define_memory_constraint \"Wdm\"\n   \"Vector duplicate memory operand\"\n-  (and (match_operand 0 \"memory_operand\")\n+  (and (match_code \"mem\")\n        (match_code \"reg\" \"0\")))"}, {"sha": "f95dd405e12715f4bb02d5e7e07b96cd0187a332", "filename": "gcc/config/riscv/iterators.md", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fiterators.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -196,7 +196,20 @@\n \t\t\t (xor \"xor\")\n \t\t\t (and \"and\")\n \t\t\t (plus \"add\")\n-\t\t\t (minus \"sub\")])\n+\t\t\t (minus \"sub\")\n+\t\t\t (smin \"smin\")\n+\t\t\t (smax \"smax\")\n+\t\t\t (umin \"umin\")\n+\t\t\t (umax \"umax\")\n+\t\t\t (mult \"mul\")\n+\t\t\t (not \"one_cmpl\")\n+\t\t\t (neg \"neg\")\n+\t\t\t (ss_plus \"ssadd\")\n+\t\t\t (us_plus \"usadd\")\n+\t\t\t (ss_minus \"sssub\")\n+\t\t\t (us_minus \"ussub\")\n+\t\t\t (sign_extend \"extend\")\n+\t\t\t (zero_extend \"zero_extend\")])\n \n ;; <or_optab> code attributes\n (define_code_attr or_optab [(ior \"ior\")\n@@ -214,7 +227,18 @@\n \t\t\t(xor \"xor\")\n \t\t\t(and \"and\")\n \t\t\t(plus \"add\")\n-\t\t\t(minus \"sub\")])\n+\t\t\t(minus \"sub\")\n+\t\t\t(smin \"min\")\n+\t\t\t(smax \"max\")\n+\t\t\t(umin \"minu\")\n+\t\t\t(umax \"maxu\")\n+\t\t\t(mult \"mul\")\n+\t\t\t(not \"not\")\n+\t\t\t(neg \"neg\")\n+\t\t\t(ss_plus \"sadd\")\n+\t\t\t(us_plus \"saddu\")\n+\t\t\t(ss_minus \"ssub\")\n+\t\t\t(us_minus \"ssubu\")])\n \n ; atomics code attribute\n (define_code_attr atomic_optab"}, {"sha": "7bc7c0b4f4d7a3de5cb6eafd1f8ee916dee14bef", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -272,28 +272,78 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"memory_operand\")))\n \n+(define_predicate \"reg_or_int_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_int_operand\")))\n+\n (define_predicate \"vector_move_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")\n-       (match_code \"const_vector\")))\n+       (and (match_code \"const_vector\")\n+            (match_test \"reload_completed\n+\t\t|| satisfies_constraint_vi (op)\n+\t\t|| satisfies_constraint_Wc0 (op)\"))))\n \n-(define_predicate \"vector_mask_operand\"\n+(define_predicate \"vector_all_trues_mask_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n+(define_predicate \"vector_mask_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"vector_all_trues_mask_operand\")))\n+\n+(define_predicate \"vector_undef_operand\"\n+  (match_test \"rtx_equal_p (op, RVV_VUNDEF (GET_MODE (op)))\"))\n+\n (define_predicate \"vector_merge_operand\"\n-  (ior (match_operand 0 \"memory_operand\")\n-       (ior (match_operand 0 \"register_operand\")\n-\t    (match_test \"GET_CODE (op) == UNSPEC\n-\t\t\t && (XINT (op, 1) == UNSPEC_VUNDEF)\"))))\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"vector_undef_operand\")))\n+\n+(define_predicate \"vector_arith_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+            (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, -16, 15)\"))))\n+\n+(define_predicate \"vector_neg_arith_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+            (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, -15, 16)\"))))\n+\n+(define_predicate \"vector_shift_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+            (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, 0, 31)\"))))\n+\n+(define_predicate \"ltge_operator\"\n+  (match_code \"lt,ltu,ge,geu\"))\n+\n+(define_predicate \"comparison_except_ltge_operator\"\n+  (match_code \"eq,ne,le,leu,gt,gtu\"))\n+\n+(define_predicate \"comparison_except_eqge_operator\"\n+  (match_code \"le,leu,gt,gtu,lt,ltu\"))\n+\n+(define_predicate \"ge_operator\"\n+  (match_code \"ge,geu\"))\n+\n+;; pmode_reg_or_uimm5_operand can be used by vsll.vx/vsrl.vx/vsra.vx instructions.\n+;; Since it has the same predicate with vector_length_operand which allows register\n+;; or immediate (0 ~ 31), we define this predicate same as vector_length_operand here.\n+;; We don't use vector_length_operand directly to predicate vsll.vx/vsrl.vx/vsra.vx\n+;; since it may be confusing.\n+(define_special_predicate \"pmode_reg_or_uimm5_operand\"\n+  (match_operand 0 \"vector_length_operand\"))\n \n (define_special_predicate \"pmode_reg_or_0_operand\"\n   (ior (match_operand 0 \"const_0_operand\")\n        (match_operand 0 \"pmode_register_operand\")))\n \n ;; The scalar operand can be directly broadcast by RVV instructions.\n (define_predicate \"direct_broadcast_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (match_test \"satisfies_constraint_Wdm (op)\")))\n+  (and (match_test \"!(reload_completed && !FLOAT_MODE_P (GET_MODE (op))\n+\t\t&& register_operand (op, GET_MODE (op))\n+\t\t&& maybe_gt (GET_MODE_BITSIZE (GET_MODE (op)), GET_MODE_BITSIZE (Pmode)))\")\n+    (ior (match_operand 0 \"register_operand\")\n+         (match_test \"satisfies_constraint_Wdm (op)\"))))\n \n ;; A CONST_INT operand that has exactly two bits cleared.\n (define_predicate \"const_nottwobits_operand\""}, {"sha": "37c634eca1d594b9ac47a1673457bd06139f1b56", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -115,12 +115,14 @@ extern const riscv_cpu_info *riscv_find_cpu (const char *);\n /* Routines implemented in riscv-selftests.cc.  */\n #if CHECKING_P\n namespace selftest {\n-extern void riscv_run_selftests (void);\n+void riscv_run_selftests (void);\n } // namespace selftest\n #endif\n \n namespace riscv_vector {\n #define RVV_VLMAX gen_rtx_REG (Pmode, X0_REGNUM)\n+#define RVV_VUNDEF(MODE)                                                       \\\n+  gen_rtx_UNSPEC (MODE, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF)\n enum vlmul_type\n {\n   LMUL_1 = 0,\n@@ -139,23 +141,24 @@ enum avl_type\n   VLMAX,\n };\n /* Routines implemented in riscv-vector-builtins.cc.  */\n-extern void init_builtins (void);\n-extern const char *mangle_builtin_type (const_tree);\n+void init_builtins (void);\n+const char *mangle_builtin_type (const_tree);\n #ifdef GCC_TARGET_H\n-extern bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n+bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n #endif\n-extern void handle_pragma_vector (void);\n-extern tree builtin_decl (unsigned, bool);\n-extern rtx expand_builtin (unsigned int, tree, rtx);\n-extern bool const_vec_all_same_in_range_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n-extern bool legitimize_move (rtx, rtx, machine_mode);\n-extern void emit_pred_op (unsigned, rtx, rtx, machine_mode);\n-extern enum vlmul_type get_vlmul (machine_mode);\n-extern unsigned int get_ratio (machine_mode);\n-extern int get_ta (rtx);\n-extern int get_ma (rtx);\n-extern int get_avl_type (rtx);\n-extern unsigned int calculate_ratio (unsigned int, enum vlmul_type);\n+void handle_pragma_vector (void);\n+tree builtin_decl (unsigned, bool);\n+rtx expand_builtin (unsigned int, tree, rtx);\n+bool const_vec_all_same_in_range_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+bool legitimize_move (rtx, rtx, machine_mode);\n+void emit_vlmax_op (unsigned, rtx, rtx, machine_mode);\n+void emit_nonvlmax_op (unsigned, rtx, rtx, rtx, machine_mode);\n+enum vlmul_type get_vlmul (machine_mode);\n+unsigned int get_ratio (machine_mode);\n+int get_ta (rtx);\n+int get_ma (rtx);\n+int get_avl_type (rtx);\n+unsigned int calculate_ratio (unsigned int, enum vlmul_type);\n enum tail_policy\n {\n   TAIL_UNDISTURBED = 0,\n@@ -173,6 +176,13 @@ enum tail_policy get_prefer_tail_policy ();\n enum mask_policy get_prefer_mask_policy ();\n rtx get_avl_type_rtx (enum avl_type);\n opt_machine_mode get_vector_mode (scalar_mode, poly_uint64);\n+bool simm5_p (rtx);\n+bool neg_simm5_p (rtx);\n+#ifdef RTX_CODE\n+bool has_vi_variant_p (rtx_code, rtx);\n+#endif\n+bool sew64_scalar_helper (rtx *, rtx *, rtx, machine_mode, machine_mode,\n+\t\t\t  bool, void (*)(rtx *, rtx));\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "59c25c65cd521c74318e36739d1921754f0b4a40", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 130, "deletions": 17, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -67,9 +67,7 @@ template <int MAX_OPERANDS> class insn_expander\n   }\n   void add_vundef_operand (machine_mode mode)\n   {\n-    add_input_operand (gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx),\n-\t\t\t\t       UNSPEC_VUNDEF),\n-\t\t       mode);\n+    add_input_operand (RVV_VUNDEF (mode), mode);\n   }\n   void add_policy_operand (enum tail_policy vta, enum mask_policy vma)\n   {\n@@ -78,9 +76,9 @@ template <int MAX_OPERANDS> class insn_expander\n     add_input_operand (tail_policy_rtx, Pmode);\n     add_input_operand (mask_policy_rtx, Pmode);\n   }\n-  void add_avl_type_operand ()\n+  void add_avl_type_operand (avl_type type)\n   {\n-    add_input_operand (get_avl_type_rtx (avl_type::VLMAX), Pmode);\n+    add_input_operand (gen_int_mode (type, Pmode), Pmode);\n   }\n \n   void expand (enum insn_code icode, bool temporary_volatile_p = false)\n@@ -165,29 +163,56 @@ calculate_ratio (unsigned int sew, enum vlmul_type vlmul)\n }\n \n /* Emit an RVV unmask && vl mov from SRC to DEST.  */\n-void\n-emit_pred_op (unsigned icode, rtx dest, rtx src, machine_mode mask_mode)\n+static void\n+emit_pred_op (unsigned icode, rtx mask, rtx dest, rtx src, rtx len,\n+\t      machine_mode mask_mode)\n {\n   insn_expander<8> e;\n   machine_mode mode = GET_MODE (dest);\n \n   e.add_output_operand (dest, mode);\n-  e.add_all_one_mask_operand (mask_mode);\n+\n+  if (mask)\n+    e.add_input_operand (mask, GET_MODE (mask));\n+  else\n+    e.add_all_one_mask_operand (mask_mode);\n+\n   e.add_vundef_operand (mode);\n \n   e.add_input_operand (src, GET_MODE (src));\n \n-  rtx vlmax = emit_vlmax_vsetvl (mode);\n-  e.add_input_operand (vlmax, Pmode);\n+  if (len)\n+    e.add_input_operand (len, Pmode);\n+  else\n+    {\n+      rtx vlmax = emit_vlmax_vsetvl (mode);\n+      e.add_input_operand (vlmax, Pmode);\n+    }\n \n   if (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n     e.add_policy_operand (get_prefer_tail_policy (), get_prefer_mask_policy ());\n \n-  e.add_avl_type_operand ();\n+  if (len)\n+    e.add_avl_type_operand (avl_type::NONVLMAX);\n+  else\n+    e.add_avl_type_operand (avl_type::VLMAX);\n \n   e.expand ((enum insn_code) icode, MEM_P (dest) || MEM_P (src));\n }\n \n+void\n+emit_vlmax_op (unsigned icode, rtx dest, rtx src, machine_mode mask_mode)\n+{\n+  emit_pred_op (icode, NULL_RTX, dest, src, NULL_RTX, mask_mode);\n+}\n+\n+void\n+emit_nonvlmax_op (unsigned icode, rtx dest, rtx src, rtx len,\n+\t\t  machine_mode mask_mode)\n+{\n+  emit_pred_op (icode, NULL_RTX, dest, src, len, mask_mode);\n+}\n+\n static void\n expand_const_vector (rtx target, rtx src, machine_mode mask_mode)\n {\n@@ -199,7 +224,7 @@ expand_const_vector (rtx target, rtx src, machine_mode mask_mode)\n       gcc_assert (\n \tconst_vec_duplicate_p (src, &elt)\n \t&& (rtx_equal_p (elt, const0_rtx) || rtx_equal_p (elt, const1_rtx)));\n-      emit_pred_op (code_for_pred_mov (mode), target, src, mode);\n+      emit_vlmax_op (code_for_pred_mov (mode), target, src, mask_mode);\n       return;\n     }\n \n@@ -210,10 +235,10 @@ expand_const_vector (rtx target, rtx src, machine_mode mask_mode)\n       /* Element in range -16 ~ 15 integer or 0.0 floating-point,\n \t we use vmv.v.i instruction.  */\n       if (satisfies_constraint_vi (src) || satisfies_constraint_Wc0 (src))\n-\temit_pred_op (code_for_pred_mov (mode), tmp, src, mask_mode);\n+\temit_vlmax_op (code_for_pred_mov (mode), tmp, src, mask_mode);\n       else\n-\temit_pred_op (code_for_pred_broadcast (mode), tmp,\n-\t\t      force_reg (elt_mode, elt), mask_mode);\n+\temit_vlmax_op (code_for_pred_broadcast (mode), tmp,\n+\t\t       force_reg (elt_mode, elt), mask_mode);\n \n       if (tmp != target)\n \temit_move_insn (target, tmp);\n@@ -252,12 +277,12 @@ legitimize_move (rtx dest, rtx src, machine_mode mask_mode)\n     {\n       rtx tmp = gen_reg_rtx (mode);\n       if (MEM_P (src))\n-\temit_pred_op (code_for_pred_mov (mode), tmp, src, mask_mode);\n+\temit_vlmax_op (code_for_pred_mov (mode), tmp, src, mask_mode);\n       else\n \temit_move_insn (tmp, src);\n       src = tmp;\n     }\n-  emit_pred_op (code_for_pred_mov (mode), dest, src, mask_mode);\n+  emit_vlmax_op (code_for_pred_mov (mode), dest, src, mask_mode);\n   return true;\n }\n \n@@ -371,4 +396,92 @@ get_vector_mode (scalar_mode inner_mode, poly_uint64 nunits)\n   return opt_machine_mode ();\n }\n \n+bool\n+simm5_p (rtx x)\n+{\n+  if (!CONST_INT_P (x))\n+    return false;\n+  return IN_RANGE (INTVAL (x), -16, 15);\n+}\n+\n+bool\n+neg_simm5_p (rtx x)\n+{\n+  if (!CONST_INT_P (x))\n+    return false;\n+  return IN_RANGE (INTVAL (x), -15, 16);\n+}\n+\n+bool\n+has_vi_variant_p (rtx_code code, rtx x)\n+{\n+  switch (code)\n+    {\n+    case PLUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case SS_PLUS:\n+    case US_PLUS:\n+    case EQ:\n+    case NE:\n+    case LE:\n+    case LEU:\n+    case GT:\n+    case GTU:\n+      return simm5_p (x);\n+\n+    case LT:\n+    case LTU:\n+    case GE:\n+    case GEU:\n+    case MINUS:\n+    case SS_MINUS:\n+      return neg_simm5_p (x);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+bool\n+sew64_scalar_helper (rtx *operands, rtx *scalar_op, rtx vl,\n+\t\t     machine_mode vector_mode, machine_mode mask_mode,\n+\t\t     bool has_vi_variant_p,\n+\t\t     void (*emit_vector_func) (rtx *, rtx))\n+{\n+  machine_mode scalar_mode = GET_MODE_INNER (vector_mode);\n+  if (has_vi_variant_p)\n+    {\n+      *scalar_op = force_reg (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (!rtx_equal_p (*scalar_op, const0_rtx))\n+\t*scalar_op = force_reg (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (immediate_operand (*scalar_op, Pmode))\n+    {\n+      if (!rtx_equal_p (*scalar_op, const0_rtx))\n+\t*scalar_op = force_reg (Pmode, *scalar_op);\n+\n+      *scalar_op = gen_rtx_SIGN_EXTEND (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (CONST_INT_P (*scalar_op))\n+    *scalar_op = force_reg (scalar_mode, *scalar_op);\n+\n+  rtx tmp = gen_reg_rtx (vector_mode);\n+  riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (vector_mode), tmp,\n+\t\t\t\t  *scalar_op, vl, mask_mode);\n+  emit_vector_func (operands, tmp);\n+\n+  return true;\n+}\n+\n } // namespace riscv_vector"}, {"sha": "88142217e45f5153bf418b3a333e4033910a94c9", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -154,6 +154,696 @@ class loadstore : public function_base\n   }\n };\n \n+/* Implements\n+ * vadd/vsub/vand/vor/vxor/vsll/vsra/vsrl/vmin/vmax/vminu/vmaxu/vdiv/vrem/vdivu/vremu/vsadd/vsaddu/vssub/vssubu.\n+ */\n+template<rtx_code CODE>\n+class binop : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (code_for_pred_scalar (CODE, e.vector_mode ()));\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (code_for_pred (CODE, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vrsub.  */\n+class vrsub : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (\n+      code_for_pred_sub_reverse_scalar (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vneg/vnot.  */\n+template<rtx_code CODE>\n+class unop : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vsext.vf2/vsext.vf4/vsext.vf8/vzext.vf2/vzext.vf4/vzext.vf8.  */\n+template<rtx_code CODE>\n+class ext : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vf2:\n+\treturn e.use_exact_insn (code_for_pred_vf2 (CODE, e.vector_mode ()));\n+      case OP_TYPE_vf4:\n+\treturn e.use_exact_insn (code_for_pred_vf4 (CODE, e.vector_mode ()));\n+      case OP_TYPE_vf8:\n+\treturn e.use_exact_insn (code_for_pred_vf8 (CODE, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vmulh/vmulhu/vmulhsu.  */\n+template<int UNSPEC>\n+class vmulh : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_mulh_scalar (UNSPEC, e.vector_mode ()));\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_mulh (UNSPEC, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vwadd/vwsub/vwmul.  */\n+template<rtx_code CODE1, rtx_code CODE2>\n+class widen_binop : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_dual_widen (CODE1, CODE2, e.vector_mode ()));\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_dual_widen_scalar (CODE1, CODE2, e.vector_mode ()));\n+      case OP_TYPE_wv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_single_widen (CODE1, CODE2, e.vector_mode ()));\n+      case OP_TYPE_wx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_single_widen_scalar (CODE1, CODE2, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vwmulsu.  */\n+class vwmulsu : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (code_for_pred_widen_mulsu (e.vector_mode ()));\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_widen_mulsu_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vwcvt.  */\n+template<rtx_code CODE>\n+class vwcvt : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vadc.  */\n+class vadc : public function_base\n+{\n+public:\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vvm:\n+\treturn e.use_exact_insn (code_for_pred_adc (e.vector_mode ()));\n+      case OP_TYPE_vxm:\n+\treturn e.use_exact_insn (code_for_pred_adc_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vsbc.  */\n+class vsbc : public function_base\n+{\n+public:\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vvm:\n+\treturn e.use_exact_insn (code_for_pred_sbc (e.vector_mode ()));\n+      case OP_TYPE_vxm:\n+\treturn e.use_exact_insn (code_for_pred_sbc_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vmadc.  */\n+class vmadc : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vvm:\n+\treturn e.use_exact_insn (code_for_pred_madc (e.vector_mode ()));\n+      case OP_TYPE_vxm:\n+\treturn e.use_exact_insn (code_for_pred_madc_scalar (e.vector_mode ()));\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_madc_overflow (e.vector_mode ()));\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_madc_overflow_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vmsbc.  */\n+class vmsbc : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vvm:\n+\treturn e.use_exact_insn (code_for_pred_msbc (e.vector_mode ()));\n+      case OP_TYPE_vxm:\n+\treturn e.use_exact_insn (code_for_pred_msbc_scalar (e.vector_mode ()));\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_msbc_overflow (e.vector_mode ()));\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_msbc_overflow_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vnsrl/vnsra.  */\n+template<rtx_code CODE>\n+class vnshift : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_wx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_narrow_scalar (CODE, e.vector_mode ()));\n+      case OP_TYPE_wv:\n+\treturn e.use_exact_insn (code_for_pred_narrow (CODE, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vncvt.  */\n+class vncvt_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_trunc (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmerge.  */\n+class vmerge : public function_base\n+{\n+public:\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vvm:\n+\treturn e.use_exact_insn (code_for_pred_merge (e.vector_mode ()));\n+      case OP_TYPE_vxm:\n+\treturn e.use_exact_insn (code_for_pred_merge_scalar (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vmv.v.x/vmv.v.v.  */\n+class vmv_v : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_v:\n+\treturn e.use_exact_insn (code_for_pred_mov (e.vector_mode ()));\n+      case OP_TYPE_x:\n+\treturn e.use_exact_insn (code_for_pred_broadcast (e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vaadd/vasub/vsmul/vssra/vssrl.  */\n+template<int UNSPEC>\n+class sat_op : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_scalar (UNSPEC, e.vector_mode ()));\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (code_for_pred (UNSPEC, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vnclip/vnclipu.  */\n+template<int UNSPEC>\n+class vnclip : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_wx:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_narrow_clip_scalar (UNSPEC, e.vector_mode ()));\n+      case OP_TYPE_wv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_narrow_clip (UNSPEC, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vmseq/vmsne/vmslt/vmsgt/vmsle/vmsge.  */\n+template<rtx_code CODE>\n+class icmp : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+\tcase OP_TYPE_vx: {\n+\t  if (CODE == GE || CODE == GEU)\n+\t    return e.use_compare_insn (CODE, code_for_pred_ge_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t  else if (CODE == EQ || CODE == NE)\n+\t    return e.use_compare_insn (CODE, code_for_pred_eqne_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t  else\n+\t    return e.use_compare_insn (CODE, code_for_pred_cmp_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t}\n+\tcase OP_TYPE_vv: {\n+\t  if (CODE == LT || CODE == LTU || CODE == GE || CODE == GEU)\n+\t    return e.use_compare_insn (CODE,\n+\t\t\t\t       code_for_pred_ltge (e.vector_mode ()));\n+\t  else\n+\t    return e.use_compare_insn (CODE,\n+\t\t\t\t       code_for_pred_cmp (e.vector_mode ()));\n+\t}\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Enumerates types of ternary operations.\n+   We have 2 types ternop:\n+     - 1. accumulator is vd:\n+        vmacc.vv vd,vs1,vs2 # vd = vs1 * vs2 + vd.\n+     - 2. accumulator is vs2:\n+        vmadd.vv vd,vs1,vs2 # vd = vs1 * vd + vs2.  */\n+enum ternop_type\n+{\n+  TERNOP_VMACC,\n+  TERNOP_VNMSAC,\n+  TERNOP_VMADD,\n+  TERNOP_VNMSUB,\n+};\n+\n+/* Implements vmacc/vnmsac/vmadd/vnmsub.  */\n+template<ternop_type TERNOP_TYPE>\n+class imac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (TERNOP_TYPE)\n+      {\n+      case TERNOP_VMACC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    true, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (true,\n+\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VNMSAC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    true, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (true, code_for_pred_mul (MINUS,\n+\t\t\t\t\t\t\t     e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VMADD:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    false, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (false,\n+\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VNMSUB:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    false, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (false,\n+\t\t\t\t    code_for_pred_mul (MINUS,\n+\t\t\t\t\t\t       e.vector_mode ()));\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Enumerates types of widen ternary operations.\n+   We have 4 types ternop:\n+     - 1. vwmacc.\n+     - 2. vwmaccu.\n+     - 3. vwmaccsu.\n+     - 4. vwmaccus.  */\n+enum widen_ternop_type\n+{\n+  WIDEN_TERNOP_VWMACC,\n+  WIDEN_TERNOP_VWMACCU,\n+  WIDEN_TERNOP_VWMACCSU,\n+  WIDEN_TERNOP_VWMACCUS,\n+};\n+\n+/* Implements vwmacc<su><su>.  */\n+template<widen_ternop_type WIDEN_TERNOP_TYPE>\n+class iwmac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (WIDEN_TERNOP_TYPE)\n+      {\n+      case WIDEN_TERNOP_VWMACC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus_scalar (SIGN_EXTEND,\n+\t\t\t\t\t\t e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus (SIGN_EXTEND, e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCU:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus_scalar (ZERO_EXTEND,\n+\t\t\t\t\t\t e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus (ZERO_EXTEND, e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCSU:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plussu_scalar (e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plussu (e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCUS:\n+\treturn e.use_widen_ternop_insn (\n+\t  code_for_pred_widen_mul_plusus_scalar (e.vector_mode ()));\n+      default:\n+\tbreak;\n+      }\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Implements vmand/vmnand/vmandn/vmxor/vmor/vmnor/vmorn/vmxnor  */\n+template<rtx_code CODE>\n+class mask_logic : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred (CODE, e.vector_mode ()));\n+  }\n+};\n+template<rtx_code CODE>\n+class mask_nlogic : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_n (CODE, e.vector_mode ()));\n+  }\n+};\n+template<rtx_code CODE>\n+class mask_notlogic : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_not (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmmv.  */\n+class vmmv : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_mov (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmclr.  */\n+class vmclr : public function_base\n+{\n+public:\n+  bool can_be_overloaded_p (enum predication_type_index) const override\n+  {\n+    return false;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    machine_mode mode = TYPE_MODE (TREE_TYPE (e.exp));\n+    e.add_all_one_mask_operand (mode);\n+    e.add_vundef_operand (mode);\n+    e.add_input_operand (mode, CONST0_RTX (mode));\n+    e.add_input_operand (call_expr_nargs (e.exp) - 1);\n+    e.add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+    return e.generate_insn (code_for_pred_mov (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmset.  */\n+class vmset : public function_base\n+{\n+public:\n+  bool can_be_overloaded_p (enum predication_type_index) const override\n+  {\n+    return false;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    machine_mode mode = TYPE_MODE (TREE_TYPE (e.exp));\n+    e.add_all_one_mask_operand (mode);\n+    e.add_vundef_operand (mode);\n+    e.add_input_operand (mode, CONSTM1_RTX (mode));\n+    e.add_input_operand (call_expr_nargs (e.exp) - 1);\n+    e.add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+    return e.generate_insn (code_for_pred_mov (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmnot.  */\n+class vmnot : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_not (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vcpop.  */\n+class vcpop : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_popcount (e.vector_mode (), Pmode));\n+  }\n+};\n+\n+/* Implements vfirst.  */\n+class vfirst : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_ffs (e.vector_mode (), Pmode));\n+  }\n+};\n+\n+/* Implements vmsbf/vmsif/vmsof.  */\n+template<int UNSPEC>\n+class mask_misc : public function_base\n+{\n+public:\n+  bool apply_tail_policy_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred (UNSPEC, e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements viota.  */\n+class viota : public function_base\n+{\n+public:\n+  bool can_be_overloaded_p (enum predication_type_index pred) const override\n+  {\n+    return pred == PRED_TYPE_tu || pred == PRED_TYPE_tum\n+\t   || pred == PRED_TYPE_tumu;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_iota (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vid.  */\n+class vid : public function_base\n+{\n+public:\n+  bool can_be_overloaded_p (enum predication_type_index pred) const override\n+  {\n+    return pred == PRED_TYPE_tu || pred == PRED_TYPE_tum\n+\t   || pred == PRED_TYPE_tumu;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_series (e.vector_mode ()));\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -178,6 +868,99 @@ static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei8_obj;\n static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei16_obj;\n static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei32_obj;\n static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei64_obj;\n+static CONSTEXPR const binop<PLUS> vadd_obj;\n+static CONSTEXPR const binop<MINUS> vsub_obj;\n+static CONSTEXPR const vrsub vrsub_obj;\n+static CONSTEXPR const binop<AND> vand_obj;\n+static CONSTEXPR const binop<IOR> vor_obj;\n+static CONSTEXPR const binop<XOR> vxor_obj;\n+static CONSTEXPR const binop<ASHIFT> vsll_obj;\n+static CONSTEXPR const binop<ASHIFTRT> vsra_obj;\n+static CONSTEXPR const binop<LSHIFTRT> vsrl_obj;\n+static CONSTEXPR const binop<SMIN> vmin_obj;\n+static CONSTEXPR const binop<SMAX> vmax_obj;\n+static CONSTEXPR const binop<UMIN> vminu_obj;\n+static CONSTEXPR const binop<UMAX> vmaxu_obj;\n+static CONSTEXPR const binop<MULT> vmul_obj;\n+static CONSTEXPR const vmulh<UNSPEC_VMULHS> vmulh_obj;\n+static CONSTEXPR const vmulh<UNSPEC_VMULHU> vmulhu_obj;\n+static CONSTEXPR const vmulh<UNSPEC_VMULHSU> vmulhsu_obj;\n+static CONSTEXPR const binop<DIV> vdiv_obj;\n+static CONSTEXPR const binop<MOD> vrem_obj;\n+static CONSTEXPR const binop<UDIV> vdivu_obj;\n+static CONSTEXPR const binop<UMOD> vremu_obj;\n+static CONSTEXPR const unop<NEG> vneg_obj;\n+static CONSTEXPR const unop<NOT> vnot_obj;\n+static CONSTEXPR const ext<SIGN_EXTEND> vsext_obj;\n+static CONSTEXPR const ext<ZERO_EXTEND> vzext_obj;\n+static CONSTEXPR const widen_binop<PLUS, SIGN_EXTEND>vwadd_obj;\n+static CONSTEXPR const widen_binop<MINUS, SIGN_EXTEND>vwsub_obj;\n+static CONSTEXPR const widen_binop<MULT, SIGN_EXTEND>vwmul_obj;\n+static CONSTEXPR const widen_binop<PLUS, ZERO_EXTEND>vwaddu_obj;\n+static CONSTEXPR const widen_binop<MINUS, ZERO_EXTEND>vwsubu_obj;\n+static CONSTEXPR const widen_binop<MULT, ZERO_EXTEND>vwmulu_obj;\n+static CONSTEXPR const vwmulsu vwmulsu_obj;\n+static CONSTEXPR const vwcvt<SIGN_EXTEND> vwcvt_x_obj;\n+static CONSTEXPR const vwcvt<ZERO_EXTEND> vwcvtu_x_obj;\n+static CONSTEXPR const vadc vadc_obj;\n+static CONSTEXPR const vsbc vsbc_obj;\n+static CONSTEXPR const vmadc vmadc_obj;\n+static CONSTEXPR const vmsbc vmsbc_obj;\n+static CONSTEXPR const vnshift<LSHIFTRT> vnsrl_obj;\n+static CONSTEXPR const vnshift<ASHIFTRT> vnsra_obj;\n+static CONSTEXPR const vncvt_x vncvt_x_obj;\n+static CONSTEXPR const vmerge vmerge_obj;\n+static CONSTEXPR const vmv_v vmv_v_obj;\n+static CONSTEXPR const icmp<EQ> vmseq_obj;\n+static CONSTEXPR const icmp<NE> vmsne_obj;\n+static CONSTEXPR const icmp<LT> vmslt_obj;\n+static CONSTEXPR const icmp<GT> vmsgt_obj;\n+static CONSTEXPR const icmp<LE> vmsle_obj;\n+static CONSTEXPR const icmp<GE> vmsge_obj;\n+static CONSTEXPR const icmp<LTU> vmsltu_obj;\n+static CONSTEXPR const icmp<GTU> vmsgtu_obj;\n+static CONSTEXPR const icmp<LEU> vmsleu_obj;\n+static CONSTEXPR const icmp<GEU> vmsgeu_obj;\n+static CONSTEXPR const imac<TERNOP_VMACC> vmacc_obj;\n+static CONSTEXPR const imac<TERNOP_VNMSAC> vnmsac_obj;\n+static CONSTEXPR const imac<TERNOP_VMADD> vmadd_obj;\n+static CONSTEXPR const imac<TERNOP_VNMSUB> vnmsub_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACC> vwmacc_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCU> vwmaccu_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCSU> vwmaccsu_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCUS> vwmaccus_obj;\n+static CONSTEXPR const binop<SS_PLUS> vsadd_obj;\n+static CONSTEXPR const binop<SS_MINUS> vssub_obj;\n+static CONSTEXPR const binop<US_PLUS> vsaddu_obj;\n+static CONSTEXPR const binop<US_MINUS> vssubu_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VAADDU> vaaddu_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VAADD> vaadd_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VASUBU> vasubu_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VASUB> vasub_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VSMUL> vsmul_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VSSRL> vssrl_obj;\n+static CONSTEXPR const sat_op<UNSPEC_VSSRA> vssra_obj;\n+static CONSTEXPR const vnclip<UNSPEC_VNCLIP> vnclip_obj;\n+static CONSTEXPR const vnclip<UNSPEC_VNCLIPU> vnclipu_obj;\n+static CONSTEXPR const mask_logic<AND> vmand_obj;\n+static CONSTEXPR const mask_nlogic<AND> vmnand_obj;\n+static CONSTEXPR const mask_notlogic<AND> vmandn_obj;\n+static CONSTEXPR const mask_logic<XOR> vmxor_obj;\n+static CONSTEXPR const mask_logic<IOR> vmor_obj;\n+static CONSTEXPR const mask_nlogic<IOR> vmnor_obj;\n+static CONSTEXPR const mask_notlogic<IOR> vmorn_obj;\n+static CONSTEXPR const mask_nlogic<XOR> vmxnor_obj;\n+static CONSTEXPR const vmmv vmmv_obj;\n+static CONSTEXPR const vmclr vmclr_obj;\n+static CONSTEXPR const vmset vmset_obj;\n+static CONSTEXPR const vmnot vmnot_obj;\n+static CONSTEXPR const vcpop vcpop_obj;\n+static CONSTEXPR const vfirst vfirst_obj;\n+static CONSTEXPR const mask_misc<UNSPEC_VMSBF> vmsbf_obj;\n+static CONSTEXPR const mask_misc<UNSPEC_VMSIF> vmsif_obj;\n+static CONSTEXPR const mask_misc<UNSPEC_VMSOF> vmsof_obj;\n+static CONSTEXPR const viota viota_obj;\n+static CONSTEXPR const vid vid_obj;\n \n /* Declare the function base NAME, pointing it to an instance\n    of class <NAME>_obj.  */\n@@ -208,5 +991,98 @@ BASE (vsoxei8)\n BASE (vsoxei16)\n BASE (vsoxei32)\n BASE (vsoxei64)\n+BASE (vadd)\n+BASE (vsub)\n+BASE (vrsub)\n+BASE (vand)\n+BASE (vor)\n+BASE (vxor)\n+BASE (vsll)\n+BASE (vsra)\n+BASE (vsrl)\n+BASE (vmin)\n+BASE (vmax)\n+BASE (vminu)\n+BASE (vmaxu)\n+BASE (vmul)\n+BASE (vmulh)\n+BASE (vmulhu)\n+BASE (vmulhsu)\n+BASE (vdiv)\n+BASE (vrem)\n+BASE (vdivu)\n+BASE (vremu)\n+BASE (vneg)\n+BASE (vnot)\n+BASE (vsext)\n+BASE (vzext)\n+BASE (vwadd)\n+BASE (vwsub)\n+BASE (vwmul)\n+BASE (vwaddu)\n+BASE (vwsubu)\n+BASE (vwmulu)\n+BASE (vwmulsu)\n+BASE (vwcvt_x)\n+BASE (vwcvtu_x)\n+BASE (vadc)\n+BASE (vsbc)\n+BASE (vmadc)\n+BASE (vmsbc)\n+BASE (vnsrl)\n+BASE (vnsra)\n+BASE (vncvt_x)\n+BASE (vmerge)\n+BASE (vmv_v)\n+BASE (vmseq)\n+BASE (vmsne)\n+BASE (vmslt)\n+BASE (vmsgt)\n+BASE (vmsle)\n+BASE (vmsge)\n+BASE (vmsltu)\n+BASE (vmsgtu)\n+BASE (vmsleu)\n+BASE (vmsgeu)\n+BASE (vmacc)\n+BASE (vnmsac)\n+BASE (vmadd)\n+BASE (vnmsub)\n+BASE (vwmacc)\n+BASE (vwmaccu)\n+BASE (vwmaccsu)\n+BASE (vwmaccus)\n+BASE (vsadd)\n+BASE (vssub)\n+BASE (vsaddu)\n+BASE (vssubu)\n+BASE (vaadd)\n+BASE (vasub)\n+BASE (vaaddu)\n+BASE (vasubu)\n+BASE (vsmul)\n+BASE (vssra)\n+BASE (vssrl)\n+BASE (vnclip)\n+BASE (vnclipu)\n+BASE (vmand)\n+BASE (vmnand)\n+BASE (vmandn)\n+BASE (vmxor)\n+BASE (vmor)\n+BASE (vmnor)\n+BASE (vmorn)\n+BASE (vmxnor)\n+BASE (vmmv)\n+BASE (vmclr)\n+BASE (vmset)\n+BASE (vmnot)\n+BASE (vcpop)\n+BASE (vfirst)\n+BASE (vmsbf)\n+BASE (vmsif)\n+BASE (vmsof)\n+BASE (viota)\n+BASE (vid)\n \n } // end namespace riscv_vector"}, {"sha": "e136cd9114768437c482b71b64be950ae6fc7fa4", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -48,6 +48,101 @@ extern const function_base *const vsoxei8;\n extern const function_base *const vsoxei16;\n extern const function_base *const vsoxei32;\n extern const function_base *const vsoxei64;\n+extern const function_base *const vadd;\n+extern const function_base *const vsub;\n+extern const function_base *const vrsub;\n+extern const function_base *const vand;\n+extern const function_base *const vor;\n+extern const function_base *const vxor;\n+extern const function_base *const vsll;\n+extern const function_base *const vsra;\n+extern const function_base *const vsrl;\n+extern const function_base *const vmin;\n+extern const function_base *const vmax;\n+extern const function_base *const vminu;\n+extern const function_base *const vmaxu;\n+extern const function_base *const vmul;\n+extern const function_base *const vmulh;\n+extern const function_base *const vmulhu;\n+extern const function_base *const vmulhsu;\n+extern const function_base *const vdiv;\n+extern const function_base *const vrem;\n+extern const function_base *const vdivu;\n+extern const function_base *const vremu;\n+extern const function_base *const vneg;\n+extern const function_base *const vnot;\n+extern const function_base *const vsext;\n+extern const function_base *const vzext;\n+extern const function_base *const vwadd;\n+extern const function_base *const vwsub;\n+extern const function_base *const vwmul;\n+extern const function_base *const vwaddu;\n+extern const function_base *const vwsubu;\n+extern const function_base *const vwmulu;\n+extern const function_base *const vwmulsu;\n+extern const function_base *const vwcvt_x;\n+extern const function_base *const vwcvtu_x;\n+extern const function_base *const vadc;\n+extern const function_base *const vsbc;\n+extern const function_base *const vmadc;\n+extern const function_base *const vmsbc;\n+extern const function_base *const vnsrl;\n+extern const function_base *const vnsra;\n+extern const function_base *const vncvt_x;\n+extern const function_base *const vmerge;\n+extern const function_base *const vmv_v;\n+extern const function_base *const vmseq;\n+extern const function_base *const vmsne;\n+extern const function_base *const vmslt;\n+extern const function_base *const vmsgt;\n+extern const function_base *const vmsle;\n+extern const function_base *const vmsge;\n+extern const function_base *const vmsltu;\n+extern const function_base *const vmsgtu;\n+extern const function_base *const vmsleu;\n+extern const function_base *const vmsgeu;\n+extern const function_base *const vmacc;\n+extern const function_base *const vnmsac;\n+extern const function_base *const vmadd;\n+extern const function_base *const vnmsub;\n+extern const function_base *const vwmacc;\n+extern const function_base *const vwmaccu;\n+extern const function_base *const vwmaccsu;\n+extern const function_base *const vwmaccus;\n+extern const function_base *const vsadd;\n+extern const function_base *const vssub;\n+extern const function_base *const vsaddu;\n+extern const function_base *const vssubu;\n+extern const function_base *const vaadd;\n+extern const function_base *const vasub;\n+extern const function_base *const vaaddu;\n+extern const function_base *const vasubu;\n+extern const function_base *const vsmul;\n+extern const function_base *const vssra;\n+extern const function_base *const vssrl;\n+extern const function_base *const vnclip;\n+extern const function_base *const vnclip;\n+extern const function_base *const vnclipu;\n+extern const function_base *const vnclipu;\n+extern const function_base *const vmand;\n+extern const function_base *const vmnand;\n+extern const function_base *const vmandn;\n+extern const function_base *const vmxor;\n+extern const function_base *const vmor;\n+extern const function_base *const vmnor;\n+extern const function_base *const vmorn;\n+extern const function_base *const vmxnor;\n+extern const function_base *const vmmv;\n+extern const function_base *const vmclr;\n+extern const function_base *const vmset;\n+extern const function_base *const vmnot;\n+extern const function_base *const vcpop;\n+extern const function_base *const vfirst;\n+extern const function_base *const vmsbf;\n+extern const function_base *const vmsif;\n+extern const function_base *const vmsof;\n+extern const function_base *const viota;\n+extern const function_base *const vid;\n }\n \n } // end namespace riscv_vector"}, {"sha": "38bf1b694bbbc79ed2bbf1dda2c60ba7b7f5df9c", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -37,15 +37,23 @@ along with GCC; see the file COPYING3. If not see\n #endif\n \n /* 6. Configuration-Setting Instructions.  */\n+\n DEF_RVV_FUNCTION (vsetvl, vsetvl, none_preds, i_none_size_size_ops)\n DEF_RVV_FUNCTION (vsetvlmax, vsetvlmax, none_preds, i_none_size_void_ops)\n+\n /* 7. Vector Loads and Stores. */\n+\n+// 7.4. Vector Unit-Stride Instructions\n DEF_RVV_FUNCTION (vle, loadstore, full_preds, all_v_scalar_const_ptr_ops)\n DEF_RVV_FUNCTION (vse, loadstore, none_m_preds, all_v_scalar_ptr_ops)\n DEF_RVV_FUNCTION (vlm, loadstore, none_preds, b_v_scalar_const_ptr_ops)\n DEF_RVV_FUNCTION (vsm, loadstore, none_preds, b_v_scalar_ptr_ops)\n+\n+// 7.5. Vector Strided Instructions\n DEF_RVV_FUNCTION (vlse, loadstore, full_preds, all_v_scalar_const_ptr_ptrdiff_ops)\n DEF_RVV_FUNCTION (vsse, loadstore, none_m_preds, all_v_scalar_ptr_ptrdiff_ops)\n+\n+// 7.6. Vector Indexed Instructions\n DEF_RVV_FUNCTION (vluxei8, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint8_index_ops)\n DEF_RVV_FUNCTION (vluxei16, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint16_index_ops)\n DEF_RVV_FUNCTION (vluxei32, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint32_index_ops)\n@@ -63,4 +71,243 @@ DEF_RVV_FUNCTION (vsoxei16, indexed_loadstore, none_m_preds, all_v_scalar_ptr_ui\n DEF_RVV_FUNCTION (vsoxei32, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint32_index_ops)\n DEF_RVV_FUNCTION (vsoxei64, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint64_index_ops)\n \n+// TODO: 7.7. Unit-stride Fault-Only-First Loads\n+// TODO: 7.8. Vector Load/Store Segment Instructions\n+\n+/* 11. Vector Integer Arithmetic Instructions.  */\n+\n+// 11.1. Vector Single-Width Integer Add and Subtract\n+DEF_RVV_FUNCTION (vadd, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vadd, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vsub, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vsub, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vrsub, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vneg, alu, full_preds, iu_v_ops)\n+\n+// 11.2. Vector Widening Integer Add/Subtract\n+DEF_RVV_FUNCTION (vwaddu, widen_alu, full_preds, u_wvv_ops)\n+DEF_RVV_FUNCTION (vwaddu, widen_alu, full_preds, u_wvx_ops)\n+DEF_RVV_FUNCTION (vwsubu, widen_alu, full_preds, u_wvv_ops)\n+DEF_RVV_FUNCTION (vwsubu, widen_alu, full_preds, u_wvx_ops)\n+DEF_RVV_FUNCTION (vwadd, widen_alu, full_preds, i_wvv_ops)\n+DEF_RVV_FUNCTION (vwadd, widen_alu, full_preds, i_wvx_ops)\n+DEF_RVV_FUNCTION (vwsub, widen_alu, full_preds, i_wvv_ops)\n+DEF_RVV_FUNCTION (vwsub, widen_alu, full_preds, i_wvx_ops)\n+DEF_RVV_FUNCTION (vwaddu, widen_alu, full_preds, u_wwv_ops)\n+DEF_RVV_FUNCTION (vwaddu, widen_alu, full_preds, u_wwx_ops)\n+DEF_RVV_FUNCTION (vwsubu, widen_alu, full_preds, u_wwv_ops)\n+DEF_RVV_FUNCTION (vwsubu, widen_alu, full_preds, u_wwx_ops)\n+DEF_RVV_FUNCTION (vwadd, widen_alu, full_preds, i_wwv_ops)\n+DEF_RVV_FUNCTION (vwadd, widen_alu, full_preds, i_wwx_ops)\n+DEF_RVV_FUNCTION (vwsub, widen_alu, full_preds, i_wwv_ops)\n+DEF_RVV_FUNCTION (vwsub, widen_alu, full_preds, i_wwx_ops)\n+DEF_RVV_FUNCTION (vwcvt_x, alu, full_preds, i_x_x_v_ops)\n+DEF_RVV_FUNCTION (vwcvtu_x, alu, full_preds, u_x_x_v_ops)\n+\n+// 11.3. Vector Integer Extension\n+DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf2_ops)\n+DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf4_ops)\n+DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf8_ops)\n+DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf2_ops)\n+DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf4_ops)\n+DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf8_ops)\n+\n+// 11.4. Vector Integer Add-with-Carry/Subtract-with-Borrow Instructions\n+DEF_RVV_FUNCTION (vadc, no_mask_policy, none_tu_preds, iu_vvvm_ops)\n+DEF_RVV_FUNCTION (vadc, no_mask_policy, none_tu_preds, iu_vvxm_ops)\n+DEF_RVV_FUNCTION (vmadc, return_mask, none_preds, iu_mvvm_ops)\n+DEF_RVV_FUNCTION (vmadc, return_mask, none_preds, iu_mvxm_ops)\n+DEF_RVV_FUNCTION (vmadc, return_mask, none_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmadc, return_mask, none_preds, iu_mvx_ops)\n+DEF_RVV_FUNCTION (vsbc, no_mask_policy, none_tu_preds, iu_vvvm_ops)\n+DEF_RVV_FUNCTION (vsbc, no_mask_policy, none_tu_preds, iu_vvxm_ops)\n+DEF_RVV_FUNCTION (vmsbc, return_mask, none_preds, iu_mvvm_ops)\n+DEF_RVV_FUNCTION (vmsbc, return_mask, none_preds, iu_mvxm_ops)\n+DEF_RVV_FUNCTION (vmsbc, return_mask, none_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmsbc, return_mask, none_preds, iu_mvx_ops)\n+\n+// 11.5. Vector Bitwise Logical Instructions\n+DEF_RVV_FUNCTION (vand, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vand, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vor, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vor, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vxor, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vxor, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vnot, alu, full_preds, iu_v_ops)\n+\n+// 11.6. Vector Single-Width Shift Instructions\n+DEF_RVV_FUNCTION (vsll, alu, full_preds, iu_shift_vvv_ops)\n+DEF_RVV_FUNCTION (vsll, alu, full_preds, iu_shift_vvx_ops)\n+DEF_RVV_FUNCTION (vsra, alu, full_preds, i_shift_vvv_ops)\n+DEF_RVV_FUNCTION (vsra, alu, full_preds, i_shift_vvx_ops)\n+DEF_RVV_FUNCTION (vsrl, alu, full_preds, u_shift_vvv_ops)\n+DEF_RVV_FUNCTION (vsrl, alu, full_preds, u_shift_vvx_ops)\n+\n+// 11.7. Vector Narrowing Integer Right Shift Instructions\n+DEF_RVV_FUNCTION (vnsrl, narrow_alu, full_preds, u_narrow_shift_vwv_ops)\n+DEF_RVV_FUNCTION (vnsrl, narrow_alu, full_preds, u_narrow_shift_vwx_ops)\n+DEF_RVV_FUNCTION (vnsra, narrow_alu, full_preds, i_narrow_shift_vwv_ops)\n+DEF_RVV_FUNCTION (vnsra, narrow_alu, full_preds, i_narrow_shift_vwx_ops)\n+DEF_RVV_FUNCTION (vncvt_x, narrow_alu, full_preds, iu_trunc_ops)\n+\n+// 11.8. Vector Integer Compare Instructions\n+DEF_RVV_FUNCTION (vmseq, return_mask, none_m_mu_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmseq, return_mask, none_m_mu_preds, iu_mvx_ops)\n+DEF_RVV_FUNCTION (vmsne, return_mask, none_m_mu_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmsne, return_mask, none_m_mu_preds, iu_mvx_ops)\n+DEF_RVV_FUNCTION (vmsltu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsltu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmslt, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmslt, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsleu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsleu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsle, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsle, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgtu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgtu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgt, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgt, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgeu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgeu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsge, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsge, return_mask, none_m_mu_preds, i_mvx_ops)\n+\n+// 11.9. Vector Integer Min/Max Instructions\n+DEF_RVV_FUNCTION (vminu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vminu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vmin, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vmin, alu, full_preds, i_vvx_ops)\n+DEF_RVV_FUNCTION (vmaxu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vmaxu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vmax, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vmax, alu, full_preds, i_vvx_ops)\n+\n+// 11.10. Vector Single-Width Integer Multiply Instructions\n+DEF_RVV_FUNCTION (vmul, alu, full_preds, iu_vvv_ops)\n+DEF_RVV_FUNCTION (vmul, alu, full_preds, iu_vvx_ops)\n+DEF_RVV_FUNCTION (vmulh, alu, full_preds, full_v_i_vvv_ops)\n+DEF_RVV_FUNCTION (vmulh, alu, full_preds, full_v_i_vvx_ops)\n+DEF_RVV_FUNCTION (vmulhu, alu, full_preds, full_v_u_vvv_ops)\n+DEF_RVV_FUNCTION (vmulhu, alu, full_preds, full_v_u_vvx_ops)\n+DEF_RVV_FUNCTION (vmulhsu, alu, full_preds, full_v_i_su_vvv_ops)\n+DEF_RVV_FUNCTION (vmulhsu, alu, full_preds, full_v_i_su_vvx_ops)\n+\n+// 11.11. Vector Integer Divide Instructions\n+DEF_RVV_FUNCTION (vdivu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vdivu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vdiv, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vdiv, alu, full_preds, i_vvx_ops)\n+DEF_RVV_FUNCTION (vremu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vremu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vrem, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vrem, alu, full_preds, i_vvx_ops)\n+\n+// 11.12. Vector Widening Integer Multiply Instructions\n+DEF_RVV_FUNCTION (vwmul, alu, full_preds, i_wvv_ops)\n+DEF_RVV_FUNCTION (vwmul, alu, full_preds, i_wvx_ops)\n+DEF_RVV_FUNCTION (vwmulu, alu, full_preds, u_wvv_ops)\n+DEF_RVV_FUNCTION (vwmulu, alu, full_preds, u_wvx_ops)\n+DEF_RVV_FUNCTION (vwmulsu, alu, full_preds, i_su_wvv_ops)\n+DEF_RVV_FUNCTION (vwmulsu, alu, full_preds, i_su_wvx_ops)\n+\n+// 11.13. Vector Single-Width Integer Multiply-Add Instructions\n+DEF_RVV_FUNCTION (vmacc, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vmacc, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vnmsac, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vnmsac, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vmadd, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vmadd, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vnmsub, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vnmsub, alu, full_preds, iu_vvxv_ops)\n+\n+// 11.14. Vector Widening Integer Multiply-Add Instructions\n+DEF_RVV_FUNCTION (vwmaccu, alu, full_preds, u_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmaccu, alu, full_preds, u_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmacc, alu, full_preds, i_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmacc, alu, full_preds, i_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmaccsu, alu, full_preds, i_su_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmaccsu, alu, full_preds, i_su_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmaccus, alu, full_preds, i_us_wwxv_ops)\n+\n+// 11.15. Vector Integer Merge Instructions\n+DEF_RVV_FUNCTION (vmerge, no_mask_policy, none_tu_preds, all_vvvm_ops)\n+DEF_RVV_FUNCTION (vmerge, no_mask_policy, none_tu_preds, iu_vvxm_ops)\n+\n+// 11.16 Vector Integer Move Instructions\n+DEF_RVV_FUNCTION (vmv_v, move, none_tu_preds, all_v_ops)\n+DEF_RVV_FUNCTION (vmv_v, move, none_tu_preds, iu_x_ops)\n+\n+/* 12. Vector Fixed-Point Arithmetic Instructions. */\n+\n+// 12.1. Vector Single-Width Saturating Add and Subtract\n+DEF_RVV_FUNCTION (vsaddu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vsaddu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vsadd, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vsadd, alu, full_preds, i_vvx_ops)\n+DEF_RVV_FUNCTION (vssubu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vssubu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vssub, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vssub, alu, full_preds, i_vvx_ops)\n+\n+// 12.2. Vector Single-Width Averaging Add and Subtract\n+DEF_RVV_FUNCTION (vaaddu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vaaddu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vaadd, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vaadd, alu, full_preds, i_vvx_ops)\n+DEF_RVV_FUNCTION (vasubu, alu, full_preds, u_vvv_ops)\n+DEF_RVV_FUNCTION (vasubu, alu, full_preds, u_vvx_ops)\n+DEF_RVV_FUNCTION (vasub, alu, full_preds, i_vvv_ops)\n+DEF_RVV_FUNCTION (vasub, alu, full_preds, i_vvx_ops)\n+\n+// 12.3. Vector Single-Width Fractional Multiply with Rounding and Saturation\n+DEF_RVV_FUNCTION (vsmul, alu, full_preds, full_v_i_vvv_ops)\n+DEF_RVV_FUNCTION (vsmul, alu, full_preds, full_v_i_vvx_ops)\n+\n+// 12.4. Vector Single-Width Scaling Shift Instructions\n+DEF_RVV_FUNCTION (vssrl, alu, full_preds, u_shift_vvv_ops)\n+DEF_RVV_FUNCTION (vssrl, alu, full_preds, u_shift_vvx_ops)\n+DEF_RVV_FUNCTION (vssra, alu, full_preds, i_shift_vvv_ops)\n+DEF_RVV_FUNCTION (vssra, alu, full_preds, i_shift_vvx_ops)\n+\n+// 12.5. Vector Narrowing Fixed-Point Clip Instructions\n+DEF_RVV_FUNCTION (vnclipu, narrow_alu, full_preds, u_narrow_shift_vwv_ops)\n+DEF_RVV_FUNCTION (vnclipu, narrow_alu, full_preds, u_narrow_shift_vwx_ops)\n+DEF_RVV_FUNCTION (vnclip, narrow_alu, full_preds, i_narrow_shift_vwv_ops)\n+DEF_RVV_FUNCTION (vnclip, narrow_alu, full_preds, i_narrow_shift_vwx_ops)\n+\n+/* TODO: 13. Vector Floating-Point Instructions.  */\n+/* TODO: 14. Vector Reduction Operations.  */\n+\n+/* 15. Vector Mask Instructions.  */\n+\n+// 15.1. Vector Mask-Register Logical Instructions\n+DEF_RVV_FUNCTION (vmand, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmnand, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmandn, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmxor, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmor, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmnor, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmorn, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmxnor, mask_alu, none_preds, b_mmm_ops)\n+DEF_RVV_FUNCTION (vmmv, mask_alu, none_preds, b_mm_ops)\n+DEF_RVV_FUNCTION (vmclr, mask_alu, none_preds, b_m_ops)\n+DEF_RVV_FUNCTION (vmset, mask_alu, none_preds, b_m_ops)\n+DEF_RVV_FUNCTION (vmnot, mask_alu, none_preds, b_mm_ops)\n+// 15.2. Vector count population in mask vcpop.m\n+DEF_RVV_FUNCTION (vcpop, mask_alu, none_m_preds, b_ulong_m_ops)\n+// 15.3. vfirst find-first-set mask bit\n+DEF_RVV_FUNCTION (vfirst, mask_alu, none_m_preds, b_long_m_ops)\n+// 15.4. vmsbf.m set-before-first mask bit\n+DEF_RVV_FUNCTION (vmsbf, mask_alu, none_m_mu_preds, b_mm_ops)\n+// 15.5. vmsif.m set-including-first mask bit\n+DEF_RVV_FUNCTION (vmsif, mask_alu, none_m_mu_preds, b_mm_ops)\n+// 15.6. vmsof.m set-only-first mask bit\n+DEF_RVV_FUNCTION (vmsof, mask_alu, none_m_mu_preds, b_mm_ops)\n+// 15.8. Vector Iota Instruction\n+DEF_RVV_FUNCTION (viota, mask_alu, full_preds, u_vm_ops)\n+// 15.9. Vector Element Index Instruction\n+DEF_RVV_FUNCTION (vid, alu, full_preds, u_v_ops)\n+\n+/* TODO: 16. Vector Permutation Instructions.  */\n+\n #undef DEF_RVV_FUNCTION"}, {"sha": "abf169dea4c51e779e897e63bdb5d9e97aa583ec", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -185,9 +185,215 @@ struct indexed_loadstore_def : public function_shape\n   }\n };\n \n+/* alu_def class.  */\n+struct alu_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    /* Return nullptr if it can not be overloaded.  */\n+    if (overloaded_p && !instance.base->can_be_overloaded_p (instance.pred))\n+      return nullptr;\n+\n+    b.append_base_name (instance.base_name);\n+\n+    /* vop<sew> --> vop<sew>_<op>. According to rvv-intrinsic-doc, _vv/_vx/_v\n+       API doesn't have OP suffix in overloaded function name, otherwise, we\n+       always append OP suffix in function name. For example, vsext_vf2.  */\n+    if (instance.op_info->op == OP_TYPE_vv || instance.op_info->op == OP_TYPE_vx\n+\t|| instance.op_info->op == OP_TYPE_v\n+\t|| instance.op_info->op == OP_TYPE_x_v)\n+      {\n+\tif (!overloaded_p)\n+\t  b.append_name (operand_suffixes[instance.op_info->op]);\n+      }\n+    else\n+      b.append_name (operand_suffixes[instance.op_info->op]);\n+\n+    /* vop<sew>_<op> --> vop<sew>_<op>_<type>.  */\n+    if (!overloaded_p)\n+      b.append_name (type_suffixes[instance.type.index].vector);\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* widen_alu_def class. Handle vwadd/vwsub. Unlike\n+   vadd.vx/vadd.vv/vwmul.vv/vwmul.vx, vwadd.vv/vwadd.vx/vwadd.wv/vwadd.wx has\n+   'OP' suffix in overloaded API.  */\n+struct widen_alu_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    b.append_base_name (instance.base_name);\n+\n+    /* vop<sew> --> vop<sew>_<op>.  */\n+    b.append_name (operand_suffixes[instance.op_info->op]);\n+\n+    /* vop<sew>_<op> --> vop<sew>_<op>_<type>.  */\n+    if (!overloaded_p)\n+      b.append_name (type_suffixes[instance.type.index].vector);\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* no_mask_policy_def class. Such instructions belong to this class\n+   doesn't need mask policy.  */\n+struct no_mask_policy_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    b.append_base_name (instance.base_name);\n+\n+    if (!overloaded_p)\n+      b.append_name (operand_suffixes[instance.op_info->op]);\n+\n+    /* vop<sew>_<op> --> vop<sew>_<op>_<type>.  */\n+    if (!overloaded_p)\n+      b.append_name (type_suffixes[instance.type.index].vector);\n+\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* return_mask_def class. Such instructions belong to this class\n+   is returning mask value.  */\n+struct return_mask_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    b.append_base_name (instance.base_name);\n+\n+    if (!overloaded_p)\n+      b.append_name (operand_suffixes[instance.op_info->op]);\n+\n+    /* vop<sew>_<op> --> vop<sew>_<op>_<type1>_<type2>.  */\n+    if (!overloaded_p)\n+      {\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+\tvector_type_index ret_type_idx\n+\t  = instance.op_info->ret.get_base_vector_type (\n+\t    builtin_types[instance.type.index].vector);\n+\tb.append_name (type_suffixes[ret_type_idx].vector);\n+      }\n+\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* narrow_alu_def class. Handle narrowing instructions like vnsrl.wv.  */\n+struct narrow_alu_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    b.append_base_name (instance.base_name);\n+\n+    if (!overloaded_p)\n+      {\n+\t/* vop --> vop_<op>.  */\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\t/* vop_<op> --> vop_<op>_<type>.  */\n+\tvector_type_index ret_type_idx\n+\t  = instance.op_info->ret.get_base_vector_type (\n+\t    builtin_types[instance.type.index].vector);\n+\tb.append_name (type_suffixes[ret_type_idx].vector);\n+      }\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* move_def class. Handle vmv.v.v/vmv.v.x.  */\n+struct move_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    /* vmv.v.x (PRED_none) can not be overloaded.  */\n+    if (instance.op_info->op == OP_TYPE_x && overloaded_p\n+\t&& instance.pred == PRED_TYPE_none)\n+      return nullptr;\n+\n+    b.append_base_name (instance.base_name);\n+\n+    if (!overloaded_p)\n+      {\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+      }\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* mask_alu_def class.  */\n+struct mask_alu_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    /* Return nullptr if it can not be overloaded.  */\n+    if (overloaded_p && !instance.base->can_be_overloaded_p (instance.pred))\n+      return nullptr;\n+\n+    b.append_base_name (instance.base_name);\n+\n+    if (instance.op_info->op == OP_TYPE_mm || instance.op_info->op == OP_TYPE_m)\n+      if (!overloaded_p)\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\n+    /* vop<sew>_<op> --> vop<sew>_<op>_<type>.  */\n+    if (!overloaded_p)\n+      b.append_name (type_suffixes[instance.type.index].vector);\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n SHAPE(vsetvl, vsetvl)\n SHAPE(vsetvl, vsetvlmax)\n SHAPE(loadstore, loadstore)\n SHAPE(indexed_loadstore, indexed_loadstore)\n+SHAPE(alu, alu)\n+SHAPE(widen_alu, widen_alu)\n+SHAPE(no_mask_policy, no_mask_policy)\n+SHAPE(return_mask, return_mask)\n+SHAPE(narrow_alu, narrow_alu)\n+SHAPE(move, move)\n+SHAPE(mask_alu, mask_alu)\n \n } // end namespace riscv_vector"}, {"sha": "406abefdb10f5b564c6b2ca7c55575fa30125704", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -28,6 +28,13 @@ extern const function_shape *const vsetvl;\n extern const function_shape *const vsetvlmax;\n extern const function_shape *const loadstore;\n extern const function_shape *const indexed_loadstore;\n+extern const function_shape *const alu;\n+extern const function_shape *const widen_alu;\n+extern const function_shape *const no_mask_policy;\n+extern const function_shape *const return_mask;\n+extern const function_shape *const narrow_alu;\n+extern const function_shape *const move;\n+extern const function_shape *const mask_alu;\n }\n \n } // end namespace riscv_vector"}, {"sha": "0a562bd283fa533df0e89b60a55f3a544644f621", "filename": "gcc/config/riscv/riscv-vector-builtins-types.def", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -42,6 +42,56 @@ along with GCC; see the file COPYING3. If not see\n #define DEF_RVV_B_OPS(TYPE, REQUIRE)\n #endif\n \n+/* Use \"DEF_RVV_WEXTI_OPS\" macro include Double-Widening signed integer which\n+   will be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_WEXTI_OPS\n+#define DEF_RVV_WEXTI_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_QEXTI_OPS\" macro include Quad-Widening signed integer which will\n+   be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_QEXTI_OPS\n+#define DEF_RVV_QEXTI_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_OEXTI_OPS\" macro include Oct-Widening signed integer which will\n+   be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_OEXTI_OPS\n+#define DEF_RVV_OEXTI_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_WEXTU_OPS\" macro include Double-Widening unsigned integer which\n+   will be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_WEXTU_OPS\n+#define DEF_RVV_WEXTU_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_QEXTU_OPS\" macro include Quad-Widening unsigned integer which\n+   will be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_QEXTU_OPS\n+#define DEF_RVV_QEXTU_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_OEXTU_OPS\" macro include Oct-Widening unsigned integer which\n+   will be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_OEXTU_OPS\n+#define DEF_RVV_OEXTU_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_FULL_V_I_OPS\" macro include all signed integer that require full\n+   'V' extension which will be iterated and registered as intrinsic functions.\n+ */\n+#ifndef DEF_RVV_FULL_V_I_OPS\n+#define DEF_RVV_FULL_V_I_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_FULL_V_U_OPS\" macro include all unsigned integer that require\n+   full 'V' extension which will be iterated and registered as intrinsic\n+   functions.  */\n+#ifndef DEF_RVV_FULL_V_U_OPS\n+#define DEF_RVV_FULL_V_U_OPS(TYPE, REQUIRE)\n+#endif\n+\n DEF_RVV_I_OPS (vint8mf8_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint8mf4_t, 0)\n DEF_RVV_I_OPS (vint8mf2_t, 0)\n@@ -106,7 +156,123 @@ DEF_RVV_B_OPS (vbool4_t, 0)\n DEF_RVV_B_OPS (vbool2_t, 0)\n DEF_RVV_B_OPS (vbool1_t, 0)\n \n+DEF_RVV_WEXTI_OPS (vint16mf4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTI_OPS (vint16mf2_t, 0)\n+DEF_RVV_WEXTI_OPS (vint16m1_t, 0)\n+DEF_RVV_WEXTI_OPS (vint16m2_t, 0)\n+DEF_RVV_WEXTI_OPS (vint16m4_t, 0)\n+DEF_RVV_WEXTI_OPS (vint16m8_t, 0)\n+DEF_RVV_WEXTI_OPS (vint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTI_OPS (vint32m1_t, 0)\n+DEF_RVV_WEXTI_OPS (vint32m2_t, 0)\n+DEF_RVV_WEXTI_OPS (vint32m4_t, 0)\n+DEF_RVV_WEXTI_OPS (vint32m8_t, 0)\n+DEF_RVV_WEXTI_OPS (vint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTI_OPS (vint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTI_OPS (vint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTI_OPS (vint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_QEXTI_OPS (vint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTI_OPS (vint32m1_t, 0)\n+DEF_RVV_QEXTI_OPS (vint32m2_t, 0)\n+DEF_RVV_QEXTI_OPS (vint32m4_t, 0)\n+DEF_RVV_QEXTI_OPS (vint32m8_t, 0)\n+DEF_RVV_QEXTI_OPS (vint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTI_OPS (vint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTI_OPS (vint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTI_OPS (vint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_OEXTI_OPS (vint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTI_OPS (vint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTI_OPS (vint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTI_OPS (vint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_WEXTU_OPS (vuint16mf4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTU_OPS (vuint16mf2_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint16m1_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint16m2_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint16m4_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint16m8_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTU_OPS (vuint32m1_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint32m2_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint32m4_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint32m8_t, 0)\n+DEF_RVV_WEXTU_OPS (vuint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTU_OPS (vuint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTU_OPS (vuint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_WEXTU_OPS (vuint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_QEXTU_OPS (vuint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTU_OPS (vuint32m1_t, 0)\n+DEF_RVV_QEXTU_OPS (vuint32m2_t, 0)\n+DEF_RVV_QEXTU_OPS (vuint32m4_t, 0)\n+DEF_RVV_QEXTU_OPS (vuint32m8_t, 0)\n+DEF_RVV_QEXTU_OPS (vuint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTU_OPS (vuint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTU_OPS (vuint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_QEXTU_OPS (vuint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_OEXTU_OPS (vuint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTU_OPS (vuint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTU_OPS (vuint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_OEXTU_OPS (vuint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_FULL_V_I_OPS (vint8mf8_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_I_OPS (vint8mf4_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint8mf2_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint8m1_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint8m2_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint8m4_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint8m8_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint16mf4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_I_OPS (vint16mf2_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint16m1_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint16m2_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint16m4_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint16m8_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_I_OPS (vint32m1_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint32m2_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint32m4_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint32m8_t, 0)\n+DEF_RVV_FULL_V_I_OPS (vint64m1_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_I_OPS (vint64m2_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_I_OPS (vint64m4_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_I_OPS (vint64m8_t, RVV_REQUIRE_FULL_V)\n+\n+DEF_RVV_FULL_V_U_OPS (vuint8mf8_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_U_OPS (vuint8mf4_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint8mf2_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint8m1_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint8m2_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint8m4_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint8m8_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint16mf4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_U_OPS (vuint16mf2_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint16m1_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint16m2_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint16m4_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint16m8_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_FULL_V_U_OPS (vuint32m1_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint32m2_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint32m4_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint32m8_t, 0)\n+DEF_RVV_FULL_V_U_OPS (vuint64m1_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_U_OPS (vuint64m2_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_U_OPS (vuint64m4_t, RVV_REQUIRE_FULL_V)\n+DEF_RVV_FULL_V_U_OPS (vuint64m8_t, RVV_REQUIRE_FULL_V)\n+\n #undef DEF_RVV_I_OPS\n #undef DEF_RVV_U_OPS\n #undef DEF_RVV_F_OPS\n #undef DEF_RVV_B_OPS\n+#undef DEF_RVV_WEXTI_OPS\n+#undef DEF_RVV_QEXTI_OPS\n+#undef DEF_RVV_OEXTI_OPS\n+#undef DEF_RVV_WEXTU_OPS\n+#undef DEF_RVV_QEXTU_OPS\n+#undef DEF_RVV_OEXTU_OPS\n+#undef DEF_RVV_FULL_V_I_OPS\n+#undef DEF_RVV_FULL_V_U_OPS"}, {"sha": "3747cad672fd400be94ebfd90ce147047b8f7eef", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 1060, "deletions": 12, "changes": 1072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -133,6 +133,33 @@ static const rvv_type_info i_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of all signed integer that SEW = 64 require full 'V' extension will be\n+   registered for intrinsic functions.  */\n+static const rvv_type_info full_v_i_ops[] = {\n+#define DEF_RVV_FULL_V_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all unsigned integer that SEW = 64 require full 'V' extension will\n+   be registered for intrinsic functions.  */\n+static const rvv_type_info full_v_u_ops[] = {\n+#define DEF_RVV_FULL_V_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all signed integer will be registered for intrinsic functions.  */\n+static const rvv_type_info u_ops[] = {\n+#define DEF_RVV_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all integer will be registered for intrinsic functions.  */\n+static const rvv_type_info iu_ops[] = {\n+#define DEF_RVV_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#define DEF_RVV_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n /* A list of all types will be registered for intrinsic functions.  */\n static const rvv_type_info all_ops[] = {\n #define DEF_RVV_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n@@ -147,13 +174,67 @@ static const rvv_type_info b_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of Double-Widening signed integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info wexti_ops[] = {\n+#define DEF_RVV_WEXTI_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Quad-Widening signed integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info qexti_ops[] = {\n+#define DEF_RVV_QEXTI_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Oct-Widening signed integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info oexti_ops[] = {\n+#define DEF_RVV_OEXTI_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Double-Widening unsigned integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info wextu_ops[] = {\n+#define DEF_RVV_WEXTU_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Double-Widening all integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info wextiu_ops[] = {\n+#define DEF_RVV_WEXTI_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#define DEF_RVV_WEXTU_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Quad-Widening unsigned integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info qextu_ops[] = {\n+#define DEF_RVV_QEXTU_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of Oct-Widening unsigned integer will be registered for intrinsic\n+ * functions.  */\n+static const rvv_type_info oextu_ops[] = {\n+#define DEF_RVV_OEXTU_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n static CONSTEXPR const rvv_arg_type_info rvv_arg_type_info_end\n   = rvv_arg_type_info (NUM_BASE_TYPES);\n \n /* A list of args for size_t func (void) function.  */\n static CONSTEXPR const rvv_arg_type_info void_args[]\n   = {rvv_arg_type_info (RVV_BASE_void), rvv_arg_type_info_end};\n \n+/* A list of args for size_t func () function.  */\n+static CONSTEXPR const rvv_arg_type_info end_args[]\n+  = {rvv_arg_type_info_end};\n+\n /* A list of args for size_t func (size_t) function.  */\n static CONSTEXPR const rvv_arg_type_info size_args[]\n   = {rvv_arg_type_info (RVV_BASE_size), rvv_arg_type_info_end};\n@@ -232,6 +313,172 @@ static CONSTEXPR const rvv_arg_type_info scalar_ptr_uint64_index_args[]\n      rvv_arg_type_info (RVV_BASE_uint64_index),\n      rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (vector_type, vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info vv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, vector_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, vector_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_scalar),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, vector_type, mask_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vvm_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_mask), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, scalar_type, mask_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vxm_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_scalar),\n+     rvv_arg_type_info (RVV_BASE_mask), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (signed vector_type, unsigned\n+ * vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_vv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_unsigned_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, scalar_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info vx_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_scalar),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (signed vector_type, unsigned\n+ * scalar_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_vx_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_unsigned_scalar), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, shift_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info shift_vv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_shift_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for double demote type func (vector_type, shift_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info shift_wv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info m_args[]\n+  = {rvv_arg_type_info (RVV_BASE_mask), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (scalar_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info x_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, size) function.  */\n+static CONSTEXPR const rvv_arg_type_info vector_size_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_size),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info vf2_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type, double demote type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info wvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info wwvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wwvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info us_wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (signed double demote type,\n+ * unsigneddouble demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type, double demote type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info wvx_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (signed double demote type, unsigned\n+ * double demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wvx_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_scalar),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type, double demote type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info wwv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type, double demote type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info wwx_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (quad demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info vf4_args[]\n+  = {rvv_arg_type_info (RVV_BASE_quad_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (oct demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info vf8_args[]\n+  = {rvv_arg_type_info (RVV_BASE_oct_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (double demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info x_x_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n /* A list of none preds that will be registered for intrinsic functions.  */\n static CONSTEXPR const predication_type_index none_preds[]\n   = {PRED_TYPE_none, NUM_PRED_TYPES};\n@@ -241,10 +488,18 @@ static CONSTEXPR const predication_type_index full_preds[]\n   = {PRED_TYPE_none, PRED_TYPE_m,  PRED_TYPE_tu,  PRED_TYPE_tum,\n      PRED_TYPE_tumu, PRED_TYPE_mu, NUM_PRED_TYPES};\n \n+/* vop/vop_tu will be registered.  */\n+static CONSTEXPR const predication_type_index none_tu_preds[]\n+  = {PRED_TYPE_none, PRED_TYPE_tu, NUM_PRED_TYPES};\n+\n /* vop/vop_m will be registered.  */\n static CONSTEXPR const predication_type_index none_m_preds[]\n   = {PRED_TYPE_none, PRED_TYPE_m, NUM_PRED_TYPES};\n \n+/* vop/vop_m/vop_mu will be registered.  */\n+static CONSTEXPR const predication_type_index none_m_mu_preds[]\n+  = {PRED_TYPE_none, PRED_TYPE_m, PRED_TYPE_mu, NUM_PRED_TYPES};\n+\n /* A static operand information for size_t func (void) function registration. */\n static CONSTEXPR const rvv_op_info i_none_size_void_ops\n   = {i_ops,\t\t\t\t/* Types */\n@@ -292,6 +547,62 @@ static CONSTEXPR const rvv_op_info b_v_scalar_ptr_ops\n      rvv_arg_type_info (RVV_BASE_void), /* Return type */\n      scalar_ptr_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_mmm_ops\n+  = {b_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_mm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_mm_ops\n+  = {b_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_m,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vm_ops\n+  = {u_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_m,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     m_args /* Args */};\n+\n+/* A static operand information for vector_type func ()\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_m_ops\n+  = {b_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_m,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     end_args /* Args */};\n+\n+/* A static operand information for vector_type func ()\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_v_ops\n+  = {u_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     end_args /* Args */};\n+\n+/* A static operand information for unsigned long func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_ulong_m_ops\n+  = {b_ops,\t\t\t\t\t /* Types */\n+     OP_TYPE_m,\t\t\t\t\t /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_unsigned_long), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for long func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_long_m_ops\n+  = {b_ops,\t\t\t\t/* Types */\n+     OP_TYPE_m,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_long), /* Return type */\n+     v_args /* Args */};\n+\n /* A static operand information for vector_type func (const scalar_type *,\n  * ptrdiff_t) function registration. */\n static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_ptrdiff_ops\n@@ -372,6 +683,519 @@ static CONSTEXPR const rvv_op_info all_v_scalar_ptr_uint64_index_ops\n      rvv_arg_type_info (RVV_BASE_void), /* Return type */\n      scalar_ptr_uint64_index_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvv_ops\n+  = {iu_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvvv_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvxv_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvvm_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vvm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vvm_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_vvvm_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vvm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vvm_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvxm_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vxm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vxm_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, vector_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_mvvm_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vvm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vvm_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, scalar_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_mvxm_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vxm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vxm_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_mvv_ops\n+  = {iu_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_mvv_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_mvv_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_mvx_ops\n+  = {iu_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_mvx_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_mvx_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_vvv_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vvv_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info full_v_i_vvv_ops\n+  = {full_v_i_ops,\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info full_v_u_vvv_ops\n+  = {full_v_u_ops,\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (signed vector_type,\n+ * unsigned vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info full_v_i_su_vvv_ops\n+  = {full_v_i_ops,\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvx_ops\n+  = {iu_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_vvx_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vvx_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type)\n+ * function registration that require full 'V' extension. */\n+static CONSTEXPR const rvv_op_info full_v_i_vvx_ops\n+  = {full_v_i_ops,\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type)\n+ * function registration that require full 'V' extension. */\n+static CONSTEXPR const rvv_op_info full_v_u_vvx_ops\n+  = {full_v_u_ops,\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (signed vector_type,\n+ * unsigned scalar_type) function registration that require full 'V' extension.\n+ */\n+static CONSTEXPR const rvv_op_info full_v_i_su_vvx_ops\n+  = {full_v_i_ops,\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_vx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, shift_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_shift_vvv_ops\n+  = {iu_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     shift_vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, size_t)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_shift_vvx_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vector_size_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, shift_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_shift_vvv_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     shift_vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, size_t)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_shift_vvx_ops\n+  = {i_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vector_size_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, shift_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_shift_vvv_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     shift_vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, size_t)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_shift_vvx_ops\n+  = {u_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vector_size_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_v_ops\n+  = {iu_ops,\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info all_v_ops\n+  = {all_ops,\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_x_ops\n+  = {iu_ops,\t\t\t/* Types */\n+     OP_TYPE_x,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_vf2_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf2,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf2_args /* Args */};\n+\n+/* A static operand information for vector_type func (quad demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_vf4_ops\n+  = {qexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf4,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf4_args /* Args */};\n+\n+/* A static operand information for vector_type func (oct demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_vf8_ops\n+  = {oexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf8,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf8_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vf2_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf2,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf2_args /* Args */};\n+\n+/* A static operand information for vector_type func (quad demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vf4_ops\n+  = {qextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf4,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf4_args /* Args */};\n+\n+/* A static operand information for vector_type func (oct demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_vf8_ops\n+  = {oextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf8,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vf8_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwvv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwxv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wwvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_us_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     us_wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (signed double demote type,\n+ * unsigned double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wvv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wvx_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvx_args /* Args */};\n+\n+/* A static operand information for vector_type func (signed double demote type,\n+ * unsigned double demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wvx_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wvx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwx_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwx_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwx_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwx_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wvx_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvx_args /* Args */};\n+\n+/* A static operand information for vector_type func (double demote type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_x_x_v_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_x_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_x_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (unsigned double demote\n+ * type) function registration. */\n+static CONSTEXPR const rvv_op_info u_x_x_v_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_x_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_x_v_args /* Args */};\n+\n+/* A static operand information for double demote type func (vector_type,\n+ * shift_type) function registration. */\n+static CONSTEXPR const rvv_op_info i_narrow_shift_vwv_ops\n+  = {wexti_ops,\t\t\t\t\t       /* Types */\n+     OP_TYPE_wv,\t\t\t\t       /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), /* Return type */\n+     shift_wv_args /* Args */};\n+\n+/* A static operand information for double demote type func (vector_type,\n+ * shift_type) function registration. */\n+static CONSTEXPR const rvv_op_info u_narrow_shift_vwv_ops\n+  = {wextu_ops,\t\t\t\t\t       /* Types */\n+     OP_TYPE_wv,\t\t\t\t       /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), /* Return type */\n+     shift_wv_args /* Args */};\n+\n+/* A static operand information for double demote type func (vector_type,\n+ * size_t) function registration. */\n+static CONSTEXPR const rvv_op_info i_narrow_shift_vwx_ops\n+  = {wexti_ops,\t\t\t\t\t       /* Types */\n+     OP_TYPE_wx,\t\t\t\t       /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), /* Return type */\n+     vector_size_args /* Args */};\n+\n+/* A static operand information for double demote type func (vector_type,\n+ * size_t) function registration. */\n+static CONSTEXPR const rvv_op_info u_narrow_shift_vwx_ops\n+  = {wextu_ops,\t\t\t\t\t       /* Types */\n+     OP_TYPE_wx,\t\t\t\t       /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), /* Return type */\n+     vector_size_args /* Args */};\n+\n+/* A static operand information for double demote type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_trunc_ops\n+  = {wextiu_ops,\t\t\t\t       /* Types */\n+     OP_TYPE_x_w,\t\t\t\t       /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), /* Return type */\n+     v_args /* Args */};\n+\n /* A list of all RVV intrinsic functions.  */\n static function_group_info function_groups[] = {\n #define DEF_RVV_FUNCTION(NAME, SHAPE, PREDS, OPS_INFO)                         \\\n@@ -605,6 +1429,8 @@ check_required_extensions (const function_instance &instance)\n     riscv_isa_flags |= RVV_REQUIRE_ZVE64;\n   if (TARGET_64BIT)\n     riscv_isa_flags |= RVV_REQUIRE_RV64BIT;\n+  if (TARGET_FULL_V)\n+    riscv_isa_flags |= RVV_REQUIRE_FULL_V;\n \n   uint64_t missing_extensions = required_extensions & ~riscv_isa_flags;\n   if (missing_extensions != 0)\n@@ -654,10 +1480,16 @@ rvv_arg_type_info::get_base_vector_type (tree type) const\n   if (!type)\n     return NUM_VECTOR_TYPES;\n   poly_int64 nunits = GET_MODE_NUNITS (TYPE_MODE (type));\n-  machine_mode inner_mode;\n+  machine_mode inner_mode = GET_MODE_INNER (TYPE_MODE (type));\n   bool unsigned_p = TYPE_UNSIGNED (type);\n+  if (base_type == RVV_BASE_double_trunc_unsigned_vector\n+      || base_type == RVV_BASE_double_trunc_unsigned_scalar)\n+    unsigned_p = true;\n   switch (base_type)\n     {\n+    case RVV_BASE_mask:\n+      inner_mode = E_BImode;\n+      break;\n     case RVV_BASE_uint8_index:\n       inner_mode = E_QImode;\n       unsigned_p = true;\n@@ -674,6 +1506,37 @@ rvv_arg_type_info::get_base_vector_type (tree type) const\n       inner_mode = E_DImode;\n       unsigned_p = true;\n       break;\n+    case RVV_BASE_shift_vector:\n+      inner_mode = GET_MODE_INNER (TYPE_MODE (type));\n+      unsigned_p = true;\n+      break;\n+    case RVV_BASE_double_trunc_vector:\n+    case RVV_BASE_double_trunc_scalar:\n+    case RVV_BASE_double_trunc_unsigned_vector:\n+    case RVV_BASE_double_trunc_unsigned_scalar:\n+      if (inner_mode == DImode)\n+\tinner_mode = SImode;\n+      else if (inner_mode == SImode)\n+\tinner_mode = HImode;\n+      else if (inner_mode == HImode)\n+\tinner_mode = QImode;\n+      else\n+\tgcc_unreachable ();\n+      break;\n+    case RVV_BASE_quad_trunc_vector:\n+      if (inner_mode == DImode)\n+\tinner_mode = HImode;\n+      else if (inner_mode == SImode)\n+\tinner_mode = QImode;\n+      else\n+\tgcc_unreachable ();\n+      break;\n+    case RVV_BASE_oct_trunc_vector:\n+      if (inner_mode == DImode)\n+\tinner_mode = QImode;\n+      else\n+\tgcc_unreachable ();\n+      break;\n     default:\n       return NUM_VECTOR_TYPES;\n     }\n@@ -689,7 +1552,8 @@ rvv_arg_type_info::get_base_vector_type (tree type) const\n       if (!vector_type)\n \tcontinue;\n \n-      if (TYPE_UNSIGNED (vector_type) != unsigned_p)\n+      if (GET_MODE_CLASS (TYPE_MODE (vector_type)) != MODE_VECTOR_BOOL\n+\t  && TYPE_UNSIGNED (vector_type) != unsigned_p)\n \tcontinue;\n \n       if (TYPE_MODE (vector_type) == mode.require ())\n@@ -701,12 +1565,28 @@ rvv_arg_type_info::get_base_vector_type (tree type) const\n tree\n rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n {\n+  /* If the builtin type is not registered means '-march' doesn't\n+     satisfy the require extension of the type. For example,\n+     vfloat32m1_t require floating-point extension. In this case,\n+     just return NULL_TREE.  */\n+  if (!builtin_types[type_idx].vector)\n+    return NULL_TREE;\n   switch (base_type)\n     {\n     case RVV_BASE_vector:\n       return builtin_types[type_idx].vector;\n     case RVV_BASE_scalar:\n       return builtin_types[type_idx].scalar;\n+    /* According to riscv-vector-builtins-types.def, the unsigned\n+       type is always the signed type + 1 (They have same SEW and LMUL).\n+       For example 'vuint8mf8_t' enum = 'vint8mf8_t' enum + 1.\n+       Note: We dont't allow type_idx to be unsigned type.  */\n+    case RVV_BASE_unsigned_vector:\n+      gcc_assert (!TYPE_UNSIGNED (builtin_types[type_idx].vector));\n+      return builtin_types[type_idx + 1].vector;\n+    case RVV_BASE_unsigned_scalar:\n+      gcc_assert (!TYPE_UNSIGNED (builtin_types[type_idx].scalar));\n+      return builtin_types[type_idx + 1].scalar;\n     case RVV_BASE_vector_ptr:\n       return builtin_types[type_idx].vector_ptr;\n     case RVV_BASE_scalar_ptr:\n@@ -737,11 +1617,24 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n     case RVV_BASE_uint16_index:\n     case RVV_BASE_uint32_index:\n     case RVV_BASE_uint64_index:\n+    case RVV_BASE_shift_vector:\n+    case RVV_BASE_double_trunc_vector:\n+    case RVV_BASE_quad_trunc_vector:\n+    case RVV_BASE_oct_trunc_vector:\n+    case RVV_BASE_double_trunc_unsigned_vector:\n+    case RVV_BASE_mask:\n       if (get_base_vector_type (builtin_types[type_idx].vector)\n \t  != NUM_VECTOR_TYPES)\n \treturn builtin_types[get_base_vector_type (\n \t\t\t       builtin_types[type_idx].vector)].vector;\n       break;\n+    case RVV_BASE_double_trunc_scalar:\n+    case RVV_BASE_double_trunc_unsigned_scalar:\n+      if (get_base_vector_type (builtin_types[type_idx].vector)\n+\t  != NUM_VECTOR_TYPES)\n+\treturn builtin_types[get_base_vector_type (\n+\t\t\t       builtin_types[type_idx].vector)].scalar;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -910,9 +1803,10 @@ function_builder::apply_predication (const function_instance &instance,\n \t\t\t\t     vec<tree> &argument_types) const\n {\n   /* These predication types need to apply merge type.  */\n-  if (instance.pred == PRED_TYPE_tu || instance.pred == PRED_TYPE_tum\n-      || instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n-    argument_types.quick_insert (0, return_type);\n+  if (instance.base->has_merge_operand_p ())\n+    if (instance.pred == PRED_TYPE_tu || instance.pred == PRED_TYPE_tum\n+\t|| instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n+      argument_types.quick_insert (0, return_type);\n \n   /* These predication types need to apply mask type.  */\n   tree mask_type = builtin_types[mask_types[instance.type.index]].vector;\n@@ -1109,8 +2003,7 @@ function_expander::add_input_operand (unsigned argno)\n void\n function_expander::add_vundef_operand (machine_mode mode)\n {\n-  rtx vundef = gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF);\n-  add_input_operand (mode, vundef);\n+  add_input_operand (mode, RVV_VUNDEF (mode));\n }\n \n /* Add a memory operand with mode MODE and address ADDR.  */\n@@ -1137,13 +2030,16 @@ function_expander::use_exact_insn (insn_code icode)\n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n \n-  if (use_real_mask_p (pred))\n-    add_input_operand (arg_offset++);\n-  else\n-    add_all_one_mask_operand (mask_mode);\n+  if (base->use_mask_predication_p ())\n+    {\n+      if (use_real_mask_p (pred))\n+\tadd_input_operand (arg_offset++);\n+      else\n+\tadd_all_one_mask_operand (mask_mode);\n+    }\n \n   /* Store operation doesn't have merge operand.  */\n-  if (!function_returns_void_p ())\n+  if (!function_returns_void_p () && base->has_merge_operand_p ())\n     {\n       if (use_real_merge_p (pred))\n \tadd_input_operand (arg_offset++);\n@@ -1228,6 +2124,158 @@ function_expander::use_contiguous_store_insn (insn_code icode)\n   return generate_insn (icode);\n }\n \n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_compare_insn (rtx_code rcode, insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  machine_mode mask_mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  if (use_real_merge_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_vundef_operand (mask_mode);\n+\n+  rtx op1 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx op2 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx comparison = gen_rtx_fmt_ee (rcode, mask_mode, op1, op2);\n+  if (!VECTOR_MODE_P (GET_MODE (op2)))\n+    comparison = gen_rtx_fmt_ee (rcode, mask_mode, op1,\n+\t\t\t\t gen_rtx_VEC_DUPLICATE (mode, op2));\n+  add_fixed_operand (comparison);\n+  add_fixed_operand (op1);\n+  if (CONST_INT_P (op2))\n+    add_integer_operand (op2);\n+  else\n+    add_fixed_operand (op2);\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  return generate_insn (icode);\n+}\n+\n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_ternop_insn (bool vd_accum_p, insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  rtx vd = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx vs1 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx vs2 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx merge = use_real_merge_p (pred) ? vd : RVV_VUNDEF (mode);\n+\n+  if (VECTOR_MODE_P (GET_MODE (vs1)))\n+    {\n+      if (!vd_accum_p)\n+\tadd_input_operand (mode, vd);\n+      add_input_operand (mode, vs1);\n+      add_input_operand (mode, vs2);\n+      if (vd_accum_p)\n+\tadd_input_operand (mode, vd);\n+      add_input_operand (mode, merge);\n+    }\n+  else\n+    {\n+      add_input_operand (GET_MODE_INNER (mode), vs1);\n+      if (vd_accum_p)\n+\t{\n+\t  add_input_operand (mode, vs2);\n+\t  add_input_operand (mode, vd);\n+\t}\n+      else\n+\t{\n+\t  add_input_operand (mode, vd);\n+\t  add_input_operand (mode, vs2);\n+\t}\n+      add_input_operand (mode, merge);\n+    }\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  /* See optabs.cc, the maximum nops is 9 for using 'maybe_gen_insn'.\n+     We temporarily use GCN directly. We will change it back it we\n+     can support nops >= 10.  */\n+  gcc_assert (maybe_legitimize_operands (icode, 0, opno, m_ops));\n+  rtx_insn *pat = GEN_FCN (\n+    icode) (m_ops[0].value, m_ops[1].value, m_ops[2].value, m_ops[3].value,\n+\t    m_ops[4].value, m_ops[5].value, m_ops[6].value, m_ops[7].value,\n+\t    m_ops[8].value, m_ops[9].value);\n+  emit_insn (pat);\n+  return m_ops[0].value;\n+}\n+\n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_widen_ternop_insn (insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  rtx merge = RVV_VUNDEF (mode);\n+  if (use_real_merge_p (pred))\n+    merge = expand_normal (CALL_EXPR_ARG (exp, arg_offset));\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    {\n+      if (argno == call_expr_nargs (exp) - 1)\n+\tadd_input_operand (mode, merge);\n+      add_input_operand (argno);\n+    }\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  /* See optabs.cc, the maximum nops is 9 for using 'maybe_gen_insn'.\n+     We temporarily use GCN directly. We will change it back it we\n+     can support nops >= 10.  */\n+  gcc_assert (maybe_legitimize_operands (icode, 0, opno, m_ops));\n+  rtx_insn *pat = GEN_FCN (\n+    icode) (m_ops[0].value, m_ops[1].value, m_ops[2].value, m_ops[3].value,\n+\t    m_ops[4].value, m_ops[5].value, m_ops[6].value, m_ops[7].value,\n+\t    m_ops[8].value, m_ops[9].value);\n+  emit_insn (pat);\n+  return m_ops[0].value;\n+}\n+\n /* Generate instruction ICODE, given that its operands have already\n    been added to M_OPS.  Return the value of the first operand.  */\n rtx"}, {"sha": "baafed8a4e94c475e0a9adc3660092c9c4f98cd7", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -273,15 +273,14 @@ DEF_RVV_OP_TYPE (vx)\n DEF_RVV_OP_TYPE (v)\n DEF_RVV_OP_TYPE (wv)\n DEF_RVV_OP_TYPE (wx)\n-DEF_RVV_OP_TYPE (x_x_v)\n+DEF_RVV_OP_TYPE (x_v)\n DEF_RVV_OP_TYPE (vf2)\n DEF_RVV_OP_TYPE (vf4)\n DEF_RVV_OP_TYPE (vf8)\n DEF_RVV_OP_TYPE (vvm)\n DEF_RVV_OP_TYPE (vxm)\n-DEF_RVV_OP_TYPE (x_x_w)\n-DEF_RVV_OP_TYPE (v_v)\n-DEF_RVV_OP_TYPE (v_x)\n+DEF_RVV_OP_TYPE (x_w)\n+DEF_RVV_OP_TYPE (x)\n DEF_RVV_OP_TYPE (vs)\n DEF_RVV_OP_TYPE (mm)\n DEF_RVV_OP_TYPE (m)"}, {"sha": "b9d736707892371d049f79437dffcfbe2d8ab227", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -106,6 +106,7 @@ static const unsigned int CP_WRITE_CSR = 1U << 5;\n #define RVV_REQUIRE_ZVE64 (1 << 1)\t/* Require TARGET_MIN_VLEN > 32.  */\n #define RVV_REQUIRE_ELEN_FP_32 (1 << 2) /* Require FP ELEN >= 32.  */\n #define RVV_REQUIRE_ELEN_FP_64 (1 << 3) /* Require FP ELEN >= 64.  */\n+#define RVV_REQUIRE_FULL_V (1 << 4) /* Require Full 'V' extension.  */\n \n /* Enumerates the RVV operand types.  */\n enum operand_type_index\n@@ -139,6 +140,9 @@ enum rvv_base_type\n {\n   RVV_BASE_vector,\n   RVV_BASE_scalar,\n+  RVV_BASE_mask,\n+  RVV_BASE_unsigned_vector,\n+  RVV_BASE_unsigned_scalar,\n   RVV_BASE_vector_ptr,\n   RVV_BASE_scalar_ptr,\n   RVV_BASE_scalar_const_ptr,\n@@ -151,6 +155,13 @@ enum rvv_base_type\n   RVV_BASE_uint16_index,\n   RVV_BASE_uint32_index,\n   RVV_BASE_uint64_index,\n+  RVV_BASE_shift_vector,\n+  RVV_BASE_double_trunc_vector,\n+  RVV_BASE_quad_trunc_vector,\n+  RVV_BASE_oct_trunc_vector,\n+  RVV_BASE_double_trunc_scalar,\n+  RVV_BASE_double_trunc_unsigned_vector,\n+  RVV_BASE_double_trunc_unsigned_scalar,\n   NUM_BASE_TYPES\n };\n \n@@ -327,6 +338,7 @@ class function_expander : public function_call_info\n   void add_all_one_mask_operand (machine_mode);\n   void add_vundef_operand (machine_mode);\n   void add_fixed_operand (rtx);\n+  void add_integer_operand (rtx);\n   void add_mem_operand (machine_mode, unsigned);\n \n   machine_mode vector_mode (void) const;\n@@ -335,6 +347,9 @@ class function_expander : public function_call_info\n   rtx use_exact_insn (insn_code);\n   rtx use_contiguous_load_insn (insn_code);\n   rtx use_contiguous_store_insn (insn_code);\n+  rtx use_compare_insn (rtx_code, insn_code);\n+  rtx use_ternop_insn (bool, insn_code);\n+  rtx use_widen_ternop_insn (insn_code);\n   rtx generate_insn (insn_code);\n \n   /* The function call expression.  */\n@@ -374,6 +389,12 @@ class function_base\n   /* Return true if intrinsic can be overloaded.  */\n   virtual bool can_be_overloaded_p (enum predication_type_index) const;\n \n+  /* Return true if intrinsics use mask predication.  */\n+  virtual bool use_mask_predication_p () const;\n+\n+  /* Return true if intrinsics has merge operand.  */\n+  virtual bool has_merge_operand_p () const;\n+\n   /* Expand the given call into rtl.  Return the result of the function,\n      or an arbitrary value if the function doesn't return a result.  */\n   virtual rtx expand (function_expander &) const = 0;\n@@ -450,6 +471,13 @@ function_expander::add_fixed_operand (rtx x)\n   create_fixed_operand (&m_ops[opno++], x);\n }\n \n+/* Add an integer operand X.  */\n+inline void\n+function_expander::add_integer_operand (rtx x)\n+{\n+  create_integer_operand (&m_ops[opno++], INTVAL (x));\n+}\n+\n /* Return the machine_mode of the corresponding vector type.  */\n inline machine_mode\n function_expander::vector_mode (void) const\n@@ -499,6 +527,22 @@ function_base::apply_mask_policy_p () const\n   return true;\n }\n \n+/* We choose to return true by default since most of the intrinsics use\n+   mask predication.  */\n+inline bool\n+function_base::use_mask_predication_p () const\n+{\n+  return true;\n+}\n+\n+/* We choose to return true by default since most of the intrinsics use\n+   has merge operand.  */\n+inline bool\n+function_base::has_merge_operand_p () const\n+{\n+  return true;\n+}\n+\n /* Since most of intrinsics can be overloaded, we set it true by default.  */\n inline bool\n function_base::can_be_overloaded_p (enum predication_type_index) const"}, {"sha": "3fbdd8622422c11cc38e4a5bf5c2ede7a0d95869", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -961,6 +961,46 @@ change_insn (function_info *ssa, insn_change change, insn_info *insn,\n   /* These routines report failures themselves.  */\n   if (!recog (attempt, change) || !change_is_worthwhile (change, false))\n     return false;\n+\n+  /* Fix bug:\n+      (insn 12 34 13 2 (set (reg:VNx8DI 120 v24 [orig:134 _1 ] [134])\n+\t(if_then_else:VNx8DI (unspec:VNx8BI [\n+\t\t    (const_vector:VNx8BI repeat [\n+\t\t\t    (const_int 1 [0x1])\n+\t\t\t])\n+\t\t    (const_int 0 [0])\n+\t\t    (const_int 2 [0x2]) repeated x2\n+\t\t    (const_int 0 [0])\n+\t\t    (reg:SI 66 vl)\n+\t\t    (reg:SI 67 vtype)\n+\t\t] UNSPEC_VPREDICATE)\n+\t    (plus:VNx8DI (reg/v:VNx8DI 104 v8 [orig:137 op1 ] [137])\n+\t\t(sign_extend:VNx8DI (vec_duplicate:VNx8SI (reg:SI 15 a5\n+    [140])))) (unspec:VNx8DI [ (const_int 0 [0]) ] UNSPEC_VUNDEF))) \"rvv.c\":8:12\n+    2784 {pred_single_widen_addsvnx8di_scalar} (expr_list:REG_EQUIV\n+    (mem/c:VNx8DI (reg:DI 10 a0 [142]) [1 <retval>+0 S[64, 64] A128])\n+\t(expr_list:REG_EQUAL (if_then_else:VNx8DI (unspec:VNx8BI [\n+\t\t\t(const_vector:VNx8BI repeat [\n+\t\t\t\t(const_int 1 [0x1])\n+\t\t\t    ])\n+\t\t\t(reg/v:DI 13 a3 [orig:139 vl ] [139])\n+\t\t\t(const_int 2 [0x2]) repeated x2\n+\t\t\t(const_int 0 [0])\n+\t\t\t(reg:SI 66 vl)\n+\t\t\t(reg:SI 67 vtype)\n+\t\t    ] UNSPEC_VPREDICATE)\n+\t\t(plus:VNx8DI (reg/v:VNx8DI 104 v8 [orig:137 op1 ] [137])\n+\t\t    (const_vector:VNx8DI repeat [\n+\t\t\t    (const_int 2730 [0xaaa])\n+\t\t\t]))\n+\t\t(unspec:VNx8DI [\n+\t\t\t(const_int 0 [0])\n+\t\t    ] UNSPEC_VUNDEF))\n+\t    (nil))))\n+    Here we want to remove use \"a3\". However, the REG_EQUAL/REG_EQUIV note use\n+    \"a3\" which made us fail in change_insn.  We reference to the\n+    'aarch64-cc-fusion.cc' and add this method.  */\n+  remove_reg_equal_equiv_notes (rinsn);\n   confirm_change_group ();\n   ssa->change_insn (change);\n \n@@ -3309,7 +3349,7 @@ pass_vsetvl::cleanup_insns (void) const\n \t  if (!has_vl_op (rinsn) || !REG_P (get_vl (rinsn)))\n \t    continue;\n \t  rtx avl = get_vl (rinsn);\n-\t  if (count_occurrences (PATTERN (rinsn), avl, true) == 1)\n+\t  if (count_occurrences (PATTERN (rinsn), avl, 0) == 1)\n \t    {\n \t      /* Get the list of uses for the new instruction.  */\n \t      auto attempt = crtl->ssa->new_change_attempt ();\n@@ -3323,7 +3363,9 @@ pass_vsetvl::cleanup_insns (void) const\n \t      use_array new_uses = use_array (uses_builder.finish ());\n \t      change.new_uses = new_uses;\n \t      change.move_range = insn->ebb ()->insn_range ();\n-\t      rtx pat = simplify_replace_rtx (PATTERN (rinsn), avl, const0_rtx);\n+\t      rtx set = single_set (rinsn);\n+\t      rtx src = simplify_replace_rtx (SET_SRC (set), avl, const0_rtx);\n+\t      rtx pat = gen_rtx_SET (SET_DEST (set), src);\n \t      gcc_assert (change_insn (crtl->ssa, change, insn, pat));\n \t    }\n \t}\n@@ -3492,8 +3534,15 @@ pass_vsetvl::compute_probabilities (void)\n       basic_block cfg_bb = bb->cfg_bb ();\n       auto &curr_prob\n \t= m_vector_manager->vector_block_infos[cfg_bb->index].probability;\n+\n+      /* GCC assume entry block (bb 0) are always so\n+\t executed so set its probability as \"always\".  */\n       if (ENTRY_BLOCK_PTR_FOR_FN (cfun) == cfg_bb)\n \tcurr_prob = profile_probability::always ();\n+      /* Exit block (bb 1) is the block we don't need to process.  */\n+      if (EXIT_BLOCK_PTR_FOR_FN (cfun) == cfg_bb)\n+\tcontinue;\n+\n       gcc_assert (curr_prob.initialized_p ());\n       FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n \t{\n@@ -3507,9 +3556,6 @@ pass_vsetvl::compute_probabilities (void)\n \t    new_prob += curr_prob * e->probability;\n \t}\n     }\n-  auto &exit_block\n-    = m_vector_manager->vector_block_infos[EXIT_BLOCK_PTR_FOR_FN (cfun)->index];\n-  exit_block.probability = profile_probability::always ();\n }\n \n /* Lazy vsetvl insertion for optimize > 0. */"}, {"sha": "f11b7949a49ea3472d357f2ac86eb55eb60fe307", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -293,7 +293,7 @@ const enum reg_class riscv_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  FRAME_REGS,\tFRAME_REGS,\tVL_REGS,\tVTYPE_REGS,\n+  FRAME_REGS,\tFRAME_REGS,\tNO_REGS,\tNO_REGS,\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n@@ -4229,15 +4229,54 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n \n   switch (letter)\n     {\n+      case 'o': {\n+\t/* Print 'OP' variant for RVV instructions.\n+\t   1. If the operand is VECTOR REG, we print 'v'(vnsrl.wv).\n+\t   2. If the operand is CONST_INT/CONST_VECTOR, we print 'i'(vnsrl.wi).\n+\t   3. If the operand is SCALAR REG, we print 'x'(vnsrl.wx).  */\n+\tif (riscv_v_ext_vector_mode_p (mode))\n+\t  {\n+\t    if (REG_P (op))\n+\t      asm_fprintf (file, \"v\");\n+\t    else if (CONST_VECTOR_P (op))\n+\t      asm_fprintf (file, \"i\");\n+\t    else\n+\t      output_operand_lossage (\"invalid vector operand\");\n+\t  }\n+\telse\n+\t  {\n+\t    if (CONST_INT_P (op))\n+\t      asm_fprintf (file, \"i\");\n+\t    else\n+\t      asm_fprintf (file, \"x\");\n+\t  }\n+\tbreak;\n+      }\n       case 'v': {\n \trtx elt;\n \n+\tif (REG_P (op))\n+\t  asm_fprintf (file, \"%s\", reg_names[REGNO (op)]);\n+\telse\n+\t  {\n+\t    if (!const_vec_duplicate_p (op, &elt))\n+\t      output_operand_lossage (\"invalid vector constant\");\n+\t    else if (satisfies_constraint_Wc0 (op))\n+\t      asm_fprintf (file, \"0\");\n+\t    else if (satisfies_constraint_vi (op)\n+\t\t     || satisfies_constraint_vj (op))\n+\t      asm_fprintf (file, \"%wd\", INTVAL (elt));\n+\t    else\n+\t      output_operand_lossage (\"invalid vector constant\");\n+\t  }\n+\tbreak;\n+      }\n+      case 'V': {\n+\trtx elt;\n \tif (!const_vec_duplicate_p (op, &elt))\n \t  output_operand_lossage (\"invalid vector constant\");\n-\telse if (satisfies_constraint_Wc0 (op))\n-\t  asm_fprintf (file, \"0\");\n-\telse if (satisfies_constraint_vi (op))\n-\t  asm_fprintf (file, \"%wd\", INTVAL (elt));\n+\telse if (satisfies_constraint_vj (op))\n+\t  asm_fprintf (file, \"%wd\", -INTVAL (elt));\n \telse\n \t  output_operand_lossage (\"invalid vector constant\");\n \tbreak;\n@@ -4338,6 +4377,10 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n         fputs (\"i\", file);\n       break;\n \n+    case 'B':\n+      fputs (GET_RTX_NAME (code), file);\n+      break;\n+\n     case 'S':\n       {\n \trtx newop = GEN_INT (ctz_hwi (INTVAL (op)));\n@@ -5044,8 +5087,9 @@ riscv_adjust_libcall_cfi_prologue ()\n       }\n \n   /* Debug info for adjust sp.  */\n-  adjust_sp_rtx = gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx, GEN_INT (-saved_size));\n+  adjust_sp_rtx =\n+    gen_rtx_SET (stack_pointer_rtx,\n+\t\t gen_rtx_PLUS (GET_MODE(stack_pointer_rtx), stack_pointer_rtx, GEN_INT (-saved_size)));\n   dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, adjust_sp_rtx,\n \t\t\t  dwarf);\n   return dwarf;\n@@ -5166,8 +5210,9 @@ riscv_adjust_libcall_cfi_epilogue ()\n   int saved_size = cfun->machine->frame.save_libcall_adjustment;\n \n   /* Debug info for adjust sp.  */\n-  adjust_sp_rtx = gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx, GEN_INT (saved_size));\n+  adjust_sp_rtx =\n+    gen_rtx_SET (stack_pointer_rtx,\n+\t\t gen_rtx_PLUS (GET_MODE(stack_pointer_rtx), stack_pointer_rtx, GEN_INT (saved_size)));\n   dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, adjust_sp_rtx,\n \t\t\t  dwarf);\n \n@@ -5821,12 +5866,6 @@ riscv_class_max_nregs (reg_class_t rclass, machine_mode mode)\n   if (reg_class_subset_p (rclass, V_REGS))\n     return riscv_hard_regno_nregs (V_REG_FIRST, mode);\n \n-  if (reg_class_subset_p (rclass, VL_REGS))\n-    return 1;\n-\n-  if (reg_class_subset_p (rclass, VTYPE_REGS))\n-    return 1;\n-\n   return 0;\n }\n "}, {"sha": "5bc7f2f467d9f6e8c4efc4faa9f96f27a7854a40", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -312,7 +312,7 @@ ASM_MISA_SPEC\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* Others.  */\t\t\t\t\t\t\t\\\n-  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   /* Vector registers.  */\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n@@ -462,8 +462,6 @@ enum reg_class\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating-point registers */\n   FRAME_REGS,\t\t\t/* arg pointer and frame pointer */\n-  VL_REGS,\t\t\t/* vl register */\n-  VTYPE_REGS,\t\t\t/* vtype register */\n   VM_REGS,\t\t\t/* v0.t registers */\n   VD_REGS,\t\t\t/* vector registers except v0.t */\n   V_REGS,\t\t\t/* vector registers */\n@@ -487,8 +485,6 @@ enum reg_class\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FRAME_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"VL_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"VTYPE_REGS\",\t\t\t\t\t\t\t\t\\\n   \"VM_REGS\",\t\t\t\t\t\t\t\t\\\n   \"VD_REGS\",\t\t\t\t\t\t\t\t\\\n   \"V_REGS\",\t\t\t\t\t\t\t\t\\\n@@ -514,12 +510,10 @@ enum reg_class\n   { 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },\t/* GR_REGS */\t\t\\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 },\t/* FP_REGS */\t\t\\\n   { 0x00000000, 0x00000000, 0x00000003, 0x00000000 },\t/* FRAME_REGS */\t\\\n-  { 0x00000000, 0x00000000, 0x00000004, 0x00000000 },\t/* VL_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000008, 0x00000000 },\t/* VTYPE_REGS */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000001 },\t/* V0_REGS */\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0xfffffffe },\t/* VNoV0_REGS */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0xffffffff },\t/* V_REGS */\t\t\\\n-  { 0xffffffff, 0xffffffff, 0x0000000f, 0xffffffff }\t/* ALL_REGS */\t\t\\\n+  { 0xffffffff, 0xffffffff, 0x00000003, 0xffffffff }\t/* ALL_REGS */\t\t\\\n }\n \n /* A C expression whose value is a register class containing hard\n@@ -651,9 +645,6 @@ enum reg_class\n #define FP_ARG_FIRST (FP_REG_FIRST + 10)\n #define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n \n-/* Helper macro for RVV vsetvl instruction generation.  */\n-#define X0_REGNUM GP_REG_FIRST\n-\n #define CALLEE_SAVED_REG_NUMBER(REGNO)\t\t\t\\\n   ((REGNO) >= 8 && (REGNO) <= 9 ? (REGNO) - 8 :\t\t\\\n    (REGNO) >= 18 && (REGNO) <= 27 ? (REGNO) - 16 : -1)\n@@ -1097,4 +1088,11 @@ extern void riscv_remove_unneeded_save_restore_calls (void);\n \n #define REGMODE_NATURAL_SIZE(MODE) riscv_regmode_natural_size (MODE)\n \n+#define RISCV_DWARF_VLENB (4096 + 0xc22)\n+\n+#define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER + 1 /* VLENB */)\n+\n+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) \\\n+  ((REGNO == RISCV_DWARF_VLENB) ? (FIRST_PSEUDO_REGISTER + 1) : REGNO)\n+\n #endif /* ! GCC_RISCV_H */"}, {"sha": "487059ebe973f129e0f06125ec6c03d1b73c1627", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -267,7 +267,8 @@\n ;; vicalu      vector arithmetic with carry or borrow instructions\n ;; vshift      vector single-width bit shift instructions\n ;; vnshift     vector narrowing integer shift instructions\n-;; vicmp       vector integer comparison/min/max instructions\n+;; viminmax    vector integer min/max instructions\n+;; vicmp       vector integer comparison instructions\n ;; vimul       vector single-width integer multiply instructions\n ;; vidiv       vector single-width integer divide instructions\n ;; viwmul      vector widening integer multiply instructions\n@@ -291,7 +292,8 @@\n ;; vfwmuladd   vector widening floating-point multiply-add instructions\n ;; vfsqrt      vector floating-point square-root instructions\n ;; vfrecp      vector floating-point reciprocal square-root instructions\n-;; vfcmp       vector floating-point comparison/min/max instructions\n+;; vfminmax    vector floating-point min/max instructions\n+;; vfcmp       vector floating-point comparison instructions\n ;; vfsgnj      vector floating-point sign-injection instructions\n ;; vfclass     vector floating-point classify instruction\n ;; vfmerge     vector floating-point merge instruction\n@@ -335,11 +337,11 @@\n    fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,sfb_alu,nop,ghost,bitmanip,rotate,\n    atomic,rdvlenb,rdvl,vsetvl,vlde,vste,vldm,vstm,vlds,vsts,\n    vldux,vldox,vstux,vstox,vldff,vldr,vstr,\n-   vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\n+   vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,viminmax,\n    vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\n    vsalu,vaalu,vsmul,vsshift,vnclip,\n    vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\n-   vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\n+   vfcmp,vfminmax,vfsgnj,vfclass,vfmerge,vfmov,\n    vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\n    vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\n    vired,viwred,vfred,vfredo,vfwred,vfwredo,"}, {"sha": "95535235354500ead9a66b74ed14206e5d3de9e0", "filename": "gcc/config/riscv/riscv.opt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Friscv.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -154,6 +154,8 @@ Mask(RVE)\n \n Mask(VECTOR)\n \n+Mask(FULL_V)\n+\n mriscv-attribute\n Target Var(riscv_emit_attribute_p) Init(-1)\n Emit RISC-V ELF attribute."}, {"sha": "023b0b329c4296a7079402f9ed1fc0a5f24d520c", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -28,6 +28,32 @@\n   ;; It's used to specify ordered/unorderd operation.\n   UNSPEC_ORDERED\n   UNSPEC_UNORDERED\n+\n+  ;; vmulh/vmulhu/vmulhsu\n+  UNSPEC_VMULHS\n+  UNSPEC_VMULHU\n+  UNSPEC_VMULHSU\n+\n+  UNSPEC_VADC\n+  UNSPEC_VSBC\n+  UNSPEC_VMADC\n+  UNSPEC_VMSBC\n+  UNSPEC_OVERFLOW\n+\n+  UNSPEC_VNCLIP\n+  UNSPEC_VNCLIPU\n+  UNSPEC_VSSRL\n+  UNSPEC_VSSRA\n+  UNSPEC_VAADDU\n+  UNSPEC_VAADD\n+  UNSPEC_VASUBU\n+  UNSPEC_VASUB\n+  UNSPEC_VSMUL\n+\n+  UNSPEC_VMSBF\n+  UNSPEC_VMSIF\n+  UNSPEC_VMSOF\n+  UNSPEC_VIOTA\n ])\n \n (define_mode_iterator V [\n@@ -47,6 +73,38 @@\n   (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n ])\n \n+(define_mode_iterator VI [\n+  VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+  VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VFULLI [\n+  VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+  VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_FULL_V\") (VNx2DI \"TARGET_FULL_V\")\n+  (VNx4DI \"TARGET_FULL_V\") (VNx8DI \"TARGET_FULL_V\")\n+])\n+\n+(define_mode_iterator VI_QHS [\n+  VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+  VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VI_D [\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VFULLI_D [\n+  (VNx1DI \"TARGET_FULL_V\") (VNx2DI \"TARGET_FULL_V\")\n+  (VNx4DI \"TARGET_FULL_V\") (VNx8DI \"TARGET_FULL_V\")\n+])\n+\n (define_mode_iterator VNX1_QHSD [\n   VNx1QI VNx1HI VNx1SI\n   (VNx1DI \"TARGET_MIN_VLEN > 32\")\n@@ -145,6 +203,24 @@\n   (VNx64BI \"TARGET_MIN_VLEN > 32\")\n ])\n \n+(define_mode_iterator VWEXTI [\n+  VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VQEXTI [\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VOEXTI [\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n (define_mode_attr VM [\n   (VNx1QI \"VNx1BI\") (VNx2QI \"VNx2BI\") (VNx4QI \"VNx4BI\") (VNx8QI \"VNx8BI\") (VNx16QI \"VNx16BI\") (VNx32QI \"VNx32BI\") (VNx64QI \"VNx64BI\")\n   (VNx1HI \"VNx1BI\") (VNx2HI \"VNx2BI\") (VNx4HI \"VNx4BI\") (VNx8HI \"VNx8BI\") (VNx16HI \"VNx16BI\") (VNx32HI \"VNx32BI\")\n@@ -154,6 +230,15 @@\n   (VNx1DF \"VNx1BI\") (VNx2DF \"VNx2BI\") (VNx4DF \"VNx4BI\") (VNx8DF \"VNx8BI\")\n ])\n \n+(define_mode_attr vm [\n+  (VNx1QI \"vnx1bi\") (VNx2QI \"vnx2bi\") (VNx4QI \"vnx4bi\") (VNx8QI \"vnx8bi\") (VNx16QI \"vnx16bi\") (VNx32QI \"vnx32bi\") (VNx64QI \"vnx64bi\")\n+  (VNx1HI \"vnx1bi\") (VNx2HI \"vnx2bi\") (VNx4HI \"vnx4bi\") (VNx8HI \"vnx8bi\") (VNx16HI \"vnx16bi\") (VNx32HI \"vnx32bi\")\n+  (VNx1SI \"vnx1bi\") (VNx2SI \"vnx2bi\") (VNx4SI \"vnx4bi\") (VNx8SI \"vnx8bi\") (VNx16SI \"vnx16bi\")\n+  (VNx1DI \"vnx1bi\") (VNx2DI \"vnx2bi\") (VNx4DI \"vnx4bi\") (VNx8DI \"vnx8bi\")\n+  (VNx1SF \"vnx1bi\") (VNx2SF \"vnx2bi\") (VNx4SF \"vnx4bi\") (VNx8SF \"vnx8bi\") (VNx16SF \"vnx16bi\")\n+  (VNx1DF \"vnx1bi\") (VNx2DF \"vnx2bi\") (VNx4DF \"vnx4bi\") (VNx8DF \"vnx8bi\")\n+])\n+\n (define_mode_attr VEL [\n   (VNx1QI \"QI\") (VNx2QI \"QI\") (VNx4QI \"QI\") (VNx8QI \"QI\") (VNx16QI \"QI\") (VNx32QI \"QI\") (VNx64QI \"QI\")\n   (VNx1HI \"HI\") (VNx2HI \"HI\") (VNx4HI \"HI\") (VNx8HI \"HI\") (VNx16HI \"HI\") (VNx32HI \"HI\")\n@@ -163,6 +248,14 @@\n   (VNx1DF \"DF\") (VNx2DF \"DF\") (VNx4DF \"DF\") (VNx8DF \"DF\")\n ])\n \n+(define_mode_attr VSUBEL [\n+  (VNx1HI \"QI\") (VNx2HI \"QI\") (VNx4HI \"QI\") (VNx8HI \"QI\") (VNx16HI \"QI\") (VNx32HI \"QI\")\n+  (VNx1SI \"HI\") (VNx2SI \"HI\") (VNx4SI \"HI\") (VNx8SI \"HI\") (VNx16SI \"HI\")\n+  (VNx1DI \"SI\") (VNx2DI \"SI\") (VNx4DI \"SI\") (VNx8DI \"SI\")\n+  (VNx1SF \"HF\") (VNx2SF \"HF\") (VNx4SF \"HF\") (VNx8SF \"HF\") (VNx16SF \"HF\")\n+  (VNx1DF \"SF\") (VNx2DF \"SF\") (VNx4DF \"SF\") (VNx8DF \"SF\")\n+])\n+\n (define_mode_attr sew [\n   (VNx1QI \"8\") (VNx2QI \"8\") (VNx4QI \"8\") (VNx8QI \"8\") (VNx16QI \"8\") (VNx32QI \"8\") (VNx64QI \"8\")\n   (VNx1HI \"16\") (VNx2HI \"16\") (VNx4HI \"16\") (VNx8HI \"16\") (VNx16HI \"16\") (VNx32HI \"16\")\n@@ -172,8 +265,282 @@\n   (VNx1DF \"64\") (VNx2DF \"64\") (VNx4DF \"64\") (VNx8DF \"64\")\n ])\n \n+(define_mode_attr V_DOUBLE_TRUNC [\n+  (VNx1HI \"VNx1QI\") (VNx2HI \"VNx2QI\")  (VNx4HI \"VNx4QI\")  (VNx8HI \"VNx8QI\")  \n+  (VNx16HI \"VNx16QI\") (VNx32HI \"VNx32QI\")\n+  (VNx1SI \"VNx1HI\") (VNx2SI \"VNx2HI\") (VNx4SI \"VNx4HI\") (VNx8SI \"VNx8HI\") \n+  (VNx16SI \"VNx16HI\")\n+  (VNx1DI \"VNx1SI\") (VNx2DI \"VNx2SI\") (VNx4DI \"VNx4SI\") (VNx8DI \"VNx8SI\")\n+])\n+\n+(define_mode_attr V_QUAD_TRUNC [\n+  (VNx1SI \"VNx1QI\") (VNx2SI \"VNx2QI\") (VNx4SI \"VNx4QI\") (VNx8SI \"VNx8QI\") \n+  (VNx16SI \"VNx16QI\")\n+  (VNx1DI \"VNx1HI\") (VNx2DI \"VNx2HI\")\n+  (VNx4DI \"VNx4HI\") (VNx8DI \"VNx8HI\")\n+])\n+\n+(define_mode_attr V_OCT_TRUNC [\n+  (VNx1DI \"VNx1QI\") (VNx2DI \"VNx2QI\") (VNx4DI \"VNx4QI\") (VNx8DI \"VNx8QI\")\n+])\n+\n (define_int_iterator ORDER [UNSPEC_ORDERED UNSPEC_UNORDERED])\n \n+(define_int_iterator VMULH [UNSPEC_VMULHS UNSPEC_VMULHU UNSPEC_VMULHSU])\n+\n+(define_int_iterator VNCLIP [UNSPEC_VNCLIP UNSPEC_VNCLIPU])\n+\n+(define_int_iterator VSAT_OP [UNSPEC_VAADDU UNSPEC_VAADD\n+\t\t\t      UNSPEC_VASUBU UNSPEC_VASUB UNSPEC_VSMUL\n+\t\t\t      UNSPEC_VSSRL UNSPEC_VSSRA])\n+\n+(define_int_iterator VSAT_ARITH_OP [UNSPEC_VAADDU UNSPEC_VAADD\n+\t\t\t      \t    UNSPEC_VASUBU UNSPEC_VASUB UNSPEC_VSMUL])\n+(define_int_iterator VSAT_SHIFT_OP [UNSPEC_VSSRL UNSPEC_VSSRA])\n+\n+(define_int_iterator VMISC [UNSPEC_VMSBF UNSPEC_VMSIF UNSPEC_VMSOF])\n+\n (define_int_attr order [\n   (UNSPEC_ORDERED \"o\") (UNSPEC_UNORDERED \"u\")\n ])\n+\n+(define_int_attr v_su [(UNSPEC_VMULHS \"\") (UNSPEC_VMULHU \"u\") (UNSPEC_VMULHSU \"su\")\n+\t\t       (UNSPEC_VNCLIP \"\") (UNSPEC_VNCLIPU \"u\")])\n+(define_int_attr sat_op [(UNSPEC_VAADDU \"aaddu\") (UNSPEC_VAADD \"aadd\")\n+\t\t\t (UNSPEC_VASUBU \"asubu\") (UNSPEC_VASUB \"asub\")\n+\t\t\t (UNSPEC_VSMUL \"smul\") (UNSPEC_VSSRL \"ssrl\")\n+\t\t\t (UNSPEC_VSSRA \"ssra\")])\n+(define_int_attr sat_insn_type [(UNSPEC_VAADDU \"vaalu\") (UNSPEC_VAADD \"vaalu\")\n+\t\t\t \t(UNSPEC_VASUBU \"vaalu\") (UNSPEC_VASUB \"vaalu\")\n+\t\t\t \t(UNSPEC_VSMUL \"vsmul\") (UNSPEC_VSSRL \"vsshift\")\n+\t\t\t \t(UNSPEC_VSSRA \"vsshift\") (UNSPEC_VNCLIP \"vnclip\")\n+\t\t\t\t(UNSPEC_VNCLIPU \"vnclip\")])\n+\n+(define_int_attr misc_op [(UNSPEC_VMSBF \"sbf\") (UNSPEC_VMSIF \"sif\") (UNSPEC_VMSOF \"sof\")])\n+\n+(define_code_iterator any_int_binop [plus minus and ior xor ashift ashiftrt lshiftrt\n+  smax umax smin umin mult div udiv mod umod\n+])\n+\n+(define_code_iterator any_int_unop [neg not])\n+\n+(define_code_iterator any_commutative_binop [plus and ior xor\n+  smax umax smin umin mult\n+])\n+\n+(define_code_iterator any_non_commutative_binop [minus div udiv mod umod])\n+\n+(define_code_iterator any_sat_int_binop [ss_plus ss_minus us_plus us_minus])\n+(define_code_iterator sat_int_plus_binop [ss_plus us_plus])\n+(define_code_iterator sat_int_minus_binop [ss_minus us_minus])\n+\n+(define_code_iterator any_widen_binop [plus minus mult])\n+(define_code_iterator plus_minus [plus minus])\n+\n+(define_code_attr macc_nmsac [(plus \"macc\") (minus \"nmsac\")])\n+(define_code_attr madd_nmsub [(plus \"madd\") (minus \"nmsub\")])\n+\n+(define_code_iterator and_ior [and ior])\n+(define_code_attr ninsn [(and \"nand\") (ior \"nor\") (xor \"xnor\")])\n+\n+(define_code_attr binop_rhs1_predicate [\n+\t\t\t(plus \"register_operand\")\n+\t\t\t(minus \"vector_arith_operand\")\n+\t\t\t(ior \"register_operand\")\n+\t\t\t(xor \"register_operand\")\n+\t\t\t(and \"register_operand\")\n+\t\t\t(ashift \"register_operand\")\n+\t\t\t(ashiftrt \"register_operand\")\n+\t\t\t(lshiftrt \"register_operand\")\n+\t\t\t(smin \"register_operand\")\n+\t\t\t(smax \"register_operand\")\n+\t\t\t(umin \"register_operand\")\n+\t\t\t(umax \"register_operand\")\n+\t\t\t(mult \"register_operand\")\n+\t\t\t(div \"register_operand\")\n+\t\t\t(mod \"register_operand\")\n+\t\t\t(udiv \"register_operand\")\n+\t\t\t(umod \"register_operand\")\n+\t\t\t(ss_plus \"register_operand\")\n+\t\t\t(us_plus \"register_operand\")\n+\t\t\t(ss_minus \"register_operand\")\n+\t\t\t(us_minus \"register_operand\")])\n+\n+(define_code_attr binop_rhs2_predicate [\n+\t\t\t(plus \"vector_arith_operand\")\n+\t\t\t(minus \"vector_neg_arith_operand\")\n+\t\t\t(ior \"vector_arith_operand\")\n+\t\t\t(xor \"vector_arith_operand\")\n+\t\t\t(and \"vector_arith_operand\")\n+\t\t\t(ashift \"vector_shift_operand\")\n+\t\t\t(ashiftrt \"vector_shift_operand\")\n+\t\t\t(lshiftrt \"vector_shift_operand\")\n+\t\t\t(smin \"register_operand\")\n+\t\t\t(smax \"register_operand\")\n+\t\t\t(umin \"register_operand\")\n+\t\t\t(umax \"register_operand\")\n+\t\t\t(mult \"register_operand\")\n+\t\t\t(div \"register_operand\")\n+\t\t\t(mod \"register_operand\")\n+\t\t\t(udiv \"register_operand\")\n+\t\t\t(umod \"register_operand\")\n+\t\t\t(ss_plus \"vector_arith_operand\")\n+\t\t\t(us_plus \"vector_arith_operand\")\n+\t\t\t(ss_minus \"vector_neg_arith_operand\")\n+\t\t\t(us_minus \"register_operand\")])\n+\n+(define_code_attr binop_rhs1_constraint [\n+\t\t\t(plus \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(minus \"vr,vr,vr,vr,vi,vi\")\n+\t\t\t(ior \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(xor \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(and \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(ashift \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(ashiftrt \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(lshiftrt \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(smin \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(smax \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umin \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umax \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(mult \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(div \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(mod \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(udiv \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umod \"vr,vr,vr,vr,vr,vr\")])\n+\n+(define_code_attr binop_rhs2_constraint [\n+\t\t\t(plus \"vr,vr,vi,vi,vr,vr\")\n+\t\t\t(minus \"vr,vr,vj,vj,vr,vr\")\n+\t\t\t(ior \"vr,vr,vi,vi,vr,vr\")\n+\t\t\t(xor \"vr,vr,vi,vi,vr,vr\")\n+\t\t\t(and \"vr,vr,vi,vi,vr,vr\")\n+\t\t\t(ashift \"vr,vr,vk,vk,vr,vr\")\n+\t\t\t(ashiftrt \"vr,vr,vk,vk,vr,vr\")\n+\t\t\t(lshiftrt \"vr,vr,vk,vk,vr,vr\")\n+\t\t\t(smin \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(smax \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umin \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umax \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(mult \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(div \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(mod \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(udiv \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(umod \"vr,vr,vr,vr,vr,vr\")\n+\t\t\t(ss_plus \"vr,vr,vi,vi\")\n+\t\t\t(us_plus \"vr,vr,vi,vi\")\n+\t\t\t(ss_minus \"vr,vr,vj,vj\")\n+\t\t\t(us_minus \"vr,vr,vr,vr\")])\n+\n+(define_code_attr int_binop_insn_type [\n+\t\t\t(plus \"vialu\")\n+\t\t\t(minus \"vialu\")\n+\t\t\t(ior \"vialu\")\n+\t\t\t(xor \"vialu\")\n+\t\t\t(and \"vialu\")\n+\t\t\t(ashift \"vshift\")\n+\t\t\t(ashiftrt \"vshift\")\n+\t\t\t(lshiftrt \"vshift\")\n+\t\t\t(smin \"viminmax\")\n+\t\t\t(smax \"viminmax\")\n+\t\t\t(umin \"viminmax\")\n+\t\t\t(umax \"viminmax\")\n+\t\t\t(mult \"vimul\")\n+\t\t\t(div \"vidiv\")\n+\t\t\t(mod \"vidiv\")\n+\t\t\t(udiv \"vidiv\")\n+\t\t\t(umod \"vidiv\")\n+\t\t\t(ss_plus \"vsalu\")\n+\t\t\t(us_plus \"vsalu\")\n+\t\t\t(ss_minus \"vsalu\")\n+\t\t\t(us_minus \"vsalu\")])\n+\n+(define_code_attr widen_binop_insn_type [\n+\t\t\t(plus \"walu\")\n+\t\t\t(minus \"walu\")\n+\t\t\t(mult \"wmul\")])\n+\n+;; <binop_vi_variant_insn> expands to the insn name of binop matching constraint rhs1 is immediate.\n+;; minus is negated as vadd and ss_minus is negated as vsadd, others remain <insn>.\n+(define_code_attr binop_vi_variant_insn [(ashift \"sll.vi\")\n+\t\t\t       (ashiftrt \"sra.vi\")\n+\t\t\t       (lshiftrt \"srl.vi\")\n+\t\t\t       (div \"div.vv\")\n+\t\t\t       (mod \"rem.vv\")\n+\t\t\t       (udiv \"divu.vv\")\n+\t\t\t       (umod \"remu.vv\")\n+\t\t\t       (ior \"or.vi\")\n+\t\t\t       (xor \"xor.vi\")\n+\t\t\t       (and \"and.vi\")\n+\t\t\t       (plus \"add.vi\")\n+\t\t\t       (minus \"add.vi\")\n+\t\t\t       (smin \"min.vv\")\n+\t\t\t       (smax \"max.vv\")\n+\t\t\t       (umin \"minu.vv\")\n+\t\t\t       (umax \"maxu.vv\")\n+\t\t\t       (mult \"mul.vv\")\n+\t\t\t       (ss_plus \"sadd.vi\")\n+\t\t\t       (us_plus \"saddu.vi\")\n+\t\t\t       (ss_minus \"sadd.vi\")\n+\t\t\t       (us_minus \"ssubu.vv\")])\n+\n+;; <binop_reverse_vi_variant_insn> expands to the insn name of binop matching constraint rhs2 is immediate.\n+;; minus is reversed as vrsub, others remain <insn>.\n+(define_code_attr binop_reverse_vi_variant_insn [(ashift \"sll.vv\")\n+\t\t\t       (ashiftrt \"sra.vv\")\n+\t\t\t       (lshiftrt \"srl.vv\")\n+\t\t\t       (div \"div.vv\")\n+\t\t\t       (mod \"rem.vv\")\n+\t\t\t       (udiv \"divu.vv\")\n+\t\t\t       (umod \"remu.vv\")\n+\t\t\t       (ior \"or.vv\")\n+\t\t\t       (xor \"xor.vv\")\n+\t\t\t       (and \"and.vv\")\n+\t\t\t       (plus \"add.vv\")\n+\t\t\t       (minus \"rsub.vi\")\n+\t\t\t       (smin \"min.vv\")\n+\t\t\t       (smax \"max.vv\")\n+\t\t\t       (umin \"minu.vv\")\n+\t\t\t       (umax \"maxu.vv\")\n+\t\t\t       (mult \"mul.vv\")])\n+\n+(define_code_attr binop_vi_variant_op [(ashift \"%3,%v4\")\n+\t\t\t     (ashiftrt \"%3,%v4\")\n+\t\t\t     (lshiftrt \"%3,%v4\")\n+\t\t\t     (div \"%3,%4\")\n+\t\t\t     (mod \"%3,%4\")\n+\t\t\t     (udiv \"%3,%4\")\n+\t\t\t     (umod \"%3,%4\")\n+\t\t\t     (ior \"%3,%v4\")\n+\t\t\t     (xor \"%3,%v4\")\n+\t\t\t     (and \"%3,%v4\")\n+\t\t\t     (plus \"%3,%v4\")\n+\t\t\t     (minus \"%3,%V4\")\n+\t\t\t     (smin \"%3,%4\")\n+\t\t\t     (smax \"%3,%4\")\n+\t\t\t     (umin \"%3,%4\")\n+\t\t\t     (umax \"%3,%4\")\n+\t\t\t     (mult \"%3,%4\")\n+\t\t\t     (ss_plus \"%3,%v4\")\n+\t\t\t     (us_plus \"%3,%v4\")\n+\t\t\t     (ss_minus \"%3,%V4\")\n+\t\t\t     (us_minus \"%3,%4\")])\n+\n+(define_code_attr binop_reverse_vi_variant_op [(ashift \"%3,%4\")\n+\t\t\t      (ashiftrt \"%3,%4\")\n+\t\t\t      (lshiftrt \"%3,%4\")\n+\t\t\t      (div \"%3,%4\")\n+\t\t\t      (mod \"%3,%4\")\n+\t\t\t      (udiv \"%3,%4\")\n+\t\t\t      (umod \"%3,%4\")\n+\t\t\t      (ior \"%3,%4\")\n+\t\t\t      (xor \"%3,%4\")\n+\t\t\t      (and \"%3,%4\")\n+\t\t\t      (plus \"%3,%4\")\n+\t\t\t      (minus \"%4,%v3\")\n+\t\t\t      (smin \"%3,%4\")\n+\t\t\t      (smax \"%3,%4\")\n+\t\t\t      (umin \"%3,%4\")\n+\t\t\t      (umax \"%3,%4\")\n+\t\t\t      (mult \"%3,%4\")])\n+\n+(define_code_attr sz [(sign_extend \"s\") (zero_extend \"z\")])"}, {"sha": "c131738c75ff1bb8f4d9848aa333a569800e9660", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 3596, "deletions": 40, "changes": 3636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "162340b5581ac73d304fe3aba5d6c34249e525cc", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3226,25 +3226,40 @@\n   \"maddld %0,%1,%2,%3\"\n   [(set_attr \"type\" \"mul\")])\n \n-(define_expand \"<u>maddditi4\"\n+;; umaddditi4 generally needs maddhdu + maddld + add instructions,\n+;; unless last operand is zero extended from DImode, then needs\n+;; maddhdu + maddld, which is both faster than mulld + mulhdu + addc + adde\n+;; resp. mulld + mulhdu + addc + addze.\n+;; We don't define maddditi4, as that one needs\n+;; maddhd + sradi + maddld + add + sub and for last operand sign extended\n+;; from DImode nothing is able to optimize it into maddhd + maddld, while\n+;; without maddditi4 mulld + mulhd + addc + adde or\n+;; mulld + mulhd + sradi + addc + adde is needed.  See PR108787.\n+(define_expand \"umaddditi4\"\n   [(set (match_operand:TI 0 \"gpc_reg_operand\")\n \t(plus:TI\n-\t  (mult:TI (any_extend:TI (match_operand:DI 1 \"gpc_reg_operand\"))\n-\t\t   (any_extend:TI (match_operand:DI 2 \"gpc_reg_operand\")))\n-\t  (any_extend:TI (match_operand:DI 3 \"gpc_reg_operand\"))))]\n+\t  (mult:TI (zero_extend:TI (match_operand:DI 1 \"gpc_reg_operand\"))\n+\t\t   (zero_extend:TI (match_operand:DI 2 \"gpc_reg_operand\")))\n+\t  (match_operand:TI 3 \"gpc_reg_operand\")))]\n   \"TARGET_MADDLD && TARGET_POWERPC64\"\n {\n   rtx op0_lo = gen_rtx_SUBREG (DImode, operands[0], BYTES_BIG_ENDIAN ? 8 : 0);\n   rtx op0_hi = gen_rtx_SUBREG (DImode, operands[0], BYTES_BIG_ENDIAN ? 0 : 8);\n+  rtx op3_lo = gen_rtx_SUBREG (DImode, operands[3], BYTES_BIG_ENDIAN ? 8 : 0);\n+  rtx op3_hi = gen_rtx_SUBREG (DImode, operands[3], BYTES_BIG_ENDIAN ? 0 : 8);\n+  rtx hi_temp = gen_reg_rtx (DImode);\n \n-  emit_insn (gen_maddlddi4 (op0_lo, operands[1], operands[2], operands[3]));\n+  emit_insn (gen_maddlddi4 (op0_lo, operands[1], operands[2], op3_lo));\n \n   if (BYTES_BIG_ENDIAN)\n-    emit_insn (gen_<u>madddi4_highpart (op0_hi, operands[1], operands[2],\n-\t\t\t\t\toperands[3]));\n+    emit_insn (gen_umadddi4_highpart (hi_temp, operands[1], operands[2],\n+\t\t\t\t      op3_lo));\n   else\n-    emit_insn (gen_<u>madddi4_highpart_le (op0_hi, operands[1], operands[2],\n-\t\t\t\t\t   operands[3]));\n+    emit_insn (gen_umadddi4_highpart_le (hi_temp, operands[1], operands[2],\n+\t\t\t\t\t op3_lo));\n+\n+  emit_insn (gen_adddi3 (op0_hi, hi_temp, op3_hi));\n+\n   DONE;\n })\n "}, {"sha": "d5d5a7cc0d35992cf711fe024991dbcd62dd333d", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -479,9 +479,9 @@\n   if (icode < 0)\n     return false;\n \n-  extract_constrain_insn (insn);\n+  extract_insn (insn);\n \n-  return which_alternative >= 0;\n+  return constrain_operands (reload_completed, get_enabled_alternatives (insn)) == 1;\n })\n \n ;; Return true if OP is a store multiple operation.  It is known to be a"}, {"sha": "b66edf03f4730bec284107180bbe84c6b47054e3", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 195, "deletions": 118, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -411,6 +411,45 @@ struct s390_address\n #define FP_ARG_NUM_REG (TARGET_64BIT? 4 : 2)\n #define VEC_ARG_NUM_REG 8\n \n+/* Return TRUE if GPR REGNO is supposed to be restored in the function\n+   epilogue.  */\n+static inline bool\n+s390_restore_gpr_p (int regno)\n+{\n+  return (cfun_frame_layout.first_restore_gpr != -1\n+\t  && regno >= cfun_frame_layout.first_restore_gpr\n+\t  && regno <= cfun_frame_layout.last_restore_gpr);\n+}\n+\n+/* Return TRUE if any of the registers in range [FIRST, LAST] is saved\n+   because of -mpreserve-args.  */\n+static inline bool\n+s390_preserve_gpr_arg_in_range_p (int first, int last)\n+{\n+  int num_arg_regs = MIN (crtl->args.info.gprs + cfun->va_list_gpr_size,\n+\t\t\t  GP_ARG_NUM_REG);\n+  return (num_arg_regs\n+\t  && s390_preserve_args_p\n+\t  && first <= GPR2_REGNUM + num_arg_regs - 1\n+\t  && last >= GPR2_REGNUM);\n+}\n+\n+static inline bool\n+s390_preserve_gpr_arg_p (int regno)\n+{\n+  return s390_preserve_gpr_arg_in_range_p (regno, regno);\n+}\n+\n+static inline bool\n+s390_preserve_fpr_arg_p (int regno)\n+{\n+  int num_arg_regs = MIN (crtl->args.info.fprs + cfun->va_list_fpr_size,\n+\t\t\t  FP_ARG_NUM_REG);\n+  return (s390_preserve_args_p\n+\t  && regno <= FPR0_REGNUM + num_arg_regs - 1\n+\t  && regno >= FPR0_REGNUM);\n+}\n+\n /* A couple of shortcuts.  */\n #define CONST_OK_FOR_J(x) \\\n \tCONST_OK_FOR_CONSTRAINT_P((x), 'J', \"J\")\n@@ -9893,61 +9932,89 @@ s390_register_info_gprtofpr ()\n }\n \n /* Set the bits in fpr_bitmap for FPRs which need to be saved due to\n-   stdarg.\n+   stdarg or -mpreserve-args.\n    This is a helper routine for s390_register_info.  */\n-\n static void\n-s390_register_info_stdarg_fpr ()\n+s390_register_info_arg_fpr ()\n {\n   int i;\n-  int min_fpr;\n-  int max_fpr;\n+  int min_stdarg_fpr = INT_MAX, max_stdarg_fpr = -1;\n+  int min_preserve_fpr = INT_MAX, max_preserve_fpr = -1;\n+  int min_fpr, max_fpr;\n \n   /* Save the FP argument regs for stdarg. f0, f2 for 31 bit and\n      f0-f4 for 64 bit.  */\n-  if (!cfun->stdarg\n-      || !TARGET_HARD_FLOAT\n-      || !cfun->va_list_fpr_size\n-      || crtl->args.info.fprs >= FP_ARG_NUM_REG)\n-    return;\n+  if (cfun->stdarg\n+      && TARGET_HARD_FLOAT\n+      && cfun->va_list_fpr_size\n+      && crtl->args.info.fprs < FP_ARG_NUM_REG)\n+    {\n+      min_stdarg_fpr = crtl->args.info.fprs;\n+      max_stdarg_fpr = min_stdarg_fpr + cfun->va_list_fpr_size - 1;\n+      if (max_stdarg_fpr >= FP_ARG_NUM_REG)\n+\tmax_stdarg_fpr = FP_ARG_NUM_REG - 1;\n+\n+      /* FPR argument regs start at f0.  */\n+      min_stdarg_fpr += FPR0_REGNUM;\n+      max_stdarg_fpr += FPR0_REGNUM;\n+    }\n+\n+  if (s390_preserve_args_p && crtl->args.info.fprs)\n+    {\n+      min_preserve_fpr = FPR0_REGNUM;\n+      max_preserve_fpr = MIN (FPR0_REGNUM + FP_ARG_NUM_REG - 1,\n+\t\t\t      FPR0_REGNUM + crtl->args.info.fprs - 1);\n+    }\n \n-  min_fpr = crtl->args.info.fprs;\n-  max_fpr = min_fpr + cfun->va_list_fpr_size - 1;\n-  if (max_fpr >= FP_ARG_NUM_REG)\n-    max_fpr = FP_ARG_NUM_REG - 1;\n+  min_fpr = MIN (min_stdarg_fpr, min_preserve_fpr);\n+  max_fpr = MAX (max_stdarg_fpr, max_preserve_fpr);\n \n-  /* FPR argument regs start at f0.  */\n-  min_fpr += FPR0_REGNUM;\n-  max_fpr += FPR0_REGNUM;\n+  if (max_fpr == -1)\n+    return;\n \n   for (i = min_fpr; i <= max_fpr; i++)\n     cfun_set_fpr_save (i);\n }\n \n+\n /* Reserve the GPR save slots for GPRs which need to be saved due to\n-   stdarg.\n+   stdarg or -mpreserve-args.\n    This is a helper routine for s390_register_info.  */\n \n static void\n-s390_register_info_stdarg_gpr ()\n+s390_register_info_arg_gpr ()\n {\n   int i;\n-  int min_gpr;\n-  int max_gpr;\n+  int min_stdarg_gpr = INT_MAX, max_stdarg_gpr = -1;\n+  int min_preserve_gpr = INT_MAX, max_preserve_gpr = -1;\n+  int min_gpr, max_gpr;\n \n-  if (!cfun->stdarg\n-      || !cfun->va_list_gpr_size\n-      || crtl->args.info.gprs >= GP_ARG_NUM_REG)\n-    return;\n+  if (cfun->stdarg\n+      && cfun->va_list_gpr_size\n+      && crtl->args.info.gprs < GP_ARG_NUM_REG)\n+    {\n+      min_stdarg_gpr = crtl->args.info.gprs;\n+      max_stdarg_gpr = min_stdarg_gpr + cfun->va_list_gpr_size - 1;\n+      if (max_stdarg_gpr >= GP_ARG_NUM_REG)\n+\tmax_stdarg_gpr = GP_ARG_NUM_REG - 1;\n+\n+      /* GPR argument regs start at r2.  */\n+      min_stdarg_gpr += GPR2_REGNUM;\n+      max_stdarg_gpr += GPR2_REGNUM;\n+    }\n+\n+  if (s390_preserve_args_p && crtl->args.info.gprs)\n+    {\n+      min_preserve_gpr = GPR2_REGNUM;\n+      max_preserve_gpr = MIN (GPR6_REGNUM,\n+\t\t\t      GPR2_REGNUM + crtl->args.info.gprs - 1);\n+    }\n \n-  min_gpr = crtl->args.info.gprs;\n-  max_gpr = min_gpr + cfun->va_list_gpr_size - 1;\n-  if (max_gpr >= GP_ARG_NUM_REG)\n-    max_gpr = GP_ARG_NUM_REG - 1;\n+  min_gpr = MIN (min_stdarg_gpr, min_preserve_gpr);\n+  max_gpr = MAX (max_stdarg_gpr, max_preserve_gpr);\n \n-  /* GPR argument regs start at r2.  */\n-  min_gpr += GPR2_REGNUM;\n-  max_gpr += GPR2_REGNUM;\n+  if (max_gpr == -1)\n+    return;\n \n   /* If r6 was supposed to be saved into an FPR and now needs to go to\n      the stack for vararg we have to adjust the restore range to make\n@@ -10079,14 +10146,14 @@ s390_register_info ()\n     if (clobbered_regs[i] && !call_used_regs[i])\n       cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;\n \n-  s390_register_info_stdarg_fpr ();\n+  s390_register_info_arg_fpr ();\n   s390_register_info_gprtofpr ();\n   s390_register_info_set_ranges ();\n-  /* stdarg functions might need to save GPRs 2 to 6.  This might\n-     override the GPR->FPR save decision made by\n-     s390_register_info_gprtofpr for r6 since vararg regs must go to\n-     the stack.  */\n-  s390_register_info_stdarg_gpr ();\n+\n+  /* Forcing argument registers to be saved on the stack might\n+     override the GPR->FPR save decision for r6 so this must come\n+     last.  */\n+  s390_register_info_arg_gpr ();\n }\n \n /* Return true if REGNO is a global register, but not one\n@@ -10141,7 +10208,7 @@ s390_optimize_register_info ()\n       cfun_gpr_save_slot (i) = SAVE_SLOT_NONE;\n \n   s390_register_info_set_ranges ();\n-  s390_register_info_stdarg_gpr ();\n+  s390_register_info_arg_gpr ();\n }\n \n /* Fill cfun->machine with info about frame of current function.  */\n@@ -10864,14 +10931,28 @@ static rtx\n save_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n+  rtx insn;\n+\n   addr = gen_rtx_MEM (DFmode, plus_constant (Pmode, base, offset));\n \n-  if (regnum >= 16 && regnum <= (16 + FP_ARG_NUM_REG))\n+  if (regnum >= FPR0_REGNUM && regnum <= (FPR0_REGNUM + FP_ARG_NUM_REG))\n     set_mem_alias_set (addr, get_varargs_alias_set ());\n   else\n     set_mem_alias_set (addr, get_frame_alias_set ());\n \n-  return emit_move_insn (addr, gen_rtx_REG (DFmode, regnum));\n+  insn = emit_move_insn (addr, gen_rtx_REG (DFmode, regnum));\n+\n+  if (!call_used_regs[regnum] || s390_preserve_fpr_arg_p (regnum))\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (s390_preserve_fpr_arg_p (regnum) && !cfun_fpr_save_p (regnum))\n+    {\n+      rtx reg = gen_rtx_REG (DFmode, regnum);\n+      add_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+      add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (addr, reg));\n+    }\n+\n+  return insn;\n }\n \n /* Emit insn to restore fpr REGNUM from offset OFFSET relative\n@@ -10891,16 +10972,15 @@ restore_fpr (rtx base, int offset, int regnum)\n    the register save area located at offset OFFSET\n    relative to register BASE.  */\n \n-static rtx\n-save_gprs (rtx base, int offset, int first, int last)\n+static void\n+save_gprs (rtx base, int offset, int first, int last, rtx_insn *before = NULL)\n {\n   rtx addr, insn, note;\n+  rtx_insn *out_insn;\n   int i;\n \n   addr = plus_constant (Pmode, base, offset);\n-  addr = gen_rtx_MEM (Pmode, addr);\n-\n-  set_mem_alias_set (addr, get_frame_alias_set ());\n+  addr = gen_frame_mem (Pmode, addr);\n \n   /* Special-case single register.  */\n   if (first == last)\n@@ -10912,7 +10992,15 @@ save_gprs (rtx base, int offset, int first, int last)\n \n       if (!global_not_special_regno_p (first))\n \tRTX_FRAME_RELATED_P (insn) = 1;\n-      return insn;\n+\n+      if (s390_preserve_gpr_arg_p (first) && !s390_restore_gpr_p (first))\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, first);\n+\t  add_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+\t  add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (addr, reg));\n+\t}\n+\n+      goto emit;\n     }\n \n \n@@ -10941,7 +11029,12 @@ save_gprs (rtx base, int offset, int first, int last)\n      set, even if it does not.  Therefore we emit a new pattern\n      without those registers as REG_FRAME_RELATED_EXPR note.  */\n \n-  if (first >= 6 && !global_not_special_regno_p (first))\n+  /* In these cases all of the sets are marked as frame related:\n+     1. call-save GPR saved and restored\n+     2. argument GPR saved because of -mpreserve-args */\n+  if ((first >= GPR6_REGNUM && !global_not_special_regno_p (first))\n+      || s390_preserve_gpr_arg_in_range_p (first, last))\n+\n     {\n       rtx pat = PATTERN (insn);\n \n@@ -10952,6 +11045,24 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* For the -mpreserve-args register saves no restore operations\n+\t will be emitted. CFI checking would complain about this. We\n+\t manually generate the REG_CFA notes here to be able to mark\n+\t those operations with REG_CFA_NO_RESTORE.  */\n+      if (s390_preserve_gpr_arg_in_range_p (first, last))\n+\t{\n+\t  for (int regno = first; regno <= last; regno++)\n+\t    {\n+\t      rtx reg = gen_rtx_REG (Pmode, regno);\n+\t      rtx reg_addr = plus_constant (Pmode, base,\n+\t\t\t\t\t    offset + (regno - first) * UNITS_PER_LONG);\n+\t      if (!s390_restore_gpr_p (regno))\n+\t\tadd_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+\t      add_reg_note (insn, REG_CFA_OFFSET,\n+\t\t\t    gen_rtx_SET (gen_frame_mem (Pmode, reg_addr), reg));\n+\t    }\n+\t}\n     }\n   else if (last >= 6)\n     {\n@@ -10962,7 +11073,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  break;\n \n       if (start > last)\n-\treturn insn;\n+\tgoto emit;\n \n       addr = plus_constant (Pmode, base,\n \t\t\t    offset + (start - first) * UNITS_PER_LONG);\n@@ -10980,7 +11091,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n-\t  return insn;\n+\t  goto emit;\n \t}\n \n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n@@ -10999,9 +11110,15 @@ save_gprs (rtx base, int offset, int first, int last)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  return insn;\n+ emit:\n+  if (before != NULL_RTX)\n+    out_insn = emit_insn_before (insn, before);\n+  else\n+    out_insn = emit_insn (insn);\n+  INSN_ADDRESSES_NEW (out_insn, -1);\n }\n \n+\n /* Generate insn to restore registers FIRST to LAST from\n    the register save area located at offset OFFSET\n    relative to register BASE.  */\n@@ -11012,8 +11129,7 @@ restore_gprs (rtx base, int offset, int first, int last)\n   rtx addr, insn;\n \n   addr = plus_constant (Pmode, base, offset);\n-  addr = gen_rtx_MEM (Pmode, addr);\n-  set_mem_alias_set (addr, get_frame_alias_set ());\n+  addr = gen_frame_mem (Pmode, addr);\n \n   /* Special-case single register.  */\n   if (first == last)\n@@ -11062,10 +11178,11 @@ s390_load_got (void)\n static void\n s390_emit_stack_tie (void)\n {\n-  rtx mem = gen_frame_mem (BLKmode,\n-\t\t\t   gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));\n-\n-  emit_insn (gen_stack_tie (mem));\n+  rtx mem = gen_frame_mem (BLKmode, stack_pointer_rtx);\n+  if (frame_pointer_needed)\n+    emit_insn (gen_stack_tie (Pmode, mem, hard_frame_pointer_rtx));\n+  else\n+    emit_insn (gen_stack_tie (Pmode, mem, stack_pointer_rtx));\n }\n \n /* Copy GPRS into FPR save slots.  */\n@@ -11425,21 +11542,19 @@ s390_emit_prologue (void)\n   /* Save call saved gprs.  */\n   if (cfun_frame_layout.first_save_gpr != -1)\n     {\n-      insn = save_gprs (stack_pointer_rtx,\n-\t\t\tcfun_frame_layout.gprs_offset +\n-\t\t\tUNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n-\t\t\tcfun_frame_layout.first_save_gpr,\n-\t\t\tcfun_frame_layout.last_save_gpr);\n+      save_gprs (stack_pointer_rtx,\n+\t\t cfun_frame_layout.gprs_offset +\n+\t\t UNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n+\t\t\t\t   - cfun_frame_layout.first_save_gpr_slot),\n+\t\t cfun_frame_layout.first_save_gpr,\n+\t\t cfun_frame_layout.last_save_gpr);\n \n       /* This is not 100% correct.  If we have more than one register saved,\n \t then LAST_PROBE_OFFSET can move even closer to sp.  */\n       last_probe_offset\n \t= (cfun_frame_layout.gprs_offset +\n \t   UNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n \t\t\t     - cfun_frame_layout.first_save_gpr_slot));\n-\n-      emit_insn (insn);\n     }\n \n   /* Dummy insn to mark literal pool slot.  */\n@@ -11469,15 +11584,10 @@ s390_emit_prologue (void)\n     {\n       if (cfun_fpr_save_p (i))\n \t{\n-\t  insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t  save_fpr (stack_pointer_rtx, offset, i);\n \t  if (offset < last_probe_offset)\n \t    last_probe_offset = offset;\n \t  offset += 8;\n-\n-\t  /* If f4 and f6 are call clobbered they are saved due to\n-\t     stdargs and therefore are not frame related.  */\n-\t  if (!call_used_regs[i])\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (!TARGET_PACKED_STACK || call_used_regs[i])\n \toffset += 8;\n@@ -11493,11 +11603,10 @@ s390_emit_prologue (void)\n       for (i = FPR15_REGNUM; i >= FPR8_REGNUM && offset >= 0; i--)\n \tif (cfun_fpr_save_p (i))\n \t  {\n-\t    insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t    save_fpr (stack_pointer_rtx, offset, i);\n \t    if (offset < last_probe_offset)\n \t      last_probe_offset = offset;\n \n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    offset -= 8;\n \t  }\n       if (offset >= cfun_frame_layout.f8_offset)\n@@ -11665,7 +11774,6 @@ s390_emit_prologue (void)\n \n \t    insn = save_fpr (temp_reg, offset, i);\n \t    offset += 8;\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\t  gen_rtx_SET (gen_rtx_MEM (DFmode, addr),\n \t\t\t\t       gen_rtx_REG (DFmode, i)));\n@@ -11676,6 +11784,7 @@ s390_emit_prologue (void)\n \n   if (frame_pointer_needed)\n     {\n+      s390_emit_stack_tie ();\n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n@@ -14159,15 +14268,11 @@ s390_optimize_prologue (void)\n \t    continue;\n \n \t  if (cfun_frame_layout.first_save_gpr != -1)\n-\t    {\n-\t      rtx s_pat = save_gprs (base,\n-\t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t    - first) * UNITS_PER_LONG,\n-\t\t\t\t     cfun_frame_layout.first_save_gpr,\n-\t\t\t\t     cfun_frame_layout.last_save_gpr);\n-\t      new_insn = emit_insn_before (s_pat, insn);\n-\t      INSN_ADDRESSES_NEW (new_insn, -1);\n-\t    }\n+\t    save_gprs (base,\n+\t\t       off + (cfun_frame_layout.first_save_gpr\n+\t\t\t      - first) * UNITS_PER_LONG,\n+\t\t       cfun_frame_layout.first_save_gpr,\n+\t\t       cfun_frame_layout.last_save_gpr, insn);\n \n \t  remove_insn (insn);\n \t  continue;\n@@ -14872,29 +14977,6 @@ s390_z10_prevent_earlyload_conflicts (rtx_insn **ready, int *nready_p)\n   ready[0] = tmp;\n }\n \n-/* Returns TRUE if BB is entered via a fallthru edge and all other\n-   incoming edges are less than likely.  */\n-static bool\n-s390_bb_fallthru_entry_likely (basic_block bb)\n-{\n-  edge e, fallthru_edge;\n-  edge_iterator ei;\n-\n-  if (!bb)\n-    return false;\n-\n-  fallthru_edge = find_fallthru_edge (bb->preds);\n-  if (!fallthru_edge)\n-    return false;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e != fallthru_edge\n-\t&& e->probability >= profile_probability::likely ())\n-      return false;\n-\n-  return true;\n-}\n-\n struct s390_sched_state\n {\n   /* Number of insns in the group.  */\n@@ -14905,7 +14987,7 @@ struct s390_sched_state\n   bool group_of_two;\n } s390_sched_state;\n \n-static struct s390_sched_state sched_state = {0, 1, false};\n+static struct s390_sched_state sched_state;\n \n #define S390_SCHED_ATTR_MASK_CRACKED    0x1\n #define S390_SCHED_ATTR_MASK_EXPANDED   0x2\n@@ -15405,7 +15487,7 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)\n \n \t      s390_get_unit_mask (insn, &units);\n \n-\t      fprintf (file, \";;\\t\\tBACKEND: units on this side unused for: \");\n+\t      fprintf (file, \";;\\t\\tBACKEND: units on this side (%d) unused for: \", sched_state.side);\n \t      for (j = 0; j < units; j++)\n \t\tfprintf (file, \"%d:%d \", j,\n \t\t    last_scheduled_unit_distance[j][sched_state.side]);\n@@ -15443,17 +15525,12 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n      current_sched_info->prev_head is the insn before the first insn of the\n      block of insns to be scheduled.\n      */\n-  rtx_insn *insn = current_sched_info->prev_head\n-    ? NEXT_INSN (current_sched_info->prev_head) : NULL;\n-  basic_block bb = insn ? BLOCK_FOR_INSN (insn) : NULL;\n-  if (s390_tune < PROCESSOR_2964_Z13 || !s390_bb_fallthru_entry_likely (bb))\n-    {\n-      last_scheduled_insn = NULL;\n-      memset (last_scheduled_unit_distance, 0,\n+  last_scheduled_insn = NULL;\n+  memset (last_scheduled_unit_distance, 0,\n \t  MAX_SCHED_UNITS * NUM_SIDES * sizeof (int));\n-      sched_state.group_state = 0;\n-      sched_state.group_of_two = false;\n-    }\n+  memset (fpd_longrunning, 0, NUM_SIDES * sizeof (int));\n+  memset (fxd_longrunning, 0, NUM_SIDES * sizeof (int));\n+  sched_state = {};\n }\n \n /* This target hook implementation for TARGET_LOOP_UNROLL_ADJUST calculates"}, {"sha": "00d39608e1d77946e64b002a89721ad8ec5d92fe", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -11590,9 +11590,10 @@\n ; This is used in s390_emit_prologue in order to prevent insns\n ; adjusting the stack pointer to be moved over insns writing stack\n ; slots using a copy of the stack pointer in a different register.\n-(define_insn \"stack_tie\"\n+(define_insn \"@stack_tie<mode>\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"+m\")\n-        (unspec:BLK [(match_dup 0)] UNSPEC_TIE))]\n+        (unspec:BLK [(match_dup 0)\n+\t\t     (match_operand:P 1 \"register_operand\" \"r\")] UNSPEC_TIE))]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])"}, {"sha": "344aa551f442e7bf4741a09e78651a431b8f247d", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -325,3 +325,7 @@ purposes.\n munroll-only-small-loops\n Target Undocumented Var(unroll_only_small_loops) Init(0) Save\n ; Use conservative small loop unrolling.\n+\n+mpreserve-args\n+Target Var(s390_preserve_args_p) Init(0)\n+Store all argument registers on the stack."}, {"sha": "148276bff270c718de04762534be4a8d93aeea88", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,128 @@\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107773\n+\t* cp-tree.h (enum tsubst_flags): New flag tf_qualifying_scope.\n+\t* decl.cc (make_typename_type): Use lookup_member instead of\n+\tlookup_field.  If tf_qualifying_scope is set, pass want_type=true\n+\tinstead of =false to lookup_member.  Generalize format specifier\n+\tin diagnostic to handle both type and non-type bindings.\n+\t* pt.cc (tsubst_aggr_type_1): Clear tf_qualifying_scope.  Tidy\n+\tthe function.\n+\t(tsubst_decl) <case USING_DECL>: Set tf_qualifying_scope when\n+\tsubstituting USING_DECL_SCOPE.\n+\t(tsubst): Clear tf_qualifying_scope right away and remember if\n+\tit was set.  Do the same for tf_tst_ok sooner.\n+\t<case TYPENAME_TYPE>: Set tf_qualifying_scope when substituting\n+\tTYPE_CONTEXT.  Pass tf_qualifying_scope to make_typename_type\n+\tif it was set.\n+\t(tsubst_qualified_id): Set tf_qualifying_scope when substituting\n+\tthe scope.\n+\t(tsubst_copy): Clear tf_qualifying_scope and remember if it was\n+\tset.\n+\t<case SCOPE_REF>: Set tf_qualifying_scope when substituting the\n+\tscope.\n+\t<case *_TYPE>: Pass tf_qualifying_scope to tsubst if it was set.\n+\t* search.cc (lookup_member): Document default argument.\n+\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* cp-tree.h: Mechanically drop static from static inline\n+\tfunctions via s/^static inline/inline/g.\n+\n+2023-02-15  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106675\n+\t* call.cc (joust_maybe_elide_copy): Return false for ck_ambig.\n+\n+2023-02-10  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107079\n+\t* call.cc (set_up_extended_ref_temp): Pass var to maybe_constant_init.\n+\n+2023-02-09  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* parser.cc (cp_parser_omp_allocate): Parse align\n+\tclause and check for restrictions.\n+\n+2023-02-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108698\n+\t* mangle.cc (write_expression, write_template_arg): Handle\n+\tEXCESS_PRECISION_EXPR with REAL_CST operand as\n+\twrite_template_arg_literal on fold_convert of the REAL_CST\n+\tto EXCESS_PRECISION_EXPR type.\n+\n+2023-02-06  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107461\n+\t* cp-tree.h (call_expr_dependent_name): Declare.\n+\t* pt.cc (iterative_hash_template_arg) <case CALL_EXPR>: Use\n+\tcall_expr_dependent_name instead of dependent_name.\n+\t* tree.cc (call_expr_dependent_name): Define.\n+\t(called_fns_equal): Adjust to take two CALL_EXPRs instead of\n+\tCALL_EXPR_FNs thereof.  Use call_expr_dependent_name instead\n+\tof dependent_name.\n+\t(cp_tree_equal) <case CALL_EXPR>: Adjust call to called_fns_equal.\n+\n+2023-02-03  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/108158\n+\t* constexpr.cc (cxx_eval_array_reference): Don't replace\n+\tnew_ctx.object.\n+\n+2023-02-03  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107461\n+\t* semantics.cc (finish_call_expr): Strip ADDR_EXPR from\n+\tthe selected callee during overload set pruning.\n+\n+2023-02-03  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/96745\n+\t* class.cc (check_methods): Diagnose an unviable OVERLOAD\n+\tset for CLASSTYPE_DESTRUCTOR differently from an ambiguous one.\n+\tThen prune the OVERLOAD to a single function.\n+\t(check_bases_and_members): Handle CLASSTYPE_DESTRUCTOR being\n+\tan OVERLOAD when calling deduce_noexcept_on_destructor.\n+\tDocument why it has to be called before check_methods.\n+\n+2023-02-03  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/108579\n+\t* class.cc (check_methods): Swap order of constraints_satisfied_p\n+\tand copy/move_fn_p tests.\n+\n+2023-02-01  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107755\n+\t* call.cc (build_new_op): Don't call warn_logical_operator when\n+\tprocessing a template.\n+\n+2023-02-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108607\n+\t* constexpr.cc (cxx_eval_constant_expression): Handle OMP_*\n+\tand OACC_* constructs as non-constant.\n+\t(potential_constant_expression_1): Handle OMP_SCAN and OMP_SCOPE.\n+\n+2023-02-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* class.cc (note_name_declared_in_class): Change from permerror to\n+\t-Wchanges-meaning pedwarn, forcing -pedantic-errors for most cases.\n+\n+2023-01-31  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108559\n+\t* cp-gimplify.cc (any_non_eliding_target_exprs): New.\n+\t(cp_genericize_init): Check it.\n+\n+2023-01-31  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107593\n+\tPR c++/108597\n+\t* cp-tree.h (instantiation_dependent_expression_p): Don't\n+\tdeclare here.\n+\n 2023-01-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/105300"}, {"sha": "048b2b052f8fd760493a838d5f9a1aa4de2dee22", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -7335,7 +7335,7 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n-      if (complain & tf_warning)\n+      if ((complain & tf_warning) && !processing_template_decl)\n \twarn_logical_operator (loc, code, boolean_type_node,\n \t\t\t       code_orig_arg1, arg1,\n \t\t\t       code_orig_arg2, arg2);\n@@ -12542,6 +12542,8 @@ joust_maybe_elide_copy (z_candidate *&cand)\n   if (!DECL_COPY_CONSTRUCTOR_P (fn) && !DECL_MOVE_CONSTRUCTOR_P (fn))\n     return false;\n   conversion *conv = cand->convs[0];\n+  if (conv->kind == ck_ambig)\n+    return false;\n   gcc_checking_assert (conv->kind == ck_ref_bind);\n   conv = next_conversion (conv);\n   if (conv->kind == ck_user && !TYPE_REF_P (conv->type))\n@@ -13583,7 +13585,7 @@ set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,\n \n   /* If the initializer is constant, put it in DECL_INITIAL so we get\n      static initialization and use in constant expressions.  */\n-  init = maybe_constant_init (expr);\n+  init = maybe_constant_init (expr, var, /*manifestly_const_eval=*/true);\n   /* As in store_init_value.  */\n   init = cp_fully_fold (init);\n   if (TREE_CONSTANT (init))"}, {"sha": "27a798297372eb1543122157228386b59373c3e0", "filename": "gcc/cp/class.cc", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4808,9 +4808,23 @@ check_methods (tree t)\n \t     in that class with an empty argument list to select the destructor\n \t     for the class, also known as the selected destructor. The program\n \t     is ill-formed if overload resolution fails. */\n+\t  int viable = 0;\n+\t  for (tree fn : ovl_range (dtor))\n+\t    if (constraints_satisfied_p (fn))\n+\t      ++viable;\n+\t  gcc_checking_assert (viable != 1);\n+\n \t  auto_diagnostic_group d;\n-\t  error_at (location_of (t), \"destructor for %qT is ambiguous\", t);\n+\t  if (viable == 0)\n+\t    error_at (location_of (t), \"no viable destructor for %qT\", t);\n+\t  else\n+\t    error_at (location_of (t), \"destructor for %qT is ambiguous\", t);\n \t  print_candidates (dtor);\n+\n+\t  /* Arbitrarily prune the overload set to a single function for\n+\t     sake of error recovery.  */\n+\t  tree *slot = find_member_slot (t, dtor_identifier);\n+\t  *slot = get_first_fn (dtor);\n \t}\n       else if (user_provided_p (dtor))\n \tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = true;\n@@ -4822,11 +4836,11 @@ check_methods (tree t)\n \t/* Might be trivial.  */;\n       else if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t/* Templates are never special members.  */;\n-      else if (!constraints_satisfied_p (fn))\n-\t/* Not eligible.  */;\n-      else if (copy_fn_p (fn))\n+      else if (copy_fn_p (fn)\n+\t       && constraints_satisfied_p (fn))\n \tTYPE_HAS_COMPLEX_COPY_CTOR (t) = true;\n-      else if (move_fn_p (fn))\n+      else if (move_fn_p (fn)\n+\t       && constraints_satisfied_p (fn))\n \tTYPE_HAS_COMPLEX_MOVE_CTOR (t) = true;\n     }\n \n@@ -4836,11 +4850,11 @@ check_methods (tree t)\n \t/* Might be trivial.  */;\n       else if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t/* Templates are never special members.  */;\n-      else if (!constraints_satisfied_p (fn))\n-\t/* Not eligible.  */;\n-      else if (copy_fn_p (fn))\n+      else if (copy_fn_p (fn)\n+\t       && constraints_satisfied_p (fn))\n \tTYPE_HAS_COMPLEX_COPY_ASSIGN (t) = true;\n-      else if (move_fn_p (fn))\n+      else if (move_fn_p (fn)\n+\t       && constraints_satisfied_p (fn))\n \tTYPE_HAS_COMPLEX_MOVE_ASSIGN (t) = true;\n     }\n }\n@@ -6048,10 +6062,12 @@ check_bases_and_members (tree t)\n   check_bases (t, &cant_have_const_ctor, &no_const_asn_ref);\n \n   /* Deduce noexcept on destructor.  This needs to happen after we've set\n-     triviality flags appropriately for our bases.  */\n+     triviality flags appropriately for our bases, and before checking\n+     overriden virtual functions via check_methods.  */\n   if (cxx_dialect >= cxx11)\n     if (tree dtor = CLASSTYPE_DESTRUCTOR (t))\n-      deduce_noexcept_on_destructor (dtor);\n+      for (tree fn : ovl_range (dtor))\n+\tdeduce_noexcept_on_destructor (fn);\n \n   /* Check all the method declarations.  */\n   check_methods (t);\n@@ -9016,7 +9032,7 @@ note_name_declared_in_class (tree name, tree decl)\n     return;\n   /* The C language allows members to be declared with a type of the same\n      name, and the C++ standard says this diagnostic is not required.  So\n-     allow it in extern \"C\" blocks unless predantic is specified.\n+     allow it in extern \"C\" blocks unless pedantic is specified.\n      Allow it in all cases if -ms-extensions is specified.  */\n   if ((!pedantic && current_lang_name == lang_name_c)\n       || flag_ms_extensions)\n@@ -9032,9 +9048,19 @@ note_name_declared_in_class (tree name, tree decl)\n \t A name N used in a class S shall refer to the same declaration\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n-      if (permerror (location_of (decl),\n-\t\t     \"declaration of %q#D changes meaning of %qD\",\n-\t\t     decl, OVL_NAME (decl)))\n+      auto ov = make_temp_override (global_dc->pedantic_errors);\n+      if (TREE_CODE (decl) == TYPE_DECL\n+\t  && TREE_CODE (olddecl) == TYPE_DECL\n+\t  && same_type_p (TREE_TYPE (decl), TREE_TYPE (olddecl)))\n+\t/* Different declaration, but same meaning; just warn.  */;\n+      else if (flag_permissive)\n+\t/* Let -fpermissive make it a warning like past versions.  */;\n+      else\n+\t/* Make it an error.  */\n+\tglobal_dc->pedantic_errors = 1;\n+      if (pedwarn (location_of (decl), OPT_Wchanges_meaning,\n+\t\t   \"declaration of %q#D changes meaning of %qD\",\n+\t\t   decl, OVL_NAME (decl)))\n \t{\n \t  inform (loc, \"used here to mean %q#D\", olddecl);\n \t  inform (location_of (olddecl), \"declared here\" );"}, {"sha": "aa2c14355f827cf9a5f60eaad0b19023dffc5059", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 79, "deletions": 31, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1119,8 +1119,8 @@ struct GTY((for_user)) constexpr_call {\n   /* The hash of this call; we remember it here to avoid having to\n      recalculate it when expanding the hash table.  */\n   hashval_t hash;\n-  /* Whether __builtin_is_constant_evaluated() should evaluate to true.  */\n-  bool manifestly_const_eval;\n+  /* The value of constexpr_ctx::manifestly_const_eval.  */\n+  enum mce_value manifestly_const_eval;\n };\n \n struct constexpr_call_hasher : ggc_ptr_hash<constexpr_call>\n@@ -1248,7 +1248,7 @@ struct constexpr_ctx {\n      trying harder to get a constant value.  */\n   bool strict;\n   /* Whether __builtin_is_constant_evaluated () should be true.  */\n-  bool manifestly_const_eval;\n+  mce_value manifestly_const_eval;\n };\n \n /* This internal flag controls whether we should avoid doing anything during\n@@ -1463,7 +1463,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   /* If we aren't requiring a constant expression, defer __builtin_constant_p\n      in a constexpr function until we have values for the parameters.  */\n   if (bi_const_p\n-      && !ctx->manifestly_const_eval\n+      && ctx->manifestly_const_eval != mce_true\n       && current_function_decl\n       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n     {\n@@ -1479,12 +1479,13 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   if (fndecl_built_in_p (fun, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n \t\t\t BUILT_IN_FRONTEND))\n     {\n-      if (!ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_unknown)\n \t{\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-      return boolean_true_node;\n+      return constant_boolean_node (ctx->manifestly_const_eval == mce_true,\n+\t\t\t\t    boolean_type_node);\n     }\n \n   if (fndecl_built_in_p (fun, CP_BUILT_IN_SOURCE_LOCATION, BUILT_IN_FRONTEND))\n@@ -1591,7 +1592,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n     }\n \n   bool save_ffbcp = force_folding_builtin_constant_p;\n-  force_folding_builtin_constant_p |= ctx->manifestly_const_eval;\n+  force_folding_builtin_constant_p |= ctx->manifestly_const_eval == mce_true;\n   tree save_cur_fn = current_function_decl;\n   /* Return name of ctx->call->fundef->decl for __builtin_FUNCTION ().  */\n   if (fndecl_built_in_p (fun, BUILT_IN_FUNCTION)\n@@ -2916,7 +2917,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       location_t save_loc = input_location;\n       input_location = loc;\n       ++function_depth;\n-      if (ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_true)\n \tFNDECL_MANIFESTLY_CONST_EVALUATED (fun) = true;\n       instantiate_decl (fun, /*defer_ok*/false, /*expl_inst*/false);\n       --function_depth;\n@@ -3676,7 +3677,7 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \n   if (r == NULL_TREE)\n     {\n-      if (ctx->manifestly_const_eval\n+      if (ctx->manifestly_const_eval == mce_true\n \t  && (flag_constexpr_fp_except\n \t      || TREE_CODE (type) != REAL_TYPE))\n \t{\n@@ -3741,13 +3742,13 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t without manifestly_const_eval even expressions or parts thereof which\n \t will later be manifestly const_eval evaluated), otherwise fold it to\n \t true.  */\n-      if (ctx->manifestly_const_eval)\n-\tval = boolean_true_node;\n-      else\n+      if (ctx->manifestly_const_eval == mce_unknown)\n \t{\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n+      val = constant_boolean_node (ctx->manifestly_const_eval == mce_true,\n+\t\t\t\t   boolean_type_node);\n     }\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n@@ -4301,10 +4302,6 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   if (!SCALAR_TYPE_P (elem_type))\n     {\n       new_ctx = *ctx;\n-      if (ctx->object)\n-\t/* If there was no object, don't add one: it could confuse us\n-\t   into thinking we're modifying a const object.  */\n-\tnew_ctx.object = t;\n       new_ctx.ctor = build_constructor (elem_type, NULL);\n       ctx = &new_ctx;\n     }\n@@ -7055,7 +7052,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t      r = v;\n \t      break;\n \t    }\n-      if (ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_true)\n \tmaybe_warn_about_constant_value (loc, t);\n       if (COMPLETE_TYPE_P (TREE_TYPE (t))\n \t  && is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/false))\n@@ -7644,7 +7641,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif (TREE_CODE (t) == CONVERT_EXPR\n \t    && ARITHMETIC_TYPE_P (type)\n \t    && INDIRECT_TYPE_P (TREE_TYPE (op))\n-\t    && ctx->manifestly_const_eval)\n+\t    && ctx->manifestly_const_eval == mce_true)\n \t  {\n \t    if (!ctx->quiet)\n \t      error_at (loc,\n@@ -8001,6 +7998,51 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       r = cxx_eval_bit_cast (ctx, t, non_constant_p, overflow_p);\n       break;\n \n+    case OMP_PARALLEL:\n+    case OMP_TASK:\n+    case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n+    case OMP_TASKLOOP:\n+    case OMP_LOOP:\n+    case OMP_TEAMS:\n+    case OMP_TARGET_DATA:\n+    case OMP_TARGET:\n+    case OMP_SECTIONS:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+    case OMP_SINGLE:\n+    case OMP_SCAN:\n+    case OMP_SCOPE:\n+    case OMP_SECTION:\n+    case OMP_MASTER:\n+    case OMP_MASKED:\n+    case OMP_TASKGROUP:\n+    case OMP_TARGET_UPDATE:\n+    case OMP_TARGET_ENTER_DATA:\n+    case OMP_TARGET_EXIT_DATA:\n+    case OMP_ATOMIC:\n+    case OMP_ATOMIC_READ:\n+    case OMP_ATOMIC_CAPTURE_OLD:\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+    case OMP_DEPOBJ:\n+    case OACC_PARALLEL:\n+    case OACC_KERNELS:\n+    case OACC_SERIAL:\n+    case OACC_DATA:\n+    case OACC_HOST_DATA:\n+    case OACC_LOOP:\n+    case OACC_CACHE:\n+    case OACC_DECLARE:\n+    case OACC_ENTER_DATA:\n+    case OACC_EXIT_DATA:\n+    case OACC_UPDATE:\n+      if (!ctx->quiet)\n+\terror_at (EXPR_LOCATION (t),\n+\t\t  \"statement is not a constant expression\");\n+      *non_constant_p = true;\n+      break;\n+\n     default:\n       if (STATEMENT_CODE_P (TREE_CODE (t)))\n \t{\n@@ -8137,7 +8179,7 @@ mark_non_constant (tree t)\n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n-\t\t\t\t  bool manifestly_const_eval = false,\n+\t\t\t\t  mce_value manifestly_const_eval = mce_unknown,\n \t\t\t\t  bool constexpr_dtor = false,\n \t\t\t\t  tree object = NULL_TREE)\n {\n@@ -8155,10 +8197,11 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   constexpr_global_ctx global_ctx;\n   constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n-\t\t\tmanifestly_const_eval || !allow_non_constant };\n+\t\t\t!allow_non_constant ? mce_true : manifestly_const_eval };\n \n   /* Turn off -frounding-math for manifestly constant evaluation.  */\n-  warning_sentinel rm (flag_rounding_math, ctx.manifestly_const_eval);\n+  warning_sentinel rm (flag_rounding_math,\n+\t\t       ctx.manifestly_const_eval == mce_true);\n   tree type = initialized_type (t);\n   tree r = t;\n   bool is_consteval = false;\n@@ -8247,7 +8290,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   auto_vec<tree, 16> cleanups;\n   global_ctx.cleanups = &cleanups;\n \n-  if (manifestly_const_eval)\n+  if (manifestly_const_eval == mce_true)\n     instantiate_constexpr_fns (r);\n   r = cxx_eval_constant_expression (&ctx, r, vc_prvalue,\n \t\t\t\t    &non_constant_p, &overflow_p);\n@@ -8386,7 +8429,7 @@ cxx_constant_value (tree t, tree decl /* = NULL_TREE */,\n \t\t    tsubst_flags_t complain /* = tf_error */)\n {\n   bool sfinae = !(complain & tf_error);\n-  tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, true, false, decl);\n+  tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, mce_true, false, decl);\n   if (sfinae && !TREE_CONSTANT (r))\n     r = error_mark_node;\n   return r;\n@@ -8398,7 +8441,7 @@ cxx_constant_value (tree t, tree decl /* = NULL_TREE */,\n void\n cxx_constant_dtor (tree t, tree decl)\n {\n-  cxx_eval_outermost_constant_expr (t, false, true, true, true, decl);\n+  cxx_eval_outermost_constant_expr (t, false, true, mce_true, true, decl);\n }\n \n /* Helper routine for fold_simple function.  Either return simplified\n@@ -8484,7 +8527,7 @@ static GTY((deletable)) hash_map<tree, tree> *cv_cache;\n \n tree\n maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n-\t\t      bool manifestly_const_eval /* = false */)\n+\t\t      mce_value manifestly_const_eval /* = mce_unknown */)\n {\n   tree r;\n \n@@ -8499,8 +8542,9 @@ maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n     /* No caching or evaluation needed.  */\n     return t;\n \n-  if (manifestly_const_eval)\n-    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n+  if (manifestly_const_eval != mce_unknown)\n+    return cxx_eval_outermost_constant_expr (t, true, true,\n+\t\t\t\t\t     manifestly_const_eval, false, decl);\n \n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n@@ -8524,7 +8568,8 @@ maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n     return t;\n \n   uid_sensitive_constexpr_evaluation_checker c;\n-  r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);\n+  r = cxx_eval_outermost_constant_expr (t, true, true,\n+\t\t\t\t\tmanifestly_const_eval, false, decl);\n   gcc_checking_assert (r == t\n \t\t       || CONVERT_EXPR_P (t)\n \t\t       || TREE_CODE (t) == VIEW_CONVERT_EXPR\n@@ -8590,7 +8635,7 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n \treturn t;\n \n       tree r = cxx_eval_outermost_constant_expr (t, true, true,\n-\t\t\t\t\t\t manifestly_const_eval,\n+\t\t\t\t\t\t mce_value (manifestly_const_eval),\n \t\t\t\t\t\t false, object);\n       /* cp_tree_equal looks through NOPs, so allow them.  */\n       gcc_checking_assert (r == t\n@@ -8637,7 +8682,7 @@ fold_non_dependent_expr (tree t,\n     return fold_non_dependent_expr_template (t, complain,\n \t\t\t\t\t     manifestly_const_eval, object);\n \n-  return maybe_constant_value (t, object, manifestly_const_eval);\n+  return maybe_constant_value (t, object, mce_value (manifestly_const_eval));\n }\n \n /* Like fold_non_dependent_expr, but if EXPR couldn't be folded to a constant,\n@@ -8715,7 +8760,8 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n       bool is_static = (decl && DECL_P (decl)\n \t\t\t&& (TREE_STATIC (decl) || DECL_EXTERNAL (decl)));\n       t = cxx_eval_outermost_constant_expr (t, allow_non_constant, !is_static,\n-\t\t\t\t\t    manifestly_const_eval, false, decl);\n+\t\t\t\t\t    mce_value (manifestly_const_eval),\n+\t\t\t\t\t    false, decl);\n     }\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n@@ -9471,6 +9517,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n     case OMP_SINGLE:\n+    case OMP_SCAN:\n+    case OMP_SCOPE:\n     case OMP_SECTION:\n     case OMP_MASTER:\n     case OMP_MASKED:"}, {"sha": "9374327008b2fe0dc95b98882383d8308d0344e6", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3068,8 +3068,7 @@ satisfy_atom (tree t, tree args, sat_info info)\n     }\n   else\n     {\n-      result = maybe_constant_value (result, NULL_TREE,\n-\t\t\t\t     /*manifestly_const_eval=*/true);\n+      result = maybe_constant_value (result, NULL_TREE, mce_true);\n       if (!TREE_CONSTANT (result))\n \tresult = error_mark_node;\n     }"}, {"sha": "32fe53521cc59d9877523301ad9861ddb7cc4b24", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 117, "deletions": 45, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -43,12 +43,26 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"opts.h\"\n \n+/* Flags for cp_fold and cp_fold_r.  */\n+\n+enum fold_flags {\n+  ff_none = 0,\n+  /* Whether we're being called from cp_fold_function.  */\n+  ff_genericize = 1 << 0,\n+  /* Whether we're folding a point where we know we're\n+     definitely not in a manifestly constant-evaluated\n+     context.  */\n+  ff_mce_false = 1 << 1,\n+};\n+\n+using fold_flags_t = int;\n+\n /* Forward declarations.  */\n \n static tree cp_genericize_r (tree *, int *, void *);\n static tree cp_fold_r (tree *, int *, void *);\n static void cp_genericize_tree (tree*, bool);\n-static tree cp_fold (tree);\n+static tree cp_fold (tree, fold_flags_t);\n \n /* Genericize a TRY_BLOCK.  */\n \n@@ -893,6 +907,21 @@ omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n     }\n }\n \n+/* True if any of the element initializers in CTOR are TARGET_EXPRs that are\n+   not expected to elide, e.g. because unsafe_copy_elision_p is true.  */\n+\n+static bool\n+any_non_eliding_target_exprs (tree ctor)\n+{\n+  for (const constructor_elt &e : *CONSTRUCTOR_ELTS (ctor))\n+    {\n+      if (TREE_CODE (e.value) == TARGET_EXPR\n+\t  && !TARGET_EXPR_ELIDING_P (e.value))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* If we might need to clean up a partially constructed object, break down the\n    CONSTRUCTOR with split_nonconstant_init.  Also expand VEC_INIT_EXPR at this\n    point.  If initializing TO with FROM is non-trivial, overwrite *REPLACE with\n@@ -904,10 +933,11 @@ cp_genericize_init (tree *replace, tree from, tree to)\n   tree init = NULL_TREE;\n   if (TREE_CODE (from) == VEC_INIT_EXPR)\n     init = expand_vec_init_expr (to, from, tf_warning_or_error);\n-  else if (flag_exceptions\n-\t   && TREE_CODE (from) == CONSTRUCTOR\n+  else if (TREE_CODE (from) == CONSTRUCTOR\n \t   && TREE_SIDE_EFFECTS (from)\n-\t   && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (from)))\n+\t   && ((flag_exceptions\n+\t\t&& TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (from)))\n+\t       || any_non_eliding_target_exprs (from)))\n     {\n       to = cp_stabilize_reference (to);\n       replace_placeholders (from, to);\n@@ -996,9 +1026,8 @@ struct cp_genericize_data\n struct cp_fold_data\n {\n   hash_set<tree> pset;\n-  bool genericize; // called from cp_fold_function?\n-\n-  cp_fold_data (bool g): genericize (g) {}\n+  fold_flags_t flags;\n+  cp_fold_data (fold_flags_t flags): flags (flags) {}\n };\n \n static tree\n@@ -1039,7 +1068,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n       break;\n     }\n \n-  *stmt_p = stmt = cp_fold (*stmt_p);\n+  *stmt_p = stmt = cp_fold (*stmt_p, data->flags);\n \n   if (data->pset.add (stmt))\n     {\n@@ -1119,12 +1148,12 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n \t here rather than in cp_genericize to avoid problems with the invisible\n \t reference transition.  */\n     case INIT_EXPR:\n-      if (data->genericize)\n+      if (data->flags & ff_genericize)\n \tcp_genericize_init_expr (stmt_p);\n       break;\n \n     case TARGET_EXPR:\n-      if (data->genericize)\n+      if (data->flags & ff_genericize)\n \tcp_genericize_target_expr (stmt_p);\n \n       /* Folding might replace e.g. a COND_EXPR with a TARGET_EXPR; in\n@@ -1157,7 +1186,10 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n void\n cp_fold_function (tree fndecl)\n {\n-  cp_fold_data data (/*genericize*/true);\n+  /* By now all manifestly-constant-evaluated expressions will have\n+     been constant-evaluated already if possible, so we can safely\n+     pass ff_mce_false.  */\n+  cp_fold_data data (ff_genericize | ff_mce_false);\n   cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &data, NULL);\n }\n \n@@ -2370,12 +2402,12 @@ cxx_omp_disregard_value_expr (tree decl, bool shared)\n \n /* Fold expression X which is used as an rvalue if RVAL is true.  */\n \n-tree\n-cp_fold_maybe_rvalue (tree x, bool rval)\n+static tree\n+cp_fold_maybe_rvalue (tree x, bool rval, fold_flags_t flags)\n {\n   while (true)\n     {\n-      x = cp_fold (x);\n+      x = cp_fold (x, flags);\n       if (rval)\n \tx = mark_rvalue_use (x);\n       if (rval && DECL_P (x)\n@@ -2393,12 +2425,24 @@ cp_fold_maybe_rvalue (tree x, bool rval)\n   return x;\n }\n \n+tree\n+cp_fold_maybe_rvalue (tree x, bool rval)\n+{\n+  return cp_fold_maybe_rvalue (x, rval, ff_none);\n+}\n+\n /* Fold expression X which is used as an rvalue.  */\n \n+static tree\n+cp_fold_rvalue (tree x, fold_flags_t flags)\n+{\n+  return cp_fold_maybe_rvalue (x, true, flags);\n+}\n+\n tree\n cp_fold_rvalue (tree x)\n {\n-  return cp_fold_maybe_rvalue (x, true);\n+  return cp_fold_rvalue (x, ff_none);\n }\n \n /* Perform folding on expression X.  */\n@@ -2434,7 +2478,7 @@ cp_fully_fold_init (tree x)\n   if (processing_template_decl)\n     return x;\n   x = cp_fully_fold (x);\n-  cp_fold_data data (/*genericize*/false);\n+  cp_fold_data data (ff_mce_false);\n   cp_walk_tree (&x, cp_fold_r, &data, NULL);\n   return x;\n }\n@@ -2450,15 +2494,29 @@ c_fully_fold (tree x, bool /*in_init*/, bool */*maybe_const*/, bool lval)\n   return cp_fold_maybe_rvalue (x, !lval);\n }\n \n-static GTY((deletable)) hash_map<tree, tree> *fold_cache;\n+static GTY((deletable)) hash_map<tree, tree> *fold_caches[2];\n+\n+/* Subroutine of cp_fold.  Returns which fold cache to use according\n+   to the given flags.  We need multiple caches since the result of\n+   folding may depend on which flags are used.  */\n+\n+static hash_map<tree, tree> *&\n+get_fold_cache (fold_flags_t flags)\n+{\n+  if (flags & ff_mce_false)\n+    return fold_caches[1];\n+  else\n+    return fold_caches[0];\n+}\n \n /* Dispose of the whole FOLD_CACHE.  */\n \n void\n clear_fold_cache (void)\n {\n-  if (fold_cache != NULL)\n-    fold_cache->empty ();\n+  for (auto& fold_cache : fold_caches)\n+    if (fold_cache != NULL)\n+      fold_cache->empty ();\n }\n \n /*  This function tries to fold an expression X.\n@@ -2469,7 +2527,7 @@ clear_fold_cache (void)\n     Function returns X or its folded variant.  */\n \n static tree\n-cp_fold (tree x)\n+cp_fold (tree x, fold_flags_t flags)\n {\n   tree op0, op1, op2, op3;\n   tree org_x = x, r = NULL_TREE;\n@@ -2487,6 +2545,7 @@ cp_fold (tree x)\n   if (DECL_P (x) || CONSTANT_CLASS_P (x))\n     return x;\n \n+  auto& fold_cache = get_fold_cache (flags);\n   if (fold_cache == NULL)\n     fold_cache = hash_map<tree, tree>::create_ggc (101);\n \n@@ -2501,7 +2560,7 @@ cp_fold (tree x)\n     case CLEANUP_POINT_EXPR:\n       /* Strip CLEANUP_POINT_EXPR if the expression doesn't have side\n \t effects.  */\n-      r = cp_fold_rvalue (TREE_OPERAND (x, 0));\n+      r = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n       if (!TREE_SIDE_EFFECTS (r))\n \tx = r;\n       break;\n@@ -2526,14 +2585,14 @@ cp_fold (tree x)\n \t     Don't create a new tree if op0 != TREE_OPERAND (x, 0), the\n \t     folding of the operand should be in the caches and if in cp_fold_r\n \t     it will modify it in place.  */\n-\t  op0 = cp_fold (TREE_OPERAND (x, 0));\n+\t  op0 = cp_fold (TREE_OPERAND (x, 0), flags);\n \t  if (op0 == error_mark_node)\n \t    x = error_mark_node;\n \t  break;\n \t}\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n \n       if (code == CONVERT_EXPR\n \t  && SCALAR_TYPE_P (TREE_TYPE (x))\n@@ -2561,7 +2620,7 @@ cp_fold (tree x)\n       break;\n \n     case EXCESS_PRECISION_EXPR:\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n       x = fold_convert_loc (EXPR_LOCATION (x), TREE_TYPE (x), op0);\n       break;\n \n@@ -2571,13 +2630,13 @@ cp_fold (tree x)\n \t{\n \t  tree p = maybe_undo_parenthesized_ref (x);\n \t  if (p != x)\n-\t    return cp_fold (p);\n+\t    return cp_fold (p, flags);\n \t}\n       goto unary;\n \n     case ADDR_EXPR:\n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false, flags);\n \n       /* Cope with user tricks that amount to offsetof.  */\n       if (op0 != error_mark_node\n@@ -2614,7 +2673,7 @@ cp_fold (tree x)\n     unary:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n \n     finish_unary:\n       if (op0 != TREE_OPERAND (x, 0))\n@@ -2641,7 +2700,7 @@ cp_fold (tree x)\n       break;\n \n     case UNARY_PLUS_EXPR:\n-      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));\n+      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n       if (op0 == error_mark_node)\n \tx = error_mark_node;\n       else\n@@ -2695,8 +2754,8 @@ cp_fold (tree x)\n     case RANGE_EXPR: case COMPLEX_EXPR:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n-      op1 = cp_fold_rvalue (TREE_OPERAND (x, 1));\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n+      op1 = cp_fold_rvalue (TREE_OPERAND (x, 1), flags);\n \n       /* decltype(nullptr) has only one value, so optimize away all comparisons\n \t with that type right away, keeping them in the IL causes troubles for\n@@ -2762,9 +2821,9 @@ cp_fold (tree x)\n     case VEC_COND_EXPR:\n     case COND_EXPR:\n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));\n-      op1 = cp_fold (TREE_OPERAND (x, 1));\n-      op2 = cp_fold (TREE_OPERAND (x, 2));\n+      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n+      op1 = cp_fold (TREE_OPERAND (x, 1), flags);\n+      op2 = cp_fold (TREE_OPERAND (x, 2), flags);\n \n       if (TREE_CODE (TREE_TYPE (x)) == BOOLEAN_TYPE)\n \t{\n@@ -2854,7 +2913,7 @@ cp_fold (tree x)\n \t      {\n \t\tif (!same_type_p (TREE_TYPE (x), TREE_TYPE (r)))\n \t\t  r = build_nop (TREE_TYPE (x), r);\n-\t\tx = cp_fold (r);\n+\t\tx = cp_fold (r, flags);\n \t\tbreak;\n \t      }\n \t  }\n@@ -2872,10 +2931,15 @@ cp_fold (tree x)\n \n \tif (callee && fndecl_built_in_p (callee, BUILT_IN_FRONTEND))\n \t  {\n+\t    iloc_sentinel ils (EXPR_LOCATION (x));\n \t    switch (DECL_FE_FUNCTION_CODE (callee))\n \t      {\n-\t\t/* Defer folding __builtin_is_constant_evaluated.  */\n \t      case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t\t/* Defer folding __builtin_is_constant_evaluated unless\n+\t\t   we know this isn't a manifestly constant-evaluated\n+\t\t   context.  */\n+\t\tif (flags & ff_mce_false)\n+\t\t  x = boolean_false_node;\n \t\tbreak;\n \t      case CP_BUILT_IN_SOURCE_LOCATION:\n \t\tx = fold_builtin_source_location (x);\n@@ -2908,7 +2972,7 @@ cp_fold (tree x)\n \tint m = call_expr_nargs (x);\n \tfor (int i = 0; i < m; i++)\n \t  {\n-\t    r = cp_fold (CALL_EXPR_ARG (x, i));\n+\t    r = cp_fold (CALL_EXPR_ARG (x, i), flags);\n \t    if (r != CALL_EXPR_ARG (x, i))\n \t      {\n \t\tif (r == error_mark_node)\n@@ -2931,7 +2995,7 @@ cp_fold (tree x)\n \n \tif (TREE_CODE (r) != CALL_EXPR)\n \t  {\n-\t    x = cp_fold (r);\n+\t    x = cp_fold (r, flags);\n \t    break;\n \t  }\n \n@@ -2944,7 +3008,15 @@ cp_fold (tree x)\n \t   constant, but the call followed by an INDIRECT_REF is.  */\n \tif (callee && DECL_DECLARED_CONSTEXPR_P (callee)\n \t    && !flag_no_inline)\n-\t  r = maybe_constant_value (x);\n+\t  {\n+\t    mce_value manifestly_const_eval = mce_unknown;\n+\t    if (flags & ff_mce_false)\n+\t      /* Allow folding __builtin_is_constant_evaluated to false during\n+\t\t constexpr evaluation of this call.  */\n+\t      manifestly_const_eval = mce_false;\n+\t    r = maybe_constant_value (x, /*decl=*/NULL_TREE,\n+\t\t\t\t      manifestly_const_eval);\n+\t  }\n \toptimize = sv;\n \n         if (TREE_CODE (r) != CALL_EXPR)\n@@ -2971,7 +3043,7 @@ cp_fold (tree x)\n \tvec<constructor_elt, va_gc> *nelts = NULL;\n \tFOR_EACH_VEC_SAFE_ELT (elts, i, p)\n \t  {\n-\t    tree op = cp_fold (p->value);\n+\t    tree op = cp_fold (p->value, flags);\n \t    if (op != p->value)\n \t      {\n \t\tif (op == error_mark_node)\n@@ -3002,7 +3074,7 @@ cp_fold (tree x)\n \n \tfor (int i = 0; i < n; i++)\n \t  {\n-\t    tree op = cp_fold (TREE_VEC_ELT (x, i));\n+\t    tree op = cp_fold (TREE_VEC_ELT (x, i), flags);\n \t    if (op != TREE_VEC_ELT (x, i))\n \t      {\n \t\tif (!changed)\n@@ -3019,10 +3091,10 @@ cp_fold (tree x)\n     case ARRAY_RANGE_REF:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold (TREE_OPERAND (x, 0));\n-      op1 = cp_fold (TREE_OPERAND (x, 1));\n-      op2 = cp_fold (TREE_OPERAND (x, 2));\n-      op3 = cp_fold (TREE_OPERAND (x, 3));\n+      op0 = cp_fold (TREE_OPERAND (x, 0), flags);\n+      op1 = cp_fold (TREE_OPERAND (x, 1), flags);\n+      op2 = cp_fold (TREE_OPERAND (x, 2), flags);\n+      op3 = cp_fold (TREE_OPERAND (x, 3), flags);\n \n       if (op0 != TREE_OPERAND (x, 0)\n \t  || op1 != TREE_OPERAND (x, 1)\n@@ -3050,7 +3122,7 @@ cp_fold (tree x)\n       /* A SAVE_EXPR might contain e.g. (0 * i) + (0 * j), which, after\n \t folding, evaluates to an invariant.  In that case no need to wrap\n \t this folded tree with a SAVE_EXPR.  */\n-      r = cp_fold (TREE_OPERAND (x, 0));\n+      r = cp_fold (TREE_OPERAND (x, 0), flags);\n       if (tree_invariant_p (r))\n \tx = r;\n       break;"}, {"sha": "5595335bbf7bbef86c7682851e0dceaef5dc5893", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4238,7 +4238,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* We have an expression tree T that represents a call, either CALL_EXPR\n    or AGGR_INIT_EXPR.  Return a reference to the Nth argument.  */\n \n-static inline tree&\n+inline tree&\n get_nth_callarg (tree t, int n)\n {\n   switch (TREE_CODE (t))\n@@ -5597,6 +5597,9 @@ enum tsubst_flags {\n   tf_tst_ok = 1 << 12,\t\t /* Allow a typename-specifier to name\n \t\t\t\t    a template (C++17 or later).  */\n   tf_dguide = 1 << 13,\t\t/* Building a deduction guide from a ctor.  */\n+  tf_qualifying_scope = 1 << 14, /* Substituting the LHS of the :: operator.\n+\t\t\t\t    Affects TYPENAME_TYPE resolution from\n+\t\t\t\t    make_typename_type.  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };\n@@ -7428,7 +7431,6 @@ extern bool any_type_dependent_arguments_p      (const vec<tree, va_gc> *);\n extern bool any_type_dependent_elements_p       (const_tree);\n extern bool type_dependent_expression_p_push\t(tree);\n extern bool value_dependent_expression_p\t(tree);\n-extern bool instantiation_dependent_expression_p (tree);\n extern bool instantiation_dependent_uneval_expression_p (tree);\n extern bool any_value_dependent_elements_p      (const_tree);\n extern bool dependent_omp_for_p\t\t\t(tree, tree, tree, tree);\n@@ -7903,6 +7905,7 @@ extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup,\n extern int is_overloaded_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern bool really_overloaded_fn\t\t(tree) ATTRIBUTE_PURE;\n extern tree dependent_name\t\t\t(tree);\n+extern tree call_expr_dependent_name\t\t(tree);\n extern tree maybe_get_fns\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_first_fn\t\t\t(tree) ATTRIBUTE_PURE;\n@@ -8456,6 +8459,24 @@ struct GTY((for_user)) constexpr_fundef {\n   tree result;\n };\n \n+/* Whether the current context is manifestly constant-evaluated.\n+   Used by the constexpr machinery to control folding of\n+   __builtin_is_constant_evaluated.  */\n+\n+enum class mce_value\n+{\n+  /* Unknown, so treat __builtin_is_constant_evaluated as non-constant.  */\n+  mce_unknown = 0,\n+  /* Fold it to true.  */\n+  mce_true = 1,\n+  /* Fold it to false.  Primarily used during cp_fold_function and\n+     cp_fully_fold_init.  */\n+  mce_false = -1,\n+};\n+constexpr mce_value mce_unknown = mce_value::mce_unknown;\n+constexpr mce_value mce_true = mce_value::mce_true;\n+constexpr mce_value mce_false = mce_value::mce_false;\n+\n extern void fini_constexpr\t\t\t(void);\n extern bool literal_type_p                      (tree);\n extern void maybe_save_constexpr_fundef\t\t(tree);\n@@ -8484,7 +8505,7 @@ inline tree cxx_constant_value (tree t, tsubst_flags_t complain)\n { return cxx_constant_value (t, NULL_TREE, complain); }\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, mce_value = mce_unknown);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,"}, {"sha": "30c7470974d4b62ec6c03b2a7dd37f046983a247", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4305,9 +4305,10 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n      member of the current instantiation or a non-dependent base;\n      lookup will stop when we hit a dependent base.  */\n   if (!dependent_scope_p (context))\n-    /* We should only set WANT_TYPE when we're a nested typename type.\n-       Then we can give better diagnostics if we find a non-type.  */\n-    t = lookup_field (context, name, 2, /*want_type=*/true);\n+    {\n+      bool want_type = (complain & tf_qualifying_scope);\n+      t = lookup_member (context, name, /*protect=*/2, want_type, complain);\n+    }\n   else\n     t = NULL_TREE;\n \n@@ -4359,7 +4360,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n       else\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"%<typename %T::%D%> names %q#T, which is not a type\",\n+\t    error (\"%<typename %T::%D%> names %q#D, which is not a type\",\n \t\t   context, name, t);\n \t  return error_mark_node;\n \t}\n@@ -11372,7 +11373,7 @@ compute_array_index_type_loc (location_t name_loc, tree name, tree size,\n \t\t\t\t    cp_convert (ssizetype, integer_one_node,\n \t\t\t\t\t\tcomplain),\n \t\t\t\t    complain);\n-\titype = maybe_constant_value (itype, NULL_TREE, true);\n+\titype = maybe_constant_value (itype, NULL_TREE, mce_true);\n       }\n \n       if (!TREE_CONSTANT (itype))"}, {"sha": "f2761d22bba02889d35b9218c95ae0b014680003", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3107,6 +3107,10 @@ write_expression (tree expr)\n   else if (TREE_CODE_CLASS (code) == tcc_constant\n \t   || code == CONST_DECL)\n     write_template_arg_literal (expr);\n+  else if (code == EXCESS_PRECISION_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (expr, 0)) == REAL_CST)\n+    write_template_arg_literal (fold_convert (TREE_TYPE (expr),\n+\t\t\t\t\t      TREE_OPERAND (expr, 0)));\n   else if (code == PARM_DECL && DECL_ARTIFICIAL (expr))\n     {\n       gcc_assert (id_equal (DECL_NAME (expr), \"this\"));\n@@ -3815,6 +3819,10 @@ write_template_arg (tree node)\n \t   || code == CONST_DECL\n \t   || null_member_pointer_value_p (node))\n     write_template_arg_literal (node);\n+  else if (code == EXCESS_PRECISION_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (node, 0)) == REAL_CST)\n+    write_template_arg_literal (fold_convert (TREE_TYPE (node),\n+\t\t\t\t\t      TREE_OPERAND (node, 0)));\n   else if (DECL_P (node))\n     {\n       write_char ('L');"}, {"sha": "1a124f5395e018f3c4b2f9f36fcd42159d0b868f", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 80, "deletions": 17, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -41483,43 +41483,106 @@ cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)\n   return finish_omp_structured_block (stmt);\n }\n \n-/* OpenMP 5.0:\n-   # pragma omp allocate (list)  [allocator(allocator)]  */\n+/* OpenMP 5.x:\n+   # pragma omp allocate (list)  clauses\n+\n+   OpenMP 5.0 clause:\n+   allocator (omp_allocator_handle_t expression)\n+\n+   OpenMP 5.1 additional clause:\n+   align (constant-expression)]  */\n \n static void\n cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n {\n   tree allocator = NULL_TREE;\n+  tree alignment = NULL_TREE;\n   location_t loc = pragma_tok->location;\n   tree nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n-      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n-    cp_lexer_consume_token (parser->lexer);\n-\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  do\n     {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tbreak;\n       matching_parens parens;\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n       location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_lexer_consume_token (parser->lexer);\n-      if (strcmp (p, \"allocator\") != 0)\n-\terror_at (cloc, \"expected %<allocator%>\");\n-      else if (parens.require_open (parser))\n+      if (strcmp (p, \"allocator\") != 0 && strcmp (p, \"align\") != 0)\n \t{\n-\t  allocator = cp_parser_assignment_expression (parser);\n-\t  if (allocator == error_mark_node)\n-\t    allocator = NULL_TREE;\n-\t  parens.require_close (parser);\n+\t  error_at (cloc, \"expected %<allocator%> or %<align%>\");\n+\t  break;\n \t}\n-    }\n+      if (!parens.require_open (parser))\n+\tbreak;\n+      tree expr = cp_parser_assignment_expression (parser);\n+      if (p[2] == 'i' && alignment)\n+\t{\n+\t  error_at (cloc, \"too many %qs clauses\", \"align\");\n+\t  break;\n+\t}\n+      else if (p[2] == 'i')\n+\t{\n+\t  if (expr != error_mark_node)\n+\t    alignment = expr;\n+\t  /* FIXME: Remove when adding check to semantics.cc; cf FIXME below. */\n+\t  if (alignment\n+\t      && !type_dependent_expression_p (alignment)\n+\t      && !INTEGRAL_TYPE_P (TREE_TYPE (alignment)))\n+\t    {\n+\t      error_at (cloc, \"%<align%> clause argument needs to be \"\n+\t\t\t      \"positive constant power of two integer \"\n+\t\t\t      \"expression\");\n+\t      alignment = NULL_TREE;\n+\t    }\n+\t  else if (alignment)\n+\t    {\n+\t      alignment = mark_rvalue_use (alignment);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  alignment = maybe_constant_value (alignment);\n+\t\t  if (TREE_CODE (alignment) != INTEGER_CST\n+\t\t      || !tree_fits_uhwi_p (alignment)\n+\t\t      || !integer_pow2p (alignment))\n+\t\t    {\n+\t\t      error_at (cloc, \"%<align%> clause argument needs to be \"\n+\t\t\t\t      \"positive constant power of two integer \"\n+\t\t\t\t      \"expression\");\n+\t\t      alignment = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (allocator)\n+\t{\n+\t  error_at (cloc, \"too many %qs clauses\", \"allocator\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  if (expr != error_mark_node)\n+\t    allocator = expr;\n+\t}\n+      parens.require_close (parser);\n+    } while (true);\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-  if (allocator)\n+  if (allocator || alignment)\n     for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n-      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = alignment;\n+      }\n \n+  /* FIXME: When implementing properly, delete the align/allocate expr error\n+     check above and add one in semantics.cc (to properly handle templates).\n+     Base this on the allocator/align modifiers check for the 'allocate' clause\n+     in semantics.cc's finish_omp_clauses.  */\n   sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n }\n "}, {"sha": "b1ac7d4beb4e0126766fac1eed8c1f6846889177", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1841,7 +1841,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n     case CALL_EXPR:\n       {\n \ttree fn = CALL_EXPR_FN (arg);\n-\tif (tree name = dependent_name (fn))\n+\tif (tree name = call_expr_dependent_name (arg))\n \t  {\n \t    if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n \t      val = iterative_hash_template_arg (TREE_OPERAND (fn, 1), val);\n@@ -7390,16 +7390,14 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t      IMPLICIT_CONV_EXPR_NONTYPE_ARG (expr) = true;\n \t      return expr;\n \t    }\n-\t  expr = maybe_constant_value (expr, NULL_TREE,\n-\t\t\t\t       /*manifestly_const_eval=*/true);\n+\t  expr = maybe_constant_value (expr, NULL_TREE, mce_true);\n \t  expr = convert_from_reference (expr);\n \t  /* EXPR may have become value-dependent.  */\n \t  val_dep_p = value_dependent_expression_p (expr);\n \t}\n       else if (TYPE_PTR_OR_PTRMEM_P (type))\n \t{\n-\t  tree folded = maybe_constant_value (expr, NULL_TREE,\n-\t\t\t\t\t      /*manifestly_const_eval=*/true);\n+\t  tree folded = maybe_constant_value (expr, NULL_TREE, mce_true);\n \t  if (TYPE_PTR_P (type) ? integer_zerop (folded)\n \t      : null_member_pointer_value_p (folded))\n \t    expr = folded;\n@@ -13919,8 +13917,7 @@ tsubst_aggr_type_1 (tree t,\n {\n   if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n     {\n-      tree argvec;\n-      tree r;\n+      complain &= ~tf_qualifying_scope;\n \n       /* Figure out what arguments are appropriate for the\n \t type we are trying to find.  For example, given:\n@@ -13931,18 +13928,14 @@ tsubst_aggr_type_1 (tree t,\n \t and supposing that we are instantiating f<int, double>,\n \t then our ARGS will be {int, double}, but, when looking up\n \t S we only want {double}.  */\n-      argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n-\t\t\t\t     complain, in_decl);\n+      tree argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n+\t\t\t\t\t  complain, in_decl);\n       if (argvec == error_mark_node)\n-\tr = error_mark_node;\n-      else\n-\t{\n-\t  r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n-\t\t\t\t     entering_scope, complain);\n-\t  r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n-\t}\n+\treturn error_mark_node;\n \n-      return r;\n+      tree r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n+\t\t\t\t      entering_scope, complain);\n+      return cp_build_qualified_type (r, cp_type_quals (t), complain);\n     }\n   else\n     /* This is not a template type, so there's nothing to do.  */\n@@ -15003,11 +14996,15 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  tree scope = USING_DECL_SCOPE (t);\n \t  if (PACK_EXPANSION_P (scope))\n \t    {\n-\t      scope = tsubst_pack_expansion (scope, args, complain, in_decl);\n+\t      scope = tsubst_pack_expansion (scope, args,\n+\t\t\t\t\t     complain | tf_qualifying_scope,\n+\t\t\t\t\t     in_decl);\n \t      variadic_p = true;\n \t    }\n \t  else\n-\t    scope = tsubst_copy (scope, args, complain, in_decl);\n+\t    scope = tsubst_copy (scope, args,\n+\t\t\t\t complain | tf_qualifying_scope,\n+\t\t\t\t in_decl);\n \n \t  tree name = DECL_NAME (t);\n \t  if (IDENTIFIER_CONV_OP_P (name)\n@@ -15821,6 +15818,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       || TREE_CODE (t) == TRANSLATION_UNIT_DECL)\n     return t;\n \n+  tsubst_flags_t tst_ok_flag = (complain & tf_tst_ok);\n+  complain &= ~tf_tst_ok;\n+\n+  tsubst_flags_t qualifying_scope_flag = (complain & tf_qualifying_scope);\n+  complain &= ~tf_qualifying_scope;\n+\n   if (DECL_P (t))\n     return tsubst_decl (t, args, complain);\n \n@@ -15889,9 +15892,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   bool fndecl_type = (complain & tf_fndecl_type);\n   complain &= ~tf_fndecl_type;\n \n-  bool tst_ok = (complain & tf_tst_ok);\n-  complain &= ~tf_tst_ok;\n-\n   if (type\n       && code != TYPENAME_TYPE\n       && code != TEMPLATE_TYPE_PARM\n@@ -16428,7 +16428,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree ctx = TYPE_CONTEXT (t);\n \tif (TREE_CODE (ctx) == TYPE_PACK_EXPANSION)\n \t  {\n-\t    ctx = tsubst_pack_expansion (ctx, args, complain, in_decl);\n+\t    ctx = tsubst_pack_expansion (ctx, args,\n+\t\t\t\t\t complain | tf_qualifying_scope,\n+\t\t\t\t\t in_decl);\n \t    if (ctx == error_mark_node\n \t\t|| TREE_VEC_LENGTH (ctx) > 1)\n \t      return error_mark_node;\n@@ -16442,8 +16444,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    ctx = TREE_VEC_ELT (ctx, 0);\n \t  }\n \telse\n-\t  ctx = tsubst_aggr_type (ctx, args, complain, in_decl,\n-\t\t\t\t  /*entering_scope=*/1);\n+\t  ctx = tsubst_aggr_type (ctx, args,\n+\t\t\t\t  complain | tf_qualifying_scope,\n+\t\t\t\t  in_decl, /*entering_scope=*/1);\n \tif (ctx == error_mark_node)\n \t  return error_mark_node;\n \n@@ -16473,8 +16476,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \n \ttsubst_flags_t tcomplain = complain | tf_keep_type_decl;\n-\tif (tst_ok)\n-\t  tcomplain |= tf_tst_ok;\n+\ttcomplain |= tst_ok_flag | qualifying_scope_flag;\n \tf = make_typename_type (ctx, f, typename_type, tcomplain);\n \tif (f == error_mark_node)\n \t  return f;\n@@ -16879,7 +16881,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   scope = TREE_OPERAND (qualified_id, 0);\n   if (args)\n     {\n-      scope = tsubst (scope, args, complain, in_decl);\n+      scope = tsubst (scope, args, complain | tf_qualifying_scope, in_decl);\n       expr = tsubst_copy (name, args, complain, in_decl);\n     }\n   else\n@@ -17125,6 +17127,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (t == NULL_TREE || t == error_mark_node || args == NULL_TREE)\n     return t;\n \n+  tsubst_flags_t qualifying_scope_flag = (complain & tf_qualifying_scope);\n+  complain &= ~tf_qualifying_scope;\n+\n   if (tree d = maybe_dependent_member_ref (t, args, complain, in_decl))\n     return d;\n \n@@ -17598,7 +17603,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case SCOPE_REF:\n       {\n-\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args,\n+\t\t\t\tcomplain | tf_qualifying_scope, in_decl);\n \ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n \treturn build_qualified_name (/*type=*/NULL_TREE, op0, op1,\n \t\t\t\t     QUALIFIED_NAME_IS_TEMPLATE (t));\n@@ -17713,7 +17719,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TYPEOF_TYPE:\n     case DECLTYPE_TYPE:\n     case TYPE_DECL:\n-      return tsubst (t, args, complain, in_decl);\n+      return tsubst (t, args, complain | qualifying_scope_flag, in_decl);\n \n     case USING_DECL:\n       t = DECL_NAME (t);"}, {"sha": "e472a97679dce36ec862a3430551e694655a6fe2", "filename": "gcc/cp/search.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1109,7 +1109,7 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n \n tree\n lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n-\t       tsubst_flags_t complain, access_failure_info *afi)\n+\t       tsubst_flags_t complain, access_failure_info *afi /* = NULL */)\n {\n   tree rval, rval_binfo = NULL_TREE;\n   tree type = NULL_TREE, basetype_path = NULL_TREE;"}, {"sha": "c2df0b69b309f3b849ebf0dbba57cf732ca4303b", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2957,13 +2957,18 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n       if (TREE_CODE (result) == CALL_EXPR\n \t  && really_overloaded_fn (orig_fn))\n \t{\n-\t  orig_fn = CALL_EXPR_FN (result);\n-\t  if (TREE_CODE (orig_fn) == COMPONENT_REF)\n+\t  tree sel_fn = CALL_EXPR_FN (result);\n+\t  if (TREE_CODE (sel_fn) == COMPONENT_REF)\n \t    {\n \t      /* The non-dependent result of build_new_method_call.  */\n-\t      orig_fn = TREE_OPERAND (orig_fn, 1);\n-\t      gcc_assert (BASELINK_P (orig_fn));\n-\t    }\n+\t      sel_fn = TREE_OPERAND (sel_fn, 1);\n+\t      gcc_assert (BASELINK_P (sel_fn));\n+\t    }\n+\t  else if (TREE_CODE (sel_fn) == ADDR_EXPR)\n+\t    /* Our original callee wasn't wrapped in an ADDR_EXPR,\n+\t       so strip this ADDR_EXPR added by build_over_call.  */\n+\t    sel_fn = TREE_OPERAND (sel_fn, 0);\n+\t  orig_fn = sel_fn;\n \t}\n \n       result = build_call_vec (TREE_TYPE (result), orig_fn, orig_args);"}, {"sha": "cd0dd963532ccbd8ac728ff980b3c12a6f52d943", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2608,6 +2608,18 @@ dependent_name (tree x)\n   return NULL_TREE;\n }\n \n+/* Like dependent_name, but instead takes a CALL_EXPR and also checks\n+   its dependence.  */\n+\n+tree\n+call_expr_dependent_name (tree x)\n+{\n+  if (TREE_TYPE (x) != NULL_TREE)\n+    /* X isn't dependent, so its callee isn't a dependent name.  */\n+    return NULL_TREE;\n+  return dependent_name (CALL_EXPR_FN (x));\n+}\n+\n /* Returns true iff X is an expression for an overloaded function\n    whose type cannot be known without performing overload\n    resolution.  */\n@@ -3870,16 +3882,18 @@ decl_internal_context_p (const_tree decl)\n   return !TREE_PUBLIC (decl);\n }\n \n-/* Subroutine of cp_tree_equal: t1 and t2 are the CALL_EXPR_FNs of two\n-   CALL_EXPRS.  Return whether they are equivalent.  */\n+/* Subroutine of cp_tree_equal: t1 and t2 are two CALL_EXPRs.\n+   Return whether their CALL_EXPR_FNs are equivalent.  */\n \n static bool\n called_fns_equal (tree t1, tree t2)\n {\n   /* Core 1321: dependent names are equivalent even if the overload sets\n      are different.  But do compare explicit template arguments.  */\n-  tree name1 = dependent_name (t1);\n-  tree name2 = dependent_name (t2);\n+  tree name1 = call_expr_dependent_name (t1);\n+  tree name2 = call_expr_dependent_name (t2);\n+  t1 = CALL_EXPR_FN (t1);\n+  t2 = CALL_EXPR_FN (t2);\n   if (name1 || name2)\n     {\n       tree targs1 = NULL_TREE, targs2 = NULL_TREE;\n@@ -4037,7 +4051,7 @@ cp_tree_equal (tree t1, tree t2)\n \tif (KOENIG_LOOKUP_P (t1) != KOENIG_LOOKUP_P (t2))\n \t  return false;\n \n-\tif (!called_fns_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))\n+\tif (!called_fns_equal (t1, t2))\n \t  return false;\n \n \tcall_expr_arg_iterator iter1, iter2;"}, {"sha": "065867b4a84adc611585702bb4274e51564dd465", "filename": "gcc/cselib.cc", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcselib.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcselib.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -80,6 +80,10 @@ struct expand_value_data\n \n static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n \n+/* This is a global so we don't have to pass this through every function.\n+   It is used in new_elt_loc_list to set SETTING_INSN.  */\n+static rtx_insn *cselib_current_insn;\n+\n /* There are three ways in which cselib can look up an rtx:\n    - for a REG, the reg_values table (which is indexed by regno) is used\n    - for a MEM, we recursively look up its address and then follow the\n@@ -143,11 +147,25 @@ cselib_hasher::equal (const cselib_val *v, const key *x_arg)\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_1 (l->loc, x, memmode, 0))\n+    if (l->setting_insn && DEBUG_INSN_P (l->setting_insn)\n+\t&& (!cselib_current_insn || !DEBUG_INSN_P (cselib_current_insn)))\n       {\n-\tpromote_debug_loc (l);\n-\treturn true;\n+\trtx_insn *save_cselib_current_insn = cselib_current_insn;\n+\t/* If l is so far a debug only loc, without debug stmts it\n+\t   would never be compared to x at all, so temporarily pretend\n+\t   current instruction is that DEBUG_INSN so that we don't\n+\t   promote other debug locs even for unsuccessful comparison.  */\n+\tcselib_current_insn = l->setting_insn;\n+\tbool match = rtx_equal_for_cselib_1 (l->loc, x, memmode, 0);\n+\tcselib_current_insn = save_cselib_current_insn;\n+\tif (match)\n+\t  {\n+\t    promote_debug_loc (l);\n+\t    return true;\n+\t  }\n       }\n+    else if (rtx_equal_for_cselib_1 (l->loc, x, memmode, 0))\n+      return true;\n \n   return false;\n }\n@@ -158,10 +176,6 @@ static hash_table<cselib_hasher> *cselib_hash_table;\n /* A table to hold preserved values.  */\n static hash_table<cselib_hasher> *cselib_preserved_hash_table;\n \n-/* This is a global so we don't have to pass this through every function.\n-   It is used in new_elt_loc_list to set SETTING_INSN.  */\n-static rtx_insn *cselib_current_insn;\n-\n /* The unique id that the next create value will take.  */\n static unsigned int next_uid;\n "}, {"sha": "e2fa8e8c2c1d5e4686d23a0546fa0c8275f03206", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -113,7 +113,7 @@ extern void dump_cselib_table (FILE *);\n /* Return the canonical value for VAL, following the equivalence chain\n    towards the earliest (== lowest uid) equivalent value.  */\n \n-static inline cselib_val *\n+inline cselib_val *\n canonical_cselib_val (cselib_val *val)\n {\n   cselib_val *canon;\n@@ -131,7 +131,7 @@ canonical_cselib_val (cselib_val *val)\n /* Return nonzero if we can prove that X and Y contain the same value, taking\n    our gathered information into account.  */\n \n-static inline int\n+inline int\n rtx_equal_for_cselib_p (rtx x, rtx y)\n {\n   if (x == y)"}, {"sha": "d8c7e21dad9b32814695c6ee09a19a8bc23b4d05", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -91,7 +91,7 @@ wide_int streamer_read_wide_int (class lto_input_block *);\n widest_int streamer_read_widest_int (class lto_input_block *);\n \n /* Returns a new bit-packing context for bit-packing into S.  */\n-static inline struct bitpack_d\n+inline struct bitpack_d\n bitpack_create (struct lto_output_stream *s)\n {\n   struct bitpack_d bp;\n@@ -102,7 +102,7 @@ bitpack_create (struct lto_output_stream *s)\n }\n \n /* Pack the NBITS bit sized value VAL into the bit-packing context BP.  */\n-static inline void\n+inline void\n bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n {\n   bitpack_word_t word = bp->word;\n@@ -132,7 +132,7 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n \n /* Pack VAL into the bit-packing context BP, using NBITS for each\n    coefficient.  */\n-static inline void\n+inline void\n bp_pack_poly_value (struct bitpack_d *bp,\n \t\t    const poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t> &val,\n \t\t    unsigned nbits)\n@@ -142,7 +142,7 @@ bp_pack_poly_value (struct bitpack_d *bp,\n }\n \n /* Finishes bit-packing of BP.  */\n-static inline void\n+inline void\n streamer_write_bitpack (struct bitpack_d *bp)\n {\n   streamer_write_uhwi_stream ((struct lto_output_stream *) bp->stream,\n@@ -152,7 +152,7 @@ streamer_write_bitpack (struct bitpack_d *bp)\n }\n \n /* Returns a new bit-packing context for bit-unpacking from IB.  */\n-static inline struct bitpack_d\n+inline struct bitpack_d\n streamer_read_bitpack (class lto_input_block *ib)\n {\n   struct bitpack_d bp;\n@@ -163,7 +163,7 @@ streamer_read_bitpack (class lto_input_block *ib)\n }\n \n /* Unpacks NBITS bits from the bit-packing context BP and returns them.  */\n-static inline bitpack_word_t\n+inline bitpack_word_t\n bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n {\n   bitpack_word_t mask, val;\n@@ -191,7 +191,7 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n \n /* Unpacks a polynomial value from the bit-packing context BP in which each\n    coefficient has NBITS bits.  */\n-static inline poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t>\n+inline poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t>\n bp_unpack_poly_value (struct bitpack_d *bp, unsigned nbits)\n {\n   poly_int_pod<NUM_POLY_INT_COEFFS, bitpack_word_t> x;\n@@ -203,7 +203,7 @@ bp_unpack_poly_value (struct bitpack_d *bp, unsigned nbits)\n \n /* Write a character to the output block.  */\n \n-static inline void\n+inline void\n streamer_write_char_stream (struct lto_output_stream *obs, char c)\n {\n   /* No space left.  */\n@@ -221,7 +221,7 @@ streamer_write_char_stream (struct lto_output_stream *obs, char c)\n \n /* Read byte from the input block.  */\n \n-static inline unsigned char\n+inline unsigned char\n streamer_read_uchar (class lto_input_block *ib)\n {\n   if (ib->p >= ib->len)\n@@ -233,7 +233,7 @@ streamer_read_uchar (class lto_input_block *ib)\n    to be compile time constant.\n    Be host independent, limit range to 31bits.  */\n \n-static inline void\n+inline void\n streamer_write_hwi_in_range (struct lto_output_stream *obs,\n \t\t\t\t  HOST_WIDE_INT min,\n \t\t\t\t  HOST_WIDE_INT max,\n@@ -251,7 +251,7 @@ streamer_write_hwi_in_range (struct lto_output_stream *obs,\n /* Input VAL into OBS and verify it is in range MIN...MAX that is supposed\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n streamer_read_hwi_in_range (class lto_input_block *ib,\n \t\t\t\t const char *purpose,\n \t\t\t\t HOST_WIDE_INT min,\n@@ -272,7 +272,7 @@ streamer_read_hwi_in_range (class lto_input_block *ib,\n    to be compile time constant.\n    Be host independent, limit range to 31bits.  */\n \n-static inline void\n+inline void\n bp_pack_int_in_range (struct bitpack_d *bp,\n \t\t      HOST_WIDE_INT min,\n \t\t      HOST_WIDE_INT max,\n@@ -291,7 +291,7 @@ bp_pack_int_in_range (struct bitpack_d *bp,\n /* Input VAL into BP and verify it is in range MIN...MAX that is supposed\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n bp_unpack_int_in_range (struct bitpack_d *bp,\n \t\t        const char *purpose,\n \t\t        HOST_WIDE_INT min,\n@@ -332,15 +332,15 @@ bp_unpack_int_in_range (struct bitpack_d *bp,\n \n /* Output the start of a record with TAG to output block OB.  */\n \n-static inline void\n+inline void\n streamer_write_record_start (struct output_block *ob, enum LTO_tags tag)\n {\n   streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n }\n \n /* Return the next tag in the input block IB.  */\n \n-static inline enum LTO_tags\n+inline enum LTO_tags\n streamer_read_record_start (class lto_input_block *ib)\n {\n   return streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);"}, {"sha": "05512bce48c1bb934df3bb87f3665f44f04fa8bf", "filename": "gcc/debug.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -270,7 +270,7 @@ extern decl_to_instance_map_t *decl_to_instance_map;\n /* Allocate decl_to_instance_map with COUNT slots to begin wtih, if it\n  * hasn't been allocated yet.  */\n \n-static inline decl_to_instance_map_t *\n+inline decl_to_instance_map_t *\n maybe_create_decl_to_instance_map (int count = 13)\n {\n   if (!decl_to_instance_map)"}, {"sha": "38f69ac57431381ac569b3761bb36a6ab84f3a74", "filename": "gcc/df-core.cc", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdf-core.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdf-core.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -874,7 +874,8 @@ make_pass_df_finish (gcc::context *ctxt)\n /* Helper function for df_worklist_dataflow.\n    Propagate the dataflow forward.\n    Given a BB_INDEX, do the dataflow propagation\n-   and set bits on for successors in PENDING\n+   and set bits on for successors in PENDING for earlier\n+   and WORKLIST for later in bbindex_to_postorder\n    if the out set of the dataflow has changed.\n \n    AGE specify time when BB was visited last time.\n@@ -890,10 +891,11 @@ make_pass_df_finish (gcc::context *ctxt)\n \n static bool\n df_worklist_propagate_forward (struct dataflow *dataflow,\n-                               unsigned bb_index,\n-                               unsigned *bbindex_to_postorder,\n-                               bitmap pending,\n-                               sbitmap considered,\n+\t\t\t       unsigned bb_index,\n+\t\t\t       unsigned *bbindex_to_postorder,\n+\t\t\t       bitmap worklist,\n+\t\t\t       bitmap pending,\n+\t\t\t       sbitmap considered,\n \t\t\t       vec<int> &last_change_age,\n \t\t\t       int age)\n {\n@@ -924,7 +926,13 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n           unsigned ob_index = e->dest->index;\n \n           if (bitmap_bit_p (considered, ob_index))\n-            bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+\t    {\n+\t      if (bbindex_to_postorder[bb_index]\n+\t\t  < bbindex_to_postorder[ob_index])\n+\t\tbitmap_set_bit (worklist, bbindex_to_postorder[ob_index]);\n+\t      else\n+\t\tbitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+\t    }\n         }\n       return true;\n     }\n@@ -937,10 +945,11 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n \n static bool\n df_worklist_propagate_backward (struct dataflow *dataflow,\n-                                unsigned bb_index,\n-                                unsigned *bbindex_to_postorder,\n-                                bitmap pending,\n-                                sbitmap considered,\n+\t\t\t\tunsigned bb_index,\n+\t\t\t\tunsigned *bbindex_to_postorder,\n+\t\t\t\tbitmap worklist,\n+\t\t\t\tbitmap pending,\n+\t\t\t\tsbitmap considered,\n \t\t\t\tvec<int> &last_change_age,\n \t\t\t\tint age)\n {\n@@ -971,7 +980,13 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n           unsigned ob_index = e->src->index;\n \n           if (bitmap_bit_p (considered, ob_index))\n-            bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+\t    {\n+\t      if (bbindex_to_postorder[bb_index]\n+\t\t  < bbindex_to_postorder[ob_index])\n+\t\tbitmap_set_bit (worklist, bbindex_to_postorder[ob_index]);\n+\t      else\n+\t\tbitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+\t    }\n         }\n       return true;\n     }\n@@ -1021,36 +1036,37 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n      and pending is for the next. */\n   while (!bitmap_empty_p (pending))\n     {\n-      bitmap_iterator bi;\n-      unsigned int index;\n-\n       std::swap (pending, worklist);\n \n-      EXECUTE_IF_SET_IN_BITMAP (worklist, 0, index, bi)\n+      do\n \t{\n+\t  unsigned index = bitmap_first_set_bit (worklist);\n+\t  bitmap_clear_bit (worklist, index);\n+\n \t  unsigned bb_index;\n \t  dcount++;\n \n-\t  bitmap_clear_bit (pending, index);\n \t  bb_index = blocks_in_postorder[index];\n \t  prev_age = last_visit_age[index];\n \t  if (dir == DF_FORWARD)\n \t    changed = df_worklist_propagate_forward (dataflow, bb_index,\n \t\t\t\t\t\t     bbindex_to_postorder,\n-\t\t\t\t\t\t     pending, considered,\n+\t\t\t\t\t\t     worklist, pending,\n+\t\t\t\t\t\t     considered,\n \t\t\t\t\t\t     last_change_age,\n \t\t\t\t\t\t     prev_age);\n \t  else\n \t    changed = df_worklist_propagate_backward (dataflow, bb_index,\n \t\t\t\t\t\t      bbindex_to_postorder,\n-\t\t\t\t\t\t      pending, considered,\n+\t\t\t\t\t\t      worklist, pending,\n+\t\t\t\t\t\t      considered,\n \t\t\t\t\t\t      last_change_age,\n \t\t\t\t\t\t      prev_age);\n \t  last_visit_age[index] = ++age;\n \t  if (changed)\n \t    last_change_age[index] = age;\n \t}\n-      bitmap_clear (worklist);\n+      while (!bitmap_empty_p (worklist));\n     }\n \n   BITMAP_FREE (worklist);"}, {"sha": "aec2223591a280c0df8cf27e6e6b44c3cd339540", "filename": "gcc/df.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1097,7 +1097,7 @@ extern void df_scan_verify (void);\n    Public functions access functions for the dataflow problems.\n ----------------------------------------------------------------------------*/\n \n-static inline struct df_scan_bb_info *\n+inline struct df_scan_bb_info *\n df_scan_get_bb_info (unsigned int index)\n {\n   if (index < df_scan->block_info_size)\n@@ -1106,7 +1106,7 @@ df_scan_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_rd_bb_info *\n+inline class df_rd_bb_info *\n df_rd_get_bb_info (unsigned int index)\n {\n   if (index < df_rd->block_info_size)\n@@ -1115,7 +1115,7 @@ df_rd_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_lr_bb_info *\n+inline class df_lr_bb_info *\n df_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_lr->block_info_size)\n@@ -1124,7 +1124,7 @@ df_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_md_bb_info *\n+inline class df_md_bb_info *\n df_md_get_bb_info (unsigned int index)\n {\n   if (index < df_md->block_info_size)\n@@ -1133,7 +1133,7 @@ df_md_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_live_bb_info *\n+inline class df_live_bb_info *\n df_live_get_bb_info (unsigned int index)\n {\n   if (index < df_live->block_info_size)\n@@ -1142,7 +1142,7 @@ df_live_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_word_lr_bb_info *\n+inline class df_word_lr_bb_info *\n df_word_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_word_lr->block_info_size)\n@@ -1151,7 +1151,7 @@ df_word_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_mir_bb_info *\n+inline class df_mir_bb_info *\n df_mir_get_bb_info (unsigned int index)\n {\n   if (index < df_mir->block_info_size)\n@@ -1165,7 +1165,7 @@ df_mir_get_bb_info (unsigned int index)\n    choose different dataflow problems depending on the optimization\n    level.  */\n \n-static inline bitmap\n+inline bitmap\n df_get_live_out (basic_block bb)\n {\n   gcc_checking_assert (df_lr);\n@@ -1181,7 +1181,7 @@ df_get_live_out (basic_block bb)\n    choose different dataflow problems depending on the optimization\n    level.  */\n \n-static inline bitmap\n+inline bitmap\n df_get_live_in (basic_block bb)\n {\n   gcc_checking_assert (df_lr);\n@@ -1195,7 +1195,7 @@ df_get_live_in (basic_block bb)\n /* Get basic block info.  */\n /* Get the artificial defs for a basic block.  */\n \n-static inline df_ref\n+inline df_ref\n df_get_artificial_defs (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_defs;\n@@ -1204,7 +1204,7 @@ df_get_artificial_defs (unsigned int bb_index)\n \n /* Get the artificial uses for a basic block.  */\n \n-static inline df_ref\n+inline df_ref\n df_get_artificial_uses (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_uses;\n@@ -1213,7 +1213,7 @@ df_get_artificial_uses (unsigned int bb_index)\n /* If INSN defines exactly one register, return the associated reference,\n    otherwise return null.  */\n \n-static inline df_ref\n+inline df_ref\n df_single_def (const df_insn_info *info)\n {\n   df_ref defs = DF_INSN_INFO_DEFS (info);\n@@ -1223,7 +1223,7 @@ df_single_def (const df_insn_info *info)\n /* If INSN uses exactly one register, return the associated reference,\n    otherwise return null.  */\n \n-static inline df_ref\n+inline df_ref\n df_single_use (const df_insn_info *info)\n {\n   df_ref uses = DF_INSN_INFO_USES (info);"}, {"sha": "e7390e495546f7bec93f18688ef1f4092a25cfa9", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -416,7 +416,7 @@ struct diagnostic_context\n   diagnostic_client_data_hooks *m_client_data_hooks;\n };\n \n-static inline void\n+inline void\n diagnostic_inhibit_notes (diagnostic_context * context)\n {\n   context->inhibit_notes_p = true;\n@@ -474,7 +474,7 @@ extern diagnostic_context *global_dc;\n /* Override the option index to be used for reporting a\n    diagnostic.  */\n \n-static inline void\n+inline void\n diagnostic_override_option_index (diagnostic_info *info, int optidx)\n {\n   info->option_index = optidx;\n@@ -546,15 +546,15 @@ int get_terminal_width (void);\n /* Return the location associated to this diagnostic. Parameter WHICH\n    specifies which location. By default, expand the first one.  */\n \n-static inline location_t\n+inline location_t\n diagnostic_location (const diagnostic_info * diagnostic, int which = 0)\n {\n   return diagnostic->message.get_location (which);\n }\n \n /* Return the number of locations to be printed in DIAGNOSTIC.  */\n \n-static inline unsigned int\n+inline unsigned int\n diagnostic_num_locations (const diagnostic_info * diagnostic)\n {\n   return diagnostic->message.m_richloc->get_num_locations ();\n@@ -564,7 +564,7 @@ diagnostic_num_locations (const diagnostic_info * diagnostic)\n    consistency.  Parameter WHICH specifies which location. By default,\n    expand the first one.  */\n \n-static inline expanded_location\n+inline expanded_location\n diagnostic_expand_location (const diagnostic_info * diagnostic, int which = 0)\n {\n   return diagnostic->richloc->get_expanded_location (which);\n@@ -579,7 +579,7 @@ const int CARET_LINE_MARGIN = 10;\n    caret line.  This is used to build a prefix and also to determine\n    whether to print one or two caret lines.  */\n \n-static inline bool\n+inline bool\n diagnostic_same_line (const diagnostic_context *context,\n \t\t       expanded_location s1, expanded_location s2)\n {"}, {"sha": "1ae68b0f20aa1c2ddf052134fbf90c8f6f4c96e4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -14483,7 +14483,7 @@ Similar to @code{__builtin_nan}, except the return type is\n @deftypefn {Built-in Function} double __builtin_nans (const char *str)\n Similar to @code{__builtin_nan}, except the significand is forced\n to be a signaling NaN@.  The @code{nans} function is proposed by\n-@uref{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm,,WG14 N965}.\n+@uref{https://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm,,WG14 N965}.\n @end deftypefn\n \n @deftypefn {Built-in Function} _Decimal32 __builtin_nansd32 (const char *str)"}, {"sha": "5b1858bfa508b94cede9e5fbb7427cf342536036", "filename": "gcc/doc/gm2.texi", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fgm2.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fgm2.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgm2.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -73,7 +73,7 @@ Boston, MA 02110-1301, USA@*\n * License::          License of GNU Modula-2\n * Copying::          GNU Public License V3.\n * Contributing::     Contributing to GNU Modula-2\n-* Internals::        GNU Modula-2 internals.\n+@c * Internals::        GNU Modula-2 internals.\n * EBNF::             EBNF of GNU Modula-2\n * Libraries::        PIM and ISO library definitions.\n * Indices::          Document and function indices.\n@@ -243,7 +243,7 @@ such as the AVR and the ARM).\n * Built-ins::             Accessing GNU Modula-2 Built-ins.\n * The PIM system module:: SYSTEM data types and procedures.\n * The ISO system module:: SYSTEM data types, procedures and run time.\n-@ifnothtml\n+@c @ifnothtml\n @c omit these nodes if generating gm2 webpage as these are hand written.\n * Release map:: Release map.\n * Documentation:: Placeholder for how to access the documentation online.\n@@ -253,7 +253,7 @@ such as the AVR and the ARM).\n * FAQ:: Frequently asked questions.\n * Community:: How to join the community.\n * Other languages:: Other languages for GCC.\n-@end ifnothtml\n+@c @end ifnothtml\n @end menu\n \n This document contains the user and design issues relevant to the\n@@ -2658,7 +2658,7 @@ you wish to see something different please email\n @section Documentation\n \n The GNU Modula-2 documentation is available on line\n-@url{https://www.nongnu.org/gm2/homepage.html,at the gm2 homepage}\n+@url{https://gcc.gnu.org/onlinedocs}\n or in the pdf, info, html file format.\n \n @node Regression tests, Limitations, Documentation, Using\n@@ -2746,7 +2746,7 @@ The mailing list contents can be viewed\n These exist and can be found on the frontends web page on the\n @uref{http://gcc.gnu.org/frontends.html, gcc web site}.\n \n-@node License, Copying, Using, Top\n+@node License, , ,\n @section License of GNU Modula-2\n \n GNU Modula-2 is free software, the compiler is held under the GPL v3\n@@ -2766,10 +2766,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n More information on how these licenses work is available\n @uref{http://www.gnu.org/licenses/licenses.html} on the GNU web site.\n \n-@c Copying node is inside the gpl_v3.texi\n-@include gpl_v3.texi\n+@node Copying, , ,\n+@include gpl_v3_without_node.texi\n \n-@node Contributing, Internals, Copying, Top\n+@node Contributing, , ,\n @section Contributing to GNU Modula-2\n \n Please do and please read the GNU Emacs info under\n@@ -2788,12 +2788,12 @@ coding.  The mailing list may be subscribed via a web interface\n \n Many thanks and enjoy your coding!\n \n-@node Internals, EBNF, Contributing, Top\n+@c @node Internals, , ,\n \n-This section is still being written.\n+@c This section is still being written.\n @c @include gm2-internals.texi\n \n-@node EBNF, Libraries, Internals, Top\n+@node EBNF, , ,\n @chapter EBNF of GNU Modula-2\n \n This chapter contains the EBNF of GNU Modula-2.  This grammar currently\n@@ -2807,14 +2807,14 @@ phase.\n \n @include m2/gm2-ebnf.texi\n \n-@node Libraries, Indices, EBNF, Top\n+@node Libraries, , ,\n @chapter PIM and ISO library definitions\n \n This chapter contains M2F, PIM and ISO libraries.\n \n @include m2/gm2-libs.texi\n \n-@node Indices, , Libraries, Top\n+@node Indices, , ,\n @section Indices\n \n @ifhtml\n@@ -2823,11 +2823,11 @@ This chapter contains M2F, PIM and ISO libraries.\n * Functions::   Function, constants, types, ebnf indices.\n @end menu\n \n-@node Contents, Functions, ,\n+@node Contents, , ,\n @section Section and subsections\n @printindex cp\n \n-@node Functions, , Contents,\n+@node Functions, , ,\n @section Function, constants, types, ebnf indices.\n @end ifhtml\n "}, {"sha": "4193d6fd55d4a590aa0a6cfcf6dbe88f65ddbeaa", "filename": "gcc/doc/include/gpl_v3.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finclude%2Fgpl_v3.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finclude%2Fgpl_v3.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finclude%2Fgpl_v3.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -20,7 +20,7 @@ license document, but changing it is not allowed.\n @c This file is intended to be included in another file.\n \n @display\n-Copyright @copyright{} 2007 Free Software Foundation, Inc. @url{https://fsf.org/}\n+Copyright @copyright{} 2007 Free Software Foundation, Inc. @url{https://www.fsf.org}\n \n Everyone is permitted to copy and distribute verbatim copies of this\n license document, but changing it is not allowed."}, {"sha": "8ef5c1414dab25e61028411e7c363b3a2fbe0d86", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5182,9 +5182,6 @@ support the Interix subsystem.  See above.\n \n Old target names including *-*-winnt and *-*-windowsnt are no longer used.\n \n-PW32 (i386-pc-pw32) support was never completed, and the project seems to\n-be inactive.  See @uref{http://pw32.sourceforge.net/} for more information.\n-\n UWIN support has been removed due to a lack of maintenance.\n \n @html"}, {"sha": "a5ea86f68c9faf7baf166827363c6c78955b4547", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3057,8 +3057,6 @@ following code is well-formed under ISO C++11, but is ill-formed when\n @option{-fchar8_t} is specified.\n \n @smallexample\n-char ca[] = u8\"xx\";     // error: char-array initialized from wide\n-                        //        string\n const char *cp = u8\"xx\";// error: invalid conversion from\n                         //        `const char8_t*' to `const char*'\n int f(const char*);\n@@ -4284,6 +4282,10 @@ b->f();\n @noindent\n fails to compile.\n \n+In cases where the different signatures are not an accident, the\n+simplest solution is to add a using-declaration to the derived class\n+to un-hide the base function, e.g. add @code{using A::f;} to @code{B}.\n+\n The optional level suffix controls the behavior when all the\n declarations in the derived class override virtual functions in the\n base class, even if not all of the base functions are overridden:\n@@ -6085,7 +6087,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wunused-label     @gol\n -Wunused-value     @gol\n -Wunused-variable  @gol\n--Wuse-after-free=3  @gol\n+-Wuse-after-free=2  @gol\n -Wvla-parameter @r{(C and Objective-C only)} @gol\n -Wvolatile-register-var  @gol\n -Wzero-length-bounds}\n@@ -6287,6 +6289,23 @@ union U @{\n \n @end itemize\n \n+@item -Wno-changes-meaning @r{(C++ and Objective-C++ only)}\n+C++ requires that unqualified uses of a name within a class have the\n+same meaning in the complete scope of the class, so declaring the name\n+after using it is ill-formed:\n+@smallexample\n+struct A;\n+struct B1 @{ A a; typedef A A; @}; // warning, 'A' changes meaning\n+struct B2 @{ A a; struct A @{ @}; @}; // error, 'A' changes meaning\n+@end smallexample\n+By default, the B1 case is only a warning because the two declarations\n+have the same type, while the B2 case is an error.  Both diagnostics\n+can be disabled with @option{-Wno-changes-meaning}.  Alternately, the\n+error case can be reduced to a warning with\n+@option{-Wno-error=changes-meaning} or @option{-fpermissive}.\n+\n+Both diagnostics are also suppressed by @option{-fms-extensions}.\n+\n @item -Wchar-subscripts\n @opindex Wchar-subscripts\n @opindex Wno-char-subscripts\n@@ -10064,6 +10083,13 @@ code, and issues warnings for problems found on them.\n \n This analysis is much more expensive than other GCC warnings.\n \n+In technical terms, it performs coverage-guided symbolic execution of\n+the code being compiled.  It is neither sound nor complete: it can\n+have false positives and false negatives.  It is a bug-finding tool,\n+rather than a tool for proving program correctness.\n+\n+The analyzer is only suitable for use on C code in this release.\n+\n Enabling this option effectively enables the following warnings:\n \n @gccoptlist{ @gol\n@@ -14652,8 +14678,8 @@ The names of specific parameters, and the meaning of the values, are\n tied to the internals of the compiler, and are subject to change\n without notice in future releases.\n \n-In order to get minimal, maximal and default value of a parameter,\n-one can use @option{--help=param -Q} options.\n+In order to get the minimal, maximal and default values of a parameter,\n+use the @option{--help=param -Q} options.\n \n In each case, the @var{value} is an integer.  The following choices\n of @var{name} are recognized for all targets:\n@@ -15489,6 +15515,9 @@ available alternatives for preferred register class even if it has\n found some choice with an appropriate register class and respect the\n found qualified matching constraint.\n \n+@item ira-simple-lra-insn-threshold\n+Approximate function insn number in 1K units triggering simple local RA.\n+\n @item lra-inheritance-ebb-probability-cutoff\n LRA tries to reuse values reloaded in registers in subsequent insns.\n This optimization is called inheritance.  EBB is used as a region to\n@@ -15784,6 +15813,10 @@ is greater or equal to this number, use callbacks instead of inline checks.\n E.g. to disable inline code use\n @option{--param asan-instrumentation-with-call-threshold=0}.\n \n+@item asan-kernel-mem-intrinsic-prefix\n+Prefix calls to memcpy, memset and memmove with __asan_ or __hwasan_\n+for -fsanitize=kernel-address or -fsanitize=kernel-hwaddress.\n+\n @item hwasan-instrument-stack\n Enable hwasan instrumentation of statically sized stack-allocated variables.\n This kind of instrumentation is enabled by default when using"}, {"sha": "c348a1e47cc3a91d2cae2b9570bb9fc3f0f24fc6", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -154,8 +154,7 @@ uncompressing GCC's intermediate language in LTO object files.\n The build system in the top level directory, including how recursion\n into subdirectories works and how building runtime libraries for\n multilibs is handled, is documented in a separate manual, included\n-with GNU Binutils.  @xref{Top, , GNU configure and build system,\n-configure, The GNU configure and build system}, for details.\n+with GNU Binutils.\n \n @node gcc Directory\n @section The @file{gcc} Subdirectory"}, {"sha": "34fabe40c1893f2d30794e44e1b11762abf562de", "filename": "gcc/dominance.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdominance.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdominance.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -639,18 +639,25 @@ dom_info::calc_idoms ()\n static void\n assign_dfs_numbers (struct et_node *node, int *num)\n {\n-  struct et_node *son;\n-\n-  node->dfs_num_in = (*num)++;\n-\n-  if (node->son)\n+  et_node *n = node;\n+  while (1)\n     {\n-      assign_dfs_numbers (node->son, num);\n-      for (son = node->son->right; son != node->son; son = son->right)\n-\tassign_dfs_numbers (son, num);\n+      n->dfs_num_in = (*num)++;\n+      if (n->son)\n+\tn = n->son;\n+      else\n+\t{\n+\t  while (!n->right || n->right == n->father->son)\n+\t    {\n+\t      n->dfs_num_out = (*num)++;\n+\t      if (n == node)\n+\t\treturn;\n+\t      n = n->father;\n+\t    }\n+\t  n->dfs_num_out = (*num)++;\n+\t  n = n->right;\n+\t}\n     }\n-\n-  node->dfs_num_out = (*num)++;\n }\n \n /* Compute the data necessary for fast resolving of dominator queries in a"}, {"sha": "ddac0f58050d34130ebbd6aa3b1adfa39c4c216c", "filename": "gcc/dominance.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -69,7 +69,7 @@ extern void verify_dominators (enum cdi_direction);\n /* Verify invariants of computed dominance information, if internal consistency\n    checks are enabled.  */\n \n-static inline void\n+inline void\n checking_verify_dominators (cdi_direction dir)\n {\n   if (flag_checking)"}, {"sha": "7d5eca899dcc98676a9ce7a7efff8e439854ff89", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -208,35 +208,35 @@ enum dump_flag : uint32_t\n \n typedef enum dump_flag dump_flags_t;\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator| (dump_flags_t lhs, dump_flags_t rhs)\n {\n   return (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t| (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator& (dump_flags_t lhs, dump_flags_t rhs)\n {\n   return (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t& (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator~ (dump_flags_t flags)\n {\n   return (dump_flags_t)~((std::underlying_type<dump_flags_t>::type)flags);\n }\n \n-static inline dump_flags_t &\n+inline dump_flags_t &\n operator|= (dump_flags_t &lhs, dump_flags_t rhs)\n {\n   lhs = (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t       | (std::underlying_type<dump_flags_t>::type)rhs);\n   return lhs;\n }\n \n-static inline dump_flags_t &\n+inline dump_flags_t &\n operator&= (dump_flags_t &lhs, dump_flags_t rhs)\n {\n   lhs = (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n@@ -276,14 +276,14 @@ enum optgroup_flag\n \n typedef enum optgroup_flag optgroup_flags_t;\n \n-static inline optgroup_flags_t\n+inline optgroup_flags_t\n operator| (optgroup_flags_t lhs, optgroup_flags_t rhs)\n {\n   return (optgroup_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t    | (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline optgroup_flags_t &\n+inline optgroup_flags_t &\n operator|= (optgroup_flags_t &lhs, optgroup_flags_t rhs)\n {\n   lhs = (optgroup_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n@@ -528,7 +528,7 @@ extern bool dumps_are_enabled;\n extern void set_dump_file (FILE *new_dump_file);\n \n /* Return true if any of the dumps is enabled, false otherwise. */\n-static inline bool\n+inline bool\n dump_enabled_p (void)\n {\n   return dumps_are_enabled;"}, {"sha": "57283c10a299a4b9af75569a1c63703a54aa10b5", "filename": "gcc/dwarf2cfi.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdwarf2cfi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fdwarf2cfi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1496,18 +1496,21 @@ dwarf2out_frame_debug_cfa_val_expression (rtx set)\n   update_row_reg_save (cur_row, dwf_regno (dest), cfi);\n }\n \n-/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE\n+   note. When called with EMIT_CFI set to false emitting a CFI\n+   statement is suppressed.  */\n \n static void\n-dwarf2out_frame_debug_cfa_restore (rtx reg)\n+dwarf2out_frame_debug_cfa_restore (rtx reg, bool emit_cfi)\n {\n   gcc_assert (REG_P (reg));\n \n   rtx span = targetm.dwarf_register_span (reg);\n   if (!span)\n     {\n       unsigned int regno = dwf_regno (reg);\n-      add_cfi_restore (regno);\n+      if (emit_cfi)\n+\tadd_cfi_restore (regno);\n       update_row_reg_save (cur_row, regno, NULL);\n     }\n   else\n@@ -1522,7 +1525,8 @@ dwarf2out_frame_debug_cfa_restore (rtx reg)\n \t  reg = XVECEXP (span, 0, par_index);\n \t  gcc_assert (REG_P (reg));\n \t  unsigned int regno = dwf_regno (reg);\n-\t  add_cfi_restore (regno);\n+\t  if (emit_cfi)\n+\t    add_cfi_restore (regno);\n \t  update_row_reg_save (cur_row, regno, NULL);\n \t}\n     }\n@@ -2309,6 +2313,7 @@ dwarf2out_frame_debug (rtx_insn *insn)\n \tbreak;\n \n       case REG_CFA_RESTORE:\n+      case REG_CFA_NO_RESTORE:\n \tn = XEXP (note, 0);\n \tif (n == NULL)\n \t  {\n@@ -2317,7 +2322,7 @@ dwarf2out_frame_debug (rtx_insn *insn)\n \t      n = XVECEXP (n, 0, 0);\n \t    n = XEXP (n, 0);\n \t  }\n-\tdwarf2out_frame_debug_cfa_restore (n);\n+\tdwarf2out_frame_debug_cfa_restore (n, REG_NOTE_KIND (note) == REG_CFA_RESTORE);\n \thandled_one = true;\n \tbreak;\n "}, {"sha": "c472c736cb66acf821d54ab899ed6e425faa0658", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -400,15 +400,15 @@ extern bool need_atomic_barrier_p (enum memmodel, bool);\n \n /* Return the current sequence.  */\n \n-static inline struct sequence_stack *\n+inline struct sequence_stack *\n get_current_sequence (void)\n {\n   return &crtl->emit.seq;\n }\n \n /* Return the outermost sequence.  */\n \n-static inline struct sequence_stack *\n+inline struct sequence_stack *\n get_topmost_sequence (void)\n {\n   struct sequence_stack *seq, *top;\n@@ -424,15 +424,15 @@ get_topmost_sequence (void)\n \n /* Return the first insn of the current sequence or current function.  */\n \n-static inline rtx_insn *\n+inline rtx_insn *\n get_insns (void)\n {\n   return get_current_sequence ()->first;\n }\n \n /* Specify a new insn as the first in the chain.  */\n \n-static inline void\n+inline void\n set_first_insn (rtx_insn *insn)\n {\n   gcc_checking_assert (!insn || !PREV_INSN (insn));\n@@ -441,15 +441,15 @@ set_first_insn (rtx_insn *insn)\n \n /* Return the last insn emitted in current sequence or current function.  */\n \n-static inline rtx_insn *\n+inline rtx_insn *\n get_last_insn (void)\n {\n   return get_current_sequence ()->last;\n }\n \n /* Specify a new insn as the last in the chain.  */\n \n-static inline void\n+inline void\n set_last_insn (rtx_insn *insn)\n {\n   gcc_checking_assert (!insn || !NEXT_INSN (insn));\n@@ -458,7 +458,7 @@ set_last_insn (rtx_insn *insn)\n \n /* Return a number larger than any instruction's uid in this function.  */\n \n-static inline int\n+inline int\n get_max_uid (void)\n {\n   return crtl->emit.x_cur_insn_uid;"}, {"sha": "5ecdbc0d1dc2959810db8d943ae298acfb55c56a", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -302,7 +302,7 @@ function_needs_eh_personality (struct function *);\n \n /* Pre-order iteration within the eh_region tree.  */\n \n-static inline eh_region\n+inline eh_region\n ehr_next (eh_region r, eh_region start)\n {\n   if (r->inner)"}, {"sha": "c1aee00c616b5a10b341c20bda895440066d8124", "filename": "gcc/expmed.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -191,31 +191,31 @@ extern struct target_expmed *this_target_expmed;\n \n /* Return a pointer to the alg_hash_entry at IDX.  */\n \n-static inline struct alg_hash_entry *\n+inline struct alg_hash_entry *\n alg_hash_entry_ptr (int idx)\n {\n   return &this_target_expmed->x_alg_hash[idx];\n }\n \n /* Return true if the x_alg_hash field might have been used.  */\n \n-static inline bool\n+inline bool\n alg_hash_used_p (void)\n {\n   return this_target_expmed->x_alg_hash_used_p;\n }\n \n /* Set whether the x_alg_hash field might have been used.  */\n \n-static inline void\n+inline void\n set_alg_hash_used_p (bool usedp)\n {\n   this_target_expmed->x_alg_hash_used_p = usedp;\n }\n \n /* Compute an index into the cost arrays by mode class.  */\n \n-static inline int\n+inline int\n expmed_mode_index (machine_mode mode)\n {\n   switch (GET_MODE_CLASS (mode))\n@@ -244,7 +244,7 @@ expmed_mode_index (machine_mode mode)\n    a particular operation performed in MODE is cheap when optimizing\n    for SPEED.  */\n \n-static inline bool *\n+inline bool *\n expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n \t\t     machine_mode mode)\n {\n@@ -255,7 +255,7 @@ expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n /* Return a pointer to a cost contained in COSTS when a particular\n    operation is performed in MODE when optimizing for SPEED.  */\n \n-static inline int *\n+inline int *\n expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n \t\t    machine_mode mode)\n {\n@@ -265,7 +265,7 @@ expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n \n /* Subroutine of {set_,}sdiv_pow2_cheap.  Not to be used otherwise.  */\n \n-static inline bool *\n+inline bool *\n sdiv_pow2_cheap_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cheap_ptr (&this_target_expmed->x_sdiv_pow2_cheap,\n@@ -275,7 +275,7 @@ sdiv_pow2_cheap_ptr (bool speed, machine_mode mode)\n /* Set whether a signed division by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_sdiv_pow2_cheap (bool speed, machine_mode mode, bool cheap_p)\n {\n   *sdiv_pow2_cheap_ptr (speed, mode) = cheap_p;\n@@ -284,15 +284,15 @@ set_sdiv_pow2_cheap (bool speed, machine_mode mode, bool cheap_p)\n /* Return whether a signed division by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline bool\n+inline bool\n sdiv_pow2_cheap (bool speed, machine_mode mode)\n {\n   return *sdiv_pow2_cheap_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}smod_pow2_cheap.  Not to be used otherwise.  */\n \n-static inline bool *\n+inline bool *\n smod_pow2_cheap_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cheap_ptr (&this_target_expmed->x_smod_pow2_cheap,\n@@ -302,7 +302,7 @@ smod_pow2_cheap_ptr (bool speed, machine_mode mode)\n /* Set whether a signed modulo by a power of 2 is CHEAP in MODE when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_smod_pow2_cheap (bool speed, machine_mode mode, bool cheap)\n {\n   *smod_pow2_cheap_ptr (speed, mode) = cheap;\n@@ -311,71 +311,71 @@ set_smod_pow2_cheap (bool speed, machine_mode mode, bool cheap)\n /* Return whether a signed modulo by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline bool\n+inline bool\n smod_pow2_cheap (bool speed, machine_mode mode)\n {\n   return *smod_pow2_cheap_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}zero_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n zero_cost_ptr (bool speed)\n {\n   return &this_target_expmed->x_zero_cost[speed];\n }\n \n /* Set the COST of loading zero when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_zero_cost (bool speed, int cost)\n {\n   *zero_cost_ptr (speed) = cost;\n }\n \n /* Return the COST of loading zero when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n zero_cost (bool speed)\n {\n   return *zero_cost_ptr (speed);\n }\n \n /* Subroutine of {set_,}add_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n add_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_add_cost, speed, mode);\n }\n \n /* Set the COST of computing an add in MODE when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_add_cost (bool speed, machine_mode mode, int cost)\n {\n   *add_cost_ptr (speed, mode) = cost;\n }\n \n /* Return the cost of computing an add in MODE when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n add_cost (bool speed, machine_mode mode)\n {\n   return *add_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}neg_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n neg_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_neg_cost, speed, mode);\n }\n \n /* Set the COST of computing a negation in MODE when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_neg_cost (bool speed, machine_mode mode, int cost)\n {\n   *neg_cost_ptr (speed, mode) = cost;\n@@ -384,15 +384,15 @@ set_neg_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of computing a negation in MODE when optimizing for\n    SPEED.  */\n \n-static inline int\n+inline int\n neg_cost (bool speed, machine_mode mode)\n {\n   return *neg_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}shift_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shift_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shift_cost[bits],\n@@ -401,7 +401,7 @@ shift_cost_ptr (bool speed, machine_mode mode, int bits)\n \n /* Set the COST of doing a shift in MODE by BITS when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shift_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shift_cost_ptr (speed, mode, bits) = cost;\n@@ -410,15 +410,15 @@ set_shift_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS when optimizing for\n    SPEED.  */\n \n-static inline int\n+inline int\n shift_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shift_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftadd_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftadd_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftadd_cost[bits],\n@@ -428,7 +428,7 @@ shiftadd_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of doing a shift in MODE by BITS followed by an add when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftadd_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftadd_cost_ptr (speed, mode, bits) = cost;\n@@ -437,15 +437,15 @@ set_shiftadd_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS followed by an add\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftadd_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftadd_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftsub0_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftsub0_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub0_cost[bits],\n@@ -455,7 +455,7 @@ shiftsub0_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of doing a shift in MODE by BITS and then subtracting a\n    value when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftsub0_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftsub0_cost_ptr (speed, mode, bits) = cost;\n@@ -464,15 +464,15 @@ set_shiftsub0_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS and then subtracting\n    a value when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftsub0_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftsub0_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftsub1_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftsub1_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub1_cost[bits],\n@@ -482,7 +482,7 @@ shiftsub1_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of subtracting a shift in MODE by BITS from a value when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftsub1_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftsub1_cost_ptr (speed, mode, bits) = cost;\n@@ -491,15 +491,15 @@ set_shiftsub1_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of subtracting a shift in MODE by BITS from a value\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftsub1_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftsub1_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}mul_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_mul_cost, speed, mode);\n@@ -508,7 +508,7 @@ mul_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing a multiplication in MODE when optimizing for\n    SPEED.  */\n \n-static inline void\n+inline void\n set_mul_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_cost_ptr (speed, mode) = cost;\n@@ -517,15 +517,15 @@ set_mul_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing a multiplication in MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n mul_cost (bool speed, machine_mode mode)\n {\n   return *mul_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}sdiv_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n sdiv_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_sdiv_cost, speed, mode);\n@@ -534,7 +534,7 @@ sdiv_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing a signed division in MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_sdiv_cost (bool speed, machine_mode mode, int cost)\n {\n   *sdiv_cost_ptr (speed, mode) = cost;\n@@ -543,15 +543,15 @@ set_sdiv_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing a signed division in MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n sdiv_cost (bool speed, machine_mode mode)\n {\n   return *sdiv_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}udiv_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n udiv_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_udiv_cost, speed, mode);\n@@ -560,7 +560,7 @@ udiv_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing an unsigned division in MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_udiv_cost (bool speed, machine_mode mode, int cost)\n {\n   *udiv_cost_ptr (speed, mode) = cost;\n@@ -569,15 +569,15 @@ set_udiv_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing an unsigned division in MODE when\n    optimizing for SPEED.  */\n \n-static inline int\n+inline int\n udiv_cost (bool speed, machine_mode mode)\n {\n   return *udiv_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}mul_widen_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_widen_cost_ptr (bool speed, machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n@@ -588,7 +588,7 @@ mul_widen_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST for computing a widening multiplication in MODE when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_mul_widen_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_widen_cost_ptr (speed, mode) = cost;\n@@ -597,15 +597,15 @@ set_mul_widen_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost for computing a widening multiplication in MODE when\n    optimizing for SPEED.  */\n \n-static inline int\n+inline int\n mul_widen_cost (bool speed, machine_mode mode)\n {\n   return *mul_widen_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}mul_highpart_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_highpart_cost_ptr (bool speed, machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n@@ -618,7 +618,7 @@ mul_highpart_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST for computing the high part of a multiplication in MODE\n    when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_mul_highpart_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_highpart_cost_ptr (speed, mode) = cost;\n@@ -627,15 +627,15 @@ set_mul_highpart_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost for computing the high part of a multiplication in MODE\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n mul_highpart_cost (bool speed, machine_mode mode)\n {\n   return *mul_highpart_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}convert_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n convert_cost_ptr (machine_mode to_mode, machine_mode from_mode,\n \t\t  bool speed)\n {\n@@ -651,7 +651,7 @@ convert_cost_ptr (machine_mode to_mode, machine_mode from_mode,\n /* Set the COST for converting from FROM_MODE to TO_MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_convert_cost (machine_mode to_mode, machine_mode from_mode,\n \t\t  bool speed, int cost)\n {\n@@ -661,7 +661,7 @@ set_convert_cost (machine_mode to_mode, machine_mode from_mode,\n /* Return the cost for converting from FROM_MODE to TO_MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n convert_cost (machine_mode to_mode, machine_mode from_mode,\n \t      bool speed)\n {"}, {"sha": "0c059ed9023bc5bdce467594fb35918dbeb1b25d", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -84,19 +84,19 @@ extern rtx convert_wider_int_to_float (machine_mode mode, machine_mode imode,\n extern rtx emit_block_op_via_libcall (enum built_in_function, rtx, rtx, rtx,\n \t\t\t\t      bool);\n \n-static inline rtx\n+inline rtx\n emit_block_copy_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMCPY, dst, src, size, tailcall);\n }\n \n-static inline rtx\n+inline rtx\n emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMMOVE, dst, src, size, tailcall);\n }\n \n-static inline rtx\n+inline rtx\n emit_block_comp_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMCMP, dst, src, size, tailcall);\n@@ -178,14 +178,14 @@ extern void clobber_reg_mode (rtx *, rtx, machine_mode);\n extern rtx copy_blkmode_to_reg (machine_mode, tree);\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-static inline void\n+inline void\n use_reg (rtx *fusage, rtx reg)\n {\n   use_reg_mode (fusage, reg, VOIDmode);\n }\n \n /* Mark REG as clobbered by the call with FUSAGE as CALL_INSN_FUNCTION_USAGE.  */\n-static inline void\n+inline void\n clobber_reg (rtx *fusage, rtx reg)\n {\n   clobber_reg_mode (fusage, reg, VOIDmode);\n@@ -303,14 +303,14 @@ extern rtx expand_expr_real_2 (sepops, rtx, machine_mode,\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n-static inline rtx\n+inline rtx\n expand_expr (tree exp, rtx target, machine_mode mode,\n \t     enum expand_modifier modifier)\n {\n   return expand_expr_real (exp, target, mode, modifier, NULL, false);\n }\n \n-static inline rtx\n+inline rtx\n expand_normal (tree exp)\n {\n   return expand_expr_real (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL, NULL, false);"}, {"sha": "8d1002ac6f089b170f8c249049b28a051391e57f", "filename": "gcc/fixed-value.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -51,7 +51,7 @@ extern FIXED_VALUE_TYPE fixed_from_double_int (double_int, scalar_mode);\n \n /* Return a CONST_FIXED from a bit payload and machine mode MODE.\n    The bits in PAYLOAD are sign-extended/zero-extended according to MODE.  */\n-static inline rtx\n+inline rtx\n const_fixed_from_double_int (double_int payload,\n \t\t\t     scalar_mode mode)\n {"}, {"sha": "2253b6e333b429ccc4248afa7ea5ff49f1cde58e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,102 @@\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* gfortran.h: Mechanically drop static from static inline\n+\tfunctions via s/^static inline/inline/g.\n+\n+2023-02-15  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/103608\n+\t* frontend-passes.cc (do_intent): Catch NULL pointer dereference on\n+\treference to invalid formal argument.\n+\n+2023-02-15  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/104554\n+\t* resolve.cc (check_assumed_size_reference): Avoid NULL pointer\n+\tdereference.\n+\n+2023-02-15  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/108512\n+\t* openmp.cc (gfc_resolve_omp_parallel_blocks): Handle combined 'loop'\n+\tdirectives.\n+\t(gfc_resolve_do_iterator): Set a source location for added\n+\t'private'-clause arguments.\n+\t* resolve.cc (gfc_resolve_code): Call gfc_resolve_omp_do_blocks\n+\talso for EXEC_OMP_LOOP and gfc_resolve_omp_parallel_blocks for\n+\tcombined directives with loop + '{masked,master} taskloop (simd)'.\n+\n+2023-02-13  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/103475\n+\t* primary.cc (gfc_expr_attr): Avoid NULL pointer dereference for\n+\tinvalid use of CLASS variable.\n+\n+2023-02-13  Rimvydas Jasinskas  <rimvydas.jas@gmail.com>\n+\n+\t* decl.cc: Add EXT_ATTR_NOINLINE, EXT_ATTR_NORETURN, EXT_ATTR_WEAK.\n+\t* gfortran.h (ext_attr_id_t): Ditto.\n+\t* gfortran.texi (GCC$ ATTRIBUTES): Document them.\n+\t* trans-decl.cc (build_function_decl): Apply them.\n+\n+2023-02-09  Harald Anlauf  <anlauf@gmx.de>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/69636\n+\tPR fortran/103779\n+\t* intrinsic.cc (gfc_convert_chartype): Recover on invalid character\n+\tkind in conversion instead of generating an internal error.\n+\n+2023-02-09  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/107424\n+\t* trans-openmp.cc (struct dovar_init_d): Add 'sym' and\n+\t'non_unit_incr' members.\n+\t(gfc_nonrect_loop_expr): New.\n+\t(gfc_trans_omp_do): Call it; use normal loop bounds\n+\tfor unit stride - and only create local loop var.\n+\n+2023-02-09  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* parse.cc (decode_omp_directive): Really ignore 'assumes' with\n+\t-fopenmp-simd.\n+\n+2023-02-08  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/103259\n+\t* resolve.cc (resolve_common_vars): Avoid NULL pointer dereference\n+\twhen a symbol's location is not set.\n+\n+2023-02-07  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/95107\n+\t* trans-decl.cc (gfc_finish_var_decl): With -fno-automatic, do not\n+\tmake ASSOCIATE variables TREE_STATIC.\n+\n+2023-02-05  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108592\n+\t* arith.cc (gfc_arith_divide): Emit integer division truncation\n+\twarnings using gfc_warning instead of gfc_warning_now to prevent\n+\tredundant messages.\n+\n+2023-02-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/108451\n+\t* trans-decl.cc (gfc_trans_use_stmts): Call clear_slot before\n+\tdoing continue.\n+\n+2023-02-01  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108609\n+\t* expr.cc (find_array_section): Add check to prevent interpreting an\n+\tmpz non-integer constant as an integer.\n+\n+2023-02-01  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* openmp.cc (resolve_omp_clauses): Check also for\n+\tpower of two.\n+\n 2023-01-29  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/108450"}, {"sha": "d0d1c0b03d225f3914cb75af07d676e6cd354d09", "filename": "gcc/fortran/arith.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Farith.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Farith.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -778,7 +778,7 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t    {\n \t      char *p;\n \t      p = mpz_get_str (NULL, 10, result->value.integer);\n-\t      gfc_warning_now (OPT_Winteger_division, \"Integer division \"\n+\t      gfc_warning (OPT_Winteger_division, \"Integer division \"\n \t\t\t       \"truncated to constant %qs at %L\", p,\n \t\t\t       &op1->where);\n \t      free (p);"}, {"sha": "eec0314cf4c3f2d5487b9f48362a396fb89e0ab2", "filename": "gcc/fortran/decl.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -11732,6 +11732,9 @@ const ext_attr_t ext_attr_list[] = {\n   { \"fastcall\",     EXT_ATTR_FASTCALL,     \"fastcall\"  },\n   { \"no_arg_check\", EXT_ATTR_NO_ARG_CHECK, NULL        },\n   { \"deprecated\",   EXT_ATTR_DEPRECATED,   NULL\t       },\n+  { \"noinline\",     EXT_ATTR_NOINLINE,     NULL\t       },\n+  { \"noreturn\",     EXT_ATTR_NORETURN,     NULL\t       },\n+  { \"weak\",\t    EXT_ATTR_WEAK,\t   NULL\t       },\n   { NULL,           EXT_ATTR_LAST,         NULL        }\n };\n "}, {"sha": "c295721b9d6d531d918161f8c42b53dc18a928d7", "filename": "gcc/fortran/expr.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1552,7 +1552,11 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       lower = ref->u.ar.as->lower[d];\n       upper = ref->u.ar.as->upper[d];\n \n-      if (!lower || !upper)\n+      if (!lower || !upper\n+\t  || lower->expr_type != EXPR_CONSTANT\n+\t  || upper->expr_type != EXPR_CONSTANT\n+\t  || lower->ts.type != BT_INTEGER\n+\t  || upper->ts.type != BT_INTEGER)\n \t{\n \t  t = false;\n \t  goto cleanup;"}, {"sha": "02fcb41dbc4112abceb0dd397d01b8d557450765", "filename": "gcc/fortran/frontend-passes.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ffrontend-passes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ffrontend-passes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3049,7 +3049,8 @@ do_intent (gfc_expr **e)\n \t  do_sym = dl->ext.iterator->var->symtree->n.sym;\n \n \t  if (a->expr && a->expr->symtree\n-\t      && a->expr->symtree->n.sym == do_sym)\n+\t      && a->expr->symtree->n.sym == do_sym\n+\t      && f->sym)\n \t    {\n \t      if (f->sym->attr.intent == INTENT_OUT)\n \t\tgfc_error_now (\"Variable %qs at %L set to undefined value \""}, {"sha": "fea25312cf433c829e8291fe359932c54bea2904", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -838,6 +838,9 @@ typedef enum\n   EXT_ATTR_FASTCALL,\n   EXT_ATTR_NO_ARG_CHECK,\n   EXT_ATTR_DEPRECATED,\n+  EXT_ATTR_NOINLINE,\n+  EXT_ATTR_NORETURN,\n+  EXT_ATTR_WEAK,\n   EXT_ATTR_LAST, EXT_ATTR_NUM = EXT_ATTR_LAST\n }\n ext_attr_id_t;\n@@ -3273,7 +3276,7 @@ void gfc_done_2 (void);\n int get_c_kind (const char *, CInteropKind_t *);\n \n const char *gfc_closest_fuzzy_match (const char *, char **);\n-static inline void\n+inline void\n vec_push (char **&optr, size_t &osz, const char *elt)\n {\n   /* {auto,}vec.safe_push () replacement.  Don't ask..  */\n@@ -3549,7 +3552,7 @@ void gfc_intrinsic_done_1 (void);\n \n char gfc_type_letter (bt, bool logical_equals_int = false);\n int gfc_type_abi_kind (bt, int);\n-static inline int\n+inline int\n gfc_type_abi_kind (gfc_typespec *ts)\n {\n   return gfc_type_abi_kind (ts->type, ts->kind);"}, {"sha": "c483e13686d9340f731466c7174912ee2794c7ad", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3246,6 +3246,13 @@ requires an explicit interface.\n @item @code{DEPRECATED} -- print a warning when using a such-tagged\n deprecated procedure, variable or parameter; the warning can be suppressed\n with @option{-Wno-deprecated-declarations}.\n+@item @code{NOINLINE} -- prevent inlining given function.\n+@item @code{NORETURN} -- add a hint that a given function cannot return.\n+@item @code{WEAK} -- emit the declaration of an external symbol as a weak\n+symbol rather than a global.  This is primarily useful in defining library\n+functions that can be overridden in user code, though it can also be used with\n+non-function declarations.  The overriding symbol must have the same type as\n+the weak symbol.\n @end itemize\n \n "}, {"sha": "17ee999c3b9767327e9d3008c0229a6c5a94eff3", "filename": "gcc/fortran/intrinsic.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fintrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fintrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5419,7 +5419,8 @@ gfc_convert_chartype (gfc_expr *expr, gfc_typespec *ts)\n   gcc_assert (expr->ts.type == BT_CHARACTER && ts->type == BT_CHARACTER);\n \n   sym = find_char_conv (&expr->ts, ts);\n-  gcc_assert (sym);\n+  if (sym == NULL)\n+    return false;\n \n   /* Insert a pre-resolved function call to the right function.  */\n   old_where = expr->where;"}, {"sha": "abca146d78ee2222c524a498a6d84e5f8f5170a7", "filename": "gcc/fortran/openmp.cc", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fopenmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fopenmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -7392,11 +7392,12 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t      || n->u.align->ts.type != BT_INTEGER\n \t      || n->u.align->rank != 0\n \t      || gfc_extract_int (n->u.align, &alignment)\n-\t      || alignment <= 0)\n+\t      || alignment <= 0\n+\t      || !pow2p_hwi (alignment))\n \t    {\n-\t      gfc_error (\"ALIGN modifier requires a scalar positive \"\n-\t\t\t \"constant integer alignment expression at %L\",\n-\t\t\t &n->u.align->where);\n+\t      gfc_error (\"ALIGN modifier requires at %L a scalar positive \"\n+\t\t\t \"constant integer alignment expression that is a \"\n+\t\t\t \"power of two\", &n->u.align->where);\n \t      break;\n \t    }\n \t}\n@@ -9124,28 +9125,32 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n     {\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_MASKED_TASKLOOP:\n+    case EXEC_OMP_MASKED_TASKLOOP_SIMD:\n+    case EXEC_OMP_MASTER_TASKLOOP:\n+    case EXEC_OMP_MASTER_TASKLOOP_SIMD:\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_PARALLEL_LOOP:\n     case EXEC_OMP_PARALLEL_MASKED_TASKLOOP:\n     case EXEC_OMP_PARALLEL_MASKED_TASKLOOP_SIMD:\n     case EXEC_OMP_PARALLEL_MASTER_TASKLOOP:\n     case EXEC_OMP_PARALLEL_MASTER_TASKLOOP_SIMD:\n-    case EXEC_OMP_MASKED_TASKLOOP:\n-    case EXEC_OMP_MASKED_TASKLOOP_SIMD:\n-    case EXEC_OMP_MASTER_TASKLOOP:\n-    case EXEC_OMP_MASTER_TASKLOOP_SIMD:\n     case EXEC_OMP_TARGET_PARALLEL_DO:\n     case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_PARALLEL_LOOP:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_LOOP:\n     case EXEC_OMP_TASKLOOP:\n     case EXEC_OMP_TASKLOOP_SIMD:\n     case EXEC_OMP_TEAMS_DISTRIBUTE:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n     case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TEAMS_LOOP:\n       gfc_resolve_omp_do_blocks (code, ns);\n       break;\n     default:\n@@ -9224,6 +9229,7 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym, bool add_clause)\n \n       p = gfc_get_omp_namelist ();\n       p->sym = sym;\n+      p->where = omp_current_ctx->code->loc;\n       p->next = omp_clauses->lists[OMP_LIST_PRIVATE];\n       omp_clauses->lists[OMP_LIST_PRIVATE] = p;\n     }"}, {"sha": "f5154d97ae85de47e310d70aedf457e2839bfa8c", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -885,6 +885,9 @@ decode_omp_directive (void)\n   switch (c)\n     {\n     case 'a':\n+      /* For -fopenmp-simd, ignore 'assumes'; note no clause starts with 's'. */\n+      if (!flag_openmp && gfc_match (\"assumes\") == MATCH_YES)\n+\tbreak;\n       matcho (\"assumes\", gfc_match_omp_assumes, ST_OMP_ASSUMES);\n       matchs (\"assume\", gfc_match_omp_assume, ST_OMP_ASSUME);\n       matcho (\"atomic\", gfc_match_omp_atomic, ST_OMP_ATOMIC);"}, {"sha": "1bea17d44fe603086382d3ce75a8843bb346b99e", "filename": "gcc/fortran/primary.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fprimary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fprimary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2770,7 +2770,7 @@ gfc_expr_attr (gfc_expr *e)\n \t{\n \t  gfc_symbol *sym = e->value.function.esym->result;\n \t  attr = sym->attr;\n-\t  if (sym->ts.type == BT_CLASS)\n+\t  if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n \t    {\n \t      attr.dimension = CLASS_DATA (sym)->attr.dimension;\n \t      attr.pointer = CLASS_DATA (sym)->attr.class_pointer;"}, {"sha": "fb0745927acd026cf9267ab53cf01cb7a600a2e6", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -953,9 +953,15 @@ resolve_common_vars (gfc_common_head *common_block, bool named_common)\n     {\n       gsym = gfc_find_gsymbol (gfc_gsym_root, csym->name);\n       if (gsym && (gsym->type == GSYM_MODULE || gsym->type == GSYM_PROGRAM))\n-\tgfc_error_now (\"Global entity %qs at %L cannot appear in a \"\n-\t\t\t\"COMMON block at %L\", gsym->name,\n-\t\t\t&gsym->where, &csym->common_block->where);\n+\t{\n+\t  if (csym->common_block)\n+\t    gfc_error_now (\"Global entity %qs at %L cannot appear in a \"\n+\t\t\t   \"COMMON block at %L\", gsym->name,\n+\t\t\t   &gsym->where, &csym->common_block->where);\n+\t  else\n+\t    gfc_error_now (\"Global entity %qs at %L cannot appear in a \"\n+\t\t\t   \"COMMON block\", gsym->name, &gsym->where);\n+\t}\n \n       /* gfc_add_in_common may have been called before, but the reported errors\n \t have been ignored to continue parsing.\n@@ -1664,9 +1670,11 @@ check_assumed_size_reference (gfc_symbol *sym, gfc_expr *e)\n \n   /* FIXME: The comparison \"e->ref->u.ar.type == AR_FULL\" is wrong.\n      What should it be?  */\n-  if (e->ref && (e->ref->u.ar.end[e->ref->u.ar.as->rank - 1] == NULL)\n-\t  && (e->ref->u.ar.as->type == AS_ASSUMED_SIZE)\n-\t       && (e->ref->u.ar.type == AR_FULL))\n+  if (e->ref\n+      && e->ref->u.ar.as\n+      && (e->ref->u.ar.end[e->ref->u.ar.as->rank - 1] == NULL)\n+      && (e->ref->u.ar.as->type == AS_ASSUMED_SIZE)\n+      && (e->ref->u.ar.type == AR_FULL))\n     {\n       gfc_error (\"The upper bound in the last dimension must \"\n \t\t \"appear in the reference to the assumed size \"\n@@ -11917,9 +11925,14 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      break;\n \t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n \t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_MASKED_TASKLOOP:\n+\t    case EXEC_OMP_MASKED_TASKLOOP_SIMD:\n+\t    case EXEC_OMP_MASTER_TASKLOOP:\n+\t    case EXEC_OMP_MASTER_TASKLOOP_SIMD:\n \t    case EXEC_OMP_PARALLEL:\n \t    case EXEC_OMP_PARALLEL_DO:\n \t    case EXEC_OMP_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_PARALLEL_LOOP:\n \t    case EXEC_OMP_PARALLEL_MASKED:\n \t    case EXEC_OMP_PARALLEL_MASKED_TASKLOOP:\n \t    case EXEC_OMP_PARALLEL_MASKED_TASKLOOP_SIMD:\n@@ -11930,11 +11943,13 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_TARGET_PARALLEL:\n \t    case EXEC_OMP_TARGET_PARALLEL_DO:\n \t    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TARGET_PARALLEL_LOOP:\n \t    case EXEC_OMP_TARGET_TEAMS:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\t    case EXEC_OMP_TARGET_TEAMS_LOOP:\n \t    case EXEC_OMP_TASK:\n \t    case EXEC_OMP_TASKLOOP:\n \t    case EXEC_OMP_TASKLOOP_SIMD:\n@@ -11943,6 +11958,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n \t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+\t    case EXEC_OMP_TEAMS_LOOP:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 0;\n \t      gfc_resolve_omp_parallel_blocks (code, ns);\n@@ -11951,6 +11967,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_DISTRIBUTE_SIMD:\n \t    case EXEC_OMP_DO:\n \t    case EXEC_OMP_DO_SIMD:\n+\t    case EXEC_OMP_LOOP:\n \t    case EXEC_OMP_SIMD:\n \t    case EXEC_OMP_TARGET_SIMD:\n \t      gfc_resolve_omp_do_blocks (code, ns);"}, {"sha": "ff64588b9a8771bacccc73820474c5f91673b231", "filename": "gcc/fortran/trans-decl.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ftrans-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ftrans-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -742,6 +742,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   /* Keep variables larger than max-stack-var-size off stack.  */\n   if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)\n       && !sym->attr.automatic\n+      && !sym->attr.associate_var\n       && sym->attr.save != SAVE_EXPLICIT\n       && sym->attr.save != SAVE_IMPLICIT\n       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))\n@@ -2337,7 +2338,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args,\n     }\n \n   /* Mark non-returning functions.  */\n-  if (sym->attr.noreturn)\n+  if (sym->attr.noreturn || sym->attr.ext_attr & (1 << EXT_ATTR_NORETURN))\n       TREE_THIS_VOLATILE(fndecl) = 1;\n \n   sym->backend_decl = fndecl;\n@@ -2481,6 +2482,17 @@ build_function_decl (gfc_symbol * sym, bool global)\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n     }\n \n+  /* Mark noinline functions.  */\n+  if (attr.ext_attr & (1 << EXT_ATTR_NOINLINE))\n+    DECL_UNINLINABLE (fndecl) = 1;\n+\n+  /* Mark noreturn functions.  */\n+  if (attr.ext_attr & (1 << EXT_ATTR_NORETURN))\n+    TREE_THIS_VOLATILE (fndecl) = 1;\n+\n+  /* Mark weak functions.  */\n+  if (attr.ext_attr & (1 << EXT_ATTR_WEAK))\n+    declare_weak (fndecl);\n \n   /* Layout the function declaration and put it in the binding level\n      of the current function.  */\n@@ -5350,7 +5362,11 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n \t      /* Sometimes, generic interfaces wind up being over-ruled by a\n \t\t local symbol (see PR41062).  */\n \t      if (!st->n.sym->attr.use_assoc)\n-\t\tcontinue;\n+\t\t{\n+\t\t  *slot = error_mark_node;\n+\t\t  entry->decls->clear_slot (slot);\n+\t\t  continue;\n+\t\t}\n \n \t      if (st->n.sym->backend_decl\n \t\t  && DECL_P (st->n.sym->backend_decl)"}, {"sha": "2d16f3be8ea6f3ab06ca15a2a829c87a9eecc6c7", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 195, "deletions": 46, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5116,18 +5116,146 @@ gfc_trans_omp_critical (gfc_code *code)\n }\n \n typedef struct dovar_init_d {\n+  gfc_symbol *sym;\n   tree var;\n   tree init;\n+  bool non_unit_iter;\n } dovar_init;\n \n+static bool\n+gfc_nonrect_loop_expr (stmtblock_t *pblock, gfc_se *sep, int loop_n,\n+\t\t       gfc_code *code, gfc_expr *expr, vec<dovar_init> *inits,\n+\t\t       int simple, gfc_expr *curr_loop_var)\n+{\n+  int i;\n+  for (i = 0; i < loop_n; i++)\n+    {\n+      gcc_assert (code->ext.iterator->var->expr_type == EXPR_VARIABLE);\n+      if (gfc_find_sym_in_expr (code->ext.iterator->var->symtree->n.sym, expr))\n+\tbreak;\n+      code = code->block->next;\n+    }\n+  if (i >= loop_n)\n+    return false;\n+\n+  /* Canonical format: TREE_VEC with [var, multiplier, offset].  */\n+  gfc_symbol *var = code->ext.iterator->var->symtree->n.sym;\n+\n+  tree tree_var = NULL_TREE;\n+  tree a1 = integer_one_node;\n+  tree a2 = integer_zero_node;\n+\n+  if (!simple)\n+    {\n+      /* FIXME: Handle non-unit iter steps, cf. PR fortran/107424.  */\n+      sorry_at (gfc_get_location (&curr_loop_var->where),\n+\t\t\"non-rectangular loop nest with step other than constant 1 \"\n+\t\t\"or -1 for %qs\", curr_loop_var->symtree->n.sym->name);\n+      return false;\n+    }\n+\n+  dovar_init *di;\n+  unsigned ix;\n+  FOR_EACH_VEC_ELT (*inits, ix, di)\n+    if (di->sym == var)\n+      {\n+\tif (!di->non_unit_iter)\n+\t  {\n+\t    tree_var = di->init;\n+\t    gcc_assert (DECL_P (tree_var));\n+\t    break;\n+\t  }\n+\telse\n+\t  {\n+\t    /* FIXME: Handle non-unit iter steps, cf. PR fortran/107424.  */\n+\t    sorry_at (gfc_get_location (&code->loc),\n+\t\t      \"non-rectangular loop nest with step other than constant \"\n+\t\t      \"1 or -1 for %qs\", var->name);\n+\t    inform (gfc_get_location (&expr->where), \"Used here\");\n+\t    return false;\n+\t  }\n+      }\n+  if (tree_var == NULL_TREE)\n+    tree_var = var->backend_decl;\n+\n+  if (expr->expr_type == EXPR_VARIABLE)\n+    gcc_assert (expr->symtree->n.sym == var);\n+  else if (expr->expr_type != EXPR_OP\n+\t   || (expr->value.op.op != INTRINSIC_TIMES\n+\t       && expr->value.op.op != INTRINSIC_PLUS\n+\t       && expr->value.op.op != INTRINSIC_MINUS))\n+    gcc_unreachable ();\n+  else\n+    {\n+      gfc_se se;\n+      gfc_expr *et = NULL, *eo = NULL, *e = expr;\n+      if (expr->value.op.op != INTRINSIC_TIMES)\n+\t{\n+\t  if (gfc_find_sym_in_expr (var, expr->value.op.op1))\n+\t    {\n+\t      e = expr->value.op.op1;\n+\t      eo = expr->value.op.op2;\n+\t    }\n+\t  else\n+\t    {\n+\t      eo = expr->value.op.op1;\n+\t      e = expr->value.op.op2;\n+\t    }\n+\t}\n+      if (e->value.op.op == INTRINSIC_TIMES)\n+\t{\n+\t  if (e->value.op.op1->expr_type == EXPR_VARIABLE\n+\t      && e->value.op.op1->symtree->n.sym == var)\n+\t    et = e->value.op.op2;\n+\t  else\n+\t    {\n+\t      et = e->value.op.op1;\n+\t      gcc_assert (e->value.op.op2->expr_type == EXPR_VARIABLE\n+\t\t\t  && e->value.op.op2->symtree->n.sym == var);\n+\t    }\n+\t}\n+      else\n+\tgcc_assert (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym == var);\n+      if (et != NULL)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, et);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  a1 = se.expr;\n+\t}\n+      if (eo != NULL)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, eo);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  a2 = se.expr;\n+\t  if (expr->value.op.op == INTRINSIC_MINUS && expr->value.op.op2 == eo)\n+\t    /* outer-var - a2.  */\n+\t    a2 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a2), a2);\n+\t  else if (expr->value.op.op == INTRINSIC_MINUS)\n+\t    /* a2 - outer-var.  */\n+\t    a1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a1), a1);\n+\t}\n+      a1 = DECL_P (a1) ? a1 : gfc_evaluate_now (a1, pblock);\n+      a2 = DECL_P (a2) ? a2 : gfc_evaluate_now (a2, pblock);\n+    }\n+\n+  gfc_init_se (sep, NULL);\n+  sep->expr = make_tree_vec (3);\n+  TREE_VEC_ELT (sep->expr, 0) = tree_var;\n+  TREE_VEC_ELT (sep->expr, 1) = fold_convert (TREE_TYPE (tree_var), a1);\n+  TREE_VEC_ELT (sep->expr, 2) = fold_convert (TREE_TYPE (tree_var), a2);\n+\n+  return true;\n+}\n \n static tree\n gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t  gfc_omp_clauses *do_clauses, tree par_clauses)\n {\n   gfc_se se;\n   tree dovar, stmt, from, to, step, type, init, cond, incr, orig_decls;\n-  tree count = NULL_TREE, cycle_label, tmp, omp_clauses;\n+  tree local_dovar = NULL_TREE, cycle_label, tmp, omp_clauses;\n   stmtblock_t block;\n   stmtblock_t body;\n   gfc_omp_clauses *clauses = code->ext.omp_clauses;\n@@ -5214,52 +5342,72 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n       gfc_add_block_to_block (pblock, &se.pre);\n-      dovar = se.expr;\n+      local_dovar = dovar_decl = dovar = se.expr;\n       type = TREE_TYPE (dovar);\n       gcc_assert (TREE_CODE (type) == INTEGER_TYPE);\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->start);\n+      gfc_conv_expr_val (&se, code->ext.iterator->step);\n       gfc_add_block_to_block (pblock, &se.pre);\n-      from = gfc_evaluate_now (se.expr, pblock);\n+      step = gfc_evaluate_now (se.expr, pblock);\n \n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->end);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      to = gfc_evaluate_now (se.expr, pblock);\n+      if (integer_onep (step))\n+\tsimple = 1;\n+      else if (tree_int_cst_equal (step, integer_minus_one_node))\n+\tsimple = -1;\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->step);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      step = gfc_evaluate_now (se.expr, pblock);\n-      dovar_decl = dovar;\n+      if (!clauses->non_rectangular\n+\t  || !gfc_nonrect_loop_expr (pblock, &se, i, orig_code->block->next,\n+\t\t\t\t     code->ext.iterator->start, &inits, simple,\n+\t\t\t\t     code->ext.iterator->var))\n+\t{\n+\t  gfc_conv_expr_val (&se, code->ext.iterator->start);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  if (!DECL_P (se.expr))\n+\t    se.expr = gfc_evaluate_now (se.expr, pblock);\n+\t}\n+      from = se.expr;\n \n-      /* Special case simple loops.  */\n-      if (VAR_P (dovar))\n+      gfc_init_se (&se, NULL);\n+      if (!clauses->non_rectangular\n+\t  || !gfc_nonrect_loop_expr (pblock, &se, i, orig_code->block->next,\n+\t\t\t\t     code->ext.iterator->end, &inits, simple,\n+\t\t\t\t     code->ext.iterator->var))\n \t{\n-\t  if (integer_onep (step))\n-\t    simple = 1;\n-\t  else if (tree_int_cst_equal (step, integer_minus_one_node))\n-\t    simple = -1;\n+\t  gfc_conv_expr_val (&se, code->ext.iterator->end);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  if (!DECL_P (se.expr))\n+\t    se.expr = gfc_evaluate_now (se.expr, pblock);\n \t}\n-      else\n+      to = se.expr;\n+\n+      if (!DECL_P (dovar))\n \tdovar_decl\n \t  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym,\n \t\t\t\t    false);\n-\n+      if (simple && !DECL_P (dovar))\n+\t{\n+\t  const char *name = code->ext.iterator->var->symtree->n.sym->name;\n+\t  local_dovar = gfc_create_var (type, name);\n+\t  dovar_init e = {code->ext.iterator->var->symtree->n.sym,\n+\t\t\t  dovar, local_dovar, false};\n+\t  inits.safe_push (e);\n+\t}\n       /* Loop body.  */\n       if (simple)\n \t{\n-\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, dovar, from);\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, local_dovar, from);\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, simple > 0\n \t\t\t\t\t       ? LE_EXPR : GE_EXPR,\n-\t\t\t\t\t       logical_type_node, dovar, to);\n+\t\t\t\t\t       logical_type_node, local_dovar,\n+\t\t\t\t\t       to);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t\t    type, dovar, step);\n+\t\t\t\t\t\t    type, local_dovar, step);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n \t\t\t\t\t\t    MODIFY_EXPR,\n-\t\t\t\t\t\t    type, dovar,\n+\t\t\t\t\t\t    type, local_dovar,\n \t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \t  if (orig_decls && !clauses->orderedc)\n \t    orig_decls = NULL;\n@@ -5280,24 +5428,27 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, type, tmp,\n \t\t\t\t step);\n \t  tmp = gfc_evaluate_now (tmp, pblock);\n-\t  count = gfc_create_var (type, \"count\");\n-\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, count,\n+\t  local_dovar = gfc_create_var (type, \"count\");\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, local_dovar,\n \t\t\t\t\t     build_int_cst (type, 0));\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, LT_EXPR,\n \t\t\t\t\t       logical_type_node,\n-\t\t\t\t\t       count, tmp);\n+\t\t\t\t\t       local_dovar, tmp);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t\t    type, count,\n+\t\t\t\t\t\t    type, local_dovar,\n \t\t\t\t\t\t    build_int_cst (type, 1));\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n-\t\t\t\t\t\t    MODIFY_EXPR, type, count,\n+\t\t\t\t\t\t    MODIFY_EXPR, type,\n+\t\t\t\t\t\t    local_dovar,\n \t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \n \t  /* Initialize DOVAR.  */\n-\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, count, step);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, local_dovar,\n+\t\t\t\t step);\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n-\t  dovar_init e = {dovar, tmp};\n+\t  dovar_init e = {code->ext.iterator->var->symtree->n.sym,\n+\t\t\t  dovar, tmp, true};\n \t  inits.safe_push (e);\n \t  if (clauses->orderedc)\n \t    {\n@@ -5312,7 +5463,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n       if (dovar_found == 3\n \t  && op == EXEC_OMP_SIMD\n \t  && collapse == 1\n-\t  && !simple)\n+\t  && local_dovar != dovar)\n \t{\n \t  for (tmp = omp_clauses; tmp; tmp = OMP_CLAUSE_CHAIN (tmp))\n \t    if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_LINEAR\n@@ -5331,11 +5482,11 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (tmp) = 1;\n \t      OMP_CLAUSE_DECL (tmp) = dovar_decl;\n \t      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+\t      if (local_dovar != dovar)\n+\t\tdovar_found = 3;\n \t    }\n-\t  if (!simple)\n-\t    dovar_found = 3;\n \t}\n-      else if (!dovar_found && !simple)\n+      else if (!dovar_found && local_dovar != dovar)\n \t{\n \t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = dovar_decl;\n@@ -5346,7 +5497,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  tree c = NULL;\n \n \t  tmp = NULL;\n-\t  if (!simple)\n+\t  if (local_dovar != dovar)\n \t    {\n \t      /* If dovar is lastprivate, but different counter is used,\n \t\t dovar += step needs to be added to\n@@ -5356,21 +5507,19 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t      if (clauses->orderedc)\n \t\t{\n \t\t  if (clauses->collapse <= 1 || i >= clauses->collapse)\n-\t\t    tmp = count;\n+\t\t    tmp = local_dovar;\n \t\t  else\n \t\t    tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t   type, count, build_one_cst (type));\n+\t\t\t\t\t   type, local_dovar,\n+\t\t\t\t\t   build_one_cst (type));\n \t\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type,\n \t\t\t\t\t tmp, step);\n \t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n \t\t\t\t\t from, tmp);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  tmp = gfc_evaluate_now (step, pblock);\n-\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n-\t\t\t\t\t dovar, tmp);\n-\t\t}\n+\t\ttmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t\t       dovar, step);\n \t      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type,\n \t\t\t\t     dovar, tmp);\n \t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n@@ -5405,9 +5554,9 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t    break;\n \t\t  }\n \t    }\n-\t  gcc_assert (simple || c != NULL);\n+\t  gcc_assert (local_dovar == dovar || c != NULL);\n \t}\n-      if (!simple)\n+      if (local_dovar != dovar)\n \t{\n \t  if (op != EXEC_OMP_SIMD || dovar_found == 1)\n \t    tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n@@ -5420,7 +5569,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t    }\n \t  else\n \t    tmp = build_omp_clause (input_location, OMP_CLAUSE_LASTPRIVATE);\n-\t  OMP_CLAUSE_DECL (tmp) = count;\n+\t  OMP_CLAUSE_DECL (tmp) = local_dovar;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n "}, {"sha": "becc56051a88d37e3e7eaa6ec208402861b0b9c6", "filename": "gcc/gcc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -842,7 +842,7 @@ proper position among the other output files.  */\n #define LINK_COMPRESS_DEBUG_SPEC \\\n \t\" %{gz|gz=zlib:\"  LD_COMPRESS_DEBUG_OPTION \"=zlib}\" \\\n \t\" %{gz=none:\"\t  LD_COMPRESS_DEBUG_OPTION \"=none}\" \\\n-\t\" %{gz*:%e-gz=zstd is not supported in this configuration} \" \\\n+\t\" %{gz=zstd:%e-gz=zstd is not supported in this configuration} \" \\\n \t\" %{gz=zlib-gnu:}\" /* Ignore silently zlib-gnu option value.  */\n #elif HAVE_LD_COMPRESS_DEBUG == 2\n /* ELF gABI style and ZSTD.  */"}, {"sha": "a76079a46af71a62ea6a496c9037a108e5991e23", "filename": "gcc/gdbinit.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgdbinit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgdbinit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbinit.in?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -31,6 +31,7 @@ GCC gdbinit file introduces several debugging shorthands:\n     pdd [dw_die_ref],\n     pbm [bitmap],\n     pel [location_t],\n+    phrs [HARD_REG_SET]\n     pp, pbs, pcfun\n \n They are generally implemented by calling a function that prints to stderr,\n@@ -145,6 +146,17 @@ Print given GENERIC expression in C syntax.\n See also 'help-gcc-hooks'.\n end\n \n+define phrs\n+eval \"set $debug_arg = $%s\", $argc ? \"arg0\" : \"\"\n+call debug_hard_reg_set ($debug_arg)\n+end\n+\n+document phrs\n+GCC hook: debug_hard_reg_set (HARD_REG_SET)\n+Print given HARD_REG_SET.\n+See also 'help-gcc-hooks'.\n+end\n+\n define pmz\n eval \"set $debug_arg = $%s\", $argc ? \"arg0\" : \"\"\n call mpz_out_str(stderr, 10, $debug_arg)"}, {"sha": "4e5df544fbfc5170bc439d9395a14f5ed13511d9", "filename": "gcc/gengtype.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -77,7 +77,7 @@ input_file* input_file_by_name (const char* name);\n const char *get_file_srcdir_relative_path (const input_file *inpf);\n \n /* Get the name of an input file.  */\n-static inline const char*\n+inline const char*\n get_input_file_name (const input_file *inpf)\n {\n   if (inpf)\n@@ -94,7 +94,7 @@ get_input_file_name (const input_file *inpf)\n    some GC roots may be missed, which is a much harder-to-debug problem.\n   */\n \n-static inline lang_bitmap\n+inline lang_bitmap\n get_lang_bitmap (const input_file* inpf)\n {\n   if (inpf == NULL)\n@@ -104,7 +104,7 @@ get_lang_bitmap (const input_file* inpf)\n \n /* Set the bitmap returned by get_lang_bitmap.  The only legitimate\n    callers of this function are read_input_list & read_state_*.  */\n-static inline void\n+inline void\n set_lang_bitmap (input_file* inpf, lang_bitmap n)\n {\n   gcc_assert (inpf);\n@@ -346,7 +346,7 @@ extern struct type callback_type;\n \n /* Test if a type is a union or a structure, perhaps a language\n    specific one.  */\n-static inline bool\n+inline bool\n union_or_struct_p (enum typekind kind)\n {\n   return (kind == TYPE_UNION\n@@ -355,14 +355,14 @@ union_or_struct_p (enum typekind kind)\n \t  || kind == TYPE_USER_STRUCT);\n }\n \n-static inline bool\n+inline bool\n union_or_struct_p (const_type_p x)\n {\n   return union_or_struct_p (x->kind);\n }\n \n /* Give the file location of a type, if any. */\n-static inline struct fileloc* \n+inline struct fileloc* \n type_fileloc (type_p t)\n {\n   if (!t) "}, {"sha": "43bd0212d0e205a8b73ba95fe44d83a193ae922e", "filename": "gcc/genmatch.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgenmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgenmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2541,7 +2541,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", _o%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n-      fprintf_indent (f, indent, \"tem_op.resimplify (lseq, valueize);\\n\");\n+      fprintf_indent (f, indent, \"tem_op.resimplify (%s, valueize);\\n\",\n+\t\t      !force_leaf ? \"lseq\" : \"NULL\");\n       fprintf_indent (f, indent,\n \t\t      \"_r%d = maybe_push_res_to_seq (&tem_op, %s);\\n\", depth,\n \t\t      !force_leaf ? \"lseq\" : \"NULL\");\n@@ -3451,7 +3452,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t  if (!is_predicate)\n \t    {\n \t      fprintf_indent (f, indent,\n-\t\t\t      \"res_op->resimplify (lseq, valueize);\\n\");\n+\t\t\t      \"res_op->resimplify (%s, valueize);\\n\",\n+\t\t\t      !e->force_leaf ? \"lseq\" : \"NULL\");\n \t      if (e->force_leaf)\n \t\tfprintf_indent (f, indent,\n \t\t\t\t\"if (!maybe_push_res_to_seq (res_op, NULL)) \""}, {"sha": "e89f7e20fc8196b77fd92fce6b62d52ebac50588", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -60,7 +60,7 @@ extern tree canonicalize_cond_expr_cond (tree);\n /* Return true if a conversion from either type of TYPE1 and TYPE2\n    to the other is not required.  Otherwise return false.  */\n \n-static inline bool\n+inline bool\n types_compatible_p (tree type1, tree type2)\n {\n   return (type1 == type2\n@@ -70,15 +70,15 @@ types_compatible_p (tree type1, tree type2)\n \n /* Return true if TYPE is a suitable type for a scalar register variable.  */\n \n-static inline bool\n+inline bool\n is_gimple_reg_type (tree type)\n {\n   return !AGGREGATE_TYPE_P (type);\n }\n \n /* Return true if T is a variable.  */\n \n-static inline bool\n+inline bool\n is_gimple_variable (tree t)\n {\n   return (TREE_CODE (t) == VAR_DECL\n@@ -89,7 +89,7 @@ is_gimple_variable (tree t)\n \n /*  Return true if T is a GIMPLE identifier (something with an address).  */\n \n-static inline bool\n+inline bool\n is_gimple_id (tree t)\n {\n   return (is_gimple_variable (t)\n@@ -102,7 +102,7 @@ is_gimple_id (tree t)\n \n /* Return true if OP, an SSA name or a DECL is a virtual operand.  */\n \n-static inline bool\n+inline bool\n virtual_operand_p (tree op)\n {\n   if (TREE_CODE (op) == SSA_NAME)\n@@ -116,7 +116,7 @@ virtual_operand_p (tree op)\n \n /*  Return true if T is something whose address can be taken.  */\n \n-static inline bool\n+inline bool\n is_gimple_addressable (tree t)\n {\n   return (is_gimple_id (t) || handled_component_p (t)\n@@ -126,7 +126,7 @@ is_gimple_addressable (tree t)\n \n /* Return true if T is a valid gimple constant.  */\n \n-static inline bool\n+inline bool\n is_gimple_constant (const_tree t)\n {\n   switch (TREE_CODE (t))\n@@ -148,7 +148,7 @@ is_gimple_constant (const_tree t)\n /* A wrapper around extract_ops_from_tree with 3 ops, for callers which\n    expect to see only a maximum of two operands.  */\n \n-static inline void\n+inline void\n extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n \t\t       tree *op1)\n {\n@@ -160,7 +160,7 @@ extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n /* Given a valid GIMPLE_CALL function address return the FUNCTION_DECL\n    associated with the callee if known.  Otherwise return NULL_TREE.  */\n \n-static inline tree\n+inline tree\n gimple_call_addr_fndecl (const_tree fn)\n {\n   if (fn && TREE_CODE (fn) == ADDR_EXPR)"}, {"sha": "935e800641300110b70f1e7d861bbe11ed2936be", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5767,15 +5767,17 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n }\n \n \n-/* Return true whether NAME has a use on STMT.  */\n+/* Return true whether NAME has a use on STMT.  Note this can return\n+   false even though there's a use on STMT if SSA operands are not\n+   up-to-date.  */\n \n static bool\n has_use_on_stmt (tree name, gimple *stmt)\n {\n-  imm_use_iterator iter;\n-  use_operand_p use_p;\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n-    if (USE_STMT (use_p) == stmt)\n+  ssa_op_iter iter;\n+  tree op;\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+    if (op == name)\n       return true;\n   return false;\n }"}, {"sha": "38352aa95af62dc68b312477c113a91579b8cd9b", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -95,7 +95,7 @@ extern void update_modified_stmts (gimple_seq);\n \n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start (gimple_seq &seq)\n {\n   gimple_stmt_iterator i;\n@@ -107,7 +107,7 @@ gsi_start (gimple_seq &seq)\n   return i;\n }\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_none (void)\n {\n   gimple_stmt_iterator i;\n@@ -119,7 +119,7 @@ gsi_none (void)\n \n /* Return a new iterator pointing to the first statement in basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n@@ -137,7 +137,7 @@ gimple_stmt_iterator gsi_start_edge (edge e);\n \n /* Return a new iterator initially pointing to GIMPLE_SEQ's last statement.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last (gimple_seq &seq)\n {\n   gimple_stmt_iterator i;\n@@ -151,7 +151,7 @@ gsi_last (gimple_seq &seq)\n \n /* Return a new iterator pointing to the last statement in basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n@@ -167,31 +167,31 @@ gsi_last_bb (basic_block bb)\n \n /* Return true if I is at the end of its sequence.  */\n \n-static inline bool\n+inline bool\n gsi_end_p (gimple_stmt_iterator i)\n {\n   return i.ptr == NULL;\n }\n \n /* Return true if I is one statement before the end of its sequence.  */\n \n-static inline bool\n+inline bool\n gsi_one_before_end_p (gimple_stmt_iterator i)\n {\n   return i.ptr != NULL && i.ptr->next == NULL;\n }\n \n /* Advance the iterator to the next gimple statement.  */\n \n-static inline void\n+inline void\n gsi_next (gimple_stmt_iterator *i)\n {\n   i->ptr = i->ptr->next;\n }\n \n /* Advance the iterator to the previous gimple statement.  */\n \n-static inline void\n+inline void\n gsi_prev (gimple_stmt_iterator *i)\n {\n   gimple *prev = i->ptr->prev;\n@@ -203,7 +203,7 @@ gsi_prev (gimple_stmt_iterator *i)\n \n /* Return the current stmt.  */\n \n-static inline gimple *\n+inline gimple *\n gsi_stmt (gimple_stmt_iterator i)\n {\n   return i.ptr;\n@@ -212,7 +212,7 @@ gsi_stmt (gimple_stmt_iterator i)\n /* Return a block statement iterator that points to the first\n    non-label statement in block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_after_labels (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_start_bb (bb);\n@@ -231,7 +231,7 @@ gsi_after_labels (basic_block bb)\n /* Return a statement iterator that points to the first\n    non-label statement in sequence SEQ.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_after_labels (gimple_seq &seq)\n {\n   gimple_stmt_iterator gsi = gsi_start (seq);\n@@ -249,7 +249,7 @@ gsi_after_labels (gimple_seq &seq)\n \n /* Advance the iterator to the next non-debug gimple statement.  */\n \n-static inline void\n+inline void\n gsi_next_nondebug (gimple_stmt_iterator *i)\n {\n   do\n@@ -261,7 +261,7 @@ gsi_next_nondebug (gimple_stmt_iterator *i)\n \n /* Advance the iterator to the previous non-debug gimple statement.  */\n \n-static inline void\n+inline void\n gsi_prev_nondebug (gimple_stmt_iterator *i)\n {\n   do\n@@ -274,7 +274,7 @@ gsi_prev_nondebug (gimple_stmt_iterator *i)\n /* Return a new iterator pointing to the first non-debug statement in\n    SEQ.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi = gsi_start (seq);\n@@ -287,7 +287,7 @@ gsi_start_nondebug (gimple_seq seq)\n /* Return a new iterator pointing to the first non-debug statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start_bb (bb);\n@@ -301,7 +301,7 @@ gsi_start_nondebug_bb (basic_block bb)\n /* Return a new iterator pointing to the first non-debug non-label statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug_after_labels_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_after_labels (bb);\n@@ -315,7 +315,7 @@ gsi_start_nondebug_after_labels_bb (basic_block bb)\n /* Return a new iterator pointing to the last non-debug statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last_nondebug_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_last_bb (bb);\n@@ -329,7 +329,7 @@ gsi_last_nondebug_bb (basic_block bb)\n /* Return true if I is followed only by debug statements in its\n    sequence.  */\n \n-static inline bool\n+inline bool\n gsi_one_nondebug_before_end_p (gimple_stmt_iterator i)\n {\n   if (gsi_one_before_end_p (i))\n@@ -343,7 +343,7 @@ gsi_one_nondebug_before_end_p (gimple_stmt_iterator i)\n /* Advance I statement iterator to the next non-virtual GIMPLE_PHI\n    statement.  */\n \n-static inline void\n+inline void\n gsi_next_nonvirtual_phi (gphi_iterator *i)\n {\n   do\n@@ -356,7 +356,7 @@ gsi_next_nonvirtual_phi (gphi_iterator *i)\n /* Return a new iterator pointing to the first non-virtual phi statement in\n    basic block BB.  */\n \n-static inline gphi_iterator\n+inline gphi_iterator\n gsi_start_nonvirtual_phis (basic_block bb)\n {\n   gphi_iterator i = gsi_start_phis (bb);\n@@ -369,23 +369,23 @@ gsi_start_nonvirtual_phis (basic_block bb)\n \n /* Return the basic block associated with this iterator.  */\n \n-static inline basic_block\n+inline basic_block\n gsi_bb (gimple_stmt_iterator i)\n {\n   return i.bb;\n }\n \n /* Return the sequence associated with this iterator.  */\n \n-static inline gimple_seq\n+inline gimple_seq\n gsi_seq (gimple_stmt_iterator i)\n {\n   return *i.seq;\n }\n \n /* Determine whether SEQ is a nondebug singleton.  */\n \n-static inline bool\n+inline bool\n gimple_seq_nondebug_singleton_p (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi;"}, {"sha": "6c085a93ea7f823ba36f7acf23b5065fc165694e", "filename": "gcc/gimple-predict.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-predict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-predict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predict.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return the predictor of GIMPLE_PREDICT statement GS.  */\n \n-static inline enum br_predictor\n+inline enum br_predictor\n gimple_predict_predictor (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -35,7 +35,7 @@ gimple_predict_predictor (const gimple *gs)\n \n /* Set the predictor of GIMPLE_PREDICT statement GS to PREDICT.  */\n \n-static inline void\n+inline void\n gimple_predict_set_predictor (gimple *gs, enum br_predictor predictor)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -46,7 +46,7 @@ gimple_predict_set_predictor (gimple *gs, enum br_predictor predictor)\n \n /* Return the outcome of GIMPLE_PREDICT statement GS.  */\n \n-static inline enum prediction\n+inline enum prediction\n gimple_predict_outcome (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -56,7 +56,7 @@ gimple_predict_outcome (const gimple *gs)\n \n /* Set the outcome of GIMPLE_PREDICT statement GS to OUTCOME.  */\n \n-static inline void\n+inline void\n gimple_predict_set_outcome (gimple *gs, enum prediction outcome)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -82,7 +82,7 @@ gimple_build_predict (enum br_predictor predictor, enum prediction outcome)\n \n /* Return true if GS is a GIMPLE_PREDICT statement.  */\n \n-static inline bool\n+inline bool\n is_gimple_predict (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_PREDICT;"}, {"sha": "546262c47946785b059130d42c67d1d823eb37ad", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1081,7 +1081,7 @@ ranger_cache::propagate_cache (tree name)\n       new_range.set_undefined ();\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  range_on_edge (e_range, e, name);\n+\t  edge_range (e_range, e, name, RFD_READ_ONLY);\n \t  if (DEBUG_RANGE_CACHE)\n \t    {\n \t      fprintf (dump_file, \"   edge %d->%d :\", e->src->index, bb->index);"}, {"sha": "10b5c18b858c232b241d03707c742fb048407468", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -44,7 +44,7 @@ bool fold_range (vrange &r, gimple *s, unsigned num_elements, vrange **vector);\n // Return the type of range which statement S calculates.  If the type is\n // unsupported or no type can be determined, return NULL_TREE.\n \n-static inline tree\n+inline tree\n gimple_range_type (const gimple *s)\n {\n   tree lhs = gimple_get_lhs (s);\n@@ -73,7 +73,7 @@ gimple_range_type (const gimple *s)\n \n // Return EXP if it is an SSA_NAME with a type supported by gimple ranges.\n \n-static inline tree\n+inline tree\n gimple_range_ssa_p (tree exp)\n {\n   if (exp && TREE_CODE (exp) == SSA_NAME &&\n@@ -86,7 +86,7 @@ gimple_range_ssa_p (tree exp)\n \n // Return true if TYPE1 and TYPE2 are compatible range types.\n \n-static inline bool\n+inline bool\n range_compatible_p (tree type1, tree type2)\n {\n   // types_compatible_p requires conversion in both directions to be useless."}, {"sha": "beb1c0064b9805ac541fccf57e20d01bbd351222", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -607,10 +607,6 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n {\n   value_relation vrel;\n   value_relation *vrel_ptr = rel;\n-  // If the lhs doesn't tell us anything, neither will unwinding further.\n-  if (lhs.varying_p ())\n-    return false;\n-\n   // Empty ranges are viral as they are on an unexecutable path.\n   if (lhs.undefined_p ())\n     {\n@@ -632,6 +628,9 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   if (op1 && op2)\n     {\n       relation_kind k = handler.op1_op2_relation (lhs);\n+      // If there is no relation, and op1 == op2, create a relation.\n+      if (!vrel_ptr && k == VREL_VARYING && op1 == op2)\n+\tk = VREL_EQ;\n       if (k != VREL_VARYING)\n        {\n \t vrel.set_relation (k, op1, op2);\n@@ -654,10 +653,19 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   if (!op1_in_chain && !op2_in_chain)\n     return false;\n \n+  // If the lhs doesn't tell us anything and there are no relations, there\n+  // is nothing to be learned.\n+  if (lhs.varying_p () && !vrel_ptr)\n+    return false;\n+\n   bool res;\n   // Process logicals as they have special handling.\n   if (is_gimple_logical_p (stmt))\n     {\n+      // If the lhs doesn't tell us anything, neither will combining operands.\n+      if (lhs.varying_p ())\n+\treturn false;\n+\n       unsigned idx;\n       if ((idx = tracer.header (\"compute_operand \")))\n \t{\n@@ -952,7 +960,9 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n {\n   gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n   gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n-  gcc_checking_assert (k != VREL_VARYING && k != VREL_UNDEFINED);\n+\n+  if (k == VREL_VARYING || k == VREL_EQ || k == VREL_UNDEFINED)\n+    return false;\n \n   bool change = false;\n   bool op1_def_p = in_chain_p (op2, op1);\n@@ -991,7 +1001,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op1_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, relation_trio::lhs_op2 (k)))\n+\t\t\t\t other_op, relation_trio::lhs_op1 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1023,7 +1033,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op2_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, relation_trio::lhs_op1 (k)))\n+\t\t\t\t other_op, relation_trio::lhs_op2 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1062,6 +1072,10 @@ gori_compute::compute_operand1_range (vrange &r,\n   tree op2 = handler.operand2 ();\n   tree lhs_name = gimple_get_lhs (stmt);\n \n+  relation_trio trio;\n+  if (rel)\n+    trio = rel->create_trio (lhs_name, op1, op2);\n+\n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range tmp (TREE_TYPE (op1));\n   Value_Range op2_range (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n@@ -1073,35 +1087,19 @@ gori_compute::compute_operand1_range (vrange &r,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      relation_kind k = VREL_VARYING;\n-      relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n-      if (rel)\n-\t{\n-\t if (lhs_name == rel->op1 () && op1 == rel->op2 ())\n-\t   k = rel->kind ();\n-\t else if (lhs_name == rel->op2 () && op1 == rel->op1 ())\n-\t   k = relation_swap (rel->kind ());\n-\t else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-\t   {\n-\t     op_op = rel->kind ();\n-\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t   }\n-\t else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-\t   {\n-\t     op_op = relation_swap (rel->kind ());\n-\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t   }\n-       }\n-      if (!handler.calc_op1 (tmp, lhs, op2_range, relation_trio (VREL_VARYING,\n-\t\t\t\t\t\t\t\t k, op_op)))\n+      relation_kind op_op = trio.op1_op2 ();\n+      if (op_op != VREL_VARYING)\n+\trefine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\n+      if (!handler.calc_op1 (tmp, lhs, op2_range, trio))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!handler.calc_op1 (tmp, lhs, op1_range, TRIO_VARYING))\n+      if (!handler.calc_op1 (tmp, lhs, op1_range, trio))\n \treturn false;\n     }\n \n@@ -1172,29 +1170,16 @@ gori_compute::compute_operand2_range (vrange &r,\n \n   src.get_operand (op1_range, op1);\n   src.get_operand (op2_range, op2);\n-  relation_kind k = VREL_VARYING;\n-  relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n+\n+  relation_trio trio;\n   if (rel)\n-    {\n-      if (lhs_name == rel->op1 () && op2 == rel->op2 ())\n-\tk = rel->kind ();\n-      else if (lhs_name == rel->op2 () && op2 == rel->op1 ())\n-\tk = relation_swap (rel->kind ());\n-      else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-\t{\n-\t  op_op = rel->kind ();\n-\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t}\n-      else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-\t{\n-\t  op_op = relation_swap (rel->kind ());\n-\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t}\n-    }\n+    trio = rel->create_trio (lhs_name, op1, op2);\n+  relation_kind op_op = trio.op1_op2 ();\n+  if (op_op != VREL_VARYING)\n+    refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n \n   // Intersect with range for op2 based on lhs and op1.\n-  if (!handler.calc_op2 (tmp, lhs, op1_range, relation_trio (k, VREL_VARYING,\n-\t\t\t\t\t\t\t     op_op)))\n+  if (!handler.calc_op2 (tmp, lhs, op1_range, trio))\n     return false;\n \n   unsigned idx;"}, {"sha": "c765e07273187c5240c41508752d320c0877cc62", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -84,7 +84,7 @@ gimple_infer_range::check_assume_func (gcall *call)\n \t    continue;\n \t  // Query the global range of the default def in the assume function.\n \t  Value_Range assume_range (type);\n-\t  global_ranges.range_of_expr (assume_range, default_def);\n+\t  gimple_range_global (assume_range, default_def, fun);\n \t  // If there is a non-varying result, add it as an inferred range.\n \t  if (!assume_range.varying_p ())\n \t    {"}, {"sha": "2eab1d59abd05042af0dd93362b9434c5170c0c7", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4326,15 +4326,6 @@ pass_waccess::check_call (gcall *stmt)\n   check_nonstring_args (stmt);\n }\n \n-\n-/* Return true of X is a DECL with automatic storage duration.  */\n-\n-static inline bool\n-is_auto_decl (tree x)\n-{\n-  return DECL_P (x) && !DECL_EXTERNAL (x) && !TREE_STATIC (x);\n-}\n-\n /* Check non-call STMT for invalid accesses.  */\n \n void\n@@ -4363,7 +4354,7 @@ pass_waccess::check_stmt (gimple *stmt)\n       while (handled_component_p (lhs))\n \tlhs = TREE_OPERAND (lhs, 0);\n \n-      if (is_auto_decl (lhs))\n+      if (auto_var_p (lhs))\n \tm_clobbers.remove (lhs);\n       return;\n     }\n@@ -4383,7 +4374,7 @@ pass_waccess::check_stmt (gimple *stmt)\n       while (handled_component_p (arg))\n \targ = TREE_OPERAND (arg, 0);\n \n-      if (!is_auto_decl (arg))\n+      if (!auto_var_p (arg))\n \treturn;\n \n       gimple **pclobber = m_clobbers.get (arg);\n@@ -4467,7 +4458,7 @@ void\n pass_waccess::check_dangling_uses (tree var, tree decl, bool maybe /* = false */,\n \t\t\t\t   bool objref /* = false */)\n {\n-  if (!decl || !is_auto_decl (decl))\n+  if (!decl || !auto_var_p (decl))\n     return;\n \n   gimple **pclob = m_clobbers.get (decl);\n@@ -4528,7 +4519,7 @@ pass_waccess::check_dangling_stores (basic_block bb,\n       if (!m_ptr_qry.get_ref (lhs, stmt, &lhs_ref, 0))\n \tcontinue;\n \n-      if (is_auto_decl (lhs_ref.ref))\n+      if (auto_var_p (lhs_ref.ref))\n \tcontinue;\n \n       if (DECL_P (lhs_ref.ref))\n@@ -4573,7 +4564,7 @@ pass_waccess::check_dangling_stores (basic_block bb,\n \t  || rhs_ref.deref != -1)\n \tcontinue;\n \n-      if (!is_auto_decl (rhs_ref.ref))\n+      if (!auto_var_p (rhs_ref.ref))\n \tcontinue;\n \n       auto_diagnostic_group d;"}, {"sha": "604af8b96b7b9e3791ff438f0f1fa612d4e723af", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -119,14 +119,14 @@ struct GTY(()) gimple_df {\n    gimple_in_ssa_p is queried by gimplifier in various early stages before SSA\n    infrastructure is initialized.  Check for presence of the datastructures\n    at first place.  */\n-static inline bool\n+inline bool\n gimple_in_ssa_p (const struct function *fun)\n {\n   return fun && fun->gimple_df && fun->gimple_df->in_ssa_p;\n }\n \n /* Artificial variable used for the virtual operand FUD chain.  */\n-static inline tree\n+inline tree\n gimple_vop (const struct function *fun)\n {\n   gcc_checking_assert (fun && fun->gimple_df);\n@@ -135,7 +135,7 @@ gimple_vop (const struct function *fun)\n \n /* Return the set of VUSE operand for statement G.  */\n \n-static inline use_operand_p\n+inline use_operand_p\n gimple_vuse_op (const gimple *g)\n {\n   struct use_optype_d *ops;\n@@ -152,7 +152,7 @@ gimple_vuse_op (const gimple *g)\n \n /* Return the set of VDEF operand for statement G.  */\n \n-static inline def_operand_p\n+inline def_operand_p\n gimple_vdef_op (gimple *g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n@@ -166,7 +166,7 @@ gimple_vdef_op (gimple *g)\n \n /* Mark statement S as modified, and update it.  */\n \n-static inline void\n+inline void\n update_stmt (gimple *s)\n {\n   if (gimple_has_ops (s))\n@@ -178,7 +178,7 @@ update_stmt (gimple *s)\n \n /* Update statement S if it has been optimized.  */\n \n-static inline void\n+inline void\n update_stmt_if_modified (gimple *s)\n {\n   if (gimple_modified_p (s))\n@@ -187,7 +187,7 @@ update_stmt_if_modified (gimple *s)\n \n /* Mark statement S as modified, and update it.  */\n \n-static inline void\n+inline void\n update_stmt_fn (struct function *fn, gimple *s)\n {\n   if (gimple_has_ops (s))"}, {"sha": "5e4eda417fbd17440f4e7220e99e6400c769b9ba", "filename": "gcc/gimple.cc", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -430,16 +430,7 @@ gimple_build_builtin_unreachable (location_t loc)\n {\n   tree data = NULL_TREE;\n   tree fn = sanitize_unreachable_fn (&data, loc);\n-  gcall *g;\n-  if (DECL_FUNCTION_CODE (fn) != BUILT_IN_TRAP)\n-    g = gimple_build_call (fn, data != NULL_TREE, data);\n-  else\n-    {\n-      /* Instead of __builtin_trap use .TRAP, so that it doesn't\n-\t need vops.  */\n-      gcc_checking_assert (data == NULL_TREE);\n-      g = gimple_build_call_internal (IFN_TRAP, 0);\n-    }\n+  gcall *g = gimple_build_call (fn, data != NULL_TREE, data);\n   gimple_call_set_ctrl_altering (g, true);\n   gimple_set_location (g, loc);\n   return g;"}, {"sha": "081d18e425aabd123ac8258a9900e3725f12185d", "filename": "gcc/gimple.h", "status": "modified", "additions": 513, "deletions": 513, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "96845154a926f97735d6f268a7e985316585f923", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -6441,7 +6441,7 @@ gimplify_save_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   gcc_assert (TREE_CODE (*expr_p) == SAVE_EXPR);\n   val = TREE_OPERAND (*expr_p, 0);\n \n-  if (TREE_TYPE (val) == error_mark_node)\n+  if (val && TREE_TYPE (val) == error_mark_node)\n     return GS_ERROR;\n \n   /* If the SAVE_EXPR has not been resolved, then evaluate it once.  */"}, {"sha": "dc6e482fce31b31c804e8180108b02a15dadfa56", "filename": "gcc/graphite.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -32,7 +32,7 @@ typedef struct scop *scop_p;\n \n typedef unsigned graphite_dim_t;\n \n-static inline graphite_dim_t scop_nb_params (scop_p);\n+inline graphite_dim_t scop_nb_params (scop_p);\n \n /* A data reference can write or read some memory or we\n    just know it may write some memory.  */\n@@ -189,23 +189,23 @@ void new_poly_dr (poly_bb_p, gimple *, enum poly_dr_type,\n void debug_pdr (poly_dr_p);\n void print_pdr (FILE *, poly_dr_p);\n \n-static inline bool\n+inline bool\n pdr_read_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_READ;\n }\n \n /* Returns true when PDR is a \"write\".  */\n \n-static inline bool\n+inline bool\n pdr_write_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_WRITE;\n }\n \n /* Returns true when PDR is a \"may write\".  */\n \n-static inline bool\n+inline bool\n pdr_may_write_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_MAY_WRITE;\n@@ -295,37 +295,37 @@ extern void debug_schedule_ast (__isl_keep isl_schedule *, scop_p);\n \n /* The basic block of the PBB.  */\n \n-static inline basic_block\n+inline basic_block\n pbb_bb (poly_bb_p pbb)\n {\n   return GBB_BB (PBB_BLACK_BOX (pbb));\n }\n \n-static inline int\n+inline int\n pbb_index (poly_bb_p pbb)\n {\n   return pbb_bb (pbb)->index;\n }\n \n /* The loop of the PBB.  */\n \n-static inline loop_p\n+inline loop_p\n pbb_loop (poly_bb_p pbb)\n {\n   return gbb_loop (PBB_BLACK_BOX (pbb));\n }\n \n /* The scop that contains the PDR.  */\n \n-static inline scop_p\n+inline scop_p\n pdr_scop (poly_dr_p pdr)\n {\n   return PBB_SCOP (PDR_PBB (pdr));\n }\n \n /* Set black box of PBB to BLACKBOX.  */\n \n-static inline void\n+inline void\n pbb_set_black_box (poly_bb_p pbb, gimple_poly_bb_p black_box)\n {\n   pbb->black_box = black_box;\n@@ -412,23 +412,23 @@ extern bool apply_poly_transforms (scop_p);\n \n /* Set the region of SCOP to REGION.  */\n \n-static inline void\n+inline void\n scop_set_region (scop_p scop, sese_info_p region)\n {\n   scop->scop_info = region;\n }\n \n /* Returns the number of parameters for SCOP.  */\n \n-static inline graphite_dim_t\n+inline graphite_dim_t\n scop_nb_params (scop_p scop)\n {\n   return scop->nb_params;\n }\n \n /* Set the number of params of SCOP to NB_PARAMS.  */\n \n-static inline void\n+inline void\n scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n {\n   scop->nb_params = nb_params;"}, {"sha": "b0bb9bce074229eb7845f54c8bb93cb6aee797c2", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -173,19 +173,19 @@ struct hard_reg_set_container\n #define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n #define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n-static inline bool\n+inline bool\n hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & ~y) == HARD_CONST (0);\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & y) != HARD_CONST (0);\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_empty_p (const_hard_reg_set x)\n {\n   return x == HARD_CONST (0);\n@@ -228,7 +228,7 @@ SET_HARD_REG_SET (HARD_REG_SET &set)\n     set.elts[i] = -1;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   HARD_REG_ELT_TYPE bad = 0;\n@@ -237,7 +237,7 @@ hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n   return bad == 0;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   HARD_REG_ELT_TYPE good = 0;\n@@ -246,7 +246,7 @@ hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n   return good != 0;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_empty_p (const_hard_reg_set x)\n {\n   HARD_REG_ELT_TYPE bad = 0;\n@@ -279,7 +279,7 @@ struct hard_reg_set_iterator\n \n /* The implementation of the iterator functions is fully analogous to\n    the bitmap iterators.  */\n-static inline void\n+inline void\n hard_reg_set_iter_init (hard_reg_set_iterator *iter, const_hard_reg_set set,\n                         unsigned min, unsigned *regno)\n {\n@@ -302,7 +302,7 @@ hard_reg_set_iter_init (hard_reg_set_iterator *iter, const_hard_reg_set set,\n   *regno = min;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n {\n   while (1)\n@@ -337,7 +337,7 @@ hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n     }\n }\n \n-static inline void\n+inline void\n hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n {\n   iter->bits >>= 1;"}, {"sha": "1c5189b04d5195b8e1496bf71df5e7cce0e83569", "filename": "gcc/hash-map.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -315,29 +315,29 @@ class GTY((user)) hash_map\n /* ggc marking routines.  */\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_ggc_mx (hash_map<K, V, H> *h)\n {\n   gt_ggc_mx (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_map<K, V, H> *h)\n {\n   gt_pch_nx (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_cleare_cache (hash_map<K, V, H> *h)\n {\n   if (h)\n     gt_cleare_cache (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_map<K, V, H> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_table.m_entries, NULL, cookie);"}, {"sha": "f6125eb6a3a0b3af41eeb98bbd0f0039cb06600b", "filename": "gcc/hash-set.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -194,21 +194,21 @@ debug_helper (hash_set<T> &ref)\n /* ggc marking routines.  */\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_ggc_mx (hash_set<K, false, H> *h)\n {\n   gt_ggc_mx (&h->m_table);\n }\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_set<K, false, H> *h)\n {\n   gt_pch_nx (&h->m_table);\n }\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_set<K, false, H> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_table.m_entries, NULL, cookie);"}, {"sha": "3f87ec06f37a7264e2d46730586c484b2c3b3160", "filename": "gcc/hash-table.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1236,7 +1236,7 @@ hash_table<Descriptor, Lazy, Allocator>::iterator::operator ++ ()\n /* ggc walking routines.  */\n \n template<typename E>\n-static inline void\n+inline void\n gt_ggc_mx (hash_table<E> *h)\n {\n   typedef hash_table<E> table;\n@@ -1257,7 +1257,7 @@ gt_ggc_mx (hash_table<E> *h)\n }\n \n template<typename D>\n-static inline void\n+inline void\n hashtab_entry_note_pointers (void *obj, void *h, gt_pointer_operator op,\n \t\t\t     void *cookie)\n {\n@@ -1293,7 +1293,7 @@ gt_pch_nx (hash_table<D> *h)\n }\n \n template<typename D>\n-static inline void\n+inline void\n gt_pch_nx (hash_table<D> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_entries, NULL, cookie);"}, {"sha": "427e9b9e9fda7fe93431c3427f6c04aac4af02af", "filename": "gcc/hwint.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -138,23 +138,23 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n \n /* Return X with all but the lowest bit masked off.  */\n \n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n least_bit_hwi (unsigned HOST_WIDE_INT x)\n {\n   return (x & -x);\n }\n \n /* True if X is zero or a power of two.  */\n \n-static inline bool\n+inline bool\n pow2_or_zerop (unsigned HOST_WIDE_INT x)\n {\n   return least_bit_hwi (x) == x;\n }\n \n /* True if X is a power of two.  */\n \n-static inline bool\n+inline bool\n pow2p_hwi (unsigned HOST_WIDE_INT x)\n {\n   return x && pow2_or_zerop (x);\n@@ -181,7 +181,7 @@ extern int ceil_log2\t\t\t(unsigned HOST_WIDE_INT);\n #else /* GCC_VERSION >= 3004 */\n \n /* For convenience, define 0 -> word_size.  */\n-static inline int\n+inline int\n clz_hwi (unsigned HOST_WIDE_INT x)\n {\n   if (x == 0)\n@@ -195,7 +195,7 @@ clz_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n ctz_hwi (unsigned HOST_WIDE_INT x)\n {\n   if (x == 0)\n@@ -209,7 +209,7 @@ ctz_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n ffs_hwi (unsigned HOST_WIDE_INT x)\n {\n # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n@@ -221,7 +221,7 @@ ffs_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n popcount_hwi (unsigned HOST_WIDE_INT x)\n {\n # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n@@ -233,19 +233,19 @@ popcount_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n floor_log2 (unsigned HOST_WIDE_INT x)\n {\n   return HOST_BITS_PER_WIDE_INT - 1 - clz_hwi (x);\n }\n \n-static inline int\n+inline int\n ceil_log2 (unsigned HOST_WIDE_INT x)\n {\n   return x == 0 ? 0 : floor_log2 (x - 1) + 1;\n }\n \n-static inline int\n+inline int\n exact_log2 (unsigned HOST_WIDE_INT x)\n {\n   return pow2p_hwi (x) ? ctz_hwi (x) : -1;\n@@ -266,15 +266,15 @@ extern HOST_WIDE_INT least_common_multiple (HOST_WIDE_INT, HOST_WIDE_INT);\n \n /* Like ctz_hwi, except 0 when x == 0.  */\n \n-static inline int\n+inline int\n ctz_or_zero (unsigned HOST_WIDE_INT x)\n {\n   return ffs_hwi (x) - 1;\n }\n \n /* Sign extend SRC starting from PREC.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n sext_hwi (HOST_WIDE_INT src, unsigned int prec)\n {\n   if (prec == HOST_BITS_PER_WIDE_INT)\n@@ -304,7 +304,7 @@ sext_hwi (HOST_WIDE_INT src, unsigned int prec)\n }\n \n /* Zero extend SRC starting from PREC.  */\n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n zext_hwi (unsigned HOST_WIDE_INT src, unsigned int prec)\n {\n   if (prec == HOST_BITS_PER_WIDE_INT)"}, {"sha": "e4168d95ad9fd158d11226648e7988984a47f963", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4253,6 +4253,9 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n \t    e = dest;\n \t}\n \n+      if (if_infop->cond_inverted)\n+\tstd::swap (t, e);\n+\n       target = noce_emit_cmove (if_infop, dest, code, cond_arg0, cond_arg1,\n \t\t\t\tt, e);\n       if (!target)\n@@ -4405,7 +4408,6 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   basic_block then_bb, else_bb, join_bb;\n   bool then_else_reversed = false;\n   rtx_insn *jump;\n-  rtx cond;\n   rtx_insn *cond_earliest;\n   struct noce_if_info if_info;\n   bool speed_p = optimize_bb_for_speed_p (test_bb);\n@@ -4481,25 +4483,28 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   if (! onlyjump_p (jump))\n     return FALSE;\n \n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  cond = noce_get_condition (jump, &cond_earliest, then_else_reversed);\n-  if (!cond)\n-    return FALSE;\n-\n-  /* We must be comparing objects whose modes imply the size.  */\n-  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n-    return FALSE;\n-\n   /* Initialize an IF_INFO struct to pass around.  */\n   memset (&if_info, 0, sizeof if_info);\n   if_info.test_bb = test_bb;\n   if_info.then_bb = then_bb;\n   if_info.else_bb = else_bb;\n   if_info.join_bb = join_bb;\n-  if_info.cond = cond;\n+  if_info.cond = noce_get_condition (jump, &cond_earliest,\n+\t\t\t\t     then_else_reversed);\n   rtx_insn *rev_cond_earliest;\n   if_info.rev_cond = noce_get_condition (jump, &rev_cond_earliest,\n \t\t\t\t\t !then_else_reversed);\n+  if (!if_info.cond && !if_info.rev_cond)\n+    return FALSE;\n+  if (!if_info.cond)\n+    {\n+      std::swap (if_info.cond, if_info.rev_cond);\n+      std::swap (cond_earliest, rev_cond_earliest);\n+      if_info.cond_inverted = true;\n+    }\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (if_info.cond, 0)) == BLKmode)\n+    return FALSE;\n   gcc_assert (if_info.rev_cond == NULL_RTX\n \t      || rev_cond_earliest == cond_earliest);\n   if_info.cond_earliest = cond_earliest;\n@@ -4518,7 +4523,9 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n \n   /* Do the real work.  */\n \n-  if (noce_process_if_block (&if_info))\n+  /* ??? noce_process_if_block has not yet been updated to handle\n+     inverted conditions.  */\n+  if (!if_info.cond_inverted && noce_process_if_block (&if_info))\n     return TRUE;\n \n   if (HAVE_conditional_move"}, {"sha": "be1385aabe408d0ef473b675dba9406d2df54d08", "filename": "gcc/ifcvt.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fifcvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fifcvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -86,6 +86,14 @@ struct noce_if_info\n      form as well.  */\n   bool then_else_reversed;\n \n+  /* True if THEN_BB is conditional on !COND rather than COND.\n+     This is used if:\n+\n+     - JUMP branches to THEN_BB on COND\n+     - JUMP falls through to JOIN_BB on !COND\n+     - COND cannot be reversed.  */\n+  bool cond_inverted;\n+\n   /* True if the contents of then_bb and else_bb are a\n      simple single set instruction.  */\n   bool then_simple;"}, {"sha": "9d68648bb3c54df6ca5d91afa231351ad5780e4e", "filename": "gcc/input.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -195,7 +195,7 @@ extern int get_discriminator_from_loc (location_t);\n    that is part of a macro replacement-list defined in a system\n    header, but expanded in a non-system file.  */\n \n-static inline int\n+inline int\n in_system_header_at (location_t loc)\n {\n   return linemap_location_in_system_header_p (line_table, loc);\n@@ -204,7 +204,7 @@ in_system_header_at (location_t loc)\n /* Return true if LOCATION is the locus of a token that\n    comes from a macro expansion, false otherwise.  */\n \n-static inline bool\n+inline bool\n from_macro_expansion_at (location_t loc)\n {\n   return linemap_location_from_macro_expansion_p (line_table, loc);\n@@ -214,29 +214,29 @@ from_macro_expansion_at (location_t loc)\n    a macro definition, false otherwise.  This differs from from_macro_expansion_at\n    in its treatment of macro arguments, for which this returns false.  */\n \n-static inline bool\n+inline bool\n from_macro_definition_at (location_t loc)\n {\n   return linemap_location_from_macro_definition_p (line_table, loc);\n }\n \n-static inline location_t\n+inline location_t\n get_pure_location (location_t loc)\n {\n   return get_pure_location (line_table, loc);\n }\n \n /* Get the start of any range encoded within location LOC.  */\n \n-static inline location_t\n+inline location_t\n get_start (location_t loc)\n {\n   return get_range_from_loc (line_table, loc).m_start;\n }\n \n /* Get the endpoint of any range encoded within location LOC.  */\n \n-static inline location_t\n+inline location_t\n get_finish (location_t loc)\n {\n   return get_range_from_loc (line_table, loc).m_finish;"}, {"sha": "baf4d995e224f0a20ea1dfb2ed5a42ec498e6b36", "filename": "gcc/insn-addr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finsn-addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finsn-addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-addr.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -37,7 +37,7 @@ extern int insn_current_address;\n #define INSN_ADDRESSES_SET_P() (insn_addresses_.exists ())\n #define INSN_ADDRESSES_SIZE() (insn_addresses_.length ())\n \n-static inline void\n+inline void\n insn_addresses_new (rtx_insn *insn, int insn_addr)\n {\n   unsigned insn_uid = INSN_UID ((insn));"}, {"sha": "a7936ff37ef6f3e15b3c0439b93d85cc1234751d", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4517,12 +4517,6 @@ expand_SPACESHIP (internal_fn, gcall *stmt)\n     emit_move_insn (target, ops[0].value);\n }\n \n-void\n-expand_TRAP (internal_fn, gcall *)\n-{\n-  expand_builtin_trap ();\n-}\n-\n void\n expand_ASSUME (internal_fn, gcall *)\n {"}, {"sha": "22b4a2d92967076c658965afcaeaf39b449a8caf", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -457,11 +457,6 @@ DEF_INTERNAL_FN (SHUFFLEVECTOR, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n /* <=> optimization.  */\n DEF_INTERNAL_FN (SPACESHIP, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n \n-/* __builtin_trap created from/for __builtin_unreachable.  */\n-DEF_INTERNAL_FN (TRAP, ECF_CONST | ECF_LEAF | ECF_NORETURN\n-\t\t       | ECF_NOTHROW | ECF_COLD | ECF_LOOPING_CONST_OR_PURE,\n-\t\t NULL)\n-\n /* [[assume (cond)]].  */\n DEF_INTERNAL_FN (ASSUME, ECF_CONST | ECF_LEAF | ECF_NOTHROW\n \t\t\t | ECF_LOOPING_CONST_OR_PURE, NULL)"}, {"sha": "2fd82a19d158854b64ec872c63b2dc11c82010b2", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -105,7 +105,7 @@ extern void init_internal_fns ();\n \n extern const char *const internal_fn_name_array[];\n \n-static inline const char *\n+inline const char *\n internal_fn_name (enum internal_fn fn)\n {\n   return internal_fn_name_array[(int) fn];\n@@ -117,7 +117,7 @@ extern internal_fn lookup_internal_fn (const char *);\n \n extern const int internal_fn_flags_array[];\n \n-static inline int\n+inline int\n internal_fn_flags (enum internal_fn fn)\n {\n   return internal_fn_flags_array[(int) fn];\n@@ -127,7 +127,7 @@ internal_fn_flags (enum internal_fn fn)\n \n extern GTY(()) const_tree internal_fn_fnspec_array[IFN_LAST + 1];\n \n-static inline const_tree\n+inline const_tree\n internal_fn_fnspec (enum internal_fn fn)\n {\n   return internal_fn_fnspec_array[(int) fn];"}, {"sha": "4b8dedc0c518c084155bb7ad983ee1eca1a91917", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1982,7 +1982,9 @@ ipa_agg_value_from_jfunc (ipa_node_params *info, cgraph_node *node,\n   tree value = NULL_TREE;\n   int src_idx;\n \n-  if (item->offset < 0 || item->jftype == IPA_JF_UNKNOWN)\n+  if (item->offset < 0\n+      || item->jftype == IPA_JF_UNKNOWN\n+      || item->offset >= (HOST_WIDE_INT) UINT_MAX * BITS_PER_UNIT)\n     return NULL_TREE;\n \n   if (item->jftype == IPA_JF_CONST)"}, {"sha": "14cf132c76713461eb9df0deab64f1a262a357ce", "filename": "gcc/ipa-devirt.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-devirt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-devirt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1300,7 +1300,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\tG_(\"it is defined as a pointer to different type \"\n \t\t\t   \"in another translation unit\"));\n-\t      if (warn && warned)\n+\t      if (warn && (warned == NULL || *warned))\n \t        warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t\t\t     loc1, loc2);\n \t      return false;\n@@ -1315,7 +1315,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"a different type is defined \"\n \t\t       \"in another translation unit\"));\n-\t  if (warn && warned)\n+\t  if (warn && (warned == NULL || *warned))\n \t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  return false;\n \t}\n@@ -1333,7 +1333,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t      G_(\"a different type is defined in another \"\n \t\t\t \"translation unit\"));\n-\t    if (warn && warned)\n+\t    if (warn && (warned == NULL || *warned))\n \t      warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  }\n \tgcc_assert (TYPE_STRING_FLAG (t1) == TYPE_STRING_FLAG (t2));\n@@ -1375,7 +1375,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"has different return value \"\n \t\t       \"in another translation unit\"));\n-\t  if (warn && warned)\n+\t  if (warn && (warned == NULL || *warned))\n \t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  return false;\n \t}\n@@ -1398,7 +1398,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t    G_(\"has different parameters in another \"\n \t\t\t       \"translation unit\"));\n-\t\t  if (warn && warned)\n+\t\t  if (warn && (warned == NULL || *warned))\n \t\t    warn_types_mismatch (TREE_VALUE (parms1),\n \t\t\t\t\t TREE_VALUE (parms2), loc1, loc2);\n \t\t  return false;\n@@ -1484,7 +1484,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t    warn_odr (t1, t2, f1, f2, warn, warned,\n \t\t\t      G_(\"a field of same name but different type \"\n \t\t\t\t \"is defined in another translation unit\"));\n-\t\t    if (warn && warned)\n+\t\t    if (warn && (warned == NULL || *warned))\n \t\t      warn_types_mismatch (TREE_TYPE (f1), TREE_TYPE (f2), loc1, loc2);\n \t\t    return false;\n \t\t  }\n@@ -3471,8 +3471,10 @@ possible_polymorphic_call_target_p (tree otr_type,\n   unsigned int i;\n   bool final;\n \n-  if (fndecl_built_in_p (n->decl, BUILT_IN_UNREACHABLE)\n-      || fndecl_built_in_p (n->decl, BUILT_IN_TRAP))\n+  if (fndecl_built_in_p (n->decl, BUILT_IN_NORMAL)\n+      && (DECL_FUNCTION_CODE (n->decl) == BUILT_IN_UNREACHABLE\n+\t  || DECL_FUNCTION_CODE (n->decl) == BUILT_IN_TRAP\n+\t  || DECL_FUNCTION_CODE (n->decl) == BUILT_IN_UNREACHABLE_TRAP))\n     return true;\n \n   if (is_cxa_pure_virtual_p (n->decl))"}, {"sha": "fcc01167d0d2889b945e8644d86c582f1cac3fce", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -435,7 +435,7 @@ void ipa_remove_from_growth_caches (struct cgraph_edge *edge);\n \n /* Return true if EDGE is a cross module call.  */\n \n-static inline bool\n+inline bool\n cross_module_call_p (struct cgraph_edge *edge)\n {\n   /* Here we do not want to walk to alias target becuase ICF may create"}, {"sha": "1ad6421a5baa151aeb1b060585efdce361a0fe1e", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Logs a MESSAGE to dump_file if exists and returns false. FUNC is name\n    of function and LINE is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_false_with_message_1 (const char *message, const char *filename,\n \t\t\t     const char *func, unsigned int line)\n {\n@@ -59,7 +59,7 @@ return_false_with_message_1 (const char *message, const char *filename,\n /* Logs return value if RESULT is false. FUNC is name of function and LINE\n    is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_with_result (bool result, const char *filename,\n \t\t    const char *func, unsigned int line)\n {\n@@ -77,7 +77,7 @@ return_with_result (bool result, const char *filename,\n /* Verbose logging function logging statements S1 and S2 of a CODE.\n    FUNC is name of function and LINE is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_different_stmts_1 (gimple *s1, gimple *s2, const char *code,\n \t\t\t  const char *func, unsigned int line)\n {"}, {"sha": "70de89a8b5a18813c44246789300709293ab25ae", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -69,7 +69,7 @@ extern function_summary <tree *> *ipa_saved_clone_sources;\n \n /* Return estimated size of the inline sequence of EDGE.  */\n \n-static inline int\n+inline int\n estimate_edge_size (struct cgraph_edge *edge)\n {\n   edge_growth_cache_entry *entry;\n@@ -82,7 +82,7 @@ estimate_edge_size (struct cgraph_edge *edge)\n \n /* Return lower bound on estimated callee growth after inlining EDGE.  */\n \n-static inline int\n+inline int\n estimate_min_edge_growth (struct cgraph_edge *edge)\n {\n   ipa_call_summary *s = ipa_call_summaries->get (edge);\n@@ -92,7 +92,7 @@ estimate_min_edge_growth (struct cgraph_edge *edge)\n \n /* Return estimated callee growth after inlining EDGE.  */\n \n-static inline int\n+inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n   ipa_call_summary *s = ipa_call_summaries->get (edge);\n@@ -103,7 +103,7 @@ estimate_edge_growth (struct cgraph_edge *edge)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline sreal\n+inline sreal\n estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n {\n   edge_growth_cache_entry *entry;\n@@ -120,7 +120,7 @@ estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline ipa_hints\n+inline ipa_hints\n estimate_edge_hints (struct cgraph_edge *edge)\n {\n   edge_growth_cache_entry *entry;"}, {"sha": "2a2d31e86dbeb87934ef0f9b3cd81620a2ea26fa", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -108,7 +108,7 @@ static const int implicit_retslot_eaf_flags\n    MODREF_FLAGS are flags determined by analysis of function body while\n    FLAGS are flags known otherwise (i.e. by fnspec, pure/const attributes\n    etc.)  */\n-static inline int\n+inline int\n interposable_eaf_flags (int modref_flags, int flags)\n {\n   /* If parameter was previously unused, we know it is only read"}, {"sha": "42488ee09c3719f66a657c5b1c277dc901c96680", "filename": "gcc/ipa-param-manipulation.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-param-manipulation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-param-manipulation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1857,6 +1857,8 @@ ipa_param_body_adjustments::modify_expression (tree *expr_p, bool convert)\n   if (convert && !useless_type_conversion_p (TREE_TYPE (expr),\n \t\t\t\t\t     TREE_TYPE (repl)))\n     {\n+      gcc_checking_assert (tree_to_shwi (TYPE_SIZE (TREE_TYPE (expr)))\n+\t\t\t   == tree_to_shwi (TYPE_SIZE (TREE_TYPE (repl))));\n       tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), repl);\n       *expr_p = vce;\n     }\n@@ -1900,6 +1902,8 @@ ipa_param_body_adjustments::modify_assignment (gimple *stmt,\n \t}\n       else\n \t{\n+\t  gcc_checking_assert (tree_to_shwi (TYPE_SIZE (TREE_TYPE (*lhs_p)))\n+\t\t\t      == tree_to_shwi (TYPE_SIZE (TREE_TYPE (*rhs_p))));\n \t  tree new_rhs = fold_build1_loc (gimple_location (stmt),\n \t\t\t\t\t  VIEW_CONVERT_EXPR, TREE_TYPE (*lhs_p),\n \t\t\t\t\t  *rhs_p);"}, {"sha": "a40ccc0ebbe84bb6d1603acbc84c7bbc34e1b91f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -348,14 +348,14 @@ struct GTY (()) ipa_jump_func\n \n /* Return the constant stored in a constant jump functin JFUNC.  */\n \n-static inline tree\n+inline tree\n ipa_get_jf_constant (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n   return jfunc->value.constant.value;\n }\n \n-static inline struct ipa_cst_ref_desc *\n+inline struct ipa_cst_ref_desc *\n ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n@@ -364,7 +364,7 @@ ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n \n /* Return the operand of a pass through jmp function JFUNC.  */\n \n-static inline tree\n+inline tree\n ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -374,7 +374,7 @@ ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)\n /* Return the number of the caller's formal parameter that a pass through jump\n    function JFUNC refers to.  */\n \n-static inline int\n+inline int\n ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -383,7 +383,7 @@ ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)\n \n /* Return operation of a pass through jump function JFUNC.  */\n \n-static inline enum tree_code\n+inline enum tree_code\n ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -392,7 +392,7 @@ ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n \n /* Return the agg_preserved flag of a pass through jump function JFUNC.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -402,7 +402,7 @@ ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n /* Return true if pass through jump function JFUNC preserves type\n    information.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -411,7 +411,7 @@ ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n \n /* Return the offset of an ancestor jump function JFUNC.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -421,7 +421,7 @@ ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n /* Return the number of the caller's formal parameter that an ancestor jump\n    function JFUNC refers to.  */\n \n-static inline int\n+inline int\n ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -430,7 +430,7 @@ ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n \n /* Return the agg_preserved flag of an ancestor jump function JFUNC.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -439,7 +439,7 @@ ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n \n /* Return true if ancestor jump function JFUNC presrves type information.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -450,7 +450,7 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n    parameter for non-NULLness unless it does not matter because the offset is\n    zero anyway.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_keep_null (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -701,7 +701,7 @@ struct ipa_func_body_info\n \n /* Return the number of formal parameters. */\n \n-static inline int\n+inline int\n ipa_get_param_count (class ipa_node_params *info)\n {\n   return vec_safe_length (info->descriptors);\n@@ -710,7 +710,7 @@ ipa_get_param_count (class ipa_node_params *info)\n /* Return the parameter declaration in DESCRIPTORS at index I and assert it is\n    indeed a PARM_DECL.  */\n \n-static inline tree\n+inline tree\n ipa_get_param (const vec<ipa_param_descriptor, va_gc> &descriptors, int i)\n {\n   tree t = descriptors[i].decl_or_type;\n@@ -723,7 +723,7 @@ ipa_get_param (const vec<ipa_param_descriptor, va_gc> &descriptors, int i)\n    using ipa_initialize_node_params.  This function should not be called in\n    WPA.  */\n \n-static inline tree\n+inline tree\n ipa_get_param (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -733,7 +733,7 @@ ipa_get_param (class ipa_node_params *info, int i)\n /* Return the type of Ith formal parameter of the function corresponding\n    to INFO if it is known or NULL if not.  */\n \n-static inline tree\n+inline tree\n ipa_get_type (class ipa_node_params *info, int i)\n {\n   if (vec_safe_length (info->descriptors) <= (unsigned) i)\n@@ -750,7 +750,7 @@ ipa_get_type (class ipa_node_params *info, int i)\n /* Return the move cost of Ith formal parameter of the function corresponding\n    to INFO.  */\n \n-static inline int\n+inline int\n ipa_get_param_move_cost (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -760,7 +760,7 @@ ipa_get_param_move_cost (class ipa_node_params *info, int i)\n /* Set the used flag corresponding to the Ith formal parameter of the function\n    associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -770,7 +770,7 @@ ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n /* Set the used_by_ipa_predicates flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_ipa_predicates (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -780,7 +780,7 @@ ipa_set_param_used_by_ipa_predicates (class ipa_node_params *info, int i, bool v\n /* Set the used_by_indirect_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_indirect_call (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -790,7 +790,7 @@ ipa_set_param_used_by_indirect_call (class ipa_node_params *info, int i, bool va\n /* Set the .used_by_polymorphic_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_polymorphic_call (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -800,7 +800,7 @@ ipa_set_param_used_by_polymorphic_call (class ipa_node_params *info, int i, bool\n /* Return how many uses described by ipa-prop a parameter has or\n    IPA_UNDESCRIBED_USE if there is a use that is not described by these\n    structures.  */\n-static inline int\n+inline int\n ipa_get_controlled_uses (class ipa_node_params *info, int i)\n {\n   /* FIXME: introducing speculation causes out of bounds access here.  */\n@@ -811,7 +811,7 @@ ipa_get_controlled_uses (class ipa_node_params *info, int i)\n \n /* Set the controlled counter of a given parameter.  */\n \n-static inline void\n+inline void\n ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -820,7 +820,7 @@ ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n \n /* Assuming a parameter does not have IPA_UNDESCRIBED_USE controlled uses,\n    return flag which indicates it has been dereferenced but only in a load.  */\n-static inline int\n+inline int\n ipa_get_param_load_dereferenced (class ipa_node_params *info, int i)\n {\n   gcc_assert (ipa_get_controlled_uses (info, i) != IPA_UNDESCRIBED_USE);\n@@ -829,7 +829,7 @@ ipa_get_param_load_dereferenced (class ipa_node_params *info, int i)\n \n /* Set the load_dereferenced flag of a given parameter.  */\n \n-static inline void\n+inline void\n ipa_set_param_load_dereferenced (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -839,7 +839,7 @@ ipa_set_param_load_dereferenced (class ipa_node_params *info, int i, bool val)\n /* Return the used flag corresponding to the Ith formal parameter of the\n    function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -849,7 +849,7 @@ ipa_is_param_used (class ipa_node_params *info, int i)\n /* Return the used_by_ipa_predicates flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_ipa_predicates (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -859,7 +859,7 @@ ipa_is_param_used_by_ipa_predicates (class ipa_node_params *info, int i)\n /* Return the used_by_indirect_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_indirect_call (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -869,7 +869,7 @@ ipa_is_param_used_by_indirect_call (class ipa_node_params *info, int i)\n /* Return the used_by_polymorphic_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_polymorphic_call (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -944,7 +944,7 @@ class GTY((for_user)) ipa_edge_args\n \n /* Return the number of actual arguments. */\n \n-static inline int\n+inline int\n ipa_get_cs_argument_count (class ipa_edge_args *args)\n {\n   return vec_safe_length (args->jump_functions);\n@@ -954,15 +954,15 @@ ipa_get_cs_argument_count (class ipa_edge_args *args)\n    there is no setter function as jump functions are all set up in\n    ipa_compute_jump_functions. */\n \n-static inline struct ipa_jump_func *\n+inline struct ipa_jump_func *\n ipa_get_ith_jump_func (class ipa_edge_args *args, int i)\n {\n   return &(*args->jump_functions)[i];\n }\n \n /* Returns a pointer to the polymorphic call context for the ith argument.\n    NULL if contexts are not computed.  */\n-static inline class ipa_polymorphic_call_context *\n+inline class ipa_polymorphic_call_context *\n ipa_get_ith_polymorhic_call_context (class ipa_edge_args *args, int i)\n {\n   if (!args->polymorphic_call_contexts)\n@@ -1056,7 +1056,7 @@ int count_formal_params (tree fndecl);\n /* This function ensures the array of node param infos is big enough to\n    accommodate a structure for all nodes and reallocates it if not.  */\n \n-static inline void\n+inline void\n ipa_check_create_node_params (void)\n {\n   if (!ipa_node_params_sum)\n@@ -1069,13 +1069,13 @@ ipa_check_create_node_params (void)\n    of this function is that debug dumping function can check info availability\n    without causing allocations.  */\n \n-static inline bool\n+inline bool\n ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n {\n   return ipa_edge_args_sum->exists (edge);\n }\n \n-static inline ipcp_transformation *\n+inline ipcp_transformation *\n ipcp_get_transformation_summary (cgraph_node *node)\n {\n   if (ipcp_transformation_sum == NULL)"}, {"sha": "6730f4f9d0e314831644ab401fdfb227ec027f34", "filename": "gcc/ipa-split.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-split.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-split.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1715,10 +1715,11 @@ execute_split_functions (void)\n   struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n   if (flags_from_decl_or_type (current_function_decl)\n-      & (ECF_NORETURN|ECF_MALLOC))\n+      & (ECF_NORETURN|ECF_MALLOC|ECF_RETURNS_TWICE))\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Not splitting: noreturn/malloc function.\\n\");\n+\tfprintf (dump_file, \"Not splitting: noreturn/malloc/returns_twice \"\n+\t\t\t    \"function.\\n\");\n       return 0;\n     }\n   if (MAIN_NAME_P (DECL_NAME (current_function_decl)))"}, {"sha": "3de7d426b7e7339d16b2ed8a28e88659bbf9562e", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -3989,9 +3989,7 @@ push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n \t{\n \t  ipa_argagg_value_list avl (ipcp_ts);\n \t  tree value = avl.get_value (base_index, pa->unit_offset);\n-\t  if (value\n-\t      && (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (value))) / BITS_PER_UNIT\n-\t\t  == pa->unit_size))\n+\t  if (value && !AGGREGATE_TYPE_P (pa->type))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"    - omitting component at byte \"\n@@ -4130,6 +4128,22 @@ process_isra_node_results (cgraph_node *node,\n   callers.release ();\n }\n \n+/* If INDICES is not empty, dump a combination of NODE's dump_name and MSG\n+   followed by the list of numbers in INDICES.  */\n+\n+static void\n+dump_list_of_param_indices (const cgraph_node *node, const char* msg,\n+\t\t\t    const vec<unsigned> &indices)\n+{\n+  if (indices.is_empty ())\n+    return;\n+  fprintf (dump_file, \"The following parameters of %s %s:\", node->dump_name (),\n+\t   msg);\n+  for (unsigned i : indices)\n+    fprintf (dump_file, \" %u\", i);\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n /* Check which parameters of NODE described by IFS have survived until IPA-SRA\n    and disable transformations for those which have not or which should not\n    transformed because the associated debug counter reached its limit.  Return\n@@ -4153,6 +4167,7 @@ adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n       check_surviving = true;\n       cinfo->param_adjustments->get_surviving_params (&surviving_params);\n     }\n+  ipcp_transformation *ipcp_ts = ipcp_get_transformation_summary (node);\n   auto_vec <unsigned> dump_dead_indices;\n   auto_vec <unsigned> dump_bad_cond_indices;\n   for (unsigned i = 0; i < len; i++)\n@@ -4202,27 +4217,40 @@ adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n \t      if (size_would_violate_limit_p (desc, desc->size_reached))\n \t\tdesc->split_candidate = false;\n \t    }\n+\n+\t  /* Avoid ICEs on size-mismatched VIEW_CONVERT_EXPRs when callers and\n+\t     callees don't agree on types in aggregates and we try to do both\n+\t     IPA-CP and IPA-SRA.  */\n+\t  if (ipcp_ts && desc->split_candidate)\n+\t    {\n+\t      ipa_argagg_value_list avl (ipcp_ts);\n+\t      for (const param_access *pa : desc->accesses)\n+\t\t{\n+\t\t  if (!pa->certain)\n+\t\t    continue;\n+\t\t  tree value = avl.get_value (i, pa->unit_offset);\n+\t\t  if (value\n+\t\t      && ((tree_to_uhwi (TYPE_SIZE (TREE_TYPE (value)))\n+\t\t\t   / BITS_PER_UNIT)\n+\t\t\t  != pa->unit_size))\n+\t\t    {\n+\t\t      desc->split_candidate = false;\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tdump_dead_indices.safe_push (i);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  if (desc->locally_unused || desc->split_candidate)\n \t    ret = false;\n \t}\n     }\n \n-  if (!dump_dead_indices.is_empty ())\n-    {\n-      fprintf (dump_file, \"The following parameters of %s are dead on arrival:\",\n-\t       node->dump_name ());\n-      for (unsigned i : dump_dead_indices)\n-\tfprintf (dump_file, \" %u\", i);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  if (!dump_bad_cond_indices.is_empty ())\n-    {\n-      fprintf (dump_file, \"The following parameters of %s are not safe to \"\n-\t       \"derefernce in all callers:\", node->dump_name ());\n-      for (unsigned i : dump_bad_cond_indices)\n-\tfprintf (dump_file, \" %u\", i);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+  dump_list_of_param_indices (node, \"are dead on arrival or have a type \"\n+\t\t\t      \"mismatch with IPA-CP\", dump_dead_indices);\n+  dump_list_of_param_indices (node, \"are not safe to dereference in all \"\n+\t\t\t      \"callers\", dump_bad_cond_indices);\n \n   return ret;\n }"}, {"sha": "5c15b60a60377649c501db3e9bd39e3fade41578", "filename": "gcc/ipa.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fipa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -182,7 +182,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n     = possible_polymorphic_call_targets\n \t(edge, &final, &cache_token);\n \n-  if (!reachable_call_targets->add (cache_token))\n+  if (cache_token != NULL && !reachable_call_targets->add (cache_token))\n     {\n       for (i = 0; i < targets.length (); i++)\n \t{"}, {"sha": "1fb2958bddd0d9db75b9eeae525a59cddb693659", "filename": "gcc/ira-color.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira-color.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira-color.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -512,6 +512,13 @@ print_hard_reg_set (FILE *f, HARD_REG_SET set, bool new_line_p)\n     fprintf (f, \"\\n\");\n }\n \n+/* Dump a hard reg set SET to stderr.  */\n+DEBUG_FUNCTION void\n+debug_hard_reg_set (HARD_REG_SET set)\n+{\n+  print_hard_reg_set (stderr, set, true);\n+}\n+\n /* Print allocno hard register subforest given by ROOTS and its LEVEL\n    to F.  */\n static void"}, {"sha": "e2de47213b490e90a56f139dcea078341a8a8fae", "filename": "gcc/ira-int.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -504,7 +504,7 @@ struct ira_emit_data\n extern ira_emit_data_t ira_allocno_emit_data;\n \n /* Abbreviation for frequent emit data access.  */\n-static inline rtx\n+inline rtx\n allocno_emit_reg (ira_allocno_t a)\n {\n   return ALLOCNO_EMIT_DATA (a)->reg;\n@@ -734,7 +734,7 @@ struct minmax_set_iterator {\n \n /* Initialize the iterator I for bit vector VEC containing minimal and\n    maximal values MIN and MAX.  */\n-static inline void\n+inline void\n minmax_set_iter_init (minmax_set_iterator *i, IRA_INT_TYPE *vec, int min,\n \t\t      int max)\n {\n@@ -749,7 +749,7 @@ minmax_set_iter_init (minmax_set_iterator *i, IRA_INT_TYPE *vec, int min,\n /* Return TRUE if we have more allocnos to visit, in which case *N is\n    set to the number of the element to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n minmax_set_iter_cond (minmax_set_iterator *i, int *n)\n {\n   /* Skip words that are zeros.  */\n@@ -774,7 +774,7 @@ minmax_set_iter_cond (minmax_set_iterator *i, int *n)\n }\n \n /* Advance to the next element in the set.  */\n-static inline void\n+inline void\n minmax_set_iter_next (minmax_set_iterator *i)\n {\n   i->word >>= 1;\n@@ -1084,7 +1084,7 @@ extern void ira_emit (bool);\n \f\n \n /* Return true if equivalence of pseudo REGNO is not a lvalue.  */\n-static inline bool\n+inline bool\n ira_equiv_no_lvalue_p (int regno)\n {\n   if (regno >= ira_reg_equiv_len)\n@@ -1098,7 +1098,7 @@ ira_equiv_no_lvalue_p (int regno)\n \f\n \n /* Initialize register costs for MODE if necessary.  */\n-static inline void\n+inline void\n ira_init_register_move_cost_if_necessary (machine_mode mode)\n {\n   if (ira_register_move_cost[mode] == NULL)\n@@ -1114,15 +1114,15 @@ struct ira_allocno_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_allocno_iter_init (ira_allocno_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more allocnos to visit, in which case *A is\n    set to the allocno to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_allocno_iter_cond (ira_allocno_iterator *i, ira_allocno_t *a)\n {\n   int n;\n@@ -1151,15 +1151,15 @@ struct ira_object_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_object_iter_init (ira_object_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more objects to visit, in which case *OBJ is\n    set to the object to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_object_iter_cond (ira_object_iterator *i, ira_object_t *obj)\n {\n   int n;\n@@ -1188,7 +1188,7 @@ struct ira_allocno_object_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_allocno_object_iter_init (ira_allocno_object_iterator *i)\n {\n   i->n = 0;\n@@ -1197,7 +1197,7 @@ ira_allocno_object_iter_init (ira_allocno_object_iterator *i)\n /* Return TRUE if we have more objects to visit in allocno A, in which\n    case *O is set to the object to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n ira_allocno_object_iter_cond (ira_allocno_object_iterator *i, ira_allocno_t a,\n \t\t\t      ira_object_t *o)\n {\n@@ -1225,15 +1225,15 @@ struct ira_pref_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_pref_iter_init (ira_pref_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more prefs to visit, in which case *PREF is\n    set to the pref to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_pref_iter_cond (ira_pref_iterator *i, ira_pref_t *pref)\n {\n   int n;\n@@ -1263,15 +1263,15 @@ struct ira_copy_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_copy_iter_init (ira_copy_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more copies to visit, in which case *CP is\n    set to the copy to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_copy_iter_cond (ira_copy_iterator *i, ira_copy_t *cp)\n {\n   int n;\n@@ -1324,7 +1324,7 @@ struct ira_object_conflict_iterator {\n };\n \n /* Initialize the iterator I with ALLOCNO conflicts.  */\n-static inline void\n+inline void\n ira_object_conflict_iter_init (ira_object_conflict_iterator *i,\n \t\t\t       ira_object_t obj)\n {\n@@ -1350,7 +1350,7 @@ ira_object_conflict_iter_init (ira_object_conflict_iterator *i,\n /* Return TRUE if we have more conflicting allocnos to visit, in which\n    case *A is set to the allocno to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n \t\t\t       ira_object_t *pobj)\n {\n@@ -1405,7 +1405,7 @@ ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n /* The function returns TRUE if at least one hard register from ones\n    starting with HARD_REGNO and containing value of MODE are in set\n    HARD_REGSET.  */\n-static inline bool\n+inline bool\n ira_hard_reg_set_intersection_p (int hard_regno, machine_mode mode,\n \t\t\t\t HARD_REG_SET hard_regset)\n {\n@@ -1419,7 +1419,7 @@ ira_hard_reg_set_intersection_p (int hard_regno, machine_mode mode,\n }\n \n /* Return number of hard registers in hard register SET.  */\n-static inline int\n+inline int\n hard_reg_set_size (HARD_REG_SET set)\n {\n   int i, size;\n@@ -1433,7 +1433,7 @@ hard_reg_set_size (HARD_REG_SET set)\n /* The function returns TRUE if hard registers starting with\n    HARD_REGNO and containing value of MODE are fully in set\n    HARD_REGSET.  */\n-static inline bool\n+inline bool\n ira_hard_reg_in_set_p (int hard_regno, machine_mode mode,\n \t\t       HARD_REG_SET hard_regset)\n {\n@@ -1454,7 +1454,7 @@ ira_hard_reg_in_set_p (int hard_regno, machine_mode mode,\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and\n    initialize the elements by VAL if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_set_costs (int **vec, reg_class_t aclass, int val)\n {\n   int i, *reg_costs;\n@@ -1470,7 +1470,7 @@ ira_allocate_and_set_costs (int **vec, reg_class_t aclass, int val)\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and copy\n    values of vector SRC into the vector if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_copy_costs (int **vec, enum reg_class aclass, int *src)\n {\n   int len;\n@@ -1484,7 +1484,7 @@ ira_allocate_and_copy_costs (int **vec, enum reg_class aclass, int *src)\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and add\n    values of vector SRC into the vector if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_accumulate_costs (int **vec, enum reg_class aclass, int *src)\n {\n   int i, len;\n@@ -1504,7 +1504,7 @@ ira_allocate_and_accumulate_costs (int **vec, enum reg_class aclass, int *src)\n /* Allocate cost vector *VEC for hard registers of ACLASS and copy\n    values of vector SRC into the vector or initialize it by VAL (if\n    SRC is null).  */\n-static inline void\n+inline void\n ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class aclass,\n \t\t\t\t    int val, int *src)\n {"}, {"sha": "6c7f4901e4cceb985f8d91087cd4da4a611d22b3", "filename": "gcc/ira.cc", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2725,6 +2725,7 @@ ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx_insn *i\n \t  return;\n \t}\n       ira_reg_equiv[to_regno].defined_p = false;\n+      ira_reg_equiv[to_regno].caller_save_p = false;\n       ira_reg_equiv[to_regno].memory\n \t= ira_reg_equiv[to_regno].constant\n \t= ira_reg_equiv[to_regno].invariant\n@@ -3070,6 +3071,8 @@ validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n     info->equiv_mem_modified = true;\n }\n \n+static int equiv_init_varies_p (rtx x);\n+\n enum valid_equiv { valid_none, valid_combine, valid_reload };\n \n /* Verify that no store between START and the death of REG invalidates\n@@ -3113,7 +3116,8 @@ validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n \t     been changed and all hell breaks loose.  */\n \t  ret = valid_combine;\n \t  if (!MEM_READONLY_P (memref)\n-\t      && !RTL_CONST_OR_PURE_CALL_P (insn))\n+\t      && (!RTL_CONST_OR_PURE_CALL_P (insn)\n+\t\t  || equiv_init_varies_p (XEXP (memref, 0))))\n \t    return valid_none;\n \t}\n \n@@ -3414,6 +3418,7 @@ no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED,\n   if (reg_equiv[regno].is_arg_equivalence)\n     return;\n   ira_reg_equiv[regno].defined_p = false;\n+  ira_reg_equiv[regno].caller_save_p = false;\n   ira_reg_equiv[regno].init_insns = NULL;\n   for (; list; list = list->next ())\n     {\n@@ -3766,7 +3771,18 @@ update_equiv_regs (void)\n \t\t{\n \t\t  replacement = copy_rtx (SET_SRC (set));\n \t\t  if (validity == valid_reload)\n-\t\t    note = set_unique_reg_note (insn, REG_EQUIV, replacement);\n+\t\t    {\n+\t\t      note = set_unique_reg_note (insn, REG_EQUIV, replacement);\n+\t\t    }\n+\t\t  else if (ira_use_lra_p)\n+\t\t    {\n+\t\t      /* We still can use this equivalence for caller save\n+\t\t\t optimization in LRA.  Mark this.  */\n+\t\t      ira_reg_equiv[regno].caller_save_p = true;\n+\t\t      ira_reg_equiv[regno].init_insns\n+\t\t\t= gen_rtx_INSN_LIST (VOIDmode, insn,\n+\t\t\t\t\t     ira_reg_equiv[regno].init_insns);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -4156,7 +4172,7 @@ setup_reg_equiv (void)\n \t\t   legitimate, we ignore such REG_EQUIV notes.  */\n \t\tif (memory_operand (x, VOIDmode))\n \t\t  {\n-\t\t    ira_reg_equiv[i].defined_p = true;\n+\t\t    ira_reg_equiv[i].defined_p = !ira_reg_equiv[i].caller_save_p;\n \t\t    ira_reg_equiv[i].memory = x;\n \t\t    continue;\n \t\t  }\n@@ -4178,6 +4194,7 @@ setup_reg_equiv (void)\n \t\t\tif (ira_reg_equiv[i].memory == NULL_RTX)\n \t\t\t  {\n \t\t\t    ira_reg_equiv[i].defined_p = false;\n+\t\t\t    ira_reg_equiv[i].caller_save_p = false;\n \t\t\t    ira_reg_equiv[i].init_insns = NULL;\n \t\t\t    break;\n \t\t\t  }\n@@ -4188,6 +4205,7 @@ setup_reg_equiv (void)\n \t      }\n \t  }\n \tira_reg_equiv[i].defined_p = false;\n+\tira_reg_equiv[i].caller_save_p = false;\n \tira_reg_equiv[i].init_insns = NULL;\n \tbreak;\n       }\n@@ -5609,12 +5627,16 @@ ira (FILE *f)\n     if (DF_REG_DEF_COUNT (i) || DF_REG_USE_COUNT (i))\n       num_used_regs++;\n \n-  /* If there are too many pseudos and/or basic blocks (e.g. 10K\n-     pseudos and 10K blocks or 100K pseudos and 1K blocks), we will\n-     use simplified and faster algorithms in LRA.  */\n+  /* If there are too many pseudos and/or basic blocks (e.g. 10K pseudos and\n+     10K blocks or 100K pseudos and 1K blocks) or we have too many function\n+     insns, we will use simplified and faster algorithms in LRA.  */\n   lra_simple_p\n-    = ira_use_lra_p\n-      && num_used_regs >= (1U << 26) / last_basic_block_for_fn (cfun);\n+    = (ira_use_lra_p\n+       && (num_used_regs >= (1U << 26) / last_basic_block_for_fn (cfun)\n+           /* max uid is a good evaluation of the number of insns as most\n+              optimizations are done on tree-SSA level.  */\n+           || ((uint64_t) get_max_uid ()\n+\t       > (uint64_t) param_ira_simple_lra_insn_threshold * 1000)));\n \n   if (lra_simple_p)\n     {"}, {"sha": "9c48f94cec92d646bfa3b3db703167df31689e45", "filename": "gcc/ira.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -175,8 +175,11 @@ extern struct target_ira *this_target_ira;\n /* Major structure describing equivalence info for a pseudo.  */\n struct ira_reg_equiv_s\n {\n-  /* True if we can use this equivalence.  */\n+  /* True if we can use this as a general equivalence.  */\n   bool defined_p;\n+  /* True if we can use this equivalence only for caller save/restore\n+     location.  */\n+  bool caller_save_p;\n   /* True if the usage of the equivalence is profitable.  */\n   bool profitable_p;\n   /* Equiv. memory, constant, invariant, and initializing insns of\n@@ -232,7 +235,7 @@ extern rtx non_conflicting_reg_copy_p (rtx_insn *);\n    non-local goto code using frame-pointer to address saved stack\n    pointer value after restoring old frame pointer value.  The\n    function returns TRUE if REGNO is such a static chain pseudo.  */\n-static inline bool\n+inline bool\n non_spilled_static_chain_regno_p (int regno)\n {\n   return (cfun->static_chain_decl && crtl->has_nonlocal_goto"}, {"sha": "4c30cab1db82000e96128975cb20ce7c30be31bf", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,9 @@\n+2023-02-16  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* jit-dejagnu.h: Mechanically drop static from static inline\n+\tfunctions via s/^static inline/inline/g.\n+\t* jit-recording.h: Likewise.\n+\n 2023-01-07  LIU Hao  <lh_mouse@126.com>\n \n \tPR middle-end/108300"}, {"sha": "bdf5785753701c7df9f8ca307c7ea6d225df883f", "filename": "gcc/jit/jit-dejagnu.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2Fjit-dejagnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2Fjit-dejagnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-dejagnu.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -66,7 +66,7 @@ dg_wait (void)\n }\n #endif\n \n-static inline void\n+inline void\n pass (const char* fmt, ...)\n {\n   va_list ap;\n@@ -81,7 +81,7 @@ pass (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n xpass (const char* fmt, ...)\n {\n   va_list ap;\n@@ -96,7 +96,7 @@ xpass (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n fail (const char* fmt, ...)\n {\n   va_list ap;\n@@ -111,7 +111,7 @@ fail (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n xfail (const char* fmt, ...)\n {\n   va_list ap;\n@@ -126,7 +126,7 @@ xfail (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n untested (const char* fmt, ...)\n {\n   va_list ap;\n@@ -141,7 +141,7 @@ untested (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n unresolved (const char* fmt, ...)\n {\n   va_list ap;\n@@ -156,7 +156,7 @@ unresolved (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n note (const char* fmt, ...)\n {\n   va_list ap;\n@@ -170,7 +170,7 @@ note (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n totals (void)\n {\n   printf (\"\\nTotals:\\n\");"}, {"sha": "400cf34560035e74038428c9af7d5c3e0bd0d0cd", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2556,7 +2556,7 @@ types_kinda_same_internal (recording::type *a,\n \n    For array and vector types the number of element also\n    has to match, aswell as the element types themself.  */\n-static inline bool\n+inline bool\n types_kinda_same (recording::type *a, recording::type *b)\n {\n   /* Handle trivial case here, to allow for inlining.  */"}, {"sha": "dbfaf0485a5a2d0d354f652ced022668da0dbc39", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5100,7 +5100,8 @@ lra_constraints (bool first_p)\n \t\t\t && (targetm.preferred_reload_class\n \t\t\t     (x, lra_get_allocno_class (i)) == NO_REGS))\n \t\t\t|| contains_symbol_ref_p (x))))\n-\t      ira_reg_equiv[i].defined_p = false;\n+\t      ira_reg_equiv[i].defined_p\n+\t\t= ira_reg_equiv[i].caller_save_p = false;\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;\n \t    if (get_equiv (reg) != reg)\n@@ -5771,14 +5772,17 @@ choose_split_class (enum reg_class allocno_class,\n   return best_cl;\n }\n \n-/* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO.\n-   It only makes sense to call this function if NEW_REGNO is always\n-   equal to ORIGINAL_REGNO.  */\n+/* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO.  It only\n+   makes sense to call this function if NEW_REGNO is always equal to\n+   ORIGINAL_REGNO.  Set up defined_p flag when caller_save_p flag is set up and\n+   CALL_SAVE_P is true.  */\n \n static void\n-lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno)\n+lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno,\n+\t\t    bool call_save_p)\n {\n-  if (!ira_reg_equiv[original_regno].defined_p)\n+  if (!ira_reg_equiv[original_regno].defined_p\n+      && !(call_save_p && ira_reg_equiv[original_regno].caller_save_p))\n     return;\n \n   ira_expand_reg_equiv ();\n@@ -5958,7 +5962,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n      rematerializing the original value instead of spilling to the stack.  */\n   if (!HARD_REGISTER_NUM_P (original_regno)\n       && mode == PSEUDO_REGNO_MODE (original_regno))\n-    lra_copy_reg_equiv (new_regno, original_regno);\n+    lra_copy_reg_equiv (new_regno, original_regno, call_save_p);\n   lra_reg_info[new_regno].restore_rtx = regno_reg_rtx[original_regno];\n   bitmap_set_bit (&lra_split_regs, new_regno);\n   if (to != NULL)"}, {"sha": "73f8eb004b02d1532b25fbbc1bcd99b2dbb6d437", "filename": "gcc/lra-int.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -419,7 +419,7 @@ extern void lra_eliminate_reg_if_possible (rtx *);\n /* Return the hard register which given pseudo REGNO assigned to.\n    Negative value means that the register got memory or we don't know\n    allocation yet.  */\n-static inline int\n+inline int\n lra_get_regno_hard_regno (int regno)\n {\n   resize_reg_info ();\n@@ -443,7 +443,7 @@ lra_change_class (int regno, enum reg_class new_class,\n \n /* Update insn operands which are duplication of NOP operand.  The\n    insn is represented by its LRA internal representation ID.  */\n-static inline void\n+inline void\n lra_update_dup (lra_insn_recog_data_t id, int nop)\n {\n   int i;\n@@ -458,7 +458,7 @@ lra_update_dup (lra_insn_recog_data_t id, int nop)\n    operands processing.\t Generally speaking, we could do this probably\n    simultaneously with operands processing because a common practice\n    is to enumerate the operators after their operands.\t*/\n-static inline void\n+inline void\n lra_update_operator_dups (lra_insn_recog_data_t id)\n {\n   int i;\n@@ -474,7 +474,7 @@ lra_update_operator_dups (lra_insn_recog_data_t id)\n }\n \n /* Return info about INSN.  Set up the info if it is not done yet.  */\n-static inline lra_insn_recog_data_t\n+inline lra_insn_recog_data_t\n lra_get_insn_recog_data (rtx_insn *insn)\n {\n   lra_insn_recog_data_t data;\n@@ -494,7 +494,7 @@ lra_get_insn_recog_data (rtx_insn *insn)\n }\n \n /* Update offset from pseudos with VAL by INCR.  */\n-static inline void\n+inline void\n lra_update_reg_val_offset (int val, poly_int64 incr)\n {\n   int i;\n@@ -507,7 +507,7 @@ lra_update_reg_val_offset (int val, poly_int64 incr)\n }\n \n /* Return true if register content is equal to VAL with OFFSET.  */\n-static inline bool\n+inline bool\n lra_reg_val_equal_p (int regno, int val, poly_int64 offset)\n {\n   if (lra_reg_info[regno].val == val\n@@ -518,7 +518,7 @@ lra_reg_val_equal_p (int regno, int val, poly_int64 offset)\n }\n \n /* Assign value of register FROM to TO.  */\n-static inline void\n+inline void\n lra_assign_reg_val (int from, int to)\n {\n   lra_reg_info[to].val = lra_reg_info[from].val;"}, {"sha": "4af85c49d43a05c39f642f40b2b843dfe14e670d", "filename": "gcc/lra-spills.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-spills.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra-spills.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -860,6 +860,9 @@ lra_final_code_change (void)\n \t\tlra_update_dup (id, i);\n \t\tinsn_change_p = true;\n \t      }\n+\t  if ((GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t      && alter_subregs (&XEXP (pat, 0), false))\n+\t    insn_change_p = true;\n \t  if (insn_change_p)\n \t    lra_update_operator_dups (id);\n "}, {"sha": "85dbf92741494ae6fa861984b09e2470b33c9f5b", "filename": "gcc/lra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -27,7 +27,7 @@ extern bool lra_simple_p;\n /* Return the allocno reg class of REGNO.  If it is a reload pseudo,\n    the pseudo should finally get hard register of the allocno\n    class.  */\n-static inline enum reg_class\n+inline enum reg_class\n lra_get_allocno_class (int regno)\n {\n   resize_reg_info ();"}, {"sha": "fc7133d07ba162e44efe0c0f259529319ba8b6f9", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -969,15 +969,15 @@ extern const char *lto_section_name[];\n extern vec<lto_out_decl_state_ptr> lto_function_decl_states;\n \n /* Return true if LTO tag TAG corresponds to a tree code.  */\n-static inline bool\n+inline bool\n lto_tag_is_tree_code_p (enum LTO_tags tag)\n {\n   return tag > LTO_first_tree_tag && (unsigned) tag <= MAX_TREE_CODES;\n }\n \n \n /* Return true if LTO tag TAG corresponds to a gimple code.  */\n-static inline bool\n+inline bool\n lto_tag_is_gimple_code_p (enum LTO_tags tag)\n {\n   return (unsigned) tag >= LTO_first_gimple_tag\n@@ -988,7 +988,7 @@ lto_tag_is_gimple_code_p (enum LTO_tags tag)\n \n /* Return the LTO tag corresponding to gimple code CODE.  See enum\n    LTO_tags for details on the conversion.  */\n-static inline enum LTO_tags\n+inline enum LTO_tags\n lto_gimple_code_to_tag (enum gimple_code code)\n {\n   return (enum LTO_tags) ((unsigned) code + LTO_first_gimple_tag);\n@@ -997,7 +997,7 @@ lto_gimple_code_to_tag (enum gimple_code code)\n \n /* Return the GIMPLE code corresponding to TAG.  See enum LTO_tags for\n    details on the conversion.  */\n-static inline enum gimple_code\n+inline enum gimple_code\n lto_tag_to_gimple_code (enum LTO_tags tag)\n {\n   gcc_assert (lto_tag_is_gimple_code_p (tag));\n@@ -1007,7 +1007,7 @@ lto_tag_to_gimple_code (enum LTO_tags tag)\n \n /* Return the LTO tag corresponding to tree code CODE.  See enum\n    LTO_tags for details on the conversion.  */\n-static inline enum LTO_tags\n+inline enum LTO_tags\n lto_tree_code_to_tag (enum tree_code code)\n {\n   return (enum LTO_tags) ((unsigned) code + LTO_first_tree_tag);\n@@ -1016,15 +1016,15 @@ lto_tree_code_to_tag (enum tree_code code)\n \n /* Return the tree code corresponding to TAG.  See enum LTO_tags for\n    details on the conversion.  */\n-static inline enum tree_code\n+inline enum tree_code\n lto_tag_to_tree_code (enum LTO_tags tag)\n {\n   gcc_assert (lto_tag_is_tree_code_p (tag));\n   return (enum tree_code) ((unsigned) tag - LTO_first_tree_tag);\n }\n \n /* Check that tag ACTUAL == EXPECTED.  */\n-static inline void\n+inline void\n lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n {\n   if (actual != expected)\n@@ -1033,7 +1033,7 @@ lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n }\n \n /* Check that tag ACTUAL is in the range [TAG1, TAG2].  */\n-static inline void\n+inline void\n lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n \t\t     enum LTO_tags tag2)\n {\n@@ -1046,7 +1046,7 @@ lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n }\n \n /* Initialize an lto_out_decl_buffer ENCODER.  */\n-static inline void\n+inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   encoder->tree_hash_table = new hash_map<tree, unsigned> (251);\n@@ -1056,7 +1056,7 @@ lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n \n /* Destroy an lto_tree_ref_encoder ENCODER by freeing its contents.  The\n    memory used by ENCODER is not freed by this function.  */\n-static inline void\n+inline void\n lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   /* Hash table may be delete already.  */\n@@ -1066,22 +1066,22 @@ lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n }\n \n /* Return the number of trees encoded in ENCODER. */\n-static inline unsigned int\n+inline unsigned int\n lto_tree_ref_encoder_size (struct lto_tree_ref_encoder *encoder)\n {\n   return encoder->trees.length ();\n }\n \n /* Return the IDX-th tree in ENCODER. */\n-static inline tree\n+inline tree\n lto_tree_ref_encoder_get_tree (struct lto_tree_ref_encoder *encoder,\n \t\t\t       unsigned int idx)\n {\n   return encoder->trees[idx];\n }\n \n /* Return number of encoded nodes in ENCODER.  */\n-static inline int\n+inline int\n lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n {\n   return encoder->nodes.length ();\n@@ -1093,7 +1093,7 @@ lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n /* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n    or LCC_NOT_FOUND if it is not there.  */\n \n-static inline int\n+inline int\n lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n \t\t\t   symtab_node *node)\n {\n@@ -1102,43 +1102,43 @@ lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n }\n \n /* Return true if iterator LSE points to nothing.  */\n-static inline bool\n+inline bool\n lsei_end_p (lto_symtab_encoder_iterator lsei)\n {\n   return lsei.index >= (unsigned)lto_symtab_encoder_size (lsei.encoder);\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next (lto_symtab_encoder_iterator *lsei)\n {\n   lsei->index++;\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline symtab_node *\n+inline symtab_node *\n lsei_node (lto_symtab_encoder_iterator lsei)\n {\n   return lsei.encoder->nodes[lsei.index].node;\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline struct cgraph_node *\n+inline struct cgraph_node *\n lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n {\n   return dyn_cast<cgraph_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline varpool_node *\n+inline varpool_node *\n lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n {\n   return dyn_cast<varpool_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the cgraph node corresponding to REF using ENCODER.  */\n \n-static inline symtab_node *\n+inline symtab_node *\n lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n {\n   if (ref == LCC_NOT_FOUND)\n@@ -1148,7 +1148,7 @@ lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei;\n@@ -1159,7 +1159,7 @@ lsei_start (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1169,7 +1169,7 @@ lsei_next_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n@@ -1183,7 +1183,7 @@ lsei_start_in_partition (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1194,7 +1194,7 @@ lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n@@ -1209,7 +1209,7 @@ lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1220,7 +1220,7 @@ lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_variable_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);"}, {"sha": "fe8c5f6e80df43987dd652787a25dbd38fc5e2e4", "filename": "gcc/lto-wrapper.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flto-wrapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Flto-wrapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -335,6 +335,8 @@ merge_and_complain (vec<cl_decoded_option> &decoded_options,\n \n \tcase OPT_fopenmp:\n \tcase OPT_fopenacc:\n+\tcase OPT_fasynchronous_unwind_tables:\n+\tcase OPT_funwind_tables:\n \t  /* For selected options we can merge conservatively.  */\n \t  if (existing_opt == -1)\n \t    decoded_options.safe_push (*foption);\n@@ -737,6 +739,8 @@ append_compiler_options (obstack *argv_obstack, vec<cl_decoded_option> opts)\n \tcase OPT_fopenacc_dim_:\n \tcase OPT_foffload_abi_:\n \tcase OPT_fcf_protection_:\n+\tcase OPT_fasynchronous_unwind_tables:\n+\tcase OPT_funwind_tables:\n \tcase OPT_g:\n \tcase OPT_O:\n \tcase OPT_Ofast:"}, {"sha": "bbd15e27e6ea734f30eae897bdb8da36acba48e1", "filename": "gcc/m2/ChangeLog", "status": "modified", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FChangeLog?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -1,3 +1,391 @@\n+2023-02-06  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\tPR modula2/108135\n+\t* gm2-compiler/M2Search.mod (DSdbEnter): Comment out.\n+\t(DSdbExit): Comment out.\n+\n+2023-02-06  Co-Authored by: Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\tPR modula2/107234\n+\t* m2pp.cc (m2pp_integer_cst): Use\n+\tHOST_WIDE_INT_PRINT_UNSIGNED as the format specifier.\n+\n+2023-02-06  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-compiler/M2Preprocess.mod (BaseName): Comment out.\n+\t* gm2-lang.cc (opt): Remove.\n+\t* gm2spec.cc (add_include): Remove.\n+\t(full_libraries): Remove.\n+\t(concat_option): Remove.\n+\n+2023-02-03  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* Make-lang.in (TEXISRC): Remove m2/images/gnu.eps.\n+\t(RSTSRC): Remove m2/images/gnu.eps.\n+\t(doc/m2.dvi): Add $(objdir)/m2/images/gnu.eps.\n+\t(doc/m2.pdf): Add $(objdir)/m2/images/gnu.eps.\n+\t(M2_PDFFILES): New definition.\n+\t(m2.install-pdf): New rule.\n+\t(m2.pod): Add $(objdir)/m2/images/gnu.eps.\n+\t(m2.info): Add $(objdir)/m2/images/gnu.eps.\n+\t(m2.html): New rule.\n+\t(m2/gpl_v3_without_node.texi): New rule.\n+\t(plugin/m2rte$(soext)): Simplify mkinstalldirs.\n+\t(cc1gm2$(exeext)): Ditto.\n+\t(m2/stage1/cc1gm2$(exeext)): Ditto.\n+\t(m2/gm2-gcc/%.o): Ditto.\n+\t(m2/gm2-gcc/rtegraph.o): Ditto.\n+\t(m2/gm2-gcc/$(SRC_PREFIX)%.h): Ditto.\n+\t(m2/mc-boot/$(SRC_PREFIX)%.o):Ditto.\n+\t(m2/mc-boot-ch/$(SRC_PREFIX)%.o): Ditto.\n+\t(m2/mc-boot/main.o): Ditto.\n+\t(m2/gm2-libs-boot/%.o):\tDitto.\n+\t(m2/gm2-libs-boot/$(SRC_PREFIX)%.h): Ditto.\n+\t(m2/gm2-libs-boot/RTcodummy.o): Ditto.\n+\t(m2/gm2-libs-boot/wrapc.o): Ditto.\n+\t(m2/gm2-libs-boot/M2LINK.o): Ditto.\n+\t(m2/gm2-libs-boot/UnixArgs.o): Ditto.\n+\t(m2/gm2-libs-boot/choosetemp.o): Ditto.\n+\t(m2/gm2-libs-boot/errno.o): Ditto.\n+\t(m2/gm2-libs-boot/dtoa.o): Ditto.\n+\t(m2/gm2-libs-boot/ldtoa.o): Ditto.\n+\t(m2/gm2-libs-boot/termios.o): Ditto.\n+\t(m2/gm2-libs-boot/SysExceptions.o): Ditto.\n+\t(m2/gm2-libs-boot/SysStorage.o): Ditto.\n+\t(m2/gm2-compiler-boot/M2GCCDeclare.o): Ditto.\n+\t(m2/gm2-compiler-boot/M2Error.o): Ditto.\n+\t(m2/gm2-compiler-boot/%.o): Ditto.\n+\t(m2/gm2-compiler-boot/$(SRC_PREFIX)%.h): Ditto.\n+\t(m2/gm2-compiler-boot/m2flex.o): Ditto.\n+\t(m2/gm2-compiler/m2flex.c): Ditto.\n+\t(m2/gm2-libiberty/$(SRC_PREFIX)%.h): Ditto.\n+\t(m2/gm2-compiler/%.o): Ditto.\n+\t(m2/gm2-compiler/m2flex.o): Ditto.\n+\t(m2/gm2-compiler/%.o): Ditto.\n+\t(m2/gm2-libs-iso/%.o): Ditto.\n+\t(m2/gm2-libs/gm2-libs-host.h): Ditto.\n+\t($(objdir)/m2/gm2-libs-min/SYSTEM.def): Ditto.\n+\t($(objdir)/m2/gm2-libs/SYSTEM.def): Ditto.\n+\t($(objdir)/m2/gm2-libs-iso/SYSTEM.def):\tDitto.\n+\t($(objdir)/m2/gm2-libs-coroutines/SYSTEM.def): Ditto.\n+\t(m2/gm2-compiler/gm2.a): Ditto.\n+\t(m2/gm2-libs-boot/libgm2.a): Ditto.\n+\t(m2/gm2-compiler-boot/gm2.a): Ditto.\n+\t(m2/boot-bin/mklink$(exeext)): Ditto.\n+\t(m2/gm2-compiler-boot/$(SRC_PREFIX)%.h): Ditto.\n+\t(m2/gm2-compiler/%.mod): Ditto.\n+\t(m2/gm2-compiler-boot/%.mod): Ditto.\n+\t(m2/pge-boot/%.o): Ditto.\n+\n+2023-02-01  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* Make-lang.in (GM2_FLAGS): Add -fno-return -Wreturn-type.\n+\t(GM2_ISO_FLAGS): Add -fno-return -Wreturn-type.\n+\t* Make-maintainer.in (GM2PATH): Split into separate -I components.\n+\t(MC-LIB-DEFS): Add RTentity.def.\n+\t(m2/boot-bin/mc-devel$(exeext)): Changed -I$(GM2PATH) to\n+\t$(GM2PATH).\n+\t(m2/boot-bin/mc-opt$(exeext)): Separate -I paths.\n+\t(m2/mc/decl.o): Separate -I paths.\n+\t(gm2-bootstrap): Separate -I paths.\n+\t(m2/mc-boot-gen/$(SRC_PREFIX)%.h): Separate -I paths.\n+\t(m2/mc-boot-gen/$(SRC_PREFIX)decl.c): Separate -I paths.\n+\t(m2/mc-boot-gen/$(SRC_PREFIX)%.c): Separate -I paths.\n+\t(gm2.verifyparanoid): Separate -I paths.\n+\t(gm2.verifystage12): Separate -I paths.\n+\t* gm2-compiler/M2ALU.mod (GetConstructorElement): Add default\n+\tReturn NulSym.  Remove return from the error case.\n+\t* gm2-compiler/M2Base.mod (ComplexToScalar): Return RType\n+\tfrom the error case.\n+\t(MixMetaTypes):  Return MakeError as a default.\n+\t* gm2-compiler/M2GCCDeclare.mod (GetTypeMin): Return NulSym\n+\tfrom the error case.\n+\t(GetTypeMax): Return NulSym from the error case.\n+\t* gm2-compiler/M2GenGCC.mod (IsExportedGcc): Replace Assert\n+\tby InternalError.\n+\t* gm2-compiler/M2Quads.mod (GetItemPointedTo): Add InternalError.\n+\t(GetTypeMin): Add InternalError.\n+\t(GetTypeMax): Add InternalError.\n+\t* gm2-compiler/M2System.mod (InitSystem): Call\n+\tPutProcedureNoReturn on Throw.\n+\t* gm2-gcc/m2except.cc (m2except_InitExceptions): fn_throw_tree\n+\tdeclare as noreturn.  fn_rethrow_tree declare as noreturn.\n+\t* gm2-libs-coroutines/Debug.def (Halt): Add noreturn attribute.\n+\t* gm2-libs-coroutines/SYSTEM.def (THROW): Add noreturn attribute.\n+\t* gm2-libs-iso/ClientSocket.mod (dorbytes): Add return FALSE.\n+\t* gm2-libs-iso/EXCEPTIONS.def (RAISE): Add noreturn attribute.\n+\t* gm2-libs-iso/IOLink.def (RAISEdevException): Add noreturn attribute.\n+\t* gm2-libs-iso/M2RTS.def (HALT): Add noreturn attribute.\n+\t(Halt): Ditto.\n+\t(HaltC): Ditto.\n+\t(ErrorMessage): Ditto.\n+\t(AssignmentException): Ditto.\n+\t(ReturnException): Ditto.\n+\t(IncException): Ditto.\n+\t(DecException): Ditto.\n+\t(InclException): Ditto.\n+\t(ExclException): Ditto.\n+\t(ShiftException): Ditto.\n+\t(RotateException): Ditto.\n+\t(StaticArraySubscriptException): Ditto.\n+\t(DynamicArraySubscriptException): Ditto.\n+\t(ForLoopBeginException): Ditto.\n+\t(ForLoopToException): Ditto.\n+\t(ForLoopEndException): Ditto.\n+\t(PointerNilException): Ditto.\n+\t(NoReturnException): Ditto.\n+\t(CaseException): Ditto.\n+\t(WholeNonPosDivException): Ditto.\n+\t(WholeNonPosModException): Ditto.\n+\t(WholeZeroDivException): Ditto.\n+\t(WholeZeroRemException): Ditto.\n+\t(WholeValueException): Ditto.\n+\t(RealValueException): Ditto.\n+\t(ParameterException): Ditto.\n+\t(NoException): Ditto.\n+\t* gm2-libs-iso/SYSTEM.def (THROW): Ditto.\n+\t* gm2-libs-iso/TermFile.mod (dorbytes): Add default return FALSE.\n+\t* gm2-libs-min/M2RTS.def: Add noreturn attribute.\n+\t* gm2-libs/FIO.mod (BufferedRead): Return -1.\n+\t(getFileName): Return NIL.\n+\t(getFileNameLength): Return 0.\n+\t* gm2-libs/M2RTS.def (HaltC): Add noreturn attribute.\n+\t(AssignmentException): Ditto.\n+\t(ReturnException): Ditto.\n+\t(IncException): Ditto.\n+\t(DecException): Ditto.\n+\t(InclException): Ditto.\n+\t(ExclException): Ditto.\n+\t(ShiftException): Ditto.\n+\t(RotateException): Ditto.\n+\t(StaticArraySubscriptException): Ditto.\n+\t(DynamicArraySubscriptException): Ditto.\n+\t(ForLoopBeginException): Ditto.\n+\t(ForLoopToException): Ditto.\n+\t(ForLoopEndException): Ditto.\n+\t(PointerNilException): Ditto.\n+\t(NoReturnException): Ditto.\n+\t(CaseException): Ditto.\n+\t(WholeNonPosDivException): Ditto.\n+\t(WholeNonPosModException): Ditto.\n+\t(WholeZeroDivException): Ditto.\n+\t(WholeZeroRemException): Ditto.\n+\t(WholeValueException): Ditto.\n+\t(RealValueException): Ditto.\n+\t(ParameterException): Ditto.\n+\t(NoException): Ditto.\n+\t* gm2-libs/RTExceptions.def (Raise): Ditto.\n+\t* gm2-libs/RTExceptions.mod (InvokeHandler): Ditto.\n+\t* gm2-libs/SYSTEM.def (THROW): Ditto.\n+\t* m2.flex (_M2_m2flex_fini): Remamed to...\n+\t(_M2_m2flex_finish): ...here.\n+\t* mc-boot-ch/GBuiltins.c (_M2_Builtins_finish): Remamed to...\n+\t(_M2_Builtins_fini): ...this.\n+\t* mc-boot-ch/GRTco.c (_M2_RTco_finish): Remamed to...\n+\t(_M2_RTco_fini): ...this.\n+\t* mc-boot-ch/GSYSTEM.c (_M2_SYSTEM_finish): Remamed to...\n+\t(_M2_SYSTEM_fini): ...this.\n+\t* mc-boot-ch/GSelective.c (_M2_Selective_finish): Remamed to...\n+\t(_M2_Selective_fini): ...this.\n+\t* mc-boot-ch/GSysExceptions.c (_M2_SysExceptions_init): Add\n+\tparameters.\n+\t(_M2_SysExceptions_finish): Remamed to...\n+\t(_M2_SysExceptions_fini): ...this.\n+\t* mc-boot-ch/GUnixArgs.cc (_M2_UnixArgs_finish): Remamed to...\n+\t(_M2_UnixArgs_fini): ...this.\n+\t(_M2_UnixArgs_ctor::_M2_UnixArgs_ctor): Change parameter\n+\tto _M2_UnixArgs_fini.\n+\t* mc-boot-ch/Gdtoa.c (_M2_dtoa_finish): Remamed to...\n+\t(_M2_dtoa_fini): ...this.\n+\t* mc-boot-ch/Gerrno.c (_M2_errno_finish): Remamed to...\n+\t(_M2_errno_fini): ...this.\n+\t* mc-boot-ch/Gldtoa.c (_M2_ldtoa_finish): Remamed to...\n+\t(_M2_ldtoa_fini): ...this.\n+\t* mc-boot-ch/Gtermios.cc (_M2_termios_init): Add parameters.\n+\t(_M2_termios_finish): Remamed to...\n+\t(_M2_termios_fini): ...this.\n+\t* mc-boot-ch/Gwrapc.c (_M2_wrapc_init): Add parameters.\n+\t(_M2_wrapc_finish): Remamed to...\n+\t(_M2_wrapc_fini): ...this.\n+\t* mc-boot/GASCII.c: Rebuild.\n+\t* mc-boot/GArgs.c: Rebuild.\n+\t* mc-boot/GAssertion.c: Rebuild.\n+\t* mc-boot/GBreak.c: Rebuild.\n+\t* mc-boot/GCmdArgs.c: Rebuild.\n+\t* mc-boot/GDebug.c: Rebuild.\n+\t* mc-boot/GDynamicStrings.c: Rebuild.\n+\t* mc-boot/GEnvironment.c: Rebuild.\n+\t* mc-boot/GFIO.c: Rebuild.\n+\t* mc-boot/GFormatStrings.c: Rebuild.\n+\t* mc-boot/GFpuIO.c: Rebuild.\n+\t* mc-boot/GIO.c: Rebuild.\n+\t* mc-boot/GIndexing.c: Rebuild.\n+\t* mc-boot/GM2Dependent.c: Rebuild.\n+\t* mc-boot/GM2EXCEPTION.c: Rebuild.\n+\t* mc-boot/GM2RTS.c: Rebuild.\n+\t* mc-boot/GM2RTS.h: Rebuild.\n+\t* mc-boot/GMemUtils.c: Rebuild.\n+\t* mc-boot/GNumberIO.c: Rebuild.\n+\t* mc-boot/GPushBackInput.c: Rebuild.\n+\t* mc-boot/GRTExceptions.c: Rebuild.\n+\t* mc-boot/GRTExceptions.h: Rebuild.\n+\t* mc-boot/GRTco.h: Rebuild.\n+\t* mc-boot/GRTint.c: Rebuild.\n+\t* mc-boot/GSArgs.c: Rebuild.\n+\t* mc-boot/GSFIO.c: Rebuild.\n+\t* mc-boot/GStdIO.c: Rebuild.\n+\t* mc-boot/GStorage.c: Rebuild.\n+\t* mc-boot/GStrCase.c: Rebuild.\n+\t* mc-boot/GStrIO.c: Rebuild.\n+\t* mc-boot/GStrLib.c: Rebuild.\n+\t* mc-boot/GStringConvert.c: Rebuild.\n+\t* mc-boot/GSysStorage.c: Rebuild.\n+\t* mc-boot/GTimeString.c: Rebuild.\n+\t* mc-boot/Galists.c: Rebuild.\n+\t* mc-boot/Gdecl.c: Rebuild.\n+\t* mc-boot/Gkeyc.c: Rebuild.\n+\t* mc-boot/Glists.c: Rebuild.\n+\t* mc-boot/GmcComment.c: Rebuild.\n+\t* mc-boot/GmcComp.c: Rebuild.\n+\t* mc-boot/GmcDebug.c: Rebuild.\n+\t* mc-boot/GmcError.c: Rebuild.\n+\t* mc-boot/GmcFileName.c: Rebuild.\n+\t* mc-boot/GmcLexBuf.c: Rebuild.\n+\t* mc-boot/GmcMetaError.c: Rebuild.\n+\t* mc-boot/GmcOptions.c: Rebuild.\n+\t* mc-boot/GmcPreprocess.c: Rebuild.\n+\t* mc-boot/GmcPretty.c: Rebuild.\n+\t* mc-boot/GmcPrintf.c: Rebuild.\n+\t* mc-boot/GmcQuiet.c: Rebuild.\n+\t* mc-boot/GmcReserved.c: Rebuild.\n+\t* mc-boot/GmcSearch.c: Rebuild.\n+\t* mc-boot/GmcStack.c: Rebuild.\n+\t* mc-boot/GmcStream.c: Rebuild.\n+\t* mc-boot/Gmcp1.c: Rebuild.\n+\t* mc-boot/Gmcp2.c: Rebuild.\n+\t* mc-boot/Gmcp3.c: Rebuild.\n+\t* mc-boot/Gmcp4.c: Rebuild.\n+\t* mc-boot/Gmcp5.c: Rebuild.\n+\t* mc-boot/GnameKey.c: Rebuild.\n+\t* mc-boot/GsymbolKey.c: Rebuild.\n+\t* mc-boot/Gtop.c: Rebuild.\n+\t* mc-boot/Gvarargs.c: Rebuild.\n+\t* mc-boot/Gwlists.c: Rebuild.\n+\t* mc-boot/GRTentity.h: New file.\n+\t* mc/decl.mod (scaffoldStatic): Change _finish to _fini.\n+\t* mc/mc.flex (_M2_mcflex_fini): New function.\n+\t(_M2_mcflex_finish): Remove function.\n+\t* tools-src/mklink.c (GenerateFinishCalls): Change\n+\t_finish to _fini.\n+\t(GeneratePrototypes): Change _finish to _fini.\n+\n+2023-01-31  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* Make-lang.in (gm2-libs.texi-check): Rename\n+\tm2/gm2-libs-pim\tto m2/gm2-libs-log.\n+\t* gm2-libs-pim/BitBlockOps.def: Moved to...\n+\t* gm2-libs-log/BitBlockOps.def: ...here.\n+\t* gm2-libs-pim/BitBlockOps.mod: Moved to...\n+\t* gm2-libs-log/BitBlockOps.mod: ...here.\n+\t* gm2-libs-pim/BitByteOps.def: Moved to...\n+\t* gm2-libs-log/BitByteOps.def: ...here.\n+\t* gm2-libs-pim/BitByteOps.mod: Moved to...\n+\t* gm2-libs-log/BitByteOps.mod: ...here.\n+\t* gm2-libs-pim/BitWordOps.def: Moved to...\n+\t* gm2-libs-log/BitWordOps.def: ...here.\n+\t* gm2-libs-pim/BitWordOps.mod: Moved to...\n+\t* gm2-libs-log/BitWordOps.mod: ...here.\n+\t* gm2-libs-pim/BlockOps.def: Moved to...\n+\t* gm2-libs-log/BlockOps.def: ...here.\n+\t* gm2-libs-pim/BlockOps.mod: Moved to...\n+\t* gm2-libs-log/BlockOps.mod: ...here.\n+\t* gm2-libs-pim/Break.c: Moved to...\n+\t* gm2-libs-log/Break.c: ...here.\n+\t* gm2-libs-pim/Break.def: Moved to...\n+\t* gm2-libs-log/Break.def: ...here.\n+\t* gm2-libs-pim/CardinalIO.def: Moved to...\n+\t* gm2-libs-log/CardinalIO.def: ...here.\n+\t* gm2-libs-pim/CardinalIO.mod: Moved to...\n+\t* gm2-libs-log/CardinalIO.mod: ...here.\n+\t* gm2-libs-pim/Conversions.def: Moved to...\n+\t* gm2-libs-log/Conversions.def: ...here.\n+\t* gm2-libs-pim/Conversions.mod: Moved to...\n+\t* gm2-libs-log/Conversions.mod: ...here.\n+\t* gm2-libs-pim/DebugPMD.def: Moved to...\n+\t* gm2-libs-log/DebugPMD.def: ...here.\n+\t* gm2-libs-pim/DebugPMD.mod: Moved to...\n+\t* gm2-libs-log/DebugPMD.mod: ...here.\n+\t* gm2-libs-pim/DebugTrace.def: Moved to...\n+\t* gm2-libs-log/DebugTrace.def: ...here.\n+\t* gm2-libs-pim/DebugTrace.mod: Moved to...\n+\t* gm2-libs-log/DebugTrace.mod: ...here.\n+\t* gm2-libs-pim/Delay.def: Moved to...\n+\t* gm2-libs-log/Delay.def: ...here.\n+\t* gm2-libs-pim/Delay.mod: Moved to...\n+\t* gm2-libs-log/Delay.mod: ...here.\n+\t* gm2-libs-pim/Display.def: Moved to...\n+\t* gm2-libs-log/Display.def: ...here.\n+\t* gm2-libs-pim/Display.mod: Moved to...\n+\t* gm2-libs-log/Display.mod: ...here.\n+\t* gm2-libs-pim/ErrorCode.def: Moved to...\n+\t* gm2-libs-log/ErrorCode.def: ...here.\n+\t* gm2-libs-pim/ErrorCode.mod: Moved to...\n+\t* gm2-libs-log/ErrorCode.mod: ...here.\n+\t* gm2-libs-pim/FileSystem.def: Moved to...\n+\t* gm2-libs-log/FileSystem.def: ...here.\n+\t* gm2-libs-pim/FileSystem.mod: Moved to...\n+\t* gm2-libs-log/FileSystem.mod: ...here.\n+\t* gm2-libs-pim/FloatingUtilities.def: Moved to...\n+\t* gm2-libs-log/FloatingUtilities.def: ...here.\n+\t* gm2-libs-pim/FloatingUtilities.mod: Moved to...\n+\t* gm2-libs-log/FloatingUtilities.mod: ...here.\n+\t* gm2-libs-pim/InOut.def: Moved to...\n+\t* gm2-libs-log/InOut.def: ...here.\n+\t* gm2-libs-pim/InOut.mod: Moved to...\n+\t* gm2-libs-log/InOut.mod: ...here.\n+\t* gm2-libs-pim/Keyboard.def: Moved to...\n+\t* gm2-libs-log/Keyboard.def: ...here.\n+\t* gm2-libs-pim/Keyboard.mod: Moved to...\n+\t* gm2-libs-log/Keyboard.mod: ...here.\n+\t* gm2-libs-pim/LongIO.def: Moved to...\n+\t* gm2-libs-log/LongIO.def: ...here.\n+\t* gm2-libs-pim/LongIO.mod: Moved to...\n+\t* gm2-libs-log/LongIO.mod: ...here.\n+\t* gm2-libs-pim/NumberConversion.def: Moved to...\n+\t* gm2-libs-log/NumberConversion.def: ...here.\n+\t* gm2-libs-pim/NumberConversion.mod: Moved to...\n+\t* gm2-libs-log/NumberConversion.mod: ...here.\n+\t* gm2-libs-pim/README.texi: Moved to...\n+\t* gm2-libs-log/README.texi: ...here.\n+\t* gm2-libs-pim/Random.def: Moved to...\n+\t* gm2-libs-log/Random.def: ...here.\n+\t* gm2-libs-pim/Random.mod: Moved to...\n+\t* gm2-libs-log/Random.mod: ...here.\n+\t* gm2-libs-pim/RealConversions.def: Moved to...\n+\t* gm2-libs-log/RealConversions.def: ...here.\n+\t* gm2-libs-pim/RealConversions.mod: Moved to...\n+\t* gm2-libs-log/RealConversions.mod: ...here.\n+\t* gm2-libs-pim/RealInOut.def: Moved to...\n+\t* gm2-libs-log/RealInOut.def: ...here.\n+\t* gm2-libs-pim/RealInOut.mod: Moved to...\n+\t* gm2-libs-log/RealInOut.mod: ...here.\n+\t* gm2-libs-pim/Strings.def: Moved to...\n+\t* gm2-libs-log/Strings.def: ...here.\n+\t* gm2-libs-pim/Strings.mod: Moved to...\n+\t* gm2-libs-log/Strings.mod: ...here.\n+\t* gm2-libs-pim/Termbase.def: Moved to...\n+\t* gm2-libs-log/Termbase.def: ...here.\n+\t* gm2-libs-pim/Termbase.mod: Moved to...\n+\t* gm2-libs-log/Termbase.mod: ...here.\n+\t* gm2-libs-pim/Terminal.def: Moved to...\n+\t* gm2-libs-log/Terminal.def: ...here.\n+\t* gm2-libs-pim/Terminal.mod: Moved to...\n+\t* gm2-libs-log/Terminal.mod: ...here.\n+\t* gm2-libs-pim/TimeDate.def: Moved to...\n+\t* gm2-libs-log/TimeDate.def: ...here.\n+\t* gm2-libs-pim/TimeDate.mod: Moved to...\n+\t* gm2-libs-log/TimeDate.mod: ...here.\n+\n 2023-01-28  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* lang.opt: Claim Wreturn-type."}, {"sha": "d1d02a0d78e0b0977acdcb45e49a9b885fb84927", "filename": "gcc/m2/Make-lang.in", "status": "modified", "additions": 92, "deletions": 67, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FMake-lang.in?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -41,16 +41,15 @@ else\n   PLUGINLDFLAGS += -nodefaultlibs\n endif\n \n-TEXISRC = $(objdir)/m2/images/gnu.eps \\\n-          $(srcdir)/doc/gm2.texi \\\n+TEXISRC = $(srcdir)/doc/gm2.texi \\\n           m2/gm2-libs.texi \\\n           m2/gm2-ebnf.texi \\\n           m2/SYSTEM-pim.texi \\\n           m2/SYSTEM-iso.texi \\\n-          m2/Builtins.texi\n+          m2/Builtins.texi \\\n+          m2/gpl_v3_without_node.texi\n \n-RSTSRC = $(objdir)/m2/images/gnu.eps \\\n-          $(srcdir)/doc/gm2.texi \\\n+RSTSRC =  $(srcdir)/doc/gm2.texi \\\n           m2/gm2-libs.rst \\\n           m2/gm2-ebnf.rst \\\n           m2/SYSTEM-pim.rst \\\n@@ -142,43 +141,62 @@ $(DESTDIR)$(man1dir)/$(GM2_INSTALL_NAME)$(man1ext): doc/m2.1 installdirs\n \n m2.dvi: doc/m2.dvi\n \n-doc/m2.dvi: $(TEXISRC)\n+doc/m2.dvi: $(TEXISRC) $(objdir)/m2/images/gnu.eps\n \t$(TEXI2DVI) -c -I $(objdir)/m2 -I $(srcdir)/doc/include -o $@ $(srcdir)/doc/gm2.texi\n \n doc/m2.ps: doc/m2.dvi\n \tdvips -o $@ $<\n \n m2.pdf: doc/m2.pdf\n \n-doc/m2.pdf: $(TEXISRC)\n+doc/m2.pdf: $(TEXISRC) $(objdir)/m2/images/gnu.eps\n \t$(TEXI2PDF) -I $(objdir)/m2 -I $(srcdir)/doc/include $(srcdir)/doc/gm2.texi -o $@\n \n+M2_PDFFILES = doc/m2.pdf\n+\n+m2.install-pdf: $(M2_PDFFILES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)/gcc\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@list='$(M2_PDFFILES)'; for p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n .INTERMEDIATE: m2.pod\n \n-m2.pod: $(TEXISRC)\n+m2.pod: $(TEXISRC) $(objdir)/m2/images/gnu.eps\n \t-$(TEXI2POD) -I $(objdir)/m2 -D m2 < $< > $@\n \n-doc/m2.info: $(TEXISRC)\n+doc/m2.info: $(TEXISRC) $(objdir)/m2/images/gnu.eps\n \tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n \t  rm -f doc/m2.info*; \\\n           $(MAKEINFO) -I$(objdir)/m2 -I$(srcdir)/doc/include \\\n                       -o $@ $(srcdir)/doc/gm2.texi ; \\\n \telse true; fi\n \n $(objdir)/m2/images/gnu.eps: $(srcdir)/m2/images/gnupng\n-\t-test -d m2/images || $(mkinstalldirs) m2/images\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \tcp $(srcdir)/m2/images/gnu.eps $@\n \n+m2.html: $(build_htmldir)/m2/index.html\n+\n+$(build_htmldir)/m2/index.html: $(TEXISRC) $(objdir)/m2/images/gnu.eps\n+\t$(mkinstalldirs) $(@D)\n+\trm -f $(@D)/*\n+\t$(TEXI2HTML) -I $(objdir)/m2 -I $(srcdir)/m2 -I $(gcc_docdir)/include -o $(@D) $<\n+\n # gm2-libs.texi\n \n m2/gm2-libs.texi: gm2-libs.texi-check; @true\n \n ifeq ($(HAVE_PYTHON),yes)\n gm2-libs.texi-check: m2/SYSTEM-pim.texi m2/SYSTEM-iso.texi m2/Builtins.texi \\\n                      $(objdir)/m2/gm2-libs-coroutines/SYSTEM.def\n-\ttest -d m2/gm2-libs-log || $(mkinstalldirs) m2/gm2-libs-log\n-\ttest -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n-\ttest -d m2/gm2-libs || $(mkinstalldirs) m2/gm2-libs\n+\t-test -d m2/gm2-libs-log || $(mkinstalldirs) m2/gm2-libs-log\n+\t-test -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n+\t-test -d m2/gm2-libs || $(mkinstalldirs) m2/gm2-libs\n \t$(PYTHON) $(srcdir)/m2/tools-src/def2doc.py -t -uLibraries -s$(srcdir)/m2 -b$(objdir)/m2 -o $(objdir)/m2/gm2-libs.texi\n else\n gm2-libs.texi-check:\n@@ -295,6 +313,9 @@ Builtins.rst-check:  m2/gm2-libs/Builtins.def\n endif\n \t$(STAMP) Builtins.rst-check\n \n+m2/gpl_v3_without_node.texi: doc/include/gpl_v3.texi\n+\tgrep -v \"^@node\" $< > $@\n+\n # Stage hooks:\n # The toplevel makefile has already created stage?/m2 at this point.\n \n@@ -388,7 +409,7 @@ override PLUGINCFLAGS := $(filter-out -mdynamic-no-pic,$(PLUGINCFLAGS))\n \n plugin/m2rte$(soext): $(srcdir)/m2/plugin/m2rte.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2) \\\n         insn-attr-common.h insn-flags.h $(generated_files)\n-\t-test -d plugin || $(mkinstalldirs) plugin\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(PLUGINCC) $(PLUGINCFLAGS) -fno-rtti -I. -I$(srcdir) $(INCINTL) -I$(srcdir)/m2 -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/../include -I$(srcdir)/../libcpp/include -Wall $(GMPINC) -Wno-literal-suffix -fPIC -c -o plugin/m2rte.o $(srcdir)/m2/plugin/m2rte.cc\n \t$(PLUGINCC) $(PLUGINCFLAGS) $(PLUGINLDFLAGS) $(PLUGINLIBS) $(LIBINTL) -fno-rtti plugin/m2rte.o -shared -o $@\n \n@@ -441,11 +462,14 @@ GM2_G=-g -fm2-g\n GM2_CPP=\n # GM2_DEBUG_STRMEM=-fcpp\n GM2_DEBUG_STRMEM=\n-GM2_FLAGS=-Wunused-variable -fsoft-check-all $(GM2_G) $(GM2_O) \\\n+GM2_FLAGS=-Wunused-variable -fsoft-check-all \\\n+ -fno-return -Wreturn-type \\\n+ $(GM2_G) $(GM2_O) \\\n  -funbounded-by-reference -fpim -fextended-opaque \\\n  -Wpedantic-cast -Wpedantic-param-names -ffunction-sections \\\n  -fdata-sections $(GM2_CPP) # -fauto-init\n GM2_ISO_FLAGS=-fsoft-check-all $(GM2_G) $(GM2_O) \\\n+ -fno-return -Wreturn-type \\\n  -funbounded-by-reference -fiso -fextended-opaque \\\n  -Wpedantic-cast -Wpedantic-param-names -ffunction-sections \\\n  -fdata-sections $(GM2_CPP)\n@@ -493,7 +517,7 @@ cc1gm2$(exeext): m2/stage1/cc1gm2$(exeext) $(m2.prev)\n m2/stage2/cc1gm2$(exeext): m2/stage1/cc1gm2$(exeext) m2/gm2-compiler/m2flex.o $(P) \\\n                             $(GM2_C_OBJS) $(BACKEND) $(LIBDEPS) $(GM2_LIBS) \\\n                             m2/gm2-gcc/rtegraph.o plugin/m2rte$(soext) m2/gm2-libs-boot/M2LINK.o\n-\t-test -d m2/stage2 || $(mkinstalldirs) m2/stage2\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t@$(call LINK_PROGRESS,$(INDEX.m2),start)\n \t+$(LLINKER) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GM2_C_OBJS) m2/gm2-compiler/m2flex.o \\\n                             attribs.o \\\n@@ -508,7 +532,7 @@ m2/stage1/cc1gm2$(exeext): gm2$(exeext) m2/gm2-compiler-boot/m2flex.o \\\n                             m2/gm2-gcc/rtegraph.o plugin/m2rte$(soext) \\\n                             m2/gm2-libs-boot/M2LINK.o \\\n                             $(m2.prev)\n-\t-test -d m2/stage1 || $(mkinstalldirs) m2/stage1\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t@$(call LINK_PROGRESS,$(INDEX.m2),start)\n \t+$(LLINKER) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GM2_C_OBJS) m2/gm2-compiler-boot/m2flex.o \\\n                             attribs.o \\\n@@ -526,15 +550,15 @@ GCC_HEADER_DEPENDENCIES_FOR_M2 = $(BUILD-BOOT-H) $(TIMEVAR_H) m2/gm2config.h $(C\n         $(generated_files) insn-attr-common.h\n \n m2/gm2-gcc/%.o: $(srcdir)/m2/gm2-gcc/%.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2)\n-\t-test -d m2/gm2-gcc || $(mkinstalldirs) m2/gm2-gcc\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(COMPILER) -c -g $(ALL_COMPILERFLAGS) \\\n              $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n m2/gm2-gcc/m2configure.o: $(srcdir)/m2/gm2-gcc/m2configure.cc \\\n                $(SYSTEM_H) $(GCC_H) $(CONFIG_H) \\\n                m2/gm2config.h $(TARGET_H) $(PLUGIN_HEADERS) \\\n                $(generated_files) $(C_TREE_H) insn-attr-common.h\n-\t-test -d m2/gm2-gcc || $(mkinstalldirs) m2/gm2-gcc\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n          $(DRIVER_DEFINES) \\\n \t\t-DLIBSUBDIR=\\\"$(libsubdir)\\\" \\\n@@ -556,7 +580,7 @@ m2/m2pp.o : $(srcdir)/m2/m2pp.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2)\n \n m2/gm2-gcc/rtegraph.o: $(srcdir)/m2/gm2-gcc/rtegraph.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2) \\\n                        gt-m2-rtegraph.h\n-\t-test -d m2/gm2-gcc || $(mkinstalldirs) m2/gm2-gcc\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(COMPILER) -c -g $(GM2GCC) $(ALL_COMPILERFLAGS) \\\n             $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n@@ -565,7 +589,7 @@ c-family/m2pp.o : $(srcdir)/m2/m2pp.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2)\n             $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n m2/gm2-gcc/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-gcc/%.def $(MCDEPS)\n-\t-test -d m2/gm2-gcc || $(mkinstalldirs) m2/gm2-gcc\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=$@ $(srcdir)/m2/gm2-gcc/$*.def\n \n # The following tables define the source files which are translated into C using mc\n@@ -1138,6 +1162,7 @@ MC-LIB-DEFS = \\\n    PushBackInput.def \\\n    RTExceptions.def \\\n    RTco.def \\\n+   RTentity.def \\\n    RTint.def \\\n    SArgs.def \\\n    SFIO.def \\\n@@ -1322,19 +1347,19 @@ m2/boot-bin/mc$(exeext): $(BUILD-MC-BOOT-O) $(BUILD-MC-INTERFACE-O) \\\n          mcflex.o m2/gm2-libs-boot/RTcodummy.o -lm\n \n m2/mc-boot/$(SRC_PREFIX)%.o: m2/mc-boot/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/mc-boot || $(mkinstalldirs) m2/mc-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -g -c -I. -I$(srcdir)/m2/mc-boot-ch -I$(srcdir)/m2/mc-boot -I$(srcdir)/../include -I$(srcdir) $(INCLUDES) $< -o $@\n \n m2/mc-boot-ch/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/mc-boot-ch || $(mkinstalldirs) m2/mc-boot-ch\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -DHAVE_CONFIG_H -g -c -I. -Im2/gm2-libs -I$(srcdir)/../include -I$(srcdir) $(INCLUDES) -Im2/gm2-libs $< -o $@\n \n m2/mc-boot-ch/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.cc m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/mc-boot-ch || $(mkinstalldirs) m2/mc-boot-ch\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -DHAVE_CONFIG_H -g -c -I. -Im2/gm2-libs -I$(srcdir)/../include -I$(srcdir) $(INCLUDES) -Im2/gm2-libs $< -o $@\n \n m2/mc-boot/main.o: $(M2LINK) $(srcdir)/m2/init/mcinit\n-\t-test -d m2/mc-boot || $(mkinstalldirs) m2/mc-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \tunset CC ; $(M2LINK) -s --langc++ --exit --name m2/mc-boot/main.c $(srcdir)/m2/init/mcinit\n \t$(CXX) -g -c -I. -I$(srcdir)/../include -I$(srcdir) $(INCLUDES) m2/mc-boot/main.c -o $@\n \n@@ -1345,152 +1370,152 @@ mcflex.c: $(srcdir)/m2/mc/mc.flex\n \tflex -t $< > $@\n \n m2/gm2-libs-boot/%.o: $(srcdir)/m2/gm2-libs-boot/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=m2/gm2-libs-boot/$*.c $(srcdir)/m2/gm2-libs-boot/$*.mod\n \t$(COMPILER) -c -DIN_GCC $(CFLAGS) $(MCINCLUDES) m2/gm2-libs-boot/$*.c -o $@\n \n m2/gm2-libs-boot/%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=m2/gm2-libs-boot/$*.c $(srcdir)/m2/gm2-libs/$*.mod\n \t$(COMPILER) -c -DIN_GCC $(CFLAGS) -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(MCINCLUDES) $(INCLUDES) m2/gm2-libs-boot/$*.c -o $@\n \n m2/gm2-libs-boot/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs/%.def $(MCDEPS)\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=$@ $(srcdir)/m2/gm2-libs/$*.def\n \n m2/gm2-libs-boot/RTcodummy.o: $(srcdir)/m2/gm2-libs-ch/RTcodummy.c m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c -DIN_GCC $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/RTintdummy.o: $(srcdir)/m2/gm2-libs-ch/RTintdummy.c m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c -DIN_GCC $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/wrapc.o: $(srcdir)/m2/gm2-libs-ch/wrapc.c m2/gm2-libs-boot/$(SRC_PREFIX)wrapc.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c -DHAVE_CONFIG_H $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot -Im2/gm2-libs $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/M2LINK.o: $(srcdir)/m2/gm2-libs-ch/M2LINK.c m2/gm2-libs-boot/$(SRC_PREFIX)M2LINK.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c -DHAVE_CONFIG_H $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot -Im2/gm2-libs $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/UnixArgs.o: $(srcdir)/m2/gm2-libs-ch/UnixArgs.cc m2/gm2-libs-boot/$(SRC_PREFIX)UnixArgs.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c -DIN_GCC $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/choosetemp.o: m2/gm2-libs-ch/choosetemp.c m2/gm2-libiberty/Gchoosetemp.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot -Im2/gm2-libiberty -I$(srcdir)/m2/gm2-libiberty/ $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/errno.o: $(srcdir)/m2/gm2-libs-ch/errno.c m2/gm2-libs-boot/$(SRC_PREFIX)errno.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/dtoa.o: $(srcdir)/m2/gm2-libs-ch/dtoa.cc m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/ldtoa.o: $(srcdir)/m2/gm2-libs-ch/ldtoa.cc m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/termios.o: $(srcdir)/m2/gm2-libs-ch/termios.c $(BUILD-LIBS-BOOT-H) m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/SysExceptions.o: $(srcdir)/m2/gm2-libs-ch/SysExceptions.c \\\n                                   m2/gm2-libs-boot/$(SRC_PREFIX)SysExceptions.h m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-boot/SysStorage.o: $(srcdir)/m2/gm2-libs/SysStorage.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=m2/gm2-libs-boot/SysStorage.c $(srcdir)/m2/gm2-libs/SysStorage.mod\n \t$(COMPILER) -DIN_GCC -c $(CFLAGS) \\\n           -I$(srcdir)/m2 -Im2 -I. -Im2/gm2-libs-boot $(MCINCLUDES) $(INCLUDES) \\\n           m2/gm2-libs-boot/SysStorage.c -o m2/gm2-libs-boot/SysStorage.o\n \n m2/gm2-compiler-boot/M2GCCDeclare.o: $(srcdir)/m2/gm2-compiler/M2GCCDeclare.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) --extended-opaque -o=m2/gm2-compiler-boot/M2GCCDeclare.c $<\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(GM2GCC) \\\n             -I. -I$(srcdir)/../include -I$(srcdir) \\\n             -I. -Im2/gm2-libs-boot -Im2/gm2-compiler-boot \\\n             -I$(srcdir)/m2/gm2-libiberty $(MCINCLUDES) $(INCLUDES) m2/gm2-compiler-boot/M2GCCDeclare.c -o $@\n \n m2/gm2-compiler-boot/M2Error.o: $(srcdir)/m2/gm2-compiler/M2Error.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) --extended-opaque -o=m2/gm2-compiler-boot/M2Error.c $<\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(GM2GCC) \\\n             -I. -I$(srcdir)/../include -I$(srcdir) \\\n             -I. -Im2/gm2-libs-boot -Im2/gm2-compiler-boot \\\n             -I$(srcdir)/m2/gm2-libiberty $(MCINCLUDES) $(INCLUDES) m2/gm2-compiler-boot/M2Error.c -o $@\n \n m2/gm2-compiler-boot/%.o: $(srcdir)/m2/gm2-compiler/%.mod $(BUILD-BOOT-H) $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=m2/gm2-compiler-boot/$*.c $(srcdir)/m2/gm2-compiler/$*.mod\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(GM2GCC) \\\n             -I. -I$(srcdir)/../include -I$(srcdir) \\\n             -I. -Im2/gm2-libs-boot -Im2/gm2-compiler-boot -Im2/gm2-libiberty \\\n             -I$(srcdir)/m2/gm2-libiberty $(MCINCLUDES) $(INCLUDES) m2/gm2-compiler-boot/$*.c -o $@\n \n m2/gm2-compiler-boot/%.o: m2/gm2-compiler-boot/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=m2/gm2-compiler-boot/$*.c m2/gm2-compiler-boot/$*.mod\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(GM2GCC) \\\n             -I. -I$(srcdir)/../include -I$(srcdir) \\\n             -I. -Im2/gm2-libs-boot -Im2/gm2-compiler-boot \\\n             -I$(srcdir)/m2/gm2-libiberty $(MCINCLUDES) $(INCLUDES) m2/gm2-compiler-boot/$*.c -o $@\n \n m2/gm2-compiler-boot/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-compiler/%.def $(MCDEPS)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=$@ $(srcdir)/m2/gm2-compiler/$*.def\n \n m2/gm2-compiler-boot/m2flex.o: m2/gm2-compiler/m2flex.c $(BUILD-BOOT-H) $(TIMEVAR_H) \\\n         $(BUILD-LIBS-BOOT-H)  m2/gm2-compiler-boot/$(SRC_PREFIX)NameKey.h \\\n         $(CONFIG_H) m2/gm2config.h $(TARGET_H) $(PLUGIN_HEADERS)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(COMPILER) -c -g $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n           $(GM2GCC) $(INCLUDES) -I$(srcdir)/m2 \\\n           -Im2 -Im2/gm2-compiler-boot -Im2/gm2-libs-boot $< -o $@\n \n m2/gm2-compiler/m2flex.c: $(srcdir)/m2/m2.flex $(TIMEVAR_H) insn-attr-common.h\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \tflex -t $< | sed -e 's/ malloc/ xmalloc/' | sed -e 's/ realloc/ xrealloc/' > $@\n \n m2/gm2-libiberty/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libiberty/%.def $(MCDEPS)\n-\t-test -d m2/gm2-libiberty || $(mkinstalldirs) m2/gm2-libiberty\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) -o=$@ $(srcdir)/m2/gm2-libiberty/$*.def\n \n # The rules to build objects in gm2-compiler and gm2-libs directories.\n \n m2/gm2-compiler/%.o: $(srcdir)/m2/gm2-compiler/%.mod\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(GM2_1) $(GM2_FLAGS) -c -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $< -o $@\n \n m2/gm2-compiler/m2flex.o: m2/gm2-compiler/m2flex.c m2/gm2-libs/gm2-libs-host.h $(TIMEVAR_H)\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(COMPILER) -c -g $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n           $(GM2GCC) -Im2/gm2-compiler-boot -Im2/gm2-libs-boot $< -o $@\n \n m2/gm2-compiler/%.o: m2/gm2-compiler/%.mod\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(GM2_1) $(GM2_FLAGS) -c -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $< -o $@\n \n m2/gm2-libs-iso/%.o: $(srcdir)/m2/gm2-libs-iso/%.c m2/gm2-libs/gm2-libs-host.h\n-\t-test -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) -DBUILD_GM2_LIBS_TARGET -DBUILD_GM2_LIBS -c $(CFLAGS) -Im2/gm2-libs -I$(srcdir)/m2 -Im2/gm2-libs-boot $(INCLUDES) $< -o $@\n \n m2/gm2-libs-iso/%.o: $(srcdir)/m2/gm2-libs-iso/%.mod\n-\t-test -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(GM2_1) $(GM2_ISO_FLAGS) -c -B./ -Im2/gm2-libs-iso:$(srcdir)/m2/gm2-libs-iso -I$(srcdir)/m2/gm2-libs $< -o $@\n \n \n # We build the cc1gm2$(exeext) from the boot stage and then proceed to build it\n # again using itself.\n \n m2/gm2-libs/gm2-libs-host.h:\n-\t-test -d m2/gm2-libs || $(mkinstalldirs) m2/gm2-libs\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \techo \"Configuring to build libraries using native compiler\" ; \\\n         NEW_SRCDIR=`${srcdir}/m2/tools-src/calcpath ../../ ${srcdir} m2/gm2-libs` ; \\\n         export NEW_SRCDIR ; \\\n@@ -1525,15 +1550,15 @@ m2/gm2config.aci:\n         fi\n \n $(objdir)/m2/gm2-libs-min/SYSTEM.def: $(GM2_PROG_DEP)\n-\t-test -d m2/gm2-libs-min || $(mkinstalldirs) m2/gm2-libs-min\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fpim \\\n              $(srcdir)/m2/gm2-libs-min/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-min/SYSTEM.mod \\\n              -I$(srcdir)/m2/gm2-libs-min -I$(srcdir)/m2/gm2-libs \\\n              \"$(GM2_FOR_TARGET)\" $@\n \n $(objdir)/m2/gm2-libs/SYSTEM.def: $(GM2_PROG_DEP)\n-\t-test -d m2/gm2-libs || $(mkinstalldirs) m2/gm2-libs\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \techo \"GM2_FOR_TARGET $(GM2_FOR_TARGET)\"\n \techo \"GCC_FOR_TARGET $(GCC_FOR_TARGET)\"\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fpim \\\n@@ -1543,15 +1568,15 @@ $(objdir)/m2/gm2-libs/SYSTEM.def: $(GM2_PROG_DEP)\n              \"$(GM2_FOR_TARGET)\" $@\n \n $(objdir)/m2/gm2-libs-iso/SYSTEM.def: $(GM2_PROG_DEP)\n-\t-test -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fiso \\\n              $(srcdir)/m2/gm2-libs-iso/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-iso/SYSTEM.mod \\\n              -I$(srcdir)/m2/gm2-libs-iso -I$(srcdir)/m2/gm2-libs \\\n              \"$(GM2_FOR_TARGET)\" $@\n \n $(objdir)/m2/gm2-libs-coroutines/SYSTEM.def: $(GM2_PROG_DEP)\n-\t-test -d m2/gm2-libs-coroutines || $(mkinstalldirs) m2/gm2-libs-coroutines\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fpim \\\n              $(srcdir)/m2/gm2-libs-coroutines/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-coroutines/SYSTEM.mod \\\n@@ -1563,41 +1588,41 @@ build-compiler: $(GM2-COMP-MODS:%.mod=m2/gm2-compiler/%.o) \\\n                 m2/gm2-compiler/m2flex.o\n \n m2/gm2-compiler/gm2.a: build-compiler gm2$(exeext)\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(AR_FOR_TARGET) cr $@ $(GM2-COMP-MODS:%.mod=m2/gm2-compiler/%.o) \\\n                     $(GM2-AUTO-MODS:%.mod=m2/gm2-compiler/%.o)\n \t$(RANLIB) $@\n \n m2/gm2-libs-boot/libgm2.a: m2/boot-bin/mc$(exeext) $(BUILD-LIBS-BOOT)\n-\t-test -d m2/gm2-libs-boot || $(mkinstalldirs) m2/gm2-libs-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(AR) cr $@ $(GM2-LIBS-BOOT-MODS:%.mod=m2/gm2-libs-boot/%.o) \\\n                     $(GM2-LIBS-BOOT-CC:%.cc=m2/gm2-libs-boot/%.o) \\\n                     $(GM2-LIBS-BOOT-C:%.c=m2/gm2-libs-boot/%.o)\n \t$(RANLIB) $@\n \n m2/gm2-compiler-boot/gm2.a: m2/boot-bin/mc$(exeext) m2/boot-bin/mklink$(exeext) \\\n                          $(BUILD-LIBS-BOOT) $(BUILD-COMPILER-BOOT)\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(AR) cr $@ $(GM2-COMP-BOOT-MODS:%.mod=m2/gm2-compiler-boot/%.o) \\\n                     $(GM2-AUTO-MODS:%.mod=m2/gm2-compiler-boot/%.o)\n \t$(RANLIB) $@\n \n m2/gm2-compiler-boot/gm2.a: m2/boot-bin/mc$(exeext)\n \n m2/boot-bin/mklink$(exeext): $(srcdir)/m2/tools-src/mklink.c\n-\t-test -d m2/boot-bin || $(mkinstalldirs) m2/boot-bin\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) $(CFLAGS) -I$(srcdir)/m2 -Im2/gm2-libs-boot -Im2/gm2-compiler-boot -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) $< -o $@\n \n m2/gm2-compiler-boot/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-compiler-boot/%.def $(MCDEPS)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(MC) --quiet -o=$@ $(srcdir)/m2/gm2-compiler-boot/$*.def\n \n m2/gm2-compiler/%.mod: $(srcdir)/m2/gm2-compiler/%.bnf $(PGE)\n-\t-test -d m2/gm2-compiler || $(mkinstalldirs) m2/gm2-compiler\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(PGE) -k -l $< -o $@\n \n m2/gm2-compiler-boot/%.mod: $(srcdir)/m2/gm2-compiler/%.bnf $(PGE)\n-\t-test -d m2/gm2-compiler-boot || $(mkinstalldirs) m2/gm2-compiler-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(PGE) -k -l $< -o $@\n \n check-m2: check-gm2\n@@ -1666,11 +1691,11 @@ ifeq ($(M2_MAINTAINER),yes)\n include m2/Make-maintainer\n else\n m2/pge-boot/%.o: m2/pge-boot/%.c m2/gm2-libs/gm2-libs-host.h m2/gm2config.h\n-\t-test -d m2/pge-boot ||$(mkinstalldirs) m2/pge-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) $(INCLUDES) -I$(srcdir)/m2/pge-boot -Im2/gm2-libs -g -c $< -o $@\n \n m2/pge-boot/%.o: m2/pge-boot/%.cc m2/gm2-libs/gm2-libs-host.h m2/gm2config.h\n-\t-test -d m2/pge-boot || $(mkinstalldirs) m2/pge-boot\n+\t-test -d $(@D) || $(mkinstalldirs) $(@D)\n \t$(CXX) $(INCLUDES) -I$(srcdir)/m2/pge-boot -Im2/gm2-libs -g -c $< -o $@\n \n $(PGE): $(BUILD-PGE-O)"}, {"sha": "d2339b370f2da4e2d7f8dd5d22ba2149a9f9b050", "filename": "gcc/m2/Make-maintainer.in", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FMake-maintainer.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2FMake-maintainer.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FMake-maintainer.in?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -410,7 +410,7 @@ MCLINK=-g     # use -g -fmodules -c if you are debugging and wish to see missing\n # version of mc.  We need a working Modula-2 compiler to run mc-maintainer.\n \n GM2SYS=${HOME}/opt/lib/gcc/x86_64-pc-linux-gnu/12.0.0/m2/m2pim\n-GM2PATH=$(srcdir)/m2/mc:$(GM2SYS):$(srcdir)/m2:m2/gm2-auto:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso\n+GM2PATH=-I$(srcdir)/m2/mc -I$(GM2SYS) -I$(srcdir)/m2 -Im2/gm2-auto -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso\n \n mc: mc-clean mc-devel\n \n@@ -483,36 +483,36 @@ m2/boot-bin/mc-devel$(exeext): m2/mc-obj/mcp1.mod \\\n \t$(RM) -rf mc-obj\n \t$(mkinstalldirs) mc-obj\n \t$(CC) -I$(srcdir)/m2/mc -c -g mcflex.c -o mc-obj/mcflex.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/decl.mod -o mc-obj/decl.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcStream.mod -o mc-obj/mcStream.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcPretty.mod -o mc-obj/mcPretty.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcStack.mod -o mc-obj/mcStack.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/varargs.mod -o mc-obj/varargs.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcMetaError.mod -o mc-obj/mcMetaError.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcOptions.mod -o mc-obj/mcOptions.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcComp.mod -o mc-obj/mcComp.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) m2/mc-obj/mcp1.mod -o mc-obj/mcp1.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) m2/mc-obj/mcp2.mod -o mc-obj/mcp2.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) m2/mc-obj/mcp3.mod -o mc-obj/mcp3.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) m2/mc-obj/mcp4.mod -o mc-obj/mcp4.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) m2/mc-obj/mcp5.mod -o mc-obj/mcp5.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/wlists.mod -o mc-obj/wlists.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/alists.mod -o mc-obj/alists.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/symbolKey.mod -o mc-obj/symbolKey.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcReserved.mod -o mc-obj/mcReserved.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/nameKey.mod -o mc-obj/nameKey.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcSearch.mod -o mc-obj/mcSearch.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcFileName.mod -o mc-obj/mcFileName.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcLexBuf.mod -o mc-obj/mcLexBuf.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcQuiet.mod -o mc-obj/mcQuiet.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcError.mod -o mc-obj/mcError.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcDebug.mod -o mc-obj/mcDebug.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcPrintf.mod -o mc-obj/mcPrintf.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/Indexing.mod -o mc-obj/Indexing.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcPreprocess.mod -o mc-obj/mcPreprocess.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/keyc.mod -o mc-obj/keyc.o\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) $(srcdir)/m2/mc/mcComment.mod -o mc-obj/mcComment.o\n-\t$(BOOTGM2) $(MCLINK) -I. -fscaffold-main -I$(GM2PATH) \\\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/decl.mod -o mc-obj/decl.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcStream.mod -o mc-obj/mcStream.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcPretty.mod -o mc-obj/mcPretty.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcStack.mod -o mc-obj/mcStack.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/varargs.mod -o mc-obj/varargs.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcMetaError.mod -o mc-obj/mcMetaError.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcOptions.mod -o mc-obj/mcOptions.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcComp.mod -o mc-obj/mcComp.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) m2/mc-obj/mcp1.mod -o mc-obj/mcp1.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) m2/mc-obj/mcp2.mod -o mc-obj/mcp2.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) m2/mc-obj/mcp3.mod -o mc-obj/mcp3.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) m2/mc-obj/mcp4.mod -o mc-obj/mcp4.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) m2/mc-obj/mcp5.mod -o mc-obj/mcp5.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/wlists.mod -o mc-obj/wlists.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/alists.mod -o mc-obj/alists.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/symbolKey.mod -o mc-obj/symbolKey.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcReserved.mod -o mc-obj/mcReserved.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/nameKey.mod -o mc-obj/nameKey.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcSearch.mod -o mc-obj/mcSearch.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcFileName.mod -o mc-obj/mcFileName.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcLexBuf.mod -o mc-obj/mcLexBuf.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcQuiet.mod -o mc-obj/mcQuiet.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcError.mod -o mc-obj/mcError.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcDebug.mod -o mc-obj/mcDebug.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcPrintf.mod -o mc-obj/mcPrintf.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/Indexing.mod -o mc-obj/Indexing.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcPreprocess.mod -o mc-obj/mcPreprocess.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/keyc.mod -o mc-obj/keyc.o\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) $(srcdir)/m2/mc/mcComment.mod -o mc-obj/mcComment.o\n+\t$(BOOTGM2) $(MCLINK) -I. -fscaffold-static -fscaffold-main $(GM2PATH) \\\n             -fuse-list=$(srcdir)/m2/init/mcinit $(srcdir)/m2/mc/top.mod -o mc \\\n             m2/gm2-libs-boot/RTcodummy.o \\\n             m2/gm2-libs-boot/dtoa.o m2/gm2-libs-boot/ldtoa.o mc-obj/*o m2/mc-boot-ch/Gabort.o\n@@ -525,20 +525,20 @@ m2/boot-bin/mc-opt$(exeext): m2/mc-obj/mcp1.mod \\\n                              mcflex.c\n \t-test -d m2/boot-bin || $(mkinstalldirs) m2/boot-bin\n \tg++ -I$(srcdir)/m2/mc -c -g mcflex.c\n-\t$(BOOTGM2) -fsources -fm2-whole-program -g -I$(srcdir)/m2/mc:$(objdir)/m2/mc-obj:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/mc $(srcdir)/m2/mc/top.mod\n+\t$(BOOTGM2) -fsources -fm2-whole-program -g -I$(srcdir)/m2/mc:$(objdir)/m2/mc-obj -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/mc $(srcdir)/m2/mc/top.mod\n \n m2/mc/decl.o:  $(srcdir)/m2/mc/decl.mod\n \t-test -d m2/mc || $(mkinstalldirs) m2/mc\n-\t$(BOOTGM2) $(MCOPTIONS) -I$(GM2PATH) -o $@ $(srcdir)/m2/mc/decl.mod\n+\t$(BOOTGM2) $(MCOPTIONS) $(GM2PATH) -o $@ $(srcdir)/m2/mc/decl.mod\n \n m2/mc-obj/%.mod: $(srcdir)/m2/mc/%.bnf $(PGE)\n \t-test -d m2/mc-obj || $(mkinstalldirs) m2/mc-obj\n \t$(PGE) -l $< -o $@\n \n gm2-bootstrap: mc-devel\n \tfor i in $(srcdir)/m2/gm2-libs/*.def ; do echo $$i ; ./mc --gcc-config-system -I$(srcdir)/m2/gm2-libs $$i ; done\n-\tfor i in $(srcdir)/m2/gm2-compiler/*.def ; do echo $$i ; ./mc --gcc-config-system -I$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-gcc $$i ; done\n-\tfor i in $(srcdir)/m2/gm2-libs/*.mod ; do echo $$i ; ./mc --gcc-config-system -I$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-gcc $$i ; done\n+\tfor i in $(srcdir)/m2/gm2-compiler/*.def ; do echo $$i ; ./mc --gcc-config-system -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-gcc $$i ; done\n+\tfor i in $(srcdir)/m2/gm2-libs/*.mod ; do echo $$i ; ./mc --gcc-config-system -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-gcc $$i ; done\n \n \n $(objdir)/plugin:\n@@ -571,31 +571,39 @@ MC_OPTIONS = $(MC_COPYRIGHT) --gcc-config-system --olang=c++\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.h: $(srcdir)/m2/mc/%.def\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\n+m2/mc-boot-gen/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs-iso/%.def\n+\t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs/%.def\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)decl.c: $(srcdir)/m2/mc/decl.mod\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) --extended-opaque -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) --extended-opaque -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.c: $(srcdir)/m2/mc/%.mod\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.c: $(srcdir)/m2/gm2-libs/%.mod\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\n+m2/mc-boot-gen/$(SRC_PREFIX)%.c: $(srcdir)/m2/gm2-libs-iso/%.mod\n+\t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs-iso/%.def\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n m2/mc-boot-gen/$(SRC_PREFIX)%.c: m2/mc-obj/%.mod\n \t-test -d m2/mc-boot-gen || $(mkinstalldirs) m2/mc-boot-gen\n-\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n+\t./mc $(MC_OPTIONS) -I$(srcdir)/m2/mc -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso $(EXTENDED_OPAQUE) --h-file-prefix=$(SRC_PREFIX) -o=$@ $<\n \n # mc-bootstrap compiles mc using the C version previously generated by mc-autogen.\n # These autogenerated files will be checked into git by the maintainer.\n@@ -680,11 +688,11 @@ gm2.verifyparanoid: m2/stage1/cc1gm2$(exeext) m2/m2obj2/cc1gm2$(exeext) m2/m2obj\n \t@echo \"verifying the three generations of GNU Modula-2 compilers - it may take some time..\"\n \t$(QUIAT)for i in $(GM2-VERIFY-MODS) ; do \\\n            echo -n \"$$i \" ; \\\n-           ./gm2 -S $(GM2_FLAGS) -c -B./stage1/m2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/1.s ; \\\n+           ./gm2 -S $(GM2_FLAGS) -c -B./stage1/m2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/1.s ; \\\n            echo -n \"[1]\" ; \\\n-           ./gm2 -S $(GM2_FLAGS) -c -B./stage2/m2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/2.s ; \\\n+           ./gm2 -S $(GM2_FLAGS) -c -B./stage2/m2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/2.s ; \\\n            echo -n \"[2]\" ; \\\n-           ./gm2 -S $(GM2_FLAGS) -c -B./stage3/m2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/3.s ; \\\n+           ./gm2 -S $(GM2_FLAGS) -c -B./stage3/m2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/3.s ; \\\n            echo -n \"[3]\" ; \\\n            if ! diff m2/gm2-compiler-verify/1.s m2/gm2-compiler-verify/2.s > m2/gm2-compiler-verify/1_2.diff 2>&1 ; then \\\n                echo -n \" [stage 1 and stage 2 differ]\" ; \\\n@@ -704,11 +712,11 @@ gm2.verifyparanoid: m2/stage1/cc1gm2$(exeext) m2/m2obj2/cc1gm2$(exeext) m2/m2obj\n \t$(QUIAT)for i in x $(GM2-VERIFY-AUTO) ; do \\\n            if [ -f m2/gm2-auto/$$i ] ; then \\\n               echo -n \"$$i \" ; \\\n-              ./gm2 -S $(GM2_FLAGS) -c -B./m2/stage1 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/1.s ; \\\n+              ./gm2 -S $(GM2_FLAGS) -c -B./m2/stage1 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/1.s ; \\\n               echo -n \"[1]\" ; \\\n-              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/2.s ; \\\n+              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/2.s ; \\\n               echo -n \"[2]\" ; \\\n-              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj3 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/3.s ; \\\n+              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj3 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/3.s ; \\\n               echo -n \"[3]\" ; \\\n               if ! diff m2/gm2-compiler-verify/1.s m2/gm2-compiler-verify/2.s > m2/gm2-compiler-verify/1_2.diff 2>&1 ; then \\\n                   echo -n \" [stage 1 and stage 2 differ]\" ; \\\n@@ -734,9 +742,9 @@ gm2.verifystage12: force m2/stage1/cc1gm2$(exeext) m2/m2obj2/cc1gm2$(exeext)\n \t@echo \"verifying stage1 and stage2 generations of GNU Modula-2 compilers - it may take some time..\"\n \t$(QUIAT)for i in $(GM2-VERIFY-MODS) ; do \\\n            echo -n \"$$i \" ; \\\n-           ./gm2 -S $(GM2_FLAGS) -c -B./stage1/m2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/1.s ; \\\n+           ./gm2 -S $(GM2_FLAGS) -c -B./stage1/m2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/1.s ; \\\n            echo -n \"[1]\" ; \\\n-           ./gm2 -S $(GM2_FLAGS) -c -B./stage2/m2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/2.s ; \\\n+           ./gm2 -S $(GM2_FLAGS) -c -B./stage2/m2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty $(srcdir)/m2/gm2-compiler/$$i -o m2/gm2-compiler-verify/2.s ; \\\n            echo -n \"[2]\" ; \\\n            if ! diff m2/gm2-compiler-verify/1.s m2/gm2-compiler-verify/2.s > m2/gm2-compiler-verify/1_2.diff 2>&1 ; then \\\n                echo -n \" [stage 1 and stage 2 differ]\" ; \\\n@@ -750,9 +758,9 @@ gm2.verifystage12: force m2/stage1/cc1gm2$(exeext) m2/m2obj2/cc1gm2$(exeext)\n \t$(QUIAT)for i in x $(GM2-VERIFY-AUTO) ; do \\\n            if [ -f m2/gm2-auto/$$i ] ; then \\\n               echo -n \"$$i \" ; \\\n-              ./gm2 -S $(GM2_FLAGS) -c -B./m2/stage1 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/1.s ; \\\n+              ./gm2 -S $(GM2_FLAGS) -c -B./m2/stage1 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/1.s ; \\\n               echo -n \"[1]\" ; \\\n-              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj2 -I$(srcdir)/m2/gm2-compiler:$(srcdir)/m2/gm2-libs:$(srcdir)/m2/gm2-gcc:$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/2.s ; \\\n+              ./gm2 -S $(GM2_FLAGS) -c -B./m2/m2obj2 -I$(srcdir)/m2/gm2-compiler -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-gcc -I$(srcdir)/m2/gm2-libiberty m2/gm2-auto/$$i -o m2/gm2-compiler-verify/2.s ; \\\n               echo -n \"[2]\" ; \\\n               if ! diff m2/gm2-compiler-verify/1.s m2/gm2-compiler-verify/2.s > m2/gm2-compiler-verify/1_2.diff 2>&1 ; then \\\n                   echo -n \" [stage 1 and stage 2 differ]\" ; \\"}, {"sha": "9739c761d643a510a1b6645eed91c07e87158ff6", "filename": "gcc/m2/gm2-compiler/M2ALU.mod", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2ALU.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2ALU.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2ALU.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -4636,12 +4636,12 @@ BEGIN\n                ELSE\n                   MetaErrorT2 (tokenno,\n                                'the {%1EN} element does not exist in the {%2ad} array declaration used by the compound literal', i, constructorType) ;\n-                  RETURN NulSym\n                END\n             END\n          END\n       END\n-   END\n+   END ;\n+   RETURN NulSym\n END GetConstructorElement ;\n \n "}, {"sha": "cc3aa4cc961656b095cb6b346f326f909354f0e6", "filename": "gcc/m2/gm2-compiler/M2Base.mod", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Base.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Base.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Base.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -33,7 +33,7 @@ IMPLEMENTATION MODULE M2Base ;\n \n FROM DynamicStrings IMPORT InitString, String, Mark, InitStringCharStar, ConCat ;\n FROM M2LexBuf IMPORT BuiltinTokenNo, GetTokenNo ;\n-FROM NameKey IMPORT MakeKey, WriteKey, KeyToCharStar ;\n+FROM NameKey IMPORT NulName, MakeKey, WriteKey, KeyToCharStar ;\n FROM M2Debug IMPORT Assert ;\n FROM SYSTEM IMPORT WORD ;\n \n@@ -74,7 +74,8 @@ FROM SymbolTable IMPORT ModeOfAddr,\n                         IsArray, IsProcedure, IsConstString,\n                         IsVarient, IsRecordField, IsFieldVarient,\n                         GetArraySubscript, IsRecord, NoOfParam,\n-                        GetNthParam, IsVarParam, GetNth, GetDimension ;\n+                        GetNthParam, IsVarParam, GetNth, GetDimension,\n+                        MakeError ;\n \n FROM M2ALU IMPORT PushIntegerTree, PushRealTree, PushCard, Equ, Gre, Less ;\n FROM M2Batch IMPORT MakeDefinitionSource ;\n@@ -1044,7 +1045,8 @@ BEGIN\n    THEN\n       RETURN( RealN(128) )\n    ELSE\n-      MetaError1('{%1ad} must be a COMPLEX type', sym)\n+      MetaError1('{%1ad} must be a COMPLEX type', sym) ;\n+      RETURN RType\n    END\n END ComplexToScalar ;\n \n@@ -1997,7 +1999,8 @@ BEGIN\n \n    ELSE\n       InternalError ('not expecting this metatype value')\n-   END\n+   END ;\n+   RETURN MakeError (NearTok, NulName)\n END MixMetaTypes ;\n \n "}, {"sha": "ef1859f46e7d8c98898d88a4b4c21bb8d62a2c57", "filename": "gcc/m2/gm2-compiler/M2GCCDeclare.mod", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -5020,7 +5020,8 @@ BEGIN\n       RETURN( min )\n    ELSIF GetSType(type)=NulSym\n    THEN\n-      MetaError1('unable to obtain the MIN value for type {%1as}', type)\n+      MetaError1('unable to obtain the MIN value for type {%1as}', type) ;\n+      RETURN NulSym\n    ELSE\n       RETURN( GetTypeMin(GetSType(type)) )\n    END\n@@ -5058,7 +5059,8 @@ BEGIN\n       RETURN( max )\n    ELSIF GetSType(type)=NulSym\n    THEN\n-      MetaError1('unable to obtain the MAX value for type {%1as}', type)\n+      MetaError1('unable to obtain the MAX value for type {%1as}', type) ;\n+      RETURN NulSym\n    ELSE\n       RETURN( GetTypeMax(GetSType(type)) )\n    END"}, {"sha": "caca8a3f795012254c62c22f17c72889ea5c630d", "filename": "gcc/m2/gm2-compiler/M2GenGCC.mod", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2GenGCC.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2GenGCC.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2GenGCC.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -392,7 +392,7 @@ BEGIN\n          END ;\n          scope := GetScope(scope)\n       END ;\n-      Assert (FALSE)\n+      InternalError ('expecting scope to eventually reach a module or defimp symbol')\n    ELSE\n       (* Otherwise it is public if it were exported.  *)\n       RETURN IsExported (GetMainModule (), sym)\n@@ -1225,13 +1225,15 @@ BEGIN\n       END ;\n       IF HighField = NulSym\n       THEN\n-         MetaError1 ('{%EkHIGH} dimension number {%1N} for array does not exist', dim)\n+         MetaError1 ('{%EkHIGH} dimension number {%1N} for array does not exist', dim) ;\n+         RETURN GetCardinalZero (location)\n       ELSE\n          (* remainingDim := dim - accessibleDim ;  --fixme-- write tests to stress this code.  *)\n          HighTree := BuildHighFromStaticArray (location, (* remainingDim, *) ArrayType) ;\n          IF HighTree = NIL\n          THEN\n-            MetaError1 ('{%EkHIGH} dimension number {%1N} for array does not exist', dim)\n+            MetaError1 ('{%EkHIGH} dimension number {%1N} for array does not exist', dim) ;\n+            RETURN GetCardinalZero (location)\n          END ;\n          RETURN HighTree\n       END"}, {"sha": "d53228b4675288fb1d14db341baed38409e8de2e", "filename": "gcc/m2/gm2-compiler/M2Preprocess.mod", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -101,6 +101,7 @@ END GetFileName ;\n    Return basename.\n *)\n \n+(*\n PROCEDURE BaseName (Path: String) : String ;\n VAR\n    ext,\n@@ -120,6 +121,7 @@ BEGIN\n    END ;\n    RETURN Dup (Slice(Path, basename, ext))\n END BaseName ;\n+*)\n \n (*\n    MakeSaveTempsFileName - return a temporary file like "}, {"sha": "17062b9a278e478c0bc3ac78a88eb10322bbddc2", "filename": "gcc/m2/gm2-compiler/M2Quads.mod", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -6677,6 +6677,8 @@ BEGIN\n    ELSIF IsVar (Sym) OR IsType (Sym)\n    THEN\n       RETURN GetItemPointedTo (GetSType (Sym))\n+   ELSE\n+      InternalError ('expecting a pointer or variable symbol')\n    END\n END GetItemPointedTo ;\n \n@@ -9297,8 +9299,9 @@ BEGIN\n    ELSIF GetSType (type) = NulSym\n    THEN\n       MetaErrorT1 (tok,\n-                   'unable to obtain the {%AkMIN} value for type {%1Aad}', type)\n+                   'unable to obtain the {%AkMIN} value for type {%1Aad}', type) ;\n       (* non recoverable error.  *)\n+      InternalError ('MetaErrorT1 {%AkMIN} should call abort')\n    ELSE\n       RETURN GetTypeMin (tok, func, GetSType (type))\n    END\n@@ -9334,8 +9337,9 @@ BEGIN\n    ELSIF GetSType (type) = NulSym\n    THEN\n       MetaErrorT1 (tok,\n-                   'unable to obtain the {%AkMAX} value for type {%1Aad}', type)\n+                   'unable to obtain the {%AkMAX} value for type {%1Aad}', type) ;\n       (* non recoverable error.  *)\n+      InternalError ('MetaErrorT1 {%AkMAX} should call abort')\n    ELSE\n       RETURN GetTypeMax (tok, func, GetSType (type))\n    END\n@@ -9452,7 +9456,7 @@ BEGIN\n          MetaErrorT1 (vartok,\n                       'parameter to {%AkMAX} must be a type or a variable, seen {%1Aad}',\n                       Var)\n-         (* non recoverable error.  *)\n+         (* non recoverable error.  *) ;\n       END\n    ELSE\n       (* we dont know the type therefore cannot fake a return.  *)"}, {"sha": "9c78c800f6f6c7035e4544447d8beb6f7c15239a", "filename": "gcc/m2/gm2-compiler/M2Search.mod", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -81,23 +81,26 @@ END doDSdbExit ;\n                doDSsbEnter when debugging garbage collection at runtime.\n *)\n \n+(*\n PROCEDURE DSdbEnter ;\n BEGIN\n END DSdbEnter ;\n-\n+*)\n \n (*\n    DSdbExit - dummy nop exit code which the preprocessor replaces by\n               doDSsbExit when debugging garbage collection at runtime.\n *)\n \n+(*\n PROCEDURE DSdbExit (s: String) ;\n BEGIN\n    IF GarbageDebugging\n    THEN\n       Assert (s # NIL)\n    END\n END DSdbExit ;\n+*)\n \n \n (*"}, {"sha": "4908578fd50730b45584a689339b6d06335bf36f", "filename": "gcc/m2/gm2-compiler/M2System.mod", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2System.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-compiler%2FM2System.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2System.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -47,6 +47,7 @@ FROM SymbolTable IMPORT NulSym,\n       \t       \t     \tPutSet, PutVar,\n       \t       \t     \tPutSubrange,\n                         PutExportQualified,\n+                        PutProcedureNoReturn,\n                         GetSym, GetSymName,\n                         GetCurrentModule, SetCurrentModule,\n                         IsLegal,\n@@ -418,6 +419,7 @@ BEGIN\n \n    Throw := MakeProcedure(BuiltinTokenNo,\n                           MakeKey('THROW')) ;       (* Procedure       *)\n+   PutProcedureNoReturn (Throw, TRUE) ;\n \n    CreateMinMaxFor(Word, 'MinWord', 'MaxWord', GetWordType()) ;\n    CreateMinMaxFor(Address, 'MinAddress', 'MaxAddress', GetPointerType()) ;"}, {"sha": "b3cd65151730b53f2c53b5e2f6cf375801f58056", "filename": "gcc/m2/gm2-gcc/m2except.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -132,13 +132,13 @@ m2except_InitExceptions (location_t location)\n   m2decl_BuildParameterDeclaration (location, NULL, ptr_type_node, FALSE);\n   fn_throw_tree = m2decl_BuildEndFunctionDeclaration (\n       location, location, \"__cxa_throw\", void_type_node, TRUE, FALSE, TRUE,\n-      FALSE);\n+      TRUE);\n \n   /* Declare void __cxa_rethrow (void).  */\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   fn_rethrow_tree = m2decl_BuildEndFunctionDeclaration (\n      location, location, \"__cxa_rethrow\", void_type_node, TRUE, FALSE, TRUE,\n-     FALSE);\n+     TRUE);\n \n   /* Declare void *__cxa_allocate_exception (size_t).  */\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n@@ -417,7 +417,7 @@ gm2_build_throw (location_t location, tree exp)\n       exp = build2 (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n \n       /* Force all the cleanups to be evaluated here so that we don't have\n-      to do them during unwinding.  */\n+\t to do them during unwinding.  */\n       exp = build1 (CLEANUP_POINT_EXPR, void_type_node, exp);\n \n       tmp = do_throw (location, ptr);"}, {"sha": "d9b63bee655222b8799106f92adbeff6bb216933", "filename": "gcc/m2/gm2-lang.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-lang.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -330,7 +330,6 @@ gm2_langhook_handle_option (\n   enum opt_code code = (enum opt_code)scode;\n \n   const struct cl_option *option = &cl_options[scode];\n-  const char *opt = (const char *)option->opt_text;\n   /* ignore file names.  */\n   if (code == N_OPTS)\n     return 1;"}, {"sha": "a4f5b68b3241869269a56bda265bd77da0db4a09", "filename": "gcc/m2/gm2-libs-coroutines/Debug.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-coroutines%2FDebug.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-coroutines%2FDebug.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-coroutines%2FDebug.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -51,7 +51,7 @@ TYPE\n PROCEDURE Halt (File    : ARRAY OF CHAR;\n                 LineNo  : CARDINAL;\n                 Function,\n-                Message : ARRAY OF CHAR) ;\n+                Message : ARRAY OF CHAR) <* noreturn *> ;\n \n \n (*"}, {"sha": "5a66d20b9cf6304582653c1efad9f725c2ae0bb5", "filename": "gcc/m2/gm2-libs-coroutines/SYSTEM.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-coroutines%2FSYSTEM.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-coroutines%2FSYSTEM.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-coroutines%2FSYSTEM.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -171,7 +171,7 @@ PROCEDURE SHIFT (val: <a set type>;\n      num is negative, otherwise the direction is up.\n   *)\n \n-PROCEDURE THROW (i: INTEGER) ;\n+PROCEDURE THROW (i: INTEGER) <* noreturn *> ;\n   (*\n      THROW is a GNU extension and was not part of the PIM or ISO\n      standards.  It throws an exception which will be caught by the EXCEPT"}, {"sha": "15a194da587ca86182cdfac7ad35414c1fe097d9", "filename": "gcc/m2/gm2-libs-iso/ClientSocket.mod", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FClientSocket.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FClientSocket.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FClientSocket.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -224,13 +224,20 @@ BEGIN\n             actual := 0 ;\n             RETURN( FALSE )\n          END\n+      ELSE\n+         RETURN( FALSE )\n       END\n    END\n END dorbytes ;\n \n \n (*\n-   dowbytes -\n+   dowbytes - attempts to write out nBytes.  The actual\n+              number of bytes written are returned.\n+              If the actual number of bytes written is >= 0 then\n+              the return result will be true.  Failure to\n+              write any bytes results in returning FALSE\n+              errno set and the actual will be set to zero.\n *)\n \n PROCEDURE dowbytes (g: GenDevIF; d: DeviceTablePtr;"}, {"sha": "d037b7e6877bc1c46fbddbfce122696976583fe8", "filename": "gcc/m2/gm2-libs-iso/EXCEPTIONS.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FEXCEPTIONS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FEXCEPTIONS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FEXCEPTIONS.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -25,7 +25,8 @@ PROCEDURE AllocateSource(VAR newSource: ExceptionSource);\n   (* Allocates a unique value of type ExceptionSource *)\n \n PROCEDURE RAISE (source: ExceptionSource;\n-                 number: ExceptionNumber; message: ARRAY OF CHAR);\n+                 number: ExceptionNumber; message: ARRAY OF CHAR)\n+                 <* noreturn *> ;\n   (* Associates the given values of source, number and message with\n      the current context and raises an exception.\n   *)"}, {"sha": "cae594b8a4bb7640486d0b0a3a45355d28d00854", "filename": "gcc/m2/gm2-libs-iso/IOLink.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FIOLink.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FIOLink.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FIOLink.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -120,7 +120,7 @@ TYPE\n *)\n \n PROCEDURE RAISEdevException (cid: IOChan.ChanId; did: DeviceId;\n-                             x: DevExceptionRange; s: ARRAY OF CHAR);\n+                             x: DevExceptionRange; s: ARRAY OF CHAR) <* noreturn *> ;\n \n   (* If the device module identified by did is not the module that made the channel\n      identified by cid, the exception wrongDevice is raised; otherwise the given exception\n@@ -134,7 +134,7 @@ PROCEDURE IsIOException () : BOOLEAN;\n   *)\n \n PROCEDURE IOException () : IOChan.ChanExceptions;\n-  (* If the current coroutine is in the exceptional execution state because of the \n+  (* If the current coroutine is in the exceptional execution state because of the\n      raising af an exception from ChanExceptions, returns the corresponding\n      enumeration value, and otherwise raises an exception.\n   *)"}, {"sha": "cca4ae641897d762fce83568bb233ac629dcc8d8", "filename": "gcc/m2/gm2-libs-iso/M2RTS.def", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -106,7 +106,7 @@ PROCEDURE InstallInitialProcedure (p: PROC) : BOOLEAN ;\n           then calling HALT with no parameter.\n *)\n \n-PROCEDURE HALT ([exitcode: INTEGER = -1]) ;\n+PROCEDURE HALT ([exitcode: INTEGER = -1]) <* noreturn *> ;\n \n \n (*\n@@ -116,7 +116,8 @@ PROCEDURE HALT ([exitcode: INTEGER = -1]) ;\n *)\n \n PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n-                function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;\n+                function: ARRAY OF CHAR; description: ARRAY OF CHAR)\n+                <* noreturn *> ;\n \n \n (*\n@@ -126,7 +127,7 @@ PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n *)\n \n PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n-                 function, description: ADDRESS) ;\n+                 function, description: ADDRESS) <* noreturn *> ;\n \n \n (*\n@@ -143,7 +144,7 @@ PROCEDURE ExitOnHalt (e: INTEGER) ;\n PROCEDURE ErrorMessage (message: ARRAY OF CHAR;\n                         filename: ARRAY OF CHAR;\n                         line: CARDINAL;\n-                        function: ARRAY OF CHAR) ;\n+                        function: ARRAY OF CHAR) <* noreturn *> ;\n \n \n (*\n@@ -175,30 +176,30 @@ PROCEDURE Length (a: ARRAY OF CHAR) : CARDINAL ;\n    The following are the runtime exception handler routines.\n *)\n \n-PROCEDURE AssignmentException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE IncException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE DecException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE InclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ExclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ShiftException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE RotateException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE StaticArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE DynamicArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopBeginException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopToException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopEndException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE PointerNilException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE NoReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE CaseException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeNonPosDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeNonPosModException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeZeroDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeZeroRemException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE RealValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ParameterException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE NoException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n+PROCEDURE AssignmentException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE IncException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE DecException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE InclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ExclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ShiftException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE RotateException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE StaticArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE DynamicArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopBeginException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopToException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopEndException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE PointerNilException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE NoReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE CaseException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeNonPosDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeNonPosModException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeZeroDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeZeroRemException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE RealValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ParameterException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE NoException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n \n \n END M2RTS."}, {"sha": "f25fc6ff3a297cf446397fee383c34a1d9c6c731", "filename": "gcc/m2/gm2-libs-iso/SYSTEM.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FSYSTEM.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FSYSTEM.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FSYSTEM.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -133,7 +133,7 @@ PROCEDURE TSIZE (<type>; ... ): CARDINAL;\n      are used to distinguish variants in a variant record.\n   *)\n \n-PROCEDURE THROW (i: INTEGER) ;\n+PROCEDURE THROW (i: INTEGER) <* noreturn *> ;\n   (*\n      THROW is a GNU extension and was not part of the PIM or ISO\n      standards.  It throws an exception which will be caught by the"}, {"sha": "95090c0ecd82528e9aeeaf76567e4f10a94055e6", "filename": "gcc/m2/gm2-libs-iso/TermFile.mod", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FTermFile.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-iso%2FTermFile.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FTermFile.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -325,12 +325,18 @@ BEGIN\n             RETURN( FALSE )\n          END\n       END\n-   END\n+   END ;\n+   RETURN( FALSE )\n END dorbytes ;\n \n \n (*\n-   dowbytes - \n+   dowbytes - attempts to write out nBytes.  The actual\n+              number of bytes written are returned.\n+              If the actual number of bytes written is >= 0 then\n+              the return result will be true.  Failure to\n+              write any bytes results in returning FALSE\n+              errno set and the actual will be set to zero.\n *)\n \n PROCEDURE dowbytes (g: GenDevIF; d: DeviceTablePtr;\n@@ -453,7 +459,7 @@ END freeData ;\n \n \n (*\n-   handlefree - \n+   handlefree -\n *)\n \n PROCEDURE handlefree (d: DeviceTablePtr) ;\n@@ -519,7 +525,7 @@ END termOpen ;\n \n \n (*\n-   RestoreTerminalSettings - \n+   RestoreTerminalSettings -\n *)\n \n PROCEDURE RestoreTerminalSettings (cid: ChanId) ;\n@@ -616,7 +622,7 @@ END Close ;\n \n \n (*\n-   Init - \n+   Init -\n *)\n \n PROCEDURE Init ;"}, {"sha": "65ffa8c53678663c1056d81e19e1193130d63932", "filename": "gcc/m2/gm2-libs-min/M2RTS.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -48,7 +48,7 @@ PROCEDURE RegisterModule (name: ADDRESS;\n PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n PROCEDURE ExecuteTerminationProcedures ;\n PROCEDURE ExecuteInitialProcedures ;\n-PROCEDURE HALT ;\n+PROCEDURE HALT <* noreturn *> ;\n PROCEDURE NoException (filename: ADDRESS;\n                        line, column: CARDINAL; scope, message: ADDRESS) ;\n "}, {"sha": "94a183301c3928be0eb3354c58f6c70a8eca53b9", "filename": "gcc/m2/gm2-libs/FIO.mod", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FFIO.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FFIO.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FFIO.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -738,14 +738,11 @@ BEGIN\n                   END\n                END ;\n                RETURN( total )\n-            ELSE\n-               RETURN( -1 )\n             END\n          END\n       END\n-   ELSE\n-      RETURN( -1 )\n-   END\n+   END ;\n+   RETURN( -1 )\n END BufferedRead ;\n \n \n@@ -1606,7 +1603,8 @@ BEGIN\n       ELSE\n          RETURN fd^.name.address\n       END\n-   END\n+   END ;\n+   RETURN NIL\n END getFileName ;\n \n \n@@ -1628,7 +1626,8 @@ BEGIN\n       ELSE\n          RETURN fd^.name.size\n       END\n-   END\n+   END ;\n+   RETURN 0\n END getFileNameLength ;\n \n "}, {"sha": "167f96423e2a4a8ed39e47168ac6977c582a6678", "filename": "gcc/m2/gm2-libs/M2RTS.def", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -136,7 +136,7 @@ PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n *)\n \n PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n-                 function, description: ADDRESS) ;\n+                 function, description: ADDRESS) <* noreturn *> ;\n \n \n (*\n@@ -169,30 +169,30 @@ PROCEDURE Length (a: ARRAY OF CHAR) : CARDINAL ;\n    The following are the runtime exception handler routines.\n *)\n \n-PROCEDURE AssignmentException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE IncException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE DecException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE InclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ExclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ShiftException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE RotateException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE StaticArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE DynamicArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopBeginException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopToException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ForLoopEndException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE PointerNilException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE NoReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE CaseException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeNonPosDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeNonPosModException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeZeroDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeZeroRemException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE WholeValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE RealValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE ParameterException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n-PROCEDURE NoException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) ;\n+PROCEDURE AssignmentException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE IncException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE DecException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE InclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ExclException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ShiftException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE RotateException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE StaticArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE DynamicArraySubscriptException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopBeginException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopToException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ForLoopEndException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE PointerNilException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE NoReturnException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE CaseException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeNonPosDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeNonPosModException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeZeroDivException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeZeroRemException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE WholeValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE RealValueException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE ParameterException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n+PROCEDURE NoException (filename: ADDRESS; line, column: CARDINAL; scope, message: ADDRESS) <* noreturn *> ;\n \n \n END M2RTS."}, {"sha": "7d3b58d561804ef3795bbbf05af903efb7f33992", "filename": "gcc/m2/gm2-libs/RTExceptions.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -56,7 +56,7 @@ TYPE\n PROCEDURE Raise (number: CARDINAL;\n                  file: ADDRESS; line: CARDINAL;\n                  column: CARDINAL; function: ADDRESS;\n-                 message: ADDRESS) ;\n+                 message: ADDRESS) <* noreturn *> ;\n \n \n (*"}, {"sha": "8d3dc04ff0f225f5387cd1c0ced4733d6f66719f", "filename": "gcc/m2/gm2-libs/RTExceptions.mod", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FRTExceptions.mod?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -125,16 +125,17 @@ END findHandler ;\n                    exception in the active EHB.\n *)\n \n-PROCEDURE InvokeHandler ;\n+PROCEDURE InvokeHandler  <* noreturn *> ;\n VAR\n    h: Handler ;\n BEGIN\n-   h := findHandler(currentEHB, currentEHB^.number) ;\n+   h := findHandler (currentEHB, currentEHB^.number) ;\n    IF h=NIL\n    THEN\n-      THROW(GetNumber(GetExceptionBlock()))\n+      THROW (GetNumber (GetExceptionBlock ()))\n    ELSE\n-      h^.p\n+      h^.p ;\n+      HALT\n    END\n END InvokeHandler ;\n \n@@ -151,7 +152,7 @@ VAR\n    n: INTEGER ;\n BEGIN\n    e := GetExceptionBlock() ;\n-   n := write(2, GetTextBuffer(e), strlen(GetTextBuffer(e))) ;\n+   n := write (2, GetTextBuffer (e), strlen (GetTextBuffer (e))) ;\n    HALT\n END DefaultErrorCatch ;\n \n@@ -162,7 +163,7 @@ END DefaultErrorCatch ;\n \n PROCEDURE DoThrow ;\n BEGIN\n-   THROW(GetNumber(GetExceptionBlock()))\n+   THROW (GetNumber (GetExceptionBlock ()))\n END DoThrow ;\n \n \n@@ -179,7 +180,7 @@ VAR\n    i: M2EXCEPTION.M2Exceptions ;\n BEGIN\n    FOR i := MIN(M2EXCEPTION.M2Exceptions) TO MAX(M2EXCEPTION.M2Exceptions) DO\n-      PushHandler(GetExceptionBlock(), VAL(CARDINAL, i), DoThrow)\n+      PushHandler (GetExceptionBlock (), VAL (CARDINAL, i), DoThrow)\n    END\n END BaseExceptionsThrow ;\n "}, {"sha": "2f72ad1718c311882f780ce99615c61b5290b041", "filename": "gcc/m2/gm2-libs/SYSTEM.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FSYSTEM.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2-libs%2FSYSTEM.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FSYSTEM.def?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -89,7 +89,7 @@ PROCEDURE SHIFT (val: <a set type>;\n      num is negative, otherwise the direction is up/left.\n   *)\n \n-PROCEDURE THROW (i: INTEGER) ;\n+PROCEDURE THROW (i: INTEGER) <* noreturn *> ;\n   (*\n      THROW is a GNU extension and was not part of the PIM or ISO\n      standards.  It throws an exception which will be caught by the"}, {"sha": "0645be9fe02fe3ab0521c7faa9d58c6e24e750bd", "filename": "gcc/m2/gm2spec.cc", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fgm2spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2spec.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -129,8 +129,6 @@ static const char *library_abbrev[maxlib]\n    -flibs=m2pim,m2iso respectively.  This provides a match between\n    the dialect of Modula-2 and the library set.  */\n \n-static const char *add_include (const char *libpath, const char *library);\n-\n static bool seen_scaffold_static = false;\n static bool seen_scaffold_dynamic = false;\n static bool seen_scaffold_main = false;\n@@ -150,7 +148,6 @@ static void append_arg (const struct cl_decoded_option *);\n /* The new argument list will be built here.  */\n static unsigned int gm2_newargc;\n static struct cl_decoded_option *gm2_new_decoded_options;\n-static const char *full_libraries = NULL;\n static const char *libraries = NULL;  /* Abbreviated libraries.  */\n \n \n@@ -241,31 +238,6 @@ safe_strdup (const char *s)\n   return NULL;\n }\n \n-static char *\n-concat_option (char *dest, const char *pre, const char *path, const char *post)\n-{\n-  if (dest == NULL)\n-    {\n-      dest = (char *) xmalloc (strlen (pre) + strlen (path) + strlen (post) + 1);\n-      strcpy (dest, pre);\n-      strcat (dest, path);\n-      strcat (dest, post);\n-      return dest;\n-    }\n-  else\n-    {\n-      char *result = (char *) xmalloc (strlen (dest) + strlen (pre)\n-\t\t\t\t       + strlen (path) + strlen (post) + 1 + 1);\n-      strcpy (result, dest);\n-      strcat (result, \" \");\n-      strcat (result, pre);\n-      strcat (result, path);\n-      strcat (result, post);\n-      free (dest);\n-      return result;\n-    }\n-}\n-\n /* add_default_libs adds the -l option which is derived from the\n    libraries.  */\n "}, {"sha": "198088beeffa05d348cdf46b37e15296acdc01ac", "filename": "gcc/m2/m2.flex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fm2.flex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fm2.flex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fm2.flex?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -826,4 +826,4 @@ int yywrap (void)\n }\n \n EXTERN void _M2_m2flex_init (void) {}\n-EXTERN void _M2_m2flex_finish (void) {}\n+EXTERN void _M2_m2flex_fini (void) {}"}, {"sha": "21d1cb9dce73bae6e8f6a6c56b0ec2b8dd9be74e", "filename": "gcc/m2/m2pp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fm2pp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fm2pp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fm2pp.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -2068,7 +2068,7 @@ m2pp_integer_cst (pretty *s, tree t)\n {\n   char val[100];\n \n-  snprintf (val, 100, \"%lud\", TREE_INT_CST_LOW (t));\n+  snprintf (val, 100, HOST_WIDE_INT_PRINT_UNSIGNED, TREE_INT_CST_LOW (t));\n   m2pp_print (s, val);\n }\n "}, {"sha": "28a41c0427ade7e2fedf297cdeccc2bee7bd5c50", "filename": "gcc/m2/mc-boot-ch/GBuiltins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -38,6 +38,6 @@ _M2_Builtins_init (void)\n \n EXTERN\n void\n-_M2_Builtins_finish (void)\n+_M2_Builtins_fini (void)\n {\n }"}, {"sha": "cb6f5152f5ade8ad028b9208b87d04f57ce3a91c", "filename": "gcc/m2/mc-boot-ch/GRTco.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGRTco.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGRTco.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGRTco.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -122,6 +122,6 @@ _M2_RTco_init (void)\n \n EXTERN\n void\n-_M2_RTco_finish (void)\n+_M2_RTco_fini (void)\n {\n }"}, {"sha": "dc63f700f4b146121314060823cac746d1d0ae55", "filename": "gcc/m2/mc-boot-ch/GSYSTEM.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSYSTEM.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSYSTEM.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGSYSTEM.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -33,6 +33,6 @@ _M2_SYSTEM_init (int argc, char *p)\n \n EXTERN\n void\n-_M2_SYSTEM_finish (int argc, char *p)\n+_M2_SYSTEM_fini (int argc, char *p)\n {\n }"}, {"sha": "e41e848986d037eb0fd247ab60582065b5894445", "filename": "gcc/m2/mc-boot-ch/GSelective.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSelective.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSelective.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGSelective.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46", "patch": "@@ -270,6 +270,6 @@ _M2_Selective_init ()\n \n EXTERN\n void\n-_M2_Selective_finish ()\n+_M2_Selective_fini ()\n {\n }"}, {"sha": "d39827e76235a23d906f976e23bcf6da90d90267", "filename": "gcc/m2/mc-boot-ch/GSysExceptions.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSysExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGSysExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGSysExceptions.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "29b8ec273232316ed9b5622c9963fc94053ba94f", "filename": "gcc/m2/mc-boot-ch/GUnixArgs.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "77a7ae50e020576149128e1b6ebd9f286b49fe73", "filename": "gcc/m2/mc-boot-ch/Gdtoa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "c65c48630afce3e388aab42999dacef69c833094", "filename": "gcc/m2/mc-boot-ch/Gerrno.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "a918cfc2d67bdd729a9104ce613ffceb4e4b4fcb", "filename": "gcc/m2/mc-boot-ch/Gldtoa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "e6f6ac898b308fbc0fd5c544c46a79e80ae1cb20", "filename": "gcc/m2/mc-boot-ch/Gtermios.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGtermios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGtermios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGtermios.cc?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "5753f5db8e28ba7d488d5503d13de84a185694ef", "filename": "gcc/m2/mc-boot-ch/Gwrapc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGwrapc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot-ch%2FGwrapc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGwrapc.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "2f768ce24c816040e6031ce9b5d39d772e1b52cb", "filename": "gcc/m2/mc-boot/GASCII.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGASCII.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGASCII.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGASCII.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "106ddfd30c6e2671b123ffb7a39ca9f6c61469a1", "filename": "gcc/m2/mc-boot/GArgs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGArgs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGArgs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGArgs.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "21ee6c0b2f24c9cc489b802c6590a14cdb3332af", "filename": "gcc/m2/mc-boot/GAssertion.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGAssertion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGAssertion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGAssertion.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "9be003bd619cf505cb4958b45f195e10c20e19b1", "filename": "gcc/m2/mc-boot/GBreak.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGBreak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGBreak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGBreak.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "c304a4071825e8dd508c62108f47dc6d3d80824b", "filename": "gcc/m2/mc-boot/GCmdArgs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "6329abb11b1665a1043c38f838d927169e6259e8", "filename": "gcc/m2/mc-boot/GDebug.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGDebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGDebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDebug.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "dfc163646bb212794a0fc48e51b3f5666410b52d", "filename": "gcc/m2/mc-boot/GDynamicStrings.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "aa5e76628730125f277762e90c2646cbcb28de44", "filename": "gcc/m2/mc-boot/GEnvironment.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGEnvironment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGEnvironment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGEnvironment.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "1ae6bb63f20073a3984cf844ac534b1a33d12c5d", "filename": "gcc/m2/mc-boot/GFIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "78e7a5a559c52b2036cee839a5e134bdf4322d76", "filename": "gcc/m2/mc-boot/GFormatStrings.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "205c27b811e146dd74d061788a942bca71849207", "filename": "gcc/m2/mc-boot/GFpuIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFpuIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGFpuIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFpuIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "e56c74382f535ae09885161c77f412eb26483cef", "filename": "gcc/m2/mc-boot/GIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "0817ff36ca258e57ffb27a8edf5e2dcf04628fcc", "filename": "gcc/m2/mc-boot/GIndexing.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIndexing.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "0057018c97929da4194a21681f463ff0231a673f", "filename": "gcc/m2/mc-boot/GM2Dependent.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "387b04764624d6e8cfe4f1ade5ff4c79cc9024cb", "filename": "gcc/m2/mc-boot/GM2EXCEPTION.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "8a65ae2a116a19a57d6b1d727ffbe1c5c9c6111e", "filename": "gcc/m2/mc-boot/GM2RTS.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "8e95e9c79b873b7a764ec47a435761f703a2aa38", "filename": "gcc/m2/mc-boot/GM2RTS.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "a80e00ecec8535f4ec7dacc69045576b3e014a64", "filename": "gcc/m2/mc-boot/GMemUtils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGMemUtils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGMemUtils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGMemUtils.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "53bac45552c01eb1b16f8e141e9c85e8b0222ca6", "filename": "gcc/m2/mc-boot/GNumberIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGNumberIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGNumberIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGNumberIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "e15b3eb9007926e9cbf6380eaca84f82445dc86c", "filename": "gcc/m2/mc-boot/GPushBackInput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "23f8fede117bc6ab07278b8922e944adc2adddbc", "filename": "gcc/m2/mc-boot/GRTExceptions.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "3f8e64dc7f30828f20ed7206e1d46bfb3b9c1214", "filename": "gcc/m2/mc-boot/GRTExceptions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "180c495a9a2caf9d1d9b669371108c0a013f48c4", "filename": "gcc/m2/mc-boot/GRTco.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTco.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTco.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTco.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "9fc2492b1238b8236201e7530c4a3367186a96da", "filename": "gcc/m2/mc-boot/GRTentity.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTentity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTentity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTentity.h?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "bc83e46c27998932654108b1e1f0bb0aae508b25", "filename": "gcc/m2/mc-boot/GRTint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTint.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "143d2783c16e18091b22a37e39580cbfe23360e4", "filename": "gcc/m2/mc-boot/GSArgs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGSArgs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGSArgs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSArgs.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "1a800138812c9895dee4a0d5a5d7a1072da13d81", "filename": "gcc/m2/mc-boot/GSFIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGSFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGSFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSFIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "41affe2a054d55d0590c1ce55cabb91f57be6fa4", "filename": "gcc/m2/mc-boot/GStdIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStdIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStdIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStdIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "5dac021d8665af0cd09e4787e70e75d776ae2202", "filename": "gcc/m2/mc-boot/GStorage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStorage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStorage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStorage.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "e3491b6d75b1656f269a4fb663d1ab65f46b63ea", "filename": "gcc/m2/mc-boot/GStrCase.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStrCase.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStrCase.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStrCase.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}, {"sha": "1e091bce54564e3ccf80b3e03ecbbefe3f94b394", "filename": "gcc/m2/mc-boot/GStrIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStrIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4670ff8f39029d6a617d76fe9b59c154f89a46/gcc%2Fm2%2Fmc-boot%2FGStrIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStrIO.c?ref=cf4670ff8f39029d6a617d76fe9b59c154f89a46"}]}