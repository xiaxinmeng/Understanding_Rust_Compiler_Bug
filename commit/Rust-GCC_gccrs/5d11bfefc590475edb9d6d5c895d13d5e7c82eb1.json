{"sha": "5d11bfefc590475edb9d6d5c895d13d5e7c82eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQxMWJmZWZjNTkwNDc1ZWRiOWQ2ZDVjODk1ZDEzZDVlN2M4MmViMQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-17T15:48:42Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-17T15:48:42Z"}, "message": "libphobos: Add IEEE quadruple support for std.conv\n\nBackport from upstream phobos 2.079 for AArch64.\n\nReviewed-on: https://github.com/dlang/phobos/pull/5965\n\nFrom-SVN: r266238", "tree": {"sha": "078d7bbf4f3630c9d698b453caa58e88f9f31b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/078d7bbf4f3630c9d698b453caa58e88f9f31b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1/comments", "author": null, "committer": null, "parents": [{"sha": "d11be094c716885475a4a1562a967e4a127ecece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11be094c716885475a4a1562a967e4a127ecece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11be094c716885475a4a1562a967e4a127ecece"}], "stats": {"total": 378, "additions": 122, "deletions": 256}, "files": [{"sha": "76ac53213821aec812f64bfc38881d6f9a6cfaed", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 122, "deletions": 256, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d11bfefc590475edb9d6d5c895d13d5e7c82eb1/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=5d11bfefc590475edb9d6d5c895d13d5e7c82eb1", "patch": "@@ -2644,7 +2644,6 @@ Target parse(Target, Source)(ref Source source)\n if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum) &&\n     isFloatingPoint!Target && !is(Target == enum))\n {\n-    import core.stdc.math : HUGE_VAL;\n     import std.ascii : isDigit, isAlpha, toLower, toUpper, isHexDigit;\n     import std.exception : enforce;\n \n@@ -2669,7 +2668,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     {\n         if (msg == null)\n             msg = \"Floating point conversion error\";\n-        return new ConvException(text(msg, \" for input \\\"\", p, \"\\\".\"), fn, ln);\n+        return new ConvException(text(msg, \" for input \\\"\", source, \"\\\".\"), fn, ln);\n     }\n \n \n@@ -2684,29 +2683,24 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         enforce(!p.empty, bailOut());\n         if (toLower(p.front) == 'i')\n             goto case 'i';\n-        enforce(!p.empty, bailOut());\n         break;\n     case '+':\n         p.popFront();\n         enforce(!p.empty, bailOut());\n         break;\n     case 'i': case 'I':\n+        // inf\n         p.popFront();\n-        enforce(!p.empty, bailOut());\n-        if (toLower(p.front) == 'n')\n-        {\n-            p.popFront();\n-            enforce(!p.empty, bailOut());\n-            if (toLower(p.front) == 'f')\n-            {\n-                // 'inf'\n-                p.popFront();\n-                static if (isNarrowString!Source)\n-                    source = cast(Source) p;\n-                return sign ? -Target.infinity : Target.infinity;\n-            }\n-        }\n-        goto default;\n+        enforce(!p.empty && toUpper(p.front) == 'N',\n+               bailOut(\"error converting input to floating point\"));\n+        p.popFront();\n+        enforce(!p.empty && toUpper(p.front) == 'F',\n+               bailOut(\"error converting input to floating point\"));\n+        // skip past the last 'f'\n+        p.popFront();\n+        static if (isNarrowString!Source)\n+            source = cast(Source) p;\n+        return sign ? -Target.infinity : Target.infinity;\n     default: {}\n     }\n \n@@ -2723,247 +2717,97 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         }\n \n         isHex = p.front == 'x' || p.front == 'X';\n+        if (isHex) p.popFront();\n     }\n+    else if (toLower(p.front) == 'n')\n+    {\n+        // nan\n+        p.popFront();\n+        enforce(!p.empty && toUpper(p.front) == 'A',\n+               bailOut(\"error converting input to floating point\"));\n+        p.popFront();\n+        enforce(!p.empty && toUpper(p.front) == 'N',\n+               bailOut(\"error converting input to floating point\"));\n+        // skip past the last 'n'\n+        p.popFront();\n+        static if (isNarrowString!Source)\n+            source = cast(Source) p;\n+        return typeof(return).nan;\n+    }\n+\n+    /*\n+     * The following algorithm consists of 2 steps:\n+     * 1) parseDigits processes the textual input into msdec and possibly\n+     *    lsdec/msscale variables, followed by the exponent parser which sets\n+     *    exp below.\n+     *    Hex: input is 0xaaaaa...p+000... where aaaa is the mantissa in hex\n+     *    and 000 is the exponent in decimal format with base 2.\n+     *    Decimal: input is 0.00333...p+000... where 0.0033 is the mantissa\n+     *    in decimal and 000 is the exponent in decimal format with base 10.\n+     * 2) Convert msdec/lsdec and exp into native real format\n+     */\n \n     real ldval = 0.0;\n     char dot = 0;                        /* if decimal point has been seen */\n     int exp = 0;\n-    long msdec = 0, lsdec = 0;\n+    ulong msdec = 0, lsdec = 0;\n     ulong msscale = 1;\n+    bool sawDigits;\n \n-    if (isHex)\n-    {\n-        int guard = 0;\n-        int anydigits = 0;\n-        uint ndigits = 0;\n-\n-        p.popFront();\n-        while (!p.empty)\n-        {\n-            int i = p.front;\n-            while (isHexDigit(i))\n-            {\n-                anydigits = 1;\n-                i = isAlpha(i) ? ((i & ~0x20) - ('A' - 10)) : i - '0';\n-                if (ndigits < 16)\n-                {\n-                    msdec = msdec * 16 + i;\n-                    if (msdec)\n-                        ndigits++;\n-                }\n-                else if (ndigits == 16)\n-                {\n-                    while (msdec >= 0)\n-                    {\n-                        exp--;\n-                        msdec <<= 1;\n-                        i <<= 1;\n-                        if (i & 0x10)\n-                            msdec |= 1;\n-                    }\n-                    guard = i << 4;\n-                    ndigits++;\n-                    exp += 4;\n-                }\n-                else\n-                {\n-                    guard |= i;\n-                    exp += 4;\n-                }\n-                exp -= dot;\n-                p.popFront();\n-                if (p.empty)\n-                    break;\n-                i = p.front;\n-                if (i == '_')\n-                {\n-                    p.popFront();\n-                    if (p.empty)\n-                        break;\n-                    i = p.front;\n-                }\n-            }\n-            if (i == '.' && !dot)\n-            {\n-                p.popFront();\n-                dot = 4;\n-            }\n-            else\n-                break;\n-        }\n-\n-        // Round up if (guard && (sticky || odd))\n-        if (guard & 0x80 && (guard & 0x7F || msdec & 1))\n-        {\n-            msdec++;\n-            if (msdec == 0)                 // overflow\n-            {\n-                msdec = 0x8000000000000000L;\n-                exp++;\n-            }\n-        }\n-\n-        enforce(anydigits, bailOut());\n-        enforce(!p.empty && (p.front == 'p' || p.front == 'P'),\n-                bailOut(\"Floating point parsing: exponent is required\"));\n-        char sexp;\n-        int e;\n-\n-        sexp = 0;\n-        p.popFront();\n-        if (!p.empty)\n-        {\n-            switch (p.front)\n-            {\n-                case '-':    sexp++;\n-                             goto case;\n-                case '+':    p.popFront(); enforce(!p.empty,\n-                                new ConvException(\"Error converting input\"~\n-                                \" to floating point\"));\n-                             break;\n-                default: {}\n-            }\n-        }\n-        ndigits = 0;\n-        e = 0;\n-        while (!p.empty && isDigit(p.front))\n-        {\n-            if (e < 0x7FFFFFFF / 10 - 10) // prevent integer overflow\n-            {\n-                e = e * 10 + p.front - '0';\n-            }\n-            p.popFront();\n-            ndigits = 1;\n-        }\n-        exp += (sexp) ? -e : e;\n-        enforce(ndigits, new ConvException(\"Error converting input\"~\n-                        \" to floating point\"));\n+    enum { hex, decimal }\n \n-        static if (real.mant_dig == 64)\n+    // sets msdec, lsdec/msscale, and sawDigits by parsing the mantissa digits\n+    void parseDigits(alias FloatFormat)()\n+    {\n+        static if (FloatFormat == hex)\n         {\n-            if (msdec)\n-            {\n-                int e2 = 0x3FFF + 63;\n-\n-                // left justify mantissa\n-                while (msdec >= 0)\n-                {\n-                    msdec <<= 1;\n-                    e2--;\n-                }\n-\n-                // Stuff mantissa directly into real\n-                ()@trusted{ *cast(long*)&ldval = msdec; }();\n-                ()@trusted{ (cast(ushort*)&ldval)[4] = cast(ushort) e2; }();\n-\n-                import std.math : ldexp;\n-\n-                // Exponent is power of 2, not power of 10\n-                ldval = ldexp(ldval,exp);\n-            }\n+            enum uint base = 16;\n+            enum ulong msscaleMax = 0x1000_0000_0000_0000UL; // largest power of 16 a ulong holds\n+            enum ubyte expIter = 4; // iterate the base-2 exponent by 4 for every hex digit\n+            alias checkDigit = isHexDigit;\n+            /*\n+             * convert letter to binary representation: First clear bit\n+             * to convert lower space chars to upperspace, then -('A'-10)\n+             * converts letter A to 10, letter B to 11, ...\n+             */\n+            alias convertDigit = (int x) => isAlpha(x) ? ((x & ~0x20) - ('A' - 10)) : x - '0';\n+            sawDigits = false;\n         }\n-        else static if (real.mant_dig == 53)\n+        else static if (FloatFormat == decimal)\n         {\n-            if (msdec)\n-            {\n-                //Exponent bias + 52:\n-                //After shifting 52 times left, exp must be 1\n-                int e2 = 0x3FF + 52;\n-\n-                // right justify mantissa\n-                // first 11 bits must be zero, rest is implied bit + mantissa\n-                // shift one time less, do rounding, shift again\n-                while ((msdec & 0xFFC0_0000_0000_0000) != 0)\n-                {\n-                    msdec  = ((cast(ulong) msdec) >> 1);\n-                    e2++;\n-                }\n-\n-                //Have to shift one more time\n-                //and do rounding\n-                if ((msdec & 0xFFE0_0000_0000_0000) != 0)\n-                {\n-                    auto roundUp = (msdec & 0x1);\n-\n-                    msdec  = ((cast(ulong) msdec) >> 1);\n-                    e2++;\n-                    if (roundUp)\n-                    {\n-                        msdec += 1;\n-                        //If mantissa was 0b1111... and we added +1\n-                        //the mantissa should be 0b10000 (think of implicit bit)\n-                        //and the exponent increased\n-                        if ((msdec & 0x0020_0000_0000_0000) != 0)\n-                        {\n-                            msdec = 0x0010_0000_0000_0000;\n-                            e2++;\n-                        }\n-                    }\n-                }\n-\n-\n-                // left justify mantissa\n-                // bit 11 must be 1\n-                while ((msdec & 0x0010_0000_0000_0000) == 0)\n-                {\n-                    msdec <<= 1;\n-                    e2--;\n-                }\n-\n-                // Stuff mantissa directly into double\n-                // (first including implicit bit)\n-                ()@trusted{ *cast(long *)&ldval = msdec; }();\n-                //Store exponent, now overwriting implicit bit\n-                ()@trusted{ *cast(long *)&ldval &= 0x000F_FFFF_FFFF_FFFF; }();\n-                ()@trusted{ *cast(long *)&ldval |= ((e2 & 0xFFFUL) << 52); }();\n-\n-                import std.math : ldexp;\n-\n-                // Exponent is power of 2, not power of 10\n-                ldval = ldexp(ldval,exp);\n-            }\n+            enum uint base = 10;\n+            enum ulong msscaleMax = 10_000_000_000_000_000_000UL; // largest power of 10 a ulong holds\n+            enum ubyte expIter = 1; // iterate the base-10 exponent once for every decimal digit\n+            alias checkDigit = isDigit;\n+            alias convertDigit = (int x) => x - '0';\n+            // Used to enforce that any mantissa digits are present\n+            sawDigits = startsWithZero;\n         }\n         else\n-            static assert(false, \"Floating point format of real type not supported\");\n-\n-        goto L6;\n-    }\n-    else // not hex\n-    {\n-        if (toUpper(p.front) == 'N' && !startsWithZero)\n-        {\n-            // nan\n-            p.popFront();\n-            enforce(!p.empty && toUpper(p.front) == 'A',\n-                   new ConvException(\"error converting input to floating point\"));\n-            p.popFront();\n-            enforce(!p.empty && toUpper(p.front) == 'N',\n-                   new ConvException(\"error converting input to floating point\"));\n-            // skip past the last 'n'\n-            p.popFront();\n-            static if (isNarrowString!Source)\n-                source = cast(Source) p;\n-            return typeof(return).nan;\n-        }\n-\n-        bool sawDigits = startsWithZero;\n+            static assert(false, \"Unrecognized floating-point format used.\");\n \n         while (!p.empty)\n         {\n             int i = p.front;\n-            while (isDigit(i))\n+            while (checkDigit(i))\n             {\n                 sawDigits = true;        /* must have at least 1 digit   */\n-                if (msdec < (0x7FFFFFFFFFFFL-10)/10)\n-                    msdec = msdec * 10 + (i - '0');\n-                else if (msscale < (0xFFFFFFFF-10)/10)\n+\n+                i = convertDigit(i);\n+\n+                if (msdec < (ulong.max - base)/base)\n+                {\n+                    // For base 16: Y = ... + y3*16^3 + y2*16^2 + y1*16^1 + y0*16^0\n+                    msdec = msdec * base + i;\n+                }\n+                else if (msscale < msscaleMax)\n                 {\n-                    lsdec = lsdec * 10 + (i - '0');\n-                    msscale *= 10;\n+                    lsdec = lsdec * base + i;\n+                    msscale *= base;\n                 }\n                 else\n                 {\n-                    exp++;\n+                    exp += expIter;\n                 }\n                 exp -= dot;\n                 p.popFront();\n@@ -2981,21 +2825,29 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n             if (i == '.' && !dot)\n             {\n                 p.popFront();\n-                dot++;\n+                dot += expIter;\n             }\n             else\n-            {\n                 break;\n-            }\n         }\n-        enforce(sawDigits, new ConvException(\"no digits seen\"));\n+\n+        // Have we seen any mantissa digits so far?\n+        enforce(sawDigits, bailOut(\"no digits seen\"));\n+        static if (FloatFormat == hex)\n+            enforce(!p.empty && (p.front == 'p' || p.front == 'P'),\n+                    bailOut(\"Floating point parsing: exponent is required\"));\n     }\n-    if (!p.empty && (p.front == 'e' || p.front == 'E'))\n+\n+    if (isHex)\n+        parseDigits!hex;\n+    else\n+        parseDigits!decimal;\n+\n+    if (isHex || (!p.empty && (p.front == 'e' || p.front == 'E')))\n     {\n-        char sexp;\n-        int e;\n+        char sexp = 0;\n+        int e = 0;\n \n-        sexp = 0;\n         p.popFront();\n         enforce(!p.empty, new ConvException(\"Unexpected end of input\"));\n         switch (p.front)\n@@ -3006,16 +2858,15 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n                          break;\n             default: {}\n         }\n-        bool sawDigits = 0;\n-        e = 0;\n+        sawDigits = false;\n         while (!p.empty && isDigit(p.front))\n         {\n             if (e < 0x7FFFFFFF / 10 - 10)   // prevent integer overflow\n             {\n                 e = e * 10 + p.front - '0';\n             }\n             p.popFront();\n-            sawDigits = 1;\n+            sawDigits = true;\n         }\n         exp += (sexp) ? -e : e;\n         enforce(sawDigits, new ConvException(\"No digits seen.\"));\n@@ -3024,7 +2875,14 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     ldval = msdec;\n     if (msscale != 1)               /* if stuff was accumulated in lsdec */\n         ldval = ldval * msscale + lsdec;\n-    if (ldval)\n+    if (isHex)\n+    {\n+        import std.math : ldexp;\n+\n+        // Exponent is power of 2, not power of 10\n+        ldval = ldexp(ldval,exp);\n+    }\n+    else if (ldval)\n     {\n         uint u = 0;\n         int pow = 4096;\n@@ -3051,10 +2909,10 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n             u++;\n         }\n     }\n-  L6: // if overflow occurred\n-    enforce(ldval != HUGE_VAL, new ConvException(\"Range error\"));\n \n-  L1:\n+    // if overflow occurred\n+    enforce(ldval != real.infinity, new ConvException(\"Range error\"));\n+\n     static if (isNarrowString!Source)\n         source = cast(Source) p;\n     return sign ? -ldval : ldval;\n@@ -3232,15 +3090,20 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n {\n     import core.stdc.errno;\n     import core.stdc.stdlib;\n+    import std.math : floatTraits, RealFormat;\n \n     errno = 0;  // In case it was set by another unittest in a different module.\n     struct longdouble\n     {\n-        static if (real.mant_dig == 64)\n+        static if (floatTraits!real.realFormat == RealFormat.ieeeQuadruple)\n+        {\n+            ushort[8] value;\n+        }\n+        else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended)\n         {\n             ushort[5] value;\n         }\n-        else static if (real.mant_dig == 53)\n+        else static if (floatTraits!real.realFormat == RealFormat.ieeeDouble)\n         {\n             ushort[4] value;\n         }\n@@ -3254,9 +3117,12 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     longdouble x1;\n     int i;\n \n-    static if (real.mant_dig == 64)\n+    static if (floatTraits!real.realFormat == RealFormat.ieeeQuadruple)\n+        // Our parser is currently limited to ieeeExtended precision\n+        enum s = \"0x1.FFFFFFFFFFFFFFFEp-16382\";\n+    else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended)\n         enum s = \"0x1.FFFFFFFFFFFFFFFEp-16382\";\n-    else static if (real.mant_dig == 53)\n+    else static if (floatTraits!real.realFormat == RealFormat.ieeeDouble)\n         enum s = \"0x1.FFFFFFFFFFFFFFFEp-1000\";\n     else\n         static assert(false, \"Floating point format for real not supported\");\n@@ -3266,7 +3132,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     assert(s2.empty);\n     x = *cast(longdouble *)&ld;\n \n-    static if (real.mant_dig == 64)\n+    static if (floatTraits!real.realFormat == RealFormat.ieeeExtended)\n     {\n         version (CRuntime_Microsoft)\n             ld1 = 0x1.FFFFFFFFFFFFFFFEp-16382L; // strtold currently mapped to strtod"}]}