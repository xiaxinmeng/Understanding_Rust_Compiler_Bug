{"sha": "827555ea3e83a504d34d5aae66cb7838a170790e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3NTU1ZWEzZTgzYTUwNGQzNGQ1YWFlNjZjYjc4MzhhMTcwNzkwZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-04-22T07:03:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-04-22T07:03:00Z"}, "message": "invoke.texi: Remove the MIPS -membedded-pic option.\n\n\t* doc/invoke.texi: Remove the MIPS -membedded-pic option.\n\t* config/mips/mips-protos.h (embedded_pic_fnaddr_reg): Delete.\n\t(embedded_pic_offset): Delete.\n\t* config/mips/mips.h (MASK_EMBEDDED_PIC): Delete.  Shuffle other\n\tMASK_* constants.\n\t(TARGET_EMBEDDED_PIC): Delete.\n\t(TARGET_SWITCHES): Remove -m{no-,}embedded-pic.\n\t(ASM_SPEC): Remove -membedded-pic.\n\t(ASM_OUTPUT_ADDR_DIFF_ELT): Remove embedded-pic handling.\n\t(ASM_OUTPUT_CASE_LABEL): Likewise.\n\t* config/mips/vxworks.h (ASM_SPEC): Remove -membedded-pic.\n\t* config/mips/windiss.h (ASM_SPEC): Likewise.\n\t* config/mips/mips.c (struct machine_function): Remove\n\tembedded_pic_fnaddr_rtx.\n\t(TARGET_ENCODE_SECTION_INFO): Remove override.\n\t(embedded_pic_fnaddr_reg, embedded_pic_offset): Delete.\n\t(override_options): Remove -membedded-pic handling.\n\t(print_operand): Remove handling of '%S'.\n\t(mips_select_section: Remove -membedded-pic handling.\n\t(mips_encode_section_info): Delete.\n\t(mips_output_conditional_branch): Remove mention of -membedded-pic.\n\t* config/mips/mips.md (define_attr length, movsi, movdi, jump): Remove\n\t-membedded-pic handling.\n\t(casesi, casesi_internal, casesi_internal_di, get_fnaddr): Delete.\n\nFrom-SVN: r81007", "tree": {"sha": "67df704a1a147342aeeb5a13a1e4b2a831d0b31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67df704a1a147342aeeb5a13a1e4b2a831d0b31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/827555ea3e83a504d34d5aae66cb7838a170790e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827555ea3e83a504d34d5aae66cb7838a170790e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827555ea3e83a504d34d5aae66cb7838a170790e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827555ea3e83a504d34d5aae66cb7838a170790e/comments", "author": null, "committer": null, "parents": [{"sha": "e930d01a4fb071e00edb80bc0c5a878733394bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e930d01a4fb071e00edb80bc0c5a878733394bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e930d01a4fb071e00edb80bc0c5a878733394bbf"}], "stats": {"total": 398, "additions": 60, "deletions": 338}, "files": [{"sha": "caca85bdf3e5b1a80350f30fb14f7d30ee6dcb7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -1,3 +1,30 @@\n+2004-04-22  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* doc/invoke.texi: Remove the MIPS -membedded-pic option.\n+\t* config/mips/mips-protos.h (embedded_pic_fnaddr_reg): Delete.\n+\t(embedded_pic_offset): Delete.\n+\t* config/mips/mips.h (MASK_EMBEDDED_PIC): Delete.  Shuffle other\n+\tMASK_* constants.\n+\t(TARGET_EMBEDDED_PIC): Delete.\n+\t(TARGET_SWITCHES): Remove -m{no-,}embedded-pic.\n+\t(ASM_SPEC): Remove -membedded-pic.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Remove embedded-pic handling.\n+\t(ASM_OUTPUT_CASE_LABEL): Likewise.\n+\t* config/mips/vxworks.h (ASM_SPEC): Remove -membedded-pic.\n+\t* config/mips/windiss.h (ASM_SPEC): Likewise.\n+\t* config/mips/mips.c (struct machine_function): Remove\n+\tembedded_pic_fnaddr_rtx.\n+\t(TARGET_ENCODE_SECTION_INFO): Remove override.\n+\t(embedded_pic_fnaddr_reg, embedded_pic_offset): Delete.\n+\t(override_options): Remove -membedded-pic handling.\n+\t(print_operand): Remove handling of '%S'.\n+\t(mips_select_section: Remove -membedded-pic handling.\n+\t(mips_encode_section_info): Delete.\n+\t(mips_output_conditional_branch): Remove mention of -membedded-pic.\n+\t* config/mips/mips.md (define_attr length, movsi, movdi, jump): Remove\n+\t-membedded-pic handling.\n+\t(casesi, casesi_internal, casesi_internal_di, get_fnaddr): Delete.\n+\n 2004-04-22  Alan Modra  <amodra@bigpond.net.au>\n \n \t* var-tracking.c (frame_base_decl): Remove useless GTY."}, {"sha": "761cf470b3d11f6014975a4dd976e447bf1a6958", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -117,8 +117,6 @@ extern int m16_nuimm8_4 (rtx, enum machine_mode);\n extern int m16_simm8_8 (rtx, enum machine_mode);\n extern int m16_nsimm8_8 (rtx, enum machine_mode);\n \n-extern struct rtx_def *embedded_pic_fnaddr_reg (void);\n-extern struct rtx_def *embedded_pic_offset (rtx);\n extern rtx mips_subword (rtx, int);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_64bit_move (rtx, rtx);"}, {"sha": "9720c7dda4e012220005ac19c996f237ccae8ec4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -206,7 +206,6 @@ static void mips_select_rtx_section (enum machine_mode, rtx,\n static void mips_select_section (tree, int, unsigned HOST_WIDE_INT)\n \t\t\t\t  ATTRIBUTE_UNUSED;\n static bool mips_in_small_data_p (tree);\n-static void mips_encode_section_info (tree, rtx, int);\n static int mips_fpr_return_fields (tree, tree *);\n static bool mips_return_in_msb (tree);\n static rtx mips_return_fpr_pair (enum machine_mode mode,\n@@ -274,10 +273,6 @@ struct mips_frame_info GTY(())\n };\n \n struct machine_function GTY(()) {\n-  /* Pseudo-reg holding the address of the current function when\n-     generating embedded PIC code.  */\n-  rtx embedded_pic_fnaddr_rtx;\n-\n   /* Pseudo-reg holding the value of $28 in a mips16 function which\n      refers to GP relative global variables.  */\n   rtx mips16_gp_pseudo_rtx;\n@@ -695,8 +690,6 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST mips_address_cost\n \n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO mips_encode_section_info\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P mips_in_small_data_p\n \n@@ -2444,55 +2437,6 @@ mips_address_cost (rtx addr)\n   return mips_address_insns (addr, SImode);\n }\n \f\n-/* Return a pseudo that points to the address of the current function.\n-   The first time it is called for a function, an initializer for the\n-   pseudo is emitted in the beginning of the function.  */\n-\n-rtx\n-embedded_pic_fnaddr_reg (void)\n-{\n-  if (cfun->machine->embedded_pic_fnaddr_rtx == NULL)\n-    {\n-      rtx seq;\n-\n-      cfun->machine->embedded_pic_fnaddr_rtx = gen_reg_rtx (Pmode);\n-\n-      /* Output code at function start to initialize the pseudo-reg.  */\n-      /* ??? We used to do this in FINALIZE_PIC, but that does not work for\n-\t inline functions, because it is called after RTL for the function\n-\t has been copied.  The pseudo-reg in embedded_pic_fnaddr_rtx however\n-\t does not get copied, and ends up not matching the rest of the RTL.\n-\t This solution works, but means that we get unnecessary code to\n-\t initialize this value every time a function is inlined into another\n-\t function.  */\n-      start_sequence ();\n-      emit_insn (gen_get_fnaddr (cfun->machine->embedded_pic_fnaddr_rtx,\n-\t\t\t\t XEXP (DECL_RTL (current_function_decl), 0)));\n-      seq = get_insns ();\n-      end_sequence ();\n-      push_topmost_sequence ();\n-      emit_insn_after (seq, get_insns ());\n-      pop_topmost_sequence ();\n-    }\n-\n-  return cfun->machine->embedded_pic_fnaddr_rtx;\n-}\n-\n-/* Return RTL for the offset from the current function to the argument.\n-   X is the symbol whose offset from the current function we want.  */\n-\n-rtx\n-embedded_pic_offset (rtx x)\n-{\n-  /* Make sure it is emitted.  */\n-  embedded_pic_fnaddr_reg ();\n-\n-  return\n-    gen_rtx_CONST (Pmode,\n-\t\t   gen_rtx_MINUS (Pmode, x,\n-\t\t\t\t  XEXP (DECL_RTL (current_function_decl), 0)));\n-}\n-\f\n /* Return one word of double-word value OP, taking into account the fixed\n    endianness of certain registers.  HIGH_P is true to select the high part,\n    false to select the low part.  */\n@@ -4778,30 +4722,6 @@ override_options (void)\n   if (!targetm.have_named_sections)\n     mips_section_threshold = 0;\n \n-  /* -membedded-pic is a form of PIC code suitable for embedded\n-     systems.  All calls are made using PC relative addressing, and\n-     all data is addressed using the $gp register.  This requires gas,\n-     which does most of the work, and GNU ld, which automatically\n-     expands PC relative calls which are out of range into a longer\n-     instruction sequence.  All gcc really does differently is\n-     generate a different sequence for a switch.  */\n-  if (TARGET_EMBEDDED_PIC)\n-    {\n-      flag_pic = 1;\n-      if (TARGET_ABICALLS)\n-\twarning (\"-membedded-pic and -mabicalls are incompatible\");\n-\n-      if (g_switch_set)\n-\twarning (\"-G and -membedded-pic are incompatible\");\n-\n-      /* Setting mips_section_threshold is not required, because gas\n-\t will force everything to be GP addressable anyhow, but\n-\t setting it will cause gcc to make better estimates of the\n-\t number of instructions required to access a particular data\n-\t item.  */\n-      mips_section_threshold = 0x7fffffff;\n-    }\n-\n   /* mips_split_addresses is a half-way house between explicit\n      relocations and the traditional assembler macros.  It can\n      split absolute 32-bit symbolic constants into a high/lo_sum\n@@ -5255,7 +5175,6 @@ mips_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n    'F'  print part of opcode for a floating-point branch condition.\n    'N'  print part of opcode for a branch condition, inverted.\n    'W'  print part of opcode for a floating-point branch condition, inverted.\n-   'S'  OP is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n    'B'  print 'z' for EQ, 'n' for NE\n    'b'  print 'n' for EQ, 'z' for NE\n    'T'  print 'f' for EQ, 't' for NE\n@@ -5493,14 +5412,6 @@ print_operand (FILE *file, rtx op, int letter)\n   else if (letter == 'R')\n     print_operand_reloc (file, op, mips_lo_relocs);\n \n-  else if (letter == 'S')\n-    {\n-      char buffer[100];\n-\n-      ASM_GENERATE_INTERNAL_LABEL (buffer, \"LS\", CODE_LABEL_NUMBER (op));\n-      assemble_name (file, buffer);\n-    }\n-\n   else if (letter == 'Z')\n     {\n       register int regnum;\n@@ -7260,11 +7171,7 @@ static void\n mips_select_section (tree decl, int reloc,\n \t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_EMBEDDED_PIC && TREE_CODE (decl) == STRING_CST)\n-    /* For embedded position independent code, put constant strings in the\n-       text section, because the data section is limited to 64K in size.  */\n-    text_section ();\n-  else if (targetm.have_named_sections)\n+  if (targetm.have_named_sections)\n     default_elf_select_section (decl, reloc, align);\n   else\n     /* The native irix o32 assembler doesn't support named sections.  */\n@@ -7318,38 +7225,6 @@ mips_in_small_data_p (tree decl)\n   size = int_size_in_bytes (TREE_TYPE (decl));\n   return (size > 0 && size <= mips_section_threshold);\n }\n-\n-\n-/* When generating embedded PIC code, SYMBOL_REF_FLAG is set for\n-   symbols which are not in the .text section.  */\n-\n-static void\n-mips_encode_section_info (tree decl, rtx rtl, int first)\n-{\n-  rtx symbol;\n-\n-  if (GET_CODE (rtl) != MEM)\n-    return;\n-\n-  symbol = XEXP (rtl, 0);\n-\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return;\n-\n-  if (TARGET_EMBEDDED_PIC)\n-    {\n-      if (TREE_CODE (decl) == VAR_DECL)\n-        SYMBOL_REF_FLAG (symbol) = 1;\n-      else if (TREE_CODE (decl) == FUNCTION_DECL)\n-        SYMBOL_REF_FLAG (symbol) = 0;\n-      else if (TREE_CODE (decl) == STRING_CST)\n-        SYMBOL_REF_FLAG (symbol) = 0;\n-      else\n-        SYMBOL_REF_FLAG (symbol) = 1;\n-    }\n-\n-  default_encode_section_info (decl, rtl, first);\n-}\n \f\n /* See whether VALTYPE is a record whose fields should be returned in\n    floating-point registers.  If so, return the number of fields and\n@@ -8977,7 +8852,7 @@ mips_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n \t\t.set macro\n \t\t.set reorder\n \n-\t   When generating non-embedded PIC, instead of:\n+\t   When generating PIC, instead of:\n \n \t        j     target\n "}, {"sha": "73fbe712dc575180d6b5563dff83778fe380b51c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -154,24 +154,23 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define MASK_XGOT\t   0x00000800\t/* emit big-got PIC */\n #define MASK_LONG_CALLS\t   0x00001000\t/* Always call through a register */\n #define MASK_64BIT\t   0x00002000\t/* Use 64 bit GP registers and insns */\n-#define MASK_EMBEDDED_PIC  0x00004000\t/* Generate embedded PIC code */\n-#define MASK_EMBEDDED_DATA 0x00008000\t/* Reduce RAM usage, not fast code */\n-#define MASK_BIG_ENDIAN\t   0x00010000\t/* Generate big endian code */\n-#define MASK_SINGLE_FLOAT  0x00020000\t/* Only single precision FPU.  */\n-#define MASK_MAD\t   0x00040000\t/* Generate mad/madu as on 4650.  */\n-#define MASK_4300_MUL_FIX  0x00080000   /* Work-around early Vr4300 CPU bug */\n-#define MASK_MIPS16\t   0x00100000\t/* Generate mips16 code */\n+#define MASK_EMBEDDED_DATA 0x00004000\t/* Reduce RAM usage, not fast code */\n+#define MASK_BIG_ENDIAN\t   0x00008000\t/* Generate big endian code */\n+#define MASK_SINGLE_FLOAT  0x00010000\t/* Only single precision FPU.  */\n+#define MASK_MAD\t   0x00020000\t/* Generate mad/madu as on 4650.  */\n+#define MASK_4300_MUL_FIX  0x00040000   /* Work-around early Vr4300 CPU bug */\n+#define MASK_MIPS16\t   0x00080000\t/* Generate mips16 code */\n #define MASK_NO_CHECK_ZERO_DIV \\\n-\t\t\t   0x00200000\t/* divide by zero checking */\n-#define MASK_BRANCHLIKELY  0x00400000   /* Generate Branch Likely\n+\t\t\t   0x00100000\t/* divide by zero checking */\n+#define MASK_BRANCHLIKELY  0x00200000   /* Generate Branch Likely\n \t\t\t\t\t   instructions.  */\n #define MASK_UNINIT_CONST_IN_RODATA \\\n-\t\t\t   0x00800000\t/* Store uninitialized\n+\t\t\t   0x00400000\t/* Store uninitialized\n \t\t\t\t\t   consts in rodata */\n-#define MASK_FIX_R4000\t   0x01000000\t/* Work around R4000 errata.  */\n-#define MASK_FIX_R4400\t   0x02000000\t/* Work around R4400 errata.  */\n-#define MASK_FIX_SB1\t   0x04000000\t/* Work around SB-1 errata.  */\n-#define MASK_FIX_VR4120\t   0x08000000   /* Work around VR4120 errata.  */\n+#define MASK_FIX_R4000\t   0x00800000\t/* Work around R4000 errata.  */\n+#define MASK_FIX_R4400\t   0x01000000\t/* Work around R4400 errata.  */\n+#define MASK_FIX_SB1\t   0x02000000\t/* Work around SB-1 errata.  */\n+#define MASK_FIX_VR4120\t   0x04000000   /* Work around VR4120 errata.  */\n \n #define MASK_FP_EXCEPTIONS 0x10000000   /* FP exceptions are enabled.  */\n \n@@ -220,10 +219,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n \t\t\t\t\t/* always call through a register */\n #define TARGET_LONG_CALLS\t(target_flags & MASK_LONG_CALLS)\n \n-\t\t\t\t\t/* generate embedded PIC code;\n-\t\t\t\t\t   requires gas.  */\n-#define TARGET_EMBEDDED_PIC\t(target_flags & MASK_EMBEDDED_PIC)\n-\n \t\t\t\t\t/* for embedded systems, optimize for\n \t\t\t\t\t   reduced RAM space instead of for\n \t\t\t\t\t   fastest code.  */\n@@ -567,10 +562,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Use indirect calls\")},\t\t\t\t\t\t\\\n   {\"no-long-calls\",\t -MASK_LONG_CALLS,\t\t\t\t\\\n      N_(\"Don't use indirect calls\")},\t\t\t\t\t\\\n-  {\"embedded-pic\",\t  MASK_EMBEDDED_PIC,\t\t\t\t\\\n-     N_(\"Use embedded PIC\")},\t\t\t\t\t\t\\\n-  {\"no-embedded-pic\",\t -MASK_EMBEDDED_PIC,\t\t\t\t\\\n-     N_(\"Don't use embedded PIC\")},\t\t\t\t\t\\\n   {\"embedded-data\",\t  MASK_EMBEDDED_DATA,\t\t\t\t\\\n      N_(\"Use ROM instead of RAM\")},\t\t\t\t\t\\\n   {\"no-embedded-data\",\t -MASK_EMBEDDED_DATA,\t\t\t\t\\\n@@ -1130,7 +1121,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n %{mfix-vr4120} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n-%{membedded-pic} \\\n %{mabi=32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n %{mabi=eabi} %{mabi=o64} %{!mabi*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\\n@@ -3213,19 +3203,15 @@ while (0)\n \t   LOCAL_LABEL_PREFIX,\t\t\t\t\t\t\\\n \t   VALUE)\n \n-/* This is how to output an element of a case-vector that is relative.\n-   This is used for pc-relative code (e.g. when TARGET_ABICALLS or\n-   TARGET_EMBEDDED_PIC).  */\n+/* This is how to output an element of a case-vector.  We can make the\n+   entries PC-relative in MIPS16 code and GP-relative when .gp(d)word\n+   is supported.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t.half\\t%sL%d-%sL%d\\n\",\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n-  else if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t%s\\t%sL%d-%sLS%d\\n\",\t\t\t\t\\\n-\t     ptr_mode == DImode ? \".dword\" : \".word\",\t\t\t\\\n-\t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n   else if (TARGET_GPWORD)\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n \t     ptr_mode == DImode ? \".gpdword\" : \".gpword\",\t\t\\\n@@ -3236,16 +3222,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n } while (0)\n \n-/* When generating embedded PIC or mips16 code we want to put the jump\n-   table in the .text section.  In all other cases, we want to put the\n-   jump table in the .rdata section.  Unfortunately, we can't use\n-   JUMP_TABLES_IN_TEXT_SECTION, because it is not conditional.\n-   Instead, we use ASM_OUTPUT_CASE_LABEL to switch back to the .text\n-   section if appropriate.  */\n+/* When generating mips16 code we want to put the jump table in the .text\n+   section.  In all other cases, we want to put the jump table in the .rdata\n+   section.  Unfortunately, we can't use JUMP_TABLES_IN_TEXT_SECTION, because\n+   it is not conditional.  Instead, we use ASM_OUTPUT_CASE_LABEL to switch back\n+   to the .text section if appropriate.  */\n #undef ASM_OUTPUT_CASE_LABEL\n #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, INSN)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_EMBEDDED_PIC || TARGET_MIPS16)\t\t\t\t\\\n+  if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n     function_section (current_function_decl);\t\t\t\t\\\n   (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);\t\t\\\n } while (0)"}, {"sha": "7f36d63f0b5e9e25bb22473e9c4fa2f28f6b9630", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 6, "deletions": 157, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -173,8 +173,7 @@\n           (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 4))))\n                      (const_int 131072))\n                  (const_int 4)\n-\t\t (ne (symbol_ref \"flag_pic && ! TARGET_EMBEDDED_PIC\")\n-\t\t     (const_int 0))\n+\t\t (ne (symbol_ref \"flag_pic\") (const_int 0))\n \t\t (const_int 24)\n \t\t ] (const_int 12))\n \n@@ -4519,23 +4518,6 @@ dsrl\\t%3,%3,1\\n\\\n {\n   if (mips_legitimize_move (DImode, operands[0], operands[1]))\n     DONE;\n-\n-  /* If we are generating embedded PIC code, and we are referring to a\n-     symbol in the .text section, we must use an offset from the start\n-     of the function.  */\n-  if (TARGET_EMBEDDED_PIC\n-      && (GET_CODE (operands[1]) == LABEL_REF\n-\t  || (GET_CODE (operands[1]) == SYMBOL_REF\n-\t      && ! SYMBOL_REF_FLAG (operands[1]))))\n-    {\n-      rtx temp;\n-\n-      temp = embedded_pic_offset (operands[1]);\n-      temp = gen_rtx_PLUS (Pmode, embedded_pic_fnaddr_reg (),\n-\t\t\t   force_reg (DImode, temp));\n-      emit_move_insn (operands[0], force_reg (DImode, temp));\n-      DONE;\n-    }\n })\n \n ;; For mips16, we need a special case to handle storing $31 into\n@@ -4663,23 +4645,6 @@ dsrl\\t%3,%3,1\\n\\\n {\n   if (mips_legitimize_move (SImode, operands[0], operands[1]))\n     DONE;\n-\n-  /* If we are generating embedded PIC code, and we are referring to a\n-     symbol in the .text section, we must use an offset from the start\n-     of the function.  */\n-  if (TARGET_EMBEDDED_PIC\n-      && (GET_CODE (operands[1]) == LABEL_REF\n-\t  || (GET_CODE (operands[1]) == SYMBOL_REF\n-\t      && ! SYMBOL_REF_FLAG (operands[1]))))\n-    {\n-      rtx temp;\n-\n-      temp = embedded_pic_offset (operands[1]);\n-      temp = gen_rtx_PLUS (Pmode, embedded_pic_fnaddr_reg (),\n-\t\t\t   force_reg (SImode, temp));\n-      emit_move_insn (operands[0], force_reg (SImode, temp));\n-      DONE;\n-    }\n })\n \n ;; We can only store $ra directly into a small sp offset.\n@@ -8091,7 +8056,7 @@ srl\\t%M0,%M1,%2\\n\\\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"!TARGET_MIPS16\"\n {\n-  if (flag_pic && ! TARGET_EMBEDDED_PIC)\n+  if (flag_pic)\n     {\n       if (get_attr_length (insn) <= 8)\n \treturn \"%*b\\t%l0%/\";\n@@ -8107,12 +8072,11 @@ srl\\t%M0,%M1,%2\\n\\\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set (attr \"length\")\n-\t;; we can't use `j' when emitting non-embedded PIC, so we emit\n-\t;; branch, if it's in range, or load the address of the branch\n-\t;; target into $at in a PIC-compatible way and then jump to it.\n+\t;; We can't use `j' when emitting PIC.  Emit a branch if it's\n+\t;; in range, otherwise load the address of the branch target into\n+\t;; $at and then jump to it.\n \t(if_then_else\n-\t (ior (eq (symbol_ref \"flag_pic && ! TARGET_EMBEDDED_PIC\")\n-\t\t  (const_int 0))\n+\t (ior (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t      (lt (abs (minus (match_dup 0)\n \t\t\t      (plus (pc) (const_int 4))))\n \t\t  (const_int 131072)))\n@@ -8247,107 +8211,6 @@ srl\\t%M0,%M1,%2\\n\\\n   DONE;\n })\n \n-;; Implement a switch statement when generating embedded PIC code.\n-;; Switches are implemented by `tablejump' when not using -membedded-pic.\n-\n-(define_expand \"casesi\"\n-  [(set (match_dup 5)\n-\t(minus:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (cc0)\n-\t(compare:CC (match_dup 5)\n-\t\t    (match_operand:SI 2 \"arith_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))\n-   (parallel\n-    [(set (pc)\n-\t  (mem:SI (plus:SI (mult:SI (match_dup 5)\n-\t\t\t\t    (const_int 4))\n-\t\t\t   (label_ref (match_operand 3 \"\" \"\")))))\n-     (clobber (match_scratch:SI 6 \"\"))\n-     (clobber (reg:SI 31))])]\n-  \"TARGET_EMBEDDED_PIC\"\n-{\n-  rtx index;\n-\n-  /* If the index is too large, go to the default label.  */\n-  index = expand_binop (SImode, sub_optab, operands[0],\n-\t\t\toperands[1], 0, 0, OPTAB_WIDEN);\n-  emit_insn (gen_cmpsi (index, operands[2]));\n-  emit_insn (gen_bgtu (operands[4]));\n-\n-  /* Do the PIC jump.  */\n-  if (Pmode != DImode)\n-    emit_jump_insn (gen_casesi_internal (index, operands[3],\n-\t\t\t\t\t gen_reg_rtx (SImode)));\n-  else\n-    emit_jump_insn (gen_casesi_internal_di (index, operands[3],\n-\t\t\t\t\t    gen_reg_rtx (DImode)));\n-\n-  DONE;\n-})\n-\n-;; An embedded PIC switch statement looks like this:\n-;;\tbal\t$LS1\n-;;\tsll\t$reg,$index,2\n-;; $LS1:\n-;;\taddu\t$reg,$reg,$31\n-;;\tlw\t$reg,$L1-$LS1($reg)\n-;;\taddu\t$reg,$reg,$31\n-;;\tj\t$reg\n-;; $L1:\n-;;\t.word\tcase1-$LS1\n-;;\t.word\tcase2-$LS1\n-;;\t...\n-\n-(define_insn \"casesi_internal\"\n-  [(set (pc)\n-\t(mem:SI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (label_ref (match_operand 1 \"\" \"\")))))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))\n-   (clobber (reg:SI 31))]\n-  \"TARGET_EMBEDDED_PIC\"\n-  {\n-    if (set_nomacro)\n-      return \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,2\\\\n%~%S1:\\;addu\\\\t%2,%2,$31%)\\;\\\\\n-.set macro\\;lw\\\\t%2,%1-%S1(%2)\\;.set nomacro\\;addu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\";\n-    return\n-  \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,2\\\\n%~%S1:\\;addu\\\\t%2,%2,$31%)\\;\\\\\n-lw\\\\t%2,%1-%S1(%2)\\;addu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n-    ;\n-  }\n-  [(set_attr \"type\"\t\"jump\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"24\")])\n-\n-;; This code assumes that the table index will never be >= 29 bits wide,\n-;; which allows the 'sign extend' from SI to DI be a no-op.\n-(define_insn \"casesi_internal_di\"\n-  [(set (pc)\n-\t(mem:DI (plus:DI (sign_extend:DI\n-\t\t\t  (mult:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t\t  (const_int 8)))\n-\t\t\t (label_ref (match_operand 1 \"\" \"\")))))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=d\"))\n-   (clobber (reg:DI 31))]\n-  \"TARGET_EMBEDDED_PIC\"\n-  {\n-    if (set_nomacro)\n-      return \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,3\\\\n%~%S1:\\;daddu\\\\t%2,%2,$31%)\\;\\\\\n-.set macro\\;ld\\\\t%2,%1-%S1(%2)\\;.set nomacro\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\";\n-    return\n-  \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,3\\\\n%~%S1:\\;daddu\\\\t%2,%2,$31%)\\;\\\\\n-ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n-    ;\n-  }\n-  [(set_attr \"type\"\t\"jump\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"24\")])\n-\n ;; For TARGET_ABICALLS, we save the gp in the jmp_buf as well.\n ;; While it is possible to either pull it off the stack (in the\n ;; o32 case) or recalculate it given t9 and our target label,\n@@ -8461,20 +8324,6 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n-;; When generating embedded PIC code we need to get the address of the\n-;; current function.  This specialized instruction does just that.\n-\n-(define_insn \"get_fnaddr\"\n-  [(set (match_operand 0 \"register_operand\" \"=d\")\n-\t(unspec [(match_operand 1 \"\" \"\")] UNSPEC_GET_FNADDR))\n-   (clobber (reg:SI 31))]\n-  \"TARGET_EMBEDDED_PIC\n-   && GET_CODE (operands[1]) == SYMBOL_REF\"\n-  \"%($LF%= = . + 8\\;bal\\t$LF%=\\;nop;la\\t%0,%1-$LF%=%)\\;addu\\t%0,%0,$31\"\n-  [(set_attr \"type\"\t\"call\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"20\")])\n-\n ;; This is used in compiling the unwind routines.\n (define_expand \"eh_return\"\n   [(use (match_operand 0 \"general_operand\" \"\"))]"}, {"sha": "ed4459829a42cd814e5d17bf4a6fcb783fc8fec7", "filename": "gcc/config/mips/vxworks.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fvxworks.h?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -45,7 +45,6 @@ Boston, MA 02111-1307, USA.  */\n %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n-%{membedded-pic} \\\n %{mabi=32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n %{mabi=eabi} %{mabi=o64} %{!mabi*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\"}, {"sha": "156057f2de7cd16c3070deb9644745769e7c08ba", "filename": "gcc/config/mips/windiss.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fwindiss.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fconfig%2Fmips%2Fwindiss.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fwindiss.h?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -45,7 +45,6 @@ Boston, MA 02111-1307, USA.  */\n %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n-%{membedded-pic} \\\n %{mabi=32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n %{mabi=eabi} %{mabi=o64} %{!mabi*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\"}, {"sha": "7e2d95a2f579ab9f5c3b626061cc68926494c4cd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827555ea3e83a504d34d5aae66cb7838a170790e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=827555ea3e83a504d34d5aae66cb7838a170790e", "patch": "@@ -468,9 +468,9 @@ in the following sections.\n @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol\n -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2  -mips64 @gol\n -mips16  -mno-mips16  -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n--mxgot  -mno-xgot  -membedded-pic  -mno-embedded-pic @gol\n--mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol\n--msingle-float  -mdouble-float  -mint64  -mlong64  -mlong32 @gol\n+-mxgot  -mno-xgot  -mgp32  -mgp64  -mfp32  -mfp64 @gol\n+-mhard-float  -msoft-float  -msingle-float  -mdouble-float @gol\n+-mint64  -mlong64  -mlong32 @gol\n -G@var{num}  -membedded-data  -mno-embedded-data @gol\n -muninit-const-in-rodata  -mno-uninit-const-in-rodata @gol\n -msplit-addresses  -mno-split-addresses  @gol\n@@ -7924,16 +7924,6 @@ file accesses more than 64k's worth of GOT entries.  Very few do.\n These options have no effect unless GCC is generating position\n independent code.\n \n-@item -membedded-pic\n-@itemx -mno-embedded-pic\n-@opindex membedded-pic\n-@opindex mno-embedded-pic\n-Generate (do not generate) position-independent code suitable for some\n-embedded systems.  All calls are made using PC relative addresses, and\n-all data is addressed using the $gp register.  No more than 65536\n-bytes of global data may be used.  This requires GNU as and GNU ld,\n-which do most of the work.\n-\n @item -mgp32\n @opindex mgp32\n Assume that general-purpose registers are 32 bits wide."}]}