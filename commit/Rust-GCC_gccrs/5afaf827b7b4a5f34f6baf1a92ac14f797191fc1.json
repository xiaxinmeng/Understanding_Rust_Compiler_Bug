{"sha": "5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmYWY4MjdiN2I0YTVmMzRmNmJhZjFhOTJhYzE0Zjc5NzE5MWZjMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-20T10:32:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-20T10:32:58Z"}, "message": "[multiple changes]\n\n2009-06-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Build_Record_Init_Proc): When copying initial\n\texpressions (possibly from a parent type) indicate that the scope of\n\tthe new itypes is the initialization procedure being built.\n\n2009-06-20  Robert Dewar  <dewar@adacore.com>\n\n\t* a-nudira.adb (Fits_In_32_Bits): New name (inverted sense) for\n\tNeeds_64, and now computed without anomolies for some dynamic types.\n\n2009-06-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_prag.adb: Minor reformatting\n\n\t* exp_disp.ads: Minor reformatting\n\nFrom-SVN: r148745", "tree": {"sha": "14e8940ec3a79d88de808ea09f87f9763c2e7d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14e8940ec3a79d88de808ea09f87f9763c2e7d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/comments", "author": null, "committer": null, "parents": [{"sha": "e80d72ea16b37dd524c55fe9fd453cebd46c9fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d72ea16b37dd524c55fe9fd453cebd46c9fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80d72ea16b37dd524c55fe9fd453cebd46c9fa0"}], "stats": {"total": 90, "additions": 58, "deletions": 32}, "files": [{"sha": "f30a5c425b7855aca85bb094ae589c18c2f6475a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "patch": "@@ -1,3 +1,20 @@\n+2009-06-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Record_Init_Proc): When copying initial\n+\texpressions (possibly from a parent type) indicate that the scope of\n+\tthe new itypes is the initialization procedure being built.\n+\n+2009-06-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-nudira.adb (Fits_In_32_Bits): New name (inverted sense) for\n+\tNeeds_64, and now computed without anomolies for some dynamic types.\n+\n+2009-06-20  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_prag.adb: Minor reformatting\n+\n+\t* exp_disp.ads: Minor reformatting\n+\n 2009-06-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Is_OK_For_Limited_Init): An unchecked conversion of a"}, {"sha": "3ed4fedfe14c44698d0372b1d771ecd24eb08a19", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "patch": "@@ -51,24 +51,34 @@ package body Ada.Numerics.Discrete_Random is\n \n    type Pointer is access all State;\n \n-   Need_64 : constant Boolean := Rst'Pos (Rst'Last) > 2**31 - 1\n-                                   or else\n-                                 Rst'Pos (Rst'First) < 2**31;\n-   --  Set if we need more than 32 bits in the result. In practice we will\n-   --  only use the meaningful 48 bits of any 64 bit number generated, since\n-   --  if more than 48 bits are required, we split the computation into two\n-   --  separate parts, since the algorithm does not behave above 48 bits.\n+   Fits_In_32_Bits : constant Boolean :=\n+                       Rst'Size < 31\n+                         or else (Rst'Size = 31\n+                                  and then Rst'Pos (Rst'First) < 0);\n+   --  This is set True if we do not need more than 32 bits in the result. If\n+   --  we need 64-bits, we will only use the meaningful 48 bits of any 64-bit\n+   --  number generated, since if more than 48 bits are required, we split the\n+   --  computation into two separate parts, since the algorithm does not behave\n+   --  above 48 bits.\n+\n+   --  The way this expression works is that obviously if the size is 31 bits,\n+   --  it fits in 32 bits. In the 32-bit case, it fits in 32-bit signed if the\n+   --  range has negative values. It is too conservative in the case that the\n+   --  programmer has set a size greater than the default, e.g. a size of 33\n+   --  for an integer type with a size of 1..10. But an over-conservative\n+   --  result is OK. The important thing is that the value is only True if\n+   --  we know the result will fit in 32-bits signed. If the value is False\n+   --  when it could be True, the behavior will be correct, just a bit less\n+   --  efficient than it could have been in some unusual cases.\n    --\n-   --  Note: the right hand side used to be Int'Last, but that won't work\n-   --  since it means that if Rst is a dynamic subtype, the comparison is\n-   --  evaluated at run time in type Int, which is too small. In practice\n-   --  the use of dynamic bounds is rare, and this constant will always\n-   --  be evaluated at compile time in an instance.\n-   --\n-   --  This still is not quite right for dynamic subtypes of 64-bit modular\n-   --  types where the upper bound can exceed the upper bound of universal\n-   --  integer. Not clear how to do this with a nice static expression ???\n-   --  Might have to introduce a special Type'First_In_32_Bits attribute!\n+   --  One might assume that we could get a more accurate result by testing\n+   --  the lower and upper bounds of the type Rst against the bounds of 32-bit\n+   --  Integer. However, there is no easy way to do that. Why? Because in the\n+   --  relatively rare case where this expresion has to be evaluated at run\n+   --  time rather than compile time (when the bounds are dynamic), we need a\n+   --  type to use for the computation. But the possible range of upper bound\n+   --  values for Rst (remembering the possibility of 64-bit modular types) is\n+   --  from -2**63 to 2**64-1, and no run-time type has a big enough range.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -134,7 +144,7 @@ package body Ada.Numerics.Discrete_Random is\n       if TF >= Flt (Rst'Pos (Rst'Last)) + 0.5 then\n          return Rst'First;\n \n-      elsif Need_64 then\n+      elsif not Fits_In_32_Bits then\n          return Rst'Val (Interfaces.Integer_64 (TF));\n \n       else"}, {"sha": "87beb499f37bc3077ee1266a0075bc87e3681510", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "patch": "@@ -1850,9 +1850,10 @@ package body Exp_Ch3 is\n \n          --  Take a copy of Exp to ensure that later copies of this component\n          --  declaration in derived types see the original tree, not a node\n-         --  rewritten during expansion of the init_proc.\n+         --  rewritten during expansion of the init_proc. If the copy contains\n+         --  itypes, the scope of the new itypes is the init.proc being built.\n \n-         Exp := New_Copy_Tree (Exp);\n+         Exp := New_Copy_Tree (Exp, New_Scope => Proc_Id);\n \n          Res := New_List (\n            Make_Assignment_Statement (Loc,\n@@ -1870,7 +1871,7 @@ package body Exp_Ch3 is\n               Make_Assignment_Statement (Loc,\n                 Name =>\n                   Make_Selected_Component (Loc,\n-                    Prefix =>  New_Copy_Tree (Lhs),\n+                    Prefix =>  New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n                     Selector_Name =>\n                       New_Reference_To (First_Tag_Component (Typ), Loc)),\n \n@@ -1893,10 +1894,11 @@ package body Exp_Ch3 is\n          then\n             Append_List_To (Res,\n               Make_Adjust_Call (\n-               Ref          => New_Copy_Tree (Lhs),\n+               Ref          => New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n                Typ          => Etype (Id),\n                Flist_Ref    =>\n-                 Find_Final_List (Etype (Id), New_Copy_Tree (Lhs)),\n+                 Find_Final_List\n+                   (Etype (Id), New_Copy_Tree (Lhs, New_Scope => Proc_Id)),\n                With_Attach  => Make_Integer_Literal (Loc, 1)));\n          end if;\n "}, {"sha": "978f0e65f318190e386a63dd499f2d9b4cf63e5b", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "patch": "@@ -146,7 +146,7 @@ package Exp_Disp is\n    --      Snames.adb.\n \n    --      Categorize the new PPO name as predefined by adding an entry in\n-   --      Is_Predefined_Dispatching_Operation in Exp_Util.adb.\n+   --      Is_Predefined_Dispatching_Operation in Exp_Disp.\n \n    --      Generate the specification of the new PPO in Make_Predefined_\n    --      Primitive_Spec in Exp_Ch3.adb. The Is_Internal flag of the defining"}, {"sha": "ea43c9135c44dc51ae13df06c286925eab31f468", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afaf827b7b4a5f34f6baf1a92ac14f797191fc1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5afaf827b7b4a5f34f6baf1a92ac14f797191fc1", "patch": "@@ -2802,8 +2802,7 @@ package body Sem_Prag is\n             end if;\n \n             if Warn_On_Export_Import and then Is_Exported (Def_Id) then\n-               Error_Msg_N\n-                 (\"?duplicate Export_Object pragma\", N);\n+               Error_Msg_N (\"?duplicate Export_Object pragma\", N);\n             else\n                Set_Exported (Def_Id, Arg_Internal);\n             end if;\n@@ -2843,8 +2842,8 @@ package body Sem_Prag is\n                  (\"?duplicate Import_Object pragma\", N);\n \n             --  Check for explicit initialization present. Note that an\n-            --  initialization that generated by the code generator, e.g.\n-            --  for an access type, does not count here.\n+            --  initialization generated by the code generator, e.g. for an\n+            --  access type, does not count here.\n \n             elsif Present (Expression (Parent (Def_Id)))\n                and then\n@@ -3141,12 +3140,10 @@ package body Sem_Prag is\n             Formal := First_Formal (Ent);\n \n             if No (Formal) then\n-               Error_Pragma\n-                 (\"at least one parameter required for pragma%\");\n+               Error_Pragma (\"at least one parameter required for pragma%\");\n \n             elsif Ekind (Formal) /= E_Out_Parameter then\n-               Error_Pragma\n-                 (\"first parameter must have mode out for pragma%\");\n+               Error_Pragma (\"first parameter must have mode out for pragma%\");\n \n             else\n                Set_Is_Valued_Procedure (Ent);"}]}