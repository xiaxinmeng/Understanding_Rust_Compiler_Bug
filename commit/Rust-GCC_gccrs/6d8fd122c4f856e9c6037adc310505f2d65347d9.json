{"sha": "6d8fd122c4f856e9c6037adc310505f2d65347d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4ZmQxMjJjNGY4NTZlOWM2MDM3YWRjMzEwNTA1ZjJkNjUzNDdkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-12-08T17:02:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-12-08T17:02:30Z"}, "message": "Fix overflows in -fprofile-reorder-functions\n\nThis patch fixes three sissues with -fprofile-reorder-functions:\n1) First is that tp_first_run is stored as 32bit integer while it can easily\n   overflow (and does so during Firefox profiling).\n2) Second problem is that flag_profile_functions can\n   not be tested w/o function context.\n   The changes to expand_all_functions makes it to work on mixed units by\n   first outputting all functions w/o -fprofile-reorder-function (or with no\n   profile info) and then outputting in first_run order\n3) LTO partitioner was mixing up order by tp_first_run and by order.\n   for no_reorder we definitly want to order via first, while for everything\n   else we want to roder by second.\n\nI have also merged duplicated comparators since they are bit fragile into\ntp_first_run_node_cmp.\n\nI originaly started to look into this because of undefined symbols with\nFirefox PGO builds.  These symbols went away with fixing these bug but I am not\nquite sure how. it is possible that there is another problem in lto_blanced_map\nbut even after reading the noreorder code few times carefuly I did not find it.\nOther explanation would be that our new qsort with broken comparator due to\noverflow can actualy remove some entries in the array, but that sounds bit\ncrazy.\n\nBootstrapped/regested x86_64-linux.\n\n\t* cgraph.c (cgraph_node::dump): Make tp_first_run 64bit.\n\t* cgraph.h (cgrpah_node): Likewise.\n\t(tp_first_run_node_cmp): Deeclare.\n\t* cgraphunit.c (node_cmp): Rename to ...\n\t(tp_first_run_node_cmp): ... this; export; watch for 64bit overflows;\n\tclear tp_first_run for no_reorder and !flag_profile_reorder_functions.\n\t(expand_all_functions): Collect tp_first_run and normal functions to\n\ttwo vectors so the other functions remain sorted. Do not check for\n\tflag_profile_reorder_functions it is function local flag.\n\t* profile.c (compute_value_histograms): Update tp_first_run printing.\n\n\t* lto-partition.c (node_cmp): Turn into simple order comparsions.\n\t(varpool_node_cmp): Remove.\n\t(add_sorted_nodes): Use node_cmp.\n\t(lto_balanced_map): Use tp_first_run_node_cmp.\n\nFrom-SVN: r279093", "tree": {"sha": "8e29349bdc425541a2785219964901a5ba270470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e29349bdc425541a2785219964901a5ba270470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d8fd122c4f856e9c6037adc310505f2d65347d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8fd122c4f856e9c6037adc310505f2d65347d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8fd122c4f856e9c6037adc310505f2d65347d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8fd122c4f856e9c6037adc310505f2d65347d9/comments", "author": null, "committer": null, "parents": [{"sha": "a8d9d6649e621e6e0d0887bd7f5a6069cb9cfa72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d9d6649e621e6e0d0887bd7f5a6069cb9cfa72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d9d6649e621e6e0d0887bd7f5a6069cb9cfa72"}], "stats": {"total": 144, "additions": 85, "deletions": 59}, "files": [{"sha": "5bb4a5b7ad2b0ed13cc8c14bed5380699fa8abcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -1,3 +1,16 @@\n+2019-12-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_node::dump): Make tp_first_run 64bit.\n+\t* cgraph.h (cgrpah_node): Likewise.\n+\t(tp_first_run_node_cmp): Deeclare.\n+\t* cgraphunit.c (node_cmp): Rename to ...\n+\t(tp_first_run_node_cmp): ... this; export; watch for 64bit overflows;\n+\tclear tp_first_run for no_reorder and !flag_profile_reorder_functions.\n+\t(expand_all_functions): Collect tp_first_run and normal functions to\n+\ttwo vectors so the other functions remain sorted. Do not check for\n+\tflag_profile_reorder_functions it is function local flag.\n+\t* profile.c (compute_value_histograms): Update tp_first_run printing.\n+\n 2019-12-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* opts.c (common_handle_option): Do not clear ipa_reference for"}, {"sha": "5c72e832a232276b0807504f0336e9ab2aa376f2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -1954,7 +1954,7 @@ cgraph_node::dump (FILE *f)\n       count.dump (f);\n     }\n   if (tp_first_run > 0)\n-    fprintf (f, \" first_run:%i\", tp_first_run);\n+    fprintf (f, \" first_run:%\" PRId64, (int64_t) tp_first_run);\n   if (origin)\n     fprintf (f, \" nested in:%s\", origin->asm_name ());\n   if (gimple_has_body_p (decl))"}, {"sha": "1b8a167fbdcfb258d53f998a33d66d08c4560792", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -1430,15 +1430,15 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n+  /* Time profiler: first run of function.  */\n+  gcov_type tp_first_run;\n   /* How to scale counts at materialization time; used to merge\n      LTO units with different number of profile runs.  */\n   int count_materialization_scale;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n   /* ID of the translation unit.  */\n   int unit_id;\n-  /* Time profiler: first run of function.  */\n-  int tp_first_run;\n \n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n@@ -2463,6 +2463,7 @@ cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n /* In cgraphunit.c  */\n void cgraphunit_c_finalize (void);\n+int tp_first_run_node_cmp (const void *pa, const void *pb);\n \n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */"}, {"sha": "0468ccfc483fd2f75e7ae49092eb58fa8b233310", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -2359,19 +2359,33 @@ cgraph_node::expand (void)\n /* Node comparator that is responsible for the order that corresponds\n    to time when a function was launched for the first time.  */\n \n-static int\n-node_cmp (const void *pa, const void *pb)\n+int\n+tp_first_run_node_cmp (const void *pa, const void *pb)\n {\n   const cgraph_node *a = *(const cgraph_node * const *) pa;\n   const cgraph_node *b = *(const cgraph_node * const *) pb;\n+  gcov_type tp_first_run_a = a->tp_first_run;\n+  gcov_type tp_first_run_b = b->tp_first_run;\n+\n+  if (!opt_for_fn (a->decl, flag_profile_reorder_functions)\n+      || a->no_reorder)\n+    tp_first_run_a = 0;\n+  if (!opt_for_fn (b->decl, flag_profile_reorder_functions)\n+      || b->no_reorder)\n+    tp_first_run_b = 0;\n+\n+  if (tp_first_run_a == tp_first_run_b)\n+    return a->order - b->order;\n \n   /* Functions with time profile must be before these without profile.  */\n-  if (!a->tp_first_run || !b->tp_first_run)\n-    return a->tp_first_run - b->tp_first_run;\n+  if (!tp_first_run_a || !tp_first_run_b)\n+    return tp_first_run_b ? 1 : -1;\n \n-  return a->tp_first_run != b->tp_first_run\n-\t ? b->tp_first_run - a->tp_first_run\n-\t : b->order - a->order;\n+  /* Watch for overlflow - tp_first_run is 64bit.  */\n+  if (tp_first_run_a > tp_first_run_b)\n+    return 1;\n+  else\n+    return -1;\n }\n \n /* Expand all functions that must be output.\n@@ -2390,8 +2404,10 @@ expand_all_functions (void)\n   cgraph_node *node;\n   cgraph_node **order = XCNEWVEC (cgraph_node *,\n \t\t\t\t\t symtab->cgraph_count);\n+  cgraph_node **tp_first_run_order = XCNEWVEC (cgraph_node *,\n+\t\t\t\t\t symtab->cgraph_count);\n   unsigned int expanded_func_count = 0, profiled_func_count = 0;\n-  int order_pos, new_order_pos = 0;\n+  int order_pos, tp_first_run_order_pos = 0, new_order_pos = 0;\n   int i;\n \n   order_pos = ipa_reverse_postorder (order);\n@@ -2401,25 +2417,43 @@ expand_all_functions (void)\n      optimization.  So we must be sure to not reference them.  */\n   for (i = 0; i < order_pos; i++)\n     if (order[i]->process)\n-      order[new_order_pos++] = order[i];\n-\n-  if (flag_profile_reorder_functions)\n-    qsort (order, new_order_pos, sizeof (cgraph_node *), node_cmp);\n+      {\n+\tif (order[i]->tp_first_run\n+\t    && opt_for_fn (order[i]->decl, flag_profile_reorder_functions))\n+\t  tp_first_run_order[tp_first_run_order_pos++] = order[i];\n+\telse\n+          order[new_order_pos++] = order[i];\n+      }\n \n+  /* Output functions in RPO so callers get optimized before callees.  This\n+     makes ipa-ra and other propagators to work.\n+     FIXME: This is far from optimal code layout.  */\n   for (i = new_order_pos - 1; i >= 0; i--)\n     {\n       node = order[i];\n \n       if (node->process)\n \t{\n \t  expanded_func_count++;\n-\t  if(node->tp_first_run)\n-\t    profiled_func_count++;\n+\t  node->process = 0;\n+\t  node->expand ();\n+\t}\n+    }\n+  qsort (tp_first_run_order, tp_first_run_order_pos,\n+\t sizeof (cgraph_node *), tp_first_run_node_cmp);\n+  for (i = 0; i < tp_first_run_order_pos; i++)\n+    {\n+      node = tp_first_run_order[i];\n+\n+      if (node->process)\n+\t{\n+\t  expanded_func_count++;\n+\t  profiled_func_count++;\n \n \t  if (symtab->dump_file)\n \t    fprintf (symtab->dump_file,\n-\t\t     \"Time profile order in expand_all_functions:%s:%d\\n\",\n-\t\t     node->asm_name (), node->tp_first_run);\n+\t\t     \"Time profile order in expand_all_functions:%s:%\" PRId64\n+\t\t     \"\\n\", node->asm_name (), (int64_t) node->tp_first_run);\n \t  node->process = 0;\n \t  node->expand ();\n \t}\n@@ -2429,7 +2463,7 @@ expand_all_functions (void)\n       fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n                main_input_filename, profiled_func_count, expanded_func_count);\n \n-  if (symtab->dump_file && flag_profile_reorder_functions)\n+  if (symtab->dump_file && tp_first_run_order_pos)\n     fprintf (symtab->dump_file, \"Expanded functions with time profile:%u/%u\\n\",\n              profiled_func_count, expanded_func_count);\n "}, {"sha": "d80b2bd61bf6fe8297eda040539458d6fa7946eb", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -1,5 +1,11 @@\n-2019-11-25  Joseph Myers  <joseph@codesourcery.com>\n+2019-12-07  Jan Hubicka  <hubicka@ucw.cz>\n \n+\t* lto-partition.c (node_cmp): Turn into simple order comparsions.\n+\t(varpool_node_cmp): Remove.\n+\t(add_sorted_nodes): Use node_cmp.\n+\t(lto_balanced_map): Use tp_first_run_node_cmp.\n+\n+/bin/bash: :q: command not found\n \tPR c/91985\n \t* lto-lang.c (lto_type_for_mode): Handle decimal floating-point\n \ttypes being NULL_TREE."}, {"sha": "4da76509616b209c904bd9ad60ab9a2d5a27311f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -372,38 +372,9 @@ lto_max_map (void)\n     new_partition (\"empty\");\n }\n \n-/* Helper function for qsort; sort nodes by order. noreorder functions must have\n-   been removed earlier.  */\n-static int\n-node_cmp (const void *pa, const void *pb)\n-{\n-  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n-  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n-\n-  /* Profile reorder flag enables function reordering based on first execution\n-     of a function. All functions with profile are placed in ascending\n-     order at the beginning.  */\n-\n-  if (flag_profile_reorder_functions)\n-  {\n-    /* Functions with time profile are sorted in ascending order.  */\n-    if (a->tp_first_run && b->tp_first_run)\n-      return a->tp_first_run != b->tp_first_run\n-\t? a->tp_first_run - b->tp_first_run\n-        : a->order - b->order;\n-\n-    /* Functions with time profile are sorted before the functions\n-       that do not have the profile.  */\n-    if (a->tp_first_run || b->tp_first_run)\n-      return b->tp_first_run - a->tp_first_run;\n-  }\n-\n-  return b->order - a->order;\n-}\n-\n /* Helper function for qsort; sort nodes by order.  */\n static int\n-varpool_node_cmp (const void *pa, const void *pb)\n+node_cmp (const void *pa, const void *pb)\n {\n   const symtab_node *a = *static_cast<const symtab_node * const *> (pa);\n   const symtab_node *b = *static_cast<const symtab_node * const *> (pb);\n@@ -418,7 +389,7 @@ add_sorted_nodes (vec<symtab_node *> &next_nodes, ltrans_partition partition)\n   unsigned i;\n   symtab_node *node;\n \n-  next_nodes.qsort (varpool_node_cmp);\n+  next_nodes.qsort (node_cmp);\n   FOR_EACH_VEC_ELT (next_nodes, i, node)\n     if (!symbol_partitioned_p (node))\n       add_symbol_to_partition (partition, node);\n@@ -537,17 +508,17 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n      unit tends to import a lot of global trees defined there.  We should\n      get better about minimizing the function bounday, but until that\n      things works smoother if we order in source order.  */\n-  order.qsort (node_cmp);\n+  order.qsort (tp_first_run_node_cmp);\n   noreorder.qsort (node_cmp);\n \n   if (dump_file)\n     {\n       for (unsigned i = 0; i < order.length (); i++)\n-\tfprintf (dump_file, \"Balanced map symbol order:%s:%u\\n\",\n-\t\t order[i]->name (), order[i]->tp_first_run);\n+\tfprintf (dump_file, \"Balanced map symbol order:%s:%\" PRId64 \"\\n\",\n+\t\t order[i]->name (), (int64_t) order[i]->tp_first_run);\n       for (unsigned i = 0; i < noreorder.length (); i++)\n-\tfprintf (dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n-\t\t noreorder[i]->name (), noreorder[i]->tp_first_run);\n+\tfprintf (dump_file, \"Balanced map symbol no_reorder:%s:%\" PRId64 \"\\n\",\n+\t\t noreorder[i]->name (), (int64_t) noreorder[i]->tp_first_run);\n     }\n \n   /* Collect all variables that should not be reordered.  */\n@@ -556,7 +527,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t&& vnode->no_reorder)\n       varpool_order.safe_push (vnode);\n   n_varpool_nodes = varpool_order.length ();\n-  varpool_order.qsort (varpool_node_cmp);\n+  varpool_order.qsort (node_cmp);\n \n   /* Compute partition size and create the first partition.  */\n   if (param_min_partition_size > max_partition_size)"}, {"sha": "7d4121712228d3a87c7325cd03b2280428651793", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd122c4f856e9c6037adc310505f2d65347d9/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6d8fd122c4f856e9c6037adc310505f2d65347d9", "patch": "@@ -874,7 +874,8 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n \t  node->tp_first_run = hist->hvalue.counters[0];\n \n           if (dump_file)\n-            fprintf (dump_file, \"Read tp_first_run: %d\\n\", node->tp_first_run);\n+            fprintf (dump_file, \"Read tp_first_run: %\" PRId64 \"\\n\",\n+\t\t     (int64_t) node->tp_first_run);\n         }\n     }\n "}]}