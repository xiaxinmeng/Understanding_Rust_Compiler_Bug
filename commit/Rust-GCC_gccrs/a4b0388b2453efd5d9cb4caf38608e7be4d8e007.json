{"sha": "a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRiMDM4OGIyNDUzZWZkNWQ5Y2I0Y2FmMzg2MDhlN2JlNGQ4ZTAwNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-25T16:58:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-25T16:58:21Z"}, "message": "lto-streamer-out.c (struct sccs): Turn to ...\n\n\t* lto-streamer-out.c (struct sccs): Turn to ...\n\t(class DFS): ... this one; refactor the DFS walk so it can\n\tbe re-done on per-SCC basis.\n\t(DFS::DFS): New constructor.\n\t(DFS::~DFS): New destructor.\n\t(hash_tree): Add new MAP argument holding in-SCC hash values;\n\tremove POINTER_TYPE hashing hack.\n\t(scc_entry_compare): Rename to ...\n\t(DFS::scc_entry_compare): ... this one.\n\t(hash_scc): Rename to ...\n\t(DFS::hash_scc): ... this one; pass output_block instead\n\tof streamer_cache; work harder to get unique and stable SCC\n\thashes.\n\t(DFS_write_tree): Rename to ...\n\t(DFS::DFS_write_tree): ... this one; add SINGLE_P parameter.\n\t(lto_output_tree): Update.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r213059", "tree": {"sha": "62d950f6cac8792ed05ffe1b946056437d64a5c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d950f6cac8792ed05ffe1b946056437d64a5c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b0388b2453efd5d9cb4caf38608e7be4d8e007/comments", "author": null, "committer": null, "parents": [{"sha": "770f687ddb80845d472bb7a09b32b1e5db9db1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770f687ddb80845d472bb7a09b32b1e5db9db1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770f687ddb80845d472bb7a09b32b1e5db9db1f9"}], "stats": {"total": 323, "additions": 250, "deletions": 73}, "files": [{"sha": "5a508200b12a25859037d511fa87f46cd4db2b0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b0388b2453efd5d9cb4caf38608e7be4d8e007/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b0388b2453efd5d9cb4caf38608e7be4d8e007/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "patch": "@@ -1,3 +1,23 @@\n+2014-07-25  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Richard Biener <rguenther@suse.de>\n+\n+\t* lto-streamer-out.c (struct sccs): Turn to ...\n+\t(class DFS): ... this one; refactor the DFS walk so it can\n+\tbe re-done on per-SCC basis.\n+\t(DFS::DFS): New constructor.\n+\t(DFS::~DFS): New destructor.\n+\t(hash_tree): Add new MAP argument holding in-SCC hash values;\n+\tremove POINTER_TYPE hashing hack.\n+\t(scc_entry_compare): Rename to ...\n+\t(DFS::scc_entry_compare): ... this one.\n+\t(hash_scc): Rename to ...\n+\t(DFS::hash_scc): ... this one; pass output_block instead\n+\tof streamer_cache; work harder to get unique and stable SCC\n+\thashes.\n+\t(DFS_write_tree): Rename to ...\n+\t(DFS::DFS_write_tree): ... this one; add SINGLE_P parameter.\n+\t(lto_output_tree): Update.\n+\n 2014-07-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto-streamer-out.c (hash_tree): Convert to inchash."}, {"sha": "271fbd56591e7be94840533627f696f380df5174", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 230, "deletions": 73, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b0388b2453efd5d9cb4caf38608e7be4d8e007/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b0388b2453efd5d9cb4caf38608e7be4d8e007/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=a4b0388b2453efd5d9cb4caf38608e7be4d8e007", "patch": "@@ -440,36 +440,71 @@ lto_output_tree_1 (struct output_block *ob, tree expr, hashval_t hash,\n     }\n }\n \n-struct sccs\n+class DFS\n {\n-  unsigned int dfsnum;\n-  unsigned int low;\n+public:\n+  DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n+       bool single_p);\n+  ~DFS ();\n+\n+  struct scc_entry\n+  {\n+    tree t;\n+    hashval_t hash;\n+  };\n+  vec<scc_entry> sccstack;\n+\n+private:\n+  struct sccs\n+  {\n+    unsigned int dfsnum;\n+    unsigned int low;\n+  };\n+\n+  static int scc_entry_compare (const void *, const void *);\n+\n+  void DFS_write_tree_body (struct output_block *ob,\n+\t\t\t    tree expr, sccs *expr_state, bool ref_p,\n+\t\t\t    bool single_p);\n+\n+  void DFS_write_tree (struct output_block *ob, sccs *from_state,\n+\t\t       tree expr, bool ref_p, bool this_ref_p,\n+\t\t       bool single_p);\n+  hashval_t\n+  hash_scc (struct output_block *ob, unsigned first, unsigned size);\n+\n+  unsigned int next_dfs_num;\n+  struct pointer_map_t *sccstate;\n+  struct obstack sccstate_obstack;\n };\n \n-struct scc_entry\n+DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n+\t  bool single_p)\n {\n-  tree t;\n-  hashval_t hash;\n-};\n-\n-static unsigned int next_dfs_num;\n-static vec<scc_entry> sccstack;\n-static struct pointer_map_t *sccstate;\n-static struct obstack sccstate_obstack;\n+  sccstack.create (0);\n+  sccstate = pointer_map_create ();\n+  gcc_obstack_init (&sccstate_obstack);\n+  next_dfs_num = 1;\n+  DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p, single_p);\n+}\n \n-static void\n-DFS_write_tree (struct output_block *ob, sccs *from_state,\n-\t\ttree expr, bool ref_p, bool this_ref_p);\n+DFS::~DFS ()\n+{\n+  sccstack.release ();\n+  pointer_map_destroy (sccstate);\n+  obstack_free (&sccstate_obstack, NULL);\n+}\n \n /* Handle the tree EXPR in the DFS walk with SCC state EXPR_STATE and\n    DFS recurse for all tree edges originating from it.  */\n \n-static void\n-DFS_write_tree_body (struct output_block *ob,\n-\t\t     tree expr, sccs *expr_state, bool ref_p)\n+void\n+DFS::DFS_write_tree_body (struct output_block *ob,\n+\t\t\t  tree expr, sccs *expr_state, bool ref_p,\n+\t\t\t  bool single_p)\n {\n #define DFS_follow_tree_edge(DEST) \\\n-  DFS_write_tree (ob, expr_state, DEST, ref_p, ref_p)\n+  DFS_write_tree (ob, expr_state, DEST, ref_p, ref_p, single_p)\n \n   enum tree_code code;\n \n@@ -690,18 +725,26 @@ DFS_write_tree_body (struct output_block *ob,\n #undef DFS_follow_tree_edge\n }\n \n-/* Return a hash value for the tree T.  */\n+/* Return a hash value for the tree T.\n+   CACHE holds hash values of trees outside current SCC.  MAP, if non-NULL,\n+   may hold hash values if trees inside current SCC.  */\n \n static hashval_t\n-hash_tree (struct streamer_tree_cache_d *cache, tree t)\n+hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map, tree t)\n {\n   inchash hstate;\n \n #define visit(SIBLING) \\\n   do { \\\n     unsigned ix; \\\n-    if (SIBLING && streamer_tree_cache_lookup (cache, SIBLING, &ix)) \\\n+    if (!SIBLING) \\\n+      hstate.add_int (0); \\\n+    else if (streamer_tree_cache_lookup (cache, SIBLING, &ix)) \\\n       hstate.add_int (streamer_tree_cache_get_hash (cache, ix)); \\\n+    else if (map) \\\n+      hstate.add_int (*map->get (SIBLING)); \\\n+    else \\\n+      hstate.add_int (1); \\\n   } while (0)\n \n   /* Hash TS_BASE.  */\n@@ -905,23 +948,7 @@ hash_tree (struct streamer_tree_cache_d *cache, tree t)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n     {\n-      if (POINTER_TYPE_P (t))\n-\t{\n-\t  /* For pointers factor in the pointed-to type recursively as\n-\t     we cannot recurse through only pointers.\n-\t     ???  We can generalize this by keeping track of the\n-\t     in-SCC edges for each tree (or arbitrarily the first\n-\t     such edge) and hashing that in in a second stage\n-\t     (instead of the quadratic mixing of the SCC we do now).  */\n-\t  hashval_t x;\n-\t  unsigned ix;\n-\t  if (streamer_tree_cache_lookup (cache, TREE_TYPE (t), &ix))\n-\t    x = streamer_tree_cache_get_hash (cache, ix);\n-\t  else\n-\t    x = hash_tree (cache, TREE_TYPE (t));\n-\t  hstate.merge_hash (x);\n-\t}\n-      else if (code != IDENTIFIER_NODE)\n+      if (code != IDENTIFIER_NODE)\n \tvisit (TREE_TYPE (t));\n     }\n \n@@ -1116,8 +1143,8 @@ hash_tree (struct streamer_tree_cache_d *cache, tree t)\n \n /* Compare two SCC entries by their hash value for qsorting them.  */\n \n-static int\n-scc_entry_compare (const void *p1_, const void *p2_)\n+int\n+DFS::scc_entry_compare (const void *p1_, const void *p2_)\n {\n   const scc_entry *p1 = (const scc_entry *) p1_;\n   const scc_entry *p2 = (const scc_entry *) p2_;\n@@ -1131,40 +1158,159 @@ scc_entry_compare (const void *p1_, const void *p2_)\n /* Return a hash value for the SCC on the SCC stack from FIRST with\n    size SIZE.  */\n \n-static hashval_t\n-hash_scc (struct streamer_tree_cache_d *cache, unsigned first, unsigned size)\n+hashval_t\n+DFS::hash_scc (struct output_block *ob,\n+\t       unsigned first, unsigned size)\n {\n+  unsigned int last_classes = 0, iterations = 0;\n+\n   /* Compute hash values for the SCC members.  */\n   for (unsigned i = 0; i < size; ++i)\n-    sccstack[first+i].hash = hash_tree (cache, sccstack[first+i].t);\n+    sccstack[first+i].hash = hash_tree (ob->writer_cache, NULL,\n+\t\t\t\t\tsccstack[first+i].t);\n \n   if (size == 1)\n     return sccstack[first].hash;\n \n-  /* Sort the SCC of type, hash pairs so that when we mix in\n-     all members of the SCC the hash value becomes independent on\n-     the order we visited the SCC.  Produce hash of the whole SCC as\n-     combination of hashes of individual elements.  Then combine that hash into\n-     hash of each element, so othewise identically looking elements from two\n-     different SCCs are distinguished.  */\n-  qsort (&sccstack[first], size, sizeof (scc_entry), scc_entry_compare);\n-\n-  hashval_t scc_hash = sccstack[first].hash;\n-  for (unsigned i = 1; i < size; ++i)\n-    scc_hash = iterative_hash_hashval_t (scc_hash,\n-\t\t\t\t\t sccstack[first+i].hash);\n-  for (unsigned i = 0; i < size; ++i)\n-    sccstack[first+i].hash = iterative_hash_hashval_t (sccstack[first+i].hash, scc_hash);\n-  return scc_hash;\n+  /* We aim to get unique hash for every tree within SCC and compute hash value\n+     of the whole SCC by combing all values together in an stable (entry point\n+     independent) order.  This guarantees that the same SCC regions within\n+     different translation units will get the same hash values and therefore\n+     will be merged at WPA time.\n+\n+     Often the hashes are already unique.  In that case we compute scc hash\n+     by combining individual hash values in an increasing order.\n+\n+     If thre are duplicates we seek at least one tree with unique hash (and\n+     pick one with minimal hash and this property).  Then we obtain stable\n+     order by DFS walk starting from this unique tree and then use index\n+     within this order to make individual hash values unique.\n+\n+     If there is no tree with unique hash, we iteratively propagate the hash\n+     values across the internal edges of SCC.  This usually quickly leads\n+     to unique hashes.  Consider, for example, an SCC containing two pointers\n+     that are identical except for type they point and assume that these\n+     types are also part of the SCC.\n+     The propagation will add the points-to type information into their hash\n+     values.  */\n+  do\n+    {\n+      /* Sort the SCC so we can easily see check for uniqueness.  */\n+      qsort (&sccstack[first], size, sizeof (scc_entry), scc_entry_compare);\n+\n+      unsigned int classes = 1;\n+      int firstunique = -1;\n+\n+      /* Find tree with lowest unique hash (if it exists) and compute\n+\t number of equivalence classes.  */\n+      if (sccstack[first].hash != sccstack[first+1].hash)\n+\tfirstunique = 0;\n+      for (unsigned i = 1; i < size; ++i)\n+\tif (sccstack[first+i-1].hash != sccstack[first+i].hash)\n+\t  {\n+\t    classes++;\n+\t    if (firstunique == -1\n+\t\t&& (i == size - 1\n+\t\t    || sccstack[first+i+1].hash != sccstack[first+i].hash))\n+\t      firstunique = i;\n+\t  }\n+\n+      /* If we found tree with unique hash; stop the iteration.  */\n+      if (firstunique != -1\n+\t  /* Also terminate if we run out of iterations or if the number of\n+\t     equivalence classes is no longer increasing.\n+\t     For example a cyclic list of trees that are all equivalent will\n+\t     never have unique entry point; we however do not build such SCCs\n+\t     in our IL.  */\n+\t  || classes <= last_classes || iterations > 16)\n+\t{\n+          hashval_t scc_hash;\n+\n+\t  /* If some hashes are not unique (CLASSES != SIZE), use the DFS walk\n+\t     starting from FIRSTUNIQUE to obstain stable order.  */\n+\t  if (classes != size && firstunique != -1)\n+\t    {\n+\t      hash_map <tree, hashval_t> map(size*2);\n+\n+\t      /* Store hash values into a map, so we can associate them with\n+\t\t reordered SCC.  */\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\tmap.put (sccstack[first+i].t, sccstack[first+i].hash);\n+\n+\t      DFS again (ob, sccstack[first+firstunique].t, false, false, true);\n+\t      gcc_assert (again.sccstack.length () == size);\n+\n+\t      memcpy (sccstack.address () + first,\n+\t\t      again.sccstack.address (),\n+\t\t      sizeof (scc_entry) * size);\n+\n+\t      /* Update hash values of individual members by hashing in the\n+\t\t index within the stable order.  This ensures uniqueness.\n+\t\t Also compute the scc_hash by mixing in all hash values in the\n+\t\t stable order we obtained.  */\n+\t      sccstack[first].hash = *map.get (sccstack[first].t);\n+\t      scc_hash = sccstack[first].hash;\n+\t      for (unsigned i = 1; i < size; ++i)\n+\t\t{\n+\t\t  sccstack[first+i].hash\n+\t\t    = iterative_hash_hashval_t (i,\n+\t\t\t\t\t\t*map.get (sccstack[first+i].t));\n+\t\t  scc_hash = iterative_hash_hashval_t (scc_hash,\n+\t\t\t\t\t\t       sccstack[first+i].hash);\n+\t\t}\n+\t    }\n+\t  /* If we got unique hash values for each tree, then sort already\n+\t     ensured entry point independent order.  Only compute the final\n+\t     scc hash.\n+\n+\t     If we failed to find the unique entry point, we go by the same\n+\t     route. We will eventually introduce unwanted hash conflicts.  */\n+\t  else\n+\t    {\n+\t      scc_hash = sccstack[first].hash;\n+\t      for (unsigned i = 1; i < size; ++i)\n+\t\tscc_hash = iterative_hash_hashval_t (scc_hash,\n+\t\t\t\t\t\t     sccstack[first+i].hash);\n+\t      /* We can not 100% guarantee that the hash will not conflict in\n+\t\t in a way so the unique hash is not found.  This however\n+\t\t should be extremely rare situation.  ICE for now so possible\n+\t\t issues are found and evaulated.  */\n+\t      gcc_checking_assert (classes == size);\n+\t    }\n+\n+\t  /* To avoid conflicts across SCCs iteratively hash the whole SCC\n+\t     hash into the hash of each of the elements.  */\n+\t  for (unsigned i = 0; i < size; ++i)\n+\t    sccstack[first+i].hash\n+\t      = iterative_hash_hashval_t (sccstack[first+i].hash, scc_hash);\n+\t  return scc_hash;\n+\t}\n+\n+      last_classes = classes;\n+      iterations++;\n+\n+      /* We failed to identify the entry point; propagate hash values across\n+\t the edges.  */\n+      {\n+\thash_map <tree, hashval_t> map(size*2);\n+\tfor (unsigned i = 0; i < size; ++i)\n+\t  map.put (sccstack[first+i].t, sccstack[first+i].hash);\n+\n+\tfor (unsigned i = 0; i < size; i++)\n+\t  sccstack[first+i].hash = hash_tree (ob->writer_cache, &map,\n+\t\t\t\t\t      sccstack[first+i].t);\n+      }\n+    }\n+  while (true);\n }\n \n /* DFS walk EXPR and stream SCCs of tree bodies if they are not\n    already in the streamer cache.  Main routine called for\n    each visit of EXPR.  */\n \n-static void\n-DFS_write_tree (struct output_block *ob, sccs *from_state,\n-\t\ttree expr, bool ref_p, bool this_ref_p)\n+void\n+DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n+\t\t     tree expr, bool ref_p, bool this_ref_p, bool single_p)\n {\n   unsigned ix;\n   sccs **slot;\n@@ -1196,10 +1342,10 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t;\n       else if (TREE_CODE (expr) == INTEGER_CST\n \t       && !TREE_OVERFLOW (expr))\n-\tDFS_write_tree (ob, cstate, TREE_TYPE (expr), ref_p, ref_p);\n+\tDFS_write_tree (ob, cstate, TREE_TYPE (expr), ref_p, ref_p, single_p);\n       else\n \t{\n-\t  DFS_write_tree_body (ob, expr, cstate, ref_p);\n+\t  DFS_write_tree_body (ob, expr, cstate, ref_p, single_p);\n \n \t  /* Walk any LTO-specific edges.  */\n \t  if (DECL_P (expr)\n@@ -1209,7 +1355,7 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t      /* Handle DECL_INITIAL for symbols.  */\n \t      tree initial = get_symbol_initial_value (ob->decl_state->symtab_node_encoder,\n \t\t\t\t\t\t       expr);\n-\t      DFS_write_tree (ob, cstate, initial, ref_p, ref_p);\n+\t      DFS_write_tree (ob, cstate, initial, ref_p, ref_p, single_p);\n \t    }\n \t}\n \n@@ -1219,6 +1365,11 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t  unsigned first, size;\n \t  tree x;\n \n+\t  /* If we are re-walking a single leaf-SCC just return and\n+\t     let the caller access the sccstack.  */\n+\t  if (single_p)\n+\t    return;\n+\n \t  /* Pop the SCC and compute its size.  */\n \t  first = sccstack.length ();\n \t  do\n@@ -1234,7 +1385,7 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t  unsigned scc_entry_len = 0;\n \t  if (!flag_wpa)\n \t    {\n-\t      scc_hash = hash_scc (ob->writer_cache, first, size);\n+\t      scc_hash = hash_scc (ob, first, size);\n \n \t      /* Put the entries with the least number of collisions first.  */\n \t      unsigned entry_start = 0;\n@@ -1258,6 +1409,18 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t\t  sccstack[first + i] = sccstack[first + entry_start + i];\n \t\t  sccstack[first + entry_start + i] = tem;\n \t\t}\n+\n+\t      if (scc_entry_len == 1)\n+\t\t; /* We already sorted SCC deterministically in hash_scc.  */\n+\t      else\n+\t\t/* Check that we have only one SCC.\n+\t\t   Naturally we may have conflicts if hash function is not\n+ \t\t   strong enough.  Lets see how far this gets.  */\n+\t\t{\n+#ifdef ENABLE_CHECKING\n+\t\t  gcc_unreachable ();\n+#endif\n+\t\t}\n \t    }\n \n \t  /* Write LTO_tree_scc.  */\n@@ -1377,13 +1540,7 @@ lto_output_tree (struct output_block *ob, tree expr,\n       /* Save ob state ... */\n       /* let's see ... */\n       in_dfs_walk = true;\n-      sccstate = pointer_map_create ();\n-      gcc_obstack_init (&sccstate_obstack);\n-      next_dfs_num = 1;\n-      DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p);\n-      sccstack.release ();\n-      pointer_map_destroy (sccstate);\n-      obstack_free (&sccstate_obstack, NULL);\n+      DFS (ob, expr, ref_p, this_ref_p, false);\n       in_dfs_walk = false;\n \n       /* Finally append a reference to the tree we were writing."}]}