{"sha": "9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAzMGE0ZDNhYTkwYzFkYjFhNjU3ZmU1NTg4YzgyM2YwZWE3M2E4Ng==", "commit": {"author": {"name": "Bilyan Borisov", "email": "bilyan.borisov@arm.com", "date": "2015-11-22T15:15:20Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2015-11-22T15:15:20Z"}, "message": "[AARCH64][PATCH 2/3] Implementing vmulx_lane NEON intrinsic variants\n\ngcc/\n\n\t* config/aarch64/arm_neon.h (vmulx_lane_f32): New.\n\t(vmulx_lane_f64): Likewise.\n\t(vmulxq_lane_f32): Refactored & moved.\n\t(vmulxq_lane_f64): Likewise.\n\t(vmulx_laneq_f32): New.\n\t(vmulx_laneq_f64): Likewise.\n\t(vmulxq_laneq_f32): Likewise.\n\t(vmulxq_laneq_f64): Likewise.\n\t(vmulxs_lane_f32): Likewise.\n\t(vmulxs_laneq_f32): Likewise.\n\t(vmulxd_lane_f64): Likewise.\n\t(vmulxd_laneq_f64): Likewise.\n\t* config/aarch64/aarch64-simd.md\n\t(*aarch64_mulx_elt_<vswap_width_name><mode>, VDQSF): New pattern.\n\t(*aarch64_mulx_elt<mode>, VDQF): Likewise.\n\t(*aarch64_mulx_elt_to_64v2df): Likewise.\n\t(*aarch64_vgetfmulx<mode>, VDQF_DF): Likewise.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/simd/vmulx_lane_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulx_lane_f64_1.c: New.\n\t* gcc.target/aarch64/simd/vmulx_laneq_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulx_laneq_f64_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxq_lane_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxq_lane_f64_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxq_laneq_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxq_laneq_f64_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxs_lane_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxs_laneq_f32_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxd_lane_f64_1.c: New.\n\t* gcc.target/aarch64/simd/vmulxd_laneq_f64_1.c: New.\n\nFrom-SVN: r230720", "tree": {"sha": "81889465952aa9181526beb88c2294298bc9b26d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81889465952aa9181526beb88c2294298bc9b26d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/comments", "author": null, "committer": null, "parents": [{"sha": "60bcff01121db11277c1ae8419ddda8f014b6196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bcff01121db11277c1ae8419ddda8f014b6196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60bcff01121db11277c1ae8419ddda8f014b6196"}], "stats": {"total": 1124, "additions": 1098, "deletions": 26}, "files": [{"sha": "51e07072e8736ce2abb706478239290d725a67cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -1,3 +1,23 @@\n+2015-11-22  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md\n+\t(*aarch64_mulx_elt_<vswap_width_name><mode>, VDQSF): New.\n+\t(*aarch64_mulx_elt<mode>, VDQF): Likewise.\n+\t(*aarch64_mulx_elt_to_64v2df): Likewise.\n+\t(*aarch64_vgetfmulx<mode>, VDQF_DF): Likewise.\n+\t* config/aarch64/arm_neon.h (vmulx_lane_f32): New.\n+\t(vmulx_lane_f64): Likewise.\n+\t(vmulxq_lane_f32): Refactored & moved.\n+\t(vmulxq_lane_f64): Likewise.\n+\t(vmulx_laneq_f32): New.\n+\t(vmulx_laneq_f64): Likewise.\n+\t(vmulxq_laneq_f32): Likewise.\n+\t(vmulxq_laneq_f64): Likewise.\n+\t(vmulxs_lane_f32): Likewise.\n+\t(vmulxs_laneq_f32): Likewise.\n+\t(vmulxd_lane_f64): Likewise.\n+\t(vmulxd_laneq_f64): Likewise.\n+\n 2015-11-21  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.c (build_pointer_type_for_mode,build_reference_type_for_mode):"}, {"sha": "3fa23b30293fe7fe6c5362791a4e022eb0b69c7f", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -2907,6 +2907,80 @@\n  [(set_attr \"type\" \"neon_fp_mul_<Vetype>\")]\n )\n \n+;; vmulxq_lane_f32, and vmulx_laneq_f32\n+\n+(define_insn \"*aarch64_mulx_elt_<vswap_width_name><mode>\"\n+  [(set (match_operand:VDQSF 0 \"register_operand\" \"=w\")\n+\t(unspec:VDQSF\n+\t [(match_operand:VDQSF 1 \"register_operand\" \"w\")\n+\t  (vec_duplicate:VDQSF\n+\t   (vec_select:<VEL>\n+\t    (match_operand:<VSWAP_WIDTH> 2 \"register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 3 \"immediate_operand\" \"i\")])))]\n+\t UNSPEC_FMULX))]\n+  \"TARGET_SIMD\"\n+  {\n+    operands[3] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n+\t\t\t\t\t  INTVAL (operands[3])));\n+    return \"fmulx\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n+  }\n+  [(set_attr \"type\" \"neon_fp_mul_<Vetype>_scalar<q>\")]\n+)\n+\n+;; vmulxq_laneq_f32, vmulxq_laneq_f64, vmulx_lane_f32\n+\n+(define_insn \"*aarch64_mulx_elt<mode>\"\n+  [(set (match_operand:VDQF 0 \"register_operand\" \"=w\")\n+\t(unspec:VDQF\n+\t [(match_operand:VDQF 1 \"register_operand\" \"w\")\n+\t  (vec_duplicate:VDQF\n+\t   (vec_select:<VEL>\n+\t    (match_operand:VDQF 2 \"register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 3 \"immediate_operand\" \"i\")])))]\n+\t UNSPEC_FMULX))]\n+  \"TARGET_SIMD\"\n+  {\n+    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    return \"fmulx\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n+  }\n+  [(set_attr \"type\" \"neon_fp_mul_<Vetype><q>\")]\n+)\n+\n+;; vmulxq_lane_f64\n+\n+(define_insn \"*aarch64_mulx_elt_to_64v2df\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=w\")\n+\t(unspec:V2DF\n+\t [(match_operand:V2DF 1 \"register_operand\" \"w\")\n+\t  (vec_duplicate:V2DF\n+\t    (match_operand:DF 2 \"register_operand\" \"w\"))]\n+\t UNSPEC_FMULX))]\n+  \"TARGET_SIMD\"\n+  {\n+    return \"fmulx\\t%0.2d, %1.2d, %2.d[0]\";\n+  }\n+  [(set_attr \"type\" \"neon_fp_mul_d_scalar_q\")]\n+)\n+\n+;; vmulxs_lane_f32, vmulxs_laneq_f32\n+;; vmulxd_lane_f64 ==  vmulx_lane_f64\n+;; vmulxd_laneq_f64 == vmulx_laneq_f64\n+\n+(define_insn \"*aarch64_vgetfmulx<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\" \"=w\")\n+\t(unspec:<VEL>\n+\t [(match_operand:<VEL> 1 \"register_operand\" \"w\")\n+\t  (vec_select:<VEL>\n+\t   (match_operand:VDQF_DF 2 \"register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 3 \"immediate_operand\" \"i\")]))]\n+\t UNSPEC_FMULX))]\n+  \"TARGET_SIMD\"\n+  {\n+    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    return \"fmulx\\t%<Vetype>0, %<Vetype>1, %2.<Vetype>[%3]\";\n+  }\n+  [(set_attr \"type\" \"fmul<Vetype>\")]\n+)\n ;; <su>q<addsub>\n \n (define_insn \"aarch64_<su_optab><optab><mode>\""}, {"sha": "138b108ff36cf63f5cd42aa4547c0291ea6cf2c7", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -8509,32 +8509,6 @@ vmulq_n_u32 (uint32x4_t a, uint32_t b)\n   return result;\n }\n \n-#define vmulxq_lane_f32(a, b, c)                                        \\\n-  __extension__                                                         \\\n-    ({                                                                  \\\n-       float32x4_t b_ = (b);                                            \\\n-       float32x4_t a_ = (a);                                            \\\n-       float32x4_t result;                                              \\\n-       __asm__ (\"fmulx %0.4s,%1.4s,%2.s[%3]\"                            \\\n-                : \"=w\"(result)                                          \\\n-                : \"w\"(a_), \"w\"(b_), \"i\"(c)                              \\\n-                : /* No clobbers */);                                   \\\n-       result;                                                          \\\n-     })\n-\n-#define vmulxq_lane_f64(a, b, c)                                        \\\n-  __extension__                                                         \\\n-    ({                                                                  \\\n-       float64x2_t b_ = (b);                                            \\\n-       float64x2_t a_ = (a);                                            \\\n-       float64x2_t result;                                              \\\n-       __asm__ (\"fmulx %0.2d,%1.2d,%2.d[%3]\"                            \\\n-                : \"=w\"(result)                                          \\\n-                : \"w\"(a_), \"w\"(b_), \"i\"(c)                              \\\n-                : /* No clobbers */);                                   \\\n-       result;                                                          \\\n-     })\n-\n __extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))\n vmvn_p8 (poly8x8_t a)\n {\n@@ -17270,6 +17244,78 @@ vmulxd_f64 (float64_t __a, float64_t __b)\n   return __builtin_aarch64_fmulxdf (__a, __b);\n }\n \n+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n+vmulx_lane_f32 (float32x2_t __a, float32x2_t __v, const int __lane)\n+{\n+  return vmulx_f32 (__a, __aarch64_vdup_lane_f32 (__v, __lane));\n+}\n+\n+__extension__ static __inline float64x1_t __attribute__ ((__always_inline__))\n+vmulx_lane_f64 (float64x1_t __a, float64x1_t __v, const int __lane)\n+{\n+  return vmulx_f64 (__a, __aarch64_vdup_lane_f64 (__v, __lane));\n+}\n+\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vmulxq_lane_f32 (float32x4_t __a, float32x2_t __v, const int __lane)\n+{\n+  return vmulxq_f32 (__a, __aarch64_vdupq_lane_f32 (__v, __lane));\n+}\n+\n+__extension__ static __inline float64x2_t __attribute__ ((__always_inline__))\n+vmulxq_lane_f64 (float64x2_t __a, float64x1_t __v, const int __lane)\n+{\n+  return vmulxq_f64 (__a, __aarch64_vdupq_lane_f64 (__v, __lane));\n+}\n+\n+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n+vmulx_laneq_f32 (float32x2_t __a, float32x4_t __v, const int __lane)\n+{\n+  return vmulx_f32 (__a, __aarch64_vdup_laneq_f32 (__v, __lane));\n+}\n+\n+__extension__ static __inline float64x1_t __attribute__ ((__always_inline__))\n+vmulx_laneq_f64 (float64x1_t __a, float64x2_t __v, const int __lane)\n+{\n+  return vmulx_f64 (__a, __aarch64_vdup_laneq_f64 (__v, __lane));\n+}\n+\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vmulxq_laneq_f32 (float32x4_t __a, float32x4_t __v, const int __lane)\n+{\n+  return vmulxq_f32 (__a, __aarch64_vdupq_laneq_f32 (__v, __lane));\n+}\n+\n+__extension__ static __inline float64x2_t __attribute__ ((__always_inline__))\n+vmulxq_laneq_f64 (float64x2_t __a, float64x2_t __v, const int __lane)\n+{\n+  return vmulxq_f64 (__a, __aarch64_vdupq_laneq_f64 (__v, __lane));\n+}\n+\n+__extension__ static __inline float32_t __attribute__ ((__always_inline__))\n+vmulxs_lane_f32 (float32_t __a, float32x2_t __v, const int __lane)\n+{\n+  return vmulxs_f32 (__a, __aarch64_vget_lane_any (__v, __lane));\n+}\n+\n+__extension__ static __inline float32_t __attribute__ ((__always_inline__))\n+vmulxs_laneq_f32 (float32_t __a, float32x4_t __v, const int __lane)\n+{\n+  return vmulxs_f32 (__a, __aarch64_vget_lane_any (__v, __lane));\n+}\n+\n+__extension__ static __inline float64_t __attribute__ ((__always_inline__))\n+vmulxd_lane_f64 (float64_t __a, float64x1_t __v, const int __lane)\n+{\n+  return vmulxd_f64 (__a, __aarch64_vget_lane_any (__v, __lane));\n+}\n+\n+__extension__ static __inline float64_t __attribute__ ((__always_inline__))\n+vmulxd_laneq_f64 (float64_t __a, float64x2_t __v, const int __lane)\n+{\n+  return vmulxd_f64 (__a, __aarch64_vget_lane_any (__v, __lane));\n+}\n+\n /* vpmax  */\n \n __extension__ static __inline int8x8_t __attribute__ ((__always_inline__))"}, {"sha": "3c1a9534be7f223c9645242d84e6c186158f982e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -1,3 +1,18 @@\n+2015-11-22  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\n+\t* gcc.target/aarch64/simd/vmulx_lane_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulx_lane_f64_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulx_laneq_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulx_laneq_f64_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxq_lane_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxq_lane_f64_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxq_laneq_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxq_laneq_f64_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxs_lane_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxs_laneq_f32_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxd_lane_f64_1.c: New.\n+\t* gcc.target/aarch64/simd/vmulxd_laneq_f64_1.c: New.\n+\n 2015-11-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/simplify_cshift_1.f90: New test."}, {"sha": "4f80678b2df32cff3237fb98354bee5754bf88f4", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx_lane_f32_1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,70 @@\n+/* Test the vmulx_lane_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_lane0_f32 (float32x2_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulx_lane_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_lane1_f32 (float32x2_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulx_lane_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+void\n+test_case (float32_t v1[2], float32_t v2[2], float32_t e1[2], float32_t e2[2])\n+{\n+  int i;\n+  float32x2_t vec1_1 = vld1_f32 (v1);\n+  float32x2_t vec1_2 = vld1_f32 (v2);\n+\n+\n+  float32x2_t actual1 = test_vmulx_lane0_f32 (vec1_1, vec1_2);\n+  float32_t actual1_1[2];\n+  vst1_f32 (actual1_1, actual1);\n+\n+  for (i = 0; i < 2; ++i)\n+    if (actual1_1[i] != e1[i])\n+      abort ();\n+\n+  float32x2_t actual2 = test_vmulx_lane1_f32 (vec1_1, vec1_2);\n+  float32_t actual2_1[2];\n+  vst1_f32 (actual2_1, actual2);\n+\n+  for (i = 0; i < 2; ++i)\n+    if (actual2_1[i] != e2[i])\n+      abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  float32_t v1 = 3.14159265359;\n+  float32_t v2 = 1.383894;\n+  float32_t v3 = -2.71828;\n+  float32_t v4 = -3.4891931;\n+\n+  float32_t v1_1[] = {v1, v2};\n+  float32_t v1_2[] = {v3, v4};\n+  float32_t e1_1[] = {v1 * v3, v2 * v3};\n+  float32_t e1_2[] = {v1 * v4, v2 * v4};\n+  test_case (v1_1, v1_2, e1_1, e1_2);\n+\n+  float32_t v2_1[] = {0, -0.0};\n+  float32_t v2_2[] = {__builtin_huge_valf (), -__builtin_huge_valf ()};\n+  float32_t e2_1[] = {2.0, -2.0};\n+  float32_t e2_2[] = {-2.0, 2.0};\n+  test_case (v2_1, v2_2, e2_1, e2_2);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "0ebdb963f60659843e505f57a2916a5a88f23ec3", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx_lane_f64_1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_lane_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,62 @@\n+/* Test the vmulx_lane_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64x1_t __attribute__ ((noinline))\n+test_vmulx_lane_f64 (float64x1_t vec1_1, float64x1_t vec1_2)\n+{\n+  return vmulx_lane_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+void\n+test_case (float64_t v1[], float64_t v2[], float64_t e[])\n+{\n+  float64x1_t vec1_1 = vld1_f64 (v1);\n+  float64x1_t vec1_2 = vld1_f64 (v2);\n+  float64x1_t expected1 = vld1_f64 (e);\n+\n+  float64x1_t actual1 = test_vmulx_lane_f64 (vec1_1, vec1_2);\n+  float64_t actual[1];\n+  vst1_f64 (actual, actual1);\n+  if (actual[0] != e[0])\n+    abort ();\n+}\n+int\n+main (void)\n+{\n+  float64_t v1 = 3.14159265359;\n+  float64_t v2 = -2.71828;\n+\n+  float64_t v1_1[] = {v1};\n+  float64_t v1_2[] =  {v2};\n+  float64_t e1[] = {v1 * v2};\n+  test_case (v1_1, v1_2, e1);\n+\n+  float64_t v2_1[] = {0};\n+  float64_t v2_2[] = {__builtin_huge_val ()};\n+  float64_t e2[] = {2.0};\n+  test_case (v2_1, v2_2, e2);\n+\n+  float64_t v4_1[] = {0};\n+  float64_t v4_2[] = {-__builtin_huge_val ()};\n+  float64_t e4[] = {-2.0};\n+  test_case (v4_1, v4_2, e4);\n+\n+  float64_t v5_1[] = {-0.0};\n+  float64_t v5_2[] = {__builtin_huge_val ()};\n+  float64_t e5[] = {-2.0};\n+  test_case (v5_1, v5_2, e5);\n+\n+  float64_t v6_1[] = {-0.0};\n+  float64_t v6_2[] = {-__builtin_huge_val ()};\n+  float64_t e6[] = {2.0};\n+  test_case (v6_1, v6_2, e6);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 1 } } */"}, {"sha": "3e968b7c277155c20721c45f074b4bfe02431d23", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx_laneq_f32_1.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,111 @@\n+/* Test the vmulx_laneq_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_laneq_f32_lane0 (float32x2_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulx_laneq_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_laneq_f32_lane1 (float32x2_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulx_laneq_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_laneq_f32_lane2 (float32x2_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulx_laneq_f32 (vec1_1, vec1_2, 2);\n+}\n+\n+float32x2_t __attribute__ ((noinline))\n+test_vmulx_laneq_f32_lane3 (float32x2_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulx_laneq_f32 (vec1_1, vec1_2, 3);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP0, EXP1, EXP2, EXP3, I)\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float32_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float32x2_t vec1 = vld1_f32 (vec1_data);\t\t\t\t\\\n+    float32_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float32x4_t vec2 = vld1q_f32 (vec2_data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32_t expected_lane0[] = EXP0;\t\t\t\t\t\\\n+    float32_t expected_lane1[] = EXP1;\t\t\t\t\t\\\n+    float32_t expected_lane2[] = EXP2;\t\t\t\t\t\\\n+    float32_t expected_lane3[] = EXP3;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x2_t actual_lane0_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f32_lane0 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane0[2];\t\t\t\t\t\t\\\n+    vst1_f32 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    if (actual_lane0[0] != expected_lane0[0]\t\t\t\t\\\n+\t|| actual_lane0[1] != expected_lane0[1])\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x2_t actual_lane1_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f32_lane1 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane1[2];\t\t\t\t\t\t\\\n+    vst1_f32 (actual_lane1, actual_lane1_v);\t\t\t\t\\\n+    if (actual_lane1[0] != expected_lane1[0]\t\t\t\t\\\n+\t|| actual_lane1[1] != expected_lane1[1])\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x2_t actual_lane2_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f32_lane2 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane2[2];\t\t\t\t\t\t\\\n+    vst1_f32 (actual_lane2, actual_lane2_v);\t\t\t\t\\\n+    if (actual_lane2[0] != expected_lane2[0]\t\t\t\t\\\n+\t|| actual_lane2[1] != expected_lane2[1])\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x2_t actual_lane3_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f32_lane3 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane3[2];\t\t\t\t\t\t\\\n+    vst1_f32 (actual_lane3, actual_lane3_v);\t\t\t\t\\\n+    if (actual_lane3[0] != expected_lane3[0]\t\t\t\t\\\n+\t|| actual_lane3[1] != expected_lane3[1])\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float32_t v1 = 3.14159265359;\n+float32_t v2 = 1.383894;\n+float32_t v3 = -2.71828;\n+float32_t v4 = -3.4891931;\n+\n+float32_t v5 = 0.0;\n+float32_t v6 = -0.0;\n+float32_t v7 = __builtin_huge_valf ();\n+float32_t v8 = -__builtin_huge_valf ();\n+\n+SETUP_VEC (PASS_ARRAY (v1, v2), PASS_ARRAY (v1, v2, v3, v4),\n+\t   PASS_ARRAY (v1*v1, v1*v2), PASS_ARRAY (v1*v2, v2*v2),\n+\t   PASS_ARRAY (v1*v3, v2*v3), PASS_ARRAY (v1*v4, v2*v4), 1)\n+\n+SETUP_VEC (PASS_ARRAY (v5, v6), PASS_ARRAY (v5, v6, v7, v8),\n+\t   PASS_ARRAY (0.0, -0.0), PASS_ARRAY (-0.0, 0.0),\n+\t   PASS_ARRAY (2.0, -2.0), PASS_ARRAY (-2.0, 2.0), 2)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[2\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[3\\\\\\]\\n\" 1 } } */"}, {"sha": "db79d5355bc925098555788c0dd09c99029576c7", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx_laneq_f64_1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_laneq_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,76 @@\n+/* Test the vmulx_laneq_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64x1_t __attribute__ ((noinline))\n+test_vmulx_laneq_f64_lane0 (float64x1_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulx_laneq_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+float64x1_t __attribute__ ((noinline))\n+test_vmulx_laneq_f64_lane1 (float64x1_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulx_laneq_f64 (vec1_1, vec1_2, 1);\n+}\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP1, EXP2, I)\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float64_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float64x1_t vec1 = vld1_f64 (vec1_data);\t\t\t\t\\\n+    float64_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float64x2_t vec2 = vld1q_f64 (vec2_data);\t\t\t\t\\\n+    float64_t expected_lane0[] = EXP1;\t\t\t\t\t\\\n+    float64_t expected_lane1[] = EXP2;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64x1_t actual_lane0_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f64_lane0 (vec1, vec2);\t\t\t\t\\\n+    float64_t actual_lane0[1];\t\t\t\t\t\t\\\n+    vst1_f64 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    if (actual_lane0[0] != expected_lane0[0])\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64x1_t actual_lane1_v =\t\t\t\t\t\\\n+      test_vmulx_laneq_f64_lane1 (vec1, vec2);\t\t\t\t\\\n+    float64_t actual_lane1[1];\t\t\t\t\t\t\\\n+    vst1_f64 (actual_lane1, actual_lane1_v);\t\t\t\t\\\n+    if (actual_lane1[0] != expected_lane1[0])\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float64_t v1 = 3.14159265359;\n+float64_t v2 = 1.383894;\n+float64_t v3 = -2.71828;\n+\n+float64_t v4 = 0.0;\n+float64_t v5 = __builtin_huge_val ();\n+float64_t v6 = -__builtin_huge_val ();\n+\n+float64_t v7 = -0.0;\n+float64_t v8 = __builtin_huge_val ();\n+float64_t v9 = -__builtin_huge_val ();\n+\n+SETUP_VEC (PASS_ARRAY (v1), PASS_ARRAY (v2, v3), PASS_ARRAY (v1*v2),\n+\t   PASS_ARRAY (v1*v3), 1)\n+SETUP_VEC (PASS_ARRAY (v4), PASS_ARRAY (v5, v6), PASS_ARRAY (2.0),\n+\t   PASS_ARRAY (-2.0), 2)\n+SETUP_VEC (PASS_ARRAY (v7), PASS_ARRAY (v8, v9), PASS_ARRAY (-2.0),\n+\t   PASS_ARRAY (2.0), 3)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "b0bf180ef1ac1416f50baa355a095b59505cd5b5", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxd_lane_f64_1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_lane_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_lane_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_lane_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,54 @@\n+/* Test the vmulxd_lane_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64_t __attribute__ ((noinline))\n+test_vmulxd_lane_f64_lane0 (float64_t vec1_1, float64x1_t vec1_2)\n+{\n+  return vmulxd_lane_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP1, I)\t\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float64_t vec1 = V1_D;\t\t\t\t\t\t\\\n+    float64_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float64x1_t vec2 = vld1_f64 (vec2_data);\t\t\t\t\\\n+    float64_t expected_lane0 = EXP1;\t\t\t\t\t\\\n+    float64_t actual_lane0 = test_vmulxd_lane_f64_lane0 (vec1, vec2);\t\\\n+    if (actual_lane0 != expected_lane0)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float64_t v1 = 3.14159265359;\n+float64_t v2 = 1.383894;\n+\n+float64_t v4 = 0.0;\n+float64_t v5 = -0.0;\n+float64_t v6 = __builtin_huge_val ();\n+float64_t v7 = -__builtin_huge_val ();\n+\n+SETUP_VEC (v1, PASS_ARRAY (v2), v1*v2, 1)\n+SETUP_VEC (v4, PASS_ARRAY (v6), 2.0, 2)\n+SETUP_VEC (v4, PASS_ARRAY (v7), -2.0, 3)\n+SETUP_VEC (v5, PASS_ARRAY (v6), -2.0, 4)\n+SETUP_VEC (v5, PASS_ARRAY (v7), 2.0, 5)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  set_and_test_case4 ();\n+  set_and_test_case5 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?(?:\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[0\\\\\\]|\\[dD\\]\\[0-9\\])\\n\" 1 } } */"}, {"sha": "3f8303c574ff40967c5b9ce5a152d70c4a11a9dc", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxd_laneq_f64_1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_laneq_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_laneq_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_laneq_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,62 @@\n+/* Test the vmulxd_laneq_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64_t __attribute__ ((noinline))\n+test_vmulxd_laneq_f64_lane0 (float64_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulxd_laneq_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+float64_t __attribute__ ((noinline))\n+test_vmulxd_laneq_f64_lane1 (float64_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulxd_laneq_f64 (vec1_1, vec1_2, 1);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP1, EXP2, I)\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float64_t vec1 = V1_D;\t\t\t\t\t\t\\\n+    float64_t vec2_data[] = V2_D;\t\t\t\t\t\\\n+    float64x2_t vec2 = vld1q_f64 (vec2_data);\t\t\t\t\\\n+    float64_t expected_lane0 = EXP1;\t\t\t\t\t\\\n+    float64_t expected_lane1 = EXP2;\t\t\t\t\t\\\n+    float64_t actual_lane0 = test_vmulxd_laneq_f64_lane0 (vec1, vec2);\t\\\n+    if (actual_lane0 != expected_lane0)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    float64_t actual_lane1 = test_vmulxd_laneq_f64_lane1 (vec1, vec2);\t\\\n+    if (actual_lane1 != expected_lane1)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float64_t v1 = 3.14159265359;\n+float64_t v2 = 1.383894;\n+float64_t v3 = -2.71828;\n+\n+float64_t v4 = 0.0;\n+float64_t v5 = -0.0;\n+float64_t v6 = __builtin_huge_val ();\n+float64_t v7 = -__builtin_huge_val ();\n+\n+SETUP_VEC (v1, PASS_ARRAY (v2, v3), v1*v2, v1*v3, 1)\n+SETUP_VEC (v4, PASS_ARRAY (v6, v7), 2.0, -2.0, 2)\n+SETUP_VEC (v5, PASS_ARRAY (v6, v7), -2.0, 2.0, 3)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "b5f586019293f6be0b2e6501370883b919bc8ba4", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxq_lane_f32_1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,79 @@\n+/* Test the vmulxq_lane_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_lane_f32_lane0 (float32x4_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulxq_lane_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_lane_f32_lane1 (float32x4_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulxq_lane_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP0, EXP1, I)\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    float32_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float32x4_t vec1 = vld1q_f32 (vec1_data);\t\t\t\t\\\n+    float32_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float32x2_t vec2 = vld1_f32 (vec2_data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32_t expected_lane0[] = EXP0;\t\t\t\t\t\\\n+    float32_t expected_lane1[] = EXP1;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane0_v =\t\t\t\t\t\\\n+      test_vmulxq_lane_f32_lane0 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane0[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane0[i] != expected_lane0[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane1_v =\t\t\t\t\t\\\n+      test_vmulxq_lane_f32_lane1 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane1[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane1, actual_lane1_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane1[i] != expected_lane1[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float32_t v1 = 3.14159265359;\n+float32_t v2 = 1.383894;\n+float32_t v3 = -2.71828;\n+float32_t v4 = -3.4891931;\n+\n+float32_t v5 = 0.0;\n+float32_t v6 = -0.0;\n+float32_t v7 = __builtin_huge_valf ();\n+float32_t v8 = -__builtin_huge_valf ();\n+\n+SETUP_VEC (PASS_ARRAY (v1, v2, v3, v4), PASS_ARRAY (v1, v2),\n+\t   PASS_ARRAY (v1*v1, v2*v1, v3*v1, v4*v1),\n+\t   PASS_ARRAY (v1*v2, v2*v2, v3*v2, v4*v2), 1)\n+\n+SETUP_VEC (PASS_ARRAY (v5, v6, v7, v8), PASS_ARRAY (v5, v6),\n+\t   PASS_ARRAY (0.0, -0.0, 2.0, -2.0),\n+\t   PASS_ARRAY (-0.0, 0.0, -2.0, 2.0), 2)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "703ec6b82d505d19a4eed3c1af729eaaf8885072", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxq_lane_f64_1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_lane_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,61 @@\n+/* Test the vmulxq_lane_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64x2_t __attribute__ ((noinline))\n+test_vmulxq_lane_f64_lane0 (float64x2_t vec1_1, float64x1_t vec1_2)\n+{\n+  return vmulxq_lane_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP0, I)\t\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    float64_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float64x2_t vec1 = vld1q_f64 (vec1_data);\t\t\t\t\\\n+    float64_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float64x1_t vec2 = vld1_f64 (vec2_data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64_t expected_lane0[] = EXP0;\t\t\t\t\t\\\n+    float64x2_t actual_lane0_v\t\t\t\t\t\t\\\n+      = test_vmulxq_lane_f64_lane0 (vec1, vec2);\t\t\t\\\n+    float64_t actual_lane0[2];\t\t\t\t\t\t\\\n+    vst1q_f64 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    for (i = 0; i < 1; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane0[i] != expected_lane0[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float64_t v1 = 3.14159265359;\n+float64_t v2 = 1.383894;\n+\n+float64_t v3 = __builtin_huge_val ();\n+float64_t v4 = -__builtin_huge_val ();\n+\n+float64_t v5 = 0.0;\n+float64_t v6 = -0.0;\n+\n+\n+SETUP_VEC (PASS_ARRAY (v1, v2), PASS_ARRAY (v1), PASS_ARRAY (v1*v1, v2*v1), 1)\n+\n+SETUP_VEC (PASS_ARRAY (v3, v4), PASS_ARRAY (v5), PASS_ARRAY (2.0, -2.0), 2)\n+\n+SETUP_VEC (PASS_ARRAY (v3, v4), PASS_ARRAY (v6), PASS_ARRAY (-2.0, 2.0), 3)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[0\\\\\\]\\n\" 1 } } */"}, {"sha": "264c0c2e6167a1e5d26d8516de20cab411b78d8d", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxq_laneq_f32_1.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,118 @@\n+/* Test the vmulxq_laneq_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f32_lane0 (float32x4_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxq_laneq_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f32_lane1 (float32x4_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxq_laneq_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f32_lane2 (float32x4_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxq_laneq_f32 (vec1_1, vec1_2, 2);\n+}\n+\n+float32x4_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f32_lane3 (float32x4_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxq_laneq_f32 (vec1_1, vec1_2, 3);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP0, EXP1, EXP2, EXP3, I)\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    float32_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float32x4_t vec1 = vld1q_f32 (vec1_data);\t\t\t\t\\\n+    float32_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float32x4_t vec2 = vld1q_f32 (vec2_data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32_t expected_lane0[] = EXP0;\t\t\t\t\t\\\n+    float32_t expected_lane1[] = EXP1;\t\t\t\t\t\\\n+    float32_t expected_lane2[] = EXP2;\t\t\t\t\t\\\n+    float32_t expected_lane3[] = EXP3;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane0_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f32_lane0 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane0[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane0[i] != expected_lane0[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane1_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f32_lane1 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane1[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane1, actual_lane1_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane1[i] != expected_lane1[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane2_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f32_lane2 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane2[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane2, actual_lane2_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane2[i] != expected_lane2[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float32x4_t actual_lane3_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f32_lane3 (vec1, vec2);\t\t\t\t\\\n+    float32_t actual_lane3[4];\t\t\t\t\t\t\\\n+    vst1q_f32 (actual_lane3, actual_lane3_v);\t\t\t\t\\\n+    for (i = 0; i < 4; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane3[i] != expected_lane3[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float32_t v1 = 3.14159265359;\n+float32_t v2 = 1.383894;\n+float32_t v3 = -2.71828;\n+float32_t v4 = -3.4891931;\n+\n+float32_t v5 = 0.0;\n+float32_t v6 = -0.0;\n+float32_t v7 = __builtin_huge_valf ();\n+float32_t v8 = -__builtin_huge_valf ();\n+\n+float32_t spec = __builtin_huge_valf () * __builtin_huge_valf ();\n+float32_t spec_n = -__builtin_huge_valf () * __builtin_huge_valf ();\n+\n+SETUP_VEC (PASS_ARRAY (v1, v2, v3, v4), PASS_ARRAY (v1, v2, v3, v4),\n+\t   PASS_ARRAY (v1*v1, v1*v2, v1*v3, v1*v4),\n+\t   PASS_ARRAY (v1*v2, v2*v2, v2*v3, v2*v4),\n+\t   PASS_ARRAY (v1*v3, v2*v3, v3*v3, v4*v3),\n+\t   PASS_ARRAY (v1*v4, v2*v4, v3*v4, v4*v4), 1)\n+\n+SETUP_VEC (PASS_ARRAY (v5, v6, v7, v8), PASS_ARRAY (v5, v6, v7, v8),\n+\t   PASS_ARRAY (0.0, -0.0, 2.0, -2.0),\n+\t   PASS_ARRAY (-0.0, 0.0, -2.0, 2.0),\n+\t   PASS_ARRAY (2.0, -2.0, spec, spec_n),\n+\t   PASS_ARRAY (-2.0, 2.0, spec_n, spec), 2)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[2\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.4\\[sS\\], ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[3\\\\\\]\\n\" 1 } } */"}, {"sha": "14e9852b32da6a4609117c35bbc85f564f82c350", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxq_laneq_f64_1.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f64_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f64_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxq_laneq_f64_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,78 @@\n+/* Test the vmulxq_laneq_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float64x2_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f64_lane0 (float64x2_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulxq_laneq_f64 (vec1_1, vec1_2, 0);\n+}\n+\n+float64x2_t __attribute__ ((noinline))\n+test_vmulxq_laneq_f64_lane1 (float64x2_t vec1_1, float64x2_t vec1_2)\n+{\n+  return vmulxq_laneq_f64 (vec1_1, vec1_2, 1);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP0, EXP1, I)\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    float64_t vec1_data[] = V1_D;\t\t\t\t\t\\\n+    float64x2_t vec1 = vld1q_f64 (vec1_data);\t\t\t\t\\\n+    float64_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float64x2_t vec2 = vld1q_f64 (vec2_data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64_t expected_lane0[] = EXP0;\t\t\t\t\t\\\n+    float64_t expected_lane1[] = EXP1;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64x2_t actual_lane0_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f64_lane0 (vec1, vec2);\t\t\t\t\\\n+    float64_t actual_lane0[2];\t\t\t\t\t\t\\\n+    vst1q_f64 (actual_lane0, actual_lane0_v);\t\t\t\t\\\n+    for (i = 0; i < 2; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane0[i] != expected_lane0[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    float64x2_t actual_lane1_v =\t\t\t\t\t\\\n+      test_vmulxq_laneq_f64_lane1 (vec1, vec2);\t\t\t\t\\\n+    float64_t actual_lane1[2];\t\t\t\t\t\t\\\n+    vst1q_f64 (actual_lane1, actual_lane1_v);\t\t\t\t\\\n+    for (i = 0; i < 2; ++i)\t\t\t\t\t\t\\\n+      if (actual_lane1[i] != expected_lane1[i])\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float64_t v1 = 3.14159265359;\n+float64_t v2 = 1.383894;\n+\n+float64_t v3 = 0.0;\n+float64_t v4 = -0.0;\n+float64_t v5 = __builtin_huge_val ();\n+float64_t v6 = -__builtin_huge_val ();\n+\n+float64_t spec = __builtin_huge_val () * __builtin_huge_val ();\n+\n+SETUP_VEC (PASS_ARRAY (v1, v2), PASS_ARRAY (v1, v2), PASS_ARRAY (v1*v1, v2*v1),\n+\t   PASS_ARRAY (v1*v2, v2*v2), 1)\n+\n+SETUP_VEC (PASS_ARRAY (v3, v4), PASS_ARRAY (v5, v6), PASS_ARRAY (2.0, -2.0),\n+\t   PASS_ARRAY (-2.0, 2.0), 2)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.2\\[dD\\], ?\\[vV\\]\\[0-9\\]+\\.\\[dD\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "124dcd8c4ec187b38ffb03606fad4121d9280451", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxs_lane_f32_1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_lane_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_lane_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_lane_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,61 @@\n+/* Test the vmulxs_lane_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_lane_f32_lane0 (float32_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulxs_lane_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_lane_f32_lane1 (float32_t vec1_1, float32x2_t vec1_2)\n+{\n+  return vmulxs_lane_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP1, EXP2, I)\t\t\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float32_t vec1 = V1_D;\t\t\t\t\t\t\\\n+    float32_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float32x2_t vec2 = vld1_f32 (vec2_data);\t\t\t\t\\\n+    float32_t expected_lane0 = EXP1;\t\t\t\t\t\\\n+    float32_t expected_lane1 = EXP2;\t\t\t\t\t\\\n+    float32_t actual_lane0 = test_vmulxs_lane_f32_lane0 (vec1, vec2);\t\\\n+    if (actual_lane0 != expected_lane0)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    float32_t actual_lane1 = test_vmulxs_lane_f32_lane1 (vec1, vec2);\t\\\n+    if (actual_lane1 != expected_lane1)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float32_t v1 = 3.14159265359;\n+float32_t v2 = 1.383894;\n+\n+float32_t v4 = 0.0;\n+float32_t v5 = -0.0;\n+float32_t v6 = __builtin_huge_valf ();\n+float32_t v7 = -__builtin_huge_valf ();\n+\n+SETUP_VEC (v1, PASS_ARRAY (v1, v2), v1*v1, v1*v2, 1)\n+SETUP_VEC (v4, PASS_ARRAY (v6, v7), 2.0, -2.0, 2)\n+SETUP_VEC (v5, PASS_ARRAY (v6, v7), -2.0, 2.0, 3)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */"}, {"sha": "255f0968822ffee7f3429c5997b02e3fcfca68f3", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxs_laneq_f32_1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_laneq_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9030a4d3aa90c1db1a657fe5588c823f0ea73a86/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_laneq_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_laneq_f32_1.c?ref=9030a4d3aa90c1db1a657fe5588c823f0ea73a86", "patch": "@@ -0,0 +1,85 @@\n+/* Test the vmulxs_laneq_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort (void);\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_laneq_f32_lane0 (float32_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxs_laneq_f32 (vec1_1, vec1_2, 0);\n+}\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_laneq_f32_lane1 (float32_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxs_laneq_f32 (vec1_1, vec1_2, 1);\n+}\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_laneq_f32_lane2 (float32_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxs_laneq_f32 (vec1_1, vec1_2, 2);\n+}\n+\n+float32_t __attribute__ ((noinline))\n+test_vmulxs_laneq_f32_lane3 (float32_t vec1_1, float32x4_t vec1_2)\n+{\n+  return vmulxs_laneq_f32 (vec1_1, vec1_2, 3);\n+}\n+\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_VEC(V1_D, V2_D, EXP1, EXP2, EXP3, EXP4, I)\t\t\\\n+  void set_and_test_case##I ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    float32_t vec1 = V1_D;\t\t\t\t\t\t\\\n+    float32_t vec2_data[] =  V2_D;\t\t\t\t\t\\\n+    float32x4_t vec2 = vld1q_f32 (vec2_data);\t\t\t\t\\\n+    float32_t expected_lane0 = EXP1;\t\t\t\t\t\\\n+    float32_t expected_lane1 = EXP2;\t\t\t\t\t\\\n+    float32_t expected_lane2 = EXP3;\t\t\t\t\t\\\n+    float32_t expected_lane3 = EXP4;\t\t\t\t\t\\\n+    float32_t actual_lane0 = test_vmulxs_laneq_f32_lane0 (vec1, vec2);\t\\\n+    if (actual_lane0 != expected_lane0)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    float32_t actual_lane1 = test_vmulxs_laneq_f32_lane1 (vec1, vec2);\t\\\n+    if (actual_lane1 != expected_lane1)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    float32_t actual_lane2 = test_vmulxs_laneq_f32_lane2 (vec1, vec2);\t\\\n+    if (actual_lane2 != expected_lane2)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    float32_t actual_lane3 = test_vmulxs_laneq_f32_lane3 (vec1, vec2);\t\\\n+    if (actual_lane3 != expected_lane3)\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+float32_t v1 = 3.14159265359;\n+float32_t v2 = 1.383894;\n+float32_t v3 = -2.71828;\n+float32_t v4 = -3.4891931;\n+\n+float32_t v5 = 0.0;\n+float32_t v6 = -0.0;\n+float32_t v7 = __builtin_huge_valf ();\n+float32_t v8 = -__builtin_huge_valf ();\n+\n+SETUP_VEC (v1, PASS_ARRAY (v1, v2, v3, v4), v1*v1, v1*v2, v3*v1, v1*v4, 1)\n+SETUP_VEC (v5, PASS_ARRAY (v5, v6, v7, v8), 0.0, -0.0, 2.0, -2.0, 2)\n+SETUP_VEC (v6, PASS_ARRAY (v5, v6, v7, v8), -0.0, 0.0, -2.0, 2.0, 3)\n+\n+int\n+main (void)\n+{\n+  set_and_test_case1 ();\n+  set_and_test_case2 ();\n+  set_and_test_case3 ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[0\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[1\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[2\\\\\\]\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[vV\\]\\[0-9\\]+\\.\\[sS\\]\\\\\\[3\\\\\\]\\n\" 1 } } */"}]}