{"sha": "94fc87ecdf45e2455deb7ee50e13765c98d4e904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmYzg3ZWNkZjQ1ZTI0NTVkZWI3ZWU1MGUxMzc2NWM5OGQ0ZTkwNA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2017-06-08T07:38:42Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2017-06-08T07:38:42Z"}, "message": "re PR middle-end/77925 (Add __builtin_issubnormal)\n\n2017-06-08  Tamar Christina  <tamar.christina@arm.com>\n\n\tPR middle-end/77925\n\tPR middle-end/77926\n\tPR middle-end/66462\n\n\t* gcc/builtins.c (fold_builtin_fpclassify): Remove.\n\t(fold_builtin_interclass_mathfn): Remove.\n\t(expand_builtin): Add builtins to lowering list.\n\t(fold_builtin_n): Remove fold_builtin_varargs.\n\t(fold_builtin_varargs): Remove.\n\t* gcc/builtins.def (BUILT_IN_ISZERO, BUILT_IN_ISSUBNORMAL): New.\n\t* gcc/real.h (get_min_float): New.\n\t(real_format): Add is_ieee_compatible field.\n\t* gcc/real.c (get_min_float): New.\n\t(ieee_single_format): Set is_ieee_compatible flag.\n\t* gcc/gimple-low.c (lower_stm): Define BUILT_IN_FPCLASSIFY,\n\tCASE_FLT_FN (BUILT_IN_ISINF), BUILT_IN_ISINFD32, BUILT_IN_ISINFD64,\n\tBUILT_IN_ISINFD128, BUILT_IN_ISNAND32, BUILT_IN_ISNAND64,\n\tBUILT_IN_ISNAND128, BUILT_IN_ISNAN, BUILT_IN_ISNORMAL, BUILT_IN_ISZERO,\n\tBUILT_IN_ISSUBNORMAL, CASE_FLT_FN (BUILT_IN_FINITE), BUILT_IN_FINITED32\n\tBUILT_IN_FINITED64, BUILT_IN_FINITED128, BUILT_IN_ISFINITE.\n\t(lower_builtin_fpclassify, is_nan, is_normal, is_infinity): New.\n\t(is_zero, is_subnormal, is_finite, use_ieee_int_mode): Likewise.\n\t(lower_builtin_isnan, lower_builtin_isinfinite): Likewise.\n\t(lower_builtin_isnormal, lower_builtin_iszero): Likewise.\n\t(lower_builtin_issubnormal, lower_builtin_isfinite): Likewise.\n\t(emit_tree_cond, get_num_as_int, emit_tree_and_return_var): New.\n\t(mips_single_format): Likewise.\n\t(motorola_single_format): Likewise.\n\t(spu_single_format): Likewise.\n\t(ieee_double_format): Likewise.\n\t(mips_double_format): Likewise.\n\t(motorola_double_format): Likewise.\n\t(ieee_extended_motorola_format): Likewise.\n\t(ieee_extended_intel_128_format): Likewise.\n\t(ieee_extended_intel_96_round_53_format): Likewise.\n\t(ibm_extended_format): Likewise.\n\t(mips_extended_format): Likewise.\n\t(ieee_quad_format): Likewise.\n\t(mips_quad_format): Likewise.\n\t(vax_f_format): Likewise.\n\t(vax_d_format): Likewise.\n\t(vax_g_format): Likewise.\n\t(decimal_single_format): Likewise.\n\t(decimal_quad_format): Likewise.\n\t(iee_half_format): Likewise.\n\t(mips_single_format): Likewise.\n\t(arm_half_format): Likewise.\n\t(real_internal_format): Likewise.\n\t* gcc/doc/extend.texi: Add documentation for built-ins.\n\t* gcc/c/c-typeck.c (convert_arguments): Add BUILT_IN_ISZERO\n\tand BUILT_IN_ISSUBNORMAL.\n\ngcc/testsuite/\n2017-06-08  Tamar Christina  <tamar.christina@arm.com>\n\n\t* gcc.target/aarch64/builtin-fpclassify.c: New codegen test.\n\t* gcc.dg/fold-notunord.c: Removed.\n\t* gcc.dg/torture/floatn-tg-4.h: Add tests for iszero and issubnormal.\n\t* gcc.dg/torture/float128-tg-4.c: Likewise.\n\t* gcc.dg/torture/float128x-tg-4: Likewise.\n\t* gcc.dg/torture/float16-tg-4.c: Likewise.\n\t* gcc.dg/torture/float32-tg-4.c: Likewise.\n\t* gcc.dg/torture/float32x-tg-4.c: Likewise.\n\t* gcc.dg/torture/float64-tg-4.c: Likewise.\n\t* gcc.dg/torture/float64x-tg-4.c: Likewise.\n\t* gcc.dg/pr28796-1.c: Add -O2.\n\t* gcc.dg/builtins-43.c: Check lower instead of gimple.\n\t* gcc.dg/tg-tests.h: Add iszero and issubnormal.\n\t* gcc.dg/pr77925.c: Add to test safe cases.\n\nFrom-SVN: r249005", "tree": {"sha": "01e590119900d4a8b6df6a832bb5456d8a7fd03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01e590119900d4a8b6df6a832bb5456d8a7fd03c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94fc87ecdf45e2455deb7ee50e13765c98d4e904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fc87ecdf45e2455deb7ee50e13765c98d4e904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94fc87ecdf45e2455deb7ee50e13765c98d4e904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fc87ecdf45e2455deb7ee50e13765c98d4e904/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb4bc6ff6c08f4e5524fa5e1881b478b0f689155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4bc6ff6c08f4e5524fa5e1881b478b0f689155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4bc6ff6c08f4e5524fa5e1881b478b0f689155"}], "stats": {"total": 1735, "additions": 1355, "deletions": 380}, "files": [{"sha": "15dbf0aebc98e5b7e2c14af85607f1b273064462", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -1,3 +1,57 @@\n+2017-06-08  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR middle-end/77925\n+\tPR middle-end/77926\n+\tPR middle-end/66462\n+\n+\t* gcc/builtins.c (fold_builtin_fpclassify): Remove.\n+\t(fold_builtin_interclass_mathfn): Remove.\n+\t(expand_builtin): Add builtins to lowering list.\n+\t(fold_builtin_n): Remove fold_builtin_varargs.\n+\t(fold_builtin_varargs): Remove.\n+\t* gcc/builtins.def (BUILT_IN_ISZERO, BUILT_IN_ISSUBNORMAL): New.\n+\t* gcc/real.h (get_min_float): New.\n+\t(real_format): Add is_ieee_compatible field.\n+\t* gcc/real.c (get_min_float): New.\n+\t(ieee_single_format): Set is_ieee_compatible flag.\n+\t* gcc/gimple-low.c (lower_stm): Define BUILT_IN_FPCLASSIFY,\n+\tCASE_FLT_FN (BUILT_IN_ISINF), BUILT_IN_ISINFD32, BUILT_IN_ISINFD64,\n+\tBUILT_IN_ISINFD128, BUILT_IN_ISNAND32, BUILT_IN_ISNAND64,\n+\tBUILT_IN_ISNAND128, BUILT_IN_ISNAN, BUILT_IN_ISNORMAL, BUILT_IN_ISZERO,\n+\tBUILT_IN_ISSUBNORMAL, CASE_FLT_FN (BUILT_IN_FINITE), BUILT_IN_FINITED32\n+\tBUILT_IN_FINITED64, BUILT_IN_FINITED128, BUILT_IN_ISFINITE.\n+\t(lower_builtin_fpclassify, is_nan, is_normal, is_infinity): New.\n+\t(is_zero, is_subnormal, is_finite, use_ieee_int_mode): Likewise.\n+\t(lower_builtin_isnan, lower_builtin_isinfinite): Likewise.\n+\t(lower_builtin_isnormal, lower_builtin_iszero): Likewise.\n+\t(lower_builtin_issubnormal, lower_builtin_isfinite): Likewise.\n+\t(emit_tree_cond, get_num_as_int, emit_tree_and_return_var): New.\n+\t(mips_single_format): Likewise.\n+\t(motorola_single_format): Likewise.\n+\t(spu_single_format): Likewise.\n+\t(ieee_double_format): Likewise.\n+\t(mips_double_format): Likewise.\n+\t(motorola_double_format): Likewise.\n+\t(ieee_extended_motorola_format): Likewise.\n+\t(ieee_extended_intel_128_format): Likewise.\n+\t(ieee_extended_intel_96_round_53_format): Likewise.\n+\t(ibm_extended_format): Likewise.\n+\t(mips_extended_format): Likewise.\n+\t(ieee_quad_format): Likewise.\n+\t(mips_quad_format): Likewise.\n+\t(vax_f_format): Likewise.\n+\t(vax_d_format): Likewise.\n+\t(vax_g_format): Likewise.\n+\t(decimal_single_format): Likewise.\n+\t(decimal_quad_format): Likewise.\n+\t(iee_half_format): Likewise.\n+\t(mips_single_format): Likewise.\n+\t(arm_half_format): Likewise.\n+\t(real_internal_format): Likewise.\n+\t* gcc/doc/extend.texi: Add documentation for built-ins.\n+\t* gcc/c/c-typeck.c (convert_arguments): Add BUILT_IN_ISZERO\n+\tand BUILT_IN_ISSUBNORMAL.\n+\n 2017-06-07  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c: The return type of the following"}, {"sha": "254dab6bfa18d4df0a39d114a22b29eb501257e6", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 349, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -165,7 +165,6 @@ static tree fold_builtin_0 (location_t, tree);\n static tree fold_builtin_1 (location_t, tree, tree);\n static tree fold_builtin_2 (location_t, tree, tree, tree);\n static tree fold_builtin_3 (location_t, tree, tree, tree, tree);\n-static tree fold_builtin_varargs (location_t, tree, tree*, int);\n \n static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n static tree fold_builtin_strspn (location_t, tree, tree);\n@@ -2227,19 +2226,8 @@ interclass_mathfn_icode (tree arg, tree fndecl)\n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n     CASE_FLT_FN (BUILT_IN_ILOGB):\n-      errno_set = true; builtin_optab = ilogb_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-      builtin_optab = isinf_optab; break;\n-    case BUILT_IN_ISNORMAL:\n-    case BUILT_IN_ISFINITE:\n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_FINITED32:\n-    case BUILT_IN_FINITED64:\n-    case BUILT_IN_FINITED128:\n-    case BUILT_IN_ISINFD32:\n-    case BUILT_IN_ISINFD64:\n-    case BUILT_IN_ISINFD128:\n-      /* These builtins have no optabs (yet).  */\n+      errno_set = true;\n+      builtin_optab = ilogb_optab;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -2258,8 +2246,7 @@ interclass_mathfn_icode (tree arg, tree fndecl)\n }\n \n /* Expand a call to one of the builtin math functions that operate on\n-   floating point argument and output an integer result (ilogb, isinf,\n-   isnan, etc).\n+   floating point argument and output an integer result (ilogb, etc).\n    Return 0 if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n    function; if convenient, the result should be placed in TARGET.  */\n@@ -6605,11 +6592,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_ILOGB):\n       if (! flag_unsafe_math_optimizations)\n \tbreak;\n-      gcc_fallthrough ();\n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_ISFINITE:\n-    case BUILT_IN_ISNORMAL:\n+\n       target = expand_builtin_interclass_mathfn (exp, target);\n       if (target)\n \treturn target;\n@@ -6917,8 +6900,25 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \t}\n       break;\n \n+    CASE_FLT_FN (BUILT_IN_ISINF):\n+    case BUILT_IN_ISNAND32:\n+    case BUILT_IN_ISNAND64:\n+    case BUILT_IN_ISNAND128:\n+    case BUILT_IN_ISNAN:\n+    case BUILT_IN_ISINFD32:\n+    case BUILT_IN_ISINFD64:\n+    case BUILT_IN_ISINFD128:\n+    case BUILT_IN_ISNORMAL:\n+    case BUILT_IN_ISZERO:\n+    case BUILT_IN_ISSUBNORMAL:\n+    case BUILT_IN_FPCLASSIFY:\n     case BUILT_IN_SETJMP:\n-      /* This should have been lowered to the builtins below.  */\n+    CASE_FLT_FN (BUILT_IN_FINITE):\n+    case BUILT_IN_FINITED32:\n+    case BUILT_IN_FINITED64:\n+    case BUILT_IN_FINITED128:\n+    case BUILT_IN_ISFINITE:\n+      /* These should have been lowered to the builtins in gimple-low.c.  */\n       gcc_unreachable ();\n \n     case BUILT_IN_SETJMP_SETUP:\n@@ -8258,184 +8258,19 @@ fold_builtin_modf (location_t loc, tree arg0, tree arg1, tree rettype)\n   return NULL_TREE;\n }\n \n-/* Given a location LOC, an interclass builtin function decl FNDECL\n-   and its single argument ARG, return an folded expression computing\n-   the same, or NULL_TREE if we either couldn't or didn't want to fold\n-   (the latter happen if there's an RTL instruction available).  */\n-\n-static tree\n-fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n-{\n-  machine_mode mode;\n-\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  if (interclass_mathfn_icode (arg, fndecl) != CODE_FOR_nothing)\n-    return NULL_TREE;\n-\n-  mode = TYPE_MODE (TREE_TYPE (arg));\n-\n-  bool is_ibm_extended = MODE_COMPOSITE_P (mode);\n \n-  /* If there is no optab, try generic code.  */\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-      tree result;\n \n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-      {\n-\t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n-\ttree const isgr_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n-\ttree type = TREE_TYPE (arg);\n-\tREAL_VALUE_TYPE r;\n-\tchar buf[128];\n-\n-\tif (is_ibm_extended)\n-\t  {\n-\t    /* NaN and Inf are encoded in the high-order double value\n-\t       only.  The low-order value is not significant.  */\n-\t    type = double_type_node;\n-\t    mode = DFmode;\n-\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n-\t  }\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&r, buf);\n-\tresult = build_call_expr (isgr_fn, 2,\n-\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n-\t\t\t\t  build_real (type, r));\n-\treturn result;\n-      }\n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_ISFINITE:\n-      {\n-\t/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n-\ttree type = TREE_TYPE (arg);\n-\tREAL_VALUE_TYPE r;\n-\tchar buf[128];\n-\n-\tif (is_ibm_extended)\n-\t  {\n-\t    /* NaN and Inf are encoded in the high-order double value\n-\t       only.  The low-order value is not significant.  */\n-\t    type = double_type_node;\n-\t    mode = DFmode;\n-\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n-\t  }\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&r, buf);\n-\tresult = build_call_expr (isle_fn, 2,\n-\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n-\t\t\t\t  build_real (type, r));\n-\t/*result = fold_build2_loc (loc, UNGT_EXPR,\n-\t\t\t\t  TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n-\t\t\t\t  build_real (type, r));\n-\tresult = fold_build1_loc (loc, TRUTH_NOT_EXPR,\n-\t\t\t\t  TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t\t  result);*/\n-\treturn result;\n-      }\n-    case BUILT_IN_ISNORMAL:\n-      {\n-\t/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &\n-\t   islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n-\ttree type = TREE_TYPE (arg);\n-\ttree orig_arg, max_exp, min_exp;\n-\tmachine_mode orig_mode = mode;\n-\tREAL_VALUE_TYPE rmax, rmin;\n-\tchar buf[128];\n-\n-\torig_arg = arg = builtin_save_expr (arg);\n-\tif (is_ibm_extended)\n-\t  {\n-\t    /* Use double to test the normal range of IBM extended\n-\t       precision.  Emin for IBM extended precision is\n-\t       different to emin for IEEE double, being 53 higher\n-\t       since the low double exponent is at least 53 lower\n-\t       than the high double exponent.  */\n-\t    type = double_type_node;\n-\t    mode = DFmode;\n-\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n-\t  }\n-\targ = fold_build1_loc (loc, ABS_EXPR, type, arg);\n-\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&rmax, buf);\n-\tsprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (orig_mode)->emin - 1);\n-\treal_from_string (&rmin, buf);\n-\tmax_exp = build_real (type, rmax);\n-\tmin_exp = build_real (type, rmin);\n-\n-\tmax_exp = build_call_expr (isle_fn, 2, arg, max_exp);\n-\tif (is_ibm_extended)\n-\t  {\n-\t    /* Testing the high end of the range is done just using\n-\t       the high double, using the same test as isfinite().\n-\t       For the subnormal end of the range we first test the\n-\t       high double, then if its magnitude is equal to the\n-\t       limit of 0x1p-969, we test whether the low double is\n-\t       non-zero and opposite sign to the high double.  */\n-\t    tree const islt_fn = builtin_decl_explicit (BUILT_IN_ISLESS);\n-\t    tree const isgt_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n-\t    tree gt_min = build_call_expr (isgt_fn, 2, arg, min_exp);\n-\t    tree eq_min = fold_build2 (EQ_EXPR, integer_type_node,\n-\t\t\t\t       arg, min_exp);\n-\t    tree as_complex = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t      complex_double_type_node, orig_arg);\n-\t    tree hi_dbl = build1 (REALPART_EXPR, type, as_complex);\n-\t    tree lo_dbl = build1 (IMAGPART_EXPR, type, as_complex);\n-\t    tree zero = build_real (type, dconst0);\n-\t    tree hilt = build_call_expr (islt_fn, 2, hi_dbl, zero);\n-\t    tree lolt = build_call_expr (islt_fn, 2, lo_dbl, zero);\n-\t    tree logt = build_call_expr (isgt_fn, 2, lo_dbl, zero);\n-\t    tree ok_lo = fold_build1 (TRUTH_NOT_EXPR, integer_type_node,\n-\t\t\t\t      fold_build3 (COND_EXPR,\n-\t\t\t\t\t\t   integer_type_node,\n-\t\t\t\t\t\t   hilt, logt, lolt));\n-\t    eq_min = fold_build2 (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t\t\t  eq_min, ok_lo);\n-\t    min_exp = fold_build2 (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t\t\t   gt_min, eq_min);\n-\t  }\n-\telse\n-\t  {\n-\t    tree const isge_fn\n-\t      = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);\n-\t    min_exp = build_call_expr (isge_fn, 2, arg, min_exp);\n-\t  }\n-\tresult = fold_build2 (BIT_AND_EXPR, integer_type_node,\n-\t\t\t      max_exp, min_exp);\n-\treturn result;\n-      }\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.\n+/* Fold a call to __builtin_isinf_sign.\n    ARG is the argument for the call.  */\n \n static tree\n-fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n+fold_builtin_classify (location_t loc, tree arg, int builtin_index)\n {\n-  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\n   if (!validate_arg (arg, REAL_TYPE))\n     return NULL_TREE;\n \n   switch (builtin_index)\n     {\n-    case BUILT_IN_ISINF:\n-      if (!HONOR_INFINITIES (arg))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n-\n-      return NULL_TREE;\n-\n     case BUILT_IN_ISINF_SIGN:\n       {\n \t/* isinf_sign(x) -> isinf(x) ? (signbit(x) ? -1 : 1) : 0 */\n@@ -8468,106 +8303,11 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n \treturn tmp;\n       }\n \n-    case BUILT_IN_ISFINITE:\n-      if (!HONOR_NANS (arg)\n-\t  && !HONOR_INFINITIES (arg))\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n-\n-      return NULL_TREE;\n-\n-    case BUILT_IN_ISNAN:\n-      if (!HONOR_NANS (arg))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n-\n-      {\n-\tbool is_ibm_extended = MODE_COMPOSITE_P (TYPE_MODE (TREE_TYPE (arg)));\n-\tif (is_ibm_extended)\n-\t  {\n-\t    /* NaN and Inf are encoded in the high-order double value\n-\t       only.  The low-order value is not significant.  */\n-\t    arg = fold_build1_loc (loc, NOP_EXPR, double_type_node, arg);\n-\t  }\n-      }\n-      arg = builtin_save_expr (arg);\n-      return fold_build2_loc (loc, UNORDERED_EXPR, type, arg, arg);\n-\n     default:\n       gcc_unreachable ();\n     }\n }\n \n-/* Fold a call to __builtin_fpclassify(int, int, int, int, int, ...).\n-   This builtin will generate code to return the appropriate floating\n-   point classification depending on the value of the floating point\n-   number passed in.  The possible return values must be supplied as\n-   int arguments to the call in the following order: FP_NAN, FP_INFINITE,\n-   FP_NORMAL, FP_SUBNORMAL and FP_ZERO.  The ellipses is for exactly\n-   one floating point argument which is \"type generic\".  */\n-\n-static tree\n-fold_builtin_fpclassify (location_t loc, tree *args, int nargs)\n-{\n-  tree fp_nan, fp_infinite, fp_normal, fp_subnormal, fp_zero,\n-    arg, type, res, tmp;\n-  machine_mode mode;\n-  REAL_VALUE_TYPE r;\n-  char buf[128];\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (nargs != 6\n-      || !validate_arg (args[0], INTEGER_TYPE)\n-      || !validate_arg (args[1], INTEGER_TYPE)\n-      || !validate_arg (args[2], INTEGER_TYPE)\n-      || !validate_arg (args[3], INTEGER_TYPE)\n-      || !validate_arg (args[4], INTEGER_TYPE)\n-      || !validate_arg (args[5], REAL_TYPE))\n-    return NULL_TREE;\n-\n-  fp_nan = args[0];\n-  fp_infinite = args[1];\n-  fp_normal = args[2];\n-  fp_subnormal = args[3];\n-  fp_zero = args[4];\n-  arg = args[5];\n-  type = TREE_TYPE (arg);\n-  mode = TYPE_MODE (type);\n-  arg = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n-\n-  /* fpclassify(x) ->\n-       isnan(x) ? FP_NAN :\n-         (fabs(x) == Inf ? FP_INFINITE :\n-\t   (fabs(x) >= DBL_MIN ? FP_NORMAL :\n-\t     (x == 0 ? FP_ZERO : FP_SUBNORMAL))).  */\n-\n-  tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,\n-\t\t     build_real (type, dconst0));\n-  res = fold_build3_loc (loc, COND_EXPR, integer_type_node,\n-\t\t     tmp, fp_zero, fp_subnormal);\n-\n-  sprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (mode)->emin - 1);\n-  real_from_string (&r, buf);\n-  tmp = fold_build2_loc (loc, GE_EXPR, integer_type_node,\n-\t\t     arg, build_real (type, r));\n-  res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, fp_normal, res);\n-\n-  if (HONOR_INFINITIES (mode))\n-    {\n-      real_inf (&r);\n-      tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,\n-\t\t\t build_real (type, r));\n-      res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp,\n-\t\t\t fp_infinite, res);\n-    }\n-\n-  if (HONOR_NANS (mode))\n-    {\n-      tmp = fold_build2_loc (loc, ORDERED_EXPR, integer_type_node, arg, arg);\n-      res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, res, fp_nan);\n-    }\n-\n-  return res;\n-}\n-\n /* Fold a call to an unordered comparison function such as\n    __builtin_isgreater().  FNDECL is the FUNCTION_DECL for the function\n    being called and ARG0 and ARG1 are the arguments for the call.\n@@ -8868,40 +8608,8 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n     case BUILT_IN_ISDIGIT:\n       return fold_builtin_isdigit (loc, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_FINITED32:\n-    case BUILT_IN_FINITED64:\n-    case BUILT_IN_FINITED128:\n-    case BUILT_IN_ISFINITE:\n-      {\n-\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISFINITE);\n-\tif (ret)\n-\t  return ret;\n-\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-      }\n-\n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-    case BUILT_IN_ISINFD32:\n-    case BUILT_IN_ISINFD64:\n-    case BUILT_IN_ISINFD128:\n-      {\n-\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF);\n-\tif (ret)\n-\t  return ret;\n-\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-      }\n-\n-    case BUILT_IN_ISNORMAL:\n-      return fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-\n     case BUILT_IN_ISINF_SIGN:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF_SIGN);\n-\n-    CASE_FLT_FN (BUILT_IN_ISNAN):\n-    case BUILT_IN_ISNAND32:\n-    case BUILT_IN_ISNAND64:\n-    case BUILT_IN_ISNAND128:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISNAN);\n+      return fold_builtin_classify (loc, arg0, BUILT_IN_ISINF_SIGN);\n \n     case BUILT_IN_FREE:\n       if (integer_zerop (arg0))\n@@ -9098,7 +8806,6 @@ fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool)\n       ret = fold_builtin_3 (loc, fndecl, args[0], args[1], args[2]);\n       break;\n     default:\n-      ret = fold_builtin_varargs (loc, fndecl, args, nargs);\n       break;\n     }\n   if (ret)\n@@ -9989,37 +9696,6 @@ fold_builtin_object_size (tree ptr, tree ost)\n   return NULL_TREE;\n }\n \n-/* Builtins with folding operations that operate on \"...\" arguments\n-   need special handling; we need to store the arguments in a convenient\n-   data structure before attempting any folding.  Fortunately there are\n-   only a few builtins that fall into this category.  FNDECL is the\n-   function, EXP is the CALL_EXPR for the call.  */\n-\n-static tree\n-fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs)\n-{\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree ret = NULL_TREE;\n-\n-  switch (fcode)\n-    {\n-    case BUILT_IN_FPCLASSIFY:\n-      ret = fold_builtin_fpclassify (loc, args, nargs);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  if (ret)\n-    {\n-      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n-      SET_EXPR_LOCATION (ret, loc);\n-      TREE_NO_WARNING (ret) = 1;\n-      return ret;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Initialize format string characters in the target charset.  */\n \n bool"}, {"sha": "db45c0771fb35faba6ae92e4e849a7285b6d0dde", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -845,6 +845,8 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFL, \"isinfl\", BT_FN_INT_LONGDOUBLE, ATTR_CO\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD32, \"isinfd32\", BT_FN_INT_DFLOAT32, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD64, \"isinfd64\", BT_FN_INT_DFLOAT64, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD128, \"isinfd128\", BT_FN_INT_DFLOAT128, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_ISZERO, \"iszero\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_ISSUBNORMAL, \"issubnormal\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ISNAN, \"isnan\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNANF, \"isnanf\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNANL, \"isnanl\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "92aab54d41621b3e3cc9184c22800ca6610717ce", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -3241,6 +3241,8 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \tcase BUILT_IN_ISINF_SIGN:\n \tcase BUILT_IN_ISNAN:\n \tcase BUILT_IN_ISNORMAL:\n+\tcase BUILT_IN_ISZERO:\n+\tcase BUILT_IN_ISSUBNORMAL:\n \tcase BUILT_IN_FPCLASSIFY:\n \t  type_generic_remove_excess_precision = true;\n \t  break;"}, {"sha": "7d3933539e794b54a3109d489a99222a434fd30d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -10501,6 +10501,10 @@ in the Cilk Plus language manual which can be found at\n @findex __builtin_isgreater\n @findex __builtin_isgreaterequal\n @findex __builtin_isinf_sign\n+@findex __builtin_isinf\n+@findex __builtin_isnan\n+@findex __builtin_iszero\n+@findex __builtin_issubnormal\n @findex __builtin_isless\n @findex __builtin_islessequal\n @findex __builtin_islessgreater\n@@ -11564,7 +11568,54 @@ constant values and they must appear in this order: @code{FP_NAN},\n @code{FP_INFINITE}, @code{FP_NORMAL}, @code{FP_SUBNORMAL} and\n @code{FP_ZERO}.  The ellipsis is for exactly one floating-point value\n to classify.  GCC treats the last argument as type-generic, which\n-means it does not do default promotion from float to double.\n+means it does not do default promotion from @code{float} to @code{double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_isnan (...)\n+This built-in implements the C99 isnan functionality which checks if\n+the given argument represents a NaN.  The return value of the\n+function will either be a 0 (false) or a 1 (true).\n+On most systems, when an IEEE 754 floating-point type is used this\n+built-in does not produce a signal when a signaling NaN is used.\n+\n+GCC treats the argument as type-generic, which means it does\n+not do default promotion from @code{float} to @code{double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_isinf (...)\n+This built-in implements the C99 isinf functionality which checks if\n+the given argument represents an infinite number.  The return\n+value of the function will either be a 0 (false) or a 1 (true).\n+\n+GCC treats the argument as type-generic, which means it does\n+not do default promotion from @code{float} to @code{double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_isnormal (...)\n+This built-in implements the C99 isnormal functionality which checks if\n+the given argument represents a normal number.  The return\n+value of the function will either be a 0 (false) or a 1 (true).\n+\n+GCC treats the argument as type-generic, which means it does\n+not do default promotion from @code{float} to @code{double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_iszero (...)\n+This built-in implements the TS 18661-1:2014 iszero functionality which checks if\n+the given argument represents the number 0 or -0.  The return\n+value of the function will either be a 0 (false) or a 1 (true).\n+\n+GCC treats the argument as type-generic, which means it does\n+not do default promotion from @code{float} to @code{double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_issubnormal (...)\n+This built-in implements the TS 18661-1:2014 issubnormal functionality which checks if\n+the given argument represents a subnormal number.  The return\n+value of the function will either be a 0 (false) or a 1 (true).\n+\n+GCC treats the argument as type-generic, which means it does\n+not do default promotion from @code{float} to @code{double}.\n @end deftypefn\n \n @deftypefn {Built-in Function} double __builtin_inf (void)"}, {"sha": "1cc4a4dd699e30de53eb7fc50ca4b615d44d8da2", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 903, "deletions": 7, "changes": 910, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -30,6 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-low.h\"\n+#include \"stor-layout.h\"\n+#include \"target.h\"\n+#include \"gimplify.h\"\n \n /* The differences between High GIMPLE and Low GIMPLE are the\n    following:\n@@ -72,6 +75,13 @@ static void lower_gimple_bind (gimple_stmt_iterator *, struct lower_data *);\n static void lower_try_catch (gimple_stmt_iterator *, struct lower_data *);\n static void lower_gimple_return (gimple_stmt_iterator *, struct lower_data *);\n static void lower_builtin_setjmp (gimple_stmt_iterator *);\n+static void lower_builtin_fpclassify (gimple_stmt_iterator *);\n+static void lower_builtin_isnan (gimple_stmt_iterator *);\n+static void lower_builtin_isinfinite (gimple_stmt_iterator *);\n+static void lower_builtin_isnormal (gimple_stmt_iterator *);\n+static void lower_builtin_iszero (gimple_stmt_iterator *);\n+static void lower_builtin_issubnormal (gimple_stmt_iterator *);\n+static void lower_builtin_isfinite (gimple_stmt_iterator *);\n static void lower_builtin_posix_memalign (gimple_stmt_iterator *);\n \n \n@@ -330,18 +340,69 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n \tif (decl\n \t    && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n \t  {\n-\t    if (DECL_FUNCTION_CODE (decl) == BUILT_IN_SETJMP)\n+\t    switch (DECL_FUNCTION_CODE (decl))\n \t      {\n+\t      case BUILT_IN_SETJMP:\n \t\tlower_builtin_setjmp (gsi);\n \t\tdata->cannot_fallthru = false;\n \t\treturn;\n-\t      }\n-\t    else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_POSIX_MEMALIGN\n-\t\t     && flag_tree_bit_ccp\n-\t\t     && gimple_builtin_call_types_compatible_p (stmt, decl))\n-\t      {\n-\t\tlower_builtin_posix_memalign (gsi);\n+\n+\t      case BUILT_IN_POSIX_MEMALIGN:\n+\t\tif (flag_tree_bit_ccp\n+\t\t    && gimple_builtin_call_types_compatible_p (stmt, decl))\n+\t\t  {\n+\t\t\tlower_builtin_posix_memalign (gsi);\n+\t\t\treturn;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case BUILT_IN_FPCLASSIFY:\n+\t\tlower_builtin_fpclassify (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      CASE_FLT_FN (BUILT_IN_ISINF):\n+\t      case BUILT_IN_ISINFD32:\n+\t      case BUILT_IN_ISINFD64:\n+\t      case BUILT_IN_ISINFD128:\n+\t\tlower_builtin_isinfinite (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      case BUILT_IN_ISNAND32:\n+\t      case BUILT_IN_ISNAND64:\n+\t      case BUILT_IN_ISNAND128:\n+\t      CASE_FLT_FN (BUILT_IN_ISNAN):\n+\t\tlower_builtin_isnan (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      case BUILT_IN_ISNORMAL:\n+\t\tlower_builtin_isnormal (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      case BUILT_IN_ISZERO:\n+\t\tlower_builtin_iszero (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      case BUILT_IN_ISSUBNORMAL:\n+\t\tlower_builtin_issubnormal (gsi);\n+\t\tdata->cannot_fallthru = false;\n+\t\treturn;\n+\n+\t      CASE_FLT_FN (BUILT_IN_FINITE):\n+\t      case BUILT_IN_FINITED32:\n+\t      case BUILT_IN_FINITED64:\n+\t      case BUILT_IN_FINITED128:\n+\t      case BUILT_IN_ISFINITE:\n+\t\tlower_builtin_isfinite (gsi);\n+\t\tdata->cannot_fallthru = false;\n \t\treturn;\n+\n+\t      default:\n+\t\tbreak;\n \t      }\n \t  }\n \n@@ -822,6 +883,841 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n   gsi_remove (gsi, false);\n }\n \n+/* This function will if ARG is not already a variable or SSA_NAME,\n+   create a new temporary TMP and bind ARG to TMP.  This new binding is then\n+   emitted into SEQ and TMP is returned.  */\n+static tree\n+emit_tree_and_return_var (gimple_seq *seq, tree arg)\n+{\n+  if (TREE_CODE (arg) == SSA_NAME || VAR_P (arg))\n+    return arg;\n+\n+  tree tmp = create_tmp_reg (TREE_TYPE (arg));\n+  gassign *stm = gimple_build_assign (tmp, arg);\n+  gimple_seq_add_stmt (seq, stm);\n+  return tmp;\n+}\n+\n+/* This function builds an if statement that ends up using explicit branches\n+   instead of becoming a ternary conditional select.  This function assumes you\n+   will fall through to the next statements after the condition for the false\n+   branch.  The code emitted looks like:\n+\n+   if (COND)\n+     RESULT_VARIABLE = TRUE_BRANCH\n+     GOTO EXIT_LABEL\n+   else\n+     ...\n+\n+   SEQ is the gimple sequence/buffer to emit any new bindings to.\n+   RESULT_VARIABLE is the value to set if COND.\n+   EXIT_LABEL is the label to jump to in case COND.\n+   COND is condition to use in the conditional statement of the if.\n+   TRUE_BRANCH is the value to set RESULT_VARIABLE to if COND.  */\n+static void\n+emit_tree_cond (gimple_seq *seq, tree result_variable, tree exit_label,\n+\t\ttree cond, tree true_branch)\n+{\n+  /* Create labels for fall through.  */\n+  tree true_label = create_artificial_label (UNKNOWN_LOCATION);\n+  tree false_label = create_artificial_label (UNKNOWN_LOCATION);\n+  gcond *stmt = gimple_build_cond_from_tree (cond, true_label, false_label);\n+  gimple_seq_add_stmt (seq, stmt);\n+\n+  /* Build the true case.  */\n+  gimple_seq_add_stmt (seq, gimple_build_label (true_label));\n+  tree value = TREE_CONSTANT (true_branch)\n+\t     ? true_branch\n+\t     : emit_tree_and_return_var (seq, true_branch);\n+  gimple_seq_add_stmt (seq, gimple_build_assign (result_variable, value));\n+  gimple_seq_add_stmt (seq, gimple_build_goto (exit_label));\n+\n+  /* Build the false case.  */\n+  gimple_seq_add_stmt (seq, gimple_build_label (false_label));\n+}\n+\n+/* This function returns a variable containing an reinterpreted ARG as an\n+   integer.\n+\n+   SEQ is the gimple sequence/buffer to write any new bindings to.\n+   ARG is the floating point number to reinterpret as an integer.\n+   LOC is the location to use when doing folding operations.  */\n+static tree\n+get_num_as_int (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+\n+  /* Re-interpret the float as an unsigned integer type\n+     with equal precision.  */\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+  tree conv_arg = fold_build1_loc (loc, VIEW_CONVERT_EXPR, int_arg_type, arg);\n+  return emit_tree_and_return_var (seq, conv_arg);\n+}\n+\n+/* Check if ARG which is the floating point number being classified is close\n+   enough to IEEE 754 format to be able to go in the early exit code.  */\n+static bool\n+use_ieee_int_mode (tree arg)\n+{\n+  tree type = TREE_TYPE (arg);\n+  machine_mode mode = TYPE_MODE (type);\n+\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+  machine_mode imode = int_mode_for_mode (mode);\n+  bool is_ibm_extended = MODE_COMPOSITE_P (mode);\n+\n+  return (format->is_binary_ieee_compatible\n+\t  && FLOAT_WORDS_BIG_ENDIAN == WORDS_BIG_ENDIAN\n+\t  /* Check if there's a usable integer mode.  */\n+\t  && imode != BLKmode\n+\t  && targetm.scalar_mode_supported_p (imode)\n+\t  && !is_ibm_extended);\n+}\n+\n+/* Perform some IBM extended format fixups on ARG for use by FP functions.\n+   This is done by ignoring the lower 64 bits of the number.\n+\n+   MODE is the machine mode of ARG.\n+   TYPE is the type of ARG.\n+   LOC is the location to be used in fold functions.  Usually is the location\n+   of the definition of ARG.  */\n+static bool\n+perform_ibm_extended_fixups (tree *arg, machine_mode *mode,\n+\t\t\t     tree *type, location_t loc)\n+{\n+  bool is_ibm_extended = MODE_COMPOSITE_P (*mode);\n+  if (is_ibm_extended)\n+    {\n+      /* NaN and Inf are encoded in the high-order double value\n+\t only.  The low-order value is not significant.  */\n+      *type = double_type_node;\n+      *mode = DFmode;\n+      *arg = fold_build1_loc (loc, NOP_EXPR, *type, *arg);\n+    }\n+\n+  return is_ibm_extended;\n+}\n+\n+/* Generates code to check if ARG is a normal number.  For the FP case we check\n+   MIN_VALUE(ARG) <= ABS(ARG) > INF and for the INT value we check the exp and\n+   mantissa bits.  Returns a variable containing a boolean which has the result\n+   of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_normal (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  machine_mode mode = TYPE_MODE (type);\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+  const tree bool_type = boolean_type_node;\n+\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+      tree orig_arg = arg;\n+      machine_mode orig_mode = mode;\n+      if (TREE_CODE (arg) != SSA_NAME\n+\t  && (TREE_ADDRESSABLE (arg) != 0\n+\t    || (TREE_CODE (arg) != PARM_DECL\n+\t        && (!VAR_P (arg) || TREE_STATIC (arg)))))\n+\torig_arg = save_expr (arg);\n+\n+      /* Perform IBM extended format fixups if required.  */\n+      bool is_ibm_extended = perform_ibm_extended_fixups (&arg, &mode,\n+\t\t\t\t\t\t\t  &type, loc);\n+\n+      REAL_VALUE_TYPE rinf, rmin;\n+      tree arg_p = fold_build1_loc (loc, ABS_EXPR, type, arg);\n+\n+      tree const islt_fn = builtin_decl_explicit (BUILT_IN_ISLESS);\n+      tree const isgt_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n+      tree const isge_fn = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);\n+\n+      char buf[128];\n+      real_inf (&rinf);\n+      get_min_float (REAL_MODE_FORMAT (orig_mode), buf, sizeof (buf));\n+      real_from_string (&rmin, buf);\n+\n+      tree inf_exp = build_call_expr (islt_fn, 2, arg_p,\n+\t\t\t\t      build_real (type, rinf));\n+      tree min_exp = build_real (type, rmin);\n+      if (is_ibm_extended)\n+\t{\n+\t  /* Testing the high end of the range is done just using\n+\t     the high double, using the same test as isfinite().\n+\t     For the subnormal end of the range we first test the\n+\t     high double, then if its magnitude is equal to the\n+\t     limit of 0x1p-969, we test whether the low double is\n+\t     non-zero and opposite sign to the high double.  */\n+\t  tree gt_min = build_call_expr (isgt_fn, 2, arg_p, min_exp);\n+\t  tree eq_min = fold_build2 (EQ_EXPR, integer_type_node,\n+\t\t\t\t     arg_p, min_exp);\n+\t  tree as_complex = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t    complex_double_type_node, orig_arg);\n+\t  tree hi_dbl = build1 (REALPART_EXPR, type, as_complex);\n+\t  tree lo_dbl = build1 (IMAGPART_EXPR, type, as_complex);\n+\t  tree zero = build_real (type, dconst0);\n+\t  tree hilt = build_call_expr (islt_fn, 2, hi_dbl, zero);\n+\t  tree lolt = build_call_expr (islt_fn, 2, lo_dbl, zero);\n+\t  tree logt = build_call_expr (isgt_fn, 2, lo_dbl, zero);\n+\t  tree ok_lo = fold_build1 (TRUTH_NOT_EXPR, integer_type_node,\n+\t\t\t\t    fold_build3 (COND_EXPR,\n+\t\t\t\t\t\t integer_type_node,\n+\t\t\t\t\t\t hilt, logt, lolt));\n+\t  eq_min = fold_build2 (TRUTH_ANDIF_EXPR, integer_type_node,\n+\t\t\t\teq_min, ok_lo);\n+\t  min_exp = fold_build2 (TRUTH_ORIF_EXPR, integer_type_node,\n+\t\t\t\t gt_min, eq_min);\n+\t}\n+\telse\n+\t{\n+\t  min_exp = build_call_expr (isge_fn, 2, arg_p, min_exp);\n+\t}\n+\n+      push_gimplify_context ();\n+      gimplify_expr (&min_exp, seq, NULL, is_gimple_val, fb_either);\n+      gimplify_expr (&inf_exp, seq, NULL, is_gimple_val, fb_either);\n+\n+      tree res\n+\t= fold_build2_loc (loc, BIT_AND_EXPR, bool_type,\n+\t\t\t   emit_tree_and_return_var (seq,\n+\t\t\t\t\t\t     gimple_boolify (min_exp)),\n+\t\t\t   emit_tree_and_return_var (seq,\n+\t\t\t\t\t\t     gimple_boolify (inf_exp)));\n+      pop_gimplify_context (NULL);\n+\n+      return emit_tree_and_return_var (seq, res);\n+    }\n+\n+  const tree int_type = unsigned_type_node;\n+  const int exp_bits  = (GET_MODE_SIZE (mode) * BITS_PER_UNIT) - format->p;\n+  const int exp_mask  = (1 << exp_bits) - 1;\n+\n+  /* Get the number reinterpreted as an integer.  */\n+  tree int_arg = get_num_as_int (seq, arg, loc);\n+\n+  /* Extract exp bits from the float, where we expect the exponent to be.\n+     We create a new type because BIT_FIELD_REF does not allow you to\n+     extract less bits than the precision of the storage variable.  */\n+  tree exp_tmp\n+    = fold_build3_loc (loc, BIT_FIELD_REF,\n+\t\t       build_nonstandard_integer_type (exp_bits, true),\n+\t\t       int_arg,\n+\t\t       build_int_cstu (int_type, exp_bits),\n+\t\t       build_int_cstu (int_type, format->p - 1));\n+  tree exp_bitfield = emit_tree_and_return_var (seq, exp_tmp);\n+\n+  /* Re-interpret the extracted exponent bits as a 32 bit int.\n+     This allows us to continue doing operations as int_type.  */\n+  tree exp\n+    = emit_tree_and_return_var (seq, fold_build1_loc (loc, NOP_EXPR, int_type,\n+\t\t\t\t\t\t      exp_bitfield));\n+\n+  /* exp_mask & ~1.  */\n+  tree mask_check\n+     = fold_build2_loc (loc, BIT_AND_EXPR, int_type,\n+\t\t\tbuild_int_cstu (int_type, exp_mask),\n+\t\t\tfold_build1_loc (loc, BIT_NOT_EXPR, int_type,\n+\t\t\t\t\t build_int_cstu (int_type, 1)));\n+\n+  /* (exp + 1) & mask_check.\n+     Check to see if exp is not all 0 or all 1.  */\n+  tree exp_check\n+    = fold_build2_loc (loc, BIT_AND_EXPR, int_type,\n+\t\t       emit_tree_and_return_var (seq,\n+\t\t\t\tfold_build2_loc (loc, PLUS_EXPR, int_type, exp,\n+\t\t\t\t\t\t build_int_cstu (int_type, 1))),\n+\t\t       mask_check);\n+\n+  tree res = fold_build2_loc (loc, NE_EXPR, boolean_type_node,\n+\t\t\t      build_int_cstu (int_type, 0),\n+\t\t\t      emit_tree_and_return_var (seq, exp_check));\n+\n+  return emit_tree_and_return_var (seq, res);\n+}\n+\n+/* Generates code to check if ARG is a zero. For both the FP and INT case we\n+   check if ARG == 0 (modulo sign bit).  Returns a variable containing a boolean\n+   which has the result of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_zero (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+      machine_mode mode = TYPE_MODE (type);\n+      /* Perform IBM extended format fixups if required.  */\n+      perform_ibm_extended_fixups (&arg, &mode, &type, loc);\n+\n+      tree res = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, arg,\n+\t\t\t\t  build_real (type, dconst0));\n+      return emit_tree_and_return_var (seq, res);\n+    }\n+\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+\n+  /* Get the number reinterpreted as an integer.\n+     Shift left to remove the sign.  */\n+  tree int_arg\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       get_num_as_int (seq, arg, loc),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* num << 1 == 0.\n+     This checks to see if the number is zero.  */\n+  tree zero_check\n+    = fold_build2_loc (loc, EQ_EXPR, boolean_type_node,\n+\t\t       build_int_cstu (int_arg_type, 0),\n+\t\t       emit_tree_and_return_var (seq, int_arg));\n+\n+  return emit_tree_and_return_var (seq, zero_check);\n+}\n+\n+/* Generates code to check if ARG is a subnormal number.  In the FP case we test\n+   fabs (ARG) != 0 && fabs (ARG) < MIN_VALUE (ARG) and in the INT case we check\n+   the exp and mantissa bits on ARG. Returns a variable containing a boolean\n+   which has the result of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_subnormal (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  const tree bool_type = boolean_type_node;\n+\n+  tree type = TREE_TYPE (arg);\n+\n+  machine_mode mode = TYPE_MODE (type);\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+      tree const islt_fn = builtin_decl_explicit (BUILT_IN_ISLESS);\n+      tree const isgt_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n+\n+      tree arg_p\n+\t= emit_tree_and_return_var (seq, fold_build1_loc (loc, ABS_EXPR, type,\n+\t\t\t\t\t\t\t  arg));\n+      REAL_VALUE_TYPE r;\n+      char buf[128];\n+      get_min_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+      real_from_string (&r, buf);\n+      tree subnorm = build_call_expr (islt_fn, 2, arg_p, build_real (type, r));\n+\n+      tree zero = build_call_expr (isgt_fn, 2, arg_p,\n+\t\t\t\t   build_real (type, dconst0));\n+\n+      push_gimplify_context ();\n+      gimplify_expr (&subnorm, seq, NULL, is_gimple_val, fb_either);\n+      gimplify_expr (&zero, seq, NULL, is_gimple_val, fb_either);\n+\n+      tree res\n+\t= fold_build2_loc (loc, BIT_AND_EXPR, bool_type,\n+\t\t\t   emit_tree_and_return_var (seq,\n+\t\t\t\t\t\t     gimple_boolify (subnorm)),\n+\t\t\t   emit_tree_and_return_var (seq,\n+\t\t\t\t\t\t     gimple_boolify (zero)));\n+      pop_gimplify_context (NULL);\n+\n+      return emit_tree_and_return_var (seq, res);\n+  }\n+\n+  /* Get the number reinterpreted as an integer.\n+     Shift left to remove the sign.  */\n+  tree int_arg\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       get_num_as_int (seq, arg, loc),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* Check for a zero exponent and non-zero mantissa.\n+     This can be done with two comparisons by first apply a\n+     removing the sign bit and checking if the value is larger\n+     than the mantissa mask.  */\n+\n+  /* This creates a mask to be used to check the mantissa value in the shifted\n+     integer representation of the fpnum.  */\n+  tree significant_bit = build_int_cstu (int_arg_type, format->p - 1);\n+  tree mantissa_mask\n+    = fold_build2_loc (loc, MINUS_EXPR, int_arg_type,\n+\t\t       fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t\t\t\tbuild_int_cstu (int_arg_type, 2),\n+\t\t\t\t\tsignificant_bit),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* Check if exponent is zero and mantissa is not.  */\n+  tree subnorm_cond_tmp\n+    = fold_build2_loc (loc, LE_EXPR, bool_type,\n+\t\t       emit_tree_and_return_var (seq, int_arg),\n+\t\t       mantissa_mask);\n+\n+  tree subnorm_cond = emit_tree_and_return_var (seq, subnorm_cond_tmp);\n+\n+  tree zero_cond\n+    = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t       emit_tree_and_return_var (seq, int_arg),\n+\t\t       build_int_cstu (int_arg_type, 0));\n+\n+  tree subnorm_check\n+    = fold_build2_loc (loc, BIT_AND_EXPR, boolean_type_node,\n+\t\t       emit_tree_and_return_var (seq, subnorm_cond),\n+\t\t       emit_tree_and_return_var (seq, zero_cond));\n+\n+  return emit_tree_and_return_var (seq, subnorm_check);\n+}\n+\n+/* Generates code to check if ARG is an infinity.  In the FP case we test\n+   FABS(ARG) == INF and in the INT case we check the bits on the exp and\n+   mantissa.  Returns a variable containing a boolean which has the result\n+   of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_infinity (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  machine_mode mode = TYPE_MODE (type);\n+  const tree bool_type = boolean_type_node;\n+\n+  if (!HONOR_INFINITIES (mode))\n+    {\n+      return build_int_cst (bool_type, false);\n+    }\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+      /* Perform IBM extended format fixups if required.  */\n+      perform_ibm_extended_fixups (&arg, &mode, &type, loc);\n+\n+      tree arg_p\n+\t= emit_tree_and_return_var (seq, fold_build1_loc (loc, ABS_EXPR, type,\n+\t\t\t\t\t\t\targ));\n+      REAL_VALUE_TYPE r;\n+      real_inf (&r);\n+      tree res = fold_build2_loc (loc, EQ_EXPR, bool_type, arg_p,\n+\t\t\t\t  build_real (type, r));\n+\n+      return emit_tree_and_return_var (seq, res);\n+    }\n+\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+\n+  /* This creates a mask to be used to check the exp value in the shifted\n+     integer representation of the fpnum.  */\n+  const int exp_bits  = (GET_MODE_SIZE (mode) * BITS_PER_UNIT) - format->p;\n+  gcc_assert (format->p > 0);\n+\n+  tree significant_bit = build_int_cstu (int_arg_type, format->p);\n+  tree exp_mask\n+    = fold_build2_loc (loc, MINUS_EXPR, int_arg_type,\n+\t\t       fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t\t\t\tbuild_int_cstu (int_arg_type, 2),\n+\t\t\t\t\tbuild_int_cstu (int_arg_type,\n+\t\t\t\t\t\t\texp_bits - 1)),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* Get the number reinterpreted as an integer.\n+     Shift left to remove the sign.  */\n+  tree int_arg\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       get_num_as_int (seq, arg, loc),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* This mask checks to see if the exp has all bits set and mantissa no\n+     bits set.  */\n+  tree inf_mask\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       exp_mask, significant_bit);\n+\n+  /* Check if exponent has all bits set and mantissa is 0.  */\n+  tree inf_check\n+    = emit_tree_and_return_var(seq,\n+\tfold_build2_loc (loc, EQ_EXPR, bool_type,\n+\t\t\t emit_tree_and_return_var(seq, int_arg),\n+\t\t\t inf_mask));\n+\n+  return emit_tree_and_return_var (seq, inf_check);\n+}\n+\n+/* Generates code to check if ARG is a finite number.  In the FP case we check\n+   if FABS(ARG) <= MAX_VALUE(ARG) and in the INT case we check the exp and\n+   mantissa bits.  Returns a variable containing a boolean which has the result\n+   of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_finite (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  machine_mode mode = TYPE_MODE (type);\n+  const tree bool_type = boolean_type_node;\n+\n+  if (!HONOR_NANS (arg) && !HONOR_INFINITIES (arg))\n+    {\n+      return build_int_cst (bool_type, true);\n+    }\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+\n+      /* Perform IBM extended format fixups if required.  */\n+      perform_ibm_extended_fixups (&arg, &mode, &type, loc);\n+\n+      tree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n+\n+      tree arg_p\n+\t= emit_tree_and_return_var (seq, fold_build1_loc (loc, ABS_EXPR, type,\n+\t\t\t\t\t\t\t  arg));\n+      REAL_VALUE_TYPE rmax;\n+      char buf[128];\n+      get_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+      real_from_string (&rmax, buf);\n+\n+      tree res = build_call_expr (isle_fn, 2,  arg_p, build_real (type, rmax));\n+\n+      push_gimplify_context ();\n+      gimplify_expr (&res, seq, NULL, is_gimple_val, fb_either);\n+      pop_gimplify_context (NULL);\n+\n+      return emit_tree_and_return_var (seq, gimple_boolify(res));\n+    }\n+\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+\n+  /* This creates a mask to be used to check the exp value in the shifted\n+     integer representation of the fpnum.  */\n+  const int exp_bits  = (GET_MODE_SIZE (mode) * BITS_PER_UNIT) - format->p;\n+  gcc_assert (format->p > 0);\n+\n+  tree significant_bit = build_int_cstu (int_arg_type, format->p);\n+  tree exp_mask\n+    = fold_build2_loc (loc, MINUS_EXPR, int_arg_type,\n+\t\t       fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t\t\t\tbuild_int_cstu (int_arg_type, 2),\n+\t\t\t\t\tbuild_int_cstu (int_arg_type,\n+\t\t\t\t\t\t\texp_bits - 1)),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* Get the number reinterpreted as an integer.\n+     Shift left to remove the sign. */\n+  tree int_arg\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       get_num_as_int (seq, arg, loc),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* This mask checks to see if the exp has all bits set and mantissa no\n+     bits set.  */\n+  tree inf_mask\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       exp_mask, significant_bit);\n+\n+  /* Check if exponent has all bits set and mantissa is 0. */\n+  tree inf_check_tmp\n+    = fold_build2_loc (loc, LT_EXPR, bool_type,\n+\t\t       emit_tree_and_return_var (seq, int_arg),\n+\t\t       inf_mask);\n+\n+  tree inf_check = emit_tree_and_return_var (seq, inf_check_tmp);\n+\n+  return emit_tree_and_return_var (seq, inf_check);\n+}\n+\n+/* Generates code to check if ARG is a NaN. In the FP case we simply check if\n+   ARG != ARG and in the INT case we check the bits in the exp and mantissa.\n+   Returns a variable containing a boolean which has the result of the check.\n+\n+   SEQ is the buffer to use to emit the gimple instructions into.\n+   LOC is the location to use during fold calls.  */\n+static tree\n+is_nan (gimple_seq *seq, tree arg, location_t loc)\n+{\n+  tree type = TREE_TYPE (arg);\n+\n+  machine_mode mode = TYPE_MODE (type);\n+  const tree bool_type = boolean_type_node;\n+\n+  if (!HONOR_NANS (mode))\n+    {\n+      return build_int_cst (bool_type, false);\n+    }\n+\n+  const real_format *format = REAL_MODE_FORMAT (mode);\n+\n+  /* If not using optimized route then exit early.  */\n+  if (!use_ieee_int_mode (arg))\n+    {\n+      /* Perform IBM extended format fixups if required.  */\n+      perform_ibm_extended_fixups (&arg, &mode, &type, loc);\n+\n+      tree arg_p\n+\t= emit_tree_and_return_var (seq, fold_build1_loc (loc, ABS_EXPR, type,\n+\t\t\t\t\t\t\t  arg));\n+      tree res\n+\t= fold_build2_loc (loc, UNORDERED_EXPR, bool_type,arg_p, arg_p);\n+\n+      return emit_tree_and_return_var (seq, res);\n+  }\n+\n+  const HOST_WIDE_INT type_width = TYPE_PRECISION (type);\n+  tree int_arg_type = build_nonstandard_integer_type (type_width, true);\n+\n+  /* This creates a mask to be used to check the exp value in the shifted\n+     integer representation of the fpnum.  */\n+  const int exp_bits  = (GET_MODE_SIZE (mode) * BITS_PER_UNIT) - format->p;\n+  tree significant_bit = build_int_cstu (int_arg_type, format->p);\n+  tree exp_mask\n+    = fold_build2_loc (loc, MINUS_EXPR, int_arg_type,\n+\t\t       fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t\t\t\tbuild_int_cstu (int_arg_type, 2),\n+\t\t\t\t\tbuild_int_cstu (int_arg_type,\n+\t\t\t\t\t\t\texp_bits - 1)),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* Get the number reinterpreted as an integer.\n+     Shift left to remove the sign.  */\n+  tree int_arg\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       get_num_as_int (seq, arg, loc),\n+\t\t       build_int_cstu (int_arg_type, 1));\n+\n+  /* This mask checks to see if the exp has all bits set and mantissa no\n+     bits set.  */\n+  tree inf_mask\n+    = fold_build2_loc (loc, LSHIFT_EXPR, int_arg_type,\n+\t\t       exp_mask, significant_bit);\n+\n+  /* Check if exponent has all bits set and mantissa is not 0.  */\n+  tree nan_check\n+    = emit_tree_and_return_var(seq,\n+\tfold_build2_loc (loc, GT_EXPR, bool_type,\n+\t\t\t emit_tree_and_return_var(seq, int_arg),\n+\t\t\t inf_mask));\n+\n+  return emit_tree_and_return_var (seq, nan_check);\n+}\n+\n+/* Validates a single argument from the arguments list CALL at position INDEX.\n+   The extracted parameter is compared against the expected type CODE.\n+\n+   A boolean is returned indicating if the parameter exist and if of the\n+   expected type.  */\n+static bool\n+gimple_validate_arg (gimple* call, int index, enum tree_code code)\n+{\n+  const tree arg = gimple_call_arg (call, index);\n+  if (!arg)\n+    return false;\n+  else if (code == POINTER_TYPE)\n+    return POINTER_TYPE_P (TREE_TYPE (arg));\n+  else if (code == INTEGER_TYPE)\n+    return INTEGRAL_TYPE_P (TREE_TYPE (arg));\n+  return code == TREE_CODE (TREE_TYPE (arg));\n+}\n+\n+/* Lowers calls to __builtin_fpclassify to\n+   fpclassify (x) ->\n+     isnormal(x) ? FP_NORMAL :\n+       iszero (x) ? FP_ZERO :\n+\t isnan (x) ? FP_NAN :\n+\t   isinfinite (x) ? FP_INFINITE :\n+\t     FP_SUBNORMAL.\n+\n+   The code may use integer arithmentic if it decides\n+   that the produced assembly would be faster. This can only be done\n+   for numbers that are similar to IEEE-754 in format.\n+\n+   This builtin will generate code to return the appropriate floating\n+   point classification depending on the value of the floating point\n+   number passed in.  The possible return values must be supplied as\n+   int arguments to the call in the following order: FP_NAN, FP_INFINITE,\n+   FP_NORMAL, FP_SUBNORMAL and FP_ZERO.  The ellipses is for exactly\n+   one floating point argument which is \"type generic\".\n+\n+   GSI is the gimple iterator containing the fpclassify call to lower.\n+   The call will be expanded and replaced inline in the given GSI.  */\n+static void\n+lower_builtin_fpclassify (gimple_stmt_iterator *gsi)\n+{\n+  gimple *call = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (call);\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (gimple_call_num_args (call) != 6\n+      || !gimple_validate_arg (call, 0, INTEGER_TYPE)\n+      || !gimple_validate_arg (call, 1, INTEGER_TYPE)\n+      || !gimple_validate_arg (call, 2, INTEGER_TYPE)\n+      || !gimple_validate_arg (call, 3, INTEGER_TYPE)\n+      || !gimple_validate_arg (call, 4, INTEGER_TYPE)\n+      || !gimple_validate_arg (call, 5, REAL_TYPE))\n+    return;\n+\n+  /* Collect the arguments from the call.  */\n+  tree fp_nan = gimple_call_arg (call, 0);\n+  tree fp_infinite = gimple_call_arg (call, 1);\n+  tree fp_normal = gimple_call_arg (call, 2);\n+  tree fp_subnormal = gimple_call_arg (call, 3);\n+  tree fp_zero = gimple_call_arg (call, 4);\n+  tree arg = gimple_call_arg (call, 5);\n+\n+  gimple_seq body = NULL;\n+\n+  /* Create label to jump to to exit.  */\n+  tree done_label = create_artificial_label (UNKNOWN_LOCATION);\n+  tree dest;\n+  tree orig_dest = dest = gimple_call_lhs (call);\n+  if (orig_dest && TREE_CODE (orig_dest) == SSA_NAME)\n+    dest = create_tmp_reg (TREE_TYPE (orig_dest));\n+\n+  emit_tree_cond (&body, dest, done_label,\n+\t\t  is_normal (&body, arg, loc), fp_normal);\n+  emit_tree_cond (&body, dest, done_label,\n+\t\t  is_zero (&body, arg, loc), fp_zero);\n+  emit_tree_cond (&body, dest, done_label,\n+\t\t  is_nan (&body, arg, loc), fp_nan);\n+  emit_tree_cond (&body, dest, done_label,\n+\t\t  is_infinity (&body, arg, loc), fp_infinite);\n+\n+  /* And finally, emit the default case if nothing else matches.\n+     This replaces the call to is_subnormal.  */\n+  gimple_seq_add_stmt (&body, gimple_build_assign (dest, fp_subnormal));\n+  gimple_seq_add_stmt (&body, gimple_build_label (done_label));\n+\n+  /* Build orig_dest = dest if necessary.  */\n+  if (dest != orig_dest)\n+    {\n+      gimple_seq_add_stmt (&body, gimple_build_assign (orig_dest, dest));\n+    }\n+\n+  gsi_insert_seq_before (gsi, body, GSI_SAME_STMT);\n+\n+\n+  /* Remove the call to __builtin_fpclassify.  */\n+  gsi_remove (gsi, false);\n+}\n+\n+/* Generic wrapper for the is_nan, is_normal, is_subnormal, is_zero, etc.\n+   All these functions have the same setup. The wrapper validates the parameter\n+   and also creates the branches and labels required to properly invoke.\n+   This has been generalize and the function to call is passed as argument FNDECL.\n+\n+   GSI is the gimple iterator containing the fpclassify call to lower.\n+   The call will be expanded and replaced inline in the given GSI.  */\n+static void\n+gen_call_fp_builtin (gimple_stmt_iterator *gsi,\n+\t\t     tree (*fndecl)(gimple_seq *, tree, location_t))\n+{\n+  gimple *call = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (call);\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (gimple_call_num_args (call) != 1\n+      || !gimple_validate_arg (call, 0, REAL_TYPE))\n+    return;\n+\n+  tree arg = gimple_call_arg (call, 0);\n+  gimple_seq body = NULL;\n+\n+  /* Create label to jump to to exit.  */\n+  tree done_label = create_artificial_label (UNKNOWN_LOCATION);\n+  tree dest;\n+  tree orig_dest = dest = gimple_call_lhs (call);\n+  tree type = TREE_TYPE (orig_dest);\n+  if (orig_dest && TREE_CODE (orig_dest) == SSA_NAME)\n+      dest = create_tmp_reg (type);\n+\n+  tree t_true = build_int_cst (type, true);\n+  tree t_false = build_int_cst (type, false);\n+\n+  emit_tree_cond (&body, dest, done_label,\n+\t\t  fndecl (&body, arg, loc), t_true);\n+\n+  /* And finally, emit the default case if nothing else matches.\n+     This replaces the call to false.  */\n+  gimple_seq_add_stmt (&body, gimple_build_assign (dest, t_false));\n+  gimple_seq_add_stmt (&body, gimple_build_label (done_label));\n+\n+  /* Build orig_dest = dest if necessary.  */\n+  if (dest != orig_dest)\n+  {\n+    gimple_seq_add_stmt (&body, gimple_build_assign (orig_dest, dest));\n+  }\n+\n+  gsi_insert_seq_before (gsi, body, GSI_SAME_STMT);\n+\n+  /* Remove the call to the builtin.  */\n+  gsi_remove (gsi, false);\n+}\n+\n+/* Lower and expand calls to __builtin_isnan in GSI.  */\n+static void\n+lower_builtin_isnan (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_nan);\n+}\n+\n+/* Lower and expand calls to __builtin_isinfinite in GSI.  */\n+static void\n+lower_builtin_isinfinite (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_infinity);\n+}\n+\n+/* Lower and expand calls to __builtin_isnormal in GSI.  */\n+static void\n+lower_builtin_isnormal (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_normal);\n+}\n+\n+/* Lower and expand calls to __builtin_iszero in GSI.  */\n+static void\n+lower_builtin_iszero (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_zero);\n+}\n+\n+/* Lower and expand calls to __builtin_issubnormal in GSI.  */\n+static void\n+lower_builtin_issubnormal (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_subnormal);\n+}\n+\n+/* Lower and expand calls to __builtin_isfinite in GSI.  */\n+static void\n+lower_builtin_isfinite (gimple_stmt_iterator *gsi)\n+{\n+  gen_call_fp_builtin (gsi, &is_finite);\n+}\n+\n /* Lower calls to posix_memalign to\n      res = posix_memalign (ptr, align, size);\n      if (res == 0)"}, {"sha": "4b4635ff913319e7267af362690dbea66d229d19", "filename": "gcc/real.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -3052,6 +3052,7 @@ const struct real_format ieee_single_format =\n     true,\n     true,\n     false,\n+    true,\n     \"ieee_single\"\n   };\n \n@@ -3075,6 +3076,7 @@ const struct real_format mips_single_format =\n     true,\n     false,\n     true,\n+    true,\n     \"mips_single\"\n   };\n \n@@ -3098,6 +3100,7 @@ const struct real_format motorola_single_format =\n     true,\n     true,\n     true,\n+    true,\n     \"motorola_single\"\n   };\n \n@@ -3132,6 +3135,7 @@ const struct real_format spu_single_format =\n     true,\n     false,\n     false,\n+    false,\n     \"spu_single\"\n   };\n \f\n@@ -3343,6 +3347,7 @@ const struct real_format ieee_double_format =\n     true,\n     true,\n     false,\n+    true,\n     \"ieee_double\"\n   };\n \n@@ -3366,6 +3371,7 @@ const struct real_format mips_double_format =\n     true,\n     false,\n     true,\n+    true,\n     \"mips_double\"\n   };\n \n@@ -3389,6 +3395,7 @@ const struct real_format motorola_double_format =\n     true,\n     true,\n     true,\n+    true,\n     \"motorola_double\"\n   };\n \f\n@@ -3735,6 +3742,7 @@ const struct real_format ieee_extended_motorola_format =\n     true,\n     true,\n     true,\n+    false,\n     \"ieee_extended_motorola\"\n   };\n \n@@ -3758,6 +3766,7 @@ const struct real_format ieee_extended_intel_96_format =\n     true,\n     true,\n     false,\n+    false,\n     \"ieee_extended_intel_96\"\n   };\n \n@@ -3781,6 +3790,7 @@ const struct real_format ieee_extended_intel_128_format =\n     true,\n     true,\n     false,\n+    false,\n     \"ieee_extended_intel_128\"\n   };\n \n@@ -3806,6 +3816,7 @@ const struct real_format ieee_extended_intel_96_round_53_format =\n     true,\n     true,\n     false,\n+    false,\n     \"ieee_extended_intel_96_round_53\"\n   };\n \f\n@@ -3896,6 +3907,7 @@ const struct real_format ibm_extended_format =\n     true,\n     true,\n     false,\n+    false,\n     \"ibm_extended\"\n   };\n \n@@ -3919,6 +3931,7 @@ const struct real_format mips_extended_format =\n     true,\n     false,\n     true,\n+    false,\n     \"mips_extended\"\n   };\n \n@@ -4184,6 +4197,7 @@ const struct real_format ieee_quad_format =\n     true,\n     true,\n     false,\n+    true,\n     \"ieee_quad\"\n   };\n \n@@ -4207,6 +4221,7 @@ const struct real_format mips_quad_format =\n     true,\n     false,\n     true,\n+    true,\n     \"mips_quad\"\n   };\n \f\n@@ -4509,6 +4524,7 @@ const struct real_format vax_f_format =\n     false,\n     false,\n     false,\n+    false,\n     \"vax_f\"\n   };\n \n@@ -4532,6 +4548,7 @@ const struct real_format vax_d_format =\n     false,\n     false,\n     false,\n+    false,\n     \"vax_d\"\n   };\n \n@@ -4555,6 +4572,7 @@ const struct real_format vax_g_format =\n     false,\n     false,\n     false,\n+    false,\n     \"vax_g\"\n   };\n \f\n@@ -4633,6 +4651,7 @@ const struct real_format decimal_single_format =\n     true,\n     true,\n     false,\n+    false,\n     \"decimal_single\"\n   };\n \n@@ -4657,6 +4676,7 @@ const struct real_format decimal_double_format =\n     true,\n     true,\n     false,\n+    false,\n     \"decimal_double\"\n   };\n \n@@ -4681,6 +4701,7 @@ const struct real_format decimal_quad_format =\n     true,\n     true,\n     false,\n+    false,\n     \"decimal_quad\"\n   };\n \f\n@@ -4820,6 +4841,7 @@ const struct real_format ieee_half_format =\n     true,\n     true,\n     false,\n+    true,\n     \"ieee_half\"\n   };\n \n@@ -4846,6 +4868,7 @@ const struct real_format arm_half_format =\n     true,\n     false,\n     false,\n+    false,\n     \"arm_half\"\n   };\n \f\n@@ -4893,6 +4916,7 @@ const struct real_format real_internal_format =\n     true,\n     true,\n     false,\n+    false,\n     \"real_internal\"\n   };\n \f\n@@ -5080,6 +5104,16 @@ get_max_float (const struct real_format *fmt, char *buf, size_t len)\n   gcc_assert (strlen (buf) < len);\n }\n \n+/* Write into BUF the minimum negative representable finite floating-point\n+   number, x, such that b**(x-1) is normalized.\n+   BUF must be large enough to contain the result.  */\n+void\n+get_min_float (const struct real_format *fmt, char *buf, size_t len)\n+{\n+  sprintf (buf, \"0x1p%d\", fmt->emin - 1);\n+  gcc_assert (strlen (buf) < len);\n+}\n+\n /* True if mode M has a NaN representation and\n    the treatment of NaN operands is important.  */\n "}, {"sha": "67fa7932e884d5102b80d8b16bfec6533054acbc", "filename": "gcc/real.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -161,6 +161,19 @@ struct real_format\n   bool has_signed_zero;\n   bool qnan_msb_set;\n   bool canonical_nan_lsbs_set;\n+\n+  /* This flag indicates whether the format is suitable for the optimized\n+     code paths for the __builtin_fpclassify function and friends.  For\n+     this, the format must be a base 2 representation with the sign bit as\n+     the most-significant bit followed by (exp <= 32) exponent bits\n+     followed by the mantissa bits.  It must be possible to interpret the\n+     bits of the floating-point representation as an integer.  NaNs and\n+     INFs (if available) must be represented by the same schema used by\n+     IEEE 754.  (NaNs must be represented by an exponent with all bits 1,\n+     any mantissa except all bits 0 and any sign bit.  +INF and -INF must be\n+     represented by an exponent with all bits 1, a mantissa with all bits 0 and\n+     a sign bit of 0 and 1 respectively.)  */\n+  bool is_binary_ieee_compatible;\n   const char *name;\n };\n \n@@ -511,6 +524,11 @@ extern bool real_isinteger (const REAL_VALUE_TYPE *, HOST_WIDE_INT *);\n    float string.  BUF must be large enough to contain the result.  */\n extern void get_max_float (const struct real_format *, char *, size_t);\n \n+/* Write into BUF the smallest positive normalized number x,\n+   such that b**(x-1) is normalized.  BUF must be large enough\n+   to contain the result.  */\n+extern void get_min_float (const struct real_format *, char *, size_t);\n+\n #ifndef GENERATOR_FILE\n /* real related routines.  */\n extern wide_int real_to_integer (const REAL_VALUE_TYPE *, bool *, int);"}, {"sha": "3899e20dedd5e65e10242b183e389a619864cef9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -1,3 +1,20 @@\n+2017-06-08  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* gcc.target/aarch64/builtin-fpclassify.c: New codegen test.\n+\t* gcc.dg/fold-notunord.c: Removed.\n+\t* gcc.dg/torture/floatn-tg-4.h: Add tests for iszero and issubnormal.\n+\t* gcc.dg/torture/float128-tg-4.c: Likewise.\n+\t* gcc.dg/torture/float128x-tg-4: Likewise.\n+\t* gcc.dg/torture/float16-tg-4.c: Likewise.\n+\t* gcc.dg/torture/float32-tg-4.c: Likewise.\n+\t* gcc.dg/torture/float32x-tg-4.c: Likewise.\n+\t* gcc.dg/torture/float64-tg-4.c: Likewise.\n+\t* gcc.dg/torture/float64x-tg-4.c: Likewise.\n+\t* gcc.dg/pr28796-1.c: Add -O2.\n+\t* gcc.dg/builtins-43.c: Check lower instead of gimple.\n+\t* gcc.dg/tg-tests.h: Add iszero and issubnormal.\n+\t* gcc.dg/pr77925.c: Add to test safe cases.\n+\n 2017-06-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/80928"}, {"sha": "5d41c28aef8619f06658f45846ae15dd8b4987ed", "filename": "gcc/testsuite/gcc.dg/builtins-43.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fno-trapping-math -fno-finite-math-only -fdump-tree-gimple -fdump-tree-optimized\" } */\n+/* { dg-options \"-O1 -fno-trapping-math -fno-finite-math-only -fdump-tree-lower -fdump-tree-optimized\" } */\n   \n extern void f(int);\n extern void link_error ();\n@@ -51,7 +51,7 @@ main ()\n \n \n /* Check that all instances of __builtin_isnan were folded.  */\n-/* { dg-final { scan-tree-dump-times \"isnan\" 0 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"isnan\" 0 \"lower\" } } */\n \n /* Check that all instances of link_error were subject to DCE.  */\n /* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" } } */"}, {"sha": "ca345154ac204cb5f380855828421b7f88d49052", "filename": "gcc/testsuite/gcc.dg/fold-notunord.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4bc6ff6c08f4e5524fa5e1881b478b0f689155/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-notunord.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4bc6ff6c08f4e5524fa5e1881b478b0f689155/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-notunord.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-notunord.c?ref=fb4bc6ff6c08f4e5524fa5e1881b478b0f689155", "patch": "@@ -1,9 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O -ftrapping-math -fdump-tree-optimized\" } */\n-\n-int f (double d)\n-{\n-  return !__builtin_isnan (d);\n-}\n-\n-/* { dg-final { scan-tree-dump \" ord \" \"optimized\" } } */"}, {"sha": "a57b4e350af1bc45344106fdeab4b32ef87f233f", "filename": "gcc/testsuite/gcc.dg/pr28796-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do link } */\n-/* { dg-options \"-ffinite-math-only\" } */\n+/* { dg-options \"-ffinite-math-only -O2\" } */\n \n extern void link_error(void);\n "}, {"sha": "f92518b59af1b126c0642a4622ba57aaea3bb24c", "filename": "gcc/testsuite/gcc.dg/pr77925.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77925.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options ieee } */\n+/* { dg-skip-if \"No Inf/NaN support\" { spu-*-* } } */\n+\n+#include \"tg-tests.h\"\n+\n+int main(void)\n+{\n+  return main_tests ();\n+}"}, {"sha": "134bc8252750fbfc05f939030b2996a7c6f9ce9b", "filename": "gcc/testsuite/gcc.dg/tg-tests.h", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -11,6 +11,7 @@ void __attribute__ ((__noinline__))\n foo_1 (float f, double d, long double ld,\n        int res_unord, int res_isnan, int res_isinf,\n        int res_isinf_sign, int res_isfin, int res_isnorm,\n+       int res_iszero, int res_issubnorm,\n        int res_signbit, int classification)\n {\n   if (__builtin_isunordered (f, 0) != res_unord)\n@@ -80,6 +81,29 @@ foo_1 (float f, double d, long double ld,\n   if (__builtin_finitel (ld) != res_isfin)\n     __builtin_abort ();\n \n+/* On CPUs which flush denormals to zero these tests can never work one\n+   denormals for the floating point version of the implementation. The integer\n+   versions would work fine but we can't detect which version we have here.  */\n+#ifdef UNSAFE\n+if (!res_issubnorm) {\n+#endif\n+  if (__builtin_iszero (f) != res_iszero)\n+    __builtin_abort ();\n+  if (__builtin_iszero (d) != res_iszero)\n+    __builtin_abort ();\n+  if (__builtin_iszero (ld) != res_iszero)\n+    __builtin_abort ();\n+\n+  if (__builtin_issubnormal (f) != res_issubnorm)\n+    __builtin_abort ();\n+  if (__builtin_issubnormal (d) != res_issubnorm)\n+    __builtin_abort ();\n+  if (__builtin_issubnormal (ld) != res_issubnorm)\n+    __builtin_abort ();\n+#ifdef UNSAFE\n+}\n+#endif\n+\n   /* Sign bit of zeros and nans is not preserved in unsafe math mode.  */\n #ifdef UNSAFE\n   if (!res_isnan && f != 0 && d != 0 && ld != 0)\n@@ -115,12 +139,13 @@ foo_1 (float f, double d, long double ld,\n void __attribute__ ((__noinline__))\n foo (float f, double d, long double ld,\n      int res_unord, int res_isnan, int res_isinf,\n-     int res_isfin, int res_isnorm, int classification)\n+     int res_isfin, int res_isnorm, int res_iszero,\n+     int res_issubnorm, int classification)\n {\n-  foo_1 (f, d, ld, res_unord, res_isnan, res_isinf, res_isinf, res_isfin, res_isnorm, 0, classification);\n+  foo_1 (f, d, ld, res_unord, res_isnan, res_isinf, res_isinf, res_isfin, res_isnorm, res_iszero, res_issubnorm, 0, classification);\n   /* Try all the values negated as well.  All will have the sign bit set,\n      except for the nan.  */\n-  foo_1 (-f, -d, -ld, res_unord, res_isnan, res_isinf, -res_isinf, res_isfin, res_isnorm, 1, classification);\n+  foo_1 (-f, -d, -ld, res_unord, res_isnan, res_isinf, -res_isinf, res_isfin, res_isnorm, res_iszero, res_issubnorm, 1, classification);\n }\n \n int __attribute__ ((__noinline__))\n@@ -132,35 +157,35 @@ main_tests (void)\n   \n   /* Test NaN.  */\n   f = __builtin_nanf(\"\"); d = __builtin_nan(\"\"); ld = __builtin_nanl(\"\");\n-  foo(f, d, ld, /*unord=*/ 1, /*isnan=*/ 1, /*isinf=*/ 0, /*isfin=*/ 0, /*isnorm=*/ 0, FP_NAN);\n+  foo(f, d, ld, /*unord=*/ 1, /*isnan=*/ 1, /*isinf=*/ 0, /*isfin=*/ 0, /*isnorm=*/ 0, /*iszero=*/0, /*issubnorm=*/0, FP_NAN);\n \n   /* Test infinity.  */\n   f = __builtin_inff(); d = __builtin_inf(); ld = __builtin_infl();\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, FP_INFINITE);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, /*iszero=*/0, /*issubnorm=*/0, FP_INFINITE);\n \n   /* Test zero.  */\n   f = 0; d = 0; ld = 0;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, FP_ZERO);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, /*iszero=*/1, /*issubnorm=*/0, FP_ZERO);\n \n   /* Test one.  */\n   f = 1; d = 1; ld = 1;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, /*iszero=*/0, /*issubnorm=*/0, FP_NORMAL);\n \n   /* Test minimum values.  */\n   f = __FLT_MIN__; d = __DBL_MIN__; ld = __LDBL_MIN__;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, /*iszero=*/0, /*issubnorm=*/0, FP_NORMAL);\n \n   /* Test subnormal values.  */\n   f = __FLT_MIN__/2; d = __DBL_MIN__/2; ld = __LDBL_MIN__/2;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, FP_SUBNORMAL);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, /*iszero=*/0, /*issubnorm=*/1, FP_SUBNORMAL);\n \n   /* Test maximum values.  */\n   f = __FLT_MAX__; d = __DBL_MAX__; ld = __LDBL_MAX__;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, /*iszero=*/0, /*issubnorm=*/0, FP_NORMAL);\n \n   /* Test overflow values.  */\n   f = __FLT_MAX__*2; d = __DBL_MAX__*2; ld = __LDBL_MAX__*2;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, FP_INFINITE);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, /*iszero=*/0, /*issubnorm=*/0, FP_INFINITE);\n \n   return 0;\n }"}, {"sha": "ec9d3ad41e24280978707888590eec1b562207f0", "filename": "gcc/testsuite/gcc.dg/torture/float128-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float128 type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-tg-4.h\""}, {"sha": "0ede861716750453a86c9abc703ad0b2826674c6", "filename": "gcc/testsuite/gcc.dg/torture/float128x-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float128x type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-tg-4.h\""}, {"sha": "007c4c224ea95537c31185d0aff964d1975f2190", "filename": "gcc/testsuite/gcc.dg/torture/float16-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float16 type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-tg-4.h\""}, {"sha": "c7f8353da2cffdfc2c2f58f5da3d5363b95e6f91", "filename": "gcc/testsuite/gcc.dg/torture/float32-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float32 type-generic built-in functions: __builtin_f__builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-tg-4.h\""}, {"sha": "0d7a592920aca112d5f6409e565d4582c253c977", "filename": "gcc/testsuite/gcc.dg/torture/float32x-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float32x type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-tg-4.h\""}, {"sha": "bb25a22a68e60ce2717ab3583bbec595dd563c35", "filename": "gcc/testsuite/gcc.dg/torture/float64-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float64 type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-tg-4.h\""}, {"sha": "82305d916b8bd75131e2c647fd37f74cadbc8f1d", "filename": "gcc/testsuite/gcc.dg/torture/float64x-tg-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg-4.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,11 @@\n+/* Test _Float64x type-generic built-in functions: __builtin_iszero,\n+   __builtin_issubnormal.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-tg-4.h\""}, {"sha": "aa3448c090cf797a1525b1045ffebeed79cace40", "filename": "gcc/testsuite/gcc.dg/torture/floatn-tg-4.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg-4.h?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,99 @@\n+/* Tests for _FloatN / _FloatNx types: compile and execution tests for\n+   type-generic built-in functions: __builtin_iszero, __builtin_issubnormal.\n+   Before including this file, define WIDTH as the value N; define EXT to 1\n+   for _FloatNx and 0 for _FloatN.  */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define MAX CONCAT3 (FLT, WIDTH, X_MAX)\n+# define MIN CONCAT3 (FLT, WIDTH, X_MIN)\n+# define TRUE_MIN CONCAT3 (FLT, WIDTH, X_TRUE_MIN)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define MAX CONCAT3 (FLT, WIDTH, _MAX)\n+# define MIN CONCAT3 (FLT, WIDTH, _MIN)\n+# define TRUE_MIN CONCAT3 (FLT, WIDTH, _TRUE_MIN)\n+#endif\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+volatile TYPE inf = __builtin_inf (), nanval = __builtin_nan (\"\");\n+volatile TYPE neginf = -__builtin_inf (), negnanval = -__builtin_nan (\"\");\n+volatile TYPE zero = CST (0.0), negzero = -CST (0.0), one = CST (1.0);\n+volatile TYPE max = MAX, negmax = -MAX, min = MIN, negmin = -MIN;\n+volatile TYPE true_min = TRUE_MIN, negtrue_min = -TRUE_MIN;\n+volatile TYPE sub_norm = MIN / 2.0;\n+\n+int\n+main (void)\n+{\n+  if (__builtin_iszero (inf) == 1)\n+    abort ();\n+  if (__builtin_iszero (nanval) == 1)\n+    abort ();\n+  if (__builtin_iszero (neginf) == 1)\n+    abort ();\n+  if (__builtin_iszero (negnanval) == 1)\n+    abort ();\n+  if (__builtin_iszero (zero) != 1)\n+    abort ();\n+  if (__builtin_iszero (negzero) != 1)\n+    abort ();\n+  if (__builtin_iszero (one) == 1)\n+    abort ();\n+  if (__builtin_iszero (max) == 1)\n+    abort ();\n+  if (__builtin_iszero (negmax) == 1)\n+    abort ();\n+  if (__builtin_iszero (min) == 1)\n+    abort ();\n+  if (__builtin_iszero (negmin) == 1)\n+    abort ();\n+  if (__builtin_iszero (true_min) == 1)\n+    abort ();\n+  if (__builtin_iszero (negtrue_min) == 1)\n+    abort ();\n+  if (__builtin_iszero (sub_norm) == 1)\n+    abort ();\n+\n+  if (__builtin_issubnormal (inf) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (nanval) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (neginf) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (negnanval) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (zero) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (negzero) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (one) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (max) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (negmax) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (min) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (negmin) == 1)\n+    abort ();\n+  if (__builtin_issubnormal (true_min) != 1)\n+    abort ();\n+  if (__builtin_issubnormal (negtrue_min) != 1)\n+    abort ();\n+  if (__builtin_issubnormal (sub_norm) != 1)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "3a1bf956bfcedcc15dc1cbacfe2f0b663b31c3cc", "filename": "gcc/testsuite/gcc.target/aarch64/builtin-fpclassify.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbuiltin-fpclassify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fc87ecdf45e2455deb7ee50e13765c98d4e904/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbuiltin-fpclassify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbuiltin-fpclassify.c?ref=94fc87ecdf45e2455deb7ee50e13765c98d4e904", "patch": "@@ -0,0 +1,22 @@\n+/* This file checks the code generation for the new __builtin_fpclassify.\n+   because checking the exact assembly isn't very useful, we'll just be checking\n+   for the presence of certain instructions and the omition of others. */\n+/* { dg-options \"-O2\" } */\n+/* { dg-do compile } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]?fabs\\[ \\t\\]?\" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]?fcmp\\[ \\t\\]?\" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]?fcmpe\\[ \\t\\]?\" } } */\n+/* { dg-final { scan-assembler \"\\[ \\t\\]?ubfx\\[ \\t\\]?\" } } */\n+\n+#include <stdio.h>\n+#include <math.h>\n+\n+/*\n+ fp_nan = args[0];\n+ fp_infinite = args[1];\n+ fp_normal = args[2];\n+ fp_subnormal = args[3];\n+ fp_zero = args[4];\n+*/\n+\n+int f(double x) { return __builtin_fpclassify(0, 1, 4, 3, 2, x); }"}]}