{"sha": "b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVkNzc3MGMzZTY4NmQ1OGU0Y2UxZTFiNDljMzVlZWMyYzA0NzViYg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2000-09-11T21:03:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2000-09-11T21:03:26Z"}, "message": "print-rtl.c (debug_call_placeholder_verbose): New variable.\n\n* print-rtl.c (debug_call_placeholder_verbose): New variable.\n(print_rtx) [CALL_PLACEHOLDER]: Dump all call sequences if it is\nset.\n* integrate.c (copy_rtx_and_substitute): Don't share\nLEAF_REG_REMAPpable registers with the inlined function.  Don't\nshare the function value with calling sequences.\n\nFrom-SVN: r36329", "tree": {"sha": "1d26f3ff7a587dc7f37d23724c0dac8615974381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d26f3ff7a587dc7f37d23724c0dac8615974381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/comments", "author": null, "committer": null, "parents": [{"sha": "da88b352787b53926ba3038983289a59ddaea887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da88b352787b53926ba3038983289a59ddaea887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da88b352787b53926ba3038983289a59ddaea887"}], "stats": {"total": 76, "additions": 73, "deletions": 3}, "files": [{"sha": "1f902ca852954970d70887a3ec93ee7e244654bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "patch": "@@ -1,3 +1,12 @@\n+2000-09-11  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* print-rtl.c (debug_call_placeholder_verbose): New variable.\n+\t(print_rtx) [CALL_PLACEHOLDER]: Dump all call sequences if it is\n+\tset.\n+\t* integrate.c (copy_rtx_and_substitute): Don't share\n+\tLEAF_REG_REMAPpable registers with the inlined function.  Don't\n+\tshare the function value with calling sequences.\n+\n 2000-09-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-decl.c (do_case): Fix a typo."}, {"sha": "6128aaf895d974638d454ebb55546361a7addcd5", "filename": "gcc/integrate.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "patch": "@@ -1746,7 +1746,15 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t{\n \t  /* Some hard registers are also mapped,\n \t     but others are not translated.  */\n-\t  if (map->reg_map[regno] != 0)\n+\t  if (map->reg_map[regno] != 0\n+\t      /* We shouldn't usually have reg_map set for return\n+\t\t register, but it may happen if we have leaf-register\n+\t\t remapping and the return register is used in one of\n+\t\t the calling sequences of a call_placeholer.  In this\n+\t\t case, we'll end up with a reg_map set for this\n+\t\t register, but we don't want to use for registers\n+\t\t marked as return values.  */\n+\t      && ! REG_FUNCTION_VALUE_P (orig))\n \t    return map->reg_map[regno];\n \n \t  /* If this is the virtual frame pointer, make space in current\n@@ -1757,7 +1765,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t     equivalence for it to be the address.  This will substitute the\n \t     address into insns where it can be substituted and use the new\n \t     pseudo where it can't.  */\n-\t  if (regno == VIRTUAL_STACK_VARS_REGNUM)\n+\t  else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n \t    {\n \t      rtx loc, seq;\n \t      int size = get_func_frame_size (DECL_SAVED_INSNS (map->fndecl));\n@@ -1844,7 +1852,26 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t      else\n \t\treturn map->inline_target;\n \t    }\n-\t  return orig;\n+#if defined (LEAF_REGISTERS) && defined (LEAF_REG_REMAP)\n+\t  /* If leaf_renumber_regs_insn() might remap this register to\n+\t     some other number, make sure we don't share it with the\n+\t     inlined function, otherwise delayed optimization of the\n+\t     inlined function may change it in place, breaking our\n+\t     reference to it.  We may still shared it within the\n+\t     function, so create an entry for this register in the\n+\t     reg_map.  */\n+\t  if (map->integrating && regno < FIRST_PSEUDO_REGISTER\n+\t      && LEAF_REGISTERS[regno] && LEAF_REG_REMAP (regno) != regno)\n+\t    {\n+\t      temp = gen_rtx_REG (mode, regno);\n+\t      map->reg_map[regno] = temp;\n+\t      return temp;\n+\t    }\n+#endif\n+\t  else\n+\t    return orig;\n+\n+\t  abort ();\n \t}\n       if (map->reg_map[regno] == NULL)\n \t{"}, {"sha": "31eac815cef57fe7b9db7d5976351eb8d41ceb43", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "patch": "@@ -63,6 +63,9 @@ int flag_dump_unnumbered = 0;\n /* Nonzero if we are dumping graphical description.  */\n int dump_for_graph;\n \n+/* Nonzero to dump all call_placeholder alternatives.  */\n+static int debug_call_placeholder_verbose;\n+\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n@@ -421,6 +424,37 @@ print_rtx (in_rtx)\n       break;\n \n     case CALL_PLACEHOLDER:\n+      if (debug_call_placeholder_verbose)\n+\t{\n+\t  fputs (\" (cond [\\n  (const_string \\\"normal\\\") (sequence [\", outfile);\n+\t  for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n+\t    {\n+\t      fputs (\"\\n    \", outfile);\n+\t      print_inline_rtx (outfile, tem, 4);\n+\t    }\n+\n+\t  tem = XEXP (in_rtx, 1);\n+\t  if (tem)\n+\t    fputs (\"\\n    ])\\n  (const_string \\\"tail_call\\\") (sequence [\", outfile);\n+\t  for (; tem != 0; tem = NEXT_INSN (tem))\n+\t    {\n+\t      fputs (\"\\n    \", outfile);\n+\t      print_inline_rtx (outfile, tem, 4);\n+\t    }\n+\n+\t  tem = XEXP (in_rtx, 2);\n+\t  if (tem)\n+\t    fputs (\"\\n    ])\\n  (const_string \\\"tail_recursion\\\") (sequence [\", outfile);\n+\t  for (; tem != 0; tem = NEXT_INSN (tem))\n+\t    {\n+\t      fputs (\"\\n    \", outfile);\n+\t      print_inline_rtx (outfile, tem, 4);\n+\t    }\n+\n+\t  fputs (\"\\n    ])\\n  ])\", outfile);\n+\t  break;\n+\t}\n+\n       for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n \tif (GET_CODE (tem) == CALL_INSN)\n \t  {"}]}