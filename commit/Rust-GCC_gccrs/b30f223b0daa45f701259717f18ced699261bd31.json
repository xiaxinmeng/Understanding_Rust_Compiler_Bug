{"sha": "b30f223b0daa45f701259717f18ced699261bd31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMwZjIyM2IwZGFhNDVmNzAxMjU5NzE3ZjE4Y2VkNjk5MjYxYmQzMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-04T19:51:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-04T19:51:11Z"}, "message": "Initial revision\n\nFrom-SVN: r278", "tree": {"sha": "9df5852df654f54cabcd25f9b9deb44d7f44b99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9df5852df654f54cabcd25f9b9deb44d7f44b99a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b30f223b0daa45f701259717f18ced699261bd31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30f223b0daa45f701259717f18ced699261bd31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b30f223b0daa45f701259717f18ced699261bd31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30f223b0daa45f701259717f18ced699261bd31/comments", "author": null, "committer": null, "parents": [{"sha": "6bce1b788365835275cb9ac72c08a7f5a6e13a40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bce1b788365835275cb9ac72c08a7f5a6e13a40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bce1b788365835275cb9ac72c08a7f5a6e13a40"}], "stats": {"total": 894, "additions": 894, "deletions": 0}, "files": [{"sha": "a65a49c81a433c1970af993190a063f2bae9dff3", "filename": "gcc/c-common.c", "status": "added", "additions": 894, "deletions": 0, "changes": 894, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f223b0daa45f701259717f18ced699261bd31/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f223b0daa45f701259717f18ced699261bd31/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b30f223b0daa45f701259717f18ced699261bd31", "patch": "@@ -0,0 +1,894 @@\n+/* Subroutines shared by all languages that are variants of C.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"c-lex.h\"\n+#include \"c-tree.h\"\n+#include \"flags.h\"\n+#include <stdio.h>\n+\n+#undef NULL\n+#define NULL 0\n+\n+/* Given a chain of STRING_CST nodes,\n+   concatenate them into one STRING_CST\n+   and give it a suitable array-of-chars data type.  */\n+\n+tree\n+combine_strings (strings)\n+     tree strings;\n+{\n+  register tree value, t;\n+  register int length = 1;\n+  int wide_length = 0;\n+  int wide_flag = 0;\n+  int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n+  int nchars;\n+\n+  if (TREE_CHAIN (strings))\n+    {\n+      /* More than one in the chain, so concatenate.  */\n+      register char *p, *q;\n+\n+      /* Don't include the \\0 at the end of each substring,\n+\t except for the last one.\n+\t Count wide strings and ordinary strings separately.  */\n+      for (t = strings; t; t = TREE_CHAIN (t))\n+\t{\n+\t  if (TREE_TYPE (t) == wchar_array_type_node)\n+\t    {\n+\t      wide_length += (TREE_STRING_LENGTH (t) - wchar_bytes);\n+\t      wide_flag = 1;\n+\t    }\n+\t  else\n+\t    length += (TREE_STRING_LENGTH (t) - 1);\n+\t}\n+\n+      /* If anything is wide, the non-wides will be converted,\n+\t which makes them take more space.  */\n+      if (wide_flag)\n+\tlength = length * wchar_bytes + wide_length;\n+\n+      p = savealloc (length);\n+\n+      /* Copy the individual strings into the new combined string.\n+\t If the combined string is wide, convert the chars to ints\n+\t for any individual strings that are not wide.  */\n+\n+      q = p;\n+      for (t = strings; t; t = TREE_CHAIN (t))\n+\t{\n+\t  int len = (TREE_STRING_LENGTH (t)\n+\t\t     - ((TREE_TYPE (t) == wchar_array_type_node)\n+\t\t\t? wchar_bytes : 1));\n+\t  if ((TREE_TYPE (t) == wchar_array_type_node) == wide_flag)\n+\t    {\n+\t      bcopy (TREE_STRING_POINTER (t), q, len);\n+\t      q += len;\n+\t    }\n+\t  else\n+\t    {\n+\t      int i;\n+\t      for (i = 0; i < len; i++)\n+\t\t((int *) q)[i] = TREE_STRING_POINTER (t)[i];\n+\t      q += len * wchar_bytes;\n+\t    }\n+\t}\n+      if (wide_flag)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < wchar_bytes; i++)\n+\t    *q++ = 0;\n+\t}\n+      else\n+\t*q = 0;\n+\n+      value = make_node (STRING_CST);\n+      TREE_STRING_POINTER (value) = p;\n+      TREE_STRING_LENGTH (value) = length;\n+      TREE_CONSTANT (value) = 1;\n+    }\n+  else\n+    {\n+      value = strings;\n+      length = TREE_STRING_LENGTH (value);\n+      if (TREE_TYPE (value) == wchar_array_type_node)\n+\twide_flag = 1;\n+    }\n+\n+  /* Compute the number of elements, for the array type.  */ \n+  nchars = wide_flag ? length / wchar_bytes : length;\n+\n+  /* Create the array type for the string constant.\n+     -Wwrite-strings says make the string constant an array of const char\n+     so that copying it to a non-const pointer will get a warning.  */\n+  if (warn_write_strings\n+      && (! flag_traditional  && ! flag_writable_strings))\n+    {\n+      tree elements\n+\t= build_type_variant (wide_flag ? wchar_type_node : char_type_node,\n+\t\t\t      1, 0);\n+      TREE_TYPE (value)\n+\t= build_array_type (elements,\n+\t\t\t    build_index_type (build_int_2 (nchars - 1, 0)));\n+    }\n+  else\n+    TREE_TYPE (value)\n+      = build_array_type (wide_flag ? wchar_type_node : char_type_node,\n+\t\t\t  build_index_type (build_int_2 (nchars - 1, 0)));\n+  TREE_CONSTANT (value) = 1;\n+  TREE_STATIC (value) = 1;\n+  return value;\n+}\n+\f\n+/* Process the attributes listed in ATTRIBUTES\n+   and install them in DECL.  */\n+\n+void\n+decl_attributes (decl, attributes)\n+     tree decl, attributes;\n+{\n+  tree a;\n+  for (a = attributes; a; a = TREE_CHAIN (a))\n+    if (TREE_VALUE (a) != 0\n+\t&& TREE_CODE (TREE_VALUE (a)) == TREE_LIST\n+\t&& TREE_PURPOSE (TREE_VALUE (a)) == get_identifier (\"aligned\"))\n+      {\n+\tint align = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (a)))\n+\t\t    * BITS_PER_UNIT;\n+\t\n+\tif (exact_log2 (align) == -1)\n+\t  warning_with_decl (decl,\n+\t\t\t\"requested alignment of `%s' is not a power of 2\");\n+\telse if (TREE_CODE (decl) != VAR_DECL\n+\t\t && TREE_CODE (decl) != FIELD_DECL)\n+\t  warning_with_decl (decl,\n+\t\t\"alignment specified for `%s' which is not a variable\");\n+\n+\t/* ??? The maximum alignment gcc can currently handle is 16 bytes!\n+\t   We should change the representation to be the log of the\n+\t   actual alignment since we only handle powers of 2 anyway.  */\n+\telse if (align > 255)\n+\t  warning_with_decl (decl,\n+\t\t\"requested alignment of `%s' exceeds compiler limits\");\n+\telse\n+\t  DECL_ALIGN (decl) = align;\n+      }\n+    else if (TREE_VALUE (a) != 0\n+\t     && TREE_CODE (TREE_VALUE (a)) == TREE_LIST\n+\t     && TREE_PURPOSE (TREE_VALUE (a)) == get_identifier (\"packed\"))\n+      {\n+\tif (TREE_CODE (decl) == FIELD_DECL)\n+\t  DECL_PACKED (decl) = 1;\n+      }\n+    else if (TREE_VALUE (a) != 0\n+\t&& TREE_CODE (TREE_VALUE (a)) == TREE_LIST\n+\t&& TREE_PURPOSE (TREE_VALUE (a)) == get_identifier (\"format\"))\n+      {\n+        tree list = TREE_VALUE (TREE_VALUE (a));\n+        tree format_type = TREE_PURPOSE (list);\n+\tint format_num = TREE_INT_CST_LOW (TREE_PURPOSE (TREE_VALUE (list)));\n+\tint first_arg_num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n+\tint is_scan;\n+\t\n+\tif (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  {\n+\t    warning_with_decl (decl,\n+\t\t\"argument format specified for non-function `%s'\");\n+\t    return;\n+\t  }\n+\t\n+\tif (format_type == get_identifier (\"printf\"))\n+\t  is_scan = 0;\n+\telse if (format_type == get_identifier (\"scanf\"))\n+\t  is_scan = 1;\n+\telse\n+\t  {\n+\t    warning_with_decl (decl,\"unrecognized format specifier for `%s'\");\n+\t    return;\n+\t  }\n+\t\n+\tif (first_arg_num != 0 && first_arg_num <= format_num)\n+\t  {\n+\t    warning_with_decl (decl,\n+\t\t\"format string arg follows the args to be formatted, for `%s'\");\n+\t    return;\n+\t  }\n+\t\n+\trecord_format_info (DECL_NAME (decl), is_scan, format_num,\n+\t\t\t    first_arg_num);\n+      }\n+}\n+\f\n+void\n+c_expand_expr_stmt (expr)\n+     tree expr;\n+{\n+  /* Do default conversion if safe and possibly important,\n+     in case within ({...}).  */\n+  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE && lvalue_p (expr))\n+      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+    expr = default_conversion (expr);\n+\n+  if (TREE_TYPE (expr) != error_mark_node\n+      && TYPE_SIZE (TREE_TYPE (expr)) == 0\n+      && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n+    error (\"expression statement has incomplete type\");\n+\n+  expand_expr_stmt (expr);\n+}\n+\f\n+/* Validate the expression after `case' and apply default promotions.  */\n+\n+tree\n+check_case_value (value)\n+     tree value;\n+{\n+  if (value == NULL_TREE)\n+    return value;\n+\n+  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n+  if (TREE_CODE (value) == NON_LVALUE_EXPR)\n+    value = TREE_OPERAND (value, 0);\n+\n+  if (TREE_CODE (value) != INTEGER_CST\n+      && value != error_mark_node)\n+    {\n+      error (\"case label does not reduce to an integer constant\");\n+      value = error_mark_node;\n+    }\n+  else\n+    /* Promote char or short to int.  */\n+    value = default_conversion (value);\n+\n+  return value;\n+}\n+\f\n+/* Return an integer type with BITS bits of precision,\n+   that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n+\n+tree\n+type_for_size (bits, unsignedp)\n+     unsigned bits;\n+     int unsignedp;\n+{\n+  if (bits <= TYPE_PRECISION (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n+  if (bits <= TYPE_PRECISION (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+\n+  if (bits <= TYPE_PRECISION (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (bits <= TYPE_PRECISION (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (bits <= TYPE_PRECISION (long_long_integer_type_node))\n+    return (unsignedp ? long_long_unsigned_type_node\n+\t    : long_long_integer_type_node);\n+\n+  return 0;\n+}\n+\n+/* Return a data type that has machine mode MODE.\n+   If the mode is an integer,\n+   then UNSIGNEDP selects between signed and unsigned types.  */\n+\n+tree\n+type_for_mode (mode, unsignedp)\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  if (mode == TYPE_MODE (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n+  if (mode == TYPE_MODE (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_long_integer_type_node))\n+    return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (long_double_type_node))\n+    return long_double_type_node;\n+\n+  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n+    return build_pointer_type (char_type_node);\n+\n+  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n+    return build_pointer_type (integer_type_node);\n+\n+  return 0;\n+}\n+\f\n+/* Print an error message for invalid operands to arith operation CODE.\n+   NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n+\n+void\n+binary_op_error (code)\n+     enum tree_code code;\n+{\n+  register char *opname;\n+  switch (code)\n+    {\n+    case NOP_EXPR:\n+      error (\"invalid truth-value expression\");\n+      return;\n+\n+    case PLUS_EXPR:\n+      opname = \"+\"; break;\n+    case MINUS_EXPR:\n+      opname = \"-\"; break;\n+    case MULT_EXPR:\n+      opname = \"*\"; break;\n+    case MAX_EXPR:\n+      opname = \"max\"; break;\n+    case MIN_EXPR:\n+      opname = \"min\"; break;\n+    case EQ_EXPR:\n+      opname = \"==\"; break;\n+    case NE_EXPR:\n+      opname = \"!=\"; break;\n+    case LE_EXPR:\n+      opname = \"<=\"; break;\n+    case GE_EXPR:\n+      opname = \">=\"; break;\n+    case LT_EXPR:\n+      opname = \"<\"; break;\n+    case GT_EXPR:\n+      opname = \">\"; break;\n+    case LSHIFT_EXPR:\n+      opname = \"<<\"; break;\n+    case RSHIFT_EXPR:\n+      opname = \">>\"; break;\n+    case TRUNC_MOD_EXPR:\n+      opname = \"%\"; break;\n+    case TRUNC_DIV_EXPR:\n+      opname = \"/\"; break;\n+    case BIT_AND_EXPR:\n+      opname = \"&\"; break;\n+    case BIT_IOR_EXPR:\n+      opname = \"|\"; break;\n+    case TRUTH_ANDIF_EXPR:\n+      opname = \"&&\"; break;\n+    case TRUTH_ORIF_EXPR:\n+      opname = \"||\"; break;\n+    case BIT_XOR_EXPR:\n+      opname = \"^\"; break;\n+    }\n+  error (\"invalid operands to binary %s\", opname);\n+}\n+\f\n+/* Subroutine of build_binary_op, used for comparison operations.\n+   See if the operands have both been converted from subword integer types\n+   and, if so, perhaps change them both back to their original type.\n+\n+   The arguments of this function are all pointers to local variables\n+   of build_binary_op: OP0_PTR is &OP0, OP1_PTR is &OP1,\n+   RESTYPE_PTR is &RESULT_TYPE and RESCODE_PTR is &RESULTCODE.\n+\n+   If this function returns nonzero, it means that the comparison has\n+   a constant value.  What this function returns is an expression for\n+   that value.  */\n+\n+tree\n+shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n+     tree *op0_ptr, *op1_ptr;\n+     tree *restype_ptr;\n+     enum tree_code *rescode_ptr;\n+{\n+  register tree type;\n+  tree op0 = *op0_ptr;\n+  tree op1 = *op1_ptr;\n+  int unsignedp0, unsignedp1;\n+  int real1, real2;\n+  tree primop0, primop1;\n+  enum tree_code code = *rescode_ptr;\n+\n+  /* Throw away any conversions to wider types\n+     already present in the operands.  */\n+\n+  primop0 = get_narrower (op0, &unsignedp0);\n+  primop1 = get_narrower (op1, &unsignedp1);\n+\n+  /* Handle the case that OP0 does not *contain* a conversion\n+     but it *requires* conversion to FINAL_TYPE.  */\n+\n+  if (op0 == primop0 && TREE_TYPE (op0) != *restype_ptr)\n+    unsignedp0 = TREE_UNSIGNED (TREE_TYPE (op0));\n+  if (op1 == primop1 && TREE_TYPE (op1) != *restype_ptr)\n+    unsignedp1 = TREE_UNSIGNED (TREE_TYPE (op1));\n+\n+  /* If one of the operands must be floated, we cannot optimize.  */\n+  real1 = TREE_CODE (TREE_TYPE (primop0)) == REAL_TYPE;\n+  real2 = TREE_CODE (TREE_TYPE (primop1)) == REAL_TYPE;\n+\n+  /* If first arg is constant, swap the args (changing operation\n+     so value is preserved), for canonicalization.  */\n+\n+  if (TREE_CONSTANT (primop0))\n+    {\n+      register tree tem = primop0;\n+      register int temi = unsignedp0;\n+      primop0 = primop1;\n+      primop1 = tem;\n+      tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      *op0_ptr = op0;\n+      *op1_ptr = op1;\n+      unsignedp0 = unsignedp1;\n+      unsignedp1 = temi;\n+      temi = real1;\n+      real1 = real2;\n+      real2 = temi;\n+\n+      switch (code)\n+\t{\n+\tcase LT_EXPR:\n+\t  code = GT_EXPR;\n+\t  break;\n+\tcase GT_EXPR:\n+\t  code = LT_EXPR;\n+\t  break;\n+\tcase LE_EXPR:\n+\t  code = GE_EXPR;\n+\t  break;\n+\tcase GE_EXPR:\n+\t  code = LE_EXPR;\n+\t  break;\n+\t}\n+      *rescode_ptr = code;\n+    }\n+\n+  /* If comparing an integer against a constant more bits wide,\n+     maybe we can deduce a value of 1 or 0 independent of the data.\n+     Or else truncate the constant now\n+     rather than extend the variable at run time.\n+\n+     This is only interesting if the constant is the wider arg.\n+     Also, it is not safe if the constant is unsigned and the\n+     variable arg is signed, since in this case the variable\n+     would be sign-extended and then regarded as unsigned.\n+     Our technique fails in this case because the lowest/highest\n+     possible unsigned results don't follow naturally from the\n+     lowest/highest possible values of the variable operand.\n+     For just EQ_EXPR and NE_EXPR there is another technique that\n+     could be used: see if the constant can be faithfully represented\n+     in the other operand's type, by truncating it and reextending it\n+     and see if that preserves the constant's value.  */\n+\n+  if (!real1 && !real2\n+      && TREE_CODE (primop1) == INTEGER_CST\n+      && TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (*restype_ptr))\n+    {\n+      int min_gt, max_gt, min_lt, max_lt;\n+      tree maxval, minval;\n+      /* 1 if comparison is nominally unsigned.  */\n+      int unsignedp = TREE_UNSIGNED (*restype_ptr);\n+      tree val;\n+\n+      type = signed_or_unsigned_type (unsignedp0, TREE_TYPE (primop0));\n+\n+      maxval = TYPE_MAX_VALUE (type);\n+      minval = TYPE_MIN_VALUE (type);\n+\n+      if (unsignedp && !unsignedp0)\n+\t*restype_ptr = signed_type (*restype_ptr);\n+\n+      if (TREE_TYPE (primop1) != *restype_ptr)\n+\tprimop1 = convert (*restype_ptr, primop1);\n+      if (type != *restype_ptr)\n+\t{\n+\t  minval = convert (*restype_ptr, minval);\n+\t  maxval = convert (*restype_ptr, maxval);\n+\t}\n+\n+      if (unsignedp && unsignedp0)\n+\t{\n+\t  min_gt = INT_CST_LT_UNSIGNED (primop1, minval);\n+\t  max_gt = INT_CST_LT_UNSIGNED (primop1, maxval);\n+\t  min_lt = INT_CST_LT_UNSIGNED (minval, primop1);\n+\t  max_lt = INT_CST_LT_UNSIGNED (maxval, primop1);\n+\t}\n+      else\n+\t{\n+\t  min_gt = INT_CST_LT (primop1, minval);\n+\t  max_gt = INT_CST_LT (primop1, maxval);\n+\t  min_lt = INT_CST_LT (minval, primop1);\n+\t  max_lt = INT_CST_LT (maxval, primop1);\n+\t}\n+\n+      val = 0;\n+      /* This used to be a switch, but Genix compiler can't handle that.  */\n+      if (code == NE_EXPR)\n+\t{\n+\t  if (max_lt || min_gt)\n+\t    val = integer_one_node;\n+\t}\n+      else if (code == EQ_EXPR)\n+\t{\n+\t  if (max_lt || min_gt)\n+\t    val = integer_zero_node;\n+\t}\n+      else if (code == LT_EXPR)\n+\t{\n+\t  if (max_lt)\n+\t    val = integer_one_node;\n+\t  if (!min_lt)\n+\t    val = integer_zero_node;\n+\t}\n+      else if (code == GT_EXPR)\n+\t{\n+\t  if (min_gt)\n+\t    val = integer_one_node;\n+\t  if (!max_gt)\n+\t    val = integer_zero_node;\n+\t}\n+      else if (code == LE_EXPR)\n+\t{\n+\t  if (!max_gt)\n+\t    val = integer_one_node;\n+\t  if (min_gt)\n+\t    val = integer_zero_node;\n+\t}\n+      else if (code == GE_EXPR)\n+\t{\n+\t  if (!min_lt)\n+\t    val = integer_one_node;\n+\t  if (max_lt)\n+\t    val = integer_zero_node;\n+\t}\n+\n+      /* If primop0 was sign-extended and unsigned comparison specd,\n+\t we did a signed comparison above using the signed type bounds.\n+\t But the comparison we output must be unsigned.\n+\n+\t Also, for inequalities, VAL is no good; but if the signed\n+\t comparison had *any* fixed result, it follows that the\n+\t unsigned comparison just tests the sign in reverse\n+\t (positive values are LE, negative ones GE).\n+\t So we can generate an unsigned comparison\n+\t against an extreme value of the signed type.  */\n+\n+      if (unsignedp && !unsignedp0)\n+\t{\n+\t  if (val != 0)\n+\t    switch (code)\n+\t      {\n+\t      case LT_EXPR:\n+\t      case GE_EXPR:\n+\t\tprimop1 = TYPE_MIN_VALUE (type);\n+\t\tval = 0;\n+\t\tbreak;\n+\n+\t      case LE_EXPR:\n+\t      case GT_EXPR:\n+\t\tprimop1 = TYPE_MAX_VALUE (type);\n+\t\tval = 0;\n+\t\tbreak;\n+\t      }\n+\t  type = unsigned_type (type);\n+\t}\n+\n+      if (max_lt && !unsignedp0)\n+\t{\n+\t  /* This is the case of (char)x >?< 0x80, which people used to use\n+\t     expecting old C compilers to change the 0x80 into -0x80.  */\n+\t  if (val == integer_zero_node)\n+\t    warning (\"comparison is always 0 due to limited range of data type\");\n+\t  if (val == integer_one_node)\n+\t    warning (\"comparison is always 1 due to limited range of data type\");\n+\t}\n+\n+      if (min_gt && unsignedp0)\n+\t{\n+\t  /* This is the case of (unsigned char)x >?< -1.  */\n+\t  if (val == integer_zero_node)\n+\t    warning (\"comparison is always 0 due to limited range of data type\");\n+\t  if (val == integer_one_node)\n+\t    warning (\"comparison is always 1 due to limited range of data type\");\n+\t}\n+\n+      if (val != 0)\n+\t{\n+\t  /* Don't forget to evaluate PRIMOP0 if it has side effects.  */\n+\t  if (TREE_SIDE_EFFECTS (primop0))\n+\t    return build (COMPOUND_EXPR, TREE_TYPE (val), primop0, val);\n+\t  return val;\n+\t}\n+\n+      /* Value is not predetermined, but do the comparison\n+\t in the type of the operand that is not constant.\n+\t TYPE is already properly set.  */\n+    }\n+  else if (real1 && real2\n+\t   && TYPE_PRECISION (TREE_TYPE (primop0)) == TYPE_PRECISION (TREE_TYPE (primop1)))\n+    type = TREE_TYPE (primop0);\n+\n+  /* If args' natural types are both narrower than nominal type\n+     and both extend in the same manner, compare them\n+     in the type of the wider arg.\n+     Otherwise must actually extend both to the nominal\n+     common type lest different ways of extending\n+     alter the result.\n+     (eg, (short)-1 == (unsigned short)-1  should be 0.)  */\n+\n+  else if (unsignedp0 == unsignedp1 && real1 == real2\n+\t   && TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (*restype_ptr)\n+\t   && TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (*restype_ptr))\n+    {\n+      type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1));\n+      type = signed_or_unsigned_type (unsignedp0\n+\t\t\t\t      || TREE_UNSIGNED (*restype_ptr),\n+\t\t\t\t      type);\n+      /* Make sure shorter operand is extended the right way\n+\t to match the longer operand.  */\n+      primop0 = convert (signed_or_unsigned_type (unsignedp0, TREE_TYPE (primop0)),\n+\t\t\t primop0);\n+      primop1 = convert (signed_or_unsigned_type (unsignedp1, TREE_TYPE (primop1)),\n+\t\t\t primop1);\n+    }\n+  else\n+    {\n+      /* Here we must do the comparison on the nominal type\n+\t using the args exactly as we received them.  */\n+      type = *restype_ptr;\n+      primop0 = op0;\n+      primop1 = op1;\n+\n+      if (!real1 && !real2 && integer_zerop (primop1)\n+\t  && TREE_UNSIGNED (TREE_TYPE (primop0)))\n+\t{\n+\t  tree value = 0;\n+\t  switch (code)\n+\t    {\n+\t    case GE_EXPR:\n+\t      if (extra_warnings)\n+\t\twarning (\"unsigned value >= 0 is always 1\");\n+\t      value = integer_one_node;\n+\t      break;\n+\n+\t    case LT_EXPR:\n+\t      if (extra_warnings)\n+\t\twarning (\"unsigned value < 0 is always 0\");\n+\t      value = integer_zero_node;\n+\t    }\n+\n+\t  if (value != 0)\n+\t    {\n+\t      /* Don't forget to evaluate PRIMOP0 if it has side effects.  */\n+\t      if (TREE_SIDE_EFFECTS (primop0))\n+\t\treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n+\t\t\t      primop0, value);\n+\t      return value;\n+\t    }\n+\t}\n+    }\n+\n+  *op0_ptr = convert (type, primop0);\n+  *op1_ptr = convert (type, primop1);\n+\n+  *restype_ptr = integer_type_node;\n+\n+  return 0;\n+}\n+\f\n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n+   or validate its data type for an `if' or `while' statement or ?..: exp.\n+\n+   This preparation consists of taking the ordinary\n+   representation of an expression expr and producing a valid tree\n+   boolean expression describing whether expr is nonzero.  We could\n+   simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n+   but we optimize comparisons, &&, ||, and !.\n+\n+   The resulting type should always be `integer_type_node'.  */\n+\n+tree\n+truthvalue_conversion (expr)\n+     tree expr;\n+{\n+  register enum tree_code code;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+      /* It is simpler and generates better code to have only TRUTH_*_EXPR\n+\t or comparison expressions as truth values at this level.  */\n+#if 0\n+    case COMPONENT_REF:\n+      /* A one-bit unsigned bit-field is already acceptable.  */\n+      if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))\n+\t  && TREE_UNSIGNED (TREE_OPERAND (expr, 1)))\n+\treturn expr;\n+      break;\n+#endif\n+\n+    case EQ_EXPR:\n+      /* It is simpler and generates better code to have only TRUTH_*_EXPR\n+\t or comparison expressions as truth values at this level.  */\n+#if 0\n+      if (integer_zerop (TREE_OPERAND (expr, 1)))\n+\treturn build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);\n+#endif\n+    case NE_EXPR: case LE_EXPR: case GE_EXPR: case LT_EXPR: case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case ERROR_MARK:\n+      return expr;\n+\n+    case INTEGER_CST:\n+      return integer_zerop (expr) ? integer_zero_node : integer_one_node;\n+\n+    case REAL_CST:\n+      return real_zerop (expr) ? integer_zero_node : integer_one_node;\n+\n+    case ADDR_EXPR:\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 0)))\n+\treturn build (COMPOUND_EXPR, integer_type_node,\n+\t\t      TREE_OPERAND (expr, 0), integer_one_node);\n+      else\n+\treturn integer_one_node;\n+\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case FLOAT_EXPR:\n+    case FFS_EXPR:\n+      /* These don't change whether an object is non-zero or zero.  */\n+      return truthvalue_conversion (TREE_OPERAND (expr, 0));\n+\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      /* These don't change whether an object is zero or non-zero, but\n+\t we can't ignore them if their second arg has side-effects.  */\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n+\treturn build (COMPOUND_EXPR, integer_type_node, TREE_OPERAND (expr, 1),\n+\t\t      truthvalue_conversion (TREE_OPERAND (expr, 0)));\n+      else\n+\treturn truthvalue_conversion (TREE_OPERAND (expr, 0));\n+      \n+    case COND_EXPR:\n+      /* Distribute the conversion into the arms of a COND_EXPR.  */\n+      return fold (build (COND_EXPR, integer_type_node, TREE_OPERAND (expr, 0),\n+\t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+\n+    case CONVERT_EXPR:\n+      /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n+\t since that affects how `default_conversion' will behave.  */\n+      if (TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE\n+\t  || TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == REFERENCE_TYPE)\n+\tbreak;\n+      /* fall through... */\n+    case NOP_EXPR:\n+      /* If this is widening the argument, we can ignore it.  */\n+      if (TYPE_PRECISION (TREE_TYPE (expr))\n+\t  >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\treturn truthvalue_conversion (TREE_OPERAND (expr, 0));\n+      break;\n+\n+    case BIT_XOR_EXPR:\n+    case MINUS_EXPR:\n+      /* These can be changed into a comparison of the two objects.  */\n+      if (TREE_TYPE (TREE_OPERAND (expr, 0))\n+\t  == TREE_TYPE (TREE_OPERAND (expr, 1)))\n+\treturn build_binary_op (NE_EXPR, TREE_OPERAND (expr, 0),\n+\t\t\t\tTREE_OPERAND (expr, 1), 1);\n+      return build_binary_op (NE_EXPR, TREE_OPERAND (expr, 0),\n+\t\t\t      fold (build1 (NOP_EXPR,\n+\t\t\t\t\t    TREE_TYPE (TREE_OPERAND (expr, 0)),\n+\t\t\t\t\t    TREE_OPERAND (expr, 1))), 1);\n+    }\n+\n+  return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n+}\n+\f\n+/* Read the rest of a #-directive from input stream FINPUT.\n+   In normal use, the directive name and the white space after it\n+   have already been read, so they won't be included in the result.\n+   We allow for the fact that the directive line may contain\n+   a newline embedded within a character or string literal which forms\n+   a part of the directive.\n+\n+   The value is a string in a reusable buffer.  It remains valid\n+   only until the next time this function is called.  */\n+\n+char *\n+get_directive_line (finput)\n+     register FILE *finput;\n+{\n+  static char *directive_buffer = NULL;\n+  static unsigned buffer_length = 0;\n+  register char *p;\n+  register char *buffer_limit;\n+  register int looking_for = 0;\n+  register int char_escaped = 0;\n+\n+  if (buffer_length == 0)\n+    {\n+      directive_buffer = (char *)xmalloc (128);\n+      buffer_length = 128;\n+    }\n+\n+  buffer_limit = &directive_buffer[buffer_length];\n+\n+  for (p = directive_buffer; ; )\n+    {\n+      int c;\n+\n+      /* Make buffer bigger if it is full.  */\n+      if (p >= buffer_limit)\n+        {\n+\t  register unsigned bytes_used = (p - directive_buffer);\n+\n+\t  buffer_length *= 2;\n+\t  directive_buffer\n+\t    = (char *)xrealloc (directive_buffer, buffer_length);\n+\t  p = &directive_buffer[bytes_used];\n+\t  buffer_limit = &directive_buffer[buffer_length];\n+        }\n+\n+      c = getc (finput);\n+\n+      /* Discard initial whitespace.  */\n+      if ((c == ' ' || c == '\\t') && p == directive_buffer)\n+\tcontinue;\n+\n+      /* Detect the end of the directive.  */\n+      if (c == '\\n' && looking_for == 0)\n+\t{\n+          ungetc (c, finput);\n+\t  c = '\\0';\n+\t}\n+\n+      *p++ = c;\n+\n+      if (c == 0)\n+\treturn directive_buffer;\n+\n+      /* Handle string and character constant syntax.  */\n+      if (looking_for)\n+\t{\n+\t  if (looking_for == c && !char_escaped)\n+\t    looking_for = 0;\t/* Found terminator... stop looking.  */\n+\t}\n+      else\n+        if (c == '\\'' || c == '\"')\n+\t  looking_for = c;\t/* Don't stop buffering until we see another\n+\t\t\t\t   another one of these (or an EOF).  */\n+\n+      /* Handle backslash.  */\n+      char_escaped = (c == '\\\\' && ! char_escaped);\n+    }\n+}"}]}