{"sha": "5ece974606452372382c845ae9ca7409a0872efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjZTk3NDYwNjQ1MjM3MjM4MmM4NDVhZTljYTc0MDlhMDg3MmVmZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-03-05T22:31:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-05T22:31:51Z"}, "message": "haifa-sched.c (build_jmp_edges): Delete dead function.\n\n        * haifa-sched.c (build_jmp_edges): Delete dead function.\n        (build_control_flow): Use cfg routines from flow.c\n        (schedule_insns): Remove debugging code accidentally checked\n        in earlier today.\n        * basic-block.h: Add external integer list structures, typdefs,\n        accessor macros and function declarations.  Simlarly for\n        basic block pred/succ support and simple bitmap stuff.\n        * flow.c: Add functions for integer list, basic block pred/succ\n        support and simple bitmap support.\n        (compute_dominators): New function to compute dominators and\n        post dominators.\n        (find_basic_blocks): Split into two functions.\n        (life_analysis): Likewise.\n        (flow_analysis): Removed.  Now handled by calling find_basic_blocks,\n        the life_analysis from toplev.c\n        * toplev.c (rest_of_compilation): Call find_basic_blocks, then\n        life_analysis instead of flow_analysis.\n\nCo-Authored-By: Doug Evans <devans@cygnus.com>\n\nFrom-SVN: r18421", "tree": {"sha": "9ef4d5713c467e16c7dd8a641a16cbbcaabda731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef4d5713c467e16c7dd8a641a16cbbcaabda731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ece974606452372382c845ae9ca7409a0872efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ece974606452372382c845ae9ca7409a0872efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ece974606452372382c845ae9ca7409a0872efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ece974606452372382c845ae9ca7409a0872efd/comments", "author": null, "committer": null, "parents": [{"sha": "ac9b3c970ec8bcc697d641e44e194ca99e65bf47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9b3c970ec8bcc697d641e44e194ca99e65bf47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9b3c970ec8bcc697d641e44e194ca99e65bf47"}], "stats": {"total": 1170, "additions": 1038, "deletions": 132}, "files": [{"sha": "bb73b4120c8103da7400ae65bdf60b8c50c29de9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ece974606452372382c845ae9ca7409a0872efd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ece974606452372382c845ae9ca7409a0872efd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ece974606452372382c845ae9ca7409a0872efd", "patch": "@@ -1,3 +1,25 @@\n+Thu Mar  5 23:24:50 1998  Jeffrey A Law  (law@cygnus.com)\n+\t\t\t  Doug Evans\t (devans@cygnus.com)\n+\n+\t* haifa-sched.c (build_jmp_edges): Delete dead function.\n+\t(build_control_flow): Use cfg routines from flow.c\n+\t(schedule_insns): Remove debugging code accidentally checked\n+\tin earlier today.\n+\n+        * basic-block.h: Add external integer list structures, typdefs,\n+        accessor macros and function declarations.  Simlarly for\n+        basic block pred/succ support and simple bitmap stuff.\n+        * flow.c: Add functions for integer list, basic block pred/succ\n+        support and simple bitmap support.\n+        (compute_dominators): New function to compute dominators and\n+        post dominators.\n+\t(find_basic_blocks): Split into two functions.\n+\t(life_analysis): Likewise.\n+\t(flow_analysis): Removed.  Now handled by calling find_basic_blocks,\n+\tthe life_analysis from toplev.c\n+\t* toplev.c (rest_of_compilation): Call find_basic_blocks, then\n+\tlife_analysis instead of flow_analysis.\n+\n Thu Mar  5 23:06:26 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* jump.c (jump_optimize): Call mark_jump_label also for deleted"}, {"sha": "4f007f604b918c6292f0ce1de3e0d6a36ee42186", "filename": "gcc/basic-block.h", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=5ece974606452372382c845ae9ca7409a0872efd", "patch": "@@ -128,3 +128,124 @@ extern regset regs_live_at_setjmp;\n #define REG_BLOCK_GLOBAL -2\n \n #define REG_BASIC_BLOCK(N) (reg_n_info[(N)].basic_block)\n+\n+/* List of integers.\n+   These are used for storing things like predecessors, etc.\n+\n+   This scheme isn't very space efficient, especially on 64 bit machines.\n+   The interface is designed so that the implementation can be replaced with\n+   something more efficient if desirable.  */\n+\n+typedef struct int_list {\n+  struct int_list *next;\n+  int val;\n+} int_list;\n+\n+typedef int_list *int_list_ptr;\n+\n+/* Integer list elements are allocated in blocks to reduce the frequency\n+   of calls to malloc and to reduce the associated space overhead.  */\n+\n+typedef struct int_list_block {\n+  struct int_list_block *next;\n+  int nodes_left;\n+#define INT_LIST_NODES_IN_BLK 500\n+  struct int_list nodes[INT_LIST_NODES_IN_BLK];\n+} int_list_block;\n+\n+/* Given a pointer to the list, return pointer to first element.  */\n+#define INT_LIST_FIRST(il) (il)\n+\n+/* Given a pointer to a list element, return pointer to next element.  */\n+#define INT_LIST_NEXT(p) ((p)->next)\n+\n+/* Return non-zero if P points to the end of the list.  */\n+#define INT_LIST_END(p) ((p) == NULL)\n+\n+/* Return element pointed to by P.  */\n+#define INT_LIST_VAL(p) ((p)->val)\n+\n+#define INT_LIST_SET_VAL(p, new_val) ((p)->val = (new_val))\n+\n+extern void free_int_list               PROTO ((int_list_block **));\n+\f\n+/* Stuff for recording basic block info.  */\n+\n+#define BLOCK_HEAD(B)      basic_block_head[(B)]\n+#define BLOCK_END(B)       basic_block_end[(B)]\n+\n+/* Special block numbers [markers] for entry and exit.  */\n+#define ENTRY_BLOCK (-1)\n+#define EXIT_BLOCK (-2)\n+\n+/* from flow.c */\n+extern int *uid_block_number;\n+#define BLOCK_NUM(INSN)    uid_block_number[INSN_UID (INSN)]\n+\n+extern int compute_preds_succs PROTO ((int_list_ptr *, int_list_ptr *,\n+\t\t\t\t       int *, int *));\n+extern void dump_bb_data       PROTO ((FILE *, int_list_ptr *, int_list_ptr *));\n+extern void free_bb_mem        PROTO ((void));\n+\f\n+/* Simple bitmaps.\n+   It's not clear yet whether using bitmap.[ch] will be a win.\n+   It should be straightforward to convert so for now we keep things simple\n+   while more important issues are dealt with.  */\n+\n+#define SBITMAP_ELT_BITS HOST_BITS_PER_WIDE_INT\n+#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n+\n+typedef struct simple_bitmap_def {\n+  /* Number of bits.  */\n+  int n_bits;\n+  /* Size in elements.  */\n+  int size;\n+  /* Size in bytes.  */\n+  int bytes;\n+  /* The elements.  */\n+  SBITMAP_ELT_TYPE elms[1];\n+} *sbitmap;\n+\n+typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n+\n+/* Return the set size needed for N elements.  */\n+#define SBITMAP_SET_SIZE(n) (((n) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n+\n+/* set bit number bitno in the bitmap */\n+#define SET_BIT(bitmap, bitno) \\\n+do { \\\n+  (bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS; \\\n+} while (0)\n+\n+/* test if bit number bitno in the bitmap is set */\n+#define TEST_BIT(bitmap, bitno) \\\n+((bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] & ((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS))\n+\n+/* reset bit number bitno in the bitmap  */\n+#define RESET_BIT(bitmap, bitno) \\\n+do { \\\n+  (bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS); \\\n+} while (0)\n+\n+extern sbitmap sbitmap_alloc PROTO ((int));\n+extern sbitmap *sbitmap_vector_alloc PROTO ((int, int));\n+extern void sbitmap_copy PROTO ((sbitmap, sbitmap));\n+extern void sbitmap_zero PROTO ((sbitmap));\n+extern void sbitmap_ones PROTO ((sbitmap));\n+extern void sbitmap_vector_zero PROTO ((sbitmap *, int));\n+extern void sbitmap_vector_ones PROTO ((sbitmap *, int));\n+extern int sbitmap_union_of_diff PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_difference PROTO ((sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_not PROTO ((sbitmap, sbitmap));\n+extern int sbitmap_a_or_b_and_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b_or_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b PROTO ((sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_or_b PROTO ((sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_intersect_of_predsucc PROTO ((sbitmap, sbitmap *,\n+\t\t\t\t\t\t  int, int_list_ptr *));\n+extern void sbitmap_intersect_of_predecessors PROTO ((sbitmap, sbitmap *, int,\n+\t\t\t\t\t\t      int_list_ptr *));\n+extern void sbitmap_intersect_of_successors PROTO ((sbitmap, sbitmap *, int,\n+\t\t\t\t\t\t    int_list_ptr *));\n+extern void sbitmap_union_of_predecessors PROTO ((sbitmap, sbitmap *, int,\n+\t\t\t\t\t\t  int_list_ptr *));"}, {"sha": "89696b04a3b34308d6cd5a65e1a83917d1efaecf", "filename": "gcc/flow.c", "status": "modified", "additions": 849, "deletions": 43, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5ece974606452372382c845ae9ca7409a0872efd", "patch": "@@ -147,7 +147,7 @@ static int max_uid_for_flow;\n    This is set up by find_basic_blocks and used there and in life_analysis,\n    and then freed.  */\n \n-static int *uid_block_number;\n+int *uid_block_number;\n \n /* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */\n \n@@ -248,9 +248,9 @@ static rtx last_mem_set;\n static HARD_REG_SET elim_reg_set;\n \n /* Forward declarations */\n-static void find_basic_blocks\t\tPROTO((rtx, rtx));\n+static void find_basic_blocks_1\t\tPROTO((rtx, rtx, int));\n static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n-static void life_analysis\t\tPROTO((rtx, int));\n+static void life_analysis_1\t\tPROTO((rtx, int));\n void allocate_for_life_analysis\t\tPROTO((void));\n void init_regset_vector\t\t\tPROTO((regset *, int, struct obstack *));\n void free_regset_vector\t\t\tPROTO((regset *, int));\n@@ -270,38 +270,31 @@ static int try_pre_increment\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n #endif\n static void mark_used_regs\t\tPROTO((regset, regset, rtx, int, rtx));\n void dump_flow_info\t\t\tPROTO((FILE *));\n+static void add_pred_succ\t\tPROTO ((int, int, int_list_ptr *,\n+\t\t\t\t\t\tint_list_ptr *, int *, int *));\n+static int_list_ptr alloc_int_list_node PROTO ((int_list_block **));\n+static int_list_ptr add_int_list_node   PROTO ((int_list_block **,\n+\t\t\t\t\t\tint_list **, int));\n \f\n-/* Find basic blocks of the current function and perform data flow analysis.\n+/* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register numbers\n-   in use.  */\n+   in use.\n+   LIVE_REACHABLE_P is non-zero if the caller needs all live blocks to\n+   be reachable.  This turns on a kludge that causes the control flow\n+   information to be inaccurate and not suitable for passes like GCSE.  */\n \n void\n-flow_analysis (f, nregs, file)\n+find_basic_blocks (f, nregs, file, live_reachable_p)\n      rtx f;\n      int nregs;\n      FILE *file;\n+     int live_reachable_p;\n {\n   register rtx insn;\n   register int i;\n   rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n   int in_libcall_block = 0;\n \n-#ifdef ELIMINABLE_REGS\n-  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n-#endif\n-\n-  /* Record which registers will be eliminated.  We use this in\n-     mark_used_regs.  */\n-\n-  CLEAR_HARD_REG_SET (elim_reg_set);\n-\n-#ifdef ELIMINABLE_REGS\n-  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n-    SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n-#else\n-  SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n-#endif\n-\n   /* Count the basic blocks.  Also find maximum insn uid value used.  */\n \n   {\n@@ -347,45 +340,45 @@ flow_analysis (f, nregs, file)\n       }\n   }\n \n+  n_basic_blocks = i;\n+\n #ifdef AUTO_INC_DEC\n-  /* Leave space for insns we make in some cases for auto-inc.  These cases\n-     are rare, so we don't need too much space.  */\n+  /* Leave space for insns life_analysis makes in some cases for auto-inc.\n+     These cases are rare, so we don't need too much space.  */\n   max_uid_for_flow += max_uid_for_flow / 10;\n #endif\n \n   /* Allocate some tables that last till end of compiling this function\n      and some needed only in find_basic_blocks and life_analysis.  */\n \n-  n_basic_blocks = i;\n-  basic_block_head = (rtx *) oballoc (n_basic_blocks * sizeof (rtx));\n-  basic_block_end = (rtx *) oballoc (n_basic_blocks * sizeof (rtx));\n-  basic_block_drops_in = (char *) alloca (n_basic_blocks);\n-  basic_block_loop_depth = (short *) alloca (n_basic_blocks * sizeof (short));\n+  basic_block_head = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n+  basic_block_end = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n+  basic_block_drops_in = (char *) xmalloc (n_basic_blocks);\n+  basic_block_loop_depth = (short *) xmalloc (n_basic_blocks * sizeof (short));\n   uid_block_number\n-    = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n-  uid_volatile = (char *) alloca (max_uid_for_flow + 1);\n+    = (int *) xmalloc ((max_uid_for_flow + 1) * sizeof (int));\n+  uid_volatile = (char *) xmalloc (max_uid_for_flow + 1);\n   bzero (uid_volatile, max_uid_for_flow + 1);\n \n-  find_basic_blocks (f, nonlocal_label_list);\n-  life_analysis (f, nregs);\n-  if (file)\n-    dump_flow_info (file);\n-\n-  basic_block_drops_in = 0;\n-  uid_block_number = 0;\n-  basic_block_loop_depth = 0;\n+  find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p);\n }\n-\f\n+\n /* Find all basic blocks of the function whose first insn is F.\n    Store the correct data in the tables that describe the basic blocks,\n    set up the chains of references for each CODE_LABEL, and\n    delete any entire basic blocks that cannot be reached.\n \n-   NONLOCAL_LABEL_LIST is the same local variable from flow_analysis.  */\n+   NONLOCAL_LABEL_LIST is a list of non-local labels in the function.\n+   Blocks that are otherwise unreachable may be reachable with a non-local\n+   goto.\n+   LIVE_REACHABLE_P is non-zero if the caller needs all live blocks to\n+   be reachable.  This turns on a kludge that causes the control flow\n+   information to be inaccurate and not suitable for passes like GCSE.  */\n \n static void\n-find_basic_blocks (f, nonlocal_label_list)\n+find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n      rtx f, nonlocal_label_list;\n+     int live_reachable_p;\n {\n   register rtx insn;\n   register int i;\n@@ -683,6 +676,10 @@ find_basic_blocks (f, nonlocal_label_list)\n \t    && LABEL_REFS (basic_block_head[i]) == basic_block_head[i])\n \t  abort ();\n \n+      /* Now delete the code for any basic blocks that can't be reached.\n+\t They can occur because jump_optimize does not recognize\n+\n+\n       /* Now delete the code for any basic blocks that can't be reached.\n \t They can occur because jump_optimize does not recognize\n \t unreachable loops as unreachable.  */\n@@ -854,6 +851,24 @@ find_basic_blocks (f, nonlocal_label_list)\n \t}\n     }\n }\n+\n+/* Record INSN's block number as BB.  */\n+\n+void\n+set_block_num (insn, bb)\n+     rtx insn;\n+     int bb;\n+{\n+  if (INSN_UID (insn) >= max_uid_for_flow)\n+    {\n+      /* Add one-eighth the size so we don't keep calling xrealloc.  */\n+      max_uid_for_flow = INSN_UID (insn) + (INSN_UID (insn) + 7) / 8;\n+      uid_block_number = (int *)\n+\txrealloc (uid_block_number, (max_uid_for_flow + 1) * sizeof (int));\n+    }\n+  BLOCK_NUM (insn) = bb;\n+}\n+\n \f\n /* Subroutines of find_basic_blocks.  */\n \n@@ -932,6 +947,82 @@ flow_delete_insn (insn)\n   return NEXT_INSN (insn);\n }\n \f\n+/* Perform data flow analysis.\n+   F is the first insn of the function and NREGS the number of register numbers\n+   in use.  */\n+\n+void\n+life_analysis (f, nregs, file)\n+     rtx f;\n+     int nregs;\n+     FILE *file;\n+{\n+  register rtx insn;\n+  register int i;\n+\n+#ifdef ELIMINABLE_REGS\n+  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+\n+  /* Record which registers will be eliminated.  We use this in\n+     mark_used_regs.  */\n+\n+  CLEAR_HARD_REG_SET (elim_reg_set);\n+\n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+    SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n+#else\n+  SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n+#endif\n+\n+  life_analysis_1 (f, nregs);\n+  if (file)\n+    dump_flow_info (file);\n+\n+  free_basic_block_vars (1);\n+}\n+\n+/* Free the variables allocated by find_basic_blocks.\n+\n+   KEEP_HEAD_END_P is non-zero if basic_block_head and basic_block_end\n+   are not to be freed.  */\n+\n+void\n+free_basic_block_vars (keep_head_end_p)\n+     int keep_head_end_p;\n+{\n+  if (basic_block_drops_in)\n+    {\n+      free (basic_block_drops_in);\n+      /* Tell dump_flow_info this isn't available anymore.  */\n+      basic_block_drops_in = 0;\n+    }\n+  if (basic_block_loop_depth)\n+    {\n+      free (basic_block_loop_depth);\n+      basic_block_loop_depth = 0;\n+    }\n+  if (uid_block_number)\n+    {\n+      free (uid_block_number);\n+      uid_block_number = 0;\n+    }\n+  if (uid_volatile)\n+    {\n+      free (uid_volatile);\n+      uid_volatile = 0;\n+    }\n+\n+  if (! keep_head_end_p && basic_block_head)\n+    {\n+      free (basic_block_head);\n+      basic_block_head = 0;\n+      free (basic_block_end);\n+      basic_block_end = 0;\n+    }\n+}\n+\n /* Determine which registers are live at the start of each\n    basic block of the function whose first insn is F.\n    NREGS is the number of registers used in F.\n@@ -940,7 +1031,7 @@ flow_delete_insn (insn)\n    regset_size and regset_bytes are also set here.  */\n \n static void\n-life_analysis (f, nregs)\n+life_analysis_1 (f, nregs)\n      rtx f;\n      int nregs;\n {\n@@ -3056,3 +3147,718 @@ print_rtl_with_bb (outf, rtx_first)\n \t}\n     }\n }\n+\n+\f\n+/* Integer list support.  */\n+\n+/* Allocate a node from list *HEAD_PTR.  */\n+\n+static int_list_ptr\n+alloc_int_list_node (head_ptr)\n+     int_list_block **head_ptr;\n+{\n+  struct int_list_block *first_blk = *head_ptr;\n+\n+  if (first_blk == NULL || first_blk->nodes_left <= 0)\n+    {\n+      first_blk = (struct int_list_block *) xmalloc (sizeof (struct int_list_block));\n+      first_blk->nodes_left = INT_LIST_NODES_IN_BLK;\n+      first_blk->next = *head_ptr;\n+      *head_ptr = first_blk;\n+    }\n+\n+  first_blk->nodes_left--;\n+  return &first_blk->nodes[first_blk->nodes_left];\n+}\n+\n+/* Pointer to head of predecessor/successor block list.  */\n+static int_list_block *pred_int_list_blocks;\n+\n+/* Add a new node to integer list LIST with value VAL.\n+   LIST is a pointer to a list object to allow for different implementations.\n+   If *LIST is initially NULL, the list is empty.\n+   The caller must not care whether the element is added to the front or\n+   to the end of the list (to allow for different implementations).  */\n+\n+static int_list_ptr\n+add_int_list_node (blk_list, list, val)\n+     int_list_block **blk_list;\n+     int_list **list;\n+     int val;\n+{\n+  int_list_ptr p = alloc_int_list_node (blk_list);\n+\n+  p->val = val;\n+  p->next = *list;\n+  *list = p;\n+  return p;\n+}\n+\n+/* Free the blocks of lists at BLK_LIST.  */\n+\n+void\n+free_int_list (blk_list)\n+     int_list_block **blk_list;\n+{\n+  int_list_block *p, *next;\n+\n+  for (p = *blk_list; p != NULL; p = next)\n+    {\n+      next = p->next;\n+      free (p);\n+    }\n+\n+  /* Mark list as empty for the next function we compile.  */\n+  *blk_list = NULL;\n+}\n+\f\n+/* Predecessor/successor computation.  */\n+\n+/* Mark PRED_BB a precessor of SUCC_BB,\n+   and conversely SUCC_BB a successor of PRED_BB.  */\n+\n+static void\n+add_pred_succ (pred_bb, succ_bb, s_preds, s_succs, num_preds, num_succs)\n+     int pred_bb;\n+     int succ_bb;\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     int *num_preds;\n+     int *num_succs;\n+{\n+  if (succ_bb != EXIT_BLOCK)\n+    {\n+      add_int_list_node (&pred_int_list_blocks, &s_preds[succ_bb], pred_bb);\n+      num_preds[succ_bb]++;\n+    }\n+  if (pred_bb != ENTRY_BLOCK)\n+    {\n+      add_int_list_node (&pred_int_list_blocks, &s_succs[pred_bb], succ_bb);\n+      num_succs[pred_bb]++;\n+    }\n+}\n+\n+/* Compute the predecessors and successors for each block.  */\n+int\n+compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     int *num_preds;\n+     int *num_succs;\n+{\n+  int bb, clear_local_bb_vars = 0;\n+\n+  bzero ((char *) s_preds, n_basic_blocks * sizeof (int_list_ptr));\n+  bzero ((char *) s_succs, n_basic_blocks * sizeof (int_list_ptr));\n+  bzero ((char *) num_preds, n_basic_blocks * sizeof (int));\n+  bzero ((char *) num_succs, n_basic_blocks * sizeof (int));\n+\n+  /* This routine can be called after life analysis; in that case\n+     basic_block_drops_in and uid_block_number will not be available\n+     and we must recompute their values.  */\n+  if (basic_block_drops_in == NULL || uid_block_number == NULL)\n+    {\n+      clear_local_bb_vars = 1;\n+      basic_block_drops_in = (char *) alloca (n_basic_blocks);\n+      uid_block_number = (int *) alloca ((get_max_uid () + 1) * sizeof (int));\n+\n+      bzero ((char *) basic_block_drops_in, n_basic_blocks * sizeof (char));\n+      bzero ((char *) uid_block_number, n_basic_blocks * sizeof (int));\n+\n+      /* Scan each basic block setting basic_block_drops_in and\n+\t uid_block_number as needed.  */\n+      for (bb = 0; bb < n_basic_blocks; bb++)\n+\t{\n+\t  rtx insn;\n+\n+\t  for (insn = PREV_INSN (basic_block_head[bb]);\n+\t       insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n+\t    ;\n+\n+\t  basic_block_drops_in[bb] = insn && GET_CODE (insn) != BARRIER;\n+\n+\t  insn = basic_block_head[bb];\n+\t  while (insn)\n+\t    {\n+\t      BLOCK_NUM (insn) = bb;\n+\t      if (insn == basic_block_end[bb])\n+\t\tbreak;\n+\t      insn = NEXT_INSN (insn);\n+\t    }\n+\t}\n+      \n+      \n+    }\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      rtx head;\n+      rtx jump;\n+\n+      head = BLOCK_HEAD (bb);\n+\n+      if (GET_CODE (head) == CODE_LABEL)\n+\tfor (jump = LABEL_REFS (head);\n+\t     jump != head;\n+\t     jump = LABEL_NEXTREF (jump))\n+\t  add_pred_succ (BLOCK_NUM (CONTAINING_INSN (jump)), bb,\n+\t\t\t s_preds, s_succs, num_preds, num_succs);\n+\n+      jump = BLOCK_END (bb);\n+      /* If this is a RETURN insn or a conditional jump in the last\n+\t basic block, or a non-jump insn in the last basic block, then\n+\t this block reaches the exit block.  */\n+      if ((GET_CODE (jump) == JUMP_INSN && GET_CODE (PATTERN (jump)) == RETURN)\n+\t  || (((GET_CODE (jump) == JUMP_INSN\n+\t        && condjump_p (jump) && !simplejump_p (jump))\n+\t       || GET_CODE (jump) != JUMP_INSN)\n+ \t      && (bb == n_basic_blocks - 1)))\n+\tadd_pred_succ (bb, EXIT_BLOCK, s_preds, s_succs, num_preds, num_succs);\n+\n+      if (basic_block_drops_in[bb])\n+\tadd_pred_succ (bb - 1, bb, s_preds, s_succs, num_preds, num_succs);\n+    }\n+\n+  add_pred_succ (ENTRY_BLOCK, 0, s_preds, s_succs, num_preds, num_succs);\n+\n+\n+  /* If we allocated any variables in temporary storage, clear out the\n+     pointer to the local storage to avoid dangling pointers.  */\n+  if (clear_local_bb_vars)\n+    {\n+      basic_block_drops_in = NULL;\n+      uid_block_number = NULL;\n+    \n+    }\n+}\n+\n+void\n+dump_bb_data (file, preds, succs)\n+     FILE *file;\n+     int_list_ptr *preds;\n+     int_list_ptr *succs;\n+{\n+  int bb;\n+  int_list_ptr p;\n+\n+  fprintf (file, \"BB data\\n\\n\");\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      fprintf (file, \"BB %d, start %d, end %d\\n\", bb,\n+\t       INSN_UID (BLOCK_HEAD (bb)), INSN_UID (BLOCK_END (bb)));\n+      fprintf (file, \"  preds:\");\n+      for (p = preds[bb]; p != NULL; p = p->next)\n+\t{\n+\t  int pred_bb = INT_LIST_VAL (p);\n+\t  if (pred_bb == ENTRY_BLOCK)\n+\t    fprintf (file, \" entry\");\n+\t  else\n+\t    fprintf (file, \" %d\", pred_bb);\n+\t}\n+      fprintf (file, \"\\n\");\n+      fprintf (file, \"  succs:\");\n+      for (p = succs[bb]; p != NULL; p = p->next)\n+\t{\n+\t  int succ_bb = INT_LIST_VAL (p);\n+\t  if (succ_bb == EXIT_BLOCK)\n+\t    fprintf (file, \" exit\");\n+\t  else\n+\t    fprintf (file, \" %d\", succ_bb);\n+\t}\n+      fprintf (file, \"\\n\");\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Free basic block data storage.  */\n+\n+void\n+free_bb_mem ()\n+{\n+  free_int_list (&pred_int_list_blocks);\n+}\n+\f\n+/* Bitmap manipulation routines.  */\n+\n+/* Allocate a simple bitmap of N_ELMS bits.  */\n+\n+sbitmap\n+sbitmap_alloc (n_elms)\n+     int n_elms;\n+{\n+  int bytes, size, amt;\n+  sbitmap bmap;\n+\n+  size = SBITMAP_SET_SIZE (n_elms);\n+  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n+  amt = (sizeof (struct simple_bitmap_def)\n+\t + bytes - sizeof (SBITMAP_ELT_TYPE));\n+  bmap = (sbitmap) xmalloc (amt);\n+  bmap->n_bits = n_elms;\n+  bmap->size = size;\n+  bmap->bytes = bytes;\n+  return bmap;\n+}\n+\n+/* Allocate a vector of N_VECS bitmaps of N_ELMS bits.  */\n+\n+sbitmap *\n+sbitmap_vector_alloc (n_vecs, n_elms)\n+     int n_vecs, n_elms;\n+{\n+  int i, bytes, offset, elm_bytes, size, amt;\n+  sbitmap *bitmap_vector;\n+\n+  size = SBITMAP_SET_SIZE (n_elms);\n+  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n+  elm_bytes = (sizeof (struct simple_bitmap_def)\n+\t       + bytes - sizeof (SBITMAP_ELT_TYPE));\n+  amt = (n_vecs * sizeof (sbitmap *)) + (n_vecs * elm_bytes);\n+  bitmap_vector = (sbitmap *) xmalloc (amt);\n+\n+  /* ??? There may be alignment problems, `offset' should be rounded up\n+     each time to account for alignment.  Later [if ever].  */\n+\n+  for (i = 0, offset = n_vecs * sizeof (sbitmap *);\n+       i < n_vecs;\n+       i++, offset += elm_bytes)\n+    {\n+      sbitmap b = (sbitmap) ((char *) bitmap_vector + offset);\n+      bitmap_vector[i] = b;\n+      b->n_bits = n_elms;\n+      b->size = size;\n+      b->bytes = bytes;\n+    }\n+\n+  return bitmap_vector;\n+}\n+\n+/* Copy sbitmap SRC to DST.  */\n+\n+void\n+sbitmap_copy (dst, src)\n+     sbitmap dst, src;\n+{\n+  int i;\n+  sbitmap_ptr d,s;\n+\n+  s = src->elms;\n+  d = dst->elms;\n+  for (i = 0; i < dst->size; i++)\n+    *d++ = *s++;\n+}\n+\n+/* Zero all elements in a bitmap.  */\n+\n+void\n+sbitmap_zero (bmap)\n+     sbitmap bmap;\n+{\n+  bzero ((char *) bmap->elms, bmap->bytes);\n+}\n+\n+/* Set to ones all elements in a bitmap.  */\n+\n+void\n+sbitmap_ones (bmap)\n+     sbitmap bmap;\n+{\n+  memset (bmap->elms, -1, bmap->bytes);\n+}\n+\n+/* Zero a vector of N_VECS bitmaps.  */\n+\n+void\n+sbitmap_vector_zero (bmap, n_vecs)\n+     sbitmap *bmap;\n+     int n_vecs;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_vecs; i++)\n+    sbitmap_zero (bmap[i]);\n+}\n+\n+/* Set to ones a vector of N_VECS bitmaps.  */\n+\n+void\n+sbitmap_vector_ones (bmap, n_vecs)\n+     sbitmap *bmap;\n+     int n_vecs;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_vecs; i++)\n+    sbitmap_ones (bmap[i]);\n+}\n+\n+/* Set DST to be A union (B - C).\n+   DST = A | (B & ~C).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_union_of_diff (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | (*bp & ~*cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set bitmap DST to the bitwise negation of the bitmap SRC.  */\n+\n+void\n+sbitmap_not (dst, src)\n+     sbitmap dst, src;\n+{\n+  int i;\n+  sbitmap_ptr dstp, ap;\n+\n+  dstp = dst->elms;\n+  ap = src->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = ~(*ap);\n+      *dstp = tmp;\n+      dstp++; ap++;\n+    }\n+}\n+\n+/* Set the bits in DST to be the difference between the bits\n+   in A and the bits in B. i.e. dst = a - b.\n+   The - operator is implemented as a & (~b).  */\n+\n+void\n+sbitmap_difference (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    *dstp++ = *ap++ & (~*bp++);\n+}\n+\n+/* Set DST to be (A and B)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_and_b (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap & *bp;\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++;\n+    }\n+  return changed;\n+}\n+/* Set DST to be (A or B)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_or_b (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | *bp;\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set DST to be (A or (B and C)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_or_b_and_c (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | (*bp & *cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set DST to be (A ann (B or C)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_and_b_or_c (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap & (*bp | *cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set the bitmap DST to the intersection of SRC of all predecessors or\n+   successors of block number BB (PRED_SUCC says which).  */\n+\n+void\n+sbitmap_intersect_of_predsucc (dst, src, bb, pred_succ)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *pred_succ;\n+{\n+  int_list_ptr ps;\n+  int ps_bb;\n+  int set_size = dst->size;\n+\n+  ps = pred_succ[bb];\n+\n+  /* It is possible that there are no predecessors(/successors).\n+     This can happen for example in unreachable code.  */\n+\n+  if (ps == NULL)\n+    {\n+      /* In APL-speak this is the `and' reduction of the empty set and thus\n+\t the result is the identity for `and'.  */\n+      sbitmap_ones (dst);\n+      return;\n+    }\n+\n+  /* Set result to first predecessor/successor.  */\n+\n+  for ( ; ps != NULL; ps = ps->next)\n+    {\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+      sbitmap_copy (dst, src[ps_bb]);\n+      /* Break out since we're only doing first predecessor.  */\n+      break;\n+    }\n+  if (ps == NULL)\n+    return;\n+\n+  /* Now do the remaining predecessors/successors.  */\n+\n+  for (ps = ps->next; ps != NULL; ps = ps->next)\n+    {\n+      int i;\n+      sbitmap_ptr p,r;\n+\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+\n+      p = src[ps_bb]->elms;\n+      r = dst->elms;\n+\n+      for (i = 0; i < set_size; i++)\n+\t*r++ &= *p++;\n+    }\n+}\n+\n+/* Set the bitmap DST to the intersection of SRC of all predecessors\n+   of block number BB.  */\n+\n+void\n+sbitmap_intersect_of_predecessors (dst, src, bb, s_preds)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *s_preds;\n+{\n+  sbitmap_intersect_of_predsucc (dst, src, bb, s_preds);\n+}\n+\n+/* Set the bitmap DST to the intersection of SRC of all successors\n+   of block number BB.  */\n+\n+void\n+sbitmap_intersect_of_successors (dst, src, bb, s_succs)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *s_succs;\n+{\n+  sbitmap_intersect_of_predsucc (dst, src, bb, s_succs);\n+}\n+\n+/* Set the bitmap DST to the union of SRC of all predecessors/successors of\n+   block number BB.  */\n+\n+void\n+sbitmap_union_of_predsucc (dst, src, bb, pred_succ)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *pred_succ;\n+{\n+  int_list_ptr ps;\n+  int ps_bb;\n+  int set_size = dst->size;\n+\n+  ps = pred_succ[bb];\n+\n+  /* It is possible that there are no predecessors(/successors).\n+     This can happen for example in unreachable code.  */\n+\n+  if (ps == NULL)\n+    {\n+      /* In APL-speak this is the `or' reduction of the empty set and thus\n+\t the result is the identity for `or'.  */\n+      sbitmap_zero (dst);\n+      return;\n+    }\n+\n+  /* Set result to first predecessor/successor.  */\n+\n+  for ( ; ps != NULL; ps = ps->next)\n+    {\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+      sbitmap_copy (dst, src[ps_bb]);\n+      /* Break out since we're only doing first predecessor.  */\n+      break;\n+    }\n+  if (ps == NULL)\n+    return;\n+\n+  /* Now do the remaining predecessors/successors.  */\n+\n+  for (ps = ps->next; ps != NULL; ps = ps->next)\n+    {\n+      int i;\n+      sbitmap_ptr p,r;\n+\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+\n+      p = src[ps_bb]->elms;\n+      r = dst->elms;\n+\n+      for (i = 0; i < set_size; i++)\n+\t*r++ |= *p++;\n+    }\n+}\n+\n+/* Set the bitmap DST to the union of SRC of all predecessors of\n+   block number BB.  */\n+\n+void\n+sbitmap_union_of_predecessors (dst, src, bb, s_preds)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *s_preds;\n+{\n+  sbitmap_union_of_predsucc (dst, src, bb, s_preds);\n+}\n+\n+/* Compute dominator relationships.  */\n+void\n+compute_dominators (dominators, post_dominators, s_preds, s_succs)\n+     sbitmap *dominators;\n+     sbitmap *post_dominators;\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+{\n+  int bb, changed, passes;\n+  sbitmap *temp_bitmap;\n+\n+  temp_bitmap = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  sbitmap_vector_ones (dominators, n_basic_blocks);\n+  sbitmap_vector_ones (post_dominators, n_basic_blocks);\n+  sbitmap_vector_zero (temp_bitmap, n_basic_blocks);\n+\n+  sbitmap_zero (dominators[0]);\n+  SET_BIT (dominators[0], 0);\n+\n+  sbitmap_zero (post_dominators[n_basic_blocks-1]);\n+  SET_BIT (post_dominators[n_basic_blocks-1], 0);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = 1; bb < n_basic_blocks; bb++)\n+\t{\n+\t  sbitmap_intersect_of_predecessors (temp_bitmap[bb], dominators,\n+\t\t\t\t\t     bb, s_preds);\n+\t  SET_BIT (temp_bitmap[bb], bb);\n+\t  changed |= sbitmap_a_and_b (dominators[bb],\n+\t\t\t\t      dominators[bb],\n+\t\t\t\t      temp_bitmap[bb]);\n+\t  sbitmap_intersect_of_successors (temp_bitmap[bb], post_dominators,\n+\t\t\t\t\t   bb, s_succs);\n+\t  SET_BIT (temp_bitmap[bb], bb);\n+\t  changed |= sbitmap_a_and_b (post_dominators[bb],\n+\t\t\t\t      post_dominators[bb],\n+\t\t\t\t      temp_bitmap[bb]);\n+\t}\n+      passes++;\n+    }\n+\n+  free (temp_bitmap);\n+}"}, {"sha": "b9b6202e3ec9995456bf8882227f7725e9e9545b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 39, "deletions": 87, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5ece974606452372382c845ae9ca7409a0872efd", "patch": "@@ -521,7 +521,6 @@ static char is_cfg_nonregular PROTO ((void));\n static int uses_reg_or_mem PROTO ((rtx));\n void debug_control_flow PROTO ((void));\n static void build_control_flow PROTO ((void));\n-static void build_jmp_edges PROTO ((rtx, int));\n static void new_edge PROTO ((int, int));\n \n \n@@ -1310,105 +1309,60 @@ debug_control_flow ()\n }\n \n \n-/* build the control flow graph. (also set nr_edges accurately) */\n+/* Build the control flow graph and set nr_edges.\n+\n+   Instead of trying to build a cfg ourselves, we rely on flow to\n+   do it for us.  Stamp out useless code (and bug) duplication.  */\n \n static void\n build_control_flow ()\n {\n-  int i;\n+  int i, j;\n+  int_list_ptr *s_preds;\n+  int_list_ptr *s_succs;\n+  int_list_ptr succ;\n+  int *num_preds;\n+  int *num_succs;\n+\n+  /* The scheduler runs after flow; therefore, we can't blindly call\n+     back into find_basic_blocks since doing so could invalidate the\n+     info in basic_block_live_at_start.\n+\n+     Consider a block consisting entirely of dead stores; after life\n+     analysis it would be a block of NOTE_INSN_DELETED notes.  If\n+     we call find_basic_blocks again, then the block would be removed\n+     entirely and invalidate our the register live information.\n+\n+     We could (should?) recompute register live information.  Doing\n+     so may even be beneficial.  */\n+  s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n+  s_succs = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n+  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n+  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n \n   nr_edges = 0;\n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      rtx insn;\n-\n-      insn = basic_block_end[i];\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  build_jmp_edges (PATTERN (insn), i);\n-\t}\n-\n-      for (insn = PREV_INSN (basic_block_head[i]);\n-\t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n-\t;\n-\n-      /* build fallthrough edges */\n-      if (!insn && i != 0)\n-\tnew_edge (i - 1, i);\n-      else if (insn && GET_CODE (insn) != BARRIER)\n-\tnew_edge (i - 1, i);\n-    }\n+    for (succ = s_succs[i]; succ; succ = succ->next)\n+      {\n+\tif (INT_LIST_VAL (succ) != EXIT_BLOCK)\n+\t  new_edge (i, INT_LIST_VAL (succ));\n+      }\n \n   /* increment by 1, since edge 0 is unused.  */\n   nr_edges++;\n \n+  /* For now.  This will move as more and more of haifa is converted\n+     to using the cfg code in flow.c  */\n+  free_bb_mem ();\n }\n \n \n-/* construct edges in the control flow graph, from 'source' block, to\n-   blocks refered to by 'pattern'.  */\n-\n-static\n-void \n-build_jmp_edges (pattern, source)\n-     rtx pattern;\n-     int source;\n-{\n-  register RTX_CODE code;\n-  register int i;\n-  register char *fmt;\n-\n-  code = GET_CODE (pattern);\n-\n-  if (code == LABEL_REF)\n-    {\n-      register rtx label = XEXP (pattern, 0);\n-      register int target;\n-\n-      /* This can happen as a result of a syntax error\n-         and a diagnostic has already been printed.  */\n-      if (INSN_UID (label) == 0)\n-\treturn;\n-\n-      target = INSN_BLOCK (label);\n-      new_edge (source, target);\n-\n-      return;\n-    }\n-\n-  /* proper handling of ADDR_DIFF_VEC: do not add a non-existing edge\n-     from the block containing the branch-on-table, to itself.  */\n-  if (code == ADDR_VEC\n-      || code == ADDR_DIFF_VEC)\n-    {\n-      int diff_vec_p = GET_CODE (pattern) == ADDR_DIFF_VEC;\n-      int len = XVECLEN (pattern, diff_vec_p);\n-      int k;\n-\n-      for (k = 0; k < len; k++)\n-\t{\n-\t  rtx tem = XVECEXP (pattern, diff_vec_p, k);\n-\n-\t  build_jmp_edges (tem, source);\n-\t}\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tbuild_jmp_edges (XEXP (pattern, i), source);\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = 0; j < XVECLEN (pattern, i); j++)\n-\t    build_jmp_edges (XVECEXP (pattern, i, j), source);\n-\t}\n-    }\n-}\n-\n+/* Record an edge in the control flow graph from SOURCE to TARGET.\n \n-/* construct an edge in the control flow graph, from 'source' to 'target'.  */\n+   In theory, this is redundant with the s_succs computed above, but\n+   we have not converted all of haifa to use information from the\n+   integer lists.  */\n \n static void\n new_edge (source, target)\n@@ -8718,8 +8672,6 @@ schedule_insns (dump_file)\n     emit_note_after (NOTE_INSN_DELETED, basic_block_end[n_basic_blocks - 1]);\n \n   /* Schedule every region in the subroutine */\n-  fprintf(stderr, \"HELLO: nr_regions=%d max_reg_num=%d\\n\",\n-        (int)nr_regions, (int)max_reg_num());   \n   for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n       schedule_region (rgn);"}, {"sha": "1922384881eb40c5d84fee0e1789fbf69ce62c26", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ece974606452372382c845ae9ca7409a0872efd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5ece974606452372382c845ae9ca7409a0872efd", "patch": "@@ -3381,8 +3381,13 @@ rest_of_compilation (decl)\n       /* Do control and data flow analysis,\n \t and write some of the results to dump file.  */\n \n-      TIMEVAR (flow_time, flow_analysis (insns, max_reg_num (),\n-\t\t\t\t\t rtl_dump_file));\n+      TIMEVAR\n+\t(flow_time,\n+\t {\n+\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n+\t   life_analysis (insns, max_reg_num (), rtl_dump_file);\n+\t });\n+\n       if (warn_uninitialized)\n \t{\n \t  uninitialized_vars_warning (DECL_INITIAL (decl));"}]}