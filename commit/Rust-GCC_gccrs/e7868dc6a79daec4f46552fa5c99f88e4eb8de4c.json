{"sha": "e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc4NjhkYzZhNzlkYWVjNGY0NjU1MmZhNWM5OWY4OGU0ZWI4ZGU0Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-02-05T23:55:26Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-02-05T23:55:26Z"}, "message": "PR tree-optimization/92765 - wrong code for strcmp of a union member\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/92765\n\t* gimple-fold.c (get_range_strlen_tree): Handle MEM_REF and PARM_DECL.\n\t* tree-ssa-strlen.c (compute_string_length): Remove.\n\t(determine_min_objsize): Remove.\n\t(get_len_or_size): Add an argument.  Call get_range_strlen_dynamic.\n\tAvoid using type size as the upper bound on string length.\n\t(handle_builtin_string_cmp): Add an argument.  Adjust.\n\t(strlen_check_and_optimize_call): Pass additional argument to\n\thandle_builtin_string_cmp.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/92765\n\t* g++.dg/tree-ssa/strlenopt-1.C: New test.\n\t* g++.dg/tree-ssa/strlenopt-2.C: New test.\n\t* gcc.dg/Warray-bounds-58.c: New test.\n\t* gcc.dg/Wrestrict-20.c: Avoid a valid -Wformat-overflow.\n\t* gcc.dg/Wstring-compare.c: Xfail a test.\n\t* gcc.dg/strcmpopt_2.c: Disable tests.\n\t* gcc.dg/strcmpopt_4.c: Adjust tests.\n\t* gcc.dg/strcmpopt_10.c: New test.\n\t* gcc.dg/strcmpopt_11.c: New test.\n\t* gcc.dg/strlenopt-69.c: Disable tests.\n\t* gcc.dg/strlenopt-92.c: New test.\n\t* gcc.dg/strlenopt-93.c: New test.\n\t* gcc.dg/strlenopt.h: Declare calloc.\n\t* gcc.dg/tree-ssa/pr92056.c: Xfail tests until pr93518 is resolved.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-23.c: Correct test (pr93517).", "tree": {"sha": "0fad493958df5c30eebb8192fd46c5f287379396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fad493958df5c30eebb8192fd46c5f287379396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6bef09771cf93e695cf719fb43db8c43e31acf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bef09771cf93e695cf719fb43db8c43e31acf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bef09771cf93e695cf719fb43db8c43e31acf5"}], "stats": {"total": 902, "additions": 701, "deletions": 201}, "files": [{"sha": "b8fa14e00b69a0002ff92317ab5523a861c1e20e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -1,3 +1,15 @@\n+2020-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92765\n+\t* gimple-fold.c (get_range_strlen_tree): Handle MEM_REF and PARM_DECL.\n+\t* tree-ssa-strlen.c (compute_string_length): Remove.\n+\t(determine_min_objsize): Remove.\n+\t(get_len_or_size): Add an argument.  Call get_range_strlen_dynamic.\n+\tAvoid using type size as the upper bound on string length.\n+\t(handle_builtin_string_cmp): Add an argument.  Adjust.\n+\t(strlen_check_and_optimize_call): Pass additional argument to\n+\thandle_builtin_string_cmp.\n+\n 2020-02-05  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*pushdi2_rex64 peephole2): Remove."}, {"sha": "fa7a396a3612e8e66df6bd51d5edb81a2eb395ab", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"tree-vector-builder.h\"\n #include \"tree-ssa-strlen.h\"\n+#include \"varasm.h\"\n \n enum strlen_range_kind {\n   /* Compute the exact constant string length.  */\n@@ -1280,7 +1281,7 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t\t       c_strlen_data *pdata, unsigned eltsize)\n {\n   gcc_assert (TREE_CODE (arg) != SSA_NAME);\n- \n+\n   /* The length computed by this invocation of the function.  */\n   tree val = NULL_TREE;\n \n@@ -1422,7 +1423,44 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t     type about the length here.  */\n \t  tight_bound = true;\n \t}\n-      else if (VAR_P (arg))\n+      else if (TREE_CODE (arg) == MEM_REF\n+\t       && TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE\n+\t       && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == INTEGER_TYPE\n+\t       && TREE_CODE (TREE_OPERAND (arg, 0)) == ADDR_EXPR)\n+\t{\n+\t  /* Handle a MEM_REF into a DECL accessing an array of integers,\n+\t     being conservative about references to extern structures with\n+\t     flexible array members that can be initialized to arbitrary\n+\t     numbers of elements as an extension (static structs are okay).\n+\t     FIXME: Make this less conservative -- see\n+\t     component_ref_size in tree.c.  */\n+\t  tree ref = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+\t  if ((TREE_CODE (ref) == PARM_DECL || VAR_P (ref))\n+\t      && (decl_binds_to_current_def_p (ref)\n+\t\t  || !array_at_struct_end_p (arg)))\n+\t    {\n+\t      /* Fail if the offset is out of bounds.  Such accesses\n+\t\t should be diagnosed at some point.  */\n+\t      val = DECL_SIZE_UNIT (ref);\n+\t      if (!val || integer_zerop (val))\n+\t\treturn false;\n+\n+\t      poly_offset_int psiz = wi::to_offset (val);\n+\t      poly_offset_int poff = mem_ref_offset (arg);\n+\t      if (known_le (psiz, poff))\n+\t\treturn false;\n+\n+\t      pdata->minlen = ssize_int (0);\n+\n+\t      /* Subtract the offset and one for the terminating nul.  */\n+\t      psiz -= poff;\n+\t      psiz -= 1;\n+\t      val = wide_int_to_tree (TREE_TYPE (val), psiz);\n+\t      /* Since VAL reflects the size of a declared object\n+\t\t rather the type of the access it is not a tight bound.  */\n+\t    }\n+\t}\n+      else if (TREE_CODE (arg) == PARM_DECL || VAR_P (arg))\n \t{\n \t  /* Avoid handling pointers to arrays.  GCC might misuse\n \t     a pointer to an array of one bound to point to an array\n@@ -1500,7 +1538,8 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t     the referenced subobject minus 1 (for the terminating nul).  */\n \t  tree type = TREE_TYPE (base);\n \t  if (TREE_CODE (type) == POINTER_TYPE\n-\t      || !VAR_P (base) || !(val = DECL_SIZE_UNIT (base)))\n+\t      || (TREE_CODE (base) != PARM_DECL && !VAR_P (base))\n+\t      || !(val = DECL_SIZE_UNIT (base)))\n \t    val = build_all_ones_cst (size_type_node);\n \t  else\n \t    {"}, {"sha": "5802f0d7c601048f108c8f8628afd67eb4dde06f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -1,3 +1,22 @@\n+2020-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92765\n+\t* g++.dg/tree-ssa/strlenopt-1.C: New test.\n+\t* g++.dg/tree-ssa/strlenopt-2.C: New test.\n+\t* gcc.dg/Warray-bounds-58.c: New test.\n+\t* gcc.dg/Wrestrict-20.c: Avoid a valid -Wformat-overflow.\n+\t* gcc.dg/Wstring-compare.c: Xfail a test.\n+\t* gcc.dg/strcmpopt_2.c: Disable tests.\n+\t* gcc.dg/strcmpopt_4.c: Adjust tests.\n+\t* gcc.dg/strcmpopt_10.c: New test.\n+\t* gcc.dg/strcmpopt_11.c: New test.\n+\t* gcc.dg/strlenopt-69.c: Disable tests.\n+\t* gcc.dg/strlenopt-92.c: New test.\n+\t* gcc.dg/strlenopt-93.c: New test.\n+\t* gcc.dg/strlenopt.h: Declare calloc.\n+\t* gcc.dg/tree-ssa/pr92056.c: Xfail tests until pr93518 is resolved.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-23.c: Correct test (pr93517).\n+\n 2020-02-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93559 - ICE with CONSTRUCTOR flags verification."}, {"sha": "b6adfac71360e396eea07ae38dea3ca0d1956800", "filename": "gcc/testsuite/g++.dg/tree-ssa/strlenopt-1.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-1.C?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,42 @@\n+/* PR tree-optimization/92765 - wrong code for strcmp of a union member\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+inline void* operator new (size_t, void *p)\n+{\n+  return p;\n+}\n+\n+struct A { char a2[2]; };\n+struct B { char a4[4]; };\n+\n+__attribute__((noipa)) void\n+sink (void*) { }\n+\n+__attribute__((noipa)) void\n+copy (char *d, const char *s)\n+{\n+  while ((*d++ = *s++));\n+}\n+\n+__attribute__((noipa)) void\n+store_and_compare (void *p)\n+{\n+  A *a = new (p) A;\n+  sink (a->a2);\n+\n+  B *b = new (p) B;\n+  char *q = (char *) b->a4;\n+  copy (q, \"abc\");\n+\n+  if (__builtin_strcmp (q, \"abc\"))\n+    __builtin_abort ();\n+}\n+\n+int main ()\n+{\n+  char a [sizeof (A) > sizeof (B) ? sizeof (A) : sizeof (B)];\n+  store_and_compare (a);\n+}"}, {"sha": "60f8205c2ab9f38eb65753c6de6b9220b194ebd9", "filename": "gcc/testsuite/g++.dg/tree-ssa/strlenopt-2.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fstrlenopt-2.C?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,56 @@\n+/* PR tree-optimization/92765 - wrong code for strcmp of a union member\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+inline void* operator new (size_t, void *p)\n+{\n+  return p;\n+}\n+\n+struct A\n+{\n+  char a[2]; char b[2]; char c[2];\n+  A () { a[0] = 0; b[0] = 0; c[0] = 0; };\n+  ~A () { }\n+};\n+\n+struct B\n+{\n+  char d[6];\n+  B () { d[0] = 0; d[2] = 0; }\n+  ~B () { }\n+};\n+\n+__attribute__((noipa)) void\n+sink (void *) { }\n+\n+__attribute__((noipa)) void\n+copy (char *d, const char *s)\n+{\n+  while ((*d++ = *s++));\n+}\n+\n+__attribute__((noipa)) void\n+store_and_compare (void *p)\n+{\n+  A *a = new (p) A ();\n+  sink (&a->b);\n+  a->~A ();\n+\n+  B *b = new (p) B ();\n+  char *q = &b->d[2];\n+  copy (q, \"abc\");\n+\n+  if (__builtin_strcmp (q, \"abc\"))\n+    __builtin_abort ();\n+  b->~B ();\n+}\n+\n+int main ()\n+{\n+  char a [sizeof (A) > sizeof (B) ? sizeof (A) : sizeof (B)];\n+  store_and_compare (a);\n+  return 0;\n+}"}, {"sha": "7bd6df2bf2e0539ae33596e8236d3e8f69a09cec", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-58.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern size_t strlen (const char*);\n+\n+void sink (size_t);\n+\n+struct A0 { char i, a[0]; };\n+\n+extern struct A0 ea0;\n+\n+void fa0_extern (void)\n+{\n+  sink (strlen (ea0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ea0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ea0.a));        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ea0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static struct A0 sa0 = { 0 };\n+\n+void fa0_static (void)\n+{\n+  sink (strlen (sa0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (sa0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (sa0.a));        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (sa0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+struct Ax { char i, a[]; };\n+\n+extern struct Ax ax;\n+\n+void fax_extern (void)\n+{\n+  sink (strlen (ax.a - 2));     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax.a - 1));     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax.a));\n+  sink (strlen (ax.a + 123));\n+}\n+\n+static struct Ax ax0 = { 0, { 0 } };\n+static struct Ax ax1 = { 1, { 1, 0 } };\n+static struct Ax ax2 = { 2, { 2, 1, 0 } };\n+static struct Ax ax3 = { 3, { 3, 2, 1, 0 } };\n+\n+void fax_static (void)\n+{\n+  sink (strlen (ax0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax0.a));\n+  sink (strlen (ax0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax0.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (strlen (ax1.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax1.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax1.a));\n+  sink (strlen (ax1.a + 1));\n+  sink (strlen (ax1.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax1.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (strlen (ax2.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax2.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax2.a));\n+  sink (strlen (ax2.a + 1));\n+  sink (strlen (ax2.a + 2));\n+  sink (strlen (ax2.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax2.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (strlen (ax3.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax3.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax3.a));\n+  sink (strlen (ax3.a + 1));\n+  sink (strlen (ax3.a + 2));\n+  sink (strlen (ax3.a + 3));\n+  sink (strlen (ax3.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax3.a + 5));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "a2d29887c37a6cfa138a4c53b0e29cc95985e4f1", "filename": "gcc/testsuite/gcc.dg/Wrestrict-20.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-20.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -15,7 +15,7 @@ void test_warn (char *p)\n   sprintf (a, \"a=%s\", a);     /* { dg-warning \"-Wrestrict\" } */\n \n   p = a;\n-  char *q = p + 1;\n+  char *q = p + 3;\n   sprintf (p, \"a=%s\", q);     /* { dg-warning \"-Wrestrict\" } */\n }\n \n@@ -31,7 +31,7 @@ void test_nowarn_front_end (char *d)\n void test_nowarn_sprintf_pass (char *d)\n {\n   char *q = d;\n-  \n+\n   sprintf (d, \"p=%p\", q);\n   snprintf (d, 32, \"p=%p\", q);\n "}, {"sha": "d1534bf7555d14865efd7128aa45237b60701f9e", "filename": "gcc/testsuite/gcc.dg/Wstring-compare.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -120,7 +120,8 @@ void strcmp_array_copy (void)\n \n void strcmp_member_array_lit (const struct S *p)\n {\n-  T (p->a4, \"1234\");        // { dg-warning \"length 4 and an array of size 4 \" }\n+  // Not handled due to the fix for PR 92756.\n+  T (p->a4, \"1234\");        // { dg-warning \"length 4 and an array of size 4 \" \"pr92765\" { xfail *-*-* } }\n }\n \n "}, {"sha": "94fda596901fbb516d7852e496cda4ab4b95e9c4", "filename": "gcc/testsuite/gcc.dg/strcmpopt_10.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,130 @@\n+/* Verify that strncmp equalities aren't eliminated when the trailing array\n+   type referenced by a member pointer is smaller than the string in cases\n+   when the pointer pointed to by the enclosing object references an object\n+   sufficiently large to store a string of equal length.\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall -Wextra -fdump-tree-optimized\" } */\n+\n+void init (void*);\n+\n+struct A1 { char i, a[1]; };\n+\n+void f1_arr (void)\n+{\n+  char a[9];\n+  init (a);\n+\n+  struct A1 *p = (struct A1*)a;\n+\n+  if (__builtin_strncmp (p->a, \"01234567\", 8) == 0)\n+    {\n+      extern void array_test (void);\n+      array_test ();\n+    }\n+}\n+\n+void f1_ptr (void)\n+{\n+  void *p;\n+  init (&p);\n+\n+  struct A1 *q = (struct A1*)p;\n+\n+  if (__builtin_strncmp (q->a, \"0123456789\", 10) == 0)\n+    {\n+      extern void pointer_test (void);\n+      pointer_test ();\n+    }\n+}\n+\n+void f1_struct (void)\n+{\n+  struct { char a[9]; } b;\n+  init (&b);\n+\n+  struct A1 *p = (struct A1*)&b;\n+\n+  if (__builtin_strncmp (p->a, \"01234567\", 8) == 0)\n+    {\n+      extern void struct_test (void);\n+      struct_test ();\n+    }\n+}\n+\n+void f1_memptr (void)\n+{\n+  struct { void *p; } b;\n+  init (&b);\n+\n+  struct A1 *p = (struct A1*)b.p;\n+\n+  if (__builtin_strncmp (p->a, \"0123456789\", 10) == 0)\n+    {\n+      extern void memptr_test (void);\n+      memptr_test ();\n+    }\n+}\n+\n+\n+struct A2 { char i, a[2]; };\n+\n+void f2_arr (void)\n+{\n+  char a[8];\n+  init (a);\n+\n+  struct A2 *p = (struct A2*)a;\n+\n+  if (__builtin_strncmp (p->a, \"0123456\", 7) == 0)\n+    {\n+      extern void array_test (void);\n+      array_test ();\n+    }\n+}\n+\n+void f2_ptr (void)\n+{\n+  void *p;\n+  init (&p);\n+\n+  struct A2 *q = (struct A2*)p;\n+\n+  if (__builtin_strncmp (q->a, \"0123456789\", 10) == 0)\n+    {\n+      extern void pointer_test (void);\n+      pointer_test ();\n+    }\n+}\n+\n+void f2_struct (void)\n+{\n+  struct { char a[8]; } b;\n+  init (&b);\n+\n+  struct A2 *p = (struct A2*)&b;\n+\n+  if (__builtin_strncmp (p->a, \"0123456\", 7) == 0)\n+    {\n+      extern void struct_test (void);\n+      struct_test ();\n+    }\n+}\n+\n+void f2_memptr (void)\n+{\n+  struct { void *p; } b;\n+  init (&b);\n+\n+  struct A2 *p = (struct A2*)b.p;\n+\n+  if (__builtin_strncmp (p->a, \"0123456789\", 10) == 0)\n+    {\n+      extern void memptr_test (void);\n+      memptr_test ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"array_test\" 2 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"pointer_test\" 2 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"struct_test\" 2 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"memptr_test\" 2 \"optimized\" } } */"}, {"sha": "945e08319968cbfd2bee8e6ad7aea73153b948f9", "filename": "gcc/testsuite/gcc.dg/strcmpopt_11.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_11.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,16 @@\n+/* Verify that strcmp doesn't make assumptions about the size of a weak\n+   symbol.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+/* An ordinary definition of A with more elements might be provided\n+   in another translation unit.  Even though that would be undefined\n+   (the type of the actual definition must be the same as the type\n+   of the weak declaration) this test verifies that GCC doesn't rely\n+   on the size of this A for optimization (as a matter of QoI).  */\n+__attribute__ ((weak)) char a[3];\n+\n+int cmp_a3_x (void)\n+{\n+  return __builtin_strcmp (a, \"1234567\") == 0;\n+}"}, {"sha": "f31761be1737f552284f607ffd684a3cf5f9e60d", "filename": "gcc/testsuite/gcc.dg/strcmpopt_2.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -4,52 +4,53 @@\n char s[100] = {'a','b','c','d'};\n typedef struct { char s[8]; int x; } S;\n \n-__attribute__ ((noinline)) int \n-f1 (S *s) \n-{ \n-  return __builtin_strcmp (s->s, \"abc\") != 0; \n+__attribute__ ((noinline)) int\n+f1 (S *s)\n+{\n+  /* Member arrays not handled due to the fix for PR 92765.  */\n+  return 0; // __builtin_strcmp (s->s, \"abc\") != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f2 (void) \n-{ \n-  return __builtin_strcmp (s, \"abc\") != 0; \n+__attribute__ ((noinline)) int\n+f2 (void)\n+{\n+  return __builtin_strcmp (s, \"abc\") != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f3 (S *s) \n-{ \n-  return __builtin_strcmp (\"abc\", s->s) != 0; \n+__attribute__ ((noinline)) int\n+f3 (S *s)\n+{\n+  return 0; // __builtin_strcmp (\"abc\", s->s) != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f4 (void) \n-{ \n-  return __builtin_strcmp (\"abc\", s) != 0; \n+__attribute__ ((noinline)) int\n+f4 (void)\n+{\n+  return __builtin_strcmp (\"abc\", s) != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f5 (S *s) \n-{ \n-  return __builtin_strncmp (s->s, \"abc\", 3) != 0; \n+__attribute__ ((noinline)) int\n+f5 (S *s)\n+{\n+  return 0; // __builtin_strncmp (s->s, \"abc\", 3) != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f6 (void) \n-{ \n-  return __builtin_strncmp (s, \"abc\", 2) != 0; \n+__attribute__ ((noinline)) int\n+f6 (void)\n+{\n+  return __builtin_strncmp (s, \"abc\", 2) != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f7 (S *s) \n-{ \n-  return __builtin_strncmp (\"abc\", s->s, 3) != 0; \n+__attribute__ ((noinline)) int\n+f7 (S *s)\n+{\n+  return 0; // __builtin_strncmp (\"abc\", s->s, 3) != 0;\n }\n \n-__attribute__ ((noinline)) int \n-f8 (void) \n-{ \n-  return __builtin_strncmp (\"abc\", s, 2) != 0; \n+__attribute__ ((noinline)) int\n+f8 (void)\n+{\n+  return __builtin_strncmp (\"abc\", s, 2) != 0;\n }\n \n int main (void)\n@@ -64,4 +65,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 8 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 4 \"strlen1\" } } */"}, {"sha": "b07fbb6b7b0c115b5fe35cf1b14940588f73fb7e", "filename": "gcc/testsuite/gcc.dg/strcmpopt_4.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -2,15 +2,26 @@\n /* { dg-options \"-O2 -fdump-tree-strlen\" } */\n \n typedef struct { char s[8]; int x; } S;\n+\n extern int max_i;\n \n-int\n-f1 (S * s)\n-{ \n-  int result, i;\n-  for (i = 0; i < max_i; i++)\n-    result += __builtin_strcmp (s->s, \"abc\") != 0 ? 2 : 1;\n+int f_param (S s)\n+{\n+  int result = 0;\n+  for (int i = 0; i < max_i; i++)\n+    result += __builtin_strcmp (s.s, \"abc\") != 0 ? 2 : 1;\n+  return result;\n+}\n+\n+\n+S s;\n+\n+int f_object (void)\n+{\n+  int result = 0;\n+  for (int i = 0; i < max_i; i++)\n+    result += __builtin_strcmp (s.s, \"abc\") != 0 ? 2 : 1;\n   return result;\n }\n \n-/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "9df6eeccb97fee66fe0e67123d7593a61012aa70", "filename": "gcc/testsuite/gcc.dg/strlenopt-69.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -35,13 +35,16 @@ void test_array_lit (void)\n \n void test_memarray_lit (struct S *p)\n {\n+#if 0\n+  /* Member arrays not handled due to the fix for PR 92765.  */\n   A (strcmp (p->a4, \"1234\"));\n   A (strcmp (p->a4, \"12345\"));\n   A (strcmp (p->a4, \"123456\"));\n \n   A (strcmp (\"1234\", p->a4));\n   A (strcmp (\"12345\", p->a4));\n   A (strcmp (\"123456\", p->a4));\n+#endif\n }\n \n /* Verify that the equality of empty strings is folded.  */"}, {"sha": "a9383e6558850a67a72f8daed329bc4103cba48c", "filename": "gcc/testsuite/gcc.dg/strlenopt-92.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-92.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,58 @@\n+/* PR tree-optimization/92765 - wrong code for strcmp of a union member\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noipa)) int\n+copy (char *x, int y)\n+{\n+  if (y == 0)\n+    strcpy (x, \"abcd\");\n+  return y;\n+}\n+\n+__attribute__((noipa)) char *\n+alloc_2_copy_compare (int x)\n+{\n+  char *p;\n+  if (x)\n+    p = malloc (4);\n+  else\n+    p = calloc (16, 1);\n+\n+  char *q = p + 2;\n+  if (copy (q, x))\n+    return p;\n+\n+  if (strcmp (q, \"abcd\") != 0)\n+    abort ();\n+\n+  return p;\n+}\n+\n+char a5[5], a6[6], a7[7];\n+\n+__attribute__((noipa)) char *\n+decl_3_copy_compare (int x)\n+{\n+  char *p = x < 0 ? a5 : 0 < x ? a6 : a7;\n+  char *q = p + 1;\n+  if (copy (q, x))\n+    return p;\n+\n+  if (strcmp (q, \"abcd\") != 0)\n+    abort ();\n+\n+  return p;\n+}\n+\n+int main ()\n+{\n+  free (alloc_2_copy_compare (0));\n+  free (alloc_2_copy_compare (1));\n+\n+  decl_3_copy_compare (-1);\n+  decl_3_copy_compare (0);\n+  decl_3_copy_compare (1);\n+}"}, {"sha": "dc5f12d2ce348d5664765760d537eeb7f80dc1c7", "filename": "gcc/testsuite/gcc.dg/strlenopt-93.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-93.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -0,0 +1,71 @@\n+/* Verify that strlen doesn't (inadvertently) use the size of an array\n+   of char pointers to put an upper bound on the length of the strings\n+   they point to.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+void eaa_test (void)\n+{\n+  extern char eaa[4][4];\n+\n+  char (*p)[4] = eaa;\n+\n+  if (!*p)\n+    return;\n+\n+  /* The longest string stored in EAA is 15 characters.  */\n+  if (__builtin_strlen (*p) > 14)\n+    {\n+      extern void eaa_ok (void);\n+      eaa_ok ();\n+    }\n+\n+  if (__builtin_strlen (*p) > 15)\n+    {\n+      extern void eaa_fail (void);\n+      eaa_fail ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"eaa_ok\" 1 \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"eaa_fail\" \"optimized\" } } */\n+\n+\n+void epa_test (void)\n+{\n+  extern char* epa[4];\n+  char **p = epa;\n+\n+  if (*p && __builtin_strlen (*p) > 123)\n+    {\n+      extern void epa_ok (void);\n+      epa_ok ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"epa_ok\" 1 \"optimized\" } } */\n+\n+\n+static char* spa[4];\n+\n+void spa_test (void)\n+{\n+  char **p = spa;\n+\n+  if (*p && __builtin_strlen (*p) > 123)\n+    {\n+      extern void spa_ok ();\n+      spa_ok ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"spa_ok\" 1 \"optimized\" } } */\n+\n+\n+void sink (void*, ...);\n+\n+void init (void)\n+{\n+  /* Make believe even the static array SA may be non-zero.  */\n+  sink (spa);\n+}"}, {"sha": "a3ca951ddc513336cb98c4e935078046d524e274", "filename": "gcc/testsuite/gcc.dg/strlenopt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -5,6 +5,7 @@\n #define NULL ((void *) 0)\n typedef __SIZE_TYPE__ size_t;\n extern void abort (void);\n+void *calloc (size_t, size_t);\n void *malloc (size_t);\n void free (void *);\n char *strdup (const char *);"}, {"sha": "7fb96514f1ddff13b346fcf0554abf7625562f39", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-23.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -642,10 +642,22 @@ void test_multiple_overlap (int i)\n   }\n \n   {\n-    char a[4];                /* { dg-message \"declared here\" } */\n+    char a[4];\n+\n+    /* There is no overlap here because the length of a3 is at most 1\n+       and a4 is necessarily the empty string.  */\n+    char *d = a;\n+    char *a3 = a + 2;\n+    char *a4 = a + 3;\n+\n+    T (d, \"%s%s\", a3, a4);\n+  }\n+\n+  {\n+    char a[5];                /* { dg-message \"declared here\" } */\n \n     /* a3 and a4 may overlap the output.  They will only not overlap\n-       it when a3 is empty, and a4 is at most chaeracter byte long.  */\n+       it when a3 is empty, and a4 is at most 1 character long.  */\n     char *d = a;\n     char *a3 = a + 2;\n     char *a4 = a + 3;"}, {"sha": "73b1f2ae52f962972d1dda4668116823a774be98", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr92056.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92056.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92056.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92056.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -1,8 +1,9 @@\n-/* PR tree-optimization/92056 */\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n-/* { dg-final { scan-tree-dump-times \"return 1;\" 2 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-not \"strcmp \\\\(\" \"optimized\" } } */\n+/* PR tree-optimization/92056\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" }\n+   Xfailed until pr93518 is resolved.\n+   { dg-final { scan-tree-dump-times \"return 1;\" 2 \"optimized\" { xfail *-*-* } } }\n+   { dg-final { scan-tree-dump-not \"strcmp \\\\(\" \"optimized\" { xfail *-*-* } } } */\n \n void bar (int, char *);\n "}, {"sha": "1cd64302d8bb18ecf4e33a49bf0f99aada6db093", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 94, "deletions": 148, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7868dc6a79daec4f46552fa5c99f88e4eb8de4c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e7868dc6a79daec4f46552fa5c99f88e4eb8de4c", "patch": "@@ -327,7 +327,8 @@ get_next_strinfo (strinfo *si)\n /* Helper function for get_stridx.  Return the strinfo index of the address\n    of EXP, which is available in PTR if nonnull.  If OFFSET_OUT, it is\n    OK to return the index for some X <= &EXP and store &EXP - X in\n-   *OFFSET_OUT.  When nonnull uses RVALS to determine range information.  */\n+   *OFFSET_OUT.  When RVALS is nonnull uses it to determine range\n+   information.  */\n \n static int\n get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n@@ -4061,105 +4062,20 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n-/* Given an index to the strinfo vector, compute the string length\n-   for the corresponding string. Return -1 when unknown.  */\n-\n-static HOST_WIDE_INT\n-compute_string_length (int idx)\n-{\n-  HOST_WIDE_INT string_leni = -1;\n-  gcc_assert (idx != 0);\n-\n-  if (idx < 0)\n-   return ~idx;\n-\n-  strinfo *si = get_strinfo (idx);\n-  if (si)\n-    {\n-      tree const_string_len = get_string_length (si);\n-      if (const_string_len && tree_fits_shwi_p (const_string_len))\n-\tstring_leni = tree_to_shwi (const_string_len);\n-    }\n-\n-  if (string_leni < 0)\n-    return -1;\n-\n-  return string_leni;\n-}\n-\n-/* Determine the minimum size of the object referenced by DEST expression\n-   which must have a pointer type.\n-   Return the minimum size of the object if successful or HWI_M1U when\n-   the size cannot be determined.  */\n-\n-static unsigned HOST_WIDE_INT\n-determine_min_objsize (tree dest)\n-{\n-  unsigned HOST_WIDE_INT size = 0;\n-\n-  init_object_sizes ();\n-\n-  if (compute_builtin_object_size (dest, 2, &size))\n-    return size;\n-\n-  /* Try to determine the size of the object through the RHS\n-     of the assign statement.  */\n-  if (TREE_CODE (dest) == SSA_NAME)\n-    {\n-      gimple *stmt = SSA_NAME_DEF_STMT (dest);\n-      if (!is_gimple_assign (stmt))\n-\treturn HOST_WIDE_INT_M1U;\n-\n-      if (!gimple_assign_single_p (stmt)\n-\t  && !gimple_assign_unary_nop_p (stmt))\n-\treturn HOST_WIDE_INT_M1U;\n-\n-      dest = gimple_assign_rhs1 (stmt);\n-      return determine_min_objsize (dest);\n-    }\n-\n-  /* Try to determine the size of the object from its type.  */\n-  if (TREE_CODE (dest) != ADDR_EXPR)\n-    return HOST_WIDE_INT_M1U;\n-\n-  tree type = TREE_TYPE (dest);\n-  if (TREE_CODE (type) == POINTER_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  /* The size of a flexible array cannot be determined.  Otherwise,\n-     for arrays with more than one element, return the size of its\n-     type.  GCC itself misuses arrays of both zero and one elements\n-     as flexible array members so they are excluded as well.  */\n-  if (TREE_CODE (type) != ARRAY_TYPE\n-      || !array_at_struct_end_p (dest))\n-    {\n-      tree type_size = TYPE_SIZE_UNIT (type);\n-      if (type_size && TREE_CODE (type_size) == INTEGER_CST\n-\t  && !integer_onep (type_size)\n-\t  && !integer_zerop (type_size))\n-        return tree_to_uhwi (type_size);\n-    }\n-\n-  return HOST_WIDE_INT_M1U;\n-}\n-\n-/* Given strinfo IDX for ARG, set LENRNG[] to the range of lengths\n-   of  the string(s) referenced by ARG if it can be determined.\n-   If the length cannot be determined, set *SIZE to the size of\n+/* Given strinfo IDX for ARG, sets LENRNG[] to the range of lengths\n+   of the string(s) referenced by ARG if it can be determined.\n+   If the length cannot be determined, sets *SIZE to the size of\n    the array the string is stored in, if any.  If no such array is\n-   known, set *SIZE to -1.  When the strings are nul-terminated set\n-   *NULTERM to true, otherwise to false.  Return true on success.  */\n+   known, sets *SIZE to -1.  When the strings are nul-terminated sets\n+   *NULTERM to true, otherwise to false.  When nonnull uses RVALS to\n+   determine range information. Returns true on success.  */\n \n static bool\n get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n-\t\t unsigned HOST_WIDE_INT *size, bool *nulterm)\n+\t\t unsigned HOST_WIDE_INT *size, bool *nulterm,\n+\t\t const vr_values *rvals)\n {\n-  /* Set so that both LEN and ~LEN are invalid lengths, i.e.,\n-     maximum possible length + 1.  */\n-  lenrng[0] = lenrng[1] = HOST_WIDE_INT_MAX;\n-\n+  /* Invalidate.  */\n   *size = HOST_WIDE_INT_M1U;\n \n   if (idx < 0)\n@@ -4168,13 +4084,18 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n       lenrng[0] = ~idx;\n       lenrng[1] = lenrng[0];\n       *nulterm = true;\n+      return true;\n     }\n-  else if (idx == 0)\n-    ; /* Handled below.  */\n-  else if (strinfo *si = get_strinfo (idx))\n+\n+  /* Set so that both LEN and ~LEN are invalid lengths, i.e., maximum\n+     possible length + 1.  */\n+  lenrng[0] = lenrng[1] = HOST_WIDE_INT_MAX;\n+\n+  if (strinfo *si = idx ? get_strinfo (idx) : NULL)\n     {\n+      /* FIXME: Handle all this in_range_strlen_dynamic.  */\n       if (!si->nonzero_chars)\n-\targ = si->ptr;\n+\t;\n       else if (tree_fits_uhwi_p (si->nonzero_chars))\n \t{\n \t  lenrng[0] = tree_to_uhwi (si->nonzero_chars);\n@@ -4195,42 +4116,62 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n \t      *nulterm = si->full_string_p;\n \t    }\n \t}\n-      else if (si->ptr)\n-\targ = si->ptr;\n     }\n \n-  if (lenrng[0] == HOST_WIDE_INT_MAX)\n+  if (lenrng[0] != HOST_WIDE_INT_MAX)\n+    return true;\n+\n+  /* Compute the minimum and maximum real or possible lengths.  */\n+  c_strlen_data lendata = { };\n+  /* Set MAXBOUND to an arbitrary non-null non-integer node as a request\n+     to have it set to the length of the longest string in a PHI.  */\n+  lendata.maxbound = arg;\n+  get_range_strlen_dynamic (arg, &lendata, rvals);\n+\n+  unsigned HOST_WIDE_INT maxbound = HOST_WIDE_INT_M1U;\n+  if (tree_fits_uhwi_p (lendata.maxbound)\n+      && !integer_all_onesp (lendata.maxbound))\n+    maxbound = tree_to_uhwi (lendata.maxbound);\n+\n+  if (tree_fits_uhwi_p (lendata.minlen) && tree_fits_uhwi_p (lendata.maxlen))\n     {\n-      /* Compute the minimum and maximum real or possible lengths.  */\n-      c_strlen_data lendata = { };\n-      if (get_range_strlen (arg, &lendata, /* eltsize = */1))\n+      unsigned HOST_WIDE_INT minlen = tree_to_uhwi (lendata.minlen);\n+      unsigned HOST_WIDE_INT maxlen = tree_to_uhwi (lendata.maxlen);\n+\n+      /* The longest string in this data model.  */\n+      const unsigned HOST_WIDE_INT lenmax\n+\t= tree_to_uhwi (max_object_size ()) - 2;\n+\n+      if (maxbound == HOST_WIDE_INT_M1U)\n \t{\n-\t  if (tree_fits_shwi_p (lendata.maxlen) && !lendata.maxbound)\n-\t    {\n-\t      lenrng[0] = tree_to_shwi (lendata.minlen);\n-\t      lenrng[1] = tree_to_shwi (lendata.maxlen);\n-\t      *nulterm = true;\n-\t    }\n-\t  else if (lendata.maxbound && tree_fits_shwi_p (lendata.maxbound))\n-\t    {\n-\t      /* Set *SIZE to the conservative LENDATA.MAXBOUND which\n-\t\t is a conservative estimate of the longest string based\n-\t\t on the sizes of the arrays referenced by ARG.  */\n-\t      *size = tree_to_uhwi (lendata.maxbound) + 1;\n-\t      *nulterm = false;\n-\t    }\n+\t  lenrng[0] = minlen;\n+\t  lenrng[1] = maxlen;\n+\t  *nulterm = minlen == maxlen;\n \t}\n-      else\n+      else if (maxlen < lenmax)\n \t{\n-\t  /* Set *SIZE to the size of the smallest object referenced\n-\t     by ARG if ARG denotes a single object, or to HWI_M1U\n-\t     otherwise.  */\n-\t  *size = determine_min_objsize (arg);\n+\t  *size = maxbound + 1;\n \t  *nulterm = false;\n \t}\n+      else\n+\treturn false;\n+\n+      return true;\n     }\n \n-  return lenrng[0] != HOST_WIDE_INT_MAX || *size != HOST_WIDE_INT_M1U;\n+  if (maxbound != HOST_WIDE_INT_M1U\n+      && lendata.maxlen\n+      && !integer_all_onesp (lendata.maxlen))\n+    {\n+      /* Set *SIZE to LENDATA.MAXBOUND which is a conservative estimate\n+\t of the longest string based on the sizes of the arrays referenced\n+\t by ARG.  */\n+      *size = maxbound + 1;\n+      *nulterm = false;\n+      return true;\n+    }\n+\n+  return false;\n }\n \n /* If IDX1 and IDX2 refer to strings A and B of unequal lengths, return\n@@ -4245,15 +4186,15 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n static tree\n strxcmp_eqz_result (tree arg1, int idx1, tree arg2, int idx2,\n \t\t    unsigned HOST_WIDE_INT bound, unsigned HOST_WIDE_INT len[2],\n-\t\t    unsigned HOST_WIDE_INT *psize)\n+\t\t    unsigned HOST_WIDE_INT *psize, const vr_values *rvals)\n {\n   /* Determine the range the length of each string is in and whether it's\n      known to be nul-terminated, or the size of the array it's stored in.  */\n   bool nul1, nul2;\n   unsigned HOST_WIDE_INT siz1, siz2;\n   unsigned HOST_WIDE_INT len1rng[2], len2rng[2];\n-  if (!get_len_or_size (arg1, idx1, len1rng, &siz1, &nul1)\n-      || !get_len_or_size (arg2, idx2, len2rng, &siz2, &nul2))\n+  if (!get_len_or_size (arg1, idx1, len1rng, &siz1, &nul1, rvals)\n+      || !get_len_or_size (arg2, idx2, len2rng, &siz2, &nul2, rvals))\n     return NULL_TREE;\n \n   /* BOUND is set to HWI_M1U for strcmp and less to strncmp, and LENiRNG\n@@ -4405,7 +4346,7 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n    another and false otherwise.  */\n \n static bool\n-handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n+handle_builtin_string_cmp (gimple_stmt_iterator *gsi, const vr_values *rvals)\n {\n   gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree lhs = gimple_call_lhs (stmt);\n@@ -4451,7 +4392,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n        or definitely unequal and if so, either fold the result to zero\n        (when equal) or set the range of the result to ~[0, 0] otherwise.  */\n     if (tree eqz = strxcmp_eqz_result (arg1, idx1, arg2, idx2, bound,\n-\t\t\t\t       len, &siz))\n+\t\t\t\t       len, &siz, rvals))\n       {\n \tif (integer_zerop (eqz))\n \t  {\n@@ -4482,26 +4423,31 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n   HOST_WIDE_INT cstlen1 = -1, cstlen2 = -1;\n   HOST_WIDE_INT arysiz1 = -1, arysiz2 = -1;\n \n-  if (idx1)\n-    cstlen1 = compute_string_length (idx1);\n-  else\n-    arysiz1 = determine_min_objsize (arg1);\n+  {\n+    unsigned HOST_WIDE_INT len1rng[2], len2rng[2];\n+    unsigned HOST_WIDE_INT arsz1, arsz2;\n+    bool nulterm[2];\n+\n+    if (!get_len_or_size (arg1, idx1, len1rng, &arsz1, nulterm, rvals)\n+\t|| !get_len_or_size (arg2, idx2, len2rng, &arsz2, nulterm + 1, rvals))\n+      return false;\n+\n+    if (len1rng[0] == len1rng[1] && len1rng[0] < HOST_WIDE_INT_MAX)\n+      cstlen1 = len1rng[0];\n+    else if (arsz1 < HOST_WIDE_INT_M1U)\n+      arysiz1 = arsz1;\n+\n+    if (len2rng[0] == len2rng[1] && len2rng[0] < HOST_WIDE_INT_MAX)\n+      cstlen2 = len2rng[0];\n+    else if (arsz2 < HOST_WIDE_INT_M1U)\n+      arysiz2 = arsz2;\n+  }\n \n   /* Bail if neither the string length nor the size of the array\n      it is stored in can be determined.  */\n-  if (cstlen1 < 0 && arysiz1 < 0)\n-    return false;\n-\n-  /* Repeat for the second argument.  */\n-  if (idx2)\n-    cstlen2 = compute_string_length (idx2);\n-  else\n-    arysiz2 = determine_min_objsize (arg2);\n-\n-  if (cstlen2 < 0 && arysiz2 < 0)\n-    return false;\n-\n-  if (cstlen1 < 0 && cstlen2 < 0)\n+  if ((cstlen1 < 0 && arysiz1 < 0)\n+      || (cstlen2 < 0 && arysiz2 < 0)\n+      || (cstlen1 < 0 && cstlen2 < 0))\n     return false;\n \n   if (cstlen1 >= 0)\n@@ -5435,7 +5381,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n       break;\n     case BUILT_IN_STRCMP:\n     case BUILT_IN_STRNCMP:\n-      if (handle_builtin_string_cmp (gsi))\n+      if (handle_builtin_string_cmp (gsi, rvals))\n \treturn false;\n       break;\n     default:"}]}