{"sha": "e6431744b24d569bcb3955e778925476aeb8b145", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0MzE3NDRiMjRkNTY5YmNiMzk1NWU3Nzg5MjU0NzZhZWI4YjE0NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-12-21T01:03:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-21T01:03:00Z"}, "message": "ia64: Implement vec_perm_const.\n\n        * config/ia64/ia64.c (MAX_VECT_LEN): New.\n        (struct expand_vec_perm_d): New.\n        (TARGET_VECTORIZE_VEC_PERM_CONST_OK): New.\n        (ia64_unpack_assemble): Use ia64_expand_vec_perm_const_1.\n        (expand_vselect, expand_vselect_vconcat): New.\n        (expand_vec_perm_identity, expand_vec_perm_shrp): New.\n        (expand_vec_perm_1, expand_vec_perm_broadcast): New.\n        (expand_vec_perm_interleave_2, expand_vec_perm_v4hi_5): New.\n        (ia64_expand_vec_perm_const_1, ia64_expand_vec_perm_const): New.\n        (ia64_vectorize_vec_perm_const_ok): New.\n        (ia64_expand_vec_setv2sf, ia64_expand_vec_perm_even_odd): New.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/vect.md (VEC): New mode iterator.\n        (vecint): New mode attribute.\n        (vec_interleave_lowv8qi, vec_interleave_highv8qi): Privatize with '*'.\n        (vec_interleave_lowv4hi, vec_interleave_highv4hi): Likewise.\n        (vec_interleave_lowv2si, vec_interleave_highv2si): Likewise.\n        (vec_interleave_lowv2sf, vec_interleave_highv2sf): Likewise.\n        (mix1_even, mix1_odd, mux1_alt): Likewise.\n        (mux1_brcst_qi): Remove '*' from name.\n        (vec_extract_evenv8qi, vec_extract_oddv8qi): Remove.\n        (vec_extract_evenv4hi, vec_extract_oddv4hi): Remove.\n        (vec_extract_evenv2si, vec_extract_oddv2si): Remove.\n        (vec_extract_evenv2sf, vec_extract_oddv2sf): Remove.\n        (vec_extract_evenodd_helper): Remove.\n        (vec_setv2sf): Use ia64_expand_vec_setv2sf.\n        (vec_pack_trunc_v4hi): Use ia64_expand_vec_perm_even_odd.\n        (vec_pack_trunc_v2si): Likewise.\n        (vec_perm_const<VEC>): New.\n\nFrom-SVN: r182564", "tree": {"sha": "8450d556f28962d191629e54bcc62623d8f450cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8450d556f28962d191629e54bcc62623d8f450cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6431744b24d569bcb3955e778925476aeb8b145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6431744b24d569bcb3955e778925476aeb8b145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6431744b24d569bcb3955e778925476aeb8b145", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6431744b24d569bcb3955e778925476aeb8b145/comments", "author": null, "committer": null, "parents": [{"sha": "0f3d6c10f436b0d037fead17db534145a0437832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3d6c10f436b0d037fead17db534145a0437832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3d6c10f436b0d037fead17db534145a0437832"}], "stats": {"total": 828, "additions": 658, "deletions": 170}, "files": [{"sha": "d393c263c34b2657413abe8e10d0902323936d0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6431744b24d569bcb3955e778925476aeb8b145", "patch": "@@ -1,3 +1,35 @@\n+2011-12-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (MAX_VECT_LEN): New.\n+\t(struct expand_vec_perm_d): New.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST_OK): New.\n+\t(ia64_unpack_assemble): Use ia64_expand_vec_perm_const_1.\n+\t(expand_vselect, expand_vselect_vconcat): New.\n+\t(expand_vec_perm_identity, expand_vec_perm_shrp): New.\n+\t(expand_vec_perm_1, expand_vec_perm_broadcast): New.\n+\t(expand_vec_perm_interleave_2, expand_vec_perm_v4hi_5): New.\n+\t(ia64_expand_vec_perm_const_1, ia64_expand_vec_perm_const): New.\n+\t(ia64_vectorize_vec_perm_const_ok): New.\n+\t(ia64_expand_vec_setv2sf, ia64_expand_vec_perm_even_odd): New.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/vect.md (VEC): New mode iterator.\n+\t(vecint): New mode attribute.\n+\t(vec_interleave_lowv8qi, vec_interleave_highv8qi): Privatize with '*'.\n+\t(vec_interleave_lowv4hi, vec_interleave_highv4hi): Likewise.\n+\t(vec_interleave_lowv2si, vec_interleave_highv2si): Likewise.\n+\t(vec_interleave_lowv2sf, vec_interleave_highv2sf): Likewise.\n+\t(mix1_even, mix1_odd, mux1_alt): Likewise.\n+\t(mux1_brcst_qi): Remove '*' from name.\n+\t(vec_extract_evenv8qi, vec_extract_oddv8qi): Remove.\n+\t(vec_extract_evenv4hi, vec_extract_oddv4hi): Remove.\n+\t(vec_extract_evenv2si, vec_extract_oddv2si): Remove.\n+\t(vec_extract_evenv2sf, vec_extract_oddv2sf): Remove.\n+\t(vec_extract_evenodd_helper): Remove.\n+\t(vec_setv2sf): Use ia64_expand_vec_setv2sf.\n+\t(vec_pack_trunc_v4hi): Use ia64_expand_vec_perm_even_odd.\n+\t(vec_pack_trunc_v2si): Likewise.\n+\t(vec_perm_const<VEC>): New.\n+\n 2011-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* tree-vect-generic.c (expand_vector_operations_1): Correct tests"}, {"sha": "f7bd4c60240e7f833cfbf306ea85d3b9b332af51", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=e6431744b24d569bcb3955e778925476aeb8b145", "patch": "@@ -61,6 +61,10 @@ extern int ia64_hard_regno_rename_ok (int, int);\n extern enum reg_class ia64_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   enum machine_mode, rtx);\n extern const char *get_bundle_name (int);\n+\n+extern void ia64_expand_vec_perm_even_odd (rtx, rtx, rtx, int);\n+extern bool ia64_expand_vec_perm_const (rtx op[4]);\n+extern void ia64_expand_vec_setv2sf (rtx op[3]);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "1635a7e59515b4104314050266ec2a93ea8bef2b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 591, "deletions": 18, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e6431744b24d569bcb3955e778925476aeb8b145", "patch": "@@ -330,6 +330,24 @@ static reg_class_t ia64_preferred_reload_class (rtx, reg_class_t);\n static enum machine_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n+\n+static bool ia64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t\t      const unsigned char *sel);\n+\n+#define MAX_VECT_LEN\t8\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_operand_p;\n+  bool testing_p; \n+};\n+\n+static bool ia64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d);\n+\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -626,6 +644,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_DELAY_VARTRACK\n #define TARGET_DELAY_VARTRACK true\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+#define TARGET_VECTORIZE_VEC_PERM_CONST_OK ia64_vectorize_vec_perm_const_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n typedef enum\n@@ -2027,28 +2048,28 @@ ia64_expand_vecint_minmax (enum rtx_code code, enum machine_mode mode,\n void\n ia64_unpack_assemble (rtx out, rtx lo, rtx hi, bool highp)\n {\n-  enum machine_mode mode = GET_MODE (lo);\n-  rtx (*gen) (rtx, rtx, rtx);\n-  rtx x;\n+  enum machine_mode vmode = GET_MODE (lo);\n+  unsigned int i, high, nelt = GET_MODE_NUNITS (vmode);\n+  struct expand_vec_perm_d d;\n+  bool ok;\n \n-  switch (mode)\n+  d.target = gen_lowpart (vmode, out);\n+  d.op0 = (TARGET_BIG_ENDIAN ? hi : lo);\n+  d.op1 = (TARGET_BIG_ENDIAN ? lo : hi);\n+  d.vmode = vmode;\n+  d.nelt = nelt;\n+  d.one_operand_p = false;\n+  d.testing_p = false;\n+\n+  high = (highp ? nelt / 2 : 0);\n+  for (i = 0; i < nelt / 2; ++i)\n     {\n-    case V8QImode:\n-      gen = highp ? gen_vec_interleave_highv8qi : gen_vec_interleave_lowv8qi;\n-      break;\n-    case V4HImode:\n-      gen = highp ? gen_vec_interleave_highv4hi : gen_vec_interleave_lowv4hi;\n-      break;\n-    default:\n-      gcc_unreachable ();\n+      d.perm[i * 2] = i + high;\n+      d.perm[i * 2 + 1] = i + high + nelt;\n     }\n \n-  x = gen_lowpart (mode, out);\n-  if (TARGET_BIG_ENDIAN)\n-    x = gen (x, hi, lo);\n-  else\n-    x = gen (x, lo, hi);\n-  emit_insn (x);\n+  ok = ia64_expand_vec_perm_const_1 (&d);\n+  gcc_assert (ok);\n }\n \n /* Return a vector of the sign-extension of VEC.  */\n@@ -11046,5 +11067,557 @@ ia64_hpux_function_section (tree decl ATTRIBUTE_UNUSED,\n {\n   return NULL;\n }\n+\f\n+/* Construct (set target (vec_select op0 (parallel perm))) and\n+   return true if that's a valid instruction in the active ISA.  */\n+\n+static bool\n+expand_vselect (rtx target, rtx op0, const unsigned char *perm, unsigned nelt)\n+{\n+  rtx rperm[MAX_VECT_LEN], x;\n+  unsigned i;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (perm[i]);\n+\n+  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelt, rperm));\n+  x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n+  x = gen_rtx_SET (VOIDmode, target, x);\n+\n+  x = emit_insn (x);\n+  if (recog_memoized (x) < 0)\n+    {\n+      remove_insn (x);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Similar, but generate a vec_concat from op0 and op1 as well.  */\n+\n+static bool\n+expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n+\t\t\tconst unsigned char *perm, unsigned nelt)\n+{\n+  enum machine_mode v2mode;\n+  rtx x;\n+\n+  v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n+  x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n+  return expand_vselect (target, x, perm, nelt);\n+}\n+\n+/* Try to expand a no-op permutation.  */\n+\n+static bool\n+expand_vec_perm_identity (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, nelt = d->nelt;\n+\n+  for (i = 0; i < nelt; ++i)\n+    if (d->perm[i] != i)\n+      return false;\n+\n+  if (!d->testing_p)\n+    emit_move_insn (d->target, d->op0);\n+\n+  return true;\n+}\n+\n+/* Try to expand D via a shrp instruction.  */\n+\n+static bool\n+expand_vec_perm_shrp (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, nelt = d->nelt, shift, mask;\n+  rtx tmp, op0, op1;;\n+\n+  /* ??? Don't force V2SFmode into the integer registers.  */\n+  if (d->vmode == V2SFmode)\n+    return false;\n+\n+  mask = (d->one_operand_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  shift = d->perm[0];\n+  for (i = 1; i < nelt; ++i)\n+    if (d->perm[i] != ((shift + i) & mask))\n+      return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  shift *= GET_MODE_UNIT_SIZE (d->vmode) * BITS_PER_UNIT;\n+\n+  /* We've eliminated the shift 0 case via expand_vec_perm_identity.  */\n+  gcc_assert (IN_RANGE (shift, 1, 63));\n+\n+  /* Recall that big-endian elements are numbered starting at the top of\n+     the register.  Ideally we'd have a shift-left-pair.  But since we\n+     don't, convert to a shift the other direction.  */\n+  if (BYTES_BIG_ENDIAN)\n+    shift = 64 - shift;\n+\n+  tmp = gen_reg_rtx (DImode);\n+  op0 = (shift < nelt ? d->op0 : d->op1);\n+  op1 = (shift < nelt ? d->op1 : d->op0);\n+  op0 = gen_lowpart (DImode, op0);\n+  op1 = gen_lowpart (DImode, op1);\n+  emit_insn (gen_shrp (tmp, op0, op1, GEN_INT (shift)));\n+\n+  emit_move_insn (d->target, gen_lowpart (d->vmode, tmp));\n+  return true;\n+}\n+\n+/* Try to instantiate D in a single instruction.  */\n+\n+static bool\n+expand_vec_perm_1 (struct expand_vec_perm_d *d)\n+{     \n+  unsigned i, nelt = d->nelt;\n+  unsigned char perm2[MAX_VECT_LEN];\n+\n+  /* Try single-operand selections.  */\n+  if (d->one_operand_p)\n+    {\n+      if (expand_vec_perm_identity (d))\n+\treturn true;\n+      if (expand_vselect (d->target, d->op0, d->perm, nelt))\n+\treturn true;\n+    }\n+\n+  /* Try two operand selections.  */\n+  if (expand_vselect_vconcat (d->target, d->op0, d->op1, d->perm, nelt))\n+    return true;\n+\n+  /* Recognize interleave style patterns with reversed operands.  */\n+  if (!d->one_operand_p)\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned e = d->perm[i];\n+\t  if (e >= nelt)\n+\t    e -= nelt;\n+\t  else\n+\t    e += nelt;\n+\t  perm2[i] = e;\n+\t}\n+\n+      if (expand_vselect_vconcat (d->target, d->op1, d->op0, perm2, nelt))\n+\treturn true;\n+    }\n+\n+  if (expand_vec_perm_shrp (d))\n+    return true;\n+\n+  /* ??? Look for deposit-like permutations where most of the result \n+     comes from one vector unchanged and the rest comes from a \n+     sequential hunk of the other vector.  */\n+\n+  return false;\n+}\n+\n+/* Pattern match broadcast permutations.  */\n+\n+static bool\n+expand_vec_perm_broadcast (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, elt, nelt = d->nelt;\n+  unsigned char perm2[2];\n+  rtx temp;\n+  bool ok;\n+\n+  if (!d->one_operand_p)\n+    return false;\n+\n+  elt = d->perm[0];\n+  for (i = 1; i < nelt; ++i)\n+    if (d->perm[i] != elt)\n+      return false;\n+\n+  switch (d->vmode)\n+    {\n+    case V2SImode:\n+    case V2SFmode:\n+      /* Implementable by interleave.  */\n+      perm2[0] = elt;\n+      perm2[1] = elt + 2;\n+      ok = expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, 2);\n+      gcc_assert (ok);\n+      break;\n+\n+    case V8QImode:\n+      /* Implementable by extract + broadcast.  */\n+      if (BYTES_BIG_ENDIAN)\n+\telt = 7 - elt;\n+      elt *= BITS_PER_UNIT;\n+      temp = gen_reg_rtx (DImode);\n+      emit_insn (gen_extzv (temp, gen_lowpart (DImode, d->op0),\n+\t\t\t    GEN_INT (elt), GEN_INT (8)));\n+      emit_insn (gen_mux1_brcst_qi (d->target, gen_lowpart (QImode, temp)));\n+      break;\n+\n+    case V4HImode:\n+      /* Should have been matched directly by vec_select.  */\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return true;\n+}\n+\n+/* A subroutine of ia64_expand_vec_perm_const_1.  Try to simplify a\n+   two vector permutation into a single vector permutation by using\n+   an interleave operation to merge the vectors.  */\n+\n+static bool\n+expand_vec_perm_interleave_2 (struct expand_vec_perm_d *d)\n+{\n+  struct expand_vec_perm_d dremap, dfinal;\n+  unsigned char remap[2 * MAX_VECT_LEN];\n+  unsigned contents, i, nelt, nelt2;\n+  unsigned h0, h1, h2, h3;\n+  rtx seq;\n+  bool ok;\n+\n+  if (d->one_operand_p)\n+    return false;\n+\n+  nelt = d->nelt;\n+  nelt2 = nelt / 2;\n+\n+  /* Examine from whence the elements come.  */\n+  contents = 0;\n+  for (i = 0; i < nelt; ++i)\n+    contents |= 1u << d->perm[i];\n+\n+  memset (remap, 0xff, sizeof (remap));\n+  dremap = *d;\n+\n+  h0 = (1u << nelt2) - 1;\n+  h1 = h0 << nelt2;\n+  h2 = h0 << nelt;\n+  h3 = h0 << (nelt + nelt2);\n+  \n+  if ((contents & (h0 | h2)) == contents)\t/* punpck even halves */\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned which = i / 2 + (i & 1 ? nelt : 0);\n+\t  remap[which] = i;\n+\t  dremap.perm[i] = which;\n+\t}\n+    }\n+  else if ((contents & (h1 | h3)) == contents)\t/* punpck odd halves */\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned which = i / 2 + nelt2 + (i & 1 ? nelt : 0);\n+\t  remap[which] = i;\n+\t  dremap.perm[i] = which;\n+\t}\n+    }\n+  else if ((contents & 0x5555) == contents)\t/* mix even elements */\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned which = (i & ~1) + (i & 1 ? nelt : 0);\n+\t  remap[which] = i;\n+\t  dremap.perm[i] = which;\n+\t}\n+    }\n+  else if ((contents & 0xaaaa) == contents)\t/* mix odd elements */\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned which = (i | 1) + (i & 1 ? nelt : 0);\n+\t  remap[which] = i;\n+\t  dremap.perm[i] = which;\n+\t}\n+    }\n+  else if (floor_log2 (contents) - ctz_hwi (contents) < (int)nelt) /* shrp */\n+    {\n+      unsigned shift = ctz_hwi (contents);\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned which = (i + shift) & (2 * nelt - 1);\n+\t  remap[which] = i;\n+\t  dremap.perm[i] = which;\n+\t}\n+    }\n+  else\n+    return false;\n+\n+  /* Use the remapping array set up above to move the elements from their\n+     swizzled locations into their final destinations.  */\n+  dfinal = *d;\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned e = remap[d->perm[i]];\n+      gcc_assert (e < nelt);\n+      dfinal.perm[i] = e;\n+    }\n+  dfinal.op0 = gen_reg_rtx (dfinal.vmode);\n+  dfinal.op1 = dfinal.op0;\n+  dfinal.one_operand_p = true;\n+  dremap.target = dfinal.op0;\n+\n+  /* Test if the final remap can be done with a single insn.  For V4HImode\n+     this *will* succeed.  For V8QImode or V2SImode it may not.  */\n+  start_sequence ();\n+  ok = expand_vec_perm_1 (&dfinal);\n+  seq = get_insns ();\n+  end_sequence ();\n+  if (!ok)\n+    return false;\n+  if (d->testing_p)\n+    return true;\n+\n+  ok = expand_vec_perm_1 (&dremap);\n+  gcc_assert (ok);\n+\n+  emit_insn (seq);\n+  return true;\n+}\n+\n+/* A subroutine of ia64_expand_vec_perm_const_1.  Emit a full V4HImode\n+   constant permutation via two mux2 and a merge.  */\n+\n+static bool\n+expand_vec_perm_v4hi_5 (struct expand_vec_perm_d *d)\n+{\n+  unsigned char perm2[4];\n+  rtx rmask[4];\n+  unsigned i;\n+  rtx t0, t1, mask, x;\n+  bool ok;\n+\n+  if (d->vmode != V4HImode || d->one_operand_p)\n+    return false;\n+  if (d->testing_p)\n+    return true;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      perm2[i] = d->perm[i] & 3;\n+      rmask[i] = (d->perm[i] & 4 ? const0_rtx : constm1_rtx);\n+    }\n+  mask = gen_rtx_CONST_VECTOR (V4HImode, gen_rtvec_v (4, rmask));\n+  mask = force_reg (V4HImode, mask);\n+\n+  t0 = gen_reg_rtx (V4HImode);\n+  t1 = gen_reg_rtx (V4HImode);\n+\n+  ok = expand_vselect (t0, d->op0, perm2, 4);\n+  gcc_assert (ok);\n+  ok = expand_vselect (t1, d->op1, perm2, 4);\n+  gcc_assert (ok);\n+\n+  x = gen_rtx_AND (V4HImode, mask, t0);\n+  emit_insn (gen_rtx_SET (VOIDmode, t0, x));\n+\n+  x = gen_rtx_NOT (V4HImode, mask);\n+  x = gen_rtx_AND (V4HImode, x, t1);\n+  emit_insn (gen_rtx_SET (VOIDmode, t1, x));\n+\n+  x = gen_rtx_IOR (V4HImode, t0, t1);\n+  emit_insn (gen_rtx_SET (VOIDmode, d->target, x));\n+\n+  return true;\n+}\n+\n+/* The guts of ia64_expand_vec_perm_const, also used by the ok hook.\n+   With all of the interface bits taken care of, perform the expansion\n+   in D and return true on success.  */\n+\n+static bool\n+ia64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n+{\n+  if (expand_vec_perm_1 (d))\n+    return true;\n+  if (expand_vec_perm_broadcast (d))\n+    return true;\n+  if (expand_vec_perm_interleave_2 (d))\n+    return true;\n+  if (expand_vec_perm_v4hi_5 (d))\n+    return true;\n+  return false;\n+}\n+\n+bool\n+ia64_expand_vec_perm_const (rtx operands[4])\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned char perm[MAX_VECT_LEN];\n+  int i, nelt, which;\n+  rtx sel;\n+\n+  d.target = operands[0];\n+  d.op0 = operands[1];\n+  d.op1 = operands[2];\n+  sel = operands[3];\n+\n+  d.vmode = GET_MODE (d.target);\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  gcc_assert (GET_CODE (sel) == CONST_VECTOR);\n+  gcc_assert (XVECLEN (sel, 0) == nelt);\n+  gcc_checking_assert (sizeof (d.perm) == sizeof (perm));\n+\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      rtx e = XVECEXP (sel, 0, i);\n+      int ei = INTVAL (e) & (2 * nelt - 1);\n+\n+      which |= (ei < nelt ? 1 : 2);\n+      d.perm[i] = ei;\n+      perm[i] = ei;\n+    }\n+\n+  switch (which)\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case 3:\n+      if (!rtx_equal_p (d.op0, d.op1))\n+\t{\n+\t  d.one_operand_p = false;\n+\t  break;\n+\t}\n+\n+      /* The elements of PERM do not suggest that only the first operand\n+\t is used, but both operands are identical.  Allow easier matching\n+\t of the permutation by folding the permutation into the single\n+\t input vector.  */\n+      for (i = 0; i < nelt; ++i)\n+\tif (d.perm[i] >= nelt)\n+\t  d.perm[i] -= nelt;\n+      /* FALLTHRU */\n+\n+    case 1:\n+      d.op1 = d.op0;\n+      d.one_operand_p = true;\n+      break;\n+\n+    case 2:\n+      for (i = 0; i < nelt; ++i)\n+        d.perm[i] -= nelt;\n+      d.op0 = d.op1;\n+      d.one_operand_p = true;\n+      break;\n+    }\n+\n+  if (ia64_expand_vec_perm_const_1 (&d))\n+    return true;\n+\n+  /* If the mask says both arguments are needed, but they are the same,\n+     the above tried to expand with one_operand_p true.  If that didn't\n+     work, retry with one_operand_p false, as that's what we used in _ok.  */\n+  if (which == 3 && d.one_operand_p)\n+    {\n+      memcpy (d.perm, perm, sizeof (perm));\n+      d.one_operand_p = false;\n+      return ia64_expand_vec_perm_const_1 (&d);\n+    }\n+\n+  return false;\n+}\n+\n+/* Implement targetm.vectorize.vec_perm_const_ok.  */\n+\n+static bool\n+ia64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t  const unsigned char *sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt, which;\n+  bool ret;\n+\n+  d.vmode = vmode;\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+\n+  /* Extract the values from the vector CST into the permutation\n+     array in D.  */\n+  memcpy (d.perm, sel, nelt);\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      unsigned char e = d.perm[i];\n+      gcc_assert (e < 2 * nelt);\n+      which |= (e < nelt ? 1 : 2);\n+    }\n+\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to the vector type.  */\n+  d.one_operand_p = (which != 3);\n+\n+  /* Otherwise we have to go through the motions and see if we can\n+     figure out how to generate the requested permutation.  */\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!d.one_operand_p)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = ia64_expand_vec_perm_const_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n+void\n+ia64_expand_vec_setv2sf (rtx operands[3])\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int which;\n+  bool ok;\n+  \n+  d.target = operands[0];\n+  d.op0 = operands[0];\n+  d.op1 = gen_reg_rtx (V2SFmode);\n+  d.vmode = V2SFmode;\n+  d.nelt = 2;\n+  d.one_operand_p = false;\n+  d.testing_p = false;\n+\n+  which = INTVAL (operands[2]);\n+  gcc_assert (which <= 1);\n+  d.perm[0] = 1 - which;\n+  d.perm[1] = which + 2;\n+\n+  emit_insn (gen_fpack (d.op1, operands[1], CONST0_RTX (SFmode)));\n+\n+  ok = ia64_expand_vec_perm_const_1 (&d);\n+  gcc_assert (ok);\n+}\n+\n+void\n+ia64_expand_vec_perm_even_odd (rtx target, rtx op0, rtx op1, int odd)\n+{\n+  struct expand_vec_perm_d d;\n+  enum machine_mode vmode = GET_MODE (target);\n+  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n+  bool ok;\n+\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+  d.vmode = vmode;\n+  d.nelt = nelt;\n+  d.one_operand_p = false;\n+  d.testing_p = false;\n+\n+  for (i = 0; i < nelt; ++i)\n+    d.perm[i] = i * 2 + odd;\n+\n+  ok = ia64_expand_vec_perm_const_1 (&d);\n+  gcc_assert (ok);\n+}\n \n #include \"gt-ia64.h\""}, {"sha": "aa77b01e7e337cac38047500dd88f1676f4a8100", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 31, "deletions": 152, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6431744b24d569bcb3955e778925476aeb8b145/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=e6431744b24d569bcb3955e778925476aeb8b145", "patch": "@@ -20,11 +20,14 @@\n \n ;; Integer vector operations\n \n+(define_mode_iterator VEC [V8QI V4HI V2SI V2SF])\n (define_mode_iterator VECINT [V8QI V4HI V2SI])\n (define_mode_iterator VECINT12 [V8QI V4HI])\n (define_mode_iterator VECINT24 [V4HI V2SI])\n (define_mode_attr vecsize [(V8QI \"1\") (V4HI \"2\") (V2SI \"4\")])\n (define_mode_attr vecwider [(V8QI \"V4HI\") (V4HI \"V2SI\")])\n+(define_mode_attr vecint\n+  [(V8QI \"V8QI\") (V4HI \"V4HI\") (V2SI \"V2SI\") (V2SF \"V2SI\")])\n \n (define_expand \"mov<mode>\"\n   [(set (match_operand:VECINT 0 \"general_operand\" \"\")\n@@ -756,7 +759,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"vec_interleave_lowv8qi\"\n+(define_insn \"*vec_interleave_lowv8qi\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n@@ -776,7 +779,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"vec_interleave_highv8qi\"\n+(define_insn \"*vec_interleave_highv8qi\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n@@ -796,7 +799,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix1_even\"\n+(define_insn \"*mix1_even\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n@@ -816,7 +819,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix1_odd\"\n+(define_insn \"*mix1_odd\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n@@ -872,7 +875,7 @@\n   \"mux1 %0 = %1, @shuf\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mux1_alt\"\n+(define_insn \"*mux1_alt\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n@@ -900,39 +903,15 @@\n   \"mux1 %0 = %1, @brcst\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"*mux1_brcst_qi\"\n+(define_insn \"mux1_brcst_qi\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_duplicate:V8QI\n \t  (match_operand:QI 1 \"gr_register_operand\" \"r\")))]\n   \"\"\n   \"mux1 %0 = %1, @brcst\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_expand \"vec_extract_evenv8qi\"\n-  [(match_operand:V8QI 0 \"gr_register_operand\" \"\")\n-   (match_operand:V8QI 1 \"gr_register_operand\" \"\")\n-   (match_operand:V8QI 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  rtx temp = gen_reg_rtx (V8QImode);\n-  emit_insn (gen_mix1_even (temp, operands[1], operands[2]));\n-  emit_insn (gen_mux1_alt (operands[0], temp));\n-  DONE;\n-})\n-\n-(define_expand \"vec_extract_oddv8qi\"\n-  [(match_operand:V8QI 0 \"gr_register_operand\" \"\")\n-   (match_operand:V8QI 1 \"gr_register_operand\" \"\")\n-   (match_operand:V8QI 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  rtx temp = gen_reg_rtx (V8QImode);\n-  emit_insn (gen_mix1_odd (temp, operands[1], operands[2]));\n-  emit_insn (gen_mux1_alt (operands[0], temp));\n-  DONE;\n-})\n-\n-(define_insn \"vec_interleave_lowv4hi\"\n+(define_insn \"*vec_interleave_lowv4hi\"\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t  (vec_concat:V8HI\n@@ -950,7 +929,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"vec_interleave_highv4hi\"\n+(define_insn \"*vec_interleave_highv4hi\"\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t  (vec_concat:V8HI\n@@ -1034,38 +1013,6 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_expand \"vec_extract_evenodd_helper\"\n-  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"\")\n-\t(vec_select:V4HI\n-\t  (match_operand:V4HI 1 \"gr_register_operand\" \"\")\n-\t  (parallel [(const_int 0) (const_int 2)\n-\t\t     (const_int 1) (const_int 3)])))]\n-  \"\")\n-\n-(define_expand \"vec_extract_evenv4hi\"\n-  [(match_operand:V4HI 0 \"gr_register_operand\")\n-   (match_operand:V4HI 1 \"gr_reg_or_0_operand\")\n-   (match_operand:V4HI 2 \"gr_reg_or_0_operand\")]\n-  \"\"\n-{\n-  rtx temp = gen_reg_rtx (V4HImode);\n-  emit_insn (gen_mix2_even (temp, operands[1], operands[2]));\n-  emit_insn (gen_vec_extract_evenodd_helper (operands[0], temp));\n-  DONE;\n-})\n-\n-(define_expand \"vec_extract_oddv4hi\"\n-  [(match_operand:V4HI 0 \"gr_register_operand\")\n-   (match_operand:V4HI 1 \"gr_reg_or_0_operand\")\n-   (match_operand:V4HI 2 \"gr_reg_or_0_operand\")]\n-  \"\"\n-{\n-  rtx temp = gen_reg_rtx (V4HImode);\n-  emit_insn (gen_mix2_odd (temp, operands[1], operands[2]));\n-  emit_insn (gen_vec_extract_evenodd_helper (operands[0], temp));\n-  DONE;\n-})\n-\n (define_insn \"*mux2_brcst_hi\"\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n \t(vec_duplicate:V4HI\n@@ -1074,7 +1021,7 @@\n   \"mux2 %0 = %1, 0\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"vec_interleave_lowv2si\"\n+(define_insn \"*vec_interleave_lowv2si\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t  (vec_concat:V4SI\n@@ -1091,7 +1038,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"vec_interleave_highv2si\"\n+(define_insn \"*vec_interleave_highv2si\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t  (vec_concat:V4SI\n@@ -1108,36 +1055,6 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_expand \"vec_extract_evenv2si\"\n-  [(match_operand:V2SI 0 \"gr_register_operand\" \"\")\n-   (match_operand:V2SI 1 \"gr_register_operand\" \"\")\n-   (match_operand:V2SI 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_interleave_highv2si (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n-  else\n-    emit_insn (gen_vec_interleave_lowv2si (operands[0], operands[1],\n-\t\t\t\t\t   operands[2]));\n-  DONE;\n-})\n-\n-(define_expand \"vec_extract_oddv2si\"\n-  [(match_operand:V2SI 0 \"gr_register_operand\" \"\")\n-   (match_operand:V2SI 1 \"gr_register_operand\" \"\")\n-   (match_operand:V2SI 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_interleave_lowv2si (operands[0], operands[1],\n-\t\t\t\t\t   operands[2]));\n-  else\n-    emit_insn (gen_vec_interleave_highv2si (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n-  DONE;\n-})\n-\n (define_expand \"vec_initv2si\"\n   [(match_operand:V2SI 0 \"gr_register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n@@ -1479,7 +1396,7 @@\n }\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"vec_interleave_highv2sf\"\n+(define_insn \"*vec_interleave_highv2sf\"\n   [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n \t(vec_select:V2SF\n \t  (vec_concat:V4SF\n@@ -1496,7 +1413,7 @@\n }\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"vec_interleave_lowv2sf\"\n+(define_insn \"*vec_interleave_lowv2sf\"\n   [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n \t(vec_select:V2SF\n \t  (vec_concat:V4SF\n@@ -1530,58 +1447,13 @@\n }\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_expand \"vec_extract_evenv2sf\"\n-  [(match_operand:V2SF 0 \"gr_register_operand\" \"\")\n-   (match_operand:V2SF 1 \"gr_register_operand\" \"\")\n-   (match_operand:V2SF 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_interleave_highv2sf (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n-  else\n-    emit_insn (gen_vec_interleave_lowv2sf (operands[0], operands[1],\n-\t\t\t\t\t   operands[2]));\n-  DONE;\n-})\n-\n-(define_expand \"vec_extract_oddv2sf\"\n-  [(match_operand:V2SF 0 \"gr_register_operand\" \"\")\n-   (match_operand:V2SF 1 \"gr_register_operand\" \"\")\n-   (match_operand:V2SF 2 \"gr_register_operand\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_interleave_lowv2sf (operands[0], operands[1],\n-\t\t\t\t\t   operands[2]));\n-  else\n-    emit_insn (gen_vec_interleave_highv2sf (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n-  DONE;\n-})\n-\n (define_expand \"vec_setv2sf\"\n   [(match_operand:V2SF 0 \"fr_register_operand\" \"\")\n    (match_operand:SF 1 \"fr_register_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]\n   \"\"\n {\n-  rtx op0 = operands[0];\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-\n-  emit_insn (gen_fpack (tmp, operands[1], CONST0_RTX (SFmode)));\n-\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      emit_insn (gen_fmix_lr (op0, tmp, op0));\n-      break;\n-    case 1:\n-      emit_insn (gen_vec_interleave_lowv2sf (op0, op0, tmp));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  ia64_expand_vec_setv2sf (operands);\n   DONE;\n })\n \n@@ -1703,10 +1575,7 @@\n {\n   rtx op1 = gen_lowpart (V8QImode, operands[1]);\n   rtx op2 = gen_lowpart (V8QImode, operands[2]);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_extract_oddv8qi (operands[0], op1, op2));\n-  else\n-    emit_insn (gen_vec_extract_evenv8qi (operands[0], op1, op2));\n+  ia64_expand_vec_perm_even_odd (operands[0], op1, op2, TARGET_BIG_ENDIAN);\n   DONE;\n })\n \n@@ -1718,13 +1587,23 @@\n {\n   rtx op1 = gen_lowpart (V4HImode, operands[1]);\n   rtx op2 = gen_lowpart (V4HImode, operands[2]);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_vec_extract_oddv4hi (operands[0], op1, op2));\n-  else\n-    emit_insn (gen_vec_extract_evenv4hi (operands[0], op1, op2));\n+  ia64_expand_vec_perm_even_odd (operands[0], op1, op2, TARGET_BIG_ENDIAN);\n   DONE;\n })\n \n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:VEC 0 \"register_operand\" \"\")\n+   (match_operand:VEC 1 \"register_operand\" \"\")\n+   (match_operand:VEC 2 \"register_operand\" \"\")\n+   (match_operand:<vecint> 3 \"\" \"\")]\n+  \"\"\n+{\n+  if (ia64_expand_vec_perm_const (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n ;; Missing operations\n ;; fprcpa\n ;; fpsqrta"}]}