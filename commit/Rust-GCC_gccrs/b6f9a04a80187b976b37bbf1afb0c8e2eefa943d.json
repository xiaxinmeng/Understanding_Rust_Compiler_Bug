{"sha": "b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmOWEwNGE4MDE4N2I5NzZiMzdiYmYxYWZiMGM4ZTJlZWZhOTQzZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-10-18T21:27:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-10-18T21:27:40Z"}, "message": "i386.c (ix86_expand_vec_perm): In merge_two use mode SUBREG of operands[0] as target.\n\n\t* config/i386/i386.c (ix86_expand_vec_perm): In merge_two use\n\tmode SUBREG of operands[0] as target.\n\t(valid_perm_using_mode_p): Don't ignore higher bits of d->perm.\n\t(expand_vec_pshufb): For V8SImode vmode emit avx2_permvarv8si.\n\t(expand_vec_perm_1): Handle identity and some broadcast\n\tpermutations.\n\t(expand_vec_perm_interleave2): Handle also 32-byte modes, using\n\tvperm2[fi]128 or vpunpck[lh]* followed by single insn permutation.\n\tFor d->testing_p return true earlier to avoid creating more GC\n\tgarbage.\n\t(expand_vec_perm_vpermq_perm_1): New function.\n\t(expand_vec_perm_vpshufb2_vpermq): For d->testing_p return true\n\tearlier to avoid creating more GC garbage.  Fix handling of\n\tV16HImode.  Avoid some SUBREGs in SET_DEST.\n\t(expand_vec_perm_broadcast_1): Return false for 32-byte integer\n\tvector modes.\n\t(expand_vec_perm_vpshufb4_vpermq2): New function.\n\t(ix86_expand_vec_perm_builtin_1): Call expand_vec_perm_vpermq_perm_1\n\tand expand_vec_perm_vpshufb4_vpermq2.\n\nFrom-SVN: r180169", "tree": {"sha": "de23d6e3c334ccca26f466c22e7d5d134ca8a089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de23d6e3c334ccca26f466c22e7d5d134ca8a089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9d662bb75152bb63ada99d46d30d98197a82160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d662bb75152bb63ada99d46d30d98197a82160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d662bb75152bb63ada99d46d30d98197a82160"}], "stats": {"total": 546, "additions": 476, "deletions": 70}, "files": [{"sha": "d8f5a8292d0df4eb74e31889b50d6b77bfd99cda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "patch": "@@ -1,3 +1,25 @@\n+2011-10-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vec_perm): In merge_two use\n+\tmode SUBREG of operands[0] as target.\n+\t(valid_perm_using_mode_p): Don't ignore higher bits of d->perm.\n+\t(expand_vec_pshufb): For V8SImode vmode emit avx2_permvarv8si.\n+\t(expand_vec_perm_1): Handle identity and some broadcast\n+\tpermutations.\n+\t(expand_vec_perm_interleave2): Handle also 32-byte modes, using\n+\tvperm2[fi]128 or vpunpck[lh]* followed by single insn permutation.\n+\tFor d->testing_p return true earlier to avoid creating more GC\n+\tgarbage.\n+\t(expand_vec_perm_vpermq_perm_1): New function.\n+\t(expand_vec_perm_vpshufb2_vpermq): For d->testing_p return true\n+\tearlier to avoid creating more GC garbage.  Fix handling of\n+\tV16HImode.  Avoid some SUBREGs in SET_DEST.\n+\t(expand_vec_perm_broadcast_1): Return false for 32-byte integer\n+\tvector modes.\n+\t(expand_vec_perm_vpshufb4_vpermq2): New function.\n+\t(ix86_expand_vec_perm_builtin_1): Call expand_vec_perm_vpermq_perm_1\n+\tand expand_vec_perm_vpshufb4_vpermq2.\n+\n 2011-10-18  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/arm/driver-arm.c (host_detect_local_cpu): Close the file"}, {"sha": "ec9d39b4830953e864417a7049e7f6a5239a1418", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 454, "deletions": 70, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f9a04a80187b976b37bbf1afb0c8e2eefa943d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b6f9a04a80187b976b37bbf1afb0c8e2eefa943d", "patch": "@@ -19663,7 +19663,7 @@ ix86_expand_vec_perm (rtx operands[])\n       mask = expand_simple_binop (maskmode, AND, mask, vt,\n \t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n \n-      xops[0] = operands[0];\n+      xops[0] = gen_lowpart (mode, operands[0]);\n       xops[1] = gen_lowpart (mode, t2);\n       xops[2] = gen_lowpart (mode, t1);\n       xops[3] = gen_rtx_EQ (maskmode, mask, vt);\n@@ -35006,8 +35006,7 @@ valid_perm_using_mode_p (enum machine_mode vmode, struct expand_vec_perm_d *d)\n       return false;\n     else\n       for (j = 1; j < chunk; ++j)\n-\tif ((d->perm[i] & (d->nelt - 1)) + j\n-\t    != (d->perm[i + j] & (d->nelt - 1)))\n+\tif (d->perm[i] + j != d->perm[i + j])\n \t  return false;\n \n   return true;\n@@ -35138,6 +35137,8 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \temit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n       else if (vmode == V32QImode)\n \temit_insn (gen_avx2_pshufbv32qi3 (target, op0, vperm));\n+      else\n+\temit_insn (gen_avx2_permvarv8si (target, vperm, op0));\n     }\n   else\n     {\n@@ -35163,9 +35164,58 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n   if (d->op0 == d->op1)\n     {\n       int mask = nelt - 1;\n+      bool identity_perm = true;\n+      bool broadcast_perm = true;\n \n       for (i = 0; i < nelt; i++)\n-\tperm2[i] = d->perm[i] & mask;\n+\t{\n+\t  perm2[i] = d->perm[i] & mask;\n+\t  if (perm2[i] != i)\n+\t    identity_perm = false;\n+\t  if (perm2[i])\n+\t    broadcast_perm = false;\n+\t}\n+\n+      if (identity_perm)\n+\t{\n+\t  if (!d->testing_p)\n+\t    emit_move_insn (d->target, d->op0);\n+\t  return true;\n+\t}\n+      else if (broadcast_perm && TARGET_AVX2)\n+\t{\n+\t  /* Use vpbroadcast{b,w,d}.  */\n+\t  rtx op = d->op0, (*gen) (rtx, rtx) = NULL;\n+\t  switch (d->vmode)\n+\t    {\n+\t    case V32QImode:\n+\t      op = gen_lowpart (V16QImode, op);\n+\t      gen = gen_avx2_pbroadcastv32qi;\n+\t      break;\n+\t    case V16HImode:\n+\t      op = gen_lowpart (V8HImode, op);\n+\t      gen = gen_avx2_pbroadcastv16hi;\n+\t      break;\n+\t    case V8SImode:\n+\t      op = gen_lowpart (V4SImode, op);\n+\t      gen = gen_avx2_pbroadcastv8si;\n+\t      break;\n+\t    case V16QImode:\n+\t      gen = gen_avx2_pbroadcastv16qi;\n+\t      break;\n+\t    case V8HImode:\n+\t      gen = gen_avx2_pbroadcastv8hi;\n+\t      break;\n+\t    /* For other modes prefer other shuffles this function creates.  */\n+\t    default: break;\n+\t    }\n+\t  if (gen != NULL)\n+\t    {\n+\t      if (!d->testing_p)\n+\t\temit_insn (gen (d->target, op));\n+\t      return true;\n+\t    }\n+\t}\n \n       if (expand_vselect (d->target, d->op0, perm2, nelt))\n \treturn true;\n@@ -35349,93 +35399,210 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n {\n   struct expand_vec_perm_d dremap, dfinal;\n   unsigned i, nelt = d->nelt, nelt2 = nelt / 2;\n-  unsigned contents, h1, h2, h3, h4;\n+  unsigned HOST_WIDE_INT contents;\n   unsigned char remap[2 * MAX_VECT_LEN];\n   rtx seq;\n-  bool ok;\n+  bool ok, same_halves = false;\n \n-  if (d->op0 == d->op1)\n-    return false;\n-\n-  /* The 256-bit unpck[lh]p[sd] instructions only operate within the 128-bit\n-     lanes.  We can use similar techniques with the vperm2f128 instruction,\n-     but it requires slightly different logic.  */\n-  if (GET_MODE_SIZE (d->vmode) != 16)\n+  if (GET_MODE_SIZE (d->vmode) == 16)\n+    {\n+      if (d->op0 == d->op1)\n+\treturn false;\n+    }\n+  else if (GET_MODE_SIZE (d->vmode) == 32)\n+    {\n+      if (!TARGET_AVX)\n+\treturn false;\n+      /* For 32-byte modes allow even d->op0 == d->op1.\n+\t The lack of cross-lane shuffling in some instructions\n+\t might prevent a single insn shuffle.  */\n+    }\n+  else\n     return false;\n \n   /* Examine from whence the elements come.  */\n   contents = 0;\n   for (i = 0; i < nelt; ++i)\n-    contents |= 1u << d->perm[i];\n-\n-  /* Split the two input vectors into 4 halves.  */\n-  h1 = (1u << nelt2) - 1;\n-  h2 = h1 << nelt2;\n-  h3 = h2 << nelt2;\n-  h4 = h3 << nelt2;\n+    contents |= ((unsigned HOST_WIDE_INT) 1) << d->perm[i];\n \n   memset (remap, 0xff, sizeof (remap));\n   dremap = *d;\n \n-  /* If the elements from the low halves use interleave low, and similarly\n-     for interleave high.  If the elements are from mis-matched halves, we\n-     can use shufps for V4SF/V4SI or do a DImode shuffle.  */\n-  if ((contents & (h1 | h3)) == contents)\n+  if (GET_MODE_SIZE (d->vmode) == 16)\n     {\n-      for (i = 0; i < nelt2; ++i)\n+      unsigned HOST_WIDE_INT h1, h2, h3, h4;\n+\n+      /* Split the two input vectors into 4 halves.  */\n+      h1 = (((unsigned HOST_WIDE_INT) 1) << nelt2) - 1;\n+      h2 = h1 << nelt2;\n+      h3 = h2 << nelt2;\n+      h4 = h3 << nelt2;\n+\n+      /* If the elements from the low halves use interleave low, and similarly\n+\t for interleave high.  If the elements are from mis-matched halves, we\n+\t can use shufps for V4SF/V4SI or do a DImode shuffle.  */\n+      if ((contents & (h1 | h3)) == contents)\n \t{\n-\t  remap[i] = i * 2;\n-\t  remap[i + nelt] = i * 2 + 1;\n-\t  dremap.perm[i * 2] = i;\n-\t  dremap.perm[i * 2 + 1] = i + nelt;\n+\t  /* punpckl* */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i] = i * 2;\n+\t      remap[i + nelt] = i * 2 + 1;\n+\t      dremap.perm[i * 2] = i;\n+\t      dremap.perm[i * 2 + 1] = i + nelt;\n+\t    }\n \t}\n-    }\n-  else if ((contents & (h2 | h4)) == contents)\n-    {\n-      for (i = 0; i < nelt2; ++i)\n+      else if ((contents & (h2 | h4)) == contents)\n \t{\n-\t  remap[i + nelt2] = i * 2;\n-\t  remap[i + nelt + nelt2] = i * 2 + 1;\n-\t  dremap.perm[i * 2] = i + nelt2;\n-\t  dremap.perm[i * 2 + 1] = i + nelt + nelt2;\n+\t  /* punpckh* */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i + nelt2] = i * 2;\n+\t      remap[i + nelt + nelt2] = i * 2 + 1;\n+\t      dremap.perm[i * 2] = i + nelt2;\n+\t      dremap.perm[i * 2 + 1] = i + nelt + nelt2;\n+\t    }\n \t}\n-    }\n-  else if ((contents & (h1 | h4)) == contents)\n-    {\n-      for (i = 0; i < nelt2; ++i)\n+      else if ((contents & (h1 | h4)) == contents)\n \t{\n-\t  remap[i] = i;\n-\t  remap[i + nelt + nelt2] = i + nelt2;\n-\t  dremap.perm[i] = i;\n-\t  dremap.perm[i + nelt2] = i + nelt + nelt2;\n+\t  /* shufps */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i] = i;\n+\t      remap[i + nelt + nelt2] = i + nelt2;\n+\t      dremap.perm[i] = i;\n+\t      dremap.perm[i + nelt2] = i + nelt + nelt2;\n+\t    }\n+\t  if (nelt != 4)\n+\t    {\n+\t      /* shufpd */\n+\t      dremap.vmode = V2DImode;\n+\t      dremap.nelt = 2;\n+\t      dremap.perm[0] = 0;\n+\t      dremap.perm[1] = 3;\n+\t    }\n \t}\n-      if (nelt != 4)\n+      else if ((contents & (h2 | h3)) == contents)\n \t{\n-\t  dremap.vmode = V2DImode;\n-\t  dremap.nelt = 2;\n-\t  dremap.perm[0] = 0;\n-\t  dremap.perm[1] = 3;\n+\t  /* shufps */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i + nelt2] = i;\n+\t      remap[i + nelt] = i + nelt2;\n+\t      dremap.perm[i] = i + nelt2;\n+\t      dremap.perm[i + nelt2] = i + nelt;\n+\t    }\n+\t  if (nelt != 4)\n+\t    {\n+\t      /* shufpd */\n+\t      dremap.vmode = V2DImode;\n+\t      dremap.nelt = 2;\n+\t      dremap.perm[0] = 1;\n+\t      dremap.perm[1] = 2;\n+\t    }\n \t}\n+      else\n+\treturn false;\n     }\n-  else if ((contents & (h2 | h3)) == contents)\n+  else\n     {\n-      for (i = 0; i < nelt2; ++i)\n+      unsigned int nelt4 = nelt / 4, nzcnt = 0;\n+      unsigned HOST_WIDE_INT q[8];\n+      unsigned int nonzero_halves[4];\n+\n+      /* Split the two input vectors into 8 quarters.  */\n+      q[0] = (((unsigned HOST_WIDE_INT) 1) << nelt4) - 1;\n+      for (i = 1; i < 8; ++i)\n+\tq[i] = q[0] << (nelt4 * i);\n+      for (i = 0; i < 4; ++i)\n+\tif (((q[2 * i] | q[2 * i + 1]) & contents) != 0)\n+\t  {\n+\t    nonzero_halves[nzcnt] = i;\n+\t    ++nzcnt;\n+\t  }\n+\n+      if (nzcnt == 1)\n+\t{\n+\t  gcc_assert (d->op0 == d->op1);\n+\t  nonzero_halves[1] = nonzero_halves[0];\n+\t  same_halves = true;\n+\t}\n+      else if (d->op0 == d->op1)\n+\t{\n+\t  gcc_assert (nonzero_halves[0] == 0);\n+\t  gcc_assert (nonzero_halves[1] == 1);\n+\t}\n+\n+      if (nzcnt <= 2)\n+\t{\n+\t  if (d->perm[0] / nelt2 == nonzero_halves[1])\n+\t    {\n+\t      /* Attempt to increase the likelyhood that dfinal\n+\t\t shuffle will be intra-lane.  */\n+\t      char tmph = nonzero_halves[0];\n+\t      nonzero_halves[0] = nonzero_halves[1];\n+\t      nonzero_halves[1] = tmph;\n+\t    }\n+\n+\t  /* vperm2f128 or vperm2i128.  */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i + nonzero_halves[1] * nelt2] = i + nelt2;\n+\t      remap[i + nonzero_halves[0] * nelt2] = i;\n+\t      dremap.perm[i + nelt2] = i + nonzero_halves[1] * nelt2;\n+\t      dremap.perm[i] = i + nonzero_halves[0] * nelt2;\n+\t    }\n+\n+\t  if (d->vmode != V8SFmode\n+\t      && d->vmode != V4DFmode\n+\t      && d->vmode != V8SImode)\n+\t    {\n+\t      dremap.vmode = V8SImode;\n+\t      dremap.nelt = 8;\n+\t      for (i = 0; i < 4; ++i)\n+\t\t{\n+\t\t  dremap.perm[i] = i + nonzero_halves[0] * 4;\n+\t\t  dremap.perm[i + 4] = i + nonzero_halves[1] * 4;\n+\t\t}\n+\t    }\n+\t}\n+      else if (d->op0 == d->op1)\n+\treturn false;\n+      else if (TARGET_AVX2\n+\t       && (contents & (q[0] | q[2] | q[4] | q[6])) == contents)\n \t{\n-\t  remap[i + nelt2] = i;\n-\t  remap[i + nelt] = i + nelt2;\n-\t  dremap.perm[i] = i + nelt2;\n-\t  dremap.perm[i + nelt2] = i + nelt;\n+\t  /* vpunpckl* */\n+\t  for (i = 0; i < nelt4; ++i)\n+\t    {\n+\t      remap[i] = i * 2;\n+\t      remap[i + nelt] = i * 2 + 1;\n+\t      remap[i + nelt2] = i * 2 + nelt2;\n+\t      remap[i + nelt + nelt2] = i * 2 + nelt2 + 1;\n+\t      dremap.perm[i * 2] = i;\n+\t      dremap.perm[i * 2 + 1] = i + nelt;\n+\t      dremap.perm[i * 2 + nelt2] = i + nelt2;\n+\t      dremap.perm[i * 2 + nelt2 + 1] = i + nelt + nelt2;\n+\t    }\n \t}\n-      if (nelt != 4)\n+      else if (TARGET_AVX2\n+\t       && (contents & (q[1] | q[3] | q[5] | q[7])) == contents)\n \t{\n-\t  dremap.vmode = V2DImode;\n-\t  dremap.nelt = 2;\n-\t  dremap.perm[0] = 1;\n-\t  dremap.perm[1] = 2;\n+\t  /* vpunpckh* */\n+\t  for (i = 0; i < nelt4; ++i)\n+\t    {\n+\t      remap[i + nelt4] = i * 2;\n+\t      remap[i + nelt + nelt4] = i * 2 + 1;\n+\t      remap[i + nelt2 + nelt4] = i * 2 + nelt2;\n+\t      remap[i + nelt + nelt2 + nelt4] = i * 2 + nelt2 + 1;\n+\t      dremap.perm[i * 2] = i + nelt4;\n+\t      dremap.perm[i * 2 + 1] = i + nelt + nelt4;\n+\t      dremap.perm[i * 2 + nelt2] = i + nelt2 + nelt4;\n+\t      dremap.perm[i * 2 + nelt2 + 1] = i + nelt + nelt2 + nelt4;\n+\t    }\n \t}\n+      else\n+\treturn false;\n     }\n-  else\n-    return false;\n \n   /* Use the remapping array set up above to move the elements from their\n      swizzled locations into their final destinations.  */\n@@ -35444,7 +35611,15 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n     {\n       unsigned e = remap[d->perm[i]];\n       gcc_assert (e < nelt);\n-      dfinal.perm[i] = e;\n+      /* If same_halves is true, both halves of the remapped vector are the\n+\t same.  Avoid cross-lane accesses if possible.  */\n+      if (same_halves && i >= nelt2)\n+\t{\n+\t  gcc_assert (e < nelt2);\n+\t  dfinal.perm[i] = e + nelt2;\n+\t}\n+      else\n+\tdfinal.perm[i] = e;\n     }\n   dfinal.op0 = gen_reg_rtx (dfinal.vmode);\n   dfinal.op1 = dfinal.op0;\n@@ -35460,6 +35635,9 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n   if (!ok)\n     return false;\n \n+  if (d->testing_p)\n+    return true;\n+\n   if (dremap.vmode != dfinal.vmode)\n     {\n       dremap.target = gen_lowpart (dremap.vmode, dremap.target);\n@@ -35474,6 +35652,83 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n+   a single vector cross-lane permutation into vpermq followed\n+   by any of the single insn permutations.  */\n+\n+static bool\n+expand_vec_perm_vpermq_perm_1 (struct expand_vec_perm_d *d)\n+{\n+  struct expand_vec_perm_d dremap, dfinal;\n+  unsigned i, j, nelt = d->nelt, nelt2 = nelt / 2, nelt4 = nelt / 4;\n+  unsigned contents[2];\n+  bool ok;\n+\n+  if (!(TARGET_AVX2\n+\t&& (d->vmode == V32QImode || d->vmode == V16HImode)\n+\t&& d->op0 == d->op1))\n+    return false;\n+\n+  contents[0] = 0;\n+  contents[1] = 0;\n+  for (i = 0; i < nelt2; ++i)\n+    {\n+      contents[0] |= 1u << (d->perm[i] / nelt4);\n+      contents[1] |= 1u << (d->perm[i + nelt2] / nelt4);\n+    }\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      unsigned int cnt = 0;\n+      for (j = 0; j < 4; ++j)\n+\tif ((contents[i] & (1u << j)) != 0 && ++cnt > 2)\n+\t  return false;\n+    }\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  dremap = *d;\n+  dremap.vmode = V4DImode;\n+  dremap.nelt = 4;\n+  dremap.target = gen_reg_rtx (V4DImode);\n+  dremap.op0 = gen_lowpart (V4DImode, d->op0);\n+  dremap.op1 = dremap.op0;\n+  for (i = 0; i < 2; ++i)\n+    {\n+      unsigned int cnt = 0;\n+      for (j = 0; j < 4; ++j)\n+\tif ((contents[i] & (1u << j)) != 0)\n+\t  dremap.perm[2 * i + cnt++] = j;\n+      for (; cnt < 2; ++cnt)\n+\tdremap.perm[2 * i + cnt] = 0;\n+    }\n+\n+  dfinal = *d;\n+  dfinal.op0 = gen_lowpart (dfinal.vmode, dremap.target);\n+  dfinal.op1 = dfinal.op0;\n+  for (i = 0, j = 0; i < nelt; ++i)\n+    {\n+      if (i == nelt2)\n+\tj = 2;\n+      dfinal.perm[i] = (d->perm[i] & (nelt4 - 1)) | (j ? nelt2 : 0);\n+      if ((d->perm[i] / nelt4) == dremap.perm[j])\n+\t;\n+      else if ((d->perm[i] / nelt4) == dremap.perm[j + 1])\n+\tdfinal.perm[i] |= nelt4;\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  ok = expand_vec_perm_1 (&dremap);\n+  gcc_assert (ok);\n+\n+  ok = expand_vec_perm_1 (&dfinal);\n+  gcc_assert (ok);\n+\n+  return true;\n+}\n+\n /* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n    a two vector permutation using 2 intra-lane interleave insns\n    and cross-lane shuffle for 32-byte vectors.  */\n@@ -35621,6 +35876,9 @@ expand_vec_perm_vpshufb2_vpermq (struct expand_vec_perm_d *d)\n       || (d->vmode != V32QImode && d->vmode != V16HImode))\n     return false;\n \n+  if (d->testing_p)\n+    return true;\n+\n   nelt = d->nelt;\n   eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n \n@@ -35635,12 +35893,12 @@ expand_vec_perm_vpshufb2_vpermq (struct expand_vec_perm_d *d)\n   for (i = 0; i < nelt; ++i)\n     {\n       unsigned j, e = d->perm[i] & (nelt / 2 - 1);\n-      unsigned which = ((d->perm[i] ^ i) & (nelt / 2));\n+      unsigned which = ((d->perm[i] ^ i) & (nelt / 2)) * eltsz;\n \n       for (j = 0; j < eltsz; ++j)\n \t{\n \t  rperm[!!which][(i * eltsz + j) ^ which] = GEN_INT (e * eltsz + j);\n-\t  rperm[!which][(i * eltsz + j) ^ (which ^ (nelt / 2))] = m128;\n+\t  rperm[!which][(i * eltsz + j) ^ (which ^ 16)] = m128;\n \t}\n     }\n \n@@ -35652,10 +35910,9 @@ expand_vec_perm_vpshufb2_vpermq (struct expand_vec_perm_d *d)\n   emit_insn (gen_avx2_pshufbv32qi3 (h, op, vperm));\n \n   /* Swap the 128-byte lanes of h into hp.  */\n-  hp = gen_reg_rtx (V32QImode);\n+  hp = gen_reg_rtx (V4DImode);\n   op = gen_lowpart (V4DImode, h);\n-  emit_insn (gen_avx2_permv4di_1 (gen_lowpart (V4DImode, hp), op,\n-\t\t\t\t  const2_rtx, GEN_INT (3), const0_rtx,\n+  emit_insn (gen_avx2_permv4di_1 (hp, op, const2_rtx, GEN_INT (3), const0_rtx,\n \t\t\t\t  const1_rtx));\n \n   vperm = gen_rtx_CONST_VECTOR (V32QImode, gen_rtvec_v (32, rperm[0]));\n@@ -35666,7 +35923,7 @@ expand_vec_perm_vpshufb2_vpermq (struct expand_vec_perm_d *d)\n   emit_insn (gen_avx2_pshufbv32qi3 (l, op, vperm));\n \n   op = gen_lowpart (V32QImode, d->target);\n-  emit_insn (gen_iorv32qi3 (op, l, hp));\n+  emit_insn (gen_iorv32qi3 (op, l, gen_lowpart (V32QImode, hp)));\n \n   return true;\n }\n@@ -35994,6 +36251,15 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n       gcc_assert (ok);\n       return true;\n \n+    case V32QImode:\n+    case V16HImode:\n+    case V8SImode:\n+    case V4DImode:\n+      /* For AVX2 broadcasts of the first element vpbroadcast* or\n+\t vpermq should be used by expand_vec_perm_1.  */\n+      gcc_assert (!TARGET_AVX2 || d->perm[0]);\n+      return false;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -36018,6 +36284,117 @@ expand_vec_perm_broadcast (struct expand_vec_perm_d *d)\n   return expand_vec_perm_broadcast_1 (d);\n }\n \n+/* Implement arbitrary permutation of two V32QImode and V16QImode operands\n+   with 4 vpshufb insns, 2 vpermq and 3 vpor.  We should have already failed\n+   all the shorter instruction sequences.  */\n+\n+static bool\n+expand_vec_perm_vpshufb4_vpermq2 (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[4][32], vperm, l[2], h[2], op, m128;\n+  unsigned int i, nelt, eltsz;\n+  bool used[4];\n+\n+  if (!TARGET_AVX2\n+      || d->op0 == d->op1\n+      || (d->vmode != V32QImode && d->vmode != V16HImode))\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  nelt = d->nelt;\n+  eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n+\n+  /* Generate 4 permutation masks.  If the required element is within\n+     the same lane, it is shuffled in.  If the required element from the\n+     other lane, force a zero by setting bit 7 in the permutation mask.\n+     In the other mask the mask has non-negative elements if element\n+     is requested from the other lane, but also moved to the other lane,\n+     so that the result of vpshufb can have the two V2TImode halves\n+     swapped.  */\n+  m128 = GEN_INT (-128);\n+  for (i = 0; i < 32; ++i)\n+    {\n+      rperm[0][i] = m128;\n+      rperm[1][i] = m128;\n+      rperm[2][i] = m128;\n+      rperm[3][i] = m128;\n+    }\n+  used[0] = false;\n+  used[1] = false;\n+  used[2] = false;\n+  used[3] = false;\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned j, e = d->perm[i] & (nelt / 2 - 1);\n+      unsigned xlane = ((d->perm[i] ^ i) & (nelt / 2)) * eltsz;\n+      unsigned int which = ((d->perm[i] & nelt) ? 2 : 0) + (xlane ? 1 : 0);\n+\n+      for (j = 0; j < eltsz; ++j)\n+\trperm[which][(i * eltsz + j) ^ xlane] = GEN_INT (e * eltsz + j);\n+      used[which] = true;\n+    }\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (!used[2 * i + 1])\n+\t{\n+\t  h[i] = NULL_RTX;\n+\t  continue;\n+\t}\n+      vperm = gen_rtx_CONST_VECTOR (V32QImode,\n+\t\t\t\t    gen_rtvec_v (32, rperm[2 * i + 1]));\n+      vperm = force_reg (V32QImode, vperm);\n+      h[i] = gen_reg_rtx (V32QImode);\n+      op = gen_lowpart (V32QImode, i ? d->op1 : d->op0);\n+      emit_insn (gen_avx2_pshufbv32qi3 (h[i], op, vperm));\n+    }\n+\n+  /* Swap the 128-byte lanes of h[X].  */\n+  for (i = 0; i < 2; ++i)\n+   {\n+     if (h[i] == NULL_RTX)\n+       continue;\n+     op = gen_reg_rtx (V4DImode);\n+     emit_insn (gen_avx2_permv4di_1 (op, gen_lowpart (V4DImode, h[i]),\n+\t\t\t\t     const2_rtx, GEN_INT (3), const0_rtx,\n+\t\t\t\t     const1_rtx));\n+     h[i] = gen_lowpart (V32QImode, op);\n+   }\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (!used[2 * i])\n+\t{\n+\t  l[i] = NULL_RTX;\n+\t  continue;\n+\t}\n+      vperm = gen_rtx_CONST_VECTOR (V32QImode, gen_rtvec_v (32, rperm[2 * i]));\n+      vperm = force_reg (V32QImode, vperm);\n+      l[i] = gen_reg_rtx (V32QImode);\n+      op = gen_lowpart (V32QImode, i ? d->op1 : d->op0);\n+      emit_insn (gen_avx2_pshufbv32qi3 (l[i], op, vperm));\n+    }\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (h[i] && l[i])\n+\t{\n+\t  op = gen_reg_rtx (V32QImode);\n+\t  emit_insn (gen_iorv32qi3 (op, l[i], h[i]));\n+\t  l[i] = op;\n+\t}\n+      else if (h[i])\n+\tl[i] = h[i];\n+    }\n+\n+  gcc_assert (l[0] && l[1]);\n+  op = gen_lowpart (V32QImode, d->target);\n+  emit_insn (gen_iorv32qi3 (op, l[0], l[1]));\n+  return true;\n+}\n+\n /* The guts of ix86_expand_vec_perm_builtin, also used by the ok hook.\n    With all of the interface bits taken care of, perform the expansion\n    in D and return true on success.  */\n@@ -36043,6 +36420,9 @@ ix86_expand_vec_perm_builtin_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_broadcast (d))\n     return true;\n \n+  if (expand_vec_perm_vpermq_perm_1 (d))\n+    return true;\n+\n   /* Try sequences of three instructions.  */\n \n   if (expand_vec_perm_pshufb2 (d))\n@@ -36072,6 +36452,10 @@ ix86_expand_vec_perm_builtin_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_even_odd (d))\n     return true;\n \n+  /* Even longer sequences.  */\n+  if (expand_vec_perm_vpshufb4_vpermq2 (d))\n+    return true;\n+\n   return false;\n }\n "}]}