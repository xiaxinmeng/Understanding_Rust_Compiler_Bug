{"sha": "ffae286a5cba64f5819f9378719423ad0d8de44b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhZTI4NmE1Y2JhNjRmNTgxOWY5Mzc4NzE5NDIzYWQwZDhkZTQ0Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-06-06T17:46:26Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-06-06T17:46:26Z"}, "message": "Add some comments.  Cleanup formatting.\n\n(type attribute): Add pstore and call.\n(return define_delay): Reorganize to make clearer.\n(call/sfunc define_delay): Define.\n(cbranch define_delay): Define to have annul-true delay slot.\n(subsi3): Use arith_reg_operand for operand 2.\n(shift patterns): Use const_int_operand instead of immediate_operand\nfor shift counts.\n(push): Add pstore constraint case.\n(movsi_i): Move t/z constraint pair to the front of the list.\n(calli, call_valuei): Add \"call\" attribute.\n\nFrom-SVN: r9888", "tree": {"sha": "b18a7330140315f5ae80618732555fb86bdecc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b18a7330140315f5ae80618732555fb86bdecc72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffae286a5cba64f5819f9378719423ad0d8de44b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffae286a5cba64f5819f9378719423ad0d8de44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffae286a5cba64f5819f9378719423ad0d8de44b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffae286a5cba64f5819f9378719423ad0d8de44b/comments", "author": null, "committer": null, "parents": [{"sha": "85256f8a68fad82c63d59d115ab69f9feadde038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85256f8a68fad82c63d59d115ab69f9feadde038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85256f8a68fad82c63d59d115ab69f9feadde038"}], "stats": {"total": 319, "additions": 184, "deletions": 135}, "files": [{"sha": "0eb66d22f85efd119343d0584e2a7f74e9fb52e8", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 184, "deletions": 135, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffae286a5cba64f5819f9378719423ad0d8de44b/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffae286a5cba64f5819f9378719423ad0d8de44b/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ffae286a5cba64f5819f9378719423ad0d8de44b", "patch": "@@ -20,6 +20,13 @@\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \n \n+;; ??? Should be enhanced to include support for many more GNU superoptimizer\n+;; sequences.  Especially the sequences for arithmetic right shifts.\n+\n+;; ??? Should check all DImode patterns for consistency and usefulness.\n+\n+;; ??? Should add support for using BSR for short function calls.\n+\n ;; ??? The MAC.W and MAC.L instructions are not supported.  There is no\n ;; way to generate them.\n \n@@ -29,6 +36,9 @@\n ;; file, and is within range.  Better would be assembler/linker relaxing,\n ;; but that is much harder.\n \n+;; ??? The cmp/str instruction is not supported.  Perhaps it can be used\n+;; for a str* inline function.\n+\n ;; Special constraints for SH machine description:\n ;;\n ;;    t -- T\n@@ -72,13 +82,15 @@\n ;; smpy\t\tword precision integer multiply\n ;; dmpy\t\tlongword or doublelongword precision integer multiply\n ;; return\trts\n-;; pload\tload of pr reg (can't be put into delay slot of rts)\n+;; pload\tload of pr reg, which can't be put into delay slot of rts\n+;; pstore\tstore of pr reg, which can't be put into delay slot of jsr\n ;; pcload\tpc relative load of constant value\n ;; rte\t\treturn from exception\n ;; sfunc\tspecial function call with known used registers\n+;; call\t\tfunction call\n \n (define_attr \"type\"\n- \"cbranch,jump,arith,other,load,store,move,smpy,dmpy,return,pload,pcload,rte,sfunc\"\n+ \"cbranch,jump,arith,other,load,store,move,smpy,dmpy,return,pload,pstore,pcload,rte,sfunc,call\"\n   (const_string \"other\"))\n \n ; If a conditional branch destination is within -252..258 bytes away\n@@ -122,6 +134,7 @@\n ;; (define_function_unit {name} {num-units} {n-users} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \n+;; ??? These are probably not correct.\n (define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcload,pload\") 2 2)\n (define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 2 2)\n (define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 3 3)\n@@ -151,18 +164,37 @@\n ;; ??? On the SH3, the rte instruction does not use the stack, so a pop\n ;; instruction can go in the delay slot.\n \n+;; Since a normal return (rts) implicitly uses the PR register,\n+;; we can't allow PR register loads in an rts delay slot.\n+\n (define_delay\n   (eq_attr \"type\" \"return\")\n   [(and (eq_attr \"in_delay_slot\" \"yes\")\n-\t(and (ior (eq_attr \"interrupt_function\" \"no\")\n-\t\t  (eq_attr \"hit_stack\" \"no\"))\n-\t     (ior (eq_attr \"interrupt_function\" \"yes\")\n-\t\t  (eq_attr \"type\" \"!pload\")))) (nil) (nil)])\n+\t(ior (and (eq_attr \"interrupt_function\" \"no\")\n+\t\t  (eq_attr \"type\" \"!pload\"))\n+\t     (and (eq_attr \"interrupt_function\" \"yes\")\n+\t\t  (eq_attr \"hit_stack\" \"no\")))) (nil) (nil)])\n+\n+;; Since a call implicitly uses the PR register, we can't allow\n+;; a PR register store in a jsr delay slot.\n+\n+(define_delay\n+  (ior (eq_attr \"type\" \"call\") (eq_attr \"type\" \"sfunc\"))\n+  [(and (eq_attr \"in_delay_slot\" \"yes\")\n+\t(eq_attr \"type\" \"!pstore\")) (nil) (nil)])\n+\n+;; Say that we have annulled true branches, since this gives smaller and\n+;; faster code when branches are predicted as not taken.\n+\n+;; ??? Branches which are out-of-range actually have two delay slots,\n+;; the first is either always executed or else annulled false, and the\n+;; second is always annulled false.  Handling these differently from\n+;; in range branches would give better code.\n \n (define_delay\n   (and (eq_attr \"type\" \"cbranch\")\n        (eq_attr \"cpu\" \"sh2,sh3\"))\n-  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n+  [(eq_attr \"in_delay_slot\" \"yes\") (const_int 1) (nil)])\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -190,6 +222,8 @@\n ;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n ;; That would still allow reload to create cmpi instructions, but would\n ;; perhaps allow forcing the constant into a register when that is better.\n+;; Probably should use r0 for mem/imm compares, but force constant into a\n+;; register for pseudo/imm compares.\n \n (define_insn \"cmpeqsi_t\"\n   [(set (reg:SI 18) (eq:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,z,r\")\n@@ -250,7 +284,7 @@\n ;; Addition instructions\n ;; -------------------------------------------------------------------------\n \n-;; this should be a define split.\n+;; ??? This should be a define expand.\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -261,7 +295,6 @@\n   \"clrt\\;addc\t%R2,%R0\\;addc\t%S2,%S0\"\n   [(set_attr \"length\" \"6\")])\n \n-\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n@@ -274,6 +307,7 @@\n ;; Subtraction instructions\n ;; -------------------------------------------------------------------------\n \n+;; ??? This should be a define expand.\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -287,7 +321,7 @@\n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"r\")))]\n+\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))]\n   \"\"\n   \"sub\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n@@ -296,7 +330,7 @@\n ;; Division instructions\n ;; -------------------------------------------------------------------------\n \n-;; we take advantage of the library routines which don't clobber as many\n+;; We take advantage of the library routines which don't clobber as many\n ;; registers as a normal function call would.\n \n ;; We must use a pseudo-reg forced to reg 0 in the SET_DEST rather than\n@@ -323,13 +357,13 @@\n   [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n    (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"\"))\n    (set (match_dup 3) (symbol_ref:SI \"__udivsi3\"))\n-   (parallel[(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t  (udiv:SI (reg:SI 4)\n-\t\t\t   (reg:SI 5)))\n-\t     (clobber (reg:SI 18))\n-\t     (clobber (reg:SI 17))\n-\t     (clobber (reg:SI 4))\n-\t     (use (match_dup 3))])]\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (udiv:SI (reg:SI 4)\n+\t\t\t    (reg:SI 5)))\n+\t      (clobber (reg:SI 18))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 3))])]\n   \"\"\n   \"operands[3] = gen_reg_rtx(SImode);\")\n \n@@ -351,15 +385,15 @@\n   [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n    (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"\"))\n    (set (match_dup 3) (symbol_ref:SI \"__sdivsi3\"))\n-   (parallel[(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t  (div:SI (reg:SI 4)\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (div:SI (reg:SI 4)\n \t\t\t   (reg:SI 5)))\n-\t     (clobber (reg:SI 18))\n-\t     (clobber (reg:SI 17))\n-\t     (clobber (reg:SI 1))\n-\t     (clobber (reg:SI 2))\n-\t     (clobber (reg:SI 3))\n-\t     (use (match_dup 3))])]\n+\t      (clobber (reg:SI 18))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 3))\n+\t      (use (match_dup 3))])]\n   \"\"\n   \"operands[3] = gen_reg_rtx(SImode);\")\n \f\n@@ -468,6 +502,8 @@\n     }\n }\")\n \n+;; ??? Why is this disabled?\n+\n (define_insn \"\"\n   [(set (reg:DI 20)\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -476,6 +512,8 @@\n   \"dmuls.l\t%2,%1\"\n   [(set_attr \"type\" \"dmpy\")])\n \n+;; ??? Why is this disabled?\n+\n (define_expand \"mulsidi3\"\n   [(set (reg:DI 20)\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n@@ -485,6 +523,8 @@\n   \"(TARGET_SH2) && 0\"\n   \"\")\n \n+;; ??? Why is this disabled?\n+\n (define_insn \"\"\n   [(set (reg:DI 20)\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -493,6 +533,8 @@\n   \"dmulu.l\t%2,%1\"\n   [(set_attr \"type\" \"dmpy\")])\n \n+;; ??? Why is this disabled?\n+\n (define_expand \"umulsidi3\"\n   [(set (reg:DI 20)\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n@@ -630,7 +672,7 @@\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"M,K\")))]\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"M,K\")))]\n   \"CONST_OK_FOR_K (INTVAL (operands[2]))\"\n   \"@\n \tadd\t%0,%0\n@@ -639,7 +681,7 @@\n (define_insn \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"#\"\n@@ -656,7 +698,7 @@\n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   [(use (reg:SI 0))]\n@@ -667,10 +709,10 @@\n }\")\n \n (define_expand \"ashlsi3\"\n-  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t  (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n   \"\"\n   \"\n {\n@@ -690,12 +732,14 @@\n (define_insn \"ashrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"M\")))\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"M\")))\n    (clobber (reg:SI 18))]\n-  \"INTVAL(operands[2]) == 1\"\n+  \"INTVAL (operands[2]) == 1\"\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; ??? This should be a define expand.\n+\n (define_insn \"ashrsi2_16\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n         (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n@@ -704,6 +748,8 @@\n   \"swap.w\t%1,%0\\;exts.w\t%0,%0\"\n   [(set_attr \"length\" \"4\")])\n \n+;; ??? This should be a define expand.\n+\n (define_insn \"ashrsi2_31\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n         (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -724,7 +770,7 @@\n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI 4)\n \t(ashiftrt:SI (reg:SI 4)\n-\t\t     (match_operand:SI 0 \"immediate_operand\" \"i\")))\n+\t\t     (match_operand:SI 0 \"const_int_operand\" \"i\")))\n    (clobber (reg:SI 18))\n    (clobber (reg:SI 17))\n    (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n@@ -734,10 +780,10 @@\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"ashrsi3\"\n-  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t  (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n   \"\"\n   \"if (expand_ashiftrt (operands)) DONE; else FAIL;\")\n \n@@ -750,28 +796,28 @@\n   \"TARGET_SH3\"\n   \"shld\t%2,%0\")\n \n-;; ??? Only the single bit shift clobbers the T bit.\n+;;  Only the single bit shift clobbers the T bit.\n \n (define_insn \"lshrsi3_m\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"M\")))\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"M\")))\n    (clobber (reg:SI 18))]\n   \"CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr\t%0\")\n \n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"K\")))]\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"K\")))]\n   \"CONST_OK_FOR_K (INTVAL (operands[2]))\n    && ! CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr%O2\t%0\")\n \n (define_insn \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"#\"\n@@ -788,7 +834,7 @@\n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   [(use (reg:SI 0))]\n@@ -799,10 +845,10 @@\n }\")\n \n (define_expand \"lshrsi3\"\n-  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t  (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n   \"\"\n   \"\n {\n@@ -817,6 +863,8 @@\n     FAIL;\n }\")\n \n+;; ??? This should be a define expand.\n+\n (define_insn \"ashldi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n@@ -827,14 +875,15 @@\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"ashldi3\"\n-  [(parallel[(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t  (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:DI 2 \"immediate_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n-\n+  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t\t\t      (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n   \"\"\n   \"{ if (GET_CODE (operands[2]) != CONST_INT\n-\t|| INTVAL (operands[2]) != 1) FAIL;} \")\n+\t || INTVAL (operands[2]) != 1) FAIL;} \")\n+\n+;; ??? This should be a define expand.\n \n (define_insn \"lshrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -846,13 +895,15 @@\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"lshrdi3\"\n-  [(parallel[(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t  (lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n+\t\t   (lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n \t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n   \"{ if (GET_CODE (operands[2]) != CONST_INT\n-\t|| INTVAL (operands[2]) != 1) FAIL;} \")\n+\t || INTVAL (operands[2]) != 1) FAIL;} \")\n+\n+;; ??? This should be a define expand.\n \n (define_insn \"ashrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -864,19 +915,18 @@\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"ashrdi3\"\n-  [(parallel[(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t  (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n+  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n   \"\"\n   \"{ if (GET_CODE (operands[2]) != CONST_INT\n-\t|| INTVAL (operands[2]) != 1) FAIL; } \")\n+\t || INTVAL (operands[2]) != 1) FAIL; } \")\n \f\n ;; -------------------------------------------------------------------------\n ;; Unary arithmetic\n ;; -------------------------------------------------------------------------\n \n-\n (define_insn \"negc\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(neg:SI (plus:SI (reg:SI 18)\n@@ -893,20 +943,19 @@\n \t(neg:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"{\n-   rtx low_src = operand_subword (operands[1], 1, 0, DImode);\n-   rtx high_src = operand_subword (operands[1], 0, 0, DImode);\n-\n-   rtx low_dst = operand_subword (operands[0], 1, 1, DImode);\n-   rtx high_dst = operand_subword (operands[0], 0, 1, DImode);\n+  \"\n+{\n+  rtx low_src = operand_subword (operands[1], 1, 0, DImode);\n+  rtx high_src = operand_subword (operands[1], 0, 0, DImode);\n \n-   emit_insn (gen_clrt ());\n-   emit_insn (gen_negc (low_dst, low_src));\n-   emit_insn (gen_negc (high_dst, high_src));\n-   DONE;\n-   }\n-   \")\n+  rtx low_dst = operand_subword (operands[0], 1, 1, DImode);\n+  rtx high_dst = operand_subword (operands[0], 0, 1, DImode);\n \n+  emit_insn (gen_clrt ());\n+  emit_insn (gen_negc (low_dst, low_src));\n+  emit_insn (gen_negc (high_dst, high_src));\n+  DONE;\n+}\")\n \n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -951,6 +1000,9 @@\n ;; Sign extension instructions\n ;; -------------------------------------------------------------------------\n \n+;; ??? This should be a define expand.\n+;; ??? Or perhaps it should be dropped?\n+\n (define_insn \"extendsidi2\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n@@ -994,12 +1046,13 @@\n \n (define_insn \"push\"\n   [(set (mem:SI (pre_dec:SI (reg:SI 15)))\n-\t(match_operand:SI 0 \"register_operand\" \"r,lx\"))]\n+\t(match_operand:SI 0 \"register_operand\" \"r,l,x\"))]\n   \"\"\n   \"@\n \tmov.l\t%0,@-r15\n+\tsts.l\t%0,@-r15\n \tsts.l\t%0,@-r15\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"type\" \"store,pstore,store\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n (define_insn \"pop\"\n@@ -1016,6 +1069,7 @@\n ;; These two patterns can happen as the result of optimization, when\n ;; comparisons get simplified to a move of zero or 1 into the T reg.\n ;; They don't disappear completely, because the T reg is a fixed hard reg.\n+\n (define_insn \"clrt\"\n   [(set (reg:SI 18) (const_int 0))]\n   \"\"\n@@ -1026,12 +1080,15 @@\n   \"\"\n   \"sett\")\n \n+;; t/z is first, so that it will be preferred over r/r when reloading a move\n+;; of a pseudo-reg into the T reg\n (define_insn \"movsi_i\"\n-  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,m,<,xl,xl,t,r\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,m,xl,t,r,xl,r,>,z,i\"))]\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=t,r,r,r,r,r,m,<,xl,xl,r\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"z,Q,rI,m,xl,t,r,xl,r,>,i\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"@\n+\ttst\t%1,%1\\;rotcl\t%1\\;xor\t#1,%1\\;rotcr\t%1\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n@@ -1041,18 +1098,15 @@\n \tsts.l\t%1,%0\n \tlds\t%1,%0\n \tlds.l\t%1,%0\n-\ttst\t%1,%1\\;rotcl\t%1\\;xor\t#1,%1\\;rotcr\t%1\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload,move,load,move,store,store,move,load,move,move,move\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,8,*\")])\n+  [(set_attr \"type\" \"move,pcload,move,load,move,store,store,move,load,move,move\")\n+   (set_attr \"length\" \"8,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-\n-  \"{ if (prepare_move_operands(operands, SImode)) DONE; } \")\n-\n+  \"{ if (prepare_move_operands (operands, SImode)) DONE; }\")\n \n (define_insn \"movqi_i\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,r,l\")\n@@ -1072,7 +1126,7 @@\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\"  \"\"))]\n   \"\"\n-  \"if (prepare_move_operands(operands, QImode)) DONE; \")\n+  \"{ if (prepare_move_operands (operands, QImode)) DONE; }\")\n \n (define_insn \"movhi_i\"\n   [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,m,r,l,r\")\n@@ -1094,7 +1148,9 @@\n   [(set (match_operand:HI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:HI 1 \"general_movsrc_operand\"  \"\"))]\n   \"\"\n-  \"if (prepare_move_operands (operands, HImode)) DONE;\")\n+  \"{ if (prepare_move_operands (operands, HImode)) DONE; }\")\n+\n+;; ??? This should be a define expand.\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,m,r\")\n@@ -1151,12 +1207,13 @@\n     FAIL;\n }\")\n \n-\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DI 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-  \"if ( prepare_move_operands(operands, DImode)) DONE; \")\n+  \"{ if ( prepare_move_operands (operands, DImode)) DONE; }\")\n+\n+;; ??? This should be a define expand.\n \n (define_insn \"movdf_k\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,m\")\n@@ -1173,7 +1230,7 @@\n (define_split\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n- \"! (GET_CODE (operands[0]) == REG\n+  \"! (GET_CODE (operands[0]) == REG\n      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n    && ! (GET_CODE (operands[1]) == REG\n          && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n@@ -1213,7 +1270,7 @@\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n- \"{ if (prepare_move_operands(operands, DFmode)) DONE; } \")\n+  \"{ if (prepare_move_operands (operands, DFmode)) DONE; }\")\n \n (define_insn \"movsf_i\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r,r,m,l,r\")\n@@ -1233,7 +1290,7 @@\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:SF 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-  \"if (prepare_move_operands (operands, SFmode)) DONE;\")\n+  \"{ if (prepare_move_operands (operands, SFmode)) DONE; }\")\n \f\n ;; ------------------------------------------------------------------------\n ;; Define the real conditional branch instructions.\n@@ -1276,8 +1333,7 @@\n (define_expand \"beq\"\n   [(set (reg:SI 18) (eq:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -1288,8 +1344,7 @@\n (define_expand \"bne\"\n   [(set (reg:SI 18) (eq:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n@@ -1298,17 +1353,16 @@\n (define_expand \"bgt\"\n   [(set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc))) ]\n+\t\t      (pc)))]\n   \"\"\n   \"from_compare (operands, GT);\")\n \n (define_expand \"blt\"\n   [(set (reg:SI 18) (ge:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)(const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n@@ -1317,29 +1371,25 @@\n (define_expand \"ble\"\n   [(set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-   ]\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n   \"from_compare (operands, LE);\")\n \n (define_expand \"bge\"\n   [(set (reg:SI 18) (ge:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc))) ]\n+\t\t      (pc)))]\n   \"\"\n   \"from_compare (operands, GE);\")\n \n (define_expand \"bgtu\"\n   [(set (reg:SI 18) (gtu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -1348,8 +1398,7 @@\n (define_expand \"bltu\"\n   [(set (reg:SI 18) (geu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t\t  (if_then_else (eq (reg:SI 18)\n-\t\t\t\t    (const_int 1))\n+\t\t  (if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t\t\t(pc)\n \t\t\t\t(label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n@@ -1358,19 +1407,16 @@\n (define_expand \"bgeu\"\n   [(set (reg:SI 18) (geu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n+\t\t      (pc)))]\n   \"\"\n   \"from_compare (operands, GEU);\")\n \n (define_expand \"bleu\"\n   [(set (reg:SI 18) (gtu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n+\t(if_then_else (eq (reg:SI 18) (const_int 1))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n@@ -1401,7 +1447,8 @@\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%0%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")])\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"call_valuei\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -1410,7 +1457,8 @@\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%1%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")])\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand 0 \"arith_reg_operand\" \"\"))\n@@ -1443,13 +1491,12 @@\n ;; defined.  Perhaps use a pseudo-reg for the T bit?\n \n (define_insn \"dect\"\n-  [(parallel[\n-\t     (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t\t  (plus:SI (match_dup 0)\n-\t\t\t   (const_int -1)))\n-\t     (set (reg:SI 18)\n-\t\t  (eq:SI (plus:SI (match_dup 0) (const_int -1))\n-\t\t\t (const_int 0)))])]\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))\n+\t      (set (reg:SI 18)\n+\t\t   (eq:SI (plus:SI (match_dup 0) (const_int -1))\n+\t\t\t  (const_int 0)))])]\n   \"TARGET_SH2\"\n   \"dt\t%0\")\n \n@@ -1493,10 +1540,10 @@\n    (set (match_dup 6) (match_dup 5))\n    (set (match_dup 6) (ashift:SI (match_dup 6) (match_dup 7)))\n    (set (reg:SI 0) (unspec [(label_ref (match_operand 3 \"\" \"\"))] 1))\n-   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n-\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n-\t\t\t\t\t\t       (match_dup 6)))))\n-\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n+   (parallel [(set (reg:SI 0) (plus:SI (reg:SI 0)\n+\t\t\t\t       (mem:HI (plus:SI (reg:SI 0)\n+\t\t\t\t\t\t\t(match_dup 6)))))\n+\t      (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n    (set (pc) (reg:SI 0))]\n   \"\"\n   \"\n@@ -1517,10 +1564,12 @@\n \t\t\t\t       (match_dup 0))))]\n   \"\"\n   \"*\n-\tif (TARGET_BIGTABLE)\n-\t\treturn \\\"mov.l\t@(r0,%0),%0\\;add\t%0,r0\\\";\n-\telse\n-\t   \treturn \\\"mov.w\t@(r0,%0),%0\\;add\t%0,r0\\\";\"\n+{\n+  if (TARGET_BIGTABLE)\n+    return \\\"mov.l\t@(r0,%0),%0\\;add\t%0,r0\\\";\n+  else\n+    return \\\"mov.w\t@(r0,%0),%0\\;add\t%0,r0\\\";\n+}\"\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"return\""}]}