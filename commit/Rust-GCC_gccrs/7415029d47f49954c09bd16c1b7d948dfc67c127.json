{"sha": "7415029d47f49954c09bd16c1b7d948dfc67c127", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQxNTAyOWQ0N2Y0OTk1NGMwOWJkMTZjMWI3ZDk0OGRmYzY3YzEyNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T09:08:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T09:08:47Z"}, "message": "[multiple changes]\n\n2010-06-14  Gary Dismukes  <dismukes@adacore.com>\n\n\t* gnat_ugn.texi: Minor typo fixes and wording changes\n\n2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_One_Call): If the call has been rewritten from a\n\tprefixed form, do not re-analyze first actual, which may need an\n\timplicit dereference.\n\t* sem_ch6.adb (Analyze_Procedure_Call): If the call is given in\n\tprefixed notation, the analysis will rewrite the node, and possible\n\terrors appear in the rewritten name of the node.\n\t* sem_res.adb: If a call is ambiguous because its first parameter is\n\tan overloaded call, report list of candidates, to clarify ambiguity of\n\tenclosing call.\n\n2010-06-14  Doug Rupp  <rupp@adacore.com>\n\n\t* s-auxdec-vms-alpha.adb: New package body implementing legacy\n\tVAX instructions with Asm insertions.\n\t* s-auxdec-vms_64.ads: Inline VAX queue functions\n\t* s-stoele.adb: Resolve some ambiguities in To_Addresss with s-suxdec\n\tthat show up only on VMS.\n\t* gcc-interface/Makefile.in: Provide translation for\n\ts-auxdec-vms-alpha.adb.\n\nFrom-SVN: r160713", "tree": {"sha": "7533ca962b0638d68e7eb2368c9936ccf713fd76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7533ca962b0638d68e7eb2368c9936ccf713fd76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7415029d47f49954c09bd16c1b7d948dfc67c127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7415029d47f49954c09bd16c1b7d948dfc67c127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7415029d47f49954c09bd16c1b7d948dfc67c127", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7415029d47f49954c09bd16c1b7d948dfc67c127/comments", "author": null, "committer": null, "parents": [{"sha": "45c9edf6f2e00eac7b68c7844470a31c01481e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c9edf6f2e00eac7b68c7844470a31c01481e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c9edf6f2e00eac7b68c7844470a31c01481e19"}], "stats": {"total": 1207, "additions": 1180, "deletions": 27}, "files": [{"sha": "6f7d87c60301e506cc2dfc676ff1ac4a6fc777d6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -1,3 +1,29 @@\n+2010-06-14  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor typo fixes and wording changes\n+\n+2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_One_Call): If the call has been rewritten from a\n+\tprefixed form, do not re-analyze first actual, which may need an\n+\timplicit dereference.\n+\t* sem_ch6.adb (Analyze_Procedure_Call): If the call is given in\n+\tprefixed notation, the analysis will rewrite the node, and possible\n+\terrors appear in the rewritten name of the node.\n+\t* sem_res.adb: If a call is ambiguous because its first parameter is\n+\tan overloaded call, report list of candidates, to clarify ambiguity of\n+\tenclosing call.\n+\n+2010-06-14  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-auxdec-vms-alpha.adb: New package body implementing legacy\n+\tVAX instructions with Asm insertions.\n+\t* s-auxdec-vms_64.ads: Inline VAX queue functions\n+\t* s-stoele.adb: Resolve some ambiguities in To_Addresss with s-suxdec\n+\tthat show up only on VMS.\n+\t* gcc-interface/Makefile.in: Provide translation for\n+\ts-auxdec-vms-alpha.adb.\n+\n 2010-06-14  Olivier Hainque  <hainque@adacore.com>\n \n \t* initialize.c (VxWorks section): Update comments."}, {"sha": "0e5692ee0b253cd93ebbda7bf50c9d1b7c71584e", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -391,6 +391,26 @@ DUMMY_SOCKETS_TARGET_PAIRS = \\\n   g-sothco.ads<g-sothco-dummy.ads \\\n   g-sttsne.ads<g-sttsne-dummy.ads\n \n+# On platform where atomic increment/decrement operations are supported\n+# special version of Ada.Strings.Unbounded package can be used.\n+\n+ATOMICS_TARGET_PAIRS += \\\n+  a-stunau.adb<a-stunau-shared.adb \\\n+  a-suteio.adb<a-suteio-shared.adb \\\n+  a-strunb.ads<a-strunb-shared.ads \\\n+  a-strunb.adb<a-strunb-shared.adb \\\n+  a-stwiun.adb<a-stwiun-shared.adb \\\n+  a-stwiun.ads<a-stwiun-shared.ads \\\n+  a-swunau.adb<a-swunau-shared.adb \\\n+  a-swuwti.adb<a-swuwti-shared.adb \\\n+  a-stzunb.adb<a-stzunb-shared.adb \\\n+  a-stzunb.ads<a-stzunb-shared.ads \\\n+  a-szunau.adb<a-szunau-shared.adb \\\n+  a-szuzti.adb<a-szuzti-shared.adb\n+\n+# Reset setting for now\n+ATOMICS_TARGET_PAIRS =\n+\n LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)ada/gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n \n # $(filter-out PATTERN...,TEXT) removes all PATTERN words from TEXT.\n@@ -468,7 +488,8 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   g-sttsne.adb<g-sttsne-vxworks.adb \\\n   g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n-  g-trasym.adb<g-trasym-unimplemented.adb\n+  g-trasym.adb<g-trasym-unimplemented.adb \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS=\\\n   mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n@@ -563,7 +584,8 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   s-vxwork.ads<s-vxwork-ppc.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n-  system.ads<system-vxworks-ppc-vthread.ads\n+  system.ads<system-vxworks-ppc-vthread.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS=\\\n   mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n@@ -627,6 +649,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksmils,$(targ))),)\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   system.ads<system-vxworks-ppc.ads \\\n+  $(ATOMICS_TARGET_PAIRS) \\\n   $(DUMMY_SOCKETS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS=\\\n@@ -949,7 +972,8 @@ ifeq ($(strip $(filter-out sparc% sun solaris%,$(targ))),)\n   system.ads<system-solaris-sparc.ads\n \n   LIBGNAT_TARGET_PAIRS_64 = \\\n-  system.ads<system-solaris-sparcv9.ads\n+  system.ads<system-solaris-sparcv9.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n     ifeq ($(strip $(MULTISUBDIR)),/sparcv9)\n@@ -1334,7 +1358,8 @@ ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n   s-osprim.adb<s-osprim-posix.adb \\\n   s-taprop.adb<s-taprop-posix.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix.adb\n+  s-tpopsp.adb<s-tpopsp-posix.adb \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   LIBGNAT_TARGET_PAIRS_32 = \\\n   system.ads<system-aix.ads\n@@ -1440,7 +1465,8 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n   s-taspri.ads<s-taspri-tru64.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-traceb.adb<s-traceb-mastop.adb \\\n-  system.ads<system-tru64.ads\n+  system.ads<system-tru64.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-tru64.adb\n \n@@ -1478,12 +1504,14 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n       system.ads<system-vms-ia64.ads\n \n     LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-      s-parame.ads<s-parame-vms-ia64.ads\n+      s-parame.ads<s-parame-vms-ia64.ads \\\n+      $(ATOMICS_TARGET_PAIRS)\n   else\n     ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n       LIBGNAT_TARGET_PAIRS_AUX1 = \\\n         g-enblsp.adb<g-enblsp-vms-alpha.adb \\\n         g-trasym.adb<g-trasym-vms-alpha.adb \\\n+        s-auxdec.adb<s-auxdec-vms-alpha.adb \\\n         s-traent.adb<s-traent-vms.adb \\\n         s-traent.ads<s-traent-vms.ads \\\n         s-asthan.adb<s-asthan-vms-alpha.adb \\\n@@ -1497,7 +1525,8 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n           s-parame.ads<s-parame-vms-restrict.ads\n       else\n         LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-          s-parame.ads<s-parame-vms-alpha.ads\n+          s-parame.ads<s-parame-vms-alpha.ads \\\n+          $(ATOMICS_TARGET_PAIRS)\n       endif\n     endif\n   endif\n@@ -1797,7 +1826,8 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n   s-tasinf.adb<s-tasinf-linux.adb \\\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  g-sercom.adb<g-sercom-linux.adb\n+  g-sercom.adb<g-sercom-linux.adb \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   LIBGNAT_TARGET_PAIRS_32 = \\\n   system.ads<system-linux-ppc.ads\n@@ -1996,7 +2026,8 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n   g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-ia64.ads\n+  system.ads<system-linux-ia64.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS =  \\\n     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n@@ -2022,7 +2053,8 @@ ifeq ($(strip $(filter-out ia64% hp hpux%,$(targ))),)\n   s-taprop.adb<s-taprop-posix.adb \\\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-hpux-ia64.ads\n+  system.ads<system-hpux-ia64.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS = \\\n   mlib-tgt-specific.adb<mlib-tgt-specific-ia64-hpux.adb\n@@ -2052,7 +2084,8 @@ ifeq ($(strip $(filter-out alpha% linux%,$(arch) $(osys))),)\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n-  system.ads<system-linux-alpha.ads\n+  system.ads<system-linux-alpha.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS =  \\\n     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n@@ -2083,7 +2116,8 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-x86_64.ads\n+  system.ads<system-linux-x86_64.ads \\\n+  $(ATOMICS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS =  \\\n     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n@@ -2138,7 +2172,8 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n     a-numaux.adb<a-numaux-x86.adb \\\n     g-trasym.ads<g-trasym-unimplemented.ads \\\n     g-trasym.adb<g-trasym-unimplemented.adb \\\n-    system.ads<system-darwin-x86_64.ads\n+    system.ads<system-darwin-x86_64.ads \\\n+    $(ATOMICS_TARGET_PAIRS)\n   endif\n \n   ifeq ($(strip $(filter-out powerpc%,$(arch))),)"}, {"sha": "801d87bf959d662ae8b5d87e815285ac91c545c8", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -16675,9 +16675,9 @@ The additional @command{gnatpp} switches are defined in this subsection.\n @item ^-files @var{filename}^/FILES=@var{output_file}^\n @cindex @option{^-files^/FILES^} (@code{gnatpp})\n Take the argument source files from the specified file. This file should be an\n-ordinary textual file containing file names separated by spaces or\n-line breaks. You can use this switch more then once in the same call to\n-@command{gnatpp}. You also can combine this switch with explicit list of\n+ordinary text file containing file names separated by spaces or\n+line breaks. You can use this switch more than once in the same call to\n+@command{gnatpp}. You also can combine this switch with an explicit list of\n files.\n \n @item ^-v^/VERBOSE^\n@@ -17358,7 +17358,7 @@ Do not generate the output in text form (implies @option{^-x^/XML^})\n \n @cindex @option{^-d^/DIRECTORY^} (@command{gnatmetric})\n @item ^-d @var{output_dir}^/DIRECTORY=@var{output_dir}^\n-Put textual files with detailed metrics into @var{output_dir}\n+Put text files with detailed metrics into @var{output_dir}\n \n @cindex @option{^-o^/SUFFIX_DETAILS^} (@command{gnatmetric})\n @item ^-o @var{file_suffix}^/SUFFIX_DETAILS=@var{file_suffix}^\n@@ -17935,7 +17935,7 @@ Additional @command{gnatmetric} switches are as follows:\n @cindex @option{^-files^/FILES^} (@code{gnatmetric})\n Take the argument source files from the specified file. This file should be an\n ordinary text file containing file names separated by spaces or\n-line breaks. You can use this switch more then once in the same call to\n+line breaks. You can use this switch more than once in the same call to\n @command{gnatmetric}. You also can combine this switch with\n an explicit list of files.\n "}, {"sha": "c03522699d7e32591cdbc6dc5e9eb833175ff128", "filename": "gcc/ada/s-auxdec-vms-alpha.adb", "status": "added", "additions": 1015, "deletions": 0, "changes": 1015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-auxdec-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-auxdec-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms-alpha.adb?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -0,0 +1,1015 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . A U X _ D E C                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/Or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off alpha ordering check on subprograms, this unit is laid\n+--  out to correspond to the declarations in the DEC 83 System unit.\n+\n+with System.Machine_Code; use System.Machine_Code;\n+package body System.Aux_DEC is\n+\n+   -----------------------------------\n+   -- Operations on Largest_Integer --\n+   -----------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type LIU is mod 2 ** Largest_Integer'Size;\n+   --  Unsigned type of same length as Largest_Integer\n+\n+   function To_LI   is new Ada.Unchecked_Conversion (LIU, Largest_Integer);\n+   function From_LI is new Ada.Unchecked_Conversion (Largest_Integer, LIU);\n+\n+   function \"not\" (Left : Largest_Integer) return Largest_Integer is\n+   begin\n+      return To_LI (not From_LI (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Largest_Integer) return Largest_Integer is\n+   begin\n+      return To_LI (From_LI (Left) and From_LI (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Largest_Integer) return Largest_Integer is\n+   begin\n+      return To_LI (From_LI (Left) or From_LI (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Largest_Integer) return Largest_Integer is\n+   begin\n+      return To_LI (From_LI (Left) xor From_LI (Right));\n+   end \"xor\";\n+\n+   --------------------------------------\n+   -- Arithmetic Operations on Address --\n+   --------------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   Asiz : constant Integer := Integer (Address'Size) - 1;\n+\n+   type SA is range -(2 ** Asiz) .. 2 ** Asiz - 1;\n+   --  Signed type of same size as Address\n+\n+   function To_A   is new Ada.Unchecked_Conversion (SA, Address);\n+   function From_A is new Ada.Unchecked_Conversion (Address, SA);\n+\n+   function \"+\" (Left : Address; Right : Integer) return Address is\n+   begin\n+      return To_A (From_A (Left) + SA (Right));\n+   end \"+\";\n+\n+   function \"+\" (Left : Integer; Right : Address) return Address is\n+   begin\n+      return To_A (SA (Left) + From_A (Right));\n+   end \"+\";\n+\n+   function \"-\" (Left : Address; Right : Address) return Integer is\n+      pragma Unsuppress (All_Checks);\n+      --  Because this can raise Constraint_Error for 64-bit addresses\n+   begin\n+      return Integer (From_A (Left) - From_A (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left : Address; Right : Integer) return Address is\n+   begin\n+      return To_A (From_A (Left) - SA (Right));\n+   end \"-\";\n+\n+   ------------------------\n+   -- Fetch_From_Address --\n+   ------------------------\n+\n+   function Fetch_From_Address (A : Address) return Target is\n+      type T_Ptr is access all Target;\n+      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n+      Ptr : constant T_Ptr := To_T_Ptr (A);\n+   begin\n+      return Ptr.all;\n+   end Fetch_From_Address;\n+\n+   -----------------------\n+   -- Assign_To_Address --\n+   -----------------------\n+\n+   procedure Assign_To_Address (A : Address; T : Target) is\n+      type T_Ptr is access all Target;\n+      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n+      Ptr : constant T_Ptr := To_T_Ptr (A);\n+   begin\n+      Ptr.all := T;\n+   end Assign_To_Address;\n+\n+   ---------------------------------\n+   -- Operations on Unsigned_Byte --\n+   ---------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type BU is mod 2 ** Unsigned_Byte'Size;\n+   --  Unsigned type of same length as Unsigned_Byte\n+\n+   function To_B   is new Ada.Unchecked_Conversion (BU, Unsigned_Byte);\n+   function From_B is new Ada.Unchecked_Conversion (Unsigned_Byte, BU);\n+\n+   function \"not\" (Left : Unsigned_Byte) return Unsigned_Byte is\n+   begin\n+      return To_B (not From_B (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Unsigned_Byte) return Unsigned_Byte is\n+   begin\n+      return To_B (From_B (Left) and From_B (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Unsigned_Byte) return Unsigned_Byte is\n+   begin\n+      return To_B (From_B (Left) or From_B (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Unsigned_Byte) return Unsigned_Byte is\n+   begin\n+      return To_B (From_B (Left) xor From_B (Right));\n+   end \"xor\";\n+\n+   ---------------------------------\n+   -- Operations on Unsigned_Word --\n+   ---------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type WU is mod 2 ** Unsigned_Word'Size;\n+   --  Unsigned type of same length as Unsigned_Word\n+\n+   function To_W   is new Ada.Unchecked_Conversion (WU, Unsigned_Word);\n+   function From_W is new Ada.Unchecked_Conversion (Unsigned_Word, WU);\n+\n+   function \"not\" (Left : Unsigned_Word) return Unsigned_Word is\n+   begin\n+      return To_W (not From_W (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Unsigned_Word) return Unsigned_Word is\n+   begin\n+      return To_W (From_W (Left) and From_W (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Unsigned_Word) return Unsigned_Word is\n+   begin\n+      return To_W (From_W (Left) or From_W (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Unsigned_Word) return Unsigned_Word is\n+   begin\n+      return To_W (From_W (Left) xor From_W (Right));\n+   end \"xor\";\n+\n+   -------------------------------------\n+   -- Operations on Unsigned_Longword --\n+   -------------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type LWU is mod 2 ** Unsigned_Longword'Size;\n+   --  Unsigned type of same length as Unsigned_Longword\n+\n+   function To_LW   is new Ada.Unchecked_Conversion (LWU, Unsigned_Longword);\n+   function From_LW is new Ada.Unchecked_Conversion (Unsigned_Longword, LWU);\n+\n+   function \"not\" (Left : Unsigned_Longword) return Unsigned_Longword is\n+   begin\n+      return To_LW (not From_LW (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Unsigned_Longword) return Unsigned_Longword is\n+   begin\n+      return To_LW (From_LW (Left) and From_LW (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Unsigned_Longword) return Unsigned_Longword is\n+   begin\n+      return To_LW (From_LW (Left) or From_LW (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Unsigned_Longword) return Unsigned_Longword is\n+   begin\n+      return To_LW (From_LW (Left) xor From_LW (Right));\n+   end \"xor\";\n+\n+   -------------------------------\n+   -- Operations on Unsigned_32 --\n+   -------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type U32 is mod 2 ** Unsigned_32'Size;\n+   --  Unsigned type of same length as Unsigned_32\n+\n+   function To_U32   is new Ada.Unchecked_Conversion (U32, Unsigned_32);\n+   function From_U32 is new Ada.Unchecked_Conversion (Unsigned_32, U32);\n+\n+   function \"not\" (Left : Unsigned_32) return Unsigned_32 is\n+   begin\n+      return To_U32 (not From_U32 (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Unsigned_32) return Unsigned_32 is\n+   begin\n+      return To_U32 (From_U32 (Left) and From_U32 (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Unsigned_32) return Unsigned_32 is\n+   begin\n+      return To_U32 (From_U32 (Left) or From_U32 (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Unsigned_32) return Unsigned_32 is\n+   begin\n+      return To_U32 (From_U32 (Left) xor From_U32 (Right));\n+   end \"xor\";\n+\n+   -------------------------------------\n+   -- Operations on Unsigned_Quadword --\n+   -------------------------------------\n+\n+   --  It would be nice to replace these with intrinsics, but that does\n+   --  not work yet (the back end would be ok, but GNAT itself objects)\n+\n+   type QWU is mod 2 ** 64;  -- 64 = Unsigned_Quadword'Size\n+   --  Unsigned type of same length as Unsigned_Quadword\n+\n+   function To_QW   is new Ada.Unchecked_Conversion (QWU, Unsigned_Quadword);\n+   function From_QW is new Ada.Unchecked_Conversion (Unsigned_Quadword, QWU);\n+\n+   function \"not\" (Left : Unsigned_Quadword) return Unsigned_Quadword is\n+   begin\n+      return To_QW (not From_QW (Left));\n+   end \"not\";\n+\n+   function \"and\" (Left, Right : Unsigned_Quadword) return Unsigned_Quadword is\n+   begin\n+      return To_QW (From_QW (Left) and From_QW (Right));\n+   end \"and\";\n+\n+   function \"or\"  (Left, Right : Unsigned_Quadword) return Unsigned_Quadword is\n+   begin\n+      return To_QW (From_QW (Left) or From_QW (Right));\n+   end \"or\";\n+\n+   function \"xor\" (Left, Right : Unsigned_Quadword) return Unsigned_Quadword is\n+   begin\n+      return To_QW (From_QW (Left) xor From_QW (Right));\n+   end \"xor\";\n+\n+   -----------------------\n+   -- Clear_Interlocked --\n+   -----------------------\n+\n+   procedure Clear_Interlocked\n+     (Bit       : in out Boolean;\n+      Old_Value : out Boolean)\n+   is\n+      use ASCII;\n+      Clr_Bit : Boolean := Bit;\n+      Old_Bit : Boolean;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"lda $16, %2\"      & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"sll $16, 3, $17 \" & LF & HT &\n+         \"bis $31, 1, $1\"   & LF & HT &\n+         \"and $17, 63, $18\" & LF & HT &\n+         \"bic $17, 63, $17\" & LF & HT &\n+         \"sra $17, 3, $17\"  & LF & HT &\n+         \"bis $31, 1, %1\"   & LF & HT &\n+         \"sll %1, $18, $18\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l $1, 0($17)\" & LF & HT &\n+         \"and $1, $18, %1\"  & LF & HT &\n+         \"bic $1, $18, $1\"  & LF & HT &\n+         \"stq_c $1, 0($17)\" & LF & HT &\n+         \"cmpeq %1, 0, %1\"  & LF & HT &\n+         \"beq $1, 1b\"       & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"xor %1, 1, %1\"    & LF & HT &\n+         \"trapb\",\n+         Outputs => (Boolean'Asm_Output (\"=m\", Clr_Bit),\n+                     Boolean'Asm_Output (\"=r\", Old_Bit)),\n+         Inputs => Boolean'Asm_Input (\"m\", Clr_Bit),\n+         Clobber => \"$1, $16, $17, $18\",\n+         Volatile => True);\n+\n+         Bit := Clr_Bit;\n+         Old_Value := Old_Bit;\n+   end Clear_Interlocked;\n+\n+   procedure Clear_Interlocked\n+     (Bit          : in out Boolean;\n+      Old_Value    : out Boolean;\n+      Retry_Count  : Natural;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+      Clr_Bit : Boolean := Bit;\n+      Succ, Old_Bit : Boolean;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"lda $16, %3\"      & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"sll $16, 3, $18 \" & LF & HT &\n+         \"bis $31, 1, %1\"   & LF & HT &\n+         \"and $18, 63, $19\" & LF & HT &\n+         \"bic $18, 63, $18\" & LF & HT &\n+         \"sra $18, 3, $18\"  & LF & HT &\n+         \"bis $31, %4, $17\" & LF & HT &\n+         \"sll %1, $19, $19\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l %2, 0($18)\" & LF & HT &\n+         \"and %2, $19, %1\"  & LF & HT &\n+         \"bic %2, $19, %2\"  & LF & HT &\n+         \"stq_c %2, 0($18)\" & LF & HT &\n+         \"beq %2, 2f\"       & LF & HT &\n+         \"cmpeq %1, 0, %1\"  & LF & HT &\n+         \"br 3f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"xor %1, 1, %1\"    & LF & HT &\n+         \"trapb\",\n+         Outputs => (Boolean'Asm_Output (\"=m\", Clr_Bit),\n+                     Boolean'Asm_Output (\"=r\", Old_Bit),\n+                     Boolean'Asm_Output (\"=r\", Succ)),\n+         Inputs => (Boolean'Asm_Input (\"m\", Clr_Bit),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$16, $17, $18, $19\",\n+         Volatile => True);\n+\n+         Bit := Clr_Bit;\n+         Old_Value := Old_Bit;\n+         Success_Flag := Succ;\n+   end Clear_Interlocked;\n+\n+   ---------------------\n+   -- Set_Interlocked --\n+   ---------------------\n+\n+   procedure Set_Interlocked\n+     (Bit       : in out Boolean;\n+      Old_Value : out Boolean)\n+   is\n+      use ASCII;\n+      Set_Bit : Boolean := Bit;\n+      Old_Bit : Boolean;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"lda $16, %2\"      & LF & HT &\n+         \"sll $16, 3, $17 \" & LF & HT &\n+         \"bis $31, 1, $1\"   & LF & HT &\n+         \"and $17, 63, $18\" & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"bic $17, 63, $17\" & LF & HT &\n+         \"sra $17, 3, $17\"  & LF & HT &\n+         \"bis $31, 1, %1\"   & LF & HT &\n+         \"sll %1, $18, $18\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l $1, 0($17)\" & LF & HT &\n+         \"and $1, $18, %1\"  & LF & HT &\n+         \"bis $1, $18, $1\"  & LF & HT &\n+         \"stq_c $1, 0($17)\" & LF & HT &\n+         \"cmovne %1, 1, %1\" & LF & HT &\n+         \"beq $1, 1b\"       & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"trapb\",\n+         Outputs => (Boolean'Asm_Output (\"=m\", Set_Bit),\n+                     Boolean'Asm_Output (\"=r\", Old_Bit)),\n+         Inputs => Boolean'Asm_Input (\"m\", Set_Bit),\n+         Clobber => \"$1, $16, $17, $18\",\n+         Volatile => True);\n+\n+         Bit := Set_Bit;\n+         Old_Value := Old_Bit;\n+   end Set_Interlocked;\n+\n+   procedure Set_Interlocked\n+     (Bit          : in out Boolean;\n+      Old_Value    : out Boolean;\n+      Retry_Count  : Natural;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+      Set_Bit : Boolean := Bit;\n+      Succ, Old_Bit : Boolean;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"lda $16, %3\"      & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"sll $16, 3, $18 \" & LF & HT &\n+         \"bis $31, 1, %1\"   & LF & HT &\n+         \"and $18, 63, $19\" & LF & HT &\n+         \"bic $18, 63, $18\" & LF & HT &\n+         \"sra $18, 3, $18\"  & LF & HT &\n+         \"bis $31, %4, $17\" & LF & HT &\n+         \"sll %1, $19, $19\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l %2, 0($18)\" & LF & HT &\n+         \"and %2, $19, %1\"  & LF & HT &\n+         \"bis %2, $19, %2\"  & LF & HT &\n+         \"stq_c %2, 0($18)\" & LF & HT &\n+         \"beq %2, 2f\"       & LF & HT &\n+         \"cmovne %1, 1, %1\" & LF & HT &\n+         \"br 3f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"trapb\",\n+         Outputs => (Boolean'Asm_Output (\"=m\", Set_Bit),\n+                     Boolean'Asm_Output (\"=r\", Old_Bit),\n+                     Boolean'Asm_Output (\"=r\", Succ)),\n+         Inputs => (Boolean'Asm_Input (\"m\", Set_Bit),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$16, $17, $18, $19\",\n+         Volatile => True);\n+\n+         Bit := Set_Bit;\n+         Old_Value := Old_Bit;\n+         Success_Flag := Succ;\n+   end Set_Interlocked;\n+\n+   ---------------------\n+   -- Add_Interlocked --\n+   ---------------------\n+\n+   procedure Add_Interlocked\n+     (Addend : Short_Integer;\n+      Augend : in out Aligned_Word;\n+      Sign   : out Integer)\n+   is\n+      use ASCII;\n+      Overflowed : Boolean := False;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"lda $18, %0\"         & LF & HT &\n+         \"bic $18, 6, $21\"     & LF & HT &\n+         \"mb\"                  & LF & HT &\n+         \"1:\"                  & LF & HT &\n+         \"ldq_l $0, 0($21)\"    & LF & HT &\n+         \"extwl $0, $18, $19\"  & LF & HT &\n+         \"mskwl $0, $18, $0\"   & LF & HT &\n+         \"addq $19, %3, $20\"   & LF & HT &\n+         \"inswl $20, $18, $17\" & LF & HT &\n+         \"xor $19, %3, $19\"    & LF & HT &\n+         \"bis $17, $0, $0\"     & LF & HT &\n+         \"stq_c $0, 0($21)\"    & LF & HT &\n+         \"beq $0, 1b\"          & LF & HT &\n+         \"srl $20, 16, $0\"     & LF & HT &\n+         \"mb\"                  & LF & HT &\n+         \"srl $20, 12, $21\"    & LF & HT &\n+         \"zapnot $20, 3, $20\"  & LF & HT &\n+         \"and $0, 1, $0\"       & LF & HT &\n+         \"and $21, 8, $21\"     & LF & HT &\n+         \"bis $21, $0, $0\"     & LF & HT &\n+         \"cmpeq $20, 0, $21\"   & LF & HT &\n+         \"xor $20, 2, $20\"     & LF & HT &\n+         \"sll $21, 2, $21\"     & LF & HT &\n+         \"bis $21, $0, $0\"     & LF & HT &\n+         \"bic $20, $19, $21\"   & LF & HT &\n+         \"srl $21, 14, $21\"    & LF & HT &\n+         \"and $21, 2, $21\"     & LF & HT &\n+         \"bis $21, $0, $0\"     & LF & HT &\n+         \"and $0, 2, %2\"       & LF & HT &\n+         \"bne %2, 2f\"          & LF & HT &\n+         \"and $0, 4, %1\"       & LF & HT &\n+         \"cmpeq %1, 0, %1\"     & LF & HT &\n+         \"and $0, 8, $0\"       & LF & HT &\n+         \"lda $16, -1\"         & LF & HT &\n+         \"cmovne $0, $16, %1\"  & LF & HT &\n+         \"2:\",\n+         Outputs => (Aligned_Word'Asm_Output (\"=m\", Augend),\n+                     Integer'Asm_Output (\"=r\", Sign),\n+                     Boolean'Asm_Output (\"=r\", Overflowed)),\n+         Inputs => (Short_Integer'Asm_Input (\"r\", Addend),\n+                    Aligned_Word'Asm_Input (\"m\", Augend)),\n+         Clobber => \"$0, $1, $16, $17, $18, $19, $20, $21\",\n+         Volatile => True);\n+\n+         if Overflowed then\n+            raise Constraint_Error;\n+         end if;\n+   end Add_Interlocked;\n+\n+   ----------------\n+   -- Add_Atomic --\n+   ----------------\n+\n+   procedure Add_Atomic\n+     (To     : in out Aligned_Integer;\n+      Amount : Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"              & LF & HT &\n+         \"1:\"              & LF & HT &\n+         \"ldl_l $1, %0\"    & LF & HT &\n+         \"addl $1, %2, $0\" & LF & HT &\n+         \"stl_c $0, %1\"    & LF & HT &\n+         \"beq $0, 1b\"      & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", Amount)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To           : in out Aligned_Integer;\n+      Amount       : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldl_l $1, %0\"     & LF & HT &\n+         \"addl $1, %4, $0\"  & LF & HT &\n+         \"stl_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stl $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Integer'Asm_Output (\"=m\", To),\n+                     Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", Amount),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To     : in out Aligned_Long_Integer;\n+      Amount : Long_Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"              & LF & HT &\n+         \"1:\"              & LF & HT &\n+         \"ldq_l $1, %0\"    & LF & HT &\n+         \"addq $1, %2, $0\" & LF & HT &\n+         \"stq_c $0, %1\"    & LF & HT &\n+         \"beq $0, 1b\"      & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", Amount)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      Amount       : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l $1, %0\"     & LF & HT &\n+         \"addq $1, %4, $0\"  & LF & HT &\n+         \"stq_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stq $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+                     Long_Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", Amount),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end Add_Atomic;\n+\n+   ----------------\n+   -- And_Atomic --\n+   ----------------\n+\n+   procedure And_Atomic\n+     (To   : in out Aligned_Integer;\n+      From : Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"             & LF & HT &\n+         \"1:\"             & LF & HT &\n+         \"ldl_l $1, %0\"   & LF & HT &\n+         \"and $1, %2, $0\" & LF & HT &\n+         \"stl_c $0, %1\"   & LF & HT &\n+         \"beq $0, 1b\"     & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", From)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To           : in out Aligned_Integer;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldl_l $1, %0\"     & LF & HT &\n+         \"and $1, %4, $0\"   & LF & HT &\n+         \"stl_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stl $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Integer'Asm_Output (\"=m\", To),\n+                     Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", From),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To   : in out Aligned_Long_Integer;\n+      From : Long_Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"             & LF & HT &\n+         \"1:\"             & LF & HT &\n+         \"ldq_l $1, %0\"   & LF & HT &\n+         \"and $1, %2, $0\" & LF & HT &\n+         \"stq_c $0, %1\"   & LF & HT &\n+         \"beq $0, 1b\"     & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", From)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l $1, %0\"     & LF & HT &\n+         \"and $1, %4, $0\"   & LF & HT &\n+         \"stq_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stq $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+                     Long_Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", From),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end And_Atomic;\n+\n+   ---------------\n+   -- Or_Atomic --\n+   ---------------\n+\n+   procedure Or_Atomic\n+     (To   : in out Aligned_Integer;\n+      From : Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"             & LF & HT &\n+         \"1:\"             & LF & HT &\n+         \"ldl_l $1, %0\"   & LF & HT &\n+         \"bis $1, %2, $0\" & LF & HT &\n+         \"stl_c $0, %1\"   & LF & HT &\n+         \"beq $0, 1b\"     & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", From)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To           : in out Aligned_Integer;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldl_l $1, %0\"     & LF & HT &\n+         \"bis $1, %4, $0\"   & LF & HT &\n+         \"stl_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stl $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Integer'Asm_Output (\"=m\", To),\n+                     Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Integer'Asm_Input (\"m\", To),\n+                    Integer'Asm_Input (\"rJ\", From),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To   : in out Aligned_Long_Integer;\n+      From : Long_Integer)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"             & LF & HT &\n+         \"1:\"             & LF & HT &\n+         \"ldq_l $1, %0\"   & LF & HT &\n+         \"bis $1, %2, $0\" & LF & HT &\n+         \"stq_c $0, %1\"   & LF & HT &\n+         \"beq $0, 1b\"     & LF & HT &\n+         \"mb\",\n+         Outputs => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", From)),\n+         Clobber => \"$0, $1\",\n+         Volatile => True);\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"mb\"               & LF & HT &\n+         \"bis $31, %5, $17\" & LF & HT &\n+         \"1:\"               & LF & HT &\n+         \"ldq_l $1, %0\"     & LF & HT &\n+         \"bis $1, %4, $0\"   & LF & HT &\n+         \"stq_c $0, %3\"     & LF & HT &\n+         \"beq $0, 2f\"       & LF & HT &\n+         \"3:\"               & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"stq $0, %2\"       & LF & HT &\n+         \"stq $1, %1\"       & LF & HT &\n+         \"br 4f\"            & LF & HT &\n+         \"2:\"               & LF & HT &\n+         \"subq $17, 1, $17\" & LF & HT &\n+         \"bgt $17, 1b\"      & LF & HT &\n+         \"br 3b\"            & LF & HT &\n+         \"4:\",\n+         Outputs => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n+                     Long_Integer'Asm_Output (\"=m\", Old_Value),\n+                     Boolean'Asm_Output (\"=m\", Success_Flag)),\n+         Inputs => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n+                    Long_Integer'Asm_Input (\"rJ\", From),\n+                    Natural'Asm_Input (\"rJ\", Retry_Count)),\n+         Clobber => \"$0, $1, $17\",\n+         Volatile => True);\n+   end Or_Atomic;\n+\n+   ------------\n+   -- Insqhi --\n+   ------------\n+\n+   procedure Insqhi\n+     (Item   : Address;\n+      Header : Address;\n+      Status : out Insq_Status) is\n+\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"bis $31, %1, $17\" & LF & HT &\n+         \"bis $31, %2, $16\" & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"call_pal 0x87\"    & LF & HT &\n+         \"mb\",\n+         Outputs => Insq_Status'Asm_Output (\"=v\", Status),\n+         Inputs => (Address'Asm_Input (\"rJ\", Item),\n+                    Address'Asm_Input (\"rJ\", Header)),\n+         Clobber => \"$16, $17\",\n+         Volatile => True);\n+   end Insqhi;\n+\n+   ------------\n+   -- Remqhi --\n+   ------------\n+\n+   procedure Remqhi\n+     (Header : Address;\n+      Item   : out Address;\n+      Status : out Remq_Status)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"bis $31, %2, $16\" & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"call_pal 0x93\"    & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"bis $31, $1, %1\",\n+         Outputs => (Remq_Status'Asm_Output (\"=v\", Status),\n+                     Address'Asm_Output (\"=r\", Item)),\n+         Inputs => Address'Asm_Input (\"rJ\", Header),\n+         Clobber => \"$1, $16\",\n+         Volatile => True);\n+   end Remqhi;\n+\n+   ------------\n+   -- Insqti --\n+   ------------\n+\n+   procedure Insqti\n+     (Item   : Address;\n+      Header : Address;\n+      Status : out Insq_Status) is\n+\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"bis $31, %1, $17\" & LF & HT &\n+         \"bis $31, %2, $16\" & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"call_pal 0x88\"    & LF & HT &\n+         \"mb\",\n+         Outputs => Insq_Status'Asm_Output (\"=v\", Status),\n+         Inputs => (Address'Asm_Input (\"rJ\", Item),\n+                    Address'Asm_Input (\"rJ\", Header)),\n+         Clobber => \"$16, $17\",\n+         Volatile => True);\n+   end Insqti;\n+\n+   ------------\n+   -- Remqti --\n+   ------------\n+\n+   procedure Remqti\n+     (Header : Address;\n+      Item   : out Address;\n+      Status : out Remq_Status)\n+   is\n+      use ASCII;\n+   begin\n+      System.Machine_Code.Asm\n+        (\n+         \"bis $31, %2, $16\" & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"call_pal 0x94\"    & LF & HT &\n+         \"mb\"               & LF & HT &\n+         \"bis $31, $1, %1\",\n+         Outputs => (Remq_Status'Asm_Output (\"=v\", Status),\n+                     Address'Asm_Output (\"=r\", Item)),\n+         Inputs => Address'Asm_Input (\"rJ\", Header),\n+         Clobber => \"$1, $16\",\n+         Volatile => True);\n+   end Remqti;\n+\n+end System.Aux_DEC;"}, {"sha": "a54f44f8e3f17804c4c313e597ae4a6e67c4a2a3", "filename": "gcc/ada/s-auxdec-vms_64.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-auxdec-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-auxdec-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms_64.ads?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -578,6 +578,13 @@ private\n       Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (Or_Atomic);\n \n+   --  Inline the VAX Queue Funtions\n+\n+   pragma Inline_Always (Insqhi);\n+   pragma Inline_Always (Remqhi);\n+   pragma Inline_Always (Insqti);\n+   pragma Inline_Always (Remqti);\n+\n    --  Provide proper unchecked conversion definitions for transfer\n    --  functions. Note that we need this level of indirection because\n    --  the formal parameter name is X and not Source (and this is indeed"}, {"sha": "dfd781012329e6271511dbebf3d5a4585fed5ca1", "filename": "gcc/ada/s-stoele.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-stoele.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fs-stoele.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stoele.adb?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -37,6 +37,10 @@ package body System.Storage_Elements is\n \n    pragma Suppress (All_Checks);\n \n+   --  Conversion to/from address\n+\n+   --  Note full qualification below of To_Address to avoid ambiguities on VMS.\n+\n    function To_Address is\n      new Ada.Unchecked_Conversion (Storage_Offset, Address);\n    function To_Offset  is\n@@ -61,22 +65,26 @@ package body System.Storage_Elements is\n \n    function \"+\" (Left : Address; Right : Storage_Offset) return Address is\n    begin\n-      return To_Address (To_Integer (Left) + To_Integer (To_Address (Right)));\n+      return System.Storage_Elements.To_Address\n+        (To_Integer (Left) + To_Integer (To_Address (Right)));\n    end \"+\";\n \n    function \"+\" (Left : Storage_Offset; Right : Address) return Address is\n    begin\n-      return To_Address (To_Integer (To_Address (Left)) + To_Integer (Right));\n+      return System.Storage_Elements.To_Address\n+        (To_Integer (To_Address (Left)) + To_Integer (Right));\n    end \"+\";\n \n    function \"-\" (Left : Address; Right : Storage_Offset) return Address is\n    begin\n-      return To_Address (To_Integer (Left) - To_Integer (To_Address (Right)));\n+      return System.Storage_Elements.To_Address\n+        (To_Integer (Left) - To_Integer (To_Address (Right)));\n    end \"-\";\n \n    function \"-\" (Left, Right : Address) return Storage_Offset is\n    begin\n-      return To_Offset (To_Address (To_Integer (Left) - To_Integer (Right)));\n+      return To_Offset (System.Storage_Elements.To_Address\n+                         (To_Integer (Left) - To_Integer (Right)));\n    end \"-\";\n \n    function \"mod\""}, {"sha": "3010183e44d073aedfac20a032b3ec7d99f90a0d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -923,7 +923,21 @@ package body Sem_Ch4 is\n                end if;\n             end if;\n \n-            Analyze_One_Call (N, Nam_Ent, False, Success);\n+            --  If the call has been rewritten from a prefixed call, the first\n+            --  parameter has been analyzed, but may need a subsequent\n+            --  dereference, so skip its analysis now.\n+\n+            if N /= Original_Node (N)\n+              and then Nkind (Original_Node (N)) = Nkind (N)\n+              and then Nkind (Name (N)) /= Nkind (Name (Original_Node (N)))\n+              and then Present (Parameter_Associations (N))\n+              and then Present (Etype (First (Parameter_Associations (N))))\n+            then\n+               Analyze_One_Call\n+                 (N, Nam_Ent, False, Success, Skip_First => True);\n+            else\n+               Analyze_One_Call (N, Nam_Ent, False, Success);\n+            end if;\n \n             --  If the interpretation succeeds, mark the proper type of the\n             --  prefix (any valid candidate will do). If not, remove the\n@@ -6080,7 +6094,7 @@ package body Sem_Ch4 is\n          First_Actual : Node_Id;\n \n       begin\n-         --  Place the name of the operation, with its interpretations,\n+         --  Place the name of the operation, with its innterpretations,\n          --  on the rewritten call.\n \n          Set_Name (Call_Node, Subprog);\n@@ -6180,6 +6194,7 @@ package body Sem_Ch4 is\n \n          if Is_Overloaded (Subprog) then\n             Save_Interps (Subprog, Node_To_Replace);\n+\n          else\n             Analyze (Node_To_Replace);\n \n@@ -6788,7 +6803,7 @@ package body Sem_Ch4 is\n               and then Present (First_Formal (Prim_Op))\n               and then Valid_First_Argument_Of (Prim_Op)\n               and then\n-                 (Nkind (Call_Node) = N_Function_Call)\n+                (Nkind (Call_Node) = N_Function_Call)\n                    = (Ekind (Prim_Op) = E_Function)\n             then\n                --  Ada 2005 (AI-251): If this primitive operation corresponds"}, {"sha": "97e38230fa56840fe3194e156645e261ab0d2bf3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -1074,9 +1074,13 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n-      --  If error analyzing prefix, then set Any_Type as result and return\n+      --  If there is an error analyzing the name (which may have been\n+      --  rewritten if the original call was in prefix notation) then error\n+      --  has been emitted already, mark node and return.\n \n-      if Etype (P) = Any_Type then\n+      if Error_Posted (N)\n+        or else Etype (Name (N)) = Any_Type\n+      then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;"}, {"sha": "4dbd22aa5e01cfde7e00ffba4c5d75ef82918567", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7415029d47f49954c09bd16c1b7d948dfc67c127/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7415029d47f49954c09bd16c1b7d948dfc67c127", "patch": "@@ -1669,6 +1669,10 @@ package body Sem_Res is\n       --  Try and fix up a literal so that it matches its expected type. New\n       --  literals are manufactured if necessary to avoid cascaded errors.\n \n+      procedure Report_Ambiguous_Argument;\n+      --  Additional diagnostics when an ambiguous call has an ambiguous\n+      --  argument (typically a controlling actual).\n+\n       procedure Resolution_Failed;\n       --  Called when attempt at resolving current expression fails\n \n@@ -1733,6 +1737,38 @@ package body Sem_Res is\n          end if;\n       end Patch_Up_Value;\n \n+      -------------------------------\n+      -- Report_Ambiguous_Argument --\n+      -------------------------------\n+\n+      procedure Report_Ambiguous_Argument is\n+         Arg : constant Node_Id := First (Parameter_Associations (N));\n+         I   : Interp_Index;\n+         It  : Interp;\n+\n+      begin\n+         if Nkind (Arg) = N_Function_Call\n+           and then Is_Entity_Name (Name (Arg))\n+           and then Is_Overloaded (Name (Arg))\n+         then\n+            Error_Msg_NE (\"ambiguous call to&\", Arg, Name (Arg));\n+\n+            Get_First_Interp (Name (Arg), I, It);\n+            while Present (It.Nam) loop\n+               Error_Msg_Sloc := Sloc (It.Nam);\n+\n+               if Nkind (Parent (It.Nam)) = N_Full_Type_Declaration then\n+                  Error_Msg_N (\"interpretation (inherited) #!\", Arg);\n+\n+               else\n+                  Error_Msg_N (\"interpretation #!\", Arg);\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end if;\n+      end Report_Ambiguous_Argument;\n+\n       -----------------------\n       -- Resolution_Failed --\n       -----------------------\n@@ -2037,6 +2073,13 @@ package body Sem_Res is\n                            Error_Msg_N -- CODEFIX\n                              (\"\\\\possible interpretation#!\", N);\n                         end if;\n+\n+                        if Nkind_In\n+                          (N, N_Procedure_Call_Statement, N_Function_Call)\n+                          and then Present (Parameter_Associations (N))\n+                        then\n+                           Report_Ambiguous_Argument;\n+                        end if;\n                      end if;\n \n                      Error_Msg_Sloc := Sloc (It.Nam);"}]}