{"sha": "447fb74d97f0fecbfe363cda7760df231e9b4c27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3ZmI3NGQ5N2YwZmVjYmZlMzYzY2RhNzc2MGRmMjMxZTliNGMyNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T15:37:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T15:37:45Z"}, "message": "exp: remove exp/proxy and exp/terminal packages\n    \n    The exp/proxy package was removed from the master library in\n    https://golang.org/cl/6461056 (August, 2012).\n    \n    The exp/terminal package was removed from the master library in\n    https://golang.org/cl/5970044 (March, 2012).\n    \n    I'm not sure why they lingered in the gofrontend copy, but let's\n    finally remove them now.\n    \n    Reviewed-on: https://go-review.googlesource.com/87138\n\nFrom-SVN: r256435", "tree": {"sha": "058a1ed166ed70f8d9e3f2c9a7130f1474935770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/058a1ed166ed70f8d9e3f2c9a7130f1474935770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447fb74d97f0fecbfe363cda7760df231e9b4c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447fb74d97f0fecbfe363cda7760df231e9b4c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447fb74d97f0fecbfe363cda7760df231e9b4c27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447fb74d97f0fecbfe363cda7760df231e9b4c27/comments", "author": null, "committer": null, "parents": [{"sha": "227e57986a52f7aba4fbc819eec4b64ae2a9776f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227e57986a52f7aba4fbc819eec4b64ae2a9776f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227e57986a52f7aba4fbc819eec4b64ae2a9776f"}], "stats": {"total": 1423, "additions": 31, "deletions": 1392}, "files": [{"sha": "13df7558fe4c1f0397bc5f9ed22270d4eca2e68a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447fb74d97f0fecbfe363cda7760df231e9b4c27/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447fb74d97f0fecbfe363cda7760df231e9b4c27/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=447fb74d97f0fecbfe363cda7760df231e9b4c27", "patch": "@@ -1,4 +1,4 @@\n-87df767807acac466edb3bb6445ad83a48141d17\n+4b8036b3f995cdb0b99a9fa26c2af1e2420b4fa2\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c8b444c7fd8baf2bd054c2f840a592201746c2de", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447fb74d97f0fecbfe363cda7760df231e9b4c27/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447fb74d97f0fecbfe363cda7760df231e9b4c27/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=447fb74d97f0fecbfe363cda7760df231e9b4c27", "patch": "@@ -235,12 +235,6 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/pem.gox \\\n \tencoding/xml.gox\n \n-toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n-\n-toolexeclibgoexp_DATA = \\\n-\texp/proxy.gox \\\n-\texp/terminal.gox\n-\n toolexeclibgogodir = $(toolexeclibgodir)/go\n \n toolexeclibgogo_DATA = \\\n@@ -759,8 +753,6 @@ PACKAGES = \\\n \tencoding/pem \\\n \tencoding/xml \\\n \terrors \\\n-\texp/proxy \\\n-\texp/terminal \\\n \texpvar \\\n \tflag \\\n \tfmt \\\n@@ -1066,7 +1058,6 @@ CHECK_DEPS = \\\n \t$(toolexeclibgocrypto_DATA) \\\n \t$(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) \\\n-\t$(toolexeclibgoexp_DATA) \\\n \t$(toolexeclibgogo_DATA) \\\n \t$(toolexeclibgohash_DATA) \\\n \t$(toolexeclibgoimage_DATA) \\\n@@ -1352,8 +1343,6 @@ TEST_PACKAGES = \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n-\texp/proxy/check \\\n-\texp/terminal/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \tgo/build/check \\"}, {"sha": "99fbd8c7308f3ac29c99490b46319dd3112f4628", "filename": "libgo/Makefile.in", "status": "modified", "additions": 30, "deletions": 65, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447fb74d97f0fecbfe363cda7760df231e9b4c27/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447fb74d97f0fecbfe363cda7760df231e9b4c27/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=447fb74d97f0fecbfe363cda7760df231e9b4c27", "patch": "@@ -131,7 +131,6 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohtmldir)\" \\\n@@ -257,17 +256,16 @@ DATA = $(noinst_DATA) $(toolexeclibgo_DATA) \\\n \t$(toolexeclibgocontainer_DATA) $(toolexeclibgocrypto_DATA) \\\n \t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodatabase_DATA) \\\n \t$(toolexeclibgodatabasesql_DATA) $(toolexeclibgodebug_DATA) \\\n-\t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n-\t$(toolexeclibgohtml_DATA) $(toolexeclibgoimage_DATA) \\\n-\t$(toolexeclibgoimagecolor_DATA) $(toolexeclibgoindex_DATA) \\\n-\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n-\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n-\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n-\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoos_DATA) \\\n-\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n-\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n-\t$(toolexeclibgotesting_DATA) \\\n+\t$(toolexeclibgoencoding_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n+\t$(toolexeclibgoimage_DATA) $(toolexeclibgoimagecolor_DATA) \\\n+\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n+\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n+\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n+\t$(toolexeclibgonethttp_DATA) $(toolexeclibgonetrpc_DATA) \\\n+\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n+\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n+\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n \t$(toolexeclibgotestinginternal_DATA) $(toolexeclibgotext_DATA) \\\n \t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n@@ -629,11 +627,6 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/pem.gox \\\n \tencoding/xml.gox\n \n-toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n-toolexeclibgoexp_DATA = \\\n-\texp/proxy.gox \\\n-\texp/terminal.gox\n-\n toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n@@ -890,8 +883,6 @@ PACKAGES = \\\n \tencoding/pem \\\n \tencoding/xml \\\n \terrors \\\n-\texp/proxy \\\n-\texp/terminal \\\n \texpvar \\\n \tflag \\\n \tfmt \\\n@@ -1176,18 +1167,17 @@ CHECK = \\\n CHECK_DEPS = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocompress_DATA) $(toolexeclibgocontainer_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgodebug_DATA) \\\n-\t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n-\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n-\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n-\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n-\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n-\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n-\t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n-\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA) $(noinst_LIBRARIES) \\\n-\t$(am__append_3) $(am__append_4)\n+\t$(toolexeclibgoencoding_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgohash_DATA) $(toolexeclibgoimage_DATA) \\\n+\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n+\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n+\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n+\t$(toolexeclibgonethttp_DATA) $(toolexeclibgoos_DATA) \\\n+\t$(toolexeclibgopath_DATA) $(toolexeclibgorpc_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n+\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA) \\\n+\t$(noinst_LIBRARIES) $(am__append_3) $(am__append_4)\n \n # Pass -ffp-contract=off, or 386-specific options, when building the\n # math package.  MATH_FLAG is defined in configure.ac.\n@@ -1334,8 +1324,6 @@ TEST_PACKAGES = \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n-\texp/proxy/check \\\n-\texp/terminal/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \tgo/build/check \\\n@@ -2210,27 +2198,6 @@ uninstall-toolexeclibgoencodingDATA:\n \t@list='$(toolexeclibgoencoding_DATA)'; test -n \"$(toolexeclibgoencodingdir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \tdir='$(DESTDIR)$(toolexeclibgoencodingdir)'; $(am__uninstall_files_from_dir)\n-install-toolexeclibgoexpDATA: $(toolexeclibgoexp_DATA)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toolexeclibgoexp_DATA)'; test -n \"$(toolexeclibgoexpdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoexpdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpdir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpdir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toolexeclibgoexpDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgoexp_DATA)'; test -n \"$(toolexeclibgoexpdir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(toolexeclibgoexpdir)'; $(am__uninstall_files_from_dir)\n install-toolexeclibgogoDATA: $(toolexeclibgogo_DATA)\n \t@$(NORMAL_INSTALL)\n \t@list='$(toolexeclibgogo_DATA)'; test -n \"$(toolexeclibgogodir)\" || list=; \\\n@@ -2855,7 +2822,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotestinginternaldir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotestinginternaldir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -2931,9 +2898,9 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodatabaseDATA \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n-\tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n-\tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoencodingDATA install-toolexeclibgogoDATA \\\n+\tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n+\tinstall-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoimagecolorDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n@@ -2999,8 +2966,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoimagecolorDATA \\\n@@ -3046,9 +3012,9 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodatabaseDATA \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n-\tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n-\tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoencodingDATA install-toolexeclibgogoDATA \\\n+\tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n+\tinstall-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoimagecolorDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n@@ -3078,8 +3044,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoimagecolorDATA \\"}, {"sha": "e602e3ac9f0102c213095f5916ef78de98c13efb", "filename": "libgo/go/exp/README", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2FREADME?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,3 +0,0 @@\n-This directory tree contains experimental packages and\n-unfinished code that is subject to even more change than the\n-rest of the Go tree."}, {"sha": "4c5ad88b1e759060536fcc18cf42570545be9bbf", "filename": "libgo/go/exp/proxy/direct.go", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proxy\n-\n-import (\n-\t\"net\"\n-)\n-\n-type direct struct{}\n-\n-// Direct is a direct proxy: one that makes network connections directly.\n-var Direct = direct{}\n-\n-func (direct) Dial(network, addr string) (net.Conn, error) {\n-\treturn net.Dial(network, addr)\n-}"}, {"sha": "0c627e9ab54fa1bc891f0882dabfcba49b0f5e8f", "filename": "libgo/go/exp/proxy/per_host.go", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,140 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proxy\n-\n-import (\n-\t\"net\"\n-\t\"strings\"\n-)\n-\n-// A PerHost directs connections to a default Dailer unless the hostname\n-// requested matches one of a number of exceptions.\n-type PerHost struct {\n-\tdef, bypass Dialer\n-\n-\tbypassNetworks []*net.IPNet\n-\tbypassIPs      []net.IP\n-\tbypassZones    []string\n-\tbypassHosts    []string\n-}\n-\n-// NewPerHost returns a PerHost Dialer that directs connections to either\n-// defaultDialer or bypass, depending on whether the connection matches one of\n-// the configured rules.\n-func NewPerHost(defaultDialer, bypass Dialer) *PerHost {\n-\treturn &PerHost{\n-\t\tdef:    defaultDialer,\n-\t\tbypass: bypass,\n-\t}\n-}\n-\n-// Dial connects to the address addr on the network net through either\n-// defaultDialer or bypass.\n-func (p *PerHost) Dial(network, addr string) (c net.Conn, err error) {\n-\thost, _, err := net.SplitHostPort(addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn p.dialerForRequest(host).Dial(network, addr)\n-}\n-\n-func (p *PerHost) dialerForRequest(host string) Dialer {\n-\tif ip := net.ParseIP(host); ip != nil {\n-\t\tfor _, net := range p.bypassNetworks {\n-\t\t\tif net.Contains(ip) {\n-\t\t\t\treturn p.bypass\n-\t\t\t}\n-\t\t}\n-\t\tfor _, bypassIP := range p.bypassIPs {\n-\t\t\tif bypassIP.Equal(ip) {\n-\t\t\t\treturn p.bypass\n-\t\t\t}\n-\t\t}\n-\t\treturn p.def\n-\t}\n-\n-\tfor _, zone := range p.bypassZones {\n-\t\tif strings.HasSuffix(host, zone) {\n-\t\t\treturn p.bypass\n-\t\t}\n-\t\tif host == zone[1:] {\n-\t\t\t// For a zone \"example.com\", we match \"example.com\"\n-\t\t\t// too.\n-\t\t\treturn p.bypass\n-\t\t}\n-\t}\n-\tfor _, bypassHost := range p.bypassHosts {\n-\t\tif bypassHost == host {\n-\t\t\treturn p.bypass\n-\t\t}\n-\t}\n-\treturn p.def\n-}\n-\n-// AddFromString parses a string that contains comma-separated values\n-// specifying hosts that should use the bypass proxy. Each value is either an\n-// IP address, a CIDR range, a zone (*.example.com) or a hostname\n-// (localhost). A best effort is made to parse the string and errors are\n-// ignored.\n-func (p *PerHost) AddFromString(s string) {\n-\thosts := strings.Split(s, \",\")\n-\tfor _, host := range hosts {\n-\t\thost = strings.TrimSpace(host)\n-\t\tif len(host) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif strings.Contains(host, \"/\") {\n-\t\t\t// We assume that it's a CIDR address like 127.0.0.0/8\n-\t\t\tif _, net, err := net.ParseCIDR(host); err == nil {\n-\t\t\t\tp.AddNetwork(net)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif ip := net.ParseIP(host); ip != nil {\n-\t\t\tp.AddIP(ip)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif strings.HasPrefix(host, \"*.\") {\n-\t\t\tp.AddZone(host[1:])\n-\t\t\tcontinue\n-\t\t}\n-\t\tp.AddHost(host)\n-\t}\n-}\n-\n-// AddIP specifies an IP address that will use the bypass proxy. Note that\n-// this will only take effect if a literal IP address is dialed. A connection\n-// to a named host will never match an IP.\n-func (p *PerHost) AddIP(ip net.IP) {\n-\tp.bypassIPs = append(p.bypassIPs, ip)\n-}\n-\n-// AddIP specifies an IP range that will use the bypass proxy. Note that this\n-// will only take effect if a literal IP address is dialed. A connection to a\n-// named host will never match.\n-func (p *PerHost) AddNetwork(net *net.IPNet) {\n-\tp.bypassNetworks = append(p.bypassNetworks, net)\n-}\n-\n-// AddZone specifies a DNS suffix that will use the bypass proxy. A zone of\n-// \"example.com\" matches \"example.com\" and all of its subdomains.\n-func (p *PerHost) AddZone(zone string) {\n-\tif strings.HasSuffix(zone, \".\") {\n-\t\tzone = zone[:len(zone)-1]\n-\t}\n-\tif !strings.HasPrefix(zone, \".\") {\n-\t\tzone = \".\" + zone\n-\t}\n-\tp.bypassZones = append(p.bypassZones, zone)\n-}\n-\n-// AddHost specifies a hostname that will use the bypass proxy.\n-func (p *PerHost) AddHost(host string) {\n-\tif strings.HasSuffix(host, \".\") {\n-\t\thost = host[:len(host)-1]\n-\t}\n-\tp.bypassHosts = append(p.bypassHosts, host)\n-}"}, {"sha": "a7d80957113d9496219c94597264fe5d6e74ea5c", "filename": "libgo/go/exp/proxy/per_host_test.go", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proxy\n-\n-import (\n-\t\"errors\"\n-\t\"net\"\n-\t\"reflect\"\n-\t\"testing\"\n-)\n-\n-type recordingProxy struct {\n-\taddrs []string\n-}\n-\n-func (r *recordingProxy) Dial(network, addr string) (net.Conn, error) {\n-\tr.addrs = append(r.addrs, addr)\n-\treturn nil, errors.New(\"recordingProxy\")\n-}\n-\n-func TestPerHost(t *testing.T) {\n-\tvar def, bypass recordingProxy\n-\tperHost := NewPerHost(&def, &bypass)\n-\tperHost.AddFromString(\"localhost,*.zone,127.0.0.1,10.0.0.1/8,1000::/16\")\n-\n-\texpectedDef := []string{\n-\t\t\"example.com:123\",\n-\t\t\"1.2.3.4:123\",\n-\t\t\"[1001::]:123\",\n-\t}\n-\texpectedBypass := []string{\n-\t\t\"localhost:123\",\n-\t\t\"zone:123\",\n-\t\t\"foo.zone:123\",\n-\t\t\"127.0.0.1:123\",\n-\t\t\"10.1.2.3:123\",\n-\t\t\"[1000::]:123\",\n-\t}\n-\n-\tfor _, addr := range expectedDef {\n-\t\tperHost.Dial(\"tcp\", addr)\n-\t}\n-\tfor _, addr := range expectedBypass {\n-\t\tperHost.Dial(\"tcp\", addr)\n-\t}\n-\n-\tif !reflect.DeepEqual(expectedDef, def.addrs) {\n-\t\tt.Errorf(\"Hosts which went to the default proxy didn't match. Got %v, want %v\", def.addrs, expectedDef)\n-\t}\n-\tif !reflect.DeepEqual(expectedBypass, bypass.addrs) {\n-\t\tt.Errorf(\"Hosts which went to the bypass proxy didn't match. Got %v, want %v\", bypass.addrs, expectedBypass)\n-\t}\n-}"}, {"sha": "b6cfd45108a2626a141d5728223268db7461d7e3", "filename": "libgo/go/exp/proxy/proxy.go", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package proxy provides support for a variety of protocols to proxy network\n-// data.\n-package proxy\n-\n-import (\n-\t\"errors\"\n-\t\"net\"\n-\t\"net/url\"\n-\t\"os\"\n-)\n-\n-// A Dialer is a means to establish a connection.\n-type Dialer interface {\n-\t// Dial connects to the given address via the proxy.\n-\tDial(network, addr string) (c net.Conn, err error)\n-}\n-\n-// Auth contains authentication parameters that specific Dialers may require.\n-type Auth struct {\n-\tUser, Password string\n-}\n-\n-// DefaultDialer returns the dialer specified by the proxy related variables in\n-// the environment.\n-func FromEnvironment() Dialer {\n-\tallProxy := os.Getenv(\"all_proxy\")\n-\tif len(allProxy) == 0 {\n-\t\treturn Direct\n-\t}\n-\n-\tproxyURL, err := url.Parse(allProxy)\n-\tif err != nil {\n-\t\treturn Direct\n-\t}\n-\tproxy, err := FromURL(proxyURL, Direct)\n-\tif err != nil {\n-\t\treturn Direct\n-\t}\n-\n-\tnoProxy := os.Getenv(\"no_proxy\")\n-\tif len(noProxy) == 0 {\n-\t\treturn proxy\n-\t}\n-\n-\tperHost := NewPerHost(proxy, Direct)\n-\tperHost.AddFromString(noProxy)\n-\treturn perHost\n-}\n-\n-// proxySchemes is a map from URL schemes to a function that creates a Dialer\n-// from a URL with such a scheme.\n-var proxySchemes map[string]func(*url.URL, Dialer) (Dialer, error)\n-\n-// RegisterDialerType takes a URL scheme and a function to generate Dialers from\n-// a URL with that scheme and a forwarding Dialer. Registered schemes are used\n-// by FromURL.\n-func RegisterDialerType(scheme string, f func(*url.URL, Dialer) (Dialer, error)) {\n-\tif proxySchemes == nil {\n-\t\tproxySchemes = make(map[string]func(*url.URL, Dialer) (Dialer, error))\n-\t}\n-\tproxySchemes[scheme] = f\n-}\n-\n-// FromURL returns a Dialer given a URL specification and an underlying\n-// Dialer for it to make network requests.\n-func FromURL(u *url.URL, forward Dialer) (Dialer, error) {\n-\tvar auth *Auth\n-\tif u.User != nil {\n-\t\tauth = new(Auth)\n-\t\tauth.User = u.User.Username()\n-\t\tif p, ok := u.User.Password(); ok {\n-\t\t\tauth.Password = p\n-\t\t}\n-\t}\n-\n-\tswitch u.Scheme {\n-\tcase \"socks5\":\n-\t\treturn SOCKS5(\"tcp\", u.Host, auth, forward)\n-\t}\n-\n-\t// If the scheme doesn't match any of the built-in schemes, see if it\n-\t// was registered by another package.\n-\tif proxySchemes != nil {\n-\t\tif f, ok := proxySchemes[u.Scheme]; ok {\n-\t\t\treturn f(u, forward)\n-\t\t}\n-\t}\n-\n-\treturn nil, errors.New(\"proxy: unknown scheme: \" + u.Scheme)\n-}"}, {"sha": "4078bc76ae8527f09efaba24bcf1317bf7ff9669", "filename": "libgo/go/exp/proxy/proxy_test.go", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proxy\n-\n-import (\n-\t\"net\"\n-\t\"net/url\"\n-\t\"testing\"\n-)\n-\n-type testDialer struct {\n-\tnetwork, addr string\n-}\n-\n-func (t *testDialer) Dial(network, addr string) (net.Conn, error) {\n-\tt.network = network\n-\tt.addr = addr\n-\treturn nil, t\n-}\n-\n-func (t *testDialer) Error() string {\n-\treturn \"testDialer \" + t.network + \" \" + t.addr\n-}\n-\n-func TestFromURL(t *testing.T) {\n-\tu, err := url.Parse(\"socks5://user:password@1.2.3.4:5678\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"failed to parse URL: %s\", err)\n-\t}\n-\n-\ttp := &testDialer{}\n-\tproxy, err := FromURL(u, tp)\n-\tif err != nil {\n-\t\tt.Fatalf(\"FromURL failed: %s\", err)\n-\t}\n-\n-\tconn, err := proxy.Dial(\"tcp\", \"example.com:80\")\n-\tif conn != nil {\n-\t\tt.Error(\"Dial unexpected didn't return an error\")\n-\t}\n-\tif tp, ok := err.(*testDialer); ok {\n-\t\tif tp.network != \"tcp\" || tp.addr != \"1.2.3.4:5678\" {\n-\t\t\tt.Errorf(\"Dialer connected to wrong host. Wanted 1.2.3.4:5678, got: %v\", tp)\n-\t\t}\n-\t} else {\n-\t\tt.Errorf(\"Unexpected error from Dial: %s\", err)\n-\t}\n-}"}, {"sha": "62fa5c9296dc7672710d1a2a1da814ef938776b7", "filename": "libgo/go/exp/proxy/socks5.go", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,207 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proxy\n-\n-import (\n-\t\"errors\"\n-\t\"io\"\n-\t\"net\"\n-\t\"strconv\"\n-)\n-\n-// SOCKS5 returns a Dialer that makes SOCKSv5 connections to the given address\n-// with an optional username and password. See RFC 1928.\n-func SOCKS5(network, addr string, auth *Auth, forward Dialer) (Dialer, error) {\n-\ts := &socks5{\n-\t\tnetwork: network,\n-\t\taddr:    addr,\n-\t\tforward: forward,\n-\t}\n-\tif auth != nil {\n-\t\ts.user = auth.User\n-\t\ts.password = auth.Password\n-\t}\n-\n-\treturn s, nil\n-}\n-\n-type socks5 struct {\n-\tuser, password string\n-\tnetwork, addr  string\n-\tforward        Dialer\n-}\n-\n-const socks5Version = 5\n-\n-const (\n-\tsocks5AuthNone     = 0\n-\tsocks5AuthPassword = 2\n-)\n-\n-const socks5Connect = 1\n-\n-const (\n-\tsocks5IP4    = 1\n-\tsocks5Domain = 3\n-\tsocks5IP6    = 4\n-)\n-\n-var socks5Errors = []string{\n-\t\"\",\n-\t\"general failure\",\n-\t\"connection forbidden\",\n-\t\"network unreachable\",\n-\t\"host unreachable\",\n-\t\"connection refused\",\n-\t\"TTL expired\",\n-\t\"command not supported\",\n-\t\"address type not supported\",\n-}\n-\n-// Dial connects to the address addr on the network net via the SOCKS5 proxy.\n-func (s *socks5) Dial(network, addr string) (net.Conn, error) {\n-\tswitch network {\n-\tcase \"tcp\", \"tcp6\", \"tcp4\":\n-\t\tbreak\n-\tdefault:\n-\t\treturn nil, errors.New(\"proxy: no support for SOCKS5 proxy connections of type \" + network)\n-\t}\n-\n-\tconn, err := s.forward.Dial(s.network, s.addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tcloseConn := &conn\n-\tdefer func() {\n-\t\tif closeConn != nil {\n-\t\t\t(*closeConn).Close()\n-\t\t}\n-\t}()\n-\n-\thost, portStr, err := net.SplitHostPort(addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tport, err := strconv.Atoi(portStr)\n-\tif err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to parse port number: \" + portStr)\n-\t}\n-\tif port < 1 || port > 0xffff {\n-\t\treturn nil, errors.New(\"proxy: port number out of range: \" + portStr)\n-\t}\n-\n-\t// the size here is just an estimate\n-\tbuf := make([]byte, 0, 6+len(host))\n-\n-\tbuf = append(buf, socks5Version)\n-\tif len(s.user) > 0 && len(s.user) < 256 && len(s.password) < 256 {\n-\t\tbuf = append(buf, 2 /* num auth methods */, socks5AuthNone, socks5AuthPassword)\n-\t} else {\n-\t\tbuf = append(buf, 1 /* num auth methods */, socks5AuthNone)\n-\t}\n-\n-\tif _, err = conn.Write(buf); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to write greeting to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\n-\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to read greeting from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\tif buf[0] != 5 {\n-\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" has unexpected version \" + strconv.Itoa(int(buf[0])))\n-\t}\n-\tif buf[1] == 0xff {\n-\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" requires authentication\")\n-\t}\n-\n-\tif buf[1] == socks5AuthPassword {\n-\t\tbuf = buf[:0]\n-\t\tbuf = append(buf, socks5Version)\n-\t\tbuf = append(buf, uint8(len(s.user)))\n-\t\tbuf = append(buf, s.user...)\n-\t\tbuf = append(buf, uint8(len(s.password)))\n-\t\tbuf = append(buf, s.password...)\n-\n-\t\tif _, err = conn.Write(buf); err != nil {\n-\t\t\treturn nil, errors.New(\"proxy: failed to write authentication request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t\t}\n-\n-\t\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n-\t\t\treturn nil, errors.New(\"proxy: failed to read authentication reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t\t}\n-\n-\t\tif buf[1] != 0 {\n-\t\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" rejected username/password\")\n-\t\t}\n-\t}\n-\n-\tbuf = buf[:0]\n-\tbuf = append(buf, socks5Version, socks5Connect, 0 /* reserved */)\n-\n-\tif ip := net.ParseIP(host); ip != nil {\n-\t\tif len(ip) == 4 {\n-\t\t\tbuf = append(buf, socks5IP4)\n-\t\t} else {\n-\t\t\tbuf = append(buf, socks5IP6)\n-\t\t}\n-\t\tbuf = append(buf, []byte(ip)...)\n-\t} else {\n-\t\tbuf = append(buf, socks5Domain)\n-\t\tbuf = append(buf, byte(len(host)))\n-\t\tbuf = append(buf, host...)\n-\t}\n-\tbuf = append(buf, byte(port>>8), byte(port))\n-\n-\tif _, err = conn.Write(buf); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to write connect request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\n-\tif _, err = io.ReadFull(conn, buf[:4]); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to read connect reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\n-\tfailure := \"unknown error\"\n-\tif int(buf[1]) < len(socks5Errors) {\n-\t\tfailure = socks5Errors[buf[1]]\n-\t}\n-\n-\tif len(failure) > 0 {\n-\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" failed to connect: \" + failure)\n-\t}\n-\n-\tbytesToDiscard := 0\n-\tswitch buf[3] {\n-\tcase socks5IP4:\n-\t\tbytesToDiscard = 4\n-\tcase socks5IP6:\n-\t\tbytesToDiscard = 16\n-\tcase socks5Domain:\n-\t\t_, err := io.ReadFull(conn, buf[:1])\n-\t\tif err != nil {\n-\t\t\treturn nil, errors.New(\"proxy: failed to read domain length from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t\t}\n-\t\tbytesToDiscard = int(buf[0])\n-\tdefault:\n-\t\treturn nil, errors.New(\"proxy: got unknown address type \" + strconv.Itoa(int(buf[3])) + \" from SOCKS5 proxy at \" + s.addr)\n-\t}\n-\n-\tif cap(buf) < bytesToDiscard {\n-\t\tbuf = make([]byte, bytesToDiscard)\n-\t} else {\n-\t\tbuf = buf[:bytesToDiscard]\n-\t}\n-\tif _, err = io.ReadFull(conn, buf); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to read address from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\n-\t// Also need to discard the port number\n-\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n-\t\treturn nil, errors.New(\"proxy: failed to read port from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n-\t}\n-\n-\tcloseConn = nil\n-\treturn conn, nil\n-}"}, {"sha": "c1ed0c0c4437d69f51d28cecc32f58f1fd3d354e", "filename": "libgo/go/exp/terminal/terminal.go", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,520 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package terminal\n-\n-import (\n-\t\"io\"\n-\t\"sync\"\n-)\n-\n-// EscapeCodes contains escape sequences that can be written to the terminal in\n-// order to achieve different styles of text.\n-type EscapeCodes struct {\n-\t// Foreground colors\n-\tBlack, Red, Green, Yellow, Blue, Magenta, Cyan, White []byte\n-\n-\t// Reset all attributes\n-\tReset []byte\n-}\n-\n-var vt100EscapeCodes = EscapeCodes{\n-\tBlack:   []byte{keyEscape, '[', '3', '0', 'm'},\n-\tRed:     []byte{keyEscape, '[', '3', '1', 'm'},\n-\tGreen:   []byte{keyEscape, '[', '3', '2', 'm'},\n-\tYellow:  []byte{keyEscape, '[', '3', '3', 'm'},\n-\tBlue:    []byte{keyEscape, '[', '3', '4', 'm'},\n-\tMagenta: []byte{keyEscape, '[', '3', '5', 'm'},\n-\tCyan:    []byte{keyEscape, '[', '3', '6', 'm'},\n-\tWhite:   []byte{keyEscape, '[', '3', '7', 'm'},\n-\n-\tReset: []byte{keyEscape, '[', '0', 'm'},\n-}\n-\n-// Terminal contains the state for running a VT100 terminal that is capable of\n-// reading lines of input.\n-type Terminal struct {\n-\t// AutoCompleteCallback, if non-null, is called for each keypress\n-\t// with the full input line and the current position of the cursor.\n-\t// If it returns a nil newLine, the key press is processed normally.\n-\t// Otherwise it returns a replacement line and the new cursor position.\n-\tAutoCompleteCallback func(line []byte, pos, key int) (newLine []byte, newPos int)\n-\n-\t// Escape contains a pointer to the escape codes for this terminal.\n-\t// It's always a valid pointer, although the escape codes themselves\n-\t// may be empty if the terminal doesn't support them.\n-\tEscape *EscapeCodes\n-\n-\t// lock protects the terminal and the state in this object from\n-\t// concurrent processing of a key press and a Write() call.\n-\tlock sync.Mutex\n-\n-\tc      io.ReadWriter\n-\tprompt string\n-\n-\t// line is the current line being entered.\n-\tline []byte\n-\t// pos is the logical position of the cursor in line\n-\tpos int\n-\t// echo is true if local echo is enabled\n-\techo bool\n-\n-\t// cursorX contains the current X value of the cursor where the left\n-\t// edge is 0. cursorY contains the row number where the first row of\n-\t// the current line is 0.\n-\tcursorX, cursorY int\n-\t// maxLine is the greatest value of cursorY so far.\n-\tmaxLine int\n-\n-\ttermWidth, termHeight int\n-\n-\t// outBuf contains the terminal data to be sent.\n-\toutBuf []byte\n-\t// remainder contains the remainder of any partial key sequences after\n-\t// a read. It aliases into inBuf.\n-\tremainder []byte\n-\tinBuf     [256]byte\n-}\n-\n-// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is\n-// a local terminal, that terminal must first have been put into raw mode.\n-// prompt is a string that is written at the start of each input line (i.e.\n-// \"> \").\n-func NewTerminal(c io.ReadWriter, prompt string) *Terminal {\n-\treturn &Terminal{\n-\t\tEscape:     &vt100EscapeCodes,\n-\t\tc:          c,\n-\t\tprompt:     prompt,\n-\t\ttermWidth:  80,\n-\t\ttermHeight: 24,\n-\t\techo:       true,\n-\t}\n-}\n-\n-const (\n-\tkeyCtrlD     = 4\n-\tkeyEnter     = '\\r'\n-\tkeyEscape    = 27\n-\tkeyBackspace = 127\n-\tkeyUnknown   = 256 + iota\n-\tkeyUp\n-\tkeyDown\n-\tkeyLeft\n-\tkeyRight\n-\tkeyAltLeft\n-\tkeyAltRight\n-)\n-\n-// bytesToKey tries to parse a key sequence from b. If successful, it returns\n-// the key and the remainder of the input. Otherwise it returns -1.\n-func bytesToKey(b []byte) (int, []byte) {\n-\tif len(b) == 0 {\n-\t\treturn -1, nil\n-\t}\n-\n-\tif b[0] != keyEscape {\n-\t\treturn int(b[0]), b[1:]\n-\t}\n-\n-\tif len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {\n-\t\tswitch b[2] {\n-\t\tcase 'A':\n-\t\t\treturn keyUp, b[3:]\n-\t\tcase 'B':\n-\t\t\treturn keyDown, b[3:]\n-\t\tcase 'C':\n-\t\t\treturn keyRight, b[3:]\n-\t\tcase 'D':\n-\t\t\treturn keyLeft, b[3:]\n-\t\t}\n-\t}\n-\n-\tif len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {\n-\t\tswitch b[5] {\n-\t\tcase 'C':\n-\t\t\treturn keyAltRight, b[6:]\n-\t\tcase 'D':\n-\t\t\treturn keyAltLeft, b[6:]\n-\t\t}\n-\t}\n-\n-\t// If we get here then we have a key that we don't recognise, or a\n-\t// partial sequence. It's not clear how one should find the end of a\n-\t// sequence without knowing them all, but it seems that [a-zA-Z] only\n-\t// appears at the end of a sequence.\n-\tfor i, c := range b[0:] {\n-\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n-\t\t\treturn keyUnknown, b[i+1:]\n-\t\t}\n-\t}\n-\n-\treturn -1, b\n-}\n-\n-// queue appends data to the end of t.outBuf\n-func (t *Terminal) queue(data []byte) {\n-\tt.outBuf = append(t.outBuf, data...)\n-}\n-\n-var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n-var space = []byte{' '}\n-\n-func isPrintable(key int) bool {\n-\treturn key >= 32 && key < 127\n-}\n-\n-// moveCursorToPos appends data to t.outBuf which will move the cursor to the\n-// given, logical position in the text.\n-func (t *Terminal) moveCursorToPos(pos int) {\n-\tif !t.echo {\n-\t\treturn\n-\t}\n-\n-\tx := len(t.prompt) + pos\n-\ty := x / t.termWidth\n-\tx = x % t.termWidth\n-\n-\tup := 0\n-\tif y < t.cursorY {\n-\t\tup = t.cursorY - y\n-\t}\n-\n-\tdown := 0\n-\tif y > t.cursorY {\n-\t\tdown = y - t.cursorY\n-\t}\n-\n-\tleft := 0\n-\tif x < t.cursorX {\n-\t\tleft = t.cursorX - x\n-\t}\n-\n-\tright := 0\n-\tif x > t.cursorX {\n-\t\tright = x - t.cursorX\n-\t}\n-\n-\tt.cursorX = x\n-\tt.cursorY = y\n-\tt.move(up, down, left, right)\n-}\n-\n-func (t *Terminal) move(up, down, left, right int) {\n-\tmovement := make([]byte, 3*(up+down+left+right))\n-\tm := movement\n-\tfor i := 0; i < up; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'A'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < down; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'B'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < left; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'D'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < right; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'C'\n-\t\tm = m[3:]\n-\t}\n-\n-\tt.queue(movement)\n-}\n-\n-func (t *Terminal) clearLineToRight() {\n-\top := []byte{keyEscape, '[', 'K'}\n-\tt.queue(op)\n-}\n-\n-const maxLineLength = 4096\n-\n-// handleKey processes the given key and, optionally, returns a line of text\n-// that the user has entered.\n-func (t *Terminal) handleKey(key int) (line string, ok bool) {\n-\tswitch key {\n-\tcase keyBackspace:\n-\t\tif t.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tt.pos--\n-\t\tt.moveCursorToPos(t.pos)\n-\n-\t\tcopy(t.line[t.pos:], t.line[1+t.pos:])\n-\t\tt.line = t.line[:len(t.line)-1]\n-\t\tif t.echo {\n-\t\t\tt.writeLine(t.line[t.pos:])\n-\t\t}\n-\t\tt.queue(eraseUnderCursor)\n-\t\tt.moveCursorToPos(t.pos)\n-\tcase keyAltLeft:\n-\t\t// move left by a word.\n-\t\tif t.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tt.pos--\n-\t\tfor t.pos > 0 {\n-\t\t\tif t.line[t.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tt.pos--\n-\t\t}\n-\t\tfor t.pos > 0 {\n-\t\t\tif t.line[t.pos] == ' ' {\n-\t\t\t\tt.pos++\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tt.pos--\n-\t\t}\n-\t\tt.moveCursorToPos(t.pos)\n-\tcase keyAltRight:\n-\t\t// move right by a word.\n-\t\tfor t.pos < len(t.line) {\n-\t\t\tif t.line[t.pos] == ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tt.pos++\n-\t\t}\n-\t\tfor t.pos < len(t.line) {\n-\t\t\tif t.line[t.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tt.pos++\n-\t\t}\n-\t\tt.moveCursorToPos(t.pos)\n-\tcase keyLeft:\n-\t\tif t.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tt.pos--\n-\t\tt.moveCursorToPos(t.pos)\n-\tcase keyRight:\n-\t\tif t.pos == len(t.line) {\n-\t\t\treturn\n-\t\t}\n-\t\tt.pos++\n-\t\tt.moveCursorToPos(t.pos)\n-\tcase keyEnter:\n-\t\tt.moveCursorToPos(len(t.line))\n-\t\tt.queue([]byte(\"\\r\\n\"))\n-\t\tline = string(t.line)\n-\t\tok = true\n-\t\tt.line = t.line[:0]\n-\t\tt.pos = 0\n-\t\tt.cursorX = 0\n-\t\tt.cursorY = 0\n-\t\tt.maxLine = 0\n-\tdefault:\n-\t\tif t.AutoCompleteCallback != nil {\n-\t\t\tt.lock.Unlock()\n-\t\t\tnewLine, newPos := t.AutoCompleteCallback(t.line, t.pos, key)\n-\t\t\tt.lock.Lock()\n-\n-\t\t\tif newLine != nil {\n-\t\t\t\tif t.echo {\n-\t\t\t\t\tt.moveCursorToPos(0)\n-\t\t\t\t\tt.writeLine(newLine)\n-\t\t\t\t\tfor i := len(newLine); i < len(t.line); i++ {\n-\t\t\t\t\t\tt.writeLine(space)\n-\t\t\t\t\t}\n-\t\t\t\t\tt.moveCursorToPos(newPos)\n-\t\t\t\t}\n-\t\t\t\tt.line = newLine\n-\t\t\t\tt.pos = newPos\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t\tif !isPrintable(key) {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(t.line) == maxLineLength {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(t.line) == cap(t.line) {\n-\t\t\tnewLine := make([]byte, len(t.line), 2*(1+len(t.line)))\n-\t\t\tcopy(newLine, t.line)\n-\t\t\tt.line = newLine\n-\t\t}\n-\t\tt.line = t.line[:len(t.line)+1]\n-\t\tcopy(t.line[t.pos+1:], t.line[t.pos:])\n-\t\tt.line[t.pos] = byte(key)\n-\t\tif t.echo {\n-\t\t\tt.writeLine(t.line[t.pos:])\n-\t\t}\n-\t\tt.pos++\n-\t\tt.moveCursorToPos(t.pos)\n-\t}\n-\treturn\n-}\n-\n-func (t *Terminal) writeLine(line []byte) {\n-\tfor len(line) != 0 {\n-\t\tremainingOnLine := t.termWidth - t.cursorX\n-\t\ttodo := len(line)\n-\t\tif todo > remainingOnLine {\n-\t\t\ttodo = remainingOnLine\n-\t\t}\n-\t\tt.queue(line[:todo])\n-\t\tt.cursorX += todo\n-\t\tline = line[todo:]\n-\n-\t\tif t.cursorX == t.termWidth {\n-\t\t\tt.cursorX = 0\n-\t\t\tt.cursorY++\n-\t\t\tif t.cursorY > t.maxLine {\n-\t\t\t\tt.maxLine = t.cursorY\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func (t *Terminal) Write(buf []byte) (n int, err error) {\n-\tt.lock.Lock()\n-\tdefer t.lock.Unlock()\n-\n-\tif t.cursorX == 0 && t.cursorY == 0 {\n-\t\t// This is the easy case: there's nothing on the screen that we\n-\t\t// have to move out of the way.\n-\t\treturn t.c.Write(buf)\n-\t}\n-\n-\t// We have a prompt and possibly user input on the screen. We\n-\t// have to clear it first.\n-\tt.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)\n-\tt.cursorX = 0\n-\tt.clearLineToRight()\n-\n-\tfor t.cursorY > 0 {\n-\t\tt.move(1 /* up */, 0, 0, 0)\n-\t\tt.cursorY--\n-\t\tt.clearLineToRight()\n-\t}\n-\n-\tif _, err = t.c.Write(t.outBuf); err != nil {\n-\t\treturn\n-\t}\n-\tt.outBuf = t.outBuf[:0]\n-\n-\tif n, err = t.c.Write(buf); err != nil {\n-\t\treturn\n-\t}\n-\n-\tt.queue([]byte(t.prompt))\n-\tchars := len(t.prompt)\n-\tif t.echo {\n-\t\tt.queue(t.line)\n-\t\tchars += len(t.line)\n-\t}\n-\tt.cursorX = chars % t.termWidth\n-\tt.cursorY = chars / t.termWidth\n-\tt.moveCursorToPos(t.pos)\n-\n-\tif _, err = t.c.Write(t.outBuf); err != nil {\n-\t\treturn\n-\t}\n-\tt.outBuf = t.outBuf[:0]\n-\treturn\n-}\n-\n-// ReadPassword temporarily changes the prompt and reads a password, without\n-// echo, from the terminal.\n-func (t *Terminal) ReadPassword(prompt string) (line string, err error) {\n-\tt.lock.Lock()\n-\tdefer t.lock.Unlock()\n-\n-\toldPrompt := t.prompt\n-\tt.prompt = prompt\n-\tt.echo = false\n-\n-\tline, err = t.readLine()\n-\n-\tt.prompt = oldPrompt\n-\tt.echo = true\n-\n-\treturn\n-}\n-\n-// ReadLine returns a line of input from the terminal.\n-func (t *Terminal) ReadLine() (line string, err error) {\n-\tt.lock.Lock()\n-\tdefer t.lock.Unlock()\n-\n-\treturn t.readLine()\n-}\n-\n-func (t *Terminal) readLine() (line string, err error) {\n-\t// t.lock must be held at this point\n-\n-\tif t.cursorX == 0 && t.cursorY == 0 {\n-\t\tt.writeLine([]byte(t.prompt))\n-\t\tt.c.Write(t.outBuf)\n-\t\tt.outBuf = t.outBuf[:0]\n-\t}\n-\n-\tfor {\n-\t\trest := t.remainder\n-\t\tlineOk := false\n-\t\tfor !lineOk {\n-\t\t\tvar key int\n-\t\t\tkey, rest = bytesToKey(rest)\n-\t\t\tif key < 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif key == keyCtrlD {\n-\t\t\t\treturn \"\", io.EOF\n-\t\t\t}\n-\t\t\tline, lineOk = t.handleKey(key)\n-\t\t}\n-\t\tif len(rest) > 0 {\n-\t\t\tn := copy(t.inBuf[:], rest)\n-\t\t\tt.remainder = t.inBuf[:n]\n-\t\t} else {\n-\t\t\tt.remainder = nil\n-\t\t}\n-\t\tt.c.Write(t.outBuf)\n-\t\tt.outBuf = t.outBuf[:0]\n-\t\tif lineOk {\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// t.remainder is a slice at the beginning of t.inBuf\n-\t\t// containing a partial key sequence\n-\t\treadBuf := t.inBuf[len(t.remainder):]\n-\t\tvar n int\n-\n-\t\tt.lock.Unlock()\n-\t\tn, err = t.c.Read(readBuf)\n-\t\tt.lock.Lock()\n-\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\tt.remainder = t.inBuf[:n+len(t.remainder)]\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-// SetPrompt sets the prompt to be used when reading subsequent lines.\n-func (t *Terminal) SetPrompt(prompt string) {\n-\tt.lock.Lock()\n-\tdefer t.lock.Unlock()\n-\n-\tt.prompt = prompt\n-}\n-\n-func (t *Terminal) SetSize(width, height int) {\n-\tt.lock.Lock()\n-\tdefer t.lock.Unlock()\n-\n-\tt.termWidth, t.termHeight = width, height\n-}"}, {"sha": "a2197210e2a8d4da5720b2c797afccd21156011d", "filename": "libgo/go/exp/terminal/terminal_test.go", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package terminal\n-\n-import (\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type MockTerminal struct {\n-\ttoSend       []byte\n-\tbytesPerRead int\n-\treceived     []byte\n-}\n-\n-func (c *MockTerminal) Read(data []byte) (n int, err error) {\n-\tn = len(data)\n-\tif n == 0 {\n-\t\treturn\n-\t}\n-\tif n > len(c.toSend) {\n-\t\tn = len(c.toSend)\n-\t}\n-\tif n == 0 {\n-\t\treturn 0, io.EOF\n-\t}\n-\tif c.bytesPerRead > 0 && n > c.bytesPerRead {\n-\t\tn = c.bytesPerRead\n-\t}\n-\tcopy(data, c.toSend[:n])\n-\tc.toSend = c.toSend[n:]\n-\treturn\n-}\n-\n-func (c *MockTerminal) Write(data []byte) (n int, err error) {\n-\tc.received = append(c.received, data...)\n-\treturn len(data), nil\n-}\n-\n-func TestClose(t *testing.T) {\n-\tc := &MockTerminal{}\n-\tss := NewTerminal(c, \"> \")\n-\tline, err := ss.ReadLine()\n-\tif line != \"\" {\n-\t\tt.Errorf(\"Expected empty line but got: %s\", line)\n-\t}\n-\tif err != io.EOF {\n-\t\tt.Errorf(\"Error should have been EOF but got: %s\", err)\n-\t}\n-}\n-\n-var keyPressTests = []struct {\n-\tin   string\n-\tline string\n-\terr  error\n-}{\n-\t{\n-\t\t\"\",\n-\t\t\"\",\n-\t\tio.EOF,\n-\t},\n-\t{\n-\t\t\"\\r\",\n-\t\t\"\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"foo\\r\",\n-\t\t\"foo\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\x1b[Cb\\r\", // right\n-\t\t\"ab\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\x1b[Db\\r\", // left\n-\t\t\"ba\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\177b\\r\", // backspace\n-\t\t\"b\",\n-\t\tnil,\n-\t},\n-}\n-\n-func TestKeyPresses(t *testing.T) {\n-\tfor i, test := range keyPressTests {\n-\t\tfor j := 0; j < len(test.in); j++ {\n-\t\t\tc := &MockTerminal{\n-\t\t\t\ttoSend:       []byte(test.in),\n-\t\t\t\tbytesPerRead: j,\n-\t\t\t}\n-\t\t\tss := NewTerminal(c, \"> \")\n-\t\t\tline, err := ss.ReadLine()\n-\t\t\tif line != test.line {\n-\t\t\t\tt.Errorf(\"Line resulting from test %d (%d bytes per read) was '%s', expected '%s'\", i, j, line, test.line)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif err != test.err {\n-\t\t\t\tt.Errorf(\"Error resulting from test %d (%d bytes per read) was '%v', expected '%v'\", i, j, err, test.err)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "211f41d10fadfd8105c5b188e0fad8710c5fc163", "filename": "libgo/go/exp/terminal/util.go", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227e57986a52f7aba4fbc819eec4b64ae2a9776f/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go?ref=227e57986a52f7aba4fbc819eec4b64ae2a9776f", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build linux\n-\n-// Package terminal provides support functions for dealing with terminals, as\n-// commonly found on UNIX systems.\n-//\n-// Putting a terminal into raw mode is the most common requirement:\n-//\n-// \toldState, err := terminal.MakeRaw(0)\n-// \tif err != nil {\n-// \t        panic(err)\n-// \t}\n-// \tdefer terminal.Restore(0, oldState)\n-package terminal\n-\n-import (\n-\t\"io\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-// State contains the state of a terminal.\n-type State struct {\n-\ttermios syscall.Termios\n-}\n-\n-// IsTerminal returns true if the given file descriptor is a terminal.\n-func IsTerminal(fd int) bool {\n-\tvar termios syscall.Termios\n-\terr := syscall.Tcgetattr(fd, &termios)\n-\treturn err == nil\n-}\n-\n-// MakeRaw put the terminal connected to the given file descriptor into raw\n-// mode and returns the previous state of the terminal so that it can be\n-// restored.\n-func MakeRaw(fd int) (*State, error) {\n-\tvar oldState State\n-\tif err := syscall.Tcgetattr(fd, &oldState.termios); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tnewState := oldState.termios\n-\tnewState.Iflag &^= syscall.ISTRIP | syscall.INLCR | syscall.ICRNL | syscall.IGNCR | syscall.IXON | syscall.IXOFF\n-\tnewState.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG\n-\tif err := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn &oldState, nil\n-}\n-\n-// Restore restores the terminal connected to the given file descriptor to a\n-// previous state.\n-func Restore(fd int, state *State) error {\n-\terr := syscall.Tcsetattr(fd, syscall.TCSANOW, &state.termios)\n-\treturn err\n-}\n-\n-//extern ioctl\n-func ioctl(int, int, unsafe.Pointer) int\n-\n-// GetSize returns the dimensions of the given terminal.\n-func GetSize(fd int) (width, height int, err error) {\n-\tvar dimensions [4]uint16\n-\n-\tif ioctl(fd, syscall.TIOCGWINSZ, unsafe.Pointer(&dimensions)) < 0 {\n-\t\treturn -1, -1, syscall.GetErrno()\n-\t}\n-\treturn int(dimensions[1]), int(dimensions[0]), nil\n-}\n-\n-// ReadPassword reads a line of input from a terminal without local echo.  This\n-// is commonly used for inputting passwords and other sensitive data. The slice\n-// returned does not include the \\n.\n-func ReadPassword(fd int) ([]byte, error) {\n-\tvar oldState syscall.Termios\n-\tif err := syscall.Tcgetattr(fd, &oldState); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tnewState := oldState\n-\tnewState.Lflag &^= syscall.ECHO\n-\tif err := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tdefer func() {\n-\t\tsyscall.Tcsetattr(fd, syscall.TCSANOW, &oldState)\n-\t}()\n-\n-\tvar buf [16]byte\n-\tvar ret []byte\n-\tfor {\n-\t\tn, err := syscall.Read(fd, buf[:])\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif n == 0 {\n-\t\t\tif len(ret) == 0 {\n-\t\t\t\treturn nil, io.EOF\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\t\tif buf[n-1] == '\\n' {\n-\t\t\tn--\n-\t\t}\n-\t\tret = append(ret, buf[:n]...)\n-\t\tif n < len(buf) {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\treturn ret, nil\n-}"}]}