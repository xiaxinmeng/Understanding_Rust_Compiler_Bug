{"sha": "8d7a5379cdb809096ffbe653fc91785eadbfa870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ3YTUzNzljZGI4MDkwOTZmZmJlNjUzZmM5MTc4NWVhZGJmYTg3MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-21T04:19:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-21T04:19:12Z"}, "message": "cp-tree.h (merge_primary_and_secondary_vtables_p): New macro.\n\n\t* cp-tree.h (merge_primary_and_secondary_vtables_p): New macro.\n\t* class.c (build_secondary_vtable): Reorganize.  Don't create a\n\tnew vtable under the new ABI.\n\t(layout_vtable_decl): Don't add num_extra_vtbl_entries when\n\tcomputing the size.\n\t(build_vtbl_initializer): Don't return a CONSTRUCTOR; just return\n\tthe initializing elements.\n\t(initialize_vtable): New function.\n\t(dfs_finish_vtbls): Use it.\n\t(dfs_accumulate_vtbl_inits): New function.\n\t(finish_vtbls): Merge primary and secondary vtables under the new\n\tABI.\n\t(finish_struct_1): Remove redundant call to layout_vtable_decl.\n\t* init.c (expand_virtual_init): Deal with BINFO_VTABLEs that\n\taren't VAR_DECLs.\n\nFrom-SVN: r32083", "tree": {"sha": "25058cbd565f8e010653d7db6f1eae0169153ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25058cbd565f8e010653d7db6f1eae0169153ad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d7a5379cdb809096ffbe653fc91785eadbfa870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7a5379cdb809096ffbe653fc91785eadbfa870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d7a5379cdb809096ffbe653fc91785eadbfa870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7a5379cdb809096ffbe653fc91785eadbfa870/comments", "author": null, "committer": null, "parents": [{"sha": "b9f39201011701cc185c3db66fdd3e2c46d6703c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f39201011701cc185c3db66fdd3e2c46d6703c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f39201011701cc185c3db66fdd3e2c46d6703c"}], "stats": {"total": 236, "additions": 176, "deletions": 60}, "files": [{"sha": "c326e41bdfd73ff4e299446f119ba1840f883530", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d7a5379cdb809096ffbe653fc91785eadbfa870", "patch": "@@ -1,5 +1,21 @@\n 2000-02-20  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (merge_primary_and_secondary_vtables_p): New macro.\n+\t* class.c (build_secondary_vtable): Reorganize.  Don't create a\n+\tnew vtable under the new ABI.\n+\t(layout_vtable_decl): Don't add num_extra_vtbl_entries when\n+\tcomputing the size.\n+\t(build_vtbl_initializer): Don't return a CONSTRUCTOR; just return\n+\tthe initializing elements.\n+\t(initialize_vtable): New function.\n+\t(dfs_finish_vtbls): Use it.\n+\t(dfs_accumulate_vtbl_inits): New function.\n+\t(finish_vtbls): Merge primary and secondary vtables under the new\n+\tABI.\n+\t(finish_struct_1): Remove redundant call to layout_vtable_decl.\n+\t* init.c (expand_virtual_init): Deal with BINFO_VTABLEs that\n+\taren't VAR_DECLs.\n+\n \t* class.c (build_vtable): New function, split out from ...\n \t(get_vtable_decl): ... here, and ...\n \t(build_secondary_vtable): ... here."}, {"sha": "7aed67b8be77eccff2822b49e52167f251e34d3d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 141, "deletions": 57, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d7a5379cdb809096ffbe653fc91785eadbfa870", "patch": "@@ -84,6 +84,7 @@ static void set_rtti_entry PARAMS ((tree, tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n+static tree dfs_accumulate_vtbl_inits PARAMS ((tree, void *));\n static void finish_vtbls PARAMS ((tree));\n static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n@@ -153,6 +154,7 @@ static tree dfs_find_base PARAMS ((tree, void *));\n static int make_new_vtable PARAMS ((tree, tree));\n extern void dump_class_hierarchy PARAMS ((tree, int));\n static tree build_vtable PARAMS ((tree, tree, tree));\n+static void initialize_vtable PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1140,13 +1142,52 @@ build_secondary_vtable (binfo, for_type)\n   joiner = JOINER;\n #endif\n \n+  if (TREE_VIA_VIRTUAL (binfo))\n+    my_friendly_assert (binfo == BINFO_FOR_VBASE (BINFO_TYPE (binfo),\n+\t\t\t\t\t\t  current_class_type),\n+\t\t\t170);\n+\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     /* We already created a vtable for this base.  There's no need to\n        do it again.  */\n     return 0;\n \n-  basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n+  /* Remember that we've created a vtable for this BINFO, so that we\n+     don't try to do so again.  */\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  \n+  /* Make fresh virtual list, so we can smash it later.  */\n+  BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n+\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      tree binfo1 = BINFO_FOR_VBASE (BINFO_TYPE (binfo), for_type);\n+\n+      /* XXX - This should never happen, if it does, the caller should\n+\t ensure that the binfo is from for_type's binfos, not from any\n+\t base type's.  We can remove all this code after a while.  */\n+      if (binfo1 != binfo)\n+\twarning (\"internal inconsistency: binfo offset error for rtti\");\n+\n+      offset = BINFO_OFFSET (binfo1);\n+    }\n+  else\n+    offset = BINFO_OFFSET (binfo);\n+\n+  set_rtti_entry (BINFO_VIRTUALS (binfo),\n+\t\t  ssize_binop (MINUS_EXPR, integer_zero_node, offset),\n+\t\t  for_type);\n+\n+  /* In the new ABI, secondary vtables are laid out as part of the\n+     same structure as the primary vtable.  */\n+  if (merge_primary_and_secondary_vtables_p ())\n+    {\n+      BINFO_VTABLE (binfo) = NULL_TREE;\n+      return 1;\n+    }\n \n+  /* Create the declaration for the secondary vtable.  */\n+  basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n   buf2 = TYPE_ASSEMBLER_NAME_STRING (basetype);\n   i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1;\n \n@@ -1228,38 +1269,11 @@ build_secondary_vtable (binfo, for_type)\n   DECL_ALIGN (new_decl) = DECL_ALIGN (orig_decl);\n   BINFO_VTABLE (binfo) = pushdecl_top_level (new_decl);\n \n-  /* Make fresh virtual list, so we can smash it later.  */\n-  BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n-\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree binfo1 = BINFO_FOR_VBASE (BINFO_TYPE (binfo), for_type);\n-\n-      /* XXX - This should never happen, if it does, the caller should\n-\t ensure that the binfo is from for_type's binfos, not from any\n-\t base type's.  We can remove all this code after a while.  */\n-      if (binfo1 != binfo)\n-\twarning (\"internal inconsistency: binfo offset error for rtti\");\n-\n-      offset = BINFO_OFFSET (binfo1);\n-    }\n-  else\n-    offset = BINFO_OFFSET (binfo);\n-\n-  set_rtti_entry (BINFO_VIRTUALS (binfo),\n-\t\t  ssize_binop (MINUS_EXPR, integer_zero_node, offset),\n-\t\t  for_type);\n-\n #ifdef GATHER_STATISTICS\n   n_vtables += 1;\n   n_vtable_elems += list_length (BINFO_VIRTUALS (binfo));\n #endif\n \n-  if (TREE_VIA_VIRTUAL (binfo))\n-    my_friendly_assert (binfo == BINFO_FOR_VBASE (BINFO_TYPE (binfo),\n-\t\t\t\t\t\t  current_class_type),\n-\t\t\t170);\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n   return 1;\n }\n \n@@ -2505,9 +2519,9 @@ duplicate_tag_error (t)\n   TYPE_NONCOPIED_PARTS (t) = NULL_TREE;\n }\n \n-/* Make the BINFO's vtablehave N entries, including RTTI entries, but\n-   not including vbase and vcall offsets.  Set its type and call the\n-   backend to lay it out.  */\n+/* Make the BINFO's vtablehave N entries, including RTTI entries,\n+   vbase and vcall offsets, etc.  Set its type and call the backend\n+   to lay it out.  */\n \n static void\n layout_vtable_decl (binfo, n)\n@@ -2518,9 +2532,6 @@ layout_vtable_decl (binfo, n)\n   tree atype;\n \n   itype = size_int (n);\n-  itype = size_binop (PLUS_EXPR, \n-\t\t      itype,\n-\t\t      num_extra_vtbl_entries (binfo));\n   atype = build_cplus_array_type (vtable_entry_type, \n \t\t\t\t  build_index_type (itype));\n   layout_type (atype);\n@@ -2621,7 +2632,9 @@ size_extra_vtbl_entries (binfo)\n }\n \n /* Construct the initializer for BINFOs virtual function table.  BINFO\n-   is part of the hierarchy dominated by T.  */\n+   is part of the hierarchy dominated by T.  The value returned is a\n+   TREE_LIST suitable for wrapping in a CONSTRUCTOR to use as the\n+   DECL_INITIAL for a vtable.  */\n \n static tree\n build_vtbl_initializer (binfo, t)\n@@ -2722,9 +2735,26 @@ build_vtbl_initializer (binfo, t)\n \n   /* The initializers were built up in reverse order; straighten them\n      out now.  */\n-  inits = nreverse (inits);\n-  /* Package all the initializers up as an array initializer.  */\n-  return build_nt (CONSTRUCTOR, NULL_TREE, inits);\n+  return nreverse (inits);\n+}\n+\n+/* Initialize the vtable for BINFO with the INITS.  */\n+\n+static void\n+initialize_vtable (binfo, inits)\n+     tree binfo;\n+     tree inits;\n+{\n+  tree context;\n+  tree decl;\n+\n+  layout_vtable_decl (binfo, list_length (inits));\n+  decl = BINFO_VTABLE (binfo);\n+  context = DECL_CONTEXT (decl);\n+  DECL_CONTEXT (decl) = 0;\n+  DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n+  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n+  DECL_CONTEXT (decl) = context;\n }\n \n /* Called from finish_vtbls via dfs_walk.  */\n@@ -2733,21 +2763,59 @@ static tree\n dfs_finish_vtbls (binfo, data)\n      tree binfo;\n      void *data;\n+{\n+  if (!BINFO_PRIMARY_MARKED_P (binfo)\n+      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n+      && BINFO_NEW_VTABLE_MARKED (binfo))\n+    initialize_vtable (binfo, \n+\t\t       build_vtbl_initializer (binfo, (tree) data));\n+\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Called from finish_vtbls via dfs_walk when using the new ABI.\n+   Accumulates the vtable initializers for all of the vtables into\n+   TREE_VALUE (DATA).  */\n+\n+static tree\n+dfs_accumulate_vtbl_inits (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n   if (!BINFO_PRIMARY_MARKED_P (binfo)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n       && BINFO_NEW_VTABLE_MARKED (binfo))\n     {\n-      tree decl;\n-      tree context;\n-      \n-      layout_vtable_decl (binfo, list_length (BINFO_VIRTUALS (binfo)));\n-      decl = BINFO_VTABLE (binfo);\n-      context = DECL_CONTEXT (decl);\n-      DECL_CONTEXT (decl) = 0;\n-      DECL_INITIAL (decl) = build_vtbl_initializer (binfo, (tree) data);\n-      cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n-      DECL_CONTEXT (decl) = context;\n+      tree l;\n+      tree t;\n+\n+      l = (tree) data;\n+      t = TREE_PURPOSE (l);\n+\n+      /* If this is a secondary vtable, record its location.  */\n+      if (binfo != TYPE_BINFO (t))\n+\t{\n+\t  tree vtbl;\n+\n+\t  vtbl = TYPE_BINFO_VTABLE (t);\n+\t  vtbl = build1 (ADDR_EXPR, \n+\t\t\t build_pointer_type (TREE_TYPE (vtbl)),\n+\t\t\t vtbl);\n+\t  BINFO_VTABLE (binfo)\n+\t    = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n+\t\t     size_binop (MULT_EXPR,\n+\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n+\t\t\t\t size_int (list_length (TREE_VALUE (l)))));\n+\t}\n+\n+      /* Add the initializers for this vtable to the initailizers for\n+\t the other vtables we've already got.  */\n+      TREE_VALUE (l) \n+\t= chainon (TREE_VALUE (l),\n+\t\t   build_vtbl_initializer (binfo, t));\n     }\n \n   CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n@@ -2762,8 +2830,27 @@ static void\n finish_vtbls (t)\n      tree t;\n {\n-  dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n-\t    dfs_unmarked_real_bases_queue_p, t);\n+  if (merge_primary_and_secondary_vtables_p ())\n+    {\n+      tree list;\n+\n+      /* Under the new ABI, we lay out the primary and secondary\n+\t vtables in one contiguous vtable.  The primary vtable is\n+\t first, followed by the secondary vtables as encountered in a\n+\t pre-order depth-first left-to-right traversal.  */\n+      list = build_tree_list (t, NULL_TREE);\n+      dfs_walk_real (TYPE_BINFO (t), \n+\t\t     dfs_accumulate_vtbl_inits,\n+\t\t     NULL, \n+\t\t     dfs_unmarked_real_bases_queue_p, \n+\t\t     list);\n+      if (TYPE_BINFO_VTABLE (t))\n+\tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n+    }\n+  else\n+    dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n+\t      dfs_unmarked_real_bases_queue_p, t);\n+\n   dfs_walk (TYPE_BINFO (t), dfs_unmark, \n \t    dfs_marked_real_bases_queue_p, t);\n }\n@@ -5039,10 +5126,6 @@ finish_struct_1 (t)\n \t= chainon (TYPE_BINFO_VIRTUALS (t), overridden_virtuals);\n     }\n \n-  /* Now lay out the virtual function table.  */\n-  if (has_virtual)\n-    layout_vtable_decl (TYPE_BINFO (t), has_virtual);\n-\n   /* If we created a new vtbl pointer for this class, add it to the\n      list.  */\n   if (TYPE_VFIELD (t) && CLASSTYPE_VFIELD_PARENT (t) == -1)\n@@ -5098,6 +5181,10 @@ finish_struct_1 (t)\n \t}\n     }\n \n+  /* Make the rtl for any new vtables we have created, and unmark\n+     the base types we marked.  */\n+  finish_vtbls (t);\n+\n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n       /* In addition to this one, all the other vfields should be listed.  */\n@@ -5113,9 +5200,6 @@ finish_struct_1 (t)\n \t\t    t);\n     }\n \n-  /* Make the rtl for any new vtables we have created, and unmark\n-     the base types we marked.  */\n-  finish_vtbls (t);\n   hack_incomplete_structures (t);\n \n   if (warn_overloaded_virtual)"}, {"sha": "500937b0ed1c9255d60b4974c33c3da601e8246b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d7a5379cdb809096ffbe653fc91785eadbfa870", "patch": "@@ -251,6 +251,10 @@ extern int flag_rtti;\n    to get the type_info object address.  */\n #define new_abi_rtti_p() (flag_new_abi)\n \n+/* Nonzero if primary and secondary vtables are combined into a single\n+   vtable.  */\n+#define merge_primary_and_secondary_vtables_p() (flag_new_abi)\n+\n \f\n /* Language-dependent contents of an identifier.  */\n "}, {"sha": "e08b2fa83ff19cace15eef08d06d819bb93c73c0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7a5379cdb809096ffbe653fc91785eadbfa870/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8d7a5379cdb809096ffbe653fc91785eadbfa870", "patch": "@@ -656,9 +656,21 @@ expand_virtual_init (binfo, decl)\n   vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n   vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo));\n-  assemble_external (vtbl);\n-  TREE_USED (vtbl) = 1;\n-  vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n+\n+  if (TREE_CODE (vtbl) == VAR_DECL)\n+    {\n+      assemble_external (vtbl);\n+      TREE_USED (vtbl) = 1;\n+      vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n+    }\n+  else\n+    /* Under the new ABI, secondary vtables are stored with the\n+       primary vtable.  So, the BINFO_VTABLE may be an expression for\n+       computing the secondary vtable, rather than the secondary\n+       vtable itself.  */\n+    my_friendly_assert (merge_primary_and_secondary_vtables_p (), \n+\t\t\t20000220);\n+\n   /* Under the new ABI, we need to point into the middle of the\n      vtable.  */\n   if (vbase_offsets_in_vtable_p ())"}]}