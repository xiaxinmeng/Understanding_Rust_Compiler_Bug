{"sha": "c4d67e2d730f6a8e45182a384b5b674f5134bc64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRkNjdlMmQ3MzBmNmE4ZTQ1MTgyYTM4NGI1YjY3NGY1MTM0YmM2NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:17:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:17:28Z"}, "message": "[multiple changes]\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch6.adb (New_Overloaded_Entity): only issue error for SPARK\n\trestriction on overloaded entity if the entity is not an operator.\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch7.adb, sem_res.adb, sem_attr.adb, restrict.adb,\n\trestrict.ads: Rename remaining Check_Formal_Restriction* into\n\tCheck_SPARK_Restriction*.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb, prj-part.adb, prj.adb, prj.ads, prj-nmsc.adb,\n\tprj-nmsc.ads, prj-err.adb (Project_Data): now discriminated on its\n\tqualifier.\n\t(Project_Empty): removed\n\t(Empty_Project): new parameter Qualifier\n\tThis is used to have fields specific to aggregate projects, cleaner\n\tNew field to store the list of aggregated projects.\n\t(Check_Aggregate_Project): removed\n\t(Process_Aggregated_Projects, Free): new subprograms.\n\nFrom-SVN: r177243", "tree": {"sha": "2f36ebbabd6d8f0da8f9326f7c1404ccfd4d24e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f36ebbabd6d8f0da8f9326f7c1404ccfd4d24e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4d67e2d730f6a8e45182a384b5b674f5134bc64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d67e2d730f6a8e45182a384b5b674f5134bc64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d67e2d730f6a8e45182a384b5b674f5134bc64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d67e2d730f6a8e45182a384b5b674f5134bc64/comments", "author": null, "committer": null, "parents": [{"sha": "3f5a8feea3381fb0311e4d1a264c0661f37432dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5a8feea3381fb0311e4d1a264c0661f37432dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5a8feea3381fb0311e4d1a264c0661f37432dd"}], "stats": {"total": 2043, "additions": 1063, "deletions": 980}, "files": [{"sha": "5ef41f80ce2c633f4c0a9db7f6ffa1852c391a21", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -1,3 +1,26 @@\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch6.adb (New_Overloaded_Entity): only issue error for SPARK\n+\trestriction on overloaded entity if the entity is not an operator.\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch7.adb, sem_res.adb, sem_attr.adb, restrict.adb,\n+\trestrict.ads: Rename remaining Check_Formal_Restriction* into\n+\tCheck_SPARK_Restriction*.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb, prj-part.adb, prj.adb, prj.ads, prj-nmsc.adb,\n+\tprj-nmsc.ads, prj-err.adb (Project_Data): now discriminated on its\n+\tqualifier.\n+\t(Project_Empty): removed\n+\t(Empty_Project): new parameter Qualifier\n+\tThis is used to have fields specific to aggregate projects, cleaner\n+\tNew field to store the list of aggregated projects.\n+\t(Check_Aggregate_Project): removed\n+\t(Process_Aggregated_Projects, Free): new subprograms.\n+\n 2011-08-03  Olivier Hainque  <hainque@adacore.com>\n \n \t* tracebak.c (STOP_FRAME ppc AIX): Stop at null return address as well."}, {"sha": "75cf23b7bfc70983afc2138d6dd300eb99529840", "filename": "gcc/ada/prj-err.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-err.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-err.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-err.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,7 +78,7 @@ package body Prj.Err is\n       --  triggered)\n \n       if Current_Verbosity = High then\n-         Write_Line (\"ERROR: \" & Msg);\n+         Debug_Output (\"ERROR: \" & Msg);\n       end if;\n \n       --  If location of error is unknown, use the location of the project\n@@ -96,7 +96,7 @@ package body Prj.Err is\n          --  access to in any case.\n \n          if Current_Verbosity = High then\n-            Write_Line (\"Error in in-memory project, ignored\");\n+            Debug_Output (\"Error in in-memory project, ignored\");\n          end if;\n \n          return;"}, {"sha": "d05af1b39f2fc979364cced61246cf3f6638d8dc", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -30,6 +30,7 @@ with Output;   use Output;\n with Prj.Com;\n with Prj.Env;  use Prj.Env;\n with Prj.Err;  use Prj.Err;\n+with Prj.Tree; use Prj.Tree;\n with Prj.Util; use Prj.Util;\n with Sinput.P;\n with Snames;   use Snames;\n@@ -196,8 +197,8 @@ package body Prj.Nmsc is\n    --  Free the memory occupied by Data\n \n    procedure Check\n-     (Project     : Project_Id;\n-      Data        : in out Tree_Processing_Data);\n+     (Project      : Project_Id;\n+      Data         : in out Tree_Processing_Data);\n    --  Process the naming scheme for a single project\n \n    procedure Initialize\n@@ -247,7 +248,8 @@ package body Prj.Nmsc is\n    --  expanded pattern was found (1 for the first element of Patterns and\n    --  all its matching directories, then 2,...).\n    --  We use a generic and not an access-to-subprogram because in some cases\n-   --  this code is compiled with the restriction No_Implicit_Dynamic_Code\n+   --  this code is compiled with the restriction No_Implicit_Dynamic_Code.\n+   --  An error message is raised if a pattern does not match any file.\n \n    procedure Add_Source\n      (Id                  : out Source_Id;\n@@ -322,12 +324,6 @@ package body Prj.Nmsc is\n    --  Check the library attributes of project Project in project tree\n    --  and modify its data Data accordingly.\n \n-   procedure Check_Aggregate_Project\n-     (Project : Project_Id;\n-      Data    : in out Tree_Processing_Data);\n-   --  Check aggregate projects attributes, and find the list of aggregated\n-   --  projects. They are stored as a \"project_files\" language in Project.\n-\n    procedure Check_Abstract_Project\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data);\n@@ -923,19 +919,27 @@ package body Prj.Nmsc is\n       end if;\n    end Canonical_Case_File_Name;\n \n-   -----------------------------\n-   -- Check_Aggregate_Project --\n-   -----------------------------\n+   ---------------------------------\n+   -- Process_Aggregated_Projects --\n+   ---------------------------------\n \n-   procedure Check_Aggregate_Project\n-     (Project : Project_Id;\n-      Data    : in out Tree_Processing_Data)\n+   procedure Process_Aggregated_Projects\n+     (Tree         : Project_Tree_Ref;\n+      Project      : Project_Id;\n+      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags        : Processing_Flags)\n    is\n+      Data : Tree_Processing_Data :=\n+        (Tree           => Tree,\n+         Node_Tree      => Node_Tree,\n+         File_To_Source => Files_Htable.Nil,\n+         Flags          => Flags);\n+\n       Project_Files : constant Prj.Variable_Value :=\n                         Prj.Util.Value_Of\n                           (Snames.Name_Project_Files,\n                            Project.Decl.Attributes,\n-                           Data.Tree);\n+                           Tree);\n \n       Project_Path_For_Aggregate : Prj.Env.Project_Search_Path;\n \n@@ -954,7 +958,6 @@ package body Prj.Nmsc is\n \n       procedure Found_Project_File (Path : Path_Information; Rank : Natural) is\n          pragma Unreferenced (Rank);\n-         Full_Path : Path_Name_Type;\n       begin\n          Debug_Output (\"Aggregates: \", Name_Id (Path.Display_Name));\n \n@@ -963,30 +966,37 @@ package body Prj.Nmsc is\n          --  can only do this when processing the aggregate project, since the\n          --  exact list of project files or project directories can depend on\n          --  scenario variables.\n+         --  We only load the projects explicitly here, but do not process\n+         --  them. For the processing, Prj.Proc will take care of processing\n+         --  them, within the same call to Recursive_Process (thus avoiding the\n+         --  processing of a given project multiple times).\n          --\n          --  ??? We might already have loaded the project\n \n-         Prj.Env.Find_Project\n-           (Self              => Project_Path_For_Aggregate,\n-            Project_File_Name => Get_Name_String (Path.Name),\n-            Directory         => Get_Name_String (Project.Path.Name),\n-            Path              => Full_Path);\n+         Add_Aggregated_Project (Project, Path => Path.Name);\n       end Found_Project_File;\n \n    --  Start of processing for Check_Aggregate_Project\n \n    begin\n+      pragma Assert (Project.Qualifier = Aggregate);\n+\n       if Project_Files.Default then\n          Error_Msg_Name_1 := Snames.Name_Project_Files;\n          Error_Msg\n-           (Data.Flags,\n+           (Flags,\n             \"Attribute %% must be specified in aggregate project\",\n             Project.Location, Project);\n          return;\n       end if;\n \n+      --  The aggregated projects are only searched relative to the directory\n+      --  of the aggregate project, not in the default project path.\n+\n       Initialize_Empty (Project_Path_For_Aggregate);\n \n+      Free (Project.Aggregated_Projects);\n+\n       --  Look for aggregated projects. For similarity with source files and\n       --  dirs, the aggregated project files are not searched for on the\n       --  project path, and are only found through the path specified in\n@@ -1001,7 +1011,7 @@ package body Prj.Nmsc is\n          Resolve_Links => Opt.Follow_Links_For_Files);\n \n       Free (Project_Path_For_Aggregate);\n-   end Check_Aggregate_Project;\n+   end Process_Aggregated_Projects;\n \n    ----------------------------\n    -- Check_Abstract_Project --\n@@ -1058,7 +1068,7 @@ package body Prj.Nmsc is\n       Prj_Data  : Project_Processing_Data;\n \n    begin\n-      Debug_Increase_Indent (\"Check \", Project.Name);\n+      Debug_Increase_Indent (\"Check\", Project.Name);\n \n       Initialize (Prj_Data, Project);\n \n@@ -1074,7 +1084,6 @@ package body Prj.Nmsc is\n       end if;\n \n       case Project.Qualifier is\n-         when Aggregate => Check_Aggregate_Project (Project, Data);\n          when Dry       => Check_Abstract_Project  (Project, Data);\n          when others    => null;\n       end case;\n@@ -5222,7 +5231,7 @@ package body Prj.Nmsc is\n \n       if Current_Verbosity = High then\n          if Project.Object_Directory = No_Path_Information then\n-            Write_Line (\"No object directory\");\n+            Debug_Output (\"No object directory\");\n          else\n             Write_Attr\n               (\"Object directory\",\n@@ -7928,17 +7937,20 @@ package body Prj.Nmsc is\n       Element : String_Element;\n \n    begin\n-      Debug_Increase_Indent (\"Source_Dirs:\");\n-\n-      Current := Project.Source_Dirs;\n-      while Current /= Nil_String loop\n-         Element := In_Tree.String_Elements.Table (Current);\n-         Write_Str  (\"   \");\n-         Write_Line (Get_Name_String (Element.Display_Value));\n-         Current := Element.Next;\n-      end loop;\n+      if Project.Source_Dirs = Nil_String then\n+         Debug_Output (\"No source dirs\");\n+      else\n+         Debug_Increase_Indent (\"Source_Dirs:\");\n+\n+         Current := Project.Source_Dirs;\n+         while Current /= Nil_String loop\n+            Element := In_Tree.String_Elements.Table (Current);\n+            Debug_Output (Get_Name_String (Element.Display_Value));\n+            Current := Element.Next;\n+         end loop;\n \n-      Debug_Decrease_Indent (\"end Source_Dirs.\");\n+         Debug_Decrease_Indent (\"end Source_Dirs.\");\n+      end if;\n    end Show_Source_Dirs;\n \n    ---------------------------"}, {"sha": "47ae06b61da5eea0e50f1868809cad5aad709bad", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,4 +42,16 @@ private package Prj.Nmsc is\n    --  Project_Id which contains all the information about the project. This\n    --  information is only valid while the external references are preserved.\n \n+   procedure Process_Aggregated_Projects\n+     (Tree         : Project_Tree_Ref;\n+      Project      : Project_Id;\n+      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags        : Processing_Flags);\n+   --  Assuming Project is an aggregate project, find out (based on the\n+   --  current external references) what are the projects it aggregates.\n+   --  This has to be done in phase 1 of the processing, so that we know the\n+   --  full list of languages required for root_project and its aggregated\n+   --  projects. As a result, it cannot be done as part of\n+   --  Process_Naming_Scheme.\n+\n end Prj.Nmsc;"}, {"sha": "7fedc86e368f77f5a2f0e9e6c8d5d35884a89169", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -1870,7 +1870,7 @@ package body Prj.Part is\n \n       Tree.Restore_And_Free (Project_Comment_State);\n \n-      Debug_Decrease_Indent (\"Done parsing project\");\n+      Debug_Decrease_Indent;\n    end Parse_Single_Project;\n \n    -----------------------"}, {"sha": "ddab4362fd8cedc3dc6571a4179c2fe1fd6b5a6c", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 834, "deletions": 849, "changes": 1683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Prj.Attr; use Prj.Attr;\n with Prj.Err;  use Prj.Err;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Nmsc; use Prj.Nmsc;\n+with Prj.Part;\n with Snames;\n \n with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n@@ -128,7 +129,7 @@ package body Prj.Proc is\n       In_Tree                : Project_Tree_Ref;\n       Flags                  : Processing_Flags;\n       From_Project_Node      : Project_Node_Id;\n-      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Node_Tree              : Project_Node_Tree_Ref;\n       Pkg                    : Package_Id;\n       Item                   : Project_Node_Id);\n    --  Process declarative items starting with From_Project_Node, and put them\n@@ -1421,7 +1422,7 @@ package body Prj.Proc is\n       In_Tree                : Project_Tree_Ref;\n       Flags                  : Processing_Flags;\n       From_Project_Node      : Project_Node_Id;\n-      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Node_Tree : Project_Node_Tree_Ref;\n       Pkg                    : Package_Id;\n       Item                   : Project_Node_Id)\n    is\n@@ -1433,6 +1434,23 @@ package body Prj.Proc is\n       --  reported, or a warning, or nothing. In the last two cases, the value\n       --  of the variable is set to a valid value, replacing Value.\n \n+      procedure Process_Package_Declaration\n+        (Current_Item : Project_Node_Id);\n+      procedure Process_Attribute_Declaration (Current : Project_Node_Id);\n+      procedure Process_Case_Construction\n+        (Current_Item : Project_Node_Id);\n+      procedure Process_Associative_Array\n+        (Current_Item : Project_Node_Id);\n+      procedure Process_Expression\n+        (Current : Project_Node_Id);\n+      procedure Process_Expression_For_Associative_Array\n+        (Current_Item : Project_Node_Id;\n+         New_Value    : Variable_Value);\n+      procedure Process_Expression_Variable_Decl\n+        (Current_Item : Project_Node_Id;\n+         New_Value    : Variable_Value);\n+      --  Process the various declarative items\n+\n       ---------------------------------\n       -- Check_Or_Set_Typed_Variable --\n       ---------------------------------\n@@ -1441,8 +1459,7 @@ package body Prj.Proc is\n         (Value       : in out Variable_Value;\n          Declaration : Project_Node_Id)\n       is\n-         Loc : constant Source_Ptr :=\n-                 Location_Of (Declaration, From_Project_Node_Tree);\n+         Loc : constant Source_Ptr := Location_Of (Declaration, Node_Tree);\n \n          Reset_Value    : Boolean := False;\n          Current_String : Project_Node_Id;\n@@ -1451,7 +1468,7 @@ package body Prj.Proc is\n          --  Report an error for an empty string\n \n          if Value.Value = Empty_String then\n-            Error_Msg_Name_1 := Name_Of (Declaration, From_Project_Node_Tree);\n+            Error_Msg_Name_1 := Name_Of (Declaration, Node_Tree);\n \n             case Flags.Allow_Invalid_External is\n                when Error =>\n@@ -1467,24 +1484,22 @@ package body Prj.Proc is\n             --  Loop through all the valid strings for the\n             --  string type and compare to the string value.\n \n-            Current_String :=\n-              First_Literal_String\n-                (String_Type_Of (Declaration, From_Project_Node_Tree),\n-                 From_Project_Node_Tree);\n+            Current_String := First_Literal_String\n+              (String_Type_Of (Declaration, Node_Tree), Node_Tree);\n+\n             while Present (Current_String)\n-              and then String_Value_Of\n-                (Current_String, From_Project_Node_Tree) /= Value.Value\n+              and then String_Value_Of (Current_String, Node_Tree) /=\n+                 Value.Value\n             loop\n                Current_String :=\n-                 Next_Literal_String (Current_String, From_Project_Node_Tree);\n+                 Next_Literal_String (Current_String, Node_Tree);\n             end loop;\n \n             --  Report error if string value is not one for the string type\n \n             if No (Current_String) then\n                Error_Msg_Name_1 := Value.Value;\n-               Error_Msg_Name_2 :=\n-                 Name_Of (Declaration, From_Project_Node_Tree);\n+               Error_Msg_Name_2 := Name_Of (Declaration, Node_Tree);\n \n                case Flags.Allow_Invalid_External is\n                   when Error =>\n@@ -1505,909 +1520,801 @@ package body Prj.Proc is\n          if Reset_Value then\n             Current_String :=\n               First_Literal_String\n-                (String_Type_Of (Declaration, From_Project_Node_Tree),\n-                 From_Project_Node_Tree);\n-\n-            Value.Value := String_Value_Of\n-              (Current_String, From_Project_Node_Tree);\n+                (String_Type_Of (Declaration, Node_Tree), Node_Tree);\n+            Value.Value := String_Value_Of (Current_String, Node_Tree);\n          end if;\n       end Check_Or_Set_Typed_Variable;\n \n-      --  Local variables\n-\n-      Current_Declarative_Item : Project_Node_Id;\n-      Current_Item             : Project_Node_Id;\n+      ---------------------------------\n+      -- Process_Package_Declaration --\n+      ---------------------------------\n \n-   --  Start of processing for Process_Declarative_Items\n+      procedure Process_Package_Declaration\n+        (Current_Item : Project_Node_Id) is\n+      begin\n+         --  Do not process a package declaration that should be ignored\n \n-   begin\n-      --  Loop through declarative items\n+         if Expression_Kind_Of (Current_Item, Node_Tree) /= Ignored then\n+            --  Create the new package\n \n-      Current_Item := Empty_Node;\n+            Package_Table.Increment_Last (In_Tree.Packages);\n \n-      Current_Declarative_Item := Item;\n-      while Present (Current_Declarative_Item) loop\n+            declare\n+               New_Pkg         : constant Package_Id :=\n+                 Package_Table.Last (In_Tree.Packages);\n+               The_New_Package : Package_Element;\n \n-         --  Get its data\n+               Project_Of_Renamed_Package : constant Project_Node_Id :=\n+                 Project_Of_Renamed_Package_Of (Current_Item, Node_Tree);\n \n-         Current_Item :=\n-           Current_Item_Node\n-             (Current_Declarative_Item, From_Project_Node_Tree);\n+            begin\n+               --  Set the name of the new package\n \n-         --  And set Current_Declarative_Item to the next declarative item\n-         --  ready for the next iteration.\n+               The_New_Package.Name := Name_Of (Current_Item, Node_Tree);\n \n-         Current_Declarative_Item :=\n-           Next_Declarative_Item\n-             (Current_Declarative_Item, From_Project_Node_Tree);\n+               --  Insert the new package in the appropriate list\n \n-         case Kind_Of (Current_Item, From_Project_Node_Tree) is\n+               if Pkg /= No_Package then\n+                  The_New_Package.Next :=\n+                    In_Tree.Packages.Table (Pkg).Decl.Packages;\n+                  In_Tree.Packages.Table (Pkg).Decl.Packages := New_Pkg;\n \n-            when N_Package_Declaration =>\n+               else\n+                  The_New_Package.Next  := Project.Decl.Packages;\n+                  Project.Decl.Packages := New_Pkg;\n+               end if;\n \n-               --  Do not process a package declaration that should be ignored\n+               In_Tree.Packages.Table (New_Pkg) := The_New_Package;\n \n-               if Expression_Kind_Of\n-                    (Current_Item, From_Project_Node_Tree) /= Ignored\n-               then\n-                  --  Create the new package\n+               if Present (Project_Of_Renamed_Package) then\n \n-                  Package_Table.Increment_Last (In_Tree.Packages);\n+                  --  Renamed or extending package\n \n                   declare\n-                     New_Pkg         : constant Package_Id :=\n-                                         Package_Table.Last (In_Tree.Packages);\n-                     The_New_Package : Package_Element;\n+                     Project_Name : constant Name_Id :=\n+                       Name_Of (Project_Of_Renamed_Package, Node_Tree);\n+\n+                     Renamed_Project : constant Project_Id :=\n+                       Imported_Or_Extended_Project_From\n+                         (Project, Project_Name);\n \n-                     Project_Of_Renamed_Package :\n-                       constant Project_Node_Id :=\n-                         Project_Of_Renamed_Package_Of\n-                           (Current_Item, From_Project_Node_Tree);\n+                     Renamed_Package : constant Package_Id :=\n+                       Package_From\n+                         (Renamed_Project, In_Tree,\n+                          Name_Of (Current_Item, Node_Tree));\n \n                   begin\n-                     --  Set the name of the new package\n+                     --  For a renamed package, copy the declarations of\n+                     --  the renamed package, but set all the locations\n+                     --  to the location of the package name in the\n+                     --  renaming declaration.\n+\n+                     Copy_Package_Declarations\n+                       (From => In_Tree.Packages.Table (Renamed_Package).Decl,\n+                        To   => In_Tree.Packages.Table (New_Pkg).Decl,\n+                        New_Loc    => Location_Of (Current_Item, Node_Tree),\n+                        Restricted => False,\n+                        In_Tree    => In_Tree);\n+                  end;\n \n-                     The_New_Package.Name :=\n-                       Name_Of (Current_Item, From_Project_Node_Tree);\n+               else\n+                  --  Set the default values of the attributes\n+\n+                  Add_Attributes\n+                    (Project,\n+                     Project.Name,\n+                     Name_Id (Project.Directory.Name),\n+                     In_Tree,\n+                     In_Tree.Packages.Table (New_Pkg).Decl,\n+                     First_Attribute_Of\n+                       (Package_Id_Of (Current_Item, Node_Tree)),\n+                     Project_Level => False);\n+               end if;\n \n-                     --  Insert the new package in the appropriate list\n+               --  Process declarative items (nothing to do when the\n+               --  package is renaming, as the first declarative item is\n+               --  null).\n \n-                     if Pkg /= No_Package then\n-                        The_New_Package.Next :=\n-                          In_Tree.Packages.Table (Pkg).Decl.Packages;\n-                        In_Tree.Packages.Table (Pkg).Decl.Packages :=\n-                          New_Pkg;\n+               Process_Declarative_Items\n+                 (Project                => Project,\n+                  In_Tree                => In_Tree,\n+                  Flags                  => Flags,\n+                  From_Project_Node      => From_Project_Node,\n+                  Node_Tree => Node_Tree,\n+                  Pkg                    => New_Pkg,\n+                  Item                   =>\n+                    First_Declarative_Item_Of (Current_Item, Node_Tree));\n+            end;\n+         end if;\n+      end Process_Package_Declaration;\n \n-                     else\n-                        The_New_Package.Next  := Project.Decl.Packages;\n-                        Project.Decl.Packages := New_Pkg;\n-                     end if;\n+      -------------------------------\n+      -- Process_Associative_Array --\n+      -------------------------------\n \n-                     In_Tree.Packages.Table (New_Pkg) :=\n-                       The_New_Package;\n+      procedure Process_Associative_Array\n+        (Current_Item : Project_Node_Id)\n+      is\n+         Current_Item_Name : constant Name_Id :=\n+           Name_Of (Current_Item, Node_Tree);\n+         --  The name of the attribute\n \n-                     if Present (Project_Of_Renamed_Package) then\n+         Current_Location  : constant Source_Ptr :=\n+           Location_Of (Current_Item, Node_Tree);\n \n-                        --  Renamed or extending package\n+         New_Array : Array_Id;\n+         --  The new associative array created\n \n-                        declare\n-                           Project_Name : constant Name_Id :=\n-                                            Name_Of\n-                                              (Project_Of_Renamed_Package,\n-                                               From_Project_Node_Tree);\n-\n-                           Renamed_Project :\n-                             constant Project_Id :=\n-                               Imported_Or_Extended_Project_From\n-                               (Project, Project_Name);\n-\n-                           Renamed_Package : constant Package_Id :=\n-                                               Package_From\n-                                                 (Renamed_Project, In_Tree,\n-                                                  Name_Of\n-                                                    (Current_Item,\n-                                                     From_Project_Node_Tree));\n+         Orig_Array : Array_Id;\n+         --  The associative array value\n \n-                        begin\n-                           --  For a renamed package, copy the declarations of\n-                           --  the renamed package, but set all the locations\n-                           --  to the location of the package name in the\n-                           --  renaming declaration.\n-\n-                           Copy_Package_Declarations\n-                             (From       =>\n-                                In_Tree.Packages.Table (Renamed_Package).Decl,\n-                              To         =>\n-                                In_Tree.Packages.Table (New_Pkg).Decl,\n-                              New_Loc    =>\n-                                Location_Of\n-                                  (Current_Item, From_Project_Node_Tree),\n-                              Restricted => False,\n-                              In_Tree    => In_Tree);\n-                        end;\n+         Orig_Project_Name : Name_Id := No_Name;\n+         --  The name of the project where the associative array\n+         --  value is.\n \n-                     else\n-                        --  Set the default values of the attributes\n-\n-                        Add_Attributes\n-                          (Project,\n-                           Project.Name,\n-                           Name_Id (Project.Directory.Name),\n-                           In_Tree,\n-                           In_Tree.Packages.Table (New_Pkg).Decl,\n-                           First_Attribute_Of\n-                             (Package_Id_Of\n-                                (Current_Item, From_Project_Node_Tree)),\n-                           Project_Level => False);\n+         Orig_Project : Project_Id := No_Project;\n+         --  The id of the project where the associative array\n+         --  value is.\n \n-                     end if;\n+         Orig_Package_Name : Name_Id := No_Name;\n+         --  The name of the package, if any, where the associative\n+         --  array value is.\n \n-                     --  Process declarative items (nothing to do when the\n-                     --  package is renaming, as the first declarative item is\n-                     --  null).\n+         Orig_Package : Package_Id := No_Package;\n+         --  The id of the package, if any, where the associative\n+         --  array value is.\n \n-                     Process_Declarative_Items\n-                       (Project                => Project,\n-                        In_Tree                => In_Tree,\n-                        Flags                  => Flags,\n-                        From_Project_Node      => From_Project_Node,\n-                        From_Project_Node_Tree => From_Project_Node_Tree,\n-                        Pkg                    => New_Pkg,\n-                        Item                   =>\n-                          First_Declarative_Item_Of\n-                            (Current_Item, From_Project_Node_Tree));\n-                  end;\n-               end if;\n+         New_Element : Array_Element_Id := No_Array_Element;\n+         --  Id of a new array element created\n \n-            when N_String_Type_Declaration =>\n+         Prev_Element : Array_Element_Id := No_Array_Element;\n+         --  Last new element id created\n \n-               --  There is nothing to process\n+         Orig_Element : Array_Element_Id := No_Array_Element;\n+         --  Current array element in original associative array\n \n-               null;\n+         Next_Element : Array_Element_Id := No_Array_Element;\n+         --  Id of the array element that follows the new element.\n+         --  This is not always nil, because values for the\n+         --  associative array attribute may already have been\n+         --  declared, and the array elements declared are reused.\n \n-            when N_Attribute_Declaration      |\n-                 N_Typed_Variable_Declaration |\n-                 N_Variable_Declaration       =>\n+         Prj : Project_List;\n \n-               if Expression_Of (Current_Item, From_Project_Node_Tree) =\n-                                                                  Empty_Node\n-               then\n+      begin\n+         --  First find if the associative array attribute already\n+         --  has elements declared.\n \n-                  --  It must be a full associative array attribute declaration\n+         if Pkg /= No_Package then\n+            New_Array := In_Tree.Packages.Table (Pkg).Decl.Arrays;\n+         else\n+            New_Array := Project.Decl.Arrays;\n+         end if;\n \n-                  declare\n-                     Current_Item_Name : constant Name_Id :=\n-                                           Name_Of\n-                                             (Current_Item,\n-                                              From_Project_Node_Tree);\n-                     --  The name of the attribute\n+         while New_Array /= No_Array\n+           and then In_Tree.Arrays.Table (New_Array).Name /= Current_Item_Name\n+         loop\n+            New_Array := In_Tree.Arrays.Table (New_Array).Next;\n+         end loop;\n \n-                     Current_Location  : constant Source_Ptr :=\n-                                           Location_Of\n-                                             (Current_Item,\n-                                              From_Project_Node_Tree);\n+         --  If the attribute has never been declared add new entry\n+         --  in the arrays of the project/package and link it.\n \n-                     New_Array : Array_Id;\n-                     --  The new associative array created\n+         if New_Array = No_Array then\n+            Array_Table.Increment_Last (In_Tree.Arrays);\n+            New_Array := Array_Table.Last (In_Tree.Arrays);\n \n-                     Orig_Array : Array_Id;\n-                     --  The associative array value\n+            if Pkg /= No_Package then\n+               In_Tree.Arrays.Table (New_Array) :=\n+                 (Name     => Current_Item_Name,\n+                  Location => Current_Location,\n+                  Value    => No_Array_Element,\n+                  Next     => In_Tree.Packages.Table (Pkg).Decl.Arrays);\n \n-                     Orig_Project_Name : Name_Id := No_Name;\n-                     --  The name of the project where the associative array\n-                     --  value is.\n+               In_Tree.Packages.Table (Pkg).Decl.Arrays := New_Array;\n \n-                     Orig_Project : Project_Id := No_Project;\n-                     --  The id of the project where the associative array\n-                     --  value is.\n+            else\n+               In_Tree.Arrays.Table (New_Array) :=\n+                 (Name     => Current_Item_Name,\n+                  Location => Current_Location,\n+                  Value    => No_Array_Element,\n+                  Next     => Project.Decl.Arrays);\n \n-                     Orig_Package_Name : Name_Id := No_Name;\n-                     --  The name of the package, if any, where the associative\n-                     --  array value is.\n+               Project.Decl.Arrays := New_Array;\n+            end if;\n+         end if;\n \n-                     Orig_Package : Package_Id := No_Package;\n-                     --  The id of the package, if any, where the associative\n-                     --  array value is.\n+         --  Find the project where the value is declared\n \n-                     New_Element : Array_Element_Id := No_Array_Element;\n-                     --  Id of a new array element created\n+         Orig_Project_Name :=\n+           Name_Of\n+             (Associative_Project_Of (Current_Item, Node_Tree), Node_Tree);\n \n-                     Prev_Element : Array_Element_Id := No_Array_Element;\n-                     --  Last new element id created\n+         Prj := In_Tree.Projects;\n+         while Prj /= null loop\n+            if Prj.Project.Name = Orig_Project_Name then\n+               Orig_Project := Prj.Project;\n+               exit;\n+            end if;\n+            Prj := Prj.Next;\n+         end loop;\n \n-                     Orig_Element : Array_Element_Id := No_Array_Element;\n-                     --  Current array element in original associative array\n+         pragma Assert (Orig_Project /= No_Project,\n+                        \"original project not found\");\n \n-                     Next_Element : Array_Element_Id := No_Array_Element;\n-                     --  Id of the array element that follows the new element.\n-                     --  This is not always nil, because values for the\n-                     --  associative array attribute may already have been\n-                     --  declared, and the array elements declared are reused.\n+         if No (Associative_Package_Of (Current_Item, Node_Tree)) then\n+            Orig_Array := Orig_Project.Decl.Arrays;\n \n-                     Prj : Project_List;\n+         else\n+            --  If in a package, find the package where the value\n+            --  is declared.\n \n-                  begin\n-                     --  First find if the associative array attribute already\n-                     --  has elements declared.\n+            Orig_Package_Name :=\n+              Name_Of\n+                (Associative_Package_Of (Current_Item, Node_Tree), Node_Tree);\n \n-                     if Pkg /= No_Package then\n-                        New_Array := In_Tree.Packages.Table\n-                                       (Pkg).Decl.Arrays;\n+            Orig_Package := Orig_Project.Decl.Packages;\n+            pragma Assert (Orig_Package /= No_Package,\n+                           \"original package not found\");\n \n-                     else\n-                        New_Array := Project.Decl.Arrays;\n-                     end if;\n+            while In_Tree.Packages.Table\n+              (Orig_Package).Name /= Orig_Package_Name\n+            loop\n+               Orig_Package := In_Tree.Packages.Table (Orig_Package).Next;\n+               pragma Assert (Orig_Package /= No_Package,\n+                              \"original package not found\");\n+            end loop;\n \n-                     while New_Array /= No_Array\n-                       and then In_Tree.Arrays.Table (New_Array).Name /=\n-                                                           Current_Item_Name\n-                     loop\n-                        New_Array := In_Tree.Arrays.Table (New_Array).Next;\n-                     end loop;\n+            Orig_Array := In_Tree.Packages.Table (Orig_Package).Decl.Arrays;\n+         end if;\n \n-                     --  If the attribute has never been declared add new entry\n-                     --  in the arrays of the project/package and link it.\n+         --  Now look for the array\n \n-                     if New_Array = No_Array then\n-                        Array_Table.Increment_Last (In_Tree.Arrays);\n-                        New_Array := Array_Table.Last (In_Tree.Arrays);\n+         while Orig_Array /= No_Array\n+           and then In_Tree.Arrays.Table (Orig_Array).Name /= Current_Item_Name\n+         loop\n+            Orig_Array := In_Tree.Arrays.Table (Orig_Array).Next;\n+         end loop;\n \n-                        if Pkg /= No_Package then\n-                           In_Tree.Arrays.Table (New_Array) :=\n-                             (Name     => Current_Item_Name,\n-                              Location => Current_Location,\n-                              Value    => No_Array_Element,\n-                              Next     => In_Tree.Packages.Table\n-                                            (Pkg).Decl.Arrays);\n+         if Orig_Array = No_Array then\n+            Error_Msg\n+              (Flags,\n+               \"associative array value not found\",\n+               Location_Of (Current_Item, Node_Tree),\n+               Project);\n \n-                           In_Tree.Packages.Table (Pkg).Decl.Arrays :=\n-                             New_Array;\n+         else\n+            Orig_Element := In_Tree.Arrays.Table (Orig_Array).Value;\n \n-                        else\n-                           In_Tree.Arrays.Table (New_Array) :=\n-                             (Name     => Current_Item_Name,\n-                              Location => Current_Location,\n-                              Value    => No_Array_Element,\n-                              Next     => Project.Decl.Arrays);\n+            --  Copy each array element\n \n-                           Project.Decl.Arrays := New_Array;\n-                        end if;\n-                     end if;\n+            while Orig_Element /= No_Array_Element loop\n \n-                     --  Find the project where the value is declared\n+               --  Case of first element\n \n-                     Orig_Project_Name :=\n-                       Name_Of\n-                         (Associative_Project_Of\n-                              (Current_Item, From_Project_Node_Tree),\n-                          From_Project_Node_Tree);\n+               if Prev_Element = No_Array_Element then\n \n-                     Prj := In_Tree.Projects;\n-                     while Prj /= null loop\n-                        if Prj.Project.Name = Orig_Project_Name then\n-                           Orig_Project := Prj.Project;\n-                           exit;\n-                        end if;\n-                        Prj := Prj.Next;\n-                     end loop;\n+                  --  And there is no array element declared yet,\n+                  --  create a new first array element.\n \n-                     pragma Assert (Orig_Project /= No_Project,\n-                                    \"original project not found\");\n+                  if In_Tree.Arrays.Table (New_Array).Value =\n+                    No_Array_Element\n+                  then\n+                     Array_Element_Table.Increment_Last\n+                       (In_Tree.Array_Elements);\n+                     New_Element := Array_Element_Table.Last\n+                       (In_Tree.Array_Elements);\n+                     In_Tree.Arrays.Table (New_Array).Value := New_Element;\n+                     Next_Element := No_Array_Element;\n \n-                     if No (Associative_Package_Of\n-                              (Current_Item, From_Project_Node_Tree))\n-                     then\n-                        Orig_Array := Orig_Project.Decl.Arrays;\n+                     --  Otherwise, the new element is the first\n \n-                     else\n-                        --  If in a package, find the package where the value\n-                        --  is declared.\n+                  else\n+                     New_Element := In_Tree.Arrays. Table (New_Array).Value;\n+                     Next_Element :=\n+                       In_Tree.Array_Elements.Table (New_Element).Next;\n+                  end if;\n \n-                        Orig_Package_Name :=\n-                          Name_Of\n-                            (Associative_Package_Of\n-                                 (Current_Item, From_Project_Node_Tree),\n-                             From_Project_Node_Tree);\n+                  --  Otherwise, reuse an existing element, or create\n+                  --  one if necessary.\n \n-                        Orig_Package := Orig_Project.Decl.Packages;\n-                        pragma Assert (Orig_Package /= No_Package,\n-                                       \"original package not found\");\n+               else\n+                  Next_Element :=\n+                    In_Tree.Array_Elements.Table (Prev_Element).Next;\n \n-                        while In_Tree.Packages.Table\n-                                (Orig_Package).Name /= Orig_Package_Name\n-                        loop\n-                           Orig_Package := In_Tree.Packages.Table\n-                                             (Orig_Package).Next;\n-                           pragma Assert (Orig_Package /= No_Package,\n-                                          \"original package not found\");\n-                        end loop;\n+                  if Next_Element = No_Array_Element then\n+                     Array_Element_Table.Increment_Last\n+                       (In_Tree.Array_Elements);\n+                     New_Element :=\n+                       Array_Element_Table.Last (In_Tree.Array_Elements);\n+                     In_Tree.Array_Elements.Table (Prev_Element).Next :=\n+                       New_Element;\n \n-                        Orig_Array :=\n-                          In_Tree.Packages.Table (Orig_Package).Decl.Arrays;\n-                     end if;\n+                  else\n+                     New_Element := Next_Element;\n+                     Next_Element :=\n+                       In_Tree.Array_Elements.Table (New_Element).Next;\n+                  end if;\n+               end if;\n \n-                     --  Now look for the array\n+               --  Copy the value of the element\n \n-                     while Orig_Array /= No_Array\n-                       and then In_Tree.Arrays.Table (Orig_Array).Name /=\n-                                                         Current_Item_Name\n-                     loop\n-                        Orig_Array := In_Tree.Arrays.Table\n-                                        (Orig_Array).Next;\n-                     end loop;\n+               In_Tree.Array_Elements.Table (New_Element) :=\n+                 In_Tree.Array_Elements.Table (Orig_Element);\n+               In_Tree.Array_Elements.Table (New_Element).Value.Project :=\n+                 Project;\n \n-                     if Orig_Array = No_Array then\n-                        Error_Msg\n-                          (Flags,\n-                           \"associative array value not found\",\n-                           Location_Of (Current_Item, From_Project_Node_Tree),\n-                           Project);\n+               --  Adjust the Next link\n \n-                     else\n-                        Orig_Element :=\n-                          In_Tree.Arrays.Table (Orig_Array).Value;\n+               In_Tree.Array_Elements.Table (New_Element).Next := Next_Element;\n \n-                        --  Copy each array element\n+               --  Adjust the previous id for the next element\n \n-                        while Orig_Element /= No_Array_Element loop\n+               Prev_Element := New_Element;\n \n-                           --  Case of first element\n+               --  Go to the next element in the original array\n \n-                           if Prev_Element = No_Array_Element then\n+               Orig_Element :=\n+                 In_Tree.Array_Elements.Table (Orig_Element).Next;\n+            end loop;\n \n-                              --  And there is no array element declared yet,\n-                              --  create a new first array element.\n+            --  Make sure that the array ends here, in case there\n+            --  previously a greater number of elements.\n \n-                              if In_Tree.Arrays.Table (New_Array).Value =\n-                                                              No_Array_Element\n-                              then\n-                                 Array_Element_Table.Increment_Last\n-                                   (In_Tree.Array_Elements);\n-                                 New_Element := Array_Element_Table.Last\n-                                   (In_Tree.Array_Elements);\n-                                 In_Tree.Arrays.Table\n-                                   (New_Array).Value := New_Element;\n-                                 Next_Element := No_Array_Element;\n+            In_Tree.Array_Elements.Table (New_Element).Next :=\n+              No_Array_Element;\n+         end if;\n+      end Process_Associative_Array;\n \n-                              --  Otherwise, the new element is the first\n+      ----------------------------------------------\n+      -- Process_Expression_For_Associative_Array --\n+      ----------------------------------------------\n \n-                              else\n-                                 New_Element := In_Tree.Arrays.\n-                                                  Table (New_Array).Value;\n-                                 Next_Element :=\n-                                   In_Tree.Array_Elements.Table\n-                                     (New_Element).Next;\n-                              end if;\n+      procedure Process_Expression_For_Associative_Array\n+        (Current_Item : Project_Node_Id;\n+         New_Value    : Variable_Value)\n+      is\n+         Current_Item_Name : constant Name_Id :=\n+           Name_Of (Current_Item, Node_Tree);\n+         Current_Location : constant Source_Ptr :=\n+           Location_Of (Current_Item, Node_Tree);\n \n-                           --  Otherwise, reuse an existing element, or create\n-                           --  one if necessary.\n+         Index_Name : Name_Id :=\n+           Associative_Array_Index_Of (Current_Item, Node_Tree);\n \n-                           else\n-                              Next_Element :=\n-                                In_Tree.Array_Elements.Table\n-                                  (Prev_Element).Next;\n+         Source_Index : constant Int :=\n+           Source_Index_Of (Current_Item, Node_Tree);\n \n-                              if Next_Element = No_Array_Element then\n-                                 Array_Element_Table.Increment_Last\n-                                   (In_Tree.Array_Elements);\n-                                 New_Element :=\n-                                   Array_Element_Table.Last\n-                                    (In_Tree.Array_Elements);\n-                                 In_Tree.Array_Elements.Table\n-                                   (Prev_Element).Next := New_Element;\n+         The_Array         : Array_Id;\n+         The_Array_Element : Array_Element_Id := No_Array_Element;\n \n-                              else\n-                                 New_Element := Next_Element;\n-                                 Next_Element :=\n-                                   In_Tree.Array_Elements.Table\n-                                     (New_Element).Next;\n-                              end if;\n-                           end if;\n+      begin\n+         if Index_Name /= All_Other_Names then\n+            Index_Name := Get_Attribute_Index\n+              (Node_Tree,\n+               Current_Item,\n+               Associative_Array_Index_Of (Current_Item, Node_Tree));\n+         end if;\n \n-                           --  Copy the value of the element\n+         --  Look for the array in the appropriate list\n \n-                           In_Tree.Array_Elements.Table\n-                             (New_Element) :=\n-                               In_Tree.Array_Elements.Table (Orig_Element);\n-                           In_Tree.Array_Elements.Table\n-                             (New_Element).Value.Project := Project;\n+         if Pkg /= No_Package then\n+            The_Array := In_Tree.Packages.Table (Pkg).Decl.Arrays;\n+         else\n+            The_Array := Project.Decl.Arrays;\n+         end if;\n \n-                           --  Adjust the Next link\n+         while The_Array /= No_Array\n+           and then In_Tree.Arrays.Table (The_Array).Name /= Current_Item_Name\n+         loop\n+            The_Array := In_Tree.Arrays.Table (The_Array).Next;\n+         end loop;\n \n-                           In_Tree.Array_Elements.Table\n-                             (New_Element).Next := Next_Element;\n+         --  If the array cannot be found, create a new entry\n+         --  in the list. As The_Array_Element is initialized\n+         --  to No_Array_Element, a new element will be\n+         --  created automatically later\n \n-                           --  Adjust the previous id for the next element\n+         if The_Array = No_Array then\n+            Array_Table.Increment_Last (In_Tree.Arrays);\n+            The_Array := Array_Table.Last (In_Tree.Arrays);\n \n-                           Prev_Element := New_Element;\n+            if Pkg /= No_Package then\n+               In_Tree.Arrays.Table (The_Array) :=\n+                 (Name     => Current_Item_Name,\n+                  Location => Current_Location,\n+                  Value    => No_Array_Element,\n+                  Next     => In_Tree.Packages.Table (Pkg).Decl.Arrays);\n \n-                           --  Go to the next element in the original array\n+               In_Tree.Packages.Table (Pkg).Decl.Arrays := The_Array;\n \n-                           Orig_Element :=\n-                             In_Tree.Array_Elements.Table\n-                               (Orig_Element).Next;\n-                        end loop;\n+            else\n+               In_Tree.Arrays.Table (The_Array) :=\n+                 (Name     => Current_Item_Name,\n+                  Location => Current_Location,\n+                  Value    => No_Array_Element,\n+                  Next     => Project.Decl.Arrays);\n \n-                        --  Make sure that the array ends here, in case there\n-                        --  previously a greater number of elements.\n+               Project.Decl.Arrays := The_Array;\n+            end if;\n \n-                        In_Tree.Array_Elements.Table\n-                          (New_Element).Next := No_Array_Element;\n-                     end if;\n-                  end;\n+            --  Otherwise initialize The_Array_Element as the\n+            --  head of the element list.\n \n-               --  Declarations other that full associative arrays\n+         else\n+            The_Array_Element := In_Tree.Arrays.Table (The_Array).Value;\n+         end if;\n \n-               else\n-                  declare\n-                     New_Value : Variable_Value :=\n-                       Expression\n-                         (Project                => Project,\n-                          In_Tree                => In_Tree,\n-                          Flags                  => Flags,\n-                          From_Project_Node      => From_Project_Node,\n-                          From_Project_Node_Tree => From_Project_Node_Tree,\n-                          Pkg                    => Pkg,\n-                          First_Term             =>\n-                            Tree.First_Term\n-                              (Expression_Of\n-                                   (Current_Item, From_Project_Node_Tree),\n-                               From_Project_Node_Tree),\n-                          Kind                   =>\n-                            Expression_Kind_Of\n-                              (Current_Item, From_Project_Node_Tree));\n-                     --  The expression value\n-\n-                     The_Variable : Variable_Id := No_Variable;\n-\n-                     Current_Item_Name : constant Name_Id :=\n-                                           Name_Of\n-                                             (Current_Item,\n-                                              From_Project_Node_Tree);\n-\n-                     Current_Location : constant Source_Ptr :=\n-                                          Location_Of\n-                                            (Current_Item,\n-                                             From_Project_Node_Tree);\n+         --  Look in the list, if any, to find an element\n+         --  with the same index and same source index.\n \n-                  begin\n-                     --  Process a typed variable declaration\n-\n-                     if Kind_Of (Current_Item, From_Project_Node_Tree) =\n-                          N_Typed_Variable_Declaration\n-                     then\n-                        Check_Or_Set_Typed_Variable\n-                          (Value       => New_Value,\n-                           Declaration => Current_Item);\n-                     end if;\n+         while The_Array_Element /= No_Array_Element\n+           and then\n+             (In_Tree.Array_Elements.Table (The_Array_Element).Index /=\n+                Index_Name\n+              or else\n+                In_Tree.Array_Elements.Table (The_Array_Element).Src_Index /=\n+                Source_Index)\n+         loop\n+            The_Array_Element :=\n+              In_Tree.Array_Elements.Table (The_Array_Element).Next;\n+         end loop;\n \n-                     --  Comment here ???\n+         --  If no such element were found, create a new one\n+         --  and insert it in the element list, with the\n+         --  proper value.\n \n-                     if Kind_Of (Current_Item, From_Project_Node_Tree) /=\n-                          N_Attribute_Declaration\n-                       or else\n-                         Associative_Array_Index_Of\n-                           (Current_Item, From_Project_Node_Tree) = No_Name\n-                     then\n-                        --  Case of a variable declaration or of a not\n-                        --  associative array attribute.\n+         if The_Array_Element = No_Array_Element then\n+            Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n+            The_Array_Element :=\n+              Array_Element_Table.Last (In_Tree.Array_Elements);\n \n-                        --  First, find the list where to find the variable\n-                        --  or attribute.\n+            In_Tree.Array_Elements.Table\n+              (The_Array_Element) :=\n+              (Index                => Index_Name,\n+               Src_Index            => Source_Index,\n+               Index_Case_Sensitive =>\n+                  not Case_Insensitive (Current_Item, Node_Tree),\n+               Value                => New_Value,\n+               Next                 => In_Tree.Arrays.Table (The_Array).Value);\n \n-                        if Kind_Of (Current_Item, From_Project_Node_Tree) =\n-                             N_Attribute_Declaration\n-                        then\n-                           if Pkg /= No_Package then\n-                              The_Variable :=\n-                                In_Tree.Packages.Table\n-                                  (Pkg).Decl.Attributes;\n-                           else\n-                              The_Variable := Project.Decl.Attributes;\n-                           end if;\n+            In_Tree.Arrays.Table (The_Array).Value := The_Array_Element;\n \n-                        else\n-                           if Pkg /= No_Package then\n-                              The_Variable :=\n-                                In_Tree.Packages.Table\n-                                  (Pkg).Decl.Variables;\n-                           else\n-                              The_Variable := Project.Decl.Variables;\n-                           end if;\n+            --  An element with the same index already exists,\n+            --  just replace its value with the new one.\n \n-                        end if;\n+         else\n+            In_Tree.Array_Elements.Table (The_Array_Element).Value :=\n+              New_Value;\n+         end if;\n+      end Process_Expression_For_Associative_Array;\n \n-                        --  Loop through the list, to find if it has already\n-                        --  been declared.\n+      --------------------------------------\n+      -- Process_Expression_Variable_Decl --\n+      --------------------------------------\n \n-                        while The_Variable /= No_Variable\n-                          and then\n-                            In_Tree.Variable_Elements.Table\n-                              (The_Variable).Name /= Current_Item_Name\n-                        loop\n-                           The_Variable :=\n-                             In_Tree.Variable_Elements.Table\n-                               (The_Variable).Next;\n-                        end loop;\n+      procedure Process_Expression_Variable_Decl\n+        (Current_Item : Project_Node_Id;\n+         New_Value    : Variable_Value)\n+      is\n+         Current_Item_Name : constant Name_Id :=\n+           Name_Of (Current_Item, Node_Tree);\n+         The_Variable : Variable_Id := No_Variable;\n \n-                        --  If it has not been declared, create a new entry\n-                        --  in the list.\n+      begin\n+         --  First, find the list where to find the variable or attribute.\n \n-                        if The_Variable = No_Variable then\n+         if Kind_Of (Current_Item, Node_Tree) =\n+           N_Attribute_Declaration\n+         then\n+            if Pkg /= No_Package then\n+               The_Variable := In_Tree.Packages.Table (Pkg).Decl.Attributes;\n+            else\n+               The_Variable := Project.Decl.Attributes;\n+            end if;\n \n-                           --  All single string attribute should already have\n-                           --  been declared with a default empty string value.\n+         else\n+            if Pkg /= No_Package then\n+               The_Variable := In_Tree.Packages.Table (Pkg).Decl.Variables;\n+            else\n+               The_Variable := Project.Decl.Variables;\n+            end if;\n+         end if;\n \n-                           pragma Assert\n-                             (Kind_Of (Current_Item, From_Project_Node_Tree) /=\n-                                N_Attribute_Declaration,\n-                              \"illegal attribute declaration for \"\n-                              & Get_Name_String (Current_Item_Name));\n+         --  Loop through the list, to find if it has already been declared.\n \n-                           Variable_Element_Table.Increment_Last\n-                             (In_Tree.Variable_Elements);\n-                           The_Variable := Variable_Element_Table.Last\n-                             (In_Tree.Variable_Elements);\n+         while The_Variable /= No_Variable\n+           and then In_Tree.Variable_Elements.Table (The_Variable).Name /=\n+              Current_Item_Name\n+         loop\n+            The_Variable :=\n+              In_Tree.Variable_Elements.Table (The_Variable).Next;\n+         end loop;\n \n-                           --  Put the new variable in the appropriate list\n+         --  If it has not been declared, create a new entry\n+         --  in the list.\n \n-                           if Pkg /= No_Package then\n-                              In_Tree.Variable_Elements.Table (The_Variable) :=\n-                                (Next   =>\n-                                   In_Tree.Packages.Table\n-                                     (Pkg).Decl.Variables,\n-                                 Name   => Current_Item_Name,\n-                                 Value  => New_Value);\n-                              In_Tree.Packages.Table\n-                                (Pkg).Decl.Variables := The_Variable;\n+         if The_Variable = No_Variable then\n \n-                           else\n-                              In_Tree.Variable_Elements.Table (The_Variable) :=\n-                                (Next   => Project.Decl.Variables,\n-                                 Name   => Current_Item_Name,\n-                                 Value  => New_Value);\n-                              Project.Decl.Variables := The_Variable;\n-                           end if;\n+            --  All single string attribute should already have\n+            --  been declared with a default empty string value.\n \n-                        --  If the variable/attribute has already been\n-                        --  declared, just change the value.\n+            pragma Assert\n+              (Kind_Of (Current_Item, Node_Tree) /=\n+                 N_Attribute_Declaration,\n+               \"illegal attribute declaration for \"\n+               & Get_Name_String (Current_Item_Name));\n \n-                        else\n-                           In_Tree.Variable_Elements.Table\n-                             (The_Variable).Value := New_Value;\n-                        end if;\n+            Variable_Element_Table.Increment_Last (In_Tree.Variable_Elements);\n+            The_Variable := Variable_Element_Table.Last\n+              (In_Tree.Variable_Elements);\n \n-                     --  Associative array attribute\n+            --  Put the new variable in the appropriate list\n \n-                     else\n-                        declare\n-                           Index_Name : Name_Id :=\n-                                          Associative_Array_Index_Of\n-                                           (Current_Item,\n-                                            From_Project_Node_Tree);\n+            if Pkg /= No_Package then\n+               In_Tree.Variable_Elements.Table (The_Variable) :=\n+                 (Next   => In_Tree.Packages.Table (Pkg).Decl.Variables,\n+                  Name   => Current_Item_Name,\n+                  Value  => New_Value);\n+               In_Tree.Packages.Table (Pkg).Decl.Variables := The_Variable;\n \n-                           Source_Index : constant Int :=\n-                                            Source_Index_Of\n-                                              (Current_Item,\n-                                               From_Project_Node_Tree);\n+            else\n+               In_Tree.Variable_Elements.Table (The_Variable) :=\n+                 (Next   => Project.Decl.Variables,\n+                  Name   => Current_Item_Name,\n+                  Value  => New_Value);\n+               Project.Decl.Variables := The_Variable;\n+            end if;\n \n-                           The_Array         : Array_Id;\n-                           The_Array_Element : Array_Element_Id :=\n-                                                 No_Array_Element;\n+            --  If the variable/attribute has already been\n+            --  declared, just change the value.\n \n-                        begin\n-                           if Index_Name /= All_Other_Names then\n-                              Index_Name := Get_Attribute_Index\n-                                (From_Project_Node_Tree,\n-                                 Current_Item,\n-                                 Associative_Array_Index_Of\n-                                   (Current_Item, From_Project_Node_Tree));\n-                           end if;\n+         else\n+            In_Tree.Variable_Elements.Table (The_Variable).Value := New_Value;\n+         end if;\n+      end Process_Expression_Variable_Decl;\n \n-                           --  Look for the array in the appropriate list\n+      ------------------------\n+      -- Process_Expression --\n+      ------------------------\n \n-                           if Pkg /= No_Package then\n-                              The_Array :=\n-                                In_Tree.Packages.Table (Pkg).Decl.Arrays;\n-                           else\n-                              The_Array :=\n-                                Project.Decl.Arrays;\n-                           end if;\n+      procedure Process_Expression\n+        (Current : Project_Node_Id)\n+      is\n+         New_Value : Variable_Value :=\n+           Expression\n+             (Project                => Project,\n+              In_Tree                => In_Tree,\n+              Flags                  => Flags,\n+              From_Project_Node      => From_Project_Node,\n+              From_Project_Node_Tree => Node_Tree,\n+              Pkg                    => Pkg,\n+              First_Term             =>\n+                Tree.First_Term\n+                  (Expression_Of (Current, Node_Tree), Node_Tree),\n+              Kind                 => Expression_Kind_Of (Current, Node_Tree));\n \n-                           while\n-                             The_Array /= No_Array\n-                               and then\n-                                 In_Tree.Arrays.Table (The_Array).Name /=\n-                                                            Current_Item_Name\n-                           loop\n-                              The_Array :=\n-                                In_Tree.Arrays.Table (The_Array).Next;\n-                           end loop;\n+      begin\n+         --  Process a typed variable declaration\n \n-                           --  If the array cannot be found, create a new entry\n-                           --  in the list. As The_Array_Element is initialized\n-                           --  to No_Array_Element, a new element will be\n-                           --  created automatically later\n+         if Kind_Of (Current, Node_Tree) =\n+           N_Typed_Variable_Declaration\n+         then\n+            Check_Or_Set_Typed_Variable (New_Value, Current);\n+         end if;\n \n-                           if The_Array = No_Array then\n-                              Array_Table.Increment_Last (In_Tree.Arrays);\n-                              The_Array := Array_Table.Last (In_Tree.Arrays);\n+         if Kind_Of (Current, Node_Tree) /= N_Attribute_Declaration\n+           or else Associative_Array_Index_Of (Current, Node_Tree) = No_Name\n+         then\n+            Process_Expression_Variable_Decl (Current, New_Value);\n+         else\n+            Process_Expression_For_Associative_Array (Current, New_Value);\n+         end if;\n+      end Process_Expression;\n \n-                              if Pkg /= No_Package then\n-                                 In_Tree.Arrays.Table (The_Array) :=\n-                                   (Name     => Current_Item_Name,\n-                                    Location => Current_Location,\n-                                    Value    => No_Array_Element,\n-                                    Next     => In_Tree.Packages.Table\n-                                                  (Pkg).Decl.Arrays);\n+      -----------------------------------\n+      -- Process_Attribute_Declaration --\n+      -----------------------------------\n \n-                                 In_Tree.Packages.Table (Pkg).Decl.Arrays :=\n-                                     The_Array;\n+      procedure Process_Attribute_Declaration (Current : Project_Node_Id) is\n+      begin\n+         if Expression_Of (Current, Node_Tree) = Empty_Node then\n+            Process_Associative_Array (Current);\n+         else\n+            Process_Expression (Current);\n+         end if;\n+      end Process_Attribute_Declaration;\n \n-                              else\n-                                 In_Tree.Arrays.Table (The_Array) :=\n-                                   (Name     => Current_Item_Name,\n-                                    Location => Current_Location,\n-                                    Value    => No_Array_Element,\n-                                    Next     => Project.Decl.Arrays);\n+      -------------------------------\n+      -- Process_Case_Construction --\n+      -------------------------------\n \n-                                 Project.Decl.Arrays := The_Array;\n-                              end if;\n+      procedure Process_Case_Construction\n+        (Current_Item             : Project_Node_Id)\n+      is\n+         The_Project : Project_Id := Project;\n+         --  The id of the project of the case variable\n \n-                           --  Otherwise initialize The_Array_Element as the\n-                           --  head of the element list.\n+         The_Package : Package_Id := Pkg;\n+         --  The id of the package, if any, of the case variable\n \n-                           else\n-                              The_Array_Element :=\n-                                In_Tree.Arrays.Table (The_Array).Value;\n-                           end if;\n+         The_Variable : Variable_Value := Nil_Variable_Value;\n+         --  The case variable\n \n-                           --  Look in the list, if any, to find an element\n-                           --  with the same index and same source index.\n+         Case_Value : Name_Id := No_Name;\n+         --  The case variable value\n \n-                           while The_Array_Element /= No_Array_Element\n-                             and then\n-                               (In_Tree.Array_Elements.Table\n-                                 (The_Array_Element).Index /= Index_Name\n-                                 or else\n-                                In_Tree.Array_Elements.Table\n-                                 (The_Array_Element).Src_Index /= Source_Index)\n-                           loop\n-                              The_Array_Element :=\n-                                In_Tree.Array_Elements.Table\n-                                  (The_Array_Element).Next;\n-                           end loop;\n+         Case_Item     : Project_Node_Id := Empty_Node;\n+         Choice_String : Project_Node_Id := Empty_Node;\n+         Decl_Item     : Project_Node_Id := Empty_Node;\n \n-                           --  If no such element were found, create a new one\n-                           --  and insert it in the element list, with the\n-                           --  proper value.\n-\n-                           if The_Array_Element = No_Array_Element then\n-                              Array_Element_Table.Increment_Last\n-                                (In_Tree.Array_Elements);\n-                              The_Array_Element :=\n-                                Array_Element_Table.Last\n-                                  (In_Tree.Array_Elements);\n-\n-                              In_Tree.Array_Elements.Table\n-                                (The_Array_Element) :=\n-                                  (Index                => Index_Name,\n-                                   Src_Index            => Source_Index,\n-                                   Index_Case_Sensitive =>\n-                                     not Case_Insensitive\n-                                       (Current_Item, From_Project_Node_Tree),\n-                                   Value                => New_Value,\n-                                   Next                 =>\n-                                     In_Tree.Arrays.Table (The_Array).Value);\n-\n-                              In_Tree.Arrays.Table (The_Array).Value :=\n-                                The_Array_Element;\n-\n-                           --  An element with the same index already exists,\n-                           --  just replace its value with the new one.\n+      begin\n+         declare\n+            Variable_Node : constant Project_Node_Id :=\n+              Case_Variable_Reference_Of\n+                (Current_Item,\n+                 Node_Tree);\n \n-                           else\n-                              In_Tree.Array_Elements.Table\n-                                (The_Array_Element).Value := New_Value;\n-                           end if;\n-                        end;\n-                     end if;\n-                  end;\n-               end if;\n+            Var_Id : Variable_Id := No_Variable;\n+            Name   : Name_Id     := No_Name;\n \n-            when N_Case_Construction =>\n-               declare\n-                  The_Project : Project_Id := Project;\n-                  --  The id of the project of the case variable\n+         begin\n+            --  If a project was specified for the case variable,\n+            --  get its id.\n+\n+            if Present (Project_Node_Of (Variable_Node, Node_Tree)) then\n+               Name :=\n+                 Name_Of\n+                   (Project_Node_Of (Variable_Node, Node_Tree), Node_Tree);\n+               The_Project :=\n+                 Imported_Or_Extended_Project_From (Project, Name);\n+            end if;\n \n-                  The_Package : Package_Id := Pkg;\n-                  --  The id of the package, if any, of the case variable\n+            --  If a package were specified for the case variable,\n+            --  get its id.\n \n-                  The_Variable : Variable_Value := Nil_Variable_Value;\n-                  --  The case variable\n+            if Present (Package_Node_Of (Variable_Node, Node_Tree)) then\n+               Name :=\n+                 Name_Of\n+                   (Package_Node_Of (Variable_Node, Node_Tree), Node_Tree);\n+               The_Package := Package_From (The_Project, In_Tree, Name);\n+            end if;\n \n-                  Case_Value : Name_Id := No_Name;\n-                  --  The case variable value\n+            Name := Name_Of (Variable_Node, Node_Tree);\n \n-                  Case_Item     : Project_Node_Id := Empty_Node;\n-                  Choice_String : Project_Node_Id := Empty_Node;\n-                  Decl_Item     : Project_Node_Id := Empty_Node;\n+            --  First, look for the case variable into the package,\n+            --  if any.\n \n-               begin\n-                  declare\n-                     Variable_Node : constant Project_Node_Id :=\n-                                       Case_Variable_Reference_Of\n-                                         (Current_Item,\n-                                          From_Project_Node_Tree);\n+            if The_Package /= No_Package then\n+               Var_Id := In_Tree.Packages.Table (The_Package).Decl.Variables;\n+               Name := Name_Of (Variable_Node, Node_Tree);\n+               while Var_Id /= No_Variable\n+                 and then In_Tree.Variable_Elements.Table (Var_Id).Name /= Name\n+               loop\n+                  Var_Id := In_Tree.Variable_Elements.Table (Var_Id).Next;\n+               end loop;\n+            end if;\n \n-                     Var_Id : Variable_Id := No_Variable;\n-                     Name   : Name_Id     := No_Name;\n+            --  If not found in the package, or if there is no\n+            --  package, look at the project level.\n \n-                  begin\n-                     --  If a project was specified for the case variable,\n-                     --  get its id.\n-\n-                     if Present (Project_Node_Of\n-                                   (Variable_Node, From_Project_Node_Tree))\n-                     then\n-                        Name :=\n-                          Name_Of\n-                            (Project_Node_Of\n-                               (Variable_Node, From_Project_Node_Tree),\n-                             From_Project_Node_Tree);\n-                        The_Project :=\n-                          Imported_Or_Extended_Project_From (Project, Name);\n-                     end if;\n+            if Var_Id = No_Variable\n+              and then No (Package_Node_Of (Variable_Node, Node_Tree))\n+            then\n+               Var_Id := The_Project.Decl.Variables;\n+               while Var_Id /= No_Variable\n+                 and then In_Tree.Variable_Elements.Table (Var_Id).Name /= Name\n+               loop\n+                  Var_Id := In_Tree.Variable_Elements.Table (Var_Id).Next;\n+               end loop;\n+            end if;\n \n-                     --  If a package were specified for the case variable,\n-                     --  get its id.\n-\n-                     if Present (Package_Node_Of\n-                                   (Variable_Node, From_Project_Node_Tree))\n-                     then\n-                        Name :=\n-                          Name_Of\n-                            (Package_Node_Of\n-                               (Variable_Node, From_Project_Node_Tree),\n-                             From_Project_Node_Tree);\n-                        The_Package :=\n-                          Package_From (The_Project, In_Tree, Name);\n-                     end if;\n+            if Var_Id = No_Variable then\n \n-                     Name := Name_Of (Variable_Node, From_Project_Node_Tree);\n+               --  Should never happen, because this has already been\n+               --  checked during parsing.\n \n-                     --  First, look for the case variable into the package,\n-                     --  if any.\n+               Write_Line\n+                 (\"variable \"\"\" & Get_Name_String (Name) & \"\"\" not found\");\n+               raise Program_Error;\n+            end if;\n \n-                     if The_Package /= No_Package then\n-                        Var_Id := In_Tree.Packages.Table\n-                                    (The_Package).Decl.Variables;\n-                        Name :=\n-                          Name_Of (Variable_Node, From_Project_Node_Tree);\n-                        while Var_Id /= No_Variable\n-                          and then\n-                            In_Tree.Variable_Elements.Table\n-                              (Var_Id).Name /= Name\n-                        loop\n-                           Var_Id := In_Tree.Variable_Elements.\n-                                       Table (Var_Id).Next;\n-                        end loop;\n-                     end if;\n+            --  Get the case variable\n \n-                     --  If not found in the package, or if there is no\n-                     --  package, look at the project level.\n+            The_Variable := In_Tree.Variable_Elements. Table (Var_Id).Value;\n \n-                     if Var_Id = No_Variable\n-                        and then\n-                        No (Package_Node_Of\n-                              (Variable_Node, From_Project_Node_Tree))\n-                     then\n-                        Var_Id := The_Project.Decl.Variables;\n-                        while Var_Id /= No_Variable\n-                          and then\n-                            In_Tree.Variable_Elements.Table\n-                              (Var_Id).Name /= Name\n-                        loop\n-                           Var_Id := In_Tree.Variable_Elements.\n-                                       Table (Var_Id).Next;\n-                        end loop;\n-                     end if;\n+            if The_Variable.Kind /= Single then\n \n-                     if Var_Id = No_Variable then\n+               --  Should never happen, because this has already been\n+               --  checked during parsing.\n \n-                        --  Should never happen, because this has already been\n-                        --  checked during parsing.\n+               Write_Line (\"variable\"\"\" & Get_Name_String (Name) &\n+                           \"\"\" is not a single string variable\");\n+               raise Program_Error;\n+            end if;\n \n-                        Write_Line (\"variable \"\"\" &\n-                                    Get_Name_String (Name) &\n-                                    \"\"\" not found\");\n-                        raise Program_Error;\n-                     end if;\n+            --  Get the case variable value\n+            Case_Value := The_Variable.Value;\n+         end;\n \n-                     --  Get the case variable\n+         --  Now look into all the case items of the case construction\n \n-                     The_Variable := In_Tree.Variable_Elements.\n-                                       Table (Var_Id).Value;\n+         Case_Item := First_Case_Item_Of (Current_Item, Node_Tree);\n \n-                     if The_Variable.Kind /= Single then\n+         Case_Item_Loop :\n+         while Present (Case_Item) loop\n+            Choice_String := First_Choice_Of (Case_Item, Node_Tree);\n \n-                        --  Should never happen, because this has already been\n-                        --  checked during parsing.\n+            --  When Choice_String is nil, it means that it is\n+            --  the \"when others =>\" alternative.\n \n-                        Write_Line (\"variable\"\"\" &\n-                                    Get_Name_String (Name) &\n-                                    \"\"\" is not a single string variable\");\n-                        raise Program_Error;\n-                     end if;\n+            if No (Choice_String) then\n+               Decl_Item := First_Declarative_Item_Of (Case_Item, Node_Tree);\n+               exit Case_Item_Loop;\n+            end if;\n \n-                     --  Get the case variable value\n-                     Case_Value := The_Variable.Value;\n-                  end;\n+            --  Look into all the alternative of this case item\n \n-                  --  Now look into all the case items of the case construction\n+            Choice_Loop :\n+            while Present (Choice_String) loop\n+               if Case_Value = String_Value_Of (Choice_String, Node_Tree) then\n+                  Decl_Item :=\n+                    First_Declarative_Item_Of (Case_Item, Node_Tree);\n+                  exit Case_Item_Loop;\n+               end if;\n \n-                  Case_Item :=\n-                    First_Case_Item_Of (Current_Item, From_Project_Node_Tree);\n-                  Case_Item_Loop :\n-                     while Present (Case_Item) loop\n-                        Choice_String :=\n-                          First_Choice_Of (Case_Item, From_Project_Node_Tree);\n+               Choice_String := Next_Literal_String (Choice_String, Node_Tree);\n+            end loop Choice_Loop;\n \n-                        --  When Choice_String is nil, it means that it is\n-                        --  the \"when others =>\" alternative.\n+            Case_Item := Next_Case_Item (Case_Item, Node_Tree);\n+         end loop Case_Item_Loop;\n \n-                        if No (Choice_String) then\n-                           Decl_Item :=\n-                             First_Declarative_Item_Of\n-                               (Case_Item, From_Project_Node_Tree);\n-                           exit Case_Item_Loop;\n-                        end if;\n+         --  If there is an alternative, then we process it\n \n-                        --  Look into all the alternative of this case item\n+         if Present (Decl_Item) then\n+            Process_Declarative_Items\n+              (Project                => Project,\n+               In_Tree                => In_Tree,\n+               Flags                  => Flags,\n+               From_Project_Node      => From_Project_Node,\n+               Node_Tree              => Node_Tree,\n+               Pkg                    => Pkg,\n+               Item                   => Decl_Item);\n+         end if;\n+      end Process_Case_Construction;\n \n-                        Choice_Loop :\n-                           while Present (Choice_String) loop\n-                              if Case_Value =\n-                                String_Value_Of\n-                                  (Choice_String, From_Project_Node_Tree)\n-                              then\n-                                 Decl_Item :=\n-                                   First_Declarative_Item_Of\n-                                     (Case_Item, From_Project_Node_Tree);\n-                                 exit Case_Item_Loop;\n-                              end if;\n+      --  Local variables\n \n-                              Choice_String :=\n-                                Next_Literal_String\n-                                  (Choice_String, From_Project_Node_Tree);\n-                           end loop Choice_Loop;\n+      Current, Decl : Project_Node_Id;\n+      Kind          : Project_Node_Kind;\n \n-                        Case_Item :=\n-                          Next_Case_Item (Case_Item, From_Project_Node_Tree);\n-                     end loop Case_Item_Loop;\n+   --  Start of processing for Process_Declarative_Items\n \n-                  --  If there is an alternative, then we process it\n+   begin\n+      Decl := Item;\n+      while Present (Decl) loop\n+         Current := Current_Item_Node (Decl, Node_Tree);\n+         Decl    := Next_Declarative_Item (Decl, Node_Tree);\n+         Kind    := Kind_Of (Current, Node_Tree);\n \n-                  if Present (Decl_Item) then\n-                     Process_Declarative_Items\n-                       (Project                => Project,\n-                        In_Tree                => In_Tree,\n-                        Flags                  => Flags,\n-                        From_Project_Node      => From_Project_Node,\n-                        From_Project_Node_Tree => From_Project_Node_Tree,\n-                        Pkg                    => Pkg,\n-                        Item                   => Decl_Item);\n-                  end if;\n-               end;\n+         case Kind is\n+            when N_Package_Declaration =>\n+               Process_Package_Declaration (Current);\n \n-            when others =>\n+            when N_String_Type_Declaration =>\n+               --  There is nothing to process\n+               null;\n \n-               --  Should never happen\n+            when N_Attribute_Declaration      |\n+                 N_Typed_Variable_Declaration |\n+                 N_Variable_Declaration       =>\n+               Process_Attribute_Declaration (Current);\n+\n+            when N_Case_Construction =>\n+               Process_Case_Construction (Current);\n \n-               Write_Line (\"Illegal declarative item: \" &\n-                           Project_Node_Kind'Image\n-                             (Kind_Of\n-                                (Current_Item, From_Project_Node_Tree)));\n+            when others =>\n+               Write_Line (\"Illegal declarative item: \" & Kind'Img);\n                raise Program_Error;\n          end case;\n       end loop;\n@@ -2439,6 +2346,8 @@ package body Prj.Proc is\n       --  And process the main project and all of the projects it depends on,\n       --  recursively.\n \n+      Debug_Increase_Indent (\"Process tree, phase 1\");\n+\n       Recursive_Process\n         (Project                => Project,\n          In_Tree                => In_Tree,\n@@ -2450,7 +2359,12 @@ package body Prj.Proc is\n       Success :=\n         Total_Errors_Detected = 0\n           and then\n-            (Warning_Mode /= Treat_As_Error or else Warnings_Detected = 0);\n+          (Warning_Mode /= Treat_As_Error or else Warnings_Detected = 0);\n+\n+      if Current_Verbosity = High then\n+         Debug_Decrease_Indent (\"Done Process tree, phase 1, Success=\"\n+                                & Success'Img);\n+      end if;\n    end Process_Project_Tree_Phase_1;\n \n    ----------------------------------\n@@ -2475,6 +2389,8 @@ package body Prj.Proc is\n    begin\n       Success := True;\n \n+      Debug_Increase_Indent (\"Process tree, phase 2\");\n+\n       if Project /= No_Project then\n          Check (In_Tree, Project, From_Project_Node_Tree, Flags);\n       end if;\n@@ -2554,6 +2470,8 @@ package body Prj.Proc is\n          end loop;\n       end if;\n \n+      Debug_Decrease_Indent (\"Done Process tree, phase 2\");\n+\n       Success :=\n         Total_Errors_Detected = 0\n           and then\n@@ -2580,6 +2498,16 @@ package body Prj.Proc is\n       --  only projects imported through a standard \"with\" are processed.\n       --  Imported is the id of the last imported project.\n \n+      procedure Process_Aggregated_Projects;\n+      --  Process all the projects aggregated in List.\n+      --  This does nothing if the project is not an aggregate project.\n+\n+      procedure Process_Extended_Project;\n+      --  Process the extended project:\n+      --  inherit all packages from the extended project that are not\n+      --  explicitly defined or renamed. Also inherit the languages, if\n+      --  attribute Languages is not explicitly defined.\n+\n       -------------------------------\n       -- Process_Imported_Projects --\n       -------------------------------\n@@ -2596,6 +2524,7 @@ package body Prj.Proc is\n          With_Clause :=\n            First_With_Clause_Of\n              (From_Project_Node, From_Project_Node_Tree);\n+\n          while Present (With_Clause) loop\n             Proj_Node :=\n               Non_Limited_Project_Node_Of\n@@ -2637,6 +2566,158 @@ package body Prj.Proc is\n          end loop;\n       end Process_Imported_Projects;\n \n+      ---------------------------------\n+      -- Process_Aggregated_Projects --\n+      ---------------------------------\n+\n+      procedure Process_Aggregated_Projects is\n+         List : Aggregated_Project_List;\n+         Loaded_Tree : Prj.Tree.Project_Node_Id;\n+         Success     : Boolean := True;\n+      begin\n+         if Project.Qualifier /= Aggregate then\n+            return;\n+         end if;\n+\n+         Debug_Increase_Indent (\"Process_Aggregated_Projects\", Project.Name);\n+\n+         Prj.Nmsc.Process_Aggregated_Projects\n+           (Tree         => In_Tree,\n+            Project      => Project,\n+            Node_Tree    => From_Project_Node_Tree,\n+            Flags        => Flags);\n+\n+         List := Project.Aggregated_Projects;\n+         while Success and then List /= null loop\n+            Prj.Part.Parse\n+              (In_Tree           => From_Project_Node_Tree,\n+               Project           => Loaded_Tree,\n+               Project_File_Name => Get_Name_String (List.Path),\n+               Errout_Handling   => Prj.Part.Never_Finalize,\n+               Current_Directory => Get_Name_String (Project.Directory.Name),\n+               Is_Config_File    => False,\n+               Flags             => Flags);\n+\n+            Success := not Prj.Tree.No (Loaded_Tree);\n+\n+            if Success then\n+               Recursive_Process\n+                 (In_Tree                => In_Tree,\n+                  Project                => List.Project,\n+                  Flags                  => Flags,\n+                  From_Project_Node      => Loaded_Tree,\n+                  From_Project_Node_Tree => From_Project_Node_Tree,\n+                  Extended_By            => No_Project);\n+            else\n+               Debug_Output (\"Failed to parse\", Name_Id (List.Path));\n+            end if;\n+\n+            List := List.Next;\n+         end loop;\n+\n+         Debug_Decrease_Indent (\"Done Process_Aggregated_Projects\");\n+      end Process_Aggregated_Projects;\n+\n+      ------------------------------\n+      -- Process_Extended_Project --\n+      ------------------------------\n+\n+      procedure Process_Extended_Project is\n+         Extended_Pkg : Package_Id;\n+         Current_Pkg  : Package_Id;\n+         Element      : Package_Element;\n+         First        : constant Package_Id := Project.Decl.Packages;\n+         Attribute1   : Variable_Id;\n+         Attribute2   : Variable_Id;\n+         Attr_Value1  : Variable;\n+         Attr_Value2  : Variable;\n+\n+      begin\n+         Extended_Pkg := Project.Extends.Decl.Packages;\n+         while Extended_Pkg /= No_Package loop\n+            Element := In_Tree.Packages.Table (Extended_Pkg);\n+\n+            Current_Pkg := First;\n+            while Current_Pkg /= No_Package\n+              and then In_Tree.Packages.Table (Current_Pkg).Name /=\n+              Element.Name\n+            loop\n+               Current_Pkg :=\n+                 In_Tree.Packages.Table (Current_Pkg).Next;\n+            end loop;\n+\n+            if Current_Pkg = No_Package then\n+               Package_Table.Increment_Last\n+                 (In_Tree.Packages);\n+               Current_Pkg := Package_Table.Last (In_Tree.Packages);\n+               In_Tree.Packages.Table (Current_Pkg) :=\n+                 (Name   => Element.Name,\n+                  Decl   => No_Declarations,\n+                  Parent => No_Package,\n+                  Next   => Project.Decl.Packages);\n+               Project.Decl.Packages := Current_Pkg;\n+               Copy_Package_Declarations\n+                 (From       => Element.Decl,\n+                  To         =>\n+                    In_Tree.Packages.Table (Current_Pkg).Decl,\n+                  New_Loc    => No_Location,\n+                  Restricted => True,\n+                  In_Tree    => In_Tree);\n+            end if;\n+\n+            Extended_Pkg := Element.Next;\n+         end loop;\n+\n+         --  Check if attribute Languages is declared in the\n+         --  extending project.\n+\n+         Attribute1 := Project.Decl.Attributes;\n+         while Attribute1 /= No_Variable loop\n+            Attr_Value1 := In_Tree.Variable_Elements.\n+              Table (Attribute1);\n+            exit when Attr_Value1.Name = Snames.Name_Languages;\n+            Attribute1 := Attr_Value1.Next;\n+         end loop;\n+\n+         if Attribute1 = No_Variable or else\n+           Attr_Value1.Value.Default\n+         then\n+            --  Attribute Languages is not declared in the extending\n+            --  project. Check if it is declared in the project being\n+            --  extended.\n+\n+            Attribute2 := Project.Extends.Decl.Attributes;\n+            while Attribute2 /= No_Variable loop\n+               Attr_Value2 := In_Tree.Variable_Elements.\n+                 Table (Attribute2);\n+               exit when Attr_Value2.Name = Snames.Name_Languages;\n+               Attribute2 := Attr_Value2.Next;\n+            end loop;\n+\n+            if Attribute2 /= No_Variable and then\n+              not Attr_Value2.Value.Default\n+            then\n+               --  As attribute Languages is declared in the project\n+               --  being extended, copy its value for the extending\n+               --  project.\n+\n+               if Attribute1 = No_Variable then\n+                  Variable_Element_Table.Increment_Last\n+                    (In_Tree.Variable_Elements);\n+                  Attribute1 := Variable_Element_Table.Last\n+                    (In_Tree.Variable_Elements);\n+                  Attr_Value1.Next := Project.Decl.Attributes;\n+                  Project.Decl.Attributes := Attribute1;\n+               end if;\n+\n+               Attr_Value1.Name := Snames.Name_Languages;\n+               Attr_Value1.Value := Attr_Value2.Value;\n+               In_Tree.Variable_Elements.Table\n+                 (Attribute1) := Attr_Value1;\n+            end if;\n+         end if;\n+      end Process_Extended_Project;\n+\n    --  Start of processing for Recursive_Process\n \n    begin\n@@ -2672,7 +2753,10 @@ package body Prj.Proc is\n                return;\n             end if;\n \n-            Project := new Project_Data'(Empty_Project);\n+            Project := new Project_Data'\n+              (Empty_Project\n+                 (Project_Qualifier_Of\n+                    (From_Project_Node, From_Project_Node_Tree)));\n             In_Tree.Projects := new Project_List_Element'\n               (Project => Project,\n                Next    => In_Tree.Projects);\n@@ -2681,9 +2765,6 @@ package body Prj.Proc is\n \n             Project.Name := Name;\n             Project.Display_Name := Name_Node.Display_Name;\n-            Project.Qualifier :=\n-              Project_Qualifier_Of (From_Project_Node, From_Project_Node_Tree);\n-\n             Get_Name_String (Name);\n \n             --  If name starts with the virtual prefix, flag the project as\n@@ -2743,117 +2824,21 @@ package body Prj.Proc is\n                In_Tree                => In_Tree,\n                Flags                  => Flags,\n                From_Project_Node      => From_Project_Node,\n-               From_Project_Node_Tree => From_Project_Node_Tree,\n+               Node_Tree => From_Project_Node_Tree,\n                Pkg                    => No_Package,\n                Item                   => First_Declarative_Item_Of\n                                           (Declaration_Node,\n                                            From_Project_Node_Tree));\n \n-            --  If it is an extending project, inherit all packages\n-            --  from the extended project that are not explicitly defined\n-            --  or renamed. Also inherit the languages, if attribute Languages\n-            --  is not explicitly defined.\n-\n             if Project.Extends /= No_Project then\n-               declare\n-                  Extended_Pkg : Package_Id;\n-                  Current_Pkg  : Package_Id;\n-                  Element      : Package_Element;\n-                  First        : constant Package_Id :=\n-                                   Project.Decl.Packages;\n-                  Attribute1   : Variable_Id;\n-                  Attribute2   : Variable_Id;\n-                  Attr_Value1  : Variable;\n-                  Attr_Value2  : Variable;\n-\n-               begin\n-                  Extended_Pkg := Project.Extends.Decl.Packages;\n-                  while Extended_Pkg /= No_Package loop\n-                     Element := In_Tree.Packages.Table (Extended_Pkg);\n-\n-                     Current_Pkg := First;\n-                     while Current_Pkg /= No_Package\n-                       and then In_Tree.Packages.Table (Current_Pkg).Name /=\n-                                                                 Element.Name\n-                     loop\n-                        Current_Pkg :=\n-                          In_Tree.Packages.Table (Current_Pkg).Next;\n-                     end loop;\n-\n-                     if Current_Pkg = No_Package then\n-                        Package_Table.Increment_Last\n-                          (In_Tree.Packages);\n-                        Current_Pkg := Package_Table.Last (In_Tree.Packages);\n-                        In_Tree.Packages.Table (Current_Pkg) :=\n-                          (Name   => Element.Name,\n-                           Decl   => No_Declarations,\n-                           Parent => No_Package,\n-                           Next   => Project.Decl.Packages);\n-                        Project.Decl.Packages := Current_Pkg;\n-                        Copy_Package_Declarations\n-                          (From       => Element.Decl,\n-                           To         =>\n-                             In_Tree.Packages.Table (Current_Pkg).Decl,\n-                           New_Loc    => No_Location,\n-                           Restricted => True,\n-                           In_Tree    => In_Tree);\n-                     end if;\n-\n-                     Extended_Pkg := Element.Next;\n-                  end loop;\n-\n-                  --  Check if attribute Languages is declared in the\n-                  --  extending project.\n-\n-                  Attribute1 := Project.Decl.Attributes;\n-                  while Attribute1 /= No_Variable loop\n-                     Attr_Value1 := In_Tree.Variable_Elements.\n-                                      Table (Attribute1);\n-                     exit when Attr_Value1.Name = Snames.Name_Languages;\n-                     Attribute1 := Attr_Value1.Next;\n-                  end loop;\n-\n-                  if Attribute1 = No_Variable or else\n-                     Attr_Value1.Value.Default\n-                  then\n-                     --  Attribute Languages is not declared in the extending\n-                     --  project. Check if it is declared in the project being\n-                     --  extended.\n-\n-                     Attribute2 := Project.Extends.Decl.Attributes;\n-                     while Attribute2 /= No_Variable loop\n-                        Attr_Value2 := In_Tree.Variable_Elements.\n-                                         Table (Attribute2);\n-                        exit when Attr_Value2.Name = Snames.Name_Languages;\n-                        Attribute2 := Attr_Value2.Next;\n-                     end loop;\n-\n-                     if Attribute2 /= No_Variable and then\n-                        not Attr_Value2.Value.Default\n-                     then\n-                        --  As attribute Languages is declared in the project\n-                        --  being extended, copy its value for the extending\n-                        --  project.\n-\n-                        if Attribute1 = No_Variable then\n-                           Variable_Element_Table.Increment_Last\n-                             (In_Tree.Variable_Elements);\n-                           Attribute1 := Variable_Element_Table.Last\n-                             (In_Tree.Variable_Elements);\n-                           Attr_Value1.Next := Project.Decl.Attributes;\n-                           Project.Decl.Attributes := Attribute1;\n-                        end if;\n-\n-                        Attr_Value1.Name := Snames.Name_Languages;\n-                        Attr_Value1.Value := Attr_Value2.Value;\n-                        In_Tree.Variable_Elements.Table\n-                          (Attribute1) := Attr_Value1;\n-                     end if;\n-                  end if;\n-               end;\n+               Process_Extended_Project;\n             end if;\n \n             Process_Imported_Projects (Imported, Limited_With => True);\n+\n+            if Err_Vars.Total_Errors_Detected = 0 then\n+               Process_Aggregated_Projects;\n+            end if;\n          end;\n       end if;\n    end Recursive_Process;"}, {"sha": "cbc2c9657eca91fb6a95112dccd47c303379078d", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -62,55 +62,6 @@ package body Prj is\n                           All_Upper_Case => All_Upper_Case_Image'Access,\n                           Mixed_Case     => Mixed_Case_Image'Access);\n \n-   Project_Empty : constant Project_Data :=\n-                     (Qualifier                      => Unspecified,\n-                      Externally_Built               => False,\n-                      Config                         => Default_Project_Config,\n-                      Name                           => No_Name,\n-                      Display_Name                   => No_Name,\n-                      Path                           => No_Path_Information,\n-                      Virtual                        => False,\n-                      Location                       => No_Location,\n-                      Mains                          => Nil_String,\n-                      Directory                      => No_Path_Information,\n-                      Library                        => False,\n-                      Library_Dir                    => No_Path_Information,\n-                      Library_Src_Dir                => No_Path_Information,\n-                      Library_ALI_Dir                => No_Path_Information,\n-                      Library_Name                   => No_Name,\n-                      Library_Kind                   => Static,\n-                      Lib_Internal_Name              => No_Name,\n-                      Standalone_Library             => False,\n-                      Lib_Interface_ALIs             => Nil_String,\n-                      Lib_Auto_Init                  => False,\n-                      Libgnarl_Needed                => Unknown,\n-                      Symbol_Data                    => No_Symbols,\n-                      Interfaces_Defined             => False,\n-                      Source_Dirs                    => Nil_String,\n-                      Source_Dir_Ranks               => No_Number_List,\n-                      Object_Directory               => No_Path_Information,\n-                      Library_TS                     => Empty_Time_Stamp,\n-                      Exec_Directory                 => No_Path_Information,\n-                      Extends                        => No_Project,\n-                      Extended_By                    => No_Project,\n-                      Languages                      => No_Language_Index,\n-                      Decl                           => No_Declarations,\n-                      Imported_Projects              => null,\n-                      Include_Path_File              => No_Path,\n-                      All_Imported_Projects          => null,\n-                      Ada_Include_Path               => null,\n-                      Ada_Objects_Path               => null,\n-                      Objects_Path                   => null,\n-                      Objects_Path_File_With_Libs    => No_Path,\n-                      Objects_Path_File_Without_Libs => No_Path,\n-                      Config_File_Name               => No_Path,\n-                      Config_File_Temp               => False,\n-                      Config_Checked                 => False,\n-                      Need_To_Build_Lib              => False,\n-                      Has_Multi_Unit_Sources         => False,\n-                      Depth                          => 0,\n-                      Unkept_Comments                => False);\n-\n    procedure Free (Project : in out Project_Id);\n    --  Free memory allocated for Project\n \n@@ -270,10 +221,20 @@ package body Prj is\n    -- Empty_Project --\n    -------------------\n \n-   function Empty_Project return Project_Data is\n+   function Empty_Project\n+     (Qualifier : Project_Qualifier) return Project_Data is\n    begin\n       Prj.Initialize (Tree => No_Project_Tree);\n-      return Project_Empty;\n+\n+      declare\n+         Data : Project_Data (Qualifier => Qualifier);\n+      begin\n+         --  Only the fields for which no default value could be provided in\n+         --  prj.ads are initialized below\n+\n+         Data.Config := Default_Project_Config;\n+         return Data;\n+      end;\n    end Empty_Project;\n \n    ------------------\n@@ -440,6 +401,7 @@ package body Prj is\n    procedure For_Every_Project_Imported\n      (By             : Project_Id;\n       With_State     : in out State;\n+      Include_Aggregated : Boolean := True;\n       Imported_First : Boolean := False)\n    is\n       use Project_Boolean_Htable;\n@@ -455,6 +417,7 @@ package body Prj is\n \n       procedure Recursive_Check (Project : Project_Id) is\n          List : Project_List;\n+         Agg  : Aggregated_Project_List;\n \n       begin\n          if not Get (Seen, Project) then\n@@ -464,20 +427,33 @@ package body Prj is\n                Action (Project, With_State);\n             end if;\n \n-            --  Visited all extended projects\n+            --  Visit all extended projects\n \n             if Project.Extends /= No_Project then\n                Recursive_Check (Project.Extends);\n             end if;\n \n-            --  Visited all imported projects\n+            --  Visit all imported projects\n \n             List := Project.Imported_Projects;\n             while List /= null loop\n                Recursive_Check (List.Project);\n                List := List.Next;\n             end loop;\n \n+            --  Visit all aggregated projects\n+\n+            if Include_Aggregated\n+              and then Project.Qualifier = Aggregate\n+            then\n+               Agg := Project.Aggregated_Projects;\n+               while Agg /= null loop\n+                  pragma Assert (Agg.Project /= No_Project);\n+                  Recursive_Check (Agg.Project);\n+                  Agg := Agg.Next;\n+               end loop;\n+            end if;\n+\n             if Imported_First then\n                Action (Project, With_State);\n             end if;\n@@ -729,6 +705,35 @@ package body Prj is\n    -- Free --\n    ----------\n \n+   procedure Free (List : in out Aggregated_Project_List) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Aggregated_Project, Aggregated_Project_List);\n+      Tmp : Aggregated_Project_List;\n+   begin\n+      while List /= null loop\n+         Tmp := List.Next;\n+         Unchecked_Free (List);\n+         List := Tmp;\n+      end loop;\n+   end Free;\n+\n+   ----------------------------\n+   -- Add_Aggregated_Project --\n+   ----------------------------\n+\n+   procedure Add_Aggregated_Project\n+     (Project : Project_Id; Path : Path_Name_Type) is\n+   begin\n+      Project.Aggregated_Projects := new Aggregated_Project'\n+        (Path    => Path,\n+         Project => No_Project,\n+         Next    => Project.Aggregated_Projects);\n+   end Add_Aggregated_Project;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n    procedure Free (Project : in out Project_Id) is\n       procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n         (Project_Data, Project_Id);\n@@ -742,6 +747,14 @@ package body Prj is\n          Free_List (Project.All_Imported_Projects, Free_Project => False);\n          Free_List (Project.Languages);\n \n+         case Project.Qualifier is\n+            when Aggregate =>\n+               Free (Project.Aggregated_Projects);\n+\n+            when others =>\n+               null;\n+         end case;\n+\n          Unchecked_Free (Project);\n       end if;\n    end Free;"}, {"sha": "db53aa0815574e1ba688adaec10b89ed4d7fbcfb", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -1086,13 +1086,34 @@ package Prj is\n                                Lib_Maj_Min_Id_Supported      => False,\n                                Auto_Init_Supported           => False);\n \n-   --  The following record describes a project file representation\n+   -------------------------\n+   -- Aggregated projects --\n+   -------------------------\n+\n+   type Aggregated_Project;\n+   type Aggregated_Project_List is access all Aggregated_Project;\n+   type Aggregated_Project is record\n+      Path    : Path_Name_Type;\n+      Project : Project_Id;\n+      Next    : Aggregated_Project_List;\n+   end record;\n+\n+   procedure Free (List : in out Aggregated_Project_List);\n+   --  Free the memory used for List\n \n-   --  Note that it is not specified if the path names of directories (source,\n-   --  object, library or exec directories) end with or without a directory\n-   --  separator.\n+   procedure Add_Aggregated_Project\n+     (Project : Project_Id; Path : Path_Name_Type);\n+   --  Add a new aggregated project in Project.\n+   --  The aggregated project has not been processed yet. This procedure should\n+   --  the called while processing the aggregate project, and as a result\n+   --  Prj.Proc.Process will then automatically process the aggregated projects\n \n-   type Project_Data is record\n+   ------------------\n+   -- Project_Data --\n+   ------------------\n+   --  The following record describes a project file representation\n+\n+   type Project_Data (Qualifier : Project_Qualifier := Unspecified) is record\n \n       -------------\n       -- General --\n@@ -1104,9 +1125,6 @@ package Prj is\n       Display_Name : Name_Id := No_Name;\n       --  The name of the project with the spelling of its declaration\n \n-      Qualifier : Project_Qualifier := Unspecified;\n-      --  The eventual qualifier for this project\n-\n       Externally_Built : Boolean := False;\n       --  True if the project is externally built. In such case, the Project\n       --  Manager will not modify anything in this project.\n@@ -1152,10 +1170,10 @@ package Prj is\n       --  The declarations (variables, attributes and packages) of this project\n       --  file.\n \n-      Imported_Projects : Project_List;\n+      Imported_Projects : Project_List := null;\n       --  The list of all directly imported projects, if any\n \n-      All_Imported_Projects : Project_List;\n+      All_Imported_Projects : Project_List := null;\n       --  The list of all projects imported directly or indirectly, if any.\n       --  This does not include the project itself.\n \n@@ -1295,9 +1313,21 @@ package Prj is\n       --  True if there are comments in the project sources that cannot be kept\n       --  in the project tree.\n \n+      -----------------------------\n+      -- qualifier-specific data --\n+      -----------------------------\n+      --  The following fields are only valid for specific types of projects.\n+\n+      case Qualifier is\n+         when Aggregate =>\n+            Aggregated_Projects : Aggregated_Project_List := null;\n+\n+         when others =>\n+            null;\n+      end case;\n    end record;\n \n-   function Empty_Project return Project_Data;\n+   function Empty_Project (Qualifier : Project_Qualifier) return  Project_Data;\n    --  Return the representation of an empty project\n \n    function Is_Extending\n@@ -1432,6 +1462,7 @@ package Prj is\n    procedure For_Every_Project_Imported\n      (By             : Project_Id;\n       With_State     : in out State;\n+      Include_Aggregated : Boolean := True;\n       Imported_First : Boolean := False);\n    --  Call Action for each project imported directly or indirectly by project\n    --  By, as well as extended projects.\n@@ -1448,6 +1479,10 @@ package Prj is\n    --\n    --  With_State may be used by Action to choose a behavior or to report some\n    --  global result.\n+   --\n+   --  If Include_Aggregated is True, then an aggregate project will recurse\n+   --  into the projects it aggregates. Otherwise, the latter are never\n+   --  returned\n \n    function Extend_Name\n      (File        : File_Name_Type;"}, {"sha": "fdc243cdd6ae0a2ae504212549ace67426417555", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -105,9 +105,9 @@ package body Restrict is\n       Check_Restriction (No_Elaboration_Code, N);\n    end Check_Elaboration_Code_Allowed;\n \n-   ------------------------------\n-   -- Check_Formal_Restriction --\n-   ------------------------------\n+   -----------------------------\n+   -- Check_SPARK_Restriction --\n+   -----------------------------\n \n    procedure Check_SPARK_Restriction\n      (Msg   : String;\n@@ -139,7 +139,7 @@ package body Restrict is\n       end if;\n    end Check_SPARK_Restriction;\n \n-   procedure Check_Formal_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n+   procedure Check_SPARK_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n       Msg_Issued          : Boolean;\n       Save_Error_Msg_Sloc : Source_Ptr;\n    begin\n@@ -166,7 +166,7 @@ package body Restrict is\n             Error_Msg_F (Msg2, N);\n          end if;\n       end if;\n-   end Check_Formal_Restriction;\n+   end Check_SPARK_Restriction;\n \n    -----------------------------------------\n    -- Check_Implicit_Dynamic_Code_Allowed --"}, {"sha": "31cecd7305d8f4aaf33811eed0282ae94448a361", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -265,8 +265,8 @@ package Restrict is\n    --  SPARK restriction is set, then an error is issued on N. Msg is appended\n    --  to the restriction failure message.\n \n-   procedure Check_Formal_Restriction (Msg1, Msg2 : String; N : Node_Id);\n-   --  Same as Check_Formal_Restriction except there is a continuation message\n+   procedure Check_SPARK_Restriction (Msg1, Msg2 : String; N : Node_Id);\n+   --  Same as Check_SPARK_Restriction except there is a continuation message\n    --  Msg2 following the initial message Msg1.\n \n    procedure Check_Implicit_Dynamic_Code_Allowed (N : Node_Id);"}, {"sha": "849ec86c824b9c5dbbd852ac4d1d95ee4b69149e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -289,7 +289,7 @@ package body Sem_Attr is\n       --  Common processing for attributes Definite and Has_Discriminants.\n       --  Checks that prefix is generic indefinite formal type.\n \n-      procedure Check_Formal_Restriction_On_Attribute;\n+      procedure Check_SPARK_Restriction_On_Attribute;\n       --  Issue an error in formal mode because attribute N is allowed\n \n       procedure Check_Integer_Type;\n@@ -568,7 +568,7 @@ package body Sem_Attr is\n       --  Start of processing for Analyze_Access_Attribute\n \n       begin\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_E0;\n \n          if Nkind (P) = N_Character_Literal then\n@@ -1289,15 +1289,15 @@ package body Sem_Attr is\n          Check_E2;\n       end Check_Floating_Point_Type_2;\n \n-      -------------------------------------------\n-      -- Check_Formal_Restriction_On_Attribute --\n-      -------------------------------------------\n+      ------------------------------------------\n+      -- Check_SPARK_Restriction_On_Attribute --\n+      ------------------------------------------\n \n-      procedure Check_Formal_Restriction_On_Attribute is\n+      procedure Check_SPARK_Restriction_On_Attribute is\n       begin\n          Error_Msg_Name_1 := Aname;\n          Check_SPARK_Restriction (\"attribute % is not allowed\", P);\n-      end Check_Formal_Restriction_On_Attribute;\n+      end Check_SPARK_Restriction_On_Attribute;\n \n       ------------------------\n       -- Check_Integer_Type --\n@@ -3266,7 +3266,7 @@ package body Sem_Attr is\n \n       when Attribute_Image => Image :\n       begin\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_Scalar_Type;\n          Set_Etype (N, Standard_String);\n \n@@ -4825,7 +4825,7 @@ package body Sem_Attr is\n \n       when Attribute_Value => Value :\n       begin\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_E1;\n          Check_Scalar_Type;\n \n@@ -4888,7 +4888,7 @@ package body Sem_Attr is\n \n       when Attribute_Wide_Image => Wide_Image :\n       begin\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_Scalar_Type;\n          Set_Etype (N, Standard_Wide_String);\n          Check_E1;\n@@ -4915,7 +4915,7 @@ package body Sem_Attr is\n \n       when Attribute_Wide_Value => Wide_Value :\n       begin\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_E1;\n          Check_Scalar_Type;\n \n@@ -4956,7 +4956,7 @@ package body Sem_Attr is\n       ----------------\n \n       when Attribute_Wide_Width =>\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_E0;\n          Check_Scalar_Type;\n          Set_Etype (N, Universal_Integer);\n@@ -4966,7 +4966,7 @@ package body Sem_Attr is\n       -----------\n \n       when Attribute_Width =>\n-         Check_Formal_Restriction_On_Attribute;\n+         Check_SPARK_Restriction_On_Attribute;\n          Check_E0;\n          Check_Scalar_Type;\n          Set_Etype (N, Universal_Integer);"}, {"sha": "d487921ad0f069c1883a5b5ed910128e3f401e5c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -8593,10 +8593,13 @@ package body Sem_Ch6 is\n          Check_Overriding_Indicator\n            (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n \n-         --  Overloading is not allowed in SPARK\n+         --  Overloading is not allowed in SPARK, except for operators\n \n-         Error_Msg_Sloc := Sloc (Homonym (S));\n-         Check_SPARK_Restriction (\"overloading not allowed with entity#\", S);\n+         if Nkind (S) /= N_Defining_Operator_Symbol then\n+            Error_Msg_Sloc := Sloc (Homonym (S));\n+            Check_SPARK_Restriction\n+              (\"overloading not allowed with entity#\", S);\n+         end if;\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent"}, {"sha": "633d975758e1e107ea2efcc825ab4d86b72efad2", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -936,7 +936,7 @@ package body Sem_Ch7 is\n \n                   else\n                      Error_Msg_Sloc := Sloc (Previous);\n-                     Check_Formal_Restriction\n+                     Check_SPARK_Restriction\n                        (\"at most one tagged type or type extension allowed\",\n                         \"\\\\ previous declaration#\",\n                         Decl);"}, {"sha": "ddb85a7a6d04d3ee8943d78ea11e0cdd29bff5bb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d67e2d730f6a8e45182a384b5b674f5134bc64/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c4d67e2d730f6a8e45182a384b5b674f5134bc64", "patch": "@@ -5748,7 +5748,7 @@ package body Sem_Res is\n --        and then Is_Inherited_Operation_For_Type\n --                   (Entity (Name (N)), Etype (N))\n --      then\n---         Check_Formal_Restriction (\"function not inherited\", N);\n+--         Check_SPARK_Restriction (\"function not inherited\", N);\n --      end if;\n \n       --  Implement rule in 12.5.1 (23.3/2): In an instance, if the actual is"}]}