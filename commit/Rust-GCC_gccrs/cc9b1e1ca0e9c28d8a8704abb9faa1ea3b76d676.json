{"sha": "cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5YjFlMWNhMGU5YzI4ZDhhODcwNGFiYjlmYWExZWEzYjc2ZDY3Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-30T11:53:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-30T11:53:39Z"}, "message": "[multiple changes]\n\n2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Code cleanup.\n\n2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): If a subtype\n\tindication is provided, check properly that it covers the element\n\ttype of of the container type.\n\n2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* g-dynhta.ads, g-dynhta.adb: Add the implementation of a load facto\n\t-based hash table.\n\nFrom-SVN: r216926", "tree": {"sha": "ed4bc91a3fb858c7bd5428a7386d267b25b2fbfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed4bc91a3fb858c7bd5428a7386d267b25b2fbfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/comments", "author": null, "committer": null, "parents": [{"sha": "35fdafcdda2be3cab0ce595ab2f06aca2f1cef77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fdafcdda2be3cab0ce595ab2f06aca2f1cef77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fdafcdda2be3cab0ce595ab2f06aca2f1cef77"}], "stats": {"total": 543, "additions": 517, "deletions": 26}, "files": [{"sha": "4a87fef7a2e3e1a6d9b9f18b6fbd3e54a8f030cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "patch": "@@ -1,3 +1,18 @@\n+2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Code cleanup.\n+\n+2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): If a subtype\n+\tindication is provided, check properly that it covers the element\n+\ttype of of the container type.\n+\n+2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* g-dynhta.ads, g-dynhta.adb: Add the implementation of a load facto\n+\t-based hash table.\n+\n 2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_util.ads, exp_util.adb (Following_Address_Clause): Modify"}, {"sha": "8df5a503ed4ed2910938c2c448cf06bf3c4df3c5", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "patch": "@@ -5834,7 +5834,8 @@ package body Exp_Ch3 is\n                          or else Nkind (Expression (Expr)) /= N_Aggregate)\n             then\n                declare\n-                  Full_Typ : constant Entity_Id := Underlying_Type (Typ);\n+                  Full_Typ   : constant Entity_Id := Underlying_Type (Typ);\n+                  Tag_Assign : Node_Id;\n \n                begin\n                   --  The re-assignment of the tag has to be done even if the\n@@ -5849,27 +5850,26 @@ package body Exp_Ch3 is\n                                            Loc));\n                   Set_Assignment_OK (New_Ref);\n \n+                  Tag_Assign :=\n+                    Make_Assignment_Statement (Loc,\n+                       Name       => New_Ref,\n+                       Expression =>\n+                         Unchecked_Convert_To (RTE (RE_Tag),\n+                           New_Occurrence_Of\n+                             (Node\n+                               (First_Elmt (Access_Disp_Table (Full_Typ))),\n+                              Loc)));\n+\n                   --  Tag initialization cannot be done before object is\n                   --  frozen. If an address clause follows, make sure freeze\n                   --  node exists, and insert it and the tag assignment after\n                   --  the address clause.\n \n                   if Present (Following_Address_Clause (N)) then\n                      Init_After := Following_Address_Clause (N);\n-                     Ensure_Freeze_Node (Def_Id);\n                   end if;\n \n-                  Insert_Actions_After (Init_After,\n-                    New_List (\n-                      Freeze_Node (Def_Id),\n-                      Make_Assignment_Statement (Loc,\n-                        Name       => New_Ref,\n-                        Expression =>\n-                          Unchecked_Convert_To (RTE (RE_Tag),\n-                            New_Occurrence_Of\n-                              (Node\n-                                (First_Elmt (Access_Disp_Table (Full_Typ))),\n-                               Loc)))));\n+                  Insert_Action_After (Init_After, Tag_Assign);\n                end;\n \n             --  Handle C++ constructor calls. Note that we do not check that"}, {"sha": "9d3424c54fc4f4783c31026b3fd8d79f81c87b2f", "filename": "gcc/ada/g-dynhta.adb", "status": "modified", "additions": 365, "deletions": 1, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dynhta.adb?ref=cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2010, AdaCore                     --\n+--                     Copyright (C) 2002-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Unchecked_Deallocation;\n+\n package body GNAT.Dynamic_HTables is\n \n    -------------------\n@@ -215,6 +217,8 @@ package body GNAT.Dynamic_HTables is\n    -------------------\n \n    package body Simple_HTable is\n+      procedure Free is new\n+        Ada.Unchecked_Deallocation (Element_Wrapper, Elmt_Ptr);\n \n       ---------\n       -- Get --\n@@ -343,4 +347,364 @@ package body GNAT.Dynamic_HTables is\n \n    end Simple_HTable;\n \n+   ------------------------\n+   -- Load_Factor_HTable --\n+   ------------------------\n+\n+   package body Load_Factor_HTable is\n+\n+      Min_Size_Increase : constant := 5;\n+      --  The minimum increase expressed as number of buckets. This value is\n+      --  used to determine the new size of small tables and/or small growth\n+      --  percentages.\n+\n+      procedure Attach\n+        (Elmt  : not null Element_Ptr;\n+         Chain : not null Element_Ptr);\n+      --  Prepend an element to a bucket chain. Elmt is inserted after the\n+      --  dummy head of Chain.\n+\n+      function Create_Buckets (Size : Positive) return Buckets_Array_Ptr;\n+      --  Allocate and initialize a new set of buckets. The buckets are created\n+      --  in the range Range_Type'First .. Range_Type'First + Size - 1.\n+\n+      procedure Detach (Elmt : not null Element_Ptr);\n+      --  Remove an element from an arbitrary bucket chain\n+\n+      function Find\n+        (Key   : Key_Type;\n+         Chain : not null Element_Ptr) return Element_Ptr;\n+      --  Try to locate the element which contains a particular key within a\n+      --  bucket chain. If no such element exists, return No_Element.\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation (Buckets_Array, Buckets_Array_Ptr);\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation (Element, Element_Ptr);\n+\n+      function Is_Empty_Chain (Chain : not null Element_Ptr) return Boolean;\n+      --  Determine whether a bucket chain contains only one element, namely\n+      --  the dummy head.\n+\n+      ------------\n+      -- Attach --\n+      ------------\n+\n+      procedure Attach\n+        (Elmt  : not null Element_Ptr;\n+         Chain : not null Element_Ptr)\n+      is\n+      begin\n+         Chain.Next.Prev := Elmt;\n+         Elmt.Next  := Chain.Next;\n+         Chain.Next := Elmt;\n+         Elmt.Prev  := Chain;\n+      end Attach;\n+\n+      --------------------\n+      -- Create_Buckets --\n+      --------------------\n+\n+      function Create_Buckets (Size : Positive) return Buckets_Array_Ptr is\n+         Low_Bound : constant Range_Type := Range_Type'First;\n+         Buckets   : Buckets_Array_Ptr;\n+\n+      begin\n+         Buckets :=\n+           new Buckets_Array (Low_Bound .. Low_Bound + Range_Type (Size) - 1);\n+\n+         --  Ensure that the dummy head of each bucket chain points to itself\n+         --  in both directions.\n+\n+         for Index in Buckets'Range loop\n+            declare\n+               Bucket : Element renames Buckets (Index);\n+\n+            begin\n+               Bucket.Prev := Bucket'Unchecked_Access;\n+               Bucket.Next := Bucket'Unchecked_Access;\n+            end;\n+         end loop;\n+\n+         return Buckets;\n+      end Create_Buckets;\n+\n+      ------------------\n+      -- Current_Size --\n+      ------------------\n+\n+      function Current_Size (T : Table) return Positive is\n+      begin\n+         --  The table should have been properly initialized during object\n+         --  elaboration.\n+\n+         if T.Buckets = null then\n+            raise Program_Error;\n+\n+         --  The size of the table is determined by the number of buckets\n+\n+         else\n+            return T.Buckets'Length;\n+         end if;\n+      end Current_Size;\n+\n+      ------------\n+      -- Detach --\n+      ------------\n+\n+      procedure Detach (Elmt : not null Element_Ptr) is\n+      begin\n+         if Elmt.Prev /= null and Elmt.Next /= null then\n+            Elmt.Prev.Next := Elmt.Next;\n+            Elmt.Next.Prev := Elmt.Prev;\n+            Elmt.Prev := null;\n+            Elmt.Next := null;\n+         end if;\n+      end Detach;\n+\n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (T : in out Table) is\n+         Bucket : Element_Ptr;\n+         Elmt   : Element_Ptr;\n+\n+      begin\n+         --  Inspect the buckets and deallocate bucket chains\n+\n+         for Index in T.Buckets'Range loop\n+            Bucket := T.Buckets (Index)'Unchecked_Access;\n+\n+            --  The current bucket chain contains an element other than the\n+            --  dummy head.\n+\n+            while not Is_Empty_Chain (Bucket) loop\n+\n+               --  Skip the dummy head, remove and deallocate the element\n+\n+               Elmt := Bucket.Next;\n+               Detach (Elmt);\n+               Free   (Elmt);\n+            end loop;\n+         end loop;\n+\n+         --  Deallocate the buckets\n+\n+         Free (T.Buckets);\n+      end Finalize;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Key   : Key_Type;\n+         Chain : not null Element_Ptr) return Element_Ptr\n+      is\n+         Elmt : Element_Ptr;\n+\n+      begin\n+         --  Skip the dummy head, inspect the bucket chain for an element whose\n+         --  key matches the requested key. Since each bucket chain is curcular\n+         --  the search must stop once the dummy head is encountered.\n+\n+         Elmt := Chain.Next;\n+         while Elmt /= Chain loop\n+            if Equal (Elmt.Key, Key) then\n+               return Elmt;\n+            end if;\n+\n+            Elmt := Elmt.Next;\n+         end loop;\n+\n+         return No_Element;\n+      end Find;\n+\n+      ---------\n+      -- Get --\n+      ---------\n+\n+      function Get (T : Table; Key : Key_Type) return Value_Type is\n+         Bucket : Element_Ptr;\n+         Elmt   : Element_Ptr;\n+\n+      begin\n+         --  Obtain the bucket chain where the (key, value) pair should reside\n+         --  by calculating the proper hash location.\n+\n+         Bucket := T.Buckets (Hash (Key, Current_Size (T)))'Unchecked_Access;\n+\n+         --  Try to find an element whose key matches the requested key\n+\n+         Elmt := Find (Key, Bucket);\n+\n+         --  The hash table does not contain a matching (key, value) pair\n+\n+         if Elmt = No_Element then\n+            return No_Value;\n+         else\n+            return Elmt.Val;\n+         end if;\n+      end Get;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      procedure Initialize (T : in out Table) is\n+      begin\n+         pragma Assert (T.Buckets = null);\n+\n+         T.Buckets       := Create_Buckets (Initial_Size);\n+         T.Element_Count := 0;\n+      end Initialize;\n+\n+      --------------------\n+      -- Is_Empty_Chain --\n+      --------------------\n+\n+      function Is_Empty_Chain (Chain : not null Element_Ptr) return Boolean is\n+      begin\n+         return Chain.Next = Chain and Chain.Prev = Chain;\n+      end Is_Empty_Chain;\n+\n+      ------------\n+      -- Remove --\n+      ------------\n+\n+      procedure Remove (T : in out Table; Key : Key_Type) is\n+         Bucket : Element_Ptr;\n+         Elmt   : Element_Ptr;\n+\n+      begin\n+         --  Obtain the bucket chain where the (key, value) pair should reside\n+         --  by calculating the proper hash location.\n+\n+         Bucket := T.Buckets (Hash (Key, Current_Size (T)))'Unchecked_Access;\n+\n+         --  Try to find an element whose key matches the requested key\n+\n+         Elmt := Find (Key, Bucket);\n+\n+         --  Remove and deallocate the (key, value) pair\n+\n+         if Elmt /= No_Element then\n+            Detach (Elmt);\n+            Free   (Elmt);\n+         end if;\n+      end Remove;\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      procedure Set\n+        (T   : in out Table;\n+         Key : Key_Type;\n+         Val : Value_Type)\n+      is\n+         Curr_Size : constant Positive := Current_Size (T);\n+\n+         procedure Grow;\n+         --  Grow the table to a new size according to the desired percentage\n+         --  and relocate all existing elements to the new buckets.\n+\n+         ----------\n+         -- Grow --\n+         ----------\n+\n+         procedure Grow is\n+            Buckets     : Buckets_Array_Ptr;\n+            Elmt        : Element_Ptr;\n+            Hash_Loc    : Range_Type;\n+            Old_Bucket  : Element_Ptr;\n+            Old_Buckets : Buckets_Array_Ptr := T.Buckets;\n+            Size        : Positive;\n+\n+         begin\n+            --  Calculate the new size and allocate a new set of buckets. Note\n+            --  that a table with a small size or a small growth percentage may\n+            --  not always grow (for example, 10 buckets and 3% increase). In\n+            --  that case, enforce a minimum increase.\n+\n+            Size :=\n+              Positive'Max (Curr_Size * ((100 + Growth_Percentage) / 100),\n+                            Min_Size_Increase);\n+            Buckets := Create_Buckets (Size);\n+\n+            --  Inspect the old buckets and transfer all elements by rehashing\n+            --  all (key, value) pairs in the new buckets.\n+\n+            for Index in Old_Buckets'Range loop\n+               Old_Bucket := Old_Buckets (Index)'Unchecked_Access;\n+\n+               --  The current bucket chain contains an element other than the\n+               --  dummy head.\n+\n+               while not Is_Empty_Chain (Old_Bucket) loop\n+\n+                  --  Skip the dummy head and find the new hash location\n+\n+                  Elmt     := Old_Bucket.Next;\n+                  Hash_Loc := Hash (Elmt.Key, Size);\n+\n+                  --  Remove the element from the old buckets and insert it\n+                  --  into the new buckets. Note that there is no need to check\n+                  --  for duplicates because the hash table did not have any to\n+                  --  begin with.\n+\n+                  Detach (Elmt);\n+                  Attach\n+                    (Elmt  => Elmt,\n+                     Chain => Buckets (Hash_Loc)'Unchecked_Access);\n+               end loop;\n+            end loop;\n+\n+            --  Associate the new buckets with the table and reclaim the\n+            --  storage occupied by the old buckets.\n+\n+            T.Buckets := Buckets;\n+\n+            Free (Old_Buckets);\n+         end Grow;\n+\n+         --  Local variables\n+\n+         subtype LLF is Long_Long_Float;\n+\n+         Count    : Natural renames T.Element_Count;\n+         Bucket   : Element_Ptr;\n+         Hash_Loc : Range_Type;\n+\n+      --  Start of processing for Set\n+\n+      begin\n+         --  Find the bucket where the (key, value) pair should be inserted by\n+         --  computing the proper hash location.\n+\n+         Hash_Loc := Hash (Key, Curr_Size);\n+         Bucket   := T.Buckets (Hash_Loc)'Unchecked_Access;\n+\n+         --  Ensure that the key is not already present in the bucket in order\n+         --  to avoid duplicates.\n+\n+         if Find (Key, Bucket) = No_Element then\n+            Attach\n+              (Elmt  => new Element'(Key, Val, null, null),\n+               Chain => Bucket);\n+            Count := Count + 1;\n+\n+            --  Multiple insertions may cause long bucket chains and decrease\n+            --  the performance of basic operations. If this is the case, grow\n+            --  the table and rehash all existing elements.\n+\n+            if (LLF (Count) / LLF (Curr_Size)) > LLF (Load_Factor) then\n+               Grow;\n+            end if;\n+         end if;\n+      end Set;\n+   end Load_Factor_HTable;\n+\n end GNAT.Dynamic_HTables;"}, {"sha": "b5670b3120a424c0e25dbe83381d2397ac6bf8a3", "filename": "gcc/ada/g-dynhta.ads", "status": "modified", "additions": 122, "deletions": 10, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dynhta.ads?ref=cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2013, AdaCore                     --\n+--                     Copyright (C) 1995-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,11 +31,13 @@\n \n --  Hash table searching routines\n \n---  This package contains two separate packages. The Simple_HTable package\n---  provides a very simple abstraction that associates one element to one\n---  key value and takes care of all allocations automatically using the heap.\n---  The Static_HTable package provides a more complex interface that allows\n---  complete control over allocation.\n+--  This package contains three separate packages. The Simple_HTable package\n+--  provides a very simple abstraction that associates one element to one key\n+--  value and takes care of all allocations automatically using the heap. The\n+--  Static_HTable package provides a more complex interface that allows full\n+--  control over allocation. The Load_Factor_HTable package provides a more\n+--  complex abstraction where collisions are resolved by chaining, and the\n+--  table grows by a percentage after the load factor has been exceeded.\n \n --  This package provides a facility similar to that of GNAT.HTable, except\n --  that this package declares types that can be used to define dynamic\n@@ -46,7 +48,8 @@\n --  GNAT.HTable to keep as much coherency as possible between these two\n --  related units.\n \n-with Ada.Unchecked_Deallocation;\n+private with Ada.Finalization;\n+\n package GNAT.Dynamic_HTables is\n \n    -------------------\n@@ -210,9 +213,6 @@ package GNAT.Dynamic_HTables is\n          Next : Elmt_Ptr;\n       end record;\n \n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Element_Wrapper, Elmt_Ptr);\n-\n       procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr);\n       function  Next     (E : Elmt_Ptr) return Elmt_Ptr;\n       function  Get_Key  (E : Elmt_Ptr) return Key;\n@@ -234,4 +234,116 @@ package GNAT.Dynamic_HTables is\n \n    end Simple_HTable;\n \n+   ------------------------\n+   -- Load_Factor_HTable --\n+   ------------------------\n+\n+   --  A simple hash table abstraction capable of growing once a treshold has\n+   --  been exceeded. Collisions are resolved by chaining elements onto lists\n+   --  hanging from individual buckets. This implementation does not make any\n+   --  effort in minimizing the number of necessary rehashes once the table has\n+   --  been expanded, hence the term \"simple\".\n+\n+   --  WARNING: This hash table implementation utilizes dynamic allocation.\n+   --  Storage reclamation is performed by the hash table.\n+\n+   --  WARNING: This hash table implementation is not thread-safe. To achieve\n+   --  proper concurrency and synchronization, wrap an instance of a table in\n+   --  a protected object.\n+\n+   generic\n+      type Range_Type is range <>;\n+      --  The underlying range of the hash table. Note that this type must be\n+      --  large enough to accomodate multiple expansions of the table.\n+\n+      type Key_Type is private;\n+      type Value_Type is private;\n+      --  The types of the (key, value) pair stored in the hash table\n+\n+      No_Value : Value_Type;\n+      --  A predefined value denoting a non-existent value\n+\n+      Initial_Size : Positive;\n+      --  The starting size of the hash table. The hash table must contain at\n+      --  least one bucket.\n+\n+      Growth_Percentage : Positive;\n+      --  The amount of increase expressed as a percentage. The hash table must\n+      --  grow by at least 1%. To illustrate, a value of 100 will increase the\n+      --  table by 100% effectively doubling its size.\n+\n+      Load_Factor : Float;\n+      --  The ratio of the elements stored within the hash table divided by the\n+      --  current size of the table. This value acts as the growth treshold. If\n+      --  exceeded, the hash table is expanded by Growth_Percentage.\n+\n+      with function Equal\n+        (Left  : Key_Type;\n+         Right : Key_Type) return Boolean;\n+\n+      with function Hash\n+        (Key  : Key_Type;\n+         Size : Positive) return Range_Type;\n+      --  Parameter Size denotes the current size of the hash table\n+\n+   package Load_Factor_HTable is\n+      type Table is tagged limited private;\n+\n+      function Current_Size (T : Table) return Positive;\n+      --  Obtain the current size of the table\n+\n+      function Get (T : Table; Key : Key_Type) return Value_Type;\n+      --  Obtain the value associated with a key. This routne returns No_Value\n+      --  if the key is not present in the hash table.\n+\n+      procedure Remove (T : in out Table; Key : Key_Type);\n+      --  Remove the value associated with the given key. This routine has no\n+      --  effect if the key is not present in the hash table.\n+\n+      procedure Set\n+        (T   : in out Table;\n+         Key : Key_Type;\n+         Val : Value_Type);\n+      --  Associate a value with a given key. This routine has no effect if the\n+      --  the (key, value) pair is already present in the hash table. Note that\n+      --  this action may cause the table to grow.\n+\n+   private\n+      --  The following types model a bucket chain. Note that the key is also\n+      --  stored for rehashing purposes.\n+\n+      type Element;\n+      type Element_Ptr is access all Element;\n+      type Element is record\n+         Key  : Key_Type;\n+         Val  : Value_Type;\n+         Prev : Element_Ptr := null;\n+         Next : Element_Ptr := null;\n+      end record;\n+\n+      No_Element : constant Element_Ptr := null;\n+\n+      --  The following types model the buckets of the hash table. Each bucket\n+      --  has a dummy head to facilitate insertion and deletion of elements.\n+\n+      type Buckets_Array is array (Range_Type range <>) of aliased Element;\n+      type Buckets_Array_Ptr is access all Buckets_Array;\n+\n+      type Table is new Ada.Finalization.Limited_Controlled with record\n+         Buckets : Buckets_Array_Ptr := null;\n+\n+         Element_Count : Natural := 0;\n+         --  The number of (key, value) pairs stored in the hash table\n+      end record;\n+\n+      procedure Finalize (T : in out Table);\n+      --  Destroy the contents of a hash table by reclaiming all storage used\n+      --  by buckets and their respective chains.\n+\n+      procedure Initialize (T : in out Table);\n+      --  Create a hash table with buckets within the range Range_Type'First ..\n+      --  Range_Type'First + Initial_Size - 1.\n+\n+   end Load_Factor_HTable;\n+\n end GNAT.Dynamic_HTables;"}, {"sha": "245464a6706718cece6060fd82e4e22f0ea9d3a7", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=cc9b1e1ca0e9c28d8a8704abb9faa1ea3b76d676", "patch": "@@ -2009,10 +2009,10 @@ package body Sem_Ch5 is\n                      Set_Etype (Def_Id, Entity (Element));\n \n                      --  If subtype indication was given, verify that it\n-                     --  matches element type of container.\n+                     --  covers the element type of the container.\n \n                      if Present (Subt)\n-                       and then Bas /= Base_Type (Etype (Def_Id))\n+                       and then not Covers (Bas, Etype (Def_Id))\n                      then\n                         Error_Msg_N\n                           (\"subtype indication does not match element type\","}]}