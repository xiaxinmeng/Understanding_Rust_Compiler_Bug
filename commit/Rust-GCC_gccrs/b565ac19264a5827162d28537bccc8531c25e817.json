{"sha": "b565ac19264a5827162d28537bccc8531c25e817", "node_id": "C_kwDOANBUbNoAKGI1NjVhYzE5MjY0YTU4MjcxNjJkMjg1MzdiY2NjODUzMWMyNWU4MTc", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-13T22:03:58Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-17T13:20:39Z"}, "message": "Add relation_trio class for range-ops.\n\nThere are 3 possible relations range-ops might care about, but only the one\nmost likely to be needed is supplied.   This patch provides a new class\nrelation_trio which allows 3 relations to be passed in a single word.\n\nfold_range (), op1_range (), and op2_range () are adjusted to take a\nrelation_trio class instead of a relation_kind, then the routine can\nextract which relation it wants to work with.\n\n\t* gimple-range-fold.cc (fold_using_range::range_of_range_op):\n\tProvide relation_trio class.\n\t* gimple-range-gori.cc (gori_compute::refine_using_relation):\n\tProvide relation_trio class.\n\t(gori_compute::refine_using_relation): Ditto.\n\t(gori_compute::compute_operand1_range): Provide lhs_op2 and\n\top1_op2 relations via relation_trio class.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t* gimple-range-op.cc (gimple_range_op_handler::calc_op1): Use\n\trelation_trio instead of relation_kind.\n\t(gimple_range_op_handler::calc_op2): Ditto.\n\t(*::fold_range): Ditto.\n\t* gimple-range-op.h (gimple_range_op::calc_op1): Adjust prototypes.\n\t(gimple_range_op::calc_op2): Adjust prototypes.\n\t* range-op-float.cc (*::fold_range): Use relation_trio instead of\n\trelation_kind.\n\t(*::op1_range): Ditto.\n\t(*::op2_range): Ditto.\n\t* range-op.cc (*::fold_range): Use relation_trio instead of\n\trelation_kind.\n\t(*::op1_range): Ditto.\n\t(*::op2_range): Ditto.\n\t* range-op.h (class range_operator): Adjust prototypes.\n\t(class range_operator_float): Ditto.\n\t(class range_op_handler): Adjust prototypes.\n\t(relop_early_resolve): Pickup op1_op2 relation from relation_trio.\n\t* value-relation.cc (VREL_LAST): Adjust use to be one past the end of\n\tthe enum.\n\t(relation_oracle::validate_relation): Use relation_trio in call\n\tto fold_range.\n\t* value-relation.h (enum relation_kind_t): Add VREL_LAST as\n\tfinal element.\n\t(class relation_trio): New.\n\t(TRIO_VARYING, TRIO_SHIFT, TRIO_MASK): New.", "tree": {"sha": "52a1122cf961dd409f02c3eb5c34811ed5e1f3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52a1122cf961dd409f02c3eb5c34811ed5e1f3e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b565ac19264a5827162d28537bccc8531c25e817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b565ac19264a5827162d28537bccc8531c25e817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b565ac19264a5827162d28537bccc8531c25e817", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b565ac19264a5827162d28537bccc8531c25e817/comments", "author": null, "committer": null, "parents": [{"sha": "04874fedae8074b252abbd70fea68bf3dd0a605b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04874fedae8074b252abbd70fea68bf3dd0a605b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04874fedae8074b252abbd70fea68bf3dd0a605b"}], "stats": {"total": 696, "additions": 405, "deletions": 291}, "files": [{"sha": "f91923782dca96f7e0bcfd2bdfc101b37f9c49ad", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -578,7 +578,8 @@ fold_using_range::range_of_range_op (vrange &r,\n \t      fputc ('\\n', dump_file);\n \t    }\n \t  // Fold range, and register any dependency if available.\n-\t  if (!handler.fold_range (r, type, range1, range2, rel))\n+\t  if (!handler.fold_range (r, type, range1, range2,\n+\t\t\t\t   relation_trio::op1_op2 (rel)))\n \t    r.set_varying (type);\n \t  if (irange::supports_p (type))\n \t    relation_fold_and_or (as_a <irange> (r), s, src);\n@@ -597,7 +598,7 @@ fold_using_range::range_of_range_op (vrange &r,\n \t\t}\n \t      if (gimple_range_ssa_p (op2))\n \t\t{\n-\t\t  rel= handler.lhs_op2_relation (r, range1, range2, rel);\n+\t\t  rel = handler.lhs_op2_relation (r, range1, range2, rel);\n \t\t  if (rel != VREL_VARYING)\n \t\t    src.register_relation (s, rel, lhs, op2);\n \t\t}"}, {"sha": "610a5295e6287f4bdb91065d34e59923772e57ec", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -991,7 +991,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op1_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, k))\n+\t\t\t\t other_op, relation_trio::lhs_op2 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1023,7 +1023,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op2_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, k))\n+\t\t\t\t other_op, relation_trio::lhs_op1 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1074,28 +1074,34 @@ gori_compute::compute_operand1_range (vrange &r,\n     {\n       src.get_operand (op2_range, op2);\n       relation_kind k = VREL_VARYING;\n+      relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n       if (rel)\n \t{\n \t if (lhs_name == rel->op1 () && op1 == rel->op2 ())\n \t   k = rel->kind ();\n \t else if (lhs_name == rel->op2 () && op1 == rel->op1 ())\n \t   k = relation_swap (rel->kind ());\n \t else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-\t   refine_using_relation (op1, op1_range, op2, op2_range, src,\n-\t\t\t\t  rel->kind ());\n+\t   {\n+\t     op_op = rel->kind ();\n+\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\t   }\n \t else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-\t   refine_using_relation (op1, op1_range, op2, op2_range, src,\n-\t\t\t\t  relation_swap (rel->kind ()));\n+\t   {\n+\t     op_op = relation_swap (rel->kind ());\n+\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\t   }\n        }\n-      if (!handler.calc_op1 (tmp, lhs, op2_range, k))\n+      if (!handler.calc_op1 (tmp, lhs, op2_range, relation_trio (VREL_VARYING,\n+\t\t\t\t\t\t\t\t k, op_op)))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!handler.calc_op1 (tmp, lhs, op1_range, VREL_VARYING))\n+      if (!handler.calc_op1 (tmp, lhs, op1_range, TRIO_VARYING))\n \treturn false;\n     }\n \n@@ -1167,23 +1173,28 @@ gori_compute::compute_operand2_range (vrange &r,\n   src.get_operand (op1_range, op1);\n   src.get_operand (op2_range, op2);\n   relation_kind k = VREL_VARYING;\n+  relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n   if (rel)\n     {\n       if (lhs_name == rel->op1 () && op2 == rel->op2 ())\n-       k = rel->kind ();\n+\tk = rel->kind ();\n       else if (lhs_name == rel->op2 () && op2 == rel->op1 ())\n-       k = relation_swap (rel->kind ());\n+\tk = relation_swap (rel->kind ());\n       else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-       refine_using_relation (op1, op1_range, op2, op2_range, src,\n-\t\t\t      rel->kind ());\n+\t{\n+\t  op_op = rel->kind ();\n+\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\t}\n       else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-       refine_using_relation (op1, op1_range, op2, op2_range, src,\n-\t\t\t      relation_swap (rel->kind ()));\n+\t{\n+\t  op_op = relation_swap (rel->kind ());\n+\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\t}\n     }\n \n-\n   // Intersect with range for op2 based on lhs and op1.\n-  if (!handler.calc_op2 (tmp, lhs, op1_range, k))\n+  if (!handler.calc_op2 (tmp, lhs, op1_range, relation_trio (k, VREL_VARYING,\n+\t\t\t\t\t\t\t     op_op)))\n     return false;\n \n   unsigned idx;"}, {"sha": "7764166d5fb1a6bfef1a97e288803d05f09f2611", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -202,7 +202,7 @@ gimple_range_op_handler::calc_op1 (vrange &r, const vrange &lhs_range)\n \n bool\n gimple_range_op_handler::calc_op1 (vrange &r, const vrange &lhs_range,\n-\t\t\t\t   const vrange &op2_range, relation_kind k)\n+\t\t\t\t   const vrange &op2_range, relation_trio k)\n {\n   // Give up on empty ranges.\n   if (lhs_range.undefined_p ())\n@@ -237,7 +237,7 @@ gimple_range_op_handler::calc_op1 (vrange &r, const vrange &lhs_range,\n \n bool\n gimple_range_op_handler::calc_op2 (vrange &r, const vrange &lhs_range,\n-\t\t\t\t   const vrange &op1_range, relation_kind k)\n+\t\t\t\t   const vrange &op1_range, relation_trio k)\n {\n   // Give up on empty ranges.\n   if (lhs_range.undefined_p ())\n@@ -263,7 +263,7 @@ class cfn_constant_float_p : public range_operator_float\n public:\n   using range_operator_float::fold_range;\n   virtual bool fold_range (irange &r, tree type, const frange &lh,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     if (lh.singleton_p ())\n       {\n@@ -285,7 +285,7 @@ class cfn_constant_p : public range_operator\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     if (lh.singleton_p ())\n       {\n@@ -308,7 +308,7 @@ class cfn_signbit : public range_operator_float\n   using range_operator_float::fold_range;\n   using range_operator_float::op1_range;\n   virtual bool fold_range (irange &r, tree type, const frange &lh,\n-\t\t\t   const irange &, relation_kind) const override\n+\t\t\t   const irange &, relation_trio) const override\n   {\n     bool signbit;\n     if (lh.signbit_p (signbit))\n@@ -322,7 +322,7 @@ class cfn_signbit : public range_operator_float\n    return false;\n   }\n   virtual bool op1_range (frange &r, tree type, const irange &lhs,\n-\t\t\t  const frange &, relation_kind) const override\n+\t\t\t  const frange &, relation_trio) const override\n   {\n     if (lhs.zero_p ())\n       {\n@@ -348,7 +348,7 @@ class cfn_copysign : public range_operator_float\n public:\n   using range_operator_float::fold_range;\n   virtual bool fold_range (frange &r, tree type, const frange &lh,\n-\t\t\t   const frange &rh, relation_kind) const override\n+\t\t\t   const frange &rh, relation_trio) const override\n   {\n     frange neg;\n     range_op_handler abs_op (ABS_EXPR, type);\n@@ -381,7 +381,7 @@ class cfn_toupper_tolower : public range_operator\n   using range_operator::fold_range;\n   cfn_toupper_tolower (bool toupper)  { m_toupper = toupper; }\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const;\n+\t\t\t   const irange &, relation_trio) const;\n private:\n   bool get_letter_range (tree type, irange &lowers, irange &uppers) const;\n   bool m_toupper;\n@@ -412,7 +412,7 @@ cfn_toupper_tolower::get_letter_range (tree type, irange &lowers,\n \n bool\n cfn_toupper_tolower::fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t\t const irange &, relation_kind) const\n+\t\t\t\t const irange &, relation_trio) const\n {\n   int_range<3> lowers;\n   int_range<3> uppers;\n@@ -445,7 +445,7 @@ class cfn_ffs : public range_operator\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     if (lh.undefined_p ())\n       return false;\n@@ -472,7 +472,7 @@ class cfn_popcount : public cfn_ffs\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &rh, relation_kind rel) const\n+\t\t\t   const irange &rh, relation_trio rel) const\n   {\n     if (lh.undefined_p ())\n       return false;\n@@ -502,14 +502,14 @@ class cfn_clz : public range_operator\n   cfn_clz (bool internal) { m_gimple_call_internal_p = internal; }\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const;\n+\t\t\t   const irange &, relation_trio) const;\n private:\n   bool m_gimple_call_internal_p;\n } op_cfn_clz (false), op_cfn_clz_internal (true);\n \n bool\n cfn_clz::fold_range (irange &r, tree type, const irange &lh,\n-\t\t     const irange &, relation_kind) const\n+\t\t     const irange &, relation_trio) const\n {\n   // __builtin_c[lt]z* return [0, prec-1], except when the\n   // argument is 0, but that is undefined behavior.\n@@ -577,14 +577,14 @@ class cfn_ctz : public range_operator\n   cfn_ctz (bool internal) { m_gimple_call_internal_p = internal; }\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const;\n+\t\t\t   const irange &, relation_trio) const;\n private:\n   bool m_gimple_call_internal_p;\n } op_cfn_ctz (false), op_cfn_ctz_internal (true);\n \n bool\n cfn_ctz::fold_range (irange &r, tree type, const irange &lh,\n-\t\t     const irange &, relation_kind) const\n+\t\t     const irange &, relation_trio) const\n {\n   if (lh.undefined_p ())\n     return false;\n@@ -647,7 +647,7 @@ class cfn_clrsb : public range_operator\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     if (lh.undefined_p ())\n       return false;\n@@ -665,7 +665,7 @@ class cfn_ubsan : public range_operator\n   cfn_ubsan (enum tree_code code) { m_code = code; }\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &rh, relation_kind rel) const\n+\t\t\t   const irange &rh, relation_trio rel) const\n   {\n     range_op_handler handler (m_code, type);\n     gcc_checking_assert (handler);\n@@ -699,7 +699,7 @@ class cfn_strlen : public range_operator\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     tree max = vrp_val_max (ptrdiff_type_node);\n     wide_int wmax\n@@ -724,7 +724,7 @@ class cfn_goacc_dim : public range_operator\n   cfn_goacc_dim (bool is_pos) { m_is_pos = is_pos; }\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &lh,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     tree axis_tree;\n     if (!lh.singleton_p (&axis_tree))\n@@ -751,7 +751,7 @@ class cfn_parity : public range_operator\n public:\n   using range_operator::fold_range;\n   virtual bool fold_range (irange &r, tree type, const irange &,\n-\t\t\t   const irange &, relation_kind) const\n+\t\t\t   const irange &, relation_trio) const\n   {\n     r.set (build_zero_cst (type), build_one_cst (type));\n     return true;"}, {"sha": "be1305c58aa3c7e91bd02c4f183409d3c889eddd", "filename": "gcc/gimple-range-op.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fgimple-range-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.h?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -36,9 +36,9 @@ class gimple_range_op_handler : public range_op_handler\n   tree operand2 () const { gcc_checking_assert (m_valid); return m_op2; }\n   bool calc_op1 (vrange &r, const vrange &lhs_range);\n   bool calc_op1 (vrange &r, const vrange &lhs_range, const vrange &op2_range,\n-\t\t relation_kind k = VREL_VARYING);\n+\t\t relation_trio = TRIO_VARYING);\n   bool calc_op2 (vrange &r, const vrange &lhs_range, const vrange &op1_range,\n-\t\t relation_kind k = VREL_VARYING);\n+\t\t relation_trio = TRIO_VARYING);\n private:\n   void maybe_builtin_call ();\n   gimple *m_stmt;"}, {"sha": "e7334794b0d2f62602385648fd372347ec84c787", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -53,7 +53,7 @@ range_operator_float::fold_range (frange &r ATTRIBUTE_UNUSED,\n \t\t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n \t\t\t\t  const frange &rh ATTRIBUTE_UNUSED,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   return false;\n }\n@@ -63,7 +63,7 @@ range_operator_float::fold_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n \t\t\t\t  const irange &rh ATTRIBUTE_UNUSED,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   return false;\n }\n@@ -73,7 +73,7 @@ range_operator_float::fold_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n \t\t\t\t  const frange &rh ATTRIBUTE_UNUSED,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   return false;\n }\n@@ -83,7 +83,7 @@ range_operator_float::op1_range (frange &r ATTRIBUTE_UNUSED,\n \t\t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return false;\n }\n@@ -93,7 +93,7 @@ range_operator_float::op1_range (frange &r ATTRIBUTE_UNUSED,\n \t\t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return false;\n }\n@@ -103,7 +103,7 @@ range_operator_float::op2_range (frange &r ATTRIBUTE_UNUSED,\n \t\t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return false;\n }\n@@ -113,7 +113,7 @@ range_operator_float::op2_range (frange &r ATTRIBUTE_UNUSED,\n \t\t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return false;\n }\n@@ -188,7 +188,7 @@ finite_operands_p (const frange &op1, const frange &op2)\n inline bool\n frelop_early_resolve (irange &r, tree type,\n \t\t      const frange &op1, const frange &op2,\n-\t\t      relation_kind rel, relation_kind my_rel)\n+\t\t      relation_trio rel, relation_kind my_rel)\n {\n   // If either operand is undefined, return VARYING.\n   if (empty_range_varying (r, type, op1, op2))\n@@ -324,14 +324,14 @@ class foperator_identity : public range_operator_float\n public:\n   bool fold_range (frange &r, tree type ATTRIBUTE_UNUSED,\n \t\t   const frange &op1, const frange &op2 ATTRIBUTE_UNUSED,\n-\t\t   relation_kind = VREL_VARYING) const final override\n+\t\t   relation_trio = TRIO_VARYING) const final override\n   {\n     r = op1;\n     return true;\n   }\n   bool op1_range (frange &r, tree type ATTRIBUTE_UNUSED,\n \t\t  const frange &lhs, const frange &op2 ATTRIBUTE_UNUSED,\n-\t\t  relation_kind = VREL_VARYING) const final override\n+\t\t  relation_trio = TRIO_VARYING) const final override\n   {\n     r = lhs;\n     return true;\n@@ -348,26 +348,26 @@ class foperator_equal : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return equal_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const final override\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n   {\n-    return op1_range (r, type, lhs, op1, rel);\n+    return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n   }\n } fop_equal;\n \n bool\n foperator_equal::fold_range (irange &r, tree type,\n \t\t\t     const frange &op1, const frange &op2,\n-\t\t\t     relation_kind rel) const\n+\t\t\t     relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_EQ))\n     return true;\n@@ -403,8 +403,9 @@ bool\n foperator_equal::op1_range (frange &r, tree type,\n \t\t\t    const irange &lhs,\n \t\t\t    const frange &op2,\n-\t\t\t    relation_kind rel) const\n+\t\t\t    relation_trio trio) const\n {\n+  relation_kind rel = trio.op1_op2 ();\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n@@ -455,20 +456,20 @@ class foperator_not_equal : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override;\n+\t\t   relation_trio rel = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return not_equal_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_not_equal;\n \n bool\n foperator_not_equal::fold_range (irange &r, tree type,\n \t\t\t\t const frange &op1, const frange &op2,\n-\t\t\t\t relation_kind rel) const\n+\t\t\t\t relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_NE))\n     return true;\n@@ -505,8 +506,9 @@ bool\n foperator_not_equal::op1_range (frange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst frange &op2,\n-\t\t\t\trelation_kind rel) const\n+\t\t\t\trelation_trio trio) const\n {\n+  relation_kind rel = trio.op1_op2 ();\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n@@ -557,23 +559,23 @@ class foperator_lt : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return lt_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_lt;\n \n bool\n foperator_lt::fold_range (irange &r, tree type,\n \t\t\t  const frange &op1, const frange &op2,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n     return true;\n@@ -599,7 +601,7 @@ foperator_lt::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op2,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -634,7 +636,7 @@ foperator_lt::op2_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op1,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -673,23 +675,23 @@ class foperator_le : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override;\n+\t\t   relation_trio rel = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return le_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind rel = VREL_VARYING) const final override;\n+\t\t  relation_trio rel = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const final override;\n+\t\t  relation_trio rel = TRIO_VARYING) const final override;\n } fop_le;\n \n bool\n foperator_le::fold_range (irange &r, tree type,\n \t\t\t  const frange &op1, const frange &op2,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n     return true;\n@@ -715,7 +717,7 @@ foperator_le::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op2,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -746,7 +748,7 @@ foperator_le::op2_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op1,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -781,23 +783,23 @@ class foperator_gt : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return gt_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_gt;\n \n bool\n foperator_gt::fold_range (irange &r, tree type,\n \t\t\t  const frange &op1, const frange &op2,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n     return true;\n@@ -823,7 +825,7 @@ foperator_gt::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op2,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -858,7 +860,7 @@ foperator_gt::op2_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op1,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -897,23 +899,23 @@ class foperator_ge : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return ge_op1_op2_relation (lhs);\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_ge;\n \n bool\n foperator_ge::fold_range (irange &r, tree type,\n \t\t\t  const frange &op1, const frange &op2,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n     return true;\n@@ -939,7 +941,7 @@ foperator_ge::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op2,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -969,7 +971,7 @@ bool\n foperator_ge::op2_range (frange &r, tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op1,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1008,22 +1010,22 @@ class foperator_unordered : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const final override\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n   {\n-    return op1_range (r, type, lhs, op1, rel);\n+    return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n   }\n } fop_unordered;\n \n bool\n foperator_unordered::fold_range (irange &r, tree type,\n \t\t\t\t const frange &op1, const frange &op2,\n-\t\t\t\t relation_kind) const\n+\t\t\t\t relation_trio) const\n {\n   // UNORDERED is TRUE if either operand is a NAN.\n   if (op1.known_isnan () || op2.known_isnan ())\n@@ -1040,8 +1042,9 @@ bool\n foperator_unordered::op1_range (frange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst frange &op2,\n-\t\t\t\trelation_kind rel) const\n+\t\t\t\trelation_trio trio) const\n {\n+  relation_kind rel = trio.op1_op2 ();\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n@@ -1081,22 +1084,22 @@ class foperator_ordered : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const final override\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n   {\n-    return op1_range (r, type, lhs, op1, rel);\n+    return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n   }\n } fop_ordered;\n \n bool\n foperator_ordered::fold_range (irange &r, tree type,\n \t\t\t       const frange &op1, const frange &op2,\n-\t\t\t       relation_kind) const\n+\t\t\t       relation_trio) const\n {\n   if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n@@ -1111,8 +1114,9 @@ bool\n foperator_ordered::op1_range (frange &r, tree type,\n \t\t\t      const irange &lhs,\n \t\t\t      const frange &op2,\n-\t\t\t      relation_kind rel) const\n+\t\t\t      relation_trio trio) const\n {\n+  relation_kind rel = trio.op1_op2 ();\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n@@ -1148,7 +1152,7 @@ class foperator_negate : public range_operator_float\n public:\n   bool fold_range (frange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind = VREL_VARYING) const final override\n+\t\t   relation_trio = TRIO_VARYING) const final override\n   {\n     if (empty_range_varying (r, type, op1, op2))\n       return true;\n@@ -1181,7 +1185,7 @@ class foperator_negate : public range_operator_float\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const frange &lhs, const frange &op2,\n-\t\t  relation_kind rel = VREL_VARYING) const final override\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n   {\n     return fold_range (r, type, lhs, op2, rel);\n   }\n@@ -1194,16 +1198,16 @@ class foperator_abs : public range_operator_float\n public:\n   bool fold_range (frange &r, tree type,\n \t\t   const frange &op1, const frange &,\n-\t\t   relation_kind = VREL_VARYING) const final override;\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n   bool op1_range (frange &r, tree type,\n \t\t  const frange &lhs, const frange &op2,\n-\t\t  relation_kind rel = VREL_VARYING) const final override;\n+\t\t  relation_trio rel = TRIO_VARYING) const final override;\n } fop_abs;\n \n bool\n foperator_abs::fold_range (frange &r, tree type,\n \t\t\t   const frange &op1, const frange &op2,\n-\t\t\t   relation_kind) const\n+\t\t\t   relation_trio) const\n {\n   if (empty_range_varying (r, type, op1, op2))\n     return true;\n@@ -1253,7 +1257,7 @@ foperator_abs::fold_range (frange &r, tree type,\n bool\n foperator_abs::op1_range (frange &r, tree type,\n \t\t\t  const frange &lhs, const frange &op2,\n-\t\t\t  relation_kind) const\n+\t\t\t  relation_trio) const\n {\n   if (empty_range_varying (r, type, lhs, op2))\n     return true;\n@@ -1282,7 +1286,7 @@ class foperator_unordered_lt : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n       {\n@@ -1311,7 +1315,7 @@ class foperator_unordered_le : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n       {\n@@ -1332,16 +1336,16 @@ class foperator_unordered_le : public range_operator_float\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_unordered_le;\n \n bool\n foperator_unordered_le::op1_range (frange &r, tree type,\n \t\t\t\t   const irange &lhs, const frange &op2,\n-\t\t\t\t   relation_kind) const\n+\t\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1365,7 +1369,7 @@ foperator_unordered_le::op2_range (frange &r,\n \t\t\t\t   tree type,\n \t\t\t\t   const irange &lhs,\n \t\t\t\t   const frange &op1,\n-\t\t\t\t   relation_kind) const\n+\t\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1392,7 +1396,7 @@ class foperator_unordered_gt : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n       {\n@@ -1413,18 +1417,18 @@ class foperator_unordered_gt : public range_operator_float\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_unordered_gt;\n \n bool\n foperator_unordered_gt::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n \t\t\t const frange &op2,\n-\t\t\t relation_kind) const\n+\t\t\t relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1448,7 +1452,7 @@ foperator_unordered_gt::op2_range (frange &r,\n \t\t\t\t   tree type,\n \t\t\t\t   const irange &lhs,\n \t\t\t\t   const frange &op1,\n-\t\t\t\t   relation_kind) const\n+\t\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1475,7 +1479,7 @@ class foperator_unordered_ge : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n       {\n@@ -1496,18 +1500,18 @@ class foperator_unordered_ge : public range_operator_float\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n } fop_unordered_ge;\n \n bool\n foperator_unordered_ge::op1_range (frange &r,\n \t\t\t\t   tree type,\n \t\t\t\t   const irange &lhs,\n \t\t\t\t   const frange &op2,\n-\t\t\t\t   relation_kind) const\n+\t\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1530,7 +1534,7 @@ bool\n foperator_unordered_ge::op2_range (frange &r, tree type,\n \t\t\t\t   const irange &lhs,\n \t\t\t\t   const frange &op1,\n-\t\t\t\t   relation_kind) const\n+\t\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1557,7 +1561,7 @@ class foperator_unordered_equal : public range_operator_float\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel = VREL_VARYING) const final override\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n       {\n@@ -1578,20 +1582,20 @@ class foperator_unordered_equal : public range_operator_float\n   }\n   bool op1_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op2,\n-\t\t  relation_kind = VREL_VARYING) const final override;\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const final override\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n   {\n-    return op1_range (r, type, lhs, op1, rel);\n+    return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n   }\n } fop_unordered_equal;\n \n bool\n foperator_unordered_equal::op1_range (frange &r, tree type,\n \t\t\t\t      const irange &lhs,\n \t\t\t\t      const frange &op2,\n-\t\t\t\t      relation_kind) const\n+\t\t\t\t      relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {"}, {"sha": "49ee7be3d3be6ac9f98f6290eaf8f57e5528fa5c", "filename": "gcc/range-op.cc", "status": "modified", "additions": 135, "deletions": 132, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -179,12 +179,13 @@ bool\n range_operator::fold_range (irange &r, tree type,\n \t\t\t    const irange &lh,\n \t\t\t    const irange &rh,\n-\t\t\t    relation_kind rel) const\n+\t\t\t    relation_trio trio) const\n {\n   gcc_checking_assert (r.supports_type_p (type));\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n \n+  relation_kind rel = trio.op1_op2 ();\n   unsigned num_lh = lh.num_pairs ();\n   unsigned num_rh = rh.num_pairs ();\n \n@@ -227,7 +228,7 @@ range_operator::op1_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t   const irange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio) const\n {\n   return false;\n }\n@@ -239,7 +240,7 @@ range_operator::op2_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t   const irange &op1 ATTRIBUTE_UNUSED,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio) const\n {\n   return false;\n }\n@@ -453,15 +454,15 @@ class operator_equal : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &val,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &val,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_equal;\n \n@@ -494,7 +495,7 @@ bool\n operator_equal::fold_range (irange &r, tree type,\n \t\t\t    const irange &op1,\n \t\t\t    const irange &op2,\n-\t\t\t    relation_kind rel) const\n+\t\t\t    relation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_EQ))\n     return true;\n@@ -527,7 +528,7 @@ bool\n operator_equal::op1_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -558,9 +559,9 @@ bool\n operator_equal::op2_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n \t\t\t   const irange &op1,\n-\t\t\t   relation_kind rel) const\n+\t\t\t   relation_trio rel) const\n {\n-  return operator_equal::op1_range (r, type, lhs, op1, rel);\n+  return operator_equal::op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n }\n \n class operator_not_equal : public range_operator\n@@ -572,15 +573,15 @@ class operator_not_equal : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_not_equal;\n \n@@ -612,7 +613,7 @@ bool\n operator_not_equal::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &op1,\n \t\t\t\tconst irange &op2,\n-\t\t\t\trelation_kind rel) const\n+\t\t\t\trelation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_NE))\n     return true;\n@@ -645,7 +646,7 @@ bool\n operator_not_equal::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n \t\t\t       const irange &op2,\n-\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t       relation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -677,9 +678,9 @@ bool\n operator_not_equal::op2_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n \t\t\t       const irange &op1,\n-\t\t\t       relation_kind rel) const\n+\t\t\t       relation_trio rel) const\n {\n-  return operator_not_equal::op1_range (r, type, lhs, op1, rel);\n+  return operator_not_equal::op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n }\n \n // (X < VAL) produces the range of [MIN, VAL - 1].\n@@ -751,15 +752,15 @@ class operator_lt :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_lt;\n \n@@ -791,7 +792,7 @@ bool\n operator_lt::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n \t\t\t const irange &op2,\n-\t\t\t relation_kind rel) const\n+\t\t\t relation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n     return true;\n@@ -815,7 +816,7 @@ bool\n operator_lt::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op2,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -837,7 +838,7 @@ bool\n operator_lt::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op1,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -865,15 +866,15 @@ class operator_le :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_le;\n \n@@ -905,7 +906,7 @@ bool\n operator_le::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n \t\t\t const irange &op2,\n-\t\t\t relation_kind rel) const\n+\t\t\t relation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n     return true;\n@@ -926,7 +927,7 @@ bool\n operator_le::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op2,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -948,7 +949,7 @@ bool\n operator_le::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op1,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -976,15 +977,15 @@ class operator_gt :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_gt;\n \n@@ -1016,7 +1017,7 @@ operator_gt::op1_op2_relation (const irange &lhs) const\n bool\n operator_gt::fold_range (irange &r, tree type,\n \t\t\t const irange &op1, const irange &op2,\n-\t\t\t relation_kind rel) const\n+\t\t\t relation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n     return true;\n@@ -1036,7 +1037,7 @@ operator_gt::fold_range (irange &r, tree type,\n bool\n operator_gt::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs, const irange &op2,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1058,7 +1059,7 @@ bool\n operator_gt::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op1,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1086,15 +1087,15 @@ class operator_ge :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_ge;\n \n@@ -1126,7 +1127,7 @@ bool\n operator_ge::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n \t\t\t const irange &op2,\n-\t\t\t relation_kind rel) const\n+\t\t\t relation_trio rel) const\n {\n   if (relop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n     return true;\n@@ -1147,7 +1148,7 @@ bool\n operator_ge::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op2,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1169,7 +1170,7 @@ bool\n operator_ge::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n \t\t\tconst irange &op1,\n-\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\trelation_trio) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -1198,11 +1199,11 @@ class operator_plus : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -1402,7 +1403,7 @@ bool\n operator_plus::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -1411,6 +1412,7 @@ operator_plus::op1_range (irange &r, tree type,\n   if (!minus)\n     return false;\n   bool res = minus.fold_range (r, type, lhs, op2);\n+  relation_kind rel = trio.lhs_op2 ();\n   // Check for a relation refinement.\n   if (res)\n     adjust_op1_for_overflow (r, op2, rel, true /* PLUS_EXPR */);\n@@ -1421,9 +1423,9 @@ bool\n operator_plus::op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n-  return op1_range (r, type, lhs, op1, rel);\n+  return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n }\n \n \n@@ -1436,11 +1438,11 @@ class operator_minus : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -1573,7 +1575,7 @@ bool\n operator_minus::op1_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -1582,6 +1584,7 @@ operator_minus::op1_range (irange &r, tree type,\n   if (!minus)\n     return false;\n   bool res = minus.fold_range (r, type, lhs, op2);\n+  relation_kind rel = trio.lhs_op2 ();\n   if (res)\n     adjust_op1_for_overflow (r, op2, rel, false /* PLUS_EXPR */);\n   return res;\n@@ -1592,7 +1595,7 @@ bool\n operator_minus::op2_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n \t\t\t   const irange &op1,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -1752,17 +1755,17 @@ class operator_mult : public cross_product_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n } op_mult;\n \n bool\n operator_mult::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs, const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t  relation_trio) const\n {\n   tree offset;\n   if (lhs.undefined_p ())\n@@ -1783,9 +1786,9 @@ operator_mult::op1_range (irange &r, tree type,\n bool\n operator_mult::op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs, const irange &op1,\n-\t\t\t  relation_kind rel) const\n+\t\t\t  relation_trio rel) const\n {\n-  return operator_mult::op1_range (r, type, lhs, op1, rel);\n+  return operator_mult::op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n }\n \n bool\n@@ -2009,15 +2012,15 @@ class operator_exact_divide : public operator_div\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n \n } op_exact_div;\n \n bool\n operator_exact_divide::op1_range (irange &r, tree type,\n \t\t\t\t  const irange &lhs,\n \t\t\t\t  const irange &op2,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -2043,11 +2046,11 @@ class operator_lshift : public cross_product_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n \n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n@@ -2067,7 +2070,7 @@ class operator_rshift : public cross_product_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb,\n \t\t\tconst wide_int &lh_ub,\n@@ -2080,7 +2083,7 @@ class operator_rshift : public cross_product_operator\n   virtual bool op1_range (irange &, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t   const irange &op1,\n \t\t\t\t\t   const irange &op2,\n@@ -2106,7 +2109,7 @@ bool\n operator_lshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n \t\t\t     const irange &op2,\n-\t\t\t     relation_kind rel) const\n+\t\t\t     relation_trio rel) const\n {\n   int_range_max shift_range;\n   if (!get_shift_range (shift_range, type, op2))\n@@ -2228,7 +2231,7 @@ operator_lshift::op1_range (irange &r,\n \t\t\t    tree type,\n \t\t\t    const irange &lhs,\n \t\t\t    const irange &op2,\n-\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t    relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -2301,7 +2304,7 @@ operator_rshift::op1_range (irange &r,\n \t\t\t    tree type,\n \t\t\t    const irange &lhs,\n \t\t\t    const irange &op2,\n-\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t    relation_trio) const\n {\n   tree shift;\n   if (lhs.undefined_p ())\n@@ -2380,7 +2383,7 @@ bool\n operator_rshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n \t\t\t     const irange &op2,\n-\t\t\t     relation_kind rel) const\n+\t\t\t     relation_trio rel) const\n {\n   int_range_max shift;\n   if (!get_shift_range (shift, type, op2))\n@@ -2412,11 +2415,11 @@ class operator_cast: public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t  const irange &op1,\n \t\t\t\t\t  const irange &op2,\n@@ -2528,7 +2531,7 @@ bool\n operator_cast::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &inner,\n \t\t\t   const irange &outer,\n-\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t   relation_trio) const\n {\n   if (empty_range_varying (r, type, inner, outer))\n     return true;\n@@ -2567,7 +2570,7 @@ bool\n operator_cast::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t  relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -2682,23 +2685,23 @@ class operator_logical_and : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_logical_and;\n \n \n bool\n operator_logical_and::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n \t\t\t\t  const irange &rh,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -2721,7 +2724,7 @@ bool\n operator_logical_and::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -2743,7 +2746,7 @@ bool\n operator_logical_and::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op1,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return operator_logical_and::op1_range (r, type, lhs, op1);\n }\n@@ -2758,15 +2761,15 @@ class operator_bitwise_and : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -2786,7 +2789,7 @@ bool\n operator_bitwise_and::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n \t\t\t\t  const irange &rh,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   if (range_operator::fold_range (r, type, lh, rh))\n     {\n@@ -3136,7 +3139,7 @@ bool\n operator_bitwise_and::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -3171,7 +3174,7 @@ bool\n operator_bitwise_and::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op1,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return operator_bitwise_and::op1_range (r, type, lhs, op1);\n }\n@@ -3186,22 +3189,22 @@ class operator_logical_or : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_logical_or;\n \n bool\n operator_logical_or::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const irange &lh,\n \t\t\t\t const irange &rh,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -3215,7 +3218,7 @@ bool\n operator_logical_or::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -3237,7 +3240,7 @@ bool\n operator_logical_or::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op1,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   return operator_logical_or::op1_range (r, type, lhs, op1);\n }\n@@ -3251,11 +3254,11 @@ class operator_bitwise_or : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel= VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -3323,7 +3326,7 @@ bool\n operator_bitwise_or::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op2,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -3345,7 +3348,7 @@ bool\n operator_bitwise_or::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op1,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   return operator_bitwise_or::op1_range (r, type, lhs, op1);\n }\n@@ -3364,11 +3367,11 @@ class operator_bitwise_xor : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_op2_relation_effect (irange &lhs_range,\n \t\t\t\t\ttree type,\n \t\t\t\t\tconst irange &op1_range,\n@@ -3454,7 +3457,7 @@ bool\n operator_bitwise_xor::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   if (lhs.undefined_p () || lhs.varying_p ())\n     {\n@@ -3489,7 +3492,7 @@ bool\n operator_bitwise_xor::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op1,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   return operator_bitwise_xor::op1_range (r, type, lhs, op1);\n }\n@@ -3507,11 +3510,11 @@ class operator_trunc_mod : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n } op_trunc_mod;\n \n void\n@@ -3574,7 +3577,7 @@ bool\n operator_trunc_mod::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n \t\t\t       const irange &,\n-\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t       relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -3600,7 +3603,7 @@ bool\n operator_trunc_mod::op2_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n \t\t\t       const irange &,\n-\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t       relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -3644,11 +3647,11 @@ class operator_logical_not : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_logical_not;\n \n // Folding a logical NOT, oddly enough, involves doing nothing on the\n@@ -3669,7 +3672,7 @@ bool\n operator_logical_not::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n \t\t\t\t  const irange &rh ATTRIBUTE_UNUSED,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -3686,7 +3689,7 @@ operator_logical_not::op1_range (irange &r,\n \t\t\t\t tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   // Logical NOT is involutary...do it again.\n   return fold_range (r, type, lhs, op2);\n@@ -3701,18 +3704,18 @@ class operator_bitwise_not : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_bitwise_not;\n \n bool\n operator_bitwise_not::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n \t\t\t\t  const irange &rh,\n-\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t  relation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -3730,7 +3733,7 @@ bool\n operator_bitwise_not::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2,\n-\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\t relation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -3749,14 +3752,14 @@ class operator_cst : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n } op_integer_cst;\n \n bool\n operator_cst::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t  const irange &lh,\n \t\t\t  const irange &rh ATTRIBUTE_UNUSED,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t  relation_trio) const\n {\n   r = lh;\n   return true;\n@@ -3772,11 +3775,11 @@ class operator_identity : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t   const irange &op1,\n \t\t\t\t\t   const irange &op2,\n@@ -3801,7 +3804,7 @@ bool\n operator_identity::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t       const irange &lh,\n \t\t\t       const irange &rh ATTRIBUTE_UNUSED,\n-\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t       relation_trio) const\n {\n   r = lh;\n   return true;\n@@ -3811,7 +3814,7 @@ bool\n operator_identity::op1_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t      const irange &lhs,\n \t\t\t      const irange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t      relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t      relation_trio) const\n {\n   r = lhs;\n   return true;\n@@ -3825,14 +3828,14 @@ class operator_unknown : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n } op_unknown;\n \n bool\n operator_unknown::fold_range (irange &r, tree type,\n \t\t\t      const irange &lh ATTRIBUTE_UNUSED,\n \t\t\t      const irange &rh ATTRIBUTE_UNUSED,\n-\t\t\t      relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t      relation_trio) const\n {\n   r.set_varying (type);\n   return true;\n@@ -3851,7 +3854,7 @@ class operator_abs : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n+\t\t\t  relation_trio) const;\n } op_abs;\n \n void\n@@ -3932,7 +3935,7 @@ bool\n operator_abs::op1_range (irange &r, tree type,\n \t\t\t const irange &lhs,\n \t\t\t const irange &op2,\n-\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t relation_trio) const\n {\n   if (empty_range_varying (r, type, lhs, op2))\n     return true;\n@@ -4013,18 +4016,18 @@ class operator_negate : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_negate;\n \n bool\n operator_negate::fold_range (irange &r, tree type,\n \t\t\t     const irange &lh,\n \t\t\t     const irange &rh,\n-\t\t\t     relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t     relation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -4037,7 +4040,7 @@ bool\n operator_negate::op1_range (irange &r, tree type,\n \t\t\t    const irange &lhs,\n \t\t\t    const irange &op2,\n-\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t    relation_trio) const\n {\n   // NEGATE is involutory.\n   return fold_range (r, type, lhs, op2);\n@@ -4052,18 +4055,18 @@ class operator_addr_expr : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio rel = TRIO_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n } op_addr;\n \n bool\n operator_addr_expr::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &lh,\n \t\t\t\tconst irange &rh,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -4082,7 +4085,7 @@ bool\n operator_addr_expr::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n \t\t\t       const irange &op2,\n-\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t       relation_trio) const\n {\n   return operator_addr_expr::fold_range (r, type, lhs, op2);\n }\n@@ -4204,11 +4207,11 @@ class pointer_or_operator : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio rel = TRIO_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n@@ -4218,7 +4221,7 @@ bool\n pointer_or_operator::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   if (lhs.undefined_p ())\n     return false;\n@@ -4236,7 +4239,7 @@ bool\n pointer_or_operator::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op1,\n-\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t\trelation_trio) const\n {\n   return pointer_or_operator::op1_range (r, type, lhs, op1);\n }\n@@ -4422,7 +4425,7 @@ bool\n range_op_handler::fold_range (vrange &r, tree type,\n \t\t\t      const vrange &lh,\n \t\t\t      const vrange &rh,\n-\t\t\t      relation_kind rel) const\n+\t\t\t      relation_trio rel) const\n {\n   gcc_checking_assert (m_valid);\n   if (m_int)\n@@ -4450,7 +4453,7 @@ bool\n range_op_handler::op1_range (vrange &r, tree type,\n \t\t\t     const vrange &lhs,\n \t\t\t     const vrange &op2,\n-\t\t\t     relation_kind rel) const\n+\t\t\t     relation_trio rel) const\n {\n   gcc_checking_assert (m_valid);\n \n@@ -4474,7 +4477,7 @@ bool\n range_op_handler::op2_range (vrange &r, tree type,\n \t\t\t     const vrange &lhs,\n \t\t\t     const vrange &op1,\n-\t\t\t     relation_kind rel) const\n+\t\t\t     relation_trio rel) const\n {\n   gcc_checking_assert (m_valid);\n   if (lhs.undefined_p ())"}, {"sha": "c7249890142ded11c61a26a91549a698caa37d18", "filename": "gcc/range-op.h", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -53,7 +53,7 @@ class range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -69,11 +69,11 @@ class range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n \n   // The following routines are used to represent relations between the\n   // various operations.  If the caller knows where the symbolics are,\n@@ -116,32 +116,32 @@ class range_operator_float\n   virtual bool fold_range (frange &r, tree type,\n \t\t\t   const frange &lh,\n \t\t\t   const frange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   // Unary operations have the range of the LHS as op2.\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const frange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const frange &lh,\n \t\t\t   const frange &rh,\n-\t\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t\t   relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n \t\t\t  const frange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op1_range (frange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const frange &op2,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n \t\t\t  const frange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const frange &op1,\n-\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n \n   virtual relation_kind lhs_op1_relation (const frange &lhs,\n \t\t\t\t\t  const frange &op1,\n@@ -173,15 +173,15 @@ class range_op_handler\n   bool fold_range (vrange &r, tree type,\n \t\t   const vrange &lh,\n \t\t   const vrange &rh,\n-\t\t   relation_kind rel = VREL_VARYING) const;\n+\t\t   relation_trio = TRIO_VARYING) const;\n   bool op1_range (vrange &r, tree type,\n \t\t  const vrange &lhs,\n \t\t  const vrange &op2,\n-\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t  relation_trio = TRIO_VARYING) const;\n   bool op2_range (vrange &r, tree type,\n \t\t  const vrange &lhs,\n \t\t  const vrange &op1,\n-\t\t  relation_kind rel = VREL_VARYING) const;\n+\t\t  relation_trio = TRIO_VARYING) const;\n   relation_kind lhs_op1_relation (const vrange &lhs,\n \t\t\t\t  const vrange &op1,\n \t\t\t\t  const vrange &op2,\n@@ -240,9 +240,10 @@ empty_range_varying (vrange &r, tree type,\n \n inline bool\n relop_early_resolve (irange &r, tree type, const vrange &op1,\n-\t\t     const vrange &op2, relation_kind rel,\n+\t\t     const vrange &op2, relation_trio trio,\n \t\t     relation_kind my_rel)\n {\n+  relation_kind rel = trio.op1_op2 ();\n   // If known relation is a complete subset of this relation, always true.\n   if (relation_union (rel, my_rel) == my_rel)\n     {"}, {"sha": "fed8a78723c3ceb818131e57f8503cc31c6f7dc5", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -32,9 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"dominance.h\"\n \n-#define VREL_LAST               VREL_PE64\n-\n-static const char *kind_string[VREL_LAST + 1] =\n+static const char *kind_string[VREL_LAST] =\n { \"varying\", \"undefined\", \"<\", \"<=\", \">\", \">=\", \"==\", \"!=\", \"pe8\", \"pe16\",\n   \"pe32\", \"pe64\" };\n \n@@ -47,7 +45,7 @@ print_relation (FILE *f, relation_kind rel)\n }\n \n // This table is used to negate the operands.  op1 REL op2 -> !(op1 REL op2).\n-relation_kind rr_negate_table[VREL_LAST + 1] = {\n+relation_kind rr_negate_table[VREL_LAST] = {\n   VREL_VARYING, VREL_UNDEFINED, VREL_GE, VREL_GT, VREL_LE, VREL_LT, VREL_NE,\n   VREL_EQ };\n \n@@ -60,7 +58,7 @@ relation_negate (relation_kind r)\n }\n \n // This table is used to swap the operands.  op1 REL op2 -> op2 REL op1.\n-relation_kind rr_swap_table[VREL_LAST + 1] = {\n+relation_kind rr_swap_table[VREL_LAST] = {\n   VREL_VARYING, VREL_UNDEFINED, VREL_GT, VREL_GE, VREL_LT, VREL_LE, VREL_EQ,\n   VREL_NE };\n \n@@ -74,7 +72,7 @@ relation_swap (relation_kind r)\n \n // This table is used to perform an intersection between 2 relations.\n \n-relation_kind rr_intersect_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+relation_kind rr_intersect_table[VREL_LAST][VREL_LAST] = {\n // VREL_VARYING\n   { VREL_VARYING, VREL_UNDEFINED, VREL_LT, VREL_LE, VREL_GT, VREL_GE, VREL_EQ,\n     VREL_NE },\n@@ -112,7 +110,7 @@ relation_intersect (relation_kind r1, relation_kind r2)\n \n // This table is used to perform a union between 2 relations.\n \n-relation_kind rr_union_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+relation_kind rr_union_table[VREL_LAST][VREL_LAST] = {\n // VREL_VARYING\n   { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n     VREL_VARYING, VREL_VARYING, VREL_VARYING },\n@@ -150,7 +148,7 @@ relation_union (relation_kind r1, relation_kind r2)\n // This table is used to determine transitivity between 2 relations.\n // (A relation0 B) and (B relation1 C) implies  (A result C)\n \n-relation_kind rr_transitive_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+relation_kind rr_transitive_table[VREL_LAST][VREL_LAST] = {\n // VREL_VARYING\n   { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n     VREL_VARYING, VREL_VARYING, VREL_VARYING },\n@@ -187,7 +185,7 @@ relation_transitive (relation_kind r1, relation_kind r2)\n \n // This vector maps a relation to the equivalent tree code.\n \n-tree_code relation_to_code [VREL_LAST + 1] = {\n+tree_code relation_to_code [VREL_LAST] = {\n   ERROR_MARK, ERROR_MARK, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EQ_EXPR,\n   NE_EXPR };\n \n@@ -226,7 +224,8 @@ relation_oracle::validate_relation (relation_kind rel, vrange &op1, vrange &op2)\n \n   // If the relation cannot be folded for any reason, leave as is.\n   Value_Range result (boolean_type_node);\n-  if (!handler.fold_range (result, boolean_type_node, op1, op2, rel))\n+  if (!handler.fold_range (result, boolean_type_node, op1, op2,\n+\t\t\t   relation_trio::op1_op2 (rel)))\n     return rel;\n \n   // The expression op1 REL op2 using REL should fold to [1,1]."}, {"sha": "027d7416163c039186f5b2acae2817a35602c734", "filename": "gcc/value-relation.h", "status": "modified", "additions": 107, "deletions": 12, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565ac19264a5827162d28537bccc8531c25e817/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=b565ac19264a5827162d28537bccc8531c25e817", "patch": "@@ -35,31 +35,30 @@ along with GCC; see the file COPYING3.  If not see\n // utilizes the relation information to enhance it's range calculations, this\n // is totally transparent to the client, and they are free to make queries.\n //\n-//\n-// relation_kind is a typedef of enum tree_code, but has restricted range\n-// and a couple of extra values.\n+// relation_kind is a new enum which represents the different relations,\n+// often with a direct mapping to treee codes. ie VREL_EQ is equivalent to\n+// EQ_EXPR.\n //\n // A query is made requesting the relation between SSA1 and SSA@ in a basic\n // block, or on an edge, the possible return values are:\n //\n-//  EQ_EXPR, NE_EXPR, LT_EXPR, LE_EXPR, GT_EXPR, and GE_EXPR mean the same.\n+//  VREL_EQ, VREL_NE, VREL_LT, VREL_LE, VREL_GT, and VREL_GE mean the same.\n //  VREL_VARYING : No relation between the 2 names.\n //  VREL_UNDEFINED : Impossible relation (ie, A < B && A > B)\n //\n-// The oracle maintains EQ_EXPR relations with equivalency sets, so if a\n-// relation comes back EQ_EXPR, it is also possible to query the set of\n-// equivlaencies.  These are basically bitmaps over ssa_names.\n+// The oracle maintains VREL_EQ relations with equivalency sets, so if a\n+// relation comes back VREL_EQ, it is also possible to query the set of\n+// equivlaencies.  These are basically bitmaps over ssa_names.  An iterator is\n+// provided later for this activity.\n //\n // Relations are maintained via the dominace trees and are optimized assuming\n // they are registered in dominance order.   When a new relation is added, it\n // is intersected with whatever existing relation exists in the dominance tree\n // and registered at the specified block.\n \n \n-// Rather than introduce a new enumerated type for relations, we can use the\n-// existing tree_codes for relations, plus add a couple of #defines for\n-// the other cases.  These codes are arranged such that VREL_VARYING is the\n-// first code, and all the rest are contiguous.\n+// These codes are arranged such that VREL_VARYING is the first code, and all\n+// the rest are contiguous.\n \n typedef enum relation_kind_t\n {\n@@ -74,7 +73,8 @@ typedef enum relation_kind_t\n   VREL_PE8,\t\t// 8 bit partial equivalency\n   VREL_PE16,\t\t// 16 bit partial equivalency\n   VREL_PE32,\t\t// 32 bit partial equivalency\n-  VREL_PE64\t\t// 64 bit partial equivalency\n+  VREL_PE64,\t\t// 64 bit partial equivalency\n+  VREL_LAST\t\t// terminate, not a real relation.\n } relation_kind;\n \n // General relation kind transformations.\n@@ -315,6 +315,101 @@ class equiv_relation_iterator {\n        ((equiv_name) = iter.get_name (&equiv_rel));\t\t\t\\\n        iter.next ())\n \n+// -----------------------------------------------------------------------\n+\n+// Range-ops deals with a LHS and 2 operands. A relation trio is a set of\n+// 3 potential relations packed into a single unsigned value.\n+//  1 - LHS relation OP1\n+//  2 - LHS relation OP2\n+//  3 - OP1 relation OP2\n+//  VREL_VARYING is a value of 0, and is the default for each position.\n+class relation_trio\n+{\n+public:\n+  relation_trio ();\n+  relation_trio (relation_kind lhs_op1, relation_kind lhs_op2,\n+\t\t relation_kind op1_op2);\n+  relation_kind lhs_op1 ();\n+  relation_kind lhs_op2 ();\n+  relation_kind op1_op2 ();\n+  relation_trio swap_op1_op2 ();\n+\n+  static relation_trio lhs_op1 (relation_kind k);\n+  static relation_trio lhs_op2 (relation_kind k);\n+  static relation_trio op1_op2 (relation_kind k);\n+\n+protected:\n+  unsigned m_val;\n+};\n+\n+//  Default VREL_VARYING for all 3 relations.\n+#define TRIO_VARYING\trelation_trio ()\n+\n+#define TRIO_SHIFT\t4\n+#define TRIO_MASK\t0x000F\n+\n+// These 3 classes are shortcuts for when a caller has a single relation to\n+// pass as a trio, it can simply construct the appropriate one.  The other\n+// unspecified realtions will be VREL_VARYING.\n+\n+inline relation_trio::relation_trio ()\n+{\n+  STATIC_ASSERT (VREL_LAST <= (1 << TRIO_SHIFT));\n+  m_val = 0;\n+}\n+\n+inline relation_trio::relation_trio (relation_kind lhs_op1,\n+\t\t\t\t     relation_kind lhs_op2,\n+\t\t\t\t     relation_kind op1_op2)\n+{\n+  STATIC_ASSERT (VREL_LAST <= (1 << TRIO_SHIFT));\n+  unsigned i1 = (unsigned) lhs_op1;\n+  unsigned i2 = ((unsigned) lhs_op2) << TRIO_SHIFT;\n+  unsigned i3 = ((unsigned) op1_op2) << (TRIO_SHIFT * 2);\n+  m_val = i1 | i2 | i3;\n+}\n+\n+inline relation_trio\n+relation_trio::lhs_op1 (relation_kind k)\n+{\n+  return relation_trio (k, VREL_VARYING, VREL_VARYING);\n+}\n+inline relation_trio\n+relation_trio::lhs_op2 (relation_kind k)\n+{\n+  return relation_trio (VREL_VARYING, k, VREL_VARYING);\n+}\n+inline relation_trio\n+relation_trio::op1_op2 (relation_kind k)\n+{\n+  return relation_trio (VREL_VARYING, VREL_VARYING, k);\n+}\n+\n+inline relation_kind\n+relation_trio::lhs_op1 ()\n+{\n+  return (relation_kind) (m_val & TRIO_MASK);\n+}\n+\n+inline relation_kind\n+relation_trio::lhs_op2 ()\n+{\n+  return (relation_kind) ((m_val >> TRIO_SHIFT) & TRIO_MASK);\n+}\n+\n+inline relation_kind\n+relation_trio::op1_op2 ()\n+{\n+  return (relation_kind) ((m_val >> (TRIO_SHIFT * 2)) & TRIO_MASK);\n+}\n+\n+inline relation_trio\n+relation_trio::swap_op1_op2 ()\n+{\n+  return relation_trio (lhs_op2 (), lhs_op1 (), relation_swap (op1_op2 ()));\n+}\n+\n+// -----------------------------------------------------------------------\n \n // The value-relation class is used to encapsulate the represention of an\n // individual relation between 2 ssa-names, and to facilitate operating on"}]}