{"sha": "4ee00913cab55b910e13162ddde001b873e57dd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVlMDA5MTNjYWI1NWI5MTBlMTMxNjJkZGRlMDAxYjg3M2U1N2RkMg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-12-11T22:44:19Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-12-11T22:44:19Z"}, "message": "tree-ssa-structalias.c (process_constraint): Remove code to transform addressofs into scalar.\n\n2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c (process_constraint): Remove code to\n\ttransform addressofs into scalar.\n\t(create_variable_info_for): In whole-program IPA, globals don't\n\tpoint to ANYTHING by default.\n\n2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* timevar.def (TV_IPA_PTA): New.\n\t* tree-pass.h (pass_ipa_pta): New\n\t* tree-ssa-structalias.c: Include cgraph.h\n\t(in_ipa_mode): New.\n\t(predbitmap_obstack): New.\n\t(EXECUTE_IF_IN_NONNULL_BITMAP): New.\n\t(struct constraint_stats): Add num_edges.\n\t(new_var_info): Don't call bitmap_clear.\n\t(struct constraint_edge): Update docs.\n\t(new_constraint_edge): Remove src param.\n\t(struct constraint_graph): Add zero_weight_succs,\n\tzero_weight_preds.  Update docs.\n\t(constraint_expr_equal): Reformat.\n\t(constraint_edge_equal): Update for removal of src.\n\t(constraint_edge_less): Ditto.\n\t(constraint_edge_vec_find): Ditto.\n\t(erase_graph_self_edge): Update for removal of src and and zero\n\tweight bitmap.\n\t(clear_edges_for_node): Ditto.\n\t(add_graph_edge): Ditto.\n\t(get_graph_weights): Ditto.\n\t(allocate_graph_weights): Ditto.\n\t(merge_graph_nodes): Ditto.\n\t(int_add_graph_edge): Ditto.\n\t(valid_graph_edge): Ditto.\n\t(valid_weighted_graph_edge): Ditto.\n\t(build_constraint_graph): Ditto.\n\t(scc_visit): Ditto.\n\t(collapse_nodes): Ditto.\n\t(process_unification_queue): Ditto.\n\t(topo_visit): Ditto.\n\t(solve_graph): Ditto.\n\t(do_structure_copy): Ditto.\n\t(perform_var_substitution): Ditto.\n\tInit and release obstack.\n\t(handle_ptr_arith): Try to resolve directly.\n\t(find_func_aliases): Don't call update_alias_info here\n\tHandle RETURN_EXPR, and CALL_EXPR's in IPA mode.\n\t(do_sd_constraint): Add code for propagating faster.\n\tUpdate.\n\t(do_ds_constraint): Ditto.\n\t(count_num_arguments): New function.\n\t(create_function_info_for): Ditto.\n\t(create_variable_info_for): Handle FUNCTION_DECL.\n\t(intra_create_variable_infos): Use make_constraint_to_anything.\n\t(init_alias_vars): Init obstacks here.\n\t(need_to_solve): Handle zero weight graph changes.\n\t(compute_points_to_sets): Call update_alias_info here.\n\t(delete_points_to_sets): Free zero weight preds/succs here.\n\t(gate_ipa_pta): New.\n\t(ipa_pta_execute): New\n\n2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c (var_anyoffset): Removed.\n\t(anyoffset_tree): Ditto.\n\t(anyoffset_id): Ditto.\n\t(do_deref): Take vector of constraints, no return value.\n\tUpdate to work on vector.\t\t \n\t(get_constraint_for): Ditto.\n\t(get_constraint_for_component_ref): Ditto.\n\t(do_structure_copy): Ditto.\n\t(handle_ptr_arith): Ditto.\n\t(find_func_aliases): Ditto.\n\t(set_uids_in_ptset): Remove anyoffset handling.\n\t(init_base_vars): Ditto.\n\nFrom-SVN: r108384", "tree": {"sha": "ba0c9cf4ec94cbd27125c146303fa68274d5c8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba0c9cf4ec94cbd27125c146303fa68274d5c8ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ee00913cab55b910e13162ddde001b873e57dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee00913cab55b910e13162ddde001b873e57dd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee00913cab55b910e13162ddde001b873e57dd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee00913cab55b910e13162ddde001b873e57dd2/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1005cc9c0df0458e6dbbe44d6a560effecfb7cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1005cc9c0df0458e6dbbe44d6a560effecfb7cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1005cc9c0df0458e6dbbe44d6a560effecfb7cc3"}], "stats": {"total": 1656, "additions": 1230, "deletions": 426}, "files": [{"sha": "47d19ac89a82b6cc4a55429389d5b9927483b04b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ee00913cab55b910e13162ddde001b873e57dd2", "patch": "@@ -1,3 +1,79 @@\n+2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c (process_constraint): Remove code to\n+\ttransform addressofs into scalar.\n+\t(create_variable_info_for): In whole-program IPA, globals don't\n+\tpoint to ANYTHING by default.\n+\n+2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* timevar.def (TV_IPA_PTA): New.\n+\t* tree-pass.h (pass_ipa_pta): New\n+\t* tree-ssa-structalias.c: Include cgraph.h\n+\t(in_ipa_mode): New.\n+\t(predbitmap_obstack): New.\n+\t(EXECUTE_IF_IN_NONNULL_BITMAP): New.\n+\t(struct constraint_stats): Add num_edges.\n+\t(new_var_info): Don't call bitmap_clear.\n+\t(struct constraint_edge): Update docs.\n+\t(new_constraint_edge): Remove src param.\n+\t(struct constraint_graph): Add zero_weight_succs,\n+\tzero_weight_preds.  Update docs.\n+\t(constraint_expr_equal): Reformat.\n+\t(constraint_edge_equal): Update for removal of src.\n+\t(constraint_edge_less): Ditto.\n+\t(constraint_edge_vec_find): Ditto.\n+\t(erase_graph_self_edge): Update for removal of src and and zero\n+\tweight bitmap.\n+\t(clear_edges_for_node): Ditto.\n+\t(add_graph_edge): Ditto.\n+\t(get_graph_weights): Ditto.\n+\t(allocate_graph_weights): Ditto.\n+\t(merge_graph_nodes): Ditto.\n+\t(int_add_graph_edge): Ditto.\n+\t(valid_graph_edge): Ditto.\n+\t(valid_weighted_graph_edge): Ditto.\n+\t(build_constraint_graph): Ditto.\n+\t(scc_visit): Ditto.\n+\t(collapse_nodes): Ditto.\n+\t(process_unification_queue): Ditto.\n+\t(topo_visit): Ditto.\n+\t(solve_graph): Ditto.\n+\t(do_structure_copy): Ditto.\n+\t(perform_var_substitution): Ditto.\n+\tInit and release obstack.\n+\t(handle_ptr_arith): Try to resolve directly.\n+\t(find_func_aliases): Don't call update_alias_info here\n+\tHandle RETURN_EXPR, and CALL_EXPR's in IPA mode.\n+\t(do_sd_constraint): Add code for propagating faster.\n+\tUpdate.\n+\t(do_ds_constraint): Ditto.\n+\t(count_num_arguments): New function.\n+\t(create_function_info_for): Ditto.\n+\t(create_variable_info_for): Handle FUNCTION_DECL.\n+\t(intra_create_variable_infos): Use make_constraint_to_anything.\n+\t(init_alias_vars): Init obstacks here.\n+\t(need_to_solve): Handle zero weight graph changes.\n+\t(compute_points_to_sets): Call update_alias_info here.\n+\t(delete_points_to_sets): Free zero weight preds/succs here.\n+\t(gate_ipa_pta): New.\n+\t(ipa_pta_execute): New\n+\n+2005-12-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c (var_anyoffset): Removed.\n+\t(anyoffset_tree): Ditto.\n+\t(anyoffset_id): Ditto.\n+\t(do_deref): Take vector of constraints, no return value.\n+\tUpdate to work on vector.\t\t \n+\t(get_constraint_for): Ditto.\n+\t(get_constraint_for_component_ref): Ditto.\n+\t(do_structure_copy): Ditto.\n+\t(handle_ptr_arith): Ditto.\n+\t(find_func_aliases): Ditto.\n+\t(set_uids_in_ptset): Remove anyoffset handling.\n+\t(init_base_vars): Ditto.\n+\n 2005-12-10  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/25010"}, {"sha": "a74670881d6c13061b9f9cb30b02b6de1c417623", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=4ee00913cab55b910e13162ddde001b873e57dd2", "patch": "@@ -46,6 +46,7 @@ DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n DEFTIMEVAR (TV_IPA_TYPE_ESCAPE       , \"ipa type escape\")\n+DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n /* Time spent by constructing CFG.  */\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */"}, {"sha": "bd1b94b516dcb1e1e353274f7250a898166d6455", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4ee00913cab55b910e13162ddde001b873e57dd2", "patch": "@@ -294,6 +294,7 @@ extern struct tree_opt_pass pass_early_ipa_inline;\n extern struct tree_opt_pass pass_ipa_reference;\n extern struct tree_opt_pass pass_ipa_pure_const;\n extern struct tree_opt_pass pass_ipa_type_escape;\n+extern struct tree_opt_pass pass_ipa_pta;\n extern struct tree_opt_pass pass_early_local_passes;\n \n extern struct tree_opt_pass pass_all_optimizations;"}, {"sha": "7f3446b886f9fefc7dc3f1d79e687e333d975236", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1152, "deletions": 426, "changes": 1578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee00913cab55b910e13162ddde001b873e57dd2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=4ee00913cab55b910e13162ddde001b873e57dd2", "patch": "@@ -49,6 +49,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n #include \"alloc-pool.h\"\n #include \"splay-tree.h\"\n #include \"tree-ssa-structalias.h\"\n+#include \"cgraph.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -162,22 +163,29 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n   htab_t heapvar_for_stmt;\n static bool use_field_sensitive = true;\n+static int in_ipa_mode = 0;\n+static bitmap_obstack predbitmap_obstack;\n+static bitmap_obstack ptabitmap_obstack;\n+static bitmap_obstack iteration_obstack;\n+\n static unsigned int create_variable_info_for (tree, const char *);\n-static struct constraint_expr get_constraint_for (tree, bool *);\n static void build_constraint_graph (void);\n \n-static bitmap_obstack ptabitmap_obstack;\n-static bitmap_obstack iteration_obstack;\n DEF_VEC_P(constraint_t);\n DEF_VEC_ALLOC_P(constraint_t,heap);\n \n+#define EXECUTE_IF_IN_NONNULL_BITMAP(a, b, c, d)\t\\\n+  if (a)\t\t\t\t\t\t\\\n+    EXECUTE_IF_SET_IN_BITMAP (a, b, c, d)\n+\n static struct constraint_stats\n {\n   unsigned int total_vars;\n   unsigned int collapsed_vars;\n   unsigned int unified_vars_static;\n   unsigned int unified_vars_dynamic;\n   unsigned int iterations;\n+  unsigned int num_edges;\n } stats;\n \n struct variable_info\n@@ -303,13 +311,6 @@ static varinfo_t var_integer;\n static tree integer_tree;\n static unsigned int integer_id;\n \n-/* Variable that represents arbitrary offsets into an object.  Used to\n-   represent pointer arithmetic, which may not legally escape the\n-   bounds of an object.  */\n-static varinfo_t var_anyoffset;\n-static tree anyoffset_tree;\n-static unsigned int anyoffset_id;\n-\n \n /* Lookup a heap var for FROM, and return it if we find one.  */\n \n@@ -362,9 +363,7 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   ret->is_unknown_size_var = false;\n   ret->has_union = false;\n   ret->solution = BITMAP_ALLOC (&ptabitmap_obstack);\n-  bitmap_clear (ret->solution);\n   ret->variables = BITMAP_ALLOC (&ptabitmap_obstack);\n-  bitmap_clear (ret->variables);\n   ret->complex = NULL;\n   ret->next = NULL;\n   ret->collapsed_to = NULL;\n@@ -391,7 +390,11 @@ struct constraint_expr\n   unsigned HOST_WIDE_INT offset;\n };\n \n-static struct constraint_expr do_deref (struct constraint_expr);\n+typedef struct constraint_expr ce_s;\n+DEF_VEC_O(ce_s);\n+DEF_VEC_ALLOC_O(ce_s, heap);\n+static void get_constraint_for (tree, VEC(ce_s, heap) **, bool *);\n+static void do_deref (VEC (ce_s, heap) **);\n \n /* Our set constraints are made up of two constraint expressions, one\n    LHS, and one RHS.  \n@@ -410,15 +413,14 @@ struct constraint\n static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n-/* An edge in the constraint graph.  We technically have no use for\n-   the src, since it will always be the same node that we are indexing\n-   into the pred/succ arrays with, but it's nice for checking\n-   purposes.  The edges are weighted, with a bit set in weights for\n-   each edge from src to dest with that weight.  */\n+/* An edge in the weighted constraint graph.   The edges are weighted,\n+   with a bit set in weights meaning their is an edge with that\n+   weight. \n+   We don't keep the src in the edge, because we always know what it\n+   is. */\n \n struct constraint_edge\n {\n-  unsigned int src;\n   unsigned int dest;\n   bitmap weights;\n };\n@@ -429,10 +431,9 @@ static alloc_pool constraint_edge_pool;\n /* Return a new constraint edge from SRC to DEST.  */\n \n static constraint_edge_t\n-new_constraint_edge (unsigned int src, unsigned int dest)\n+new_constraint_edge (unsigned int dest)\n {\n   constraint_edge_t ret = pool_alloc (constraint_edge_pool);\n-  ret->src = src;\n   ret->dest = dest;\n   ret->weights = NULL;\n   return ret;\n@@ -442,16 +443,21 @@ DEF_VEC_P(constraint_edge_t);\n DEF_VEC_ALLOC_P(constraint_edge_t,heap);\n \n \n-/* The constraint graph is simply a set of adjacency vectors, one per\n-   variable. succs[x] is the vector of successors for variable x, and preds[x]\n-   is the vector of predecessors for variable x. \n-   IOW, all edges are \"forward\" edges, which is not like our CFG.  \n-   So remember that\n-   preds[x]->src == x, and\n-   succs[x]->src == x.  */\n+/* The constraint graph is represented internally in two different\n+   ways.  The overwhelming majority of edges in the constraint graph\n+   are zero weigh edges, and thus, using a vector of contrainst_edge_t\n+   is a waste of time and memory, since they have no weights.  We\n+   simply use a bitmap to store the preds and succs for each node.\n+   The weighted edges are stored as a set of adjacency vectors, one\n+   per variable. succs[x] is the vector of successors for variable x,\n+   and preds[x] is the vector of predecessors for variable x.  IOW,\n+   all edges are \"forward\" edges, which is not like our CFG.  So\n+   remember that preds[x]->src == x, and succs[x]->src == x.  */\n \n struct constraint_graph\n {\n+  bitmap *zero_weight_succs;\n+  bitmap *zero_weight_preds;\n   VEC(constraint_edge_t,heap) **succs;\n   VEC(constraint_edge_t,heap) **preds;\n };\n@@ -532,7 +538,6 @@ debug_constraints (void)\n    For each node that was already collapsed:\n        changed_count--;\n \n-\n    while (changed_count > 0)\n    {\n      compute topological ordering for constraint graph\n@@ -556,9 +561,7 @@ debug_constraints (void)\n static bool\n constraint_expr_equal (struct constraint_expr a, struct constraint_expr b)\n {\n-  return a.type == b.type\n-    && a.var == b.var\n-    && a.offset == b.offset;\n+  return a.type == b.type && a.var == b.var && a.offset == b.offset;\n }\n \n /* Return true if constraint expression A is less than constraint expression\n@@ -719,7 +722,7 @@ insert_into_complex (unsigned int var, constraint_t c)\n static bool\n constraint_edge_equal (struct constraint_edge a, struct constraint_edge b)\n {\n-  return a.src == b.src && a.dest == b.dest;\n+  return a.dest == b.dest;\n }\n \n /* Compare two constraint edges, return true if A is less than B */\n@@ -729,10 +732,7 @@ constraint_edge_less (const constraint_edge_t a, const constraint_edge_t b)\n {\n   if (a->dest < b->dest)\n     return true;\n-  else if (a->dest == b->dest)\n-    return a->src < b->src;\n-  else\n-    return false;\n+  return false;\n }\n \n /* Find the constraint edge that matches LOOKFOR, in VEC.\n@@ -743,10 +743,12 @@ constraint_edge_vec_find (VEC(constraint_edge_t,heap) *vec,\n \t\t\t  struct constraint_edge lookfor)\n {\n   unsigned int place;  \n-  constraint_edge_t edge;\n+  constraint_edge_t edge = NULL;\n \n   place = VEC_lower_bound (constraint_edge_t, vec, &lookfor, \n \t\t\t   constraint_edge_less);\n+  if (place >= VEC_length (constraint_edge_t, vec))\n+    return NULL;\n   edge = VEC_index (constraint_edge_t, vec, place);\n   if (!constraint_edge_equal (*edge, lookfor))\n     return NULL;\n@@ -791,16 +793,18 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n   srcvi->complex = NULL;\n }\n \n-/* Erase EDGE from GRAPH.  This routine only handles self-edges\n-   (e.g. an edge from a to a).  */\n+/* Erase an edge from SRC to SRC from GRAPH.  This routine only\n+   handles self-edges (e.g. an edge from a to a).  */\n \n static void\n-erase_graph_self_edge (constraint_graph_t graph, struct constraint_edge edge)\n+erase_graph_self_edge (constraint_graph_t graph, unsigned int src)\n {\n-  VEC(constraint_edge_t,heap) *predvec = graph->preds[edge.src];\n-  VEC(constraint_edge_t,heap) *succvec = graph->succs[edge.dest];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[src];\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[src];\n+  struct constraint_edge edge;\n   unsigned int place;\n-  gcc_assert (edge.src == edge.dest);\n+\n+  edge.dest = src;\n \n   /* Remove from the successors.  */\n   place = VEC_lower_bound (constraint_edge_t, succvec, &edge, \n@@ -836,34 +840,66 @@ clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n {\n   VEC(constraint_edge_t,heap) *succvec = graph->succs[node];\n   VEC(constraint_edge_t,heap) *predvec = graph->preds[node];\n-  constraint_edge_t c;\n+  bitmap_iterator bi;\n+  unsigned int j;\n+  constraint_edge_t c = NULL;\n   int i;\n-  \n+\n   /* Walk the successors, erase the associated preds.  */\n+  \n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[node], 0, j, bi)\n+    if (j != node)\n+      bitmap_clear_bit (graph->zero_weight_preds[j], node);\n+  \n   for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n     if (c->dest != node)\n       {\n \tunsigned int place;\n \tstruct constraint_edge lookfor;\n-\tlookfor.src = c->dest;\n+\tconstraint_edge_t result;\n+\n \tlookfor.dest = node;\n \tplace = VEC_lower_bound (constraint_edge_t, graph->preds[c->dest], \n \t\t\t\t &lookfor, constraint_edge_less);\n-\tVEC_ordered_remove (constraint_edge_t, graph->preds[c->dest], place);\n+\tresult = VEC_ordered_remove (constraint_edge_t, \n+\t\t\t\t     graph->preds[c->dest], place);\n+\tpool_free (constraint_edge_pool, result);\n       }\n+\n   /* Walk the preds, erase the associated succs.  */\n+\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[node], 0, j, bi)\n+    if (j != node)\n+      bitmap_clear_bit (graph->zero_weight_succs[j], node);\n+  \n   for (i =0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n     if (c->dest != node)\n       {\n \tunsigned int place;\n \tstruct constraint_edge lookfor;\n-\tlookfor.src = c->dest;\n+\tconstraint_edge_t result;\n+\n \tlookfor.dest = node;\n \tplace = VEC_lower_bound (constraint_edge_t, graph->succs[c->dest],\n \t\t\t\t &lookfor, constraint_edge_less);\n-\tVEC_ordered_remove (constraint_edge_t, graph->succs[c->dest], place);\n+\tresult = VEC_ordered_remove (constraint_edge_t, \n+\t\t\t\t     graph->succs[c->dest], place);\n+\tpool_free (constraint_edge_pool, result);\n+\n       }    \n-  \n+\n+  if (graph->zero_weight_preds[node])\n+    {\n+      BITMAP_FREE (graph->zero_weight_preds[node]);\n+      graph->zero_weight_preds[node] = NULL;\n+    } \n+\n+  if (graph->zero_weight_succs[node])\n+    {\n+      BITMAP_FREE (graph->zero_weight_succs[node]);\n+      graph->zero_weight_succs[node] = NULL;\n+    } \n+\n   VEC_free (constraint_edge_t, heap, graph->preds[node]);\n   VEC_free (constraint_edge_t, heap, graph->succs[node]);\n   graph->preds[node] = NULL;\n@@ -872,55 +908,89 @@ clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n \n static bool edge_added = false;\n   \n-/* Add edge NEWE to the graph.  */\n+/* Add edge (src, dest) to the graph.  */\n \n static bool\n-add_graph_edge (constraint_graph_t graph, struct constraint_edge newe)\n+add_graph_edge (constraint_graph_t graph, unsigned int src, unsigned int dest)\n {\n   unsigned int place;\n-  unsigned int src = newe.src;\n-  unsigned int dest = newe.dest;\n   VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge newe;\n+  newe.dest = dest;\n \n   vec = graph->preds[src];\n   place = VEC_lower_bound (constraint_edge_t, vec, &newe, \n \t\t\t   constraint_edge_less);\n   if (place == VEC_length (constraint_edge_t, vec)\n       || VEC_index (constraint_edge_t, vec, place)->dest != dest)\n     {\n-      constraint_edge_t edge = new_constraint_edge (src, dest);\n-      bitmap weightbitmap;\n+      constraint_edge_t edge = new_constraint_edge (dest);\n \n-      weightbitmap = BITMAP_ALLOC (&ptabitmap_obstack);\n-      edge->weights = weightbitmap;\n-      VEC_safe_insert (constraint_edge_t, heap, graph->preds[edge->src], \n+      VEC_safe_insert (constraint_edge_t, heap, graph->preds[src], \n \t\t       place, edge);\n-      edge = new_constraint_edge (dest, src);\n-      edge->weights = weightbitmap;\n-      place = VEC_lower_bound (constraint_edge_t, graph->succs[edge->src],\n+      edge = new_constraint_edge (src);\n+\n+      place = VEC_lower_bound (constraint_edge_t, graph->succs[dest],\n \t\t\t       edge, constraint_edge_less);\n-      VEC_safe_insert (constraint_edge_t, heap, graph->succs[edge->src], \n+      VEC_safe_insert (constraint_edge_t, heap, graph->succs[dest], \n \t\t       place, edge);\n       edge_added = true;\n+      stats.num_edges++;\n       return true;\n     }\n   else\n     return false;\n }\n \n \n-/* Return the bitmap representing the weights of edge LOOKFOR */\n+/* Return the bitmap representing the weights of edge (SRC, DEST).  */\n+\n+static bitmap *\n+get_graph_weights (constraint_graph_t graph, unsigned int src,\n+\t\t   unsigned int dest)\n+{\n+  constraint_edge_t edge;\n+  VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge lookfor;\n+\n+  lookfor.dest = dest;\n+\n+  vec = graph->preds[src];\n+  edge = constraint_edge_vec_find (vec, lookfor);\n+  gcc_assert (edge != NULL);\n+  return &edge->weights;\n+}\n+\n+/* Allocate graph weight bitmap for the edges associated with SRC and\n+   DEST in GRAPH.  Both the pred and the succ edges share a single\n+   bitmap, so we need to set both edges to that bitmap.  */\n \n static bitmap\n-get_graph_weights (constraint_graph_t graph, struct constraint_edge lookfor)\n+allocate_graph_weights (constraint_graph_t graph, unsigned int src, \n+\t\t\tunsigned int dest)\n {\n+  bitmap result;\n   constraint_edge_t edge;\n-  unsigned int src = lookfor.src;\n   VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge lookfor;\n+  \n+  result = BITMAP_ALLOC (&ptabitmap_obstack);\n+\n+  /* Set the pred weight.  */\n+  lookfor.dest = dest;\n   vec = graph->preds[src];\n   edge = constraint_edge_vec_find (vec, lookfor);\n   gcc_assert (edge != NULL);\n-  return edge->weights;\n+  edge->weights = result;\n+\n+  /* Set the succ weight.  */  \n+  lookfor.dest = src;\n+  vec = graph->succs[dest];\n+  edge = constraint_edge_vec_find (vec, lookfor);\n+  gcc_assert (edge != NULL);\n+  edge->weights = result;\n+  \n+  return result;  \n }\n \n \n@@ -934,48 +1004,85 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n   VEC(constraint_edge_t,heap) *predvec = graph->preds[from];\n   int i;\n   constraint_edge_t c;\n-  \n-  /* Merge all the predecessor edges.  */\n+  unsigned int j;\n+  bitmap_iterator bi;\n+\n+  /* Merge all the zero weighted predecessor edges.  */\n+  if (graph->zero_weight_preds[from])\n+    {\n+      if (!graph->zero_weight_preds[to])\n+\tgraph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+      \n+      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_preds[from], 0, j, bi)\n+\t{\n+\t  if (j != to)\n+\t    {\n+\t      bitmap_clear_bit (graph->zero_weight_succs[j], from);\n+\t      bitmap_set_bit (graph->zero_weight_succs[j], to);\n+\t    }\n+\t}\n+      bitmap_ior_into (graph->zero_weight_preds[to], \n+\t\t       graph->zero_weight_preds[from]);\n+    }\n \n+  /* Merge all the zero weighted successor edges.  */\n+  if (graph->zero_weight_succs[from])\n+    {\n+      if (!graph->zero_weight_succs[to])\n+\tgraph->zero_weight_succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n+      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_succs[from], 0, j, bi)\n+\t{\n+\t  bitmap_clear_bit (graph->zero_weight_preds[j], from);\n+\t  bitmap_set_bit (graph->zero_weight_preds[j], to);\n+\t}\n+      bitmap_ior_into (graph->zero_weight_succs[to], \n+\t\t       graph->zero_weight_succs[from]);\n+    }\n+\n+  /* Merge all the non-zero weighted predecessor edges.  */\n   for (i = 0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n     {\n       unsigned int d = c->dest;\n-      struct constraint_edge olde;\n-      struct constraint_edge newe;\n       bitmap temp;\n-      bitmap weights;\n+      bitmap *weights;\n+\n       if (c->dest == from)\n \td = to;\n-      newe.src = to;\n-      newe.dest = d;\n-      add_graph_edge (graph, newe);\n-      olde.src = from;\n-      olde.dest = c->dest;\n-      olde.weights = NULL;\n-      temp = get_graph_weights (graph, olde);\n-      weights = get_graph_weights (graph, newe);\n-      bitmap_ior_into (weights, temp);\n-    }\n-  \n-  /* Merge all the successor edges.  */\n+\n+      add_graph_edge (graph, to, d);\n+\n+      temp = *(get_graph_weights (graph, from, c->dest));      \n+      if (temp)\n+\t{\n+\t  weights = get_graph_weights (graph, to, d);\n+\t  if (!*weights)\n+\t    *weights = allocate_graph_weights (graph, to, d);\n+\t  \n+\t  bitmap_ior_into (*weights, temp);\n+\t}\n+      \n+    }\n+  \n+  /* Merge all the non-zero weighted successor edges.  */\n   for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n     {\n       unsigned int d = c->dest;\n-      struct constraint_edge olde;\n-      struct constraint_edge newe;\n       bitmap temp;\n-      bitmap weights;\n+      bitmap *weights;\n+\n       if (c->dest == from)\n \td = to;\n-      newe.src = d;\n-      newe.dest = to;\n-      add_graph_edge (graph, newe);\n-      olde.src = c->dest;\n-      olde.dest = from;\n-      olde.weights = NULL;\n-      temp = get_graph_weights (graph, olde);\n-      weights = get_graph_weights (graph, newe);\n-      bitmap_ior_into (weights, temp);\n+\n+      add_graph_edge (graph, d, to);\n+\n+      temp = *(get_graph_weights (graph, c->dest, from));\n+      if (temp)\n+\t{\n+\t  weights = get_graph_weights (graph, d, to);\n+\t  if (!*weights)\n+\t    *weights = allocate_graph_weights (graph, d, to);\n+\t  bitmap_ior_into (*weights, temp);\n+\t}\n     }\n   clear_edges_for_node (graph, from);\n }\n@@ -994,25 +1101,73 @@ int_add_graph_edge (constraint_graph_t graph, unsigned int to,\n     }\n   else\n     {\n-      bool r;\n-      struct constraint_edge edge;\n-      edge.src = to;\n-      edge.dest = from;\n-      edge.weights = NULL;\n-      r = add_graph_edge (graph, edge);\n-      r |= !bitmap_bit_p (get_graph_weights (graph, edge), weight);\n-      bitmap_set_bit (get_graph_weights (graph, edge), weight);\n+      bool r = false;\n+\n+      if (weight == 0)\n+\t{\n+          if (!graph->zero_weight_preds[to])\n+\t    graph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+          if (!graph->zero_weight_succs[from])\n+\t    graph->zero_weight_succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n+\t  if (!bitmap_bit_p (graph->zero_weight_succs[from], to))\n+\t    {\n+\t      edge_added = true;\n+\t      r = true;\n+\t      stats.num_edges++;\n+\t      bitmap_set_bit (graph->zero_weight_preds[to], from);\n+\t      bitmap_set_bit (graph->zero_weight_succs[from], to);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  bitmap *weights;\n+\n+\t  r = add_graph_edge (graph, to, from);\n+\t  weights = get_graph_weights (graph, to, from);\n+\n+\t  if (!*weights)\n+\t    {\n+\t      r = true;\n+\t      *weights = allocate_graph_weights (graph, to, from);\n+\t      bitmap_set_bit (*weights, weight);\n+\t    }\n+\t  else\n+\t    {\n+\t      r |= !bitmap_bit_p (*weights, weight);\n+\t      bitmap_set_bit (*weights, weight);\n+\t    }\n+\t}\n+      \n       return r;\n     }\n }\n \n \n-/* Return true if LOOKFOR is an existing graph edge.  */\n+/* Return true if {DEST.SRC} is an existing graph edge in GRAPH.  */\n \n static bool\n-valid_graph_edge (constraint_graph_t graph, struct constraint_edge lookfor)\n+valid_graph_edge (constraint_graph_t graph, unsigned int src, \n+\t\t  unsigned int dest)\n {\n-  return constraint_edge_vec_find (graph->preds[lookfor.src], lookfor) != NULL;\n+  struct constraint_edge lookfor;\n+  lookfor.dest = src;\n+  \n+  return (graph->zero_weight_succs[dest] \n+      && bitmap_bit_p (graph->zero_weight_succs[dest], src)) \n+    || constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n+}\n+\n+/* Return true if {DEST, SRC} is an existing weighted graph edge (IE has\n+   a weight other than 0) in GRAPH.  */\n+static bool\n+valid_weighted_graph_edge (constraint_graph_t graph, unsigned int src, \n+\t\t\t   unsigned int dest)\n+{\n+  struct constraint_edge lookfor;\n+  lookfor.dest = src;\n+  \n+  return graph->preds[src] \n+    && constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n }\n \n \n@@ -1025,10 +1180,14 @@ build_constraint_graph (void)\n   constraint_t c;\n \n   graph = xmalloc (sizeof (struct constraint_graph));\n-  graph->succs = xcalloc (VEC_length (varinfo_t, varmap),\n+  graph->succs = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n \t\t\t  sizeof (*graph->succs));\n-  graph->preds = xcalloc (VEC_length (varinfo_t, varmap),\n+  graph->preds = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n \t\t\t  sizeof (*graph->preds));\n+  graph->zero_weight_succs = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n+\t\t\t  sizeof (*graph->zero_weight_succs));\n+  graph->zero_weight_preds = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n+\t\t\t  sizeof (*graph->zero_weight_preds));\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -1060,14 +1219,8 @@ build_constraint_graph (void)\n \t     anything */\n \t  if (lhsvar != rhsvar || rhs.offset != 0 || lhs.offset != 0)\n \t    {\n-\t      \n-\t      struct constraint_edge edge;\n-\t      edge.src = lhsvar;\n-\t      edge.dest = rhsvar;\n \t      /* x = y (simple) */\n-\t      add_graph_edge (graph, edge);\n-\t      bitmap_set_bit (get_graph_weights (graph, edge),\n-\t\t\t      rhs.offset);\n+\t      int_add_graph_edge (graph, lhs.var, rhs.var, rhs.offset);\n \t    }\n \t  \n \t}\n@@ -1110,30 +1263,26 @@ struct scc_info\n static void\n scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n {\n-  constraint_edge_t c;\n-  int i;\n+  unsigned int i;\n+  bitmap_iterator bi;\n \n   gcc_assert (get_varinfo (n)->node == n);\n   SET_BIT (si->visited, n);\n   RESET_BIT (si->in_component, n);\n   si->visited_index[n] = si->current_index ++;\n   \n   /* Visit all the successors.  */\n-  for (i = 0; VEC_iterate (constraint_edge_t, graph->succs[n], i, c); i++)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[n], 0, i, bi)\n     {\n-      /* We only want to find and collapse the zero weight edges. */\n-      if (bitmap_bit_p (c->weights, 0))\n+      unsigned int w = i;\n+      if (!TEST_BIT (si->visited, w))\n+\tscc_visit (graph, si, w);\n+      if (!TEST_BIT (si->in_component, w))\n \t{\n-\t  unsigned int w = c->dest;\n-\t  if (!TEST_BIT (si->visited, w))\n-\t    scc_visit (graph, si, w);\n-\t  if (!TEST_BIT (si->in_component, w))\n-\t    {\n-\t      unsigned int t = get_varinfo (w)->node;\n-\t      unsigned int nnode = get_varinfo (n)->node;\n-\t      if (si->visited_index[t] < si->visited_index[nnode])\n-\t\tget_varinfo (n)->node = t;\n-\t    }\n+\t  unsigned int t = get_varinfo (w)->node;\n+\t  unsigned int nnode = get_varinfo (n)->node;\n+\t  if (si->visited_index[t] < si->visited_index[nnode])\n+\t    get_varinfo (n)->node = t;\n \t}\n     }\n   \n@@ -1163,25 +1312,28 @@ static void\n collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from)\n {\n   bitmap tosol, fromsol;\n-  struct constraint_edge edge;\n-\n \n   condense_varmap_nodes (to, from);\n   tosol = get_varinfo (to)->solution;\n   fromsol = get_varinfo (from)->solution;\n   bitmap_ior_into (tosol, fromsol);\n   merge_graph_nodes (graph, to, from);\n-  edge.src = to;\n-  edge.dest = to;\n-  edge.weights = NULL;\n-  if (valid_graph_edge (graph, edge))\n+\n+  if (valid_graph_edge (graph, to, to))\n     {\n-      bitmap weights = get_graph_weights (graph, edge);\n-      bitmap_clear_bit (weights, 0);\n-      if (bitmap_empty_p (weights))\n-\terase_graph_self_edge (graph, edge);\n+      if (graph->zero_weight_preds[to])\n+\t{\n+\t  bitmap_clear_bit (graph->zero_weight_preds[to], to);\n+\t  bitmap_clear_bit (graph->zero_weight_succs[to], to);\n+\t}\n+      if (valid_weighted_graph_edge (graph, to, to))\n+\t{\n+\t  bitmap weights = *(get_graph_weights (graph, to, to));\n+\t  if (!weights || bitmap_empty_p (weights))\n+\t    erase_graph_self_edge (graph, to);\n+\t}\n     }\n-  bitmap_clear (fromsol);\n+  BITMAP_FREE (fromsol);\n   get_varinfo (to)->address_taken |= get_varinfo (from)->address_taken;\n   get_varinfo (to)->indirect_target |= get_varinfo (from)->indirect_target;\n }\n@@ -1262,8 +1414,6 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n       if (i == VEC_length (unsigned, si->unification_queue)\n \t  || get_varinfo (VEC_index (unsigned, si->unification_queue, i))->node != n)\n \t{\n-\t  struct constraint_edge edge;\n-\n \t  /* If the solution changes because of the merging, we need to mark\n \t     the variable as changed.  */\n \t  if (bitmap_ior_into (get_varinfo (n)->solution, tmp))\n@@ -1275,15 +1425,21 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \t\t}\n \t    }\n \t  bitmap_clear (tmp);\n-\t  edge.src = n;\n-\t  edge.dest = n;\n-\t  edge.weights = NULL;\n-\t  if (valid_graph_edge (graph, edge))\n+\n+\t  if (valid_graph_edge (graph, n, n))\n \t    {\n-\t      bitmap weights = get_graph_weights (graph, edge);\n-\t      bitmap_clear_bit (weights, 0);\n-\t      if (bitmap_empty_p (weights))\n-\t\terase_graph_self_edge (graph, edge);\n+\t      if (graph->zero_weight_succs[n])\n+\t\t{\n+\t\t  if (graph->zero_weight_preds[n])\n+\t\t    bitmap_clear_bit (graph->zero_weight_preds[n], n);\n+\t\t  bitmap_clear_bit (graph->zero_weight_succs[n], n);\n+\t\t}\n+\t      if (valid_weighted_graph_edge (graph, n, n))\n+\t\t{\n+\t\t  bitmap weights = *(get_graph_weights (graph, n, n));\n+\t\t  if (!weights || bitmap_empty_p (weights))\n+\t\t    erase_graph_self_edge (graph, n);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1335,14 +1491,30 @@ topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \t    unsigned int n)\n {\n   VEC(constraint_edge_t,heap) *succs = graph->succs[n];\n+  bitmap temp;\n+  bitmap_iterator bi;\n   constraint_edge_t c;\n   int i;\n+  unsigned int j;\n+\n   SET_BIT (ti->visited, n);\n-  for (i = 0; VEC_iterate (constraint_edge_t, succs, i, c); i++)\n+  if (VEC_length (constraint_edge_t, succs) != 0)\n     {\n-      if (!TEST_BIT (ti->visited, c->dest))\n-\ttopo_visit (graph, ti, c->dest);\n+      temp = BITMAP_ALLOC (&iteration_obstack);\n+      if (graph->zero_weight_succs[n])\n+\tbitmap_ior_into (temp, graph->zero_weight_succs[n]);\n+      for (i = 0; VEC_iterate (constraint_edge_t, succs, i, c); i++)\n+\tbitmap_set_bit (temp, c->dest);\n     }\n+  else \n+    temp = graph->zero_weight_succs[n];\n+\n+  if (temp) \n+    EXECUTE_IF_SET_IN_BITMAP (temp, 0, j, bi)\n+      {\n+\tif (!TEST_BIT (ti->visited, j))\n+\t  topo_visit (graph, ti, j);\n+      }\n   VEC_safe_push (unsigned, heap, ti->topo_order, n);\n }\n \n@@ -1366,6 +1538,8 @@ type_safe (unsigned int n, unsigned HOST_WIDE_INT *offset)\n   return (get_varinfo (n)->offset + *offset) < get_varinfo (n)->fullsize;\n }\n \n+#define DONT_PROPAGATE_WITH_ANYTHING 0\n+\n /* Process a constraint C that represents *x = &y.  */\n \n static void\n@@ -1403,7 +1577,7 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t\t}\n \t    }\n \t}\n-      else if (dump_file && !(get_varinfo (j)->is_special_var))\n+      else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_da_constraint.\\n\");\n       \n     }\n@@ -1421,7 +1595,16 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n   bitmap sol = get_varinfo (lhs)->solution;\n   unsigned int j;\n   bitmap_iterator bi;\n-  \n+\n+#if DONT_PROPAGATE_WITH_ANYTHING \n+ if (bitmap_bit_p (delta, anything_id))\n+   {\n+     flag = !bitmap_bit_p (sol, anything_id);\n+     if (flag)\n+       bitmap_set_bit (sol, anything_id);\n+     goto done;\n+   }\n+#endif\n   /* For each variable j in delta (Sol(y)), add    \n      an edge in the graph from j to x, and union Sol(j) into Sol(x).  */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n@@ -1433,18 +1616,25 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + roffset;\n \t  unsigned int t;\n \n-\t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\t  \n+\t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n \t  t = v->node;\n-\t  if (int_add_graph_edge (graph, lhs, t, 0))\n-\t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\t  \n+\n+\t  /* Adding edges from the special vars is pointless.\n+\t     They don't have sets that can change.  */\n+\t  if (get_varinfo (t) ->is_special_var)\n+\t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n+\t  else if (int_add_graph_edge (graph, lhs, t, 0))\n+\t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t}\n-      else if (dump_file && !(get_varinfo (j)->is_special_var))\n+      else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_sd_constraint\\n\");\n       \n     }\n-\n+#if DONT_PROPAGATE_WITH_ANYTHING\n+done:\n+#endif\n   /* If the LHS solution changed, mark the var as changed.  */\n   if (flag)\n     {\n@@ -1468,6 +1658,36 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n   unsigned int j;\n   bitmap_iterator bi;\n \n+#if DONT_PROPAGATE_WITH_ANYTHING \n+ if (bitmap_bit_p (sol, anything_id))\n+   {\n+     EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n+       {\n+\t varinfo_t jvi = get_varinfo (j);\n+\t unsigned int t;\n+\t unsigned int loff = c->lhs.offset;\n+\t unsigned HOST_WIDE_INT fieldoffset = jvi->offset + loff;\n+\t varinfo_t v;\n+\n+\t v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n+\t if (!v)\n+\t   continue;\n+\t t = v->node;\n+\t \n+\t if (!bitmap_bit_p (get_varinfo (t)->solution, anything_id))\n+\t   {\n+\t     bitmap_set_bit (get_varinfo (t)->solution, anything_id);\n+\t     if (!TEST_BIT (changed, t))\n+\t       {\n+\t\t SET_BIT (changed, t);\n+\t\t changed_count++;\n+\t       }\n+\t   }\n+       }\n+     return;\n+   }\n+#endif\n+\n   /* For each member j of delta (Sol(x)), add an edge from y to j and\n      union Sol(y) into Sol(j) */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n@@ -1490,9 +1710,7 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n \t\t{\n \t\t  get_varinfo (t)->solution = tmp;\n \t\t  if (t == rhs)\n-\t\t    {\n-\t\t      sol = get_varinfo (rhs)->solution;\n-\t\t    }\n+\t\t    sol = get_varinfo (rhs)->solution;\n \t\t  if (!TEST_BIT (changed, t))\n \t\t    {\n \t\t      SET_BIT (changed, t);\n@@ -1501,7 +1719,7 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n \t\t}\n \t    }\n \t}    \n-      else if (dump_file && !(get_varinfo (j)->is_special_var))\n+      else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_ds_constraint\\n\");\n     }\n }\n@@ -1581,6 +1799,7 @@ find_and_collapse_graph_cycles (constraint_graph_t graph, bool update_changed)\n   for (i = 0; i != size; ++i)\n     if (!TEST_BIT (si->visited, i) && get_varinfo (i)->node == i)\n       scc_visit (graph, si, i);\n+  \n   process_unification_queue (graph, si, update_changed);\n   free_scc_info (si);\n }\n@@ -1630,6 +1849,7 @@ perform_var_substitution (constraint_graph_t graph)\n {\n   struct topo_info *ti = init_topo_info ();\n  \n+  bitmap_obstack_initialize (&iteration_obstack);\n   /* Compute the topological ordering of the graph, then visit each\n      node in topological order.  */\n   compute_topo_order (graph, ti);\n@@ -1642,60 +1862,101 @@ perform_var_substitution (constraint_graph_t graph)\n       bool okay_to_elim = false;\n       unsigned int root = VEC_length (varinfo_t, varmap);\n       VEC(constraint_edge_t,heap) *predvec = graph->preds[i];\n-      constraint_edge_t ce;\n+      constraint_edge_t ce = NULL;\n       bitmap tmp;\n+      unsigned int k;\n+      bitmap_iterator bi;\n \n       /* We can't eliminate things whose address is taken, or which is\n \t the target of a dereference.  */\n       if (vi->address_taken || vi->indirect_target)\n \tcontinue;\n \n       /* See if all predecessors of I are ripe for elimination */\n-      for (pred = 0; VEC_iterate (constraint_edge_t, predvec, pred, ce); pred++)\n-\t{\n-\t  bitmap weight;\n-\t  unsigned int w;\n-\t  weight = get_graph_weights (graph, *ce);\n-\t\n-\t  /* We can't eliminate variables that have nonzero weighted\n-\t     edges between them.  */\n-\t  if (bitmap_other_than_zero_bit_set (weight))\n-\t    {\n-\t      okay_to_elim = false;\n-\t      break;\n-\t    }\n-\t  w = get_varinfo (ce->dest)->node;\n+      EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[i], 0, k, bi)\n+\t  {\n+\t    unsigned int w;\n+\t    w = get_varinfo (k)->node;\n \n-\t  /* We can't eliminate the node if one of the predecessors is\n-\t     part of a different strongly connected component.  */\n-\t  if (!okay_to_elim)\n-\t    {\n-\t      root = w;\n-\t      okay_to_elim = true;\n-\t    }\n-\t  else if (w != root)\n-\t    {\n-\t      okay_to_elim = false;\n-\t      break;\n-\t    }\n+\t    /* We can't eliminate the node if one of the predecessors is\n+\t       part of a different strongly connected component.  */\n+\t    if (!okay_to_elim)\n+\t      {\n+\t\troot = w;\n+\t\tokay_to_elim = true;\n+\t      }\n+\t    else if (w != root)\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tbreak;\n+\t      }\n \n-\t  /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n-\t     then Solution(i) is a subset of Solution (w), where w is a\n-\t     predecessor in the graph.  \n-\t     Corollary: If all predecessors of i have the same\n-\t     points-to set, then i has that same points-to set as\n-\t     those predecessors.  */\n-\t  tmp = BITMAP_ALLOC (NULL);\n-\t  bitmap_and_compl (tmp, get_varinfo (i)->solution,\n-\t\t\t    get_varinfo (w)->solution);\n-\t  if (!bitmap_empty_p (tmp))\n-\t    {\n-\t      okay_to_elim = false;\n-\t      BITMAP_FREE (tmp);\n-\t      break;\n-\t    }\n-\t  BITMAP_FREE (tmp);\n-\t}\n+\t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n+\t       then Solution(i) is a subset of Solution (w), where w is a\n+\t       predecessor in the graph.  \n+\t       Corollary: If all predecessors of i have the same\n+\t       points-to set, then i has that same points-to set as\n+\t       those predecessors.  */\n+\t    tmp = BITMAP_ALLOC (NULL);\n+\t    bitmap_and_compl (tmp, get_varinfo (i)->solution,\n+\t\t\t      get_varinfo (w)->solution);\n+\t    if (!bitmap_empty_p (tmp))\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tBITMAP_FREE (tmp);\n+\t\tbreak;\n+\t      }\n+\t    BITMAP_FREE (tmp);\n+\t  }\n+\n+      if (okay_to_elim)\n+\tfor (pred = 0; \n+\t     VEC_iterate (constraint_edge_t, predvec, pred, ce); \n+\t     pred++)\n+\t  {\n+\t    bitmap weight;\n+\t    unsigned int w;\n+\t    weight = *(get_graph_weights (graph, i, ce->dest));\n+\n+\t    /* We can't eliminate variables that have nonzero weighted\n+\t       edges between them.  */\n+\t    if (weight && bitmap_other_than_zero_bit_set (weight))\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tbreak;\n+\t      }\n+\t    w = get_varinfo (ce->dest)->node;\n+\n+\t    /* We can't eliminate the node if one of the predecessors is\n+\t       part of a different strongly connected component.  */\n+\t    if (!okay_to_elim)\n+\t      {\n+\t\troot = w;\n+\t\tokay_to_elim = true;\n+\t      }\n+\t    else if (w != root)\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tbreak;\n+\t      }\n+\n+\t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n+\t       then Solution(i) is a subset of Solution (w), where w is a\n+\t       predecessor in the graph.  \n+\t       Corollary: If all predecessors of i have the same\n+\t       points-to set, then i has that same points-to set as\n+\t       those predecessors.  */\n+\t    tmp = BITMAP_ALLOC (NULL);\n+\t    bitmap_and_compl (tmp, get_varinfo (i)->solution,\n+\t\t\t      get_varinfo (w)->solution);\n+\t    if (!bitmap_empty_p (tmp))\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tBITMAP_FREE (tmp);\n+\t\tbreak;\n+\t      }\n+\t    BITMAP_FREE (tmp);\n+\t  }\n \n       /* See if the root is different than the original node. \n \t If so, we've found an equivalence.  */\n@@ -1712,10 +1973,10 @@ perform_var_substitution (constraint_graph_t graph)\n \t}\n     }\n \n+  bitmap_obstack_release (&iteration_obstack);\n   free_topo_info (ti);\n }\n \n-\n /* Solve the constraint graph GRAPH using our worklist solver.\n    This is based on the PW* family of solvers from the \"Efficient Field\n    Sensitive Pointer Analysis for C\" paper.\n@@ -1744,7 +2005,7 @@ solve_graph (constraint_graph_t graph)\n       unsigned int i;\n       struct topo_info *ti = init_topo_info ();\n       stats.iterations++;\n-      \n+\n       bitmap_obstack_initialize (&iteration_obstack);\n       \n       if (edge_added)\n@@ -1754,7 +2015,7 @@ solve_graph (constraint_graph_t graph)\n \t     first iteration.  */\n \t  if (stats.iterations > 1)\n \t    find_and_collapse_graph_cycles (graph, true);\n-\t  \n+\n \t  edge_added = false;\n \t}\n \n@@ -1771,8 +2032,9 @@ solve_graph (constraint_graph_t graph)\n \t    {\n \t      unsigned int j;\n \t      constraint_t c;\n-\t      constraint_edge_t e;\n+\t      constraint_edge_t e = NULL;\n \t      bitmap solution;\n+\t      bitmap_iterator bi;\n \t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n \t      VEC(constraint_edge_t,heap) *succs;\n \n@@ -1786,6 +2048,24 @@ solve_graph (constraint_graph_t graph)\n \n \t      /* Propagate solution to all successors.  */\n \t      succs = graph->succs[i];\n+\t      \n+\t      EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[i], 0, j, bi)\n+\t\t{\n+\t\t  bitmap tmp = get_varinfo (j)->solution;\n+\t\t  bool flag = false;\n+\t\t  \n+\t\t  flag = set_union_with_increment (tmp, solution, 0);\n+\t\t  \n+\t\t  if (flag)\n+\t\t    {\n+\t\t      get_varinfo (j)->solution = tmp;\n+\t\t      if (!TEST_BIT (changed, j))\n+\t\t\t{\n+\t\t\t  SET_BIT (changed, j);\n+\t\t\t  changed_count++;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t      for (j = 0; VEC_iterate (constraint_edge_t, succs, j, e); j++)\n \t\t{\n \t\t  bitmap tmp = get_varinfo (e->dest)->solution;\n@@ -1794,13 +2074,13 @@ solve_graph (constraint_graph_t graph)\n \t\t  bitmap weights = e->weights;\n \t\t  bitmap_iterator bi;\n \n-\t\t  gcc_assert (!bitmap_empty_p (weights));\n+\t\t  gcc_assert (weights && !bitmap_empty_p (weights));\n \t\t  EXECUTE_IF_SET_IN_BITMAP (weights, 0, k, bi)\n \t\t    flag |= set_union_with_increment (tmp, solution, k);\n \n \t\t  if (flag)\n \t\t    {\n-\t\t      get_varinfo (e->dest)->solution = tmp;\t\t    \n+\t\t      get_varinfo (e->dest)->solution = tmp;\n \t\t      if (!TEST_BIT (changed, e->dest))\n \t\t\t{\n \t\t\t  SET_BIT (changed, e->dest);\n@@ -2062,98 +2342,102 @@ offset_overlaps_with_access (const unsigned HOST_WIDE_INT fieldpos,\n \n /* Given a COMPONENT_REF T, return the constraint_expr for it.  */\n \n-static struct constraint_expr\n-get_constraint_for_component_ref (tree t, bool *need_anyoffset)\n+static void\n+get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results, \n+\t\t\t\t  bool *anyoffset)\n {\n-  struct constraint_expr result;\n+  tree orig_t = t;\n   HOST_WIDE_INT bitsize = -1;\n   HOST_WIDE_INT bitpos;\n   tree offset = NULL_TREE;\n   enum machine_mode mode;\n   int unsignedp;\n   int volatilep;\n   tree forzero;\n-  \n-  result.offset = 0;\n-  result.type = SCALAR;\n-  result.var = 0;\n+  struct constraint_expr *result;\n+  unsigned int beforelength = VEC_length (ce_s, *results);\n \n   /* Some people like to do cute things like take the address of\n      &0->a.b */\n   forzero = t;\n   while (!SSA_VAR_P (forzero) && !CONSTANT_CLASS_P (forzero))\n-      forzero = TREE_OPERAND (forzero, 0);\n+    forzero = TREE_OPERAND (forzero, 0);\n \n   if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero)) \n     {\n-      result.offset = 0;\n-      result.var = integer_id;\n-      result.type = SCALAR;\n-      return result;\n+      struct constraint_expr temp;\n+      \n+      temp.offset = 0;\n+      temp.var = integer_id;\n+      temp.type = SCALAR;\n+      VEC_safe_push (ce_s, heap, *results, &temp);\n+      return;\n     }\n  \n   t = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n \t\t\t   &unsignedp, &volatilep, false);\n-  result = get_constraint_for (t, need_anyoffset);\n+  get_constraint_for (t, results, anyoffset);\n+  result = VEC_last (ce_s, *results);\n+\n+  gcc_assert (beforelength + 1 == VEC_length (ce_s, *results));\n \n   /* This can also happen due to weird offsetof type macros.  */\n-  if (TREE_CODE (t) != ADDR_EXPR && result.type == ADDRESSOF)\n-    result.type = SCALAR;\n+  if (TREE_CODE (t) != ADDR_EXPR && result->type == ADDRESSOF)\n+    result->type = SCALAR;\n   \n   /* If we know where this goes, then yay. Otherwise, booo. */\n \n   if (offset == NULL && bitsize != -1)\n     {\n-      result.offset = bitpos;\n+      result->offset = bitpos;\n     }\t\n-  else if (need_anyoffset)\n+  /* FIXME: Handle the DEREF case.  */\n+  else if (anyoffset && result->type != DEREF)\n     {\n-      result.offset = 0;\n-      *need_anyoffset = true; \n+      result->offset = 0;\n+      *anyoffset = true;\n     }\n   else\n     {\n-      result.var = anything_id;\n-      result.offset = 0;      \n+      result->var = anything_id;\n+      result->offset = 0;      \n     }\n \n-  if (result.type == SCALAR)\n+  if (result->type == SCALAR)\n     {\n       /* In languages like C, you can access one past the end of an\n \t array.  You aren't allowed to dereference it, so we can\n \t ignore this constraint. When we handle pointer subtraction,\n \t we may have to do something cute here.  */\n       \n-      if (result.offset < get_varinfo (result.var)->fullsize)\t\n+      if (result->offset < get_varinfo (result->var)->fullsize)\n \t{\n \t  /* It's also not true that the constraint will actually start at the\n \t     right offset, it may start in some padding.  We only care about\n \t     setting the constraint to the first actual field it touches, so\n \t     walk to find it.  */ \n \t  varinfo_t curr;\n-\t  for (curr = get_varinfo (result.var); curr; curr = curr->next)\n+\t  for (curr = get_varinfo (result->var); curr; curr = curr->next)\n \t    {\n \t      if (offset_overlaps_with_access (curr->offset, curr->size,\n-\t\t\t\t\t       result.offset, bitsize))\n+\t\t\t\t\t       result->offset, bitsize))\n \t\t{\n-\t\t  result.var = curr->id;\n+\t\t  result->var = curr->id;\n \t\t  break;\n-\n \t\t}\n \t    }\n \t  /* assert that we found *some* field there. The user couldn't be\n \t     accessing *only* padding.  */\n-\t     \n-\t  gcc_assert (curr);\n+\t  /* Still the user could access one past the end of an array\n+\t     embedded in a struct resulting in accessing *only* padding.  */\n+\t  gcc_assert (curr || ref_contains_array_ref (orig_t));\n \t}\n       else\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  fprintf (dump_file, \"Access to past the end of variable, ignoring\\n\");\n \n-      result.offset = 0;\n+      result->offset = 0;\n     }\n-  \n-  return result;\n }\n \n \n@@ -2163,35 +2447,34 @@ get_constraint_for_component_ref (tree t, bool *need_anyoffset)\n    DEREF (DEREF) = (temp = DEREF1; result = DEREF(temp))\n    This is needed so that we can handle dereferencing DEREF constraints.  */\n \n-static struct constraint_expr\n-do_deref (struct constraint_expr cons)\n+static void\n+do_deref (VEC (ce_s, heap) **constraints)\n {\n-  if (cons.type == SCALAR)\n-    {\n-      cons.type = DEREF;\n-      return cons;\n-    }\n-  else if (cons.type == ADDRESSOF)\n-    {\n-      cons.type = SCALAR;\n-      return cons;\n-    }\n-  else if (cons.type == DEREF)\n+  struct constraint_expr *c;\n+  unsigned int i = 0;\n+  for (i = 0; VEC_iterate (ce_s, *constraints, i, c); i++)\n     {\n-      tree tmpvar = create_tmp_var_raw (ptr_type_node, \"derefmp\");\n-      struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n-      process_constraint (new_constraint (tmplhs, cons));\n-      cons.var = tmplhs.var;\n-      return cons;\n+      if (c->type == SCALAR)\n+\tc->type = DEREF;\n+      else if (c->type == ADDRESSOF)\n+\tc->type = SCALAR;\n+      else if (c->type == DEREF)\n+\t{\n+\t  tree tmpvar = create_tmp_var_raw (ptr_type_node, \"dereftmp\");\n+\t  struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n+\t  process_constraint (new_constraint (tmplhs, *c));\n+\t  c->var = tmplhs.var;\n+\t}\n+      else\n+\tgcc_unreachable ();\n     }\n-  gcc_unreachable ();\n }\n \n \n /* Given a tree T, return the constraint expression for it.  */\n \n-static struct constraint_expr\n-get_constraint_for (tree t, bool *need_anyoffset)\n+static void\n+get_constraint_for (tree t, VEC (ce_s, heap) **results, bool *anyoffset)\n {\n   struct constraint_expr temp;\n \n@@ -2209,15 +2492,17 @@ get_constraint_for (tree t, bool *need_anyoffset)\n       temp.var = integer_id;\n       temp.type = SCALAR;\n       temp.offset = 0;\n-      return temp;\n+      VEC_safe_push (ce_s, heap, *results, &temp);\n+      return;\n     }\n   else if (TREE_CODE (t) == INTEGER_CST\n \t   && integer_zerop (t))\n     {\n       temp.var = nothing_id;\n       temp.type = ADDRESSOF;\n       temp.offset = 0;\n-      return temp;\n+      VEC_safe_push (ce_s, heap, *results, &temp);\n+      return;\n     }\n \n   switch (TREE_CODE_CLASS (TREE_CODE (t)))\n@@ -2228,12 +2513,18 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \t  {\n \t  case ADDR_EXPR:\n \t    {\n-\t      temp = get_constraint_for (TREE_OPERAND (t, 0), need_anyoffset);\n-\t       if (temp.type == DEREF)\n-\t\t temp.type = SCALAR;\n-\t       else\n-\t\t temp.type = ADDRESSOF;\n-\t      return temp;\n+\t      struct constraint_expr *c;\n+\t      unsigned int i;\n+\n+\t      get_constraint_for (TREE_OPERAND (t, 0), results, anyoffset);\n+\t      for (i = 0; VEC_iterate (ce_s, *results, i, c); i++)\n+\t\t{\n+\t\t  if (c->type == DEREF)\n+\t\t    c->type = SCALAR;\n+\t\t  else \n+\t\t    c->type = ADDRESSOF;\n+\t\t}\n+\t      return;\n \t    }\n \t    break;\n \t  case CALL_EXPR:\n@@ -2262,15 +2553,17 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \t\tvi->is_heap_var = 1;\n \t\ttemp.type = ADDRESSOF;\n \t\ttemp.offset = 0;\n-\t\treturn temp;\n+\t\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\t\treturn;\n \t      }\n \t    /* FALLTHRU */\n \t  default:\n \t    {\n \t      temp.type = ADDRESSOF;\n \t      temp.var = anything_id;\n \t      temp.offset = 0;\n-\t      return temp;\n+\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      return;\n \t    }\n \t  }\n       }\n@@ -2280,21 +2573,22 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \t  {\n \t  case INDIRECT_REF:\n \t    {\n-\t      temp = get_constraint_for (TREE_OPERAND (t, 0), need_anyoffset);\n-\t      temp = do_deref (temp);\n-\t      return temp;\n+\t      get_constraint_for (TREE_OPERAND (t, 0), results, anyoffset);\n+\t      do_deref (results);\n+\t      return;\n \t    }\n \t  case ARRAY_REF:\n \t  case ARRAY_RANGE_REF:\n \t  case COMPONENT_REF:\n-\t    temp = get_constraint_for_component_ref (t, need_anyoffset);\n-\t    return temp;\n+\t    get_constraint_for_component_ref (t, results, anyoffset);\n+\t    return;\n \t  default:\n \t    {\n \t      temp.type = ADDRESSOF;\n \t      temp.var = anything_id;\n \t      temp.offset = 0;\n-\t      return temp;\n+\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      return;\n \t    }\n \t  }\n       }\n@@ -2312,7 +2606,10 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \t\t Anything else, we see through */\n \t      if (!(POINTER_TYPE_P (TREE_TYPE (t))\n \t\t    && ! POINTER_TYPE_P (TREE_TYPE (op))))\n-\t\treturn get_constraint_for (op, need_anyoffset);\n+\t\t{\n+\t\t  get_constraint_for (op, results, anyoffset);\n+\t\t  return;\n+\t\t}\n \n \t      /* FALLTHRU  */\n \t    }\n@@ -2321,7 +2618,8 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \t      temp.type = ADDRESSOF;\n \t      temp.var = anything_id;\n \t      temp.offset = 0;\n-\t      return temp;\n+\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      return;\n \t    }\n \t  }\n       }\n@@ -2330,26 +2628,43 @@ get_constraint_for (tree t, bool *need_anyoffset)\n \tswitch (TREE_CODE (t))\n \t  {\n \t  case PHI_NODE:\t   \n-\t    return get_constraint_for (PHI_RESULT (t), need_anyoffset);\n+\t    {\n+\t      get_constraint_for (PHI_RESULT (t), results, anyoffset);\n+\t      return;\n+\t    }\n+\t    break;\n \t  case SSA_NAME:\n-\t    return get_constraint_exp_from_ssa_var (t);\n+\t    {\n+\t      struct constraint_expr temp;\n+\t      temp = get_constraint_exp_from_ssa_var (t);\n+\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      return;\n+\t    }\n+\t    break;\n \t  default:\n \t    {\n \t      temp.type = ADDRESSOF;\n \t      temp.var = anything_id;\n \t      temp.offset = 0;\n-\t      return temp;\n+\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      return;\n \t    }\n \t  }\n       }\n     case tcc_declaration:\n-      return get_constraint_exp_from_ssa_var (t);\n+      {\n+\tstruct constraint_expr temp;\n+\ttemp = get_constraint_exp_from_ssa_var (t);\n+\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\treturn;\n+      }\n     default:\n       {\n \ttemp.type = ADDRESSOF;\n \ttemp.var = anything_id;\n \ttemp.offset = 0;\n-\treturn temp;\n+\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\treturn;\n       }\n     }\n }\n@@ -2507,13 +2822,21 @@ static void\n do_structure_copy (tree lhsop, tree rhsop)\n {\n   struct constraint_expr lhs, rhs, tmp;\n+  VEC (ce_s, heap) *lhsc = NULL, *rhsc = NULL;\n   varinfo_t p;\n   unsigned HOST_WIDE_INT lhssize;\n   unsigned HOST_WIDE_INT rhssize;\n \n-  lhs = get_constraint_for (lhsop, NULL);  \n-  rhs = get_constraint_for (rhsop, NULL);\n+  get_constraint_for (lhsop, &lhsc, NULL);\n+  get_constraint_for (rhsop, &rhsc, NULL);\n+  gcc_assert (VEC_length (ce_s, lhsc) == 1);\n+  gcc_assert (VEC_length (ce_s, rhsc) == 1);\n+  lhs = *(VEC_last (ce_s, lhsc));\n+  rhs = *(VEC_last (ce_s, rhsc));\n   \n+  VEC_free (ce_s, heap, lhsc);\n+  VEC_free (ce_s, heap, rhsc);\n+\n   /* If we have special var = x, swap it around.  */\n   if (lhs.var <= integer_id && !(get_varinfo (rhs.var)->is_special_var))\n     {\n@@ -2540,6 +2863,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n \t{\n \t  struct constraint_expr templhs = lhs;\n \t  struct constraint_expr temprhs = rhs;\n+\n \t  if (templhs.type == SCALAR )\n \t    templhs.var = p->id;\n \t  else\n@@ -2551,8 +2875,11 @@ do_structure_copy (tree lhsop, tree rhsop)\n     {\n       tree rhstype = TREE_TYPE (rhsop);\n       tree lhstype = TREE_TYPE (lhsop);\n-      tree rhstypesize = TYPE_SIZE (rhstype);\n-      tree lhstypesize = TYPE_SIZE (lhstype);\n+      tree rhstypesize;\n+      tree lhstypesize;\n+\n+      lhstypesize = DECL_P (lhsop) ? DECL_SIZE (lhsop) : TYPE_SIZE (lhstype);\n+      rhstypesize = DECL_P (rhsop) ? DECL_SIZE (rhsop) : TYPE_SIZE (rhstype);\n \n       /* If we have a variably sized types on the rhs or lhs, and a deref\n \t constraint, add the constraint, lhsconstraint = &ANYTHING.\n@@ -2831,25 +3158,47 @@ update_alias_info (tree stmt, struct alias_info *ai)\n    separate constraint by the caller.  */\n \n static bool\n-handle_ptr_arith (struct constraint_expr lhs, tree expr)\n+handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n {\n   tree op0, op1;\n-  struct constraint_expr base, offset;\n+  struct constraint_expr *c, *c2;\n+  unsigned int i = 0;\n+  unsigned int j = 0;\n+  VEC (ce_s, heap) *temp = NULL;\n+  unsigned int rhsoffset = 0;\n \n   if (TREE_CODE (expr) != PLUS_EXPR)\n     return false;\n \n   op0 = TREE_OPERAND (expr, 0);\n   op1 = TREE_OPERAND (expr, 1);\n \n-  base = get_constraint_for (op0, NULL);\n+  get_constraint_for (op0, &temp, NULL);\n+  if (POINTER_TYPE_P (TREE_TYPE (op0))\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) == RECORD_TYPE\n+      && TREE_CODE (op1) == INTEGER_CST)\n+    {\n+      rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n+    }\n+  \n \n-  offset.var = anyoffset_id;\n-  offset.type = ADDRESSOF;\n-  offset.offset = 0;\n+  for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n+    for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)\n+      {\n+\tif (c2->type == ADDRESSOF && rhsoffset != 0)\n+\t  {\n+\t    varinfo_t temp = get_varinfo (c2->var);\n+\t    \n+\t    gcc_assert (first_vi_for_offset (temp, rhsoffset) != NULL);\n+\t    c2->var = first_vi_for_offset (temp, rhsoffset)->id;\n+\t    c2->offset = 0;\n+\t  }\n+\telse\n+\t  c2->offset = rhsoffset;\n+\tprocess_constraint (new_constraint (*c, *c2));\n+      }\n \n-  process_constraint (new_constraint (lhs, base));\n-  process_constraint (new_constraint (lhs, offset));\n+  VEC_free (ce_s, heap, temp);\n \n   return true;\n }\n@@ -2861,14 +3210,15 @@ handle_ptr_arith (struct constraint_expr lhs, tree expr)\n    when building alias sets and computing alias grouping heuristics.  */\n \n static void\n-find_func_aliases (tree t, struct alias_info *ai)\n+find_func_aliases (tree origt)\n {\n-  struct constraint_expr lhs, rhs;\n+  tree t = origt;\n+  VEC(ce_s, heap) *lhsc = NULL;\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  struct constraint_expr *c;\n \n-  /* Update various related attributes like escaped addresses, pointer\n-     dereferences for loads and stores.  This is used when creating\n-     name tags and alias sets.  */\n-  update_alias_info (t, ai);\n+  if (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0))\n+    t = TREE_OPERAND (t, 0);\n \n   /* Now build constraints expressions.  */\n   if (TREE_CODE (t) == PHI_NODE)\n@@ -2879,20 +3229,137 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t  || AGGREGATE_TYPE_P (TREE_TYPE (PHI_RESULT (t))))\n \t{\n \t  int i;\n-\n-\t  lhs = get_constraint_for (PHI_RESULT (t), NULL);\n+\t  unsigned int j;\n+\t  \n+\t  /* For a phi node, assign all the arguments to\n+\t     the result.  */\n+\t  get_constraint_for (PHI_RESULT (t), &lhsc, NULL);\n \t  for (i = 0; i < PHI_NUM_ARGS (t); i++)\n+\t    { \n+\t      get_constraint_for (PHI_ARG_DEF (t, i), &rhsc, NULL);\n+\t      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n+\t\t{\n+\t\t  struct constraint_expr *c2;\n+\t\t  while (VEC_length (ce_s, rhsc) > 0)\n+\t\t    {\n+\t\t      c2 = VEC_last (ce_s, rhsc);\n+\t\t      process_constraint (new_constraint (*c, *c2));\n+\t\t      VEC_pop (ce_s, rhsc);\n+\t\t    }\n+\t\t}\n+\t    } \n+\t}\n+    }\n+  /* In IPA mode, we need to generate constraints to pass call\n+     arguments through their calls.   There are two case, either a\n+     modify_expr when we are returning a value, or just a plain\n+     call_expr when we are not.   */\n+  else if (in_ipa_mode\n+\t   && ((TREE_CODE (t) == MODIFY_EXPR \n+\t\t&& TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR\n+\t       && !(call_expr_flags (TREE_OPERAND (t, 1)) \n+\t\t    & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n+\t       || (TREE_CODE (t) == CALL_EXPR \n+\t\t   && !(call_expr_flags (t) \n+\t\t\t& (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))))\n+    {\n+      tree lhsop;\n+      tree rhsop;\n+      unsigned int varid;\n+      bool found = false;\n+      tree arglist;\n+      varinfo_t fi;\n+      int i = 1;\n+      tree decl;\n+      if (TREE_CODE (t) == MODIFY_EXPR)\n+\t{\n+\t  lhsop = TREE_OPERAND (t, 0);\n+\t  rhsop = TREE_OPERAND (t, 1);\n+\t}\n+      else\n+\t{\n+\t  lhsop = NULL;\n+\t  rhsop = t;\n+\t}\n+      decl = get_callee_fndecl (rhsop);\n+\n+      /* If we can directly resolve the function being called, do so.\n+\t Otherwise, it must be some sort of indirect expression that\n+\t we should still be able to handle.  */\n+      if (decl)\n+\t{\n+\t  found = lookup_id_for_tree (decl, &varid);\n+\t  gcc_assert (found);\n+\t}\n+      else\n+\t{\n+\t  decl = TREE_OPERAND (rhsop, 0);\n+\t  found = lookup_id_for_tree (decl, &varid);\n+\t  gcc_assert (found);\n+\t}\n+\n+      /* Assign all the passed arguments to the approriate incoming\n+\t parameters of the function.  */\n+      fi = get_varinfo (varid);\n+      arglist = TREE_OPERAND (rhsop, 1);\n+\t\n+      for (;arglist; arglist = TREE_CHAIN (arglist))\n+\t{\n+\t  tree arg = TREE_VALUE (arglist);\n+\t  struct constraint_expr lhs ;\n+\t  struct constraint_expr *rhsp;\n+\n+\t  get_constraint_for (arg, &rhsc, NULL);\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n \t    {\n-\t      rhs = get_constraint_for (PHI_ARG_DEF (t, i), NULL);\n-\t      process_constraint (new_constraint (lhs, rhs));\n+\t      lhs.type = DEREF;\n+\t      lhs.var = fi->id;\n+\t      lhs.offset = i;\n+\t    }\n+\t  else\n+\t    {\n+\t      lhs.type = SCALAR;\n+\t      lhs.var = first_vi_for_offset (fi, i)->id;\n+\t      lhs.offset = 0;\n \t    }\n+\t  while (VEC_length (ce_s, rhsc) != 0)\n+\t    {\n+\t      rhsp = VEC_last (ce_s, rhsc);\n+\t      process_constraint (new_constraint (lhs, *rhsp));\n+\t      VEC_pop (ce_s, rhsc);\n+\t    }\n+\t  i++;\n \t}\n+      /* If we are returning a value, assign it to the result.  */\n+      if (lhsop)\n+\t{\n+\t  struct constraint_expr rhs;\n+\t  struct constraint_expr *lhsp;\n+\t  unsigned int j = 0;\n+\t  \n+\t  get_constraint_for (lhsop, &lhsc, NULL);\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    {\n+\t      rhs.type = DEREF;\n+\t      rhs.var = fi->id;\n+\t      rhs.offset = i;\n+\t    }\n+\t  else\n+\t    {\n+\t      rhs.type = SCALAR;\n+\t      rhs.var = first_vi_for_offset (fi, i)->id;\n+\t      rhs.offset = 0;\n+\t    }\n+\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t    process_constraint (new_constraint (*lhsp, rhs));\n+\t}      \n     }\n+  /* Otherwise, just a regular assignment statement.  */\n   else if (TREE_CODE (t) == MODIFY_EXPR)\n     {\n       tree lhsop = TREE_OPERAND (t, 0);\n       tree rhsop = TREE_OPERAND (t, 1);\n-      int i;\t\n+      int i;\n \n       if (AGGREGATE_TYPE_P (TREE_TYPE (lhsop)) \n \t  && AGGREGATE_TYPE_P (TREE_TYPE (rhsop)))\n@@ -2907,7 +3374,7 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n \t      || TREE_CODE (rhsop) == CALL_EXPR)\n \t    {\n-\t      lhs = get_constraint_for (lhsop, NULL);\n+\t      get_constraint_for (lhsop, &lhsc, NULL);\n \t      switch (TREE_CODE_CLASS (TREE_CODE (rhsop)))\n \t\t{\n \t\t  /* RHS that consist of unary operations,\n@@ -2920,24 +3387,45 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t\t  case tcc_expression:\n \t\t  case tcc_unary:\n \t\t      {\n-\t\t\ttree anyoffsetrhs = rhsop;\n+\t\t\tunsigned int j;\n \t\t\tbool need_anyoffset = false;\n-\t\t\trhs = get_constraint_for (rhsop, &need_anyoffset);\n-\t\t\tprocess_constraint (new_constraint (lhs, rhs));\n+\t\t\ttree strippedrhs = rhsop;\n+\t\t\ttree rhstype;\n+\n+\t\t\t/* XXX: Push this back into the ADDR_EXPR\n+\t\t\t   case, and remove anyoffset handling.  */\n+\t\t\tSTRIP_NOPS (strippedrhs);\n+\t\t\trhstype = TREE_TYPE (strippedrhs);\n \t\t\t\n-\t\t\tSTRIP_NOPS (anyoffsetrhs);\n-\t\t\t/* When taking the address of an aggregate\n-\t\t\t   type, from the LHS we can access any field\n-\t\t\t   of the RHS.  */\n-\t\t\tif (need_anyoffset || (rhs.type == ADDRESSOF\n-\t\t\t    && !(get_varinfo (rhs.var)->is_special_var)\n-\t\t\t    && AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (anyoffsetrhs)))))\n+\t\t\tget_constraint_for (rhsop, &rhsc, &need_anyoffset);\n+\t\t\tif (TREE_CODE (strippedrhs) == ADDR_EXPR\n+\t\t\t    && AGGREGATE_TYPE_P (TREE_TYPE (rhstype)))\n \t\t\t  {\n-\t\t\t    rhs.var = anyoffset_id;\n-\t\t\t    rhs.type = ADDRESSOF;\n-\t\t\t    rhs.offset = 0;\n-\t\t\t    process_constraint (new_constraint (lhs, rhs));\n+\t\t\t    struct constraint_expr *origrhs;\n+\t\t\t    varinfo_t origvar;\n+\t\t\t    struct constraint_expr tmp;\n+\n+\t\t\t    gcc_assert (VEC_length (ce_s, rhsc) == 1);\n+\t\t\t    origrhs = VEC_last (ce_s, rhsc);\n+\t\t\t    tmp = *origrhs;\n+\t\t\t    VEC_pop (ce_s, rhsc);\n+\t\t\t    origvar = get_varinfo (origrhs->var);\n+\t\t\t    for (; origvar; origvar = origvar->next)\n+\t\t\t      {\n+\t\t\t\ttmp.var = origvar->id;\n+\t\t\t\tVEC_safe_push (ce_s, heap, rhsc, &tmp);\n+\t\t\t      }\n \t\t\t  }\n+\n+\t\t\tfor (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n+\t\t\t  {\n+\t\t\t    struct constraint_expr *c2;\n+\t\t\t    unsigned int k;\n+\t\t\t    \n+\t\t\t    for (k = 0; VEC_iterate (ce_s, rhsc, k, c2); k++)\n+\t\t\t      process_constraint (new_constraint (*c, *c2));\n+\t\t\t  }\n+\n \t\t      }\n \t\t    break;\n \n@@ -2947,7 +3435,7 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t\t\t   PTR + CST, we can simply use PTR's\n \t\t\t   constraint because pointer arithmetic is\n \t\t\t   not allowed to go out of bounds.  */\n-\t\t\tif (handle_ptr_arith (lhs, rhsop))\n+\t\t\tif (handle_ptr_arith (lhsc, rhsop))\n \t\t\t  break;\n \t\t      }\n \t\t    /* FALLTHRU  */\n@@ -2960,8 +3448,20 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t\t    for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (rhsop)); i++)\n \t\t      {\n \t\t\ttree op = TREE_OPERAND (rhsop, i);\n-\t\t\trhs = get_constraint_for (op, NULL);\n-\t\t\tprocess_constraint (new_constraint (lhs, rhs));\n+\t\t\tunsigned int j;\n+\n+\t\t\tgcc_assert (VEC_length (ce_s, rhsc) == 0);\n+\t\t\tget_constraint_for (op, &rhsc, NULL);\n+\t\t\tfor (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n+\t\t\t  {\n+\t\t\t    struct constraint_expr *c2;\n+\t\t\t    while (VEC_length (ce_s, rhsc) > 0)\n+\t\t\t      {\n+\t\t\t\tc2 = VEC_last (ce_s, rhsc);\n+\t\t\t\tprocess_constraint (new_constraint (*c, *c2));\n+\t\t\t\tVEC_pop (ce_s, rhsc);\n+\t\t\t      }\n+\t\t\t  }\n \t\t      }\n \t\t}      \n \t    }\n@@ -2971,8 +3471,10 @@ find_func_aliases (tree t, struct alias_info *ai)\n   /* After promoting variables and computing aliasing we will\n      need to re-scan most statements.  FIXME: Try to minimize the\n      number of statements re-scanned.  It's not really necessary to\n-     re-scan *all* statements.  */\n-  mark_stmt_modified (t);\n+     re-scan *all* statements.  */  \n+  mark_stmt_modified (origt);\n+  VEC_free (ce_s, heap, rhsc);\n+  VEC_free (ce_s, heap, lhsc);\n }\n \n \n@@ -3123,6 +3625,137 @@ make_constraint_to_anything (varinfo_t vi)\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n+/* Count the number of arguments DECL has, and set IS_VARARGS to true\n+   if it is a varargs function.  */\n+\n+static unsigned int\n+count_num_arguments (tree decl, bool *is_varargs)\n+{\n+  unsigned int i = 0;\n+  tree t;\n+\n+  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); \n+       t;\n+       t = TREE_CHAIN (t))\n+    {\t\n+      if (TREE_VALUE (t) == void_type_node)\n+\tbreak;\n+      i++;\n+    }\n+  \n+  if (!t)\n+    *is_varargs = true;\n+  return i;\n+}\n+\n+/* Creation function node for DECL, using NAME, and return the index\n+   of the variable we've created for the function.  */\n+\n+static unsigned int\n+create_function_info_for (tree decl, const char *name)\n+{\n+  unsigned int index = VEC_length (varinfo_t, varmap);\n+  varinfo_t vi;\n+  tree arg; \n+  unsigned int i;\n+  bool is_varargs = false;\n+\n+  /* Create the variable info.  */\n+\n+  vi = new_var_info (decl, index, name, index);\n+  vi->decl = decl;\n+  vi->offset = 0;\n+  vi->has_union = 0;\n+  vi->size = 1;\n+  vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n+  insert_id_for_tree (vi->decl, index);  \n+  VEC_safe_push (varinfo_t, heap, varmap, vi);\n+\n+  stats.total_vars++;\n+\n+  /* If it's varargs, we don't know how many arguments it has, so we\n+     can't do much.\n+  */\n+  if (is_varargs)\n+    {\n+      vi->fullsize = ~0;\n+      vi->size = ~0;\n+      vi->is_unknown_size_var = true;\n+      return index;\n+    }\n+\n+  \n+  arg = DECL_ARGUMENTS (decl);\n+\n+  /* Set up varirables for each argument.  */\n+  for (i = 1; i < vi->fullsize; i++)\n+    {      \n+      varinfo_t argvi;\n+      const char *newname;\n+      char *tempname;\n+      unsigned int newindex;\n+      tree argdecl = decl;\n+\n+      if (arg)\n+\targdecl = arg;\n+      \n+      newindex = VEC_length (varinfo_t, varmap);\n+      asprintf (&tempname, \"%s.arg%d\", name, i-1);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      argvi = new_var_info (argdecl, newindex,newname, newindex);\n+      argvi->decl = argdecl;\n+      VEC_safe_push (varinfo_t, heap, varmap, argvi);\n+      argvi->offset = i;\n+      argvi->size = 1;\n+      argvi->fullsize = vi->fullsize;\n+      argvi->has_union = false;\n+      insert_into_field_list (vi, argvi);\n+      stats.total_vars ++;\n+      if (arg)\n+\t{\n+\t  insert_id_for_tree (arg, newindex);\n+\t  arg = TREE_CHAIN (arg);\n+\t}\n+    }\n+  \n+  /* Create a variable for the return var.  */\n+  if (DECL_RESULT (decl) != NULL\n+      || !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+    {\n+      varinfo_t resultvi;\n+      const char *newname;\n+      char *tempname;\n+      unsigned int newindex;\n+      tree resultdecl = decl;\n+\n+      vi->fullsize ++;\n+\n+\n+      if (DECL_RESULT (decl))\n+\tresultdecl = DECL_RESULT (decl);\n+      \n+      newindex = VEC_length (varinfo_t, varmap);\n+      asprintf (&tempname, \"%s.result\", name);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      resultvi = new_var_info (resultdecl, newindex, newname, newindex);\n+      resultvi->decl = resultdecl;\n+      VEC_safe_push (varinfo_t, heap, varmap, resultvi);\n+      resultvi->offset = i;\n+      resultvi->size = 1;\n+      resultvi->fullsize = vi->fullsize;\n+      resultvi->has_union = false;\n+      insert_into_field_list (vi, resultvi);\n+      stats.total_vars ++;\n+      if (DECL_RESULT (decl))\n+\tinsert_id_for_tree (DECL_RESULT (decl), newindex);\n+    }\n+  return index;\n+}  \n+\n \n /* Return true if FIELDSTACK contains fields that overlap. \n    FIELDSTACK is assumed to be sorted by offset.  */\n@@ -3153,11 +3786,14 @@ create_variable_info_for (tree decl, const char *name)\n   unsigned int index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n   tree decltype = TREE_TYPE (decl);\n+  tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decltype);\n   bool notokay = false;\n   bool hasunion;\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n   \n+  if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n+    return create_function_info_for (decl, name);\n \n   hasunion = TREE_CODE (decltype) == UNION_TYPE\n              || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n@@ -3168,7 +3804,7 @@ create_variable_info_for (tree decl, const char *name)\n \t{\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n \t  notokay = true;\n-\t}\t \n+\t}\n     }\n   \n \n@@ -3179,9 +3815,8 @@ create_variable_info_for (tree decl, const char *name)\n   vi->decl = decl;\n   vi->offset = 0;\n   vi->has_union = hasunion;\n-  if (!TYPE_SIZE (decltype) \n-      || TREE_CODE (TYPE_SIZE (decltype)) != INTEGER_CST\n-      || TREE_CODE (decltype) == ARRAY_TYPE\n+  if (!declsize\n+      || TREE_CODE (declsize) != INTEGER_CST\n       || TREE_CODE (decltype) == UNION_TYPE\n       || TREE_CODE (decltype) == QUAL_UNION_TYPE)\n     {\n@@ -3191,13 +3826,13 @@ create_variable_info_for (tree decl, const char *name)\n     }\n   else\n     {\n-      vi->fullsize = TREE_INT_CST_LOW (TYPE_SIZE (decltype));\n+      vi->fullsize = TREE_INT_CST_LOW (declsize);\n       vi->size = vi->fullsize;\n     }\n   \n   insert_id_for_tree (vi->decl, index);  \n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n-  if (is_global)\n+  if (is_global && (!flag_whole_program || !in_ipa_mode))\n     make_constraint_to_anything (vi);\n \n   stats.total_vars++;\n@@ -3215,7 +3850,6 @@ create_variable_info_for (tree decl, const char *name)\n \t{\n \t  if (!DECL_SIZE (fo->field) \n \t      || TREE_CODE (DECL_SIZE (fo->field)) != INTEGER_CST\n-\t      || TREE_CODE (TREE_TYPE (fo->field)) == ARRAY_TYPE\n \t      || fo->offset < 0)\n \t    {\n \t      notokay = true;\n@@ -3270,10 +3904,10 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->fullsize = vi->fullsize;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n-\t  if (is_global)\n+\t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n \t    make_constraint_to_anything (newvi);\n \n-\t  stats.total_vars++;\t  \n+\t  stats.total_vars++;\n \t}\n       VEC_free (fieldoff_s, heap, fieldstack);\n     }\n@@ -3318,23 +3952,14 @@ intra_create_variable_infos (void)\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n     {\n       struct constraint_expr lhs;\n-      struct constraint_expr rhs;\n       varinfo_t p;\n       \n       lhs.offset = 0;\n       lhs.type = SCALAR;\n       lhs.var  = create_variable_info_for (t, alias_get_name (t));\n       \n-      rhs.var = anything_id;\n-      rhs.type = ADDRESSOF;\n-      rhs.offset = 0;\n-\n       for (p = get_varinfo (lhs.var); p; p = p->next)\n-\t{\n-\t  struct constraint_expr temp = lhs;\n-\t  temp.var = p->id;\n-\t  process_constraint (new_constraint (temp, rhs));\n-\t}\n+\tmake_constraint_to_anything (p);\n     }\t\n \n }\n@@ -3347,22 +3972,12 @@ set_uids_in_ptset (bitmap into, bitmap from)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  bool found_anyoffset = false;\n   subvar_t sv;\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n \n-      /* If we find ANYOFFSET in the solution and the solution\n-\t includes SFTs for some structure, then all the SFTs in that\n-\t structure will need to be added to the alias set.  */\n-      if (vi->id == anyoffset_id)\n-\t{\n-\t  found_anyoffset = true;\n-\t  continue;\n-\t}\n-\n       /* The only artificial variables that are allowed in a may-alias\n \t set are heap variables.  */\n       if (vi->is_artificial_var && !vi->is_heap_var)\n@@ -3378,24 +3993,14 @@ set_uids_in_ptset (bitmap into, bitmap from)\n       else if (TREE_CODE (vi->decl) == VAR_DECL \n \t       || TREE_CODE (vi->decl) == PARM_DECL)\n \t{\n-\t  if (found_anyoffset\n-\t      && var_can_have_subvars (vi->decl)\n-\t      && get_subvars_for_var (vi->decl))\n-\t    {\n-\t      /* If ANYOFFSET is in the solution set and VI->DECL is\n-\t\t an aggregate variable with sub-variables, then any of\n-\t\t the SFTs inside VI->DECL may have been accessed.  Add\n-\t\t all the sub-vars for VI->DECL.  */\n-\t      for (sv = get_subvars_for_var (vi->decl); sv; sv = sv->next)\n-\t\tbitmap_set_bit (into, DECL_UID (sv->var));\n-\t    }\n-\t  else if (var_can_have_subvars (vi->decl)\n+\t  if (var_can_have_subvars (vi->decl)\n \t\t   && get_subvars_for_var (vi->decl))\n \t    {\n \t      /* If VI->DECL is an aggregate for which we created\n \t\t SFTs, add the SFT corresponding to VI->OFFSET.  */\n \t      tree sft = get_subvar_at (vi->decl, vi->offset);\n-\t      bitmap_set_bit (into, DECL_UID (sft));\n+\t      if (sft)\n+\t\tbitmap_set_bit (into, DECL_UID (sft));\n \t    }\n \t  else\n \t    {\n@@ -3490,14 +4095,6 @@ find_what_p_points_to (tree p)\n }\n \n \n-/* Initialize things necessary to perform PTA */\n-\n-static void\n-init_alias_vars (void)\n-{\n-  bitmap_obstack_initialize (&ptabitmap_obstack);\n-}\n-\n \n /* Dump points-to information to OUTFILE.  */\n \n@@ -3518,6 +4115,7 @@ dump_sa_points_to_info (FILE *outfile)\n       fprintf (outfile, \"Dynamically unified vars: %d\\n\",\n \t       stats.unified_vars_dynamic);\n       fprintf (outfile, \"Iterations:               %d\\n\", stats.iterations);\n+      fprintf (outfile, \"Number of edges:          %d\\n\", stats.num_edges);\n     }\n \n   for (i = 0; i < VEC_length (varinfo_t, varmap); i++)\n@@ -3635,32 +4233,6 @@ init_base_vars (void)\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n-\n-  /* Create the ANYOFFSET variable, used to represent an arbitrary offset\n-     inside an object.  This is similar to ANYTHING, but less drastic.\n-     It means that the pointer can point anywhere inside an object,\n-     but not outside of it.  */\n-  anyoffset_tree = create_tmp_var_raw (void_type_node, \"ANYOFFSET\");\n-  anyoffset_id = 4;\n-  var_anyoffset = new_var_info (anyoffset_tree, anyoffset_id, \"ANYOFFSET\",\n-                                anyoffset_id); \n-  insert_id_for_tree (anyoffset_tree, anyoffset_id);\n-  var_anyoffset->is_artificial_var = 1;\n-  var_anyoffset->size = ~0;\n-  var_anyoffset->offset = 0;\n-  var_anyoffset->next = NULL;\n-  var_anyoffset->fullsize = ~0;\n-  var_anyoffset->is_special_var = 1;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_anyoffset);\n-\n-  /* ANYOFFSET points to ANYOFFSET.  */\n-  lhs.type = SCALAR;\n-  lhs.var = anyoffset_id;\n-  lhs.offset = 0;\n-  rhs.type = ADDRESSOF;\n-  rhs.var = anyoffset_id;\n-  rhs.offset = 0;\n-  process_constraint (new_constraint (lhs, rhs));\n }  \n \n /* Return true if we actually need to solve the constraint graph in order to\n@@ -3690,7 +4262,8 @@ need_to_solve (void)\n \t  && !bitmap_bit_p (v->solution, anything_id))\n \tfound_non_anything = true;\n       else if (bitmap_empty_p (v->solution)\n-\t       && VEC_length (constraint_edge_t, graph->preds[v->id]) != 0)\n+\t       && (VEC_length (constraint_edge_t, graph->preds[v->id]) != 0\n+\t\t || (graph->zero_weight_preds[v->id] && !bitmap_empty_p (graph->zero_weight_preds[v->id]))))\n \tfound_non_anything = true;\n \n       if (found_address_taken && found_non_anything)\n@@ -3700,17 +4273,13 @@ need_to_solve (void)\n   return false;\n }\n \n-/* Create points-to sets for the current function.  See the comments\n-   at the start of the file for an algorithmic overview.  */\n+/* Initialize things necessary to perform PTA */\n \n-void\n-compute_points_to_sets (struct alias_info *ai)\n+static void\n+init_alias_vars (void)\n {\n-  basic_block bb;\n-\n-  timevar_push (TV_TREE_PTA);\n-\n-  init_alias_vars ();\n+  bitmap_obstack_initialize (&ptabitmap_obstack);\n+  bitmap_obstack_initialize (&predbitmap_obstack);\n \n   constraint_pool = create_alloc_pool (\"Constraint pool\", \n \t\t\t\t       sizeof (struct constraint), 30);\n@@ -3725,6 +4294,20 @@ compute_points_to_sets (struct alias_info *ai)\n   memset (&stats, 0, sizeof (stats));\n \n   init_base_vars ();\n+}\n+\n+\n+/* Create points-to sets for the current function.  See the comments\n+   at the start of the file for an algorithmic overview.  */\n+\n+void\n+compute_points_to_sets (struct alias_info *ai)\n+{\n+  basic_block bb;\n+\n+  timevar_push (TV_TREE_PTA);\n+\n+  init_alias_vars ();\n \n   intra_create_variable_infos ();\n \n@@ -3735,11 +4318,28 @@ compute_points_to_sets (struct alias_info *ai)\n       tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n-\tif (is_gimple_reg (PHI_RESULT (phi)))\n-\t  find_func_aliases (phi, ai);\n+\t{\n+\t  if (is_gimple_reg (PHI_RESULT (phi)))\n+\t    {\n+\t      find_func_aliases (phi);\n+\t      /* Update various related attributes like escaped\n+\t\t addresses, pointer dereferences for loads and stores.\n+\t\t This is used when creating name tags and alias\n+\t\t sets.  */\n+\t      update_alias_info (phi, ai);\n+\t    }\n+\t}\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tfind_func_aliases (bsi_stmt (bsi), ai);\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  find_func_aliases (stmt);\n+\t      /* Update various related attributes like escaped\n+\t\t addresses, pointer dereferences for loads and stores.\n+\t\t This is used when creating name tags and alias\n+\t\t sets.  */\n+\t  update_alias_info (stmt, ai);\n+\t}\n     }\n \n   build_constraint_graph ();\n@@ -3753,7 +4353,8 @@ compute_points_to_sets (struct alias_info *ai)\n   if (need_to_solve ())\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"\\nCollapsing static cycles and doing variable \"\n+\tfprintf (dump_file,\n+\t\t \"\\nCollapsing static cycles and doing variable \"\n \t\t \"substitution:\\n\");\n       \n       find_and_collapse_graph_cycles (graph, false);\n@@ -3784,6 +4385,7 @@ delete_points_to_sets (void)\n \n   htab_delete (id_for_tree);\n   bitmap_obstack_release (&ptabitmap_obstack);\n+  bitmap_obstack_release (&predbitmap_obstack);\n   VEC_free (constraint_t, heap, constraints);\n   \n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n@@ -3792,6 +4394,8 @@ delete_points_to_sets (void)\n       VEC_free (constraint_edge_t, heap, graph->preds[i]);\n       VEC_free (constraint_t, heap, v->complex);\n     }\n+  free (graph->zero_weight_preds);\n+  free (graph->zero_weight_succs);\n   free (graph->succs);\n   free (graph->preds);\n   free (graph);\n@@ -3804,6 +4408,128 @@ delete_points_to_sets (void)\n   have_alias_info = false;\n }\n \n+/* Return true if we should execute IPA PTA.  */\n+static bool\n+gate_ipa_pta (void)\n+{\n+  return (flag_unit_at_a_time != 0\n+\t  /* Don't bother doing anything if the program has errors.  */\n+\t  && !(errorcount || sorrycount));\n+}\n+\n+/* Execute the driver for IPA PTA.  */\n+static void\n+ipa_pta_execute (void)\n+{\n+  struct cgraph_node *node;\n+  in_ipa_mode = 1;\n+\n+  init_alias_vars ();\n+  \n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->analyzed || cgraph_is_master_clone (node))\n+\t{\n+\t  unsigned int varid;\n+\t  \n+\t  varid = create_function_info_for (node->decl, \n+\t\t\t\t\t    cgraph_node_name (node));\n+\t  if (node->local.externally_visible)\n+\t    {\n+\t      varinfo_t fi = get_varinfo (varid);\n+\t      for (; fi; fi = fi->next)\n+\t\tmake_constraint_to_anything (fi);\n+\t    }\n+\t}\n+    }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (node->analyzed && cgraph_is_master_clone (node))\n+\t{\n+\t  struct function *cfun = DECL_STRUCT_FUNCTION (node->decl);\n+\t  basic_block bb;\n+\t  tree old_func_decl = current_function_decl;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \n+\t\t     \"Generating constraints for %s\\n\", \n+\t\t     cgraph_node_name (node)); \n+\t  push_cfun (cfun);\n+\t  current_function_decl = node->decl;\n+\n+\t  FOR_EACH_BB_FN (bb, cfun)\n+\t    {\n+\t      block_stmt_iterator bsi; \n+\t      tree phi;\n+\t      \n+\t      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+\t\t{\n+\t\t  if (is_gimple_reg (PHI_RESULT (phi)))\n+\t\t    {\n+\t\t      find_func_aliases (phi);\n+\t\t    }\n+\t\t}\n+\t      \n+\t      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\t{\n+\t\t  tree stmt = bsi_stmt (bsi);\n+\t\t  find_func_aliases (stmt);\n+\t\t}\n+\t    }\t\n+\t  current_function_decl = old_func_decl;\n+\t  pop_cfun ();\t  \n+\t}\n+      else\n+\t{\n+\t  /* Make point to anything.  */\n+\t}\n+    }\n+\n+  build_constraint_graph ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n+      dump_constraints (dump_file);\n+    }\n+  \n+  if (need_to_solve ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \n+\t\t \"\\nCollapsing static cycles and doing variable \"\n+\t\t \"substitution:\\n\");\n+      \n+      find_and_collapse_graph_cycles (graph, false);\n+      perform_var_substitution (graph);\n+      \n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nSolving graph:\\n\");\n+      \n+      solve_graph (graph);\n+    }\n+  \n+  if (dump_file)\n+    dump_sa_points_to_info (dump_file);\n+  in_ipa_mode = 0;\n+}\n+  \n+struct tree_opt_pass pass_ipa_pta =\n+{\n+  \"pta\",\t\t                /* name */\n+  gate_ipa_pta,\t\t\t/* gate */\n+  ipa_pta_execute,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_PTA,\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n /* Initialize the heapvar for statement mapping.  */\n void \n init_alias_heapvars (void)"}]}