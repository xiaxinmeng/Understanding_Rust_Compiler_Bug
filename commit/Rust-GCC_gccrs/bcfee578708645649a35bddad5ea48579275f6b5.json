{"sha": "bcfee578708645649a35bddad5ea48579275f6b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmZWU1Nzg3MDg2NDU2NDlhMzViZGRhZDVlYTQ4NTc5Mjc1ZjZiNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-10-03T10:28:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-10-03T10:28:50Z"}, "message": "convert.c (convert_to_integer): Do not introduce useless conversions between integral types.\n\n\t* convert.c (convert_to_integer): Do not introduce useless conversions\n\tbetween integral types.\n\nFrom-SVN: r215843", "tree": {"sha": "c0f876e4d6ea20b37981e650091d325e3c79507f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0f876e4d6ea20b37981e650091d325e3c79507f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcfee578708645649a35bddad5ea48579275f6b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcfee578708645649a35bddad5ea48579275f6b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcfee578708645649a35bddad5ea48579275f6b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcfee578708645649a35bddad5ea48579275f6b5/comments", "author": null, "committer": null, "parents": [{"sha": "8684302d34b6e1a6244f07990d7304b919e2010d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8684302d34b6e1a6244f07990d7304b919e2010d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8684302d34b6e1a6244f07990d7304b919e2010d"}], "stats": {"total": 34, "additions": 29, "deletions": 5}, "files": [{"sha": "56add5bffc1b9f81a8c1452b1ab80ac1cac19397", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcfee578708645649a35bddad5ea48579275f6b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcfee578708645649a35bddad5ea48579275f6b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcfee578708645649a35bddad5ea48579275f6b5", "patch": "@@ -1,3 +1,8 @@\n+2014-10-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* convert.c (convert_to_integer): Do not introduce useless conversions\n+\tbetween integral types.\n+\n 2014-10-03  David Sherwood  <david.sherwood@arm.com>\n \n \t* ira-int.h (ira_allocno): Mark hard_regno as signed."}, {"sha": "9ef27f6347f8257e6bc6c24a1f484e02ebe51b3e", "filename": "gcc/convert.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcfee578708645649a35bddad5ea48579275f6b5/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcfee578708645649a35bddad5ea48579275f6b5/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=bcfee578708645649a35bddad5ea48579275f6b5", "patch": "@@ -746,8 +746,9 @@ convert_to_integer (tree type, tree expr)\n \t\t/* Can't do arithmetic in enumeral types\n \t\t   so use an integer type that will hold the values.  */\n \t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t  typex = lang_hooks.types.type_for_size\n-\t\t    (TYPE_PRECISION (typex), TYPE_UNSIGNED (typex));\n+\t\t  typex\n+\t\t    = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t\t      TYPE_UNSIGNED (typex));\n \n \t\t/* But now perhaps TYPEX is as wide as INPREC.\n \t\t   In that case, do nothing special here.\n@@ -788,9 +789,15 @@ convert_to_integer (tree type, tree expr)\n \t\t\t    && (ex_form == PLUS_EXPR\n \t\t\t\t|| ex_form == MINUS_EXPR\n \t\t\t\t|| ex_form == MULT_EXPR)))\n-\t\t      typex = unsigned_type_for (typex);\n+\t\t      {\n+\t\t\tif (!TYPE_UNSIGNED (typex))\n+\t\t\t  typex = unsigned_type_for (typex);\n+\t\t      }\n \t\t    else\n-\t\t      typex = signed_type_for (typex);\n+\t\t      {\n+\t\t\tif (TYPE_UNSIGNED (typex))\n+\t\t\t  typex = signed_type_for (typex);\n+\t\t      }\n \t\t    return convert (type,\n \t\t\t\t    fold_build2 (ex_form, typex,\n \t\t\t\t\t\t convert (typex, arg0),\n@@ -805,7 +812,19 @@ convert_to_integer (tree type, tree expr)\n \t  /* This is not correct for ABS_EXPR,\n \t     since we must test the sign before truncation.  */\n \t  {\n-\t    tree typex = unsigned_type_for (type);\n+\t    /* Do the arithmetic in type TYPEX,\n+\t       then convert result to TYPE.  */\n+\t    tree typex = type;\n+\n+\t    /* Can't do arithmetic in enumeral types\n+\t       so use an integer type that will hold the values.  */\n+\t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t      typex\n+\t\t= lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t\t  TYPE_UNSIGNED (typex));\n+\n+\t    if (!TYPE_UNSIGNED (typex))\n+\t      typex = unsigned_type_for (typex);\n \t    return convert (type,\n \t\t\t    fold_build1 (ex_form, typex,\n \t\t\t\t\t convert (typex,"}]}