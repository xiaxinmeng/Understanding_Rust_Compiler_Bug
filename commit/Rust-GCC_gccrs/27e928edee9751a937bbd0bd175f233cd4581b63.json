{"sha": "27e928edee9751a937bbd0bd175f233cd4581b63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlOTI4ZWRlZTk3NTFhOTM3YmJkMGJkMTc1ZjIzM2NkNDU4MWI2Mw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-05-10T13:23:35Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-05-10T13:23:35Z"}, "message": "re PR java/21436 (imports not remembered for previously compiled files)\n\ngcc/java:\n2005-05-10  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR java/21436\n\t* class.c (maybe_layout_super_class): Look for imports in this_class.\n\t* parse.h (ctxp_for_generation_last): New.\n\t(do_resolve_class): Add a parameter.\n\t* parse.y (ctxp_for_generation_last): New.\n\t(java_pop_parser_context): Add at end of list.\n\t(find_in_imports, find_in_imports_on_demand): Look in ctxp\n\tif the TYPE_IMPORT_LIST or respectively the TYPE_IMPORT_DEMAND_LIST of\n\tthe given type are NULL.\n\t(do_resolve_class): Look into the imports of the new second parameter.\n\tAdjust recursive calls.\n\t(resolve_class, resolve_inner_class, find_as_inner_class): Adjust\n\tcalls to do_resolve_class.\n\t(create_class): Set the TYPE_IMPORT_LIST and TYPE_IMPORT_DEMAND_LIST.\n\t(java_complete_class): Do not do that here.\n\nlibjava:\n2005-05-10  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR java/21436\n\t* testsuite/libjava.jacks/jacks.xfail: Adjust.\n\nFrom-SVN: r99513", "tree": {"sha": "feb534487f7c16b52aaa30fbe27ccd9255bc7194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feb534487f7c16b52aaa30fbe27ccd9255bc7194"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27e928edee9751a937bbd0bd175f233cd4581b63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e928edee9751a937bbd0bd175f233cd4581b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e928edee9751a937bbd0bd175f233cd4581b63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e928edee9751a937bbd0bd175f233cd4581b63/comments", "author": null, "committer": null, "parents": [{"sha": "2798c11f46535b4581da39ed747dd07f02085ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2798c11f46535b4581da39ed747dd07f02085ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2798c11f46535b4581da39ed747dd07f02085ae5"}], "stats": {"total": 99, "additions": 73, "deletions": 26}, "files": [{"sha": "5da68340ad32affdcfea16de3cdb92d82be64bc9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -1,3 +1,21 @@\n+2005-05-10  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR java/21436\n+\t* class.c (maybe_layout_super_class): Look for imports in this_class.\n+\t* parse.h (ctxp_for_generation_last): New.\n+\t(do_resolve_class): Add a parameter.\n+\t* parse.y (ctxp_for_generation_last): New.\n+\t(java_pop_parser_context): Add at end of list.\n+\t(find_in_imports, find_in_imports_on_demand): Look in ctxp\n+\tif the TYPE_IMPORT_LIST or respectively the TYPE_IMPORT_DEMAND_LIST of\n+\tthe given type are NULL.\n+\t(do_resolve_class): Look into the imports of the new second parameter.\n+\tAdjust recursive calls.\n+\t(resolve_class, resolve_inner_class, find_as_inner_class): Adjust\n+\tcalls to do_resolve_class.\n+\t(create_class): Set the TYPE_IMPORT_LIST and TYPE_IMPORT_DEMAND_LIST.\n+\t(java_complete_class): Do not do that here.\n+\n 2005-05-03  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \tPR java/20309\n@@ -15447,7 +15465,7 @@\n \t(CLASS_P): Moved around.\n \t(java_parse_abort_on_error): Macro moved from jcf-parse.c\n \t* jcf-parse.c (java_parse_abort_on_error): Macro moved to\n-\tjava-parse.h\n+\tjava-tree.h\n \t(jcf_parse_source): Changed leading comment. Removed unnecessary\n \tfclose and CLASS_FROM_SOURCE_P marking.\n \t(parse_source_file): New local variables remember_for_generation"}, {"sha": "9ab88570d03cb0ee9aa099ce23f365b0592e550d", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -2085,7 +2085,7 @@ maybe_layout_super_class (tree super_class, tree this_class)\n \t\t\t\t\t  DECL_SOURCE_LINE (this_decl), 0);\n #endif\n \t    }\n-\t  super_class = do_resolve_class (NULL_TREE, /* FIXME? */\n+\t  super_class = do_resolve_class (NULL_TREE, this_class,\n \t\t\t\t\t  super_class, NULL_TREE, this_wrap);\n \t  if (!super_class)\n \t    return NULL_TREE;\t/* FIXME, NULL_TREE not checked by caller. */"}, {"sha": "232eead9862fcd143ec68b744e9706f2efa2d28f", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -937,7 +937,7 @@ void java_layout_classes (void);\n void java_reorder_fields (void);\n tree java_method_add_stmt (tree, tree);\n int java_report_errors (void);\n-extern tree do_resolve_class (tree, tree, tree, tree);\n+extern tree do_resolve_class (tree, tree, tree, tree, tree);\n #endif\n char *java_get_line_col (const char *, int, int);\n extern void reset_report (void);\n@@ -960,5 +960,6 @@ extern void java_finish_classes (void);\n \n extern GTY(()) struct parser_ctxt *ctxp;\n extern GTY(()) struct parser_ctxt *ctxp_for_generation;\n+extern GTY(()) struct parser_ctxt *ctxp_for_generation_last;\n \n #endif /* ! GCC_JAVA_PARSE_H */"}, {"sha": "b4facbba592e50bd88313a88ec607bea1a6eeabb", "filename": "gcc/java/parse.y", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -361,6 +361,7 @@ struct parser_ctxt *ctxp;\n \n /* List of things that were analyzed for which code will be generated */\n struct parser_ctxt *ctxp_for_generation = NULL;\n+struct parser_ctxt *ctxp_for_generation_last = NULL;\n \n /* binop_lookup maps token to tree_code. It is used where binary\n    operations are involved and required by the parser. RDIV_EXPR\n@@ -2765,8 +2766,12 @@ java_pop_parser_context (int generate)\n      do is to just update a list of class names.  */\n   if (generate)\n     {\n-      ctxp->next = ctxp_for_generation;\n-      ctxp_for_generation = ctxp;\n+      if (ctxp_for_generation_last == NULL)\n+        ctxp_for_generation = ctxp;\n+      else\n+        ctxp_for_generation_last->next = ctxp;\n+      ctxp->next = NULL;\n+      ctxp_for_generation_last = ctxp;\n     }\n \n   /* And restore those of the previous context */\n@@ -3706,7 +3711,7 @@ resolve_inner_class (htab_t circularity_hash, tree cl, tree *enclosing,\n         break;\n \n       if (TREE_CODE (local_super) == POINTER_TYPE)\n-        local_super = do_resolve_class (NULL, local_super, NULL, NULL);\n+        local_super = do_resolve_class (NULL, NULL, local_super, NULL, NULL);\n       else\n \tlocal_super = TYPE_NAME (local_super);\n \n@@ -3768,7 +3773,7 @@ find_as_inner_class (tree enclosing, tree name, tree cl)\n \t  acc = merge_qualified_name (acc,\n \t\t\t\t      EXPR_WFL_NODE (TREE_PURPOSE (qual)));\n \t  BUILD_PTR_FROM_NAME (ptr, acc);\n-\t  decl = do_resolve_class (NULL_TREE, ptr, NULL_TREE, cl);\n+\t  decl = do_resolve_class (NULL_TREE, NULL_TREE, ptr, NULL_TREE, cl);\n \t}\n \n       /* A NULL qual and a decl means that the search ended\n@@ -4177,6 +4182,12 @@ create_class (int flags, tree id, tree super, tree interfaces)\n      virtual function table in java.lang.object.  */\n   TYPE_VFIELD (TREE_TYPE (decl)) = TYPE_VFIELD (object_type_node);\n \n+  /* We keep the compilation unit imports in the class so that\n+     they can be used later to resolve type dependencies that\n+     aren't necessary to solve now. */\n+  TYPE_IMPORT_LIST (TREE_TYPE (decl)) = ctxp->import_list;\n+  TYPE_IMPORT_DEMAND_LIST (TREE_TYPE (decl)) = ctxp->import_demand_list;\n+\n   /* Add the private this$<n> field, Replicate final locals still in\n      scope as private final fields mangled like val$<local_name>.\n      This does not occur for top level (static) inner classes. */\n@@ -5683,12 +5694,6 @@ java_complete_class (void)\n     {\n       jdep *dep;\n \n-      /* We keep the compilation unit imports in the class so that\n-\t they can be used later to resolve type dependencies that\n-\t aren't necessary to solve now. */\n-      TYPE_IMPORT_LIST (TREE_TYPE (cclass)) = ctxp->import_list;\n-      TYPE_IMPORT_DEMAND_LIST (TREE_TYPE (cclass)) = ctxp->import_demand_list;\n-\n       for (dep = CLASSD_FIRST (cclassd); dep; dep = JDEP_CHAIN (dep))\n \t{\n \t  tree decl;\n@@ -5839,7 +5844,7 @@ resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n     WFL_STRIP_BRACKET (cl, cl);\n \n   /* 2- Resolve the bare type */\n-  if (!(resolved_type_decl = do_resolve_class (enclosing, class_type,\n+  if (!(resolved_type_decl = do_resolve_class (enclosing, NULL_TREE, class_type,\n \t\t\t\t\t       decl, cl)))\n     return NULL_TREE;\n   resolved_type = TREE_TYPE (resolved_type_decl);\n@@ -5862,7 +5867,8 @@ resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n    and (but it doesn't really matter) qualify_and_find.  */\n \n tree\n-do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n+do_resolve_class (tree enclosing, tree import_type, tree class_type, tree decl,\n+\t\t  tree cl)\n {\n   tree new_class_decl = NULL_TREE, super = NULL_TREE;\n   tree saved_enclosing_type = enclosing ? TREE_TYPE (enclosing) : NULL_TREE;\n@@ -5879,7 +5885,7 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n       if (split_qualified_name (&left, &right, TYPE_NAME (class_type)) == 0)\n \t{\n \t  BUILD_PTR_FROM_NAME (left_type, left);\n-\t  q = do_resolve_class (enclosing, left_type, decl, cl);\n+\t  q = do_resolve_class (enclosing, import_type, left_type, decl, cl);\n \t  if (q)\n \t    {\n \t      enclosing = q;\n@@ -5924,8 +5930,11 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n \treturn new_class_decl;\n     }\n \n-  /* 1- Check for the type in single imports. This will change\n-     TYPE_NAME() if something relevant is found */\n+  /* 1- Check for the type in single imports.  Look at enclosing classes and,\n+     if we're laying out a superclass, at the import list for the subclass.\n+     This will change TYPE_NAME() if something relevant is found. */\n+  if (import_type && TYPE_IMPORT_LIST (import_type))\n+    find_in_imports (import_type, class_type);\n   find_in_imports (saved_enclosing_type, class_type);\n \n   /* 2- And check for the type in the current compilation unit */\n@@ -5947,8 +5956,14 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n   /* 4- Check the import on demands. Don't allow bar.baz to be\n      imported from foo.* */\n   if (!QUALIFIED_P (TYPE_NAME (class_type)))\n-    if (find_in_imports_on_demand (saved_enclosing_type, class_type))\n-      return NULL_TREE;\n+    {\n+      if (import_type\n+\t  && TYPE_IMPORT_DEMAND_LIST (import_type)\n+\t  && find_in_imports_on_demand (import_type, class_type))\n+        return NULL_TREE;\n+      if (find_in_imports_on_demand (saved_enclosing_type, class_type))\n+        return NULL_TREE;\n+    }\n \n   /* If found in find_in_imports_on_demand, the type has already been\n      loaded. */\n@@ -6970,8 +6985,12 @@ process_imports (void)\n static void\n find_in_imports (tree enclosing_type, tree class_type)\n {\n-  tree import = (enclosing_type ? TYPE_IMPORT_LIST (enclosing_type) :\n-\t\t ctxp->import_list);\n+  tree import;\n+  if (enclosing_type && TYPE_IMPORT_LIST (enclosing_type))\n+    import = TYPE_IMPORT_LIST (enclosing_type);\n+  else\n+    import = ctxp->import_list;\n+\n   while (import)\n     {\n       if (TREE_VALUE (import) == TYPE_NAME (class_type))\n@@ -7129,12 +7148,16 @@ static int\n find_in_imports_on_demand (tree enclosing_type, tree class_type)\n {\n   tree class_type_name = TYPE_NAME (class_type);\n-  tree import = (enclosing_type ? TYPE_IMPORT_DEMAND_LIST (enclosing_type) :\n-\t\t  ctxp->import_demand_list);\n   tree cl = NULL_TREE;\n   int seen_once = -1;\t/* -1 when not set, 1 if seen once, >1 otherwise. */\n   int to_return = -1;\t/* -1 when not set, 0 or 1 otherwise */\n   tree node;\n+  tree import;\n+\n+  if (enclosing_type && TYPE_IMPORT_DEMAND_LIST (enclosing_type))\n+    import = TYPE_IMPORT_DEMAND_LIST (enclosing_type);\n+  else\n+    import = ctxp->import_demand_list;\n \n   for (; import; import = TREE_CHAIN (import))\n     {"}, {"sha": "bbcff752642e5b718c1cca4c62eac1b7fd4ce517", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -1,3 +1,8 @@\n+2005-05-10  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR java/21436\n+\t* testsuite/libjava.jacks/jacks.xfail: Adjust.\n+\n 2005-05-09  Mike Stump  <mrs@apple.com>\n \n \t* configure: Regenerate."}, {"sha": "4cc878464fd6ef883ab0162d92e677c71d4e9c32", "filename": "libjava/testsuite/libjava.jacks/jacks.xfail", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e928edee9751a937bbd0bd175f233cd4581b63/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e928edee9751a937bbd0bd175f233cd4581b63/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail?ref=27e928edee9751a937bbd0bd175f233cd4581b63", "patch": "@@ -152,8 +152,8 @@\n 15.11.2-syntax-1\n 15.12.1-syntax-1\n 15.12.1-type-14\n-15.12.2.1-accessibility-method-3\n-15.12.2.1-accessibility-method-5\n+15.12.2.1-accessibility-method-2\n+15.12.2.1-accessibility-method-4\n 15.12.2.1-accessibility-method-6\n 15.12.2.2-ambiguous-10\n 15.12.2.2-ambiguous-12"}]}