{"sha": "1d5d7a21e006965c06d800141c149cf793aeefe1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1ZDdhMjFlMDA2OTY1YzA2ZDgwMDE0MWMxNDljZjc5M2FlZWZlMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-17T07:51:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-17T07:51:56Z"}, "message": "ia64.md: Use braced strings instead of quoted strings for code blocks.\n\n        * config/ia64/ia64.md: Use braced strings instead of quoted strings\n        for code blocks.  Tidy whitespace.\n\nFrom-SVN: r53551", "tree": {"sha": "bdf7744e1f0f0c268b72b342518611f9714c0902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdf7744e1f0f0c268b72b342518611f9714c0902"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d5d7a21e006965c06d800141c149cf793aeefe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5d7a21e006965c06d800141c149cf793aeefe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5d7a21e006965c06d800141c149cf793aeefe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5d7a21e006965c06d800141c149cf793aeefe1/comments", "author": null, "committer": null, "parents": [{"sha": "ae46c4e08a8cbb8359203a90e172a78e3263174b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae46c4e08a8cbb8359203a90e172a78e3263174b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae46c4e08a8cbb8359203a90e172a78e3263174b"}], "stats": {"total": 479, "additions": 206, "deletions": 273}, "files": [{"sha": "9b1331f5f2564e422546c09cb60954e2d4c2b23c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5d7a21e006965c06d800141c149cf793aeefe1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5d7a21e006965c06d800141c149cf793aeefe1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d5d7a21e006965c06d800141c149cf793aeefe1", "patch": "@@ -1,3 +1,8 @@\n+2002-05-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.md: Use braced strings instead of quoted strings\n+\tfor code blocks.  Tidy whitespace.\n+\n 2002-05-17  Richard Henderson  <rth@redhat.com>\n \n \t* hooks.c (hook_tree_bool_false): New."}, {"sha": "d81d6ac585fbef8c068c36ce891083a7e5d5eba9", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 201, "deletions": 273, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5d7a21e006965c06d800141c149cf793aeefe1/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5d7a21e006965c06d800141c149cf793aeefe1/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=1d5d7a21e006965c06d800141c149cf793aeefe1", "patch": "@@ -99,8 +99,12 @@\n ;; multiple instructions, patterns which emit 0 instructions, and patterns\n ;; which emit instruction that can go in any slot (e.g. nop).\n \n-(define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,fmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,chk_s,long_i,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,st,syst_m0,syst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop_b,nop_f,nop_i,nop_m,nop_x,lfetch\"\n-         (const_string \"unknown\"))\n+(define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,\n+\tfmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,\n+\tchk_s,long_i,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,st,syst_m0,\n+\tsyst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop_b,nop_f,\n+\tnop_i,nop_m,nop_x,lfetch\"\n+  (const_string \"unknown\"))\n \n ;; chk_s has an I and an M form; use type A for convenience.\n (define_attr \"type\" \"unknown,A,I,M,F,B,L,X,S\"\n@@ -271,12 +275,11 @@\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (QImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movqi_internal\"\n   [(set (match_operand:QI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n@@ -296,12 +299,11 @@\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (HImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n@@ -321,12 +323,11 @@\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (SImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r, m, r,*f,*f, r,*d\")\n@@ -343,14 +344,13 @@\n   mov %0 = %1\n   mov %0 = %1\n   mov %0 = %r1\"\n-;; frar_m, toar_m ??? why not frar_i and toar_i\n+  ;; frar_m, toar_m ??? why not frar_i and toar_i\n   [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,frar_m,toar_m\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n@@ -370,12 +370,13 @@\n       if (rtx_equal_function_value_matters\n \t  && ! (GET_CODE (operands[1]) == SYMBOL_REF\n \t\t&& SYMBOL_REF_FLAG (operands[1])))\n-\temit_insn (gen_movdi_symbolic (operands[0], operands[1], gen_reg_rtx (DImode)));\n+\temit_insn (gen_movdi_symbolic (operands[0], operands[1],\n+\t\t\t\t       gen_reg_rtx (DImode)));\n       else\n         ia64_expand_load_address (operands[0], operands[1], NULL_RTX);\n       DONE;\n     }\n-}\")\n+})\n \n ;; This is used during early compilation to delay the decision on\n ;; how to refer to a variable as long as possible.  This is especially\n@@ -395,67 +396,64 @@\n   \"* abort ();\"\n   \"\"\n   [(const_int 0)]\n-  \"ia64_expand_load_address (operands[0], operands[1], operands[2]); DONE;\")\n+  { ia64_expand_load_address (operands[0], operands[1], operands[2]); DONE; })\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n \t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b, r,*e, r,*d, r,*c\")\n \t(match_operand:DI 1 \"move_operand\"\n \t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO,*e,rK,*d,rK,*c,rO\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n-  \"*\n {\n   static const char * const alt[] = {\n-    \\\"%,mov %0 = %r1\\\",\n-    \\\"%,addl %0 = %1, r0\\\",\n-    \\\"%,movl %0 = %1\\\",\n-    \\\"%,ld8%O1 %0 = %1%P1\\\",\n-    \\\"%,st8%Q0 %0 = %r1%P0\\\",\n-    \\\"%,getf.sig %0 = %1\\\",\n-    \\\"%,setf.sig %0 = %r1\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"%,ldf8 %0 = %1%P1\\\",\n-    \\\"%,stf8 %0 = %1%P0\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"%,mov %0 = %r1\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"%,mov %0 = %1\\\",\n-    \\\"mov %0 = pr\\\",\n-    \\\"mov pr = %1, -1\\\"\n+    \"%,mov %0 = %r1\",\n+    \"%,addl %0 = %1, r0\",\n+    \"%,movl %0 = %1\",\n+    \"%,ld8%O1 %0 = %1%P1\",\n+    \"%,st8%Q0 %0 = %r1%P0\",\n+    \"%,getf.sig %0 = %1\",\n+    \"%,setf.sig %0 = %r1\",\n+    \"%,mov %0 = %1\",\n+    \"%,ldf8 %0 = %1%P1\",\n+    \"%,stf8 %0 = %1%P0\",\n+    \"%,mov %0 = %1\",\n+    \"%,mov %0 = %r1\",\n+    \"%,mov %0 = %1\",\n+    \"%,mov %0 = %1\",\n+    \"%,mov %0 = %1\",\n+    \"%,mov %0 = %1\",\n+    \"mov %0 = pr\",\n+    \"mov pr = %1, -1\"\n   };\n \n   if (which_alternative == 2 && ! TARGET_NO_PIC\n       && symbolic_operand (operands[1], VOIDmode))\n     abort ();\n \n   return alt[which_alternative];\n-}\"\n+}\n   [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_operand:DI 1 \"symbolic_operand\" \"\"))]\n   \"reload_completed && ! TARGET_NO_PIC\"\n   [(const_int 0)]\n-  \"\n {\n   ia64_expand_load_address (operands[0], operands[1], NULL_RTX);\n   DONE;\n-}\")\n+})\n \n (define_expand \"load_fptr\"\n   [(set (match_dup 2)\n \t(plus:DI (reg:DI 1) (match_operand:DI 1 \"function_operand\" \"\")))\n    (set (match_operand:DI 0 \"register_operand\" \"\") (match_dup 3))]\n   \"\"\n-  \"\n {\n   operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);\n   operands[3] = gen_rtx_MEM (DImode, operands[2]);\n   RTX_UNCHANGING_P (operands[3]) = 1;\n-}\")\n+})\n \n (define_insn \"*load_fptr_internal1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -484,23 +482,21 @@\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_dup 3) (match_dup 2)))]\n   \"\"\n-  \"\n {\n   operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);\n   operands[3] = pic_offset_table_rtx;\n-}\")\n+})\n \n (define_expand \"load_symptr\"\n   [(set (match_operand:DI 2 \"register_operand\" \"\")\n \t(plus:DI (match_dup 4) (match_operand:DI 1 \"got_symbolic_operand\" \"\")))\n    (set (match_operand:DI 0 \"register_operand\" \"\") (match_dup 3))]\n   \"\"\n-  \"\n {\n   operands[3] = gen_rtx_MEM (DImode, operands[2]);\n   operands[4] = pic_offset_table_rtx;\n   RTX_UNCHANGING_P (operands[3]) = 1;\n-}\")\n+})\n \n (define_insn \"*load_symptr_internal1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -516,12 +512,11 @@\n \t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n \t      (clobber (match_scratch:DI 2 \"\"))])]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (TImode, operands[1]);\n-}\")\n+})\n \n (define_insn_and_split \"*movti_internal\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n@@ -531,7 +526,6 @@\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx adj1, adj2, in[2], out[2], insn;\n   int first;\n@@ -566,7 +560,7 @@\n \t\t\t\t\t  XEXP (XEXP (out[!first], 0), 0),\n \t\t\t\t\t  REG_NOTES (insn));\n   DONE;\n-}\"\n+}\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -580,7 +574,6 @@\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx in[2], out[2];\n   int first;\n@@ -599,7 +592,7 @@\n   emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));\n   emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -608,26 +601,24 @@\n \t\t   (match_operand:TI 1 \"\" \"m\"))\n \t      (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))])]\n   \"\"\n-  \"\n {\n   unsigned int s_regno = REGNO (operands[2]);\n   if (s_regno == REGNO (operands[0]))\n     s_regno += 1;\n   operands[2] = gen_rtx_REG (DImode, s_regno);\n-}\")\n+})\n \n (define_expand \"reload_outti\"\n   [(parallel [(set (match_operand:TI 0 \"\" \"=m\")\n \t\t   (match_operand:TI 1 \"register_operand\" \"r\"))\n \t      (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))])]\n   \"\"\n-  \"\n {\n   unsigned int s_regno = REGNO (operands[2]);\n   if (s_regno == REGNO (operands[1]))\n     s_regno += 1;\n   operands[2] = gen_rtx_REG (DImode, s_regno);\n-}\")\n+})\n \n ;; Floating Point Moves\n ;;\n@@ -638,52 +629,50 @@\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (SFmode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movsf_internal\"\n   [(set (match_operand:SF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:SF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n-  mov %0 = %F1\n-  ldfs %0 = %1%P1\n-  stfs %0 = %F1%P0\n-  getf.s %0 = %F1\n-  setf.s %0 = %1\n-  mov %0 = %1\n-  ld4%O1 %0 = %1%P1\n-  st4%Q0 %0 = %1%P0\"\n+   mov %0 = %F1\n+   ldfs %0 = %1%P1\n+   stfs %0 = %F1%P0\n+   getf.s %0 = %F1\n+   setf.s %0 = %1\n+   mov %0 = %1\n+   ld4%O1 %0 = %1%P1\n+   st4%Q0 %0 = %1%P0\"\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (DFmode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:DF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n-  mov %0 = %F1\n-  ldfd %0 = %1%P1\n-  stfd %0 = %F1%P0\n-  getf.d %0 = %F1\n-  setf.d %0 = %1\n-  mov %0 = %1\n-  ld8%O1 %0 = %1%P1\n-  st8%Q0 %0 = %1%P0\"\n+   mov %0 = %F1\n+   ldfd %0 = %1%P1\n+   stfd %0 = %F1%P0\n+   getf.d %0 = %F1\n+   setf.d %0 = %1\n+   mov %0 = %1\n+   ld8%O1 %0 = %1%P1\n+   st8%Q0 %0 = %1%P0\"\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")])\n \n ;; With no offsettable memory references, we've got to have a scratch\n@@ -692,7 +681,6 @@\n   [(set (match_operand:TF 0 \"general_operand\" \"\")\n \t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"INTEL_EXTENDED_IEEE_FORMAT\"\n-  \"\n {\n   /* We must support TFmode loads into general registers for stdarg/vararg\n      and unprototyped calls.  We split them into DImode loads for convenience.\n@@ -753,7 +741,7 @@\n       if (! ia64_move_ok (operands[0], operands[1]))\n \toperands[1] = force_reg (TFmode, operands[1]);\n     }\n-}\")\n+})\n \n ;; ??? There's no easy way to mind volatile acquire/release semantics.\n \n@@ -762,9 +750,9 @@\n \t(match_operand:TF 1 \"general_tfmode_operand\"     \"fG,m,fG\"))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n-  mov %0 = %F1\n-  ldfe %0 = %1%P1\n-  stfe %0 = %F1%P0\"\n+   mov %0 = %F1\n+   ldfe %0 = %1%P1\n+   stfe %0 = %F1%P0\"\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n \f\n ;; ::::::::::::::::::::\n@@ -1032,7 +1020,6 @@\n \t\t\t (match_operand:DI 2 \"const_int_operand\" \"\"))\n \t(match_operand:DI 3 \"nonmemory_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   int width = INTVAL (operands[1]);\n   int shift = INTVAL (operands[2]);\n@@ -1100,7 +1087,7 @@\n       operands[2] = GEN_INT (shift);\n #endif\n     }\n-}\")\n+})\n \n (define_insn \"*insv_internal\"\n   [(set (zero_extract:DI (match_operand:DI 0 \"gr_register_operand\" \"+r\")\n@@ -1120,11 +1107,10 @@\n \t\t(match_operand:DI 3 \"const_int_operand\" \"n\")))]\n   \"CONST_OK_FOR_M (INTVAL (operands[2]))\n    && ia64_depz_field_mask (operands[3], operands[2]) > 0\"\n-  \"*\n {\n   operands[3] = GEN_INT (ia64_depz_field_mask (operands[3], operands[2]));\n-  return \\\"%,dep.z %0 = %1, %2, %3\\\";\n-}\"\n+  return \"%,dep.z %0 = %1, %2, %3\";\n+}\n   [(set_attr \"itanium_class\" \"ishf\")])\n \n (define_insn \"shift_mix4left\"\n@@ -1728,9 +1714,9 @@\n \t\t (match_operand:SI 2 \"gr_reg_or_22bit_operand\" \"r,I,J\")))]\n   \"\"\n   \"@\n-  add %0 = %1, %2\n-  adds %0 = %2, %1\n-  addl %0 = %2, %1\"\n+   add %0 = %1, %2\n+   adds %0 = %2, %1\n+   addl %0 = %2, %1\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"*addsi3_plus1\"\n@@ -1810,10 +1796,7 @@\n \t\t\t (neg:SI (match_dup 1))\n \t\t\t (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[2] = gen_reg_rtx (BImode); })\n \n (define_expand \"sminsi3\"\n   [(set (match_dup 3)\n@@ -1823,10 +1806,7 @@\n \t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"smaxsi3\"\n   [(set (match_dup 3)\n@@ -1836,10 +1816,7 @@\n \t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"uminsi3\"\n   [(set (match_dup 3)\n@@ -1849,10 +1826,7 @@\n \t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"umaxsi3\"\n   [(set (match_dup 3)\n@@ -1862,17 +1836,13 @@\n \t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"divsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n \n@@ -1904,14 +1874,13 @@\n   emit_insn (gen_fix_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n   emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n   DONE;\n-}\")\n+})\n \n (define_expand \"modsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op2_neg, op1_di, div;\n \n@@ -1928,14 +1897,13 @@\n   emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n \t\t\t  gen_lowpart (SImode, op1_di)));\n   DONE;\n-}\")\n+})\n \n (define_expand \"udivsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n \n@@ -1967,14 +1935,13 @@\n   emit_insn (gen_fixuns_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n   emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n   DONE;\n-}\")\n+})\n \n (define_expand \"umodsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op2_neg, op1_di, div;\n \n@@ -1991,7 +1958,7 @@\n   emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n \t\t\t  gen_lowpart (SImode, op1_di)));\n   DONE;\n-}\")\n+})\n \n (define_insn_and_split \"divsi3_internal\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n@@ -2047,9 +2014,9 @@\n \t\t (match_operand:DI 2 \"gr_reg_or_22bit_operand\" \"r,I,J\")))]\n   \"\"\n   \"@\n-  add %0 = %1, %2\n-  adds %0 = %2, %1\n-  addl %0 = %2, %1\"\n+   add %0 = %1, %2\n+   adds %0 = %2, %1\n+   addl %0 = %2, %1\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"*adddi3_plus1\"\n@@ -2198,10 +2165,7 @@\n \t\t\t (neg:DI (match_dup 1))\n \t\t\t (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[2] = gen_reg_rtx (BImode); })\n \n (define_expand \"smindi3\"\n   [(set (match_dup 3)\n@@ -2211,10 +2175,7 @@\n \t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"smaxdi3\"\n   [(set (match_dup 3)\n@@ -2224,10 +2185,7 @@\n \t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"umindi3\"\n   [(set (match_dup 3)\n@@ -2237,10 +2195,7 @@\n \t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"umaxdi3\"\n   [(set (match_dup 3)\n@@ -2250,10 +2205,7 @@\n \t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (BImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (BImode); })\n \n (define_expand \"ffsdi2\"\n   [(set (match_dup 6)\n@@ -2266,14 +2218,13 @@\n \t(if_then_else:DI (ne (match_dup 6) (const_int 0))\n \t\t\t (match_dup 5) (match_dup 4)))]\n   \"\"\n-  \"\n {\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n   operands[5] = gen_reg_rtx (DImode);\n   operands[6] = gen_reg_rtx (BImode);\n-}\")\n+})\n \n (define_insn \"*popcnt\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n@@ -2288,7 +2239,6 @@\n \t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op1_tf, op2_tf, op0_tf;\n \n@@ -2311,14 +2261,13 @@\n \n   emit_insn (gen_fix_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"moddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op2_neg, div;\n \n@@ -2329,14 +2278,13 @@\n \n   emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"udivdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op1_tf, op2_tf, op0_tf;\n \n@@ -2359,14 +2307,13 @@\n \n   emit_insn (gen_fixuns_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"umoddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx op2_neg, div;\n \n@@ -2377,7 +2324,7 @@\n \n   emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n   DONE;\n-}\")\n+})\n \n (define_insn_and_split \"divdi3_internal_lat\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n@@ -2598,7 +2545,6 @@\n \t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx insn;\n   if (TARGET_INLINE_DIV_LAT)\n@@ -2607,7 +2553,7 @@\n     insn = gen_divsf3_internal_thr (operands[0], operands[1], operands[2]);\n   emit_insn (insn);\n   DONE;\n-}\")\n+})\n \n (define_insn_and_split \"divsf3_internal_lat\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n@@ -2657,11 +2603,13 @@\n      (set (match_dup 0)\n \t  (float_truncate:SF (match_dup 6))))\n   ] \n-  \"operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n-   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[0]));\n-   operands[10] = CONST1_RTX (TFmode);\"\n+{\n+  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[9] = gen_rtx_REG (DFmode, REGNO (operands[0]));\n+  operands[10] = CONST1_RTX (TFmode);\n+}\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn_and_split \"divsf3_internal_thr\"\n@@ -2709,11 +2657,13 @@\n \t    (plus:TF (mult:TF (match_dup 4) (match_dup 6))\n \t\t\t      (match_dup 3)))))\n   ] \n-  \"operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n-   operands[9] = gen_rtx_REG (SFmode, REGNO (operands[3]));\n-   operands[10] = CONST1_RTX (TFmode);\"\n+{\n+  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[9] = gen_rtx_REG (SFmode, REGNO (operands[3]));\n+  operands[10] = CONST1_RTX (TFmode);\n+}\n   [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n@@ -2904,7 +2854,6 @@\n \t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx insn;\n   if (TARGET_INLINE_DIV_LAT)\n@@ -2913,7 +2862,7 @@\n     insn = gen_divdf3_internal_thr (operands[0], operands[1], operands[2]);\n   emit_insn (insn);\n   DONE;\n-}\")\n+})\n \n (define_insn_and_split \"divdf3_internal_lat\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n@@ -2986,12 +2935,14 @@\n \t  (float_truncate:DF (plus:TF (mult:TF (match_dup 5) (match_dup 7))\n \t\t\t      (match_dup 3)))))\n   ] \n-  \"operands[7] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-   operands[9] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n-   operands[10] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n-   operands[11] = gen_rtx_REG (DFmode, REGNO (operands[5]));\n-   operands[12] = CONST1_RTX (TFmode);\"\n+{\n+  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n+  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n+  operands[9] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[10] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n+  operands[11] = gen_rtx_REG (DFmode, REGNO (operands[5]));\n+  operands[12] = CONST1_RTX (TFmode);\n+}\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn_and_split \"divdf3_internal_thr\"\n@@ -3051,11 +3002,13 @@\n \t  (plus:DF (mult:DF (match_dup 4) (match_dup 0))\n \t\t\t    (match_dup 9))))\n   ] \n-  \"operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n-   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n-   operands[10] = CONST1_RTX (TFmode);\"\n+{\n+  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[9] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n+  operands[10] = CONST1_RTX (TFmode);\n+}\n   [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n@@ -3378,7 +3331,6 @@\n \t(div:TF (match_operand:TF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:TF 2 \"fr_register_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n-  \"\n {\n   rtx insn;\n   if (TARGET_INLINE_DIV_LAT)\n@@ -3387,7 +3339,7 @@\n     insn = gen_divtf3_internal_thr (operands[0], operands[1], operands[2]);\n   emit_insn (insn);\n   DONE;\n-}\")\n+})\n \n (define_insn_and_split \"divtf3_internal_lat\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n@@ -3573,7 +3525,6 @@\n \t(ashift:SI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t   (match_operand:SI 2 \"gr_reg_or_5bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n     {\n@@ -3583,7 +3534,7 @@\n       emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));\n       operands[2] = subshift;\n     }\n-}\")\n+})\n \n (define_insn \"*ashlsi3_internal\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"=r,r,r\")\n@@ -3601,7 +3552,6 @@\n \t(ashiftrt:SI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t     (match_operand:SI 2 \"gr_reg_or_5bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   rtx subtarget = gen_reg_rtx (DImode);\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -3616,14 +3566,13 @@\n     }\n   emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);\n   DONE;\n-}\")\n+})\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"\")\n \t(lshiftrt:SI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t     (match_operand:SI 2 \"gr_reg_or_5bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   rtx subtarget = gen_reg_rtx (DImode);\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -3638,7 +3587,7 @@\n     }\n   emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);\n   DONE;\n-}\")\n+})\n \n ;; Use mix4.r/shr to implement rotrsi3.  We only get 32 bits of valid result\n ;; here, instead of 64 like the patterns above.  Keep the pattern together\n@@ -3649,15 +3598,14 @@\n \t(rotatert:SI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t     (match_operand:SI 2 \"gr_reg_or_5bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (GET_MODE (operands[2]) != VOIDmode)\n     {\n       rtx tmp = gen_reg_rtx (DImode);\n       emit_insn (gen_zero_extendsidi2 (tmp, operands[2]));\n       operands[2] = tmp;\n     }\n-}\")\n+})\n \n (define_insn_and_split \"*rotrsi3_internal\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"=&r\")\n@@ -3678,7 +3626,6 @@\n \t(rotate:SI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t   (match_operand:SI 2 \"gr_reg_or_5bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! shift_32bit_count_operand (operands[2], SImode))\n     {\n@@ -3687,7 +3634,7 @@\n       emit_insn (gen_rotrsi3 (operands[0], operands[1], tmp));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn_and_split \"*rotlsi3_internal\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"=r\")\n@@ -3701,8 +3648,10 @@\n \t\t(ashift:DI (zero_extend:DI (match_dup 1)) (const_int 32))))\n    (set (match_dup 3)\n \t(lshiftrt:DI (match_dup 3) (match_dup 2)))]\n-  \"operands[3] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-   operands[2] = GEN_INT (32 - INTVAL (operands[2]));\")\n+{\n+  operands[3] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+  operands[2] = GEN_INT (32 - INTVAL (operands[2]));\n+})\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3785,11 +3734,10 @@\n \t(rotatert:DI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t\t     (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! shift_count_operand (operands[2], DImode))\n     FAIL;\n-}\")\n+})\n \n (define_insn \"*rotrdi3_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n@@ -3804,11 +3752,10 @@\n \t(rotate:DI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t\t   (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! shift_count_operand (operands[2], DImode))\n     FAIL;\n-}\")\n+})\n \n (define_insn \"*rotldi3_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n@@ -3909,72 +3856,66 @@\n         (compare (match_operand:BI 0 \"register_operand\" \"\")\n   \t\t (match_operand:BI 1 \"const_int_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmpsi\"\n   [(set (cc0)\n         (compare (match_operand:SI 0 \"gr_register_operand\" \"\")\n   \t\t (match_operand:SI 1 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmpdi\"\n   [(set (cc0)\n         (compare (match_operand:DI 0 \"gr_register_operand\" \"\")\n   \t\t (match_operand:DI 1 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmpsf\"\n   [(set (cc0)\n         (compare (match_operand:SF 0 \"fr_reg_or_fp01_operand\" \"\")\n   \t\t (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmpdf\"\n   [(set (cc0)\n         (compare (match_operand:DF 0 \"fr_reg_or_fp01_operand\" \"\")\n   \t\t (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmptf\"\n   [(set (cc0)\n         (compare (match_operand:TF 0 \"tfreg_or_fp01_operand\" \"\")\n   \t\t (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"\")))]\n   \"INTEL_EXTENDED_IEEE_FORMAT\"\n-  \"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n   DONE;\n-}\")\n+})\n \n (define_insn \"*cmpsi_normal\"\n   [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n@@ -4206,15 +4147,14 @@\n    (use (match_operand 3 \"\" \"\"))\t; loop level\n    (use (match_operand 4 \"\" \"\"))]\t; label\n   \"\"\n-  \"\n {\n   /* Only use cloop on innermost loops.  */\n   if (INTVAL (operands[3]) > 1)\n     FAIL;\n   emit_jump_insn (gen_doloop_end_internal (gen_rtx_REG (DImode, AR_LC_REGNUM),\n \t\t\t\t\t   operands[4]));\n   DONE;\n-}\")\n+})\n \n (define_insn \"doloop_end_internal\"\n   [(set (pc) (if_then_else (ne (match_operand:DI 0 \"ar_lc_reg_operand\" \"\")\n@@ -4352,7 +4292,7 @@\n \t   \"rim,rim,rim, rim, *f, *b,*d*e,*f,*b,*d*e,rO,*f,rOQ,rO,  rK\")))]\n   \"ia64_move_ok (operands[0], operands[2])\n    && ia64_move_ok (operands[0], operands[3])\"\n-  \"* abort ();\"\n+  { abort (); }\n   [(set_attr \"predicable\" \"no\")])\n \n (define_split\n@@ -4365,7 +4305,6 @@\n \t  (match_operand 3 \"move_operand\" \"\")))]\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx tmp;\n   if (! rtx_equal_p (operands[0], operands[2]))\n@@ -4384,7 +4323,7 @@\n       emit_insn (tmp);\n     }\n   DONE;\n-}\")\n+})\n \n ;; Absolute value pattern.\n \n@@ -4431,11 +4370,10 @@\n    (cond_exec\n      (match_dup 5)\n      (set (match_dup 0) (match_dup 3)))]\n-  \"\n {\n   operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n \t\t\t\tVOIDmode, operands[1], const0_rtx);\n-}\")\n+})\n \n ;;\n ;; SImode if_then_else patterns.\n@@ -4453,7 +4391,7 @@\n \t\t    \"rim*f,rO,rO,0,0,0,rim*f,rO,rO\")))]\n   \"ia64_move_ok (operands[0], operands[2])\n    && ia64_move_ok (operands[0], operands[3])\"\n-  \"* abort ();\"\n+  { abort (); }\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*abssi2_internal\"\n@@ -4499,11 +4437,10 @@\n    (cond_exec\n      (match_dup 5)\n      (set (match_dup 0) (match_dup 3)))]\n-  \"\n {\n   operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n \t\t\t\tVOIDmode, operands[1], const0_rtx);\n-}\")\n+})\n \n (define_insn_and_split \"*cond_opsi2_internal\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"=r\")\n@@ -4524,11 +4461,10 @@\n    (cond_exec\n      (match_dup 7)\n      (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 3) (match_dup 4)])))]\n-  \"\n {\n   operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[6]) == NE ? EQ : NE,\n \t\t\t\tVOIDmode, operands[1], const0_rtx);\n-}\"\n+}\n   [(set_attr \"itanium_class\" \"ialu\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -4552,11 +4488,10 @@\n    (cond_exec\n      (match_dup 7)\n      (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 4) (match_dup 3)])))]\n-  \"\n {\n   operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[6]) == NE ? EQ : NE,\n \t\t\t\tVOIDmode, operands[1], const0_rtx);\n-}\"\n+}\n   [(set_attr \"itanium_class\" \"ialu\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -4583,23 +4518,21 @@\n    (use (match_operand 2 \"\" \"\"))\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   ia64_expand_call (NULL_RTX, operands[0], operands[2], 0);\n   DONE;\n-}\")\n+})\n \n (define_expand \"sibcall\"\n   [(use (match_operand:DI 0 \"\" \"\"))\n    (use (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"\" \"\"))\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   ia64_expand_call (NULL_RTX, operands[0], operands[2], 1);\n   DONE;\n-}\")\n+})\n \n ;; Subroutine call instruction returning a value.  Operand 0 is the hard\n ;; register in which the value is returned.  There are three more operands,\n@@ -4615,11 +4548,10 @@\n    (use (match_operand 3 \"\" \"\"))\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   ia64_expand_call (operands[0], operands[1], operands[3], 0);\n   DONE;\n-}\")\n+})\n \n (define_expand \"sibcall_value\"\n   [(use (match_operand 0 \"\" \"\"))\n@@ -4628,11 +4560,10 @@\n    (use (match_operand 3 \"\" \"\"))\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   ia64_expand_call (operands[0], operands[1], operands[3], 1);\n   DONE;\n-}\")\n+})\n \n ;; Call subroutine returning any type.\n \n@@ -4642,7 +4573,6 @@\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n   \"\"\n-  \"\n {\n   int i;\n \n@@ -4661,7 +4591,7 @@\n   emit_insn (gen_blockage ());\n \n   DONE;\n-}\")\n+})\n \n (define_insn \"call_nopic\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"b,i\"))\n@@ -4826,29 +4756,26 @@\n (define_expand \"prologue\"\n   [(const_int 1)]\n   \"\"\n-  \"\n {\n   ia64_expand_prologue ();\n   DONE;\n-}\")\n+})\n \n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n-  \"\n {\n   ia64_expand_epilogue (0);\n   DONE;\n-}\")\n+})\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n   \"\"\n-  \"\n {\n   ia64_expand_epilogue (1);\n   DONE;\n-}\")\n+})\n \n ;; This prevents the scheduler from moving the SP decrement past FP-relative\n ;; stack accesses.  This is the same as adddi3 plus the extra set.\n@@ -4861,9 +4788,9 @@\n \t(match_dup 3))]\n   \"\"\n   \"@\n-  add %0 = %1, %2\n-  adds %0 = %2, %1\n-  addl %0 = %2, %1\"\n+   add %0 = %1, %2\n+   adds %0 = %2, %1\n+   addl %0 = %2, %1\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n ;; This prevents the scheduler from moving the SP restore past FP-relative\n@@ -4877,6 +4804,16 @@\n   \"mov %0 = %1\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n+;; As USE insns aren't meaningful after reload, this is used instead\n+;; to prevent deleting instructions setting registers for EH handling\n+(define_insn \"prologue_use\"\n+  [(unspec:DI [(match_operand:DI 0 \"register_operand\" \"\")]\n+\t      UNSPEC_PROLOGUE_USE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"itanium_class\" \"ignore\")\n+   (set_attr \"predicable\" \"no\")])\n+\n ;; Allocate a new register frame.\n \n (define_insn \"alloc\"\n@@ -4908,10 +4845,11 @@\n \t\t   UNSPEC_GR_SPILL))\n    (clobber (match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n-  \"*\n {\n-  return \\\".mem.offset %2, 0\\;%,st8.spill %0 = %1%P0\\\";\n-}\"\n+  /* Note that we use a C output pattern here to avoid the predicate\n+     being automatically added before the .mem.offset directive.  */\n+  return \".mem.offset %2, 0\\;%,st8.spill %0 = %1%P0\";\n+}\n   [(set_attr \"itanium_class\" \"st\")])\n \n ;; Reads ar.unat\n@@ -4931,10 +4869,7 @@\n \t\t   UNSPEC_GR_RESTORE))\n    (use (match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n-  \"*\n-{\n-  return \\\".mem.offset %2, 0\\;%,ld8.fill %0 = %1%P1\\\";\n-}\"\n+  { return \".mem.offset %2, 0\\;%,ld8.fill %0 = %1%P1\"; }\n   [(set_attr \"itanium_class\" \"ld\")])\n \n (define_insn \"fr_spill\"\n@@ -4968,7 +4903,21 @@\n   [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")]\n \t\t    UNSPECV_SET_BSP)]\n   \"\"\n-  \"flushrs\\;mov r19=ar.rsc\\;;;\\;and r19=0x1c,r19\\;;;\\;mov ar.rsc=r19\\;;;\\;mov ar.bspstore=%0\\;;;\\;or r19=0x3,r19\\;;;\\;loadrs\\;invala\\;;;\\;mov ar.rsc=r19\"\n+  \"flushrs\n+\tmov r19=ar.rsc\n+\t;;\n+\tand r19=0x1c,r19\n+\t;;\n+\tmov ar.rsc=r19\n+\t;;\n+\tmov ar.bspstore=%0\n+\t;;\n+\tor r19=0x3,r19\n+\t;;\n+\tloadrs\n+\tinvala\n+\t;;\n+\tmov ar.rsc=r19\"\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -5031,10 +4980,7 @@\n (define_insn \"bundle_selector\"\n   [(unspec [(match_operand 0 \"const_int_operand\" \"\")] UNSPEC_BUNDLE_SELECTOR)]\n   \"\"\n-  \"*\n-{\n-  return get_bundle_name (INTVAL (operands[0]));\n-}\"\n+  { return get_bundle_name (INTVAL (operands[0])); }\n   [(set_attr \"itanium_class\" \"ignore\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -5129,22 +5075,20 @@\n   [(use (match_operand:OI 0 \"memory_operand\" \"\"))\n    (use (match_operand:DI 1 \"register_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t \\\"__ia64_save_stack_nonlocal\\\"),\n \t\t     0, VOIDmode, 2, XEXP (operands[0], 0), Pmode,\n \t\t     operands[1], Pmode);\n   DONE;\n-}\")\n+})\n \n (define_expand \"nonlocal_goto\"\n   [(use (match_operand 0 \"general_operand\" \"\"))\n    (use (match_operand 1 \"general_operand\" \"\"))\n    (use (match_operand 2 \"general_operand\" \"\"))\n    (use (match_operand 3 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \\\"__ia64_nonlocal_goto\\\"),\n \t\t     LCT_NORETURN, VOIDmode, 3,\n@@ -5153,34 +5097,31 @@\n \t\t     operands[3], Pmode);\n   emit_barrier ();\n   DONE;\n-}\")\n+})\n \n ;; The rest of the setjmp processing happens with the nonlocal_goto expander.\n ;; ??? This is not tested.\n (define_expand \"builtin_setjmp_setup\"\n   [(use (match_operand:DI 0 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   emit_move_insn (ia64_gp_save_reg (0), gen_rtx_REG (DImode, GR_REG (1)));\n   DONE;\n-}\")\n+})\n \n (define_expand \"builtin_setjmp_receiver\"\n   [(use (match_operand:DI 0 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   emit_move_insn (gen_rtx_REG (DImode, GR_REG (1)), ia64_gp_save_reg (0));\n   DONE;\n-}\")\n+})\n \n (define_expand \"eh_epilogue\"\n   [(use (match_operand:DI 0 \"register_operand\" \"r\"))\n    (use (match_operand:DI 1 \"register_operand\" \"r\"))\n    (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n   \"\"\n-  \"\n {\n   rtx bsp = gen_rtx_REG (Pmode, 10);\n   rtx sp = gen_rtx_REG (Pmode, 9);\n@@ -5200,22 +5141,21 @@\n \n   cfun->machine->ia64_eh_epilogue_sp = sp;\n   cfun->machine->ia64_eh_epilogue_bsp = bsp;\n-}\")\n+})\n \f\n ;; Builtin apply support.\n \n (define_expand \"restore_stack_nonlocal\"\n   [(use (match_operand:DI 0 \"register_operand\" \"\"))\n    (use (match_operand:OI 1 \"memory_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t \\\"__ia64_restore_stack_nonlocal\\\"),\n+\t\t\t\t\t \"__ia64_restore_stack_nonlocal\"),\n \t\t     0, VOIDmode, 1,\n \t\t     copy_to_reg (XEXP (operands[1], 0)), Pmode);\n   DONE;\n-}\")\n+})\n \n \f\n ;;; Intrinsics support.\n@@ -5224,11 +5164,10 @@\n   [(set (mem:BLK (match_dup 0))\n \t(unspec:BLK [(mem:BLK (match_dup 0))] UNSPEC_MF))]\n   \"\"\n-  \"\n {\n   operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n   MEM_VOLATILE_P (operands[0]) = 1;\n-}\")\n+})\n \n (define_insn \"*mf_internal\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n@@ -5328,11 +5267,10 @@\n (define_insn \"safe_across_calls_normal\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_PSAC_NORMAL)]\n   \"\"\n-  \"*\n {\n   emit_safe_across_calls (asm_out_file);\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"itanium_class\" \"ignore\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -5369,13 +5307,3 @@\n   \"\"\n   \"addp4 %0 = %1, %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n-\n-;; As USE insns aren't meaningful after reload, this is used instead\n-;; to prevent deleting instructions setting registers for EH handling\n-(define_insn \"prologue_use\"\n-  [(unspec:DI [(match_operand:DI 0 \"register_operand\" \"\")]\n-\t      UNSPEC_PROLOGUE_USE)]\n-  \"\"\n-  \"// %0 needed for EH\"\n-  [(set_attr \"itanium_class\" \"ignore\")\n-   (set_attr \"predicable\" \"no\")])"}]}