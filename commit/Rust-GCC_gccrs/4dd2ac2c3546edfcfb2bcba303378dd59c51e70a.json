{"sha": "4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRkMmFjMmMzNTQ2ZWRmY2ZiMmJjYmEzMDMzNzhkZDU5YzUxZTcwYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-24T02:34:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-24T02:34:05Z"}, "message": "i386.c (ix86_frame): New structure.\n\n\t* i386.c (ix86_frame): New structure.\n\t(ix86_compute_frame_size): Kill.\n\t(ix86_compute_frame_layout): New.\n\t(ix86_save_reg): New.\n\t(ix86_can_use_return_insn_p): Use frame layout stuff.\n\t(ix86_expand_prologue): Likewise.\n\t(ix86_expand_epilogue): Likewise.\n\t(ix86_initial_elimination_offset): Likewise.\n\t(ix86_nsaved_regs): Use ix86_save_reg.\n\t(ix86_emit_save_regs): Likewise.\n\nFrom-SVN: r40022", "tree": {"sha": "87ca093f4e992a9915e4888a24355f9d55928c71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87ca093f4e992a9915e4888a24355f9d55928c71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a/comments", "author": null, "committer": null, "parents": [{"sha": "a686dbf86a80b697e84a8ea9a8fa94b281796557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a686dbf86a80b697e84a8ea9a8fa94b281796557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a686dbf86a80b697e84a8ea9a8fa94b281796557"}], "stats": {"total": 294, "additions": 161, "deletions": 133}, "files": [{"sha": "5699d93605ea995c86a2cd8d53e08ffaaee73d44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "patch": "@@ -1,3 +1,16 @@\n+Sat Feb 24 03:32:50 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_frame): New structure.\n+\t(ix86_compute_frame_size): Kill.\n+\t(ix86_compute_frame_layout): New.\n+\t(ix86_save_reg): New.\n+\t(ix86_can_use_return_insn_p): Use frame layout stuff.\n+\t(ix86_expand_prologue): Likewise.\n+\t(ix86_expand_epilogue): Likewise.\n+\t(ix86_initial_elimination_offset): Likewise.\n+\t(ix86_nsaved_regs): Use ix86_save_reg.\n+\t(ix86_emit_save_regs): Likewise.\n+\n Sat Feb 24 03:30:38 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (find_sub_basic_blocks): New function."}, {"sha": "e90cc0da6c1a33ac692a5e72b21155047aa75080", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 148, "deletions": 133, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd2ac2c3546edfcfb2bcba303378dd59c51e70a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4dd2ac2c3546edfcfb2bcba303378dd59c51e70a", "patch": "@@ -402,6 +402,40 @@ struct machine_function\n \n #define ix86_stack_locals (cfun->machine->stack_locals)\n \n+/* Structure describing stack frame layout.\n+   Stack grows downward:\n+\n+   [arguments]\n+\t\t\t\t\t      <- ARG_POINTER\n+   saved pc\n+\n+   saved frame pointer if frame_pointer_needed\n+\t\t\t\t\t      <- HARD_FRAME_POINTER\n+   [saved regs]\n+\n+   [padding1]          \\\n+\t\t        )\n+   [va_arg registers]  (\n+\t\t        > to_allocate\t      <- FRAME_POINTER\n+   [frame]\t       (\n+\t\t        )\n+   [padding2]\t       /\n+  */\n+struct ix86_frame\n+{\n+  int nregs;\n+  int padding1;\n+  HOST_WIDE_INT frame;\n+  int padding2;\n+  int outgoing_arguments_size;\n+\n+  HOST_WIDE_INT to_allocate;\n+  /* The offsets relative to ARG_POINTER.  */\n+  HOST_WIDE_INT frame_pointer_offset;\n+  HOST_WIDE_INT hard_frame_pointer_offset;\n+  HOST_WIDE_INT stack_pointer_offset;\n+};\n+\n /* which cpu are we scheduling for */\n enum processor_type ix86_cpu;\n \n@@ -469,8 +503,6 @@ static void ix86_mark_machine_status PARAMS ((struct function *));\n static void ix86_free_machine_status PARAMS ((struct function *));\n static int ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n-static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT,\n-\t\t\t\t\t\t     int *, int *, int *));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int));\n@@ -508,6 +540,8 @@ static int ix86_fp_comparison_arithmetics_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_fcomi_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_sahf_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_cost PARAMS ((enum rtx_code code));\n+static int ix86_save_reg PARAMS ((int));\n+static void ix86_compute_frame_layout PARAMS ((struct ix86_frame *));\n \f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -1667,8 +1701,7 @@ symbolic_reference_mentioned_p (op)\n int\n ix86_can_use_return_insn_p ()\n {\n-  HOST_WIDE_INT tsize;\n-  int nregs;\n+  struct ix86_frame frame;\n \n #ifdef NON_SAVING_SETJMP\n   if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n@@ -1688,8 +1721,8 @@ ix86_can_use_return_insn_p ()\n       && current_function_args_size >= 32768)\n     return 0;\n \n-  tsize = ix86_compute_frame_size (get_frame_size (), &nregs, NULL, NULL);\n-  return tsize == 0 && nregs == 0;\n+  ix86_compute_frame_layout (&frame);\n+  return frame.to_allocate == 0 && frame.nregs == 0;\n }\n \n /* Value should be nonzero if functions must have frame pointers.\n@@ -1817,24 +1850,31 @@ gen_push (arg)\n \t\t      arg);\n }\n \n+/* Return 1 if we need to save REGNO.  */\n+static int\n+ix86_save_reg (regno)\n+\tint regno;\n+{\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  return ((regs_ever_live[regno] && !call_used_regs[regno]\n+\t   && !fixed_regs[regno]\n+\t   && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+\t  || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used));\n+\n+}\n+\n /* Return number of registers to be saved on the stack.  */\n \n static int\n ix86_nsaved_regs ()\n {\n   int nregs = 0;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n-  int limit = (frame_pointer_needed\n-\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n   int regno;\n \n-  for (regno = limit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      {\n-\tnregs ++;\n-      }\n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n+    if (ix86_save_reg (regno))\n+      nregs++;\n   return nregs;\n }\n \n@@ -1846,82 +1886,46 @@ ix86_initial_elimination_offset (from, to)\n      int from;\n      int to;\n {\n-  int padding1;\n-  int nregs;\n-\n-  /* Stack grows downward:\n-\n-     [arguments]\n-\t\t\t\t\t\t<- ARG_POINTER\n-     saved pc\n-\n-     saved frame pointer if frame_pointer_needed\n-\t\t\t\t\t\t<- HARD_FRAME_POINTER\n-     [saved regs]\n-\n-     [padding1]   \\\n-\t\t   |\t\t\t\t<- FRAME_POINTER\n-     [frame]\t   > tsize\n-\t\t   |\n-     [padding2]   /\n-    */\n+  struct ix86_frame frame;\n+  ix86_compute_frame_layout (&frame);\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    /* Skip saved PC and previous frame pointer.\n-       Executed only when frame_pointer_needed.  */\n-    return 8;\n+    return frame.hard_frame_pointer_offset;\n   else if (from == FRAME_POINTER_REGNUM\n \t   && to == HARD_FRAME_POINTER_REGNUM)\n-    {\n-      ix86_compute_frame_size (get_frame_size (), &nregs, &padding1, (int *) 0);\n-      padding1 += nregs * UNITS_PER_WORD;\n-      return -padding1;\n-    }\n+    return frame.hard_frame_pointer_offset - frame.frame_pointer_offset;\n   else\n     {\n-      /* ARG_POINTER or FRAME_POINTER to STACK_POINTER elimination.  */\n-      int frame_size = frame_pointer_needed ? 8 : 4;\n-      HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\n-\t\t\t\t\t\t     &nregs, &padding1, (int *) 0);\n-\n       if (to != STACK_POINTER_REGNUM)\n \tabort ();\n       else if (from == ARG_POINTER_REGNUM)\n-\treturn tsize + nregs * UNITS_PER_WORD + frame_size;\n+\treturn frame.stack_pointer_offset;\n       else if (from != FRAME_POINTER_REGNUM)\n \tabort ();\n       else\n-\treturn tsize - padding1;\n+\treturn frame.stack_pointer_offset - frame.frame_pointer_offset;\n     }\n }\n \n-/* Compute the size of local storage taking into consideration the\n-   desired stack alignment which is to be maintained.  Also determine\n-   the number of registers saved below the local storage.\n+/* Fill structure ix86_frame about frame of currently computed function.  */\n \n-   PADDING1 returns padding before stack frame and PADDING2 returns\n-   padding after stack frame;\n- */\n-\n-static HOST_WIDE_INT\n-ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n-     HOST_WIDE_INT size;\n-     int *nregs_on_stack;\n-     int *rpadding1;\n-     int *rpadding2;\n+static void\n+ix86_compute_frame_layout (frame)\n+     struct ix86_frame *frame;\n {\n-  int nregs;\n-  int padding1 = 0;\n-  int padding2 = 0;\n   HOST_WIDE_INT total_size;\n   int stack_alignment_needed = cfun->stack_alignment_needed / BITS_PER_UNIT;\n   int offset;\n   int preferred_alignment = cfun->preferred_stack_boundary / BITS_PER_UNIT;\n+  HOST_WIDE_INT size = get_frame_size ();\n \n-  nregs = ix86_nsaved_regs ();\n+  frame->nregs = ix86_nsaved_regs ();\n   total_size = size;\n \n-  offset = frame_pointer_needed ? 8 : 4;\n+  /* Skip return value and save base pointer.  */\n+  offset = frame_pointer_needed ? UNITS_PER_WORD * 2 : UNITS_PER_WORD;\n+\n+  frame->hard_frame_pointer_offset = offset;\n \n   /* Do some sanity checking of stack_alignment_needed and\n      preferred_alignment, since i386 port is the only using those features\n@@ -1936,36 +1940,58 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n   if (stack_alignment_needed > PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n     abort ();\n \n-  if (stack_alignment_needed < 4)\n-    stack_alignment_needed = 4;\n+  if (stack_alignment_needed < STACK_BOUNDARY / BITS_PER_UNIT)\n+    stack_alignment_needed = STACK_BOUNDARY / BITS_PER_UNIT;\n \n-  offset += nregs * UNITS_PER_WORD;\n+  /* Register save area */\n+  offset += frame->nregs * UNITS_PER_WORD;\n \n-  if (ACCUMULATE_OUTGOING_ARGS)\n-    total_size += current_function_outgoing_args_size;\n+  /* Align start of frame for local function.  */\n+  frame->padding1 = ((offset + stack_alignment_needed - 1)\n+\t\t     & -stack_alignment_needed) - offset;\n \n-  total_size += offset;\n+  offset += frame->padding1;\n \n-  /* Align start of frame for local function.  */\n-  padding1 = ((offset + stack_alignment_needed - 1)\n-\t      & -stack_alignment_needed) - offset;\n-  total_size += padding1;\n+  /* Frame pointer points here.  */\n+  frame->frame_pointer_offset = offset;\n \n-  /* Align stack boundary.  */\n-  padding2 = ((total_size + preferred_alignment - 1)\n-\t      & -preferred_alignment) - total_size;\n+  offset += size;\n \n+  /* Add outgoing arguments area.  */\n   if (ACCUMULATE_OUTGOING_ARGS)\n-    padding2 += current_function_outgoing_args_size;\n-\n-  if (nregs_on_stack)\n-    *nregs_on_stack = nregs;\n-  if (rpadding1)\n-    *rpadding1 = padding1;\n-  if (rpadding2)\n-    *rpadding2 = padding2;\n+    {\n+      offset += current_function_outgoing_args_size;\n+      frame->outgoing_arguments_size = current_function_outgoing_args_size;\n+    }\n+  else\n+    frame->outgoing_arguments_size = 0;\n \n-  return size + padding1 + padding2;\n+  /* Align stack boundary.  */\n+  frame->padding2 = ((offset + preferred_alignment - 1)\n+\t\t     & -preferred_alignment) - offset;\n+\n+  offset += frame->padding2;\n+\n+  /* We've reached end of stack frame.  */\n+  frame->stack_pointer_offset = offset;\n+\n+  /* Size prologue needs to allocate.  */\n+  frame->to_allocate =\n+    (size + frame->padding1 + frame->padding2\n+     + frame->outgoing_arguments_size);\n+\n+#if 0\n+  fprintf (stderr, \"nregs: %i\\n\", frame->nregs);\n+  fprintf (stderr, \"size: %i\\n\", size);\n+  fprintf (stderr, \"alignment1: %i\\n\", stack_alignment_needed);\n+  fprintf (stderr, \"padding1: %i\\n\", frame->padding1);\n+  fprintf (stderr, \"padding2: %i\\n\", frame->padding2);\n+  fprintf (stderr, \"to_allocate: %i\\n\", frame->to_allocate);\n+  fprintf (stderr, \"frame_pointer_offset: %i\\n\", frame->frame_pointer_offset);\n+  fprintf (stderr, \"hard_frame_pointer_offset: %i\\n\",\n+\t   frame->hard_frame_pointer_offset);\n+  fprintf (stderr, \"stack_pointer_offset: %i\\n\", frame->stack_pointer_offset);\n+#endif\n }\n \n /* Emit code to save registers in the prologue.  */\n@@ -1974,16 +2000,10 @@ static void\n ix86_emit_save_regs ()\n {\n   register int regno;\n-  int limit;\n   rtx insn;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n-  limit = (frame_pointer_needed\n-\t   ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n \n-  for (regno = limit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n+    if (ix86_save_reg (regno))\n       {\n \tinsn = emit_insn (gen_push (gen_rtx_REG (SImode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -1995,11 +2015,12 @@ ix86_emit_save_regs ()\n void\n ix86_expand_prologue ()\n {\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *) 0,\n-\t\t\t\t\t\t (int *) 0, (int *) 0);\n   rtx insn;\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n+  struct ix86_frame frame;\n+\n+  ix86_compute_frame_layout (&frame);\n \n   /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n      slower on all targets.  Also sdb doesn't like it.  */\n@@ -2015,17 +2036,17 @@ ix86_expand_prologue ()\n \n   ix86_emit_save_regs ();\n \n-  if (tsize == 0)\n+  if (frame.to_allocate == 0)\n     ;\n-  else if (! TARGET_STACK_PROBE || tsize < CHECK_STACK_LIMIT)\n+  else if (! TARGET_STACK_PROBE || frame.to_allocate < CHECK_STACK_LIMIT)\n     {\n       if (frame_pointer_needed)\n \tinsn = emit_insn (gen_pro_epilogue_adjust_stack\n \t\t\t  (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t           GEN_INT (-tsize), hard_frame_pointer_rtx));\n+\t\t           GEN_INT (-frame.to_allocate), hard_frame_pointer_rtx));\n       else\n         insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (-tsize)));\n+\t\t\t\t      GEN_INT (-frame.to_allocate)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n@@ -2035,7 +2056,7 @@ ix86_expand_prologue ()\n       rtx arg0, sym;\n \n       arg0 = gen_rtx_REG (SImode, 0);\n-      emit_move_insn (arg0, GEN_INT (tsize));\n+      emit_move_insn (arg0, GEN_INT (frame.to_allocate));\n \n       sym = gen_rtx_MEM (FUNCTION_MODE,\n \t\t\t gen_rtx_SYMBOL_REF (Pmode, \"_alloca\"));\n@@ -2087,20 +2108,15 @@ ix86_emit_restore_regs_using_mov (pointer, offset)\n \tint offset;\n {\n   int regno;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n-  int limit = (frame_pointer_needed\n-\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n \n-  for (regno = 0; regno < limit; regno++)\n-    if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (ix86_save_reg (regno))\n       {\n-\temit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\tadj_offsettable_operand (gen_rtx_MEM (SImode,\n+\temit_move_insn (gen_rtx_REG (Pmode, regno),\n+\t\t\tadj_offsettable_operand (gen_rtx_MEM (Pmode,\n \t\t\t\t\t\t\t      pointer),\n \t\t\t\t\t\t offset));\n-\toffset += 4;\n+\toffset += UNITS_PER_WORD;\n       }\n }\n \n@@ -2110,18 +2126,15 @@ void\n ix86_expand_epilogue (emit_return)\n      int emit_return;\n {\n-  int nregs;\n   int regno;\n-\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n+  struct ix86_frame frame;\n   HOST_WIDE_INT offset;\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs,\n-\t\t\t\t\t\t (int *) 0, (int *) 0);\n+\n+  ix86_compute_frame_layout (&frame);\n \n   /* Calculate start of saved registers relative to ebp.  */\n-  offset = -nregs * UNITS_PER_WORD;\n+  offset = -frame.nregs * UNITS_PER_WORD;\n \n #ifdef FUNCTION_BLOCK_PROFILER_EXIT\n   if (profile_block_flag == 2)\n@@ -2140,24 +2153,25 @@ ix86_expand_epilogue (emit_return)\n      are no registers to restore.  We also use this code when TARGET_USE_LEAVE\n      and there is exactly one register to pop. This heruistic may need some\n      tuning in future.  */\n-  if ((!sp_valid && nregs <= 1)\n-      || (frame_pointer_needed && !nregs && tsize)\n+  if ((!sp_valid && frame.nregs <= 1)\n+      || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE && !optimize_size\n-\t  && nregs == 1))\n+\t  && frame.nregs == 1))\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n \t locations.  If both are available, default to ebp, since offsets\n \t are known to be small.  Only exception is esp pointing directly to the\n \t end of block of saved registers, where we may simplify addressing\n \t mode.  */\n \n-      if (!frame_pointer_needed || (sp_valid && !tsize))\n-\tix86_emit_restore_regs_using_mov (stack_pointer_rtx, tsize);\n+      if (!frame_pointer_needed || (sp_valid && !frame.to_allocate))\n+\tix86_emit_restore_regs_using_mov (stack_pointer_rtx, frame.to_allocate);\n       else\n \tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx, offset);\n \n       if (!frame_pointer_needed)\n-\tix86_emit_epilogue_esp_adjustment (tsize + nregs * UNITS_PER_WORD);\n+\tix86_emit_epilogue_esp_adjustment (frame.to_allocate\n+\t\t\t\t\t   + frame.nregs * UNITS_PER_WORD);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_size)\n \temit_insn (gen_leave ());\n@@ -2183,13 +2197,14 @@ ix86_expand_epilogue (emit_return)\n \t\t\t\t\t\t    GEN_INT (offset),\n \t\t\t\t\t\t    hard_frame_pointer_rtx));\n \t}\n-      else if (tsize)\n-\tix86_emit_epilogue_esp_adjustment (tsize);\n+      else if (frame.to_allocate)\n+\tix86_emit_epilogue_esp_adjustment (frame.to_allocate);\n \n-      for (regno = 0; regno < STACK_POINTER_REGNUM; regno++)\n-\tif ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (ix86_save_reg (regno))\n \t  emit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n+      if (frame_pointer_needed)\n+\temit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */"}]}