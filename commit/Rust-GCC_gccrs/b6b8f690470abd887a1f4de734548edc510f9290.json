{"sha": "b6b8f690470abd887a1f4de734548edc510f9290", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZiOGY2OTA0NzBhYmQ4ODdhMWY0ZGU3MzQ1NDhlZGM1MTBmOTI5MA==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2003-11-19T12:02:11Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-11-19T12:02:11Z"}, "message": "FlatteningPathIterator.java: Entirely re-written.\n\n2003-11-19  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/FlatteningPathIterator.java: Entirely re-written.\n\t* java/awt/geom/doc-files/FlatteningPathIterator-1.html:\n\tDescribe how the implementation works.\n\nFrom-SVN: r73734", "tree": {"sha": "cef7d50742f7b5bcf27c9b376c2e4b564d0d1d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef7d50742f7b5bcf27c9b376c2e4b564d0d1d04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6b8f690470abd887a1f4de734548edc510f9290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b8f690470abd887a1f4de734548edc510f9290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b8f690470abd887a1f4de734548edc510f9290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b8f690470abd887a1f4de734548edc510f9290/comments", "author": null, "committer": null, "parents": [{"sha": "1f33554abb31ee66b0b61be508d91d1cafdc4b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f33554abb31ee66b0b61be508d91d1cafdc4b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f33554abb31ee66b0b61be508d91d1cafdc4b0b"}], "stats": {"total": 1013, "additions": 987, "deletions": 26}, "files": [{"sha": "ef79f94e5b6693deb1a8ce1b36531a6d4df09146", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b6b8f690470abd887a1f4de734548edc510f9290", "patch": "@@ -1,3 +1,9 @@\n+2003-11-19  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/FlatteningPathIterator.java: Entirely re-written.\n+\t* java/awt/geom/doc-files/FlatteningPathIterator-1.html:\n+\tDescribe how the implementation works.\n+\n 2003-11-19  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/Socket.java"}, {"sha": "94ff145621b49bab46af0322cccd3cec59a5f12a", "filename": "libjava/java/awt/geom/FlatteningPathIterator.java", "status": "modified", "additions": 500, "deletions": 26, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2Fjava%2Fawt%2Fgeom%2FFlatteningPathIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2Fjava%2Fawt%2Fgeom%2FFlatteningPathIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FFlatteningPathIterator.java?ref=b6b8f690470abd887a1f4de734548edc510f9290", "patch": "@@ -1,5 +1,5 @@\n-/* FlatteningPathIterator.java -- performs interpolation of curved paths\n-   Copyright (C) 2002 Free Software Foundation\n+/* FlatteningPathIterator.java -- Approximates curves by straight lines\n+   Copyright (C) 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -38,68 +38,542 @@\n \n package java.awt.geom;\n \n+import java.util.NoSuchElementException;\n+\n+\n /**\n- * This class can be used to perform the flattening required by the Shape\n- * interface. It interpolates a curved path segment into a sequence of flat\n- * ones within a certain flatness, up to a recursion limit.\n+ * A PathIterator for approximating curved path segments by sequences\n+ * of straight lines. Instances of this class will only return\n+ * segments of type {@link PathIterator#SEG_MOVETO}, {@link\n+ * PathIterator#SEG_LINETO}, and {@link PathIterator#SEG_CLOSE}.\n+ *\n+ * <p>The accuracy of the approximation is determined by two\n+ * parameters:\n+ *\n+ * <ul><li>The <i>flatness</i> is a threshold value for deciding when\n+ * a curved segment is consided flat enough for being approximated by\n+ * a single straight line. Flatness is defined as the maximal distance\n+ * of a curve control point to the straight line that connects the\n+ * curve start and end. A lower flatness threshold means a closer\n+ * approximation.  See {@link QuadCurve2D#getFlatness()} and {@link\n+ * CubicCurve2D#getFlatness()} for drawings which illustrate the\n+ * meaning of flatness.</li>\n+ *\n+ * <li>The <i>recursion limit</i> imposes an upper bound for how often\n+ * a curved segment gets subdivided. A limit of <i>n</i> means that\n+ * for each individual quadratic and cubic B&#xe9;zier spline\n+ * segment, at most 2<sup><small><i>n</i></small></sup> {@link\n+ * PathIterator#SEG_LINETO} segments will be created.</li></ul>\n+ *\n+ * <p><b>Memory Efficiency:</b> The memory consumption grows linearly\n+ * with the recursion limit. Neither the <i>flatness</i> parameter nor\n+ * the number of segments in the flattened path will affect the memory\n+ * consumption.\n+ *\n+ * <p><b>Thread Safety:</b> Multiple threads can safely work on\n+ * separate instances of this class. However, multiple threads should\n+ * not concurrently access the same instance, as no synchronization is\n+ * performed.\n+ *\n+ * @see <a href=\"doc-files/FlatteningPathIterator-1.html\"\n+ * >Implementation Note</a>\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  *\n- * @author Eric Blake <ebb9@email.byu.edu>\n- * @see Shape\n- * @see RectangularShape#getPathIterator(AffineTransform, double)\n  * @since 1.2\n- * @status STUBS ONLY\n  */\n-public class FlatteningPathIterator implements PathIterator\n+public class FlatteningPathIterator\n+  implements PathIterator\n {\n-  // The iterator we are applied to.\n-  private PathIterator subIterator;\n-  private double flatness;\n-  private int limit;\n+  /**\n+   * The PathIterator whose curved segments are being approximated.\n+   */\n+  private final PathIterator srcIter;\n+\n+\n+  /**\n+   * The square of the flatness threshold value, which determines when\n+   * a curve segment is considered flat enough that no further\n+   * subdivision is needed.\n+   *\n+   * <p>Calculating flatness actually produces the squared flatness\n+   * value. To avoid the relatively expensive calculation of a square\n+   * root for each curve segment, we perform all flatness comparisons\n+   * on squared values.\n+   *\n+   * @see QuadCurve2D#getFlatnessSq()\n+   * @see CubicCurve2D#getFlatnessSq()\n+   */\n+  private final double flatnessSq;\n+\n+\n+  /**\n+   * The maximal number of subdivions that are performed to\n+   * approximate a quadratic or cubic curve segment.\n+   */\n+  private final int recursionLimit;\n+\n+\n+  /**\n+   * A stack for holding the coordinates of subdivided segments.\n+   *\n+   * @see <a href=\"doc-files/FlatteningPathIterator-1.html\"\n+   * >Implementation Note</a>\n+   */\n+  private double[] stack;\n+\n+\n+  /**\n+   * The current stack size.\n+   *\n+   * @see <a href=\"doc-files/FlatteningPathIterator-1.html\"\n+   * >Implementation Note</a>\n+   */\n+  private int stackSize;\n+\n+\n+  /**\n+   * The number of recursions that were performed to arrive at\n+   * a segment on the stack.\n+   *\n+   * @see <a href=\"doc-files/FlatteningPathIterator-1.html\"\n+   * >Implementation Note</a>\n+   */\n+  private int[] recLevel;\n+\n+  \n+  \n+  private final double[] scratch = new double[6];\n+\n+\n+  /**\n+   * The segment type of the last segment that was returned by\n+   * the source iterator.\n+   */\n+  private int srcSegType;\n+\n \n+  /**\n+   * The current <i>x</i> position of the source iterator.\n+   */\n+  private double srcPosX;\n+\n+\n+  /**\n+   * The current <i>y</i> position of the source iterator.\n+   */\n+  private double srcPosY;\n+\n+\n+  /**\n+   * A flag that indicates when this path iterator has finished its\n+   * iteration over path segments.\n+   */\n+  private boolean done;\n+\n+\n+  /**\n+   * Constructs a new PathIterator for approximating an input\n+   * PathIterator with straight lines. The approximation works by\n+   * recursive subdivisons, until the specified flatness threshold is\n+   * not exceeded.\n+   *\n+   * <p>There will not be more than 10 nested recursion steps, which\n+   * means that a single <code>SEG_QUADTO</code> or\n+   * <code>SEG_CUBICTO</code> segment is approximated by at most\n+   * 2<sup><small>10</small></sup> = 1024 straight lines.\n+   */\n   public FlatteningPathIterator(PathIterator src, double flatness)\n   {\n     this(src, flatness, 10);\n   }\n-  public FlatteningPathIterator(PathIterator src, double flatness, int limit)\n+\n+\n+  /**\n+   * Constructs a new PathIterator for approximating an input\n+   * PathIterator with straight lines. The approximation works by\n+   * recursive subdivisons, until the specified flatness threshold is\n+   * not exceeded.  Additionally, the number of recursions is also\n+   * bound by the specified recursion limit.\n+   */\n+  public FlatteningPathIterator(PathIterator src, double flatness,\n+                                int limit)\n   {\n-    subIterator = src;\n-    this.flatness = flatness;\n-    this.limit = limit;\n     if (flatness < 0 || limit < 0)\n       throw new IllegalArgumentException();\n+\n+    srcIter = src;\n+    flatnessSq = flatness * flatness;\n+    recursionLimit = limit;\n+    fetchSegment();\n   }\n \n+\n+  /**\n+   * Returns the maximally acceptable flatness.\n+   *\n+   * @see QuadCurve2D#getFlatness()\n+   * @see CubicCurve2D#getFlatness()\n+   */\n   public double getFlatness()\n   {\n-    return flatness;\n+    return Math.sqrt(flatnessSq);\n   }\n \n+\n+  /**\n+   * Returns the maximum number of recursive curve subdivisions.\n+   */\n   public int getRecursionLimit()\n   {\n-    return limit;\n+    return recursionLimit;\n   }\n \n+\n+  // Documentation will be copied from PathIterator.\n   public int getWindingRule()\n   {\n-    return subIterator.getWindingRule();\n+    return srcIter.getWindingRule();\n   }\n \n+\n+  // Documentation will be copied from PathIterator.\n   public boolean isDone()\n   {\n-    return subIterator.isDone();\n+    return done;\n   }\n \n+\n+  // Documentation will be copied from PathIterator.\n   public void next()\n   {\n-    throw new Error(\"not implemented\");\n+    if (stackSize > 0)\n+    {\n+      --stackSize;\n+      if (stackSize > 0)\n+      {\n+        switch (srcSegType)\n+        {\n+        case PathIterator.SEG_QUADTO:\n+          subdivideQuadratic();\n+          return;\n+\n+        case PathIterator.SEG_CUBICTO:\n+          subdivideCubic();\n+          return;\n+\n+        default:\n+          throw new IllegalStateException();\n+        }\n+      }\n+    }\n+\n+    srcIter.next();\n+    fetchSegment();\n   }\n \n+\n+  // Documentation will be copied from PathIterator.\n   public int currentSegment(double[] coords)\n   {\n-    throw new Error(\"not implemented\");\n+    if (done)\n+      throw new NoSuchElementException();\n+\n+    switch (srcSegType)\n+    {\n+    case PathIterator.SEG_CLOSE:\n+      return srcSegType;\n+\n+    case PathIterator.SEG_MOVETO:\n+    case PathIterator.SEG_LINETO:\n+      coords[0] = srcPosX;\n+      coords[1] = srcPosY;\n+      return srcSegType;\n+\n+    case PathIterator.SEG_QUADTO:\n+      if (stackSize == 0)\n+      {\n+        coords[0] = srcPosX;\n+        coords[1] = srcPosY;\n+      }\n+      else\n+      {\n+        int sp = stack.length - 4 * stackSize;\n+        coords[0] = stack[sp + 2];\n+        coords[1] = stack[sp + 3];\n+      }\n+      return PathIterator.SEG_LINETO;\n+\n+    case PathIterator.SEG_CUBICTO:\n+      if (stackSize == 0)\n+      {\n+        coords[0] = srcPosX;\n+        coords[1] = srcPosY;\n+      }\n+      else\n+      {\n+        int sp = stack.length - 6 * stackSize;\n+        coords[0] = stack[sp + 4];\n+        coords[1] = stack[sp + 5];\n+      }\n+      return PathIterator.SEG_LINETO;\n+    }\n+\n+    throw new IllegalStateException();\n   }\n+\n+\n+  // Documentation will be copied from PathIterator.\n   public int currentSegment(float[] coords)\n   {\n-    throw new Error(\"not implemented\");\n+    if (done)\n+      throw new NoSuchElementException();\n+\n+    switch (srcSegType)\n+    {\n+    case PathIterator.SEG_CLOSE:\n+      return srcSegType;\n+\n+    case PathIterator.SEG_MOVETO:\n+    case PathIterator.SEG_LINETO:\n+      coords[0] = (float) srcPosX;\n+      coords[1] = (float) srcPosY;\n+      return srcSegType;\n+\n+    case PathIterator.SEG_QUADTO:\n+      if (stackSize == 0)\n+      {\n+        coords[0] = (float) srcPosX;\n+        coords[1] = (float) srcPosY;\n+      }\n+      else\n+      {\n+        int sp = stack.length - 4 * stackSize;\n+        coords[0] = (float) stack[sp + 2];\n+        coords[1] = (float) stack[sp + 3];\n+      }\n+      return PathIterator.SEG_LINETO;\n+\n+    case PathIterator.SEG_CUBICTO:\n+      if (stackSize == 0)\n+      {\n+        coords[0] = (float) srcPosX;\n+        coords[1] = (float) srcPosY;\n+      }\n+      else\n+      {\n+        int sp = stack.length - 6 * stackSize;\n+        coords[0] = (float) stack[sp + 4];\n+        coords[1] = (float) stack[sp + 5];\n+      }\n+      return PathIterator.SEG_LINETO;\n+    }\n+\n+    throw new IllegalStateException();\n+  }\n+\n+\n+  /**\n+   * Fetches the next segment from the source iterator.\n+   */\n+  private void fetchSegment()\n+  {\n+    int sp;\n+\n+    if (srcIter.isDone())\n+    {\n+      done = true;\n+      return;\n+    }\n+\n+    srcSegType = srcIter.currentSegment(scratch);\n+    \n+    switch (srcSegType)\n+    {\n+    case PathIterator.SEG_CLOSE:\n+      return;\n+\n+    case PathIterator.SEG_MOVETO:\n+    case PathIterator.SEG_LINETO:\n+      srcPosX = scratch[0];\n+      srcPosY = scratch[1];\n+      return;\n+\n+    case PathIterator.SEG_QUADTO:\n+      if (recursionLimit == 0)\n+      {\n+        srcPosX = scratch[2];\n+        srcPosY = scratch[3];\n+        stackSize = 0;\n+        return;\n+      }\n+      sp = 4 * recursionLimit;\n+      stackSize = 1;\n+      if (stack == null)\n+      {\n+        stack = new double[sp + /* 4 + 2 */ 6];\n+        recLevel = new int[recursionLimit + 1];\n+      }\n+      recLevel[0] = 0;\n+      stack[sp] = srcPosX;                  // P1.x\n+      stack[sp + 1] = srcPosY;              // P1.y\n+      stack[sp + 2] = scratch[0];           // C.x\n+      stack[sp + 3] = scratch[1];           // C.y\n+      srcPosX = stack[sp + 4] = scratch[2]; // P2.x\n+      srcPosY = stack[sp + 5] = scratch[3]; // P2.y\n+      subdivideQuadratic();\n+      break;\n+\n+    case PathIterator.SEG_CUBICTO:\n+      if (recursionLimit == 0)\n+      {\n+        srcPosX = scratch[4];\n+        srcPosY = scratch[5];\n+        stackSize = 0;\n+        return;\n+      }\n+      sp = 6 * recursionLimit;\n+      stackSize = 1;\n+      if ((stack == null) || (stack.length < sp + 8))\n+      {\n+        stack = new double[sp + /* 6 + 2 */ 8];\n+        recLevel = new int[recursionLimit + 1];\n+      }\n+      recLevel[0] = 0;\n+      stack[sp] = srcPosX;                  // P1.x\n+      stack[sp + 1] = srcPosY;              // P1.y\n+      stack[sp + 2] = scratch[0];           // C1.x\n+      stack[sp + 3] = scratch[1];           // C1.y\n+      stack[sp + 4] = scratch[2];           // C2.x\n+      stack[sp + 5] = scratch[3];           // C2.y\n+      srcPosX = stack[sp + 6] = scratch[4]; // P2.x\n+      srcPosY = stack[sp + 7] = scratch[5]; // P2.y\n+      subdivideCubic();\n+      return;\n+    }\n+  }\n+\n+\n+  /**\n+   * Repeatedly subdivides the quadratic curve segment that is on top\n+   * of the stack. The iteration terminates when the recursion limit\n+   * has been reached, or when the resulting segment is flat enough.\n+   */\n+  private void subdivideQuadratic()\n+  {\n+    int sp;\n+    int level;\n+\n+    sp = stack.length - 4 * stackSize - 2;\n+    level = recLevel[stackSize - 1];\n+    while ((level < recursionLimit)\n+           && (QuadCurve2D.getFlatnessSq(stack, sp) >= flatnessSq))\n+    {\n+      recLevel[stackSize] = recLevel[stackSize - 1] = ++level;\n+      QuadCurve2D.subdivide(stack, sp, stack, sp - 4, stack, sp);\n+      ++stackSize;\n+      sp -= 4;\n+    }\n+  }\n+\n+\n+  /**\n+   * Repeatedly subdivides the cubic curve segment that is on top\n+   * of the stack. The iteration terminates when the recursion limit\n+   * has been reached, or when the resulting segment is flat enough.\n+   */\n+  private void subdivideCubic()\n+  {\n+    int sp;\n+    int level;\n+\n+    sp = stack.length - 6 * stackSize - 2;\n+    level = recLevel[stackSize - 1];\n+    while ((level < recursionLimit)\n+           && (CubicCurve2D.getFlatnessSq(stack, sp) >= flatnessSq))\n+    {\n+      recLevel[stackSize] = recLevel[stackSize - 1] = ++level;\n+      \n+      CubicCurve2D.subdivide(stack, sp, stack, sp - 6, stack, sp);\n+      ++stackSize;\n+      sp -= 6;\n+    }\n   }\n-} // class FlatteningPathIterator\n+\n+\n+  /* These routines were useful for debugging. Since they would\n+   * just bloat the implementation, they are commented out.\n+   *\n+   *\n+\n+  private static String segToString(int segType, double[] d, int offset)\n+  {\n+    String s;\n+\n+    switch (segType)\n+    {\n+    case PathIterator.SEG_CLOSE:\n+      return \"SEG_CLOSE\";\n+\n+    case PathIterator.SEG_MOVETO:\n+      return \"SEG_MOVETO (\" + d[offset] + \", \" + d[offset + 1] + \")\";\n+\n+    case PathIterator.SEG_LINETO:\n+      return \"SEG_LINETO (\" + d[offset] + \", \" + d[offset + 1] + \")\";\n+\n+    case PathIterator.SEG_QUADTO:\n+      return \"SEG_QUADTO (\" + d[offset] + \", \" + d[offset + 1]\n+        + \") (\" + d[offset + 2] + \", \" + d[offset + 3] + \")\";\n+\n+    case PathIterator.SEG_CUBICTO:\n+      return \"SEG_CUBICTO (\" + d[offset] + \", \" + d[offset + 1]\n+        + \") (\" + d[offset + 2] + \", \" + d[offset + 3]\n+        + \") (\" + d[offset + 4] + \", \" + d[offset + 5] + \")\";\n+    }\n+\n+    throw new IllegalStateException();\n+  }\n+\n+\n+  private void dumpQuadraticStack(String msg)\n+  {\n+    int sp = stack.length - 4 * stackSize - 2;\n+    int i = 0;\n+    System.err.print(\"    \" + msg + \":\");\n+    while (sp < stack.length)\n+    {\n+      System.err.print(\" (\" + stack[sp] + \", \" + stack[sp+1] + \")\");\n+      if (i < recLevel.length)\n+        System.out.print(\"/\" + recLevel[i++]);\n+      if (sp + 3 < stack.length)\n+        System.err.print(\" [\" + stack[sp+2] + \", \" + stack[sp+3] + \"]\");\n+      sp += 4;\n+    }\n+    System.err.println();\n+  }\n+\n+\n+  private void dumpCubicStack(String msg)\n+  {\n+    int sp = stack.length - 6 * stackSize - 2;\n+    int i = 0;\n+    System.err.print(\"    \" + msg + \":\");\n+    while (sp < stack.length)\n+    {\n+      System.err.print(\" (\" + stack[sp] + \", \" + stack[sp+1] + \")\");\n+      if (i < recLevel.length)\n+        System.out.print(\"/\" + recLevel[i++]);\n+      if (sp + 3 < stack.length)\n+      {\n+        System.err.print(\" [\" + stack[sp+2] + \", \" + stack[sp+3] + \"]\");\n+        System.err.print(\" [\" + stack[sp+4] + \", \" + stack[sp+5] + \"]\");\n+      }\n+      sp += 6;\n+    }\n+    System.err.println();\n+  }\n+\n+  *\n+  *\n+  */\n+}"}, {"sha": "5a52d693edd582824fb97422d1d92571834644fc", "filename": "libjava/java/awt/geom/doc-files/FlatteningPathIterator-1.html", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FFlatteningPathIterator-1.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b8f690470abd887a1f4de734548edc510f9290/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FFlatteningPathIterator-1.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FFlatteningPathIterator-1.html?ref=b6b8f690470abd887a1f4de734548edc510f9290", "patch": "@@ -0,0 +1,481 @@\n+<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n+<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n+  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n+<head>\n+  <title>The GNU Implementation of java.awt.geom.FlatteningPathIterator</title>\n+  <meta name=\"author\" content=\"Sascha Brawer\" />\n+  <style type=\"text/css\"><!--\n+    td { white-space: nowrap; }\n+    li { margin: 2mm 0; }\n+  --></style>\n+</head>\n+<body>\n+\n+<h1>The GNU Implementation of FlatteningPathIterator</h1>\n+\n+<p><i><a href=\"http://www.dandelis.ch/people/brawer/\">Sascha\n+Brawer</a>, November 2003</i></p>\n+\n+<p>This document describes the GNU implementation of the class\n+<code>java.awt.geom.FlatteningPathIterator</code>. It does\n+<em>not</em> describe how a programmer should use this class; please\n+refer to the generated API documentation for this purpose. Instead, it\n+is intended for maintenance programmers who want to understand the\n+implementation, for example because they want to extend the class or\n+fix a bug.</p>\n+\n+\n+<h2>Data Structures</h2>\n+\n+<p>The algorithm uses a stack. Its allocation is delayed to the time\n+when the source path iterator actually returns the first curved\n+segment (either <code>SEG_QUADTO</code> or <code>SEG_CUBICTO</code>).\n+If the input path does not contain any curved segments, the value of\n+the <code>stack</code> variable stays <code>null</code>. In this quite\n+common case, the memory consumption is minimal.</p>\n+\n+<dl><dt><code>stack</code></dt><dd>The variable <code>stack</code> is\n+a <code>double</code> array that holds the start, control and end\n+points of individual sub-segments.</dd>\n+\n+<dt><code>recLevel</code></dt><dd>The variable <code>recLevel</code>\n+holds how many recursive sub-divisions were needed to calculate a\n+segment. The original curve has recursion level 0. For each\n+sub-division, the corresponding recursion level is increased by\n+one.</dd>\n+\n+<dt><code>stackSize</code></dt><dd>Finally, the variable\n+<code>stackSize</code> indicates how many sub-segments are stored on\n+the stack.</dd></dl>\n+\n+<h2>Algorithm</h2>\n+\n+<p>The implementation separately processes each segment that the\n+base iterator returns.</p>\n+\n+<p>In the case of <code>SEG_CLOSE</code>,\n+<code>SEG_MOVETO</code> and <code>SEG_LINETO</code> segments, the\n+implementation simply hands the segment to the consumer, without actually\n+doing anything.</p>\n+\n+<p>Any <code>SEG_QUADTO</code> and <code>SEG_CUBICTO</code> segments\n+need to be flattened. Flattening is performed with a fixed-sized\n+stack, holding the coordinates of subdivided segments. When the base\n+iterator returns a <code>SEG_QUADTO</code> and\n+<code>SEG_CUBICTO</code> segments, it is recursively flattened as\n+follows:</p>\n+\n+<ol><li>Intialization: Allocate memory for the stack (unless a\n+sufficiently large stack has been allocated previously). Push the\n+original quadratic or cubic curve onto the stack. Mark that segment as\n+having a <code>recLevel</code> of zero.</li>\n+\n+<li>If the stack is empty, flattening the segment is complete,\n+and the next segment is fetched from the base iterator.</li>\n+\n+<li>If the stack is not empty, pop a curve segment from the\n+stack.\n+\n+  <ul><li>If its <code>recLevel</code> exceeds the recursion limit,\n+  hand the current segment to the consumer.</li>\n+\n+  <li>Calculate the squared flatness of the segment. If it smaller\n+  than <code>flatnessSq</code>, hand the current segment to the\n+  consumer.</li>\n+\n+  <li>Otherwise, split the segment in two halves. Push the right\n+  half onto the stack. Then, push the left half onto the stack.\n+  Continue with step two.</li></ul></li>\n+</ol>\n+\n+<p>The implementation is slightly complicated by the fact that\n+consumers <em>pull</em> the flattened segments from the\n+<code>FlatteningPathIterator</code>. This means that we actually\n+cannot &#x201c;hand the curent segment over to the consumer.&#x201d;\n+But the algorithm is easier to understand if one assumes a\n+<em>push</em> paradigm.</p>\n+\n+\n+<h2>Example</h2>\n+\n+<p>The following example shows how a\n+<code>FlatteningPathIterator</code> processes a\n+<code>SEG_QUADTO</code> segment. It is (arbitrarily) assumed that the\n+recursion limit was set to 2.</p>\n+\n+<blockquote>\n+<table border=\"1\" cellspacing=\"0\" cellpadding=\"8\">\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th></th><th>A</th><th>B</th><th>C</th>\n+    <th>D</th><th>E</th><th>F</th><th>G</th><th>H</th>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[0]</code></th>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>ll</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[1]</code></th>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>ll</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[2]</code></th>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>ll</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[3]</code></th>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>ll</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[4]</code></th>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>l</sub>.x</i></td>\n+    <td><i>E<sub>ll</sub>.x</i>\n+             = <i>S<sub>lr</sub>.x</i></td>\n+    <td><i>S<sub>lr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>rl</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[5]</code></th>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>l</sub>.y</i></td>\n+    <td><i>E<sub>ll</sub>.x</i>\n+             = <i>S<sub>lr</sub>.y</i></td>\n+    <td><i>S<sub>lr</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td><i>S<sub>rl</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[6]</code></th>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>l</sub>.x</i></td>\n+    <td><i>C<sub>lr</sub>.x</i></td>\n+    <td><i>C<sub>lr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>rl</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[7]</code></th>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>l</sub>.y</i></td>\n+    <td><i>C<sub>lr</sub>.y</i></td>\n+    <td><i>C<sub>lr</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td><i>C<sub>rl</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[8]</code></th>\n+    <td><i>S.x</i></td>\n+    <td><i>E<sub>l</sub>.x</i>\n+             = <i>S<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>lr</sub>.x</i>\n+             = <i>S<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>lr</sub>.x</i>\n+             = <i>S<sub>r</sub>.x</i></td>\n+    <td><i>S<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>rl</sub>.x</i>\n+             = <i>S<sub>rr</sub>.x</i></td>\n+    <td><i>S<sub>rr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[9]</code></th>\n+    <td><i>S.y</i></td>\n+    <td><i>E<sub>l</sub>.y</i>\n+             = <i>S<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>lr</sub>.y</i>\n+             = <i>S<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>lr</sub>.y</i>\n+             = <i>S<sub>r</sub>.y</i></td>\n+    <td><i>S<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>rl</sub>.y</i>\n+             = <i>S<sub>rr</sub>.y</i></td>\n+    <td><i>S<sub>rr</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[10]</code></th>\n+    <td><i>C.x</i></td>\n+    <td><i>C<sub>r</sub>.x</i></td>\n+    <td><i>C<sub>r</sub>.x</i></td>\n+    <td><i>C<sub>r</sub>.x</i></td>\n+    <td><i>C<sub>r</sub>.x</i></td>\n+    <td><i>C<sub>rr</sub>.x</i></td>\n+    <td><i>C<sub>rr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[11]</code></th>\n+    <td><i>C.y</i></td>\n+    <td><i>C<sub>r</sub>.y</i></td>\n+    <td><i>C<sub>r</sub>.y</i></td>\n+    <td><i>C<sub>r</sub>.y</i></td>\n+    <td><i>C<sub>r</sub>.y</i></td>\n+    <td><i>C<sub>rr</sub>.y</i></td>\n+    <td><i>C<sub>rr</sub>.y</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[12]</code></th>\n+    <td><i>E.x</i></td>\n+    <td><i>E<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>r</sub>.x</i></td>\n+    <td><i>E<sub>rr</sub>.x</i></td>\n+    <td><i>E<sub>rr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+    <th><code>stack[13]</code></th>\n+    <td><i>E.y</i></td>\n+    <td><i>E<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>r</sub>.y</i></td>\n+    <td><i>E<sub>rr</sub>.y</i></td>\n+    <td><i>E<sub>rr</sub>.x</i></td>\n+    <td>&#x2014;</td>\n+  </tr>\n+  <tr align=\"center\" valign=\"baseline\">\n+     <th><code>stackSize</code></th>\n+     <td>1</td>\n+     <td>2</td>\n+     <td>3</td>\n+     <td>2</td>\n+     <td>1</td>\n+     <td>2</td>\n+     <td>1</td>\n+     <td>0</td>\n+   </tr>\n+   <tr align=\"center\" valign=\"baseline\">\n+     <th><code>recLevel[2]</code></th>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+     <td>2</td>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+   </tr>\n+   <tr align=\"center\" valign=\"baseline\">\n+     <th><code>recLevel[1]</code></th>\n+     <td>&#x2014;</td>\n+     <td>1</td>\n+     <td>2</td>\n+     <td>2</td>\n+     <td>&#x2014;</td>\n+     <td>2</td>\n+     <td>&#x2014;</td>\n+     <td>&#x2014;</td>\n+   </tr>\n+   <tr align=\"center\" valign=\"baseline\">\n+     <th><code>recLevel[0]</code></th>\n+     <td>0</td>\n+     <td>1</td>\n+     <td>1</td>\n+     <td>1</td>\n+     <td>1</td>\n+     <td>2</td>\n+     <td>2</td>\n+     <td>&#x2014;</td>\n+   </tr>\n+ </table>\n+</blockquote>\n+\n+<ol>\n+\n+<li>The data structures are initialized as follows.\n+   \n+<ul><li>The segment&#x2019;s end point <i>E</i>, control point\n+<i>C</i>, and start point <i>S</i> are pushed onto the stack.</li>\n+   \n+  <li>Currently, the curve in the stack would be approximated by one\n+  single straight line segment (<i>S</i> &#x2013; <i>E</i>).\n+  Therefore, <code>stackSize</code> is set to 1.</li>\n+   \n+  <li>This single straight line segment is approximating the original\n+  curve, which can be seen as the result of zero recursive\n+  splits. Therefore, <code>recLevel[0]</code> is set to\n+  zero.</li></ul>\n+   \n+Column A shows the state after the initialization step.</li>\n+   \n+<li>The algorithm proceeds by taking the topmost curve segment\n+(<i>S</i> &#x2013; <i>C</i> &#x2013; <i>E</i>) from the stack.\n+   \n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[0]</code>) is zero, which is smaller than\n+  the limit 2.</li>\n+   \n+  <li>The method <code>java.awt.geom.QuadCurve2D.getFlatnessSq</code>\n+  is called to calculate the squared flatness.</li>\n+   \n+  <li>For the sake of argument, we assume that the squared flatness is\n+  exceeding the threshold stored in <code>flatnessSq</code>. Thus, the\n+  curve segment <i>S</i> &#x2013; <i>C</i> &#x2013; <i>E</i> gets\n+  subdivided into a left and a right half, namely\n+  <i>S<sub>l</sub></i> &#x2013; <i>C<sub>l</sub></i> &#x2013;\n+  <i>E<sub>l</sub></i> and <i>S<sub>r</sub></i> &#x2013;\n+  <i>C<sub>r</sub></i> &#x2013; <i>E<sub>r</sub></i>. Both halves are\n+  pushed onto the stack, so the left half is now on top.\n+   \n+  <br />&nbsp;<br />The left half starts at the same point\n+  as the original curve, so <i>S<sub>l</sub></i> has the same\n+  coordinates as <i>S</i>.  Similarly, the end point of the right\n+  half and of the original curve are identical\n+  (<i>E<sub>r</sub></i> = <i>E</i>).  More interestingly, the left\n+  half ends where the right half starts. Because\n+  <i>E<sub>l</sub></i> = <i>S<sub>r</sub></i>, their coordinates need\n+  to be stored only once, which amounts to saving 16 bytes (two\n+  <code>double</code> values) for each iteration.</li></ul>\n+\n+Column B shows the state after the first iteration.</li>\n+\n+<li>Again, the topmost curve segment (<i>S<sub>l</sub></i>\n+&#x2013; <i>C<sub>l</sub></i> &#x2013; <i>E<sub>l</sub></i>) is\n+taken from the stack.\n+\n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[1]</code>) is 1, which is smaller than\n+  the limit 2.</li>\n+   \n+  <li>The method <code>java.awt.geom.QuadCurve2D.getFlatnessSq</code>\n+  is called to calculate the squared flatness.</li>\n+\n+  <li>Assuming that the segment is still not considered\n+  flat enough, it gets subdivided into a left\n+  (<i>S<sub>ll</sub></i> &#x2013; <i>C<sub>ll</sub></i> &#x2013;\n+  <i>E<sub>ll</sub></i>) and a right (<i>S<sub>lr</sub></i>\n+  &#x2013; <i>C<sub>lr</sub></i> &#x2013; <i>E<sub>lr</sub></i>)\n+  half.</li></ul>\n+\n+Column C shows the state after the second iteration.</li>\n+ \n+<li>The topmost curve segment (<i>S<sub>ll</sub></i> &#x2013;\n+<i>C<sub>ll</sub></i> &#x2013; <i>E<sub>ll</sub></i>) is popped from\n+the stack.\n+\n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[2]</code>) is 2, which is <em>not</em> smaller than\n+  the limit 2. Therefore, a <code>SEG_LINETO</code> (from\n+  <i>S<sub>ll</sub></i> to <i>E<sub>ll</sub></i>) is passed to the\n+  consumer.</li></ul>\n+\n+  The new state is shown in column D.</li>\n+\n+\n+<li>The topmost curve segment (<i>S<sub>lr</sub></i> &#x2013;\n+<i>C<sub>lr</sub></i> &#x2013; <i>E<sub>lr</sub></i>) is popped from\n+the stack.\n+\n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[1]</code>) is 2, which is <em>not</em> smaller than\n+  the limit 2. Therefore, a <code>SEG_LINETO</code> (from\n+  <i>S<sub>lr</sub></i> to <i>E<sub>lr</sub></i>) is passed to the\n+  consumer.</li></ul>\n+\n+  The new state is shown in column E.</li>\n+\n+<li>The algorithm proceeds by taking the topmost curve segment\n+(<i>S<sub>r</sub></i> &#x2013; <i>C<sub>r</sub></i> &#x2013;\n+<i>E<sub>r</sub></i>) from the stack.\n+   \n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[0]</code>) is 1, which is smaller than\n+  the limit 2.</li>\n+  \n+  <li>The method <code>java.awt.geom.QuadCurve2D.getFlatnessSq</code>\n+  is called to calculate the squared flatness.</li>\n+   \n+  <li>For the sake of argument, we again assume that the squared\n+  flatness is exceeding the threshold stored in\n+  <code>flatnessSq</code>. Thus, the curve segment\n+  (<i>S<sub>r</sub></i> &#x2013; <i>C<sub>r</sub></i> &#x2013;\n+  <i>E<sub>r</sub></i>) is subdivided into a left and a right half,\n+  namely\n+  <i>S<sub>rl</sub></i> &#x2013; <i>C<sub>rl</sub></i> &#x2013;\n+  <i>E<sub>rl</sub></i> and <i>S<sub>rr</sub></i> &#x2013;\n+  <i>C<sub>rr</sub></i> &#x2013; <i>E<sub>rr</sub></i>. Both halves\n+  are pushed onto the stack.</li></ul>\n+\n+  The new state is shown in column F.</li>\n+\n+<li>The topmost curve segment (<i>S<sub>rl</sub></i> &#x2013;\n+<i>C<sub>rl</sub></i> &#x2013; <i>E<sub>rl</sub></i>) is popped from\n+the stack.\n+\n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[2]</code>) is 2, which is <em>not</em> smaller than\n+  the limit 2. Therefore, a <code>SEG_LINETO</code> (from\n+  <i>S<sub>rl</sub></i> to <i>E<sub>rl</sub></i>) is passed to the\n+  consumer.</li></ul>\n+\n+  The new state is shown in column G.</li>\n+\n+<li>The topmost curve segment (<i>S<sub>rr</sub></i> &#x2013;\n+<i>C<sub>rr</sub></i> &#x2013; <i>E<sub>rr</sub></i>) is popped from\n+the stack.\n+\n+  <ul><li>The recursion level of this segment (stored in\n+  <code>recLevel[2]</code>) is 2, which is <em>not</em> smaller than\n+  the limit 2. Therefore, a <code>SEG_LINETO</code> (from\n+  <i>S<sub>rr</sub></i> to <i>E<sub>rr</sub></i>) is passed to the\n+  consumer.</li></ul>\n+\n+  The new state is shown in column H.</li>\n+\n+<li>The stack is now empty. The FlatteningPathIterator will fetch the\n+next segment from the base iterator, and process it.</li>\n+\n+</ol>\n+\n+<p>In order to split the most recently pushed segment, the\n+<code>subdivideQuadratic()</code> method passes <code>stack</code>\n+directly to\n+<code>QuadCurve2D.subdivide(double[],int,double[],int,double[],int)</code>.\n+Because the stack grows towards the beginning of the array, no data\n+needs to be copied around: <code>subdivide</code> will directly store\n+the result into the stack, which will have the contents shown to the\n+right.</p>\n+\n+</body>\n+</html>"}]}