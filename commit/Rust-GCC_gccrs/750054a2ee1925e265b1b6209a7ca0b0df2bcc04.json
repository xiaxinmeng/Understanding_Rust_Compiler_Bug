{"sha": "750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwMDU0YTJlZTE5MjVlMjY1YjFiNjIwOWE3Y2EwYjBkZjJiY2MwNA==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@apple.com", "date": "2004-04-09T19:57:47Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2004-04-09T19:57:47Z"}, "message": "basic-block.h (struct edge_def): Add new field, crossing_edge.\n\n2004-04-09  Caroline Tice  <ctice@apple.com>\n\n        * basic-block.h (struct edge_def):  Add new field, crossing_edge.\n        (struct basic_block_def):  Add new field, partition.\n        (UNPARTITIONED, HOT_PARTITION, COLD_PARTITION):  New constant macro\n        definitions.\n        (partition_hot_cold_basic_blocks): Add extern function\n        declaration.\n        * bb-reorder.c (function.h, obstack.h, expr.h, regs.h):  Add four new\n        include statements.\n        (N_ROUNDS): Increase the maximum number of rounds by 1.\n        (branch_threshold): Add array value for new round.\n        (exec_threshold): Add array value for new round.\n        (push_to_next_round_p): New function.\n        (add_unlikely_executed_notes): New function.\n        (find_rarely_executed_basic_blocks_and_crossing_edges): New function.\n        (mark_bb_for_unlikely_executed_section): New function.\n        (add_labels_and_missing_jumps): New function.\n        (add_reg_crossing_jump_notes): New function.\n        (fix_up_fall_thru_edges): New function.\n        (find_jump_block): New function.\n        (fix_crossing_conditional_branches): New function.\n        (fix_crossing_unconditional_branches): New function.\n        (fix_edges_for_rarely_executed_code): New function.\n        (partition_hot_cold_basic_blocks): New function.\n        (find_traces):  Add an extra round for partitioning hot/cold\n        basic blocks.\n        (find_traces_1_round): Add a parameter.  Modify to push all cold blocks,\n        and only cold blocks, into the last (extra) round of collecting traces.\n        (better_edge_p): Add a parameter.  Modify to favor non-crossing edges\n        over crossing edges.\n        (bb_to_key):  Add code to correctly identify cold blocks when\n        doing partitioning.\n        (connect_traces): Modify to connect all the non-cold traces first, then\n        go back and connect up all the cold traces.\n        (reorder_basic_blocks):  Add call to add_unlikely_executed_notes.\n        * cfg.c (entry_exit_blocks): Add initialization for partition field in\n        entry and exit blocks.\n        * cfgbuild.c (make_edges): Update current_function_has_computed_jump\n        if we are doing hot/cold partitioning.\n        * cfgcleanup.c (cfglayout.h): Add new include statement.\n        (try_simplify_condjump): Modify to not attempt on blocks with jumps\n        that cross section boundaries.\n        (try_forward_edges): Likewise.\n        (merge_blocks_move_predecessor_nojumps): Likewise.\n        (merge_blocks_move_successor_nojumps): Likewise.\n        (merge_blocks_move): Likewise.\n        (try_crossjump_to_edge): Modify to not attempt after we have done\n        the block partitioning.\n        (try_crossjump_bb): Modify to not attempt on blocks with jumps that\n        cross section boundaries.\n        (try_optimize_cfg): Likewise.\n        * cfghooks.c (tidy_fallthru_edges): Modify to not remove indirect\n        jumps that cross section boundaries.\n        * cfglayout.c (flags.h): Add new include statement.\n        (update_unlikely_executed_notes):  New function.\n        (fixup_reorder_chain):  Add code so when a new jumping basic block is\n        added, it's UNLIKELY_EXECUTED_CODE and REG_CROSSING_JUMP notes are\n        updated appropriately.\n        (duplicate_insn_chain):  Add code to duplicate the new NOTE insn\n        introduced by this optimization.\n        * cfglayout.h (scan_ahead_for_unlikely_executed_note):  Add new\n        extern function declaration.\n        * cfgrtl.c (can_delete_note_p):  Add NOTE_INSN_UNLIKELY_EXECUTED_CODE to\n        list of notes that can be deleted.\n        (create_basic_block_structure):  Add initialization for partition field.\n        (rtl_can_merge_blocks):  Modify to test blocks for jumps that cross\n        section boundaries.\n        (try_redirect_by_replacing_jump):  Modify to not attempt on jumps that\n        cross section boundaries.\n        (commit_one_edge_insertion): Add code so newly created basic block\n        ends up in correct (hot or cold) section.  Modify to disallow\n        insertions before NOTE_INSN_UNLIKELY_EXECUTED_CODE notes.\n        (rtl_verify_flow_info_1):  Add code to verify that no fall_thru edge\n        crosses section boundaries.\n        (cfg_layout_can_merge_blocks_p): Modify to test blocks for jumps that\n        cross section boundaries.\n        (force_nonfallthru_and_redirect): Modify to make sure new basic block\n        ends up in correct section, with correct notes attached.\n        * common.opt (freorder-blocks-and-partition):  Add new flag for this\n        optimization.\n        * dbxout.c (dbx_function_end):  Add code to make sure scope labels at\n        the end of functions are written into the correct (hot or cold)\n        section.\n        (dbx_source_file): Add code so writing debug file information\n        doesn't incorrectly change sections.\n        * defaults.h (NORMAL_TEXT_SECTION_NAME): New constant macro, for use\n        in partitioning hot/cold basic blocks into separate sections.\n        (SECTION_FORMAT_STRING): New constant macro, for linux/i386 hot/cold\n        section partitioning.\n        (HAS_LONG_COND_BRANCH): New constant macro, indicating whether or not\n        conditional branches can span all of memory.\n        (HAS_LONG_UNCOND_BRANCH): New constant macro, indicationg whether or not\n        unconditional branches can span all of memory.\n        * final.c (scan_ahead_for_unlikely_executed_note):  New function.\n        (final_scan_insn):  Add code to check for NOTE instruction indicating\n        whether basic block belongs in hot or cold section, and to make sure\n        the current basic block is being written to the appropriate section.\n        Also added code to ensure that jump table basic blocks end up in the\n        correct section.\n        * flags.h (flag_reorder_blocks_and_partition):  New flag.\n        * ifcvt.c (find_if_case_1):  Modify to not attempt if conversion if\n        one of the branches has a jump that crosses between sections.\n        (find_if_case_2): Likewise.\n        (ifcvt): Modify to not attempt to mark loop exit edges after\n        hot/cold partitioning has occurred.\n        * opts.c (decode_options): Code to handle new flag,\n        flag_reorder_blocks_and_partition; also to turn it off if\n        flag_exceptions is on.\n        (common_handle_option): Code to handle new flag,\n        flag_reorder_blocks_and_partition.\n        * output.h (unlikely_text_section): New extern function declaration.\n        (in_unlikely_text_section): New extern function declaration.\n        * passes.c (rest_of_handle_stack_regs):  Add\n        flag_reorder_blocks_and_partition as an 'or' condition for calling\n        reorder_basic_blocks.\n        (rest_of_handle_reorder_blocks):  Add flag_reorder_blocks_and_partition\n        as an 'or' condition for calling reorder_basic_blocks.\n        (rest_of_compilation):  Add call to partition_hot_cold_basic_blocks.\n        * print-rtl.c (print_rtx): Add code for handling new note,\n        NOTE_INSN_UNLIKELY_EXECUTED_CODE\n        * rtl.c  (NOTE_INSN_UNLIKELY_EXECUTED_CODE): New note insn (see below).\n        (REG_CROSSING_JUMP): New kind of reg_note, to mark jumps that\n        cross between section boundaries.\n        * rtl.h (NOTE_INSN_UNLIKELY_EXECUTED_CODE):  New note instruction,\n        indicating the basic block containing it belongs in the cold section.\n        (REG_CROSSING_JUMP): New type of reg_note, to mark jumps that cross\n        between hot and cold sections.\n        * toplev.c (flag_reorder_blocks_and_partition):  Add code to\n        initialize this flag, and to tie it to the command-line option\n        freorder-blocks-and-partition.\n        * varasm.c (cfglayout.h):  Add new include statement.\n        (unlikely_section_label_printed):  New global variable, used for\n        determining when to output section name labels for cold sections.\n        (in_section):  Add in_unlikely_executed_text to enum data structure.\n        (text_section):  Modify code to use SECTION_FORMAT_STRING and\n        NORMAL_TEXT_SECTION_NAME macros.\n        (unlikely_text_section):  New function.\n        (in_unlikely_text_section):  New function.\n        (function_section):  Add code to make sure beginning of function is\n        written into correct section (hot or cold).\n        (assemble_start_function):  Add code to make sure stuff is written to\n        the correct section.\n        (assemble_zeros):  Add in_unlikely_text_section as an 'or' condition\n        to an if statement that was checking 'in_text_section'.\n        (assemble_variable):  Add 'in_unlikely_text_section' as an 'or'\n        condition to an if statement that was checking 'in_text_section'.\n        (default_section_type_flags_1):  Add check: if in cold section\n        flags = SECTION_CODE.\n        * config/darwin.c (darwin_asm_named_section):  Modify to use\n        SECTION_FORMAT_STRING if we are partitioning hot/cold blocks.\n        * config/i386/i386.h (HAS_LONG_COND_BRANCH): Defined this macro\n        specifically for the i386.\n        (HAS_LONG_UNCOND_BRANCH):  Defined this macro specifically for the i386.\n        * config/rs6000/darwin.h (UNLIKELY_EXECUTED_TEXT_SECTION_NAME): Change\n        text string to something more informative.\n        (NORMAL_TEXT_SECTION_NAME): Add new definition.\n        (SECTION_FORMAT_STRING):  Add new definition.\n        * config/rs6000/rs6000.c (rs6000_assemble_integer):  Add\n        '!in_unlikely_text_section' as an 'and' condition to an if statement\n        that was already checking '!in_text_section'.\n        * config/rs6000/sysv4.h (HOT_TEXT_SECTION_NAME,NORMAL_TEXT_SECTION_NAME,\n        UNLIKELY_EXECUTED_TEXT_SECTION_NAME,SECTION_FORMAT_STRING): Make\n        sure these are properly defined for linux on ppc.\n        * doc/invoke.texi  (freorder-blocks-and-partition): Add documentation\n        for this new flag.\n        * doc/rtl.texi (REG_CROSSING_JUMP):  Add documentation for new\n        reg_note.\n        * doc/tm.texi (NORMAL_TEXT_SECTION_NAME, SECTION_FORMAT_STRING,\n        HAS_LONG_COND_BRANCH, HAS_LONG_UNCOND_BRANCH): Add documentation for\n        these new macros.\n\nFrom-SVN: r80564", "tree": {"sha": "08448cb08b26ca1a0048bc5685984f053bff36b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08448cb08b26ca1a0048bc5685984f053bff36b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/comments", "author": null, "committer": null, "parents": [{"sha": "d770b996d29f752c3a85b90cb82c878c4352f65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d770b996d29f752c3a85b90cb82c878c4352f65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d770b996d29f752c3a85b90cb82c878c4352f65b"}], "stats": {"total": 1698, "additions": 1659, "deletions": 39}, "files": [{"sha": "abbb5b63161fa4e956eb6601539d859c47a5f689", "filename": "gcc/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -1,3 +1,175 @@\n+2004-04-09  Caroline Tice  <ctice@apple.com>\n+\n+        * basic-block.h (struct edge_def):  Add new field, crossing_edge.\n+\t(struct basic_block_def):  Add new field, partition.\n+\t(UNPARTITIONED, HOT_PARTITION, COLD_PARTITION):  New constant macro\n+\tdefinitions.\n+\t(partition_hot_cold_basic_blocks): Add extern function \n+\tdeclaration.\n+        * bb-reorder.c (function.h, obstack.h, expr.h, regs.h):  Add four new \n+\tinclude\tstatements.\n+\t(N_ROUNDS): Increase the maximum number of rounds by 1.\n+\t(branch_threshold): Add array value for new round.\n+\t(exec_threshold): Add array value for new round.\n+\t(push_to_next_round_p): New function.\n+\t(add_unlikely_executed_notes): New function.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): New function.\n+\t(mark_bb_for_unlikely_executed_section): New function.\n+\t(add_labels_and_missing_jumps): New function.\n+\t(add_reg_crossing_jump_notes): New function.\n+\t(fix_up_fall_thru_edges): New function.\n+\t(find_jump_block): New function.\n+\t(fix_crossing_conditional_branches): New function.\n+\t(fix_crossing_unconditional_branches): New function.\n+\t(fix_edges_for_rarely_executed_code): New function.\n+\t(partition_hot_cold_basic_blocks): New function.\n+\t(find_traces):  Add an extra round for partitioning hot/cold\n+\tbasic blocks.\n+\t(find_traces_1_round): Add a parameter.  Modify to push all cold blocks,\n+\tand only cold blocks, into the last (extra) round of collecting traces.\n+\t(better_edge_p): Add a parameter.  Modify to favor non-crossing edges \n+\tover crossing edges.\n+\t(bb_to_key):  Add code to correctly identify cold blocks when \n+\tdoing partitioning.\n+\t(connect_traces): Modify to connect all the non-cold traces first, then\n+\tgo back and connect up all the cold traces.\n+\t(reorder_basic_blocks):  Add call to add_unlikely_executed_notes.\n+\t* cfg.c (entry_exit_blocks): Add initialization for partition field in\n+\tentry and exit blocks.\n+\t* cfgbuild.c (make_edges): Update current_function_has_computed_jump  \n+\tif we are doing hot/cold partitioning.\n+\t* cfgcleanup.c (cfglayout.h): Add new include statement.\n+\t(try_simplify_condjump): Modify to not attempt on blocks with jumps \n+\tthat cross section boundaries.\n+\t(try_forward_edges): Likewise.\n+\t(merge_blocks_move_predecessor_nojumps): Likewise.\n+\t(merge_blocks_move_successor_nojumps): Likewise.\n+\t(merge_blocks_move): Likewise.\n+\t(try_crossjump_to_edge): Modify to not attempt after we have done\n+\tthe block partitioning.\n+\t(try_crossjump_bb): Modify to not attempt on blocks with jumps that\n+\tcross section boundaries.\n+\t(try_optimize_cfg): Likewise.\n+\t* cfghooks.c (tidy_fallthru_edges): Modify to not remove indirect\n+\tjumps that cross section boundaries.\n+        * cfglayout.c (flags.h): Add new include statement.\n+\t(update_unlikely_executed_notes):  New function.\n+\t(fixup_reorder_chain):  Add code so when a new jumping basic block is \n+        added, it's UNLIKELY_EXECUTED_CODE and REG_CROSSING_JUMP notes are \n+\tupdated appropriately.\n+\t(duplicate_insn_chain):  Add code to duplicate the new NOTE insn\n+\tintroduced by this optimization.\n+        * cfglayout.h (scan_ahead_for_unlikely_executed_note):  Add new \n+        extern function declaration.\n+\t* cfgrtl.c (can_delete_note_p):  Add NOTE_INSN_UNLIKELY_EXECUTED_CODE to\n+\tlist of notes that can be deleted.\n+\t(create_basic_block_structure):  Add initialization for partition field.\n+\t(rtl_can_merge_blocks):  Modify to test blocks for jumps that cross\n+\tsection boundaries.\n+\t(try_redirect_by_replacing_jump):  Modify to not attempt on jumps that\n+\tcross section boundaries.\n+\t(commit_one_edge_insertion): Add code so newly created basic block\n+\tends up in correct (hot or cold) section.  Modify to disallow \n+\tinsertions before NOTE_INSN_UNLIKELY_EXECUTED_CODE notes.\n+\t(rtl_verify_flow_info_1):  Add code to verify that no fall_thru edge\n+\tcrosses section boundaries.\n+\t(cfg_layout_can_merge_blocks_p): Modify to test blocks for jumps that\n+\tcross section boundaries.\n+\t(force_nonfallthru_and_redirect): Modify to make sure new basic block\n+\tends up in correct section, with correct notes attached.\n+        * common.opt (freorder-blocks-and-partition):  Add new flag for this \n+        optimization.\n+        * dbxout.c (dbx_function_end):  Add code to make sure scope labels at\n+        the end of functions are written into the correct (hot or cold) \n+        section.\n+\t(dbx_source_file): Add code so writing debug file information\n+\tdoesn't incorrectly change sections.\n+        * defaults.h (NORMAL_TEXT_SECTION_NAME): New constant macro, for use\n+\tin partitioning hot/cold basic blocks into separate sections.\n+\t(SECTION_FORMAT_STRING): New constant macro, for linux/i386 hot/cold \n+\tsection partitioning.\n+\t(HAS_LONG_COND_BRANCH): New constant macro, indicating whether or not\n+\tconditional branches can span all of memory.\n+\t(HAS_LONG_UNCOND_BRANCH): New constant macro, indicationg whether or not\n+\tunconditional branches can span all of memory.\n+        * final.c (scan_ahead_for_unlikely_executed_note):  New function.\n+\t(final_scan_insn):  Add code to check for NOTE instruction indicating \n+        whether basic block belongs in hot or cold section, and to make sure \n+        the current basic block is being written to the appropriate section.  \n+        Also added code to ensure that jump table basic blocks end up in the \n+        correct section.\n+        * flags.h (flag_reorder_blocks_and_partition):  New flag.\n+\t* ifcvt.c (find_if_case_1):  Modify to not attempt if conversion if\n+\tone of the branches has a jump that crosses between sections.\n+\t(find_if_case_2): Likewise.\n+\t(ifcvt): Modify to not attempt to mark loop exit edges after \n+\thot/cold partitioning has occurred.\n+        * opts.c (decode_options): Code to handle new flag, \n+        flag_reorder_blocks_and_partition; also to turn it off if\n+\tflag_exceptions is on.\n+\t(common_handle_option): Code to handle new flag, \n+        flag_reorder_blocks_and_partition.\n+        * output.h (unlikely_text_section): New extern function declaration.\n+\t(in_unlikely_text_section): New extern function declaration.\n+\t* passes.c (rest_of_handle_stack_regs):  Add \n+\tflag_reorder_blocks_and_partition as an 'or' condition for calling \n+\treorder_basic_blocks.\n+\t(rest_of_handle_reorder_blocks):  Add flag_reorder_blocks_and_partition \n+\tas an 'or' condition for calling reorder_basic_blocks.\n+\t(rest_of_compilation):  Add call to partition_hot_cold_basic_blocks.\n+        * print-rtl.c (print_rtx): Add code for handling new note,\n+        NOTE_INSN_UNLIKELY_EXECUTED_CODE\n+        * rtl.c  (NOTE_INSN_UNLIKELY_EXECUTED_CODE): New note insn (see below).\n+\t(REG_CROSSING_JUMP): New kind of reg_note, to mark jumps that\n+\tcross between section boundaries.\n+        * rtl.h (NOTE_INSN_UNLIKELY_EXECUTED_CODE):  New note instruction, \n+        indicating the basic block containing it belongs in the cold section.\n+\t(REG_CROSSING_JUMP): New type of reg_note, to mark jumps that cross\n+\tbetween hot and cold sections.\n+        * toplev.c (flag_reorder_blocks_and_partition):  Add code to \n+        initialize this flag, and to tie it to the command-line option \n+        freorder-blocks-and-partition.\n+        * varasm.c (cfglayout.h):  Add new include statement.\n+\t(unlikely_section_label_printed):  New global variable, used for \n+        determining when to output section name labels for cold sections.\n+\t(in_section):  Add in_unlikely_executed_text to enum data structure.\n+\t(text_section):  Modify code to use SECTION_FORMAT_STRING and\n+\tNORMAL_TEXT_SECTION_NAME macros.\n+\t(unlikely_text_section):  New function.\n+\t(in_unlikely_text_section):  New function.\n+\t(function_section):  Add code to make sure beginning of function is \n+        written into correct section (hot or cold).\n+\t(assemble_start_function):  Add code to make sure stuff is written to \n+        the correct section.\n+\t(assemble_zeros):  Add in_unlikely_text_section as an 'or' condition \n+        to an if statement that was checking 'in_text_section'.\n+\t(assemble_variable):  Add 'in_unlikely_text_section' as an 'or' \n+        condition to an if statement that was checking 'in_text_section'.\n+        (default_section_type_flags_1):  Add check: if in cold section \n+        flags = SECTION_CODE.\n+\t* config/darwin.c (darwin_asm_named_section):  Modify to use\n+\tSECTION_FORMAT_STRING if we are partitioning hot/cold blocks.\n+\t* config/i386/i386.h (HAS_LONG_COND_BRANCH): Defined this macro \n+\tspecifically for the i386.\n+\t(HAS_LONG_UNCOND_BRANCH):  Defined this macro specifically for the i386.\n+        * config/rs6000/darwin.h (UNLIKELY_EXECUTED_TEXT_SECTION_NAME): Change\n+\ttext string to something more informative.\n+\t(NORMAL_TEXT_SECTION_NAME): Add new definition.\n+\t(SECTION_FORMAT_STRING):  Add new definition.\n+        * config/rs6000/rs6000.c (rs6000_assemble_integer):  Add \n+        '!in_unlikely_text_section' as an 'and' condition to an if statement \n+        that was already checking '!in_text_section'.\n+        * config/rs6000/sysv4.h (HOT_TEXT_SECTION_NAME,NORMAL_TEXT_SECTION_NAME,\n+        UNLIKELY_EXECUTED_TEXT_SECTION_NAME,SECTION_FORMAT_STRING): Make\n+        sure these are properly defined for linux on ppc.\n+        * doc/invoke.texi  (freorder-blocks-and-partition): Add documentation \n+        for this new flag.\n+\t* doc/rtl.texi (REG_CROSSING_JUMP):  Add documentation for new\n+\treg_note.\n+        * doc/tm.texi (NORMAL_TEXT_SECTION_NAME, SECTION_FORMAT_STRING, \n+\tHAS_LONG_COND_BRANCH, HAS_LONG_UNCOND_BRANCH): Add documentation for \n+\tthese new macros.\n+\n 2004-04-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* function.c (gen_mem_addressof): When changing the RTX from a REG"}, {"sha": "2c3ef5811119ab72a5f69475c03cd54ccbc33478", "filename": "gcc/basic-block.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -138,6 +138,8 @@ typedef struct edge_def {\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n   gcov_type count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n+  bool crossing_edge;           /* Crosses between hot and cold sections, when\n+\t\t\t\t   we do partitioning.  */\n } *edge;\n \n #define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n@@ -246,6 +248,9 @@ typedef struct basic_block_def {\n   /* Various flags.  See BB_* below.  */\n   int flags;\n \n+  /* Which section block belongs in, when partitioning basic blocks.  */\n+  int partition;\n+\n   /* Additional data maintained by cfg_layout routines.  */\n   struct reorder_block_def *rbi;\n } *basic_block;\n@@ -260,6 +265,12 @@ typedef struct basic_block_def {\n #define BB_IRREDUCIBLE_LOOP\t16\n #define BB_SUPERBLOCK\t\t32\n \n+/* Partitions, to be used when partitioning hot and cold basic blocks into\n+   separate sections.  */\n+#define UNPARTITIONED   0\n+#define HOT_PARTITION   1\n+#define COLD_PARTITION  2\n+\n /* Number of basic blocks in the current function.  */\n \n extern int n_basic_blocks;\n@@ -611,6 +622,7 @@ extern bool control_flow_insn_p (rtx);\n \n /* In bb-reorder.c */\n extern void reorder_basic_blocks (void);\n+extern void partition_hot_cold_basic_blocks (void);\n \n /* In dominance.c */\n "}, {"sha": "ae335c1d74bc7260183acbb4027514c5c6588ca7", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 908, "deletions": 18, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -77,15 +77,21 @@\n #include \"cfglayout.h\"\n #include \"fibheap.h\"\n #include \"target.h\"\n+#include \"function.h\"\n+#include \"obstack.h\"\n+#include \"expr.h\"\n+#include \"regs.h\"\n \n-/* The number of rounds.  */\n-#define N_ROUNDS 4\n+/* The number of rounds.  In most cases there will only be 4 rounds, but\n+   when partitioning hot and cold basic blocks into separate sections of\n+   the .o file there will be an extra round.*/\n+#define N_ROUNDS 5\n \n /* Branch thresholds in thousandths (per mille) of the REG_BR_PROB_BASE.  */\n-static int branch_threshold[N_ROUNDS] = {400, 200, 100, 0};\n+static int branch_threshold[N_ROUNDS] = {400, 200, 100, 0, 0};\n \n /* Exec thresholds in thousandths (per mille) of the frequency of bb 0.  */\n-static int exec_threshold[N_ROUNDS] = {500, 200, 50, 0};\n+static int exec_threshold[N_ROUNDS] = {500, 200, 50, 0, 0};\n \n /* If edge frequency is lower than DUPLICATION_THRESHOLD per mille of entry\n    block the edge destination is not duplicated while connecting traces.  */\n@@ -146,14 +152,58 @@ static void find_traces (int *, struct trace *);\n static basic_block rotate_loop (edge, struct trace *, int);\n static void mark_bb_visited (basic_block, int);\n static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n-\t\t\t\t int, fibheap_t *);\n+\t\t\t\t int, fibheap_t *, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static fibheapkey_t bb_to_key (basic_block);\n-static bool better_edge_p (basic_block, edge, int, int, int, int);\n+static bool better_edge_p (basic_block, edge, int, int, int, int, edge);\n static void connect_traces (int, struct trace *);\n static bool copy_bb_p (basic_block, int);\n static int get_uncond_jump_length (void);\n+static bool push_to_next_round_p (basic_block, int, int, int, gcov_type);\n+static void add_unlikely_executed_notes (void);\n+static void find_rarely_executed_basic_blocks_and_crossing_edges (edge *, \n+\t\t\t\t\t\t\t\t  int *,\n+\t\t\t\t\t\t\t\t  int *);\n+static void mark_bb_for_unlikely_executed_section  (basic_block);\n+static void add_labels_and_missing_jumps (edge *, int);\n+static void add_reg_crossing_jump_notes (void);\n+static void fix_up_fall_thru_edges (void);\n+static void fix_edges_for_rarely_executed_code (edge *, int);\n+static void fix_crossing_conditional_branches (void);\n+static void fix_crossing_unconditional_branches (void);\n \f\n+/* Check to see if bb should be pushed into the next round of trace\n+   collections or not.  Reasons for pushing the block forward are 1).\n+   If the block is cold, we are doing partitioning, and there will be\n+   another round (cold partition blocks are not supposed to be\n+   collected into traces until the very last round); or 2). There will\n+   be another round, and the basic block is not \"hot enough\" for the\n+   current round of trace collection.  */\n+\n+static bool\n+push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n+\t\t      int exec_th, gcov_type count_th)\n+{\n+  bool there_exists_another_round;\n+  bool cold_block;\n+  bool block_not_hot_enough;\n+\n+  there_exists_another_round = round < number_of_rounds - 1;\n+\n+  cold_block = (flag_reorder_blocks_and_partition \n+\t\t&& bb->partition == COLD_PARTITION);\n+\n+  block_not_hot_enough = (bb->frequency < exec_th \n+\t\t\t  || bb->count < count_th\n+\t\t\t  || probably_never_executed_bb_p (bb));\n+\n+  if (there_exists_another_round\n+      && (cold_block || block_not_hot_enough))\n+    return true;\n+  else \n+    return false;\n+}\n+\n /* Find the traces for Software Trace Cache.  Chain each trace through\n    RBI()->next.  Store the number of traces to N_TRACES and description of\n    traces to TRACES.  */\n@@ -162,9 +212,18 @@ static void\n find_traces (int *n_traces, struct trace *traces)\n {\n   int i;\n+  int number_of_rounds;\n   edge e;\n   fibheap_t heap;\n \n+  /* Add one extra round of trace collection when partitioning hot/cold\n+     basic blocks into separate sections.  The last round is for all the\n+     cold blocks (and ONLY the cold blocks).  */\n+\n+  number_of_rounds = N_ROUNDS - 1;\n+  if (flag_reorder_blocks_and_partition)\n+    number_of_rounds = N_ROUNDS;\n+\n   /* Insert entry points of function into heap.  */\n   heap = fibheap_new ();\n   max_entry_frequency = 0;\n@@ -181,7 +240,7 @@ find_traces (int *n_traces, struct trace *traces)\n     }\n \n   /* Find the traces.  */\n-  for (i = 0; i < N_ROUNDS; i++)\n+  for (i = 0; i < number_of_rounds; i++)\n     {\n       gcov_type count_threshold;\n \n@@ -195,7 +254,8 @@ find_traces (int *n_traces, struct trace *traces)\n \n       find_traces_1_round (REG_BR_PROB_BASE * branch_threshold[i] / 1000,\n \t\t\t   max_entry_frequency * exec_threshold[i] / 1000,\n-\t\t\t   count_threshold, traces, n_traces, i, &heap);\n+\t\t\t   count_threshold, traces, n_traces, i, &heap,\n+\t\t\t   number_of_rounds);\n     }\n   fibheap_delete (heap);\n \n@@ -354,8 +414,13 @@ mark_bb_visited (basic_block bb, int trace)\n static void\n find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t     struct trace *traces, int *n_traces, int round,\n-\t\t     fibheap_t *heap)\n+\t\t     fibheap_t *heap, int number_of_rounds)\n {\n+  /* The following variable refers to the last round in which non-\"cold\" \n+     blocks may be collected into a trace.  */\n+\n+  int last_round = N_ROUNDS - 1;\n+\n   /* Heap for discarded basic blocks which are possible starting points for\n      the next round.  */\n   fibheap_t new_heap = fibheap_new ();\n@@ -374,10 +439,13 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       if (dump_file)\n \tfprintf (dump_file, \"Getting bb %d\\n\", bb->index);\n \n-      /* If the BB's frequency is too low send BB to the next round.  */\n-      if (round < N_ROUNDS - 1\n-\t  && (bb->frequency < exec_th || bb->count < count_th\n-\t      || probably_never_executed_bb_p (bb)))\n+      /* If the BB's frequency is too low send BB to the next round.  When\n+         partitioning hot/cold blocks into separate sections, make sure all\n+         the cold blocks (and ONLY the cold blocks) go into the (extra) final\n+         round.  */\n+\n+      if (push_to_next_round_p (bb, round, number_of_rounds, exec_th, \n+\t\t\t\tcount_th))\n \t{\n \t  int key = bb_to_key (bb);\n \t  bbd[bb->index].heap = new_heap;\n@@ -427,6 +495,10 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  && e->dest->rbi->visited != *n_traces)\n \t\tcontinue;\n \n+\t      if (e->dest->partition == COLD_PARTITION\n+\t\t  && round < last_round)\n+\t\tcontinue;\n+\n \t      prob = e->probability;\n \t      freq = EDGE_FREQUENCY (e);\n \n@@ -436,7 +508,11 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  || prob < branch_th || freq < exec_th || e->count < count_th)\n \t\tcontinue;\n \n-\t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq))\n+\t      /* If partitioning hot/cold basic blocks, don't consider edges\n+\t\t that cross section boundaries.  */\n+\n+\t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq,\n+\t\t\t\t best_edge))\n \t\t{\n \t\t  best_edge = e;\n \t\t  best_prob = prob;\n@@ -490,7 +566,13 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t      || prob < branch_th || freq < exec_th\n \t\t      || e->count < count_th)\n \t\t    {\n-\t\t      if (round < N_ROUNDS - 1)\n+\t\t      /* When partitioning hot/cold basic blocks, make sure\n+\t\t\t the cold blocks (and only the cold blocks) all get\n+\t\t\t pushed to the last round of trace collection.  */\n+\n+\t\t      if (push_to_next_round_p (e->dest, round, \n+\t\t\t\t\t\tnumber_of_rounds,\n+\t\t\t\t\t\texec_th, count_th))\n \t\t\twhich_heap = new_heap;\n \t\t    }\n \n@@ -588,6 +670,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n \t\t\t&& !e->dest->rbi->visited\n \t\t\t&& !e->dest->pred->pred_next\n+\t\t\t&& !e->crossing_edge\n \t\t\t&& e->dest->succ\n \t\t\t&& (e->dest->succ->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->dest->succ->flags & EDGE_COMPLEX)\n@@ -707,7 +790,8 @@ bb_to_key (basic_block bb)\n   int priority = 0;\n \n   /* Do not start in probably never executed blocks.  */\n-  if (probably_never_executed_bb_p (bb))\n+\n+  if (bb->partition == COLD_PARTITION || probably_never_executed_bb_p (bb))\n     return BB_FREQ_MAX;\n \n   /* Prefer blocks whose predecessor is an end of some trace\n@@ -739,7 +823,7 @@ bb_to_key (basic_block bb)\n \n static bool\n better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n-\t       int best_freq)\n+\t       int best_freq, edge cur_best_edge)\n {\n   bool is_better_edge;\n \n@@ -770,6 +854,16 @@ better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n   else\n     is_better_edge = false;\n \n+  /* If we are doing hot/cold partitioning, make sure that we always favor\n+     non-crossing edges over crossing edges.  */\n+\n+  if (!is_better_edge\n+      && flag_reorder_blocks_and_partition \n+      && cur_best_edge \n+      && cur_best_edge->crossing_edge\n+      && !e->crossing_edge)\n+    is_better_edge = true;\n+\n   return is_better_edge;\n }\n \n@@ -779,7 +873,10 @@ static void\n connect_traces (int n_traces, struct trace *traces)\n {\n   int i;\n+  int unconnected_hot_trace_count = 0;\n+  bool cold_connected = true;\n   bool *connected;\n+  bool *cold_traces;\n   int last_trace;\n   int freq_threshold;\n   gcov_type count_threshold;\n@@ -792,17 +889,66 @@ connect_traces (int n_traces, struct trace *traces)\n \n   connected = xcalloc (n_traces, sizeof (bool));\n   last_trace = -1;\n-  for (i = 0; i < n_traces; i++)\n+\n+  /* If we are partitioning hot/cold basic blocks, mark the cold\n+     traces as already connnected, to remove them from consideration\n+     for connection to the hot traces.  After the hot traces have all\n+     been connected (determined by \"unconnected_hot_trace_count\"), we\n+     will go back and connect the cold traces.  */\n+\n+  cold_traces = xcalloc (n_traces, sizeof (bool));\n+\n+  if (flag_reorder_blocks_and_partition)\n+    for (i = 0; i < n_traces; i++)\n+      {\n+\tif (traces[i].first->partition == COLD_PARTITION)\n+\t  {\n+\t    connected[i] = true;\n+\t    cold_traces[i] = true;\n+\t    cold_connected = false;\n+\t  }\n+\telse\n+\t  unconnected_hot_trace_count++;\n+      }\n+  \n+  for (i = 0; i < n_traces || !cold_connected ; i++)\n     {\n       int t = i;\n       int t2;\n       edge e, best;\n       int best_len;\n \n+      /* If we are partitioning hot/cold basic blocks, check to see\n+\t if all the hot traces have been connected.  If so, go back\n+\t and mark the cold traces as unconnected so we can connect\n+\t them up too.  Re-set \"i\" to the first (unconnected) cold\n+\t trace. Use flag \"cold_connected\" to make sure we don't do\n+         this step more than once.  */\n+\n+      if (flag_reorder_blocks_and_partition\n+\t  && (i >= n_traces || unconnected_hot_trace_count <= 0)\n+\t  && !cold_connected)\n+\t{\n+\t  int j;\n+\t  int first_cold_trace = -1;\n+\n+\t  for (j = 0; j < n_traces; j++)\n+\t    if (cold_traces[j])\n+\t      {\n+\t\tconnected[j] = false;\n+\t\tif (first_cold_trace == -1)\n+\t\t  first_cold_trace = j;\n+\t      }\n+\t  i = t = first_cold_trace;\n+\t  cold_connected = true;\n+\t}\n+\n       if (connected[t])\n \tcontinue;\n \n       connected[t] = true;\n+      if (unconnected_hot_trace_count > 0)\n+\tunconnected_hot_trace_count--;\n \n       /* Find the predecessor traces.  */\n       for (t2 = t; t2 > 0;)\n@@ -832,6 +978,10 @@ connect_traces (int n_traces, struct trace *traces)\n \t      best->src->rbi->next = best->dest;\n \t      t2 = bbd[best->src->index].end_of_trace;\n \t      connected[t2] = true;\n+\n+\t      if (unconnected_hot_trace_count > 0)\n+\t\tunconnected_hot_trace_count--;\n+\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file, \"Connection: %d %d\\n\",\n@@ -881,6 +1031,8 @@ connect_traces (int n_traces, struct trace *traces)\n \t      t = bbd[best->dest->index].start_of_trace;\n \t      traces[last_trace].last->rbi->next = traces[t].first;\n \t      connected[t] = true;\n+\t      if (unconnected_hot_trace_count > 0)\n+\t\tunconnected_hot_trace_count--;\n \t      last_trace = t;\n \t    }\n \t  else\n@@ -940,6 +1092,9 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t      }\n \t\t  }\n \n+\t      if (flag_reorder_blocks_and_partition)\n+\t\ttry_copy = false;\n+\n \t      /* Copy tiny blocks always; copy larger blocks only when the\n \t\t edge is traversed frequently enough.  */\n \t      if (try_copy\n@@ -969,6 +1124,8 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t      t = bbd[next_bb->index].start_of_trace;\n \t\t      traces[last_trace].last->rbi->next = traces[t].first;\n \t\t      connected[t] = true;\n+\t\t      if (unconnected_hot_trace_count > 0)\n+\t\t\tunconnected_hot_trace_count--;\n \t\t      last_trace = t;\n \t\t    }\n \t\t  else\n@@ -1063,6 +1220,682 @@ get_uncond_jump_length (void)\n   return length;\n }\n \n+static void\n+add_unlikely_executed_notes (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    if (bb->partition == COLD_PARTITION)\n+      mark_bb_for_unlikely_executed_section (bb);\n+}\n+\n+/* Find the basic blocks that are rarely executed and need to be moved to\n+   a separate section of the .o file (to cut down on paging and improve\n+   cache locality).  */\n+\n+static void\n+find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges, \n+\t\t\t\t\t\t      int *n_crossing_edges, \n+\t\t\t\t\t\t      int *max_idx)\n+{\n+  basic_block bb;\n+  edge e;\n+  int i;\n+\n+  /* Mark which partition (hot/cold) each basic block belongs in.  */\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      if (probably_never_executed_bb_p (bb))\n+\tbb->partition = COLD_PARTITION;\n+      else\n+\tbb->partition = HOT_PARTITION;\n+    }\n+\n+  /* Mark every edge that crosses between sections.  */\n+\n+  i = 0;\n+  FOR_EACH_BB (bb)\n+    for (e = bb->succ; e; e = e->succ_next)\n+      {\n+\tif (e->src != ENTRY_BLOCK_PTR\n+\t    && e->dest != EXIT_BLOCK_PTR\n+\t    && e->src->partition != e->dest->partition)\n+\t  {\n+\t    e->crossing_edge = true;\n+\t    if (i == *max_idx)\n+\t      {\n+\t\t*max_idx *= 2;\n+\t\tcrossing_edges = xrealloc (crossing_edges,\n+\t\t\t\t\t   (*max_idx) * sizeof (edge));\n+\t      }\n+\t    crossing_edges[i++] = e;\n+\t  }\n+\telse\n+\t  e->crossing_edge = false;\n+      }\n+\n+  *n_crossing_edges = i;\n+}\n+\n+/* Add NOTE_INSN_UNLIKELY_EXECUTED_CODE to top of basic block.   This note\n+   is later used to mark the basic block to be put in the \n+   unlikely-to-be-executed section of the .o file.  */\n+\n+static void\n+mark_bb_for_unlikely_executed_section (basic_block bb) \n+{\n+  rtx cur_insn;\n+  rtx insert_insn = NULL;\n+  rtx new_note;\n+  \n+  /* Find first non-note instruction and insert new NOTE before it (as\n+     long as new NOTE is not first instruction in basic block).  */\n+  \n+  for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb)); \n+       cur_insn = NEXT_INSN (cur_insn))\n+    if (GET_CODE (cur_insn) != NOTE\n+\t&& GET_CODE (cur_insn) != CODE_LABEL)\n+      {\n+\tinsert_insn = cur_insn;\n+\tbreak;\n+      }\n+  \n+  /* Insert note and assign basic block number to it.  */\n+  \n+  if (insert_insn) \n+    {\n+      new_note = emit_note_before (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n+ \t\t\t\t   insert_insn);\n+      NOTE_BASIC_BLOCK (new_note) = bb;\n+    }\n+  else\n+    {\n+      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n+\t\t\t\t  BB_END (bb));\n+      NOTE_BASIC_BLOCK (new_note) = bb;\n+    }\n+}\n+\n+/* If any destination of a crossing edge does not have a label, add label;\n+   Convert any fall-through crossing edges (for blocks that do not contain\n+   a jump) to unconditional jumps.   */\n+\n+static void \n+add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n+{\n+  int i;\n+  basic_block src;\n+  basic_block dest;\n+  rtx label;\n+  rtx barrier;\n+  rtx new_jump;\n+  \n+  for (i=0; i < n_crossing_edges; i++) \n+    {\n+      if (crossing_edges[i]) \n+  \t{\n+  \t  src = crossing_edges[i]->src; \n+  \t  dest = crossing_edges[i]->dest;\n+ \t  \n+  \t  /* Make sure dest has a label.  */\n+  \t  \n+  \t  if (dest && (dest != EXIT_BLOCK_PTR))\n+  \t    {\n+\t      label = block_label (dest);\n+\t      \n+ \t      /* Make sure source block ends with a jump.  */\n+\t      \n+ \t      if (src && (src != ENTRY_BLOCK_PTR)) \n+ \t\t{\n+\t\t  if (GET_CODE (BB_END (src)) != JUMP_INSN)\n+ \t\t    /* bb just falls through.  */\n+ \t\t    {\n+ \t\t      /* make sure there's only one successor */\n+ \t\t      if (src->succ && (src->succ->succ_next == NULL))\n+ \t\t\t{\n+ \t\t\t  /* Find label in dest block.  */\n+\t\t\t  label = block_label (dest);\n+\n+\t\t\t  new_jump = emit_jump_insn_after (gen_jump (label), \n+\t\t\t\t\t\t\t   BB_END (src));\n+\t\t\t  barrier = emit_barrier_after (new_jump);\n+\t\t\t  JUMP_LABEL (new_jump) = label;\n+\t\t\t  LABEL_NUSES (label) += 1;\n+\t\t\t  src->rbi->footer = unlink_insn_chain (barrier,\n+\t\t\t\t\t\t\t\tbarrier);\n+\t\t\t  /* Mark edge as non-fallthru.  */\n+\t\t\t  crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n+\t\t\t}\n+ \t\t      else\n+ \t\t\t{ \n+ \t\t\t  /* Basic block has two successors, but\n+ \t\t\t     doesn't end in a jump; something is wrong\n+ \t\t\t     here!  */\n+ \t\t\t  abort();\n+ \t\t\t}\n+ \t\t    } /* end: 'if (GET_CODE ... '  */\n+ \t\t} /* end: 'if (src && src->index...'  */\n+  \t    } /* end: 'if (dest && dest->index...'  */\n+  \t} /* end: 'if (crossing_edges[i]...'  */\n+    } /* end for loop  */\n+}\n+\n+/* Find any bb's where the fall-through edge is a crossing edge (note that\n+   these bb's must also contain a conditional jump; we've already\n+   dealt with fall-through edges for blocks that didn't have a\n+   conditional jump in the call to add_labels_and_missing_jumps).\n+   Convert the fall-through edge to non-crossing edge by inserting a\n+   new bb to fall-through into.  The new bb will contain an\n+   unconditional jump (crossing edge) to the original fall through\n+   destination.  */\n+\n+static void \n+fix_up_fall_thru_edges (void)\n+{\n+  basic_block cur_bb;\n+  basic_block new_bb;\n+  edge succ1;\n+  edge succ2;\n+  edge fall_thru;\n+  edge cond_jump;\n+  edge e;\n+  bool cond_jump_crosses;\n+  int invert_worked;\n+  rtx old_jump;\n+  rtx fall_thru_label;\n+  rtx barrier;\n+  \n+  FOR_EACH_BB (cur_bb)\n+    {\n+      fall_thru = NULL;\n+      succ1 = cur_bb->succ;\n+      if (succ1)\n+  \tsucc2 = succ1->succ_next;\n+      else\n+  \tsucc2 = NULL;\n+      \n+      /* Find the fall-through edge.  */\n+      \n+      if (succ1 \n+ \t  && (succ1->flags & EDGE_FALLTHRU))\n+ \t{\n+ \t  fall_thru = succ1;\n+ \t  cond_jump = succ2;\n+ \t}\n+      else if (succ2 \n+ \t       && (succ2->flags & EDGE_FALLTHRU))\n+ \t{\n+ \t  fall_thru = succ2;\n+ \t  cond_jump = succ1;\n+ \t}\n+      \n+      if (fall_thru && (fall_thru->dest != EXIT_BLOCK_PTR))\n+  \t{\n+  \t  /* Check to see if the fall-thru edge is a crossing edge.  */\n+\t\n+\t  if (fall_thru->crossing_edge)\n+  \t    {\n+\t      /* The fall_thru edge crosses; now check the cond jump edge, if\n+\t         it exists.  */\n+\t      \n+ \t      cond_jump_crosses = true;\n+ \t      invert_worked  = 0;\n+\t      old_jump = BB_END (cur_bb);\n+\t      \n+ \t      /* Find the jump instruction, if there is one.  */\n+\t      \n+ \t      if (cond_jump)\n+ \t\t{\n+\t\t  if (!cond_jump->crossing_edge)\n+ \t\t    cond_jump_crosses = false;\n+\t\t  \n+ \t\t  /* We know the fall-thru edge crosses; if the cond\n+ \t\t     jump edge does NOT cross, and its destination is the\n+\t\t     next block in the bb order, invert the jump\n+ \t\t     (i.e. fix it so the fall thru does not cross and\n+ \t\t     the cond jump does).  */\n+ \t\t  \n+\t\t  if (!cond_jump_crosses\n+\t\t      && cur_bb->rbi->next == cond_jump->dest)\n+ \t\t    {\n+ \t\t      /* Find label in fall_thru block. We've already added\n+ \t\t         any missing labels, so there must be one. */\n+ \t\t      \n+ \t\t      fall_thru_label = block_label (fall_thru->dest);\n+\n+ \t\t      if (old_jump && fall_thru_label)\n+ \t\t\tinvert_worked = invert_jump (old_jump, \n+ \t\t\t\t\t\t     fall_thru_label,0);\n+ \t\t      if (invert_worked)\n+ \t\t\t{\n+ \t\t\t  fall_thru->flags &= ~EDGE_FALLTHRU;\n+ \t\t\t  cond_jump->flags |= EDGE_FALLTHRU;\n+ \t\t\t  update_br_prob_note (cur_bb);\n+ \t\t\t  e = fall_thru;\n+ \t\t\t  fall_thru = cond_jump;\n+ \t\t\t  cond_jump = e;\n+\t\t\t  cond_jump->crossing_edge = true;\n+\t\t\t  fall_thru->crossing_edge = false;\n+ \t\t\t}\n+ \t\t    }\n+ \t\t}\n+\t      \n+ \t      if (cond_jump_crosses || !invert_worked)\n+ \t\t{\n+ \t\t  /* This is the case where both edges out of the basic\n+ \t\t     block are crossing edges. Here we will fix up the\n+\t\t     fall through edge. The jump edge will be taken care\n+\t\t     of later.  */\n+\t\t  \n+ \t\t  new_bb = force_nonfallthru (fall_thru);  \n+\t\t  \n+ \t\t  if (new_bb)\n+ \t\t    {\n+ \t\t      new_bb->rbi->next = cur_bb->rbi->next;\n+ \t\t      cur_bb->rbi->next = new_bb;\n+\t\t      \n+ \t\t      /* Make sure new fall-through bb is in same \n+\t\t\t partition as bb it's falling through from.  */\n+ \t\t      \n+\t\t      new_bb->partition = cur_bb->partition;\n+\t\t      new_bb->succ->crossing_edge = true;\n+ \t\t    }\n+\t\t  \n+ \t\t  /* Add barrier after new jump */\n+\t\t  \n+ \t\t  if (new_bb)\n+ \t\t    {\n+ \t\t      barrier = emit_barrier_after (BB_END (new_bb));\n+ \t\t      new_bb->rbi->footer = unlink_insn_chain (barrier, \n+ \t\t\t\t\t\t\t       barrier);\n+ \t\t    }\n+ \t\t  else\n+ \t\t    {\n+ \t\t      barrier = emit_barrier_after (BB_END (cur_bb));\n+ \t\t      cur_bb->rbi->footer = unlink_insn_chain (barrier,\n+ \t\t\t\t\t\t\t       barrier);\n+ \t\t    }\n+ \t\t}\n+  \t    }\n+  \t}\n+    }\n+}\n+\n+/* This function checks the destination blockof a \"crossing jump\" to\n+   see if it has any crossing predecessors that begin with a code label\n+   and end with an unconditional jump.  If so, it returns that predecessor\n+   block.  (This is to avoid creating lots of new basic blocks that all\n+   contain unconditional jumps to the same destination).  */\n+\n+static basic_block\n+find_jump_block (basic_block jump_dest) \n+{ \n+  basic_block source_bb = NULL; \n+  edge e;\n+  rtx insn;\n+\n+  for (e = jump_dest->pred; e; e = e->pred_next)\n+    if (e->crossing_edge)\n+      {\n+\tbasic_block src = e->src;\n+\t\n+\t/* Check each predecessor to see if it has a label, and contains\n+\t   only one executable instruction, which is an unconditional jump.\n+\t   If so, we can use it.   */\n+\t\n+\tif (GET_CODE (BB_HEAD (src)) == CODE_LABEL)\n+\t  for (insn = BB_HEAD (src); \n+\t       !INSN_P (insn) && insn != NEXT_INSN (BB_END (src));\n+\t       insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (INSN_P (insn)\n+\t\t  && insn == BB_END (src)\n+\t\t  && GET_CODE (insn) == JUMP_INSN\n+\t\t  && !any_condjump_p (insn))\n+\t\t{\n+\t\t  source_bb = src;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t\n+\tif (source_bb)\n+\t  break;\n+      }\n+\n+  return source_bb;\n+}\n+\n+/* Find all BB's with conditional jumps that are crossing edges;\n+   insert a new bb and make the conditional jump branch to the new\n+   bb instead (make the new bb same color so conditional branch won't\n+   be a 'crossing' edge).  Insert an unconditional jump from the\n+   new bb to the original destination of the conditional jump.  */\n+\n+static void\n+fix_crossing_conditional_branches (void)\n+{\n+  basic_block cur_bb;\n+  basic_block new_bb;\n+  basic_block last_bb;\n+  basic_block dest;\n+  basic_block prev_bb;\n+  edge succ1;\n+  edge succ2;\n+  edge crossing_edge;\n+  edge new_edge;\n+  rtx old_jump;\n+  rtx set_src;\n+  rtx old_label = NULL_RTX;\n+  rtx new_label;\n+  rtx new_jump;\n+  rtx barrier;\n+\n+ last_bb = EXIT_BLOCK_PTR->prev_bb;\n+  \n+  FOR_EACH_BB (cur_bb)\n+    {\n+      crossing_edge = NULL;\n+      succ1 = cur_bb->succ;\n+      if (succ1)\n+ \tsucc2 = succ1->succ_next;\n+      else\n+ \tsucc2 = NULL;\n+      \n+      /* We already took care of fall-through edges, so only one successor\n+\t can be a crossing edge.  */\n+      \n+      if (succ1 && succ1->crossing_edge)\n+\tcrossing_edge = succ1;\n+      else if (succ2 && succ2->crossing_edge)\n+ \tcrossing_edge = succ2;\n+      \n+      if (crossing_edge) \n+ \t{\n+\t  old_jump = BB_END (cur_bb);\n+\t  \n+\t  /* Check to make sure the jump instruction is a\n+\t     conditional jump.  */\n+\t  \n+\t  set_src = NULL_RTX;\n+\n+\t  if (any_condjump_p (old_jump))\n+\t    {\n+\t      if (GET_CODE (PATTERN (old_jump)) == SET)\n+\t\tset_src = SET_SRC (PATTERN (old_jump));\n+\t      else if (GET_CODE (PATTERN (old_jump)) == PARALLEL)\n+\t\t{\n+\t\t  set_src = XVECEXP (PATTERN (old_jump), 0,0);\n+\t\t  if (GET_CODE (set_src) == SET)\n+\t\t    set_src = SET_SRC (set_src);\n+\t\t  else\n+\t\t    set_src = NULL_RTX;\n+\t\t}\n+\t    }\n+\n+\t  if (set_src && (GET_CODE (set_src) == IF_THEN_ELSE))\n+\t    {\n+\t      if (GET_CODE (XEXP (set_src, 1)) == PC)\n+\t\told_label = XEXP (set_src, 2);\n+\t      else if (GET_CODE (XEXP (set_src, 2)) == PC)\n+\t\told_label = XEXP (set_src, 1);\n+\t      \n+\t      /* Check to see if new bb for jumping to that dest has\n+\t\t already been created; if so, use it; if not, create\n+\t\t a new one.  */\n+\n+\t      new_bb = find_jump_block (crossing_edge->dest);\n+\t      \n+\t      if (new_bb)\n+\t\tnew_label = block_label (new_bb);\n+\t      else\n+\t\t{\n+\t\t  /* Create new basic block to be dest for\n+\t\t     conditional jump.  */\n+\t\t  \n+\t\t  new_bb = create_basic_block (NULL, NULL, last_bb);\n+\t\t  new_bb->rbi->next = last_bb->rbi->next;\n+\t\t  last_bb->rbi->next = new_bb;\n+\t\t  prev_bb = last_bb;\n+\t\t  last_bb = new_bb;\n+\t\t  \n+\t\t  /* Update register liveness information.  */\n+\t\t  \n+\t\t  new_bb->global_live_at_start = \n+\t\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t\t  new_bb->global_live_at_end = \n+\t\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t\t  COPY_REG_SET (new_bb->global_live_at_end,\n+\t\t\t\tprev_bb->global_live_at_end);\n+\t\t  COPY_REG_SET (new_bb->global_live_at_start,\n+\t\t\t\tprev_bb->global_live_at_end);\n+\t\t  \n+\t\t  /* Put appropriate instructions in new bb.  */\n+\t\t  \n+\t\t  new_label = gen_label_rtx ();\n+\t\t  emit_label_before (new_label, BB_HEAD (new_bb));\n+\t\t  BB_HEAD (new_bb) = new_label;\n+\t\t  \n+\t\t  if (GET_CODE (old_label) == LABEL_REF)\n+\t\t    {\n+\t\t      old_label = JUMP_LABEL (old_jump);\n+\t\t      new_jump = emit_jump_insn_after (gen_jump \n+\t\t\t\t\t\t       (old_label), \n+\t\t\t\t\t\t       BB_END (new_bb));\n+\t\t    }\n+\t\t  else if (GET_CODE (old_label) == RETURN)\n+\t\t    new_jump = emit_jump_insn_after (gen_return (), \n+\t\t\t\t\t\t     BB_END (new_bb));\n+\t\t  else\n+\t\t    abort ();\n+\t\t  \n+\t\t  barrier = emit_barrier_after (new_jump);\n+\t\t  JUMP_LABEL (new_jump) = old_label;\n+\t\t  new_bb->rbi->footer = unlink_insn_chain (barrier, \n+\t\t\t\t\t\t\t   barrier);\n+\t\t  \n+\t\t  /* Make sure new bb is in same partition as source\n+\t\t     of conditional branch.  */\n+\t\t  \n+\t\t  new_bb->partition = cur_bb->partition;\n+\t\t}\n+\t      \n+\t      /* Make old jump branch to new bb.  */\n+\t      \n+\t      redirect_jump (old_jump, new_label, 0);\n+\t      \n+\t      /* Remove crossing_edge as predecessor of 'dest'.  */\n+\t      \n+\t      dest = crossing_edge->dest;\n+\t      \n+\t      redirect_edge_succ (crossing_edge, new_bb);\n+\t      \n+\t      /* Make a new edge from new_bb to old dest; new edge\n+\t\t will be a successor for new_bb and a predecessor\n+\t\t for 'dest'.  */\n+\t      \n+\t      if (!new_bb->succ)\n+\t\tnew_edge = make_edge (new_bb, dest, 0);\n+\t      else\n+\t\tnew_edge = new_bb->succ;\n+\t      \n+\t      crossing_edge->crossing_edge = false;\n+\t      new_edge->crossing_edge = true;\n+\t    }\n+ \t}\n+    }\n+}\n+\n+/* Find any unconditional branches that cross between hot and cold\n+   sections.  Convert them into indirect jumps instead.  */\n+\n+static void\n+fix_crossing_unconditional_branches (void)\n+{\n+  basic_block cur_bb;\n+  rtx last_insn;\n+  rtx label;\n+  rtx label_addr;\n+  rtx indirect_jump_sequence;\n+  rtx jump_insn = NULL_RTX;\n+  rtx new_reg;\n+  rtx cur_insn;\n+  edge succ;\n+  \n+  FOR_EACH_BB (cur_bb)\n+    {\n+      last_insn = BB_END (cur_bb);\n+      succ = cur_bb->succ;\n+\n+      /* Check to see if bb ends in a crossing (unconditional) jump.  At\n+         this point, no crossing jumps should be conditional.  */\n+\n+      if (GET_CODE (last_insn) == JUMP_INSN\n+\t  && succ->crossing_edge)\n+\t{\n+\t  rtx label2, table;\n+\n+\t  if (any_condjump_p (last_insn))\n+\t    abort ();\n+\n+\t  /* Make sure the jump is not already an indirect or table jump.  */\n+\n+\t  else if (!computed_jump_p (last_insn)\n+\t\t   && !tablejump_p (last_insn, &label2, &table))\n+\t    {\n+\t      /* We have found a \"crossing\" unconditional branch.  Now\n+\t\t we must convert it to an indirect jump.  First create\n+\t\t reference of label, as target for jump.  */\n+\t      \n+\t      label = JUMP_LABEL (last_insn);\n+\t      label_addr = gen_rtx_LABEL_REF (VOIDmode, label);\n+\t      LABEL_NUSES (label) += 1;\n+\t      \n+\t      /* Get a register to use for the indirect jump.  */\n+\t      \n+\t      new_reg = gen_reg_rtx (Pmode);\n+\t      \n+\t      /* Generate indirect the jump sequence.  */\n+\t      \n+\t      start_sequence ();\n+\t      emit_move_insn (new_reg, label_addr);\n+\t      emit_indirect_jump (new_reg);\n+\t      indirect_jump_sequence = get_insns ();\n+\t      end_sequence ();\n+\t      \n+\t      /* Make sure every instruction in the new jump sequence has\n+\t\t its basic block set to be cur_bb.  */\n+\t      \n+\t      for (cur_insn = indirect_jump_sequence; cur_insn;\n+\t\t   cur_insn = NEXT_INSN (cur_insn))\n+\t\t{\n+\t\t  BLOCK_FOR_INSN (cur_insn) = cur_bb;\n+\t\t  if (GET_CODE (cur_insn) == JUMP_INSN)\n+\t\t    jump_insn = cur_insn;\n+\t\t}\n+\t      \n+\t      /* Insert the new (indirect) jump sequence immediately before\n+\t\t the unconditional jump, then delete the unconditional jump.  */\n+\t      \n+\t      emit_insn_before (indirect_jump_sequence, last_insn);\n+\t      delete_insn (last_insn);\n+\t      \n+\t      /* Make BB_END for cur_bb be the jump instruction (NOT the\n+\t\t barrier instruction at the end of the sequence...).  */\n+\t      \n+\t      BB_END (cur_bb) = jump_insn;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Add REG_CROSSING_JUMP note to all crossing jump insns.  */\n+\n+static void\n+add_reg_crossing_jump_notes (void)\n+{\n+  basic_block bb;\n+  edge e;\n+\n+  FOR_EACH_BB (bb)\n+    for (e = bb->succ; e; e = e->succ_next)\n+      if (e->crossing_edge\n+\t  && GET_CODE (BB_END (e->src)) == JUMP_INSN)\n+\tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP, \n+\t\t\t\t\t\t\t NULL_RTX, \n+\t\t\t\t\t\t         REG_NOTES (BB_END \n+\t\t\t\t\t\t\t\t  (e->src)));\n+}\n+\n+/* Basic blocks containing NOTE_INSN_UNLIKELY_EXECUTED_CODE will be\n+   put in a separate section of the .o file, to reduce paging and\n+   improve cache performance (hopefully).  This can result in bits of\n+   code from the same function being widely separated in the .o file.\n+   However this is not obvious to the current bb structure.  Therefore\n+   we must take care to ensure that: 1). There are no fall_thru edges\n+   that cross between sections;  2). For those architectures which\n+   have \"short\" conditional branches, all conditional branches that\n+   attempt to cross between sections are converted to unconditional\n+   branches; and, 3). For those architectures which have \"short\"\n+   unconditional branches, all unconditional branches that attempt\n+   to cross between sections are converted to indirect jumps.\n+   \n+   The code for fixing up fall_thru edges that cross between hot and\n+   cold basic blocks does so by creating new basic blocks containing \n+   unconditional branches to the appropriate label in the \"other\" \n+   section.  The new basic block is then put in the same (hot or cold)\n+   section as the original conditional branch, and the fall_thru edge\n+   is modified to fall into the new basic block instead.  By adding\n+   this level of indirection we end up with only unconditional branches\n+   crossing between hot and cold sections.  \n+   \n+   Conditional branches are dealt with by adding a level of indirection.\n+   A new basic block is added in the same (hot/cold) section as the \n+   conditional branch, and the conditional branch is retargeted to the\n+   new basic block.  The new basic block contains an unconditional branch\n+   to the original target of the conditional branch (in the other section).\n+\n+   Unconditional branches are dealt with by converting them into\n+   indirect jumps.  */\n+\n+static void \n+fix_edges_for_rarely_executed_code (edge *crossing_edges, \n+\t\t\t\t    int n_crossing_edges)\n+{\n+  /* Make sure the source of any crossing edge ends in a jump and the\n+     destination of any crossing edge has a label.  */\n+  \n+  add_labels_and_missing_jumps (crossing_edges, n_crossing_edges);\n+  \n+  /* Convert all crossing fall_thru edges to non-crossing fall\n+     thrus to unconditional jumps (that jump to the original fall\n+     thru dest).  */\n+  \n+  fix_up_fall_thru_edges ();\n+  \n+  /* If the architecture does not have conditional branches that can\n+     span all of memory, convert crossing conditional branches into\n+     crossing unconditional branches.  */\n+  \n+  if (!HAS_LONG_COND_BRANCH)\n+    fix_crossing_conditional_branches ();\n+  \n+  /* If the architecture does not have unconditional branches that\n+     can span all of memory, convert crossing unconditional branches\n+     into indirect jumps.  Since adding an indirect jump also adds\n+     a new register usage, update the register usage information as\n+     well.  */\n+  \n+  if (!HAS_LONG_UNCOND_BRANCH)\n+    {\n+      fix_crossing_unconditional_branches ();\n+      reg_scan (get_insns(), max_reg_num (), 1);\n+    }\n+\n+  add_reg_crossing_jump_notes ();\n+}\n+\n /* Reorder basic blocks.  The main entry point to this file.  */\n \n void\n@@ -1111,7 +1944,64 @@ reorder_basic_blocks (void)\n   if (dump_file)\n     dump_flow_info (dump_file);\n \n+  if (flag_reorder_blocks_and_partition)\n+    add_unlikely_executed_notes ();\n+\n   cfg_layout_finalize ();\n \n   timevar_pop (TV_REORDER_BLOCKS);\n }\n+\n+/* This function is the main 'entrance' for the optimization that\n+   partitions hot and cold basic blocks into separate sections of the\n+   .o file (to improve performance and cache locality).  Ideally it\n+   would be called after all optimizations that rearrange the CFG have\n+   been called.  However part of this optimization may introduce new\n+   register usage, so it must be called before register allocation has\n+   occurred.  This means that this optimization is actually called\n+   well before the optimization that reorders basic blocks (see function\n+   above).\n+\n+   This optimization checks the feedback information to determine\n+   which basic blocks are hot/cold and adds\n+   NOTE_INSN_UNLIKELY_EXECUTED_CODE to non-hot basic blocks.  The\n+   presence or absence of this note is later used for writing out\n+   sections in the .o file.  This optimization must also modify the\n+   CFG to make sure there are no fallthru edges between hot & cold\n+   blocks, as those blocks will not necessarily be contiguous in the\n+   .o (or assembly) file; and in those cases where the architecture\n+   requires it, conditional and unconditional branches that cross\n+   between sections are converted into unconditional or indirect\n+   jumps, depending on what is appropriate.  */\n+\n+void\n+partition_hot_cold_basic_blocks (void)\n+{\n+  basic_block cur_bb;\n+  edge *crossing_edges;\n+  int n_crossing_edges;\n+  int max_edges = 2 * last_basic_block;\n+  \n+  if (n_basic_blocks <= 1)\n+    return;\n+  \n+  crossing_edges = xcalloc (max_edges, sizeof (edge));\n+\n+  cfg_layout_initialize ();\n+  \n+  FOR_EACH_BB (cur_bb)\n+    if (cur_bb->index >= 0\n+ \t&& cur_bb->next_bb->index >= 0)\n+      cur_bb->rbi->next = cur_bb->next_bb;\n+  \n+  find_rarely_executed_basic_blocks_and_crossing_edges (crossing_edges, \n+\t\t\t\t\t\t\t&n_crossing_edges, \n+\t\t\t\t\t\t\t&max_edges);\n+\n+  if (n_crossing_edges > 0)\n+    fix_edges_for_rarely_executed_code (crossing_edges, n_crossing_edges);\n+  \n+  free (crossing_edges);\n+\n+  cfg_layout_finalize();\n+}"}, {"sha": "5eb9c248c5ba1798e60b6acf9739492836888d4a", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -115,6 +115,7 @@ struct basic_block_def entry_exit_blocks[2]\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0,\t\t\t\t/* flags */\n+    0,                          /* partition */\n     NULL\t\t\t/* rbi */\n   },\n   {\n@@ -138,6 +139,7 @@ struct basic_block_def entry_exit_blocks[2]\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0,\t\t\t\t/* flags */\n+    0,                          /* partition */\n     NULL\t\t\t/* rbi */\n   }\n };"}, {"sha": "cd936a27b9d7711d04eed417a141d60dcc4871dc", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -271,6 +271,12 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n   /* Assume no computed jump; revise as we create edges.  */\n   current_function_has_computed_jump = 0;\n \n+  /* If we are partitioning hot and cold basic blocks into separate\n+     sections, we cannot assume there is no computed jump.  */\n+\n+  if (flag_reorder_blocks_and_partition)\n+    current_function_has_computed_jump = 1;\n+\n   /* Heavy use of computed goto in machine-generated code can lead to\n      nearly fully-connected CFGs.  In that case we spend a significant\n      amount of time searching the edge lists for duplicates.  */"}, {"sha": "51182e3f400db64d7933cb480cf985e73f4a2f8b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"regs.h\"\n+#include \"cfglayout.h\"\n #include \"expr.h\"\n \n /* cleanup_cfg maintains following flags for each basic block.  */\n@@ -150,6 +151,15 @@ try_simplify_condjump (basic_block cbranch_block)\n     return false;\n   jump_dest_block = jump_block->succ->dest;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+\n+  if (flag_reorder_blocks_and_partition\n+      && (jump_block->partition != jump_dest_block->partition\n+\t  || cbranch_jump_edge->crossing_edge))\n+    return false;\n+\n   /* The conditional branch must target the block after the\n      unconditional branch.  */\n   cbranch_dest_block = cbranch_jump_edge->dest;\n@@ -428,6 +438,14 @@ try_forward_edges (int mode, basic_block b)\n   bool changed = false;\n   edge e, next, *threaded_edges = NULL;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n+    return false;\n+\n   for (e = b->succ; e; e = next)\n     {\n       basic_block target, first;\n@@ -675,6 +693,15 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (a->partition != b->partition\n+\t  || find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)))\n+    return;\n+\n   barrier = next_nonnote_insn (BB_END (a));\n   if (GET_CODE (barrier) != BARRIER)\n     abort ();\n@@ -718,6 +745,15 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n   rtx barrier, real_b_end;\n   rtx label, table;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || a->partition != b->partition))\n+    return;\n+\n   real_b_end = BB_END (b);\n \n   /* If there is a jump table following block B temporarily add the jump table\n@@ -782,6 +818,18 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       && tail_recursion_label_p (BB_HEAD (c)))\n     return NULL;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || find_reg_note (BB_END (c), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || b->partition != c->partition))\n+    return NULL;\n+      \n+    \n+\n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n     {\n@@ -1453,6 +1501,12 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   rtx newpos1, newpos2;\n   edge s;\n \n+  /* If we have partitioned hot/cold basic blocks, it is a bad idea\n+     to try this optimization.  */\n+\n+  if (flag_reorder_blocks_and_partition && no_new_pseudos)\n+    return false;\n+\n   /* Search backward through forwarder blocks.  We don't need to worry\n      about multiple entry or chained forwarders, as they will be optimized\n      away.  We do this to look past the unconditional jump following a\n@@ -1639,6 +1693,15 @@ try_crossjump_bb (int mode, basic_block bb)\n   if (!bb->pred || !bb->pred->pred_next)\n     return false;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (bb->pred->src->partition != bb->pred->pred_next->src->partition\n+\t  || bb->pred->crossing_edge))\n+    return false;\n+\n   /* It is always cheapest to redirect a block that ends in a branch to\n      a block that falls through into BB, as that adds no branches to the\n      program.  We'll try that combination first.  */\n@@ -1895,6 +1958,7 @@ try_optimize_cfg (int mode)\n \t\t  && ! b->succ->succ_next\n \t\t  && b->succ->dest != EXIT_BLOCK_PTR\n \t\t  && onlyjump_p (BB_END (b))\n+\t\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n \t\t  && try_redirect_by_replacing_jump (b->succ, b->succ->dest,\n \t\t\t\t\t\t     (mode & CLEANUP_CFGLAYOUT) != 0))\n \t\t{"}, {"sha": "001dfe29bd4f701071d2c2c809030e7f7defd203", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -600,7 +600,8 @@ tidy_fallthru_edges (void)\n       if ((s = b->succ) != NULL\n \t  && ! (s->flags & EDGE_COMPLEX)\n \t  && s->succ_next == NULL\n-\t  && s->dest == c)\n+\t  && s->dest == c\n+\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n \ttidy_fallthru_edge (s);\n     }\n }"}, {"sha": "c5b89ac92ad24b46faf91dacd1ec51ae1d5745e5", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -35,6 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"ggc.h\"\n #include \"alloc-pool.h\"\n+#include \"flags.h\"\n \n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.  */\n@@ -57,6 +58,7 @@ void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n static rtx duplicate_insn_chain (rtx, rtx);\n static tree insn_scope (rtx);\n+static void update_unlikely_executed_notes (basic_block);\n \f\n rtx\n unlink_insn_chain (rtx first, rtx last)\n@@ -635,6 +637,7 @@ fixup_reorder_chain (void)\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n       basic_block nb;\n+      basic_block old_bb;\n \n       if (bb->succ == NULL)\n \tcontinue;\n@@ -711,6 +714,11 @@ fixup_reorder_chain (void)\n \t\t    }\n \t\t}\n \n+\t      /* If the \"jumping\" edge is a crossing edge, and the fall\n+\t\t through edge is non-crossing, leave things as they are.  */\n+\t      else if (e_taken->crossing_edge && !e_fall->crossing_edge)\n+\t\tcontinue;\n+\n \t      /* Otherwise we can try to invert the jump.  This will\n \t\t basically never fail, however, keep up the pretense.  */\n \t      else if (invert_jump (bb_end_insn,\n@@ -768,7 +776,34 @@ fixup_reorder_chain (void)\n \t  nb->rbi->next = bb->rbi->next;\n \t  bb->rbi->next = nb;\n \t  /* Don't process this new block.  */\n+\t  old_bb = bb;\n \t  bb = nb;\n+\t  \n+\t  /* Make sure new bb is tagged for correct section (same as\n+\t     fall-thru source).  */\n+\t  e_fall->src->partition = bb->pred->src->partition;\n+\t  if (flag_reorder_blocks_and_partition)\n+\t    {\n+\t      if (bb->pred->src->partition == COLD_PARTITION)\n+\t\t{\n+\t\t  rtx new_note;\n+\t\t  rtx note = BB_HEAD (e_fall->src);\n+\t\t  \n+\t\t  while (!INSN_P (note)\n+\t\t\t && note != BB_END (e_fall->src))\n+\t\t    note = NEXT_INSN (note);\n+\t\t  \n+\t\t  new_note = emit_note_before \n+                                          (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n+\t\t\t\t\t   note);\n+\t\t  NOTE_BASIC_BLOCK (new_note) = bb;\n+\t\t}\n+\t      if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+\t\t  && !any_condjump_p (BB_END (bb))\n+\t\t  && bb->succ->crossing_edge )\n+\t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n+\t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n+\t    }\n \t}\n     }\n \n@@ -803,6 +838,8 @@ fixup_reorder_chain (void)\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n \n+      update_unlikely_executed_notes (bb);\n+\n       bb->prev_bb = prev_bb;\n       prev_bb->next_bb = bb;\n     }\n@@ -820,6 +857,21 @@ fixup_reorder_chain (void)\n     }\n }\n \f\n+/* Update the basic block number information in any \n+   NOTE_INSN_UNLIKELY_EXECUTED_CODE notes within the basic block.  */\n+\n+static void\n+update_unlikely_executed_notes (basic_block bb)\n+{\n+  rtx cur_insn;\n+\n+  for (cur_insn = BB_HEAD (bb); cur_insn != BB_END (bb); \n+       cur_insn = NEXT_INSN (cur_insn)) \n+    if (GET_CODE (cur_insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n+      NOTE_BASIC_BLOCK (cur_insn) = bb;\n+}\n+\f\n /* Perform sanity checks on the insn chain.\n    1. Check that next/prev pointers are consistent in both the forward and\n       reverse direction.\n@@ -990,6 +1042,7 @@ duplicate_insn_chain (rtx from, rtx to)\n \t      abort ();\n \t      break;\n \t    case NOTE_INSN_REPEATED_LINE_NUMBER:\n+\t    case NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n \t      emit_note_copy (insn);\n \t      break;\n "}, {"sha": "0361dc68e05b67b651842682cf47cdc07217d984", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -45,3 +45,4 @@ extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *);\n extern void cfg_layout_initialize_rbi (basic_block);\n+extern bool scan_ahead_for_unlikely_executed_note (rtx);"}, {"sha": "2e09ba2055dd9b5d81bc0f16b35639c67fdb0703", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 110, "deletions": 1, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -99,6 +99,7 @@ can_delete_note_p (rtx note)\n {\n   return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n \t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK\n+\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_UNLIKELY_EXECUTED_CODE\n \t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_PREDICTION);\n }\n \n@@ -319,6 +320,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   link_block (bb, after);\n   BASIC_BLOCK (bb->index) = bb;\n   update_bb_for_insn (bb);\n+  bb->partition = UNPARTITIONED;\n \n   /* Tag the block so that we know it has been used when considering\n      other basic block notes.  */\n@@ -620,11 +622,24 @@ rtl_merge_blocks (basic_block a, basic_block b)\n static bool\n rtl_can_merge_blocks (basic_block a,basic_block b)\n {\n+  bool partitions_ok = true;\n+\n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || a->partition != b->partition))\n+    partitions_ok = false;\n+\n   /* There must be exactly one edge in between the blocks.  */\n   return (a->succ && !a->succ->succ_next && a->succ->dest == b\n \t  && !b->pred->pred_next && a != b\n \t  /* Must be simple edge.  */\n \t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && partitions_ok\n \t  && a->next_bb == b\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n@@ -665,6 +680,15 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   rtx set;\n   int fallthru = 0;\n \n+\n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX))\n+    return false;\n+\n   /* Verify that all targets will be TARGET.  */\n   for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n     if (tmp->dest != target && tmp != e)\n@@ -1066,6 +1090,33 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t\t\ttarget->global_live_at_start);\n \t}\n \n+      /* Make sure new block ends up in correct hot/cold section.  */\n+\n+      jump_block->partition = e->src->partition;\n+      if (flag_reorder_blocks_and_partition)\n+\t{\n+\t  if (e->src->partition == COLD_PARTITION)\n+\t    {\n+\t      rtx bb_note, new_note;\n+\t      for (bb_note = BB_HEAD (jump_block); \n+\t\t   bb_note && bb_note != NEXT_INSN (BB_END (jump_block));\n+\t\t   bb_note = NEXT_INSN (bb_note))\n+\t\tif (GET_CODE (bb_note) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (bb_note) == NOTE_INSN_BASIC_BLOCK)\n+\t\t  break;\n+\t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n+\t\t\t\t\t  bb_note);\n+\t      NOTE_BASIC_BLOCK (new_note) = jump_block; \n+\t      jump_block->partition = COLD_PARTITION;\n+\t    }\n+\t  if (GET_CODE (BB_END (jump_block)) == JUMP_INSN\n+\t      && !any_condjump_p (BB_END (jump_block))\n+\t      && jump_block->succ->crossing_edge )\n+\t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n+\t      (REG_CROSSING_JUMP, NULL_RTX, \n+\t       REG_NOTES (BB_END (jump_block)));\n+\t}\n+\n       /* Wire edge in.  */\n       new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n       new_edge->probability = e->probability;\n@@ -1480,6 +1531,10 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t    tmp = NEXT_INSN (tmp);\n \t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n \t    tmp = NEXT_INSN (tmp);\n+\t  if (tmp \n+\t      && GET_CODE (tmp) == NOTE\n+\t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n+\t    tmp = NEXT_INSN (tmp);\n \t  if (tmp == BB_HEAD (bb))\n \t    before = tmp;\n \t  else if (tmp)\n@@ -1522,6 +1577,38 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t{\n \t  bb = split_edge (e);\n \t  after = BB_END (bb);\n+\n+\t  /* If we are partitioning hot/cold basic blocks, we must make sure\n+\t     that the new basic block ends up in the correct section.  */\n+\n+\t  bb->partition = e->src->partition;\n+\t  if (flag_reorder_blocks_and_partition\n+\t      && e->src != ENTRY_BLOCK_PTR\n+\t      && e->src->partition == COLD_PARTITION)\n+\t    {\n+\t      rtx bb_note, new_note, cur_insn;\n+\n+\t      bb_note = NULL_RTX;\n+\t      for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n+\t\t   cur_insn = NEXT_INSN (cur_insn))\n+\t\tif (GET_CODE (cur_insn) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_BASIC_BLOCK)\n+\t\t  {\n+\t\t    bb_note = cur_insn;\n+\t\t    break;\n+\t\t  }\n+\n+\t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n+\t\t\t\t\t  bb_note);\n+\t      NOTE_BASIC_BLOCK (new_note) = bb;\n+\t      if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+\t\t  && !any_condjump_p (BB_END (bb))\n+\t\t  && bb->succ->crossing_edge )\n+\t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n+\t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n+\t      if (after == bb_note)\n+\t\tafter = new_note;\n+\t    }\n \t}\n     }\n \n@@ -1791,6 +1878,7 @@ update_br_prob_note (basic_block bb)\n    - tails of basic blocks (ensure that boundary is necessary)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n      and NOTE_INSN_BASIC_BLOCK\n+   - verify that no fall_thru edge crosses hot/cold partition boundaries\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n@@ -1878,7 +1966,15 @@ rtl_verify_flow_info_1 (void)\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  if (e->flags & EDGE_FALLTHRU)\n-\t    n_fallthru++, fallthru = e;\n+\t    {\n+\t      n_fallthru++, fallthru = e;\n+\t      if (e->crossing_edge)\n+\t\t{ \n+\t\t  error (\"Fallthru edge crosses section boundary (bb %i)\",\n+\t\t\t e->src->index);\n+\t\t  err = 1;\n+\t\t}\n+\t    }\n \n \t  if ((e->flags & ~(EDGE_DFS_BACK\n \t\t\t    | EDGE_CAN_FALLTHRU\n@@ -2553,11 +2649,24 @@ cfg_layout_delete_block (basic_block bb)\n static bool\n cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n {\n+  bool partitions_ok = true;\n+\n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || a->partition != b->partition))\n+    partitions_ok = false;\n+\n   /* There must be exactly one edge in between the blocks.  */\n   return (a->succ && !a->succ->succ_next && a->succ->dest == b\n \t  && !b->pred->pred_next && a != b\n \t  /* Must be simple edge.  */\n \t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && partitions_ok\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */"}, {"sha": "d7bed08d4ae780aa5d1f588f12d3384425b7f306", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -569,6 +569,10 @@ freorder-blocks\n Common\n Reorder basic blocks to improve code placement\n \n+freorder-blocks-and-partition\n+Common\n+Reorder basic blocks and partition into hot and cold sections\n+\n freorder-functions\n Common\n Reorder functions to improve code placement"}, {"sha": "a626045a9fcf2f5a335ddb2f8e3e4037da4d286d", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -1304,7 +1304,10 @@ darwin_globalize_label (FILE *stream, const char *name)\n void\n darwin_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n {\n-  fprintf (asm_out_file, \".section %s\\n\", name);\n+  if (flag_reorder_blocks_and_partition)\n+    fprintf (asm_out_file, SECTION_FORMAT_STRING, name);\n+  else\n+    fprintf (asm_out_file, \".section %s\\n\", name);\n }\n \n unsigned int"}, {"sha": "846b6e9dbaef488026dafe153d4cc2f1c82f380b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -207,6 +207,9 @@ extern int target_flags;\n #endif\n #endif\n \n+#define HAS_LONG_COND_BRANCH 1\n+#define HAS_LONG_UNCOND_BRANCH 1\n+\n /* Avoid adding %gs:0 in TLS references; use %gs:address directly.  */\n #define TARGET_TLS_DIRECT_SEG_REFS (target_flags & MASK_TLS_DIRECT_SEG_REFS)\n "}, {"sha": "993126f84896f6c8a23038edec097b5bad86b28e", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -145,8 +145,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* These are used by -fbranch-probabilities */\n #define HOT_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n+#define NORMAL_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \\\n-                              \"__TEXT,__text2,regular,pure_instructions\"\n+                              \"__TEXT,__unlikely,regular,pure_instructions\"\n+#define SECTION_FORMAT_STRING \".section %s\\n\\t.align 2\\n\"\n \n /* Define cutoff for using external functions to save floating point.\n    Currently on Darwin, always use inline stores.  */"}, {"sha": "49132641729aea1648762273740cc6c05cc8f46a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -9702,6 +9702,7 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       if (TARGET_RELOCATABLE\n \t  && !in_toc_section ()\n \t  && !in_text_section ()\n+\t  && !in_text_unlikely_section ()\n \t  && !recurse\n \t  && GET_CODE (x) != CONST_INT\n \t  && GET_CODE (x) != CONST_DOUBLE"}, {"sha": "39497e9736b35bab84f0aadbc101324c08783e6e", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -434,6 +434,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define\tBSS_SECTION_ASM_OP\t\"\\t.section\\t\\\".bss\\\"\"\n \n+#define HOT_TEXT_SECTION_NAME \".text\"\n+#define NORMAL_TEXT_SECTION_NAME \".text\"\n+#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \".text.unlikely\"\n+#define SECTION_FORMAT_STRING \".section\\t\\\"%s\\\"\\n\\t.align 2\\n\"\n+\n /* Override elfos.h definition.  */\n #undef\tINIT_SECTION_ASM_OP\n #define\tINIT_SECTION_ASM_OP \"\\t.section\\t\\\".init\\\",\\\"ax\\\"\""}, {"sha": "a93946d2ec7492b9be6093b35660bf68d032df18", "filename": "gcc/dbxout.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -448,6 +448,9 @@ static void\n dbxout_function_end (void)\n {\n   char lscope_label_name[100];\n+\n+  function_section (current_function_decl);\n+  \n   /* Convert Ltext into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n@@ -728,7 +731,10 @@ dbxout_source_file (FILE *file, const char *filename)\n \t  && DECL_SECTION_NAME (current_function_decl) != NULL_TREE)\n \t; /* Don't change section amid function.  */\n       else\n-\ttext_section ();\n+\t{\n+\t  if (!in_text_section () && !in_unlikely_text_section ())\n+\t    text_section ();\n+\t}\n       targetm.asm_out.internal_label (file, \"Ltext\", source_label_number);\n       source_label_number++;\n       lastfile = filename;"}, {"sha": "efd28af753adcaff8985619f2fd49f305dcf0789", "filename": "gcc/defaults.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -623,10 +623,26 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define HOT_TEXT_SECTION_NAME \"text.hot\"\n #endif\n \n+#ifndef NORMAL_TEXT_SECTION_NAME\n+#define NORMAL_TEXT_SECTION_NAME \".text\"\n+#endif\n+\n #ifndef UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \"text.unlikely\"\n #endif\n \n+#ifndef SECTION_FORMAT_STRING\n+#define SECTION_FORMAT_STRING \"\\t.section\\t%s\\n\\t.align 2\\n\"\n+#endif\n+\n+#ifndef HAS_LONG_COND_BRANCH\n+#define HAS_LONG_COND_BRANCH 0\n+#endif\n+\n+#ifndef HAS_LONG_UNCOND_BRANCH\n+#define HAS_LONG_UNCOND_BRANCH 0\n+#endif\n+\n #ifndef VECTOR_MODE_SUPPORTED_P\n #define VECTOR_MODE_SUPPORTED_P(MODE) 0\n #endif"}, {"sha": "83845f0ea40b070aaee6253d568f46c05ec7841e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -284,7 +284,7 @@ in the following sections.\n -foptimize-sibling-calls  -fprefetch-loop-arrays @gol\n -fprofile-generate -fprofile-use @gol\n -freduce-all-givs  -fregmove  -frename-registers @gol\n--freorder-blocks  -freorder-functions @gol\n+-freorder-blocks  -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -frounding-math -fschedule-insns  -fschedule-insns2 @gol\n -fno-sched-interblock  -fno-sched-spec  -fsched-spec-load @gol\n@@ -3680,7 +3680,7 @@ optimizations designed to reduce code size.\n \n @option{-Os} disables the following optimization flags:\n @gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol\n--falign-labels  -freorder-blocks  -fprefetch-loop-arrays}\n+-falign-labels  -freorder-blocks  -freorder-blocks-and-partition -fprefetch-loop-arrays}\n \n If you use multiple @option{-O} options, with or without level numbers,\n the last such option is the one that is effective.\n@@ -4206,6 +4206,13 @@ taken branches and improve code locality.\n \n Enabled at levels @option{-O2}, @option{-O3}.\n \n+@item -freorder-blocks-and-partition\n+@opindex freorder-blocks-and-partition\n+In addition to reordering basic blocks in the compiled function, in order\n+to reduce number of taken branches, partitions hot and cold basic blocks\n+into separate sections of the assembly and .o files, to improve\n+paging and cache locality performance.\n+\n @item -freorder-functions\n @opindex freorder-functions\n Reorder basic blocks in the compiled function in order to reduce number of"}, {"sha": "746bca587bde0641d5ab2af6ca4605cae7da5202", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -3288,6 +3288,16 @@ This insn uses @var{op}, a @code{code_label} or a @code{note} of type\n be held in a register.  The presence of this note allows jump\n optimization to be aware that @var{op} is, in fact, being used, and flow\n optimization to build an accurate flow graph.\n+\n+@findex REG_CROSSING_JUMP\n+@item REG_CROSSING_JUMP\n+This insn is an branching instruction (either an unconditional jump or\n+an indirect jump) which crosses between hot and cold sections, which\n+could potentially be very far apart in the executable.  The presence\n+of this note indicates to other optimizations that this this branching\n+instruction should not be ``collapsed'' into a simpler branching\n+construct.  It is used when the optimization to partition basic blocks\n+into hot and cold sections is turned on.\n @end table\n \n The following notes describe attributes of outputs of an insn:"}, {"sha": "1d413e0dad5970c115d2bded28c2231bfbcb5d5e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -5802,6 +5802,13 @@ frequently executed functions of the program.  If not defined, GCC will provide\n a default definition if the target supports named sections.\n @end defmac\n \n+@defmac NORMAL_TEXT_SECTION_NAME\n+If defined, a C string constant for the name of the section containing code \n+that does not go into the ``unlikely executed text'' partition.  This is used\n+as part of the optimization that partitions hot and cold basic blocks into\n+separate sections in the .o and executable files.\n+@end defmac\n+\n @defmac UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n If defined, a C string constant for the name of the section containing unlikely\n executed functions in the program.\n@@ -5853,6 +5860,12 @@ finalization code.  If not defined, GCC will assume such a section does\n not exist.\n @end defmac\n \n+@defmac SECTION_FORMAT_STRING\n+If defined, format string used by fprintf to write out the\n+text section headers for the hot and cold sections of the\n+assembly file, when hot and cold partitioning is being performed.\n+@end defmac\n+\n @defmac CRT_CALL_STATIC_FUNCTION (@var{section_op}, @var{function})\n If defined, an ASM statement that switches to a different section\n via @var{section_op}, calls @var{function}, and switches back to\n@@ -8454,6 +8467,24 @@ For each predicate function named in @code{PREDICATE_CODES}, a\n declaration will be generated in @file{insn-codes.h}.\n @end defmac\n \n+@defmac HAS_LONG_COND_BRANCH\n+Define this boolean macro to indicate whether or not your architecture\n+has conditional branches that can span all of memory.  It is used in\n+conjunction with an optimization that partitions hot and cold basic\n+blocks into separate sections of the executable.  If this macro is\n+set to false, gcc will convert any conditional branches that attempt\n+to cross between sections into unconditional branches or indirect jumps.\n+@end defmac\n+\n+@defmac HAS_LONG_UNCOND_BRANCH\n+Define this boolean macro to indicate whether or not your architecture\n+has unconditional branches that can span all of memory.  It is used in\n+conjunction with an optimization that partitions hot and cold basic\n+blocks into separate sections of the executable.  If this macro is\n+set to false, gcc will convert any unconditional branches that attempt\n+to cross between sections into indirect jumps.\n+@end defmac\n+\n @defmac SPECIAL_MODE_PREDICATES\n Define this if you have special predicates that know special things\n about modes.  Genrecog will warn about certain forms of"}, {"sha": "9aa4657b068c2a61b7804d093945255276a1a6a0", "filename": "gcc/final.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -1623,6 +1623,35 @@ output_alternate_entry_point (FILE *file, rtx insn)\n     }\n }\n \n+/* Return boolean indicating if there is a NOTE_INSN_UNLIKELY_EXECUTED_CODE\n+   note in the instruction chain (going forward) between the current\n+   instruction, and the next 'executable' instruction.  */\n+\n+bool\n+scan_ahead_for_unlikely_executed_note (rtx insn)\n+{\n+  rtx temp;\n+  int bb_note_count = 0;\n+\n+  for (temp = insn; temp; temp = NEXT_INSN (temp))\n+    {\n+      if (GET_CODE (temp) == NOTE\n+\t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n+\treturn true;\n+      if (GET_CODE (temp) == NOTE\n+\t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_BASIC_BLOCK)\n+\t{\n+\t  bb_note_count++;\n+\t  if (bb_note_count > 1)\n+\t    return false;\n+\t}\n+      if (INSN_P (temp))\n+\treturn false;\n+    }\n+  \n+  return false;\n+}\n+\n /* The final scan for one insn, INSN.\n    Args are same as in `final', except that INSN\n    is the insn being scanned.\n@@ -1672,7 +1701,31 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_EXPECTED_VALUE:\n \t  break;\n \n+\tcase NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n+\t  \n+\t  /* The presence of this note indicates that this basic block\n+\t     belongs in the \"cold\" section of the .o file.  If we are\n+\t     not already writing to the cold section we need to change\n+\t     to it.  */\n+\t  \n+\t  unlikely_text_section ();\n+\t  break;\n+\t  \n \tcase NOTE_INSN_BASIC_BLOCK:\n+\t  \n+\t  /* If we are performing the optimization that paritions\n+\t     basic blocks into hot & cold sections of the .o file,\n+\t     then at the start of each new basic block, before\n+\t     beginning to write code for the basic block, we need to\n+\t     check to see whether the basic block belongs in the hot\n+\t     or cold section of the .o file, and change the section we\n+\t     are writing to appropriately.  */\n+\t  \n+\t  if (flag_reorder_blocks_and_partition\n+\t      && in_unlikely_text_section()\n+\t      && !scan_ahead_for_unlikely_executed_note (insn))\n+\t    text_section ();\n+\n #ifdef IA64_UNWIND_INFO\n \t  IA64_UNWIND_EMIT (asm_out_file, insn);\n #endif\n@@ -1859,6 +1912,27 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       if (LABEL_NAME (insn))\n \t(*debug_hooks->label) (insn);\n \n+      /* If we are doing the optimization that partitions hot & cold\n+\t basic blocks into separate sections of the .o file, we need\n+\t to ensure the jump table ends up in the correct section...  */\n+      \n+      if (flag_reorder_blocks_and_partition)\n+\t{\n+\t  rtx tmp_table, tmp_label;\n+\t  if (GET_CODE (insn) == CODE_LABEL\n+\t      && tablejump_p (NEXT_INSN (insn), &tmp_label, &tmp_table))\n+\t    {\n+\t      /* Do nothing; Do NOT change the current section.  */\n+\t    }\n+\t  else if (scan_ahead_for_unlikely_executed_note (insn)) \n+\t    unlikely_text_section ();\n+\t  else \n+\t    {\n+\t      if (in_unlikely_text_section ())\n+\t\ttext_section ();\n+\t    }\n+\t}\n+\n       if (app_on)\n \t{\n \t  fputs (ASM_APP_OFF, file);"}, {"sha": "472df5426d608f5e769557e927c7b8d1fa013639", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -210,6 +210,11 @@ extern int flag_branch_probabilities;\n \n extern int flag_reorder_blocks;\n \n+/* Nonzero if basic blocks should be partitioned into hot and cold\n+   sections of the .o file, in addition to being reordered.  */\n+\n+extern int flag_reorder_blocks_and_partition;\n+\n /* Nonzero if functions should be reordered.  */\n \n extern int flag_reorder_functions;"}, {"sha": "f0802372f7bc97227c7445f63ca6d7a438b8f67b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -2851,6 +2851,18 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   edge then_succ = then_bb->succ;\n   int then_bb_index;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && ((BB_END (then_bb) \n+\t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n+\t  || (BB_END (else_bb)\n+\t      && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+\t\t\t\tNULL_RTX))))\n+    return FALSE;\n+\n   /* THEN has one successor.  */\n   if (!then_succ || then_succ->succ_next != NULL)\n     return FALSE;\n@@ -2919,6 +2931,18 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   edge else_succ = else_bb->succ;\n   rtx note;\n \n+  /* If we are partitioning hot/cold basic blocks, we don't want to\n+     mess up unconditional or indirect jumps that cross between hot\n+     and cold sections.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && ((BB_END (then_bb)\n+\t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n+\t  || (BB_END (else_bb) \n+\t      && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+\t\t\t\tNULL_RTX))))\n+    return FALSE;\n+\n   /* ELSE has one successor.  */\n   if (!else_succ || else_succ->succ_next != NULL)\n     return FALSE;\n@@ -3263,7 +3287,8 @@ if_convert (int x_life_data_ok)\n   num_true_changes = 0;\n   life_data_ok = (x_life_data_ok != 0);\n \n-  if (! targetm.cannot_modify_jumps_p ())\n+  if ((! targetm.cannot_modify_jumps_p ())\n+      && (!flag_reorder_blocks_and_partition || !no_new_pseudos))\n     mark_loop_exit_edges ();\n \n   /* Free up basic_block_for_insn so that we don't have to keep it"}, {"sha": "a2df41a489af6dcde8d56a8e9bfc911d58e012cf", "filename": "gcc/opts.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -592,6 +592,7 @@ decode_options (unsigned int argc, const char **argv)\n \t or less automatically remove extra jumps, but would also try to\n \t use more short jumps instead of long jumps.  */\n       flag_reorder_blocks = 0;\n+      flag_reorder_blocks_and_partition = 0;\n     }\n \n   if (optimize_size)\n@@ -657,6 +658,19 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (flag_really_no_inline == 2)\n     flag_really_no_inline = flag_no_inline;\n+\n+  /* The optimization to partition hot and cold basic blocks into separate\n+     sections of the .o and executable files does not work (currently)\n+     with exception handling.  If flag_exceptions is turned on we need to\n+     turn off the partitioning optimization.  */\n+\n+  if (flag_exceptions && flag_reorder_blocks_and_partition)\n+    {\n+      warning \n+\t    (\"-freorder-blocks-and-partition does not work with exceptions\");\n+      flag_reorder_blocks_and_partition = 0;\n+      flag_reorder_blocks = 1;\n+    }\n }\n \n /* Handle target- and language-independent options.  Return zero to\n@@ -1268,6 +1282,10 @@ common_handle_option (size_t scode, const char *arg,\n       flag_reorder_blocks = value;\n       break;\n \n+    case OPT_freorder_blocks_and_partition:\n+      flag_reorder_blocks_and_partition = value;\n+      break;\n+  \n     case OPT_freorder_functions:\n       flag_reorder_functions = value;\n       break;"}, {"sha": "9040327879c861dceab85de17a268345999f25c5", "filename": "gcc/output.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -162,6 +162,9 @@ extern void check_function_return_warnings (void);\n /* Tell assembler to switch to text section.  */\n extern void text_section (void);\n \n+/* Tell assembler to switch to unlikely-to-be-executed text section.  */\n+extern void unlikely_text_section (void);\n+\n /* Tell assembler to switch to data section.  */\n extern void data_section (void);\n \n@@ -172,6 +175,9 @@ extern void readonly_data_section (void);\n /* Determine if we're in the text section.  */\n extern int in_text_section (void);\n \n+/* Determine if we're in the unlikely-to-be-executed text section.  */\n+extern int in_unlikely_text_section (void);\n+\n #ifdef CTORS_SECTION_ASM_OP\n extern void ctors_section (void);\n #endif"}, {"sha": "2453c748dc3507574d879aaf7b0f4c6d21f16545", "filename": "gcc/passes.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -522,7 +522,7 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n     {\n       if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n \t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n-\t  && flag_reorder_blocks)\n+\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n \t{\n \t  reorder_basic_blocks ();\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n@@ -718,9 +718,9 @@ rest_of_handle_reorder_blocks (tree decl, rtx insns)\n \n   if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n     tracer ();\n-  if (flag_reorder_blocks)\n+  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n     reorder_basic_blocks ();\n-  if (flag_reorder_blocks\n+  if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n       || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n     changed |= cleanup_cfg (CLEANUP_EXPENSIVE\n \t\t\t    | (!HAVE_conditional_execution\n@@ -1806,6 +1806,20 @@ rest_of_compilation (tree decl)\n   if (flag_if_conversion)\n     rest_of_handle_if_after_combine (decl, insns);\n \n+  /* The optimization to partition hot/cold basic blocks into separate\n+     sections of the .o file does not work well with exception handling.\n+     Don't call it if there are exceptions. */\n+\n+  if (flag_reorder_blocks_and_partition && !flag_exceptions)\n+    {\n+      no_new_pseudos = 0;\n+      partition_hot_cold_basic_blocks ();\n+      allocate_reg_life_data ();\n+      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, \n+\t\t\tPROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+      no_new_pseudos = 1;\n+    }\n+\n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n     rest_of_handle_regmove (decl, insns);\n "}, {"sha": "6562afcc5242cade3b92d28c9ebc0082a74743d2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -291,6 +291,14 @@ print_rtx (rtx in_rtx)\n \t\t  fprintf (outfile, \" [ ERROR ]\");\n \t\tbreak;\n \n+\t      case NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n+\t\t{\n+\t\t  basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t\t  if (bb != 0)\n+\t\t    fprintf (outfile, \" [bb %d]\", bb->index);\n+\t\t  break;\n+\t\t}\n+\t\t\n \t      case NOTE_INSN_VAR_LOCATION:\n \t\tfprintf (outfile, \" (\");\n \t\tprint_mem_expr (outfile, NOTE_VAR_LOCATION_DECL (in_rtx));"}, {"sha": "59d77999c2b717804ed51fde803783db0998cd9c", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -122,7 +122,9 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n   \"NOTE_INSN_REPEATED_LINE_NUMBER\",\n   \"NOTE_INSN_BASIC_BLOCK\", \"NOTE_INSN_EXPECTED_VALUE\",\n-  \"NOTE_INSN_PREDICTION\", \"NOTE_INSN_VAR_LOCATION\"\n+  \"NOTE_INSN_PREDICTION\",\n+  \"NOTE_INSN_UNLIKELY_EXECUTED_CODE\",\n+  \"NOTE_INSN_VAR_LOCATION\"\n };\n \n const char * const reg_note_name[] =\n@@ -134,7 +136,7 @@ const char * const reg_note_name[] =\n   \"REG_VALUE_PROFILE\", \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\",\n   \"REG_FRAME_RELATED_EXPR\", \"REG_EH_CONTEXT\", \"REG_EH_REGION\",\n   \"REG_SAVE_NOTE\", \"REG_MAYBE_DEAD\", \"REG_NORETURN\",\n-  \"REG_NON_LOCAL_GOTO\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\",\n+  \"REG_NON_LOCAL_GOTO\", \"REG_CROSSING_JUMP\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\",\n   \"REG_VTABLE_REF\"\n };\n "}, {"sha": "f6ebe34caa4c4856c624560efb48f129b5d57bcd", "filename": "gcc/rtl.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -857,6 +857,11 @@ enum reg_note\n      computed goto.  */\n   REG_NON_LOCAL_GOTO,\n \n+  /* Indicates that a jump crosses between hot and cold sections\n+     in a (partitioned) assembly or .o file, and therefore should not be\n+     reduced to a simpler jump by optimizations.  */\n+  REG_CROSSING_JUMP,\n+\n   /* This kind of note is generated at each to `setjmp',\n      and similar functions that can return twice.  */\n   REG_SETJMP,\n@@ -1018,6 +1023,10 @@ enum insn_note\n   /* Record a prediction.  Uses NOTE_PREDICTION.  */\n   NOTE_INSN_PREDICTION,\n \n+  /* Record that the current basic block is unlikely to be executed and\n+     should be moved to the UNLIKELY_EXECUTED_TEXT_SECTION.  */\n+  NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n+\n   /* The location of a variable.  */\n   NOTE_INSN_VAR_LOCATION,\n "}, {"sha": "39b2ddf1f6f2e116586592ee91922c4e25075c25", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -249,6 +249,11 @@ int flag_branch_probabilities = 0;\n \n int flag_reorder_blocks = 0;\n \n+/* Nonzero if blocks should be partitioned into hot and cold sections in\n+   addition to being reordered. */\n+\n+int flag_reorder_blocks_and_partition = 0;\n+\n /* Nonzero if functions should be reordered.  */\n \n int flag_reorder_functions = 0;\n@@ -955,6 +960,7 @@ static const lang_independent_options f_options[] =\n   {\"branch-probabilities\", &flag_branch_probabilities, 1 },\n   {\"profile\", &profile_flag, 1 },\n   {\"reorder-blocks\", &flag_reorder_blocks, 1 },\n+  {\"reorder-blocks-and-partition\", &flag_reorder_blocks_and_partition, 1},\n   {\"reorder-functions\", &flag_reorder_functions, 1 },\n   {\"rename-registers\", &flag_rename_registers, 1 },\n   {\"cprop-registers\", &flag_cprop_registers, 1 },"}, {"sha": "c35c9b7773ece8cbdf8d3454063dd30d47af411d", "filename": "gcc/varasm.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750054a2ee1925e265b1b6209a7ca0b0df2bcc04/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=750054a2ee1925e265b1b6209a7ca0b0df2bcc04", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"debug.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n+#include \"cfglayout.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -100,6 +101,14 @@ int size_directive_output;\n \n tree last_assemble_variable_decl;\n \n+/* The following global variable indicates if the section label for the\n+   \"cold\" section of code has been output yet to the assembler.  The\n+   label is useful when running gdb.  This is part of the optimization that\n+   partitions hot and cold basic blocks into separate sections of the .o\n+   file.  */\n+\n+bool unlikely_section_label_printed = false;\n+\n /* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.\n    So giving constant the alias set for the type will allow such\n    initializations to appear to conflict with the load of the constant.  We\n@@ -145,7 +154,8 @@ static bool asm_emit_uninitialised (tree, const char*,\n \t\t\t\t    unsigned HOST_WIDE_INT);\n static void mark_weak (tree);\n \f\n-enum in_section { no_section, in_text, in_data, in_named\n+enum in_section { no_section, in_text, in_unlikely_executed_text, in_data, \n+\t\t  in_named\n #ifdef BSS_SECTION_ASM_OP\n   , in_bss\n #endif\n@@ -198,7 +208,34 @@ text_section (void)\n   if (in_section != in_text)\n     {\n       in_section = in_text;\n-      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n+      fprintf (asm_out_file, SECTION_FORMAT_STRING, NORMAL_TEXT_SECTION_NAME);\n+    }\n+}\n+\n+/* Tell assembler to switch to unlikely-to-be-executed text section.  */\n+\n+void\n+unlikely_text_section (void)\n+{\n+  if ((in_section != in_unlikely_executed_text)\n+      &&  (in_section != in_named \n+\t   || strcmp (in_named_name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) != 0))\n+    {\n+#ifdef TARGET_ASM_NAMED_SECTION\n+\t\n+      named_section (NULL_TREE, UNLIKELY_EXECUTED_TEXT_SECTION_NAME, 0);\n+      \n+#else\n+      in_section = in_unlikely_executed_text;\n+      fprintf (asm_out_file, SECTION_FORMAT_STRING, \n+\t       UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n+#endif /* ifdef TARGET_ASM_NAMED_SECTION */\n+      if (!unlikely_section_label_printed)\n+\t{\n+\t  fprintf (asm_out_file, \"__%s_unlikely_section:\\n\", \n+\t\t   current_function_name ());\n+\t  unlikely_section_label_printed = true;\n+\t}\n     }\n }\n \n@@ -244,6 +281,14 @@ in_text_section (void)\n   return in_section == in_text;\n }\n \n+/* Determine if we're in the unlikely-to-be-executed text section.  */\n+\n+int\n+in_unlikely_text_section (void)\n+{\n+  return in_section == in_unlikely_executed_text;\n+}\n+\n /* Determine if we're in the data section.  */\n \n int\n@@ -483,11 +528,16 @@ asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n void\n function_section (tree decl)\n {\n-  if (decl != NULL_TREE\n-      && DECL_SECTION_NAME (decl) != NULL_TREE)\n-    named_section (decl, (char *) 0, 0);\n+  if (scan_ahead_for_unlikely_executed_note (get_insns()))\n+    unlikely_text_section ();\n   else\n-    text_section ();\n+    {\n+      if (decl != NULL_TREE\n+\t  && DECL_SECTION_NAME (decl) != NULL_TREE)\n+\tnamed_section (decl, (char *) 0, 0);\n+      else\n+\ttext_section (); \n+    }\n }\n \n /* Switch to section for variable DECL.  RELOC is the same as the\n@@ -1030,6 +1080,8 @@ assemble_start_function (tree decl, const char *fnname)\n {\n   int align;\n \n+  unlikely_section_label_printed = false;\n+\n   /* The following code does not need preprocessing in the assembler.  */\n \n   app_disable ();\n@@ -1117,7 +1169,8 @@ assemble_zeros (unsigned HOST_WIDE_INT size)\n #ifdef ASM_NO_SKIP_IN_TEXT\n   /* The `space' pseudo in the text section outputs nop insns rather than 0s,\n      so we must output 0s explicitly in the text section.  */\n-  if (ASM_NO_SKIP_IN_TEXT && in_text_section ())\n+  if ((ASM_NO_SKIP_IN_TEXT && in_text_section ())\n+      || (ASM_NO_SKIP_IN_TEXT && in_unlikely_text_section ()))\n     {\n       unsigned HOST_WIDE_INT i;\n       for (i = 0; i < size; i++)\n@@ -1479,7 +1532,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   variable_section (decl, reloc);\n \n   /* dbxout.c needs to know this.  */\n-  if (in_text_section ())\n+  if (in_text_section () || in_unlikely_text_section ())\n     DECL_IN_TEXT_SECTION (decl) = 1;\n \n   /* Output the alignment of this data.  */\n@@ -4328,6 +4381,8 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n     flags = SECTION_CODE;\n   else if (decl && decl_readonly_section_1 (decl, reloc, shlib))\n     flags = 0;\n+  else if (strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n+    flags = SECTION_CODE;\n   else\n     flags = SECTION_WRITE;\n "}]}