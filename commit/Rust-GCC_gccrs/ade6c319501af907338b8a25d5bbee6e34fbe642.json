{"sha": "ade6c319501af907338b8a25d5bbee6e34fbe642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRlNmMzMTk1MDFhZjkwNzMzOGI4YTI1ZDViYmVlNmUzNGZiZTY0Mg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-05-31T19:02:47Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-05-31T19:02:47Z"}, "message": "Add -mabi=n32 support.\n\n(mips_const_double_ok, mips_move_1word, mips_move_2words,\nfunction_arg, override_options, mips_asm_file_start,\ncompute_frame_size, save_restore_insns, function_prologue,\nmips_expand_prologue, function_epilogue, mips_function_value): Modify.\n(mips_abi, mips_abi_string): Define\n\nFrom-SVN: r12133", "tree": {"sha": "ffb56b7c7855347fa07076bf66f185d4d5fb0cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffb56b7c7855347fa07076bf66f185d4d5fb0cd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ade6c319501af907338b8a25d5bbee6e34fbe642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade6c319501af907338b8a25d5bbee6e34fbe642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade6c319501af907338b8a25d5bbee6e34fbe642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade6c319501af907338b8a25d5bbee6e34fbe642/comments", "author": null, "committer": null, "parents": [{"sha": "0bc25b2b460c1fce8a443fb3ac1e8dc60b139630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc25b2b460c1fce8a443fb3ac1e8dc60b139630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bc25b2b460c1fce8a443fb3ac1e8dc60b139630"}], "stats": {"total": 104, "additions": 85, "deletions": 19}, "files": [{"sha": "ee17847b20b161df2a101307570c7a71c4d4ef48", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 85, "deletions": 19, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade6c319501af907338b8a25d5bbee6e34fbe642/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade6c319501af907338b8a25d5bbee6e34fbe642/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ade6c319501af907338b8a25d5bbee6e34fbe642", "patch": "@@ -192,9 +192,16 @@ enum processor_type mips_cpu;\n /* which instruction set architecture to use.  */\n int mips_isa;\n \n+#ifdef MIPS_ABI_DEFAULT\n+/* which ABI to use.  This is defined to a constant in mips.h if the target\n+   doesn't support multiple ABIs.  */\n+enum mips_abi_type mips_abi;\n+#endif\n+\n /* Strings to hold which cpu and instruction set architecture to use.  */\n char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n+char *mips_abi_string;\t\t/* for -mabi={32,n32,64} */\n \n /* Generating calls to position independent functions?  */\n enum mips_abicalls_type mips_abicalls;\n@@ -487,7 +494,7 @@ mips_const_double_ok (op, mode)\n     return TRUE;\n \n   /* ??? li.s does not work right with SGI's Irix 6 assembler.  */\n-  if (ABI_64BIT)\n+  if (mips_abi != ABI_32)\n     return FALSE;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n@@ -1076,7 +1083,9 @@ mips_move_1word (operands, insn, unsignedp)\n \t    }\n \n \t  else if (GP_REG_P (regno0))\n-\t    ret = (INTVAL (op1) < 0) ? \"li\\t%0,%1\\t\\t\\t# %X1\" : \"li\\t%0,%X1\\t\\t# %1\";\n+\t    /* Don't use X format, because that will give out of range\n+\t       numbers for 64 bit host and 32 bit target.  */\n+\t    ret = \"li\\t%0,%1\\t\\t\\t# %X1\";\n \t}\n \n       else if (code1 == CONST_DOUBLE && mode == SFmode)\n@@ -1463,11 +1472,17 @@ mips_move_2words (operands, insn)\n \t\t   a number that the assembler won't accept.  */\n \t\tret = \"dli\\t%0,%X1\\t\\t# %1\";\n \t    }\n-\t  else\n+\t  else if (HOST_BITS_PER_WIDE_INT < 64)\n \t    {\n \t      operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n \t      ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n \t    }\n+\t  else\n+\t    {\n+\t      operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n+\t      operands[1] = GEN_INT (INTVAL (operands[1]) << 32 >> 32);\n+\t      ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n+\t    }\n \t}\n \n       else if (code1 == MEM)\n@@ -2877,7 +2892,7 @@ function_arg (cum, mode, type, named)\n   switch (mode)\n     {\n     case SFmode:\n-      if (! ABI_64BIT || mips_isa < 3)\n+      if (mips_abi == ABI_32)\n \t{\n \t  if (cum->gp_reg_found || cum->arg_number >= 2 || TARGET_SOFT_FLOAT)\n \t    regbase = GP_ARG_FIRST;\n@@ -2897,7 +2912,7 @@ function_arg (cum, mode, type, named)\n     case DFmode:\n       if (! TARGET_64BIT)\n \tcum->arg_words += (cum->arg_words & 1);\n-      if (! ABI_64BIT || mips_isa < 3)\n+      if (mips_abi == ABI_32)\n \tregbase = ((cum->gp_reg_found\n \t\t    || TARGET_SOFT_FLOAT\n \t\t    || TARGET_SINGLE_FLOAT\n@@ -3114,6 +3129,57 @@ override_options ()\n       mips_isa = 1;\n     }\n \n+#ifdef MIPS_ABI_DEFAULT\n+  /* Get the ABI to use.  Currently this code is only used for Irix 6.  */\n+  if (mips_abi_string == (char *) 0)\n+    mips_abi = MIPS_ABI_DEFAULT;\n+  else if (! strcmp (mips_abi_string, \"32\"))\n+    mips_abi = ABI_32;\n+  else if (! strcmp (mips_abi_string, \"n32\"))\n+    mips_abi = ABI_N32;\n+  else if (! strcmp (mips_abi_string, \"64\"))\n+    mips_abi = ABI_64;\n+  else\n+    error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n+\n+  /* A specified ISA defaults the ABI if it was not specified.  */\n+  if (mips_abi_string == 0 && mips_isa_string)\n+    {\n+      if (mips_isa <= 2)\n+\tmips_abi = ABI_32;\n+      else\n+\tmips_abi = ABI_64;\n+    }\n+  /* A specified ABI defaults the ISA if it was not specified.  */\n+  else if (mips_isa_string == 0 && mips_abi_string)\n+    {\n+      if (mips_abi == ABI_32)\n+\tmips_isa = 1;\n+      else if (mips_abi == ABI_N32)\n+\tmips_isa = 3;\n+      else\n+\tmips_isa = 4;\n+    }\n+  /* If both ABI and ISA were specified, check for conflicts.  */\n+  else if (mips_isa_string && mips_abi_string)\n+    {\n+      if ((mips_isa <= 2 && (mips_abi == ABI_N32 || mips_abi == ABI_64))\n+\t  || (mips_isa >= 3 && mips_abi == ABI_32))\n+\terror (\"-mabi=%s does not support -mips%d\", mips_abi_string, mips_isa);\n+    }\n+\n+  /* Override TARGET_DEFAULT if necessary.  */\n+  if (mips_abi == ABI_32)\n+    target_flags &= ~ (MASK_FLOAT64|MASK_64BIT);\n+\n+  /* ??? This doesn't work yet, so don't let people try to use it.  */\n+  if (mips_abi == ABI_32)\n+    error (\"The -mabi=32 support does not work yet.\");\n+#else\n+  if (mips_abi_string)\n+    error (\"This target does not support the -mabi switch.\");\n+#endif\n+\n #ifdef MIPS_CPU_STRING_DEFAULT\n   /* ??? There is a minor inconsistency here.  If the user specifies an ISA\n      greater than that supported by the default processor, then the user gets\n@@ -3232,7 +3298,7 @@ override_options ()\n \tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit gp registers\");\n     }\n \n-  if (ABI_64BIT && mips_isa >= 3)\n+  if (mips_abi != ABI_32)\n     flag_pcc_struct_return = 0;\n \n   /* Tell halfpic.c that we have half-pic code if we do.  */\n@@ -4100,7 +4166,7 @@ mips_asm_file_start (stream)\n \n   /* Start a section, so that the first .popsection directive is guaranteed\n      to have a previously defined section to pop back to.  */\n-  if (ABI_64BIT && mips_isa >= 3)\n+  if (mips_abi != ABI_32)\n     fprintf (stream, \"\\t.section\\t.text\\n\");\n \n   /* This code exists so that we can put all externs before all symbol\n@@ -4447,7 +4513,7 @@ compute_frame_size (size)\n      for leaf routines (total_size == extra_size) to save the gp reg.\n      The gp reg is callee saved in the 64 bit ABI, so all routines must\n      save the gp reg.  */\n-  if (total_size == extra_size && ! (ABI_64BIT && mips_isa >= 3))\n+  if (total_size == extra_size && mips_abi == ABI_32)\n     total_size = extra_size = 0;\n   else if (TARGET_ABICALLS)\n     {\n@@ -4461,7 +4527,7 @@ compute_frame_size (size)\n \n   /* Add in space reserved on the stack by the callee for storing arguments\n      passed in registers.  */\n-  if (ABI_64BIT && mips_isa >= 3)\n+  if (mips_abi != ABI_32)\n     total_size += MIPS_STACK_ALIGN (current_function_pretend_args_size);\n \n   /* Save other computed information.  */\n@@ -4624,13 +4690,13 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n \t\t  if (store_p)\n \t\t    emit_move_insn (mem_rtx, reg_rtx);\n-\t\t  else if (!TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3)\n+\t\t  else if (!TARGET_ABICALLS || mips_abi != ABI_32\n \t\t\t   || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (store_p || !TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3)\n+\t\t  if (store_p || !TARGET_ABICALLS || mips_abi != ABI_32\n \t\t      || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    fprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n \t\t\t     (TARGET_64BIT\n@@ -4803,7 +4869,7 @@ function_prologue (file, size)\n \t   current_frame_info.fmask,\n \t   current_frame_info.fp_save_offset);\n \n-  if (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3))\n+  if (TARGET_ABICALLS && mips_abi == ABI_32)\n     {\n       char *sp_str = reg_names[STACK_POINTER_REGNUM];\n \n@@ -4928,7 +4994,7 @@ mips_expand_prologue ()\n \n   /* If this function is a varargs function, store any registers that\n      would normally hold arguments ($4 - $7) on the stack.  */\n-  if ((! ABI_64BIT || mips_isa < 3)\n+  if (mips_abi == ABI_32\n       && ((TYPE_ARG_TYPES (fntype) != 0\n \t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype))) != void_type_node))\n \t  || (arg_name != (char *)0\n@@ -4939,7 +5005,7 @@ mips_expand_prologue ()\n       rtx ptr = stack_pointer_rtx;\n \n       /* If we are doing svr4-abi, sp has already been decremented by tsize. */\n-      if (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3))\n+      if (TARGET_ABICALLS)\n \toffset += tsize;\n \n       for (; regno <= GP_ARG_LAST; regno++)\n@@ -4957,7 +5023,7 @@ mips_expand_prologue ()\n       rtx tsize_rtx = GEN_INT (tsize);\n \n       /* If we are doing svr4-abi, sp move is done by function_prologue.  */\n-      if (!TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3))\n+      if (!TARGET_ABICALLS || mips_abi != ABI_32)\n \t{\n \t  if (tsize > 32767)\n \t    {\n@@ -4984,7 +5050,7 @@ mips_expand_prologue ()\n \t    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \t}\n \n-      if (TARGET_ABICALLS && (ABI_64BIT && mips_isa >= 3))\n+      if (TARGET_ABICALLS && mips_abi != ABI_32)\n \temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0)));\n     }\n \n@@ -5107,7 +5173,7 @@ function_epilogue (file, size)\n       save_restore_insns (FALSE, tmp_rtx, tsize, file);\n \n       load_only_r31 = (((current_frame_info.mask\n-\t\t\t & ~ (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3)\n+\t\t\t & ~ (TARGET_ABICALLS && mips_abi == ABI_32\n \t\t\t      ? PIC_OFFSET_TABLE_MASK : 0))\n \t\t\t== RA_MASK)\n \t\t       && current_frame_info.fmask == 0);\n@@ -5428,7 +5494,7 @@ mips_select_section (decl, reloc)\n     }\n }\n \f\n-#if ABI_64BIT\n+#ifdef MIPS_ABI_DEFAULT\n /* Support functions for the 64 bit ABI.  */\n \n /* Return the register to be used for word INDEX of a variable with type TYPE\n@@ -5483,7 +5549,7 @@ mips_function_value (valtype, func)\n \n   if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n     reg = FP_RETURN;\n-  else if (TREE_CODE (valtype) == RECORD_TYPE && mips_isa >= 3)\n+  else if (TREE_CODE (valtype) == RECORD_TYPE && mips_abi != ABI_32)\n     {\n       /* A struct with only one or two floating point fields is returned in\n \t the floating point registers.  */"}]}