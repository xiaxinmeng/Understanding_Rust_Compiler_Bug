{"sha": "3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk1NjI0NGM1OGFjY2VlYmYxZWYyY2Y5YTYzZTk5ZjBmODJhYmNiNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-05-18T21:07:48Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-05-18T21:07:48Z"}, "message": "PR middle-end/94940 - spurious -Warray-bounds for a zero length array member of union\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/94940\n\t* gcc.dg/Warray-bounds-61.c: New test.\n\ngcc/ChangeLog:\n\n\tPR middle-end/94940\n\t* tree-vrp.c (vrp_prop::check_mem_ref): Remove unreachable code.\n\t* tree.c (component_ref_size): Correct the handling or array members\n\tof unions.\n\tDrop a pointless test.\n\tRename a local variable.", "tree": {"sha": "8f8e1b8c745a4a28fe13858fa9714341af118a59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f8e1b8c745a4a28fe13858fa9714341af118a59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "628bb8040858e0b3446e5f6740c0c0f557d3abdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628bb8040858e0b3446e5f6740c0c0f557d3abdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628bb8040858e0b3446e5f6740c0c0f557d3abdc"}], "stats": {"total": 276, "additions": 237, "deletions": 39}, "files": [{"sha": "135ebca56c41af297ce1400ba3ee538e7a819bf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "patch": "@@ -1,3 +1,12 @@\n+2020-05-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/94940\n+\t* tree-vrp.c (vrp_prop::check_mem_ref): Remove unreachable code.\n+\t* tree.c (component_ref_size): Correct the handling or array members\n+\tof unions.\n+\tDrop a pointless test.\n+\tRename a local variable.\n+\n 2020-05-18  Jason Merrill  <jason@redhat.com>\n \n \t* aclocal.m4: Add ax_cxx_compile_stdcxx.m4."}, {"sha": "8b86b7a15450dca3dcccf1fb57e76857188177a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "patch": "@@ -1,3 +1,8 @@\n+2020-05-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/94940\n+\t* gcc.dg/Warray-bounds-61.c: New test.\n+\n 2020-05-18  Marek Polacek  <polacek@redhat.com>\n \n \tDR 1512"}, {"sha": "5b66cdc0aab1a475cf5c0dde281a204655b332c3", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-61.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-61.c?ref=3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "patch": "@@ -0,0 +1,190 @@\n+/* PR middle-end/94940 - spurious -Warray-bounds for a zero length array\n+   member of union\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+extern int n;\n+\n+extern union Ua3_a0 {\n+  int a3[3];\n+  int a2[2];                  // can only alias a3[0 - 2]\n+  int a1[1];                  // can alias all of the union\n+  int a0[0];                  // ditto\n+} ua3_a0;\n+\n+void test_ua3_ua0_a0 (int i)\n+{\n+  ua3_a0.a0[0] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a0[1] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a0[2] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a0[3] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a0[4] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a0[i] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+\n+  if (i < __LINE__)\n+    i = 5;\n+  ua3_a0.a0[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  if (i > -1)\n+    i = -1;\n+  ua3_a0.a0[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_ua3_ua0_a1 (int i)\n+{\n+  /* Abusing one-element array members the same way as those of\n+     length zero is discouraged but so far acceted without warnings.\n+     This should change at some point.  */\n+\n+  ua3_a0.a1[0] = 0;\n+  ua3_a0.a1[1] = 0;\n+  ua3_a0.a1[2] = 0;\n+  ua3_a0.a1[3] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a1[i] = 0;\n+\n+  if (i > -1)\n+    i = -1;\n+  ua3_a0.a1[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  if (i < 7)\n+    i = 7;\n+  ua3_a0.a1[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_ua3_ua0_a2 (int i)\n+{\n+  ua3_a0.a2[0] = 0;\n+  ua3_a0.a2[1] = 0;\n+  ua3_a0.a2[2] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ua3_a0.a2[i] = 0;\n+\n+  if (i < __LINE__)\n+    i = __LINE__;\n+  ua3_a0.a2[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  if (i > -1)\n+    i = -1;\n+  ua3_a0.a2[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+extern union Ua2_a3 {\n+  int a2[2];                  // can only alias a3[0 - 1]\n+  int a3[3];\n+} ua2_a3;\n+\n+void test_ua2_ua3 (int i)\n+{\n+  ua2_a3.a2[0] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  ua2_a3.a2[1] = 0;           // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  ua2_a3.a2[2] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ua2_a3.a2[i] = 0;\n+\n+  if (i < __LINE__)\n+    i = __LINE__;\n+  ua2_a3.a2[i] = 0;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+extern struct SUa2_a0 {\n+  union Ua2_a0 {\n+    int a2[2];\n+    int a0[0];\n+  } u;\n+} sua2_a0;\n+\n+void test_sua2_sua0 (int i)\n+{\n+  n += sua2_a0.u.a0[0];\n+  n += sua2_a0.u.a0[1];\n+  n += sua2_a0.u.a0[2];       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  n += sua2_a0.u.a0[i];\n+\n+  if (i < __LINE__)\n+    i = __LINE__;\n+  n += sua2_a0.u.a0[i];       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_sua2_sua0_ptr (int i)\n+{\n+  union Ua2_a0 *p = &sua2_a0.u;\n+\n+  n += p->a0[0];\n+  n += p->a0[1];\n+  n += p->a0[2];              // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  n += p->a0[i];\n+}\n+\n+\n+extern struct SUSa3_a0 {\n+  union USa3_a0 {\n+    struct {\n+      int a3[3];\n+    } s;\n+    int a2[2];                // can alias s.a3[0 - 2]\n+    int a1[1];                // can alias s.a3[0 - 2]\n+    int a0[0];                // can alias s.a3[0]\n+  } u;\n+} susa3_ua0;\n+\n+void test_susa3_sua0 (int i, int j)\n+{\n+  n += susa3_ua0.u.a0[0];\n+  n += susa3_ua0.u.a0[1];\n+  n += susa3_ua0.u.a0[2];\n+  n += susa3_ua0.u.a0[3];     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_susa3_sua0_ptr (int i, int j)\n+{\n+  union USa3_a0 *p = &susa3_ua0.u;\n+  n += p->a0[0];\n+  n += p->a0[1];\n+  n += p->a0[2];\n+  n += p->a0[3];              // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_susa3_sua1 (int i)\n+{\n+  n += susa3_ua0.u.a1[0];\n+  n += susa3_ua0.u.a1[1];\n+  n += susa3_ua0.u.a1[2];\n+  n += susa3_ua0.u.a1[3];     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  if (i < __LINE__)\n+    i = __LINE__;\n+  n += susa3_ua0.u.a1[i];     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_susa3_sua2 (void)\n+{\n+  n += susa3_ua0.u.a2[0];\n+  n += susa3_ua0.u.a2[1];\n+  n += susa3_ua0.u.a2[2];     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  n += susa3_ua0.u.a2[3];     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+extern struct {\n+  union {\n+    struct {\n+      int a3[3];\n+    } s1;\n+    struct {\n+      int a0[0];\n+    } s2;\n+  } u;\n+} susa3_usa0;\n+\n+void test_susi3_susi0 (int i)\n+{\n+  n += susa3_usa0.u.s2.a0[0];\n+  n += susa3_usa0.u.s2.a0[1];\n+  n += susa3_usa0.u.s2.a0[2];\n+  n += susa3_usa0.u.s2.a0[3]; // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  n += susa3_usa0.u.s2.a0[i];\n+\n+  if (i < __LINE__)\n+    i = __LINE__;\n+  n += susa3_usa0.u.s2.a0[i]; // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "67c76db8fb1f85005e5abd228e789275588d203a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "patch": "@@ -4009,15 +4009,11 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n       else\n \tarrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n \n-      if (TREE_CODE (ref) == MEM_REF)\n-\t{\n-\t  /* For MEM_REF determine a tighter bound of the non-array\n-\t     element type.  */\n-\t  tree eltype = TREE_TYPE (reftype);\n-\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n-\t    eltype = TREE_TYPE (eltype);\n-\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n-\t}\n+      /* Determine a tighter bound of the non-array element type.  */\n+      tree eltype = TREE_TYPE (reftype);\n+      while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\teltype = TREE_TYPE (eltype);\n+      eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n     }\n   else\n     {\n@@ -4050,27 +4046,17 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n       if (TREE_CODE (reftype) != ARRAY_TYPE)\n \treftype = build_array_type_nelts (reftype, 1);\n \n-      if (TREE_CODE (ref) == MEM_REF)\n-\t{\n-\t  /* Extract the element type out of MEM_REF and use its size\n-\t     to compute the index to print in the diagnostic; arrays\n-\t     in MEM_REF don't mean anything.  A type with no size like\n-\t     void is as good as having a size of 1.  */\n-\t  tree type = TREE_TYPE (ref);\n-\t  while (TREE_CODE (type) == ARRAY_TYPE)\n-\t    type = TREE_TYPE (type);\n-\t  if (tree size = TYPE_SIZE_UNIT (type))\n-\t    {\n-\t      offrange[0] = offrange[0] / wi::to_offset (size);\n-\t      offrange[1] = offrange[1] / wi::to_offset (size);\n-\t    }\n-\t}\n-      else\n+      /* Extract the element type out of MEM_REF and use its size\n+\t to compute the index to print in the diagnostic; arrays\n+\t in MEM_REF don't mean anything.  A type with no size like\n+\t void is as good as having a size of 1.  */\n+      tree type = TREE_TYPE (ref);\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+\ttype = TREE_TYPE (type);\n+      if (tree size = TYPE_SIZE_UNIT (type))\n \t{\n-\t  /* For anything other than MEM_REF, compute the index to\n-\t     print in the diagnostic as the offset over element size.  */\n-\t  offrange[0] = offrange[0] / eltsize;\n-\t  offrange[1] = offrange[1] / eltsize;\n+\t  offrange[0] = offrange[0] / wi::to_offset (size);\n+\t  offrange[1] = offrange[1] / wi::to_offset (size);\n \t}\n \n       bool warned;"}, {"sha": "54e471acc8906b63d1bff5def6c6b600616f0caa", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3956244c58acceebf1ef2cf9a63e99f0f82abcb7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "patch": "@@ -13600,6 +13600,10 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n   if (!interior_zero_length)\n     interior_zero_length = &int_0_len;\n \n+  /* The object/argument referenced by the COMPONENT_REF and its type.  */\n+  tree arg = TREE_OPERAND (ref, 0);\n+  tree argtype = TREE_TYPE (arg);\n+  /* The referenced member.  */\n   tree member = TREE_OPERAND (ref, 1);\n \n   tree memsize = DECL_SIZE_UNIT (member);\n@@ -13611,7 +13615,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \n       bool trailing = array_at_struct_end_p (ref);\n       bool zero_length = integer_zerop (memsize);\n-      if (!trailing && (!interior_zero_length || !zero_length))\n+      if (!trailing && !zero_length)\n \t/* MEMBER is either an interior array or is an array with\n \t   more than one element.  */\n \treturn memsize;\n@@ -13630,9 +13634,14 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t\t  offset_int minidx = wi::to_offset (min);\n \t\t  offset_int maxidx = wi::to_offset (max);\n \t\t  if (maxidx - minidx > 0)\n-\t\t    /* MEMBER is an array with more than 1 element.  */\n+\t\t    /* MEMBER is an array with more than one element.  */\n \t\t    return memsize;\n \t\t}\n+\n+      /* For a refernce to a zero- or one-element array member of a union\n+\t use the size of the union instead of the size of the member.  */\n+      if (TREE_CODE (argtype) == UNION_TYPE)\n+\tmemsize = TYPE_SIZE_UNIT (argtype);\n     }\n \n   /* MEMBER is either a bona fide flexible array member, or a zero-length\n@@ -13647,28 +13656,27 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n       if (!*interior_zero_length)\n \treturn NULL_TREE;\n \n-      if (TREE_CODE (TREE_OPERAND (ref, 0)) != COMPONENT_REF)\n+      if (TREE_CODE (arg) != COMPONENT_REF)\n \treturn NULL_TREE;\n \n-      base = TREE_OPERAND (ref, 0);\n+      base = arg;\n       while (TREE_CODE (base) == COMPONENT_REF)\n \tbase = TREE_OPERAND (base, 0);\n       baseoff = tree_to_poly_int64 (byte_position (TREE_OPERAND (ref, 1)));\n     }\n \n   /* BASE is the declared object of which MEMBER is either a member\n-     or that is cast to REFTYPE (e.g., a char buffer used to store\n-     a REFTYPE object).  */\n-  tree reftype = TREE_TYPE (TREE_OPERAND (ref, 0));\n+     or that is cast to ARGTYPE (e.g., a char buffer used to store\n+     an ARGTYPE object).  */\n   tree basetype = TREE_TYPE (base);\n \n   /* Determine the base type of the referenced object.  If it's\n-     the same as REFTYPE and MEMBER has a known size, return it.  */\n+     the same as ARGTYPE and MEMBER has a known size, return it.  */\n   tree bt = basetype;\n   if (!*interior_zero_length)\n     while (TREE_CODE (bt) == ARRAY_TYPE)\n       bt = TREE_TYPE (bt);\n-  bool typematch = useless_type_conversion_p (reftype, bt);\n+  bool typematch = useless_type_conversion_p (argtype, bt);\n   if (memsize && typematch)\n     return memsize;\n \n@@ -13684,7 +13692,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t  if (init)\n \t    {\n \t      memsize = TYPE_SIZE_UNIT (TREE_TYPE (init));\n-\t      if (tree refsize = TYPE_SIZE_UNIT (reftype))\n+\t      if (tree refsize = TYPE_SIZE_UNIT (argtype))\n \t\t{\n \t\t  /* Use the larger of the initializer size and the tail\n \t\t     padding in the enclosing struct.  */"}]}