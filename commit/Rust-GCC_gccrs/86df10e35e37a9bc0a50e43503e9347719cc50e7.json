{"sha": "86df10e35e37a9bc0a50e43503e9347719cc50e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkZjEwZTM1ZTM3YTliYzBhNTBlNDM1MDNlOTM0NzcxOWNjNTBlNw==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2004-10-13T03:48:03Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-10-13T03:48:03Z"}, "message": "Makefile.in (tree-ssa-loop-niter.o): Depends on tree-data-ref.h.\n\n2004-10-11  Sebastian Pop  <pop@cri.ensmp.fr>\n\n\t* Makefile.in (tree-ssa-loop-niter.o): Depends on tree-data-ref.h.\n\t* cfgloop.c (initialize_loops_parallel_p): New.\n\t(flow_loops_find): Initialize the parallel_p field to true for all\n\tthe loops.\n\t* tree-ssa-loop-niter.c: Include \"tree-data-ref.h\".\n\t(estimate_numbers_of_iterations_loop): Infers the loop bounds from\n\tthe size of the data accessed in the loop.\n\t(struct nb_iter_bound): Moved...\n\t* cfgloop.h (struct nb_iter_bound): ... here.\n\t(estimated_nb_iterations, parallel_p): New fields in struct loop.\n\t(record_estimate): Declare extern here.\n\t* tree-chrec.c: Fix comments.\n\t(nb_vars_in_chrec): New function.\n\t* tree-chrec.h (nb_vars_in_chrec): Declared here.\n\t* tree-data-ref.c: Don't include lambda.h, that is already included\n\tin tree-data-ref.h.\n\t(tree_fold_divides_p): Don't check for integer_onep.\n\t(tree_fold_bezout): Removed.\n\t(gcd): New static duplicated function.\n\t(int_divides_p, dump_subscript): New.\n\t(dump_data_dependence_relation): Use dump_subscript.\n\t(dump_dist_dir_vectors, dump_ddrs, compute_estimated_nb_iterations,\n\testimate_niter_from_size_of_data): New.\n\t(analyze_array_indexes, analyze_array): Call\n\testimate_niter_from_size_of_data during\tthe detection of array\n\treferences.  Pass in a pointer to the statement that contains the\n\tarray reference.\n\t(all_chrecs_equal_p): New.\n\t(compute_distance_vector): Renamed compute_subscript_distance.\n\tDeal with multivariate conflict functions.\n\t(initialize_data_dependence_relation): Initialize DDR_AFFINE_P,\n\tDDR_SIZE_VECT, DDR_DIST_VECT, and DDR_DIR_VECT.\n\t(non_affine_dependence_relation): New.\n\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine,\n\tanalyze_siv_subscript, analyze_miv_subscript,\n\tanalyze_overlapping_iterations, subscript_dependence_tester):\n\tInitialize and return last_conflicts function.\n\t(initialize_matrix_A, FLOOR, compute_overlap_steps_for_affine_univar,\n\tcompute_overlap_steps_for_affine_1_2): New.\n\t(analyze_siv_subscript_affine_cst): Removed.\n\t(analyze_subscript_affine_affine): Disprove dependences based on the\n\titeration domains.  Solve the univariate dependence case as before,\n\tbut use lambda_matrix_right_hermite instead of tree_fold_bezout.\n\tImplement the multivariate case of 2 versus 1 variables.\n\t(build_classic_dist_vector, build_classic_dir_vector): Implement some\n\tunhandled cases.\n\t(find_data_references_in_loop): Compute and initialize\n\tloop->estimated_nb_iterations and loop->parallel_p.\n\t(analyze_all_data_dependences): Modify the debug dump order.\n\t* tree-data-ref.h (SUB_LAST_CONFLICT_IN_A, SUB_LAST_CONFLICT_IN_B,\n\tsubscript->last_conflict_in_a, subscript->last_conflict_in_b): Removed.\n\t(SUB_LAST_CONFLICT, subscript->last_conflict,\n\tdata_dependence_relation->affine_p, data_dependence_relation->size_vect,\n\tDDR_AFFINE_P, DDR_SIZE_VECT): New.\n\t(find_data_references_in_loop, initialize_data_dependence_relation,\n\tdump_subscript, dump_ddrs, dump_dist_dir_vectors): Declared here.\n\nFrom-SVN: r88965", "tree": {"sha": "1226bd75bfb69754520d53c7eb3bfc5d227899fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1226bd75bfb69754520d53c7eb3bfc5d227899fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86df10e35e37a9bc0a50e43503e9347719cc50e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86df10e35e37a9bc0a50e43503e9347719cc50e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86df10e35e37a9bc0a50e43503e9347719cc50e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86df10e35e37a9bc0a50e43503e9347719cc50e7/comments", "author": null, "committer": null, "parents": [{"sha": "06c3418c6cde0cca0caa32123e5ae3e05ea31019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c3418c6cde0cca0caa32123e5ae3e05ea31019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c3418c6cde0cca0caa32123e5ae3e05ea31019"}], "stats": {"total": 1488, "additions": 1033, "deletions": 455}, "files": [{"sha": "5083211e03d8559b2d8b19b2af592b8663939d97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -1,3 +1,62 @@\n+2004-10-11  Sebastian Pop  <pop@cri.ensmp.fr>\n+ \n+\t* Makefile.in (tree-ssa-loop-niter.o): Depends on tree-data-ref.h.\n+\t* cfgloop.c (initialize_loops_parallel_p): New.\n+\t(flow_loops_find): Initialize the parallel_p field to true for all \n+\tthe loops.\n+\t* tree-ssa-loop-niter.c: Include \"tree-data-ref.h\".\n+\t(estimate_numbers_of_iterations_loop): Infers the loop bounds from \n+\tthe size of the data accessed in the loop.\n+\t(struct nb_iter_bound): Moved... \n+\t* cfgloop.h (struct nb_iter_bound): ... here.\n+\t(estimated_nb_iterations, parallel_p): New fields in struct loop.\n+\t(record_estimate): Declare extern here.\n+\t* tree-chrec.c: Fix comments.\n+\t(nb_vars_in_chrec): New function.\n+\t* tree-chrec.h (nb_vars_in_chrec): Declared here.\n+\t* tree-data-ref.c: Don't include lambda.h, that is already included \n+\tin tree-data-ref.h.\n+\t(tree_fold_divides_p): Don't check for integer_onep.\n+\t(tree_fold_bezout): Removed.\n+\t(gcd): New static duplicated function.\n+\t(int_divides_p, dump_subscript): New.\n+\t(dump_data_dependence_relation): Use dump_subscript.\n+\t(dump_dist_dir_vectors, dump_ddrs, compute_estimated_nb_iterations, \n+\testimate_niter_from_size_of_data): New.\n+\t(analyze_array_indexes, analyze_array): Call \n+\testimate_niter_from_size_of_data during\tthe detection of array \n+\treferences.  Pass in a pointer to the statement that contains the \n+\tarray reference.\n+\t(all_chrecs_equal_p): New.\n+\t(compute_distance_vector): Renamed compute_subscript_distance.\n+\tDeal with multivariate conflict functions.\n+\t(initialize_data_dependence_relation): Initialize DDR_AFFINE_P, \n+\tDDR_SIZE_VECT, DDR_DIST_VECT, and DDR_DIR_VECT.\n+\t(non_affine_dependence_relation): New.\n+\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine, \n+\tanalyze_siv_subscript, analyze_miv_subscript, \n+\tanalyze_overlapping_iterations, subscript_dependence_tester): \n+\tInitialize and return last_conflicts function.\n+\t(initialize_matrix_A, FLOOR, compute_overlap_steps_for_affine_univar,\n+\tcompute_overlap_steps_for_affine_1_2): New.\n+\t(analyze_siv_subscript_affine_cst): Removed.\n+\t(analyze_subscript_affine_affine): Disprove dependences based on the \n+\titeration domains.  Solve the univariate dependence case as before, \n+\tbut use lambda_matrix_right_hermite instead of tree_fold_bezout.\n+\tImplement the multivariate case of 2 versus 1 variables.\n+\t(build_classic_dist_vector, build_classic_dir_vector): Implement some \n+\tunhandled cases.\n+\t(find_data_references_in_loop): Compute and initialize \n+\tloop->estimated_nb_iterations and loop->parallel_p.\n+\t(analyze_all_data_dependences): Modify the debug dump order.\n+\t* tree-data-ref.h (SUB_LAST_CONFLICT_IN_A, SUB_LAST_CONFLICT_IN_B,\n+\tsubscript->last_conflict_in_a, subscript->last_conflict_in_b): Removed.\n+\t(SUB_LAST_CONFLICT, subscript->last_conflict, \n+\tdata_dependence_relation->affine_p, data_dependence_relation->size_vect,\n+\tDDR_AFFINE_P, DDR_SIZE_VECT): New.\n+\t(find_data_references_in_loop, initialize_data_dependence_relation,\n+\tdump_subscript, dump_ddrs, dump_dist_dir_vectors): Declared here.\n+\n 2004-10-12  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* configure: Regenerate."}, {"sha": "622ecd2ef152fcad928dd9b9f0cb83d42480946a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -1706,7 +1706,7 @@ tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) cfgloop.h $(PARAMS_H) tree-inline.h \\\n    output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H) \\\n-   tree-pass.h $(SCEV_H)\t\t \n+   tree-pass.h $(SCEV_H) tree-data-ref.h\n tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) tree-inline.h \\\n    output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H) \\"}, {"sha": "b995b39784417cfc4fe3a748b5b9b05175c5f547", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -780,6 +780,20 @@ canonicalize_loop_headers (void)\n #endif\n }\n \n+/* Initialize all the parallel_p fields of the loops structure to true.  */\n+\n+static void\n+initialize_loops_parallel_p (struct loops *loops)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < loops->num; i++)\n+    {\n+      struct loop *loop = loops->parray[i];\n+      loop->parallel_p = true;\n+    }\n+}\n+\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_depth information in basic block structures.  FLAGS\n    controls which loop information is collected.  Return the number of natural\n@@ -945,6 +959,7 @@ flow_loops_find (struct loops *loops, int flags)\n \tflow_loop_scan (loops->parray[i], flags);\n \n       loops->num = num_loops;\n+      initialize_loops_parallel_p (loops);\n     }\n \n   sbitmap_free (headers);"}, {"sha": "5de3f64b80baaae0c794cd3888841d5fb9422e38", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -43,6 +43,20 @@ struct lpt_decision\n   unsigned times;\n };\n \n+/* The structure describing a bound on number of iterations of a loop.  */\n+\n+struct nb_iter_bound\n+{\n+  tree bound;\t\t/* The expression whose value is an upper bound on the\n+\t\t\t   number of executions of anything after ...  */\n+  tree at_stmt;\t\t/* ... this statement during one execution of loop.  */\n+  tree additional;\t/* A conjunction of conditions the operands of BOUND\n+\t\t\t   satisfy.  The additional information about the value\n+\t\t\t   of the bound may be derived from it.  */\n+  struct nb_iter_bound *next;\n+\t\t\t/* The next bound in a list.  */\n+};\n+\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n@@ -173,12 +187,22 @@ struct loop\n      information in this field.  */\n   tree nb_iterations;\n \n+  /* An INTEGER_CST estimation of the number of iterations.  NULL_TREE\n+     if there is no estimation.  */\n+  tree estimated_nb_iterations;\n+\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n \n   /* If not NULL, loop has just single exit edge stored here (edges to the\n      EXIT_BLOCK_PTR do not count.  */\n   edge single_exit;\n+\n+  /* True when the loop does not carry data dependences, and\n+     consequently the iterations can be executed in any order.  False\n+     when the loop carries data dependences, or when the property is\n+     not decidable.  */\n+  bool parallel_p;\n };\n \n /* Flags for state of loop structure.  */\n@@ -462,6 +486,7 @@ enum\n extern void unroll_and_peel_loops (struct loops *, int);\n extern void doloop_optimize_loops (struct loops *);\n extern void move_loop_invariants (struct loops *);\n+extern void record_estimate (struct loop *, tree, tree, tree);\n \n /* Old loop optimizer interface.  */\n "}, {"sha": "be0d80a73fdb4d6c7cbc6b3c2f9337490acc9af1", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -636,7 +636,7 @@ chrec_component_in_loop_num (tree chrec,\n }\n \n /* Returns the evolution part in LOOP_NUM.  Example: the call\n-   evolution_part_in_loop_num (1, {{0, +, 1}_1, +, 2}_1) returns \n+   evolution_part_in_loop_num ({{0, +, 1}_1, +, 2}_1, 1) returns \n    {1, +, 2}_1  */\n \n tree \n@@ -647,7 +647,7 @@ evolution_part_in_loop_num (tree chrec,\n }\n \n /* Returns the initial condition in LOOP_NUM.  Example: the call\n-   initial_condition_in_loop_num ({{0, +, 1}_1, +, 2}_2, 1) returns \n+   initial_condition_in_loop_num ({{0, +, 1}_1, +, 2}_2, 2) returns \n    {0, +, 1}_1  */\n \n tree \n@@ -932,6 +932,26 @@ evolution_function_is_univariate_p (tree chrec)\n     }\n }\n \n+/* Returns the number of variables of CHREC.  Example: the call\n+   nb_vars_in_chrec ({{0, +, 1}_5, +, 2}_6) returns 2.  */\n+\n+unsigned \n+nb_vars_in_chrec (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return 0;\n+\n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      return 1 + nb_vars_in_chrec \n+\t(initial_condition_in_loop_num (chrec, CHREC_VARIABLE (chrec)));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n \f\n \n /* Convert the initial condition of chrec to type.  */"}, {"sha": "bc722d8e87295af8f205a8e874d1fdbb342a9019", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -91,6 +91,7 @@ extern bool chrec_contains_undetermined (tree);\n extern bool tree_contains_chrecs (tree);\n extern bool evolution_function_is_affine_multivariate_p (tree);\n extern bool evolution_function_is_univariate_p (tree);\n+extern unsigned nb_vars_in_chrec (tree);\n \n \f\n "}, {"sha": "213f8d439accfce8d1dfd0e1bd832c5fac57b8a9", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 880, "deletions": 427, "changes": 1307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -44,7 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        - polyhedron dependence\n      or with the chains of recurrences based representation,\n      \n-   - to define a knowledge base for storing the data dependences \n+   - to define a knowledge base for storing the data dependeces \n      information,\n      \n    - to define an interface to access this data.\n@@ -94,7 +94,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n-#include \"lambda.h\"\n \n /* This is the simplest data dependence test: determines whether the\n    data references A and B access the same array/region.  Returns\n@@ -113,6 +112,7 @@ array_base_name_differ_p (struct data_reference *a,\n   tree ta = TREE_TYPE (base_a);\n   tree tb = TREE_TYPE (base_b);\n \n+\n   /* Determine if same base.  Example: for the array accesses\n      a[i], b[i] or pointer accesses *a, *b, bases are a, b.  */\n   if (base_a == base_b)\n@@ -130,7 +130,7 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  /* record/union based accesses - s.a[i], t.b[j]. bases are s.a,t.b.  */ \n+  /* Record/union based accesses - s.a[i], t.b[j]. bases are s.a,t.b.  */ \n   if (TREE_CODE (base_a) == COMPONENT_REF && TREE_CODE (base_b) == COMPONENT_REF\n       && TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0)\n       && TREE_OPERAND (base_a, 1) == TREE_OPERAND (base_b, 1))\n@@ -139,6 +139,7 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n+\n   /* Determine if different bases.  */\n \n   /* At this point we know that base_a != base_b.  However, pointer\n@@ -206,109 +207,39 @@ tree_fold_divides_p (tree type,\n \t\t     tree a, \n \t\t     tree b)\n {\n-  if (integer_onep (a))\n-    return true;\n-  \n   /* Determines whether (A == gcd (A, B)).  */\n   return integer_zerop \n     (fold (build (MINUS_EXPR, type, a, tree_fold_gcd (a, b))));\n }\n \n-/* Bezout: Let A1 and A2 be two integers; there exist two integers U11\n-   and U12 such that, \n-   \n-   |  U11 * A1 + U12 * A2 = gcd (A1, A2).\n-   \n-   This function computes the greatest common divisor using the\n-   Blankinship algorithm.  The gcd is returned, and the coefficients\n-   of the unimodular matrix U are (U11, U12, U21, U22) such that, \n-\n-   |  U.A = S\n-   \n-   |  (U11 U12) (A1) = (gcd)\n-   |  (U21 U22) (A2)   (0)\n-   \n-   FIXME: Use lambda_..._hermite for implementing this function.\n-*/\n+/* Compute the greatest common denominator of two numbers using\n+   Euclid's algorithm.  */\n \n-static tree \n-tree_fold_bezout (tree a1, \n-\t\t  tree a2,\n-\t\t  tree *u11, tree *u12,\n-\t\t  tree *u21, tree *u22)\n+static int \n+gcd (int a, int b)\n {\n-  tree s1, s2;\n-  \n-  /* Initialize S with the coefficients of A.  */\n-  s1 = a1;\n-  s2 = a2;\n-  \n-  /* Initialize the U matrix */\n-  *u11 = integer_one_node; \n-  *u12 = integer_zero_node;\n-  *u21 = integer_zero_node;\n-  *u22 = integer_one_node;\n   \n-  if (integer_zerop (a1)\n-      || integer_zerop (a2))\n-    return integer_zero_node;\n-  \n-  while (!integer_zerop (s2))\n-    {\n-      int sign;\n-      tree z, zu21, zu22, zs2;\n-      \n-      sign = tree_int_cst_sgn (s1) * tree_int_cst_sgn (s2);\n-      z = fold (build (FLOOR_DIV_EXPR, integer_type_node, \n-\t\t       fold (build1 (ABS_EXPR, integer_type_node, s1)), \n-\t\t       fold (build1 (ABS_EXPR, integer_type_node, s2))));\n-      zu21 = fold (build (MULT_EXPR, integer_type_node, z, *u21));\n-      zu22 = fold (build (MULT_EXPR, integer_type_node, z, *u22));\n-      zs2 = fold (build (MULT_EXPR, integer_type_node, z, s2));\n-      \n-      /* row1 -= z * row2.  */\n-      gcc_assert (sign != 0);\n-      if (sign < 0)\n-\t{\n-\t  *u11 = fold (build (PLUS_EXPR, integer_type_node, *u11, zu21));\n-\t  *u12 = fold (build (PLUS_EXPR, integer_type_node, *u12, zu22));\n-\t  s1 = fold (build (PLUS_EXPR, integer_type_node, s1, zs2));\n-\t}\n-      else\n-\t{\n-\t  *u11 = fold (build (MINUS_EXPR, integer_type_node, *u11, zu21));\n-\t  *u12 = fold (build (MINUS_EXPR, integer_type_node, *u12, zu22));\n-\t  s1 = fold (build (MINUS_EXPR, integer_type_node, s1, zs2));\n-\t}\n-      \n-      /* Interchange row1 and row2.  */\n-      {\n-\ttree flip;\n-\t\n-\tflip = *u11;\n-\t*u11 = *u21;\n-\t*u21 = flip;\n-\n-\tflip = *u12;\n-\t*u12 = *u22;\n-\t*u22 = flip;\n-\t\n-\tflip = s1;\n-\ts1 = s2;\n-\ts2 = flip;\n-      }\n-    }\n+  int x, y, z;\n   \n-  if (tree_int_cst_sgn (s1) < 0)\n+  x = abs (a);\n+  y = abs (b);\n+\n+  while (x>0)\n     {\n-      *u11 = fold (build (MULT_EXPR, integer_type_node, *u11, \n-\t\t\t  integer_minus_one_node));\n-      *u12 = fold (build (MULT_EXPR, integer_type_node, *u12, \n-\t\t\t\t integer_minus_one_node));\n-      s1 = fold (build (MULT_EXPR, integer_type_node, s1, integer_minus_one_node));\n+      z = y % x;\n+      y = x;\n+      x = z;\n     }\n-  \n-  return s1;\n+\n+  return (y);\n+}\n+\n+/* Returns true iff A divides B.  */\n+\n+static inline bool \n+int_divides_p (int a, int b)\n+{\n+  return ((b % a) == 0);\n }\n \n \f\n@@ -360,83 +291,85 @@ dump_data_reference (FILE *outf,\n   fprintf (outf, \")\\n\");\n }\n \n+/* Dump function for a SUBSCRIPT structure.  */\n+\n+void \n+dump_subscript (FILE *outf, struct subscript *subscript)\n+{\n+  tree chrec = SUB_CONFLICTS_IN_A (subscript);\n+\n+  fprintf (outf, \"\\n (subscript \\n\");\n+  fprintf (outf, \"  iterations_that_access_an_element_twice_in_A: \");\n+  print_generic_stmt (outf, chrec, 0);\n+  if (chrec == chrec_known)\n+    fprintf (outf, \"    (no dependence)\\n\");\n+  else if (chrec_contains_undetermined (chrec))\n+    fprintf (outf, \"    (don't know)\\n\");\n+  else\n+    {\n+      tree last_iteration = SUB_LAST_CONFLICT (subscript);\n+      fprintf (outf, \"  last_conflict: \");\n+      print_generic_stmt (outf, last_iteration, 0);\n+    }\n+\t  \n+  chrec = SUB_CONFLICTS_IN_B (subscript);\n+  fprintf (outf, \"  iterations_that_access_an_element_twice_in_B: \");\n+  print_generic_stmt (outf, chrec, 0);\n+  if (chrec == chrec_known)\n+    fprintf (outf, \"    (no dependence)\\n\");\n+  else if (chrec_contains_undetermined (chrec))\n+    fprintf (outf, \"    (don't know)\\n\");\n+  else\n+    {\n+      tree last_iteration = SUB_LAST_CONFLICT (subscript);\n+      fprintf (outf, \"  last_conflict: \");\n+      print_generic_stmt (outf, last_iteration, 0);\n+    }\n+\n+  fprintf (outf, \"  (Subscript distance: \");\n+  print_generic_stmt (outf, SUB_DISTANCE (subscript), 0);\n+  fprintf (outf, \"  )\\n\");\n+  fprintf (outf, \" )\\n\");\n+}\n+\n /* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n \n void \n dump_data_dependence_relation (FILE *outf, \n \t\t\t       struct data_dependence_relation *ddr)\n {\n-  unsigned int i;\n   struct data_reference *dra, *drb;\n-  \n+\n   dra = DDR_A (ddr);\n   drb = DDR_B (ddr);\n-  \n-  if (dra && drb)\n-    fprintf (outf, \"(Data Dep:\");\n-  else\n-    fprintf (outf, \"(Data Dep:\");\n-\n-  if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n+  fprintf (outf, \"(Data Dep: \\n\");\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     fprintf (outf, \"    (don't know)\\n\");\n   \n   else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     fprintf (outf, \"    (no dependence)\\n\");\n   \n-  else\n+  else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n+      unsigned int i;\n       for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n \t{\n-\t  tree chrec;\n-\t  struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n-\t  \n-\t  fprintf (outf, \"\\n (subscript %d:\\n\", i);\n \t  fprintf (outf, \"  access_fn_A: \");\n \t  print_generic_stmt (outf, DR_ACCESS_FN (dra, i), 0);\n \t  fprintf (outf, \"  access_fn_B: \");\n \t  print_generic_stmt (outf, DR_ACCESS_FN (drb, i), 0);\n-\t  \n-\t  chrec = SUB_CONFLICTS_IN_A (subscript);\n-\t  fprintf (outf, \"  iterations_that_access_an_element_twice_in_A: \");\n-\t  print_generic_stmt (outf, chrec, 0);\n-\t  if (chrec == chrec_known)\n-\t    fprintf (outf, \"    (no dependence)\\n\");\n-\t  else if (chrec_contains_undetermined (chrec))\n-\t    fprintf (outf, \"    (don't know)\\n\");\n-\t  else\n-\t    {\n-\t      tree last_iteration = SUB_LAST_CONFLICT_IN_A (subscript);\n-\t      fprintf (outf, \"  last_iteration_that_access_an_element_twice_in_A: \");\n-\t      print_generic_stmt (outf, last_iteration, 0);\n-\t    }\n-\t  \n-\t  chrec = SUB_CONFLICTS_IN_B (subscript);\n-\t  fprintf (outf, \"  iterations_that_access_an_element_twice_in_B: \");\n-\t  print_generic_stmt (outf, chrec, 0);\n-\t  if (chrec == chrec_known)\n-\t    fprintf (outf, \"    (no dependence)\\n\");\n-\t  else if (chrec_contains_undetermined (chrec))\n-\t    fprintf (outf, \"    (don't know)\\n\");\n-\t  else\n-\t    {\n-\t      tree last_iteration = SUB_LAST_CONFLICT_IN_B (subscript);\n-\t      fprintf (outf, \"  last_iteration_that_access_an_element_twice_in_B: \");\n-\t      print_generic_stmt (outf, last_iteration, 0);\n-\t    }\n-      \n-\t  fprintf (outf, \" )\\n\");\n+\t  dump_subscript (outf, DDR_SUBSCRIPT (ddr, i));\n \t}\n-  \n-      fprintf (outf, \" (Distance Vector: \\n\");\n-      for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+      if (DDR_DIST_VECT (ddr))\n \t{\n-\t  struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n-      \n-\t  fprintf (outf, \"(\");\n-\t  print_generic_stmt (outf, SUB_DISTANCE (subscript), 0);\n-\t  fprintf (outf, \")\\n\");\n+\t  fprintf (outf, \"  distance_vect: \");\n+\t  print_lambda_vector (outf, DDR_DIST_VECT (ddr), DDR_SIZE_VECT (ddr));\n+\t}\n+      if (DDR_DIR_VECT (ddr))\n+\t{\n+\t  fprintf (outf, \"  direction_vect: \");\n+\t  print_lambda_vector (outf, DDR_DIR_VECT (ddr), DDR_SIZE_VECT (ddr));\n \t}\n-      fprintf (outf, \" )\\n\");\n     }\n \n   fprintf (outf, \")\\n\");\n@@ -485,8 +418,120 @@ dump_data_dependence_direction (FILE *file,\n     }\n }\n \n+/* Dumps the distance and direction vectors in FILE.  DDRS contains\n+   the dependence relations, and VECT_SIZE is the size of the\n+   dependence vectors, or in other words the number of loops in the\n+   considered nest.  */\n+\n+void \n+dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n+    {\n+      struct data_dependence_relation *ddr = \n+\t(struct data_dependence_relation *) \n+\tVARRAY_GENERIC_PTR (ddrs, i);\n+      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n+\t  && DDR_AFFINE_P (ddr))\n+\t{\n+\t  fprintf (file, \"DISTANCE_V (\");\n+\t  print_lambda_vector (file, DDR_DIST_VECT (ddr), DDR_SIZE_VECT (ddr));\n+\t  fprintf (file, \")\\n\");\n+\t  fprintf (file, \"DIRECTION_V (\");\n+\t  print_lambda_vector (file, DDR_DIR_VECT (ddr), DDR_SIZE_VECT (ddr));\n+\t  fprintf (file, \")\\n\");\n+\t}\n+    }\n+  fprintf (file, \"\\n\\n\");\n+}\n+\n+/* Dumps the data dependence relations DDRS in FILE.  */\n+\n+void \n+dump_ddrs (FILE *file, varray_type ddrs)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n+    {\n+      struct data_dependence_relation *ddr = \n+\t(struct data_dependence_relation *) \n+\tVARRAY_GENERIC_PTR (ddrs, i);\n+      dump_data_dependence_relation (file, ddr);\n+    }\n+  fprintf (file, \"\\n\\n\");\n+}\n+\n \f\n \n+/* Compute the lowest iteration bound for LOOP.  It is an\n+   INTEGER_CST.  */\n+\n+static void\n+compute_estimated_nb_iterations (struct loop *loop)\n+{\n+  tree estimation;\n+  struct nb_iter_bound *bound, *next;\n+  \n+  for (bound = loop->bounds; bound; bound = next)\n+    {\n+      next = bound->next;\n+      estimation = bound->bound;\n+\n+      if (TREE_CODE (estimation) != INTEGER_CST)\n+\tcontinue;\n+\n+      if (loop->estimated_nb_iterations)\n+\t{\n+\t  /* Update only if estimation is smaller.  */\n+\t  if (tree_int_cst_lt (estimation, loop->estimated_nb_iterations))\n+\t    loop->estimated_nb_iterations = estimation;\n+\t}\n+      else\n+\tloop->estimated_nb_iterations = estimation;\n+    }\n+}\n+\n+/* Estimate the number of iterations from the size of the data and the\n+   access functions.  */\n+\n+static void\n+estimate_niter_from_size_of_data (struct loop *loop, \n+\t\t\t\t  tree opnd0, \n+\t\t\t\t  tree access_fn, \n+\t\t\t\t  tree stmt)\n+{\n+  tree estimation;\n+  tree array_size, data_size, element_size;\n+  tree init, step;\n+\n+  init = initial_condition (access_fn);\n+  step = evolution_part_in_loop_num (access_fn, loop->num);\n+\n+  array_size = TYPE_SIZE (TREE_TYPE (opnd0));\n+  element_size = TYPE_SIZE (TREE_TYPE (TREE_TYPE (opnd0)));\n+  if (array_size == NULL_TREE \n+      || element_size == NULL_TREE)\n+    return;\n+\n+  data_size = fold (build2 (EXACT_DIV_EXPR, integer_type_node, \n+\t\t\t   array_size, element_size));\n+\n+  if (init != NULL_TREE\n+      && step != NULL_TREE\n+      && TREE_CODE (init) == INTEGER_CST\n+      && TREE_CODE (step) == INTEGER_CST)\n+    {\n+      estimation = fold (build2 (CEIL_DIV_EXPR, integer_type_node, \n+\t\t\t\t fold (build2 (MINUS_EXPR, integer_type_node, \n+\t\t\t\t\t       data_size, init)), step));\n+\n+      record_estimate (loop, estimation, boolean_true_node, stmt);\n+    }\n+}\n+\n /* Given an ARRAY_REF node REF, records its access functions.\n    Example: given A[i][3], record in ACCESS_FNS the opnd1 function,\n    i.e. the constant \"3\", then recursively call the function on opnd0,\n@@ -496,7 +541,7 @@ dump_data_dependence_direction (FILE *file,\n static tree\n analyze_array_indexes (struct loop *loop,\n \t\t       varray_type *access_fns, \n-\t\t       tree ref)\n+\t\t       tree ref, tree stmt)\n {\n   tree opnd0, opnd1;\n   tree access_fn;\n@@ -510,12 +555,15 @@ analyze_array_indexes (struct loop *loop,\n      the optimizers.  */\n   access_fn = instantiate_parameters \n     (loop, analyze_scalar_evolution (loop, opnd1));\n+\n+  if (loop->estimated_nb_iterations == NULL_TREE)\n+    estimate_niter_from_size_of_data (loop, opnd0, access_fn, stmt);\n   \n   VARRAY_PUSH_TREE (*access_fns, access_fn);\n   \n   /* Recursively record other array access functions.  */\n   if (TREE_CODE (opnd0) == ARRAY_REF)\n-    return analyze_array_indexes (loop, access_fns, opnd0);\n+    return analyze_array_indexes (loop, access_fns, opnd0, stmt);\n   \n   /* Return the base name of the data access.  */\n   else\n@@ -546,7 +594,7 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   DR_REF (res) = ref;\n   VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 3, \"access_fns\");\n   DR_BASE_NAME (res) = analyze_array_indexes \n-    (loop_containing_stmt (stmt), &(DR_ACCESS_FNS (res)), ref);\n+    (loop_containing_stmt (stmt), &(DR_ACCESS_FNS (res)), ref, stmt);\n   DR_IS_READ (res) = is_read;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -592,11 +640,31 @@ init_data_ref (tree stmt,\n \n \f\n \n-/* When there exists a dependence relation, determine its distance\n-   vector.  */\n+/* Returns true when all the functions of a tree_vec CHREC are the\n+   same.  */\n+\n+static bool \n+all_chrecs_equal_p (tree chrec)\n+{\n+  int j;\n+\n+  for (j = 0; j < TREE_VEC_LENGTH (chrec) - 1; j++)\n+    {\n+      tree chrec_j = TREE_VEC_ELT (chrec, j);\n+      tree chrec_j_1 = TREE_VEC_ELT (chrec, j + 1);\n+      if (!integer_zerop \n+\t  (chrec_fold_minus \n+\t   (integer_type_node, chrec_j, chrec_j_1)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Determine for each subscript in the data dependence relation DDR\n+   the distance.  */\n \n static void\n-compute_distance_vector (struct data_dependence_relation *ddr)\n+compute_subscript_distance (struct data_dependence_relation *ddr)\n {\n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n@@ -610,7 +678,30 @@ compute_distance_vector (struct data_dependence_relation *ddr)\n  \t  subscript = DDR_SUBSCRIPT (ddr, i);\n  \t  conflicts_a = SUB_CONFLICTS_IN_A (subscript);\n  \t  conflicts_b = SUB_CONFLICTS_IN_B (subscript);\n- \t  difference = chrec_fold_minus \n+\n+\t  if (TREE_CODE (conflicts_a) == TREE_VEC)\n+\t    {\n+\t      if (!all_chrecs_equal_p (conflicts_a))\n+\t\t{\n+\t\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tconflicts_a = TREE_VEC_ELT (conflicts_a, 0);\n+\t    }\n+\n+\t  if (TREE_CODE (conflicts_b) == TREE_VEC)\n+\t    {\n+\t      if (!all_chrecs_equal_p (conflicts_b))\n+\t\t{\n+\t\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tconflicts_b = TREE_VEC_ELT (conflicts_b, 0);\n+\t    }\n+\n+\t  difference = chrec_fold_minus \n \t    (integer_type_node, conflicts_b, conflicts_a);\n  \t  \n  \t  if (evolution_function_is_constant_p (difference))\n@@ -649,8 +740,12 @@ initialize_data_dependence_relation (struct data_reference *a,\n   else\n     {\n       unsigned int i;\n+      DDR_AFFINE_P (res) = true;\n       DDR_ARE_DEPENDENT (res) = NULL_TREE;\n       DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n+      DDR_SIZE_VECT (res) = 0;\n+      DDR_DIST_VECT (res) = NULL;\n+      DDR_DIR_VECT (res) = NULL;\n       \n       for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n \t{\n@@ -659,8 +754,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n \t  subscript = xmalloc (sizeof (struct subscript));\n \t  SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n \t  SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n-\t  SUB_LAST_CONFLICT_IN_A (subscript) = chrec_dont_know;\n-\t  SUB_LAST_CONFLICT_IN_B (subscript) = chrec_dont_know;\n+\t  SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n \t  SUB_DISTANCE (subscript) = chrec_dont_know;\n \t  VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n \t}\n@@ -687,6 +781,18 @@ finalize_ddr_dependent (struct data_dependence_relation *ddr,\n   varray_clear (DDR_SUBSCRIPTS (ddr));\n }\n \n+/* The dependence relation DDR cannot be represented by a distance\n+   vector.  */\n+\n+static inline void\n+non_affine_dependence_relation (struct data_dependence_relation *ddr)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(Dependence relation cannot be represented by distance vector.) \\n\");\n+\n+  DDR_AFFINE_P (ddr) = false;\n+}\n+\n \f\n \n /* This section contains the classic Banerjee tests.  */\n@@ -750,7 +856,8 @@ static void\n analyze_ziv_subscript (tree chrec_a, \n \t\t       tree chrec_b, \n \t\t       tree *overlaps_a,\n-\t\t       tree *overlaps_b)\n+\t\t       tree *overlaps_b, \n+\t\t       tree *last_conflicts)\n {\n   tree difference;\n   \n@@ -768,20 +875,23 @@ analyze_ziv_subscript (tree chrec_a,\n \t     overlaps for each iteration in the loop.  */\n \t  *overlaps_a = integer_zero_node;\n \t  *overlaps_b = integer_zero_node;\n+\t  *last_conflicts = chrec_dont_know;\n \t}\n       else\n \t{\n \t  /* The accesses do not overlap.  */\n \t  *overlaps_a = chrec_known;\n-\t  *overlaps_b = chrec_known;\t  \n+\t  *overlaps_b = chrec_known;\n+\t  *last_conflicts = integer_zero_node;\n \t}\n       break;\n       \n     default:\n       /* We're not sure whether the indexes overlap.  For the moment, \n \t conservatively answer \"don't know\".  */\n       *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\t  \n+      *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n       break;\n     }\n   \n@@ -801,7 +911,8 @@ static void\n analyze_siv_subscript_cst_affine (tree chrec_a, \n \t\t\t\t  tree chrec_b,\n \t\t\t\t  tree *overlaps_a, \n-\t\t\t\t  tree *overlaps_b)\n+\t\t\t\t  tree *overlaps_b, \n+\t\t\t\t  tree *last_conflicts)\n {\n   bool value0, value1, value2;\n   tree difference = chrec_fold_minus \n@@ -811,6 +922,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n     {\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n       return;\n     }\n   else\n@@ -821,6 +933,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;      \n+\t      *last_conflicts = chrec_dont_know;\n \t      return;\n \t    }\n \t  else\n@@ -840,6 +953,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t\t(build (EXACT_DIV_EXPR, integer_type_node, \n \t\t\t\tfold (build1 (ABS_EXPR, integer_type_node, difference)), \n \t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      *last_conflicts = integer_one_node;\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -849,6 +963,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t    {\n \t\t      *overlaps_a = chrec_known;\n \t\t      *overlaps_b = chrec_known;      \n+\t\t      *last_conflicts = integer_zero_node;\n \t\t      return;\n \t\t    }\n \t\t}\n@@ -862,6 +977,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     In this case, chrec_a will not overlap with chrec_b.  */\n \t\t  *overlaps_a = chrec_known;\n \t\t  *overlaps_b = chrec_known;\n+\t\t  *last_conflicts = integer_zero_node;\n \t\t  return;\n \t\t}\n \t    }\n@@ -872,6 +988,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;      \n+\t      *last_conflicts = chrec_dont_know;\n \t      return;\n \t    }\n \t  else\n@@ -889,6 +1006,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      *overlaps_b = fold \n \t\t\t(build (EXACT_DIV_EXPR, integer_type_node, difference, \n \t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      *last_conflicts = integer_one_node;\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -898,6 +1016,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t    {\n \t\t      *overlaps_a = chrec_known;\n \t\t      *overlaps_b = chrec_known;      \n+\t\t      *last_conflicts = integer_zero_node;\n \t\t      return;\n \t\t    }\n \t\t}\n@@ -910,28 +1029,201 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     In this case, chrec_a will not overlap with chrec_b.  */\n \t\t  *overlaps_a = chrec_known;\n \t\t  *overlaps_b = chrec_known;\n+\t\t  *last_conflicts = integer_zero_node;\n \t\t  return;\n \t\t}\n \t    }\n \t}\n     }\n }\n \n-/* Analyze a SIV (Single Index Variable) subscript where CHREC_A is an\n-   affine function, and CHREC_B is a constant.  *OVERLAPS_A and\n-   *OVERLAPS_B are initialized to the functions that describe the\n-   relation between the elements accessed twice by CHREC_A and\n-   CHREC_B.  For k >= 0, the following property is verified:\n+/* Helper recursive function for intializing the matrix A.  Returns\n+   the initial value of CHREC.  */\n \n-   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+static int\n+initialize_matrix_A (lambda_matrix A, tree chrec, unsigned index, int mult)\n+{\n+  gcc_assert (chrec);\n+\n+  if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n+    return int_cst_value (chrec);\n+\n+  A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));\n+  return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);\n+}\n+\n+#define FLOOR_DIV(x,y) ((x) / (y))\n+\n+/* Solves the special case of the Diophantine equation: \n+   | {0, +, STEP_A}_x (OVERLAPS_A) = {0, +, STEP_B}_y (OVERLAPS_B)\n+\n+   Computes the descriptions OVERLAPS_A and OVERLAPS_B.  NITER is the\n+   number of iterations that loops X and Y run.  The overlaps will be\n+   constructed as evolutions in dimension DIM.  */\n \n static void\n-analyze_siv_subscript_affine_cst (tree chrec_a, \n-\t\t\t\t  tree chrec_b,\n-\t\t\t\t  tree *overlaps_a, \n-\t\t\t\t  tree *overlaps_b)\n+compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b, \n+\t\t\t\t\t tree *overlaps_a, tree *overlaps_b, \n+\t\t\t\t\t tree *last_conflicts, int dim)\n+{\n+  if (((step_a > 0 && step_b > 0)\n+       || (step_a < 0 && step_b < 0)))\n+    {\n+      int step_overlaps_a, step_overlaps_b;\n+      int gcd_steps_a_b, last_conflict, tau2;\n+\n+      gcd_steps_a_b = gcd (step_a, step_b);\n+      step_overlaps_a = step_b / gcd_steps_a_b;\n+      step_overlaps_b = step_a / gcd_steps_a_b;\n+\n+      tau2 = FLOOR_DIV (niter, step_overlaps_a);\n+      tau2 = MIN (tau2, FLOOR_DIV (niter, step_overlaps_b));\n+      last_conflict = tau2;\n+\n+      *overlaps_a = build_polynomial_chrec\n+\t(dim, integer_zero_node,\n+\t build_int_cst (NULL_TREE, step_overlaps_a));\n+      *overlaps_b = build_polynomial_chrec\n+\t(dim, integer_zero_node,\n+\t build_int_cst (NULL_TREE, step_overlaps_b));\n+      *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n+    }\n+\n+  else\n+    {\n+      *overlaps_a = integer_zero_node;\n+      *overlaps_b = integer_zero_node;\n+      *last_conflicts = integer_zero_node;\n+    }\n+}\n+\n+\n+/* Solves the special case of a Diophantine equation where CHREC_A is\n+   an affine bivariate function, and CHREC_B is an affine univariate\n+   function.  For example, \n+\n+   | {{0, +, 1}_x, +, 1335}_y = {0, +, 1336}_z\n+   \n+   has the following overlapping functions: \n+\n+   | x (t, u, v) = {{0, +, 1336}_t, +, 1}_v\n+   | y (t, u, v) = {{0, +, 1336}_u, +, 1}_v\n+   | z (t, u, v) = {{{0, +, 1}_t, +, 1335}_u, +, 1}_v\n+\n+   FORNOW: This is a specialized implementation for a case occuring in\n+   a common benchmark.  Implement the general algorithm.  */\n+\n+static void\n+compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b, \n+\t\t\t\t      tree *overlaps_a, tree *overlaps_b, \n+\t\t\t\t      tree *last_conflicts)\n {\n-  analyze_siv_subscript_cst_affine (chrec_b, chrec_a, overlaps_b, overlaps_a);\n+  bool xz_p, yz_p, xyz_p;\n+  int step_x, step_y, step_z;\n+  int niter_x, niter_y, niter_z, niter;\n+  tree numiter_x, numiter_y, numiter_z;\n+  tree overlaps_a_xz, overlaps_b_xz, last_conflicts_xz;\n+  tree overlaps_a_yz, overlaps_b_yz, last_conflicts_yz;\n+  tree overlaps_a_xyz, overlaps_b_xyz, last_conflicts_xyz;\n+\n+  step_x = int_cst_value (CHREC_RIGHT (CHREC_LEFT (chrec_a)));\n+  step_y = int_cst_value (CHREC_RIGHT (chrec_a));\n+  step_z = int_cst_value (CHREC_RIGHT (chrec_b));\n+\n+  numiter_x = number_of_iterations_in_loop \n+    (current_loops->parray[CHREC_VARIABLE (CHREC_LEFT (chrec_a))]);\n+  numiter_y = number_of_iterations_in_loop \n+    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n+  numiter_z = number_of_iterations_in_loop \n+    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n+\n+  if (TREE_CODE (numiter_x) != INTEGER_CST)\n+    numiter_x = current_loops->parray[CHREC_VARIABLE (CHREC_LEFT (chrec_a))]\n+      ->estimated_nb_iterations;\n+  if (TREE_CODE (numiter_y) != INTEGER_CST)\n+    numiter_y = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n+      ->estimated_nb_iterations;\n+  if (TREE_CODE (numiter_z) != INTEGER_CST)\n+    numiter_z = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n+      ->estimated_nb_iterations;\n+\n+  if (numiter_x == NULL_TREE || numiter_y == NULL_TREE \n+      || numiter_z == NULL_TREE)\n+    {\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n+      return;\n+    }\n+\n+  niter_x = int_cst_value (numiter_x);\n+  niter_y = int_cst_value (numiter_y);\n+  niter_z = int_cst_value (numiter_z);\n+\n+  niter = MIN (niter_x, niter_z);\n+  compute_overlap_steps_for_affine_univar (niter, step_x, step_z,\n+\t\t\t\t\t   &overlaps_a_xz,\n+\t\t\t\t\t   &overlaps_b_xz,\n+\t\t\t\t\t   &last_conflicts_xz, 1);\n+  niter = MIN (niter_y, niter_z);\n+  compute_overlap_steps_for_affine_univar (niter, step_y, step_z,\n+\t\t\t\t\t   &overlaps_a_yz,\n+\t\t\t\t\t   &overlaps_b_yz,\n+\t\t\t\t\t   &last_conflicts_yz, 2);\n+  niter = MIN (niter_x, niter_z);\n+  niter = MIN (niter_y, niter);\n+  compute_overlap_steps_for_affine_univar (niter, step_x + step_y, step_z,\n+\t\t\t\t\t   &overlaps_a_xyz,\n+\t\t\t\t\t   &overlaps_b_xyz,\n+\t\t\t\t\t   &last_conflicts_xyz, 3);\n+\n+  xz_p = !integer_zerop (last_conflicts_xz);\n+  yz_p = !integer_zerop (last_conflicts_yz);\n+  xyz_p = !integer_zerop (last_conflicts_xyz);\n+\n+  if (xz_p || yz_p || xyz_p)\n+    {\n+      *overlaps_a = make_tree_vec (2);\n+      TREE_VEC_ELT (*overlaps_a, 0) = integer_zero_node;\n+      TREE_VEC_ELT (*overlaps_a, 1) = integer_zero_node;\n+      *overlaps_b = integer_zero_node;\n+      if (xz_p)\n+\t{\n+\t  TREE_VEC_ELT (*overlaps_a, 0) = \n+\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 0),\n+\t\t\t     overlaps_a_xz);\n+\t  *overlaps_b = \n+\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_xz);\n+\t  *last_conflicts = last_conflicts_xz;\n+\t}\n+      if (yz_p)\n+\t{\n+\t  TREE_VEC_ELT (*overlaps_a, 1) = \n+\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 1),\n+\t\t\t     overlaps_a_yz);\n+\t  *overlaps_b = \n+\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_yz);\n+\t  *last_conflicts = last_conflicts_yz;\n+\t}\n+      if (xyz_p)\n+\t{\n+\t  TREE_VEC_ELT (*overlaps_a, 0) = \n+\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 0),\n+\t\t\t     overlaps_a_xyz);\n+\t  TREE_VEC_ELT (*overlaps_a, 1) = \n+\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 1),\n+\t\t\t     overlaps_a_xyz);\n+\t  *overlaps_b = \n+\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_xyz);\n+\t  *last_conflicts = last_conflicts_xyz;\n+\t}\n+    }\n+  else\n+    {\n+      *overlaps_a = integer_zero_node;\n+      *overlaps_b = integer_zero_node;\n+      *last_conflicts = integer_zero_node;\n+    }\n }\n \n /* Determines the overlapping elements due to accesses CHREC_A and\n@@ -942,10 +1234,14 @@ static void\n analyze_subscript_affine_affine (tree chrec_a, \n \t\t\t\t tree chrec_b,\n \t\t\t\t tree *overlaps_a, \n-\t\t\t\t tree *overlaps_b)\n+\t\t\t\t tree *overlaps_b, \n+\t\t\t\t tree *last_conflicts)\n {\n-  tree left_a, left_b, right_a, right_b;\n-  \n+  unsigned nb_vars_a, nb_vars_b, dim;\n+  int init_a, init_b, gamma, gcd_alpha_beta;\n+  int tau1, tau2;\n+  lambda_matrix A, U, S;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_subscript_affine_affine \\n\");\n   \n@@ -960,208 +1256,240 @@ analyze_subscript_affine_affine (tree chrec_a,\n      there is no dependence.  This function outputs a description of\n      the iterations that hold the intersections.  */\n \n-  left_a = CHREC_LEFT (chrec_a);\n-  left_b = CHREC_LEFT (chrec_b);\n-  right_a = CHREC_RIGHT (chrec_a);\n-  right_b = CHREC_RIGHT (chrec_b);\n   \n-  if (chrec_zerop (chrec_fold_minus (integer_type_node, left_a, left_b)))\n-    {\n-      /* The first element accessed twice is on the first\n-\t iteration.  */\n-      *overlaps_a = build_polynomial_chrec \n-\t(CHREC_VARIABLE (chrec_b), integer_zero_node, integer_one_node);\n-      *overlaps_b = build_polynomial_chrec \n-\t(CHREC_VARIABLE (chrec_a), integer_zero_node, integer_one_node);\n-    }\n-  \n-  else if (TREE_CODE (left_a) == INTEGER_CST\n-\t   && TREE_CODE (left_b) == INTEGER_CST\n-\t   && TREE_CODE (right_a) == INTEGER_CST \n-\t   && TREE_CODE (right_b) == INTEGER_CST\n-\t   \n-\t   /* Both functions should have the same evolution sign.  */\n-\t   && ((tree_int_cst_sgn (right_a) > 0 \n-\t\t&& tree_int_cst_sgn (right_b) > 0)\n-\t       || (tree_int_cst_sgn (right_a) < 0\n-\t\t   && tree_int_cst_sgn (right_b) < 0)))\n+  nb_vars_a = nb_vars_in_chrec (chrec_a);\n+  nb_vars_b = nb_vars_in_chrec (chrec_b);\n+\n+  dim = nb_vars_a + nb_vars_b;\n+  U = lambda_matrix_new (dim, dim);\n+  A = lambda_matrix_new (dim, 1);\n+  S = lambda_matrix_new (dim, 1);\n+\n+  init_a = initialize_matrix_A (A, chrec_a, 0, 1);\n+  init_b = initialize_matrix_A (A, chrec_b, nb_vars_a, -1);\n+  gamma = init_b - init_a;\n+\n+  /* Don't do all the hard work of solving the Diophantine equation\n+     when we already know the solution: for example, \n+     | {3, +, 1}_1\n+     | {3, +, 4}_2\n+     | gamma = 3 - 3 = 0.\n+     Then the first overlap occurs during the first iterations: \n+     | {3, +, 1}_1 ({0, +, 4}_x) = {3, +, 4}_2 ({0, +, 1}_x)\n+  */\n+  if (gamma == 0)\n     {\n-      /* Here we have to solve the Diophantine equation.  Reference\n-\t book: \"Loop Transformations for Restructuring Compilers - The\n-\t Foundations\" by Utpal Banerjee, pages 59-80.\n-\t \n-\t ALPHA * X0 = BETA * Y0 + GAMMA.  \n-\t \n-\t with:\n-\t ALPHA = RIGHT_A\n-\t BETA = RIGHT_B\n-\t GAMMA = LEFT_B - LEFT_A\n-\t CHREC_A = {LEFT_A, +, RIGHT_A}\n-\t CHREC_B = {LEFT_B, +, RIGHT_B}\n-\t \n-\t The Diophantine equation has a solution if and only if gcd\n-\t (ALPHA, BETA) divides GAMMA.  This is commonly known under\n-\t the name of the \"gcd-test\".\n-      */\n-      tree alpha, beta, gamma;\n-      tree la, lb;\n-      tree gcd_alpha_beta;\n-      tree u11, u12, u21, u22;\n-\n-      /* Both alpha and beta have to be integer_type_node. The gcd\n-\t function does not work correctly otherwise.  */\n-      alpha = copy_node (right_a);\n-      beta = copy_node (right_b);\n-      la = copy_node (left_a);\n-      lb = copy_node (left_b);\n-      TREE_TYPE (alpha) = integer_type_node;\n-      TREE_TYPE (beta) = integer_type_node;\n-      TREE_TYPE (la) = integer_type_node;\n-      TREE_TYPE (lb) = integer_type_node;\n-      \n-      gamma = fold (build (MINUS_EXPR, integer_type_node, lb, la));\n-      \n-      /* FIXME: Use lambda_*_Hermite for implementing Bezout.  */\n-      gcd_alpha_beta = tree_fold_bezout \n-\t(alpha, \n-\t fold (build (MULT_EXPR, integer_type_node, beta, \n-\t\t      integer_minus_one_node)),\n-\t &u11, &u12, \n-\t &u21, &u22);\n-      \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (nb_vars_a == 1 && nb_vars_b == 1)\n \t{\n-\t  fprintf (dump_file, \"  (alpha = \");\n-\t  print_generic_expr (dump_file, alpha, 0);\n-\t  fprintf (dump_file, \")\\n  (beta = \");\n-\t  print_generic_expr (dump_file, beta, 0);\n-\t  fprintf (dump_file, \")\\n  (gamma = \");\n-\t  print_generic_expr (dump_file, gamma, 0);\n-\t  fprintf (dump_file, \")\\n  (gcd_alpha_beta = \");\n-\t  print_generic_expr (dump_file, gcd_alpha_beta, 0);\n-\t  fprintf (dump_file, \")\\n\");\n+\t  int step_a, step_b;\n+\t  int niter, niter_a, niter_b;\n+\t  tree numiter_a, numiter_b;\n+\n+\t  numiter_a = number_of_iterations_in_loop \n+\t    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n+\t  numiter_b = number_of_iterations_in_loop \n+\t    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n+\n+\t  if (TREE_CODE (numiter_a) != INTEGER_CST)\n+\t    numiter_a = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n+\t      ->estimated_nb_iterations;\n+\t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n+\t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n+\t      ->estimated_nb_iterations;\n+\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t    {\n+\t      *overlaps_a = chrec_dont_know;\n+\t      *overlaps_b = chrec_dont_know;\n+\t      *last_conflicts = chrec_dont_know;\n+\t      return;\n+\t    }\n+\n+\t  niter_a = int_cst_value (numiter_a);\n+\t  niter_b = int_cst_value (numiter_b);\n+\t  niter = MIN (niter_a, niter_b);\n+\n+\t  step_a = int_cst_value (CHREC_RIGHT (chrec_a));\n+\t  step_b = int_cst_value (CHREC_RIGHT (chrec_b));\n+\n+\t  compute_overlap_steps_for_affine_univar (niter, step_a, step_b, \n+\t\t\t\t\t\t   overlaps_a, overlaps_b, \n+\t\t\t\t\t\t   last_conflicts, 1);\n \t}\n-      \n-      /* The classic \"gcd-test\".  */\n-      if (!tree_fold_divides_p (integer_type_node, gcd_alpha_beta, gamma))\n+\n+      else if (nb_vars_a == 2 && nb_vars_b == 1)\n+\tcompute_overlap_steps_for_affine_1_2\n+\t  (chrec_a, chrec_b, overlaps_a, overlaps_b, last_conflicts);\n+\n+      else if (nb_vars_a == 1 && nb_vars_b == 2)\n+\tcompute_overlap_steps_for_affine_1_2\n+\t  (chrec_b, chrec_a, overlaps_b, overlaps_a, last_conflicts);\n+\n+      else\n \t{\n-\t  /* The \"gcd-test\" has determined that there is no integer\n-\t     solution, i.e. there is no dependence.  */\n-\t  *overlaps_a = chrec_known;\n-\t  *overlaps_b = chrec_known;\n+\t  *overlaps_a = chrec_dont_know;\n+\t  *overlaps_b = chrec_dont_know;\n+\t  *last_conflicts = chrec_dont_know;\n \t}\n-      \n-      else\n+      return;\n+    }\n+\n+  /* U.A = S */\n+  lambda_matrix_right_hermite (A, dim, 1, S, U);\n+\n+  if (S[0][0] < 0)\n+    {\n+      S[0][0] *= -1;\n+      lambda_matrix_row_negate (U, dim, 0);\n+    }\n+  gcd_alpha_beta = S[0][0];\n+\n+  /* The classic \"gcd-test\".  */\n+  if (!int_divides_p (gcd_alpha_beta, gamma))\n+    {\n+      /* The \"gcd-test\" has determined that there is no integer\n+\t solution, i.e. there is no dependence.  */\n+      *overlaps_a = chrec_known;\n+      *overlaps_b = chrec_known;\n+      *last_conflicts = integer_zero_node;\n+    }\n+\n+  /* Both access functions are univariate.  This includes SIV and MIV cases.  */\n+  else if (nb_vars_a == 1 && nb_vars_b == 1)\n+    {\n+      /* Both functions should have the same evolution sign.  */\n+      if (((A[0][0] > 0 && -A[1][0] > 0)\n+\t   || (A[0][0] < 0 && -A[1][0] < 0)))\n \t{\n \t  /* The solutions are given by:\n \t     | \n-\t     | [GAMMA/GCD_ALPHA_BETA  t].[u11 u12]  = [X]\n-\t     |                           [u21 u22]    [Y]\n-\t     \n+\t     | [GAMMA/GCD_ALPHA_BETA  t].[u11 u12]  = [x0]\n+\t     |                           [u21 u22]    [y0]\n+\t \n \t     For a given integer t.  Using the following variables,\n-\t     \n+\t \n \t     | i0 = u11 * gamma / gcd_alpha_beta\n \t     | j0 = u12 * gamma / gcd_alpha_beta\n \t     | i1 = u21\n \t     | j1 = u22\n-\t     \n+\t \n \t     the solutions are:\n-\t     \n-\t     | x = i0 + i1 * t, \n-\t     | y = j0 + j1 * t.  */\n-\t  \n-\t  tree i0, j0, i1, j1, t;\n-\t  tree gamma_gcd;\n-\t  \n+\t \n+\t     | x0 = i0 + i1 * t, \n+\t     | y0 = j0 + j1 * t.  */\n+      \n+\t  int i0, j0, i1, j1;\n+\n \t  /* X0 and Y0 are the first iterations for which there is a\n \t     dependence.  X0, Y0 are two solutions of the Diophantine\n \t     equation: chrec_a (X0) = chrec_b (Y0).  */\n-\t  tree x0, y0;\n-      \n-\t  /* Exact div because in this case gcd_alpha_beta divides\n-\t     gamma.  */\n-\t  gamma_gcd = fold (build (EXACT_DIV_EXPR, integer_type_node, gamma, \n-\t\t\t\t   gcd_alpha_beta));\n-\t  i0 = fold (build (MULT_EXPR, integer_type_node, u11, gamma_gcd));\n-\t  j0 = fold (build (MULT_EXPR, integer_type_node, u12, gamma_gcd));\n-\t  i1 = u21;\n-\t  j1 = u22;\n-\t  \n-\t  if ((tree_int_cst_sgn (i1) == 0\n-\t       && tree_int_cst_sgn (i0) < 0)\n-\t      || (tree_int_cst_sgn (j1) == 0\n-\t\t  && tree_int_cst_sgn (j0) < 0))\n+\t  int x0, y0;\n+\t  int niter, niter_a, niter_b;\n+\t  tree numiter_a, numiter_b;\n+\n+\t  numiter_a = number_of_iterations_in_loop \n+\t    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n+\t  numiter_b = number_of_iterations_in_loop \n+\t    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n+\n+\t  if (TREE_CODE (numiter_a) != INTEGER_CST)\n+\t    numiter_a = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n+\t      ->estimated_nb_iterations;\n+\t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n+\t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n+\t      ->estimated_nb_iterations;\n+\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t    {\n+\t      *overlaps_a = chrec_dont_know;\n+\t      *overlaps_b = chrec_dont_know;\n+\t      *last_conflicts = chrec_dont_know;\n+\t      return;\n+\t    }\n+\n+\t  niter_a = int_cst_value (numiter_a);\n+\t  niter_b = int_cst_value (numiter_b);\n+\t  niter = MIN (niter_a, niter_b);\n+\n+\t  i0 = U[0][0] * gamma / gcd_alpha_beta;\n+\t  j0 = U[0][1] * gamma / gcd_alpha_beta;\n+\t  i1 = U[1][0];\n+\t  j1 = U[1][1];\n+\n+\t  if ((i1 == 0 && i0 < 0)\n+\t      || (j1 == 0 && j0 < 0))\n \t    {\n \t      /* There is no solution.  \n \t\t FIXME: The case \"i0 > nb_iterations, j0 > nb_iterations\" \n \t\t falls in here, but for the moment we don't look at the \n \t\t upper bound of the iteration domain.  */\n \t      *overlaps_a = chrec_known;\n \t      *overlaps_b = chrec_known;\n-  \t    }\n-\t  \n+\t      *last_conflicts = integer_zero_node;\n+\t    }\n+\n \t  else \n \t    {\n-\t      if (tree_int_cst_sgn (i1) > 0)\n+\t      if (i1 > 0)\n \t\t{\n-\t\t  t = fold \n-\t\t    (build (CEIL_DIV_EXPR, integer_type_node, \n-\t\t\t    fold (build (MULT_EXPR, integer_type_node, i0, \n-\t\t\t\t\t integer_minus_one_node)), \n-\t\t\t    i1));\n-\t\t  \n-\t\t  if (tree_int_cst_sgn (j1) > 0)\n+\t\t  tau1 = CEIL (-i0, i1);\n+\t\t  tau2 = FLOOR_DIV (niter - i0, i1);\n+\n+\t\t  if (j1 > 0)\n \t\t    {\n-\t\t      t = fold \n-\t\t\t(build (MAX_EXPR, integer_type_node, t,\n-\t\t\t\tfold (build (CEIL_DIV_EXPR, integer_type_node,\n-\t\t\t\t\t     fold (build \n-\t\t\t\t\t\t   (MULT_EXPR,\n-\t\t\t\t\t\t    integer_type_node, j0,\n-\t\t\t\t\t\t    integer_minus_one_node)),\n-\t\t\t\t\t     j1))));\n-\t\t      \n-\t\t      x0 = fold \n-\t\t\t(build (PLUS_EXPR, integer_type_node, i0, \n-\t\t\t\tfold (build \n-\t\t\t\t      (MULT_EXPR, integer_type_node, i1, t))));\n-\t\t      y0 = fold \n-\t\t\t(build (PLUS_EXPR, integer_type_node, j0, \n-\t\t\t\tfold (build \n-\t\t\t\t      (MULT_EXPR, integer_type_node, j1, t))));\n-\t\t      \n-\t\t      *overlaps_a = build_polynomial_chrec \n-\t\t\t(CHREC_VARIABLE (chrec_b), x0, u21);\n-\t\t      *overlaps_b = build_polynomial_chrec \n-\t\t\t(CHREC_VARIABLE (chrec_a), y0, u22);\n+\t\t      int last_conflict;\n+\t\t      tau1 = MAX (tau1, CEIL (-j0, j1));\n+\t\t      tau2 = MIN (tau2, FLOOR_DIV (niter - j0, j1));\n+\n+\t\t      x0 = (i1 * tau1 + i0) % i1;\n+\t\t      y0 = (j1 * tau1 + j0) % j1;\n+\t\t      tau1 = (x0 - i0)/i1;\n+\t\t      last_conflict = tau2 - tau1;\n+\n+\t\t      *overlaps_a = build_polynomial_chrec\n+\t\t\t(1,\n+\t\t\t build_int_cst (NULL_TREE, x0),\n+\t\t\t build_int_cst (NULL_TREE, i1));\n+\t\t      *overlaps_b = build_polynomial_chrec\n+\t\t\t(1,\n+\t\t\t build_int_cst (NULL_TREE, y0),\n+\t\t\t build_int_cst (NULL_TREE, j1));\n+\t\t      *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* FIXME: For the moment, the upper bound of the\n \t\t\t iteration domain for j is not checked. */\n \t\t      *overlaps_a = chrec_dont_know;\n \t\t      *overlaps_b = chrec_dont_know;\n+\t\t      *last_conflicts = chrec_dont_know;\n \t\t    }\n \t\t}\n-\t      \n+\t  \n \t      else\n \t\t{\n \t\t  /* FIXME: For the moment, the upper bound of the\n \t\t     iteration domain for i is not checked. */\n \t\t  *overlaps_a = chrec_dont_know;\n \t\t  *overlaps_b = chrec_dont_know;\n+\t\t  *last_conflicts = chrec_dont_know;\n \t\t}\n \t    }\n \t}\n+      else\n+\t{\n+\t  *overlaps_a = chrec_dont_know;\n+\t  *overlaps_b = chrec_dont_know;\n+\t  *last_conflicts = chrec_dont_know;\n+\t}\n     }\n-  \n+\n   else\n     {\n-      /* For the moment, \"don't know\".  */\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n     }\n-  \n+\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (overlaps_a = \");\n@@ -1186,30 +1514,31 @@ static void\n analyze_siv_subscript (tree chrec_a, \n \t\t       tree chrec_b,\n \t\t       tree *overlaps_a, \n-\t\t       tree *overlaps_b)\n+\t\t       tree *overlaps_b, \n+\t\t       tree *last_conflicts)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_siv_subscript \\n\");\n   \n   if (evolution_function_is_constant_p (chrec_a)\n       && evolution_function_is_affine_p (chrec_b))\n     analyze_siv_subscript_cst_affine (chrec_a, chrec_b, \n-\t\t\t\t      overlaps_a, overlaps_b);\n+\t\t\t\t      overlaps_a, overlaps_b, last_conflicts);\n   \n   else if (evolution_function_is_affine_p (chrec_a)\n \t   && evolution_function_is_constant_p (chrec_b))\n-    analyze_siv_subscript_affine_cst (chrec_a, chrec_b, \n-\t\t\t\t      overlaps_a, overlaps_b);\n+    analyze_siv_subscript_cst_affine (chrec_b, chrec_a, \n+\t\t\t\t      overlaps_b, overlaps_a, last_conflicts);\n   \n   else if (evolution_function_is_affine_p (chrec_a)\n-\t   && evolution_function_is_affine_p (chrec_b)\n-\t   && (CHREC_VARIABLE (chrec_a) == CHREC_VARIABLE (chrec_b)))\n+\t   && evolution_function_is_affine_p (chrec_b))\n     analyze_subscript_affine_affine (chrec_a, chrec_b, \n-\t\t\t\t     overlaps_a, overlaps_b);\n+\t\t\t\t     overlaps_a, overlaps_b, last_conflicts);\n   else\n     {\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n     }\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1246,7 +1575,8 @@ static void\n analyze_miv_subscript (tree chrec_a, \n \t\t       tree chrec_b, \n \t\t       tree *overlaps_a, \n-\t\t       tree *overlaps_b)\n+\t\t       tree *overlaps_b, \n+\t\t       tree *last_conflicts)\n {\n   /* FIXME:  This is a MIV subscript, not yet handled.\n      Example: (A[{1, +, 1}_1] vs. A[{1, +, 1}_2]) that comes from \n@@ -1269,6 +1599,8 @@ analyze_miv_subscript (tree chrec_a,\n \t in the same order.  */\n       *overlaps_a = integer_zero_node;\n       *overlaps_b = integer_zero_node;\n+      *last_conflicts = number_of_iterations_in_loop \n+\t(current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n     }\n   \n   else if (evolution_function_is_constant_p (difference)\n@@ -1283,32 +1615,36 @@ analyze_miv_subscript (tree chrec_a,\n \t consequently there are no overlapping elements.  */\n       *overlaps_a = chrec_known;\n       *overlaps_b = chrec_known;\n+      *last_conflicts = integer_zero_node;\n     }\n   \n-  else if (evolution_function_is_univariate_p (chrec_a)\n-\t   && evolution_function_is_univariate_p (chrec_b))\n+  else if (evolution_function_is_affine_multivariate_p (chrec_a)\n+\t   && evolution_function_is_affine_multivariate_p (chrec_b))\n     {\n       /* testsuite/.../ssa-chrec-35.c\n \t {0, +, 1}_2  vs.  {0, +, 1}_3\n \t the overlapping elements are respectively located at iterations:\n-\t {0, +, 1}_3 and {0, +, 1}_2.\n+\t {0, +, 1}_x and {0, +, 1}_x, \n+\t in other words, we have the equality: \n+\t {0, +, 1}_2 ({0, +, 1}_x) = {0, +, 1}_3 ({0, +, 1}_x)\n+\t \n+\t Other examples: \n+\t {{0, +, 1}_1, +, 2}_2 ({0, +, 1}_x, {0, +, 1}_y) = \n+\t {0, +, 1}_1 ({{0, +, 1}_x, +, 2}_y)\n+\n+\t {{0, +, 2}_1, +, 3}_2 ({0, +, 1}_y, {0, +, 1}_x) = \n+\t {{0, +, 3}_1, +, 2}_2 ({0, +, 1}_x, {0, +, 1}_y)\n       */\n-      if (evolution_function_is_affine_p (chrec_a)\n-\t  && evolution_function_is_affine_p (chrec_b))\n-\tanalyze_subscript_affine_affine (chrec_a, chrec_b, \n-\t\t\t\t\t overlaps_a, overlaps_b);\n-      else\n-\t{\n-\t  *overlaps_a = chrec_dont_know;\n-\t  *overlaps_b = chrec_dont_know;\n-\t}\n+      analyze_subscript_affine_affine (chrec_a, chrec_b, \n+\t\t\t\t       overlaps_a, overlaps_b, last_conflicts);\n     }\n   \n   else\n     {\n       /* When the analysis is too difficult, answer \"don't know\".  */\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n     }\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1329,7 +1665,8 @@ static void\n analyze_overlapping_iterations (tree chrec_a, \n \t\t\t\ttree chrec_b, \n \t\t\t\ttree *overlap_iterations_a, \n-\t\t\t\ttree *overlap_iterations_b)\n+\t\t\t\ttree *overlap_iterations_b, \n+\t\t\t\ttree *last_conflicts)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1354,15 +1691,18 @@ analyze_overlapping_iterations (tree chrec_a,\n   \n   else if (ziv_subscript_p (chrec_a, chrec_b))\n     analyze_ziv_subscript (chrec_a, chrec_b, \n-\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+\t\t\t   overlap_iterations_a, overlap_iterations_b,\n+\t\t\t   last_conflicts);\n   \n   else if (siv_subscript_p (chrec_a, chrec_b))\n     analyze_siv_subscript (chrec_a, chrec_b, \n-\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+\t\t\t   overlap_iterations_a, overlap_iterations_b, \n+\t\t\t   last_conflicts);\n   \n   else\n     analyze_miv_subscript (chrec_a, chrec_b, \n-\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+\t\t\t   overlap_iterations_a, overlap_iterations_b,\n+\t\t\t   last_conflicts);\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1386,6 +1726,7 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n   unsigned int i;\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n+  tree last_conflicts;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n@@ -1397,7 +1738,8 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n       \n       analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n \t\t\t\t      DR_ACCESS_FN (drb, i),\n-\t\t\t\t      &overlaps_a, &overlaps_b);\n+\t\t\t\t      &overlaps_a, &overlaps_b, \n+\t\t\t\t      &last_conflicts);\n       \n       if (chrec_contains_undetermined (overlaps_a)\n  \t  || chrec_contains_undetermined (overlaps_b))\n@@ -1417,6 +1759,7 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n  \t{\n  \t  SUB_CONFLICTS_IN_A (subscript) = overlaps_a;\n  \t  SUB_CONFLICTS_IN_B (subscript) = overlaps_b;\n+\t  SUB_LAST_CONFLICT (subscript) = last_conflicts;\n  \t}\n     }\n   \n@@ -1428,7 +1771,8 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n \n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP is the loop->num of the first loop.  */\n+   FIRST_LOOP is the loop->num of the first loop in the analyzed \n+   loop nest.  */\n \n static void\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n@@ -1447,22 +1791,68 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n   \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n+      tree access_fn_a, access_fn_b;\n       struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n \n       if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n-\treturn;\n+\t{\n+\t  non_affine_dependence_relation (ddr);\n+\t  return;\n+\t}\n+\n+      access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n+      access_fn_b = DR_ACCESS_FN (DDR_B (ddr), i);\n \n-      if (TREE_CODE (SUB_CONFLICTS_IN_A (subscript)) == POLYNOMIAL_CHREC)\n+      if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC \n+\t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n \t{\n-\t  int dist;\n-\t  int loop_nb;\n-\t  loop_nb = CHREC_VARIABLE (SUB_CONFLICTS_IN_A (subscript));\n+\t  int dist, loop_nb;\n+\t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n+\t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n+\t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n+\t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n+\n+\t  if (loop_nb_a != loop_nb_b\n+\t      && !flow_loop_nested_p (loop_a, loop_b)\n+\t      && !flow_loop_nested_p (loop_b, loop_a))\n+\t    {\n+\t      /* Example: when there are two consecutive loops,\n+\n+\t\t | loop_1\n+\t\t |   A[{0, +, 1}_1]\n+\t\t | endloop_1\n+\t\t | loop_2\n+\t\t |   A[{0, +, 1}_2]\n+\t\t | endloop_2\n+\n+\t\t the dependence relation cannot be captured by the\n+\t\t distance abstraction.  */\n+\t      non_affine_dependence_relation (ddr);\n+\t      return;\n+\t    }\n+\n+\t  /* The dependence is carried by the outermost loop.  Example:\n+\t     | loop_1\n+\t     |   A[{4, +, 1}_1]\n+\t     |   loop_2\n+\t     |     A[{5, +, 1}_2]\n+\t     |   endloop_2\n+\t     | endloop_1\n+\t     In this case, the dependence is carried by loop_1.  */\n+\t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n \t  loop_nb -= first_loop;\n+\n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n \t  gcc_assert (loop_nb >= 0);\n \t  gcc_assert (loop_nb < nb_loops);\n+\t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n+\t    {\n+\t      non_affine_dependence_relation (ddr);\n+\t      return;\n+\t    }\n+\t  \n \t  dist = int_cst_value (SUB_DISTANCE (subscript));\n \n \t  /* This is the subscript coupling test.  \n@@ -1505,6 +1895,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n     lca_nb -= first_loop;\n     gcc_assert (lca_nb >= 0);\n     gcc_assert (lca_nb < nb_loops);\n+\n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n@@ -1519,8 +1910,13 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \tlca_nb = lca->num - first_loop;\n \twhile (lca->depth != 0)\n \t  {\n-\t    gcc_assert (lca_nb >= 0);\n+\t    /* If we're considering just a sub-nest, then don't record\n+\t       any information on the outer loops.  */\n+\t    if (lca_nb < 0)\n+\t      break;\n+\n \t    gcc_assert (lca_nb < nb_loops);\n+\n \t    if (init_v[lca_nb] == 0)\n \t      dist_v[lca_nb] = 1;\n \t    lca = lca->outer;\n@@ -1531,13 +1927,15 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n   }\n   \n   DDR_DIST_VECT (ddr) = dist_v;\n+  DDR_SIZE_VECT (ddr) = nb_loops;\n }\n \n /* Compute the classic per loop direction vector.  \n \n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP is the loop->num of the first loop.  */\n+   FIRST_LOOP is the loop->num of the first loop in the analyzed \n+   loop nest.  */\n \n static void\n build_classic_dir_vector (struct data_dependence_relation *ddr, \n@@ -1556,33 +1954,77 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n   \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n+      tree access_fn_a, access_fn_b;\n       struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n \n-      if (TREE_CODE (SUB_CONFLICTS_IN_A (subscript)) == POLYNOMIAL_CHREC\n-\t  && TREE_CODE (SUB_CONFLICTS_IN_B (subscript)) == POLYNOMIAL_CHREC)\n+      if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t{\n-\t  int loop_nb;\n-\t  \n+\t  non_affine_dependence_relation (ddr);\n+\t  return;\n+\t}\n+\n+      access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n+      access_fn_b = DR_ACCESS_FN (DDR_B (ddr), i);\n+      if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC\n+\t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n+\t{\n+\t  int dist, loop_nb;\n \t  enum data_dependence_direction dir = dir_star;\n-\t  loop_nb = CHREC_VARIABLE (SUB_CONFLICTS_IN_A (subscript));\n+\t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n+\t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n+\t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n+\t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n+\n+\t  if (loop_nb_a != loop_nb_b\n+\t      && !flow_loop_nested_p (loop_a, loop_b)\n+\t      && !flow_loop_nested_p (loop_b, loop_a))\n+\t    {\n+\t      /* Example: when there are two consecutive loops,\n+\n+\t\t | loop_1\n+\t\t |   A[{0, +, 1}_1]\n+\t\t | endloop_1\n+\t\t | loop_2\n+\t\t |   A[{0, +, 1}_2]\n+\t\t | endloop_2\n+\n+\t\t the dependence relation cannot be captured by the\n+\t\t distance abstraction.  */\n+\t      non_affine_dependence_relation (ddr);\n+\t      return;\n+\t    }\n+\n+\t  /* The dependence is carried by the outermost loop.  Example:\n+\t     | loop_1\n+\t     |   A[{4, +, 1}_1]\n+\t     |   loop_2\n+\t     |     A[{5, +, 1}_2]\n+\t     |   endloop_2\n+\t     | endloop_1\n+\t     In this case, the dependence is carried by loop_1.  */\n+\t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n \t  loop_nb -= first_loop;\n \n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n \t  gcc_assert (loop_nb >= 0);\n \t  gcc_assert (loop_nb < nb_loops);\n-\t  if (!chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n+\n+\t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n-\t      int dist = int_cst_value (SUB_DISTANCE (subscript));\n-\t      \n-\t      if (dist == 0)\n-\t\tdir = dir_equal;\n-\t      else if (dist > 0)\n-\t\tdir = dir_positive;\n-\t      else if (dist < 0)\n-\t\tdir = dir_negative;\n+\t      non_affine_dependence_relation (ddr);\n+\t      return;\n \t    }\n+\n+\t  dist = int_cst_value (SUB_DISTANCE (subscript));\n+\n+\t  if (dist == 0)\n+\t    dir = dir_equal;\n+\t  else if (dist > 0)\n+\t    dir = dir_positive;\n+\t  else if (dist < 0)\n+\t    dir = dir_negative;\n \t  \n \t  /* This is the subscript coupling test.  \n \t     | loop i = 0, N, 1\n@@ -1625,6 +2067,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \n     gcc_assert (lca_nb >= 0);\n     gcc_assert (lca_nb < nb_loops);\n+\n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n@@ -1638,8 +2081,13 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \tlca_nb = lca->num - first_loop;\n \twhile (lca->depth != 0)\n \t  {\n-\t    gcc_assert (lca_nb >= 0);\n+\t    /* If we're considering just a sub-nest, then don't record\n+\t       any information on the outer loops.  */\n+\t    if (lca_nb < 0)\n+\t      break;\n+\n \t    gcc_assert (lca_nb < nb_loops);\n+\n \t    if (init_v[lca_nb] == 0)\n \t      dir_v[lca_nb] = dir_positive;\n \t    lca = lca->outer;\n@@ -1650,6 +2098,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n   }\n   \n   DDR_DIR_VECT (ddr) = dir_v;\n+  DDR_SIZE_VECT (ddr) = nb_loops;\n }\n \n /* Returns true when all the access functions of A are affine or\n@@ -1734,12 +2183,11 @@ compute_all_dependences (varray_type datarefs,\n \n \ta = VARRAY_GENERIC_PTR (datarefs, i);\n \tb = VARRAY_GENERIC_PTR (datarefs, j);\n-\n \tddr = initialize_data_dependence_relation (a, b);\n \n \tVARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n \tcompute_affine_dependence (ddr);\n-\tcompute_distance_vector (ddr);\n+\tcompute_subscript_distance (ddr);\n       }\n }\n \n@@ -1752,12 +2200,13 @@ compute_all_dependences (varray_type datarefs,\n    acceptable for the moment, since this function is used only for\n    debugging purposes.  */\n \n-static tree \n+tree \n find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n {\n+  bool dont_know_node_not_inserted = true;\n   basic_block bb;\n   block_stmt_iterator bsi;\n-  \n+\n   FOR_EACH_BB (bb)\n     {\n       if (!flow_bb_inside_loop_p (loop, bb))\n@@ -1789,11 +2238,33 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t\t\t\t       true));\n \n   \t  else\n-\t    return chrec_dont_know;\n+\t    {\n+\t      if (dont_know_node_not_inserted)\n+\t\t{\n+\t\t  struct data_reference *res;\n+\t\t  res = xmalloc (sizeof (struct data_reference));\n+\t\t  DR_STMT (res) = NULL_TREE;\n+\t\t  DR_REF (res) = NULL_TREE;\n+\t\t  DR_ACCESS_FNS (res) = NULL;\n+\t\t  DR_BASE_NAME (res) = NULL;\n+\t\t  DR_IS_READ (res) = false;\n+\t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, res);\n+\n+\t\t  dont_know_node_not_inserted = false;\n+\t\t}\n+\t    }\n+\n+\t  /* When there are no defs in the loop, the loop is parallel.  */\n+\t  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n+\t      || NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n+\t    bb->loop_father->parallel_p = false;\n \t}\n+\n+      if (bb->loop_father->estimated_nb_iterations == NULL_TREE)\n+\tcompute_estimated_nb_iterations (bb->loop_father);\n     }\n \n-  return NULL_TREE;\n+  return dont_know_node_not_inserted ? NULL_TREE : chrec_dont_know;\n }\n \n \f\n@@ -1881,63 +2352,44 @@ analyze_all_data_dependences (struct loops *loops)\n     {\n       dump_data_dependence_relations (dump_file, dependence_relations);\n       fprintf (dump_file, \"\\n\\n\");\n-    }\n \n-  /* Don't dump distances in order to avoid to update the\n-     testsuite.  */\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n-\t{\n-\t  struct data_dependence_relation *ddr = \n-\t    (struct data_dependence_relation *) \n-\t    VARRAY_GENERIC_PTR (dependence_relations, i);\n-\t  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-\t    {\n-\t      fprintf (dump_file, \"DISTANCE_V (\");\n-\t      print_lambda_vector (dump_file, DDR_DIST_VECT (ddr), loops->num);\n-\t      fprintf (dump_file, \")\\n\");\n-\t      fprintf (dump_file, \"DIRECTION_V (\");\n-\t      print_lambda_vector (dump_file, DDR_DIR_VECT (ddr), loops->num);\n-\t      fprintf (dump_file, \")\\n\");\n-\t    }\n-\t}\n-      fprintf (dump_file, \"\\n\\n\");\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_STATS))\n-    {\n-      unsigned nb_top_relations = 0;\n-      unsigned nb_bot_relations = 0;\n-      unsigned nb_basename_differ = 0;\n-      unsigned nb_chrec_relations = 0;\n+      if (dump_flags & TDF_DETAILS)\n+\tdump_dist_dir_vectors (dump_file, dependence_relations);\n \n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+      if (dump_flags & TDF_STATS)\n \t{\n-\t  struct data_dependence_relation *ddr;\n-\t  ddr = VARRAY_GENERIC_PTR (dependence_relations, i);\n+\t  unsigned nb_top_relations = 0;\n+\t  unsigned nb_bot_relations = 0;\n+\t  unsigned nb_basename_differ = 0;\n+\t  unsigned nb_chrec_relations = 0;\n+\n+\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+\t    {\n+\t      struct data_dependence_relation *ddr;\n+\t      ddr = VARRAY_GENERIC_PTR (dependence_relations, i);\n \t  \n-\t  if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n-\t    nb_top_relations++;\n+\t      if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n+\t\tnb_top_relations++;\n \t  \n-\t  else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-\t    {\n-\t      struct data_reference *a = DDR_A (ddr);\n-\t      struct data_reference *b = DDR_B (ddr);\n-\t      bool differ_p;\t\n+\t      else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\t\t{\n+\t\t  struct data_reference *a = DDR_A (ddr);\n+\t\t  struct data_reference *b = DDR_B (ddr);\n+\t\t  bool differ_p;\t\n \t      \n-\t      if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n-\t\t  || (array_base_name_differ_p (a, b, &differ_p) && differ_p))\n-\t\tnb_basename_differ++;\n-\t      else\n-\t\tnb_bot_relations++;\n-\t    }\n+\t\t  if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n+\t\t      || (array_base_name_differ_p (a, b, &differ_p) && differ_p))\n+\t\t    nb_basename_differ++;\n+\t\t  else\n+\t\t    nb_bot_relations++;\n+\t\t}\n \t  \n-\t  else \n-\t    nb_chrec_relations++;\n-\t}\n+\t      else \n+\t\tnb_chrec_relations++;\n+\t    }\n       \n-      gather_stats_on_scev_database ();\n+\t  gather_stats_on_scev_database ();\n+\t}\n     }\n \n   free_dependence_relations (dependence_relations);\n@@ -1991,3 +2443,4 @@ free_data_refs (varray_type datarefs)\n     }\n   varray_clear (datarefs);\n }\n+"}, {"sha": "ea3bb7ddd30090450c79f74d422ffde202b0078d", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -79,10 +79,9 @@ struct subscript\n   tree conflicting_iterations_in_a;\n   tree conflicting_iterations_in_b;\n   \n-  /* These fields store the information about the iteration domain\n+  /* This field stores the information about the iteration domain\n      validity of the dependence relation.  */\n-  tree last_conflict_in_a;\n-  tree last_conflict_in_b;\n+  tree last_conflict;\n   \n   /* Distance from the iteration that access a conflicting element in\n      A to the iteration that access this same conflicting element in\n@@ -93,8 +92,7 @@ struct subscript\n \n #define SUB_CONFLICTS_IN_A(SUB) SUB->conflicting_iterations_in_a\n #define SUB_CONFLICTS_IN_B(SUB) SUB->conflicting_iterations_in_b\n-#define SUB_LAST_CONFLICT_IN_A(SUB) SUB->last_conflict_in_a\n-#define SUB_LAST_CONFLICT_IN_B(SUB) SUB->last_conflict_in_b\n+#define SUB_LAST_CONFLICT(SUB) SUB->last_conflict\n #define SUB_DISTANCE(SUB) SUB->distance\n \n /* A data_dependence_relation represents a relation between two\n@@ -106,6 +104,10 @@ struct data_dependence_relation\n   struct data_reference *a;\n   struct data_reference *b;\n \n+  /* When the dependence relation is affine, it can be represented by\n+     a distance vector.  */\n+  bool affine_p;\n+\n   /* A \"yes/no/maybe\" field for the dependence relation:\n      \n      - when \"ARE_DEPENDENT == NULL_TREE\", there exist a dependence\n@@ -124,6 +126,9 @@ struct data_dependence_relation\n      the data_dependence_relation.  */\n   varray_type subscripts;\n \n+  /* The size of the direction/distance vectors.  */\n+  int size_vect;\n+\n   /* The classic direction vector.  */\n   lambda_vector dir_vect;\n \n@@ -133,26 +138,32 @@ struct data_dependence_relation\n \n #define DDR_A(DDR) DDR->a\n #define DDR_B(DDR) DDR->b\n+#define DDR_AFFINE_P(DDR) DDR->affine_p\n #define DDR_ARE_DEPENDENT(DDR) DDR->are_dependent\n #define DDR_SUBSCRIPTS(DDR) DDR->subscripts\n #define DDR_SUBSCRIPTS_VECTOR_INIT(DDR, N) \\\n   VARRAY_GENERIC_PTR_INIT (DDR_SUBSCRIPTS (DDR), N, \"subscripts_vector\");\n #define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n #define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n+#define DDR_SIZE_VECT(DDR) DDR->size_vect\n #define DDR_DIR_VECT(DDR) DDR->dir_vect\n #define DDR_DIST_VECT(DDR) DDR->dist_vect\n \n \f\n \n-struct data_dependence_relation *initialize_data_dependence_relation \n+extern tree find_data_references_in_loop (struct loop *, varray_type *);\n+extern struct data_dependence_relation *initialize_data_dependence_relation \n (struct data_reference *, struct data_reference *);\n-void compute_affine_dependence (struct data_dependence_relation *);\n+extern void compute_affine_dependence (struct data_dependence_relation *);\n extern void analyze_all_data_dependences (struct loops *);\n extern void compute_data_dependences_for_loop (unsigned, struct loop *, \n \t\t\t\t\t       varray_type *, varray_type *);\n extern struct data_reference * init_data_ref (tree, tree, tree, tree, bool);\n extern struct data_reference *analyze_array (tree, tree, bool);\n \n+extern void dump_subscript (FILE *, struct subscript *);\n+extern void dump_ddrs (FILE *, varray_type);\n+extern void dump_dist_dir_vectors (FILE *, varray_type);\n extern void dump_data_reference (FILE *, struct data_reference *);\n extern void dump_data_references (FILE *, varray_type);\n extern void dump_data_dependence_relation (FILE *, \n@@ -161,11 +172,12 @@ extern void dump_data_dependence_relations (FILE *, varray_type);\n extern void dump_data_dependence_direction (FILE *, \n \t\t\t\t\t    enum data_dependence_direction);\n extern bool array_base_name_differ_p (struct data_reference *, \n-\t\t\t\t      struct data_reference *, bool *p);\n+\t\t\t\t      struct data_reference *, bool *);\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (varray_type);\n extern void free_data_refs (varray_type);\n \n+\n \f\n \n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "0e2b8706776d2c366699dac8a47866c9b9acd3f1", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86df10e35e37a9bc0a50e43503e9347719cc50e7/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=86df10e35e37a9bc0a50e43503e9347719cc50e7", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"tree-data-ref.h\"\n #include \"params.h\"\n #include \"flags.h\"\n #include \"tree-inline.h\"\n@@ -943,24 +944,10 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \n */\n \n-/* The structure describing a bound on number of iterations of a loop.  */\n-\n-struct nb_iter_bound\n-{\n-  tree bound;\t\t/* The expression whose value is an upper bound on the\n-\t\t\t   number of executions of anything after ...  */\n-  tree at_stmt;\t\t/* ... this statement during one execution of loop.  */\n-  tree additional;\t/* A conjunction of conditions the operands of BOUND\n-\t\t\t   satisfy.  The additional information about the value\n-\t\t\t   of the bound may be derived from it.  */\n-  struct nb_iter_bound *next;\n-\t\t\t/* The next bound in a list.  */\n-};\n-\n /* Records that AT_STMT is executed at most BOUND times in LOOP.  The\n    additional condition ADDITIONAL is recorded with the bound.  */\n \n-static void\n+void\n record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n {\n   struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n@@ -1010,8 +997,14 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n     }\n   free (exits);\n   \n-  /* TODO Here we could use other possibilities, like bounds of arrays accessed\n-     in the loop.  */\n+  /* Analyzes the bounds of arrays accessed in the loop.  */\n+  if (loop->estimated_nb_iterations == NULL_TREE)\n+    {\n+      varray_type datarefs;\n+      VARRAY_GENERIC_PTR_INIT (datarefs, 3, \"datarefs\");\n+      find_data_references_in_loop (loop, &datarefs);\n+      free_data_refs (datarefs);\n+    }\n }\n \n /* Records estimates on numbers of iterations of LOOPS.  */"}]}