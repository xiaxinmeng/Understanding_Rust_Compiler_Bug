{"sha": "d674b9e395cf36d357c07a2edfe2b239668f3006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY3NGI5ZTM5NWNmMzZkMzU3YzA3YTJlZGZlMmIyMzk2NjhmMzAwNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-10T12:41:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-10T12:41:54Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r426", "tree": {"sha": "7fdb16c887f825cd8b11a93126831d62f9b8e825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fdb16c887f825cd8b11a93126831d62f9b8e825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d674b9e395cf36d357c07a2edfe2b239668f3006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d674b9e395cf36d357c07a2edfe2b239668f3006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d674b9e395cf36d357c07a2edfe2b239668f3006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d674b9e395cf36d357c07a2edfe2b239668f3006/comments", "author": null, "committer": null, "parents": [{"sha": "db5dc21f767db6d18eed651aec203ae1f30c4f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5dc21f767db6d18eed651aec203ae1f30c4f44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5dc21f767db6d18eed651aec203ae1f30c4f44"}], "stats": {"total": 16, "additions": 12, "deletions": 4}, "files": [{"sha": "c9f3346fe89e5d272a949143af454a14b6baa79c", "filename": "gcc/reorg.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d674b9e395cf36d357c07a2edfe2b239668f3006/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d674b9e395cf36d357c07a2edfe2b239668f3006/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=d674b9e395cf36d357c07a2edfe2b239668f3006", "patch": "@@ -2674,7 +2674,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n      int own_thread, own_opposite_thread;\n      int slots_to_fill, *pslots_filled;\n {\n-  rtx new_thread = thread;\n+  rtx new_thread;\n   rtx delay_list = 0;\n   struct resources opposite_needed, set, needed;\n   rtx trial;\n@@ -2698,6 +2698,12 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n   else\n     mark_target_live_regs (opposite_thread, &opposite_needed);\n \n+  /* If the insn at THREAD can be split, do it here to avoid having to\n+     update THREAD and NEW_THREAD if it is done in the loop below.  Also\n+     initialize NEW_THREAD.  */\n+\n+  new_thread = thread = try_split (PATTERN (thread), thread);\n+\n   /* Scan insns at THREAD.  We are looking for an insn that can be removed\n      from THREAD (it neither sets nor references resources that were set\n      ahead of it and it doesn't set anything needs by the insns ahead of\n@@ -2895,7 +2901,8 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n   /* If we haven't found anything for this delay slot and it is very\n      likely that the branch will be taken, see if the insn at our target\n-     increments or decrements a register.  If so, try to place the opposite\n+     increments or decrements a register with an increment that does not\n+     depend on the destination register.  If so, try to place the opposite\n      arithmetic insn after the jump insn and put the arithmetic insn in the\n      delay slot.  If we can't do this, return.  */\n   if (delay_list == 0 && likely && new_thread && GET_CODE (new_thread) == INSN)\n@@ -2904,7 +2911,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n       rtx dest;\n       rtx src;\n \n-      trial = try_split (pat, new_thread, 0);\n+      trial = new_thread;\n       pat = PATTERN (trial);\n \n       if (GET_CODE (trial) != INSN || GET_CODE (pat) != SET\n@@ -2913,7 +2920,8 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n       dest = SET_DEST (pat), src = SET_SRC (pat);\n       if ((GET_CODE (src) == PLUS || GET_CODE (src) == MINUS)\n-\t  && rtx_equal_p (XEXP (src, 0), dest))\n+\t  && rtx_equal_p (XEXP (src, 0), dest)\n+\t  && ! reg_overlap_mentioned_p (dest, XEXP (src, 1)))\n \t{\n \t  rtx other = XEXP (src, 1);\n \t  rtx new_arith;"}]}