{"sha": "70aa0e6eef9d65744f37adc2a3cffef1a8217dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBhYTBlNmVlZjlkNjU3NDRmMzdhZGMyYTNjZmZlZjFhODIxN2RjMQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-24T17:24:43Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-24T17:24:43Z"}, "message": "libstdc++: Robustify long double std::to_chars testcase [PR98384]\n\nThe long double std::to_chars testcase currently verifies the\ncorrectness of its output by comparing it to that of printf, so if\nthere's a mismatch between to_chars and printf, the test FAILs.  This\nworks well for the scientific, fixed and general formatting modes,\nbecause the corresponding printf conversion specifiers (%e, %f and %g)\nare rigidly specified.\n\nBut this doesn't work well for the hex formatting mode because the\ncorresponding printf conversion specifier %a is more flexibly specified.\nFor instance, the hexadecimal forms 0x1p+0, 0x2p-1, 0x4p-2 and 0x8p-3\nare all equivalent and valid outputs of the %a specifier for the number 1.\nThe apparent freedom here is the choice of leading hex digit -- the\nstandard just requires that the leading hex digit is nonzero for\nnormalized numbers.\n\nCurrently, our hexadecimal formatting implementation uses 0/1/2 as the\nleading hex digit for floating point types that have an implicit leading\nmantissa bit which in practice means all supported floating point types\nexcept x86 long double.  The latter type has a 64 bit mantissa with an\nexplicit leading mantissa bit, and for this type our implementation uses\nthe most significant four bits of the mantissa as leading hex digit.\nThis seems to be consistent with most printf implementations, but not\nall, as PR98384 illustrates.\n\nIn order to avoid false-positive FAILs due to arbitrary disagreement\nbetween to_chars and printf about the choice of leading hex digit, this\npatch makes the testcase's verification via printf conditional on the\nleading hex digits first agreeing.  An additional verification step is\nalso added: round-tripping the output of to_chars through from_chars\nshould recover the value exactly.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/98384\n\t* testsuite/20_util/to_chars/long_double.cc: Include <optional>.\n\t(test01): Simplify verifying the nearby values by using a\n\t2-iteration loop and a dedicated output buffer to check that the\n\tnearby values are different.  Factor out the printf-based\n\tverification into a local function, and check that the leading\n\thex digits agree before comparing to the output of printf.  Also\n\tverify the output by round-tripping it through from_chars.", "tree": {"sha": "c6d7cbeed76a64b54e491aa19d8799822a604f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6d7cbeed76a64b54e491aa19d8799822a604f32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1/comments", "author": null, "committer": null, "parents": [{"sha": "a13be187cb2987db851b3f096f5319d5fe3a7301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a13be187cb2987db851b3f096f5319d5fe3a7301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a13be187cb2987db851b3f096f5319d5fe3a7301"}], "stats": {"total": 73, "additions": 47, "deletions": 26}, "files": [{"sha": "da847ae5401433335b570385ef3d3af5fdef28ed", "filename": "libstdc++-v3/testsuite/20_util/to_chars/long_double.cc", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70aa0e6eef9d65744f37adc2a3cffef1a8217dc1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc?ref=70aa0e6eef9d65744f37adc2a3cffef1a8217dc1", "patch": "@@ -26,6 +26,7 @@\n #include <cmath>\n #include <cstring>\n #include <iterator>\n+#include <optional>\n #include <limits>\n \n #include <testsuite_hooks.h>\n@@ -50,6 +51,38 @@ namespace detail\n void\n test01()\n {\n+  // Verifies correctness of the hexadecimal form [BEGIN,END) for VALUE by\n+  // round-tripping it through from_chars (if available).\n+  auto verify_via_from_chars = [] (char *begin, char *end, long double value) {\n+#if __cpp_lib_to_chars >= 201611L || _GLIBCXX_HAVE_USELOCALE\n+    long double roundtrip;\n+    auto result = from_chars(begin, end, roundtrip, chars_format::hex);\n+    VERIFY( result.ec == errc{} );\n+    VERIFY( result.ptr == end );\n+    VERIFY( roundtrip == value );\n+#endif\n+  };\n+\n+  // Verifies correctness of the null-terminated hexadecimal form at BEGIN\n+  // for VALUE and PRECISION by comparing it with the output of printf's %La\n+  // conversion specifier.\n+  auto verify_via_printf = [] (char *begin, long double value,\n+\t\t\t       optional<int> precision = nullopt) {\n+    char printf_buffer[1024] = {};\n+    if (precision.has_value())\n+      sprintf(printf_buffer, \"%.*La\", precision.value(), value);\n+    else\n+      sprintf(printf_buffer, \"%La\", value);\n+\n+    // Only compare with the output of printf if the leading hex digits agree.\n+    // If the leading hex digit of our form doesn't agree with that of printf,\n+    // then the two forms may still be equivalent (e.g. 1.1p+0 vs 8.8p-3).  But\n+    // if the leading hex digits do agree, then we do expect the two forms to be\n+    // the same.\n+    if (printf_buffer[strlen(\"0x\")] == begin[0])\n+      VERIFY( !strcmp(begin, printf_buffer+strlen(\"0x\")) );\n+  };\n+\n   const long double hex_testcases[]\n     = { detail::nextdownl(numeric_limits<long double>::max()),\n \tdetail::nextupl(numeric_limits<long double>::min()),\n@@ -92,38 +125,27 @@ test01()\n \tif (testcase == 0.0L || isinf(testcase))\n \t  continue;\n \n-\tchar to_chars_buffer[1024], printf_buffer[1024];\n-\tmemset(to_chars_buffer, '\\0', sizeof(to_chars_buffer));\n-\tmemset(printf_buffer, '\\0', sizeof(printf_buffer));\n-\n+\tchar to_chars_buffer[1024] = {};\n \tauto result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n \t\t\t       testcase, chars_format::hex);\n \tVERIFY( result.ec == errc{} );\n \t*result.ptr = '\\0';\n-\tsprintf(printf_buffer, \"%La\", testcase);\n-\tVERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\tverify_via_from_chars(begin(to_chars_buffer), result.ptr, testcase);\n+\tverify_via_printf(to_chars_buffer, testcase);\n \n+\t// Verify the nearby values, and also check they have a different\n+\t// shortest form.\n+\tfor (long double nearby\n+\t     : { detail::nextdownl(testcase), detail::nextupl(testcase) })\n \t  {\n-\t    // Verify that the nearby values have a different shortest form.\n-\t    testcase = detail::nextdownl(testcase);\n-\t    result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n-\t\t\t      testcase, chars_format::hex);\n-\t    VERIFY( result.ec == errc{} );\n-\t    *result.ptr = '\\0';\n-\t    VERIFY( strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) != 0);\n-\t    sprintf(printf_buffer, \"%La\", testcase);\n-\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n-\n-\t    testcase = detail::nextupl(detail::nextupl(testcase));\n-\t    result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n-\t\t\t      testcase, chars_format::hex);\n+\t    char nearby_buffer[1024] = {};\n+\t    result = to_chars(begin(nearby_buffer), end(nearby_buffer),\n+\t\t\t      nearby, chars_format::hex);\n \t    VERIFY( result.ec == errc{} );\n \t    *result.ptr = '\\0';\n-\t    VERIFY( strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) != 0);\n-\t    sprintf(printf_buffer, \"%La\", testcase);\n-\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n-\n-\t    testcase = detail::nextdownl(testcase);\n+\t    VERIFY( strcmp(nearby_buffer, to_chars_buffer) != 0);\n+\t    verify_via_from_chars(begin(nearby_buffer), result.ptr, nearby);\n+\t    verify_via_printf(nearby_buffer, nearby);\n \t  }\n \n \tfor (int precision = -1; precision < 50; precision++)\n@@ -132,8 +154,7 @@ test01()\n \t\t\t      testcase, chars_format::hex, precision);\n \t    VERIFY( result.ec == errc{} );\n \t    *result.ptr = '\\0';\n-\t    sprintf(printf_buffer, \"%.*La\", precision, testcase);\n-\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\t    verify_via_printf(to_chars_buffer, testcase, precision);\n \t  }\n       }\n }"}]}