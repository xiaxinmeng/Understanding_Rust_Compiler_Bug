{"sha": "b679b55b5eb8ea463af3459092c19ba05cde664b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3OWI1NWI1ZWI4ZWE0NjNhZjM0NTkwOTJjMTliYTA1Y2RlNjY0Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-18T16:14:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-18T16:14:10Z"}, "message": "Makefile.in: Add ipa-predicate.o and ipa-predicate.h\n\n\t* Makefile.in: Add ipa-predicate.o and ipa-predicate.h\n\t* ipa-inline-analysis.c (NUM_CONDITIONS): turn into\n\tpredicate::num_conditions\n\t(IS_NOT_CONSTANT): turn into predicate::is_not_constant.\n\t(CHANGED): turn into predicate::changed.\n\t(agg_position_info): Move to ipa-predicate.h\n\t(add_condition, predicate::add_clause, predicate::operator &=,\n\tpredicate::or_with, predicate::evaluate, predicate::probability,\n\tdump_condition, dump_clause, predicate::dump,\n\tpredicate::remap_after_duplication, predicate::remap_after_inlining,\n\tpredicate::stream_in, predicate::stream_out): Move to ipa-predicate.c\n\t(evaluate_conditions_for_known_args): Update.\n\t(set_cond_stmt_execution_predicate): Update.\n\t* ipa-inline.h: Include ipa-predicate.h\n\t(condition, inline_param_summary, conditions, agg_position_info,\n\tpredicate): Move to ipa-predicate.h\n\t* ipa-predicate.c: New file.\n\t* ipa-predicate.h: New file.\n\nFrom-SVN: r248241", "tree": {"sha": "e3393d1db3f70a23661e59bd26269ba67b9d40e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3393d1db3f70a23661e59bd26269ba67b9d40e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b679b55b5eb8ea463af3459092c19ba05cde664b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b679b55b5eb8ea463af3459092c19ba05cde664b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b679b55b5eb8ea463af3459092c19ba05cde664b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b679b55b5eb8ea463af3459092c19ba05cde664b/comments", "author": null, "committer": null, "parents": [{"sha": "00d600138536a4978f40b25233c2f37c0fc426d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d600138536a4978f40b25233c2f37c0fc426d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d600138536a4978f40b25233c2f37c0fc426d4"}], "stats": {"total": 1573, "additions": 828, "deletions": 745}, "files": [{"sha": "8ace3c262394d7c7642ae5ff7e79a2c4cded683a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b679b55b5eb8ea463af3459092c19ba05cde664b", "patch": "@@ -1347,6 +1347,7 @@ OBJS = \\\n \tipa-visibility.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\\n+\tipa-predicate.o \\\n \tipa-profile.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n@@ -2505,6 +2506,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/trans-mem.c \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n+  $(srcdir)/ipa-predicate.h \\\n   $(srcdir)/ipa-inline.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\"}, {"sha": "15af015792ce0445a32a7961e422929a0b82a2eb", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 11, "deletions": 559, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b679b55b5eb8ea463af3459092c19ba05cde664b", "patch": "@@ -86,19 +86,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgexpand.h\"\n #include \"gimplify.h\"\n \n-/* Number of bits in integer, but we really want to be stable across different\n-   hosts.  */\n-#define NUM_CONDITIONS 32\n-\n-/* Special condition code we use to represent test that operand is compile time\n-   constant.  */\n-#define IS_NOT_CONSTANT ERROR_MARK\n-/* Special condition code we use to represent test that operand is not changed\n-   across invocation of the function.  When operand IS_NOT_CONSTANT it is always\n-   CHANGED, however i.e. loop invariants can be NOT_CHANGED given percentage\n-   of executions even when they are not compile time constants.  */\n-#define CHANGED IDENTIFIER_NODE\n-\n /* Holders of ipa cgraph hooks: */\n static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n@@ -117,396 +104,6 @@ vec<edge_growth_cache_entry> edge_growth_cache;\n /* Edge predicates goes here.  */\n static object_allocator<predicate> edge_predicate_pool (\"edge predicates\");\n \n-/* Simple description of whether a memory load or a condition refers to a load\n-   from an aggregate and if so, how and where from in the aggregate.\n-   Individual fields have the same meaning like fields with the same name in\n-   struct condition.  */\n-\n-struct agg_position_info\n-{\n-  HOST_WIDE_INT offset;\n-  bool agg_contents;\n-  bool by_ref;\n-};\n-\n-/* Add condition to condition list SUMMARY. OPERAND_NUM, SIZE, CODE and VAL\n-   correspond to fields of condition structure.  AGGPOS describes whether the\n-   used operand is loaded from an aggregate and where in the aggregate it is.\n-   It can be NULL, which means this not a load from an aggregate.  */\n-\n-static predicate\n-add_condition (struct inline_summary *summary, int operand_num,\n-\t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n-\t       enum tree_code code, tree val)\n-{\n-  int i;\n-  struct condition *c;\n-  struct condition new_cond;\n-  HOST_WIDE_INT offset;\n-  bool agg_contents, by_ref;\n-\n-  if (aggpos)\n-    {\n-      offset = aggpos->offset;\n-      agg_contents = aggpos->agg_contents;\n-      by_ref = aggpos->by_ref;\n-    }\n-  else\n-    {\n-      offset = 0;\n-      agg_contents = false;\n-      by_ref = false;\n-    }\n-\n-  gcc_checking_assert (operand_num >= 0);\n-  for (i = 0; vec_safe_iterate (summary->conds, i, &c); i++)\n-    {\n-      if (c->operand_num == operand_num\n-\t  && c->size == size\n-\t  && c->code == code\n-\t  && c->val == val\n-\t  && c->agg_contents == agg_contents\n-\t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n-\treturn predicate::predicate_testing_cond (i);\n-    }\n-  /* Too many conditions.  Give up and return constant true.  */\n-  if (i == NUM_CONDITIONS - predicate::first_dynamic_condition)\n-    return true;\n-\n-  new_cond.operand_num = operand_num;\n-  new_cond.code = code;\n-  new_cond.val = val;\n-  new_cond.agg_contents = agg_contents;\n-  new_cond.by_ref = by_ref;\n-  new_cond.offset = offset;\n-  new_cond.size = size;\n-  vec_safe_push (summary->conds, new_cond);\n-\n-  return predicate::predicate_testing_cond (i);\n-}\n-\n-\n-/* Add clause CLAUSE into the predicate P.\n-   When CONDITIONS is NULL do not perform checking whether NEW_CLAUSE\n-   is obviously true.  This is useful only when NEW_CLAUSE is known to be\n-   sane.  */\n-\n-void\n-predicate::add_clause (conditions conditions, clause_t new_clause)\n-{\n-  int i;\n-  int i2;\n-  int insert_here = -1;\n-  int c1, c2;\n-\n-  /* True clause.  */\n-  if (!new_clause)\n-    return;\n-\n-  /* False clause makes the whole predicate false.  Kill the other variants.  */\n-  if (new_clause == (1 << predicate::false_condition))\n-    {\n-      *this = false;\n-      return;\n-    }\n-  if (*this == false)\n-    return;\n-\n-  /* No one should be silly enough to add false into nontrivial clauses.  */\n-  gcc_checking_assert (!(new_clause & (1 << predicate::false_condition)));\n-\n-  /* Look where to insert the new_clause.  At the same time prune out\n-     new_clauses of P that are implied by the new new_clause and thus\n-     redundant.  */\n-  for (i = 0, i2 = 0; i <= max_clauses; i++)\n-    {\n-      m_clause[i2] = m_clause[i];\n-\n-      if (!m_clause[i])\n-\tbreak;\n-\n-      /* If m_clause[i] implies new_clause, there is nothing to add.  */\n-      if ((m_clause[i] & new_clause) == m_clause[i])\n-\t{\n-\t  /* We had nothing to add, none of clauses should've become\n-\t     redundant.  */\n-\t  gcc_checking_assert (i == i2);\n-\t  return;\n-\t}\n-\n-      if (m_clause[i] < new_clause && insert_here < 0)\n-\tinsert_here = i2;\n-\n-      /* If new_clause implies clause[i], then clause[i] becomes redundant.\n-         Otherwise the clause[i] has to stay.  */\n-      if ((m_clause[i] & new_clause) != new_clause)\n-\ti2++;\n-    }\n-\n-  /* Look for clauses that are obviously true.  I.e.\n-     op0 == 5 || op0 != 5.  */\n-  if (conditions)\n-    for (c1 = predicate::first_dynamic_condition; c1 < NUM_CONDITIONS; c1++)\n-      {\n-\tcondition *cc1;\n-\tif (!(new_clause & (1 << c1)))\n-\t  continue;\n-\tcc1 = &(*conditions)[c1 - predicate::first_dynamic_condition];\n-\t/* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n-\t   and thus there is no point for looking for them.  */\n-\tif (cc1->code == CHANGED || cc1->code == IS_NOT_CONSTANT)\n-\t  continue;\n-\tfor (c2 = c1 + 1; c2 < NUM_CONDITIONS; c2++)\n-\t  if (new_clause & (1 << c2))\n-\t    {\n-\t      condition *cc1 =\n-\t\t&(*conditions)[c1 - predicate::first_dynamic_condition];\n-\t      condition *cc2 =\n-\t\t&(*conditions)[c2 - predicate::first_dynamic_condition];\n-\t      if (cc1->operand_num == cc2->operand_num\n-\t\t  && cc1->val == cc2->val\n-\t\t  && cc2->code != IS_NOT_CONSTANT\n-\t\t  && cc2->code != CHANGED\n-\t\t  && cc1->code == invert_tree_comparison (cc2->code,\n-\t\t\t\t\t\t\t  HONOR_NANS (cc1->val)))\n-\t\treturn;\n-\t    }\n-      }\n-\n-\n-  /* We run out of variants.  Be conservative in positive direction.  */\n-  if (i2 == max_clauses)\n-    return;\n-  /* Keep clauses in decreasing order. This makes equivalence testing easy.  */\n-  m_clause[i2 + 1] = 0;\n-  if (insert_here >= 0)\n-    for (; i2 > insert_here; i2--)\n-      m_clause[i2] = m_clause[i2 - 1];\n-  else\n-    insert_here = i2;\n-  m_clause[insert_here] = new_clause;\n-}\n-\n-\n-/* Do THIS &= P.  */\n-\n-predicate &\n-predicate::operator &= (const predicate &p)\n-{\n-  /* Avoid busy work.  */\n-  if (p == false || *this == true)\n-    {\n-      *this = p;\n-      return *this;\n-    }\n-  if (*this == false || p == true || this == &p)\n-    return *this;\n-\n-  int i;\n-\n-  /* See how far predicates match.  */\n-  for (i = 0; m_clause[i] && m_clause[i] == p.m_clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < max_clauses);\n-    }\n-\n-  /* Combine the predicates rest.  */\n-  for (; p.m_clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < max_clauses);\n-      add_clause (NULL, p.m_clause[i]);\n-    }\n-  return *this;\n-}\n-\n-\n-\n-/* Return THIS | P2.  */\n-\n-predicate\n-predicate::or_with (conditions conditions,\n-\t            const predicate &p) const\n-{\n-  /* Avoid busy work.  */\n-  if (p == false || *this == true || *this == p)\n-    return *this;\n-  if (*this == false || p == true)\n-    return p;\n-\n-  /* OK, combine the predicates.  */\n-  predicate out = true;\n-\n-  for (int i = 0; m_clause[i]; i++)\n-    for (int j = 0; p.m_clause[j]; j++)\n-      {\n-\tgcc_checking_assert (i < max_clauses && j < max_clauses);\n-\tout.add_clause (conditions, m_clause[i] | p.m_clause[j]);\n-      }\n-  return out;\n-}\n-\n-\n-/* Having partial truth assignment in POSSIBLE_TRUTHS, return false\n-   if predicate P is known to be false.  */\n-\n-bool\n-predicate::evaluate (clause_t possible_truths) const\n-{\n-  int i;\n-\n-  /* True remains true.  */\n-  if (*this == true)\n-    return true;\n-\n-  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n-\n-  /* See if we can find clause we can disprove.  */\n-  for (i = 0; m_clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < max_clauses);\n-      if (!(m_clause[i] & possible_truths))\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Return the probability in range 0...REG_BR_PROB_BASE that the predicated\n-   instruction will be recomputed per invocation of the inlined call.  */\n-\n-int\n-predicate::probability (conditions conds,\n-\t                clause_t possible_truths,\n-\t                vec<inline_param_summary> inline_param_summary) const\n-{\n-  int i;\n-  int combined_prob = REG_BR_PROB_BASE;\n-\n-  /* True remains true.  */\n-  if (*this == true)\n-    return REG_BR_PROB_BASE;\n-\n-  if (*this == false)\n-    return 0;\n-\n-  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n-\n-  /* See if we can find clause we can disprove.  */\n-  for (i = 0; m_clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < max_clauses);\n-      if (!(m_clause[i] & possible_truths))\n-\treturn 0;\n-      else\n-\t{\n-\t  int this_prob = 0;\n-\t  int i2;\n-\t  if (!inline_param_summary.exists ())\n-\t    return REG_BR_PROB_BASE;\n-\t  for (i2 = 0; i2 < NUM_CONDITIONS; i2++)\n-\t    if ((m_clause[i] & possible_truths) & (1 << i2))\n-\t      {\n-\t\tif (i2 >= predicate::first_dynamic_condition)\n-\t\t  {\n-\t\t    condition *c =\n-\t\t      &(*conds)[i2 - predicate::first_dynamic_condition];\n-\t\t    if (c->code == CHANGED\n-\t\t\t&& (c->operand_num <\n-\t\t\t    (int) inline_param_summary.length ()))\n-\t\t      {\n-\t\t\tint iprob =\n-\t\t\t  inline_param_summary[c->operand_num].change_prob;\n-\t\t\tthis_prob = MAX (this_prob, iprob);\n-\t\t      }\n-\t\t    else\n-\t\t      this_prob = REG_BR_PROB_BASE;\n-\t\t  }\n-\t\telse\n-\t\t  this_prob = REG_BR_PROB_BASE;\n-\t      }\n-\t  combined_prob = MIN (this_prob, combined_prob);\n-\t  if (!combined_prob)\n-\t    return 0;\n-\t}\n-    }\n-  return combined_prob;\n-}\n-\n-\n-/* Dump conditional COND.  */\n-\n-static void\n-dump_condition (FILE *f, conditions conditions, int cond)\n-{\n-  condition *c;\n-  if (cond == predicate::false_condition)\n-    fprintf (f, \"false\");\n-  else if (cond == predicate::not_inlined_condition)\n-    fprintf (f, \"not inlined\");\n-  else\n-    {\n-      c = &(*conditions)[cond - predicate::first_dynamic_condition];\n-      fprintf (f, \"op%i\", c->operand_num);\n-      if (c->agg_contents)\n-\tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t\t c->by_ref ? \"ref \" : \"\", c->offset);\n-      if (c->code == IS_NOT_CONSTANT)\n-\t{\n-\t  fprintf (f, \" not constant\");\n-\t  return;\n-\t}\n-      if (c->code == CHANGED)\n-\t{\n-\t  fprintf (f, \" changed\");\n-\t  return;\n-\t}\n-      fprintf (f, \" %s \", op_symbol_code (c->code));\n-      print_generic_expr (f, c->val);\n-    }\n-}\n-\n-\n-/* Dump clause CLAUSE.  */\n-\n-static void\n-dump_clause (FILE *f, conditions conds, clause_t clause)\n-{\n-  int i;\n-  bool found = false;\n-  fprintf (f, \"(\");\n-  if (!clause)\n-    fprintf (f, \"true\");\n-  for (i = 0; i < NUM_CONDITIONS; i++)\n-    if (clause & (1 << i))\n-      {\n-\tif (found)\n-\t  fprintf (f, \" || \");\n-\tfound = true;\n-\tdump_condition (f, conds, i);\n-      }\n-  fprintf (f, \")\");\n-}\n-\n-\n-/* Dump THIS to F. CONDS a vector of conditions used when evauating\n-   predicats. When NL is true new line is output at the end of dump.  */\n-\n-void\n-predicate::dump (FILE *f, conditions conds, bool nl) const\n-{\n-  int i;\n-  if (*this == true)\n-    dump_clause (f, conds, 0);\n-  else\n-    for (i = 0; m_clause[i]; i++)\n-      {\n-\tif (i)\n-\t  fprintf (f, \" && \");\n-\tdump_clause (f, conds, m_clause[i]);\n-      }\n-  if (nl)\n-    fprintf (f, \"\\n\");\n-}\n-\n \n /* Dump inline hints.  */\n void\n@@ -770,7 +367,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t{\n \t  struct ipa_agg_jump_function *agg;\n \n-\t  if (c->code == CHANGED\n+\t  if (c->code == predicate::changed\n \t      && !c->by_ref\n \t      && (known_vals[c->operand_num] == error_mark_node))\n \t    continue;\n@@ -787,7 +384,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       else\n \t{\n \t  val = known_vals[c->operand_num];\n-\t  if (val == error_mark_node && c->code != CHANGED)\n+\t  if (val == error_mark_node && c->code != predicate::changed)\n \t    val = NULL_TREE;\n \t}\n \n@@ -797,7 +394,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n-      if (c->code == CHANGED)\n+      if (c->code == predicate::changed)\n \t{\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n@@ -809,7 +406,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n-      if (c->code == IS_NOT_CONSTANT)\n+      if (c->code == predicate::is_not_constant)\n \t{\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n@@ -1025,23 +622,6 @@ inline_summary_t::remove (cgraph_node *node, inline_summary *info)\n   reset_inline_summary (node, info);\n }\n \n-/* Remap predicate THIS of former function to be predicate of duplicated function.\n-   POSSIBLE_TRUTHS is clause of possible truths in the duplicated node,\n-   INFO is inline summary of the duplicated node.  */\n-\n-predicate\n-predicate::remap_after_duplication (clause_t possible_truths)\n-{\n-  int j;\n-  predicate out = true;\n-  for (j = 0; m_clause[j]; j++)\n-    if (!(possible_truths & m_clause[j]))\n-      return false;\n-    else\n-      out.add_clause (NULL, possible_truths & m_clause[j]);\n-  return out;\n-}\n-\n /* Same as remap_predicate_after_duplication but handle hint predicate *P.\n    Additionally care about allocating new memory slot for updated predicate\n    and set it to NULL when it becomes true or false (and thus uninteresting).\n@@ -1778,7 +1358,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n       predicate p = add_condition (summary, index, size, &aggpos,\n-\t\t\t\t\t  IS_NOT_CONSTANT, NULL_TREE);\n+\t\t\t\t   predicate::is_not_constant, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n       *(predicate *) e->aux = p;\n     }\n@@ -1945,7 +1525,8 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n \n   parm = unmodified_parm (NULL, expr, &size);\n   if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n-    return add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);\n+    return add_condition (summary, index, size, NULL, predicate::changed,\n+\t\t\t  NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false;\n   if (TREE_CODE (expr) == SSA_NAME)\n@@ -2058,7 +1639,8 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \n   if (is_load)\n     op_non_const =\n-      add_condition (summary, base_index, size, &aggpos, CHANGED, NULL);\n+      add_condition (summary, base_index, size, &aggpos, predicate::changed,\n+\t\t     NULL);\n   else\n     op_non_const = false;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n@@ -2070,7 +1652,8 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n-\t    p = add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);\n+\t    p = add_condition (summary, index, size, NULL, predicate::changed,\n+\t\t\t       NULL_TREE);\n \t  else\n \t    continue;\n \t}\n@@ -3357,101 +2940,6 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t       ret_nonspec_time, hints, vNULL);\n }\n \n-/* Translate all conditions from callee representation into caller\n-   representation and symbolically evaluate predicate THIS into new predicate.\n-\n-   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO\n-   is summary of function predicate P is from. OPERAND_MAP is array giving\n-   callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clausule of all\n-   callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n-   predicate under which callee is executed.  OFFSET_MAP is an array of of\n-   offsets that need to be added to conditions, negative offset means that\n-   conditions relying on values passed by reference have to be discarded\n-   because they might not be preserved (and should be considered offset zero\n-   for other purposes).  */\n-\n-predicate\n-predicate::remap_after_inlining (struct inline_summary *info,\n-\t\t\t\t struct inline_summary *callee_info,\n-\t\t\t\t vec<int> operand_map,\n-\t\t\t\t vec<int> offset_map,\n-\t\t\t\t clause_t possible_truths,\n-\t\t\t\t const predicate &toplev_predicate)\n-{\n-  int i;\n-  predicate out = true;\n-\n-  /* True predicate is easy.  */\n-  if (*this == true)\n-    return toplev_predicate;\n-  for (i = 0; m_clause[i]; i++)\n-    {\n-      clause_t clause = m_clause[i];\n-      int cond;\n-      predicate clause_predicate = false;\n-\n-      gcc_assert (i < max_clauses);\n-\n-      for (cond = 0; cond < NUM_CONDITIONS; cond++)\n-\t/* Do we have condition we can't disprove?   */\n-\tif (clause & possible_truths & (1 << cond))\n-\t  {\n-\t    predicate cond_predicate;\n-\t    /* Work out if the condition can translate to predicate in the\n-\t       inlined function.  */\n-\t    if (cond >= predicate::first_dynamic_condition)\n-\t      {\n-\t\tstruct condition *c;\n-\n-\t\tc = &(*callee_info->conds)[cond\n-\t\t\t\t\t   -\n-\t\t\t\t\t   predicate::first_dynamic_condition];\n-\t\t/* See if we can remap condition operand to caller's operand.\n-\t\t   Otherwise give up.  */\n-\t\tif (!operand_map.exists ()\n-\t\t    || (int) operand_map.length () <= c->operand_num\n-\t\t    || operand_map[c->operand_num] == -1\n-\t\t    /* TODO: For non-aggregate conditions, adding an offset is\n-\t\t       basically an arithmetic jump function processing which\n-\t\t       we should support in future.  */\n-\t\t    || ((!c->agg_contents || !c->by_ref)\n-\t\t\t&& offset_map[c->operand_num] > 0)\n-\t\t    || (c->agg_contents && c->by_ref\n-\t\t\t&& offset_map[c->operand_num] < 0))\n-\t\t  cond_predicate = true;\n-\t\telse\n-\t\t  {\n-\t\t    struct agg_position_info ap;\n-\t\t    HOST_WIDE_INT offset_delta = offset_map[c->operand_num];\n-\t\t    if (offset_delta < 0)\n-\t\t      {\n-\t\t\tgcc_checking_assert (!c->agg_contents || !c->by_ref);\n-\t\t\toffset_delta = 0;\n-\t\t      }\n-\t\t    gcc_assert (!c->agg_contents\n-\t\t\t\t|| c->by_ref || offset_delta == 0);\n-\t\t    ap.offset = c->offset + offset_delta;\n-\t\t    ap.agg_contents = c->agg_contents;\n-\t\t    ap.by_ref = c->by_ref;\n-\t\t    cond_predicate = add_condition (info,\n-\t\t\t\t\t\t    operand_map[c->operand_num],\n-\t\t\t\t\t\t    c->size, &ap, c->code,\n-\t\t\t\t\t\t    c->val);\n-\t\t  }\n-\t      }\n-\t    /* Fixed conditions remains same, construct single\n-\t       condition predicate.  */\n-\t    else\n-\t      cond_predicate = predicate::predicate_testing_cond (cond);\n-\t    clause_predicate = clause_predicate.or_with (info->conds,\n-\t\t\t\t\t                 cond_predicate);\n-\t  }\n-      out &= clause_predicate;\n-    }\n-  out &= toplev_predicate;\n-  return out;\n-}\n-\n \n /* Update summary information of inline clones after inlining.\n    Compute peak stack usage.  */\n@@ -4175,27 +3663,6 @@ inline_generate_summary (void)\n }\n \n \n-/* Read predicate from IB.  */\n-\n-void\n-predicate::stream_in (struct lto_input_block *ib)\n-{\n-  clause_t clause;\n-  int k = 0;\n-\n-  do\n-    {\n-      gcc_assert (k <= max_clauses);\n-      clause = m_clause[k++] = streamer_read_uhwi (ib);\n-    }\n-  while (clause);\n-\n-  /* Zero-initialize the remaining clauses in OUT.  */\n-  while (k <= max_clauses)\n-    m_clause[k++] = 0;\n-}\n-\n-\n /* Write inline summary for edge E to OB.  */\n \n static void\n@@ -4356,21 +3823,6 @@ inline_read_summary (void)\n }\n \n \n-/* Write predicate P to OB.  */\n-\n-void\n-predicate::stream_out (struct output_block *ob)\n-{\n-  int j;\n-  for (j = 0; m_clause[j]; j++)\n-    {\n-      gcc_assert (j < max_clauses);\n-      streamer_write_uhwi (ob, m_clause[j]);\n-    }\n-  streamer_write_uhwi (ob, 0);\n-}\n-\n-\n /* Write inline summary for edge E to OB.  */\n \n static void"}, {"sha": "f7dd312e449ebe2e2198e0401df39e679a5ca350", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 10, "deletions": 186, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=b679b55b5eb8ea463af3459092c19ba05cde664b", "patch": "@@ -22,33 +22,9 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_IPA_INLINE_H\n \n #include \"sreal.h\"\n+#include \"ipa-predicate.h\"\n \n \n-/* Representation of inline parameters that do depend on context function is\n-   inlined into (i.e. known constant values of function parameters.\n-\n-   Conditions that are interesting for function body are collected into CONDS\n-   vector.  They are of simple for  function_param OP VAL, where VAL is\n-   IPA invariant.  The conditions are then referred by predicates.  */\n-\n-struct GTY(()) condition\n-{\n-  /* If agg_contents is set, this is the offset from which the used data was\n-     loaded.  */\n-  HOST_WIDE_INT offset;\n-  /* Size of the access reading the data (or the PARM_DECL SSA_NAME).  */\n-  HOST_WIDE_INT size;\n-  tree val;\n-  int operand_num;\n-  ENUM_BITFIELD(tree_code) code : 16;\n-  /* Set if the used data were loaded from an aggregate parameter or from\n-     data received by reference.  */\n-  unsigned agg_contents : 1;\n-  /* If agg_contents is set, this differentiates between loads from data\n-     passed by reference and by value.  */\n-  unsigned by_ref : 1;\n-};\n-\n /* Inline hints are reasons why inline heuristics should preffer inlining given\n    function.  They are represtented as bitmap of the following values.  */\n enum inline_hints_vals {\n@@ -78,171 +54,19 @@ enum inline_hints_vals {\n   /* We know that the callee is hot by profile.  */\n   INLINE_HINT_known_hot = 256\n };\n-typedef int inline_hints;\n-\n-/* Information kept about parameter of call site.  */\n-struct inline_param_summary\n-{\n-  /* REG_BR_PROB_BASE based probability that parameter will change in between\n-     two invocation of the calls.\n-     I.e. loop invariant parameters\n-     REG_BR_PROB_BASE/estimated_iterations and regular\n-     parameters REG_BR_PROB_BASE.\n-\n-     Value 0 is reserved for compile time invariants. */\n-  int change_prob;\n-};\n-\n-typedef vec<condition, va_gc> *conditions;\n \n-/* Predicates are used to repesent function parameters (such as runtime)\n-   which depend on a context function is called in.\n-\n-   Predicates are logical formulas in conjunctive-disjunctive form consisting\n-   of clauses which are bitmaps specifying a set of condition that must\n-   be true for a clause to be satisfied. Physically they are represented as\n-   array of clauses terminated by 0.\n-\n-   In order to make predicate (possibly) true, all of its clauses must\n-   be (possibly) true. To make clause (possibly) true, one of conditions\n-   it mentions must be (possibly) true.\n+typedef int inline_hints;\n \n-   There are fixed bounds on number of clauses and conditions and all the\n-   manipulation functions are conservative in positive direction. I.e. we\n-   may lose precision by thinking that predicate may be true even when it\n-   is not.  */\n+/* Simple description of whether a memory load or a condition refers to a load\n+   from an aggregate and if so, how and where from in the aggregate.\n+   Individual fields have the same meaning like fields with the same name in\n+   struct condition.  */\n \n-typedef uint32_t clause_t;\n-class predicate\n+struct agg_position_info\n {\n-public:\n-  enum predicate_conditions\n-    {\n-      false_condition = 0,\n-      not_inlined_condition = 1,\n-      first_dynamic_condition = 2\n-    };\n-\n-  /* Initialize predicate either to true of false depending on P.  */\n-  inline predicate (bool p = true)\n-    {\n-      if (p)\n-        /* True predicate.  */\n-        m_clause[0] = 0;\n-      else\n-        /* False predicate. */\n-        set_to_cond (false_condition);\n-    }\n-\n-  /* Sanity check that we do not mix pointers to predicates with predicates.  */\n-  inline predicate (predicate *)\n-    {\n-      gcc_unreachable ();\n-    }\n-\n-  /* Return predicate testing condition I.  */\n-  static inline predicate predicate_testing_cond (int i)\n-    {\n-      class predicate p;\n-      p.set_to_cond (i + first_dynamic_condition);\n-      return p;\n-    }\n-\n-  /* Return predicate testing that function was not inlined.  */\n-  static predicate not_inlined (void)\n-    {\n-      class predicate p;\n-      p.set_to_cond (not_inlined_condition);\n-      return p;\n-    }\n-\n-  /* Compute logical and of predicates.  */\n-  predicate & operator &= (const predicate &);\n-  inline predicate operator &(const predicate &p)\n-    {\n-      predicate ret = *this;\n-      ret &= p;\n-      return ret;\n-    }\n-\n-  /* Compute logical or of predicates.  This is not operator because\n-     extra parameter CONDITIONS is needed  */\n-  predicate or_with (conditions, const predicate &) const;\n-\n-  /* Return true if predicates are known to be equal.  */\n-  inline bool operator==(const predicate &p2) const\n-    {\n-      int i;\n-      for (i = 0; m_clause[i]; i++)\n-\t{\n-\t  gcc_checking_assert (i < max_clauses);\n-\t  gcc_checking_assert (m_clause[i] > m_clause[i + 1]);\n-\t  gcc_checking_assert (!p2.m_clause[i]\n-\t\t\t       || p2.m_clause[i] > p2.m_clause[i + 1]);\n-\t  if (m_clause[i] != p2.m_clause[i])\n-\t    return false;\n-\t}\n-      return !p2.m_clause[i];\n-    }\n-\n-  /* Return true if predicates are known to be true or false depending\n-     on COND.  */\n-  inline bool operator==(const bool cond) const\n-    {\n-      if (cond)\n-        return !m_clause[0];\n-      if (m_clause[0] == (1 << false_condition))\n-\t{\n-\t  gcc_checking_assert (!m_clause[1]\n-\t\t\t       && m_clause[0] == 1\n-\t\t\t\t  << false_condition);\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  inline bool operator!=(const predicate &p2) const\n-    {\n-      return !(*this == p2);\n-    }\n-\n-  inline bool operator!=(const bool cond) const\n-    {\n-      return !(*this == cond);\n-    }\n-\n-  /* Evaluate if predicate is known to be false given the clause of possible\n-     truths.  */\n-  bool evaluate (clause_t) const;\n-\n-  /* Estimate probability that predicate will be true in a given context.  */\n-  int probability (conditions, clause_t, vec<inline_param_summary>) const;\n-\n-  /* Dump predicate to F. Output newline if nl.  */\n-  void dump (FILE *f, conditions, bool nl=true) const;\n-\n-  /* Return predicate equal to THIS after duplication.  */\n-  predicate remap_after_duplication (clause_t);\n-\n-  /* Return predicate equal to THIS after inlining.  */\n-  predicate remap_after_inlining (struct inline_summary *,\n-\t\t\t          struct inline_summary *,\n-\t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n-\n-  void stream_in (struct lto_input_block *);\n-  void stream_out (struct output_block *);\n-private:\n-  static const int max_clauses = 8;\n-  clause_t m_clause[max_clauses + 1];\n-\n-  /* Initialize predicate to one testing single condition number COND.  */\n-  inline void set_to_cond (int cond)\n-    {\n-      m_clause[0] = 1 << cond;\n-      m_clause[1] = 0;\n-    }\n-\n-  void add_clause (conditions conditions, clause_t);\n+  HOST_WIDE_INT offset;\n+  bool agg_contents;\n+  bool by_ref;\n };\n \n /* Represnetation of function body size and time depending on the inline"}, {"sha": "660e327582441f41bfbc2c35738e16b640f41f67", "filename": "gcc/ipa-predicate.c", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=b679b55b5eb8ea463af3459092c19ba05cde664b", "patch": "@@ -0,0 +1,573 @@\n+/* IPA predicates.\n+   Copyright (C) 2003-2017 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"tree-vrp.h\"\n+#include \"symbol-summary.h\"\n+#include \"alloc-pool.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-inline.h\"\n+#include \"real.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple.h\"\n+#include \"data-streamer.h\"\n+\n+\n+/* Add clause CLAUSE into the predicate P.\n+   When CONDITIONS is NULL do not perform checking whether NEW_CLAUSE\n+   is obviously true.  This is useful only when NEW_CLAUSE is known to be\n+   sane.  */\n+\n+void\n+predicate::add_clause (conditions conditions, clause_t new_clause)\n+{\n+  int i;\n+  int i2;\n+  int insert_here = -1;\n+  int c1, c2;\n+\n+  /* True clause.  */\n+  if (!new_clause)\n+    return;\n+\n+  /* False clause makes the whole predicate false.  Kill the other variants.  */\n+  if (new_clause == (1 << predicate::false_condition))\n+    {\n+      *this = false;\n+      return;\n+    }\n+  if (*this == false)\n+    return;\n+\n+  /* No one should be silly enough to add false into nontrivial clauses.  */\n+  gcc_checking_assert (!(new_clause & (1 << predicate::false_condition)));\n+\n+  /* Look where to insert the new_clause.  At the same time prune out\n+     new_clauses of P that are implied by the new new_clause and thus\n+     redundant.  */\n+  for (i = 0, i2 = 0; i <= max_clauses; i++)\n+    {\n+      m_clause[i2] = m_clause[i];\n+\n+      if (!m_clause[i])\n+\tbreak;\n+\n+      /* If m_clause[i] implies new_clause, there is nothing to add.  */\n+      if ((m_clause[i] & new_clause) == m_clause[i])\n+\t{\n+\t  /* We had nothing to add, none of clauses should've become\n+\t     redundant.  */\n+\t  gcc_checking_assert (i == i2);\n+\t  return;\n+\t}\n+\n+      if (m_clause[i] < new_clause && insert_here < 0)\n+\tinsert_here = i2;\n+\n+      /* If new_clause implies clause[i], then clause[i] becomes redundant.\n+         Otherwise the clause[i] has to stay.  */\n+      if ((m_clause[i] & new_clause) != new_clause)\n+\ti2++;\n+    }\n+\n+  /* Look for clauses that are obviously true.  I.e.\n+     op0 == 5 || op0 != 5.  */\n+  if (conditions)\n+    for (c1 = predicate::first_dynamic_condition;\n+\t c1 < num_conditions; c1++)\n+      {\n+\tcondition *cc1;\n+\tif (!(new_clause & (1 << c1)))\n+\t  continue;\n+\tcc1 = &(*conditions)[c1 - predicate::first_dynamic_condition];\n+\t/* We have no way to represent !changed and !is_not_constant\n+\t   and thus there is no point for looking for them.  */\n+\tif (cc1->code == changed || cc1->code == is_not_constant)\n+\t  continue;\n+\tfor (c2 = c1 + 1; c2 < num_conditions; c2++)\n+\t  if (new_clause & (1 << c2))\n+\t    {\n+\t      condition *cc1 =\n+\t\t&(*conditions)[c1 - predicate::first_dynamic_condition];\n+\t      condition *cc2 =\n+\t\t&(*conditions)[c2 - predicate::first_dynamic_condition];\n+\t      if (cc1->operand_num == cc2->operand_num\n+\t\t  && cc1->val == cc2->val\n+\t\t  && cc2->code != is_not_constant\n+\t\t  && cc2->code != predicate::changed\n+\t\t  && cc1->code == invert_tree_comparison (cc2->code,\n+\t\t\t\t\t\t\t  HONOR_NANS (cc1->val)))\n+\t\treturn;\n+\t    }\n+      }\n+\n+\n+  /* We run out of variants.  Be conservative in positive direction.  */\n+  if (i2 == max_clauses)\n+    return;\n+  /* Keep clauses in decreasing order. This makes equivalence testing easy.  */\n+  m_clause[i2 + 1] = 0;\n+  if (insert_here >= 0)\n+    for (; i2 > insert_here; i2--)\n+      m_clause[i2] = m_clause[i2 - 1];\n+  else\n+    insert_here = i2;\n+  m_clause[insert_here] = new_clause;\n+}\n+\n+\n+/* Do THIS &= P.  */\n+\n+predicate &\n+predicate::operator &= (const predicate &p)\n+{\n+  /* Avoid busy work.  */\n+  if (p == false || *this == true)\n+    {\n+      *this = p;\n+      return *this;\n+    }\n+  if (*this == false || p == true || this == &p)\n+    return *this;\n+\n+  int i;\n+\n+  /* See how far predicates match.  */\n+  for (i = 0; m_clause[i] && m_clause[i] == p.m_clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < max_clauses);\n+    }\n+\n+  /* Combine the predicates rest.  */\n+  for (; p.m_clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < max_clauses);\n+      add_clause (NULL, p.m_clause[i]);\n+    }\n+  return *this;\n+}\n+\n+\n+\n+/* Return THIS | P2.  */\n+\n+predicate\n+predicate::or_with (conditions conditions,\n+\t            const predicate &p) const\n+{\n+  /* Avoid busy work.  */\n+  if (p == false || *this == true || *this == p)\n+    return *this;\n+  if (*this == false || p == true)\n+    return p;\n+\n+  /* OK, combine the predicates.  */\n+  predicate out = true;\n+\n+  for (int i = 0; m_clause[i]; i++)\n+    for (int j = 0; p.m_clause[j]; j++)\n+      {\n+\tgcc_checking_assert (i < max_clauses && j < max_clauses);\n+\tout.add_clause (conditions, m_clause[i] | p.m_clause[j]);\n+      }\n+  return out;\n+}\n+\n+\n+/* Having partial truth assignment in POSSIBLE_TRUTHS, return false\n+   if predicate P is known to be false.  */\n+\n+bool\n+predicate::evaluate (clause_t possible_truths) const\n+{\n+  int i;\n+\n+  /* True remains true.  */\n+  if (*this == true)\n+    return true;\n+\n+  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n+\n+  /* See if we can find clause we can disprove.  */\n+  for (i = 0; m_clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < max_clauses);\n+      if (!(m_clause[i] & possible_truths))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Return the probability in range 0...REG_BR_PROB_BASE that the predicated\n+   instruction will be recomputed per invocation of the inlined call.  */\n+\n+int\n+predicate::probability (conditions conds,\n+\t                clause_t possible_truths,\n+\t                vec<inline_param_summary> inline_param_summary) const\n+{\n+  int i;\n+  int combined_prob = REG_BR_PROB_BASE;\n+\n+  /* True remains true.  */\n+  if (*this == true)\n+    return REG_BR_PROB_BASE;\n+\n+  if (*this == false)\n+    return 0;\n+\n+  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n+\n+  /* See if we can find clause we can disprove.  */\n+  for (i = 0; m_clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < max_clauses);\n+      if (!(m_clause[i] & possible_truths))\n+\treturn 0;\n+      else\n+\t{\n+\t  int this_prob = 0;\n+\t  int i2;\n+\t  if (!inline_param_summary.exists ())\n+\t    return REG_BR_PROB_BASE;\n+\t  for (i2 = 0; i2 < num_conditions; i2++)\n+\t    if ((m_clause[i] & possible_truths) & (1 << i2))\n+\t      {\n+\t\tif (i2 >= predicate::first_dynamic_condition)\n+\t\t  {\n+\t\t    condition *c =\n+\t\t      &(*conds)[i2 - predicate::first_dynamic_condition];\n+\t\t    if (c->code == predicate::changed\n+\t\t\t&& (c->operand_num <\n+\t\t\t    (int) inline_param_summary.length ()))\n+\t\t      {\n+\t\t\tint iprob =\n+\t\t\t  inline_param_summary[c->operand_num].change_prob;\n+\t\t\tthis_prob = MAX (this_prob, iprob);\n+\t\t      }\n+\t\t    else\n+\t\t      this_prob = REG_BR_PROB_BASE;\n+\t\t  }\n+\t\telse\n+\t\t  this_prob = REG_BR_PROB_BASE;\n+\t      }\n+\t  combined_prob = MIN (this_prob, combined_prob);\n+\t  if (!combined_prob)\n+\t    return 0;\n+\t}\n+    }\n+  return combined_prob;\n+}\n+\n+\n+/* Dump conditional COND.  */\n+\n+void\n+dump_condition (FILE *f, conditions conditions, int cond)\n+{\n+  condition *c;\n+  if (cond == predicate::false_condition)\n+    fprintf (f, \"false\");\n+  else if (cond == predicate::not_inlined_condition)\n+    fprintf (f, \"not inlined\");\n+  else\n+    {\n+      c = &(*conditions)[cond - predicate::first_dynamic_condition];\n+      fprintf (f, \"op%i\", c->operand_num);\n+      if (c->agg_contents)\n+\tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n+\t\t c->by_ref ? \"ref \" : \"\", c->offset);\n+      if (c->code == predicate::is_not_constant)\n+\t{\n+\t  fprintf (f, \" not constant\");\n+\t  return;\n+\t}\n+      if (c->code == predicate::changed)\n+\t{\n+\t  fprintf (f, \" changed\");\n+\t  return;\n+\t}\n+      fprintf (f, \" %s \", op_symbol_code (c->code));\n+      print_generic_expr (f, c->val);\n+    }\n+}\n+\n+\n+/* Dump clause CLAUSE.  */\n+\n+static void\n+dump_clause (FILE *f, conditions conds, clause_t clause)\n+{\n+  int i;\n+  bool found = false;\n+  fprintf (f, \"(\");\n+  if (!clause)\n+    fprintf (f, \"true\");\n+  for (i = 0; i < predicate::num_conditions; i++)\n+    if (clause & (1 << i))\n+      {\n+\tif (found)\n+\t  fprintf (f, \" || \");\n+\tfound = true;\n+\tdump_condition (f, conds, i);\n+      }\n+  fprintf (f, \")\");\n+}\n+\n+\n+/* Dump THIS to F. CONDS a vector of conditions used when evauating\n+   predicats. When NL is true new line is output at the end of dump.  */\n+\n+void\n+predicate::dump (FILE *f, conditions conds, bool nl) const\n+{\n+  int i;\n+  if (*this == true)\n+    dump_clause (f, conds, 0);\n+  else\n+    for (i = 0; m_clause[i]; i++)\n+      {\n+\tif (i)\n+\t  fprintf (f, \" && \");\n+\tdump_clause (f, conds, m_clause[i]);\n+      }\n+  if (nl)\n+    fprintf (f, \"\\n\");\n+}\n+\n+\n+void\n+predicate::debug (conditions conds) const\n+{\n+  dump (stderr, conds);\n+}\n+\n+\n+/* Remap predicate THIS of former function to be predicate of duplicated function.\n+   POSSIBLE_TRUTHS is clause of possible truths in the duplicated node,\n+   INFO is inline summary of the duplicated node.  */\n+\n+predicate\n+predicate::remap_after_duplication (clause_t possible_truths)\n+{\n+  int j;\n+  predicate out = true;\n+  for (j = 0; m_clause[j]; j++)\n+    if (!(possible_truths & m_clause[j]))\n+      return false;\n+    else\n+      out.add_clause (NULL, possible_truths & m_clause[j]);\n+  return out;\n+}\n+\n+\n+/* Translate all conditions from callee representation into caller\n+   representation and symbolically evaluate predicate THIS into new predicate.\n+\n+   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO\n+   is summary of function predicate P is from. OPERAND_MAP is array giving\n+   callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clausule of all\n+   callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n+   predicate under which callee is executed.  OFFSET_MAP is an array of of\n+   offsets that need to be added to conditions, negative offset means that\n+   conditions relying on values passed by reference have to be discarded\n+   because they might not be preserved (and should be considered offset zero\n+   for other purposes).  */\n+\n+predicate\n+predicate::remap_after_inlining (struct inline_summary *info,\n+\t\t\t\t struct inline_summary *callee_info,\n+\t\t\t\t vec<int> operand_map,\n+\t\t\t\t vec<int> offset_map,\n+\t\t\t\t clause_t possible_truths,\n+\t\t\t\t const predicate &toplev_predicate)\n+{\n+  int i;\n+  predicate out = true;\n+\n+  /* True predicate is easy.  */\n+  if (*this == true)\n+    return toplev_predicate;\n+  for (i = 0; m_clause[i]; i++)\n+    {\n+      clause_t clause = m_clause[i];\n+      int cond;\n+      predicate clause_predicate = false;\n+\n+      gcc_assert (i < max_clauses);\n+\n+      for (cond = 0; cond < num_conditions; cond++)\n+\t/* Do we have condition we can't disprove?   */\n+\tif (clause & possible_truths & (1 << cond))\n+\t  {\n+\t    predicate cond_predicate;\n+\t    /* Work out if the condition can translate to predicate in the\n+\t       inlined function.  */\n+\t    if (cond >= predicate::first_dynamic_condition)\n+\t      {\n+\t\tstruct condition *c;\n+\n+\t\tc = &(*callee_info->conds)[cond\n+\t\t\t\t\t   -\n+\t\t\t\t\t   predicate::first_dynamic_condition];\n+\t\t/* See if we can remap condition operand to caller's operand.\n+\t\t   Otherwise give up.  */\n+\t\tif (!operand_map.exists ()\n+\t\t    || (int) operand_map.length () <= c->operand_num\n+\t\t    || operand_map[c->operand_num] == -1\n+\t\t    /* TODO: For non-aggregate conditions, adding an offset is\n+\t\t       basically an arithmetic jump function processing which\n+\t\t       we should support in future.  */\n+\t\t    || ((!c->agg_contents || !c->by_ref)\n+\t\t\t&& offset_map[c->operand_num] > 0)\n+\t\t    || (c->agg_contents && c->by_ref\n+\t\t\t&& offset_map[c->operand_num] < 0))\n+\t\t  cond_predicate = true;\n+\t\telse\n+\t\t  {\n+\t\t    struct agg_position_info ap;\n+\t\t    HOST_WIDE_INT offset_delta = offset_map[c->operand_num];\n+\t\t    if (offset_delta < 0)\n+\t\t      {\n+\t\t\tgcc_checking_assert (!c->agg_contents || !c->by_ref);\n+\t\t\toffset_delta = 0;\n+\t\t      }\n+\t\t    gcc_assert (!c->agg_contents\n+\t\t\t\t|| c->by_ref || offset_delta == 0);\n+\t\t    ap.offset = c->offset + offset_delta;\n+\t\t    ap.agg_contents = c->agg_contents;\n+\t\t    ap.by_ref = c->by_ref;\n+\t\t    cond_predicate = add_condition (info,\n+\t\t\t\t\t\t    operand_map[c->operand_num],\n+\t\t\t\t\t\t    c->size, &ap, c->code,\n+\t\t\t\t\t\t    c->val);\n+\t\t  }\n+\t      }\n+\t    /* Fixed conditions remains same, construct single\n+\t       condition predicate.  */\n+\t    else\n+\t      cond_predicate = predicate::predicate_testing_cond (cond);\n+\t    clause_predicate = clause_predicate.or_with (info->conds,\n+\t\t\t\t\t                 cond_predicate);\n+\t  }\n+      out &= clause_predicate;\n+    }\n+  out &= toplev_predicate;\n+  return out;\n+}\n+\n+\n+/* Read predicate from IB.  */\n+\n+void\n+predicate::stream_in (struct lto_input_block *ib)\n+{\n+  clause_t clause;\n+  int k = 0;\n+\n+  do\n+    {\n+      gcc_assert (k <= max_clauses);\n+      clause = m_clause[k++] = streamer_read_uhwi (ib);\n+    }\n+  while (clause);\n+\n+  /* Zero-initialize the remaining clauses in OUT.  */\n+  while (k <= max_clauses)\n+    m_clause[k++] = 0;\n+}\n+\n+\n+/* Write predicate P to OB.  */\n+\n+void\n+predicate::stream_out (struct output_block *ob)\n+{\n+  int j;\n+  for (j = 0; m_clause[j]; j++)\n+    {\n+      gcc_assert (j < max_clauses);\n+      streamer_write_uhwi (ob, m_clause[j]);\n+    }\n+  streamer_write_uhwi (ob, 0);\n+}\n+\n+\n+/* Add condition to condition list SUMMARY. OPERAND_NUM, SIZE, CODE and VAL\n+   correspond to fields of condition structure.  AGGPOS describes whether the\n+   used operand is loaded from an aggregate and where in the aggregate it is.\n+   It can be NULL, which means this not a load from an aggregate.  */\n+\n+predicate\n+add_condition (struct inline_summary *summary, int operand_num,\n+\t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n+\t       enum tree_code code, tree val)\n+{\n+  int i;\n+  struct condition *c;\n+  struct condition new_cond;\n+  HOST_WIDE_INT offset;\n+  bool agg_contents, by_ref;\n+\n+  if (aggpos)\n+    {\n+      offset = aggpos->offset;\n+      agg_contents = aggpos->agg_contents;\n+      by_ref = aggpos->by_ref;\n+    }\n+  else\n+    {\n+      offset = 0;\n+      agg_contents = false;\n+      by_ref = false;\n+    }\n+\n+  gcc_checking_assert (operand_num >= 0);\n+  for (i = 0; vec_safe_iterate (summary->conds, i, &c); i++)\n+    {\n+      if (c->operand_num == operand_num\n+\t  && c->size == size\n+\t  && c->code == code\n+\t  && c->val == val\n+\t  && c->agg_contents == agg_contents\n+\t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n+\treturn predicate::predicate_testing_cond (i);\n+    }\n+  /* Too many conditions.  Give up and return constant true.  */\n+  if (i == predicate::num_conditions - predicate::first_dynamic_condition)\n+    return true;\n+\n+  new_cond.operand_num = operand_num;\n+  new_cond.code = code;\n+  new_cond.val = val;\n+  new_cond.agg_contents = agg_contents;\n+  new_cond.by_ref = by_ref;\n+  new_cond.offset = offset;\n+  new_cond.size = size;\n+  vec_safe_push (summary->conds, new_cond);\n+\n+  return predicate::predicate_testing_cond (i);\n+}"}, {"sha": "9557c3fabcc2be219706eddd392701436ea38d95", "filename": "gcc/ipa-predicate.h", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b679b55b5eb8ea463af3459092c19ba05cde664b/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=b679b55b5eb8ea463af3459092c19ba05cde664b", "patch": "@@ -0,0 +1,232 @@\n+/* IPA predicates.\n+   Copyright (C) 2003-2017 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Representation of inline parameters that do depend on context function is\n+   inlined into (i.e. known constant values of function parameters.\n+\n+   Conditions that are interesting for function body are collected into CONDS\n+   vector.  They are of simple for  function_param OP VAL, where VAL is\n+   IPA invariant.  The conditions are then referred by predicates.  */\n+\n+struct GTY(()) condition\n+{\n+  /* If agg_contents is set, this is the offset from which the used data was\n+     loaded.  */\n+  HOST_WIDE_INT offset;\n+  /* Size of the access reading the data (or the PARM_DECL SSA_NAME).  */\n+  HOST_WIDE_INT size;\n+  tree val;\n+  int operand_num;\n+  ENUM_BITFIELD(tree_code) code : 16;\n+  /* Set if the used data were loaded from an aggregate parameter or from\n+     data received by reference.  */\n+  unsigned agg_contents : 1;\n+  /* If agg_contents is set, this differentiates between loads from data\n+     passed by reference and by value.  */\n+  unsigned by_ref : 1;\n+};\n+\n+/* Information kept about parameter of call site.  */\n+struct inline_param_summary\n+{\n+  /* REG_BR_PROB_BASE based probability that parameter will change in between\n+     two invocation of the calls.\n+     I.e. loop invariant parameters\n+     REG_BR_PROB_BASE/estimated_iterations and regular\n+     parameters REG_BR_PROB_BASE.\n+\n+     Value 0 is reserved for compile time invariants. */\n+  int change_prob;\n+};\n+\n+typedef vec<condition, va_gc> *conditions;\n+\n+/* Predicates are used to repesent function parameters (such as runtime)\n+   which depend on a context function is called in.\n+\n+   Predicates are logical formulas in conjunctive-disjunctive form consisting\n+   of clauses which are bitmaps specifying a set of condition that must\n+   be true for a clause to be satisfied. Physically they are represented as\n+   array of clauses terminated by 0.\n+\n+   In order to make predicate (possibly) true, all of its clauses must\n+   be (possibly) true. To make clause (possibly) true, one of conditions\n+   it mentions must be (possibly) true.\n+\n+   There are fixed bounds on number of clauses and conditions and all the\n+   manipulation functions are conservative in positive direction. I.e. we\n+   may lose precision by thinking that predicate may be true even when it\n+   is not.  */\n+\n+typedef uint32_t clause_t;\n+class predicate\n+{\n+public:\n+  enum predicate_conditions\n+    {\n+      false_condition = 0,\n+      not_inlined_condition = 1,\n+      first_dynamic_condition = 2\n+    };\n+\n+  /* Maximal number of conditions predicate can reffer to.  This is limited\n+     by using clause_t to be 32bit.  */\n+  static const int num_conditions = 32;\n+\n+  /* Special condition code we use to represent test that operand is compile\n+     time constant.  */\n+  static const tree_code is_not_constant = ERROR_MARK;\n+\n+  /* Special condition code we use to represent test that operand is not changed\n+     across invocation of the function.  When operand IS_NOT_CONSTANT it is\n+     always CHANGED, however i.e. loop invariants can be NOT_CHANGED given\n+     percentage of executions even when they are not compile time constants.  */\n+  static const tree_code changed = IDENTIFIER_NODE;\n+\n+\n+\n+  /* Initialize predicate either to true of false depending on P.  */\n+  inline predicate (bool p = true)\n+    {\n+      if (p)\n+        /* True predicate.  */\n+        m_clause[0] = 0;\n+      else\n+        /* False predicate. */\n+        set_to_cond (false_condition);\n+    }\n+\n+  /* Sanity check that we do not mix pointers to predicates with predicates.  */\n+  inline predicate (predicate *)\n+    {\n+      gcc_unreachable ();\n+    }\n+\n+  /* Return predicate testing condition I.  */\n+  static inline predicate predicate_testing_cond (int i)\n+    {\n+      class predicate p;\n+      p.set_to_cond (i + first_dynamic_condition);\n+      return p;\n+    }\n+\n+  /* Return predicate testing that function was not inlined.  */\n+  static predicate not_inlined (void)\n+    {\n+      class predicate p;\n+      p.set_to_cond (not_inlined_condition);\n+      return p;\n+    }\n+\n+  /* Compute logical and of predicates.  */\n+  predicate & operator &= (const predicate &);\n+  inline predicate operator &(const predicate &p)\n+    {\n+      predicate ret = *this;\n+      ret &= p;\n+      return ret;\n+    }\n+\n+  /* Compute logical or of predicates.  This is not operator because\n+     extra parameter CONDITIONS is needed  */\n+  predicate or_with (conditions, const predicate &) const;\n+\n+  /* Return true if predicates are known to be equal.  */\n+  inline bool operator==(const predicate &p2) const\n+    {\n+      int i;\n+      for (i = 0; m_clause[i]; i++)\n+\t{\n+\t  gcc_checking_assert (i < max_clauses);\n+\t  gcc_checking_assert (m_clause[i] > m_clause[i + 1]);\n+\t  gcc_checking_assert (!p2.m_clause[i]\n+\t\t\t       || p2.m_clause[i] > p2.m_clause[i + 1]);\n+\t  if (m_clause[i] != p2.m_clause[i])\n+\t    return false;\n+\t}\n+      return !p2.m_clause[i];\n+    }\n+\n+  /* Return true if predicates are known to be true or false depending\n+     on COND.  */\n+  inline bool operator==(const bool cond) const\n+    {\n+      if (cond)\n+        return !m_clause[0];\n+      if (m_clause[0] == (1 << false_condition))\n+\t{\n+\t  gcc_checking_assert (!m_clause[1]\n+\t\t\t       && m_clause[0] == 1\n+\t\t\t\t  << false_condition);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  inline bool operator!=(const predicate &p2) const\n+    {\n+      return !(*this == p2);\n+    }\n+\n+  inline bool operator!=(const bool cond) const\n+    {\n+      return !(*this == cond);\n+    }\n+\n+  /* Evaluate if predicate is known to be false given the clause of possible\n+     truths.  */\n+  bool evaluate (clause_t) const;\n+\n+  /* Estimate probability that predicate will be true in a given context.  */\n+  int probability (conditions, clause_t, vec<inline_param_summary>) const;\n+\n+  /* Dump predicate to F. Output newline if nl.  */\n+  void dump (FILE *f, conditions, bool nl=true) const;\n+  void DEBUG_FUNCTION debug (conditions) const;\n+\n+  /* Return predicate equal to THIS after duplication.  */\n+  predicate remap_after_duplication (clause_t);\n+\n+  /* Return predicate equal to THIS after inlining.  */\n+  predicate remap_after_inlining (struct inline_summary *,\n+\t\t\t          struct inline_summary *,\n+\t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n+\n+  void stream_in (struct lto_input_block *);\n+  void stream_out (struct output_block *);\n+\n+private:\n+  static const int max_clauses = 8;\n+  clause_t m_clause[max_clauses + 1];\n+\n+  /* Initialize predicate to one testing single condition number COND.  */\n+  inline void set_to_cond (int cond)\n+    {\n+      m_clause[0] = 1 << cond;\n+      m_clause[1] = 0;\n+    }\n+\n+  void add_clause (conditions conditions, clause_t);\n+};\n+\n+void dump_condition (FILE *f, conditions conditions, int cond);\n+predicate add_condition (struct inline_summary *summary, int operand_num,\n+\t\t\t HOST_WIDE_INT size, struct agg_position_info *aggpos,\n+\t\t\t enum tree_code code, tree val);"}]}