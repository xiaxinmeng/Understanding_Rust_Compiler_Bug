{"sha": "60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBiMTIwOWQ2NGNlZTNiNDdjZjliM2Y1YjlkYTRmNzRmMDNhMjViYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-13T19:34:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-14T17:57:17Z"}, "message": "Fix Placeholder type checking\n\nWhen we are checking a trait impl block, associated types can equal any\ntype this ensures we update the traits associated types inline with\nrespective trait-impl-block that implements this trait.\n\nFixes #456", "tree": {"sha": "ef91aff90b40bb5f3b33d5ea1df31e53419ad6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef91aff90b40bb5f3b33d5ea1df31e53419ad6e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4ea3a19464b9bc79dad9cf5bb9bffc660718632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ea3a19464b9bc79dad9cf5bb9bffc660718632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ea3a19464b9bc79dad9cf5bb9bffc660718632"}], "stats": {"total": 355, "additions": 238, "deletions": 117}, "files": [{"sha": "e255fc45bd6d363e6d9bc06cc26276a72503e7bd", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -27,6 +27,7 @@ namespace Resolver {\n \n // Data Objects for the associated trait items in a structure we can work with\n // https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/associated-constants.html\n+class TypeCheckContext;\n class TraitItemReference\n {\n public:\n@@ -39,26 +40,25 @@ class TraitItemReference\n   };\n \n   TraitItemReference (std::string identifier, bool optional, TraitItemType type,\n-\t\t      const HIR::TraitItem *hir_trait_item, TyTy::BaseType *ty,\n-\t\t      Location locus)\n-    : identifier (identifier), optional_flag (optional), type (type),\n-      hir_trait_item (hir_trait_item), ty (ty), locus (locus)\n-  {}\n+\t\t      HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+\t\t      std::vector<TyTy::SubstitutionParamMapping> substitutions,\n+\t\t      Location locus);\n \n-  TraitItemReference (TraitItemReference const &other)\n-    : identifier (other.identifier), optional_flag (other.optional_flag),\n-      type (other.type), hir_trait_item (other.hir_trait_item), ty (other.ty),\n-      locus (other.locus)\n-  {}\n+  TraitItemReference (TraitItemReference const &other);\n \n   TraitItemReference &operator= (TraitItemReference const &other)\n   {\n     identifier = other.identifier;\n     optional_flag = other.optional_flag;\n     type = other.type;\n     hir_trait_item = other.hir_trait_item;\n-    ty = other.ty;\n+    self = other.self;\n     locus = other.locus;\n+    context = other.context;\n+\n+    inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+    for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+      inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n \n     return *this;\n   }\n@@ -68,7 +68,8 @@ class TraitItemReference\n \n   static TraitItemReference error ()\n   {\n-    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, Location ());\n+    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, {},\n+\t\t\t       Location ());\n   }\n \n   static TraitItemReference &error_node ()\n@@ -82,7 +83,7 @@ class TraitItemReference\n   std::string as_string () const\n   {\n     return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n-\t   + ty->as_string () + \")\";\n+\t   + \")\";\n   }\n \n   static std::string trait_item_type_as_string (TraitItemType ty)\n@@ -109,17 +110,65 @@ class TraitItemReference\n \n   const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n \n-  TyTy::BaseType *get_tyty () const { return ty; }\n-\n   Location get_locus () const { return locus; }\n \n+  const Analysis::NodeMapping &get_mappings () const\n+  {\n+    return hir_trait_item->get_mappings ();\n+  }\n+\n+  TyTy::BaseType *get_tyty () const\n+  {\n+    rust_assert (hir_trait_item != nullptr);\n+\n+    switch (type)\n+      {\n+      case CONST:\n+\treturn get_type_from_constant (\n+\t  static_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n+\tbreak;\n+\n+      case TYPE:\n+\treturn get_type_from_typealias (\n+\t  static_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+\n+      case FN:\n+\treturn get_type_from_fn (\n+\t  static_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n+\tbreak;\n+\n+      default:\n+\treturn get_error ();\n+      }\n+\n+    gcc_unreachable ();\n+    return get_error ();\n+  }\n+\n private:\n+  TyTy::ErrorType *get_error () const\n+  {\n+    return new TyTy::ErrorType (get_mappings ().get_hirid ());\n+  }\n+\n+  TyTy::BaseType *get_type_from_typealias (/*const*/\n+\t\t\t\t\t   HIR::TraitItemType &type) const;\n+\n+  TyTy::BaseType *\n+  get_type_from_constant (/*const*/ HIR::TraitItemConst &constant) const;\n+\n+  TyTy::BaseType *get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const;\n+\n   std::string identifier;\n   bool optional_flag;\n   TraitItemType type;\n-  const HIR::TraitItem *hir_trait_item;\n-  TyTy::BaseType *ty;\n+  HIR::TraitItem *hir_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> inherited_substitutions;\n   Location locus;\n+\n+  TyTy::BaseType\n+    *self; // this is the implict Self TypeParam required for methods\n+  Resolver::TypeCheckContext *context;\n };\n \n class TraitReference"}, {"sha": "3de68c8e685edaefb4c7049e541aad330ee0225d", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 3, "deletions": 100, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -55,128 +55,31 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::TYPE,\n-\t\t\t\t   &type, ty, locus);\n+\t\t\t\t   &type, self, substitutions, locus);\n   }\n \n   void visit (HIR::TraitItemConst &cst) override\n   {\n-    // attempt to lookup the type of the trait item function\n-    TyTy::BaseType *ty = nullptr;\n-    if (!context->lookup_type (cst.get_mappings ().get_hirid (), &ty))\n-      {\n-\tauto resolved = TypeCheckType::Resolve (cst.get_type ().get ());\n-\tif (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (cst.get_locus (),\n-\t\t\t   \"failed to resolve trait constant type\");\n-\t    return;\n-\t  }\n-      }\n-\n     // create trait-item-ref\n     Location locus = cst.get_locus ();\n     bool is_optional = cst.has_expr ();\n     std::string identifier = cst.get_name ();\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::CONST,\n-\t\t\t\t   &cst, ty, locus);\n+\t\t\t\t   &cst, self, substitutions, locus);\n   }\n \n   void visit (HIR::TraitItemFunc &fn) override\n   {\n-    // FIXME this is duplicated in a few places and could be refactored\n-\n-    // attempt to lookup the type of the trait item function\n-    TyTy::BaseType *ty = nullptr;\n-    if (!context->lookup_type (fn.get_mappings ().get_hirid (), &ty))\n-      {\n-\tHIR::TraitFunctionDecl &function = fn.get_decl ();\n-\tif (function.has_generics ())\n-\t  {\n-\t    for (auto &generic_param : function.get_generic_params ())\n-\t      {\n-\t\tswitch (generic_param.get ()->get_kind ())\n-\t\t  {\n-\t\t  case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t    // Skipping Lifetime completely until better handling.\n-\t\t    break;\n-\n-\t\t    case HIR::GenericParam::GenericKind::TYPE: {\n-\t\t      auto param_type = TypeResolveGenericParam::Resolve (\n-\t\t\tgeneric_param.get ());\n-\t\t      context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\t    param_type);\n-\n-\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n-\t\t\tparam_type));\n-\t\t    }\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tTyTy::BaseType *ret_type = nullptr;\n-\tif (!function.has_return_type ())\n-\t  ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n-\telse\n-\t  {\n-\t    auto resolved\n-\t      = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\t    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t      {\n-\t\trust_error_at (fn.get_locus (),\n-\t\t\t       \"failed to resolve return type\");\n-\t\treturn;\n-\t      }\n-\n-\t    ret_type = resolved->clone ();\n-\t    ret_type->set_ref (\n-\t      function.get_return_type ()->get_mappings ().get_hirid ());\n-\t  }\n-\n-\tstd::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-\tif (function.is_method ())\n-\t  {\n-\t    // add the synthetic self param at the front, this is a placeholder\n-\t    // for compilation to know parameter names. The types are ignored\n-\t    // but we reuse the HIR identifier pattern which requires it\n-\t    HIR::SelfParam &self_param = function.get_self ();\n-\t    HIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n-\t      \"self\", self_param.get_locus (), self_param.is_ref (),\n-\t      self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n-\t    context->insert_type (self_param.get_mappings (), self->clone ());\n-\t    params.push_back (\n-\t      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t\t   self->clone ()));\n-\t  }\n-\n-\tfor (auto &param : function.get_function_params ())\n-\t  {\n-\t    // get the name as well required for later on\n-\t    auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-\t    params.push_back (std::pair<HIR::Pattern *, TyTy::BaseType *> (\n-\t      param.get_param_name (), param_tyty));\n-\n-\t    context->insert_type (param.get_mappings (), param_tyty);\n-\t  }\n-\n-\tty = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t       function.get_function_name (),\n-\t\t\t       function.is_method (), std::move (params),\n-\t\t\t       ret_type, std::move (substitutions));\n-\tcontext->insert_type (fn.get_mappings (), ty);\n-      }\n-\n     // create trait-item-ref\n     Location locus = fn.get_locus ();\n     bool is_optional = fn.has_block_defined ();\n     std::string identifier = fn.get_decl ().get_function_name ();\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::FN, &fn,\n-\t\t\t\t   ty, locus);\n+\t\t\t\t   self, substitutions, locus);\n   }\n \n private:"}, {"sha": "0f704ae9e1033413af7e3e269ecf7c23786cf517", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -289,6 +289,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \treturn;\n       }\n \n+    context->insert_type (trait_item_ref.get_mappings (), lookup->clone ());\n     resolved_trait_item = trait_item_ref;\n   }\n "}, {"sha": "1d97deb3c80f3ef13843ea99fd6d14a88efc12dc", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -375,5 +375,128 @@ TypeCheckType::visit (HIR::ArrayType &type)\n \t\t\t\t    TyTy::TyVar (base->get_ref ()));\n }\n \n+// rust-hir-trait-ref.h\n+\n+TraitItemReference::TraitItemReference (\n+  std::string identifier, bool optional, TraitItemType type,\n+  HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions, Location locus)\n+  : identifier (identifier), optional_flag (optional), type (type),\n+    hir_trait_item (hir_trait_item), inherited_substitutions (substitutions),\n+    locus (locus), self (self), context (TypeCheckContext::get ())\n+{}\n+\n+TraitItemReference::TraitItemReference (TraitItemReference const &other)\n+  : identifier (other.identifier), optional_flag (other.optional_flag),\n+    type (other.type), hir_trait_item (other.hir_trait_item),\n+    locus (other.locus), self (other.self), context (TypeCheckContext::get ())\n+{\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_typealias (/*const*/\n+\t\t\t\t\t     HIR::TraitItemType &type) const\n+{\n+  TyTy::TyVar var (get_mappings ().get_hirid ());\n+  return var.get_tyty ();\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_constant (\n+  /*const*/ HIR::TraitItemConst &constant) const\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ().get ());\n+  TyTy::BaseType *expr\n+    = TypeCheckExpr::Resolve (constant.get_expr ().get (), false);\n+\n+  return type->unify (expr);\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = inherited_substitutions;\n+\n+  HIR::TraitFunctionDecl &function = fn.get_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t      // Skipping Lifetime completely until better handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_return_type ())\n+    ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (fn.get_locus (), \"failed to resolve return type\");\n+\t  return get_error ();\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  if (function.is_method ())\n+    {\n+      // add the synthetic self param at the front, this is a placeholder\n+      // for compilation to know parameter names. The types are ignored\n+      // but we reuse the HIR identifier pattern which requires it\n+      HIR::SelfParam &self_param = function.get_self ();\n+      HIR::IdentifierPattern *self_pattern\n+\t= new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n+\t\t\t\t      self_param.is_ref (),\n+\t\t\t\t      self_param.is_mut (),\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+      context->insert_type (self_param.get_mappings (), self->clone ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t     self->clone ()));\n+    }\n+\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+    }\n+\n+  return new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\t   function.get_function_name (), function.is_method (),\n+\t\t\t   std::move (params), ret_type, substitutions);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "5aae2e3a9c56f09ab60b33cab968b49ba173f347", "filename": "gcc/testsuite/rust/compile/torture/traits6.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -0,0 +1,23 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name .Foo::A.\" \"\" { target *-*-* } .-1 }\n+\n+    fn baz(a: Self::A) -> Self::A;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Foo::baz.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for Bar<T> {\n+    type A = T;\n+\n+    fn baz(a: Self::A) -> T {\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar::<i32>::baz(123);\n+}"}, {"sha": "c971a11bf8821a8d18bd1886ca0f2d92309aa13d", "filename": "gcc/testsuite/rust/compile/traits3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs?ref=60b1209d64cee3b47cf9b3f5b9da4f74f03a25bb", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {\n+    type A;\n+\n+    fn baz(a: Self::A) -> Self::A;\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for Bar<T> {\n+    type A = i32;\n+\n+    fn baz(a: f32) -> f32 {\n+        // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"method .baz. has an incompatible type for trait .Foo.\" \"\" { target *-*-* } .-2 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar::<i32>::baz(123f32);\n+}"}]}