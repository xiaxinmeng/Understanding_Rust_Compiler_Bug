{"sha": "0501dbd932a7e9ac64f14158d9ef998b08d01243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwMWRiZDkzMmE3ZTlhYzY0ZjE0MTU4ZDllZjk5OGIwOGQwMTI0Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-05-13T11:51:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-05-13T11:51:03Z"}, "message": "libcpp: Replace macro usage with C++ constructs\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (MAX_SOURCE_LOCATION): Convert from a macro\n\tto a const source_location.\n\t(RESERVED_LOCATION_COUNT): Likewise.\n\t(linemap_check_ordinary): Convert from a macro to a pair of inline\n\tfunctions, for const/non-const arguments.\n\t(MAP_START_LOCATION): Likewise.\n\t(ORDINARY_MAP_STARTING_LINE_NUMBER): Likewise.\n\t(ORDINARY_MAP_INCLUDER_FILE_INDEX): Likewise.\n\t(ORDINARY_MAP_IN_SYSTEM_HEADER_P): Likewise.\n\t(ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): Convert from a macro to a\n\tpair of inline functions, for const/non-const arguments, where the\n\tlatter is named...\n\t(SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): New function.\n\t(ORDINARY_MAP_FILE_NAME): Convert from a macro to a pair of inline\n\tfunctions, for const/non-const arguments.\n\t(MACRO_MAP_MACRO): Likewise.\n\t(MACRO_MAP_NUM_MACRO_TOKENS): Likewise.\n\t(MACRO_MAP_LOCATIONS): Likewise.\n\t(MACRO_MAP_EXPANSION_POINT_LOCATION): Likewise.\n\t(LINEMAPS_MAP_INFO): Likewise.\n\t(LINEMAPS_MAPS): Likewise.\n\t(LINEMAPS_ALLOCATED): Likewise.\n\t(LINEMAPS_USED): Likewise.\n\t(LINEMAPS_CACHE): Likewise.\n\t(LINEMAPS_ORDINARY_CACHE): Likewise.\n\t(LINEMAPS_MACRO_CACHE): Likewise.\n\t(LINEMAPS_MAP_AT): Convert from a macro to an inline function.\n\t(LINEMAPS_LAST_MAP): Likewise.\n\t(LINEMAPS_LAST_ALLOCATED_MAP): Likewise.\n\t(LINEMAPS_ORDINARY_MAPS): Likewise.\n\t(LINEMAPS_ORDINARY_MAP_AT): Likewise.\n\t(LINEMAPS_ORDINARY_ALLOCATED): Likewise.\n\t(LINEMAPS_ORDINARY_USED): Likewise.\n\t(LINEMAPS_LAST_ORDINARY_MAP): Likewise.\n\t(LINEMAPS_LAST_ALLOCATED_ORDINARY_MAP): Likewise.\n\t(LINEMAPS_MACRO_MAPS): Likewise.\n\t(LINEMAPS_MACRO_MAP_AT): Likewise.\n\t(LINEMAPS_MACRO_ALLOCATED): Likewise.\n\t(LINEMAPS_MACRO_USED): Likewise.\n\t(LINEMAPS_MACRO_LOWEST_LOCATION): Likewise.\n\t(LINEMAPS_LAST_MACRO_MAP): Likewise.\n\t(LINEMAPS_LAST_ALLOCATED_MACRO_MAP): Likewise.\n\t(IS_ADHOC_LOC): Likewise.\n\t(COMBINE_LOCATION_DATA): Likewise.\n\t(SOURCE_LINE): Likewise.\n\t(SOURCE_COLUMN): Likewise.\n\t(LAST_SOURCE_LINE_LOCATION): Likewise.\n\t(LAST_SOURCE_LINE): Likewise.\n\t(LAST_SOURCE_COLUMN): Likewise.\n\t(LAST_SOURCE_LINE_LOCATION)\n\t(INCLUDED_FROM): Likewise.\n\t(MAIN_FILE_P): Likewise.\n\t(LINEMAP_FILE): Likewise.\n\t(LINEMAP_LINE): Likewise.\n\t(LINEMAP_SYSP): Likewise.\n\t(linemap_location_before_p): Likewise.\n\t* line-map.c (linemap_check_files_exited): Make local \"map\" const.\n\t(linemap_add): Use SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS.\n\t(linemap_line_start): Likewise.\n\nFrom-SVN: r223152", "tree": {"sha": "3f3f5964864628ec2dd679c97fc5af9b494dd0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3f5964864628ec2dd679c97fc5af9b494dd0fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0501dbd932a7e9ac64f14158d9ef998b08d01243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0501dbd932a7e9ac64f14158d9ef998b08d01243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0501dbd932a7e9ac64f14158d9ef998b08d01243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0501dbd932a7e9ac64f14158d9ef998b08d01243/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39ba2a0ed8a19215218b415e596d2498d75b1040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ba2a0ed8a19215218b415e596d2498d75b1040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ba2a0ed8a19215218b415e596d2498d75b1040"}], "stats": {"total": 630, "additions": 517, "deletions": 113}, "files": [{"sha": "229ffd33f039e7492986fe088422dfb767aa1f5d", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=0501dbd932a7e9ac64f14158d9ef998b08d01243", "patch": "@@ -1,3 +1,65 @@\n+2015-05-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (MAX_SOURCE_LOCATION): Convert from a macro\n+\tto a const source_location.\n+\t(RESERVED_LOCATION_COUNT): Likewise.\n+\t(linemap_check_ordinary): Convert from a macro to a pair of inline\n+\tfunctions, for const/non-const arguments.\n+\t(MAP_START_LOCATION): Likewise.\n+\t(ORDINARY_MAP_STARTING_LINE_NUMBER): Likewise.\n+\t(ORDINARY_MAP_INCLUDER_FILE_INDEX): Likewise.\n+\t(ORDINARY_MAP_IN_SYSTEM_HEADER_P): Likewise.\n+\t(ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): Convert from a macro to a\n+\tpair of inline functions, for const/non-const arguments, where the\n+\tlatter is named...\n+\t(SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): New function.\n+\t(ORDINARY_MAP_FILE_NAME): Convert from a macro to a pair of inline\n+\tfunctions, for const/non-const arguments.\n+\t(MACRO_MAP_MACRO): Likewise.\n+\t(MACRO_MAP_NUM_MACRO_TOKENS): Likewise.\n+\t(MACRO_MAP_LOCATIONS): Likewise.\n+\t(MACRO_MAP_EXPANSION_POINT_LOCATION): Likewise.\n+\t(LINEMAPS_MAP_INFO): Likewise.\n+\t(LINEMAPS_MAPS): Likewise.\n+\t(LINEMAPS_ALLOCATED): Likewise.\n+\t(LINEMAPS_USED): Likewise.\n+\t(LINEMAPS_CACHE): Likewise.\n+\t(LINEMAPS_ORDINARY_CACHE): Likewise.\n+\t(LINEMAPS_MACRO_CACHE): Likewise.\n+\t(LINEMAPS_MAP_AT): Convert from a macro to an inline function.\n+\t(LINEMAPS_LAST_MAP): Likewise.\n+\t(LINEMAPS_LAST_ALLOCATED_MAP): Likewise.\n+\t(LINEMAPS_ORDINARY_MAPS): Likewise.\n+\t(LINEMAPS_ORDINARY_MAP_AT): Likewise.\n+\t(LINEMAPS_ORDINARY_ALLOCATED): Likewise.\n+\t(LINEMAPS_ORDINARY_USED): Likewise.\n+\t(LINEMAPS_LAST_ORDINARY_MAP): Likewise.\n+\t(LINEMAPS_LAST_ALLOCATED_ORDINARY_MAP): Likewise.\n+\t(LINEMAPS_MACRO_MAPS): Likewise.\n+\t(LINEMAPS_MACRO_MAP_AT): Likewise.\n+\t(LINEMAPS_MACRO_ALLOCATED): Likewise.\n+\t(LINEMAPS_MACRO_USED): Likewise.\n+\t(LINEMAPS_MACRO_LOWEST_LOCATION): Likewise.\n+\t(LINEMAPS_LAST_MACRO_MAP): Likewise.\n+\t(LINEMAPS_LAST_ALLOCATED_MACRO_MAP): Likewise.\n+\t(IS_ADHOC_LOC): Likewise.\n+\t(COMBINE_LOCATION_DATA): Likewise.\n+\t(SOURCE_LINE): Likewise.\n+\t(SOURCE_COLUMN): Likewise.\n+\t(LAST_SOURCE_LINE_LOCATION): Likewise.\n+\t(LAST_SOURCE_LINE): Likewise.\n+\t(LAST_SOURCE_COLUMN): Likewise.\n+\t(LAST_SOURCE_LINE_LOCATION)\n+\t(INCLUDED_FROM): Likewise.\n+\t(MAIN_FILE_P): Likewise.\n+\t(LINEMAP_FILE): Likewise.\n+\t(LINEMAP_LINE): Likewise.\n+\t(LINEMAP_SYSP): Likewise.\n+\t(linemap_location_before_p): Likewise.\n+\t* line-map.c (linemap_check_files_exited): Make local \"map\" const.\n+\t(linemap_add): Use SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS.\n+\t(linemap_line_start): Likewise.\n+\n 2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n \n \t* aclocal.m4: Regenerated with automake-1.11.6."}, {"sha": "86a33f1638bfe25e89c3e783bfd4f2867d61b671", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 452, "deletions": 110, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=0501dbd932a7e9ac64f14158d9ef998b08d01243", "patch": "@@ -155,7 +155,7 @@ struct GTY(()) line_map_ordinary {\n \n /* This is the highest possible source location encoded within an\n    ordinary or macro map.  */\n-#define MAX_SOURCE_LOCATION 0x7FFFFFFF\n+const source_location MAX_SOURCE_LOCATION = 0x7FFFFFFF;\n \n struct cpp_hashnode;\n \n@@ -298,47 +298,207 @@ struct GTY(()) line_map {\n #define linemap_assert_fails(EXPR) __extension__ \\\n   ({linemap_assert (EXPR); false;})\n \n-/* Assert that MAP encodes locations of tokens that are not part of\n-   the replacement-list of a macro expansion.  */\n-#define linemap_check_ordinary(LINE_MAP) __extension__\t\t\\\n-  ({linemap_assert (!linemap_macro_expansion_map_p (LINE_MAP)); \\\n-    (LINE_MAP);})\n #else\n /* Include EXPR, so that unused variable warnings do not occur.  */\n #define linemap_assert(EXPR) ((void)(0 && (EXPR)))\n #define linemap_assert_fails(EXPR) (! (EXPR))\n-#define linemap_check_ordinary(LINE_MAP) (LINE_MAP)\n #endif\n \n /* Return TRUE if MAP encodes locations coming from a macro\n    replacement-list at macro expansion point.  */\n bool\n linemap_macro_expansion_map_p (const struct line_map *);\n \n-#define MAP_START_LOCATION(MAP) (MAP)->start_location\n+/* Assert that MAP encodes locations of tokens that are not part of\n+   the replacement-list of a macro expansion.  */\n+inline struct line_map *\n+linemap_check_ordinary (struct line_map *map)\n+{\n+  linemap_assert (!linemap_macro_expansion_map_p (map));\n+  return map;\n+}\n+\n+/* Assert that MAP encodes locations of tokens that are not part of\n+   the replacement-list of a macro expansion.  */\n+\n+inline const struct line_map *\n+linemap_check_ordinary (const struct line_map *map)\n+{\n+  linemap_assert (!linemap_macro_expansion_map_p (map));\n+  return map;\n+}\n+\n+/* Read the start location of MAP, as an rvalue.  */\n+\n+inline source_location\n+MAP_START_LOCATION (const line_map *map)\n+{\n+  return map->start_location;\n+}\n+\n+/* Access the start location of MAP as a reference\n+   (e.g. as an lvalue).  */\n+\n+inline source_location&\n+MAP_START_LOCATION (line_map *map)\n+{\n+  return map->start_location;\n+}\n+\n+/* Get the starting line number of ordinary map MAP.  */\n+\n+inline linenum_type\n+ORDINARY_MAP_STARTING_LINE_NUMBER (const line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_line;\n+}\n+\n+/* Access the starting line number of ordinary map MAP by\n+   reference (e.g. as an lvalue).  */\n+\n+inline linenum_type&\n+ORDINARY_MAP_STARTING_LINE_NUMBER (line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_line;\n+}\n+\n+/* Get the index of the ordinary map at whose end\n+   ordinary map MAP was included.\n+\n+   File(s) at the bottom of the include stack have this set.  */\n+\n+inline int\n+ORDINARY_MAP_INCLUDER_FILE_INDEX (const line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.included_from;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline int&\n+ORDINARY_MAP_INCLUDER_FILE_INDEX (line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.included_from;\n+}\n+\n+/* Return a positive value if map encodes locations from a system\n+   header, 0 otherwise. Returns 1 if ordinary map MAP encodes locations\n+   in a system header and 2 if it encodes locations in a C system header\n+   that therefore needs to be extern \"C\" protected in C++.  */\n+\n+inline unsigned char\n+ORDINARY_MAP_IN_SYSTEM_HEADER_P (const line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.sysp;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned char &\n+ORDINARY_MAP_IN_SYSTEM_HEADER_P (line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.sysp;\n+}\n+\n+/* Get the number of the low-order source_location bits used for a\n+   column number within ordinary map MAP.  */\n+\n+inline unsigned char\n+ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (const line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.column_bits;\n+}\n+\n+/* Set the number of the low-order source_location bits used for a\n+   column number within ordinary map MAP.  */\n+\n+inline void\n+SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (line_map *map, int col_bits)\n+{\n+  linemap_check_ordinary (map)->d.ordinary.column_bits = col_bits;\n+}\n+\n+/* Get the filename of ordinary map MAP.  */\n+\n+inline const char *\n+ORDINARY_MAP_FILE_NAME (const line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_file;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline const char * &\n+ORDINARY_MAP_FILE_NAME (line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_file;\n+}\n+\n+/* Get the cpp macro whose expansion gave birth to macro map MAP.  */\n+\n+inline cpp_hashnode *\n+MACRO_MAP_MACRO (const line_map *map)\n+{\n+  return map->d.macro.macro;\n+}\n \n-#define ORDINARY_MAP_FILE_NAME(MAP) \\\n-  linemap_check_ordinary (MAP)->d.ordinary.to_file\n+/* As above, but by reference (e.g. as an lvalue).  */\n \n-#define ORDINARY_MAP_STARTING_LINE_NUMBER(MAP) \\\n-  linemap_check_ordinary (MAP)->d.ordinary.to_line\n+inline cpp_hashnode * &\n+MACRO_MAP_MACRO (line_map *map)\n+{\n+  return map->d.macro.macro;\n+}\n \n-#define ORDINARY_MAP_INCLUDER_FILE_INDEX(MAP) \\\n-  linemap_check_ordinary (MAP)->d.ordinary.included_from\n+/* Get the number of tokens inside the replacement-list of the macro\n+   that led to macro map MAP.  */\n \n-#define ORDINARY_MAP_IN_SYSTEM_HEADER_P(MAP) \\\n-  linemap_check_ordinary (MAP)->d.ordinary.sysp\n+inline unsigned int\n+MACRO_MAP_NUM_MACRO_TOKENS (const line_map *map)\n+{\n+  return map->d.macro.n_tokens;\n+}\n \n-#define ORDINARY_MAP_NUMBER_OF_COLUMN_BITS(MAP) \\\n-  linemap_check_ordinary (MAP)->d.ordinary.column_bits\n+/* As above, but by reference (e.g. as an lvalue).  */\n \n-#define MACRO_MAP_MACRO(MAP) (MAP)->d.macro.macro\n+inline unsigned int &\n+MACRO_MAP_NUM_MACRO_TOKENS (line_map *map)\n+{\n+  return map->d.macro.n_tokens;\n+}\n \n-#define MACRO_MAP_NUM_MACRO_TOKENS(MAP) (MAP)->d.macro.n_tokens\n+/* Get the array of pairs of locations within macro map MAP.\n+   See the declaration of line_map_macro for more information.  */\n \n-#define MACRO_MAP_LOCATIONS(MAP) (MAP)->d.macro.macro_locations\n+inline source_location *\n+MACRO_MAP_LOCATIONS (const line_map *map)\n+{\n+  return map->d.macro.macro_locations;\n+}\n \n-#define MACRO_MAP_EXPANSION_POINT_LOCATION(MAP) (MAP)->d.macro.expansion\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline source_location * &\n+MACRO_MAP_LOCATIONS (line_map *map)\n+{\n+  return map->d.macro.macro_locations;\n+}\n+\n+/* Get the location of the expansion point of the macro map MAP.  */\n+\n+inline source_location\n+MACRO_MAP_EXPANSION_POINT_LOCATION (const line_map *map)\n+{\n+  return map->d.macro.expansion;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline source_location &\n+MACRO_MAP_EXPANSION_POINT_LOCATION (line_map *map)\n+{\n+  return map->d.macro.expansion;\n+}\n \n /* The abstraction of a set of location maps. There can be several\n    types of location maps. This abstraction contains the attributes\n@@ -430,119 +590,248 @@ struct GTY(()) line_maps {\n /* Returns the pointer to the memory region where information about\n    maps are stored in the line table SET. MACRO_MAP_P is a flag\n    telling if we want macro or ordinary maps.  */\n-#define LINEMAPS_MAP_INFO(SET, MACRO_MAP_P)\t\t\t\t\\\n-  ((MACRO_MAP_P)\t\t\t\t\t\t\t\\\n-   ? &((SET)->info_macro)\t\t\t\t\t\t\\\n-   : &((SET)->info_ordinary))\n+inline struct maps_info *\n+LINEMAPS_MAP_INFO (line_maps *set, bool macro_map_p)\n+{\n+  return (macro_map_p\n+\t  ? &(set->info_macro)\n+\t  : &(set->info_ordinary));\n+}\n+\n+/* As above, but preserving constness.  */\n+\n+inline const struct maps_info *\n+LINEMAPS_MAP_INFO (const line_maps *set, bool macro_map_p)\n+{\n+  return (macro_map_p\n+\t  ? &(set->info_macro)\n+\t  : &(set->info_ordinary));\n+}\n \n /* Returns the pointer to the memory region where maps are stored in\n    the line table SET. MAP_KIND shall be TRUE if we are interested in\n    macro maps false otherwise.  */\n-#define LINEMAPS_MAPS(SET, MAP_KIND) \\\n-  (LINEMAPS_MAP_INFO (SET, MAP_KIND))->maps\n+inline line_map *\n+LINEMAPS_MAPS (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->maps;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline line_map * &\n+LINEMAPS_MAPS (line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->maps;\n+}\n \n /* Returns the number of allocated maps so far. MAP_KIND shall be TRUE\n    if we are interested in macro maps, FALSE otherwise.  */\n-#define LINEMAPS_ALLOCATED(SET, MAP_KIND) \\\n-  (LINEMAPS_MAP_INFO (SET, MAP_KIND))->allocated\n+inline unsigned int\n+LINEMAPS_ALLOCATED (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->allocated;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned int &\n+LINEMAPS_ALLOCATED (line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->allocated;\n+}\n \n /* Returns the number of used maps so far. MAP_KIND shall be TRUE if\n    we are interested in macro maps, FALSE otherwise.*/\n-#define LINEMAPS_USED(SET, MAP_KIND) \\\n-  (LINEMAPS_MAP_INFO (SET, MAP_KIND))->used\n+inline unsigned int\n+LINEMAPS_USED (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->used;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned int &\n+LINEMAPS_USED (line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->used;\n+}\n \n /* Returns the index of the last map that was looked up with\n    linemap_lookup. MAP_KIND shall be TRUE if we are interested in\n    macro maps, FALSE otherwise.  */\n-#define LINEMAPS_CACHE(SET, MAP_KIND) \\\n-  (LINEMAPS_MAP_INFO (SET, MAP_KIND))->cache\n+inline unsigned int\n+LINEMAPS_CACHE (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->cache;\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned int &\n+LINEMAPS_CACHE (line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_INFO (set, map_kind)->cache;\n+}\n \n /* Return the map at a given index.  */\n-#define LINEMAPS_MAP_AT(SET, MAP_KIND, INDEX)\t\\\n-  (&((LINEMAPS_MAPS (SET, MAP_KIND))[(INDEX)]))\n+inline line_map *\n+LINEMAPS_MAP_AT (const line_maps *set, bool map_kind, int index)\n+{\n+  return &(LINEMAPS_MAPS (set, map_kind)[index]);\n+}\n \n /* Returns the last map used in the line table SET. MAP_KIND\n    shall be TRUE if we are interested in macro maps, FALSE\n    otherwise.*/\n-#define LINEMAPS_LAST_MAP(SET, MAP_KIND) \\\n-  LINEMAPS_MAP_AT (SET, MAP_KIND, (LINEMAPS_USED (SET, MAP_KIND) - 1))\n+inline line_map *\n+LINEMAPS_LAST_MAP (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_AT (set, map_kind,\n+\t\t\t  LINEMAPS_USED (set, map_kind) - 1);\n+}\n \n /* Returns the last map that was allocated in the line table SET.\n    MAP_KIND shall be TRUE if we are interested in macro maps, FALSE\n    otherwise.*/\n-#define LINEMAPS_LAST_ALLOCATED_MAP(SET, MAP_KIND) \\\n-  LINEMAPS_MAP_AT (SET, MAP_KIND, LINEMAPS_ALLOCATED (SET, MAP_KIND) - 1)\n+inline line_map *\n+LINEMAPS_LAST_ALLOCATED_MAP (const line_maps *set, bool map_kind)\n+{\n+  return LINEMAPS_MAP_AT (set, map_kind,\n+\t\t\t  LINEMAPS_ALLOCATED (set, map_kind) - 1);\n+}\n \n /* Returns a pointer to the memory region where ordinary maps are\n    allocated in the line table SET.  */\n-#define LINEMAPS_ORDINARY_MAPS(SET) \\\n-  LINEMAPS_MAPS (SET, false)\n+inline line_map *\n+LINEMAPS_ORDINARY_MAPS (const line_maps *set)\n+{\n+  return LINEMAPS_MAPS (set, false);\n+}\n \n /* Returns the INDEXth ordinary map.  */\n-#define LINEMAPS_ORDINARY_MAP_AT(SET, INDEX)\t\\\n-  LINEMAPS_MAP_AT (SET, false, INDEX)\n+inline line_map *\n+LINEMAPS_ORDINARY_MAP_AT (const line_maps *set, int index)\n+{\n+  return LINEMAPS_MAP_AT (set, false, index);\n+}\n \n /* Return the number of ordinary maps allocated in the line table\n    SET.  */\n-#define LINEMAPS_ORDINARY_ALLOCATED(SET) \\\n-  LINEMAPS_ALLOCATED(SET, false)\n+inline unsigned int\n+LINEMAPS_ORDINARY_ALLOCATED (const line_maps *set)\n+{\n+  return LINEMAPS_ALLOCATED (set, false);\n+}\n \n /* Return the number of ordinary maps used in the line table SET.  */\n-#define LINEMAPS_ORDINARY_USED(SET) \\\n-  LINEMAPS_USED(SET, false)\n+inline unsigned int\n+LINEMAPS_ORDINARY_USED (const line_maps *set)\n+{\n+  return LINEMAPS_USED (set, false);\n+}\n \n /* Return the index of the last ordinary map that was looked up with\n    linemap_lookup.  */\n-#define LINEMAPS_ORDINARY_CACHE(SET) \\\n-  LINEMAPS_CACHE(SET, false)\n+inline unsigned int\n+LINEMAPS_ORDINARY_CACHE (const line_maps *set)\n+{\n+  return LINEMAPS_CACHE (set, false);\n+}\n+\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned int &\n+LINEMAPS_ORDINARY_CACHE (line_maps *set)\n+{\n+  return LINEMAPS_CACHE (set, false);\n+}\n \n /* Returns a pointer to the last ordinary map used in the line table\n    SET.  */\n-#define LINEMAPS_LAST_ORDINARY_MAP(SET) \\\n-  LINEMAPS_LAST_MAP(SET, false)\n+inline line_map *\n+LINEMAPS_LAST_ORDINARY_MAP (const line_maps *set)\n+{\n+  return LINEMAPS_LAST_MAP (set, false);\n+}\n \n /* Returns a pointer to the last ordinary map allocated the line table\n    SET.  */\n-#define LINEMAPS_LAST_ALLOCATED_ORDINARY_MAP(SET) \\\n-  LINEMAPS_LAST_ALLOCATED_MAP(SET, false)\n+inline line_map *\n+LINEMAPS_LAST_ALLOCATED_ORDINARY_MAP (const line_maps *set)\n+{\n+  return LINEMAPS_LAST_ALLOCATED_MAP (set, false);\n+}\n \n /* Returns a pointer to the beginning of the region where macro maps\n    are allcoated.  */\n-#define LINEMAPS_MACRO_MAPS(SET) \\\n-  LINEMAPS_MAPS(SET, true)\n+inline line_map *\n+LINEMAPS_MACRO_MAPS (const line_maps *set)\n+{\n+  return LINEMAPS_MAPS (set, true);\n+}\n \n /* Returns the INDEXth macro map.  */\n-#define LINEMAPS_MACRO_MAP_AT(SET, INDEX)\t\\\n-  LINEMAPS_MAP_AT (SET, true, INDEX)\n+inline line_map *\n+LINEMAPS_MACRO_MAP_AT (const line_maps *set, int index)\n+{\n+  return LINEMAPS_MAP_AT (set, true, index);\n+}\n \n /* Returns the number of macro maps that were allocated in the line\n    table SET.  */\n-#define LINEMAPS_MACRO_ALLOCATED(SET) \\\n-  LINEMAPS_ALLOCATED(SET, true)\n+inline unsigned int\n+LINEMAPS_MACRO_ALLOCATED (const line_maps *set)\n+{\n+  return LINEMAPS_ALLOCATED (set, true);\n+}\n \n /* Returns the number of macro maps used in the line table SET.  */\n-#define LINEMAPS_MACRO_USED(SET) \\\n-  LINEMAPS_USED(SET, true)\n+inline unsigned int\n+LINEMAPS_MACRO_USED (const line_maps *set)\n+{\n+  return LINEMAPS_USED (set, true);\n+}\n \n /* Returns the index of the last macro map looked up with\n    linemap_lookup.  */\n-#define LINEMAPS_MACRO_CACHE(SET) \\\n-  LINEMAPS_CACHE(SET, true)\n+inline unsigned int\n+LINEMAPS_MACRO_CACHE (const line_maps *set)\n+{\n+  return LINEMAPS_CACHE (set, true);\n+}\n \n-/* Returns the lowest location [of a token resulting from macro\n-   expansion] encoded in this line table.  */\n-#define LINEMAPS_MACRO_LOWEST_LOCATION(SET)\t\t\t\\\n-  (LINEMAPS_MACRO_USED (set)\t\t\t\t\t\\\n-   ? MAP_START_LOCATION (LINEMAPS_LAST_MACRO_MAP (set))\t\t\\\n-   : MAX_SOURCE_LOCATION)\n+/* As above, but by reference (e.g. as an lvalue).  */\n+\n+inline unsigned int &\n+LINEMAPS_MACRO_CACHE (line_maps *set)\n+{\n+  return LINEMAPS_CACHE (set, true);\n+}\n \n /* Returns the last macro map used in the line table SET.  */\n-#define LINEMAPS_LAST_MACRO_MAP(SET) \\\n-  LINEMAPS_LAST_MAP (SET, true)\n+inline line_map *\n+LINEMAPS_LAST_MACRO_MAP (const line_maps *set)\n+{\n+  return LINEMAPS_LAST_MAP (set, true);\n+}\n+\n+/* Returns the lowest location [of a token resulting from macro\n+   expansion] encoded in this line table.  */\n+inline source_location\n+LINEMAPS_MACRO_LOWEST_LOCATION (const line_maps *set)\n+{\n+  return LINEMAPS_MACRO_USED (set)\n+         ? MAP_START_LOCATION (LINEMAPS_LAST_MACRO_MAP (set))\n+         : MAX_SOURCE_LOCATION;\n+}\n \n /* Returns the last macro map allocated in the line table SET.  */\n-#define LINEMAPS_LAST_ALLOCATED_MACRO_MAP(SET) \\\n-  LINEMAPS_LAST_ALLOCATED_MAP (SET, true)\n+inline line_map *\n+LINEMAPS_LAST_ALLOCATED_MACRO_MAP (const line_maps *set)\n+{\n+  return LINEMAPS_LAST_ALLOCATED_MAP (set, true);\n+}\n \n extern void location_adhoc_data_fini (struct line_maps *);\n extern source_location get_combined_adhoc_loc (struct line_maps *,\n@@ -551,9 +840,23 @@ extern void *get_data_from_adhoc_loc (struct line_maps *, source_location);\n extern source_location get_location_from_adhoc_loc (struct line_maps *,\n \t\t\t\t\t\t    source_location);\n \n-#define IS_ADHOC_LOC(LOC) (((LOC) & MAX_SOURCE_LOCATION) != (LOC))\n-#define COMBINE_LOCATION_DATA(SET, LOC, BLOCK) \\\n-  get_combined_adhoc_loc ((SET), (LOC), (BLOCK))\n+/* Get whether location LOC is an ad-hoc location.  */\n+\n+inline bool\n+IS_ADHOC_LOC (source_location loc)\n+{\n+  return (loc & MAX_SOURCE_LOCATION) != loc;\n+}\n+\n+/* Combine LOC and BLOCK, giving a combined adhoc location.  */\n+\n+inline source_location\n+COMBINE_LOCATION_DATA (struct line_maps *set,\n+\t\t       source_location loc,\n+\t\t       void *block)\n+{\n+  return get_combined_adhoc_loc (set, loc, block);\n+}\n \n extern void rebuild_location_adhoc_htab (struct line_maps *);\n \n@@ -631,47 +934,72 @@ bool linemap_location_from_macro_expansion_p (const struct line_maps *,\n /* source_location values from 0 to RESERVED_LOCATION_COUNT-1 will\n    be reserved for libcpp user as special values, no token from libcpp\n    will contain any of those locations.  */\n-#define RESERVED_LOCATION_COUNT\t2\n+const int RESERVED_LOCATION_COUNT = 2;\n \n /* Converts a map and a source_location to source line.  */\n-#define SOURCE_LINE(MAP, LOC)\t\t\t\t\t\t\\\n-  (((((LOC) - linemap_check_ordinary (MAP)->start_location)\t\t\\\n-     >> (MAP)->d.ordinary.column_bits) + (MAP)->d.ordinary.to_line))\n+inline linenum_type\n+SOURCE_LINE (const struct line_map *map, source_location loc)\n+{\n+  return ((loc - linemap_check_ordinary (map)->start_location)\n+\t  >> map->d.ordinary.column_bits) + map->d.ordinary.to_line;\n+}\n \n /* Convert a map and source_location to source column number.  */\n-#define SOURCE_COLUMN(MAP, LOC)\t\t\t\t\t\t\\\n-  ((((LOC) - linemap_check_ordinary (MAP)->start_location)\t\t\\\n-    & ((1 << (MAP)->d.ordinary.column_bits) - 1)))\n+inline linenum_type\n+SOURCE_COLUMN (const struct line_map *map, source_location loc)\n+{\n+  return ((loc - linemap_check_ordinary (map)->start_location)\n+\t  & ((1 << map->d.ordinary.column_bits) - 1));\n+}\n+\n+/* Return the location of the last source line within an ordinary\n+   map.  */\n+inline source_location\n+LAST_SOURCE_LINE_LOCATION (const struct line_map *map)\n+{\n+  return (((linemap_check_ordinary (map)[1].start_location - 1\n+\t    - map->start_location)\n+\t   & ~((1 << map->d.ordinary.column_bits) - 1))\n+\t  + map->start_location);\n+}\n \n /* Returns the last source line number within an ordinary map.  This\n    is the (last) line of the #include, or other directive, that caused\n    a map change.  */\n-#define LAST_SOURCE_LINE(MAP) \\\n-  SOURCE_LINE (MAP, LAST_SOURCE_LINE_LOCATION (MAP))\n+\n+inline linenum_type\n+LAST_SOURCE_LINE (const struct line_map *map)\n+{\n+  return SOURCE_LINE (map, LAST_SOURCE_LINE_LOCATION (map));\n+}\n \n /* Return the last column number within an ordinary map.  */\n-#define LAST_SOURCE_COLUMN(MAP) \\\n-  SOURCE_COLUMN (MAP, LAST_SOURCE_LINE_LOCATION (MAP))\n \n-/* Return the location of the last source line within an ordinary\n-   map.  */\n-#define LAST_SOURCE_LINE_LOCATION(MAP)\t\t\t\t\t\\\n-  ((((linemap_check_ordinary (MAP)[1].start_location - 1\t\t\\\n-      - (MAP)->start_location)\t\t\t\t\t\t\\\n-     & ~((1 << (MAP)->d.ordinary.column_bits) - 1))\t\t\t\\\n-    + (MAP)->start_location))\n+inline linenum_type\n+LAST_SOURCE_COLUMN (const struct line_map *map)\n+{\n+  return SOURCE_COLUMN (map, LAST_SOURCE_LINE_LOCATION (map));\n+}\n \n /* Returns the map a given map was included from, or NULL if the map\n    belongs to the main file, i.e, a file that wasn't included by\n    another one.  */\n-#define INCLUDED_FROM(SET, MAP)\t\t\t\t\t\t\\\n-  ((linemap_check_ordinary (MAP)->d.ordinary.included_from == -1)\t\\\n-   ? NULL\t\t\t\t\t\t\t\t\\\n-   : (&LINEMAPS_ORDINARY_MAPS (SET)[(MAP)->d.ordinary.included_from]))\n \n-/* Nonzero if the map is at the bottom of the include stack.  */\n-#define MAIN_FILE_P(MAP)\t\t\t\t\t\t\\\n-  ((linemap_check_ordinary (MAP)->d.ordinary.included_from < 0))\n+inline struct line_map *\n+INCLUDED_FROM (struct line_maps *set, const struct line_map *map)\n+{\n+  return ((linemap_check_ordinary (map)->d.ordinary.included_from == -1)\n+\t  ? NULL\n+\t  : (&LINEMAPS_ORDINARY_MAPS (set)[(map)->d.ordinary.included_from]));\n+}\n+\n+/* True if the map is at the bottom of the include stack.  */\n+\n+inline bool\n+MAIN_FILE_P (const struct line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.included_from < 0;\n+}\n \n /* Encode and return a source_location from a column number. The\n    source line considered is the last source line used to call\n@@ -695,19 +1023,28 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n \t\t\t\t     unsigned int offset);\n \n /* Return the file this map is for.  */\n-#define LINEMAP_FILE(MAP)\t\t\t\t\t\\\n-  (linemap_check_ordinary (MAP)->d.ordinary.to_file)\n+inline const char *\n+LINEMAP_FILE (const struct line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_file;\n+}\n \n /* Return the line number this map started encoding location from.  */\n-#define LINEMAP_LINE(MAP)\t\t\t\t\t\\\n-  (linemap_check_ordinary (MAP)->d.ordinary.to_line)\n+inline linenum_type\n+LINEMAP_LINE (const struct line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.to_line;\n+}\n \n /* Return a positive value if map encodes locations from a system\n    header, 0 otherwise. Returns 1 if MAP encodes locations in a\n    system header and 2 if it encodes locations in a C system header\n    that therefore needs to be extern \"C\" protected in C++.  */\n-#define LINEMAP_SYSP(MAP)\t\t\t\t\t\\\n-  (linemap_check_ordinary (MAP)->d.ordinary.sysp)\n+inline unsigned char\n+LINEMAP_SYSP (const struct line_map *map)\n+{\n+  return linemap_check_ordinary (map)->d.ordinary.sysp;\n+}\n \n /* Return a positive value if PRE denotes the location of a token that\n    comes before the token of POST, 0 if PRE denotes the location of\n@@ -720,8 +1057,13 @@ int linemap_compare_locations (struct line_maps *set,\n /* Return TRUE if LOC_A denotes the location a token that comes\n    topogically before the token denoted by location LOC_B, or if they\n    are equal.  */\n-#define linemap_location_before_p(SET, LOC_A, LOC_B)\t\\\n-  (linemap_compare_locations ((SET), (LOC_A), (LOC_B)) >= 0)\n+inline bool\n+linemap_location_before_p (struct line_maps *set,\n+\t\t\t   source_location loc_a,\n+\t\t\t   source_location loc_b)\n+{\n+  return linemap_compare_locations (set, loc_a, loc_b) >= 0;\n+}\n \n typedef struct\n {"}, {"sha": "fd16c24c0c615d2833399a52d945ef459c4d29f9", "filename": "libcpp/line-map.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0501dbd932a7e9ac64f14158d9ef998b08d01243/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=0501dbd932a7e9ac64f14158d9ef998b08d01243", "patch": "@@ -191,7 +191,7 @@ linemap_init (struct line_maps *set,\n void\n linemap_check_files_exited (struct line_maps *set)\n {\n-  struct line_map *map;\n+  const struct line_map *map;\n   /* Depending upon whether we are handling preprocessed input or\n      not, this can be a user error or an ICE.  */\n   for (map = LINEMAPS_LAST_ORDINARY_MAP (set);\n@@ -371,7 +371,7 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   ORDINARY_MAP_FILE_NAME (map) = to_file;\n   ORDINARY_MAP_STARTING_LINE_NUMBER (map) = to_line;\n   LINEMAPS_ORDINARY_CACHE (set) = LINEMAPS_ORDINARY_USED (set) - 1;\n-  ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) = 0;\n+  SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map, 0);\n   set->highest_location = start_location;\n   set->highest_line = start_location;\n   set->max_column_hint = 0;\n@@ -564,7 +564,7 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t\t\t\t\t       (map),\n \t\t\t\t\t       ORDINARY_MAP_FILE_NAME (map),\n \t\t\t\t\t       to_line);\n-      ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) = column_bits;\n+      SET_ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map, column_bits);\n       r = (MAP_START_LOCATION (map)\n \t   + ((to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))\n \t      << column_bits));"}]}