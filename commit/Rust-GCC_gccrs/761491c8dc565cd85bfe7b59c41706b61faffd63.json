{"sha": "761491c8dc565cd85bfe7b59c41706b61faffd63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYxNDkxYzhkYzU2NWNkODViZmU3YjU5YzQxNzA2YjYxZmFmZmQ2Mw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2001-01-10T17:05:43Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-01-10T17:05:43Z"}, "message": "[multiple changes]\n\n2001-01-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* java-tree.h (lang_printable_name_wls): New prototype.\n\t* lang.c (put_decl_name): Removed dead code. Use DECL_CONTEXT\n\trather than `current_class' to print type name. Don't prepend type\n\tnames when printing constructor names.\n\t(lang_printable_name_wls): New function.\n\t* jcf-parse.c (jcf_parse_source): Pass NULL `file' argument to\n\t`build_expr_wfl', alway set EXPR_WFL_FILENAME_NODE.\n\t* parse.y (patch_method_invocation): Message tuned for constructors.\n\t(not_accessible_p): Grant `private' access from within\n\tenclosing contexts.\n\n2001-01-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (patch_binop): Compute missing type in error situations.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-01/msg00752.html)\n\nFrom-SVN: r38870", "tree": {"sha": "32b7af9ce6f4e5053e903e857f8b85deacf18cfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32b7af9ce6f4e5053e903e857f8b85deacf18cfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/761491c8dc565cd85bfe7b59c41706b61faffd63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761491c8dc565cd85bfe7b59c41706b61faffd63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761491c8dc565cd85bfe7b59c41706b61faffd63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761491c8dc565cd85bfe7b59c41706b61faffd63/comments", "author": null, "committer": null, "parents": [{"sha": "31bb3027a6ebbaa77b0d159f792a8fa9147b8841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bb3027a6ebbaa77b0d159f792a8fa9147b8841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31bb3027a6ebbaa77b0d159f792a8fa9147b8841"}], "stats": {"total": 95, "additions": 75, "deletions": 20}, "files": [{"sha": "f7bae10a4c0ab89d69a78b6081fb951e09df9329", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=761491c8dc565cd85bfe7b59c41706b61faffd63", "patch": "@@ -1,3 +1,20 @@\n+2001-01-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (lang_printable_name_wls): New prototype.\n+\t* lang.c (put_decl_name): Removed dead code. Use DECL_CONTEXT\n+\trather than `current_class' to print type name. Don't prepend type\n+\tnames when printing constructor names.\n+\t(lang_printable_name_wls): New function.\n+\t* jcf-parse.c (jcf_parse_source): Pass NULL `file' argument to\n+\t`build_expr_wfl', alway set EXPR_WFL_FILENAME_NODE.\n+\t* parse.y (patch_method_invocation): Message tuned for constructors.\n+\t(not_accessible_p): Grant `private' access from within\n+\tenclosing contexts.\n+\t\n+2001-01-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (patch_binop): Compute missing type in error situations.\n+\n 2001-01-05  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* class.c (make_class_data): Push initial value for \"arrayclass\"."}, {"sha": "510511eb2196e421094b20604c27030383879dda", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=761491c8dc565cd85bfe7b59c41706b61faffd63", "patch": "@@ -1111,6 +1111,7 @@ extern boolean java_hash_compare_tree_node PARAMS ((hash_table_key,\n \t\t\t\t\t\t    hash_table_key));\n extern void java_check_methods PARAMS ((tree));\n extern void init_jcf_parse PARAMS((void));\n+extern const char *lang_printable_name_wls PARAMS ((tree, int));\n \n /* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included\n    to declare `enum expand_modifier'. */"}, {"sha": "3fa64b2246b2a13a92b29aaaf73f888d8ceb57fd", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=761491c8dc565cd85bfe7b59c41706b61faffd63", "patch": "@@ -569,9 +569,8 @@ jcf_parse_source ()\n   java_push_parser_context ();\n   BUILD_FILENAME_IDENTIFIER_NODE (file, current_jcf->filename);\n   if (wfl_operator == NULL_TREE)\n-    wfl_operator = build_expr_wfl (NULL_TREE, file, 0, 0);\n-  else\n-    EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n+    wfl_operator = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n+  EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n   input_filename = ggc_strdup (current_jcf->filename);\n   current_class = NULL_TREE;\n   current_function_decl = NULL_TREE;"}, {"sha": "e312f501edd6a3dd9321f734752d13df20f70522", "filename": "gcc/java/lang.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=761491c8dc565cd85bfe7b59c41706b61faffd63", "patch": "@@ -502,18 +502,13 @@ put_decl_node (node)\n   if (TREE_CODE_CLASS (TREE_CODE (node)) == 'd'\n       && DECL_NAME (node) != NULL_TREE)\n     {\n-#if 0\n-      if (DECL_CONTEXT (node) != NULL_TREE)\n-\t{\n-\t  put_decl_node (DECL_CONTEXT (node));\n-\t  put_decl_string (\".\", 1);\n-\t}\n-#endif\n+      /* We want to print the type the DECL belongs to. We don't do\n+\t that when we handle constructors. */\n       if (TREE_CODE (node) == FUNCTION_DECL\n-\t  && DECL_INIT_P (node)\n-\t  && !DECL_ARTIFICIAL (node) && current_class)\n-\tput_decl_node (TYPE_NAME (current_class));\n-      else\n+\t  && ! DECL_CONSTRUCTOR_P (node)\n+\t  && ! DECL_ARTIFICIAL (node) && DECL_CONTEXT (node))\n+\tput_decl_node (TYPE_NAME (DECL_CONTEXT (node)));\n+      else if (! DECL_CONSTRUCTOR_P (node))\n \tput_decl_node (DECL_NAME (node));\n       if (TREE_CODE (node) == FUNCTION_DECL && TREE_TYPE (node) != NULL_TREE)\n \t{\n@@ -574,6 +569,21 @@ lang_printable_name (decl, v)\n   return decl_buf;\n }\n \n+/* Does the same thing that lang_printable_name, but add a leading\n+   space to the DECL name string -- With Leading Space.  */\n+\n+const char *\n+lang_printable_name_wls (decl, v)\n+     tree decl;\n+     int v  __attribute__ ((__unused__));\n+{\n+  decl_bufpos = 1;\n+  put_decl_node (decl);\n+  put_decl_string (\"\", 1);\n+  decl_buf [0] = ' ';\n+  return decl_buf;\n+}\n+\n /* Print on stderr the current class and method context.  This function\n    is the value of the hook print_error_function, called from toplev.c. */\n "}, {"sha": "a59e1987aabf5ca72457f42e9005738a23b9b9ab", "filename": "gcc/java/parse.y", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761491c8dc565cd85bfe7b59c41706b61faffd63/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=761491c8dc565cd85bfe7b59c41706b61faffd63", "patch": "@@ -9701,11 +9701,16 @@ not_accessible_p (reference, member, from_super)\n     }\n \n   /* Check access on private members. Access is granted only if it\n-     occurs from within the class in which it is declared. Exceptions\n-     are accesses from inner-classes. */\n+     occurs from within the class in which it is declared -- that does\n+     it for innerclasses too. */\n   if (access_flag & ACC_PRIVATE)\n-    return (current_class == DECL_CONTEXT (member) ? 0 : \n-\t    (INNER_CLASS_TYPE_P (current_class) ? 0 : 1));\n+    {\n+      if (reference == DECL_CONTEXT (member))\n+\treturn 0;\n+      if (enclosing_context_p (reference, DECL_CONTEXT (member)))\n+\treturn 0;\n+      return 1;\n+    }\n \n   /* Default access are permitted only when occuring within the\n      package in which the type (REFERENCE) is declared. In other words,\n@@ -10054,10 +10059,13 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n     {\n       char *fct_name = xstrdup (lang_printable_name (list, 0));\n+      int ctor_p = DECL_CONSTRUCTOR_P (list);\n       parse_error_context \n-\t(wfl, \"Can't access %s method `%s %s.%s' from `%s'\",\n+\t(wfl, \"Can't access %s %s `%s%s.%s' from `%s'\",\n \t java_accstring_lookup (get_access_flags_from_decl (list)),\n-\t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0), \n+\t (ctor_p ? \"constructor\" : \"method\"),\n+\t (ctor_p ? \n+\t  \"\" : lang_printable_name_wls (TREE_TYPE (TREE_TYPE (list)), 0)), \n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (list)))), \n \t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n       free (fct_name);\n@@ -13117,6 +13125,26 @@ patch_binop (node, wfl_op1, wfl_op2)\n \n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n+  /* If either op<n>_type are NULL, this might be early signs of an\n+     error situation, unless it's too early to tell (in case we're\n+     handling a `+', `==', `!=' or `instanceof'.) We want to set op<n>_type\n+     correctly so the error can be later on reported accurately. */\n+  if (! (code == PLUS_EXPR || code == NE_EXPR \n+\t || code == EQ_EXPR || code == INSTANCEOF_EXPR))\n+    {\n+      tree n;\n+      if (! op1_type)\n+\t{\n+\t  n = java_complete_tree (op1);\n+\t  op1_type = TREE_TYPE (n);\n+\t}\n+      if (! op2_type)\n+\t{\n+\t  n = java_complete_tree (op2);\n+\t  op2_type = TREE_TYPE (n);\n+\t}\n+    }\n+\n   switch (code)\n     {\n     /* 15.16 Multiplicative operators */"}]}