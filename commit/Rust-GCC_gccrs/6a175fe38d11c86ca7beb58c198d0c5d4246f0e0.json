{"sha": "6a175fe38d11c86ca7beb58c198d0c5d4246f0e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExNzVmZTM4ZDExYzg2Y2E3YmViNThjMTk4ZDBjNWQ0MjQ2ZjBlMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-10T23:56:33Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-10T23:56:33Z"}, "message": "000-10-10  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* Makefile.am (LIBSUPCXX_INCLUDES): Adjust.\n\t* libsupc++/include: Remove\n\t* libsupc++/include/*: Move to ...\n\t* libsupc++: Here.\n\t* libsupc++/Makefile.am (glibcppinstall_HEADERS): Install headers.\n\t(glibcppinstalldir): New.\n\n\t* src/Makefile.am (c_base_headers): New.\n\t(c_shadow_headers): New\n\t(c_headers): New.\n\t(myinstallheaders): Correct install issues.\n\t* src/Makefile.in: Regenerate.\n\n\t* Makefile.am (CSHADOW_INCLUDES): Simplify.\n\t* Makefile.in: Regenerate.\n\t* acinclude.m4 (GLIBCPP_ENABLE_SHADOW): Add c_include_dir.\n\t* aclocal.m4: Regenerate.\n\t* mkcheck.in (SRC_DIR): Use it.\n\n\t* include/bits/std_stdexcept.h: And here.\n\t* include/bits/std_ios.h: Change std_exception.h to exception.\n\t* src/locale.cc: And here.\n\t* src/locale-inst.cc: And here.\n\n\t* include/bits/valarray_array.h: And here.\n\t* include/bits/stl_alloc.h: And here.\n\t* include/bits/stl_algobase.h: And here.\n\t* include/bits/pthread_allocimpl.h: And here.\n\t* include/bits/stl_construct.h: Change to std_new.h to new.\n\n\t* include/bits/locale_facets.h: Change std_typeinfo.h to typeinfo.\n\n\t* src/Makefile.am (INCLUDES): Add LIBSUPCXX_INCLUDES.\n\t(headers): Remove duplicated headers.\n\t(std_headers): And here.\n\t* src/Makefile.in: Regenerate.\n\t* libsupc++/Makefile.am (LIBSUPCXX_INCLUDES): Remove.\n\t* libsupc++/Makefile.in: Regenerate.\n\t* Makefile.am (LIBSUPCXX_INCLUDES): Add here.\n\t(AM_MAKEFLAGS): And here.\n\t* Makefile.in: Regenerate.\n\t* include/bits/std_typeinfo.h: Remove.\n\t* include/bits/std_new.h: Remove\n\t* include/bits/std_exception.h: Remove.\n\t* std/new: Remove.\n\t* std/typeinfo: Remove.\n\t* std/exception: Remove.\n\n\t* libio/_G_config.h (__need_ptrdiff_t): Add.\n\n\t* libsupc++/include/new: Change stddef.h to cstddef.\n\t* libsupc++/tinfo.h: Change limits.h to climits.\n\t* libsupc++/pure.cc: Comment out _GNU_LIBRARY_ bits, as this\n\trenders the file uncompilable. Add copyright.\n\n\t* include/c_std/bits/std_cstddef.h: Don't bring wchar_t into std\n\tnamespace, as it is a fundamental type.\n\nFrom-SVN: r36834", "tree": {"sha": "8972ea18ad2f6ad9edb9c86936f52fc48e62148c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8972ea18ad2f6ad9edb9c86936f52fc48e62148c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a175fe38d11c86ca7beb58c198d0c5d4246f0e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a175fe38d11c86ca7beb58c198d0c5d4246f0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a175fe38d11c86ca7beb58c198d0c5d4246f0e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a175fe38d11c86ca7beb58c198d0c5d4246f0e0/comments", "author": null, "committer": null, "parents": [{"sha": "a6863e25381bb2a7b858f01296d2957506b1709d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6863e25381bb2a7b858f01296d2957506b1709d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6863e25381bb2a7b858f01296d2957506b1709d"}], "stats": {"total": 824, "additions": 0, "deletions": 824}, "files": [{"sha": "908d7c467fec0b25c5bc20e955090e5a7fbb454e", "filename": "libstdc++-v3/libsupc++/include/cxxabi.h", "status": "removed", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h?ref=a6863e25381bb2a7b858f01296d2957506b1709d", "patch": "@@ -1,519 +0,0 @@\n-/* new abi support -*- C++ -*-\n-   Copyright (C) 2000\n-   Free Software Foundation, Inc.\n-   Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>  */\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/* This file declares the new abi entry points into the runtime. It is not\n-   normally necessary for user programs to include this header, or use the\n-   entry points directly. However, this header is available should that be\n-   needed.\n-   \n-   Some of the entry points are intended for both C and C++, thus this header\n-   is includable from both C and C++. Though the C++ specific parts are not\n-   available in C, naturally enough.  */\n-\n-#ifndef __CXXABI_H\n-#define __CXXABI_H 1\n-\n-#if defined(__cplusplus) && (!defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-/* These structures only make sense when targeting the new abi, catch a\n-   bonehead error early rather than let the user get very confused.  */\n-#error \"Not targetting the new abi, supply -fnew-abi\"\n-#endif\n-\n-#ifdef __cplusplus\n-\n-// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of\n-// std::size_t and std::ptrdiff_t respectively. This makes us independant of\n-// the conformance level of <cstddef> and whether -fhonor-std was supplied.\n-// <cstddef> is not currently available during compiler building anyway.\n-// Including <stddef.h> would be wrong, as that would rudely place size_t in\n-// the global namespace.\n-\n-#include <typeinfo>\n-\n-namespace __cxxabiv1\n-{\n-\n-/* type information for int, float etc */\n-class __fundamental_type_info\n-  : public std::type_info\n-{\n-public:\n-  virtual ~__fundamental_type_info ();\n-public:\n-  explicit __fundamental_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* type information for array objects */\n-class __array_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-protected:\n-  virtual ~__array_type_info ();\n-public:\n-  explicit __array_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* type information for functions (both member and non-member) */\n-class __function_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__function_type_info ();\n-public:\n-  explicit __function_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-  \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_function_p () const;\n-};\n-\n-/* type information for enumerations */\n-class __enum_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__enum_type_info ();\n-public:\n-  explicit __enum_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* common type information for simple pointers and pointers to member */\n-class __pbase_type_info\n-  : public std::type_info\n-{\n-/* abi defined member variables */\n-public:\n-  unsigned int __qualifier_flags; /* qualification of the target object */\n-  const std::type_info *__pointee;   /* type of pointed to object */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pbase_type_info ();\n-public:\n-  explicit __pbase_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : std::type_info (__n), __qualifier_flags (__quals), __pointee (__type)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  enum __qualifier_masks {\n-    __const_mask = 0x1,\n-    __volatile_mask = 0x2,\n-    __restrict_mask = 0x4,\n-    __incomplete_mask = 0x8,\n-    __incomplete_class_mask = 0x10\n-  };\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_catch (const std::type_info *__thr_type,\n-                           void **__thr_obj,\n-                           unsigned __outer) const;\n-protected:\n-  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                       void **__thr_obj,\n-                                       unsigned __outer) const;\n-};\n-\n-/* type information for simple pointers */\n-class __pointer_type_info\n-  : public __pbase_type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_type_info ();\n-public:\n-  explicit __pointer_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : __pbase_type_info (__n, __quals, __type)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_pointer_p () const;\n-\n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n-\n-/* type information for a pointer to member variable */\n-class __pointer_to_member_type_info\n-  : public __pbase_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  __class_type_info *__context_class;   /* class of the member */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_to_member_type_info ();\n-public:\n-  explicit __pointer_to_member_type_info (const char *__n,\n-                                          int __quals,\n-                                          const std::type_info *__type,\n-                                          __class_type_info *__klass)\n-    : __pbase_type_info (__n, __quals, __type), __context_class (__klass)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n-\n-class __class_type_info;\n-\n-/* helper class for __vmi_class_type */\n-class __base_class_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info *__base;    /* base class type */\n-  long __offset_flags;            /* offset and info */\n-\n-/* implementation defined types */\n-public:\n-  enum __offset_flags_masks {\n-    __virtual_mask = 0x1,\n-    __public_mask = 0x2,\n-    hwm_bit = 2,\n-    offset_shift = 8          /* bits to shift offset by */\n-  };\n-  \n-/* implementation defined member functions */\n-public:\n-  bool __is_virtual_p () const\n-    { return __offset_flags & __virtual_mask; }\n-  bool __is_public_p () const\n-    { return __offset_flags & __public_mask; }\n-  __PTRDIFF_TYPE__ __offset () const\n-    { \n-      // This shift, being of a signed type, is implementation defined. GCC\n-      // implements such shifts as arithmetic, which is what we want.\n-      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> offset_shift;\n-    }\n-};\n-\n-/* type information for a class */\n-class __class_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__class_type_info ();\n-public:\n-  explicit __class_type_info (const char *__n)\n-    : type_info (__n)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  /* sub_kind tells us about how a base object is contained within a derived\n-     object. We often do this lazily, hence the UNKNOWN value. At other times\n-     we may use NOT_CONTAINED to mean not publicly contained. */\n-  enum __sub_kind\n-  {\n-    __unknown = 0,              /* we have no idea */\n-    __not_contained,            /* not contained within us (in some */\n-                                /* circumstances this might mean not contained */\n-                                /* publicly) */\n-    __contained_ambig,          /* contained ambiguously */\n-    \n-    __contained_virtual_mask = __base_class_info::__virtual_mask, /* via a virtual path */\n-    __contained_public_mask = __base_class_info::__public_mask,   /* via a public path */\n-    __contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n-    \n-    __contained_private = __contained_mask,\n-    __contained_public = __contained_mask | __contained_public_mask\n-  };\n-\n-public:  \n-  struct __upcast_result;\n-  struct __dyncast_result;\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;\n-\n-protected:\n-  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n-                           unsigned __outer) const;\n-\n-\n-public:\n-  /* Helper for upcast. See if DST is us, or one of our bases. */\n-  /* Return false if not found, true if found. */\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-\n-public:\n-  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n-     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n-     destination type. SRC2DST indicates how SRC objects might be contained\n-     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n-     virtuality. Returns not_contained for non containment or private\n-     containment. */\n-  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                       const void *__obj_ptr,\n-                                       const __class_type_info *__src_type,\n-                                       const void *__src_ptr) const;\n-\n-public:\n-  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n-     points to a base of our type within the complete object. SRC_TYPE\n-     indicates the static type started from and SRC_PTR points to that base\n-     within the most derived object. Fill in RESULT with what we find. Return\n-     true if we have located an ambiguous match. */\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-public:\n-  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n-     inherited by the type started from -- which is not necessarily the\n-     current type. The current type will be a base of the destination type.\n-     OBJ_PTR points to the current base. */\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-};\n-\n-/* type information for a class with a single non-virtual base */\n-class __si_class_type_info\n-  : public __class_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info *__base_type;\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__si_class_type_info ();\n-public:\n-  explicit __si_class_type_info (const char *__n,\n-                                 const __class_type_info *__base)\n-    : __class_type_info (__n), __base_type (__base)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__sub_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* type information for a class with multiple and/or virtual bases */\n-class __vmi_class_type_info : public __class_type_info {\n-/* abi defined member variables */\n-public:\n-  unsigned int __flags;         /* details about the class heirarchy */\n-  unsigned int __base_count;    /* number of direct bases */\n-  __base_class_info const __base_info[1]; /* array of bases */\n-  /* The array of bases uses the trailing array struct hack\n-     so this class is not constructable with a normal constructor. It is\n-     internally generated by the compiler. */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__vmi_class_type_info ();\n-public:\n-  explicit __vmi_class_type_info (const char *__n,\n-                                  int ___flags)\n-    : __class_type_info (__n), __flags (___flags), __base_count (0)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  enum __flags_masks {\n-    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n-    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n-    non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n-    public_base_mask = 0x8,          /* has public base (direct) */\n-    \n-    __flags_unknown_mask = 0x10\n-  };\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* dynamic cast runtime */\n-extern \"C\"\n-void *__dynamic_cast (const void *__src_ptr,    /* object started from */\n-                      const __class_type_info *__src_type, /* static type of object */\n-                      const __class_type_info *__dst_type, /* desired target type */\n-                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */\n-\n-    /* src2dst has the following possible values\n-       >= 0: src_type is a unique public non-virtual base of dst_type\n-             dst_ptr + src2dst == src_ptr\n-       -1: unspecified relationship\n-       -2: src_type is not a public base of dst_type\n-       -3: src_type is a multiple public non-virtual base of dst_type */\n-\n-/* array ctor/dtor routines */\n-\n-/* allocate and construct array */\n-extern \"C\"\n-void *__cxa_vec_new (__SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     __SIZE_TYPE__ __padding_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *, __SIZE_TYPE__));\n-\n-/* construct array */\n-extern \"C\"\n-void __cxa_vec_ctor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_cctor (void *dest_array,\n-\t\t      void *src_array,\n-\t\t      __SIZE_TYPE__ element_count,\n-\t\t      __SIZE_TYPE__ element_size,\n-\t\t      void (*constructor) (void *, void *),\n-\t\t      void (*destructor) (void *));\n- \n-/* destruct array */\n-extern \"C\"\n-void __cxa_vec_dtor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__destructor) (void *));\n-\n-/* destruct and release array */\n-extern \"C\"\n-void __cxa_vec_delete (void *__array_address,\n-                       __SIZE_TYPE__ __element_size,\n-                       __SIZE_TYPE__ __padding_size,\n-                       void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_delete2 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *));\n-                  \n-extern \"C\"\n-void __cxa_vec_delete3 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *, __SIZE_TYPE__));\n-                  \n-/* demangling routines */\n-\n-extern \"C\" \n-char *__cxa_demangle (const char *__mangled_name,\n-\t\t      char *__output_buffer,\n-\t\t      __SIZE_TYPE__ *__length,\n-\t\t      int *__status);\n-\n-} /* namespace __cxxabiv1 */\n-\n-/* User programs should use the alias `abi'. */\n-namespace abi = __cxxabiv1;\n-\n-#else\n-#endif /* __cplusplus */\n-\n-\n-#endif /* __CXXABI_H */"}, {"sha": "4d35c56c4054ecadc6615534e174c4479aaeba30", "filename": "libstdc++-v3/libsupc++/include/exception", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception?ref=a6863e25381bb2a7b858f01296d2957506b1709d", "patch": "@@ -1,65 +0,0 @@\n-// Exception Handling support header for -*- C++ -*-\n-// Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __EXCEPTION__\n-#define __EXCEPTION__\n-\n-#pragma interface \"exception\"\n-\n-extern \"C++\" {\n-\n-namespace std {\n-\n-class exception {\n-public:\n-  exception () { }\n-  virtual ~exception () { }\n-  virtual const char* what () const;\n-};\n-\n-class bad_exception : public exception {\n-public:\n-  bad_exception () { }\n-  virtual ~bad_exception () { }\n-};\n-\n-typedef void (*terminate_handler) ();\n-typedef void (*unexpected_handler) ();\n-\n-terminate_handler set_terminate (terminate_handler);\n-void terminate () __attribute__ ((__noreturn__));\n-unexpected_handler set_unexpected (unexpected_handler);\n-void unexpected () __attribute__ ((__noreturn__));\n-bool uncaught_exception ();\n-\n-} // namespace std\n-\n-} // extern \"C++\"\n-\n-#endif"}, {"sha": "cbb8d107acff183f8d109e5d341ff9fd00cab464", "filename": "libstdc++-v3/libsupc++/include/new", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew?ref=a6863e25381bb2a7b858f01296d2957506b1709d", "patch": "@@ -1,68 +0,0 @@\n-// The -*- C++ -*- dynamic memory management header.\n-// Copyright (C) 1994, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __NEW__\n-#define __NEW__\n-\n-#pragma interface \"new\"\n-#include <stddef.h>\n-#include <exception>\n-\n-extern \"C++\" {\n-\n-namespace std {\n-\n-  class bad_alloc : public exception {\n-  public:\n-    virtual const char* what() const throw() { return \"bad_alloc\"; }\n-  };\n-\n-  struct nothrow_t {};\n-  extern const nothrow_t nothrow;\n-  typedef void (*new_handler)();\n-  new_handler set_new_handler (new_handler);\n-\n-} // namespace std\n-\n-// replaceable signatures\n-void *operator new (size_t) throw (std::bad_alloc);\n-void *operator new[] (size_t) throw (std::bad_alloc);\n-void operator delete (void *) throw();\n-void operator delete[] (void *) throw();\n-void *operator new (size_t, const std::nothrow_t&) throw();\n-void *operator new[] (size_t, const std::nothrow_t&) throw();\n-void operator delete (void *, const std::nothrow_t&) throw();\n-void operator delete[] (void *, const std::nothrow_t&) throw();\n-\n-// default placement versions of operator new\n-inline void *operator new(size_t, void *place) throw() { return place; }\n-inline void *operator new[](size_t, void *place) throw() { return place; }\n-} // extern \"C++\"\n-\n-#endif"}, {"sha": "cb1fa4cb5caa3becee3728a9a79acb64649d8205", "filename": "libstdc++-v3/libsupc++/include/new.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h?ref=a6863e25381bb2a7b858f01296d2957506b1709d", "patch": "@@ -1,38 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// Copyright (C) 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __NEW_H__\n-#define __NEW_H__\n-\n-#include <new>\n-\n-using std::new_handler;\n-using std::set_new_handler;\n-\n-#endif // __NEW_H__"}, {"sha": "91f0de2c720c8b7885685bdb2ffc9f34e7c1a55b", "filename": "libstdc++-v3/libsupc++/include/typeinfo", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6863e25381bb2a7b858f01296d2957506b1709d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo?ref=a6863e25381bb2a7b858f01296d2957506b1709d", "patch": "@@ -1,134 +0,0 @@\n-// RTTI support for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// __GXX_ABI_VERSION distinguishes the ABI that is being used. Values <100\n-// indicate the `old' abi, which grew as C++ was defined. Values >=100\n-// indicate the `new' abi, which is a cross vendor C++ abi, documented at\n-// `http://reality.sgi.com/dehnert_engr/cxx/'.\n-\n-#ifndef __TYPEINFO__\n-#define __TYPEINFO__\n-\n-#pragma interface \"typeinfo\"\n-\n-#include <exception>\n-\n-extern \"C++\" {\n-\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-namespace __cxxabiv1\n-{\n-  class __class_type_info;\n-} // namespace __cxxabiv1\n-#endif\n-\n-namespace std {\n-\n-class type_info {\n-public:\n-  // Destructor. Being the first non-inline virtual function, this controls in\n-  // which translation unit the vtable is emitted. The compiler makes use of\n-  // that information to know where to emit the runtime-mandated type_info\n-  // structures in the new-abi.\n-  virtual ~type_info ();\n-\n-private:\n-  // Assigning type_info is not supported.  made private.\n-  type_info& operator= (const type_info&);\n-  type_info (const type_info&);\n-\n-protected:\n-  const char *__name;\n-\n-protected:\n-  explicit type_info (const char *__n): __name (__n) { }\n-\n-public:\n-  // the public interface\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-  // In old abi, there can be multiple instances of a type_info object for one\n-  // type. Uniqueness must use the _name value, not object address.\n-  bool before (const type_info& arg) const;\n-  const char* name () const\n-    { return __name; }\n-  bool operator== (const type_info& __arg) const;\n-  bool operator!= (const type_info& __arg) const\n-    { return !operator== (__arg); }\n-\n-#else\n-  // In new abi we can rely on type_info's NTBS being unique,\n-  // and therefore address comparisons are sufficient.\n-  bool before (const type_info& __arg) const\n-    { return __name < __arg.__name; }\n-  const char* name () const\n-    { return __name; }\n-  bool operator== (const type_info& __arg) const\n-    { return __name == __arg.__name; }\n-  bool operator!= (const type_info& __arg) const\n-    { return !operator== (__arg); }\n-#endif\n-\n-  // the internal interface\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-public:\n-  // return true if this is a pointer type of some kind\n-  virtual bool __is_pointer_p () const;\n-  // return true if this is a function type\n-  virtual bool __is_function_p () const;\n-\n-  // Try and catch a thrown type. Store an adjusted pointer to the caught type\n-  // in THR_OBJ. If THR_TYPE is not a pointer type, then THR_OBJ points to the\n-  // thrown object. If THR_TYPE is a pointer type, then THR_OBJ is the pointer\n-  // itself. OUTER indicates the number of outer pointers, and whether they\n-  // were const qualified.\n-  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n-                         unsigned __outer) const;\n-\n-  // internally used during catch matching\n-  virtual bool __do_upcast (const __cxxabiv1::__class_type_info *__target,\n-\t\t\t    void **__obj_ptr) const;\n-#endif\n-};\n-\n-class bad_cast : public exception {\n-public:\n-  bad_cast() { }\n-  virtual ~bad_cast() { }\n-};\n-\n-class bad_typeid : public exception {\n- public:\n-  bad_typeid () { }\n-  virtual ~bad_typeid () { }\n-};\n-\n-} // namespace std\n-\n-} // extern \"C++\"\n-#endif"}]}