{"sha": "2c5bfdf70b616ace5c3f5322299ccc9729e08384", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1YmZkZjcwYjYxNmFjZTVjM2Y1MzIyMjk5Y2NjOTcyOWUwODM4NA==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2009-05-28T07:42:52Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2009-05-28T07:42:52Z"}, "message": "re PR middle-end/33699 (missing optimization on const addr area store)\n\n\tPR middle-end/33699\n\t* target.h (struct gcc_target): Fix indentation.  Add\n\tconst_anchor.\n\t* target-def.h (TARGET_CONST_ANCHOR): New macro.\n\t(TARGET_INITIALIZER): Use it.\n\t* cse.c (CHEAPER): Move it up to the other macros.\n\t(insert): Rename this ...\n\t(insert_with_costs): ... to this.  Add cost parameters.  Update\n\tfunction comment.\n\t(insert): New function.  Call insert_with_costs.\n\t(compute_const_anchors, insert_const_anchor, insert_const_anchors,\n\tfind_reg_offset_for_const, try_const_anchors): New functions.\n\t(cse_insn): Call try_const_anchors.  Adjust cost of src_related\n\twhen using a const-anchor.  Call insert_const_anchors.\n\t* config/mips/mips.c (mips_set_mips16_mode): Set\n\ttargetm.const_anchor.\n\t* doc/tm.texi (Misc): Document TARGET_CONST_ANCHOR.\n\ntestsuite/\n\t* gcc.target/mips/const-anchor-1.c: New test.\n\t* gcc.target/mips/const-anchor-2.c: New test.\n\nFrom-SVN: r147944", "tree": {"sha": "b6849b0da1547659fc7e169123e25b958cc36e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6849b0da1547659fc7e169123e25b958cc36e69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c5bfdf70b616ace5c3f5322299ccc9729e08384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5bfdf70b616ace5c3f5322299ccc9729e08384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c5bfdf70b616ace5c3f5322299ccc9729e08384", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5bfdf70b616ace5c3f5322299ccc9729e08384/comments", "author": null, "committer": null, "parents": [{"sha": "51fb7760dd6fcad1570ef1462459136cefb9c8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51fb7760dd6fcad1570ef1462459136cefb9c8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51fb7760dd6fcad1570ef1462459136cefb9c8f0"}], "stats": {"total": 315, "additions": 303, "deletions": 12}, "files": [{"sha": "19324c74c2b8fa70de6a47eba204561eedaf8d24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -1,3 +1,23 @@\n+2009-05-28  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\tPR middle-end/33699\n+\t* target.h (struct gcc_target): Fix indentation.  Add\n+\tconst_anchor.\n+\t* target-def.h (TARGET_CONST_ANCHOR): New macro.\n+\t(TARGET_INITIALIZER): Use it.\n+\t* cse.c (CHEAPER): Move it up to the other macros.\n+\t(insert): Rename this ...\n+\t(insert_with_costs): ... to this.  Add cost parameters.  Update\n+\tfunction comment.\n+\t(insert): New function.  Call insert_with_costs.\n+\t(compute_const_anchors, insert_const_anchor, insert_const_anchors,\n+\tfind_reg_offset_for_const, try_const_anchors): New functions.\n+\t(cse_insn): Call try_const_anchors.  Adjust cost of src_related\n+\twhen using a const-anchor.  Call insert_const_anchors.\n+\t* config/mips/mips.c (mips_set_mips16_mode): Set\n+\ttargetm.const_anchor.\n+\t* doc/tm.texi (Misc): Document TARGET_CONST_ANCHOR.\n+\n 2009-05-28  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* tree-inline.c (remap_decls): Enable nonlocalized variables"}, {"sha": "50a47e9bd5e2a710dfa1cf6c286e816c69e960f6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -13928,6 +13928,8 @@ mips_set_mips16_mode (int mips16_p)\n       targetm.min_anchor_offset = 0;\n       targetm.max_anchor_offset = 127;\n \n+      targetm.const_anchor = 0;\n+\n       if (flag_pic && !TARGET_OLDABI)\n \tsorry (\"MIPS16 PIC for ABIs other than o32 and o64\");\n \n@@ -13955,6 +13957,8 @@ mips_set_mips16_mode (int mips16_p)\n \n       targetm.min_anchor_offset = -32768;\n       targetm.max_anchor_offset = 32767;\n+\n+      targetm.const_anchor = 0x8000;\n     }\n \n   /* (Re)initialize MIPS target internals for new ISA.  */"}, {"sha": "8e37b64ecbb683dec4a5405e365b636ca334335b", "filename": "gcc/cse.c", "status": "modified", "additions": 229, "deletions": 11, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -502,6 +502,11 @@ struct table_elt\n \n #define REGNO_QTY_VALID_P(N) (REG_QTY (N) >= 0)\n \n+/* Compare table_elt X and Y and return true iff X is cheaper than Y.  */\n+\n+#define CHEAPER(X, Y) \\\n+ (preferable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n+\n static struct table_elt *table[HASH_SIZE];\n \n /* Chain of `struct table_elt's made so far for this function\n@@ -563,6 +568,8 @@ static void remove_pseudo_from_table (rtx, unsigned);\n static struct table_elt *lookup (rtx, unsigned, enum machine_mode);\n static struct table_elt *lookup_for_remove (rtx, unsigned, enum machine_mode);\n static rtx lookup_as_function (rtx, enum rtx_code);\n+static struct table_elt *insert_with_costs (rtx, struct table_elt *, unsigned,\n+\t\t\t\t\t    enum machine_mode, int, int);\n static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n \t\t\t\t enum machine_mode);\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n@@ -1213,6 +1220,174 @@ insert_regs (rtx x, struct table_elt *classp, int modified)\n     return mention_regs (x);\n }\n \f\n+\n+/* Compute upper and lower anchors for CST.  Also compute the offset of CST\n+   from these anchors/bases such that *_BASE + *_OFFS = CST.  Return false iff\n+   CST is equal to an anchor.  */\n+\n+static bool\n+compute_const_anchors (rtx cst,\n+\t\t       HOST_WIDE_INT *lower_base, HOST_WIDE_INT *lower_offs,\n+\t\t       HOST_WIDE_INT *upper_base, HOST_WIDE_INT *upper_offs)\n+{\n+  HOST_WIDE_INT n = INTVAL (cst);\n+\n+  *lower_base = n & ~(targetm.const_anchor - 1);\n+  if (*lower_base == n)\n+    return false;\n+\n+  *upper_base =\n+    (n + (targetm.const_anchor - 1)) & ~(targetm.const_anchor - 1);\n+  *upper_offs = n - *upper_base;\n+  *lower_offs = n - *lower_base;\n+  return true;\n+}\n+\n+/* Insert the equivalence between ANCHOR and (REG + OFF) in mode MODE.  */\n+\n+static void\n+insert_const_anchor (HOST_WIDE_INT anchor, rtx reg, HOST_WIDE_INT offs,\n+\t\t     enum machine_mode mode)\n+{\n+  struct table_elt *elt;\n+  unsigned hash;\n+  rtx anchor_exp;\n+  rtx exp;\n+\n+  anchor_exp = GEN_INT (anchor);\n+  hash = HASH (anchor_exp, mode);\n+  elt = lookup (anchor_exp, hash, mode);\n+  if (!elt)\n+    elt = insert (anchor_exp, NULL, hash, mode);\n+\n+  exp = plus_constant (reg, offs);\n+  /* REG has just been inserted and the hash codes recomputed.  */\n+  mention_regs (exp);\n+  hash = HASH (exp, mode);\n+\n+  /* Use the cost of the register rather than the whole expression.  When\n+     looking up constant anchors we will further offset the corresponding\n+     expression therefore it does not make sense to prefer REGs over\n+     reg-immediate additions.  Prefer instead the oldest expression.  Also\n+     don't prefer pseudos over hard regs so that we derive constants in\n+     argument registers from other argument registers rather than from the\n+     original pseudo that was used to synthesize the constant.  */\n+  insert_with_costs (exp, elt, hash, mode, COST (reg), 1);\n+}\n+\n+/* The constant CST is equivalent to the register REG.  Create\n+   equivalences between the two anchors of CST and the corresponding\n+   register-offset expressions using REG.  */\n+\n+static void\n+insert_const_anchors (rtx reg, rtx cst, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT lower_base, lower_offs, upper_base, upper_offs;\n+\n+  if (!compute_const_anchors (cst, &lower_base, &lower_offs,\n+\t\t\t      &upper_base, &upper_offs))\n+      return;\n+\n+  /* Ignore anchors of value 0.  Constants accessible from zero are\n+     simple.  */\n+  if (lower_base != 0)\n+    insert_const_anchor (lower_base, reg, -lower_offs, mode);\n+\n+  if (upper_base != 0)\n+    insert_const_anchor (upper_base, reg, -upper_offs, mode);\n+}\n+\n+/* We need to express ANCHOR_ELT->exp + OFFS.  Walk the equivalence list of\n+   ANCHOR_ELT and see if offsetting any of the entries by OFFS would create a\n+   valid expression.  Return the cheapest and oldest of such expressions.  In\n+   *OLD, return how old the resulting expression is compared to the other\n+   equivalent expressions.  */\n+\n+static rtx\n+find_reg_offset_for_const (struct table_elt *anchor_elt, HOST_WIDE_INT offs,\n+\t\t\t   unsigned *old)\n+{\n+  struct table_elt *elt;\n+  unsigned idx;\n+  struct table_elt *match_elt;\n+  rtx match;\n+\n+  /* Find the cheapest and *oldest* expression to maximize the chance of\n+     reusing the same pseudo.  */\n+\n+  match_elt = NULL;\n+  match = NULL_RTX;\n+  for (elt = anchor_elt->first_same_value, idx = 0;\n+       elt;\n+       elt = elt->next_same_value, idx++)\n+    {\n+      if (match_elt && CHEAPER (match_elt, elt))\n+\treturn match;\n+\n+      if (REG_P (elt->exp)\n+\t  || (GET_CODE (elt->exp) == PLUS\n+\t      && REG_P (XEXP (elt->exp, 0))\n+\t      && GET_CODE (XEXP (elt->exp, 1)) == CONST_INT))\n+\t{\n+\t  rtx x;\n+\n+\t  /* Ignore expressions that are no longer valid.  */\n+\t  if (!REG_P (elt->exp) && !exp_equiv_p (elt->exp, elt->exp, 1, false))\n+\t    continue;\n+\n+\t  x = plus_constant (elt->exp, offs);\n+\t  if (REG_P (x)\n+\t      || (GET_CODE (x) == PLUS\n+\t\t  && IN_RANGE (INTVAL (XEXP (x, 1)),\n+\t\t\t       -targetm.const_anchor,\n+\t\t\t       targetm.const_anchor - 1)))\n+\t    {\n+\t      match = x;\n+\t      match_elt = elt;\n+\t      *old = idx;\n+\t    }\n+\t}\n+    }\n+\n+  return match;\n+}\n+\n+/* Try to express the constant SRC_CONST using a register+offset expression\n+   derived from a constant anchor.  Return it if successful or NULL_RTX,\n+   otherwise.  */\n+\n+static rtx\n+try_const_anchors (rtx src_const, enum machine_mode mode)\n+{\n+  struct table_elt *lower_elt, *upper_elt;\n+  HOST_WIDE_INT lower_base, lower_offs, upper_base, upper_offs;\n+  rtx lower_anchor_rtx, upper_anchor_rtx;\n+  rtx lower_exp = NULL_RTX, upper_exp = NULL_RTX;\n+  unsigned lower_old, upper_old;\n+\n+  if (!compute_const_anchors (src_const, &lower_base, &lower_offs,\n+\t\t\t      &upper_base, &upper_offs))\n+    return NULL_RTX;\n+\n+  lower_anchor_rtx = GEN_INT (lower_base);\n+  upper_anchor_rtx = GEN_INT (upper_base);\n+  lower_elt = lookup (lower_anchor_rtx, HASH (lower_anchor_rtx, mode), mode);\n+  upper_elt = lookup (upper_anchor_rtx, HASH (upper_anchor_rtx, mode), mode);\n+\n+  if (lower_elt)\n+    lower_exp = find_reg_offset_for_const (lower_elt, lower_offs, &lower_old);\n+  if (upper_elt)\n+    upper_exp = find_reg_offset_for_const (upper_elt, upper_offs, &upper_old);\n+\n+  if (!lower_exp)\n+    return upper_exp;\n+  if (!upper_exp)\n+    return lower_exp;\n+\n+  /* Return the older expression.  */\n+  return (upper_old > lower_old ? upper_exp : lower_exp);\n+}\n+\f\n /* Look in or update the hash table.  */\n \n /* Remove table element ELT from use in the table.\n@@ -1380,11 +1555,11 @@ lookup_as_function (rtx x, enum rtx_code code)\n   return 0;\n }\n \n-/* Insert X in the hash table, assuming HASH is its hash code\n-   and CLASSP is an element of the class it should go in\n-   (or 0 if a new class should be made).\n-   It is inserted at the proper position to keep the class in\n-   the order cheapest first.\n+/* Insert X in the hash table, assuming HASH is its hash code and\n+   CLASSP is an element of the class it should go in (or 0 if a new\n+   class should be made).  COST is the code of X and reg_cost is the\n+   cost of registers in X.  It is inserted at the proper position to\n+   keep the class in the order cheapest first.\n \n    MODE is the machine-mode of X, or if X is an integer constant\n    with VOIDmode then MODE is the mode with which X will be used.\n@@ -1404,11 +1579,9 @@ lookup_as_function (rtx x, enum rtx_code code)\n \n    If necessary, update table showing constant values of quantities.  */\n \n-#define CHEAPER(X, Y) \\\n- (preferable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n-\n static struct table_elt *\n-insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mode)\n+insert_with_costs (rtx x, struct table_elt *classp, unsigned int hash,\n+\t\t   enum machine_mode mode, int cost, int reg_cost)\n {\n   struct table_elt *elt;\n \n@@ -1430,8 +1603,8 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n   elt->exp = x;\n   elt->canon_exp = NULL_RTX;\n-  elt->cost = COST (x);\n-  elt->regcost = approx_reg_cost (x);\n+  elt->cost = cost;\n+  elt->regcost = reg_cost;\n   elt->next_same_value = 0;\n   elt->prev_same_value = 0;\n   elt->next_same_hash = table[hash];\n@@ -1566,6 +1739,17 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n   return elt;\n }\n+\n+/* Wrap insert_with_costs by passing the default costs.  */\n+\n+static struct table_elt *\n+insert (rtx x, struct table_elt *classp, unsigned int hash,\n+\tenum machine_mode mode)\n+{\n+  return\n+    insert_with_costs (x, classp, hash, mode, COST (x), approx_reg_cost (x));\n+}\n+\n \f\n /* Given two equivalence classes, CLASS1 and CLASS2, put all the entries from\n    CLASS2 into CLASS1.  This is done when we have reached an insn which makes\n@@ -4253,6 +4437,7 @@ cse_insn (rtx insn)\n       rtx src_eqv_here;\n       rtx src_const = 0;\n       rtx src_related = 0;\n+      bool src_related_is_const_anchor = false;\n       struct table_elt *src_const_elt = 0;\n       int src_cost = MAX_COST;\n       int src_eqv_cost = MAX_COST;\n@@ -4602,6 +4787,19 @@ cse_insn (rtx insn)\n \t}\n #endif /* LOAD_EXTEND_OP */\n \n+      /* Try to express the constant using a register+offset expression\n+\t derived from a constant anchor.  */\n+\n+      if (targetm.const_anchor\n+\t  && !src_related\n+\t  && src_const\n+\t  && GET_CODE (src_const) == CONST_INT)\n+\t{\n+\t  src_related = try_const_anchors (src_const, mode);\n+\t  src_related_is_const_anchor = src_related != NULL_RTX;\n+\t}\n+\n+\n       if (src == src_folded)\n \tsrc_folded = 0;\n \n@@ -4706,6 +4904,18 @@ cse_insn (rtx insn)\n \t    {\n \t      src_related_cost = COST (src_related);\n \t      src_related_regcost = approx_reg_cost (src_related);\n+\n+\t      /* If a const-anchor is used to synthesize a constant that\n+\t\t normally requires multiple instructions then slightly prefer\n+\t\t it over the original sequence.  These instructions are likely\n+\t\t to become redundant now.  We can't compare against the cost\n+\t\t of src_eqv_here because, on MIPS for example, multi-insn\n+\t\t constants have zero cost; they are assumed to be hoisted from\n+\t\t loops.  */\n+\t      if (src_related_is_const_anchor\n+\t\t  && src_related_cost == src_cost\n+\t\t  && src_eqv_here)\n+\t\tsrc_related_cost--;\n \t    }\n \t}\n \n@@ -5440,6 +5650,14 @@ cse_insn (rtx insn)\n \telt = insert (dest, sets[i].src_elt,\n \t\t      sets[i].dest_hash, GET_MODE (dest));\n \n+\t/* If this is a constant, insert the constant anchors with the\n+\t   equivalent register-offset expressions using register DEST.  */\n+\tif (targetm.const_anchor\n+\t    && REG_P (dest)\n+\t    && SCALAR_INT_MODE_P (GET_MODE (dest))\n+\t    && GET_CODE (sets[i].src_elt->exp) == CONST_INT)\n+\t  insert_const_anchors (dest, sets[i].src_elt->exp, GET_MODE (dest));\n+\n \telt->in_memory = (MEM_P (sets[i].inner_dest)\n \t\t\t  && !MEM_READONLY_P (sets[i].inner_dest));\n "}, {"sha": "552d5c9ef8a686ba6a7a4c3b77eac2c0e1728d92", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -10852,3 +10852,21 @@ cannot safely move arguments from the registers in which they are passed\n to the stack.  Therefore, this hook should return true in general, but\n false for naked functions.  The default implementation always returns true.\n @end deftypefn\n+\n+\n+@deftypevr {Target Hook} {unsigned HOST_WIDE_INT} TARGET_CONST_ANCHOR\n+On some architectures it can take multiple instructions to synthesize\n+a constant.  If there is another constant already in a register that\n+is close enough in value then it is preferable that the new constant\n+is computed from this register using immediate addition or\n+substraction.  We accomplish this through CSE.  Besides the value of\n+the constant we also add a lower and an upper constant anchor to the\n+available expressions.  These are then queried when encountering new\n+constants.  The anchors are computed by rounding the constant up and\n+down to a multiple of the value of @code{TARGET_CONST_ANCHOR}.\n+@code{TARGET_CONST_ANCHOR} should be the maximum positive value\n+accepted by immediate-add plus one.  We currently assume that the\n+value of @code{TARGET_CONST_ANCHOR} is a power of 2.  For example, on\n+MIPS, where add-immediate takes a 16-bit signed value,\n+@code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value\n+is zero, which disables this optimization.  @end deftypevr"}, {"sha": "8aeebeb80f142c6f9339cb1c58e9608f7dd0542b", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -423,6 +423,7 @@\n \n /* In cse.c.  */\n #define TARGET_ADDRESS_COST default_address_cost\n+#define TARGET_CONST_ANCHOR 0\n \n /* In builtins.c.  */\n #define TARGET_INIT_BUILTINS hook_void_void\n@@ -922,6 +923,7 @@\n   TARGET_STACK_PROTECT_FAIL,\t\t\t\\\n   TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n   TARGET_VALID_DLLIMPORT_ATTRIBUTE_P,\t\t\\\n+  TARGET_CONST_ANCHOR,\t\t\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_INVALID_CONVERSION,\t\t\t\\\n   TARGET_INVALID_UNARY_OP,\t\t\t\\"}, {"sha": "0d60b1134ce2e75f22093cbea662036ad7ab5ed3", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -481,7 +481,7 @@ struct gcc_target\n \n     /* Target builtin that implements vector permute.  */\n     tree (* builtin_vec_perm) (tree, tree*);\n-} vectorize;\n+  } vectorize;\n \n   /* The initial value of target_flags.  */\n   int default_target_flags;\n@@ -825,6 +825,10 @@ struct gcc_target\n      checks to  handle_dll_attribute ().  */\n   bool (* valid_dllimport_attribute_p) (const_tree decl);\n \n+  /* If non-zero, align constant anchors in CSE to a multiple of this\n+     value.  */\n+  unsigned HOST_WIDE_INT const_anchor;\n+\n   /* Functions relating to calls - argument passing, returns, etc.  */\n   struct calls {\n     bool (*promote_function_args) (const_tree fntype);"}, {"sha": "54fa22c0d744189e767288ab8daaa51772dd1060", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -1,3 +1,9 @@\n+2009-05-28  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\tPR middle-end/33699\n+\t* gcc.target/mips/const-anchor-1.c: New test.\n+\t* gcc.target/mips/const-anchor-2.c: New test.\n+\n 2009-05-27  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/initlist15.C: New."}, {"sha": "66981671d02e83b40b01d64893e4703cf8a54a19", "filename": "gcc/testsuite/gcc.target/mips/const-anchor-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-1.c?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -0,0 +1,10 @@\n+/* Derive a constant (0x1233ffff) from an intermediate value\n+   (0x1234000) used to build another constant.  */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler-not \"0x12330000|305332224\" } } */\n+/* { dg-final { scan-assembler \"addiu\\t\\\\\\$5,\\\\\\$\\[0-9\\]*,-1\" } } */\n+\n+NOMIPS16 void f ()\n+{\n+  g (0x12340001, 0x1233ffff);\n+}"}, {"sha": "ccb89bb766c84b17c8be625dbf2dbafc9ba6d7ed", "filename": "gcc/testsuite/gcc.target/mips/const-anchor-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5bfdf70b616ace5c3f5322299ccc9729e08384/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fconst-anchor-2.c?ref=2c5bfdf70b616ace5c3f5322299ccc9729e08384", "patch": "@@ -0,0 +1,9 @@\n+/* Derive a constant (0x30001) from another constant.  */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler-not \"0x300000|196608\" } } */\n+/* { dg-final { scan-assembler \"addiu\\t\\\\\\$5,\\\\\\$\\[0-9\\]*,32763\" } } */\n+\n+NOMIPS16 void f ()\n+{\n+  g (0x28006, 0x30001);\n+}"}]}