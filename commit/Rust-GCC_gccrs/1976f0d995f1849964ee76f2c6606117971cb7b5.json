{"sha": "1976f0d995f1849964ee76f2c6606117971cb7b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3NmYwZDk5NWYxODQ5OTY0ZWU3NmYyYzY2MDYxMTc5NzFjYjdiNQ==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2003-05-05T22:28:16Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2003-05-05T22:28:16Z"}, "message": "stl_threads.h (_Atomic_swap): Kill it...\n\n\t* include/bits/stl_threads.h (_Atomic_swap): Kill it...\n\t(_Swap_lock_struct<>): ...and the horse it rode in on.\n\t* src/globals.cc (_Swap_lock_struct<>): Likewise.\n\t* include/ext/stl_rope.h (_Rope_RopeRep<>::_M_c_string_lock): New\n\tmember to support...\n\t* include/ext/ropeimpl.h (rope<>::c_str): Follow *all* memory\n\tvisibility rules related to POSIX threads.\n\t* testsuite/thread/pthread7-rope.cc: New test.\n\nFrom-SVN: r66507", "tree": {"sha": "a1558f18a5fa30b3f3cba3a01604fd6338b293f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1558f18a5fa30b3f3cba3a01604fd6338b293f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1976f0d995f1849964ee76f2c6606117971cb7b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1976f0d995f1849964ee76f2c6606117971cb7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1976f0d995f1849964ee76f2c6606117971cb7b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1976f0d995f1849964ee76f2c6606117971cb7b5/comments", "author": null, "committer": null, "parents": [{"sha": "6ccfe27ca7807e9e467134b4e6695e3659fc5521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ccfe27ca7807e9e467134b4e6695e3659fc5521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ccfe27ca7807e9e467134b4e6695e3659fc5521"}], "stats": {"total": 185, "additions": 134, "deletions": 51}, "files": [{"sha": "c2180150d74ba9422e704ed8f146953cbd4568cd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -1,3 +1,15 @@\n+2003-05-05  Loren J. Rittle  <ljrittle@acm.org>\n+\t    (Inspired by an alternate patch from Danny Smith.)\n+\n+\t* include/bits/stl_threads.h (_Atomic_swap): Kill it...\n+\t(_Swap_lock_struct<>): ...and the horse it rode in on.\n+\t* src/globals.cc (_Swap_lock_struct<>): Likewise.\n+\t* include/ext/stl_rope.h (_Rope_RopeRep<>::_M_c_string_lock): New\n+\tmember to support...\n+\t* include/ext/ropeimpl.h (rope<>::c_str): Follow *all* memory\n+\tvisibility rules related to POSIX threads.\n+\t* testsuite/thread/pthread7-rope.cc: New test.\n+\n 2003-05-04  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* testsuite/21_strings/basic_string/find/char/3.cc: New"}, {"sha": "53baf256184849a44d5586f84247cd994b7d3c7b", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -97,35 +97,6 @@ namespace std\n       return __tmp;\n     }\n   };\n-\n-  // Atomic swap on unsigned long\n-  // This is guaranteed to behave as though it were atomic only if all\n-  // possibly concurrent updates use _Atomic_swap.\n-  // In some cases the operation is emulated with a lock.\n-#if defined (__GTHREAD_MUTEX_INIT)\n-  // This could be optimized to use the atomicity.h abstraction layer.\n-  // vyzo: simple _Atomic_swap implementation following the guidelines above\n-  // We use a template here only to get a unique initialized instance.\n-  template<int __dummy>\n-    struct _Swap_lock_struct \n-    { static __gthread_mutex_t _S_swap_lock; };\n-\n-  template<int __dummy>\n-    __gthread_mutex_t\n-    _Swap_lock_struct<__dummy>::_S_swap_lock = __GTHREAD_MUTEX_INIT;\n-\n-  // This should be portable, but performance is expected to be quite\n-  // awful.  This really needs platform specific code.\n-  inline unsigned long \n-  _Atomic_swap(unsigned long * __p, unsigned long __q) \n-  {\n-    __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n-    unsigned long __result = *__p;\n-    *__p = __q;\n-    __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n-    return __result;\n-  }\n-#endif\n } //namespace std\n \n   // Locking class.  Note that this class *does not have a"}, {"sha": "8be840eadd78f20cda142dfed6a71e74b2a97511", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -1450,26 +1450,17 @@ const _CharT* rope<_CharT,_Alloc>::c_str() const {\n \t\t\t\t\t     // but probably fast.\n         return _S_empty_c_str;\n     }\n-    __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n-    if (0 != __old_c_string) return(__old_c_string);\n-    size_t __s = size();\n-    _CharT* __result = _Data_allocate(__s + 1);\n-    _S_flatten(this->_M_tree_ptr, __result);\n-    __result[__s] = _S_eos((_CharT*)0);\n-#   ifdef __GC\n-\t_M_tree_ptr->_M_c_string = __result;\n-#   else\n-      if ((__old_c_string = (__GC_CONST _CharT*)\n-             std::_Atomic_swap((unsigned long *)\n-\t\t\t       (&(this->_M_tree_ptr->_M_c_string)),\n-\t\t\t  (unsigned long)__result)) != 0) {\n-\t// It must have been added in the interim.  Hence it had to have been\n-\t// separately allocated.  Deallocate the old copy, since we just\n-\t// replaced it.\n-\t_Destroy(__old_c_string, __old_c_string + __s + 1);\n-\t_Data_deallocate(__old_c_string, __s + 1);\n+    __gthread_mutex_lock (&this->_M_tree_ptr->_M_c_string_lock);\n+    __GC_CONST _CharT* __result = this->_M_tree_ptr->_M_c_string;\n+    if (0 == __result)\n+      {\n+\tsize_t __s = size();\n+\t__result = _Data_allocate(__s + 1);\n+\t_S_flatten(this->_M_tree_ptr, __result);\n+\t__result[__s] = _S_eos((_CharT*)0);\n+\tthis->_M_tree_ptr->_M_c_string = __result;\n       }\n-#   endif\n+    __gthread_mutex_unlock (&this->_M_tree_ptr->_M_c_string_lock);\n     return(__result);\n }\n "}, {"sha": "8a7d0b7d5d2c053ab66731869aaeddaeb06773f3", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -483,6 +483,7 @@ struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n     bool _M_is_balanced:8;\n     unsigned char _M_depth;\n     __GC_CONST _CharT* _M_c_string;\n+    __gthread_mutex_t _M_c_string_lock;\n                         /* Flattened version of string, if needed.  */\n                         /* typically 0.                             */\n                         /* If it's not 0, then the memory is owned  */\n@@ -498,7 +499,12 @@ struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n           _Refcount_Base(1),\n #         endif\n           _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0)\n+#ifdef __GTHREAD_MUTEX_INIT\n+\t  , _M_c_string_lock (__GTHREAD_MUTEX_INIT)\n     { }\n+#else\n+    { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }\n+#endif\n #   ifdef __GC\n         void _M_incr () {}\n #   endif"}, {"sha": "31c1371ad58360cc89849eee1109612bf19cda45", "filename": "libstdc++-v3/src/globals.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -227,9 +227,6 @@ namespace __gnu_cxx\n   // allows static initialization of these objects on systems that need a\n   // function call to initialize a mutex.  For example, see stl_threads.h.\n #ifdef __GTHREAD_MUTEX_INIT\n-  // Need to provide explicit instantiations of static data for\n-  // systems with broken weak linkage support.\n-  template __gthread_mutex_t _Swap_lock_struct<0>::_S_swap_lock;\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n   __gthread_once_t _GLIBCPP_once = __GTHREAD_ONCE_INIT;\n   __gthread_mutex_t _GLIBCPP_mutex;"}, {"sha": "12e71efa28505c76edadbb397b18f40db4a29146", "filename": "libstdc++-v3/testsuite/thread/pthread7-rope.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread7-rope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1976f0d995f1849964ee76f2c6606117971cb7b5/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread7-rope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread7-rope.cc?ref=1976f0d995f1849964ee76f2c6606117971cb7b5", "patch": "@@ -0,0 +1,106 @@\n+// 2003-05-03  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* } }\n+// { dg-options \"-DDEBUG_ASSERT -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* } }\n+// { dg-options \"-DDEBUG_ASSERT -pthreads\" { target *-*-solaris* } }\n+\n+#include <ext/rope>\n+#include <cstring>\n+#include <testsuite_hooks.h>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+\n+const int max_thread_count = 4;\n+const int max_loop_count = 10000;\n+\n+__gnu_cxx::crope foo4;\n+\n+void* thread_main (void *)\n+{\n+  // To see a problem with gcc 3.3 and before, set a break point here.\n+  // Single step through c_str implementation, call sched_yield after\n+  // capture of NULL __old_c_string in any thread.  Single step\n+  // through another thread past that same point.  Now, one thread\n+  // will receive a bad pointer return.  Adding dummy sched_yield\n+  // should never change program semantics under POSIX threads.\n+  const char* data4 = foo4.c_str();\n+\n+  // Please note that the memory leak in the rope implementation with\n+  // this test case, existed before and after fixing this bug...\n+\n+  VERIFY( !std::strcmp (data4, \"barbazbonglehellohellohello\") );\n+}\n+\n+int\n+main()\n+{\n+  pthread_t tid[max_thread_count];\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (max_thread_count);\n+#endif\n+\n+  __gnu_cxx::crope foo;\n+  foo += \"bar\";\n+  foo += \"baz\";\n+  foo += \"bongle\";\n+  const char* data = foo.c_str();\n+  VERIFY( !std::strcmp (data, \"barbazbongle\") );\n+\n+  const char* data2;\n+  {\n+    __gnu_cxx::crope foo2;\n+    foo2 += \"bar2\";\n+    foo2 += \"baz2\";\n+    foo2 += \"bongle2\";\n+    data2 = foo2.c_str();\n+    VERIFY( !std::strcmp (data2, \"bar2baz2bongle2\") );\n+  }\n+\n+  __gnu_cxx::crope foo3 (\"hello\");\n+  const char* data3 = foo3.c_str();\n+  VERIFY( !std::strcmp (data3, \"hello\") );\n+\n+  for (int j = 0; j < max_loop_count; j++)\n+    {\n+      foo4 = foo;\n+      foo4 += foo3;\n+      foo4 += foo3;\n+      foo4 += foo3;\n+\n+      for (int i = 0; i < max_thread_count; i++)\n+\tpthread_create (&tid[i], NULL, thread_main, 0);\n+\n+      for (int i = 0; i < max_thread_count; i++)\n+\tpthread_join (tid[i], NULL);\n+    }\n+\n+  // Nothing says the data will be trashed at this point...\n+  VERIFY( std::strcmp (data2, \"bar2baz2bongle2\") );\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}]}