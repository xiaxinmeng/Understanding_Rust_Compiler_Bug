{"sha": "7b45d0dfeb5f855723a2603bb5ea6585438f224c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I0NWQwZGZlYjVmODU1NzIzYTI2MDNiYjVlYTY1ODU0MzhmMjI0Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-12-16T15:57:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-12-16T15:57:43Z"}, "message": "re PR c/78408 (C loop initial declarations generate wrong code)\n\n\tPR c/78408\n\t* tree-ssa-ccp.c: Include tree-dfa.h.\n\t(optimize_memcpy): New function.\n\t(pass_fold_builtins::execute): Use it.  Remove useless conditional\n\tbreak after BUILT_IN_VA_*.\n\n\t* gcc.dg/pr78408-1.c: New test.\n\t* gcc.dg/pr78408-2.c: New test.\n\nFrom-SVN: r243753", "tree": {"sha": "1d05f12a040e606bb996ebd77f4df26222ed6d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d05f12a040e606bb996ebd77f4df26222ed6d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b45d0dfeb5f855723a2603bb5ea6585438f224c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b45d0dfeb5f855723a2603bb5ea6585438f224c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b45d0dfeb5f855723a2603bb5ea6585438f224c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b45d0dfeb5f855723a2603bb5ea6585438f224c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b520e8d4a24036508ad59eadf725437d2717a84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b520e8d4a24036508ad59eadf725437d2717a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b520e8d4a24036508ad59eadf725437d2717a84"}], "stats": {"total": 278, "additions": 275, "deletions": 3}, "files": [{"sha": "84797ad7acb483a3df73c53e20b616ee61bf5a94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -1,3 +1,11 @@\n+2016-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/78408\n+\t* tree-ssa-ccp.c: Include tree-dfa.h.\n+\t(optimize_memcpy): New function.\n+\t(pass_fold_builtins::execute): Use it.  Remove useless conditional\n+\tbreak after BUILT_IN_VA_*.\n+\n 2016-12-16  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/78819"}, {"sha": "e72a49b637545a8f9f443442b9a4cbcce6085477", "filename": "gcc/sanopt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -802,6 +802,9 @@ sanitize_asan_mark_poison (void)\n \t  if (maybe_contains_asan_check (stmt))\n \t    {\n \t      bitmap_set_bit (with_check, bb->index);\n+if (dump_file)\n+fprintf (dump_file, \"setting bit %d\\n\", bb->index);\n+\n \t      break;\n \t    }\n \t}"}, {"sha": "dc64b2c7f6db991a97048749b38c6059a2bf7f78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -1,3 +1,9 @@\n+2016-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/78408\n+\t* gcc.dg/pr78408-1.c: New test.\n+\t* gcc.dg/pr78408-2.c: New test.\n+\n 2016-12-16  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/78819"}, {"sha": "a7a772a2be73741bcdce92e1f007597e85776227", "filename": "gcc/testsuite/gcc.dg/pr78408-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-1.c?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -0,0 +1,88 @@\n+/* PR c/78408 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab1-details\" } */\n+/* { dg-final { scan-tree-dump-times \"after previous\" 17 \"fab1\" } } */\n+\n+struct S { char a[32]; };\n+struct T { char a[65536]; };\n+void bar (int, struct S *, struct S *, struct T *, struct T *);\n+void baz (char *, char *);\n+\n+void\n+f1 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  a = b = (struct S) {};\n+  c = d = (struct T) {};\n+  bar (1, &a, &b, &c, &d);\n+}\n+\n+void\n+f2 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  b = (struct S) {};\n+  a = b;\n+  d = (struct T) {};\n+  c = d;\n+  bar (2, &a, &b, &c, &d);\n+}\n+\n+void\n+f3 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  __builtin_memset (&b, 0, sizeof (b));\n+  a = b;\n+  __builtin_memset (&d, 0, sizeof (d));\n+  c = d;\n+  bar (3, &a, &b, &c, &d);\n+}\n+\n+\n+void\n+f4 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  b = (struct S) {};\n+  __builtin_memcpy (&a, &b, sizeof (b));\n+  d = (struct T) {};\n+  __builtin_memcpy (&c, &d, sizeof (d));\n+  bar (4, &a, &b, &c, &d);\n+}\n+\n+void\n+f5 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  __builtin_memset (&b, 0, sizeof (b));\n+  __builtin_memcpy (&a, &b, sizeof (b));\n+  __builtin_memset (&d, 0, sizeof (d));\n+  __builtin_memcpy (&c, &d, sizeof (d));\n+  bar (5, &a, &b, &c, &d);\n+}\n+\n+void\n+f6 (void)\n+{\n+  struct S a, b, e, g;\n+  struct T c, d, f, h;\n+  g = e = a = b = (struct S) {};\n+  h = f = c = d = (struct T) {};\n+  bar (6, &a, &b, &c, &d);\n+  bar (6, &e, &g, &f, &h);\n+}\n+\n+void\n+f7 (void)\n+{\n+  char a[64], b[64];\n+  __builtin_memset (a + 13, 2, 27);\n+  __builtin_memcpy (b + 4, a + 17, 23);\n+  baz (a, b);\n+}"}, {"sha": "7870e4e7ca6ad5ee9eb387240ff3e2b3232c8651", "filename": "gcc/testsuite/gcc.dg/pr78408-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78408-2.c?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -0,0 +1,39 @@\n+/* PR c/78408 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab1-details\" } */\n+/* { dg-final { scan-tree-dump-not \"after previous\" \"fab1\" } } */\n+\n+struct S { char a[32]; };\n+struct T { char a[65536]; };\n+void bar (int, struct S *, struct S *, struct T *, struct T *);\n+void baz (char *, char *);\n+\n+void\n+f1 (void)\n+{\n+  struct S a, b;\n+  struct T c, d;\n+  __builtin_memset (&b, 2, sizeof (b));\n+  a = b;\n+  __builtin_memset (&d, 3, sizeof (d));\n+  c = d;\n+  bar (3, &a, &b, &c, &d);\n+}\n+\n+void\n+f2 (void)\n+{\n+  char a[64], b[64];\n+  __builtin_memset (a + 13, 2, 27);\n+  __builtin_memcpy (b + 4, a + 17, 24);\n+  baz (a, b);\n+}\n+\n+void\n+f3 (void)\n+{\n+  char a[64], b[64];\n+  __builtin_memset (a + 13, 2, 27);\n+  __builtin_memcpy (b + 4, a + 12, 5);\n+  baz (a, b);\n+}"}, {"sha": "fb90d02e9962da458065d12272dcf4f845c8496c", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45d0dfeb5f855723a2603bb5ea6585438f224c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=7b45d0dfeb5f855723a2603bb5ea6585438f224c", "patch": "@@ -143,6 +143,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"optabs-query.h\"\n #include \"tree-ssa-ccp.h\"\n+#include \"tree-dfa.h\"\n \n /* Possible lattice values.  */\n typedef enum\n@@ -2933,6 +2934,119 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   release_ssa_name (lhs);\n }\n \n+/* Optimize\n+   a = {};\n+   b = a;\n+   into\n+   a = {};\n+   b = {};\n+   Similarly for memset (&a, ..., sizeof (a)); instead of a = {};\n+   and/or memcpy (&b, &a, sizeof (a)); instead of b = a;  */\n+\n+static void\n+optimize_memcpy (gimple_stmt_iterator *gsip, tree dest, tree src, tree len)\n+{\n+  gimple *stmt = gsi_stmt (*gsip);\n+  if (gimple_has_volatile_ops (stmt))\n+    return;\n+\n+  tree vuse = gimple_vuse (stmt);\n+  if (vuse == NULL)\n+    return;\n+\n+  gimple *defstmt = SSA_NAME_DEF_STMT (vuse);\n+  tree src2 = NULL_TREE, len2 = NULL_TREE;\n+  HOST_WIDE_INT offset, offset2;\n+  tree val = integer_zero_node;\n+  if (gimple_store_p (defstmt)\n+      && gimple_assign_single_p (defstmt)\n+      && TREE_CODE (gimple_assign_rhs1 (defstmt)) == CONSTRUCTOR\n+      && !gimple_clobber_p (defstmt))\n+    src2 = gimple_assign_lhs (defstmt);\n+  else if (gimple_call_builtin_p (defstmt, BUILT_IN_MEMSET)\n+\t   && TREE_CODE (gimple_call_arg (defstmt, 0)) == ADDR_EXPR\n+\t   && TREE_CODE (gimple_call_arg (defstmt, 1)) == INTEGER_CST)\n+    {\n+      src2 = TREE_OPERAND (gimple_call_arg (defstmt, 0), 0);\n+      len2 = gimple_call_arg (defstmt, 2);\n+      val = gimple_call_arg (defstmt, 1);\n+      /* For non-0 val, we'd have to transform stmt from assignment\n+\t into memset (only if dest is addressable).  */\n+      if (!integer_zerop (val) && is_gimple_assign (stmt))\n+\tsrc2 = NULL_TREE;\n+    }\n+\n+  if (src2 == NULL_TREE)\n+    return;\n+\n+  if (len == NULL_TREE)\n+    len = (TREE_CODE (src) == COMPONENT_REF\n+\t   ? DECL_SIZE_UNIT (TREE_OPERAND (src, 1))\n+\t   : TYPE_SIZE_UNIT (TREE_TYPE (src)));\n+  if (len2 == NULL_TREE)\n+    len2 = (TREE_CODE (src2) == COMPONENT_REF\n+\t    ? DECL_SIZE_UNIT (TREE_OPERAND (src2, 1))\n+\t    : TYPE_SIZE_UNIT (TREE_TYPE (src2)));\n+  if (len == NULL_TREE\n+      || TREE_CODE (len) != INTEGER_CST\n+      || len2 == NULL_TREE\n+      || TREE_CODE (len2) != INTEGER_CST)\n+    return;\n+\n+  src = get_addr_base_and_unit_offset (src, &offset);\n+  src2 = get_addr_base_and_unit_offset (src2, &offset2);\n+  if (src == NULL_TREE\n+      || src2 == NULL_TREE\n+      || offset < offset2)\n+    return;\n+\n+  if (!operand_equal_p (src, src2, 0))\n+    return;\n+\n+  /* [ src + offset2, src + offset2 + len2 - 1 ] is set to val.\n+     Make sure that\n+     [ src + offset, src + offset + len - 1 ] is a subset of that.  */\n+  if (wi::to_offset (len) + (offset - offset2) > wi::to_offset (len2))\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Simplified\\n  \");\n+      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+      fprintf (dump_file, \"after previous\\n  \");\n+      print_gimple_stmt (dump_file, defstmt, 0, dump_flags);\n+    }\n+\n+  /* For simplicity, don't change the kind of the stmt,\n+     turn dest = src; into dest = {}; and memcpy (&dest, &src, len);\n+     into memset (&dest, val, len);\n+     In theory we could change dest = src into memset if dest\n+     is addressable (maybe beneficial if val is not 0), or\n+     memcpy (&dest, &src, len) into dest = {} if len is the size\n+     of dest, dest isn't volatile.  */\n+  if (is_gimple_assign (stmt))\n+    {\n+      tree ctor = build_constructor (TREE_TYPE (dest), NULL);\n+      gimple_assign_set_rhs_from_tree (gsip, ctor);\n+      update_stmt (stmt);\n+    }\n+  else /* If stmt is memcpy, transform it into memset.  */\n+    {\n+      gcall *call = as_a <gcall *> (stmt);\n+      tree fndecl = builtin_decl_implicit (BUILT_IN_MEMSET);\n+      gimple_call_set_fndecl (call, fndecl);\n+      gimple_call_set_fntype (call, TREE_TYPE (fndecl));\n+      gimple_call_set_arg (call, 1, val);\n+      update_stmt (stmt);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"into\\n  \");\n+      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+    }\n+}\n+\n /* A simple pass that attempts to fold all builtin functions.  This pass\n    is run after we've propagated as many constants as we can.  */\n \n@@ -2999,6 +3113,9 @@ pass_fold_builtins::execute (function *fun)\n \t\t      continue;\n \t\t    }\n \t\t}\n+\t      else if (gimple_assign_load_p (stmt) && gimple_store_p (stmt))\n+\t\toptimize_memcpy (&i, gimple_assign_lhs (stmt),\n+\t\t\t\t gimple_assign_rhs1 (stmt), NULL_TREE);\n \t      gsi_next (&i);\n \t      continue;\n \t    }\n@@ -3114,14 +3231,25 @@ pass_fold_builtins::execute (function *fun)\n \t\t\t\t\t\tfalse, false);\n \t\t  break;\n \n+\t\tcase BUILT_IN_MEMCPY:\n+\t\t  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+\t\t      && TREE_CODE (gimple_call_arg (stmt, 0)) == ADDR_EXPR\n+\t\t      && TREE_CODE (gimple_call_arg (stmt, 1)) == ADDR_EXPR\n+\t\t      && TREE_CODE (gimple_call_arg (stmt, 2)) == INTEGER_CST)\n+\t\t    {\n+\t\t      tree dest = TREE_OPERAND (gimple_call_arg (stmt, 0), 0);\n+\t\t      tree src = TREE_OPERAND (gimple_call_arg (stmt, 1), 0);\n+\t\t      tree len = gimple_call_arg (stmt, 2);\n+\t\t      optimize_memcpy (&i, dest, src, len);\n+\t\t    }\n+\t\t  break;\n+\n \t\tcase BUILT_IN_VA_START:\n \t\tcase BUILT_IN_VA_END:\n \t\tcase BUILT_IN_VA_COPY:\n \t\t  /* These shouldn't be folded before pass_stdarg.  */\n \t\t  result = optimize_stdarg_builtin (stmt);\n-\t\t  if (result)\n-\t\t    break;\n-\t\t  /* FALLTHRU */\n+\t\t  break;\n \n \t\tdefault:;\n \t\t}"}]}