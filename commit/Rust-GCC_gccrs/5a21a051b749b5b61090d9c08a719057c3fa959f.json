{"sha": "5a21a051b749b5b61090d9c08a719057c3fa959f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyMWEwNTFiNzQ5YjViNjEwOTBkOWMwOGE3MTkwNTdjM2ZhOTU5Zg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-08T15:33:40Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-08T15:33:40Z"}, "message": "Patch for PR java/1414:\n\n\t* parse.y (case_label_list): New global.\n\t(goal): Register case_label_list with GC.\n\t(java_complete_lhs): Save new case on case_label_list.\n\t(patch_switch_statement): Check for duplicate case labels.\n\nFrom-SVN: r46845", "tree": {"sha": "61fe286c996cf180db5faa498f6c59bb04e42c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61fe286c996cf180db5faa498f6c59bb04e42c15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a21a051b749b5b61090d9c08a719057c3fa959f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a21a051b749b5b61090d9c08a719057c3fa959f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a21a051b749b5b61090d9c08a719057c3fa959f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a21a051b749b5b61090d9c08a719057c3fa959f/comments", "author": null, "committer": null, "parents": [{"sha": "3248fb6cc439e756430002bf78f01a9eb297babc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3248fb6cc439e756430002bf78f01a9eb297babc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3248fb6cc439e756430002bf78f01a9eb297babc"}], "stats": {"total": 64, "additions": 60, "deletions": 4}, "files": [{"sha": "ce4073ffb573bba83923559b2a64837d4a25bcef", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5a21a051b749b5b61090d9c08a719057c3fa959f", "patch": "@@ -1,3 +1,11 @@\n+2001-11-07  Tom Tromey  <tromey@redhat.com>\n+\n+\tPatch for PR java/1414:\n+\t* parse.y (case_label_list): New global.\n+\t(goal): Register case_label_list with GC.\n+\t(java_complete_lhs): Save new case on case_label_list.\n+\t(patch_switch_statement): Check for duplicate case labels.\n+\n 2001-11-07  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (patch_assignment): Removed unused third argument."}, {"sha": "4262f41078fcf5f9e79dee8cae43c98b92763197", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=5a21a051b749b5b61090d9c08a719057c3fa959f", "patch": "@@ -1757,7 +1757,8 @@ generate_bytecode_insns (exp, target, state)\n \t\t    gap_start--;\n \t\t  }\n \t\trelocs[gap_start++] = reloc;\n-\t\t/* Note we don't check for duplicates.  FIXME! */\n+\t\t/* Note we don't check for duplicates.  This is\n+\t\t   handled by the parser.  */\n \t      }\n \n \t    if (2 * sw_state.num_cases"}, {"sha": "bc79e582b42cf26849eae6c98d9d056fca6936a0", "filename": "gcc/java/parse.y", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a21a051b749b5b61090d9c08a719057c3fa959f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5a21a051b749b5b61090d9c08a719057c3fa959f", "patch": "@@ -422,6 +422,13 @@ static tree current_this;\n    the list of the catch clauses of the currently analysed try block. */\n static tree currently_caught_type_list;\n \n+/* This holds a linked list of all the case labels for the current\n+   switch statement.  It is only used when checking to see if there\n+   are duplicate labels.  FIXME: probably this should just be attached\n+   to the switch itself; then it could be referenced via\n+   `ctxp->current_loop'.  */\n+static tree case_label_list; \n+\n static tree src_parse_roots[1] = { NULL_TREE };\n \n /* All classes seen from source code */\n@@ -622,6 +629,7 @@ goal:\n \t\t  ggc_add_tree_root (&package_list, 1);\n \t\t  ggc_add_tree_root (&current_this, 1);\n \t\t  ggc_add_tree_root (&currently_caught_type_list, 1);\n+\t\t  ggc_add_tree_root (&case_label_list, 1);\n \t\t  ggc_add_root (&ctxp, 1, \n \t\t\t\tsizeof (struct parser_ctxt *),\n \t\t\t\tmark_parser_ctxt);\n@@ -11674,9 +11682,12 @@ java_complete_lhs (node)\n       TREE_CONSTANT_OVERFLOW (cn) = 0;\n       CAN_COMPLETE_NORMALLY (cn) = 1;\n \n-      /* Multiple instance of a case label bearing the same\n-\t value is checked during code generation. The case\n-\t expression is allright so far. */\n+      /* Save the label on a list so that we can later check for\n+\t duplicates.  */\n+      case_label_list = tree_cons (node, cn, case_label_list);\n+\n+      /* Multiple instance of a case label bearing the same value is\n+\t checked later. The case expression is all right so far. */\n       if (TREE_CODE (cn) == VAR_DECL)\n \tcn = DECL_INITIAL (cn);\n       TREE_OPERAND (node, 0) = cn;\n@@ -15404,6 +15415,7 @@ patch_switch_statement (node)\n      tree node;\n {\n   tree se = TREE_OPERAND (node, 0), se_type;\n+  tree save, iter;\n \n   /* Complete the switch expression */\n   se = TREE_OPERAND (node, 0) = java_complete_tree (se);\n@@ -15421,8 +15433,43 @@ patch_switch_statement (node)\n       return error_mark_node;\n     }\n \n+  /* Save and restore the outer case label list.  */\n+  save = case_label_list;\n+  case_label_list = NULL_TREE;\n+\n   TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n \n+  /* See if we've found a duplicate label.  We can't leave this until\n+     code generation, because in `--syntax-only' and `-C' modes we\n+     don't do ordinary code generation.  */\n+  for (iter = case_label_list; iter != NULL_TREE; iter = TREE_CHAIN (iter))\n+    {\n+      HOST_WIDE_INT val = TREE_INT_CST_LOW (TREE_VALUE (iter));\n+      tree subiter;\n+      for (subiter = TREE_CHAIN (iter);\n+\t   subiter != NULL_TREE;\n+\t   subiter = TREE_CHAIN (subiter))\n+\t{\n+\t  HOST_WIDE_INT subval = TREE_INT_CST_LOW (TREE_VALUE (subiter));\n+\t  if (val == subval)\n+\t    {\n+\t      EXPR_WFL_LINECOL (wfl_operator)\n+\t\t= EXPR_WFL_LINECOL (TREE_PURPOSE (iter));\n+\t      /* The case_label_list is in reverse order, so print the\n+\t\t outer label first.  */\n+\t      parse_error_context (wfl_operator, \"duplicate case label: `%d'\",\n+\t\t\t\t   subval);\n+\t      EXPR_WFL_LINECOL (wfl_operator)\n+\t\t= EXPR_WFL_LINECOL (TREE_PURPOSE (subiter));\n+\t      parse_error_context (wfl_operator, \"original label is here\");\n+\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  case_label_list = save;\n+\n   /* Ready to return */\n   if (TREE_CODE (TREE_OPERAND (node, 1)) == ERROR_MARK)\n     {"}]}