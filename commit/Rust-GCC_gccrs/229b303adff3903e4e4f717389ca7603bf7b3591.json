{"sha": "229b303adff3903e4e4f717389ca7603bf7b3591", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5YjMwM2FkZmYzOTAzZTRlNGY3MTczODljYTc2MDNiZjdiMzU5MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-10-04T16:08:18Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-10-04T16:08:18Z"}, "message": "i386.h (processor_costs): Add new fields fadd, fmul, fdiv, fabs, fchs and fsqrt to costs structure.\n\n\n\t* config/i386/i386.h (processor_costs): Add new fields fadd,\n\tfmul, fdiv, fabs, fchs and fsqrt to costs structure.\n\t(RTX_COSTS): Use these fields to determine the RTX costs\n\tof floating point addition/subtraction, multiplication,\n\tdivision, fabs, negation and square root respectively.\n\t* config/i386/i386.c (size_cost): Provide instruction sizes\n\tfor these new fields.\n\t(i386_cost, i486_cost, pentium_cost, pentiumpro_cost,\n\tk6_cost, athlon_cost, pentium4_cost): Provide typical cycle\n\tcounts for these new fields for all x86 processor variants.\n\nFrom-SVN: r57820", "tree": {"sha": "6f8ecebd7115ed4b0f41a751c4373bc568b70118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f8ecebd7115ed4b0f41a751c4373bc568b70118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/229b303adff3903e4e4f717389ca7603bf7b3591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229b303adff3903e4e4f717389ca7603bf7b3591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229b303adff3903e4e4f717389ca7603bf7b3591", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229b303adff3903e4e4f717389ca7603bf7b3591/comments", "author": null, "committer": null, "parents": [{"sha": "f42ee52fc006fd8540e4a7a4356abc830a520a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f42ee52fc006fd8540e4a7a4356abc830a520a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f42ee52fc006fd8540e4a7a4356abc830a520a44"}], "stats": {"total": 104, "additions": 99, "deletions": 5}, "files": [{"sha": "8c68ceba3c7d11f34253bb7689b7022f75072ed5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=229b303adff3903e4e4f717389ca7603bf7b3591", "patch": "@@ -1,3 +1,16 @@\n+2002-10-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/i386/i386.h (processor_costs): Add new fields fadd,\n+\tfmul, fdiv, fabs, fchs and fsqrt to costs structure.\n+\t(RTX_COSTS): Use these fields to determine the RTX costs\n+\tof floating point addition/subtraction, multiplication,\n+\tdivision, fabs, negation and square root respectively.\n+\t* config/i386/i386.c (size_cost): Provide instruction sizes\n+\tfor these new fields.\n+\t(i386_cost, i486_cost, pentium_cost, pentiumpro_cost,\n+\tk6_cost, athlon_cost, pentium4_cost): Provide typical cycle\n+\tcounts for these new fields for all x86 processor variants.\n+\n 2002-10-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips.c (mips_const_double_ok): Delete unused variable."}, {"sha": "f612623ea6bad7f98ae19d4910623513acf4db89", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=229b303adff3903e4e4f717389ca7603bf7b3591", "patch": "@@ -84,7 +84,14 @@ struct processor_costs size_cost = {\t/* costs for tunning for size */\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n+  2,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  2,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  2,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  2,\t\t\t\t\t/* cost of FABS instruction.  */\n+  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  2,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n+\n /* Processor costs (relative to an add) */\n static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n@@ -121,6 +128,12 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n+  23,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  27,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  88,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  22,\t\t\t\t\t/* cost of FABS instruction.  */\n+  24,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  122,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -158,6 +171,12 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n+  8,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  16,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  73,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  3,\t\t\t\t\t/* cost of FABS instruction.  */\n+  3,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  83,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -195,6 +214,12 @@ struct processor_costs pentium_cost = {\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n+  3,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  3,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  39,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  1,\t\t\t\t\t/* cost of FABS instruction.  */\n+  1,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  70,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -232,6 +257,12 @@ struct processor_costs pentiumpro_cost = {\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n   32,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n+  3,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  5,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  56,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  2,\t\t\t\t\t/* cost of FABS instruction.  */\n+  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  56,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -269,6 +300,12 @@ struct processor_costs k6_cost = {\n   6,\t\t\t\t\t/* MMX or SSE register to integer */\n   32,\t\t\t\t\t/* size of prefetch block */\n   1,\t\t\t\t\t/* number of parallel prefetches */\n+  2,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  2,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  2,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  56,\t\t\t\t\t/* cost of FABS instruction.  */\n+  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  56,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -306,6 +343,12 @@ struct processor_costs athlon_cost = {\n   5,\t\t\t\t\t/* MMX or SSE register to integer */\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n+  4,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  4,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  24,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  2,\t\t\t\t\t/* cost of FABS instruction.  */\n+  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  35,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n@@ -343,6 +386,12 @@ struct processor_costs pentium4_cost = {\n   10,\t\t\t\t\t/* MMX or SSE register to integer */\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n+  5,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n+  7,\t\t\t\t\t/* cost of FMUL instruction.  */\n+  43,\t\t\t\t\t/* cost of FDIV instruction.  */\n+  2,\t\t\t\t\t/* cost of FABS instruction.  */\n+  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n+  43,\t\t\t\t\t/* cost of FSQRT instruction.  */\n };\n \n const struct processor_costs *ix86_cost = &pentium_cost;"}, {"sha": "a2f1cc2e5ce8b7fb0e1b4833c4a5cb05d43b5702", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229b303adff3903e4e4f717389ca7603bf7b3591/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=229b303adff3903e4e4f717389ca7603bf7b3591", "patch": "@@ -75,6 +75,12 @@ struct processor_costs {\n   const int prefetch_block;\t/* bytes moved to cache for prefetch.  */\n   const int simultaneous_prefetches; /* number of parallel prefetch\n \t\t\t\t   operations.  */\n+  const int fadd;\t\t/* cost of FADD and FSUB instructions.  */\n+  const int fmul;\t\t/* cost of FMUL instruction.  */\n+  const int fdiv;\t\t/* cost of FDIV instruction.  */\n+  const int fabs;\t\t/* cost of FABS instruction.  */\n+  const int fchs;\t\t/* cost of FCHS instruction.  */\n+  const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n };\n \n extern const struct processor_costs *ix86_cost;\n@@ -2632,7 +2638,9 @@ do {\t\t\t\t\t\t\t\\\n     break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fmul);\t\t\t\t\\\n+    else if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\\\n \tint nbits = 0;\t\t\t\t\t\t\t\\\n@@ -2654,10 +2662,16 @@ do {\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\t\t\\\n-    TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fdiv);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide);\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_DECOMPOSE_LEA\t\t\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fadd);\t\t\t\t\\\n+    else if (!TARGET_DECOMPOSE_LEA\t\t\t\t\t\\\n \t&& INTEGRAL_MODE_P (GET_MODE (X))\t\t\t\t\\\n \t&& GET_MODE_BITSIZE (GET_MODE (X)) <= GET_MODE_BITSIZE (Pmode))\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -2697,21 +2711,29 @@ do {\t\t\t\t\t\t\t\\\n \t\t    + rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fadd);\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   case AND:\t\t\t\t\t\t\t\t\\\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n     if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n       return (COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\\\n \t      + (rtx_cost (XEXP (X, 0), (OUTER_CODE))\t\t\t\\\n \t         << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n \t      + (rtx_cost (XEXP (X, 1), (OUTER_CODE))\t\t\t\\\n  \t         << (GET_MODE (XEXP (X, 1)) != DImode)));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fchs);\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   case NOT:\t\t\t\t\t\t\t\t\\\n     if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2);\t\t\t\\\n@@ -2723,6 +2745,16 @@ do {\t\t\t\t\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (0);\t\t\t\t\t\\\n     break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  case ABS:\t\t\t\t\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fabs);\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SQRT:\t\t\t\t\t\t\t\t\\\n+    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fsqrt);\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   egress_rtx_costs:\t\t\t\t\t\t\t\\\n     break;\n "}]}