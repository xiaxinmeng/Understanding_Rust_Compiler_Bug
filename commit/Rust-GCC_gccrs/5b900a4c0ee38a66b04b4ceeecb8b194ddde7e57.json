{"sha": "5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5MDBhNGMwZWUzOGE2NmIwNGI0Y2VlZWNiOGIxOTRkZGRlN2U1Nw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-07-12T14:42:08Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-07-12T14:42:08Z"}, "message": "re PR target/25413 (wrong alignment or incorrect address computation in vectorized code on Pentium 4 SSE)\n\n2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n            Devang Patel  <dpatel@apple.com>\n\n        PR tree-optimization/25413\n        * targhooks.c (default_builtin_vector_alignment_reachable): New.\n        * targhooks.h (default_builtin_vector_alignment_reachable): New.\n        * tree.h (contains_packed_reference): New.\n        * expr.c (contains_packed_reference): New.\n        * tree-vect-analyze.c (vector_alignment_reachable_p): New.\n        (vect_enhance_data_refs_alignment): Call\n        vector_alignment_reachable_p.\n        * target.h (vector_alignment_reachable): New builtin.\n        * target-def.h (TARGET_VECTOR_ALIGNMENT_REACHABLE): New.\n        * config/rs6000/rs6000.c (rs6000_vector_alignment_reachable): New.\n        (TARGET_VECTOR_ALIGNMENT_REACHABLE): Define.\n\n\nCo-Authored-By: Devang Patel <dpatel@apple.com>\n\nFrom-SVN: r126591", "tree": {"sha": "1d606e4397ee32cd9fe29b0165fe91119ff4fbc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d606e4397ee32cd9fe29b0165fe91119ff4fbc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/comments", "author": null, "committer": null, "parents": [{"sha": "2df6377e6e01046582d489ae59b5be1371b42d59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df6377e6e01046582d489ae59b5be1371b42d59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df6377e6e01046582d489ae59b5be1371b42d59"}], "stats": {"total": 503, "additions": 474, "deletions": 29}, "files": [{"sha": "5a6f61c3ae31fccaa0306f6be07716785d9c1541", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -10,6 +10,22 @@\n \t* varasm.c (assemble_start_function): Use DECL_ALIGN instead of\n \tFUNCTION_BOUNDARY.\n \n+2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n+\t    Devang Patel  <dpatel@apple.com>\n+\n+\tPR tree-optimization/25413\n+\t* targhooks.c (default_builtin_vector_alignment_reachable): New.\n+\t* targhooks.h (default_builtin_vector_alignment_reachable): New.\n+\t* tree.h (contains_packed_reference): New.\n+\t* expr.c (contains_packed_reference): New.\n+\t* tree-vect-analyze.c (vector_alignment_reachable_p): New.\n+\t(vect_enhance_data_refs_alignment): Call\n+\tvector_alignment_reachable_p.\n+\t* target.h (vector_alignment_reachable): New builtin.\n+\t* target-def.h (TARGET_VECTOR_ALIGNMENT_REACHABLE): New.\n+\t* config/rs6000/rs6000.c (rs6000_vector_alignment_reachable): New.\n+\t(TARGET_VECTOR_ALIGNMENT_REACHABLE): Define.\n+\n 2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* target.h (builtin_vectorization_cost): Add new target builtin."}, {"sha": "c9c5a19f878dcc826a66442937c538f55830883c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -717,6 +717,7 @@ static tree rs6000_builtin_mul_widen_odd (tree);\n static tree rs6000_builtin_conversion (enum tree_code, tree);\n \n static void def_builtin (int, const char *, tree, int);\n+static bool rs6000_vector_alignment_reachable (tree, bool);\n static void rs6000_init_builtins (void);\n static rtx rs6000_expand_unop_builtin (enum insn_code, tree, rtx);\n static rtx rs6000_expand_binop_builtin (enum insn_code, tree, rtx);\n@@ -984,6 +985,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n #define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n \n+#undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n+\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n \n@@ -1806,6 +1810,37 @@ rs6000_builtin_mul_widen_odd (tree type)\n     }\n }\n \n+\n+/* Return true iff, data reference of TYPE can reach vector alignment (16)\n+   after applying N number of iterations.  This routine does not determine\n+   how may iterations are required to reach desired alignment.  */\n+\n+static bool\n+rs6000_vector_alignment_reachable (tree type ATTRIBUTE_UNUSED, bool is_packed)\n+{\n+  if (is_packed)\n+    return false;\n+\n+  if (TARGET_32BIT)\n+    {\n+      if (rs6000_alignment_flags == MASK_ALIGN_NATURAL)\n+        return true;\n+\n+      if (rs6000_alignment_flags ==  MASK_ALIGN_POWER)\n+        return true;\n+\n+      return false;\n+    }\n+  else\n+    {\n+      if (TARGET_MACHO)\n+        return false;\n+\n+      /* Assuming that all other types are naturally aligned. CHECKME!  */\n+      return true;\n+    }\n+}\n+\n /* Handle generic options of the form -mfoo=yes/no.\n    NAME is the option name.\n    VALUE is the option value."}, {"sha": "cfc6ed18a2bd580ca503cb770f15b1bf0de75a6c", "filename": "gcc/expr.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -5924,6 +5924,47 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   return exp;\n }\n \n+/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n+   look for whether EXP or any nested component-refs within EXP is marked\n+   as PACKED.  */\n+\n+bool\n+contains_packed_reference (tree exp)\n+{\n+  bool packed_p = false;\n+\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    packed_p = DECL_PACKED (field) \n+\t\t       || TYPE_PACKED (TREE_TYPE (field))\n+\t\t       || TYPE_PACKED (TREE_TYPE (exp));\n+\t    if (packed_p)\n+\t      goto done;\n+\t  }\n+\t  break;\n+\n+\tcase BIT_FIELD_REF:\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\tcase VIEW_CONVERT_EXPR:\n+\t  break;\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+ done:\n+  return packed_p;\n+}\n+\n /* Return a tree of sizetype representing the size, in bytes, of the element\n    of EXP, an ARRAY_REF.  */\n "}, {"sha": "b0ae5978b91dc8de0e9d78392a445860fa7a7439", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -357,6 +357,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST 0\n+#define TARGET_VECTOR_ALIGNMENT_REACHABLE \\\n+  default_builtin_vector_alignment_reachable\n \n #define TARGET_VECTORIZE                                                \\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -365,7 +367,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n     TARGET_VECTORIZE_BUILTIN_CONVERSION,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\t\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,\t\t\t\\\n+    TARGET_VECTOR_ALIGNMENT_REACHABLE\t\t\t\t\t\\\n   }\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0"}, {"sha": "e19680918d9bc8befe5fcd8a70db3073721bbce4", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -417,6 +417,10 @@ struct gcc_target\n     /* Returns the cost to be added to the overheads involved with\n        executing the vectorized version of a loop.  */\n     int (*builtin_vectorization_cost) (bool);\n+\n+    /* Return true if vector alignment is reachable (by peeling N\n+       interations) for the given type.  */\n+    bool (* vector_alignment_reachable) (tree, bool);\n   } vectorize;\n \n   /* The initial value of target_flags.  */"}, {"sha": "f875b87e6038f8cb78931acec3232b2b46a9e1a4", "filename": "gcc/targhooks.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -653,4 +653,20 @@ tree default_mangle_decl_assembler_name (tree decl ATTRIBUTE_UNUSED,\n    return id;\n }\n \n+bool\n+default_builtin_vector_alignment_reachable (tree type, bool is_packed)\n+{\n+  if (is_packed)\n+    return false;\n+\n+  /* Assuming that types whose size is > pointer-size are not guaranteed to be\n+     naturally aligned.  */\n+  if (tree_int_cst_compare (TYPE_SIZE (type), bitsize_int (POINTER_SIZE)) > 0)\n+    return false;\n+\n+  /* Assuming that types whose size is <= pointer-size\n+     are naturally aligned.  */\n+  return true;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "5848f6c3b531aab91ee5cb9d962885ca061ba8bc", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -66,6 +66,8 @@ extern tree default_builtin_vectorized_conversion (enum tree_code, tree);\n \n extern tree default_builtin_reciprocal (enum built_in_function, bool, bool);\n \n+extern bool default_builtin_vector_alignment_reachable (tree, bool);\n+\n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n "}, {"sha": "1b0e69af2e839f428ae669c600f8aa3a86dd3971", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -1,3 +1,13 @@\n+2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n+\t    Devang Patel  <dpatel@apple.com>\n+\n+\tPR tree-optimization/25413\n+\t* gcc.dg/vect/vect-align-1.c: New.\n+\t* gcc.dg/vect/vect-align-2.c: New.\n+\t* gcc.dg/vect/pr25413.c: New.\n+\t* gcc.dg/vect/pr25413a.c: New.\n+\t* gcc.dg/vect/pr31699.c: Fix dg-final check.\n+\n 2007-07-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* lib/target-support.exp (check_ultrasparc_hw_available):"}, {"sha": "a171249ff3ce830254ac6a11e059ecec900b71ae", "filename": "gcc/testsuite/gcc.dg/vect/pr25413.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+\n+struct\n+{\n+  char c;\n+  double d[N];\n+} a;\n+\n+int main1()\n+{\n+  int i;\n+  for ( i=0; i<N; ++i )\n+    a.d[i]=1;\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+  check_vect ();\n+  \n+  main1 ();\n+  for (i=0; i<N; i++)\n+    if (a.d[i] != 1)\n+      abort ();\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "730920a16daecfa3cd81b516e59530367a493e04", "filename": "gcc/testsuite/gcc.dg/vect/pr25413a.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -0,0 +1,129 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+\n+typedef unsigned int size_t;\n+\n+extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));\n+\n+typedef double num_t;\n+static const num_t num__infty = ((num_t)1.0)/((num_t)0.0);\n+\n+struct oct_tt;\n+typedef struct oct_tt oct_t;\n+\n+typedef unsigned int var_t;\n+typedef enum {\n+  OCT_EMPTY = 0,\n+  OCT_NORMAL = 1,\n+  OCT_CLOSED = 2\n+} oct_state;\n+\n+struct oct_tt {\n+  var_t n;\n+\n+  int ref;\n+\n+  oct_state state;\n+  struct oct_tt* closed;\n+\n+  num_t* c;\n+};\n+\n+void* octfapg_mm_malloc (size_t t);\n+oct_t* octfapg_alloc (var_t n);\n+oct_t* octfapg_full_copy (oct_t* m);\n+\n+struct mmalloc_tt;\n+typedef struct mmalloc_tt mmalloc_t;\n+\n+struct mmalloc_tt\n+{\n+  int id;\n+\n+  int nb_alloc;\n+  int nb_realloc;\n+  int nb_free;\n+\n+  size_t rem;\n+  size_t max;\n+  size_t tot;\n+\n+};\n+\n+typedef struct\n+{\n+  size_t size;\n+\n+  mmalloc_t* mm;\n+  int id;\n+\n+  double dummy;\n+\n+} mmheader_t;\n+\n+void*\n+octfapg_mm_malloc (size_t t)\n+{\n+  char* m = (char*)malloc(t+sizeof(mmheader_t));\n+  return m+sizeof(mmheader_t);\n+}\n+\n+oct_t* octfapg_empty (var_t n);\n+\n+oct_t*\n+octfapg_empty (const var_t n)\n+{\n+  oct_t* m;\n+  /*octfapg_timing_enter(\"oct_empty\",3);*/\n+  m = ((oct_t*) octfapg_mm_malloc (sizeof(oct_t)));\n+  m->n = n;\n+  m->ref = 1;\n+  m->state = OCT_EMPTY;\n+  m->closed = (oct_t*)((void *)0);\n+  m->c = (num_t*)((void *)0);\n+  /*octfapg_timing_exit(\"oct_empty\",3);*/\n+  return m;\n+}\n+\n+oct_t*\n+octfapg_alloc (const var_t n)\n+{\n+  size_t nn = (2*(size_t)(n)*((size_t)(n)+1));\n+  oct_t* m;\n+  m = octfapg_empty(n);\n+  m->c = ((num_t*) octfapg_mm_malloc (sizeof(num_t)*(nn)));\n+  ;\n+  m->state = OCT_NORMAL;\n+  m->closed = (oct_t*)((void *)0);\n+  return m;\n+}\n+\n+oct_t*\n+octfapg_universe (const var_t n)\n+{\n+  oct_t* m;\n+  size_t i, nn = (2*(size_t)(n)*((size_t)(n)+1));\n+  m = octfapg_alloc(n);\n+  for (i=0;i<nn;i++) *(m->c+i) = num__infty;\n+  for (i=0;i<2*n;i++) *(m->c+((size_t)(i)+(((size_t)(i)+1)*((size_t)(i)+1))/2)) = (num_t)(0);\n+  m->state = OCT_CLOSED;\n+  return m;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+  check_vect ();\n+  \n+  oct_t *p = octfapg_universe(10);\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1ea8121691b8afb0ebd2a24957afc814a7e71357", "filename": "gcc/testsuite/gcc.dg/vect/pr31699.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -31,5 +31,6 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_intfloat_cvt } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5804d5120ffcea560a6e2cf0a538d8861da55a52", "filename": "gcc/testsuite/gcc.dg/vect/vect-align-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+/* Compile time known misalignment. Cannot use loop peeling to align\n+   the store.  */\n+\n+#define N 16\n+\n+struct foo {\n+  char x;\n+  int y[N];\n+} __attribute__((packed));\n+\n+int\n+main1 (struct foo * __restrict__ p)\n+{\n+  int i;\n+  int x[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      p->y[i] = x[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (p->y[i] != x[i])\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  struct foo *p = malloc (2*sizeof (struct foo));\n+  check_vect ();\n+  \n+  main1 (p);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "75fb21436aa3c95c83dfa74abfcea9a87ced4d37", "filename": "gcc/testsuite/gcc.dg/vect/vect-align-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+/* Compile time unknown misalignment. Cannot use loop peeling to align\n+   the store.  */\n+\n+#define N 17\n+\n+struct foo {\n+  char x0;\n+  int y[N][N];\n+} __attribute__ ((packed));\n+\n+struct foo f2;\n+int z[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+void fbar(struct foo *fp)\n+{\n+  int i,j;\n+   for (i=0; i<N; i++)\n+      for (j=0; j<N; j++)\n+        f2.y[i][j] = z[i];\n+\n+   for (i=0; i<N; i++)\n+      for (j=0; j<N; j++)\n+\tif (f2.y[i][j] != z[i])\n+\t  abort ();\n+}\n+\n+int main (void)\n+{\n+  struct foo  *fp = (struct foo *) malloc (2*sizeof (struct foo));\n+\n+  fbar(fp);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "317e334d936fe9f80b132efc9fe4ecde51820e61", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n+#include \"target.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n #include \"tree-flow.h\"\n@@ -1379,6 +1380,76 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vector_alignment_reachable_p\n+\n+   Return true if vector alignment for DR is reachable by peeling\n+   a few loop iterations.  Return false otherwise.  */\n+\n+static bool\n+vector_alignment_reachable_p (struct data_reference *dr)\n+{\n+  tree stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    {\n+      /* For interleaved access we peel only if number of iterations in\n+\t the prolog loop ({VF - misalignment}), is a multiple of the\n+\t number of the interleaved accesses.  */\n+      int elem_size, mis_in_elements;\n+      int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+      /* FORNOW: handle only known alignment.  */\n+      if (!known_alignment_for_access_p (dr))\n+\treturn false;\n+\n+      elem_size = UNITS_PER_SIMD_WORD / nelements;\n+      mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n+\n+      if ((nelements - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n+\treturn false;\n+    }\n+\n+  /* If misalignment is known at the compile time then allow peeling\n+     only if natural alignment is reachable through peeling.  */\n+  if (known_alignment_for_access_p (dr) && !aligned_access_p (dr))\n+    {\n+      HOST_WIDE_INT elmsize = \n+\t\tint_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\t{\n+\t  fprintf (vect_dump, \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n+\t  fprintf (vect_dump, \". misalignment = %d. \", DR_MISALIGNMENT (dr));\n+\t}\n+      if (DR_MISALIGNMENT (dr) % elmsize)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"data size does not divide the misalignment.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (!known_alignment_for_access_p (dr))\n+    {\n+      tree type = (TREE_TYPE (DR_REF (dr)));\n+      tree ba = DR_BASE_OBJECT (dr);\n+      bool is_packed = false;\n+\n+      if (ba)\n+\tis_packed = contains_packed_reference (ba);\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"Unknown misalignment, is_packed = %d\",is_packed);\n+      if (targetm.vectorize.vector_alignment_reachable (type, is_packed))\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Function vect_enhance_data_refs_alignment\n \n    This pass will use loop versioning and loop peeling in order to enhance\n@@ -1540,33 +1611,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n         {\n-\t  if (DR_GROUP_FIRST_DR (stmt_info))\n-\t    {\n-\t      /* For interleaved access we peel only if number of iterations in\n-\t\t the prolog loop ({VF - misalignment}), is a multiple of the\n-\t\t number of the interleaved accesses.  */\n-\t      int elem_size, mis_in_elements;\n-\t      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t      int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n-\n-\t      /* FORNOW: handle only known alignment.  */\n-\t      if (!known_alignment_for_access_p (dr))\n-\t\t{\n-\t\t  do_peeling = false;\n-\t\t  break;\n-\t\t}\n-\n-\t      elem_size = UNITS_PER_SIMD_WORD / nelements;\n-\t      mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n-\n-\t      if ((nelements - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n-\t\t{\n-\t\t  do_peeling = false;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  dr0 = dr;\n-\t  do_peeling = true;\n+\t  do_peeling = vector_alignment_reachable_p (dr);\n+\t  if (do_peeling)\n+\t    dr0 = dr;\n+\t  if (!do_peeling && vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"vector alignment may not be reachable\");\n \t  break;\n \t}\n     }"}, {"sha": "82e9933592a0d8e29bae9cfc24f5c051db68af2b", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5b900a4c0ee38a66b04b4ceeecb8b194ddde7e57", "patch": "@@ -4315,6 +4315,12 @@ extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t tree *, enum machine_mode *, int *, int *,\n \t\t\t\t bool);\n \n+/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n+   look for whether EXP or any nested component-refs within EXP is marked\n+   as PACKED.  */\n+\n+extern bool contains_packed_reference (tree exp);\n+\n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n extern int handled_component_p (tree);"}]}