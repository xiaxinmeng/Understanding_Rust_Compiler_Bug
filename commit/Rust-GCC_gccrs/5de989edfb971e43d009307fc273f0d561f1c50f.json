{"sha": "5de989edfb971e43d009307fc273f0d561f1c50f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlOTg5ZWRmYjk3MWU0M2QwMDkzMDdmYzI3M2YwZDU2MWYxYzUwZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-15T10:20:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-15T10:20:58Z"}, "message": "tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Restructure forwarding through conversions and copies to avoid performing...\n\n2013-10-15  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1):\n\tRestructure forwarding through conversions and copies to\n\tavoid performing copy-propagation the wrong way.  Adjust\n\trecursion invocations.\n\t(forward_propagate_addr_expr): Add argument stating if we\n\tare recursing from a single-use.\n\t(ssa_forward_propagate_and_combine): Adjust.\n\nFrom-SVN: r203591", "tree": {"sha": "edaf637c89b4570769ea55aee074b8bc953501bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edaf637c89b4570769ea55aee074b8bc953501bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5de989edfb971e43d009307fc273f0d561f1c50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de989edfb971e43d009307fc273f0d561f1c50f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de989edfb971e43d009307fc273f0d561f1c50f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de989edfb971e43d009307fc273f0d561f1c50f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7457605705ec616086ecf5834325964703631155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7457605705ec616086ecf5834325964703631155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7457605705ec616086ecf5834325964703631155"}], "stats": {"total": 86, "additions": 55, "deletions": 31}, "files": [{"sha": "550897bb6292b52fe4c62c4dce5f3e75b713f216", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de989edfb971e43d009307fc273f0d561f1c50f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de989edfb971e43d009307fc273f0d561f1c50f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5de989edfb971e43d009307fc273f0d561f1c50f", "patch": "@@ -1,3 +1,13 @@\n+2013-10-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1):\n+\tRestructure forwarding through conversions and copies to\n+\tavoid performing copy-propagation the wrong way.  Adjust\n+\trecursion invocations.\n+\t(forward_propagate_addr_expr): Add argument stating if we\n+\tare recursing from a single-use.\n+\t(ssa_forward_propagate_and_combine): Adjust.\n+\n 2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* dumpfile.h (gcc::dump_manager): New class, to hold state"}, {"sha": "65f7ee17d46b88bfb1d4ce7af0007f008f776afe", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de989edfb971e43d009307fc273f0d561f1c50f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de989edfb971e43d009307fc273f0d561f1c50f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5de989edfb971e43d009307fc273f0d561f1c50f", "patch": "@@ -161,7 +161,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    This will (of course) be extended as other needs arise.  */\n \n-static bool forward_propagate_addr_expr (tree name, tree rhs);\n+static bool forward_propagate_addr_expr (tree, tree, bool);\n \n /* Set to true if we delete dead edges during the optimization.  */\n static bool cfg_changed;\n@@ -714,36 +714,45 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n   rhs_code = gimple_assign_rhs_code (use_stmt);\n   rhs = gimple_assign_rhs1 (use_stmt);\n \n-  /* Trivial cases.  The use statement could be a trivial copy or a\n-     useless conversion.  Recurse to the uses of the lhs as copyprop does\n-     not copy through different variant pointers and FRE does not catch\n-     all useless conversions.  Treat the case of a single-use name and\n+  /* Do not perform copy-propagation but recurse through copy chains.  */\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && rhs_code == SSA_NAME)\n+    return forward_propagate_addr_expr (lhs, def_rhs, single_use_p);\n+\n+  /* The use statement could be a conversion.  Recurse to the uses of the\n+     lhs as copyprop does not copy through pointer to integer to pointer\n+     conversions and FRE does not catch all cases either.\n+     Treat the case of a single-use name and\n      a conversion to def_rhs type separate, though.  */\n   if (TREE_CODE (lhs) == SSA_NAME\n-      && ((rhs_code == SSA_NAME && rhs == name)\n-\t  || CONVERT_EXPR_CODE_P (rhs_code)))\n+      && CONVERT_EXPR_CODE_P (rhs_code))\n     {\n-      /* Only recurse if we don't deal with a single use or we cannot\n-\t do the propagation to the current statement.  In particular\n-\t we can end up with a conversion needed for a non-invariant\n-\t address which we cannot do in a single statement.  */\n-      if (!single_use_p\n-\t  || (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (def_rhs))\n-\t      && (!is_gimple_min_invariant (def_rhs)\n-\t\t  || (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t\t      && POINTER_TYPE_P (TREE_TYPE (def_rhs))\n-\t\t      && (TYPE_PRECISION (TREE_TYPE (lhs))\n-\t\t\t  > TYPE_PRECISION (TREE_TYPE (def_rhs)))))))\n-\treturn forward_propagate_addr_expr (lhs, def_rhs);\n-\n-      gimple_assign_set_rhs1 (use_stmt, unshare_expr (def_rhs));\n-      if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (def_rhs)))\n-\tgimple_assign_set_rhs_code (use_stmt, TREE_CODE (def_rhs));\n-      else\n-\tgimple_assign_set_rhs_code (use_stmt, NOP_EXPR);\n-      return true;\n+      /* If there is a point in a conversion chain where the types match\n+         so we can remove a conversion re-materialize the address here\n+\t and stop.  */\n+      if (single_use_p\n+\t  && useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (def_rhs)))\n+\t{\n+\t  gimple_assign_set_rhs1 (use_stmt, unshare_expr (def_rhs));\n+\t  gimple_assign_set_rhs_code (use_stmt, TREE_CODE (def_rhs));\n+\t  return true;\n+\t}\n+\n+      /* Else recurse if the conversion preserves the address value.  */\n+      if ((INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t   || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (lhs))\n+\t      >= TYPE_PRECISION (TREE_TYPE (def_rhs))))\n+\treturn forward_propagate_addr_expr (lhs, def_rhs, single_use_p);\n+\n+      return false;\n     }\n \n+  /* If this isn't a conversion chain from this on we only can propagate\n+     into compatible pointer contexts.  */\n+  if (!types_compatible_p (TREE_TYPE (name), TREE_TYPE (def_rhs)))\n+    return false;\n+\n   /* Propagate through constant pointer adjustments.  */\n   if (TREE_CODE (lhs) == SSA_NAME\n       && rhs_code == POINTER_PLUS_EXPR\n@@ -768,7 +777,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n       /* Recurse.  If we could propagate into all uses of lhs do not\n \t bother to replace into the current use but just pretend we did.  */\n       if (TREE_CODE (new_def_rhs) == ADDR_EXPR\n-\t  && forward_propagate_addr_expr (lhs, new_def_rhs))\n+\t  && forward_propagate_addr_expr (lhs, new_def_rhs, single_use_p))\n \treturn true;\n \n       if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (new_def_rhs)))\n@@ -996,15 +1005,20 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n    Try to forward propagate the ADDR_EXPR into all uses of the SSA_NAME.\n    Often this will allow for removal of an ADDR_EXPR and INDIRECT_REF\n    node or for recovery of array indexing from pointer arithmetic.\n+\n+   PARENT_SINGLE_USE_P tells if, when in a recursive invocation, NAME was\n+   the single use in the previous invocation.  Pass true when calling\n+   this as toplevel.\n+\n    Returns true, if all uses have been propagated into.  */\n \n static bool\n-forward_propagate_addr_expr (tree name, tree rhs)\n+forward_propagate_addr_expr (tree name, tree rhs, bool parent_single_use_p)\n {\n   imm_use_iterator iter;\n   gimple use_stmt;\n   bool all = true;\n-  bool single_use_p = has_single_use (name);\n+  bool single_use_p = parent_single_use_p && has_single_use (name);\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, name)\n     {\n@@ -3336,7 +3350,7 @@ ssa_forward_propagate_and_combine (void)\n \t\t   || !DECL_P (base)\n \t\t   || decl_address_invariant_p (base))\n \t\t  && !stmt_references_abnormal_ssa_name (stmt)\n-\t\t  && forward_propagate_addr_expr (lhs, rhs))\n+\t\t  && forward_propagate_addr_expr (lhs, rhs, true))\n \t\t{\n \t\t  release_defs (stmt);\n \t\t  gsi_remove (&gsi, true);\n@@ -3360,7 +3374,7 @@ ssa_forward_propagate_and_combine (void)\n \t\t\t\t\t\t TREE_TYPE (TREE_TYPE (rhs)),\n \t\t\t\t\t\t rhs,\n \t\t\t\t\t\t fold_convert (ptr_type_node,\n-\t\t\t\t\t\t\t       off)))))\n+\t\t\t\t\t\t\t       off))), true))\n \t\t{\n \t\t  release_defs (stmt);\n \t\t  gsi_remove (&gsi, true);"}]}