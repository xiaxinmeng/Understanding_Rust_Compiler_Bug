{"sha": "4798080d4a3530d985efef68aa2e04ec7549b3c1", "node_id": "C_kwDOANBUbNoAKDQ3OTgwODBkNGEzNTMwZDk4NWVmZWY2OGFhMmUwNGVjNzU0OWIzYzE", "commit": {"author": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-12-22T02:14:06Z"}, "committer": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2023-01-16T10:40:52Z"}, "message": "Add c[lt]z idiom recognition\n\nThis recognises the patterns of the form:\n  while (n & 1) { n >>= 1 }\n\nUnfortunately there are currently two issues relating to this patch.\n\nFirstly, simplify_using_initial_conditions does not recognise that\n\t(n != 0) and ((n & 1) == 0) implies that ((n >> 1) != 0).\n\nThis preconditions arise following the loop copy-header pass, and the\nassumptions returned by number_of_iterations_exit_assumptions then\nprevent final value replacement from using the niter result.\n\nI'm not sure what is the best way to fix this - one approach could be to\nmodify simplify_using_initial_conditions to handle this sort of case,\nbut it seems that it basically wants the information that ranger could\ngive anway, so would something like that be a better option?\n\nThe second issue arises in the vectoriser, which is able to determine\nthat the niter->assumptions are always true.\nWhen building with -march=armv8.4-a+sve -S -O3, we get this codegen:\n\nfoo (unsigned int b) {\n    int c = 0;\n\n    if (b == 0)\n      return PREC;\n\n    while (!(b & (1 << (PREC - 1)))) {\n        b <<= 1;\n        c++;\n    }\n\n    return c;\n}\n\nfoo:\n.LFB0:\n        .cfi_startproc\n        cmp     w0, 0\n        cbz     w0, .L6\n        blt     .L7\n        lsl     w1, w0, 1\n        clz     w2, w1\n        cmp     w2, 14\n        bls     .L8\n        mov     x0, 0\n        cntw    x3\n        add     w1, w2, 1\n        index   z1.s, #0, #1\n        whilelo p0.s, wzr, w1\n.L4:\n        add     x0, x0, x3\n        mov     p1.b, p0.b\n        mov     z0.d, z1.d\n        whilelo p0.s, w0, w1\n        incw    z1.s\n        b.any   .L4\n        add     z0.s, z0.s, #1\n        lastb   w0, p1, z0.s\n        ret\n        .p2align 2,,3\n.L8:\n        mov     w0, 0\n        b       .L3\n        .p2align 2,,3\n.L13:\n        lsl     w1, w1, 1\n.L3:\n        add     w0, w0, 1\n        tbz     w1, #31, .L13\n        ret\n        .p2align 2,,3\n.L6:\n        mov     w0, 32\n        ret\n        .p2align 2,,3\n.L7:\n        mov     w0, 0\n        ret\n        .cfi_endproc\n\nIn essence, the vectoriser uses the niter information to determine\nexactly how many iterations of the loop it needs to run. It then uses\nSVE whilelo instructions to run this number of iterations. The original\nloop counter is also vectorised, despite only being used in the final\niteration, and then the final value of this counter is used as the\nreturn value (which is the same as the number of iterations it computed\nin the first place).\n\nThis vectorisation is obviously bad, and I think it exposes a latent\nbug in the vectoriser, rather than being an issue caused by this\nspecific patch.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-loop-niter.cc (number_of_iterations_cltz): New.\n\t(number_of_iterations_bitcount): Add call to the above.\n\t(number_of_iterations_exit_assumptions): Add EQ_EXPR case for\n\tc[lt]z idiom recognition.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/cltz-max.c: New test.\n\t* gcc.dg/tree-ssa/clz-char.c: New test.\n\t* gcc.dg/tree-ssa/clz-int.c: New test.\n\t* gcc.dg/tree-ssa/clz-long-long.c: New test.\n\t* gcc.dg/tree-ssa/clz-long.c: New test.\n\t* gcc.dg/tree-ssa/ctz-char.c: New test.\n\t* gcc.dg/tree-ssa/ctz-int.c: New test.\n\t* gcc.dg/tree-ssa/ctz-long-long.c: New test.\n\t* gcc.dg/tree-ssa/ctz-long.c: New test.", "tree": {"sha": "4992cd8ab32f800df41b676c38a175f162671fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4992cd8ab32f800df41b676c38a175f162671fb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4798080d4a3530d985efef68aa2e04ec7549b3c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4798080d4a3530d985efef68aa2e04ec7549b3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4798080d4a3530d985efef68aa2e04ec7549b3c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4798080d4a3530d985efef68aa2e04ec7549b3c1/comments", "author": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0419b9b80065ac2e01e4137b7efc149ee3b1bdd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0419b9b80065ac2e01e4137b7efc149ee3b1bdd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0419b9b80065ac2e01e4137b7efc149ee3b1bdd6"}], "stats": {"total": 517, "additions": 517, "deletions": 0}, "files": [{"sha": "a6bea3d338940efee2e7e1c95a5941525945af9e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cltz-max.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-max.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-max.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-max.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-loop-optimize -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int clz_count1 (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return 0;\n+\n+    while (!(b & (1 << (PREC - 1)))) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 1)\n+      return 0;\n+    else\n+      return 34567;\n+}\n+\n+int clz_count2 (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return 0;\n+\n+    while (!(b & (1 << PREC - 1))) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 2)\n+      return 0;\n+    else\n+      return 76543;\n+}\n+\n+int ctz_count1 (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return 0;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 1)\n+      return 0;\n+    else\n+      return 23456;\n+}\n+\n+int ctz_count2 (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return 0;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 2)\n+      return 0;\n+    else\n+      return 65432;\n+}\n+/* { dg-final { scan-tree-dump-times \"34567\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"76543\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"23456\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"65432\" 1 \"optimized\" } } */"}, {"sha": "4a122db95bbb576b4ade706bd3b1ca809d2f1e3b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-char.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-char.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzl } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & (1 << (PREC - 1)))) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1 << (PREC - 1)) != 0)\n+    __builtin_abort ();\n+  if (foo(35) != PREC - 6)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "96646f8e19cd5b2342acb88949b3ef6e3e2abd5a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-int.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-int.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzl } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_INT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned int b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & (1 << (PREC - 1)))) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1 << (PREC - 1)) != 0)\n+    __builtin_abort ();\n+  if (foo(35) != PREC - 6)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "80d3edc1dab2e74fc3271ba9d97640839b3a3786", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-long-long.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long-long.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzll } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long long b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & (1LL << (PREC - 1)))) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1LL << (PREC - 1)) != 0)\n+    __builtin_abort ();\n+  if (foo(35) != PREC - 6)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "1c8037f93b9c9d42f580a172267c65723a46ef8b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-long.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-long.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzl } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & (1L << (PREC - 1)))) {\n+\tb <<= 1;\n+\tc++;\n+}\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1L << (PREC - 1)) != 0)\n+    __builtin_abort ();\n+  if (foo(35) != PREC - 6)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "3cd166acbd4670e175d79a2403de2d5a4fd38665", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-char.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-char.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctz } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned char b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(128) != 7)\n+    __builtin_abort ();\n+  if (foo(96) != 5)\n+    __builtin_abort ();\n+  if (foo(35) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "7f63493eb7389a18516f8f126c3c55dc80f0bde6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-int.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-int.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctz } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_INT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned int b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1 << (PREC - 1)) != PREC - 1)\n+    __builtin_abort ();\n+  if (foo(96) != 5)\n+    __builtin_abort ();\n+  if (foo(35) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "924f61b76f01c77a40b9fff64af3b629ab1418c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-long-long.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long-long.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctzll } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long long b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1LL << (PREC - 1)) != PREC - 1)\n+    __builtin_abort ();\n+  if (foo(96) != 5)\n+    __builtin_abort ();\n+  if (foo(35) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "178945daa8a2697989f1a1a0804ce33d768dcc55", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-long.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-long.c?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctzl } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long b) {\n+    int c = 0;\n+\n+    if (b == 0)\n+      return PREC;\n+\n+    while (!(b & 1)) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != PREC)\n+    __builtin_abort ();\n+  if (foo(1L << (PREC - 1)) != PREC - 1)\n+    __builtin_abort ();\n+  if (foo(96) != 5)\n+    __builtin_abort ();\n+  if (foo(35) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "26e39ad3a5121947e3ad19e5925c3d85c5e9d01a", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798080d4a3530d985efef68aa2e04ec7549b3c1/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=4798080d4a3530d985efef68aa2e04ec7549b3c1", "patch": "@@ -2304,6 +2304,167 @@ build_cltz_expr (tree src, bool leading, bool define_at_zero)\n   return call;\n }\n \n+/* See comment below for number_of_iterations_bitcount.\n+   For c[lt]z, we have:\n+\n+   modify:\n+   iv_2 = iv_1 << 1 OR iv_1 >> 1\n+\n+   test:\n+   if (iv & 1 << (prec-1)) OR (iv & 1)\n+\n+   modification count:\n+   src precision - c[lt]z (src)\n+\n+ */\n+\n+static bool\n+number_of_iterations_cltz (loop_p loop, edge exit,\n+\t\t\t       enum tree_code code,\n+\t\t\t       class tree_niter_desc *niter)\n+{\n+  bool modify_before_test = true;\n+  HOST_WIDE_INT max;\n+  int checked_bit;\n+  tree iv_2;\n+\n+  /* Check that condition for staying inside the loop is like\n+     if (iv == 0).  */\n+  gimple *cond_stmt = last_stmt (exit->src);\n+  if (!cond_stmt\n+      || gimple_code (cond_stmt) != GIMPLE_COND\n+      || (code != EQ_EXPR && code != GE_EXPR)\n+      || !integer_zerop (gimple_cond_rhs (cond_stmt))\n+      || TREE_CODE (gimple_cond_lhs (cond_stmt)) != SSA_NAME)\n+    return false;\n+\n+  if (code == EQ_EXPR)\n+    {\n+      /* Make sure we check a bitwise and with a suitable constant */\n+      gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (cond_stmt));\n+      if (!is_gimple_assign (and_stmt)\n+\t  || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR\n+\t  || !integer_pow2p (gimple_assign_rhs2 (and_stmt)))\n+\treturn false;\n+\n+      checked_bit = tree_log2 (gimple_assign_rhs2 (and_stmt));\n+\n+      iv_2 = gimple_assign_rhs1 (and_stmt);\n+    }\n+  else\n+    {\n+      /* We have a GE_EXPR - a signed comparison with zero is equivalent to\n+\t testing the leading bit, so check for this pattern too.  */\n+\n+      iv_2 = gimple_cond_lhs (cond_stmt);\n+      tree test_value_type = TREE_TYPE (iv_2);\n+\n+      if (TYPE_UNSIGNED (test_value_type))\n+\treturn false;\n+\n+      gimple *test_value_stmt = SSA_NAME_DEF_STMT (iv_2);\n+\n+      if (is_gimple_assign (test_value_stmt)\n+\t  && gimple_assign_rhs_code (test_value_stmt) == NOP_EXPR)\n+\t{\n+\t  /* If the test value comes from a NOP_EXPR, then we need to unwrap\n+\t     this.  We conservatively require that both types have the same\n+\t     precision.  */\n+\t  iv_2 = gimple_assign_rhs1 (test_value_stmt);\n+\t  tree rhs_type = TREE_TYPE (iv_2);\n+\t  if (TREE_CODE (rhs_type) != INTEGER_TYPE\n+\t      || (TYPE_PRECISION (rhs_type)\n+\t\t  != TYPE_PRECISION (test_value_type)))\n+\t    return false;\n+\t}\n+\n+      checked_bit = TYPE_PRECISION (test_value_type) - 1;\n+    }\n+\n+  gimple *iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n+\n+  /* If the test comes before the iv modification, then these will actually be\n+     iv_1 and a phi node.  */\n+  if (gimple_code (iv_2_stmt) == GIMPLE_PHI\n+      && gimple_bb (iv_2_stmt) == loop->header\n+      && gimple_phi_num_args (iv_2_stmt) == 2\n+      && (TREE_CODE (gimple_phi_arg_def (iv_2_stmt,\n+\t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n+\t  == SSA_NAME))\n+    {\n+      /* iv_2 is actually one of the inputs to the phi.  */\n+      iv_2 = gimple_phi_arg_def (iv_2_stmt, loop_latch_edge (loop)->dest_idx);\n+      iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n+      modify_before_test = false;\n+    }\n+\n+  /* Make sure iv_2_stmt is a logical shift by one stmt:\n+     iv_2 = iv_1 {<<|>>} 1  */\n+  if (!is_gimple_assign (iv_2_stmt)\n+      || (gimple_assign_rhs_code (iv_2_stmt) != LSHIFT_EXPR\n+\t  && (gimple_assign_rhs_code (iv_2_stmt) != RSHIFT_EXPR\n+\t      || !TYPE_UNSIGNED (TREE_TYPE (gimple_assign_lhs (iv_2_stmt)))))\n+      || !integer_onep (gimple_assign_rhs2 (iv_2_stmt)))\n+    return false;\n+\n+  bool left_shift = (gimple_assign_rhs_code (iv_2_stmt) == LSHIFT_EXPR);\n+\n+  tree iv_1 = gimple_assign_rhs1 (iv_2_stmt);\n+\n+  /* Check the recurrence.  */\n+  gimple *phi = SSA_NAME_DEF_STMT (iv_1);\n+  if (gimple_code (phi) != GIMPLE_PHI\n+      || (gimple_bb (phi) != loop_latch_edge (loop)->dest)\n+      || (iv_2 != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n+    return false;\n+\n+  /* We found a match.  */\n+  tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n+  int src_precision = TYPE_PRECISION (TREE_TYPE (src));\n+\n+  /* Apply any needed preprocessing to src.  */\n+  int num_ignored_bits;\n+  if (left_shift)\n+    num_ignored_bits = src_precision - checked_bit - 1;\n+  else\n+    num_ignored_bits = checked_bit;\n+\n+  if (modify_before_test)\n+    num_ignored_bits++;\n+\n+  if (num_ignored_bits != 0)\n+    src = fold_build2 (left_shift ? LSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t       TREE_TYPE (src), src,\n+\t\t       build_int_cst (integer_type_node, num_ignored_bits));\n+\n+  /* Get the corresponding c[lt]z builtin.  */\n+  tree expr = build_cltz_expr (src, left_shift, false);\n+\n+  if (!expr)\n+    return false;\n+\n+  max = src_precision - num_ignored_bits - 1;\n+\n+  expr = fold_convert (unsigned_type_node, expr);\n+\n+  tree assumptions = fold_build2 (NE_EXPR, boolean_type_node, src,\n+\t\t\t\t  build_zero_cst (TREE_TYPE (src)));\n+\n+  niter->assumptions = simplify_using_initial_conditions (loop, assumptions);\n+  niter->may_be_zero = boolean_false_node;\n+  niter->niter = simplify_using_initial_conditions (loop, expr);\n+\n+  if (TREE_CODE (niter->niter) == INTEGER_CST)\n+    niter->max = tree_to_uhwi (niter->niter);\n+  else\n+    niter->max = max;\n+\n+  niter->bound = NULL_TREE;\n+  niter->cmp = ERROR_MARK;\n+\n+  return true;\n+}\n+\n /* See comment below for number_of_iterations_bitcount.\n    For c[lt]z complement, we have:\n \n@@ -2464,6 +2625,7 @@ number_of_iterations_bitcount (loop_p loop, edge exit,\n \t\t\t       class tree_niter_desc *niter)\n {\n   return (number_of_iterations_popcount (loop, exit, code, niter)\n+\t  || number_of_iterations_cltz (loop, exit, code, niter)\n \t  || number_of_iterations_cltz_complement (loop, exit, code, niter));\n }\n \n@@ -2992,6 +3154,9 @@ number_of_iterations_exit_assumptions (class loop *loop, edge exit,\n     case NE_EXPR:\n       break;\n \n+    case EQ_EXPR:\n+      return number_of_iterations_cltz (loop, exit, code, niter);\n+\n     default:\n       return false;\n     }"}]}