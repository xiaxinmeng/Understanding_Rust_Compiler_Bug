{"sha": "4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2", "node_id": "C_kwDOANBUbNoAKDRjNDZmNWE0NzFjMjM5ZjdkM2ZiMzdjNzQ4ZjFmMThhOGViYWUxYTI", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T16:36:27Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T17:33:53Z"}, "message": "ifcvt: Check if cmovs are needed.\n\nWhen if-converting multiple SETs and we encounter a swap-style idiom\n\n  if (a > b)\n    {\n      tmp = c;   // [1]\n      c = d;\n      d = tmp;\n    }\n\nifcvt should not generate a conditional move for the instruction at\n[1].\n\nIn order to achieve that, this patch goes through all relevant SETs\nand marks the relevant instructions.  This helps to evaluate costs.\n\nOn top, only generate temporaries if the current cmov is going to\noverwrite one of the comparands of the initial compare.\n\ngcc/ChangeLog:\n\n\t* ifcvt.cc (need_cmov_or_rewire): New function.\n\t(noce_convert_multiple_sets): Call it.", "tree": {"sha": "3daf62a0b89865bf617203851079cdc66cb54fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3daf62a0b89865bf617203851079cdc66cb54fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5148d4faa6fb1e93b8ea1fad4a69806454f56f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5148d4faa6fb1e93b8ea1fad4a69806454f56f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5148d4faa6fb1e93b8ea1fad4a69806454f56f5"}], "stats": {"total": 174, "additions": 150, "deletions": 24}, "files": [{"sha": "0f7a126ad92f968cef67cbcac2810ec7f2886a9b", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 150, "deletions": 24, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=4c46f5a471c239f7d3fb37c748f1f18a8ebae1a2", "patch": "@@ -98,6 +98,8 @@ static int dead_or_predicable (basic_block, basic_block, basic_block,\n \t\t\t       edge, int);\n static void noce_emit_move_insn (rtx, rtx);\n static rtx_insn *block_has_only_trap (basic_block);\n+static void need_cmov_or_rewire (basic_block, hash_set<rtx_insn *> *,\n+\t\t\t\t hash_map<rtx_insn *, int> *);\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n@@ -3209,6 +3211,11 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   auto_vec<rtx_insn *> unmodified_insns;\n   int count = 0;\n \n+  hash_set<rtx_insn *> need_no_cmov;\n+  hash_map<rtx_insn *, int> rewired_src;\n+\n+  need_cmov_or_rewire (then_bb, &need_no_cmov, &rewired_src);\n+\n   FOR_BB_INSNS (then_bb, insn)\n     {\n       /* Skip over non-insns.  */\n@@ -3219,26 +3226,49 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n       gcc_checking_assert (set);\n \n       rtx target = SET_DEST (set);\n-      rtx temp = gen_reg_rtx (GET_MODE (target));\n+      rtx temp;\n+\n       rtx new_val = SET_SRC (set);\n+      if (int *ii = rewired_src.get (insn))\n+\tnew_val = simplify_replace_rtx (new_val, targets[*ii],\n+\t\t\t\t\ttemporaries[*ii]);\n       rtx old_val = target;\n \n-      /* If we were supposed to read from an earlier write in this block,\n-\t we've changed the register allocation.  Rewire the read.  While\n-\t we are looking, also try to catch a swap idiom.  */\n-      for (int i = count - 1; i >= 0; --i)\n-\tif (reg_overlap_mentioned_p (new_val, targets[i]))\n-\t  {\n-\t    /* Catch a \"swap\" style idiom.  */\n-\t    if (find_reg_note (insn, REG_DEAD, new_val) != NULL_RTX)\n-\t      /* The write to targets[i] is only live until the read\n-\t\t here.  As the condition codes match, we can propagate\n-\t\t the set to here.  */\n-\t      new_val = SET_SRC (single_set (unmodified_insns[i]));\n-\t    else\n-\t      new_val = temporaries[i];\n-\t    break;\n-\t  }\n+      /* As we are transforming\n+\t if (x > y)\n+\t   {\n+\t     a = b;\n+\t     c = d;\n+\t   }\n+\t into\n+\t   a = (x > y) ...\n+\t   c = (x > y) ...\n+\n+\t we potentially check x > y before every set.\n+\t Even though the check might be removed by subsequent passes, this means\n+\t that we cannot transform\n+\t   if (x > y)\n+\t     {\n+\t       x = y;\n+\t       ...\n+\t     }\n+\t into\n+\t   x = (x > y) ...\n+\t   ...\n+\t since this would invalidate x and the following to-be-removed checks.\n+\t Therefore we introduce a temporary every time we are about to\n+\t overwrite a variable used in the check.  Costing of a sequence with\n+\t these is going to be inaccurate so only use temporaries when\n+\t needed.  */\n+      if (reg_overlap_mentioned_p (target, cond))\n+\ttemp = gen_reg_rtx (GET_MODE (target));\n+      else\n+\ttemp = target;\n+\n+      /* We have identified swap-style idioms before.  A normal\n+\t set will need to be a cmov while the first instruction of a swap-style\n+\t idiom can be a regular move.  This helps with costing.  */\n+      bool need_cmov = !need_no_cmov.contains (insn);\n \n       /* If we had a non-canonical conditional jump (i.e. one where\n \t the fallthrough is to the \"else\" case) we need to reverse\n@@ -3281,16 +3311,29 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t  old_val = lowpart_subreg (dst_mode, old_val, src_mode);\n \t}\n \n-      /* Actually emit the conditional move.  */\n-      rtx temp_dest = noce_emit_cmove (if_info, temp, cond_code,\n+      rtx temp_dest = NULL_RTX;\n+\n+      if (need_cmov)\n+\t{\n+\t  /* Actually emit the conditional move.  */\n+\t  temp_dest = noce_emit_cmove (if_info, temp, cond_code,\n \t\t\t\t       x, y, new_val, old_val);\n \n-      /* If we failed to expand the conditional move, drop out and don't\n-\t try to continue.  */\n-      if (temp_dest == NULL_RTX)\n+\t  /* If we failed to expand the conditional move, drop out and don't\n+\t     try to continue.  */\n+\t  if (temp_dest == NULL_RTX)\n+\t    {\n+\t      end_sequence ();\n+\t      return FALSE;\n+\t    }\n+\t}\n+      else\n \t{\n-\t  end_sequence ();\n-\t  return FALSE;\n+\t  if (if_info->then_else_reversed)\n+\t    noce_emit_move_insn (temp, old_val);\n+\t  else\n+\t    noce_emit_move_insn (temp, new_val);\n+\t  temp_dest = temp;\n \t}\n \n       /* Bookkeeping.  */\n@@ -3814,6 +3857,89 @@ check_cond_move_block (basic_block bb,\n   return TRUE;\n }\n \n+/* Find local swap-style idioms in BB and mark the first insn (1)\n+   that is only a temporary as not needing a conditional move as\n+   it is going to be dead afterwards anyway.\n+\n+     (1) int tmp = a;\n+\t a = b;\n+\t b = tmp;\n+\n+\t ifcvt\n+\t -->\n+\n+\t tmp = a;\n+\t a = cond ? b : a_old;\n+\t b = cond ? tmp : b_old;\n+\n+    Additionally, store the index of insns like (2) when a subsequent\n+    SET reads from their destination.\n+\n+    (2) int c = a;\n+\tint d = c;\n+\n+\tifcvt\n+\t-->\n+\n+\tc = cond ? a : c_old;\n+\td = cond ? d : c;     // Need to use c rather than c_old here.\n+*/\n+\n+static void\n+need_cmov_or_rewire (basic_block bb,\n+\t\t     hash_set<rtx_insn *> *need_no_cmov,\n+\t\t     hash_map<rtx_insn *, int> *rewired_src)\n+{\n+  rtx_insn *insn;\n+  int count = 0;\n+  auto_vec<rtx_insn *> insns;\n+  auto_vec<rtx> dests;\n+\n+  /* Iterate over all SETs, storing the destinations\n+     in DEST.\n+     - If we hit a SET that reads from a destination\n+       that we have seen before and the corresponding register\n+       is dead afterwards, the register does not need to be\n+       moved conditionally.\n+     - If we encounter a previously changed register,\n+       rewire the read to the original source.  */\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      rtx set, src, dest;\n+\n+      if (!active_insn_p (insn))\n+\tcontinue;\n+\n+      set = single_set (insn);\n+      if (set == NULL_RTX)\n+\tcontinue;\n+\n+      src = SET_SRC (set);\n+      if (SUBREG_P (src))\n+\tsrc = SUBREG_REG (src);\n+      dest = SET_DEST (set);\n+\n+      /* Check if the current SET's source is the same\n+\t as any previously seen destination.\n+\t This is quadratic but the number of insns in BB\n+\t is bounded by PARAM_MAX_RTL_IF_CONVERSION_INSNS.  */\n+      if (REG_P (src))\n+\tfor (int i = count - 1; i >= 0; --i)\n+\t  if (reg_overlap_mentioned_p (src, dests[i]))\n+\t    {\n+\t      if (find_reg_note (insn, REG_DEAD, src) != NULL_RTX)\n+\t\tneed_no_cmov->add (insns[i]);\n+\t      else\n+\t\trewired_src->put (insn, i);\n+\t    }\n+\n+      insns.safe_push (insn);\n+      dests.safe_push (dest);\n+\n+      count++;\n+    }\n+}\n+\n /* Given a basic block BB suitable for conditional move conversion,\n    a condition COND, and pointer maps THEN_VALS and ELSE_VALS containing\n    the register values depending on COND, emit the insns in the block as"}]}