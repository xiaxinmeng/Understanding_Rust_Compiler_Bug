{"sha": "b49365b2a9bd4170aec2ceed613b7c5979337014", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5MzY1YjJhOWJkNDE3MGFlYzJjZWVkNjEzYjdjNTk3OTMzNzAxNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-05-29T08:06:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-29T08:06:40Z"}, "message": "sem_eval.adb (Is_Same_Value): Take care of several more cases\n\n2008-05-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb (Is_Same_Value): Take care of several more cases\n\nFrom-SVN: r136144", "tree": {"sha": "70fc3446870a6c6ff123f6e9970f5b46183e1bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70fc3446870a6c6ff123f6e9970f5b46183e1bae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b49365b2a9bd4170aec2ceed613b7c5979337014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49365b2a9bd4170aec2ceed613b7c5979337014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49365b2a9bd4170aec2ceed613b7c5979337014", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49365b2a9bd4170aec2ceed613b7c5979337014/comments", "author": null, "committer": null, "parents": [{"sha": "26ff8edeba735f0c4825c855c2375b9a9f9107f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ff8edeba735f0c4825c855c2375b9a9f9107f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ff8edeba735f0c4825c855c2375b9a9f9107f9"}], "stats": {"total": 75, "additions": 52, "deletions": 23}, "files": [{"sha": "e9bbd7b01534d284dd945dd6776d5f5b55a31120", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49365b2a9bd4170aec2ceed613b7c5979337014/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49365b2a9bd4170aec2ceed613b7c5979337014/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=b49365b2a9bd4170aec2ceed613b7c5979337014", "patch": "@@ -388,18 +388,17 @@ package body Sem_Eval is\n         (N : Node_Id;\n          R : out Node_Id;\n          V : out Uint);\n-      --  This procedure decomposes the node N into an expression node\n-      --  and a signed offset, so that the value of N is equal to the\n-      --  value of R plus the value V (which may be negative). If no\n-      --  such decomposition is possible, then on return R is a copy\n-      --  of N, and V is set to zero.\n+      --  This procedure decomposes the node N into an expression node and a\n+      --  signed offset, so that the value of N is equal to the value of R plus\n+      --  the value V (which may be negative). If no such decomposition is\n+      --  possible, then on return R is a copy of N, and V is set to zero.\n \n       function Compare_Fixup (N : Node_Id) return Node_Id;\n-      --  This function deals with replacing 'Last and 'First references\n-      --  with their corresponding type bounds, which we then can compare.\n-      --  The argument is the original node, the result is the identity,\n-      --  unless we have a 'Last/'First reference in which case the value\n-      --  returned is the appropriate type bound.\n+      --  This function deals with replacing 'Last and 'First references with\n+      --  their corresponding type bounds, which we then can compare. The\n+      --  argument is the original node, the result is the identity, unless we\n+      --  have a 'Last/'First reference in which case the value returned is the\n+      --  appropriate type bound.\n \n       function Is_Same_Value (L, R : Node_Id) return Boolean;\n       --  Returns True iff L and R represent expressions that definitely\n@@ -432,7 +431,6 @@ package body Sem_Eval is\n             return;\n \n          elsif Nkind (N) = N_Attribute_Reference  then\n-\n             if Attribute_Name (N) = Name_Succ then\n                R := First (Expressions (N));\n                V := Uint_1;\n@@ -570,13 +568,15 @@ package body Sem_Eval is\n       --  Start of processing for Is_Same_Value\n \n       begin\n-         --  Values are the same if they are the same identifier and the\n-         --  identifier refers to a constant object (E_Constant). This\n-         --  does not however apply to Float types, since we may have two\n-         --  NaN values and they should never compare equal.\n+         --  Values are the same if they refer to the same entity and the\n+         --  entity is a constant object (E_Constant). This does not however\n+         --  apply to Float types, since we may have two NaN values and they\n+         --  should never compare equal.\n \n-         if Nkind (Lf) = N_Identifier and then Nkind (Rf) = N_Identifier\n+         if Nkind_In (Lf, N_Identifier, N_Expanded_Name)\n+           and then Nkind_In (Rf, N_Identifier, N_Expanded_Name)\n            and then Entity (Lf) = Entity (Rf)\n+           and then Present (Entity (Lf))\n            and then not Is_Floating_Point_Type (Etype (L))\n            and then Is_Constant_Object (Entity (Lf))\n          then\n@@ -591,24 +591,53 @@ package body Sem_Eval is\n          then\n             return True;\n \n-         --  Or if they are both 'First or 'Last values applying to the\n-         --  same entity (first and last don't change even if value does)\n+         --  False if Nkind of the two nodes is different for remaining cases\n+\n+         elsif Nkind (Lf) /= Nkind (Rf) then\n+            return False;\n+\n+         --  True if both 'First or 'Last values applying to the same entity\n+         --  (first and last don't change even if value does). Note that we\n+         --  need this even with the calls to Compare_Fixup, to handle the\n+         --  case of unconstrained array attributes where Compare_Fixup\n+         --  cannot find useful bounds.\n \n          elsif Nkind (Lf) = N_Attribute_Reference\n-                 and then\n-               Nkind (Rf) = N_Attribute_Reference\n            and then Attribute_Name (Lf) = Attribute_Name (Rf)\n            and then (Attribute_Name (Lf) = Name_First\n                        or else\n                      Attribute_Name (Lf) = Name_Last)\n-           and then Is_Entity_Name (Prefix (Lf))\n-           and then Is_Entity_Name (Prefix (Rf))\n+           and then Nkind_In (Prefix (Lf), N_Identifier, N_Expanded_Name)\n+           and then Nkind_In (Prefix (Rf), N_Identifier, N_Expanded_Name)\n            and then Entity (Prefix (Lf)) = Entity (Prefix (Rf))\n            and then Is_Same_Subscript (Expressions (Lf), Expressions (Rf))\n          then\n             return True;\n \n-         --  All other cases, we can't tell\n+         --  True if the same selected component from the same record\n+\n+         elsif Nkind (Lf) = N_Selected_Component\n+           and then Selector_Name (Lf) = Selector_Name (Rf)\n+           and then Is_Same_Value (Prefix (Lf), Prefix (Rf))\n+         then\n+            return True;\n+\n+         --  True if the same unary operator applied to the same operand\n+\n+         elsif Nkind (Lf) in N_Unary_Op\n+           and then Is_Same_Value (Right_Opnd (Lf), Right_Opnd (Rf))\n+         then\n+            return True;\n+\n+         --  True if the same binary operator applied to the same operand\n+\n+         elsif Nkind (Lf) in N_Binary_Op\n+           and then Is_Same_Value (Left_Opnd  (Lf), Left_Opnd  (Rf))\n+           and then Is_Same_Value (Right_Opnd (Lf), Right_Opnd (Rf))\n+         then\n+            return True;\n+\n+         --  All other cases, we can't tell, so False\n \n          else\n             return False;"}]}