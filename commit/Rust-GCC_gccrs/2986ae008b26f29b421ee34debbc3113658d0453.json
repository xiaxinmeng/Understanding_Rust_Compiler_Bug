{"sha": "2986ae008b26f29b421ee34debbc3113658d0453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4NmFlMDA4YjI2ZjI5YjQyMWVlMzRkZWJiYzMxMTM2NThkMDQ1Mw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-19T20:19:03Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-19T20:19:03Z"}, "message": "38th Cygnus<->FSF merge\n\nFrom-SVN: r7337", "tree": {"sha": "6821be58065899a0af95c7612b289e6fe83ca054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6821be58065899a0af95c7612b289e6fe83ca054"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2986ae008b26f29b421ee34debbc3113658d0453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2986ae008b26f29b421ee34debbc3113658d0453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2986ae008b26f29b421ee34debbc3113658d0453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2986ae008b26f29b421ee34debbc3113658d0453/comments", "author": null, "committer": null, "parents": [{"sha": "639010aff2cc347f3900a47ad4948ae8c3e7cf4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/639010aff2cc347f3900a47ad4948ae8c3e7cf4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/639010aff2cc347f3900a47ad4948ae8c3e7cf4d"}], "stats": {"total": 3482, "additions": 1264, "deletions": 2218}, "files": [{"sha": "f4b142407d38504d7c0f20e8382efe725730bd76", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -1,3 +1,207 @@\n+Thu May 19 12:08:48 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (type_promotes_to): Make sure bool promotes to int rather\n+\tthan unsigned on platforms where sizeof(char)==sizeof(int).\n+\n+Wed May 18 14:27:06 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_c_cast): Tack on a NOP_EXPR when casting to\n+\tanother variant.\n+\t(build_modify_expr): Don't strip NOP_EXPRs, and don't get tricky\n+\tand treat them as lvalues.\n+\n+\t* decl.c (shadow_tag): Do complain about forward declarations of\n+\tenums and empty declarations.\n+\t* parse.y: Don't complain about forward declarations of enums and\n+\tempty declarations.\n+\n+\t* typeck.c (convert_for_assignment): Complain about changing\n+\tthe signedness of a pointer's target type.\n+\n+\t* parse.y (stmt): Move duplicated code for checking case values from\n+\there.\n+\t* decl2.c (check_cp_case_value): To here.  And add a call to\n+\tconstant_expression_warning.\n+\n+\t* typeck.c (convert_for_assignment): Don't complain about assigning\n+\ta negative value to bool.\n+\n+\t* decl.c (init_decl_processing): Make bool unsigned.\n+\n+\t* class.c (finish_struct): Allow bool bitfields.\n+\n+Wed May 18 14:41:59 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (finish_base_struct): Make sure we set BINFO_VTABLE and\n+\tBINFO_VIRTUALS when we choose a new base class to inherit from.\n+\t* class.c (modify_one_vtable): Use get_vfield_offset to get the\n+\toffset to the most base class subobject that we derived this binfo\n+\tfrom.\n+\t* class.c (finish_struct): Move code to calculate the\n+\tDECL_FIELD_BITPOS of the vfield up, as we need might need it for\n+\tnew calls to get_vfield_offset in modify_one_vtable.\n+\n+Wed May 18 12:35:27 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)\n+\n+\t* Make-lang.in (c++.install-man): Get g++.1 from $(srcdir)/cp.\n+\n+Wed May 18 03:28:35 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (build_type_conversion): Lose special handling of\n+\ttruthvalues.\n+\n+\t* search.c (dfs_pushdecls): Improve shadowing warning.\n+\n+Tue May 17 13:34:46 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (build_delete): Throw away const and volatile on `this'.\n+\n+\t* decl.c (finish_enum): Put the constants in TYPE_VALUES again,\n+\trather than the enumerators.\n+\t(pushtag): s/cdecl/c_decl/g\n+\n+Mon May 16 23:04:01 1994  Stephen R. van den Berg  (berg@pool.informatik.rwth-aachen.de)\n+\n+        * cp/typeck.c (common_type): Attribute merging.\n+        (comp_types): Utilise COMP_TYPE_ATTRIBUTES macro.\n+\n+        * cp/parse.y: Revamp attribute parsing.\n+\n+Mon May 16 01:40:34 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (shadow_tag): Also check for inappropriate use of auto and\n+\tregister.\n+\n+\t* method.c (build_overload_name): Clarify that the illegal case is a\n+\tpointer or reference to array of unknown bound.\n+\n+\t* error.c (dump_type_prefix): Print references to arrays properly.\n+\n+\t* typeck.c (various): Be more helpful in pointer\n+\tcomparison diagnostics.\n+\n+\t* tree.c (lvalue_p): MODIFY_EXPRs are lvalues again.  Isn't this\n+\tfun?\n+\n+\t* parse.y: Also catch an error after valid stmts.\n+\n+\t* search.c (dfs_init_vbase_pointers): Don't abort because `this' is\n+\tconst.\n+\n+\t* typeck.c (convert_for_initialization): If call to\n+\tconvert_to_reference generated a diagnostic, print out the parm\n+\tnumber and function decl if any.\n+\n+\t* errfn.c (cp_thing): Check atarg1 to determine whether or not we're\n+\tspecifying a line, not atarg.\n+\n+\t* tree.c (build_cplus_method_type): Always make `this' const.\n+\n+\t* decl2.c (grokclassfn): If -fthis-is-variable and this function is\n+\ta constructor or destructor, make `this' non-const.\n+\n+\t* typeck.c (build_modify_expr): Don't warn specially about\n+\tassignment to `this' here anymore, since it will be caught by the\n+\tusual machinery.\n+\n+\t* various: Disallow specific GNU extensions (variable-size arrays,\n+\tetc.) when flag_ansi is set, not necessarily when pedantic is set,\n+\tso that people can compile with -pedantic-errors for tighter const\n+\tchecking and such without losing desirable extensions.\n+\n+\t* typeck2.c (build_functional_cast): Call build_method_call with\n+\tLOOKUP_PROTECT.\n+\t(process_init_constructor): Only process FIELD_DECLs.\n+\n+\t* decl.c (finish_decl): Also force static consts with no explicit\n+\tinitializer that need constructing into the data segment.\n+\n+\t* init.c (build_delete): Undo last patch, as it interferes with\n+\tautomatic cleanups.\n+\n+Sat May 14 01:59:31 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c, class.h, cp-tree.h, cvt.c, decl2.c: Lose old overloading\n+\tcode.\n+\n+\t* init.c (build_delete): pedwarn about using plain delete to delete\n+\tan array.\n+\n+Fri May 13 16:45:07 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (comp_target_types): Be more helpful in contravariance\n+\twarnings, and make them pedwarns.\n+\n+\t* decl.c (grokdeclarator): Use decl_context to decide whether or not\n+\tthis is an access declaration.\n+\n+\t* class.c (finish_struct_bits): Set TYPE_HAS_INT_CONVERSION if it\n+\thas a conversion to enum or bool, too.\n+\n+Fri May 13 16:31:27 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* method.c (emit_thunk):  Make declaration for\n+\tcurrent_call_is_indirect local (needed for hppa).\n+\n+Fri May 13 16:16:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (uses_template_parms): Grok BOOLEAN_TYPE.\n+\t(tsubst): Ditto.\n+\n+Fri May 13 16:23:32 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* pt.c (tsubst): If there is already a function for this expansion,\n+\tuse it.\n+\t* pt.c (instantiate_template): Ditto.\n+\n+Fri May 13 10:30:42 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* parse.y (implicitly_scoped_stmt, simple_stmt case): Use\n+\tkept_level_p for MARK_ENDS argument to expand_end_bindings, to avoid\n+\tgenerating debug info for unemitted symbols on some systems.\n+\n+\t* cp-tree.h (build_static_cast, build_reinterpret_cast,\n+\tbuild_const_cast): Add declarations.\n+\n+Fri May 13 09:50:31 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* search.c (expand_indirect_vtbls_init): Fix breakage from Apr 27\n+\tfix.  We now try get_binfo, and if that doesn't find what we want,\n+\twe go back to the old method, which still sometimes fails.\n+\n+Fri May 13 01:43:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (initdcl): Call cplus_decl_attributes on the right\n+\tvariable.\n+\t* decl2.c (cplus_decl_attributes): Don't call decl_attributes for\n+\tvoid_type_node.\n+\n+\t* typeck.c (build_binary_op_nodefault): Change result_type for\n+\tcomparison ops to bool.\n+\t(build_binary_op): Convert args of && and || to bool.\n+\t* cvt.c (build_default_binary_type_conversion): Convert args of &&\n+\tand || to bool.\n+\t(build_default_unary_type_conversion): Convert arg of ! to bool.\n+\t(type_promotes_to): bool promotes to int.\n+\n+Fri May 13 01:43:18 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\tImplement the new builtin `bool' type.\n+\t* typeck.c (build_binary_op_nodefault): Convert args of && and || to\n+\tbool.\n+\t(build_unary_op): Convert arg of ! to bool.\n+\t* parse.y: Know true and false.  Use bool_truthvalue_conversion.\n+\t* method.c (build_overload_value): Know bool.\n+\t(build_overload_name): Ditto.\n+\t* lex.c (init_lex): Set up RID_BOOL.\n+\t* gxx.gperf: Add bool, true, false.\n+\t* error.c (*): Know bool.\n+\t* decl.c (init_decl_processing): Set up bool, true, false.\n+\t* cvt.c (cp_convert): Handle conversion to bool.\n+\t(build_type_conversion): Ditto.\n+\t* *.c: Accept bool where integers and enums are accepted (use\n+\tINTEGRAL_CODE_P macro).\n+\n Thu May 12 19:13:54 1994  Richard Earnshaw  (rwe11@cl.cam.ac.uk)\n \n \t* g++.c: Use #ifdef for __MSDOS__, not #if."}, {"sha": "e957776711d4f0082768d3a1c9cc005843cad460", "filename": "gcc/cp/call.c", "status": "modified", "additions": 302, "deletions": 1572, "changes": 1874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -44,38 +44,17 @@ extern tree unary_complex_lvalue ();\n \n /* Compute the ease with which a conversion can be performed\n    between an expected and the given type.  */\n-static int convert_harshness_old ();\n-static struct harshness_code convert_harshness_ansi ();\n-\n-/* OLD METHOD */\n-/* Note the old method also uses USER_HARSHNESS, BASE_DERIVED_HARSHNESS,\n-   CONST_HARSHNESS.  */\n-#define EVIL 1\n-#define TRIVIAL 0\n-#define EVIL_HARSHNESS(ARG) ((ARG) & 1)\n-#define ELLIPSIS_HARSHNESS(ARG) ((ARG) & 2)\n-#define CONTRAVARIANT_HARSHNESS(ARG) ((ARG) & 8)\n-#define INT_TO_BD_HARSHNESS(ARG) (((ARG) << 5) | 16)\n-#define INT_FROM_BD_HARSHNESS(ARG) ((ARG) >> 5)\n-#define INT_TO_EASY_HARSHNESS(ARG) ((ARG) << 5)\n-#define INT_FROM_EASY_HARSHNESS(ARG) ((ARG) >> 5)\n-#define ONLY_EASY_HARSHNESS(ARG) (((ARG) & 31) == 0)\n-\n-\n-/* NEW METHOD */\n+static struct harshness_code convert_harshness ();\n+\n #define EVIL_RETURN(ARG)\t((ARG).code = EVIL_CODE, (ARG))\n #define QUAL_RETURN(ARG)\t((ARG).code = QUAL_CODE, (ARG))\n #define TRIVIAL_RETURN(ARG)\t((ARG).code = TRIVIAL_CODE, (ARG))\n #define ZERO_RETURN(ARG)\t((ARG).code = 0, (ARG))\n \n-#define USER_HARSHNESS(ARG) ((ARG) & 4)\n-#define BASE_DERIVED_HARSHNESS(ARG) ((ARG) & 16)\n-#define CONST_HARSHNESS(ARG) ((ARG) & 2048)\n-\n /* Ordering function for overload resolution.  Compare two candidates\n    by gross quality.  */\n int\n-rank_for_overload_ansi (x, y)\n+rank_for_overload (x, y)\n      struct candidate *x, *y;\n {\n   if (y->h.code & (EVIL_CODE|ELLIPSIS_CODE|USER_CODE))\n@@ -85,8 +64,8 @@ rank_for_overload_ansi (x, y)\n \n   /* This is set by compute_conversion_costs, for calling a non-const\n      member function from a const member function.  */\n-  if ((y->v.ansi_harshness[0].code & CONST_CODE) ^ (x->v.ansi_harshness[0].code & CONST_CODE))\n-    return y->v.ansi_harshness[0].code - x->v.ansi_harshness[0].code;\n+  if ((y->harshness[0].code & CONST_CODE) ^ (x->harshness[0].code & CONST_CODE))\n+    return y->harshness[0].code - x->harshness[0].code;\n \n   if (y->h.code & STD_CODE)\n     {\n@@ -100,33 +79,6 @@ rank_for_overload_ansi (x, y)\n   return y->h.code - x->h.code;\n }\n \n-int\n-rank_for_overload_old (x, y)\n-     struct candidate *x, *y;\n-{\n-  if (y->evil - x->evil)\n-    return y->evil - x->evil;\n-  if (CONST_HARSHNESS (y->v.old_harshness[0]) ^ CONST_HARSHNESS (x->v.old_harshness[0]))\n-    return y->v.old_harshness[0] - x->v.old_harshness[0];\n-  if (y->ellipsis - x->ellipsis)\n-    return y->ellipsis - x->ellipsis;\n-  if (y->user - x->user)\n-    return y->user - x->user;\n-  if (y->b_or_d - x->b_or_d)\n-    return y->b_or_d - x->b_or_d;\n-  return y->easy - x->easy;\n-}\n-\n-int\n-rank_for_overload (x, y)\n-     struct candidate *x, *y;\n-{\n-  if (flag_ansi_overloading)\n-    return rank_for_overload_ansi (x, y);\n-  else\n-    return rank_for_overload_old (x, y);\n-}\n-\n /* Compare two candidates, argument by argument.  */\n int\n rank_for_ideal (x, y)\n@@ -139,17 +91,17 @@ rank_for_ideal (x, y)\n \n   for (i = 0; i < x->h_len; i++)\n     {\n-      if (y->v.ansi_harshness[i].code - x->v.ansi_harshness[i].code)\n-\treturn y->v.ansi_harshness[i].code - x->v.ansi_harshness[i].code;\n-      if ((y->v.ansi_harshness[i].code & STD_CODE)\n-\t  && (y->v.ansi_harshness[i].distance - x->v.ansi_harshness[i].distance))\n-\treturn y->v.ansi_harshness[i].distance - x->v.ansi_harshness[i].distance;\n+      if (y->harshness[i].code - x->harshness[i].code)\n+\treturn y->harshness[i].code - x->harshness[i].code;\n+      if ((y->harshness[i].code & STD_CODE)\n+\t  && (y->harshness[i].distance - x->harshness[i].distance))\n+\treturn y->harshness[i].distance - x->harshness[i].distance;\n \n       /* They're both the same code.  Now see if we're dealing with an\n \t integral promotion that needs a finer grain of accuracy.  */\n-      if (y->v.ansi_harshness[0].code & PROMO_CODE\n-\t  && (y->v.ansi_harshness[i].int_penalty ^ x->v.ansi_harshness[i].int_penalty))\n-\treturn y->v.ansi_harshness[i].int_penalty - x->v.ansi_harshness[i].int_penalty;\n+      if (y->harshness[0].code & PROMO_CODE\n+\t  && (y->harshness[i].int_penalty ^ x->harshness[i].int_penalty))\n+\treturn y->harshness[i].int_penalty - x->harshness[i].int_penalty;\n     }\n   return 0;\n }\n@@ -158,7 +110,7 @@ rank_for_ideal (x, y)\n    we have to work with.  We use a somewhat arbitrary cost function\n    to measure this conversion.  */\n static struct harshness_code\n-convert_harshness_ansi (type, parmtype, parm)\n+convert_harshness (type, parmtype, parm)\n      register tree type, parmtype;\n      tree parm;\n {\n@@ -213,7 +165,7 @@ convert_harshness_ansi (type, parmtype, parm)\n       /* Compare return types.  */\n       p1 = TREE_TYPE (type);\n       p2 = TREE_TYPE (parmtype);\n-      h2 = convert_harshness_ansi (p1, p2, NULL_TREE);\n+      h2 = convert_harshness (p1, p2, NULL_TREE);\n       if (h2.code & EVIL_CODE)\n \treturn h2;\n \n@@ -262,7 +214,7 @@ convert_harshness_ansi (type, parmtype, parm)\n       while (p1 && TREE_VALUE (p1) != void_type_node\n \t     && p2 && TREE_VALUE (p2) != void_type_node)\n \t{\n-\t  h2 = convert_harshness_ansi (TREE_VALUE (p1), TREE_VALUE (p2),\n+\t  h2 = convert_harshness (TREE_VALUE (p1), TREE_VALUE (p2),\n \t\t\t\t       NULL_TREE);\n \t  if (h2.code & EVIL_CODE)\n \t    return h2;\n@@ -341,7 +293,7 @@ convert_harshness_ansi (type, parmtype, parm)\n   if (coder == VOID_TYPE)\n     return EVIL_RETURN (h);\n \n-  if (codel == ENUMERAL_TYPE || codel == INTEGER_TYPE)\n+  if (INTEGRAL_CODE_P (codel))\n     {\n       /* Control equivalence of ints an enums.  */\n \n@@ -356,7 +308,7 @@ convert_harshness_ansi (type, parmtype, parm)\n \n       /* else enums and ints (almost) freely interconvert.  */\n \n-      if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n+      if (INTEGRAL_CODE_P (coder))\n \t{\n \t  if (TYPE_MAIN_VARIANT (type)\n \t      == TYPE_MAIN_VARIANT (type_promotes_to (parmtype)))\n@@ -395,7 +347,7 @@ convert_harshness_ansi (type, parmtype, parm)\n \t    \n \t  return h;\n \t}\n-      else if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n+      else if (INTEGRAL_CODE_P (coder))\n \t{\n \t  h.code = STD_CODE;\n \t  h.distance = 0;\n@@ -625,12 +577,11 @@ convert_harshness_ansi (type, parmtype, parm)\n \t   matter if we make life easier for the programmer\n \t   by creating a temporary variable with which to\n \t   hold the result.  */\n-\tif (parm && (coder == INTEGER_TYPE\n-\t\t     || coder == ENUMERAL_TYPE\n+\tif (parm && (INTEGRAL_CODE_P (coder)\n \t\t     || coder == REAL_TYPE)\n \t    && ! lvalue_p (parm))\n \t  {\n-\t    h = convert_harshness_ansi (ttl, ttr, NULL_TREE);\n+\t    h = convert_harshness (ttl, ttr, NULL_TREE);\n \t    if (penalty > 2 || h.code != 0)\n \t      h.code |= STD_CODE;\n \t    else\n@@ -672,7 +623,7 @@ convert_harshness_ansi (type, parmtype, parm)\n \n \tif (parm && codel != REFERENCE_TYPE)\n \t  {\n-\t    h = convert_harshness_ansi (ttl, ttr, NULL_TREE);\n+\t    h = convert_harshness (ttl, ttr, NULL_TREE);\n \t    if (penalty == 2)\n \t      h.code |= QUAL_CODE;\n \t    else if (penalty == 4)\n@@ -731,967 +682,215 @@ convert_harshness_ansi (type, parmtype, parm)\n   return EVIL_RETURN (h);\n }\n \n-/* TYPE is the type we wish to convert to.  PARM is the parameter\n-   we have to work with.  We use a somewhat arbitrary cost function\n-   to measure this conversion.  */\n-static int\n-convert_harshness_old (type, parmtype, parm)\n-     register tree type, parmtype;\n-     tree parm;\n+#ifdef DEBUG_MATCHING\n+static char *\n+print_harshness (h)\n+     struct harshness_code *h;\n {\n-  register enum tree_code codel;\n-  register enum tree_code coder;\n+  static char buf[1024];\n+  char tmp[1024];\n \n-#ifdef GATHER_STATISTICS\n-  n_convert_harshness++;\n-#endif\n+  bzero (buf, 1024 * sizeof (char));\n+  strcat (buf, \"codes=[\");\n+  if (h->code & EVIL_CODE)\n+    strcat (buf, \"EVIL\");\n+  if (h->code & CONST_CODE)\n+    strcat (buf, \" CONST\");\n+  if (h->code & ELLIPSIS_CODE)\n+    strcat (buf, \" ELLIPSIS\");\n+  if (h->code & USER_CODE)\n+    strcat (buf, \" USER\");\n+  if (h->code & STD_CODE)\n+    strcat (buf, \" STD\");\n+  if (h->code & PROMO_CODE)\n+    strcat (buf, \" PROMO\");\n+  if (h->code & QUAL_CODE)\n+    strcat (buf, \" QUAL\");\n+  if (h->code & TRIVIAL_CODE)\n+    strcat (buf, \" TRIVIAL\");\n+  if (buf[0] == '\\0')\n+    strcat (buf, \"0\");\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  if (TYPE_PTRMEMFUNC_P (parmtype))\n-    parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n+  sprintf (tmp, \"] distance=%d int_penalty=%d\", h->distance, h->int_penalty);\n \n-  codel = TREE_CODE (type);\n-  coder = TREE_CODE (parmtype);\n+  strcat (buf, tmp);\n \n-  if (TYPE_MAIN_VARIANT (parmtype) == TYPE_MAIN_VARIANT (type))\n-    return TRIVIAL;\n+  return buf;\n+}\n+#endif\n \n-  if (coder == ERROR_MARK)\n-    return EVIL;\n+/* Algorithm: For each argument, calculate how difficult it is to\n+   make FUNCTION accept that argument.  If we can easily tell that\n+   FUNCTION won't be acceptable to one of the arguments, then we\n+   don't need to compute the ease of converting the other arguments,\n+   since it will never show up in the intersection of all arguments'\n+   favorite functions.\n \n-  if (codel == POINTER_TYPE && fntype_p (parmtype))\n-    {\n-      tree p1, p2;\n-      int harshness, new_harshness;\n+   Conversions between builtin and user-defined types are allowed, but\n+   no function involving such a conversion is preferred to one which\n+   does not require such a conversion.  Furthermore, such conversions\n+   must be unique.  */\n \n-      /* Get to the METHOD_TYPE or FUNCTION_TYPE that this might be.  */\n-      type = TREE_TYPE (type);\n+void\n+compute_conversion_costs (function, tta_in, cp, arglen)\n+     tree function;\n+     tree tta_in;\n+     struct candidate *cp;\n+     int arglen;\n+{\n+  tree ttf_in = TYPE_ARG_TYPES (TREE_TYPE (function));\n+  tree ttf = ttf_in;\n+  tree tta = tta_in;\n \n-      if (coder == POINTER_TYPE)\n-\t{\n-\t  parmtype = TREE_TYPE (parmtype);\n-\t  coder = TREE_CODE (parmtype);\n-\t}\n+  /* Start out with no strikes against.  */\n+  int evil_strikes = 0;\n+  int ellipsis_strikes = 0;\n+  int user_strikes = 0;\n+  int b_or_d_strikes = 0;\n+  int easy_strikes = 0;\n \n-      if (coder != TREE_CODE (type))\n-\treturn EVIL;\n+  int strike_index = 0, win;\n+  struct harshness_code lose;\n \n-      harshness = 0;\n+#ifdef GATHER_STATISTICS\n+  n_compute_conversion_costs++;\n+#endif\n \n-      /* We allow the default conversion between function type\n-\t and pointer-to-function type for free.  */\n-      if (type == parmtype)\n-\treturn TRIVIAL;\n+  cp->function = function;\n+  cp->arg = tta ? TREE_VALUE (tta) : NULL_TREE;\n+  cp->u.bad_arg = 0;\t\t/* optimistic!  */\n \n-      /* Compare return types.  */\n-      p1 = TREE_TYPE (type);\n-      p2 = TREE_TYPE (parmtype);\n-      new_harshness = convert_harshness_old (p1, p2, NULL_TREE);\n-      if (EVIL_HARSHNESS (new_harshness))\n-\treturn EVIL;\n+  cp->h.code = 0;\n+  cp->h.distance = 0;\n+  cp->h.int_penalty = 0;\n+  bzero (cp->harshness,\n+\t (cp->h_len + 1) * sizeof (struct harshness_code));\n \n-      if (BASE_DERIVED_HARSHNESS (new_harshness))\n-\t{\n-\t  tree binfo;\n+  while (ttf && tta)\n+    {\n+      struct harshness_code h;\n \n-\t  /* This only works for pointers.  */\n-\t  if (TREE_CODE (p1) != POINTER_TYPE\n-\t      && TREE_CODE (p1) != REFERENCE_TYPE)\n-\t    return EVIL;\n+      if (ttf == void_list_node)\n+\tbreak;\n \n-\t  p1 = TREE_TYPE (p1);\n-\t  p2 = TREE_TYPE (p2);\n-\t  /* Don't die if we happen to be dealing with void*.  */\n-\t  if (!IS_AGGR_TYPE (p1) || !IS_AGGR_TYPE (p2))\n-\t    return EVIL;\n-\t  if (CONTRAVARIANT_HARSHNESS (new_harshness))\n-\t    binfo = get_binfo (p2, p1, 0);\n-\t  else\n-\t    binfo = get_binfo (p1, p2, 0);\n+      if (type_unknown_p (TREE_VALUE (tta)))\n+\t{\t  \n+\t  /* Must perform some instantiation here.  */\n+\t  tree rhs = TREE_VALUE (tta);\n+\t  tree lhstype = TREE_VALUE (ttf);\n \n-\t  if (! BINFO_OFFSET_ZEROP (binfo))\n-\t    {\n-\t      static int explained = 0;\n-\t      if (CONTRAVARIANT_HARSHNESS (new_harshness))\n-\t\tmessage_2_types (sorry, \"cannot cast `%d' to `%d' at function call site\", p2, p1);\n-\t      else\n-\t\tmessage_2_types (sorry, \"cannot cast `%d' to `%d' at function call site\", p1, p2);\n+\t  /* Keep quiet about possible contravariance violations.  */\n+\t  int old_inhibit_warnings = inhibit_warnings;\n+\t  inhibit_warnings = 1;\n \n-\t      if (! explained++)\n-\t\tsorry (\"(because pointer values change during conversion)\");\n-\t      return EVIL;\n-\t    }\n-\t}\n+\t  /* @@ This is to undo what `grokdeclarator' does to\n+\t     parameter types.  It really should go through\n+\t     something more general.  */\n \n-      harshness |= new_harshness;\n+\t  TREE_TYPE (tta) = unknown_type_node;\n+\t  rhs = instantiate_type (lhstype, rhs, 0);\n+\t  inhibit_warnings = old_inhibit_warnings;\n \n-      p1 = TYPE_ARG_TYPES (type);\n-      p2 = TYPE_ARG_TYPES (parmtype);\n-      while (p1 && TREE_VALUE (p1) != void_type_node\n-\t     && p2 && TREE_VALUE (p2) != void_type_node)\n+\t  if (TREE_CODE (rhs) == ERROR_MARK)\n+\t    h.code = EVIL_CODE;\n+\t  else\n+\t    h = convert_harshness (lhstype, TREE_TYPE (rhs), rhs);\n+\t}\n+      else\n \t{\n-\t  new_harshness = convert_harshness_old (TREE_VALUE (p1),\n-\t\t\t\t\t\t TREE_VALUE (p2), NULL_TREE);\n-\t  if (EVIL_HARSHNESS (new_harshness))\n-\t    return EVIL;\n+#ifdef DEBUG_MATCHING\n+\t  static tree old_function = NULL_TREE;\n \n-\t  if (BASE_DERIVED_HARSHNESS (new_harshness))\n+\t  if (!old_function || function != old_function)\n \t    {\n-\t      /* This only works for pointers and references. */\n-\t      if (TREE_CODE (TREE_VALUE (p1)) != POINTER_TYPE\n-\t\t  && TREE_CODE (TREE_VALUE (p1)) != REFERENCE_TYPE)\n-\t\treturn EVIL;\n-\t      new_harshness ^= CONTRAVARIANT_HARSHNESS (new_harshness);\n-\t      harshness |= new_harshness;\n+\t      cp_error (\"trying %D\", function);\n+\t      old_function = function;\n \t    }\n-\t  /* This trick allows use to accumulate easy type\n-\t     conversions without messing up the bits that encode\n-\t     info about more involved things.  */\n-\t  else if (ONLY_EASY_HARSHNESS (new_harshness))\n-\t    harshness += new_harshness;\n-\t  else\n-\t    harshness |= new_harshness;\n-\t  p1 = TREE_CHAIN (p1);\n-\t  p2 = TREE_CHAIN (p2);\n-\t}\n-      if (p1 == p2)\n-\treturn harshness;\n-      if (p2)\n-\treturn p1 ? EVIL : (harshness | ELLIPSIS_HARSHNESS (-1));\n-      if (p1)\n-\treturn harshness | (TREE_PURPOSE (p1) == NULL_TREE);\n-    }\n-  else if (codel == POINTER_TYPE && coder == OFFSET_TYPE)\n-    {\n-      /* XXX: Note this is set a few times, but it's never actually\n-\t used! (bpk) */\n-      int harshness;\n \n-      /* Get to the OFFSET_TYPE that this might be.  */\n-      type = TREE_TYPE (type);\n+\t  cp_error (\"      doing (%T) %E against arg %T\",\n+\t\t    TREE_TYPE (TREE_VALUE (tta)), TREE_VALUE (tta),\n+\t\t    TREE_VALUE (ttf));\n+#endif\n \n-      if (coder != TREE_CODE (type))\n-\treturn EVIL;\n+\t  h = convert_harshness (TREE_VALUE (ttf),\n+\t\t\t\t      TREE_TYPE (TREE_VALUE (tta)),\n+\t\t\t\t      TREE_VALUE (tta));\n \n-      harshness = 0;\n+#ifdef DEBUG_MATCHING\n+\t  cp_error (\"     evaluated %s\", print_harshness (&h));\n+#endif\n+\t}\n \n-      if (TYPE_OFFSET_BASETYPE (type) == TYPE_OFFSET_BASETYPE (parmtype))\n-\tharshness = 0;\n-      else if (UNIQUELY_DERIVED_FROM_P (TYPE_OFFSET_BASETYPE (type),\n-\t\t\t       TYPE_OFFSET_BASETYPE (parmtype)))\n-\tharshness = INT_TO_BD_HARSHNESS (1);\n-      else if (UNIQUELY_DERIVED_FROM_P (TYPE_OFFSET_BASETYPE (parmtype),\n-\t\t\t       TYPE_OFFSET_BASETYPE (type)))\n-\tharshness = CONTRAVARIANT_HARSHNESS (-1);\n+      cp->harshness[strike_index] = h;\n+      if ((h.code & EVIL_CODE)\n+\t  || ((h.code & STD_CODE) && h.distance < 0))\n+\t{\n+\t  cp->u.bad_arg = strike_index;\n+\t  evil_strikes = 1;\n+\t}\n+     else if (h.code & ELLIPSIS_CODE)\n+       ellipsis_strikes += 1;\n+#if 0\n+      /* This is never set by `convert_harshness'.  */\n+      else if (h.code & USER_CODE)\n+\t{\n+\t  user_strikes += 1;\n+\t}\n+#endif\n       else\n-\treturn EVIL;\n-      /* Now test the OFFSET_TYPE's target compatibility.  */\n-      type = TREE_TYPE (type);\n-      parmtype = TREE_TYPE (parmtype);\n-    }\n+\t{\n+\t  if ((h.code & STD_CODE) && h.distance)\n+\t    {\n+\t      if (h.distance > b_or_d_strikes)\n+\t\tb_or_d_strikes = h.distance;\n+\t    }\n+\t  else\n+\t    easy_strikes += (h.code & (STD_CODE|PROMO_CODE|TRIVIAL_CODE));\n+\t  cp->h.code |= h.code;\n+\t  /* Make sure we communicate this.  */\n+\t  cp->h.int_penalty += h.int_penalty;\n+\t}\n \n-  if (coder == UNKNOWN_TYPE)\n-    {\n-      if (codel == FUNCTION_TYPE\n-\t  || codel == METHOD_TYPE\n-\t  || (codel == POINTER_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)))\n-\treturn TRIVIAL;\n-      return EVIL;\n+      ttf = TREE_CHAIN (ttf);\n+      tta = TREE_CHAIN (tta);\n+      strike_index += 1;\n     }\n \n-  if (coder == VOID_TYPE)\n-    return EVIL;\n-\n-  if (codel == ENUMERAL_TYPE || codel == INTEGER_TYPE)\n+  if (tta)\n     {\n-      /* Control equivalence of ints an enums.  */\n-\n-      if (codel == ENUMERAL_TYPE\n-\t  && flag_int_enum_equivalence == 0)\n-\t{\n-\t  /* Enums can be converted to ints, but not vice-versa.  */\n-\t  if (coder != ENUMERAL_TYPE\n-\t      || TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (parmtype))\n-\t    return EVIL;\n-\t}\n-\n-      /* else enums and ints (almost) freely interconvert.  */\n-\n-      if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n-\t{\n-\t  int easy = TREE_UNSIGNED (type) ^ TREE_UNSIGNED (parmtype);\n-\t  if (codel != coder)\n-\t    easy += 1;\n-\t  if (TYPE_MODE (type) != TYPE_MODE (parmtype))\n-\t    easy += 2;\n-\t  return INT_TO_EASY_HARSHNESS (easy);\n-\t}\n-      else if (coder == REAL_TYPE)\n-\treturn INT_TO_EASY_HARSHNESS (4);\n-    }\n-\n-  if (codel == REAL_TYPE)\n-    if (coder == REAL_TYPE)\n-      /* Shun converting between float and double if a choice exists.  */\n-      {\n-\tif (TYPE_MODE (type) != TYPE_MODE (parmtype))\n-\t  return INT_TO_EASY_HARSHNESS (2);\n-\treturn TRIVIAL;\n-      }\n-    else if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n-      return INT_TO_EASY_HARSHNESS (4);\n-\n-  /* convert arrays which have not previously been converted.  */\n-  if (codel == ARRAY_TYPE)\n-    codel = POINTER_TYPE;\n-  if (coder == ARRAY_TYPE)\n-    coder = POINTER_TYPE;\n-\n-  /* Conversions among pointers */\n-  if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n-    {\n-      register tree ttl = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      register tree ttr = TYPE_MAIN_VARIANT (TREE_TYPE (parmtype));\n-      int penalty = 4 * (ttl != ttr);\n-      /* Anything converts to void *.  void * converts to anything.\n-\t Since these may be `const void *' (etc.) use VOID_TYPE\n-\t instead of void_type_node.\n-\t Otherwise, the targets must be the same,\n-\t except that we do allow (at some cost) conversion\n-\t between signed and unsinged pointer types.  */\n-\n-      if ((TREE_CODE (ttl) == METHOD_TYPE\n-\t   || TREE_CODE (ttl) == FUNCTION_TYPE)\n-\t  && TREE_CODE (ttl) == TREE_CODE (ttr))\n-\t{\n-\t  if (comptypes (ttl, ttr, -1))\n-\t    return INT_TO_EASY_HARSHNESS (penalty);\n-\t  return EVIL;\n-\t}\n-\n-      if (!(TREE_CODE (ttl) == VOID_TYPE\n-\t    || TREE_CODE (ttr) == VOID_TYPE\n-\t    || (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (ttr)\n-\t\t&& (ttl = unsigned_type (ttl),\n-\t\t    ttr = unsigned_type (ttr),\n-\t\t    penalty = 10, 0))\n-\t    || (comp_target_types (ttl, ttr, 0))))\n-\treturn EVIL;\n-\n-      if (penalty == 10)\n-\treturn INT_TO_EASY_HARSHNESS (10);\n-      if (ttr == ttl)\n-\treturn INT_TO_BD_HARSHNESS (0);\n-\n-      if (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n-\t{\n-\t  int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n-\t  if (b_or_d < 0)\n-\t    {\n-\t      b_or_d = get_base_distance (ttr, ttl, 0, 0);\n-\t      if (b_or_d < 0)\n-\t\treturn EVIL;\n-\t      return CONTRAVARIANT_HARSHNESS (-1);\n-\t    }\n-\t  return INT_TO_BD_HARSHNESS (b_or_d);\n-\t}\n-      /* If converting from a `class*' to a `void*', make it\n-\t less favorable than any inheritance relationship.  */\n-      if (TREE_CODE (ttl) == VOID_TYPE && IS_AGGR_TYPE (ttr))\n-\treturn INT_TO_BD_HARSHNESS (CLASSTYPE_MAX_DEPTH (ttr)+1);\n-      return INT_TO_EASY_HARSHNESS (penalty);\n-    }\n-\n-  if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n-    {\n-      /* This is not a bad match, but don't let it beat\n-\t integer-enum combinations.  */\n-      if (parm && integer_zerop (parm))\n-\treturn INT_TO_EASY_HARSHNESS (4);\n-    }\n-\n-  /* C++: Since the `this' parameter of a signature member function\n-     is represented as a signature pointer to handle default implementations\n-     correctly, we can have the case that `type' is a signature pointer\n-     while `parmtype' is a pointer to a signature table.  We don't really\n-     do any conversions in this case, so just return 0.  */\n-\n-  if (codel == RECORD_TYPE && coder == POINTER_TYPE\n-      && IS_SIGNATURE_POINTER (type) && IS_SIGNATURE (TREE_TYPE (parmtype)))\n-    return 0;\n-\n-  /* C++: one of the types must be a reference type.  */\n-  {\n-    tree ttl, ttr;\n-    register tree intype = TYPE_MAIN_VARIANT (parmtype);\n-    register enum tree_code form = TREE_CODE (intype);\n-    int penalty;\n-\n-    if (codel == REFERENCE_TYPE || coder == REFERENCE_TYPE)\n-      {\n-\tttl = TYPE_MAIN_VARIANT (type);\n-\n-\tif (codel == REFERENCE_TYPE)\n-\t  {\n-\t    ttl = TREE_TYPE (ttl);\n-\n-\t    /* When passing a non-const argument into a const reference,\n-\t       dig it a little, so a non-const reference is preferred over\n-\t       this one. (mrs) */\n-\t    if (parm && TREE_READONLY (ttl) && ! TREE_READONLY (parm))\n-\t      penalty = 2;\n-\t    else\n-\t      penalty = 0;\n-\n-\t    ttl = TYPE_MAIN_VARIANT (ttl);\n-\n-\t    if (form == OFFSET_TYPE)\n-\t      {\n-\t\tintype = TREE_TYPE (intype);\n-\t\tform = TREE_CODE (intype);\n-\t      }\n-\n-\t    if (form == REFERENCE_TYPE)\n-\t      {\n-\t\tintype = TYPE_MAIN_VARIANT (TREE_TYPE (intype));\n-\n-\t\tif (ttl == intype)\n-\t\t  return TRIVIAL;\n-\t\tpenalty = 2;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Can reference be built up?  */\n-\t\tif (ttl == intype && penalty == 0) {\n-\t\t  /* Because the READONLY bits and VIRTUAL bits are not always\n-\t\t     in the type, this extra check is necessary.  The problem\n-\t\t     should be fixed someplace else, and this extra code\n-\t\t     removed.\n-\n-\t\t     Also, if type if a reference, the readonly bits could\n-\t\t     either be in the outer type (with reference) or on the\n-\t\t     inner type (the thing being referenced).  (mrs)  */\n-\t\t  if (parm\n-\t\t      && ((TREE_READONLY (parm)\n-\t\t\t   && ! (TYPE_READONLY (type)\n-\t\t\t\t || (TREE_CODE (type) == REFERENCE_TYPE\n-\t\t\t\t     && TYPE_READONLY (TREE_TYPE (type)))))\n-\t\t\t  || (TREE_SIDE_EFFECTS (parm)\n-\t\t\t      && ! (TYPE_VOLATILE (type)\n-\t\t\t\t    || (TREE_CODE (type) == REFERENCE_TYPE\n-\t\t\t\t\t&& TYPE_VOLATILE (TREE_TYPE (type)))))))\n-\t\t    penalty = 2;\n-\t\t  else\n-\t\t    return TRIVIAL;\n-\t\t}\n-\t\telse\n-\t\t  penalty = 2;\n-\t      }\n-\t  }\n-\telse if (form == REFERENCE_TYPE)\n-\t  {\n-\t    if (parm)\n-\t      {\n-\t\ttree tmp = convert_from_reference (parm);\n-\t\tintype = TYPE_MAIN_VARIANT (TREE_TYPE (tmp));\n-\t      }\n-\t    else\n-\t      {\n-\t\tintype = parmtype;\n-\t\tdo\n-\t\t  {\n-\t\t    intype = TREE_TYPE (intype);\n-\t\t  }\n-\t\twhile (TREE_CODE (intype) == REFERENCE_TYPE);\n-\t\tintype = TYPE_MAIN_VARIANT (intype);\n-\t      }\n-\n-\t    if (ttl == intype)\n-\t      return TRIVIAL;\n-\t    else\n-\t      penalty = 2;\n-\t  }\n-\n-\tif (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n-\t  {\n-\t    ttl = unsigned_type (ttl);\n-\t    intype = unsigned_type (intype);\n-\t    penalty += 2;\n-\t  }\n-\n-\tttr = intype;\n-\n-\t/* If the initializer is not an lvalue, then it does not\n-\t   matter if we make life easier for the programmer\n-\t   by creating a temporary variable with which to\n-\t   hold the result.  */\n-\tif (parm && (coder == INTEGER_TYPE\n-\t\t     || coder == ENUMERAL_TYPE\n-\t\t     || coder == REAL_TYPE)\n-\t    && ! lvalue_p (parm))\n-\t  return (convert_harshness_old (ttl, ttr, NULL_TREE)\n-\t\t  | INT_TO_EASY_HARSHNESS (penalty));\n-\n-\tif (ttl == ttr)\n-\t  {\n-\t    if (penalty)\n-\t      return INT_TO_EASY_HARSHNESS (penalty);\n-\t    return INT_TO_BD_HARSHNESS (0);\n-\t  }\n-\n-\t/* Pointers to voids always convert for pointers.  But\n-\t   make them less natural than more specific matches.  */\n-\tif (TREE_CODE (ttl) == POINTER_TYPE && TREE_CODE (ttr) == POINTER_TYPE)\n-\t  if (TREE_TYPE (ttl) == void_type_node\n-\t      || TREE_TYPE (ttr) == void_type_node)\n-\t    return INT_TO_EASY_HARSHNESS (penalty+1);\n-\n-\tif (parm && codel != REFERENCE_TYPE)\n-\t  return (convert_harshness_old (ttl, ttr, NULL_TREE)\n-\t\t  | INT_TO_EASY_HARSHNESS (penalty));\n-\n-\t/* Here it does matter.  If this conversion is from\n-\t   derived to base, allow it.  Otherwise, types must\n-\t   be compatible in the strong sense.  */\n-\tif (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n-\t  {\n-\t    int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n-\t    if (b_or_d < 0)\n-\t      {\n-\t\tb_or_d = get_base_distance (ttr, ttl, 0, 0);\n-\t\tif (b_or_d < 0)\n-\t\t  return EVIL;\n-\t\treturn CONTRAVARIANT_HARSHNESS (-1);\n-\t      }\n-\t    /* Say that this conversion is relatively painless.\n-\t       If it turns out that there is a user-defined X(X&)\n-\t       constructor, then that will be invoked, but that's\n-\t       preferable to dealing with other user-defined conversions\n-\t       that may produce surprising results.  */\n-\t    return INT_TO_BD_HARSHNESS (b_or_d);\n-\t  }\n-\n-\tif (comp_target_types (ttl, intype, 1))\n-\t  return INT_TO_EASY_HARSHNESS (penalty);\n-      }\n-  }\n-  if (codel == RECORD_TYPE && coder == RECORD_TYPE)\n-    {\n-      int b_or_d = get_base_distance (type, parmtype, 0, 0);\n-      if (b_or_d < 0)\n-\t{\n-\t  b_or_d = get_base_distance (parmtype, type, 0, 0);\n-\t  if (b_or_d < 0)\n-\t    return EVIL;\n-\t  return CONTRAVARIANT_HARSHNESS (-1);\n-\t}\n-      return INT_TO_BD_HARSHNESS (b_or_d);\n-    }\n-  return EVIL;\n-}\n-\n-#ifdef DEBUG_MATCHING\n-static char *\n-print_harshness (h)\n-     struct harshness_code *h;\n-{\n-  static char buf[1024];\n-  char tmp[1024];\n-\n-  bzero (buf, 1024 * sizeof (char));\n-  strcat (buf, \"codes=[\");\n-  if (h->code & EVIL_CODE)\n-    strcat (buf, \"EVIL\");\n-  if (h->code & CONST_CODE)\n-    strcat (buf, \" CONST\");\n-  if (h->code & ELLIPSIS_CODE)\n-    strcat (buf, \" ELLIPSIS\");\n-  if (h->code & USER_CODE)\n-    strcat (buf, \" USER\");\n-  if (h->code & STD_CODE)\n-    strcat (buf, \" STD\");\n-  if (h->code & PROMO_CODE)\n-    strcat (buf, \" PROMO\");\n-  if (h->code & QUAL_CODE)\n-    strcat (buf, \" QUAL\");\n-  if (h->code & TRIVIAL_CODE)\n-    strcat (buf, \" TRIVIAL\");\n-  if (buf[0] == '\\0')\n-    strcat (buf, \"0\");\n-\n-  sprintf (tmp, \"] distance=%d int_penalty=%d\", h->distance, h->int_penalty);\n-\n-  strcat (buf, tmp);\n-\n-  return buf;\n-}\n-#endif\n-\n-/* Algorithm: For each argument, calculate how difficult it is to\n-   make FUNCTION accept that argument.  If we can easily tell that\n-   FUNCTION won't be acceptable to one of the arguments, then we\n-   don't need to compute the ease of converting the other arguments,\n-   since it will never show up in the intersection of all arguments'\n-   favorite functions.\n-\n-   Conversions between builtin and user-defined types are allowed, but\n-   no function involving such a conversion is preferred to one which\n-   does not require such a conversion.  Furthermore, such conversions\n-   must be unique.  */\n-\n-void\n-compute_conversion_costs_ansi (function, tta_in, cp, arglen)\n-     tree function;\n-     tree tta_in;\n-     struct candidate *cp;\n-     int arglen;\n-{\n-  tree ttf_in = TYPE_ARG_TYPES (TREE_TYPE (function));\n-  tree ttf = ttf_in;\n-  tree tta = tta_in;\n-\n-  /* Start out with no strikes against.  */\n-  int evil_strikes = 0;\n-  int ellipsis_strikes = 0;\n-  int user_strikes = 0;\n-  int b_or_d_strikes = 0;\n-  int easy_strikes = 0;\n-\n-  int strike_index = 0, win;\n-  struct harshness_code lose;\n-\n-#ifdef GATHER_STATISTICS\n-  n_compute_conversion_costs++;\n-#endif\n-\n-  cp->function = function;\n-  cp->arg = tta ? TREE_VALUE (tta) : NULL_TREE;\n-  cp->u.bad_arg = 0;\t\t/* optimistic!  */\n-\n-  cp->h.code = 0;\n-  cp->h.distance = 0;\n-  cp->h.int_penalty = 0;\n-  bzero (cp->v.ansi_harshness,\n-\t (cp->h_len + 1) * sizeof (struct harshness_code));\n-\n-  while (ttf && tta)\n-    {\n-      struct harshness_code h;\n-\n-      if (ttf == void_list_node)\n-\tbreak;\n-\n-      if (type_unknown_p (TREE_VALUE (tta)))\n-\t{\t  \n-\t  /* Must perform some instantiation here.  */\n-\t  tree rhs = TREE_VALUE (tta);\n-\t  tree lhstype = TREE_VALUE (ttf);\n-\n-\t  /* Keep quiet about possible contravariance violations.  */\n-\t  int old_inhibit_warnings = inhibit_warnings;\n-\t  inhibit_warnings = 1;\n-\n-\t  /* @@ This is to undo what `grokdeclarator' does to\n-\t     parameter types.  It really should go through\n-\t     something more general.  */\n-\n-\t  TREE_TYPE (tta) = unknown_type_node;\n-\t  rhs = instantiate_type (lhstype, rhs, 0);\n-\t  inhibit_warnings = old_inhibit_warnings;\n-\n-\t  if (TREE_CODE (rhs) == ERROR_MARK)\n-\t    h.code = EVIL_CODE;\n-\t  else\n-\t    h = convert_harshness_ansi (lhstype, TREE_TYPE (rhs), rhs);\n-\t}\n-      else\n-\t{\n-#ifdef DEBUG_MATCHING\n-\t  static tree old_function = NULL_TREE;\n-\n-\t  if (!old_function || function != old_function)\n-\t    {\n-\t      cp_error (\"trying %D\", function);\n-\t      old_function = function;\n-\t    }\n-\n-\t  cp_error (\"      doing (%T) %E against arg %T\",\n-\t\t    TREE_TYPE (TREE_VALUE (tta)), TREE_VALUE (tta),\n-\t\t    TREE_VALUE (ttf));\n-#endif\n-\n-\t  h = convert_harshness_ansi (TREE_VALUE (ttf),\n-\t\t\t\t      TREE_TYPE (TREE_VALUE (tta)),\n-\t\t\t\t      TREE_VALUE (tta));\n-\n-#ifdef DEBUG_MATCHING\n-\t  cp_error (\"     evaluated %s\", print_harshness (&h));\n-#endif\n-\t}\n-\n-      cp->v.ansi_harshness[strike_index] = h;\n-      if ((h.code & EVIL_CODE)\n-\t  || ((h.code & STD_CODE) && h.distance < 0))\n-\t{\n-\t  cp->u.bad_arg = strike_index;\n-\t  evil_strikes = 1;\n-\t}\n-     else if (h.code & ELLIPSIS_CODE)\n-       ellipsis_strikes += 1;\n-#if 0\n-      /* This is never set by `convert_harshness_ansi'.  */\n-      else if (h.code & USER_CODE)\n-\t{\n-\t  user_strikes += 1;\n-\t}\n-#endif\n-      else\n-\t{\n-\t  if ((h.code & STD_CODE) && h.distance)\n-\t    {\n-\t      if (h.distance > b_or_d_strikes)\n-\t\tb_or_d_strikes = h.distance;\n-\t    }\n-\t  else\n-\t    easy_strikes += (h.code & (STD_CODE|PROMO_CODE|TRIVIAL_CODE));\n-\t  cp->h.code |= h.code;\n-\t  /* Make sure we communicate this.  */\n-\t  cp->h.int_penalty += h.int_penalty;\n-\t}\n-\n-      ttf = TREE_CHAIN (ttf);\n-      tta = TREE_CHAIN (tta);\n-      strike_index += 1;\n-    }\n-\n-  if (tta)\n-    {\n-      /* ran out of formals, and parmlist is fixed size.  */\n-      if (ttf /* == void_type_node */)\n-\t{\n-\t  cp->h.code = EVIL_CODE;\n-\t  cp->u.bad_arg = -1;\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  struct harshness_code h;\n-\t  int l = list_length (tta);\n-\t  ellipsis_strikes += l;\n-\t  h.code = ELLIPSIS_CODE;\n-\t  h.distance = 0;\n-\t  h.int_penalty = 0;\n-\t  for (; l; --l)\n-\t    cp->v.ansi_harshness[strike_index++] = h;\n-\t}\n-    }\n-  else if (ttf && ttf != void_list_node)\n-    {\n-      /* ran out of actuals, and no defaults.  */\n-      if (TREE_PURPOSE (ttf) == NULL_TREE)\n-\t{\n-\t  cp->h.code = EVIL_CODE;\n-\t  cp->u.bad_arg = -2;\n-\t  return;\n-\t}\n-      /* Store index of first default.  */\n-      cp->v.ansi_harshness[arglen].distance = strike_index+1;\n-    }\n-  else\n-    cp->v.ansi_harshness[arglen].distance = 0;\n-\n-  /* Argument list lengths work out, so don't need to check them again.  */\n-  if (evil_strikes)\n-    {\n-      /* We do not check for derived->base conversions here, since in\n-\t no case would they give evil strike counts, unless such conversions\n-\t are somehow ambiguous.  */\n-\n-      /* See if any user-defined conversions apply.\n-         But make sure that we do not loop.  */\n-      static int dont_convert_types = 0;\n-\n-      if (dont_convert_types)\n+      /* ran out of formals, and parmlist is fixed size.  */\n+      if (ttf /* == void_type_node */)\n \t{\n \t  cp->h.code = EVIL_CODE;\n+\t  cp->u.bad_arg = -1;\n \t  return;\n \t}\n-\n-      win = 0;\t\t\t/* Only get one chance to win.  */\n-      ttf = TYPE_ARG_TYPES (TREE_TYPE (function));\n-      tta = tta_in;\n-      strike_index = 0;\n-      evil_strikes = 0;\n-\n-      while (ttf && tta)\n-\t{\n-\t  if (ttf == void_list_node)\n-\t    break;\n-\n-\t  lose = cp->v.ansi_harshness[strike_index];\n-\t  if ((lose.code & EVIL_CODE)\n-\t      || ((lose.code & STD_CODE) && lose.distance < 0))\n-\t    {\n-\t      tree actual_type = TREE_TYPE (TREE_VALUE (tta));\n-\t      tree formal_type = TREE_VALUE (ttf);\n-\t      int extra_conversions = 0;\n-\n-\t      dont_convert_types = 1;\n-\n-\t      if (TREE_CODE (formal_type) == REFERENCE_TYPE)\n-\t\tformal_type = TREE_TYPE (formal_type);\n-\t      if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n-\t\tactual_type = TREE_TYPE (actual_type);\n-\n-\t      if (formal_type != error_mark_node\n-\t\t  && actual_type != error_mark_node)\n-\t\t{\n-\t\t  formal_type = TYPE_MAIN_VARIANT (formal_type);\n-\t\t  actual_type = TYPE_MAIN_VARIANT (actual_type);\n-\n-\t\t  if (TYPE_HAS_CONSTRUCTOR (formal_type))\n-\t\t    {\n-\t\t      /* If it has a constructor for this type,\n-\t\t\t try to use it.  */\n-\t\t      /* @@ There is no way to save this result yet, so\n-\t\t\t success is a NULL_TREE for now.  */\n-\t\t      if (convert_to_aggr (formal_type, TREE_VALUE (tta), 0, 1)\n-\t\t\t  != error_mark_node)\n-\t\t\twin++;\n-\t\t    }\n-\t\t  if (TYPE_LANG_SPECIFIC (actual_type)\n-\t\t      && TYPE_HAS_CONVERSION (actual_type))\n-\t\t    {\n-\t\t      tree conv;\n-\t\t      /* Don't issue warnings since we're only groping\n-\t\t\t around for the right answer, we haven't yet\n-\t\t\t committed to going with this solution.  */\n-\t\t      int old_inhibit_warnings = inhibit_warnings;\n-\n-\t\t      inhibit_warnings = 1;\n-\t\t      conv = build_type_conversion\n-\t\t\t(CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n-\t\t      inhibit_warnings = old_inhibit_warnings;\n-\n-\t\t      if (conv)\n-\t\t\t{\n-\t\t\t  if (conv == error_mark_node)\n-\t\t\t    win += 2;\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      win++;\n-\t\t\t      if (TREE_CODE (conv) != CALL_EXPR)\n-\t\t\t\textra_conversions = 1;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n-\t\t\t{\n-\t\t\t  conv = build_type_conversion (CALL_EXPR, formal_type,\n-\t\t\t\t\t\t\tTREE_VALUE (tta), 0);\n-\t\t\t  if (conv)\n-\t\t\t    {\n-\t\t\t      if (conv == error_mark_node)\n-\t\t\t\twin += 2;\n-\t\t\t      else\n-\t\t\t\t{\n-\t\t\t\t  win++;\n-\t\t\t\t  if (TREE_CODE (conv) != CALL_EXPR)\n-\t\t\t\t    extra_conversions = 1;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      dont_convert_types = 0;\n-\n-\t      if (win == 1)\n-\t\t{\n-\t\t  user_strikes += 1;\n-\t\t  cp->v.ansi_harshness[strike_index].code\n-\t\t    = USER_CODE | (extra_conversions ? STD_CODE : 0);\n-\t\t  win = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (cp->u.bad_arg > strike_index)\n-\t\t    cp->u.bad_arg = strike_index;\n-\n-\t\t  evil_strikes = win ? 2 : 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  ttf = TREE_CHAIN (ttf);\n-\t  tta = TREE_CHAIN (tta);\n-\t  strike_index += 1;\n-\t}\n-    }\n-\n-  /* Const member functions get a small penalty because defaulting\n-     to const is less useful than defaulting to non-const. */\n-  /* This is bogus, it does not correspond to anything in the ARM.\n-     This code will be fixed when this entire section is rewritten\n-     to conform to the ARM.  (mrs)  */\n-  if (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n-    {\n-      tree this_parm = TREE_VALUE (ttf_in);\n-\n-      if (TREE_CODE (this_parm) == RECORD_TYPE\t/* Is `this' a sig ptr?  */\n-\t    ? TYPE_READONLY (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (this_parm))))\n-\t    : TYPE_READONLY (TREE_TYPE (this_parm)))\n-\t{\n-\t  cp->v.ansi_harshness[0].code |= TRIVIAL_CODE;\n-\t  ++easy_strikes;\n-\t}\n-      else\n-\t{\n-\t  /* Calling a non-const member function from a const member function\n-\t     is probably invalid, but for now we let it only draw a warning.\n-\t     We indicate that such a mismatch has occurred by setting the\n-\t     harshness to a maximum value.  */\n-\t  if (TREE_CODE (TREE_TYPE (TREE_VALUE (tta_in))) == POINTER_TYPE\n-\t      && (TYPE_READONLY (TREE_TYPE (TREE_TYPE (TREE_VALUE (tta_in))))))\n-\t    cp->v.ansi_harshness[0].code |= CONST_CODE;\n-\t}\n-    }\n-\n-  if (evil_strikes)\n-    cp->h.code = EVIL_CODE;\n-  if (ellipsis_strikes)\n-    cp->h.code |= ELLIPSIS_CODE;\n-  if (user_strikes)\n-    cp->h.code |= USER_CODE;\n-#ifdef DEBUG_MATCHING\n-  cp_error (\"final eval %s\", print_harshness (&cp->h));\n-#endif\n-}\n-\n-void\n-compute_conversion_costs_old (function, tta_in, cp, arglen)\n-     tree function;\n-     tree tta_in;\n-     struct candidate *cp;\n-     int arglen;\n-{\n-  tree ttf_in = TYPE_ARG_TYPES (TREE_TYPE (function));\n-  tree ttf = ttf_in;\n-  tree tta = tta_in;\n-\n-  /* Start out with no strikes against.  */\n-  int evil_strikes = 0;\n-  int ellipsis_strikes = 0;\n-  int user_strikes = 0;\n-  int b_or_d_strikes = 0;\n-  int easy_strikes = 0;\n-\n-  int strike_index = 0, win, lose;\n-\n-#ifdef GATHER_STATISTICS\n-  n_compute_conversion_costs++;\n-#endif\n-\n-  cp->function = function;\n-  cp->arg = tta ? TREE_VALUE (tta) : NULL_TREE;\n-  cp->u.bad_arg = 0;\t\t/* optimistic!  */\n-\n-  bzero (cp->v.old_harshness, (cp->h_len + 1) * sizeof (unsigned short));\n-\n-  while (ttf && tta)\n-    {\n-      int harshness;\n-\n-      if (ttf == void_list_node)\n-\tbreak;\n-\n-      if (type_unknown_p (TREE_VALUE (tta)))\n-\t{\t  \n-\t  /* Must perform some instantiation here.  */\n-\t  tree rhs = TREE_VALUE (tta);\n-\t  tree lhstype = TREE_VALUE (ttf);\n-\n-\t  /* Keep quiet about possible contravariance violations.  */\n-\t  int old_inhibit_warnings = inhibit_warnings;\n-\t  inhibit_warnings = 1;\n-\n-\t  /* @@ This is to undo what `grokdeclarator' does to\n-\t     parameter types.  It really should go through\n-\t     something more general.  */\n-\n-\t  TREE_TYPE (tta) = unknown_type_node;\n-\t  rhs = instantiate_type (lhstype, rhs, 0);\n-\t  inhibit_warnings = old_inhibit_warnings;\n-\n-\t  if (TREE_CODE (rhs) == ERROR_MARK)\n-\t    harshness = 1;\n-\t  else\n-\t    {\n-\t      harshness = convert_harshness_old (lhstype, TREE_TYPE (rhs),\n-\t\t\t\t\t\t rhs);\n-\t      /* harshness |= 2; */\n-\t    }\n-\t}\n-      else\n-\tharshness = convert_harshness_old (TREE_VALUE (ttf),\n-\t\t\t\t\t   TREE_TYPE (TREE_VALUE (tta)),\n-\t\t\t\t\t   TREE_VALUE (tta));\n-\n-      cp->v.old_harshness[strike_index] = harshness;\n-      if (EVIL_HARSHNESS (harshness)\n-\t  || CONTRAVARIANT_HARSHNESS (harshness))\n-\t{\n-\t  cp->u.bad_arg = strike_index;\n-\t  evil_strikes = 1;\n-\t}\n-     else if (ELLIPSIS_HARSHNESS (harshness))\n-\t{\n-\t  ellipsis_strikes += 1;\n-\t}\n-#if 0\n-      /* This is never set by `convert_harshness_old'.  */\n-      else if (USER_HARSHNESS (harshness))\n-\t{\n-\t  user_strikes += 1;\n-\t}\n-#endif\n-      else if (BASE_DERIVED_HARSHNESS (harshness))\n-\t{\n-\t  b_or_d_strikes += INT_FROM_BD_HARSHNESS (harshness);\n-\t}\n       else\n-\teasy_strikes += INT_FROM_EASY_HARSHNESS (harshness);\n-      ttf = TREE_CHAIN (ttf);\n-      tta = TREE_CHAIN (tta);\n-      strike_index += 1;\n-    }\n-\n-  if (tta)\n-    {\n-      /* ran out of formals, and parmlist is fixed size.  */\n-      if (ttf /* == void_type_node */)\n-\t{\n-\t  cp->evil = 1;\n-\t  cp->u.bad_arg = -1;\n-\t  return;\n+\t{\n+\t  struct harshness_code h;\n+\t  int l = list_length (tta);\n+\t  ellipsis_strikes += l;\n+\t  h.code = ELLIPSIS_CODE;\n+\t  h.distance = 0;\n+\t  h.int_penalty = 0;\n+\t  for (; l; --l)\n+\t    cp->harshness[strike_index++] = h;\n \t}\n-      else ellipsis_strikes += list_length (tta);\n     }\n   else if (ttf && ttf != void_list_node)\n     {\n       /* ran out of actuals, and no defaults.  */\n       if (TREE_PURPOSE (ttf) == NULL_TREE)\n \t{\n-\t  cp->evil = 1;\n+\t  cp->h.code = EVIL_CODE;\n \t  cp->u.bad_arg = -2;\n \t  return;\n \t}\n       /* Store index of first default.  */\n-      cp->v.old_harshness[arglen] = strike_index+1;\n+      cp->harshness[arglen].distance = strike_index+1;\n     }\n   else\n-    cp->v.old_harshness[arglen] = 0;\n+    cp->harshness[arglen].distance = 0;\n \n   /* Argument list lengths work out, so don't need to check them again.  */\n   if (evil_strikes)\n@@ -1706,7 +905,7 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \n       if (dont_convert_types)\n \t{\n-\t  cp->evil = 1;\n+\t  cp->h.code = EVIL_CODE;\n \t  return;\n \t}\n \n@@ -1721,12 +920,13 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \t  if (ttf == void_list_node)\n \t    break;\n \n-\t  lose = cp->v.old_harshness[strike_index];\n-\t  if (EVIL_HARSHNESS (lose)\n-\t      || CONTRAVARIANT_HARSHNESS (lose))\n+\t  lose = cp->harshness[strike_index];\n+\t  if ((lose.code & EVIL_CODE)\n+\t      || ((lose.code & STD_CODE) && lose.distance < 0))\n \t    {\n \t      tree actual_type = TREE_TYPE (TREE_VALUE (tta));\n \t      tree formal_type = TREE_VALUE (ttf);\n+\t      int extra_conversions = 0;\n \n \t      dont_convert_types = 1;\n \n@@ -1743,42 +943,52 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \n \t\t  if (TYPE_HAS_CONSTRUCTOR (formal_type))\n \t\t    {\n-\t\t      /* If it has a constructor for this type, try to use it.  */\n+\t\t      /* If it has a constructor for this type,\n+\t\t\t try to use it.  */\n+\t\t      /* @@ There is no way to save this result yet, so\n+\t\t\t success is a NULL_TREE for now.  */\n \t\t      if (convert_to_aggr (formal_type, TREE_VALUE (tta), 0, 1)\n \t\t\t  != error_mark_node)\n-\t\t\t{\n-\t\t\t  /* @@ There is no way to save this result yet.\n-\t\t\t     @@ So success is NULL_TREE for now.  */\n-\t\t\t  win++;\n-\t\t\t}\n+\t\t\twin++;\n \t\t    }\n-\t\t  if (TYPE_LANG_SPECIFIC (actual_type) && TYPE_HAS_CONVERSION (actual_type))\n+\t\t  if (TYPE_LANG_SPECIFIC (actual_type)\n+\t\t      && TYPE_HAS_CONVERSION (actual_type))\n \t\t    {\n-\t\t      if (TREE_CODE (formal_type) == INTEGER_TYPE\n-\t\t\t  && TYPE_HAS_INT_CONVERSION (actual_type))\n-\t\t\twin++;\n-\t\t      else if (TREE_CODE (formal_type) == REAL_TYPE\n-\t\t\t       && TYPE_HAS_REAL_CONVERSION (actual_type))\n-\t\t\twin++;\n-\t\t      else\n+\t\t      tree conv;\n+\t\t      /* Don't issue warnings since we're only groping\n+\t\t\t around for the right answer, we haven't yet\n+\t\t\t committed to going with this solution.  */\n+\t\t      int old_inhibit_warnings = inhibit_warnings;\n+\n+\t\t      inhibit_warnings = 1;\n+\t\t      conv = build_type_conversion\n+\t\t\t(CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n+\t\t      inhibit_warnings = old_inhibit_warnings;\n+\n+\t\t      if (conv)\n+\t\t\t{\n+\t\t\t  if (conv == error_mark_node)\n+\t\t\t    win += 2;\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      win++;\n+\t\t\t      if (TREE_CODE (conv) != CALL_EXPR)\n+\t\t\t\textra_conversions = 1;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n \t\t\t{\n-\t\t\t  tree conv = build_type_conversion (CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n+\t\t\t  conv = build_type_conversion (CALL_EXPR, formal_type,\n+\t\t\t\t\t\t\tTREE_VALUE (tta), 0);\n \t\t\t  if (conv)\n \t\t\t    {\n \t\t\t      if (conv == error_mark_node)\n \t\t\t\twin += 2;\n \t\t\t      else\n-\t\t\t\twin++;\n-\t\t\t    }\n-\t\t\t  else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n-\t\t\t    {\n-\t\t\t      conv = build_type_conversion (CALL_EXPR, formal_type, TREE_VALUE (tta), 0);\n-\t\t\t      if (conv)\n \t\t\t\t{\n-\t\t\t\t  if (conv == error_mark_node)\n-\t\t\t\t    win += 2;\n-\t\t\t\t  else\n-\t\t\t\t    win++;\n+\t\t\t\t  win++;\n+\t\t\t\t  if (TREE_CODE (conv) != CALL_EXPR)\n+\t\t\t\t    extra_conversions = 1;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n@@ -1789,7 +999,8 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \t      if (win == 1)\n \t\t{\n \t\t  user_strikes += 1;\n-\t\t  cp->v.old_harshness[strike_index] = USER_HARSHNESS (-1);\n+\t\t  cp->harshness[strike_index].code\n+\t\t    = USER_CODE | (extra_conversions ? STD_CODE : 0);\n \t\t  win = 0;\n \t\t}\n \t      else\n@@ -1821,7 +1032,7 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \t    ? TYPE_READONLY (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (this_parm))))\n \t    : TYPE_READONLY (TREE_TYPE (this_parm)))\n \t{\n-\t  cp->v.old_harshness[0] += INT_TO_EASY_HARSHNESS (1);\n+\t  cp->harshness[0].code |= TRIVIAL_CODE;\n \t  ++easy_strikes;\n \t}\n       else\n@@ -1832,371 +1043,19 @@ compute_conversion_costs_old (function, tta_in, cp, arglen)\n \t     harshness to a maximum value.  */\n \t  if (TREE_CODE (TREE_TYPE (TREE_VALUE (tta_in))) == POINTER_TYPE\n \t      && (TYPE_READONLY (TREE_TYPE (TREE_TYPE (TREE_VALUE (tta_in))))))\n-\t    cp->v.old_harshness[0] |= CONST_HARSHNESS (-1);\n-\t}\n-    }\n-\n-  cp->evil = evil_strikes;\n-  cp->ellipsis = ellipsis_strikes;\n-  cp->user = user_strikes;\n-  cp->b_or_d = b_or_d_strikes;\n-  cp->easy = easy_strikes;\n-}\n-\n-void\n-compute_conversion_costs (function, tta_in, cp, arglen)\n-     tree function;\n-     tree tta_in;\n-     struct candidate *cp;\n-     int arglen;\n-{\n-  if (flag_ansi_overloading)\n-    compute_conversion_costs_ansi (function, tta_in, cp, arglen);\n-  else\n-    compute_conversion_costs_old (function, tta_in, cp, arglen);\n-}\n-\n-/* When one of several possible overloaded functions and/or methods\n-   can be called, choose the best candidate for overloading.\n-\n-   BASETYPE is the context from which we start method resolution\n-   or NULL if we are comparing overloaded functions.\n-   CANDIDATES is the array of candidates we have to choose from.\n-   N_CANDIDATES is the length of CANDIDATES.\n-   PARMS is a TREE_LIST of parameters to the function we'll ultimately\n-   choose.  It is modified in place when resolving methods.  It is not\n-   modified in place when resolving overloaded functions.\n-   LEN is the length of the parameter list.  */\n-\n-static struct candidate *\n-ideal_candidate_old (basetype, candidates, n_candidates, parms, len)\n-     tree basetype;\n-     struct candidate *candidates;\n-     int n_candidates;\n-     tree parms;\n-     int len;\n-{\n-  struct candidate *cp = candidates + n_candidates;\n-  int index, i;\n-  tree ttf;\n-\n-  qsort (candidates,\t\t/* char *base */\n-\t n_candidates,\t\t/* int nel */\n-\t sizeof (struct candidate), /* int width */\n-\t rank_for_overload);\t/* int (*compar)() */\n-\n-  /* If the best candidate requires user-defined conversions,\n-     and its user-defined conversions are a strict subset\n-     of all other candidates requiring user-defined conversions,\n-     then it is, in fact, the best.  */\n-  for (i = -1; cp + i != candidates; i--)\n-    if (cp[i].user == 0)\n-      break;\n-\n-  if (i < -1)\n-    {\n-      tree ttf0;\n-\n-      /* Check that every other candidate requires those conversions\n-\t as a strict subset of their conversions.  */\n-      if (cp[i].user == cp[-1].user)\n-\tgoto non_subset;\n-\n-      /* Look at subset relationship more closely.  */\n-      while (i != -1)\n-\t{\n-\t  for (ttf = TYPE_ARG_TYPES (TREE_TYPE (cp[i].function)),\n-\t       ttf0 = TYPE_ARG_TYPES (TREE_TYPE (cp[-1].function)),\n-\t       index = 0; index < len; index++)\n-\t    {\n-\t      if (USER_HARSHNESS (cp[i].v.old_harshness[index]))\n-\t\t{\n-\t\t  /* If our \"best\" candidate also needs a conversion,\n-\t\t     it must be the same one.  */\n-\t\t  if (USER_HARSHNESS (cp[-1].v.old_harshness[index])\n-\t\t      && TREE_VALUE (ttf) != TREE_VALUE (ttf0))\n-\t\t    goto non_subset;\n-\t\t}\n-\t      ttf = TREE_CHAIN (ttf);\n-\t      ttf0 = TREE_CHAIN (ttf0);\n-\t      /* Handle `...' gracefully.  */\n-\t      if (ttf == NULL_TREE || ttf0 == NULL_TREE)\n-\t\tbreak;\n-\t    }\n-\t  i++;\n+\t    cp->harshness[0].code |= CONST_CODE;\n \t}\n-      /* The best was the best.  */\n-      return cp - 1;\n-    non_subset:\n-      /* Use other rules for determining \"bestness\".  */\n-      ;\n     }\n \n-  /* If the best two candidates we find require user-defined\n-     conversions, we may need to report and error message.  */\n-  if (cp[-1].user && cp[-2].user\n-      && (cp[-1].b_or_d || cp[-2].b_or_d == 0))\n-    {\n-      /* If the best two methods found involved user-defined\n-\t type conversions, then we must see whether one\n-\t of them is exactly what we wanted.  If not, then\n-\t we have an ambiguity.  */\n-      int best = 0;\n-      tree tta = parms;\n-      tree f1;\n-#if 0\n-      /* for LUCID */\n-      tree p1;\n-#endif\n-\n-      /* Stash all of our parameters in safe places\n-\t so that we can perform type conversions in place.  */\n-      while (tta)\n-\t{\n-\t  TREE_PURPOSE (tta) = TREE_VALUE (tta);\n-\t  tta = TREE_CHAIN (tta);\n-\t}\n-\n-      i = 0;\n-      do\n-\t{\n-\t  int exact_conversions = 0;\n-\n-\t  i -= 1;\n-\t  tta = parms;\n-\t  if (DECL_STATIC_FUNCTION_P (cp[i].function))\n-\t    tta = TREE_CHAIN (tta);\n-\t  /* special note, we don't go through len parameters, because we\n-\t     may only need len-1 parameters because of a call to a static\n-\t     member. */\n-\t  for (ttf = TYPE_ARG_TYPES (TREE_TYPE (cp[i].function)), index = 0;\n-\t       tta;\n-\t       tta = TREE_CHAIN (tta), ttf = TREE_CHAIN (ttf), index++)\n-\t    {\n-\t      /* If this is a varargs function, there's no conversion to do,\n-\t\t but don't accept an arg that needs a copy ctor.  */\n-\t      if (ttf == NULL_TREE)\n-\t\t{\n-\t\t  /* FIXME: verify that we cannot get here with an\n-\t\t     arg that needs a ctor.  */\n-\t\t  break;\n-\t\t}\n-\n-\t      if (USER_HARSHNESS (cp[i].v.old_harshness[index]))\n-\t\t{\n-\t\t  tree this_parm = build_type_conversion (CALL_EXPR, TREE_VALUE (ttf), TREE_PURPOSE (tta), 2);\n-\t\t  if (basetype != NULL_TREE)\n-\t\t    TREE_VALUE (tta) = this_parm;\n-\t\t  if (this_parm)\n-\t\t    {\n-\t\t      if (TREE_CODE (this_parm) != CONVERT_EXPR\n-\t\t\t  && (TREE_CODE (this_parm) != NOP_EXPR\n-\t\t\t      || comp_target_types (TREE_TYPE (this_parm),\n-\t\t\t\t\t\t    TREE_TYPE (TREE_OPERAND (this_parm, 0)), 1)))\n-\t\t\texact_conversions += 1;\n-\t\t    }\n-\t\t  else if (PROMOTES_TO_AGGR_TYPE (TREE_VALUE (ttf), REFERENCE_TYPE))\n-\t\t    {\n-\t\t      /* To get here we had to have succeeded via\n-\t\t\t a constructor.  */\n-\t\t      TREE_VALUE (tta) = TREE_PURPOSE (tta);\n-\t\t      exact_conversions += 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  if (exact_conversions == cp[i].user)\n-\t    {\n-\t      if (best == 0)\n-\t\t{\n-\t\t  best = i;\n-\t\t  f1 = cp[best].function;\n-#if 0\n-\t\t  /* For LUCID */\n-\t\t  p1 = TYPE_ARG_TYPES (TREE_TYPE (f1));\n-#endif\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Don't complain if next best is from base class.  */\n-\t\t  tree f2 = cp[i].function;\n-\n-\t\t  if (TREE_CODE (TREE_TYPE (f1)) == METHOD_TYPE\n-\t\t      && TREE_CODE (TREE_TYPE (f2)) == METHOD_TYPE\n-\t\t      && BASE_DERIVED_HARSHNESS (cp[i].v.old_harshness[0])\n-\t\t      && cp[best].v.old_harshness[0] < cp[i].v.old_harshness[0])\n-\t\t    {\n-#if 0\n-\t\t      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (f2));\n-\t\t      /* For LUCID.  */\n-\t\t      if (! compparms (TREE_CHAIN (p1), TREE_CHAIN (p2), 1))\n-\t\t\tgoto ret0;\n-\t\t      else\n+  if (evil_strikes)\n+    cp->h.code = EVIL_CODE;\n+  if (ellipsis_strikes)\n+    cp->h.code |= ELLIPSIS_CODE;\n+  if (user_strikes)\n+    cp->h.code |= USER_CODE;\n+#ifdef DEBUG_MATCHING\n+  cp_error (\"final eval %s\", print_harshness (&cp->h));\n #endif\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Ensure that there's nothing ambiguous about these\n-\t\t\t two fns.  */\n-\t\t      int identical = 1;\n-\t\t      for (index = 0; index < len; index++)\n-\t\t\t{\n-\t\t\t  /* Type conversions must be piecewise equivalent.  */\n-\t\t\t  if (USER_HARSHNESS (cp[best].v.old_harshness[index])\n-\t\t\t      != USER_HARSHNESS (cp[i].v.old_harshness[index]))\n-\t\t\t    goto ret0;\n-\t\t\t  /* If there's anything we like better about the\n-\t\t\t     other function, consider it ambiguous.  */\n-\t\t\t  if (cp[i].v.old_harshness[index] < cp[best].v.old_harshness[index])\n-\t\t\t    goto ret0;\n-\t\t\t  /* If any single one it diffent, then the whole is\n-\t\t\t     not identical.  */\n-\t\t\t  if (cp[i].v.old_harshness[index] != cp[best].v.old_harshness[index])\n-\t\t\t    identical = 0;\n-\t\t\t}\n-\n-\t\t      /* If we can't tell the difference between the two, it\n-\t\t\t is ambiguous.  */\n-\t\t      if (identical)\n-\t\t\tgoto ret0;\n-\n-\t\t      /* If we made it to here, it means we're satisfied that\n-\t\t\t BEST is still best.  */\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t} while (cp + i != candidates);\n-\n-      if (best)\n-\t{\n-\t  int exact_conversions = cp[best].user;\n-\t  tta = parms;\n-\t  if (DECL_STATIC_FUNCTION_P (cp[best].function))\n-\t    tta = TREE_CHAIN (parms);\n-\t  for (ttf = TYPE_ARG_TYPES (TREE_TYPE (cp[best].function)), index = 0;\n-\t       exact_conversions > 0;\n-\t       tta = TREE_CHAIN (tta), ttf = TREE_CHAIN (ttf), index++)\n-\t    {\n-\t      if (USER_HARSHNESS (cp[best].v.old_harshness[index]))\n-\t\t{\n-\t\t  /* We must now fill in the slot we left behind.\n-\t\t     @@ This could be optimized to use the value previously\n-\t\t     @@ computed by build_type_conversion in some cases.  */\n-\t\t  if (basetype != NULL_TREE)\n-\t\t    TREE_VALUE (tta) = convert (TREE_VALUE (ttf), TREE_PURPOSE (tta));\n-\t\t  exact_conversions -= 1;\n-\t\t}\n-\t      else\n-\t\tTREE_VALUE (tta) = TREE_PURPOSE (tta);\n-\t    }\n-\t  return cp + best;\n-\t}\n-      goto ret0;\n-    }\n-  /* If the best two candidates we find both use default parameters,\n-     we may need to report and error.  Don't need to worry if next-best\n-     candidate is forced to use user-defined conversion when best is not.  */\n-  if (cp[-2].user == 0\n-      && cp[-1].v.old_harshness[len] != 0 && cp[-2].v.old_harshness[len] != 0)\n-    {\n-      tree tt1 = TYPE_ARG_TYPES (TREE_TYPE (cp[-1].function));\n-      tree tt2 = TYPE_ARG_TYPES (TREE_TYPE (cp[-2].function));\n-      unsigned i = cp[-1].v.old_harshness[len];\n-\n-      if (cp[-2].v.old_harshness[len] < i)\n-\ti = cp[-2].v.old_harshness[len];\n-      while (--i > 0)\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (TREE_VALUE (tt1))\n-\t      != TYPE_MAIN_VARIANT (TREE_VALUE (tt2)))\n-\t    /* These lists are not identical, so we can choose our best candidate.  */\n-\t    return cp - 1;\n-\t  tt1 = TREE_CHAIN (tt1);\n-\t  tt2 = TREE_CHAIN (tt2);\n-\t}\n-      /* To get here, both lists had the same parameters up to the defaults\n-\t which were used.  This is an ambiguous request.  */\n-      goto ret0;\n-    }\n-\n-  /* Otherwise, return our best candidate.  Note that if we get candidates\n-     from independent base classes, we have an ambiguity, even if one\n-     argument list look a little better than another one.  */\n-  if (cp[-1].b_or_d && basetype && TYPE_USES_MULTIPLE_INHERITANCE (basetype))\n-    {\n-      int i = n_candidates - 1, best = i;\n-      tree base1 = NULL_TREE;\n-\n-      if (TREE_CODE (TREE_TYPE (candidates[i].function)) == FUNCTION_TYPE)\n-\treturn cp - 1;\n-\n-      for (; i >= 0 && candidates[i].user == 0 && candidates[i].evil == 0; i--)\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (candidates[i].function)) == METHOD_TYPE)\n-\t    {\n-\t      tree newbase = DECL_CLASS_CONTEXT (candidates[i].function);\n-\n-\t      if (base1 != NULL_TREE)\n-\t\t{\n-\t\t  /* newbase could be a base or a parent of base1 */\n-\t\t  if (newbase != base1 && ! UNIQUELY_DERIVED_FROM_P (newbase, base1)\n-\t\t      && ! UNIQUELY_DERIVED_FROM_P (base1, newbase))\n-\t\t    {\n-\t\t      cp_error (\"ambiguous request for function from distinct base classes of type `%T'\", basetype);\n-\t\t      cp_error_at (\"  first candidate is `%#D'\",\n-\t\t\t\t     candidates[best].function);\n-\t\t      cp_error_at (\"  second candidate is `%#D'\",\n-\t\t\t\t     candidates[i].function);\n-\t\t      cp[-1].evil = 1;\n-\t\t      return cp - 1;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  best = i;\n-\t\t  base1 = newbase;\n-\t\t}\n-\t    }\n-\t  else\n-\t    return cp - 1;\n-\t}\n-    }\n-\n-  /* Don't accept a candidate as being ideal if it's indistinguishable\n-     from another candidate.  */\n-  if (rank_for_overload (cp-1, cp-2) == 0)\n-    {\n-      /* If the types are distinguishably different (like\n-\t `long' vs. `unsigned long'), that's ok.  But if they are arbitrarily\n-\t different, such as `int (*)(void)' vs. `void (*)(int)',\n-\t that's not ok.  */\n-      tree p1 = TYPE_ARG_TYPES (TREE_TYPE (cp[-1].function));\n-      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (cp[-2].function));\n-      while (p1 && p2)\n-\t{\n-\t  if (TREE_CODE (TREE_VALUE (p1)) == POINTER_TYPE\n-\t      && TREE_CODE (TREE_TYPE (TREE_VALUE (p1))) == FUNCTION_TYPE\n-\t      && TREE_VALUE (p1) != TREE_VALUE (p2))\n-\t    return NULL;\n-\t  p1 = TREE_CHAIN (p1);\n-\t  p2 = TREE_CHAIN (p2);\n-\t}\n-      if (p1 || p2)\n-\treturn NULL;\n-    }\n-\n-  return cp - 1;\n-\n- ret0:\n-  /* In the case where there is no ideal candidate, restore\n-     TREE_VALUE slots of PARMS from TREE_PURPOSE slots.  */\n-  while (parms)\n-    {\n-      TREE_VALUE (parms) = TREE_PURPOSE (parms);\n-      parms = TREE_CHAIN (parms);\n-    }\n-  return NULL;\n }\n \n /* Subroutine of ideal_candidate.  See if X or Y is a better match\n@@ -2216,8 +1075,20 @@ strictly_better (x, y)\n   return 0;\n }\n \n+/* When one of several possible overloaded functions and/or methods\n+   can be called, choose the best candidate for overloading.\n+\n+   BASETYPE is the context from which we start method resolution\n+   or NULL if we are comparing overloaded functions.\n+   CANDIDATES is the array of candidates we have to choose from.\n+   N_CANDIDATES is the length of CANDIDATES.\n+   PARMS is a TREE_LIST of parameters to the function we'll ultimately\n+   choose.  It is modified in place when resolving methods.  It is not\n+   modified in place when resolving overloaded functions.\n+   LEN is the length of the parameter list.  */\n+\n static struct candidate *\n-ideal_candidate_ansi (basetype, candidates, n_candidates, parms, len)\n+ideal_candidate (basetype, candidates, n_candidates, parms, len)\n      tree basetype;\n      struct candidate *candidates;\n      int n_candidates;\n@@ -2278,27 +1149,27 @@ ideal_candidate_ansi (basetype, candidates, n_candidates, parms, len)\n \t     rank_for_ideal);\n       for (i = 0; i < len; i++)\n \t{\n-\t  if (cp[-1].v.ansi_harshness[i].code < cp[-2].v.ansi_harshness[i].code)\n+\t  if (cp[-1].harshness[i].code < cp[-2].harshness[i].code)\n \t    better = 1;\n-\t  else if (cp[-1].v.ansi_harshness[i].code > cp[-2].v.ansi_harshness[i].code)\n+\t  else if (cp[-1].harshness[i].code > cp[-2].harshness[i].code)\n \t    worse = 1;\n-\t  else if (cp[-1].v.ansi_harshness[i].code & STD_CODE)\n+\t  else if (cp[-1].harshness[i].code & STD_CODE)\n \t    {\n \t      /* If it involves a standard conversion, let the\n \t\t inheritance lattice be the final arbiter.  */\n-\t      if (cp[-1].v.ansi_harshness[i].distance > cp[-2].v.ansi_harshness[i].distance)\n+\t      if (cp[-1].harshness[i].distance > cp[-2].harshness[i].distance)\n \t\tworse = 1;\n-\t      else if (cp[-1].v.ansi_harshness[i].distance < cp[-2].v.ansi_harshness[i].distance)\n+\t      else if (cp[-1].harshness[i].distance < cp[-2].harshness[i].distance)\n \t\tbetter = 1;\n \t    }\n-\t  else if (cp[-1].v.ansi_harshness[i].code & PROMO_CODE)\n+\t  else if (cp[-1].harshness[i].code & PROMO_CODE)\n \t    {\n \t      /* For integral promotions, take into account a finer\n \t\t granularity for determining which types should be favored\n \t\t over others in such promotions.  */\n-\t      if (cp[-1].v.ansi_harshness[i].int_penalty > cp[-2].v.ansi_harshness[i].int_penalty)\n+\t      if (cp[-1].harshness[i].int_penalty > cp[-2].harshness[i].int_penalty)\n \t\tworse = 1;\n-\t      else if (cp[-1].v.ansi_harshness[i].int_penalty < cp[-2].v.ansi_harshness[i].int_penalty)\n+\t      else if (cp[-1].harshness[i].int_penalty < cp[-2].harshness[i].int_penalty)\n \t\tbetter = 1;\n \t    }\n \t}\n@@ -2309,22 +1180,6 @@ ideal_candidate_ansi (basetype, candidates, n_candidates, parms, len)\n   return cp-1;\n }\n \n-static struct candidate *\n-ideal_candidate (basetype, candidates, n_candidates, parms, len)\n-     tree basetype;\n-     struct candidate *candidates;\n-     int n_candidates;\n-     tree parms;\n-     int len;\n-{\n-  if (flag_ansi_overloading)\n-    return ideal_candidate_ansi (basetype, candidates, n_candidates, parms,\n-\t\t\t\t len);\n-  else\n-    return ideal_candidate_old (basetype, candidates, n_candidates, parms,\n-\t\t\t\tlen);\n-}\n-\n /* Assume that if the class referred to is not in the\n    current class hierarchy, that it may be remote.\n    PARENT is assumed to be of aggregate type here.  */\n@@ -3252,12 +2107,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\tmy_friendly_abort (167);\n \n \t      cp->h_len = len;\n-\t      if (flag_ansi_overloading)\n-\t\tcp->v.ansi_harshness = (struct harshness_code *)\n-\t\t  alloca ((len + 1) * sizeof (struct harshness_code));\n-\t      else\n-\t\tcp->v.old_harshness = (unsigned short *)\n-\t\t  alloca ((len + 1) * sizeof (unsigned short));\n+\t      cp->harshness = (struct harshness_code *)\n+\t\talloca ((len + 1) * sizeof (struct harshness_code));\n \n \t      result = build_overload_call (name, friend_parms, 0, cp);\n \t      /* If it turns out to be the one we were actually looking for\n@@ -3266,30 +2117,16 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      if (TREE_CODE (result) == CALL_EXPR)\n \t\treturn result;\n \n-\t      if (flag_ansi_overloading)\n-\t\twhile ((cp->h.code & EVIL_CODE) == 0)\n-\t\t  {\n-\t\t    /* non-standard uses: set the field to 0 to indicate\n-\t\t       we are using a non-member function.  */\n-\t\t    cp->u.field = 0;\n-\t\t    if (cp->v.ansi_harshness[len].distance == 0\n-\t\t\t&& cp->h.code < best)\n-\t\t      best = cp->h.code;\n-\t\t    cp += 1;\n-\t\t  }\n-\t      else\n-\t\twhile (cp->evil == 0)\n-\t\t  {\n-\t\t    /* non-standard uses: set the field to 0 to indicate\n-\t\t       we are using a non-member function.  */\n-\t\t    cp->u.field = 0;\n-\t\t    if (cp->v.old_harshness[len] == 0\n-\t\t\t&& cp->v.old_harshness[len] == 0\n-\t\t\t&& cp->ellipsis == 0 && cp->user == 0 && cp->b_or_d == 0\n-\t\t\t&& cp->easy < best)\n-\t\t      best = cp->easy;\n-\t\t    cp += 1;\n-\t\t  }\n+\t      while ((cp->h.code & EVIL_CODE) == 0)\n+\t\t{\n+\t\t  /* non-standard uses: set the field to 0 to indicate\n+\t\t     we are using a non-member function.  */\n+\t\t  cp->u.field = 0;\n+\t\t  if (cp->harshness[len].distance == 0\n+\t\t      && cp->h.code < best)\n+\t\t    best = cp->h.code;\n+\t\t  cp += 1;\n+\t\t}\n \t    }\n \t}\n \n@@ -3357,48 +2194,31 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t  n_inner_fields_searched++;\n #endif\n \t\t  cp->h_len = len;\n-\t\t  if (flag_ansi_overloading)\n-\t\t    cp->v.ansi_harshness = (struct harshness_code *)\n-\t\t      alloca ((len + 1) * sizeof (struct harshness_code));\n-\t\t  else\n-\t\t    cp->v.old_harshness = (unsigned short *)\n-\t\t      alloca ((len + 1) * sizeof (unsigned short));\n+\t\t  cp->harshness = (struct harshness_code *)\n+\t\t    alloca ((len + 1) * sizeof (struct harshness_code));\n \n \t\t  if (DECL_STATIC_FUNCTION_P (function))\n \t\t    these_parms = TREE_CHAIN (these_parms);\n \t\t  compute_conversion_costs (function, these_parms, cp, len);\n \n-\t\t  if (!flag_ansi_overloading)\n-\t\t      cp->b_or_d += b_or_d;\n-\n-\t\t  if ((flag_ansi_overloading && (cp->h.code & EVIL_CODE) == 0)\n-\t\t      || (!flag_ansi_overloading && cp->evil == 0))\n+\t\t  if ((cp->h.code & EVIL_CODE) == 0)\n \t\t    {\n \t\t      cp->u.field = function;\n \t\t      cp->function = function;\n \t\t      cp->basetypes = basetype_path;\n \n \t\t      /* No \"two-level\" conversions.  */\n \t\t      if (flags & LOOKUP_NO_CONVERSION\n-\t\t\t  && ((flag_ansi_overloading\n-\t\t\t       && (cp->h.code & USER_CODE))\n-\t\t\t      || (!flag_ansi_overloading\n-\t\t\t\t  && cp->user != 0)))\n+\t\t\t  && (cp->h.code & USER_CODE))\n \t\t\tcontinue;\n \n \t\t      /* If we used default parameters, we must\n \t\t\t check to see whether anyone else might\n \t\t\t use them also, and report a possible\n \t\t\t ambiguity.  */\n \t\t      if (! TYPE_USES_MULTIPLE_INHERITANCE (save_basetype)\n-\t\t\t  && ((flag_ansi_overloading\n-\t\t\t       && cp->v.ansi_harshness[len].distance == 0\n-\t\t\t       && cp->h.code < best)\n-\t\t\t      || (!flag_ansi_overloading\n-\t\t\t\t  && cp->v.old_harshness[len] == 0\n-\t\t\t\t  && CONST_HARSHNESS (cp->v.old_harshness[0]) == 0\n-\t\t\t\t  && cp->ellipsis == 0 && cp->user == 0 && cp->b_or_d == 0\n-\t\t\t\t  && cp->easy < best)))\n+\t\t\t  && cp->harshness[len].distance == 0\n+\t\t\t  && cp->h.code < best)\n \t\t\t{\n \t\t\t  if (! DECL_STATIC_FUNCTION_P (function))\n \t\t\t    TREE_VALUE (parms) = cp->arg;\n@@ -3472,12 +2292,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t    }\n \t\t  return error_mark_node;\n \t\t}\n-\t      if ((flag_ansi_overloading && (cp->h.code & EVIL_CODE))\n-\t\t  || (!flag_ansi_overloading && cp->evil))\n+\t      if (cp->h.code & EVIL_CODE)\n \t\treturn error_mark_node;\n \t    }\n-\t  else if ((flag_ansi_overloading && (cp[-1].h.code & EVIL_CODE))\n-\t\t   || (!flag_ansi_overloading && cp[-1].evil == 2))\n+\t  else if (cp[-1].h.code & EVIL_CODE)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n \t\tcp_error (\"ambiguous type conversion requested for %s `%D'\",\n@@ -3546,10 +2364,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       continue;\n \n     found_and_maybe_warn:\n-      if (((flag_ansi_overloading\n-\t    && (cp->v.ansi_harshness[0].code & CONST_CODE))\n-\t   || (!flag_ansi_overloading\n-\t       && CONST_HARSHNESS (cp->v.old_harshness[0])))\n+      if ((cp->harshness[0].code & CONST_CODE)\n \t  /* 12.1p2: Constructors can be called for const objects.  */\n \t  && ! DECL_CONSTRUCTOR_P (cp->function))\n \t{\n@@ -3869,24 +2684,11 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \n   if (final_cp)\n     {\n-      if (flag_ansi_overloading)\n-\t{\n-\t  final_cp[0].h.code = 0;\n-\t  final_cp[0].h.distance = 0;\n-\t  final_cp[0].function = 0;\n-\t  /* end marker.  */\n-\t  final_cp[1].h.code = EVIL_CODE;\n-\t}\n-      else\n-\t{\n-\t  final_cp[0].evil = 0;\n-\t  final_cp[0].user = 0;\n-\t  final_cp[0].b_or_d = 0;\n-\t  final_cp[0].easy = 0;\n-\t  final_cp[0].function = 0;\n-\t  /* end marker.  */\n-\t  final_cp[1].evil = 1;\n-\t}\n+      final_cp[0].h.code = 0;\n+      final_cp[0].h.distance = 0;\n+      final_cp[0].function = 0;\n+      /* end marker.  */\n+      final_cp[1].h.code = EVIL_CODE;\n     }\n \n   for (parm = parms; parm; parm = TREE_CHAIN (parm))\n@@ -3896,12 +2698,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       if (t == error_mark_node)\n \t{\n \t  if (final_cp)\n-\t    {\n-\t      if (flag_ansi_overloading)\n-\t\tfinal_cp->h.code = EVIL_CODE;\n-\t      else\n-\t\tfinal_cp->evil = 1;\n-\t    }\n+\t    final_cp->h.code = EVIL_CODE;\n \t  return error_mark_node;\n \t}\n       if (TREE_CODE (t) == ARRAY_TYPE || TREE_CODE (t) == OFFSET_TYPE)\n@@ -3920,26 +2717,6 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n   else\n     parmtypes = void_list_node;\n \n-  if (! flag_ansi_overloading)\n-    {\n-      tree fn;\n-\n-      /* This is a speed improvement that ends up not working properly in\n-\t the situation of fns with and without default parameters.  I turned\n-\t this off in the new method so it'll go through the argument matching\n-\t code to properly diagnose a match/failure. (bpk)  */\n-      overload_name = build_decl_overload (fnname, parmtypes, 0);\n-      fn = lookup_name_nonclass (overload_name);\n-\n-      /* Now check to see whether or not we can win.\n-\t Note that if we are called from `build_method_call',\n-\t then we cannot have a mis-match, because we would have\n-\t already found such a winning case.  */\n-\n-      if (fn && TREE_CODE (fn) == FUNCTION_DECL)\n-\treturn build_function_call (DECL_MAIN_VARIANT (fn), parms);\n-    }\n-\n   functions = lookup_name_nonclass (fnname);\n \n   if (functions == NULL_TREE)\n@@ -3949,12 +2726,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       if (flags & LOOKUP_COMPLAIN)\n \terror (\"only member functions apply\");\n       if (final_cp)\n-\t{\n-\t  if (flag_ansi_overloading)\n-\t    final_cp->h.code = EVIL_CODE;\n-\t  else\n-\t    final_cp->evil = 1;\n-\t}\n+\tfinal_cp->h.code = EVIL_CODE;\n       return error_mark_node;\n     }\n \n@@ -3982,12 +2754,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \tcp_error (\"function `%D' declared overloaded, but no instances of that function declared\",\n \t\t  TREE_PURPOSE (functions));\n       if (final_cp)\n-\t{\n-\t  if (flag_ansi_overloading)\n-\t    final_cp->h.code = EVIL_CODE;\n-\t  else\n-\t    final_cp->evil = 1;\n-\t}\n+\tfinal_cp->h.code = EVIL_CODE;\n       return error_mark_node;\n     }\n \n@@ -4061,10 +2828,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t  /* Unconverted template -- failed match.  */\n \t  cp->function = function;\n \t  cp->u.bad_arg = -4;\n-\t  if (flag_ansi_overloading)\n-\t    cp->h.code = EVIL_CODE;\n-\t  else\n-\t    cp->evil = 1;\n+\t  cp->h.code = EVIL_CODE;\n \t}\n       else\n \t{\n@@ -4086,60 +2850,30 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t  /* Can't use alloca here, since result might be\n \t     passed to calling function.  */\n \t  cp->h_len = parmlength;\n-\t  if (flag_ansi_overloading)\n-\t    cp->v.ansi_harshness = (struct harshness_code *)\n-\t      oballoc ((parmlength + 1) * sizeof (struct harshness_code));\n-\t  else\n-\t    cp->v.old_harshness = (unsigned short *)\n-\t      oballoc ((parmlength + 1) * sizeof (unsigned short));\n+\t  cp->harshness = (struct harshness_code *)\n+\t    oballoc ((parmlength + 1) * sizeof (struct harshness_code));\n \n \t  compute_conversion_costs (function, parms, cp, parmlength);\n \n-\t  if (flag_ansi_overloading)\n-\t    /* Make sure this is clear as well.  */\n-\t    cp->h.int_penalty += template_cost;\n-\t  else\n-\t    /* Should really add another field...  */\n-\t    cp->easy = cp->easy * 128 + template_cost;\n+\t  /* Make sure this is clear as well.  */\n+\t  cp->h.int_penalty += template_cost;\n \n-\t  /* It seemed easier to have both if stmts in here, rather\n-\t     than excluding the hell out of it with flag_ansi_overloading\n-\t     everywhere. (bpk) */\n-\t  if (flag_ansi_overloading)\n-\t    {\n-\t      if ((cp[0].h.code & EVIL_CODE) == 0)\n-\t\t{\n-\t\t  cp[1].h.code = EVIL_CODE;\n-\n-\t\t  /* int_penalty is set by convert_harshness_ansi for cases\n-\t\t     where we need to know about any penalties that would\n-\t\t     otherwise make a TRIVIAL_CODE pass.  */\n-\t\t  if (final_cp\n-\t\t      && template_cost == 0\n-\t\t      && cp[0].h.code <= TRIVIAL_CODE\n-\t\t      && cp[0].h.int_penalty == 0)\n-\t\t    {\n-\t\t      final_cp[0].h = cp[0].h;\n-\t\t      return function;\n-\t\t    }\n-\t\t  cp++;\n-\t\t}\n-\t    }\n-\t  else\n+\t  if ((cp[0].h.code & EVIL_CODE) == 0)\n \t    {\n-\t      if (cp[0].evil == 0)\n+\t      cp[1].h.code = EVIL_CODE;\n+\n+\t      /* int_penalty is set by convert_harshness_ansi for cases\n+\t\t where we need to know about any penalties that would\n+\t\t otherwise make a TRIVIAL_CODE pass.  */\n+\t      if (final_cp\n+\t\t  && template_cost == 0\n+\t\t  && cp[0].h.code <= TRIVIAL_CODE\n+\t\t  && cp[0].h.int_penalty == 0)\n \t\t{\n-\t\t  cp[1].evil = 1;\n-\t\t  if (final_cp\n-\t\t      && cp[0].user == 0 && cp[0].b_or_d == 0\n-\t\t      && template_cost == 0\n-\t\t      && cp[0].easy <= 1)\n-\t\t    {\n-\t\t      final_cp[0].easy = cp[0].easy;\n-\t\t      return function;\n-\t\t    }\n-\t\t  cp++;\n+\t\t  final_cp[0].h = cp[0].h;\n+\t\t  return function;\n \t\t}\n+\t      cp++;\n \t    }\n \t}\n     }\n@@ -4149,10 +2883,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       tree rval = error_mark_node;\n \n       /* Leave marker.  */\n-      if (flag_ansi_overloading)\n-\tcp[0].h.code = EVIL_CODE;\n-      else\n-\tcp[0].evil = 1;\n+      cp[0].h.code = EVIL_CODE;\n       if (cp - candidates > 1)\n \t{\n \t  struct candidate *best_cp\n@@ -4173,8 +2904,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       else\n \t{\n \t  cp -= 1;\n-\t  if ((flag_ansi_overloading && (cp->h.code & EVIL_CODE))\n-\t      || (!flag_ansi_overloading && cp->evil > 1))\n+\t  if (cp->h.code & EVIL_CODE)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n \t\terror (\"type conversion ambiguous\");"}, {"sha": "4fab523b25f541817a1382f6f3f6e113635e6a9d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -1490,6 +1490,12 @@ finish_base_struct (t, b, t_binfo)\n \t      if (b->has_virtual == 0)\n \t\t{\n \t\t  first_vfn_base_index = i;\n+\n+\t\t  /* Update these two, now that we know what vtable we are\n+\t\t     going to extend.  This is so that we can add virtual\n+\t\t     functions, and override them properly.  */\n+\t\t  BINFO_VTABLE (t_binfo) = TYPE_BINFO_VTABLE (basetype);\n+\t\t  BINFO_VIRTUALS (t_binfo) = TYPE_BINFO_VIRTUALS (basetype);\n \t\t  b->has_virtual = CLASSTYPE_VSIZE (basetype);\n \t\t  b->vfield = CLASSTYPE_VFIELD (basetype);\n \t\t  CLASSTYPE_VFIELD (t) = b->vfield;\n@@ -1678,7 +1684,9 @@ finish_struct_bits (t, max_has_virtual)\n \t\t  else\n \t\t    conv_index = ptr_conv;\n \t\t}\n-\t      else if (typecode_p (return_type, INTEGER_TYPE))\n+\t      else if (typecode_p (return_type, INTEGER_TYPE)\n+\t\t       || typecode_p (return_type, BOOLEAN_TYPE)\n+\t\t       || typecode_p (return_type, ENUMERAL_TYPE))\n \t\t{\n \t\t  TYPE_HAS_INT_CONVERSION (t) = 1;\n \t\t  conv_index = int_conv;\n@@ -2160,9 +2168,11 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t\t}\n \t    }\n \n-\t  /* Find the right offset for the this pointer based on the base\n-\t     class we just found.  */\n-\t  base_offset = BINFO_OFFSET (binfo);\n+\t  /* Find the right offset for the this pointer based on the\n+\t     base class we just found.  We have to take into\n+\t     consideration the virtual base class pointers that we\n+\t     stick in before the virtual function table pointer.  */\n+\t  base_offset = get_vfield_offset (binfo);\n \t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n \n \t  /* Make sure we can modify the derived association with immunity.  */\n@@ -2929,10 +2939,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      /* Invalid bit-field size done by grokfield.  */\n \t      /* Detect invalid bit-field type.  */\n \t      if (DECL_INITIAL (x)\n-\t\t  && TREE_CODE (TREE_TYPE (x)) != INTEGER_TYPE\n-\t\t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n+\t\t  && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n \t\t{\n-\t\t  cp_error_at (\"bit-field `%D' has invalid type\", x);\n+\t\t  cp_error_at (\"bit-field `%#D' with non-integral type\", x);\n \t\t  DECL_INITIAL (x) = NULL;\n \t\t}\n \n@@ -3499,6 +3508,27 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t}\n     }\n \n+  /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n+     might need to know it for setting up the offsets in the vtable\n+     (or in thunks) below.  */\n+  if (vfield != NULL_TREE\n+      && DECL_FIELD_CONTEXT (vfield) != t)\n+    {\n+      tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n+      tree offset = BINFO_OFFSET (binfo);\n+\n+      vfield = copy_node (vfield);\n+      copy_lang_decl (vfield);\n+\n+      if (! integer_zerop (offset))\n+\toffset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT));\n+      DECL_FIELD_CONTEXT (vfield) = t;\n+      DECL_CLASS_CONTEXT (vfield) = t;\n+      DECL_FIELD_BITPOS (vfield)\n+\t= size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n+      CLASSTYPE_VFIELD (t) = vfield;\n+    }\n+    \n #ifdef NOTQUITE\n   cp_warning (\"Doing hard virtuals for %T...\", t);\n #endif\n@@ -3739,6 +3769,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  DECL_REGISTER (vtbl_ptr) = 1;\n \t  CLASSTYPE_VTBL_PTR (t) = vtbl_ptr;\n \t}\n+#if 0\n+      /* This is now done above. */\n       if (DECL_FIELD_CONTEXT (vfield) != t)\n \t{\n \t  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n@@ -3755,6 +3787,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    = size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n \t  CLASSTYPE_VFIELD (t) = vfield;\n \t}\n+#endif\n \n       /* In addition to this one, all the other vfields should be listed. */\n       /* Before that can be done, we have to have FIELD_DECLs for them, and"}, {"sha": "6f31e15ee83c6f8ced1740fdaf7723d1df1ffe7e", "filename": "gcc/cp/class.h", "status": "modified", "additions": 5, "deletions": 50, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.h?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -39,34 +39,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    and one uses pointers of strictly higher type (derived where\n    another uses base), then that alternative is silently chosen.\n \n-   If two candidates have a non-monotonic derived/base pointer\n-   relationship, and/or a non-monotonic easy conversion relationship,\n-   then a warning is emitted to show which paths are possible, and\n-   which one is being chosen.\n-\n-   For example:\n-\n-   int i;\n-   double x;\n-\n-   overload f;\n-   int f (int, int);\n-   double f (double, double);\n-\n-   f (i, x);\t// draws a warning\n-\n-   struct B\n-   {\n-     f (int);\n-   } *bb;\n-   struct D : B\n-   {\n-     f (double);\n-   } *dd;\n-\n-   dd->f (x);\t// exact match\n-   dd->f (i);\t// draws warning\n-\n    Note that this technique really only works for 255 arguments.  Perhaps\n    this is not enough.  */\n \n@@ -102,36 +74,19 @@ struct harshness_code\n \n struct candidate\n {\n-  /* OLD METHOD */\n-  unsigned char evil;\t      /* !0 if this will never convert.  */\n-  unsigned char ellipsis;     /* !0 if a match against an ellipsis occurred */\n-  unsigned char user;\t      /* !0 if at least one user-defined type conv.  */\n-  unsigned short b_or_d;      /* count number of derived->base or\n-\t\t\t\t base->derived conv.  */\n-  unsigned short easy;\t      /* count number of builtin type conv.  */\n-\n-  /* NEW METHOD */\n   struct harshness_code h;\t/* Used for single-argument conversions.  */\n \n   int h_len;\t\t\t/* The length of the harshness vector.  */\n \n-  /* Both methods.  */\n   tree function;\t\t/* A FUNCTION_DECL */\n   tree basetypes;\t\t/* The path to function. */\n   tree arg;\t\t\t/* first parm to function.  */\n \n-  /* This union is only here while we maintain both the old and new\n-     argument matching schemes.  When it goes away, all v.ansi_harshness\n-     references will be just `harshness'.  */\n-  union\n-    {\n-      /* Indexed by argument number, encodes evil, user, d_to_b, and easy\n-\t strikes for that argument.  At end of array, we store the index+1\n-\t of where we started using default parameters, or 0 if there are\n-\t none.  */\n-      struct harshness_code *ansi_harshness; /* NEW METHOD */\n-      unsigned short *old_harshness;  /* OLD METHOD */\n-    } v;\n+  /* Indexed by argument number, encodes evil, user, d_to_b, and easy\n+     strikes for that argument.  At end of array, we store the index+1\n+     of where we started using default parameters, or 0 if there are\n+     none.  */\n+  struct harshness_code *harshness;\n \n   union\n     {"}, {"sha": "061c7f1e28ac5c2fc5d7f30841f5790b3f5652a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -280,11 +280,6 @@ extern int flag_ansi;\n \n extern int flag_handle_exceptions;\n \n-/* Nonzero means do argument matching for overloading according to the\n-   ANSI rules, rather than what g++ used to believe to be correct.  */\n-\n-extern int flag_ansi_overloading;\n-\n /* Nonzero means recognize and handle signature language constructs.  */\n \n extern int flag_handle_signatures;\n@@ -1132,6 +1127,10 @@ struct lang_decl\n        || TYPE_MAIN_VARIANT (t) == short_integer_type_node\t\\\n        || TYPE_MAIN_VARIANT (t) == short_unsigned_type_node))\n \n+#define INTEGRAL_CODE_P(CODE) \\\n+  (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n+#define ARITHMETIC_TYPE_P(TYPE) (INTEGRAL_TYPE_P (TYPE) || FLOAT_TYPE_P (TYPE))\n+\n /* Mark which labels are explicitly declared.\n    These may be shadowed, and may be referenced from nested functions.  */\n #define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n@@ -1367,6 +1366,7 @@ extern tree delta_type_node;\n extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n /* For building calls to `delete'.  */\n extern tree integer_two_node, integer_three_node;\n+extern tree bool_type_node, true_node, false_node;\n \n /* in except.c */\n extern tree current_exception_type;\n@@ -1938,6 +1938,7 @@ extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n+extern tree check_cp_case_value\t\t\tPROTO((tree));\n \n /* in edsel.c */\n \n@@ -2217,6 +2218,7 @@ extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n \n /* in typeck.c */\n+extern tree bool_truthvalue_conversion\t\tPROTO((tree));\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n extern int type_unknown_p\t\t\tPROTO((tree));\n@@ -2262,6 +2264,9 @@ extern tree build_x_conditional_expr\t\tPROTO((tree, tree, tree));\n extern tree build_conditional_expr\t\tPROTO((tree, tree, tree));\n extern tree build_x_compound_expr\t\tPROTO((tree));\n extern tree build_compound_expr\t\t\tPROTO((tree));\n+extern tree build_static_cast\t\t\tPROTO((tree, tree));\n+extern tree build_reinterpret_cast\t\tPROTO((tree, tree));\n+extern tree build_const_cast\t\t\tPROTO((tree, tree));\n extern tree build_c_cast\t\t\tPROTO((tree, tree));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern int language_lvalue_valid\t\tPROTO((tree));"}, {"sha": "7bfe80233a8add6859d13cb5809da4b098599b7b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 96, "deletions": 71, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -186,7 +186,7 @@ cp_convert_to_pointer (type, expr)\n       return expr;\n     }\n \n-  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+  if (INTEGRAL_CODE_P (form))\n     {\n       if (type_precision (intype) == POINTER_SIZE)\n \treturn build1 (CONVERT_EXPR, type, expr);\n@@ -950,16 +950,11 @@ convert_to_aggr (type, expr, msgp, protect)\n       {\n \tfunction = fndecl;\n \tcp->h_len = 2;\n-\tif (flag_ansi_overloading)\n-\t  cp->v.ansi_harshness = (struct harshness_code *)\n-\t    alloca (3 * sizeof (struct harshness_code));\n-\telse\n-\t  cp->v.old_harshness = (unsigned short *)\n-\t    alloca (3 * sizeof (short));\n+\tcp->harshness = (struct harshness_code *)\n+\t  alloca (3 * sizeof (struct harshness_code));\n \n \tcompute_conversion_costs (fndecl, parmlist, cp, 2);\n-\tif ((flag_ansi_overloading && (cp->h.code & EVIL_CODE) == 0)\n-\t    || (!flag_ansi_overloading && cp->evil == 0))\n+\tif ((cp->h.code & EVIL_CODE) == 0)\n \t  {\n \t    cp->u.field = fndecl;\n \t    if (protect)\n@@ -983,10 +978,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n \t\t: 1)\n \t      {\n-\t\tif ((flag_ansi_overloading && cp->h.code <= TRIVIAL_CODE)\n-\t\t    || (!flag_ansi_overloading\n-\t\t\t&& cp->user == 0 && cp->b_or_d == 0\n-\t\t\t&& cp->easy <= 1))\n+\t\tif (cp->h.code <= TRIVIAL_CODE)\n \t\t  goto found_and_ok;\n \t\tcp++;\n \t      }\n@@ -1014,8 +1006,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \t\t rank_for_overload); /* int (*compar)() */\n \n \t--cp;\n-\tif ((flag_ansi_overloading && (cp->h.code & EVIL_CODE))\n-\t    || (!flag_ansi_overloading && cp->evil > 1))\n+\tif (cp->h.code & EVIL_CODE)\n \t  {\n \t    if (msgp)\n \t      *msgp = \"ambiguous type conversion possible for `%s'\";\n@@ -1235,15 +1226,14 @@ cp_convert (type, expr, convtype, flags)\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n-  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n+  if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (expr);\n       enum tree_code form = TREE_CODE (intype);\n       /* enum = enum, enum = int, enum = float are all errors. */\n       if (flag_int_enum_equivalence == 0\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && (form == INTEGER_TYPE || form == REAL_TYPE\n-\t      || form == ENUMERAL_TYPE))\n+\t  && ARITHMETIC_TYPE_P (intype))\n \t{\n \t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n \n@@ -1258,9 +1248,23 @@ cp_convert (type, expr, convtype, flags)\n \t  tree rval;\n \t  rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n \t  if (rval) return rval;\n-\t  cp_error (\"`%#T' used where an `int' was expected\", intype);\n+\t  if (code == BOOLEAN_TYPE)\n+\t    cp_error (\"`%#T' used where a `bool' was expected\", intype);\n+\t  else\n+\t    cp_error (\"`%#T' used where an `int' was expected\", intype);\n \t  return error_mark_node;\n \t}\n+      if (code == BOOLEAN_TYPE)\n+\t{\n+\t  tree newe = truthvalue_conversion (e);\n+\t  /* Avoid stupid (infinite) recursion from backend. */\n+\t  if (TREE_CODE (newe) != NOP_EXPR || e != TREE_OPERAND (newe, 0))\n+\t    e = newe;\n+\t  if (TREE_TYPE (e) == bool_type_node)\n+\t    return e;\n+\t  else\n+\t    return build1 (NOP_EXPR, bool_type_node, e);\n+\t}\n       return fold (convert_to_integer (type, e));\n     }\n   if (code == POINTER_TYPE)\n@@ -1554,6 +1558,14 @@ build_type_conversion (code, xtype, expr, for_sure)\n   if (TREE_CODE (basetype) == REFERENCE_TYPE)\n     basetype = TREE_TYPE (basetype);\n \n+  if (TYPE_PTRMEMFUNC_P (basetype) && TREE_CODE (xtype) == BOOLEAN_TYPE)\n+    {\n+      /* We convert a pointer to member function into a boolean,\n+\t by just checking the index value, for == 0, we want false, for\n+\t != 0, we want true.  */\n+      return convert (xtype, build_component_ref (expr, index_identifier, 0, 0));\n+    }\n+\n   basetype = TYPE_MAIN_VARIANT (basetype);\n   if (! TYPE_LANG_SPECIFIC (basetype) || ! TYPE_HAS_CONVERSION (basetype))\n     return NULL_TREE;\n@@ -1651,6 +1663,30 @@ build_type_conversion (code, xtype, expr, for_sure)\n   if (exact_conversion)\n     return NULL_TREE;\n \n+  if (TREE_CODE (type) == BOOLEAN_TYPE)\n+    {\n+      tree as_int = build_type_conversion (code, long_long_unsigned_type_node, expr, 0);\n+      tree as_ptr = build_type_conversion (code, ptr_type_node, expr, 0);\n+      /* We are missing the conversion to pointer to member type. */\n+      /* We are missing the conversion to floating type. */\n+      if (as_int && as_ptr && for_sure)\n+\t{\n+\t  cp_error (\"ambiguous conversion from `%T' to `bool', can convert to integral type or pointer\", TREE_TYPE (expr));\n+\t  return error_mark_node;\n+\t}\n+      if (as_int)\n+\t{\n+\t  as_int = build_type_conversion (code, long_long_unsigned_type_node, expr, for_sure+exact_conversion*2);\n+\t  return convert (xtype, as_int);\n+\t}\n+      if (as_ptr)\n+\t{\n+\t  as_ptr = build_type_conversion (code, ptr_type_node, expr, for_sure+exact_conversion*2);\n+\t  return convert (xtype, as_ptr);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n   /* No perfect match found, try default.  */\n #if 0 /* This is wrong; there is no standard conversion from void* to\n          anything.  -jason */\n@@ -1686,8 +1722,6 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t}\n     }\n \n- try_pointer:\n-\n   if (TREE_CODE (type) == POINTER_TYPE && TYPE_READONLY (TREE_TYPE (type)))\n     {\n       /* Try converting to some other const pointer type and then using\n@@ -1747,7 +1781,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n     {\n       /* Only accept using an operator double() if there isn't a conflicting\n \t operator int().  */\n-      if (flag_ansi_overloading && TYPE_HAS_INT_CONVERSION (basetype))\n+      if (TYPE_HAS_INT_CONVERSION (basetype))\n \t{\n \t  error (\"two possible conversions for type `%s'\",\n \t\t TYPE_NAME_STRING (type));\n@@ -1758,17 +1792,6 @@ build_type_conversion (code, xtype, expr, for_sure)\n       return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n     }\n \n-  /* THIS IS A KLUDGE.  */\n-  if (TREE_CODE (type) != POINTER_TYPE\n-      && (code == TRUTH_ANDIF_EXPR\n-\t  || code == TRUTH_ORIF_EXPR\n-\t  || code == TRUTH_NOT_EXPR))\n-    {\n-      /* Here's when we can convert to a pointer.  */\n-      type = ptr_type_node;\n-      goto try_pointer;\n-    }\n-\n   /* THESE ARE TOTAL KLUDGES.  */\n   /* Default promotion yields no new alternatives, try\n      conversions which are anti-default, such as\n@@ -1777,7 +1800,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \n      */\n   if (type_default == type\n-      && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE))\n+      && (INTEGRAL_TYPE_P (type) || TREE_CODE (type) == REAL_TYPE))\n     {\n       int not_again = 0;\n \n@@ -1819,19 +1842,10 @@ build_type_conversion (code, xtype, expr, for_sure)\n   /* Now, try C promotions...\n \n      float -> int\n-     int -> float, void *\n-     void * -> int\n-\n-     Truthvalue conversions let us try to convert\n-     to pointer if we were going for int, and to int\n-     if we were looking for pointer.  */\n+     int -> float  */\n \n     basetype = save_basetype;\n-    if (TREE_CODE (type) == REAL_TYPE\n-\t|| (TREE_CODE (type) == POINTER_TYPE\n-\t    && (code == TRUTH_ANDIF_EXPR\n-\t\t|| code == TRUTH_ORIF_EXPR\n-\t\t|| code == TRUTH_NOT_EXPR)))\n+    if (TREE_CODE (type) == REAL_TYPE)\n       type = integer_type_node;\n     else if (TREE_CODE (type) == INTEGER_TYPE)\n       if (TYPE_HAS_REAL_CONVERSION (basetype))\n@@ -1917,11 +1931,17 @@ build_default_binary_type_conversion (code, arg1, arg2)\n       return 0;\n     }\n \n-  if (TYPE_HAS_INT_CONVERSION (type1) && TYPE_HAS_REAL_CONVERSION (type1))\n-    cp_warning (\"ambiguous type conversion for type `%T', defaulting to int\",\n-\t\ttype1);\n-  if (TYPE_HAS_INT_CONVERSION (type1))\n+  if (code == TRUTH_ANDIF_EXPR\n+      || code == TRUTH_ORIF_EXPR)\n     {\n+      *arg1 = convert (bool_type_node, *arg1);\n+      *arg2 = convert (bool_type_node, *arg2);\n+    }\n+  else if (TYPE_HAS_INT_CONVERSION (type1))\n+    {\n+      if (TYPE_HAS_REAL_CONVERSION (type1))\n+\tcp_pedwarn (\"ambiguous type conversion for type `%T', defaulting to int\",\n+\t\t    type1);\n       *arg1 = build_type_conversion (code, integer_type_node, *arg1, 1);\n       *arg2 = build_type_conversion (code, integer_type_node, *arg2, 1);\n     }\n@@ -1956,7 +1976,7 @@ build_default_binary_type_conversion (code, arg1, arg2)\n   return 1;\n }\n \n-/* Must convert two aggregate types to non-aggregate type.\n+/* Must convert an aggregate type to non-aggregate type.\n    Attempts to find a non-ambiguous, \"best\" type conversion.\n \n    Return 1 on success, 0 on failure.\n@@ -1970,21 +1990,22 @@ build_default_unary_type_conversion (code, arg)\n      tree *arg;\n {\n   tree type = TREE_TYPE (*arg);\n-  tree id = TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-    ? TYPE_IDENTIFIER (type) : TYPE_NAME (type);\n-  char *name = IDENTIFIER_POINTER (id);\n \n   if (! TYPE_HAS_CONVERSION (type))\n     {\n-      error (\"type conversion required for type `%s'\", name);\n+      cp_error (\"type conversion required for type `%T'\", type);\n       return 0;\n     }\n \n-  if (TYPE_HAS_INT_CONVERSION (type) && TYPE_HAS_REAL_CONVERSION (type))\n-    warning (\"ambiguous type conversion for type `%s', defaulting to int\",\n-\t     name);\n-  if (TYPE_HAS_INT_CONVERSION (type))\n-    *arg = build_type_conversion (code, integer_type_node, *arg, 1);\n+  if (code == TRUTH_NOT_EXPR)\n+    *arg = convert (bool_type_node, *arg);\n+  else if (TYPE_HAS_INT_CONVERSION (type))\n+    {\n+      if (TYPE_HAS_REAL_CONVERSION (type))\n+\tcp_pedwarn (\"ambiguous type conversion for type `%T', defaulting to int\",\n+\t\t    type);\n+      *arg = build_type_conversion (code, integer_type_node, *arg, 1);\n+    }\n   else if (TYPE_HAS_REAL_CONVERSION (type))\n     *arg = build_type_conversion (code, double_type_node, *arg, 1);\n   else\n@@ -1995,7 +2016,7 @@ build_default_unary_type_conversion (code, arg)\n     }\n   if (*arg == NULL_TREE)\n     {\n-      error (\"default type conversion for type `%s' failed\", name);\n+      cp_error (\"default type conversion for type `%T' failed\", type);\n       return 0;\n     }\n   return 1;\n@@ -2009,17 +2030,21 @@ type_promotes_to (type)\n   int constp = TYPE_READONLY (type);\n   int volatilep = TYPE_VOLATILE (type);\n   type = TYPE_MAIN_VARIANT (type);\n-  \n-  /* Normally convert enums to int,\n-     but convert wide enums to something wider.  */\n-  if (TREE_CODE (type) == ENUMERAL_TYPE\n-      || type == wchar_type_node)\n-    type = type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t       TYPE_PRECISION (integer_type_node)),\n-\t\t\t  ((flag_traditional\n-\t\t\t    || (TYPE_PRECISION (type)\n-\t\t\t\t>= TYPE_PRECISION (integer_type_node)))\n-\t\t\t   && TREE_UNSIGNED (type)));\n+\n+  /* bool always promotes to int (not unsigned), even if it's the same\n+     size.  */\n+  if (type == bool_type_node)\n+    type = integer_type_node;\n+\n+  /* Normally convert enums to int, but convert wide enums to something\n+     wider.  */\n+  else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t   || type == wchar_type_node)\n+    type = type_for_size\n+      (MAX (TYPE_PRECISION (type), TYPE_PRECISION (integer_type_node)),\n+       (flag_traditional\n+\t|| (TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node)))\n+       && TREE_UNSIGNED (type));\n   else if (C_PROMOTING_INTEGER_TYPE_P (type))\n     {\n       /* Traditionally, unsignedness is preserved in default promotions."}, {"sha": "fd73388d65ddd4cf866c7885a494d8c0cf937123", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 64, "deletions": 35, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -204,6 +204,9 @@ tree int_array_type_node;\n \n tree wchar_array_type_node;\n \n+/* The bool data type, and constants */\n+tree bool_type_node, true_node, false_node;\n+\n /* type `int ()' -- used for implicit declaration of functions.  */\n \n tree default_function_type;\n@@ -412,9 +415,7 @@ extern int flag_no_builtin;\n \n extern int flag_implement_inlines;\n \n-/* Nonzero means handle things in ANSI, instead of GNU fashion.  This\n-   flag should be tested for language behavior that's different between\n-   ANSI and GNU, but not so horrible as to merit a PEDANTIC label.  */\n+/* Nonzero means disable GNU extensions.  */\n \n extern int flag_ansi;\n \n@@ -1709,7 +1710,7 @@ pushtag (name, type, globalize)\n {\n   register struct binding_level *b;\n   tree context = 0;\n-  tree cdecl = 0;\n+  tree c_decl = 0;\n \n   b = inner_binding_level;\n   while (b->tag_transparent\n@@ -1727,7 +1728,7 @@ pushtag (name, type, globalize)\n       if (! context && ! globalize)\n         context = current_scope ();\n       if (context)\n-\tcdecl = TREE_CODE (context) == FUNCTION_DECL\n+\tc_decl = TREE_CODE (context) == FUNCTION_DECL\n \t  ? context : TYPE_NAME (context);\n \n       /* Record the identifier as the type's name if it has none.  */\n@@ -1746,7 +1747,7 @@ pushtag (name, type, globalize)\n \t  if (b->parm_flag != 2\n \t      || TYPE_SIZE (current_class_type) != NULL_TREE)\n \t    {\n-\t      d = lookup_nested_type (type, cdecl);\n+\t      d = lookup_nested_type (type, c_decl);\n \n \t      if (d == NULL_TREE)\n \t\t{\n@@ -1824,7 +1825,7 @@ pushtag (name, type, globalize)\n \t  else if (context && TREE_CODE (context) == FUNCTION_DECL)\n \t    {\n \t      /* Function-nested class.  */\n-\t      set_nested_typename (d, DECL_ASSEMBLER_NAME (cdecl),\n+\t      set_nested_typename (d, DECL_ASSEMBLER_NAME (c_decl),\n \t\t\t\t   name, type);\n \t      /* This builds the links for classes nested in fn scope.  */\n \t      DECL_CONTEXT (d) = context;\n@@ -1834,7 +1835,7 @@ pushtag (name, type, globalize)\n \t  else if (context && TREE_CODE (context) == RECORD_TYPE)\n \t    {\n \t      /* Class-nested class.  */\n-\t      set_nested_typename (d, DECL_NESTED_TYPENAME (cdecl),\n+\t      set_nested_typename (d, DECL_NESTED_TYPENAME (c_decl),\n \t\t\t\t   name, type);\n \t      /* This builds the links for classes nested in type scope.  */\n \t      DECL_CONTEXT (d) = context;\n@@ -4373,6 +4374,14 @@ init_decl_processing ()\n   TREE_TYPE (integer_three_node) = integer_type_node;\n   empty_init_node = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n \n+  bool_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n+  TREE_SET_CODE (bool_type_node, BOOLEAN_TYPE);\n+  record_builtin_type (RID_BOOL, \"bool\", bool_type_node);\n+  false_node = build_int_2 (0, 0);\n+  TREE_TYPE (false_node) = bool_type_node;\n+  true_node = build_int_2 (1, 0);\n+  TREE_TYPE (true_node) = bool_type_node;\n+\n   /* These are needed by stor-layout.c.  */\n   size_zero_node = size_int (0);\n   size_one_node = size_int (1);\n@@ -5007,7 +5016,7 @@ shadow_tag (declspecs)\n {\n   int found_tag = 0;\n   int warned = 0;\n-  int static_or_extern = 0;\n+  tree ob_modifier = NULL_TREE;\n   register tree link;\n   register enum tree_code code, ok_code = ERROR_MARK;\n   register tree t = NULL_TREE;\n@@ -5018,11 +5027,12 @@ shadow_tag (declspecs)\n \n       code = TREE_CODE (value);\n       if (IS_AGGR_TYPE_CODE (code) || code == ENUMERAL_TYPE)\n-\t/* Used to test also that TYPE_SIZE (value) != 0.\n-\t   That caused warning for `struct foo;' at top level in the file.  */\n \t{\n \t  register tree name = TYPE_NAME (value);\n \n+\t  if (code == ENUMERAL_TYPE && TYPE_SIZE (value) == 0)\n+\t    cp_error (\"forward declaration of `%#T'\", value);\n+\n \t  if (name == NULL_TREE)\n \t    name = lookup_tag_reverse (value, NULL_TREE);\n \n@@ -5041,7 +5051,6 @@ shadow_tag (declspecs)\n \t      pushtag (name, t, 0);\n \t      pop_obstacks ();\n \t      ok_code = code;\n-\t      break;\n \t    }\n \t  else if (name != NULL_TREE || code == ENUMERAL_TYPE)\n \t    ok_code = code;\n@@ -5056,8 +5065,10 @@ shadow_tag (declspecs)\n \t    }\n \t}\n       else if (value == ridpointers[(int) RID_STATIC]\n-\t       || value == ridpointers[(int) RID_EXTERN])\n-\tstatic_or_extern = 1;\n+\t       || value == ridpointers[(int) RID_EXTERN]\n+\t       || value == ridpointers[(int) RID_AUTO]\n+\t       || value == ridpointers[(int) RID_REGISTER])\n+\tob_modifier = value;\n     }\n \n   /* This is where the variables in an anonymous union are\n@@ -5086,9 +5097,10 @@ shadow_tag (declspecs)\n   else\n     {\n       /* Anonymous unions are objects, that's why we only check for\n-\t static/extern specifiers in this branch.  */\n-      if (static_or_extern)\n-\terror (\"static/extern can only be specified for objects and functions\");\n+\t inappropriate specifiers in this branch.  */\n+      if (ob_modifier)\n+\tcp_error (\"`%D' can only be specified for objects and functions\",\n+\t\t  ob_modifier);\n \n       if (ok_code == RECORD_TYPE\n \t  && found_tag == 1\n@@ -5113,8 +5125,10 @@ shadow_tag (declspecs)\n \t      pop_obstacks ();\n \t    }\n \t}\n+      else if (found_tag == 0)\n+\tpedwarn (\"abstract declarator used as declaration\");\n       else if (!warned && found_tag > 1)\n-\twarning (\"multiple types in one declaration\");\n+\tpedwarn (\"multiple types in one declaration\");\n     }\n }\n \f\n@@ -5967,14 +5981,16 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  && (TYPE_READONLY (type) || TREE_READONLY (decl)))\n \tcp_error (\"uninitialized const `%D'\", decl);\n \n-      /* Initialize variables in need of static initialization\n-\t with `empty_init_node' to keep assemble_variable from putting them\n-\t in the wrong program space.  (Common storage is okay for non-public\n-\t uninitialized data; the linker can't match it with storage from other\n-\t files, and we may save some disk space.)  */\n+      /* Initialize variables in need of static initialization with\n+\t `empty_init_node' to keep assemble_variable from putting them in\n+\t the wrong program space.  Common storage is okay for non-public\n+\t uninitialized data; the linker can't match it with storage from\n+\t other files, and we may save some disk space.  Consts have to go\n+\t into data, though, since the backend would put them in text\n+\t otherwise.  */\n       if (flag_pic == 0\n \t  && TREE_STATIC (decl)\n-\t  && TREE_PUBLIC (decl)\n+\t  && (TREE_PUBLIC (decl) || was_readonly)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && TREE_CODE (decl) == VAR_DECL\n \t  && TYPE_NEEDS_CONSTRUCTING (type)\n@@ -7341,6 +7357,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t}\n \t      goto found;\n \t    }\n+\t  if (id == ridpointers[(int) RID_BOOL])\n+\t    {\n+\t      if (type)\n+\t\terror (\"extraneous `bool' ignored\");\n+\t      else\n+\t\t{\n+\t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n+\t\t}\n+\t      goto found;\n+\t    }\n \t  if (id == ridpointers[(int) RID_WCHAR])\n \t    {\n \t      if (type)\n@@ -7445,7 +7471,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t/* Save warning until we know what is really going on.  */\n \t\twarn_about_return_type = 1;\n \t    }\n-\t  else if (class_binding_level && declarator\n+\t  else if (decl_context == FIELD && declarator\n \t\t   && TREE_CODE (declarator) == SCOPE_REF)\n \t    /* OK -- access declaration */;\n \t  else if (declspecs == NULL_TREE &&\n@@ -8007,7 +8033,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\tif (TREE_READONLY_DECL_P (size))\n \t\t  size = decl_constant_value (size);\n-\t\tif (pedantic && integer_zerop (size))\n+\t\tif (flag_ansi && integer_zerop (size))\n \t\t  cp_pedwarn (\"ANSI C++ forbids zero-size array `%D'\", dname);\n \t\tif (TREE_CONSTANT (size))\n \t\t  {\n@@ -8022,7 +8048,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    if (pedantic)\n+\t\t    if (flag_ansi)\n \t\t      cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n \t\t\t\t  dname);\n \t\t  dont_grok_size:\n@@ -8909,7 +8935,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t   initialize the named nonstatic member....  This (or an\n \t\t   initializer list) is the only way to initialize\n \t\t   nonstatic const and reference members.  */\n-\t\telse if (pedantic || flag_ansi || ! constp)\n+\t\telse if (flag_ansi || ! constp)\n \t\t  pedwarn (\"ANSI C++ forbids initialization of %s `%s'\",\n \t\t\t   constp ? \"const member\" : \"member\",\n \t\t\t   IDENTIFIER_POINTER (declarator));\n@@ -9061,7 +9087,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    if (RIDBIT_SETP (RID_EXTERN, specbits))\n \t      {\n \t\tcurrent_extern_inline = 1;\n-\t\tif (flag_ansi || pedantic || flag_pedantic_errors)\n+\t\tif (flag_ansi)\n \t\t  pedwarn (\"ANSI C++ does not permit `extern inline'\");\n \t      }\n \t  }\n@@ -10245,31 +10271,34 @@ finish_enum (enumtype, values)\n   register HOST_WIDE_INT minvalue = 0;\n   register HOST_WIDE_INT i;\n \n-  TYPE_VALUES (enumtype) = values;\n-\n   /* Calculate the maximum value of any enumerator in this type.  */\n \n   if (values)\n     {\n       /* Speed up the main loop by performing some precalculations */\n \n-      HOST_WIDE_INT value = TREE_INT_CST_LOW (TREE_VALUE (values));\n+      HOST_WIDE_INT value;\n       TREE_TYPE (TREE_VALUE (values)) = enumtype;\n       TREE_TYPE (DECL_INITIAL (TREE_VALUE (values))) = enumtype;\n+      TREE_VALUE (values) = DECL_INITIAL (TREE_VALUE (values));\n+      value = TREE_INT_CST_LOW (TREE_VALUE (values));\n       minvalue = maxvalue = value;\n       \n       for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n \t{\n+\t  TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n+\t  TREE_TYPE (DECL_INITIAL (TREE_VALUE (pair))) = enumtype;\n+\t  TREE_VALUE (pair) = DECL_INITIAL (TREE_VALUE (pair));\n \t  value = TREE_INT_CST_LOW (TREE_VALUE (pair));\n \t  if (value > maxvalue)\n \t    maxvalue = value;\n \t  else if (value < minvalue)\n \t    minvalue = value;\n-\t  TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n-\t  TREE_TYPE (DECL_INITIAL (TREE_VALUE (pair))) = enumtype;\n \t}\n     }\n \n+  TYPE_VALUES (enumtype) = values;\n+\n   if (flag_short_enums)\n     {\n       /* Determine the precision this type needs, lay it out, and define\n@@ -10970,7 +10999,7 @@ store_return_init (return_id, init)\n {\n   tree decl = DECL_RESULT (current_function_decl);\n \n-  if (pedantic)\n+  if (flag_ansi)\n     /* Give this error as many times as there are occurrences,\n        so that users can use Emacs compilation buffers to find\n        and fix all such places.  */"}, {"sha": "55414dfba2a8508759f946824b1cf422a468e2e1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -96,17 +96,10 @@ int flag_signed_bitfields = 1;\n \n int flag_no_ident = 0;\n \n-/* Nonzero means handle things in ANSI, instead of GNU fashion.  This\n-   flag should be tested for language behavior that's different between\n-   ANSI and GNU, but not so horrible as to merit a PEDANTIC label.  */\n+/* Nonzero means disable GNU extensions.  */\n \n int flag_ansi = 0;\n \n-/* Nonzero means do argument matching for overloading according to the\n-   ANSI rules, rather than what g++ used to believe to be correct.  */\n-\n-int flag_ansi_overloading = 1;\n-\n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n \n@@ -359,7 +352,6 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n-  {\"ansi-overloading\", &flag_ansi_overloading, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n@@ -797,9 +789,11 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t we may wish to make it special.  */\n       tree type = TREE_VALUE (arg_types);\n \n-      if (flags == DTOR_FLAG)\n+      if ((flag_this_is_variable > 0)\n+\t  && (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function)))\n \ttype = TYPE_MAIN_VARIANT (type);\n-      else if (DECL_CONSTRUCTOR_P (function))\n+\n+      if (DECL_CONSTRUCTOR_P (function))\n \t{\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (ctype))\n \t    {\n@@ -824,14 +818,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n       DECL_REGISTER (parm) = 1;\n-#if 0\n-      /* it is wrong to flag the object as readonly, when\n-\t flag_this_is_variable is 0. */\n-      if (flags != DTOR_FLAG\n-\t  && (flag_this_is_variable <= 0 || TYPE_READONLY (type)))\n-#else\n-      if (flags != DTOR_FLAG && TYPE_READONLY (type))\n-#endif\n+      if (TYPE_READONLY (type))\n \tTREE_READONLY (parm) = 1;\n       TREE_CHAIN (parm) = last_function_parms;\n       last_function_parms = parm;\n@@ -1044,7 +1031,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n     case 2:\n       maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n       if (! flag_traditional)\n-\tpedwarn (\"ANSI C++ forbids array size in vector delete\");\n+\tpedwarn (\"anachronistic use of array size in vector delete\");\n       /* Fall through.  */\n     case 1:\n       elt_size = c_sizeof (type);\n@@ -1800,7 +1787,7 @@ build_push_scope (cname, name)\n void cplus_decl_attributes (decl, attributes)\n      tree decl, attributes;\n {\n-  if (decl)\n+  if (decl && decl != void_type_node)\n     decl_attributes (decl, attributes);\n }\n \f\n@@ -2952,3 +2939,43 @@ finish_decl_parsing (decl)\n       return NULL_TREE;\n     }\n }\n+\n+tree\n+check_cp_case_value (value)\n+     tree value;\n+{\n+  if (value == NULL_TREE)\n+    return value;\n+\n+  /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n+     Strip such NOP_EXPRs.  */\n+  if (TREE_CODE (value) == NOP_EXPR\n+      && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n+    value = TREE_OPERAND (value, 0);\n+\n+  if (TREE_READONLY_DECL_P (value))\n+    {\n+      value = decl_constant_value (value);\n+      /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n+\t Strip such NOP_EXPRs.  */\n+      if (TREE_CODE (value) == NOP_EXPR\n+\t  && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n+\tvalue = TREE_OPERAND (value, 0);\n+    }\n+  value = fold (value);\n+\n+  if (TREE_CODE (value) != INTEGER_CST\n+      && value != error_mark_node)\n+    {\n+      cp_error (\"case label `%E' does not reduce to an integer constant\",\n+\t\tvalue);\n+      value = error_mark_node;\n+    }\n+  else\n+    /* Promote char or short to int.  */\n+    value = default_conversion (value);\n+\n+  constant_expression_warning (value);\n+\n+  return value;\n+}"}, {"sha": "1b345fda9c2adaf026d75450ba1ed19fa2c76f3b", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -120,7 +120,7 @@ cp_thing (errfn, atarg1, format, arglist)\n \n \t  if (arg >= NARGS) abort ();\n \t  \n-\t  if (maybe_here && atarg)\n+\t  if (maybe_here && atarg1)\n \t    atarg = args[arg];\n \n \t  /* Must use a temporary to avoid calling *function twice */"}, {"sha": "6d2ec7fc8b8515a7648a8ad6508ad9c47bc876f6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -198,6 +198,7 @@ dump_type (t, v)\n       /* fall through.  */\n     case REAL_TYPE:\n     case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n       dump_readonly_or_volatile (t, after);\n       OB_PUTID (TYPE_IDENTIFIER (t));\n       break;\n@@ -356,6 +357,10 @@ dump_type_prefix (t, v)\n \n \tswitch (TREE_CODE (sub))\n \t  {\n+\t  case ARRAY_TYPE:\n+\t    OB_PUTC2 (' ', '(');\n+\t    break;\n+\n \t  case POINTER_TYPE:\n \t    /* We don't want \"char * &\" */\n \t    if (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n@@ -405,6 +410,7 @@ dump_type_prefix (t, v)\n     case ERROR_MARK:\n     case IDENTIFIER_NODE:\n     case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n     case REAL_TYPE:\n     case RECORD_TYPE:\n     case TEMPLATE_TYPE_PARM:\n@@ -476,6 +482,7 @@ dump_type_suffix (t, v)\n     case ERROR_MARK:\n     case IDENTIFIER_NODE:\n     case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n     case REAL_TYPE:\n     case RECORD_TYPE:\n     case TEMPLATE_TYPE_PARM:"}, {"sha": "aa59484a3059f13329a89eaff11e28e7e06b1028", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -28,6 +28,7 @@ __volatile__, TYPE_QUAL, RID_VOLATILE\n __wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n asm, ASM_KEYWORD, NORID,\n auto, SCSPEC, RID_AUTO,\n+bool, TYPESPEC, RID_BOOL,\n break, BREAK, NORID,\n case, CASE, NORID,\n catch, CATCH, NORID,\n@@ -45,6 +46,7 @@ dynamic_cast, DYNAMIC_CAST, NORID,\n else, ELSE, NORID,\n enum, ENUM, NORID,\n extern, SCSPEC, RID_EXTERN,\n+false, CXX_FALSE, NORID,\n float, TYPESPEC, RID_FLOAT,\n for, FOR, NORID,\n friend, SCSPEC, RID_FRIEND,\n@@ -76,6 +78,7 @@ switch, SWITCH, NORID,\n this, THIS, NORID,\n throw, THROW, NORID,\n template, TEMPLATE, RID_TEMPLATE,\n+true, CXX_TRUE, NORID,\n try, TRY, NORID,\n typedef, SCSPEC, RID_TYPEDEF,\n typeof, TYPEOF, NORID,"}, {"sha": "8453c4bec35548c7271560d33b369922d4064fae", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -3,12 +3,12 @@\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 83\n+#define TOTAL_KEYWORDS 86\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 170\n-/* maximum key range = 167, duplicates = 0 */\n+#define MAX_HASH_VALUE 171\n+/* maximum key range = 168, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +20,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n-     171, 171, 171, 171, 171,   0, 171,  62,   5,  65,\n-      27,   0,  18,   7,  10,  48, 171,   1,  30,   7,\n-      79,   0,  33, 171,  18,   0,   4,  26,  13,   0,\n-       1,  24, 171, 171, 171, 171, 171, 171,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n+     172, 172, 172, 172, 172,   0, 172,  36,   1,  61,\n+       0,   0,  30,  44,  44,  35, 172,   7,  12,  53,\n+      40,  17,   6, 172,  28,   2,   4,  35,  31,  51,\n+       5,   7, 172, 172, 172, 172, 172, 172,\n     };\n   register int hval = len;\n \n@@ -65,120 +65,120 @@ is_reserved_word (str, len)\n     {\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n-      {\"\",}, {\"\",}, \n+      {\"\",}, \n+      {\"delete\",  DELETE, NORID,},\n+      {\"double\",  TYPESPEC, RID_DOUBLE,},\n+      {\"true\",  CXX_TRUE, NORID,},\n       {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"typeid\",  TYPEID, NORID,},\n+      {\"\",}, \n       {\"this\",  THIS, NORID,},\n-      {\"throw\",  THROW, NORID,},\n+      {\"\",}, \n+      {\"try\",  TRY, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"do\",  DO, NORID,},\n+      {\"\",}, \n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"\",}, \n+      {\"__classof__\",  CLASSOF, NORID},\n+      {\"\",}, \n       {\"__headof__\",  HEADOF, NORID},\n-      {\"goto\",  GOTO, NORID,},\n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"\",}, \n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n       {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n       {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"\",}, \n-      {\"enum\",  ENUM, NORID,},\n-      {\"static_cast\",  STATIC_CAST, NORID,},\n-      {\"switch\",  SWITCH, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"false\",  CXX_FALSE, NORID,},\n       {\"sizeof\",  SIZEOF, NORID,},\n-      {\"\",}, \n-      {\"__headof\",  HEADOF, NORID},\n       {\"short\",  TYPESPEC, RID_SHORT,},\n       {\"typeof\",  TYPEOF, NORID,},\n-      {\"do\",  DO, NORID,},\n-      {\"\",}, \n-      {\"try\",  TRY, NORID,},\n-      {\"\",}, \n-      {\"delete\",  DELETE, NORID,},\n-      {\"__typeof__\",  TYPEOF, NORID},\n-      {\"while\",  WHILE, NORID,},\n-      {\"struct\",  AGGR, RID_RECORD,},\n-      {\"typeid\",  TYPEID, NORID,},\n-      {\"double\",  TYPESPEC, RID_DOUBLE,},\n-      {\"for\",  FOR, NORID,},\n-      {\"\",}, \n-      {\"__classof__\",  CLASSOF, NORID},\n-      {\"\",}, {\"\",}, \n-      {\"operator\",  OPERATOR, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n-      {\"\",}, \n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n       {\"\",}, \n       {\"int\",  TYPESPEC, RID_INT,},\n-      {\"\",}, \n-      {\"__classof\",  CLASSOF, NORID},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n       {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"\",}, {\"\",}, \n-      {\"headof\",  HEADOF, NORID,},\n-      {\"\",}, \n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"struct\",  AGGR, RID_RECORD,},\n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"break\",  BREAK, NORID,},\n       {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"\",}, \n+      {\"default\",  DEFAULT, NORID,},\n       {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"__classof\",  CLASSOF, NORID},\n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"__headof\",  HEADOF, NORID},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"\",}, \n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"for\",  FOR, NORID,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"__alignof__\",  ALIGNOF, NORID},\n       {\"\",}, \n-      {\"if\",  IF, NORID,},\n       {\"case\",  CASE, NORID,},\n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"if\",  IF, NORID,},\n+      {\"while\",  WHILE, NORID,},\n+      {\"\",}, \n       {\"class\",  AGGR, RID_CLASS,},\n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"break\",  BREAK, NORID,},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"const\",  TYPE_QUAL, RID_CONST,},\n       {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"new\",  NEW, NORID,},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n-      {\"\",}, {\"\",}, {\"\",}, \n+      {\"auto\",  SCSPEC, RID_AUTO,},\n       {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"throw\",  THROW, NORID,},\n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n+      {\"\",}, \n+      {\"headof\",  HEADOF, NORID,},\n+      {\"\",}, \n+      {\"goto\",  GOTO, NORID,},\n       {\"\",}, {\"\",}, \n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"overload\",  OVERLOAD, NORID,},\n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"\",}, \n+      {\"new\",  NEW, NORID,},\n+      {\"\",}, \n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"operator\",  OPERATOR, NORID,},\n       {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"__extension__\",  EXTENSION, NORID},\n       {\"\",}, {\"\",}, \n       {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"\",}, \n+      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"continue\",  CONTINUE, NORID,},\n-      {\"default\",  DEFAULT, NORID,},\n-      {\"char\",  TYPESPEC, RID_CHAR,},\n+      {\"return\",  RETURN, NORID,},\n+      {\"enum\",  ENUM, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"classof\",  CLASSOF, NORID,},\n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"union\",  AGGR, RID_UNION,},\n-      {\"\",}, \n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n-      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"overload\",  OVERLOAD, NORID,},\n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"return\",  RETURN, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n-      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n-      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"classof\",  CLASSOF, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"const_cast\",  CONST_CAST, NORID,},\n-      {\"catch\",  CATCH, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, \n-      {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"catch\",  CATCH, NORID,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "186741421c211dcfc380a687d1ae9a799109b157", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -3566,7 +3566,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n-      type = TREE_TYPE (type);\n+      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (TYPE_SIZE (type) == 0)\n \t{\n \t  incomplete_type_error (0, type);\n@@ -3582,6 +3582,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t}\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n+\n+      /* throw away const and volatile on target type of addr */\n+      addr = convert_force (build_pointer_type (type), addr);\n       ref = build_indirect_ref (addr, NULL_PTR);\n       ptr = 1;\n     }"}, {"sha": "595ba8266675040bb03497e5362dc7f327c837d8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -577,6 +577,9 @@ init_lex ()\n   ridpointers[(int) RID_INT] = get_identifier (\"int\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_INT],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_INT]));\n+  ridpointers[(int) RID_BOOL] = get_identifier (\"bool\");\n+  SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_BOOL],\n+\t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_BOOL]));\n   ridpointers[(int) RID_CHAR] = get_identifier (\"char\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_CHAR],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]));\n@@ -4442,9 +4445,9 @@ real_yylex ()\n \t\tvalue = MIN_MAX;\n \t\tnextchar = c1;\n \t      }\n-\t    if (pedantic)\n-\t      error (\"use of `operator %s' is not standard C++\",\n-\t\t     token_buffer);\n+\t    if (flag_ansi)\n+\t      pedwarn (\"use of `operator %s' is not standard C++\",\n+\t\t       token_buffer);\n \t    goto done;\n \t  }\n "}, {"sha": "a9ea60efa0a5f8360b34d733fca5f5f69d80ef2f", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -26,6 +26,7 @@ enum rid\n {\n   RID_UNUSED,\n   RID_INT,\n+  RID_BOOL,\n   RID_CHAR,\n   RID_WCHAR,\n   RID_FLOAT,"}, {"sha": "d0b847e87891ce79e3b946bb54ccdd5c21e8c334", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -366,6 +366,11 @@ build_overload_value (type, value)\n \ticat (TREE_INT_CST_LOW (value));\n \treturn;\n       }\n+    case BOOLEAN_TYPE:\n+      {\n+\ticat (TREE_INT_CST_LOW (value));\n+\treturn;\n+      }\n #ifndef REAL_IS_NOT_DOUBLE\n     case REAL_TYPE:\n       {\n@@ -587,10 +592,7 @@ build_overload_name (parmtypes, begin, end)\n \n \t    OB_PUTC ('A');\n \t    if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n-\t      {\n-\t\terror (\"parameter type with unspecified array bounds invalid\");\n-\t\ticat (1);\n-\t      }\n+\t      error (\"pointer or reference to array of unknown bound in parm type\");\n \t    else\n \t      {\n \t\tlength = array_type_nelts (parmtype);\n@@ -701,6 +703,10 @@ build_overload_name (parmtypes, begin, end)\n \t    my_friendly_abort (73);\n \t  break;\n \n+\tcase BOOLEAN_TYPE:\n+\t  OB_PUTC ('b');\n+\t  break;\n+\n \tcase REAL_TYPE:\n \t  parmtype = TYPE_MAIN_VARIANT (parmtype);\n \t  if (parmtype == long_double_type_node)\n@@ -1703,7 +1709,7 @@ emit_thunk (thunk_fndecl)\n   int delta = THUNK_DELTA (thunk_fndecl);\n   int tem;\n   int failure = 0;\n-  extern int current_call_is_indirect; /* Needed for (at least) HPPA. */\n+  int current_call_is_indirect = 0;\t/* needed for HPPA FUNCTION_ARG */\n \n   /* Used to remember which regs we need to emit a USE rtx for. */\n   rtx need_use[FIRST_PSEUDO_REGISTER];"}, {"sha": "30e076c657926a03b9baa67c45e7d0222e923f16", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 83, "deletions": 166, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -149,7 +149,7 @@ empty_parms ()\n /* the reserved words... C++ extensions */\n %token <ttype> AGGR\n %token <itype> VISSPEC\n-%token DELETE NEW OVERLOAD THIS OPERATOR\n+%token DELETE NEW OVERLOAD THIS OPERATOR CXX_TRUE CXX_FALSE\n %token LEFT_RIGHT TEMPLATE\n %token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST\n %token <itype> SCOPE\n@@ -197,14 +197,15 @@ empty_parms ()\n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n %type <ttype> paren_expr_or_null nontrivial_exprlist\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n-%type <ttype> typed_declspecs reserved_declspecs\n+%type <ttype> typed_declspecs reserved_declspecs boolean.literal\n %type <ttype> typed_typespecs reserved_typespecquals\n %type <ttype> declmods typespec typespecqual_reserved\n %type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n %type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n %type <ttype> init initlist maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n-%type <ttype> maybe_attribute attribute_list attrib\n+%type <ttype> maybe_attribute attributes attribute attribute_list attrib\n+%type <ttype> any_word\n \n %type <ttype> compstmt implicitly_scoped_stmt\n \n@@ -284,7 +285,6 @@ static tree current_aggr;\n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n extern void yyprint ();\n extern tree combine_strings\t\tPROTO((tree));\n-extern tree truthvalue_conversion\tPROTO((tree));\n %}\n \f\n %%\n@@ -320,8 +320,7 @@ extdefs:\n \t;\n \n asm_keyword:\n-\tASM_KEYWORD { if (pedantic)\n-\t\t      pedwarn (\"ANSI C++ forbids use of `asm' keyword\"); }\n+\t  ASM_KEYWORD\n \t| GCC_ASM_KEYWORD\n \t;\n \n@@ -551,15 +550,6 @@ datadef:\n \t\t    else if (CLASSTYPE_USE_TEMPLATE (t) == 1)\n \t\t      error (\"override declaration for already-expanded template\");\n \t\t  }\n-\t\telse if (TREE_CODE (t) == ENUMERAL_TYPE\n-\t\t\t && !TYPE_SIZE (t))\n-\t\t  cp_error (\"forward declaration of `%#T'\", t);\n-\t\telse if (TREE_CODE (t) == IDENTIFIER_NODE)\n-\t\t  {\n-\t\t    tree v = lookup_name (t, 1);\n-\t\t    cp_error (\"abstract declarator `%T' used as declaration\",\n-\t\t\t      v);\n-\t\t  }\n \t      }\n \t    note_list_got_semicolon ($<ttype>$);\n \t  }\n@@ -1098,7 +1088,7 @@ new_initializer:\n \t   syntactically valid but semantically invalid.  */\n \t| '=' init\n \t\t{\n-\t\t  if (pedantic || flag_ansi)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n \t\t  $$ = $2;\n \t\t}\n@@ -1125,7 +1115,7 @@ cast_expr:\n \t\t{ \n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\tnreverse ($3)); \n-\t\t  if (pedantic)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n \t\t  /* Indicate that this was a GNU C constructor expression.  */\n \t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n@@ -1279,6 +1269,7 @@ primary:\n \t\t    $$ = do_identifier ($$);\n \t\t}\t\t\n \t| CONSTANT\n+\t| boolean.literal\n \t| string\n \t\t{ $$ = combine_strings ($$); }\n \t| '(' expr ')'\n@@ -1295,7 +1286,7 @@ primary:\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n \t\t{ tree rtl_exp;\n-\t\t  if (pedantic)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  rtl_exp = expand_end_stmt_expr ($<ttype>2);\n \t\t  /* The statements have side effects, so the group does.  */\n@@ -1576,7 +1567,7 @@ primary_no_id:\n \t\t    }\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n-\t\t{ if (pedantic)\n+\t\t{ if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  $$ = expand_end_stmt_expr ($<ttype>2); }\n \t| primary_no_id '(' nonnull_exprlist ')'\n@@ -1611,6 +1602,13 @@ delete:\t  DELETE\n \t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n+boolean.literal:\n+\t  CXX_TRUE\n+\t\t{ $$ = true_node; }\n+\t| CXX_FALSE\n+\t\t{ $$ = false_node; }\n+\t;\n+\n /* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n string:\n \t  STRING\n@@ -1802,11 +1800,11 @@ typespec: structsp\n \t| complete_type_name\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3);\n-\t\t  if (pedantic)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| TYPEOF '(' type_id ')'\n \t\t{ $$ = groktypename ($3);\n-\t\t  if (pedantic)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n@@ -1912,9 +1910,9 @@ initdcl:\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_decl ($<ttype>6, $7, $3, 0); }\n \t| declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ tree d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n+\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4);\n-\t\t  finish_decl (d, NULL_TREE, $3, 0); }\n+\t\t  finish_decl ($<ttype>$, NULL_TREE, $3, 0); }\n \t;\n \n notype_initdcl0:\n@@ -1958,64 +1956,53 @@ nomods_initdcl0:\n /* the * rules are dummies to accept the Apollo extended syntax\n    so that the header files compile. */\n maybe_attribute:\n+      /* empty */\n+  \t\t{ $$ = NULL_TREE; }\n+\t| attributes\n+\t\t{ $$ = $1; }\n+\t;\n+ \n+attributes:\n+      attribute\n+\t\t{ $$ = $1; }\n+\t| attributes attribute\n+\t\t{ $$ = chainon ($1, $2); }\n+\t;\n+\n+attribute:\n+      ATTRIBUTE '(' '(' attribute_list ')' ')'\n+\t\t{ $$ = $4; }\n+\t;\n+\n+attribute_list:\n+      attrib\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| attribute_list ',' attrib\n+\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+ \n+attrib:\n     /* empty */\n-\t{ $$ = NULL_TREE; }\n-    | maybe_attribute ATTRIBUTE '(' '(' attribute_list ')' ')'\n-\t{ $$ = chainon ($5, $1); }\n-    ;\n-\n-attribute_list\n-    : attrib\n-\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-    | attribute_list ',' attrib\n-\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n-    ;\n-\n-attrib\n-    : identifier\n-\t{ if (strcmp (IDENTIFIER_POINTER ($1), \"packed\")\n-\t      && strcmp (IDENTIFIER_POINTER ($1), \"noreturn\"))\n-\t    warning (\"`%s' attribute directive ignored\",\n-\t\t     IDENTIFIER_POINTER ($1));\n-\t  $$ = $1; }\n-    | TYPE_QUAL\n-    | identifier '(' expr_no_commas ')'\n-\t{ /* If not aligned(n), section(name), or mode(name),\n-\t     then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"section\") == 0\n-\t      || strcmp (IDENTIFIER_POINTER ($1), \"mode\") == 0)\n-\t    {\n-\t      if (TREE_CODE ($3) != STRING_CST)\n-\t\t{\n-\t\t  error (\"invalid argument in `%s' attribute\",\n-\t\t\t IDENTIFIER_POINTER ($1));\n-\t\t  $$ = $1;\n-\t\t}\n-\t      $$ = tree_cons ($1, $3, NULL_TREE);\n-\t    }\n-\t  else if (strcmp (IDENTIFIER_POINTER ($1), \"aligned\") != 0)\n-\t    {\n-\t      warning (\"`%s' attribute directive ignored\",\n-\t\t       IDENTIFIER_POINTER ($1));\n-\t      $$ = $1;\n-\t    }\n-\t  else\n-\t    $$ = tree_cons ($1, $3, NULL_TREE); }\n-    | identifier '(' IDENTIFIER ',' expr_no_commas ',' expr_no_commas ')'\n-\t{ /* if not \"format(...)\", then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"format\") != 0)\n-\t    {\n-\t      warning (\"`%s' attribute directive ignored\",\n-\t\t       IDENTIFIER_POINTER ($1));\n-\t      $$ = $1;\n-\t    }\n-\t  else\n-\t    $$ = tree_cons ($1,\n-\t\t\t    tree_cons ($3,\n-\t\t\t\t       tree_cons ($5, $7, NULL_TREE),\n-\t\t\t\t       NULL_TREE),\n-\t\t\t    NULL_TREE); }\n-    ;\n+\t\t{ $$ = NULL_TREE; }\n+\t| any_word\n+\t\t{ $$ = $1; }\n+\t| any_word '(' IDENTIFIER ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, build_tree_list (NULL_TREE, $3)); }\n+\t| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, tree_cons (NULL_TREE, $3, $5)); }\n+\t| any_word '(' nonnull_exprlist ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, $3); }\n+\t;\n+\n+/* This still leaves out most reserved keywords,\n+   shouldn't we include them?  */\n+\n+any_word:\n+\t  identifier\n+\t| SCSPEC\n+\t| TYPESPEC\n+\t| TYPE_QUAL\n+\t;\n \n /* A nonempty list of identifiers, including typenames.  */\n identifiers_or_typenames:\n@@ -2663,7 +2650,7 @@ new_type_id:\n \t   non-constant dimension.  */\n \t| '(' type_id ')' '[' expr ']'\n \t\t{\n-\t\t  if (pedantic || flag_ansi)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n \t\t  $$ = build_parse_node (ARRAY_REF, TREE_VALUE ($2), $5);\n \t\t  $$ = build_decl_list (TREE_PURPOSE ($2), $$);\n@@ -3003,7 +2990,7 @@ errstmt:  error ';'\n maybe_label_decls:\n \t  /* empty */\n \t| label_decls\n-\t\t{ if (pedantic)\n+\t\t{ if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids label declarations\"); }\n \t;\n \n@@ -3040,6 +3027,10 @@ compstmt: '{' .pushlevel '}'\n \t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n \t\t  $$ = poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary (); }\n+\t| '{' .pushlevel maybe_label_decls stmts error '}'\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n+\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n+\t\t  pop_momentary (); }\n \t| '{' .pushlevel maybe_label_decls error '}'\n \t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n@@ -3051,15 +3042,15 @@ simple_if:\n \t\t{ cond_stmt_keyword = \"if\"; }\n \t  .pushlevel paren_cond_or_null\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_start_cond (truthvalue_conversion ($4), 0); }\n+\t\t  expand_start_cond (bool_truthvalue_conversion ($4), 0); }\n \t  implicitly_scoped_stmt\n \t;\n \n implicitly_scoped_stmt:\n \t  compstmt\n \t\t{ finish_stmt (); }\n \t| .pushlevel simple_stmt\n-\t\t{ expand_end_bindings (getdecls (), getdecls() != NULL_TREE, 1);\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  $$ = poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary (); }\n \t;\n@@ -3106,7 +3097,7 @@ simple_stmt:\n \t\t  expand_start_loop (1);\n \t\t  cond_stmt_keyword = \"while\"; }\n \t  .pushlevel paren_cond_or_null\n-\t\t{ expand_exit_loop_if_false (0, truthvalue_conversion ($4)); }\n+\t\t{ expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n \t  already_scoped_stmt\n \t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n@@ -3122,7 +3113,7 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"do\"; }\n \t  paren_expr_or_null ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (0, truthvalue_conversion ($6));\n+\t\t  expand_exit_loop_if_false (0, bool_truthvalue_conversion ($6));\n \t\t  expand_end_loop ();\n \t\t  clear_momentary ();\n \t\t  finish_stmt (); }\n@@ -3133,7 +3124,7 @@ simple_stmt:\n \t\t  expand_start_loop_continue_elsewhere (1); }\n \t  .pushlevel xcond ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, truthvalue_conversion ($4)); }\n+\t\t  if ($4) expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n \t  xexpr ')'\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n@@ -3154,7 +3145,7 @@ simple_stmt:\n \t\t  expand_start_loop_continue_elsewhere (1); }\n \t  .pushlevel xcond ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, truthvalue_conversion ($4)); }\n+\t\t  if ($4) expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n \t  xexpr ')'\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n@@ -3185,36 +3176,10 @@ simple_stmt:\n \t\t  pop_momentary ();\n \t\t  finish_stmt (); }\n \t| CASE expr_no_commas ':'\n-\t\t{ register tree value = $2;\n+\t\t{ register tree value = check_cp_case_value ($2);\n \t\t  register tree label\n \t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-\t\t  /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t     Strip such NOP_EXPRs.  */\n-\t\t  if (TREE_CODE (value) == NOP_EXPR\n-\t\t      && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n-\t\t    value = TREE_OPERAND (value, 0);\n-\n-\t\t  if (TREE_READONLY_DECL_P (value))\n-\t\t    {\n-\t\t      value = decl_constant_value (value);\n-\t\t      /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t\t Strip such NOP_EXPRs.  */\n-\t\t      if (TREE_CODE (value) == NOP_EXPR\n-\t\t\t  && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n-\t\t\tvalue = TREE_OPERAND (value, 0);\n-\t\t    }\n-\t\t  value = fold (value);\n-\n-\t\t  if (TREE_CODE (value) != INTEGER_CST\n-\t\t      && value != error_mark_node)\n-\t\t    {\n-\t\t      cp_error (\"case label `%E' does not reduce to an integer constant\", $2);\n-\t\t      value = error_mark_node;\n-\t\t    }\n-\t\t  else\n-\t\t    /* Promote char or short to int.  */\n-\t\t    value = default_conversion (value);\n \t\t  if (value != error_mark_node)\n \t\t    {\n \t\t      tree duplicate;\n@@ -3236,61 +3201,13 @@ simple_stmt:\n \t\t}\n \t  stmt\n \t| CASE expr_no_commas RANGE expr_no_commas ':'\n-\t\t{ register tree value1 = $2;\n-\t\t  register tree value2 = $4;\n+\t\t{ register tree value1 = check_cp_case_value ($2);\n+\t\t  register tree value2 = check_cp_case_value ($4);\n \t\t  register tree label\n \t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-\t\t  if (pedantic)\n+\t\t  if (flag_ansi)\n \t\t    pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n-\n-\t\t  /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t     Strip such NOP_EXPRs.  */\n-\t\t  if (TREE_CODE (value1) == NOP_EXPR\n-\t\t      && TREE_TYPE (value1) == TREE_TYPE (TREE_OPERAND (value1, 0)))\n-\t\t    value1 = TREE_OPERAND (value1, 0);\n-\n-\t\t  if (TREE_READONLY_DECL_P (value1))\n-\t\t    {\n-\t\t      value1 = decl_constant_value (value1);\n-\t\t      /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t\t Strip such NOP_EXPRs.  */\n-\t\t      if (TREE_CODE (value1) == NOP_EXPR\n-\t\t\t  && TREE_TYPE (value1) == TREE_TYPE (TREE_OPERAND (value1, 0)))\n-\t\t\tvalue1 = TREE_OPERAND (value1, 0);\n-\t\t    }\n-\t\t  value1 = fold (value1);\n-\n-\t\t  /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t     Strip such NOP_EXPRs.  */\n-\t\t  if (TREE_CODE (value2) == NOP_EXPR\n-\t\t      && TREE_TYPE (value2) == TREE_TYPE (TREE_OPERAND (value2, 0)))\n-\t\t    value2 = TREE_OPERAND (value2, 0);\n-\n-\t\t  if (TREE_READONLY_DECL_P (value2))\n-\t\t    {\n-\t\t      value2 = decl_constant_value (value2);\n-\t\t      /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t\t\t Strip such NOP_EXPRs.  */\n-\t\t      if (TREE_CODE (value2) == NOP_EXPR\n-\t\t\t  && TREE_TYPE (value2) == TREE_TYPE (TREE_OPERAND (value2, 0)))\n-\t\t\tvalue2 = TREE_OPERAND (value2, 0);\n-\t\t    }\n-\t\t  value2 = fold (value2);\n-\n-\n-\t\t  if (TREE_CODE (value1) != INTEGER_CST\n-\t\t      && value1 != error_mark_node)\n-\t\t    {\n-\t\t      error (\"case label does not reduce to an integer constant\");\n-\t\t      value1 = error_mark_node;\n-\t\t    }\n-\t\t  if (TREE_CODE (value2) != INTEGER_CST\n-\t\t      && value2 != error_mark_node)\n-\t\t    {\n-\t\t      error (\"case label does not reduce to an integer constant\");\n-\t\t      value2 = error_mark_node;\n-\t\t    }\n \t\t  if (value1 != error_mark_node\n \t\t      && value2 != error_mark_node)\n \t\t    {"}, {"sha": "997941c5a02521be0320c164eb77a242edc38ace", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -782,6 +782,7 @@ uses_template_parms (t)\n     case REAL_TYPE:\n     case VOID_TYPE:\n     case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n       return 0;\n \n       /* constants */\n@@ -1142,6 +1143,7 @@ tsubst (t, args, nargs, in_decl)\n     case VOID_TYPE:\n     case REAL_TYPE:\n     case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n@@ -1351,6 +1353,11 @@ tsubst (t, args, nargs, in_decl)\n \t\t\t\t\t   DECL_CONTEXT (t) != NULL_TREE);\n \t\t  r = build_lang_decl (FUNCTION_DECL, r, type);\n \t\t}\n+\t      else if (DECL_INLINE (r) && DECL_SAVED_INSNS (r))\n+\t\t{\n+\t\t  /* This overrides the template version, use it. */\n+\t\t  return r;\n+\t\t}\n \t    }\n \t  }\n \tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n@@ -1638,8 +1645,10 @@ instantiate_template (tmpl, targ_ptr)\n       DECL_ARGUMENTS (fndecl) = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n     }\n      \n+  /* If we have a preexisting version of this function, don't expand\n+     the template version, use the other instead.  */\n   t = DECL_TEMPLATE_INFO (tmpl);\n-  if (t->text)\n+  if (t->text && !(DECL_INLINE (fndecl) && DECL_SAVED_INSNS (fndecl)))\n     {\n       p = (struct pending_inline *) permalloc (sizeof (struct pending_inline));\n       p->parm_vec = t->parm_vec;"}, {"sha": "ea7de8f9f6f37c352e36e1afe065fd472133b232", "filename": "gcc/cp/search.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -2426,7 +2426,7 @@ dfs_init_vbase_pointers (binfo)\n \n   this_vbase_ptr = vbase_decl_ptr_intermediate;\n \n-  if (TYPE_POINTER_TO (type) != TREE_TYPE (this_vbase_ptr))\n+  if (TYPE_POINTER_TO (type) != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n     my_friendly_abort (125);\n \n   while (fields && DECL_NAME (fields)\n@@ -2525,9 +2525,30 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t  if (use_computed_offsets)\n \t    addr = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbases));\n \t  else\n-\t    addr = convert_pointer_to_real (vbases, vbase_decl_ptr);\n-\t  if (addr == error_mark_node)\n-\t    continue;\n+\t    {\n+\t      tree vbinfo = get_binfo (TREE_TYPE (vbases),\n+\t\t\t\t       TREE_TYPE (vbase_decl),\n+\t\t\t\t       0);\n+\n+\t      /* See is we can get lucky.  */\n+\t      if (TREE_VIA_VIRTUAL (vbinfo))\n+\t\taddr = convert_pointer_to_real (vbinfo, vbase_decl_ptr);\n+\t      else\n+\t\t{\n+\t\t  /* We go through all these contortions to avoid this\n+\t\t     call, as it will fail when the virtual base type\n+\t\t     is ambiguous from here.  We don't yet have a way\n+\t\t     to search for and find just an instance of the\n+\t\t     virtual base class.  Searching for the binfo in\n+\t\t     vbases won't work, as we don't have the vbase\n+\t\t     pointer field, for all vbases in the main class,\n+\t\t     only direct vbases.  */\n+\t\t  addr = convert_pointer_to_real (TREE_TYPE (vbases),\n+\t\t\t\t\t\t  vbase_decl_ptr);\n+\t\t  if (addr == error_mark_node)\n+\t\t    continue;\n+\t\t}\n+\t    }\n \n \t  /* Do all vtables from this virtual base. */\n \t  /* This assumes that virtual bases can never serve as parent\n@@ -2877,12 +2898,16 @@ dfs_pushdecls (binfo)\n \t\t{\n \t\t  /* Only complain if we shadow something we can access.  */\n \t\t  if (old\n+\t\t      && warn_shadow\n \t\t      && ((DECL_LANG_SPECIFIC (old)\n \t\t\t   && DECL_CLASS_CONTEXT (old) == current_class_type)\n \t\t\t  || ! TREE_PRIVATE (old)))\n \t\t    /* Should figure out access control more accurately.  */\n-\t\t    cp_warning (\"shadowing member `%#D' with member function `%#D'\",\n-\t\t\t\told, *methods);\n+\t\t    {\n+\t\t      cp_warning_at (\"member `%#D' is shadowed\", old);\n+\t\t      cp_warning_at (\"by member function `%#D'\", *methods);\n+\t\t      warning (\"in this context\");\n+\t\t    }\n \t\t  tmp = build_tree_list (DECL_NAME (*methods), *methods);\n \t\t}\n \t      pop_obstacks ();"}, {"sha": "b4712a6ac4d6e1816563bc22ddd91496be79ecce", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -94,6 +94,9 @@ lvalue_p (ref)\n \t  return (lvalue_p (TREE_OPERAND (ref, 1))\n \t\t  && lvalue_p (TREE_OPERAND (ref, 2)));\n \n+\tcase MODIFY_EXPR:\n+\t  return 1;\n+\n \tcase COMPOUND_EXPR:\n \t  return lvalue_p (TREE_OPERAND (ref, 1));\n \t}\n@@ -111,7 +114,7 @@ lvalue_or_else (ref, string)\n {\n   int win = lvalue_p (ref);\n   if (! win)\n-    error (\"invalid lvalue in %s\", string);\n+    error (\"non-lvalue in %s\", string);\n   return win;\n }\n \n@@ -305,13 +308,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n   else\n     {\n       ptype = build_pointer_type (basetype);\n-#if 0\n-      /* it is wrong to flag the object the pointer points to as readonly\n-\t when flag_this_is_variable is 0. */\n-      ptype = build_type_variant (ptype, flag_this_is_variable <= 0, 0);\n-#else\n-      ptype = build_type_variant (ptype, 0, 0);\n-#endif\n+      ptype = build_type_variant (ptype, 1, 0);\n     }\n   /* The actual arglist for this function includes a \"hidden\" argument\n      which is \"this\".  Put it into the list of argument types.  */"}, {"sha": "f2b375bf40f9fbbf7ae8a21297754ab3d0811758", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 229, "deletions": 147, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -47,7 +47,6 @@ static tree pointer_int_sum ();\n static tree pointer_diff ();\n static tree convert_sequence ();\n /* static */ tree unary_complex_lvalue ();\n-tree truthvalue_conversion ();\n \n extern rtx original_result_rtx;\n \n@@ -258,6 +257,7 @@ common_type (t1, t2)\n {\n   register enum tree_code code1;\n   register enum tree_code code2;\n+  tree attributes;\n \n   /* Save time if the two types are the same.  */\n \n@@ -269,6 +269,40 @@ common_type (t1, t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n+  /* Merge the attributes */\n+\n+  { register tree a1, a2;\n+    a1 = TYPE_ATTRIBUTES (t1);\n+    a2 = TYPE_ATTRIBUTES (t2);\n+\n+    /* Either one unset?  Take the set one.  */\n+\n+    if (!(attributes = a1))\n+       attributes = a2;\n+\n+    /* One that completely contains the other?  Take it.  */\n+\n+    else if (a2 && !attribute_list_contained (a1, a2))\n+       if (attribute_list_contained (a2, a1))\n+\t  attributes = a2;\n+       else\n+\t{\n+\t  /* Pick the longest list, and hang on the other\n+\t     list.  */\n+\t\n+\t  if (list_length (a1) < list_length (a2))\n+\t     attributes = a2, a2 = a1;\n+\n+\t  for (; a2; a2 = TREE_CHAIN (a2))\n+\t     if (!value_member (attributes, a2))\n+\t      {\n+\t\ta1 = copy_node (a2);\n+\t\tTREE_CHAIN (a1) = attributes;\n+\t\tattributes = a1;\n+\t      }\n+\t}\n+  }\n+\n   /* Treat an enum type as the unsigned integer type of the same width.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n@@ -286,39 +320,43 @@ common_type (t1, t2)\n       /* If only one is real, use it as the result.  */\n \n       if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n-\treturn t1;\n+\treturn build_type_attribute_variant (t1, attributes);\n \n       if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n-\treturn t2;\n+        return build_type_attribute_variant (t2, attributes);\n \n       /* Both real or both integers; use the one with greater precision.  */\n \n       if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n-\treturn t1;\n+\treturn build_type_attribute_variant (t1, attributes);\n       else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n-\treturn t2;\n+        return build_type_attribute_variant (t2, attributes);\n \n       /* Same precision.  Prefer longs to ints even when same size.  */\n-\n+  \n       if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n-\treturn long_unsigned_type_node;\n+        return build_type_attribute_variant (long_unsigned_type_node,\n+\t\t\t\t\t     attributes);\n \n       if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n \t{\n \t  /* But preserve unsignedness from the other type,\n \t     since long cannot hold all the values of an unsigned int.  */\n \t  if (TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n-\t    return long_unsigned_type_node;\n-\t  return long_integer_type_node;\n+\t     t1 = long_unsigned_type_node;\n+\t  else\n+\t     t1 = long_integer_type_node;\n+\t  return build_type_attribute_variant (t1, attributes);\n \t}\n \n       /* Otherwise prefer the unsigned one.  */\n \n       if (TREE_UNSIGNED (t1))\n-\treturn t1;\n-      else return t2;\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn build_type_attribute_variant (t2, attributes);\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -336,28 +374,32 @@ common_type (t1, t2)\n \t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n \ttarget = build_type_variant (target, constp, volatilep);\n \tif (code1 == POINTER_TYPE)\n-\t  return build_pointer_type (target);\n+\t  t1 = build_pointer_type (target);\n \telse\n-\t  return build_reference_type (target);\n+\t  t1 = build_reference_type (target);\n+\treturn build_type_attribute_variant (t1, attributes);\n       }\n #if 0\n     case POINTER_TYPE:\n-      return build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      return build_type_attribute_variant (t1, attributes);\n \n     case REFERENCE_TYPE:\n-      return build_reference_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      t1 = build_reference_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      return build_type_attribute_variant (t1, attributes);\n #endif\n \n     case ARRAY_TYPE:\n       {\n \ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n-\t  return t1;\n+\t  return build_type_attribute_variant (t1, attributes);\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2))\n-\t  return t2;\n+\t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n-\treturn build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tt1 = build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\treturn build_type_attribute_variant (t1, attributes);\n       }\n \n     case FUNCTION_TYPE:\n@@ -371,40 +413,40 @@ common_type (t1, t2)\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (valtype == TREE_TYPE (t1) && ! p2)\n-\t  return t1;\n+\t  return build_type_attribute_variant (t1, attributes);\n \tif (valtype == TREE_TYPE (t2) && ! p1)\n-\t  return t2;\n+\t  return build_type_attribute_variant (t2, attributes);\n \n \t/* Simple way if one arg fails to specify argument types.  */\n \tif (p1 == NULL_TREE || TREE_VALUE (p1) == void_type_node)\n \t  {\n \t    rval = build_function_type (valtype, p2);\n \t    if ((raises = TYPE_RAISES_EXCEPTIONS (t2)))\n \t      rval = build_exception_variant (NULL_TREE, rval, raises);\n-\t    return rval;\n+\t    return build_type_attribute_variant (rval, attributes);\n \t  }\n \traises = TYPE_RAISES_EXCEPTIONS (t1);\n \tif (p2 == NULL_TREE || TREE_VALUE (p2) == void_type_node)\n \t  {\n \t    rval = build_function_type (valtype, p1);\n \t    if (raises)\n \t      rval = build_exception_variant (NULL_TREE, rval, raises);\n-\t    return rval;\n+\t    return build_type_attribute_variant (rval, attributes);\n \t  }\n \n \trval = build_function_type (valtype, commonparms (p1, p2));\n-\treturn build_exception_variant (NULL_TREE, rval, raises);\n+\trval = build_exception_variant (NULL_TREE, rval, raises);\n+\treturn build_type_attribute_variant (rval, attributes);\n       }\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n       my_friendly_assert (TYPE_MAIN_VARIANT (t1) == t1\n \t\t\t  && TYPE_MAIN_VARIANT (t2) == t2, 306);\n \n-      if (binfo_or_else (t1, t2))\n-\treturn t1;\n-      compiler_error (\"common_type called with uncommon aggregate types\");\n-      return t1;\n+      if (! binfo_or_else (t1, t2))\n+         compiler_error (\"common_type called with uncommon aggregate types\");\n+      return build_type_attribute_variant (t1, attributes);\n \n     case METHOD_TYPE:\n       if (comptypes (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2), 1)\n@@ -424,24 +466,28 @@ common_type (t1, t2)\n \t  t2 = build_function_type (TREE_TYPE (t2), TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n \t  t3 = common_type (t1, t2);\n \t  t3 = build_cplus_method_type (basetype, TREE_TYPE (t3), TYPE_ARG_TYPES (t3));\n-\t  return build_exception_variant (basetype, t3, raises);\n+\t  t1 = build_exception_variant (basetype, t3, raises);\n \t}\n-      compiler_error (\"common_type called with uncommon method types\");\n-      return t1;\n+      else\n+        compiler_error (\"common_type called with uncommon method types\");\n+\n+      return build_type_attribute_variant (t1, attributes);\n \n     case OFFSET_TYPE:\n       if (TYPE_OFFSET_BASETYPE (t1) == TYPE_OFFSET_BASETYPE (t2)\n \t  && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n \t{\n \t  tree basetype = TYPE_OFFSET_BASETYPE (t1);\n-\t  return build_offset_type (basetype,\n+\t  t1 = build_offset_type (basetype,\n \t\t\t\t    common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n \t}\n-      compiler_error (\"common_type called with uncommon member types\");\n-      return t1;\n+      else\n+        compiler_error (\"common_type called with uncommon member types\");\n+\n+      /* ... falls through ... */\n \n     default:\n-      return t1;\n+      return build_type_attribute_variant (t1, attributes);\n     }\n }\n \f\n@@ -514,6 +560,7 @@ comptypes (type1, type2, strict)\n {\n   register tree t1 = type1;\n   register tree t2 = type2;\n+  int attrval, val;\n \n   /* Suppress errors caused by previously reported errors */\n \n@@ -571,20 +618,30 @@ comptypes (type1, type2, strict)\n   if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return 1;\n \n+#ifdef COMP_TYPE_ATTRIBUTES\n+  if (! (attrval = COMP_TYPE_ATTRIBUTES (t1, t2)))\n+     return 0;\n+#else\n+  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n+  attrval = 1;\n+#endif\n+\n+  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n+  val = 0;\n+\n   switch (TREE_CODE (t1))\n     {\n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      if (t1 == t2)\n-\treturn 1;\n       if (strict <= 0)\n \tgoto look_hard;\n       return 0;\n \n     case OFFSET_TYPE:\n-      return (comptypes (TYPE_POINTER_TO (TYPE_OFFSET_BASETYPE (t1)),\n+      val = (comptypes (TYPE_POINTER_TO (TYPE_OFFSET_BASETYPE (t1)),\n \t\t\t TYPE_POINTER_TO (TYPE_OFFSET_BASETYPE (t2)), strict)\n \t      && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict));\n+      break;\n \n     case METHOD_TYPE:\n       if (! compexcepttypes (t1, t2, strict))\n@@ -595,17 +652,22 @@ comptypes (type1, type2, strict)\n \t to something expecting a derived member (or member function),\n \t but not vice-versa!  */\n \n-      return (comptypes (TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t2)),\n+      val = (comptypes (TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t2)),\n \t\t\t TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t1)), strict)\n \t      && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict)\n \t      && compparms (TREE_CHAIN (TYPE_ARG_TYPES (t1)),\n \t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t2)), strict));\n+      break;\n+\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       t1 = TREE_TYPE (t1);\n       t2 = TREE_TYPE (t2);\n       if (t1 == t2)\n-\treturn 1;\n+\t{\n+\t  val = 1;\n+\t  break;\n+\t}\n       if (strict <= 0)\n \t{\n \t  if (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE)\n@@ -615,34 +677,43 @@ comptypes (type1, type2, strict)\n \t      rval = t1 == t2 || UNIQUELY_DERIVED_FROM_P (t1, t2);\n \n \t      if (rval)\n-\t\treturn 1;\n+\t\t{\n+\t\t  val = 1;\n+\t\t  break;\n+\t\t}\n \t      if (strict < 0)\n-\t\treturn UNIQUELY_DERIVED_FROM_P (t2, t1);\n+\t\t{\n+\t\t  val = UNIQUELY_DERIVED_FROM_P (t2, t1);\n+\t\t  break;\n+\t\t}\n \t    }\n \t  return 0;\n \t}\n       else\n-\treturn comptypes (t1, t2, strict);\n+\tval = comptypes (t1, t2, strict);\n+      break;\n \n     case FUNCTION_TYPE:\n       if (! compexcepttypes (t1, t2, strict))\n \treturn 0;\n \n-      return ((TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t       || comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n-\t      && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2), strict));\n+      val = ((TREE_TYPE (t1) == TREE_TYPE (t2)\n+\t      || comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n+\t     && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2), strict));\n+      break;\n \n     case ARRAY_TYPE:\n       /* Target types must match incl. qualifiers.  */\n-      return comp_array_types (comptypes, t1, t2, strict);\n+      val = comp_array_types (comptypes, t1, t2, strict);\n+      break;\n \n     case TEMPLATE_TYPE_PARM:\n       return 1;\n \n     case UNINSTANTIATED_P_TYPE:\n       return UPT_TEMPLATE (t1) == UPT_TEMPLATE (t2);\n     }\n-  return 0;\n+  return attrval == 2 && val == 1 ? 2 : val;\n }\n \n /* Return 1 if TTL and TTR are pointers to types that are equivalent,\n@@ -683,7 +754,8 @@ comp_target_types (ttl, ttr, nptrs)\n \tcase 1:\n \t  return 1;\n \tcase 2:\n-\t  warning (\"contravariance violation for method types ignored\");\n+\t  cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n+\t\t      ttr, ttl);\n \t  return 1;\n \tdefault:\n \t  my_friendly_abort (112);\n@@ -702,7 +774,8 @@ comp_target_types (ttl, ttr, nptrs)\n       else if (comptypes (TYPE_OFFSET_BASETYPE (ttl), TYPE_OFFSET_BASETYPE (ttr), 0)\n \t       && comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n \t{\n-\t  warning (\"contravariance violation for member types ignored\");\n+\t  cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n+\t\t      ttr, ttl);\n \t  return 1;\n \t}\n     }\n@@ -1224,7 +1297,7 @@ default_conversion (exp)\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n \n-  if (code == ENUMERAL_TYPE || code == INTEGER_TYPE)\n+  if (INTEGRAL_CODE_P (code))\n     {\n       tree t = type_promotes_to (type);\n       if (t != TYPE_MAIN_VARIANT (type))\n@@ -2656,14 +2729,21 @@ build_binary_op (code, arg1, arg2, convert_p)\n \t  tree types[2], try;\n \t  \n \t  types[0] = type1; types[1] = type2;\n-\t  try = build_type_conversion (code, types[convert_index ^ 1],\n-\t\t\t\t       args[convert_index], 1);\n-\t  \n-\t  if (try == 0\n-\t      && args[1] == integer_zero_node\n-\t      && (code == NE_EXPR || code == EQ_EXPR))\n-\t    try = build_type_conversion (code, ptr_type_node,\n+\t  if (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n+\t    try = build_type_conversion (code, bool_type_node,\n \t\t\t\t\t args[convert_index], 1);\n+\t  else\n+\t    {\n+\t      try = build_type_conversion (code, types[convert_index ^ 1],\n+\t\t\t\t\t   args[convert_index], 1);\n+\t  \n+\t      if (try == 0\n+\t\t  && args[1] == integer_zero_node\n+\t\t  && (code == NE_EXPR || code == EQ_EXPR))\n+\t\ttry = build_type_conversion (code, ptr_type_node,\n+\t\t\t\t\t     args[convert_index], 1);\n+\t    }\n+\n \t  if (try == 0)\n \t    {\n \t      cp_error (\"no match for `%O(%#T, %#T)'\", code,\n@@ -2875,17 +2955,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == POINTER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == POINTER_TYPE || code1 == REAL_TYPE))\n-\t{\n-\t  /* Result of these operations is always an int,\n-\t     but that does not mean the operands should be\n-\t     converted to ints!  */\n-\t  result_type = integer_type_node;\n-\t  op0 = truthvalue_conversion (op0);\n-\t  op1 = truthvalue_conversion (op1);\n-\t  converted = 1;\n-\t}\n+      result_type = bool_type_node;\n+      op0 = bool_truthvalue_conversion (op0);\n+      op1 = bool_truthvalue_conversion (op1);\n+      converted = 1;\n       break;\n \n       /* Shift operations: result has same type as first operand;\n@@ -2966,9 +3039,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      /* Result of comparison is always int,\n-\t but don't convert the args to int!  */\n-      result_type = integer_type_node;\n+      result_type = bool_type_node;\n       converted = 1;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n@@ -2984,10 +3055,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    {\n \t      tree base = common_base_type (tt0, tt1);\n \t      if (base == NULL_TREE)\n-\t\twarning (\"comparison of distinct object pointer types\");\n+\t\tcp_warning (\"comparison of distinct object pointer types `%T' and `%T'\", type0, type1);\n \t      else if (base == error_mark_node)\n \t\t{\n-\t\t  message_2_types (error, \"comparison of pointer types `%s*' and `%s*' requires conversion to ambiguous supertype\", tt0, tt1);\n+\t\t  cp_error (\"comparison of pointer types `%T' and `%T' requires conversion to ambiguous supertype\", type0, type1);\n \t\t  return error_mark_node;\n \t\t}\n \t      else\n@@ -3017,9 +3088,13 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else if ((TYPE_SIZE (tt0) != 0) != (TYPE_SIZE (tt1) != 0))\n-\t    pedwarn (\"comparison of complete and incomplete pointers\");\n+\t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers `%T' and `%T'\",\n+\t\t\tTYPE_SIZE (tt0) == 0 ? \"in\" : \"\",\n+\t\t\tTYPE_SIZE (tt1) == 0 ? \"in\" : \"\",\n+\t\t\ttype0, type1);\n \t  else\n-\t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t\ttype0, type1);\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n@@ -3137,10 +3212,14 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  if (! comp_target_types (type0, type1, 1))\n-\t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t\ttype0, type1);\n \t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n \t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n-\t    pedwarn (\"comparison of complete and incomplete pointers\");\n+\t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n+\t\t\tTYPE_SIZE (TREE_TYPE (type0)) == 0 ? \"in\" : \"\",\n+\t\t\tTYPE_SIZE (TREE_TYPE (type1)) == 0 ? \"in\" : \"\",\n+\t\t\ttype0, type1);\n \t  else if (pedantic\n \t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n@@ -3158,34 +3237,34 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  if (! comp_target_types (type0, type1, 1))\n-\t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t\ttype0, type1);\n \t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n \t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n-\t    pedwarn (\"comparison of complete and incomplete pointers\");\n+\t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n+\t\t\tTYPE_SIZE (TREE_TYPE (type0)) == 0 ? \"in\" : \"\",\n+\t\t\tTYPE_SIZE (TREE_TYPE (type1)) == 0 ? \"in\" : \"\",\n+\t\t\ttype0, type1);\n \t  else if (pedantic \n \t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n-\t  result_type = integer_type_node;\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n \t{\n-\t  result_type = integer_type_node;\n \t  op1 = null_pointer_node;\n \t  if (pedantic)\n \t    pedwarn (\"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n \t{\n-\t  result_type = integer_type_node;\n \t  op0 = null_pointer_node;\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids ordered comparison of pointer with integer zero\");\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  result_type = integer_type_node;\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t  else if (! flag_traditional)\n@@ -3194,13 +3273,13 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  result_type = integer_type_node;\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t  else if (! flag_traditional)\n \t    warning (\"comparison between pointer and integer\");\n \t  op0 = convert (TREE_TYPE (op1), op0);\n \t}\n+      result_type = bool_type_node;\n       converted = 1;\n       break;\n     }\n@@ -3332,8 +3411,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree val \n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \t  if (val != 0)\n-\t    return val;\n-\t  op0 = xop0, op1 = xop1, result_type = xresult_type;\n+\t    return convert (bool_type_node, val);\n+\t  op0 = xop0, op1 = xop1, result_type = bool_type_node;\n \t  resultcode = xresultcode;\n \t}\n \n@@ -3659,6 +3738,17 @@ build_x_unary_op (code, xarg)\n   return build_unary_op (code, xarg, 0);\n }\n \n+/* Just like truthvalue_conversion, but we want a BOOLEAN_TYPE */\n+tree\n+bool_truthvalue_conversion (expr)\n+     tree expr;\n+{\n+  /* We really want to preform the optimizations in truthvalue_conversion\n+     but, not this way. */\n+  /* expr = truthvalue_conversion (expr); */\n+  return convert (bool_type_node, expr);\n+}\n+\n /* C++: Must handle pointers to members.\n \n    Perhaps type instantiation should be extended to handle conversion\n@@ -3771,23 +3861,11 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      if (isaggrtype)\n-\t{\n-\t  arg = truthvalue_conversion (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t}\n-\n-      if (typecode != INTEGER_TYPE\n-\t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n-\t  /* These will convert to a pointer.  */\n-\t  && typecode != ARRAY_TYPE && typecode != FUNCTION_TYPE)\n-\t{\n-\t  errstring = \"wrong type argument to unary exclamation mark\";\n-\t  break;\n-\t}\n-      arg = truthvalue_conversion (arg);\n+      arg = bool_truthvalue_conversion (arg);\n       val = invert_truthvalue (arg);\n-      if (val) return val;\n+      if (arg != error_mark_node)\n+\treturn val;\n+      errstring = \"in argument to unary !\";\n       break;\n \n     case NOP_EXPR:\n@@ -4426,7 +4504,7 @@ build_conditional_expr (ifexp, op1, op2)\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n-  ifexp = truthvalue_conversion (default_conversion (ifexp));\n+  ifexp = bool_truthvalue_conversion (default_conversion (ifexp));\n \n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n@@ -4841,21 +4919,7 @@ build_c_cast (type, expr)\n \n   if (TREE_TYPE (value)\n       && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (value)))\n-    {\n-      /* For C++, we must copy the constness of TYPE into VALUE.  */\n-      if (TREE_READONLY (value) != TYPE_READONLY (type))\n-\t{\n-\t  value = copy_node (value);\n-\t  TREE_READONLY (value) = TYPE_READONLY (type);\n-\t}\n-      else if (pedantic)\n-\t{\n-\t  if (TREE_CODE (type) == RECORD_TYPE\n-\t      || TREE_CODE (type) == UNION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids casting nonscalar to the same type\");\n-\t}\n-      return value;\n-    }\n+    return build1 (NOP_EXPR, type, value);\n \n   /* If there's only one function in the overloaded space,\n      just take it.  */\n@@ -5262,12 +5326,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n     return error_mark_node;\n \n-  /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-     Strip such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n-  if (TREE_CODE (rhs) == NOP_EXPR\n-      && TREE_TYPE (rhs) == TREE_TYPE (TREE_OPERAND (rhs, 0)))\n-    rhs = TREE_OPERAND (rhs, 0);\n-\n   /* Decide early if we are going to protect RHS from GC\n      before assigning it to LHS.  */\n   if (type_needs_gc_entry (TREE_TYPE (rhs))\n@@ -5432,6 +5490,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n     }\n \n+#if 0\n   /* Handle a cast used as an \"lvalue\".\n      We have already performed any binary operator using the value as cast.\n      Now convert the result to the cast type of the lhs,\n@@ -5464,6 +5523,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \treturn convert_force (TREE_TYPE (lhs), result);\n       }\n     }\n+#endif\n \n   if (TREE_CODE (lhs) == OFFSET_REF)\n     {\n@@ -5521,16 +5581,10 @@ build_modify_expr (lhs, modifycode, rhs)\n   /* check to see if there is an assignment to `this' */\n   if (lhs == current_class_decl)\n     {\n-      if (DECL_NAME (current_function_decl) != NULL_TREE)\n-\t{\n-\t  /* ARM 18.3.3 and draft standard section C.11 say that assigning\n-\t     something to this is an anachronism.  */\n-\t  if (pedantic)\n-\t    warning (\"anachronistic assignment to `this' pointer\");\n-\t  else if (flag_this_is_variable > 0\n-\t\t   && current_class_name != DECL_NAME (current_function_decl))\n-\t    warning (\"assignment to `this' not in constructor or destructor\");\n-\t}\n+      if (flag_this_is_variable > 0\n+\t  && DECL_NAME (current_function_decl) != NULL_TREE\n+\t  && current_class_name != DECL_NAME (current_function_decl))\n+\twarning (\"assignment to `this' not in constructor or destructor\");\n       current_function_just_assigned_this = 1;\n     }\n \n@@ -6151,8 +6205,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       return error_mark_node;\n     }\n   /* Arithmetic types all interconvert.  */\n-  if ((codel == INTEGER_TYPE || codel == REAL_TYPE)\n-       && (coder == INTEGER_TYPE || coder == REAL_TYPE))\n+  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == BOOLEAN_TYPE)\n+       && (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == BOOLEAN_TYPE))\n     {\n       /* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */\n       if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n@@ -6165,7 +6219,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t}\n       /* And we should warn if assigning a negative value to\n \t an unsigned variable.  */\n-      else if (TREE_UNSIGNED (type))\n+      else if (TREE_UNSIGNED (type) && codel != BOOLEAN_TYPE)\n \t{\n \t  if (TREE_CODE (rhs) == INTEGER_CST\n \t      && TREE_NEGATED_INT (rhs))\n@@ -6268,12 +6322,14 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n \t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n \t      && rhs != null_pointer_node)\n-\t    if (coder == RECORD_TYPE)\n-\t      pedwarn (\"implicit conversion of signature pointer to type `%s'\",\n-\t\t       type_as_string (type, 0));\n-\t    else\n-\t      pedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n-\t\t       errtype);\n+\t    {\n+\t      if (coder == RECORD_TYPE)\n+\t\tpedwarn (\"implicit conversion of signature pointer to type `%s'\",\n+\t\t\t type_as_string (type, 0));\n+\t      else\n+\t\tpedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n+\t\t\t errtype);\n+\t    }\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if ((TREE_CODE (ttr) != FUNCTION_TYPE && TREE_CODE (ttr) != METHOD_TYPE)\n@@ -6286,7 +6342,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t  sorry (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n \t\t  return error_mark_node;\n \t\t}\n-\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t      else if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\t{\n \t\t  if (fndecl)\n \t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n@@ -6295,7 +6351,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n-\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\t{\n \t\t  if (fndecl)\n \t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n@@ -6304,6 +6360,16 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n+\t      else if (TREE_CODE (ttl) == TREE_CODE (ttr)\n+\t\t       && ! comp_target_types (type, rhstype, 1))\n+\t\t{\n+\t\t  if (fndecl)\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes signedness\",\n+\t\t\t\trhstype, parmnum, fndecl);\n+\t\t  else\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes signedness\",\n+\t\t\t\terrtype, type, rhstype);\n+\t\t}\n \t    }\n \t}\n       else if (TREE_CODE (ttr) == OFFSET_TYPE\n@@ -6570,8 +6636,24 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n      return here before checking if RHS is of complete type.  */\n      \n   if (codel == REFERENCE_TYPE)\n-    return convert_to_reference (type, rhs, CONV_IMPLICIT, flags,\n-\t\t\t\t exp ? exp : error_mark_node);\n+    {\n+      /* This should eventually happen in convert_arguments.  */\n+      extern int warningcount, errorcount;\n+      int savew, savee;\n+\n+      if (fndecl)\n+\tsavew = warningcount, savee = errorcount;\n+      rhs = convert_to_reference (type, rhs, CONV_IMPLICIT, flags,\n+\t\t\t\t  exp ? exp : error_mark_node);\n+      if (fndecl)\n+\t{\n+\t  if (warningcount > savew)\n+\t    cp_warning_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n+\t  else if (errorcount > savee)\n+\t    cp_error_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n+\t}\n+      return rhs;\n+    }      \n \n   rhs = require_complete_type (rhs);\n   if (rhs == error_mark_node)"}, {"sha": "baf55a41b9f170c612bef8494dfbb7baa2727efe", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2986ae008b26f29b421ee34debbc3113658d0453/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2986ae008b26f29b421ee34debbc3113658d0453", "patch": "@@ -766,6 +766,7 @@ digest_init (type, init, tail)\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n+      || code == BOOLEAN_TYPE\n       || (code == RECORD_TYPE && ! raw_constructor\n \t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))))\n     {\n@@ -951,13 +952,7 @@ process_init_constructor (type, init, elts)\n \t      continue;\n \t    }\n \n-\t  if (TREE_CODE (field) == CONST_DECL || TREE_CODE (field) == TYPE_DECL)\n-\t    continue;\n-\n-\t  /* A static member isn't considered \"part of the object\", so\n-\t     it has no business even thinking about involving itself in\n-\t     what an initializer-list is trying to do.  */\n-\t  if (TREE_CODE (field) == VAR_DECL && TREE_STATIC (field))\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \n \t  if (TREE_VALUE (tail) != 0)\n@@ -1462,16 +1457,18 @@ build_functional_cast (exp, parms)\n     }\n \n   {\n-    int flags = LOOKUP_SPECULATIVELY|LOOKUP_COMPLAIN;\n+    int flags = LOOKUP_SPECULATIVELY|LOOKUP_NORMAL;\n \n     if (parms && TREE_CHAIN (parms) == NULL_TREE)\n       flags |= LOOKUP_NO_CONVERSION;\n \n-  try_again:\n     expr_as_ctor = build_method_call (NULL_TREE, name, parms,\n \t\t\t\t      NULL_TREE, flags);\n \n-    if (expr_as_ctor && expr_as_ctor != error_mark_node)\n+    if (expr_as_ctor == error_mark_node)\n+      return error_mark_node;\n+\n+    else if (expr_as_ctor)\n       {\n \tif (expr_as_conversion && expr_as_conversion != error_mark_node)\n \t  {\n@@ -1514,18 +1511,6 @@ build_functional_cast (exp, parms)\n \treturn expr_as_ctor;\n       }\n \n-    /* If it didn't work going through constructor, try type conversion.  */\n-    if (! (flags & LOOKUP_COMPLAIN))\n-      {\n-\tif (expr_as_conversion)\n-\t  return expr_as_conversion;\n-\tif (flags & LOOKUP_NO_CONVERSION)\n-\t  {\n-\t    flags = LOOKUP_NORMAL;\n-\t    goto try_again;\n-\t  }\n-      }\n-\n     if (expr_as_conversion)\n       return expr_as_conversion;\n "}]}