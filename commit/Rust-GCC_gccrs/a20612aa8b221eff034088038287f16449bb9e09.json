{"sha": "a20612aa8b221eff034088038287f16449bb9e09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwNjEyYWE4YjIyMWVmZjAzNDA4ODAzODI4N2YxNjQ0OWJiOWUwOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-29T02:10:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-29T02:10:42Z"}, "message": "dwarf2out.c (dw_val_class_offset): New.\n\n\t* dwarf2out.c (dw_val_class_offset): New.\n\t(struct dw_ranges_struct, dw_ranges_ref): New.\n\t(ranges_table, ranges_table_allocated): New.\n\t(ranges_table_in_use, RANGES_TABLE_INCREMENT): New.\n\t(add_AT_offset, add_ranges, output_ranges): New.\n\t(print_die, output_die): Handle dw_val_class_offset.\n\t(attr_checksum, size_of_die, value_format): Likewise.\n\t(gen_lexical_block_die): Handle non-contiguous blocks.\n\t(gen_block_die): Likewise.\n\t(dwarf2out_finish): Add a DW_AT_entry_pc to the compilation unit\n\tif needed.  Dump the ranges table.\n\t* final.c (final_start_function): Remove unnecessary notes and\n\trebuild the block tree before numbering the blocks.\n\t* function.c (reorder_blocks_0): Walk the existing block tree\n\tto unmark all blocks.\n\t(reorder_blocks_1): Create block fragments when duplicate block\n\tnotes are seen.\n\t(reorder_fix_fragments): New.\n\t(reorder_blocks): Call it.\n\t* tree.h (BLOCK_FRAGMENT_ORIGIN, BLOCK_FRAGMENT_CHAIN): New.\n\nFrom-SVN: r44444", "tree": {"sha": "e6828ba8212c1bd787e1ea3b54680bdef5677a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6828ba8212c1bd787e1ea3b54680bdef5677a3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a20612aa8b221eff034088038287f16449bb9e09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20612aa8b221eff034088038287f16449bb9e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20612aa8b221eff034088038287f16449bb9e09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20612aa8b221eff034088038287f16449bb9e09/comments", "author": null, "committer": null, "parents": [{"sha": "594280a3964b64125bc6259ee2fda308dfc01d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594280a3964b64125bc6259ee2fda308dfc01d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/594280a3964b64125bc6259ee2fda308dfc01d36"}], "stats": {"total": 437, "additions": 383, "deletions": 54}, "files": [{"sha": "ef77e9e77ef20a4b4ebb941e925d06f1c82acd5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20612aa8b221eff034088038287f16449bb9e09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20612aa8b221eff034088038287f16449bb9e09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a20612aa8b221eff034088038287f16449bb9e09", "patch": "@@ -1,3 +1,26 @@\n+2001-07-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (dw_val_class_offset): New.\n+\t(struct dw_ranges_struct, dw_ranges_ref): New.\n+\t(ranges_table, ranges_table_allocated): New.\n+\t(ranges_table_in_use, RANGES_TABLE_INCREMENT): New.\n+\t(add_AT_offset, add_ranges, output_ranges): New.\n+\t(print_die, output_die): Handle dw_val_class_offset.\n+\t(attr_checksum, size_of_die, value_format): Likewise.\n+\t(gen_lexical_block_die): Handle non-contiguous blocks.\n+\t(gen_block_die): Likewise.\n+\t(dwarf2out_finish): Add a DW_AT_entry_pc to the compilation unit\n+\tif needed.  Dump the ranges table.\n+\t* final.c (final_start_function): Remove unnecessary notes and\n+\trebuild the block tree before numbering the blocks.\n+\t* function.c (reorder_blocks_0): Walk the existing block tree\n+\tto unmark all blocks.\n+\t(reorder_blocks_1): Create block fragments when duplicate block\n+\tnotes are seen.\n+\t(reorder_fix_fragments): New.\n+\t(reorder_blocks): Call it.\n+\t* tree.h (BLOCK_FRAGMENT_ORIGIN, BLOCK_FRAGMENT_CHAIN): New.\n+\n 2001-07-28  Richard Henderson  <rth@redhat.com>\n \n \t* emit-rtl.c (adjust_address): Make a copy of the memory address."}, {"sha": "0c34ab89f17a389ef5f1c7d1c14f3e1cf0e05a3a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 235, "deletions": 20, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a20612aa8b221eff034088038287f16449bb9e09", "patch": "@@ -2138,6 +2138,7 @@ typedef struct dw_loc_list_struct *dw_loc_list_ref;\n typedef enum\n {\n   dw_val_class_addr,\n+  dw_val_class_offset,\n   dw_val_class_loc,\n   dw_val_class_loc_list,\n   dw_val_class_const,\n@@ -2181,6 +2182,7 @@ typedef struct dw_val_struct\n   union\n     {\n       rtx val_addr;\n+      long unsigned val_offset;\n       dw_loc_list_ref  val_loc_list;\n       dw_loc_descr_ref val_loc;\n       long int val_int;\n@@ -3075,7 +3077,7 @@ typedef struct dw_attr_struct *dw_attr_ref;\n typedef struct dw_line_info_struct *dw_line_info_ref;\n typedef struct dw_separate_line_info_struct *dw_separate_line_info_ref;\n typedef struct pubname_struct *pubname_ref;\n-typedef dw_die_ref *arange_ref;\n+typedef struct dw_ranges_struct *dw_ranges_ref;\n \n /* Each entry in the line_info_table maintains the file and\n    line number associated with the label generated for that\n@@ -3136,6 +3138,11 @@ typedef struct pubname_struct\n }\n pubname_entry;\n \n+struct dw_ranges_struct\n+{\n+  int block_num;\n+};\n+\n /* The limbo die list structure.  */\n typedef struct limbo_die_struct\n {\n@@ -3346,9 +3353,8 @@ static unsigned pubname_table_in_use;\n    pubname_table.  */\n #define PUBNAME_TABLE_INCREMENT 64\n \n-/* A pointer to the base of a table that contains a list of publicly\n-   accessible names.  */\n-static arange_ref arange_table;\n+/* Array of dies for which we should generate .debug_arange info.  */\n+static dw_die_ref *arange_table;\n \n /* Number of elements currently allocated for arange_table.  */\n static unsigned arange_table_allocated;\n@@ -3360,6 +3366,19 @@ static unsigned arange_table_in_use;\n    arange_table.  */\n #define ARANGE_TABLE_INCREMENT 64\n \n+/* Array of dies for which we should generate .debug_ranges info.  */\n+static dw_ranges_ref ranges_table;\n+\n+/* Number of elements currently allocated for ranges_table.  */\n+static unsigned ranges_table_allocated;\n+\n+/* Number of elements in ranges_table currently in use.  */\n+static unsigned ranges_table_in_use;\n+\n+/* Size (in elements) of increments by which we may expand the\n+   ranges_table.  */\n+#define RANGES_TABLE_INCREMENT 64\n+\n /* Whether we have location lists that need outputting */\n static unsigned have_location_lists;\n \n@@ -3445,6 +3464,9 @@ static void add_AT_lbl_id\t\tPARAMS ((dw_die_ref,\n static void add_AT_lbl_offset\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t const char *));\n+static void add_AT_offset\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned long));\n static dw_attr_ref get_AT\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute));\n static const char *get_AT_low_pc\tPARAMS ((dw_die_ref));\n@@ -3508,6 +3530,8 @@ static void add_pubname\t\t\tPARAMS ((tree, dw_die_ref));\n static void output_pubnames\t\tPARAMS ((void));\n static void add_arange\t\t\tPARAMS ((tree, dw_die_ref));\n static void output_aranges\t\tPARAMS ((void));\n+static unsigned int add_ranges\t\tPARAMS ((tree));\n+static void output_ranges\t\tPARAMS ((void));\n static void output_line_info\t\tPARAMS ((void));\n static void output_file_names           PARAMS ((void));\n static dw_die_ref base_type_die\t\tPARAMS ((tree));\n@@ -3633,6 +3657,9 @@ static char *gen_internal_sym \t\tPARAMS ((const char *));\n #ifndef DEBUG_STR_SECTION\n #define DEBUG_STR_SECTION\t\".debug_str\"\n #endif\n+#ifndef DEBUG_RANGES_SECTION\n+#define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n+#endif\n \n /* Standard ELF section names for compiled code and data.  */\n #ifndef TEXT_SECTION\n@@ -3666,6 +3693,7 @@ static char *gen_internal_sym \t\tPARAMS ((const char *));\n #ifndef DEBUG_MACINFO_SECTION_LABEL\n #define DEBUG_MACINFO_SECTION_LABEL     \"Ldebug_macinfo\"\n #endif\n+\n /* Definitions of defaults for formats and names of various special\n    (artificial) labels which may be generated within this file (when the -g\n    options is used and DWARF_DEBUGGING_INFO is in effect.\n@@ -4030,6 +4058,31 @@ dwarf_attr_name (attr)\n     case DW_AT_vtable_elem_location:\n       return \"DW_AT_vtable_elem_location\";\n \n+    case DW_AT_allocated:\n+      return \"DW_AT_allocated\";\n+    case DW_AT_associated:\n+      return \"DW_AT_associated\";\n+    case DW_AT_data_location:\n+      return \"DW_AT_data_location\";\n+    case DW_AT_stride:\n+      return \"DW_AT_stride\";\n+    case DW_AT_entry_pc:\n+      return \"DW_AT_entry_pc\";\n+    case DW_AT_use_UTF8:\n+      return \"DW_AT_use_UTF8\";\n+    case DW_AT_extension:\n+      return \"DW_AT_extension\";\n+    case DW_AT_ranges:\n+      return \"DW_AT_ranges\";\n+    case DW_AT_trampoline:\n+      return \"DW_AT_trampoline\";\n+    case DW_AT_call_column:\n+      return \"DW_AT_call_column\";\n+    case DW_AT_call_file:\n+      return \"DW_AT_call_file\";\n+    case DW_AT_call_line:\n+      return \"DW_AT_call_line\";\n+\n     case DW_AT_MIPS_fde:\n       return \"DW_AT_MIPS_fde\";\n     case DW_AT_MIPS_loop_begin:\n@@ -4602,6 +4655,23 @@ add_AT_lbl_offset (die, attr_kind, label)\n   add_dwarf_attr (die, attr);\n }\n \n+/* Add an offset attribute value to a DIE.  */\n+\n+static void\n+add_AT_offset (die, attr_kind, offset)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+     register unsigned long offset;\n+{\n+  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+\n+  attr->dw_attr_next = NULL;\n+  attr->dw_attr = attr_kind;\n+  attr->dw_attr_val.val_class = dw_val_class_offset;\n+  attr->dw_attr_val.v.val_offset = offset;\n+  add_dwarf_attr (die, attr);\n+}\n+\n static inline const char *AT_lbl PARAMS ((dw_attr_ref));\n static inline const char *\n AT_lbl (a)\n@@ -5014,11 +5084,15 @@ print_die (die, outfile)\n \tcase dw_val_class_addr:\n \t  fprintf (outfile, \"address\");\n \t  break;\n+\tcase dw_val_class_offset:\n+\t  fprintf (outfile, \"offset\");\n+\t  break;\n \tcase dw_val_class_loc:\n \t  fprintf (outfile, \"location descriptor\");\n \t  break;\n \tcase dw_val_class_loc_list:\n-\t  fprintf (outfile, \"location list -> label:%s\", AT_loc_list (a)->ll_symbol);\n+\t  fprintf (outfile, \"location list -> label:%s\",\n+\t\t   AT_loc_list (a)->ll_symbol);\n \t  break;\n \tcase dw_val_class_const:\n \t  fprintf (outfile, \"%ld\", AT_int (a));\n@@ -5249,6 +5323,7 @@ attr_checksum (at, ctx)\n     case dw_val_class_str:\n       PROCESS_STRING (AT_string (at));\n       break;\n+\n     case dw_val_class_addr:\n       r = AT_addr (at);\n       switch (GET_CODE (r))\n@@ -5262,6 +5337,10 @@ attr_checksum (at, ctx)\n \t}\n       break;\n \n+    case dw_val_class_offset:\n+      PROCESS (at->dw_attr_val.v.val_offset);\n+      break;\n+\n     case dw_val_class_loc:\n       for (loc = AT_loc (at); loc; loc = loc->dw_loc_next)\n \tloc_checksum (loc, ctx);\n@@ -5275,6 +5354,7 @@ attr_checksum (at, ctx)\n     case dw_val_class_fde_ref:\n     case dw_val_class_lbl_id:\n     case dw_val_class_lbl_offset:\n+      break;\n \n     default:\n       break;\n@@ -5680,6 +5760,9 @@ size_of_die (die)\n \tcase dw_val_class_addr:\n \t  size += DWARF2_ADDR_SIZE;\n \t  break;\n+\tcase dw_val_class_offset:\n+\t  size += DWARF_OFFSET_SIZE;\n+\t  break;\n \tcase dw_val_class_loc:\n \t  {\n \t    register unsigned long lsize = size_of_locs (AT_loc (a));\n@@ -5827,6 +5910,12 @@ value_format (a)\n     {\n     case dw_val_class_addr:\n       return DW_FORM_addr;\n+    case dw_val_class_offset:\n+      if (DWARF_OFFSET_SIZE == 4)\n+\treturn DW_FORM_data4;\n+      if (DWARF_OFFSET_SIZE == 8)\n+\treturn DW_FORM_data8;\n+      abort ();\n     case dw_val_class_loc_list:\n       /* FIXME: Could be DW_FORM_data8, with a > 32 bit size\n \t .debug_loc section */\n@@ -5876,6 +5965,7 @@ value_format (a)\n       return DW_FORM_data;\n     case dw_val_class_str:\n       return DW_FORM_string;\n+\n     default:\n       abort ();\n     }\n@@ -5990,15 +6080,17 @@ add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n   *d = new_loc_list (descr, begin, end, section, 0);\n }\n \n-\n-\n /* Output the location list given to us */\n static void\n output_loc_list (list_head)\n      register dw_loc_list_ref list_head;\n {\n   register dw_loc_list_ref curr=list_head;\n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n+\n+  /* ??? This shouldn't be needed now that we've forced the\n+     compilation unit base address to zero when there is code\n+     in more than one section.  */\n   if (strcmp (curr->section, \".text\") == 0)\n     {\n       /* dw2_asm_output_data will mask off any extra bits in the ~0.  */\n@@ -6060,6 +6152,11 @@ output_die (die)\n \t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n \t  break;\n \n+\tcase dw_val_class_offset:\n+\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, a->dw_attr_val.v.val_offset,\n+\t\t\t       \"%s\", name);\n+\t  break;\n+\n \tcase dw_val_class_loc:\n \t  size = size_of_locs (AT_loc (a));\n \n@@ -6121,14 +6218,17 @@ output_die (die)\n \tcase dw_val_class_flag:\n \t  dw2_asm_output_data (1, AT_flag (a), \"%s\", name);\n \t  break;\n+\n         case dw_val_class_loc_list:\n \t  {\n \t    char *sym = AT_loc_list (a)->ll_symbol;\n \t    if (sym == 0)\n \t      abort();\n-\t    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label, name);\n+\t    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym,\n+\t\t\t\t  loc_section_label, \"%s\", name);\n \t  }\n \t  break;\n+\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n \t    {\n@@ -6330,9 +6430,8 @@ add_arange (decl, die)\n   if (arange_table_in_use == arange_table_allocated)\n     {\n       arange_table_allocated += ARANGE_TABLE_INCREMENT;\n-      arange_table\n-\t= (arange_ref) xrealloc (arange_table,\n-\t\t\t\t arange_table_allocated * sizeof (dw_die_ref));\n+      arange_table = (dw_die_ref *)\n+\txrealloc (arange_table, arange_table_allocated * sizeof (dw_die_ref));\n     }\n \n   arange_table[arange_table_in_use++] = die;\n@@ -6418,6 +6517,80 @@ output_aranges ()\n   dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n }\n \n+/* Add a new entry to .debug_ranges.  Return the offset at which it\n+   was placed.  */\n+\n+static unsigned int\n+add_ranges (block)\n+     tree block;\n+{\n+  unsigned int in_use = ranges_table_in_use;\n+\n+  if (in_use == ranges_table_allocated)\n+    {\n+      ranges_table_allocated += RANGES_TABLE_INCREMENT;\n+      ranges_table = (dw_ranges_ref)\n+\txrealloc (ranges_table, (ranges_table_allocated\n+\t\t\t\t * sizeof (struct dw_ranges_struct)));\n+    }\n+\n+  ranges_table[in_use].block_num = (block ? BLOCK_NUMBER (block) : 0);\n+  ranges_table_in_use = in_use + 1;\n+\n+  return in_use * 2 * DWARF2_ADDR_SIZE;\n+}\n+\n+static void\n+output_ranges ()\n+{\n+  register unsigned i;\n+  const char *start_fmt = \"Offset 0x%x\";\n+  const char *fmt = start_fmt;\n+\n+  for (i = 0; i < ranges_table_in_use; ++i)\n+    {\n+      int block_num = ranges_table[i].block_num;\n+\n+      if (block_num)\n+\t{\n+\t  char blabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  char elabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (blabel, BLOCK_BEGIN_LABEL, block_num);\n+\t  ASM_GENERATE_INTERNAL_LABEL (elabel, BLOCK_END_LABEL, block_num);\n+\n+\t  /* If all code is in the text section, then the compilation\n+\t     unit base address defaults to DW_AT_low_pc, which is the\n+\t     base of the text section.  */\n+\t  if (separate_line_info_table_in_use == 0)\n+\t    {\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t    text_section_label,\n+\t\t\t\t    fmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t    text_section_label, NULL);\n+\t    }\n+\t  /* Otherwise, we add a DW_AT_entry_pc attribute to force the\n+\t     compilation unit base address to zero, which allows us to\n+\t     use absolute addresses, and not worry about whether the\n+\t     target supports cross-section arithmetic.  */\n+\t  else\n+\t    {\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t   fmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel, NULL);\n+\t    }\n+\n+\t  fmt = NULL;\n+\t}\n+      else\n+\t{\n+\t  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n+\t  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n+\t  fmt = start_fmt;\n+\t}\n+    }\n+}\n \n /* Data structure containing information about input files.  */\n struct file_info\n@@ -9973,6 +10146,7 @@ gen_variable_die (decl, context_die)\n   /* ??? Loop unrolling/reorder_blocks should perhaps be rewritten to\n      copy decls and set the DECL_ABSTRACT flag on them instead of\n      sharing them.  */\n+  /* ??? Duplicated blocks have been rewritten to use .debug_ranges.  */\n   else if (old_die && TREE_STATIC (decl)\n  \t   && get_AT_flag (old_die, DW_AT_declaration) == 1)\n     {\n@@ -10084,12 +10258,30 @@ gen_lexical_block_die (stmt, context_die, depth)\n \n   if (! BLOCK_ABSTRACT (stmt))\n     {\n-      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n-\t\t\t\t   BLOCK_NUMBER (stmt));\n-      add_AT_lbl_id (stmt_die, DW_AT_low_pc, label);\n-      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL,\n-\t\t\t\t   BLOCK_NUMBER (stmt));\n-      add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n+      if (BLOCK_FRAGMENT_CHAIN (stmt))\n+\t{\n+\t  tree chain;\n+\n+\t  add_AT_offset (stmt_die, DW_AT_ranges, add_ranges (stmt));\n+\n+\t  chain = BLOCK_FRAGMENT_CHAIN (stmt);\n+\t  do\n+\t    {\n+\t      add_ranges (chain);\n+\t      chain = BLOCK_FRAGMENT_CHAIN (chain);\n+\t    }\n+\t  while (chain);\n+\t  add_ranges (NULL);\n+\t}\n+      else\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n+\t\t\t\t       BLOCK_NUMBER (stmt));\n+\t  add_AT_lbl_id (stmt_die, DW_AT_low_pc, label);\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL,\n+\t\t\t\t       BLOCK_NUMBER (stmt));\n+\t  add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n+\t}\n     }\n \n   decls_for_scope (stmt, stmt_die, depth);\n@@ -10721,11 +10913,22 @@ gen_block_die (stmt, context_die, depth)\n   register enum tree_code origin_code;\n \n   /* Ignore blocks never really used to make RTL.  */\n-\n   if (stmt == NULL_TREE || !TREE_USED (stmt)\n       || (!TREE_ASM_WRITTEN (stmt) && !BLOCK_ABSTRACT (stmt)))\n     return;\n \n+  /* If the block is one fragment of a non-contiguous block, do not\n+     process the variables, since they will have been done by the\n+     origin block.  Do process subblocks.  */\n+  if (BLOCK_FRAGMENT_ORIGIN (stmt))\n+    {\n+      tree sub;\n+\n+      for (sub= BLOCK_SUBBLOCKS (stmt); sub; sub = BLOCK_CHAIN (sub))\n+\tgen_block_die (sub, context_die, depth + 1);\n+      return;\n+    }\n+\n   /* Determine the \"ultimate origin\" of this block.  This block may be an\n      inlined instance of an inlined instance of inline function, so we have\n      to trace all of the way back through the origin chain to find out what\n@@ -11607,6 +11810,11 @@ dwarf2out_finish (input_filename)\n       add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, text_section_label);\n       add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n     }\n+  /* And if it wasn't, we need to give .debug_loc and .debug_ranges\n+     an appropriate \"base address\".  Use zero so that these addresses\n+     become absolute.  */\n+  else if (have_location_lists || ranges_table_in_use)\n+    add_AT_addr (comp_unit_die, DW_AT_entry_pc, const0_rtx);\n \n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     add_AT_lbl_offset (comp_unit_die, DW_AT_stmt_list,\n@@ -11640,7 +11848,8 @@ dwarf2out_finish (input_filename)\n       ASM_OUTPUT_SECTION (asm_out_file, DEBUG_ARANGES_SECTION);\n       output_aranges ();\n     }\n-  /* Output location list section if necessary */\n+\n+  /* Output location list section if necessary.  */\n   if (have_location_lists)\n     {\n       /* Output the location lists info. */\n@@ -11649,12 +11858,18 @@ dwarf2out_finish (input_filename)\n       have_location_lists = 0;\n     }\n \n+  /* Output ranges section if necessary.  */\n+  if (ranges_table_in_use)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_RANGES_SECTION);\n+      output_ranges ();\n+    }\n+\n   /* Have to end the primary source file. */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     { \n       ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n       dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n     }\n-  \n }\n #endif /* DWARF2_DEBUGGING_INFO */"}, {"sha": "7598c1d29be7d72f7747388118cfc4a572c1b1c5", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a20612aa8b221eff034088038287f16449bb9e09", "patch": "@@ -1597,8 +1597,9 @@ final_start_function (first, file, optimize)\n      function.  */\n   if (write_symbols)\n     {\n-      number_blocks (current_function_decl);\n       remove_unnecessary_notes ();\n+      reorder_blocks ();\n+      number_blocks (current_function_decl);\n       /* We never actually put out begin/end notes for the top-level\n \t block in the function.  But, conceptually, that block is\n \t always needed.  */"}, {"sha": "4dec34e8a789aca58eda214a4440057d4fbdf6e0", "filename": "gcc/function.c", "status": "modified", "additions": 94, "deletions": 33, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a20612aa8b221eff034088038287f16449bb9e09", "patch": "@@ -278,8 +278,9 @@ static void pad_below\t\tPARAMS ((struct args_size *, enum machine_mode,\n static rtx round_trampoline_addr PARAMS ((rtx));\n static rtx adjust_trampoline_addr PARAMS ((rtx));\n static tree *identify_blocks_1\tPARAMS ((rtx, tree *, tree *, tree *));\n-static void reorder_blocks_0\tPARAMS ((rtx));\n+static void reorder_blocks_0\tPARAMS ((tree));\n static void reorder_blocks_1\tPARAMS ((rtx, tree, varray_type *));\n+static void reorder_fix_fragments PARAMS ((tree));\n static tree blocks_nreverse\tPARAMS ((tree));\n static int all_blocks\t\tPARAMS ((tree, tree *));\n static tree *get_block_vector   PARAMS ((tree, int *));\n@@ -5819,8 +5820,11 @@ identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n   return block_vector;\n }\n \n-/* Identify BLOCKs referenced by more than one\n-   NOTE_INSN_BLOCK_{BEG,END}, and create duplicate blocks.  */\n+/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},\n+   and create duplicate blocks.  */\n+/* ??? Need an option to either create block fragments or to create\n+   abstract origin duplicates of a source block.  It really depends\n+   on what optimization has been performed.  */\n \n void\n reorder_blocks ()\n@@ -5833,47 +5837,34 @@ reorder_blocks ()\n \n   VARRAY_TREE_INIT (block_stack, 10, \"block_stack\");\n \n+  /* Reset the TREE_ASM_WRITTEN bit for all blocks.  */\n+  reorder_blocks_0 (block);\n+\n   /* Prune the old trees away, so that they don't get in the way.  */\n   BLOCK_SUBBLOCKS (block) = NULL_TREE;\n   BLOCK_CHAIN (block) = NULL_TREE;\n \n-  reorder_blocks_0 (get_insns ());\n+  /* Recreate the block tree from the note nesting.  */\n   reorder_blocks_1 (get_insns (), block, &block_stack);\n-\n   BLOCK_SUBBLOCKS (block) = blocks_nreverse (BLOCK_SUBBLOCKS (block));\n \n+  /* Remove deleted blocks from the block fragment chains.  */\n+  reorder_fix_fragments (block);\n+\n   VARRAY_FREE (block_stack);\n }\n \n-/* Helper function for reorder_blocks.  Process the insn chain beginning\n-   at INSNS.  Recurse for CALL_PLACEHOLDER insns.  */\n+/* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */\n \n static void\n-reorder_blocks_0 (insns)\n-     rtx insns;\n+reorder_blocks_0 (block)\n+     tree block;\n {\n-  rtx insn;\n-\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+  while (block)\n     {\n-      if (GET_CODE (insn) == NOTE)\n-\t{\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n-\t    {\n-\t      tree block = NOTE_BLOCK (insn);\n-\t      TREE_ASM_WRITTEN (block) = 0;\n-\t    }\n-\t}\n-      else if (GET_CODE (insn) == CALL_INSN\n-\t       && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t{\n-\t  rtx cp = PATTERN (insn);\n-\t  reorder_blocks_0 (XEXP (cp, 0));\n-\t  if (XEXP (cp, 1))\n-\t    reorder_blocks_0 (XEXP (cp, 1));\n-\t  if (XEXP (cp, 2))\n-\t    reorder_blocks_0 (XEXP (cp, 2));\n-\t}\n+      TREE_ASM_WRITTEN (block) = 0;\n+      reorder_blocks_0 (BLOCK_SUBBLOCKS (block));\n+      block = BLOCK_CHAIN (block);\n     }\n }\n \n@@ -5892,12 +5883,26 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t    {\n \t      tree block = NOTE_BLOCK (insn);\n-\t      /* If we have seen this block before, copy it.  */\n+\n+\t      /* If we have seen this block before, that means it now\n+\t\t spans multiple address regions.  Create a new fragment.  */\n \t      if (TREE_ASM_WRITTEN (block))\n \t\t{\n-\t\t  block = copy_node (block);\n-\t\t  NOTE_BLOCK (insn) = block;\n+\t\t  tree new_block = copy_node (block);\n+\t\t  tree origin;\n+\n+\t\t  origin = (BLOCK_FRAGMENT_ORIGIN (block)\n+\t\t\t    ? BLOCK_FRAGMENT_ORIGIN (block)\n+\t\t\t    : block);\n+\t\t  BLOCK_FRAGMENT_ORIGIN (new_block) = origin;\n+\t\t  BLOCK_FRAGMENT_CHAIN (new_block)\n+\t\t    = BLOCK_FRAGMENT_CHAIN (origin);\n+\t\t  BLOCK_FRAGMENT_CHAIN (origin) = new_block;\n+\n+\t\t  NOTE_BLOCK (insn) = new_block;\n+\t\t  block = new_block;\n \t\t}\n+\n \t      BLOCK_SUBBLOCKS (block) = 0;\n \t      TREE_ASM_WRITTEN (block) = 1;\n \t      BLOCK_SUPERCONTEXT (block) = current_block;\n@@ -5928,6 +5933,62 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n     }\n }\n \n+/* Rationalize BLOCK_FRAGMENT_ORIGIN.  If an origin block no longer\n+   appears in the block tree, select one of the fragments to become\n+   the new origin block.  */\n+\n+static void\n+reorder_fix_fragments (block)\n+    tree block;\n+{\n+  while (block)\n+    {\n+      tree dup_origin = BLOCK_FRAGMENT_ORIGIN (block);\n+      tree new_origin = NULL_TREE;\n+\n+      if (dup_origin)\n+\t{\n+\t  if (! TREE_ASM_WRITTEN (dup_origin))\n+\t    {\n+\t      new_origin = BLOCK_FRAGMENT_CHAIN (dup_origin);\n+\t      \n+\t      /* Find the first of the remaining fragments.  There must\n+\t\t be at least one -- the current block.  */\n+\t      while (! TREE_ASM_WRITTEN (new_origin))\n+\t\tnew_origin = BLOCK_FRAGMENT_CHAIN (new_origin);\n+\t      BLOCK_FRAGMENT_ORIGIN (new_origin) = NULL_TREE;\n+\t    }\n+\t}\n+      else if (! dup_origin)\n+\tnew_origin = block;\n+\n+      /* Re-root the rest of the fragments to the new origin.  In the\n+\t case that DUP_ORIGIN was null, that means BLOCK was the origin\n+\t of a chain of fragments and we want to remove those fragments\n+\t that didn't make it to the output.  */\n+      if (new_origin)\n+\t{\n+\t  tree *pp = &BLOCK_FRAGMENT_CHAIN (new_origin);\n+\t  tree chain = *pp;\n+\n+\t  while (chain)\n+\t    {\n+\t      if (TREE_ASM_WRITTEN (chain))\n+\t\t{\n+\t\t  BLOCK_FRAGMENT_ORIGIN (chain) = new_origin;\n+\t\t  *pp = chain;\n+\t\t  pp = &BLOCK_FRAGMENT_CHAIN (chain);\n+\t\t}\n+\t      chain = BLOCK_FRAGMENT_CHAIN (chain);\n+\t    }\n+\t  *pp = NULL_TREE;\n+\t}\n+\n+      reorder_fix_fragments (BLOCK_SUBBLOCKS (block));\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n+\n /* Reverse the order of elements in the chain T of blocks,\n    and return the new head of the chain (old last element).  */\n "}, {"sha": "efd4e6cd9532da2bf1f161fce0fb7fd152758217", "filename": "gcc/tree.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20612aa8b221eff034088038287f16449bb9e09/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a20612aa8b221eff034088038287f16449bb9e09", "patch": "@@ -848,6 +848,33 @@ struct tree_exp\n    the debugging output format in use.  */\n #define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)->block.block_num)\n \n+/* If block reordering splits a lexical block into discontiguous\n+   address ranges, we'll make a copy of the original block.\n+\n+   Note that this is logically distinct from BLOCK_ABSTRACT_ORIGIN.\n+   In that case, we have one source block that has been replicated\n+   (through inlining or unrolling) into many logical blocks, and that\n+   these logical blocks have different physical variables in them.\n+\n+   In this case, we have one logical block split into several\n+   non-contiguous address ranges.  Most debug formats can't actually\n+   represent this idea directly, so we fake it by creating multiple\n+   logical blocks with the same variables in them.  However, for those\n+   that do support non-contiguous regions, these allow the original\n+   logical block to be reconstructed, along with the set of address\n+   ranges.\n+\n+   One of the logical block fragments is arbitrarily chosen to be\n+   the ORIGIN.  The other fragments will point to the origin via\n+   BLOCK_FRAGMENT_ORIGIN; the origin itself will have this pointer\n+   be null.  The list of fragments will be chained through \n+   BLOCK_FRAGMENT_CHAIN from the origin.  */\n+\n+#define BLOCK_FRAGMENT_ORIGIN(NODE) \\\n+  (BLOCK_CHECK (NODE)->block.fragment_origin)\n+#define BLOCK_FRAGMENT_CHAIN(NODE) \\\n+  (BLOCK_CHECK (NODE)->block.fragment_chain)\n+\n struct tree_block\n {\n   struct tree_common common;\n@@ -860,6 +887,8 @@ struct tree_block\n   union tree_node *subblocks;\n   union tree_node *supercontext;\n   union tree_node *abstract_origin;\n+  union tree_node *fragment_origin;\n+  union tree_node *fragment_chain;\n };\n \f\n /* Define fields and accessors for nodes representing data types.  */"}]}