{"sha": "ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwM2E3NDQ5YmMxMzQwMzQxZjJlNTUyYmE0OTM4YTVkYThkNmZkYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-12-04T08:49:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-12-04T08:49:49Z"}, "message": "builtins.c (target_newline): Export.\n\n2014-12-04  Richard Biener  <rguenther@suse.de>\n\n\t* builtins.c (target_newline): Export.\n\t(target_percent_s_newline): Likewise.\n\t(fold_builtin_1): Do not fold printf functions here.\n\t(fold_builtin_2): Likewise.\n\t(fold_builtin_3): Likewise, do not fold strncat.\n\t(fold_builtin_strncat): Move to gimple-fold.c.\n\t(fold_builtin_printf): Likewise.\n\t* builtins.h (target_newline): Declare.\n\t(target_percent_s_newline): Likewise.\n\t* gimple-fold.c (gimple_fold_builtin_strncat): Move from\n\tbuiltins.c and gimplify.\n\t(gimple_fold_builtin_printf): Likewise.\n\t(gimple_fold_builtin): Fold strncat, printf, printf_unlocked,\n\tvprintf, printf_chk and vprintf_chk here.\n\nFrom-SVN: r218343", "tree": {"sha": "bab79632c35294405cd297e6c0e8d2b1e9be1150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bab79632c35294405cd297e6c0e8d2b1e9be1150"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0b340af16a7e6b7eca4c81b6f0ef373a38a1a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b340af16a7e6b7eca4c81b6f0ef373a38a1a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b340af16a7e6b7eca4c81b6f0ef373a38a1a7f"}], "stats": {"total": 482, "additions": 243, "deletions": 239}, "files": [{"sha": "266bbfe0d0c119bfdf09a333601f41c0514386ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "patch": "@@ -1,3 +1,20 @@\n+2014-12-04  Richard Biener  <rguenther@suse.de>\n+\n+\t* builtins.c (target_newline): Export.\n+\t(target_percent_s_newline): Likewise.\n+\t(fold_builtin_1): Do not fold printf functions here.\n+\t(fold_builtin_2): Likewise.\n+\t(fold_builtin_3): Likewise, do not fold strncat.\n+\t(fold_builtin_strncat): Move to gimple-fold.c.\n+\t(fold_builtin_printf): Likewise.\n+\t* builtins.h (target_newline): Declare.\n+\t(target_percent_s_newline): Likewise.\n+\t* gimple-fold.c (gimple_fold_builtin_strncat): Move from\n+\tbuiltins.c and gimplify.\n+\t(gimple_fold_builtin_printf): Likewise.\n+\t(gimple_fold_builtin): Fold strncat, printf, printf_unlocked,\n+\tvprintf, printf_chk and vprintf_chk here.\n+\n 2014-12-03  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config/rs6000/rs6000.md (floatsidf2_internal): Use std::swap."}, {"sha": "257d001bfbf9c1fa98dc66854e44a757528e0b86", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 239, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "patch": "@@ -200,7 +200,6 @@ static tree fold_builtin_varargs (location_t, tree, tree*, int, bool);\n static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n static tree fold_builtin_strstr (location_t, tree, tree, tree);\n static tree fold_builtin_strrchr (location_t, tree, tree, tree);\n-static tree fold_builtin_strncat (location_t, tree, tree, tree);\n static tree fold_builtin_strspn (location_t, tree, tree);\n static tree fold_builtin_strcspn (location_t, tree, tree);\n \n@@ -211,15 +210,14 @@ static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n-static tree fold_builtin_printf (location_t, tree, tree, tree, bool, enum built_in_function);\n \n-static unsigned HOST_WIDE_INT target_newline;\n+unsigned HOST_WIDE_INT target_newline;\n unsigned HOST_WIDE_INT target_percent;\n static unsigned HOST_WIDE_INT target_c;\n static unsigned HOST_WIDE_INT target_s;\n char target_percent_c[3];\n char target_percent_s[3];\n-static char target_percent_s_newline[4];\n+char target_percent_s_newline[4];\n static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n static tree do_mpfr_arg2 (tree, tree, tree,\n@@ -9892,7 +9890,7 @@ fold_builtin_0 (location_t loc, tree fndecl, bool ignore ATTRIBUTE_UNUSED)\n    function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n-fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n+fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10289,11 +10287,6 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n     case BUILT_IN_ISNAND128:\n       return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISNAN);\n \n-    case BUILT_IN_PRINTF:\n-    case BUILT_IN_PRINTF_UNLOCKED:\n-    case BUILT_IN_VPRINTF:\n-      return fold_builtin_printf (loc, fndecl, arg0, NULL_TREE, ignore, fcode);\n-\n     case BUILT_IN_FREE:\n       if (integer_zerop (arg0))\n \treturn build_empty_stmt (loc);\n@@ -10463,21 +10456,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     case BUILT_IN_OBJECT_SIZE:\n       return fold_builtin_object_size (arg0, arg1);\n \n-    case BUILT_IN_PRINTF:\n-    case BUILT_IN_PRINTF_UNLOCKED:\n-    case BUILT_IN_VPRINTF:\n-      return fold_builtin_printf (loc, fndecl, arg0, arg1, ignore, fcode);\n-\n-    case BUILT_IN_PRINTF_CHK:\n-    case BUILT_IN_VPRINTF_CHK:\n-      if (!validate_arg (arg0, INTEGER_TYPE)\n-\t  || TREE_SIDE_EFFECTS (arg0))\n-\treturn NULL_TREE;\n-      else\n-\treturn fold_builtin_printf (loc, fndecl,\n-\t\t\t\t    arg1, NULL_TREE, ignore, fcode);\n-    break;\n-\n     case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n       return fold_builtin_atomic_always_lock_free (arg0, arg1);\n \n@@ -10496,7 +10474,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n \n static tree\n fold_builtin_3 (location_t loc, tree fndecl,\n-\t\ttree arg0, tree arg1, tree arg2, bool ignore)\n+\t\ttree arg0, tree arg1, tree arg2, bool)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10517,9 +10495,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \treturn do_mpfr_remquo (arg0, arg1, arg2);\n     break;\n \n-    case BUILT_IN_STRNCAT:\n-      return fold_builtin_strncat (loc, arg0, arg1, arg2);\n-\n     case BUILT_IN_STRNCMP:\n       return fold_builtin_strncmp (loc, arg0, arg1, arg2);\n \n@@ -10530,15 +10505,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     case BUILT_IN_MEMCMP:\n       return fold_builtin_memcmp (loc, arg0, arg1, arg2);;\n \n-    case BUILT_IN_PRINTF_CHK:\n-    case BUILT_IN_VPRINTF_CHK:\n-      if (!validate_arg (arg0, INTEGER_TYPE)\n-\t  || TREE_SIDE_EFFECTS (arg0))\n-\treturn NULL_TREE;\n-      else\n-\treturn fold_builtin_printf (loc, fndecl, arg1, arg2, ignore, fcode);\n-    break;\n-\n     case BUILT_IN_EXPECT:\n       return fold_builtin_expect (loc, arg0, arg1, arg2);\n \n@@ -11118,58 +11084,6 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n     }\n }\n \n-/* Simplify a call to the strncat builtin.  DST, SRC, and LEN are the\n-   arguments to the call.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-fold_builtin_strncat (location_t loc, tree dst, tree src, tree len)\n-{\n-  if (!validate_arg (dst, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE)\n-      || !validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-  else\n-    {\n-      const char *p = c_getstr (src);\n-\n-      /* If the requested length is zero, or the src parameter string\n-\t length is zero, return the dst parameter.  */\n-      if (integer_zerop (len) || (p && *p == '\\0'))\n-\treturn omit_two_operands_loc (loc, TREE_TYPE (dst), dst, src, len);\n-\n-      /* If the requested len is greater than or equal to the string\n-\t length, call strcat.  */\n-      if (TREE_CODE (len) == INTEGER_CST && p\n-\t  && compare_tree_int (len, strlen (p)) >= 0)\n-\t{\n-\t  tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n-\n-\t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation.  */\n-\t  if (!fn)\n-\t    return NULL_TREE;\n-\n-\t  return build_call_expr_loc (loc, fn, 2, dst, src);\n-\t}\n-      return NULL_TREE;\n-    }\n-}\n-\n /* Simplify a call to the strspn builtin.  S1 and S2 are the arguments\n    to the call.\n \n@@ -11771,155 +11685,6 @@ fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs,\n   return NULL_TREE;\n }\n \n-/* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.\n-   FMT and ARG are the arguments to the call; we don't fold cases with\n-   more than 2 arguments, and ARG may be null if this is a 1-argument case.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.  FCODE is the BUILT_IN_*\n-   code of the function to be simplified.  */\n-\n-static tree\n-fold_builtin_printf (location_t loc, tree fndecl, tree fmt,\n-\t\t     tree arg, bool ignore,\n-\t\t     enum built_in_function fcode)\n-{\n-  tree fn_putchar, fn_puts, newarg, call = NULL_TREE;\n-  const char *fmt_str = NULL;\n-\n-  /* If the return value is used, don't do the transformation.  */\n-  if (! ignore)\n-    return NULL_TREE;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (!validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  /* Check whether the format is a literal string constant.  */\n-  fmt_str = c_getstr (fmt);\n-  if (fmt_str == NULL)\n-    return NULL_TREE;\n-\n-  if (fcode == BUILT_IN_PRINTF_UNLOCKED)\n-    {\n-      /* If we're using an unlocked function, assume the other\n-\t unlocked functions exist explicitly.  */\n-      fn_putchar = builtin_decl_explicit (BUILT_IN_PUTCHAR_UNLOCKED);\n-      fn_puts = builtin_decl_explicit (BUILT_IN_PUTS_UNLOCKED);\n-    }\n-  else\n-    {\n-      fn_putchar = builtin_decl_implicit (BUILT_IN_PUTCHAR);\n-      fn_puts = builtin_decl_implicit (BUILT_IN_PUTS);\n-    }\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  if (strcmp (fmt_str, target_percent_s) == 0\n-      || strchr (fmt_str, target_percent) == NULL)\n-    {\n-      const char *str;\n-\n-      if (strcmp (fmt_str, target_percent_s) == 0)\n-\t{\n-\t  if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n-\t    return NULL_TREE;\n-\n-\t  if (!arg || !validate_arg (arg, POINTER_TYPE))\n-\t    return NULL_TREE;\n-\n-\t  str = c_getstr (arg);\n-\t  if (str == NULL)\n-\t    return NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* The format specifier doesn't contain any '%' characters.  */\n-\t  if (fcode != BUILT_IN_VPRINTF && fcode != BUILT_IN_VPRINTF_CHK\n-\t      && arg)\n-\t    return NULL_TREE;\n-\t  str = fmt_str;\n-\t}\n-\n-      /* If the string was \"\", printf does nothing.  */\n-      if (str[0] == '\\0')\n-\treturn build_int_cst (TREE_TYPE (TREE_TYPE (fndecl)), 0);\n-\n-      /* If the string has length of 1, call putchar.  */\n-      if (str[1] == '\\0')\n-\t{\n-\t  /* Given printf(\"c\"), (where c is any one character,)\n-\t     convert \"c\"[0] to an int and pass that to the replacement\n-\t     function.  */\n-\t  newarg = build_int_cst (integer_type_node, str[0]);\n-\t  if (fn_putchar)\n-\t    call = build_call_expr_loc (loc, fn_putchar, 1, newarg);\n-\t}\n-      else\n-\t{\n-\t  /* If the string was \"string\\n\", call puts(\"string\").  */\n-\t  size_t len = strlen (str);\n-\t  if ((unsigned char)str[len - 1] == target_newline\n-\t      && (size_t) (int) len == len\n-\t      && (int) len > 0)\n-\t    {\n-\t      char *newstr;\n-\t      tree offset_node, string_cst;\n-\n-\t      /* Create a NUL-terminated string that's one char shorter\n-\t\t than the original, stripping off the trailing '\\n'.  */\n-\t      newarg = build_string_literal (len, str);\n-\t      string_cst = string_constant (newarg, &offset_node);\n-\t      gcc_checking_assert (string_cst\n-\t\t\t\t   && (TREE_STRING_LENGTH (string_cst)\n-\t\t\t\t       == (int) len)\n-\t\t\t\t   && integer_zerop (offset_node)\n-\t\t\t\t   && (unsigned char)\n-\t\t\t\t      TREE_STRING_POINTER (string_cst)[len - 1]\n-\t\t\t\t      == target_newline);\n-\t      /* build_string_literal creates a new STRING_CST,\n-\t\t modify it in place to avoid double copying.  */\n-\t      newstr = CONST_CAST (char *, TREE_STRING_POINTER (string_cst));\n-\t      newstr[len - 1] = '\\0';\n-\t      if (fn_puts)\n-\t\tcall = build_call_expr_loc (loc, fn_puts, 1, newarg);\n-\t    }\n-\t  else\n-\t    /* We'd like to arrange to call fputs(string,stdout) here,\n-\t       but we need stdout and don't have a way to get it yet.  */\n-\t    return NULL_TREE;\n-\t}\n-    }\n-\n-  /* The other optimizations can be done only on the non-va_list variants.  */\n-  else if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n-    return NULL_TREE;\n-\n-  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg).  */\n-  else if (strcmp (fmt_str, target_percent_s_newline) == 0)\n-    {\n-      if (!arg || !validate_arg (arg, POINTER_TYPE))\n-\treturn NULL_TREE;\n-      if (fn_puts)\n-\tcall = build_call_expr_loc (loc, fn_puts, 1, arg);\n-    }\n-\n-  /* If the format specifier was \"%c\", call __builtin_putchar(arg).  */\n-  else if (strcmp (fmt_str, target_percent_c) == 0)\n-    {\n-      if (!arg || !validate_arg (arg, INTEGER_TYPE))\n-\treturn NULL_TREE;\n-      if (fn_putchar)\n-\tcall = build_call_expr_loc (loc, fn_putchar, 1, arg);\n-    }\n-\n-  if (!call)\n-    return NULL_TREE;\n-\n-  return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)), call);\n-}\n-\n /* Initialize format string characters in the target charset.  */\n \n bool"}, {"sha": "661397c3f2d8e13f9b81ea0c00cf1b9380fc9797", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "patch": "@@ -89,8 +89,10 @@ extern bool is_inexpensive_builtin (tree);\n extern bool readonly_data_expr (tree exp);\n extern const char *c_getstr (tree);\n extern bool init_target_chars (void);\n+extern unsigned HOST_WIDE_INT target_newline;\n extern unsigned HOST_WIDE_INT target_percent;\n extern char target_percent_s[3];\n extern char target_percent_c[3];\n+extern char target_percent_s_newline[4];\n \n #endif"}, {"sha": "d6ba2b266ef4c493852a6da70f6edc5f2767df24", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad03a7449bc1340341f2e552ba4938a5da8d6fdc/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ad03a7449bc1340341f2e552ba4938a5da8d6fdc", "patch": "@@ -1628,6 +1628,46 @@ gimple_fold_builtin_strcat_chk (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+/* Simplify a call to the strncat builtin.  */\n+\n+static bool\n+gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  tree dst = gimple_call_arg (stmt, 0);\n+  tree src = gimple_call_arg (stmt, 1);\n+  tree len = gimple_call_arg (stmt, 2);\n+\n+  const char *p = c_getstr (src);\n+\n+  /* If the requested length is zero, or the src parameter string\n+     length is zero, return the dst parameter.  */\n+  if (integer_zerop (len) || (p && *p == '\\0'))\n+    {\n+      replace_call_with_value (gsi, dst);\n+      return true;\n+    }\n+\n+  /* If the requested len is greater than or equal to the string\n+     length, call strcat.  */\n+  if (TREE_CODE (len) == INTEGER_CST && p\n+      && compare_tree_int (len, strlen (p)) >= 0)\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n+\n+      /* If the replacement _DECL isn't initialized, don't do the\n+\t transformation.  */\n+      if (!fn)\n+\treturn false;\n+\n+      gcall *repl = gimple_build_call (fn, 2, dst, src);\n+      replace_call_with_call_and_fold (gsi, repl);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Fold a call to the __strncat_chk builtin with arguments DEST, SRC,\n    LEN, and SIZE.  */\n \n@@ -2554,6 +2594,168 @@ gimple_fold_builtin_fprintf (gimple_stmt_iterator *gsi,\n   return false;\n }\n \n+/* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.\n+   FMT and ARG are the arguments to the call; we don't fold cases with\n+   more than 2 arguments, and ARG may be null if this is a 1-argument case.\n+\n+   Return NULL_TREE if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.  FCODE is the BUILT_IN_*\n+   code of the function to be simplified.  */\n+\n+static bool\n+gimple_fold_builtin_printf (gimple_stmt_iterator *gsi, tree fmt,\n+\t\t\t    tree arg, enum built_in_function fcode)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  tree fn_putchar, fn_puts, newarg;\n+  const char *fmt_str = NULL;\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (gimple_call_lhs (stmt) != NULL_TREE)\n+    return false;\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return false;\n+\n+  if (fcode == BUILT_IN_PRINTF_UNLOCKED)\n+    {\n+      /* If we're using an unlocked function, assume the other\n+\t unlocked functions exist explicitly.  */\n+      fn_putchar = builtin_decl_explicit (BUILT_IN_PUTCHAR_UNLOCKED);\n+      fn_puts = builtin_decl_explicit (BUILT_IN_PUTS_UNLOCKED);\n+    }\n+  else\n+    {\n+      fn_putchar = builtin_decl_implicit (BUILT_IN_PUTCHAR);\n+      fn_puts = builtin_decl_implicit (BUILT_IN_PUTS);\n+    }\n+\n+  if (!init_target_chars ())\n+    return false;\n+\n+  if (strcmp (fmt_str, target_percent_s) == 0\n+      || strchr (fmt_str, target_percent) == NULL)\n+    {\n+      const char *str;\n+\n+      if (strcmp (fmt_str, target_percent_s) == 0)\n+\t{\n+\t  if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n+\t    return false;\n+\n+\t  if (!arg || ! POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t    return false;\n+\n+\t  str = c_getstr (arg);\n+\t  if (str == NULL)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  /* The format specifier doesn't contain any '%' characters.  */\n+\t  if (fcode != BUILT_IN_VPRINTF && fcode != BUILT_IN_VPRINTF_CHK\n+\t      && arg)\n+\t    return false;\n+\t  str = fmt_str;\n+\t}\n+\n+      /* If the string was \"\", printf does nothing.  */\n+      if (str[0] == '\\0')\n+\t{\n+\t  replace_call_with_value (gsi, NULL_TREE);\n+\t  return true;\n+\t}\n+\n+      /* If the string has length of 1, call putchar.  */\n+      if (str[1] == '\\0')\n+\t{\n+\t  /* Given printf(\"c\"), (where c is any one character,)\n+\t     convert \"c\"[0] to an int and pass that to the replacement\n+\t     function.  */\n+\t  newarg = build_int_cst (integer_type_node, str[0]);\n+\t  if (fn_putchar)\n+\t    {\n+\t      gcall *repl = gimple_build_call (fn_putchar, 1, newarg);\n+\t      replace_call_with_call_and_fold (gsi, repl);\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* If the string was \"string\\n\", call puts(\"string\").  */\n+\t  size_t len = strlen (str);\n+\t  if ((unsigned char)str[len - 1] == target_newline\n+\t      && (size_t) (int) len == len\n+\t      && (int) len > 0)\n+\t    {\n+\t      char *newstr;\n+\t      tree offset_node, string_cst;\n+\n+\t      /* Create a NUL-terminated string that's one char shorter\n+\t\t than the original, stripping off the trailing '\\n'.  */\n+\t      newarg = build_string_literal (len, str);\n+\t      string_cst = string_constant (newarg, &offset_node);\n+\t      gcc_checking_assert (string_cst\n+\t\t\t\t   && (TREE_STRING_LENGTH (string_cst)\n+\t\t\t\t       == (int) len)\n+\t\t\t\t   && integer_zerop (offset_node)\n+\t\t\t\t   && (unsigned char)\n+\t\t\t\t      TREE_STRING_POINTER (string_cst)[len - 1]\n+\t\t\t\t      == target_newline);\n+\t      /* build_string_literal creates a new STRING_CST,\n+\t\t modify it in place to avoid double copying.  */\n+\t      newstr = CONST_CAST (char *, TREE_STRING_POINTER (string_cst));\n+\t      newstr[len - 1] = '\\0';\n+\t      if (fn_puts)\n+\t\t{\n+\t\t  gcall *repl = gimple_build_call (fn_puts, 1, newarg);\n+\t\t  replace_call_with_call_and_fold (gsi, repl);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* We'd like to arrange to call fputs(string,stdout) here,\n+\t       but we need stdout and don't have a way to get it yet.  */\n+\t    return false;\n+\t}\n+    }\n+\n+  /* The other optimizations can be done only on the non-va_list variants.  */\n+  else if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n+    return false;\n+\n+  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg).  */\n+  else if (strcmp (fmt_str, target_percent_s_newline) == 0)\n+    {\n+      if (!arg || ! POINTER_TYPE_P (TREE_TYPE (arg)))\n+\treturn false;\n+      if (fn_puts)\n+\t{\n+\t  gcall *repl = gimple_build_call (fn_puts, 1, arg);\n+\t  replace_call_with_call_and_fold (gsi, repl);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* If the format specifier was \"%c\", call __builtin_putchar(arg).  */\n+  else if (strcmp (fmt_str, target_percent_c) == 0)\n+    {\n+      if (!arg || ! useless_type_conversion_p (integer_type_node,\n+\t\t\t\t\t       TREE_TYPE (arg)))\n+\treturn false;\n+      if (fn_putchar)\n+\t{\n+\t  gcall *repl = gimple_build_call (fn_putchar, 1, arg);\n+\t  replace_call_with_call_and_fold (gsi, repl);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n \n \n /* Fold a call to __builtin_strlen with known length LEN.  */\n@@ -2629,6 +2831,8 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_STRCAT:\n       return gimple_fold_builtin_strcat (gsi, gimple_call_arg (stmt, 0),\n \t\t\t\t\t gimple_call_arg (stmt, 1));\n+    case BUILT_IN_STRNCAT:\n+      return gimple_fold_builtin_strncat (gsi);\n     case BUILT_IN_FPUTS:\n       return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n \t\t\t\t\tgimple_call_arg (stmt, 1), false);\n@@ -2690,6 +2894,22 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t\t\t\t\t    : NULL_TREE,\n \t\t\t\t\t    fcode);\n       break;\n+    case BUILT_IN_PRINTF:\n+    case BUILT_IN_PRINTF_UNLOCKED:\n+    case BUILT_IN_VPRINTF:\n+      if (n == 1 || n == 2)\n+\treturn gimple_fold_builtin_printf (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t   n == 2\n+\t\t\t\t\t   ? gimple_call_arg (stmt, 1)\n+\t\t\t\t\t   : NULL_TREE, fcode);\n+      break;\n+    case BUILT_IN_PRINTF_CHK:\n+    case BUILT_IN_VPRINTF_CHK:\n+      if (n == 2 || n == 3)\n+\treturn gimple_fold_builtin_printf (gsi, gimple_call_arg (stmt, 1),\n+\t\t\t\t\t   n == 3\n+\t\t\t\t\t   ? gimple_call_arg (stmt, 2)\n+\t\t\t\t\t   : NULL_TREE, fcode);\n     default:;\n     }\n "}]}