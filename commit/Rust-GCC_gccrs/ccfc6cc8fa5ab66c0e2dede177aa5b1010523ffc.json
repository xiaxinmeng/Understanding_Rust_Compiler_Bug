{"sha": "ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NmYzZjYzhmYTVhYjY2YzBlMmRlZGUxNzdhYTViMTAxMDUyM2ZmYw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-08-14T10:04:51Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-08-14T10:04:51Z"}, "message": "reload.c (find_reloads): Handle constraint letters marked by EXTRA_ADDRESS_CONSTRAINT and...\n\n\t* reload.c (find_reloads): Handle constraint letters marked by\n\tEXTRA_ADDRESS_CONSTRAINT and EXTRA_MEMORY_CONSTRAINT.\n\t(alternative_allows_memconst): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\t* recog.c (asm_operand_ok, preprocess_constraints,\n\tconstrain_operands): Likewise.\n\t* regclass.c (record_operand_costs, record_reg_classes): Likewise.\n\t* local-alloc.c (block_alloc, requires_inout): Likewise.\n\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n\n\t* defaults.h (EXTRA_MEMORY_CONSTRAINT): Provide a default.\n\t(EXTRA_ADDRESS_CONSTRAINT): Likewise.\n\t* doc/tm.texi: Document these two new target macros.\n\n\t* config/s390/s390.c (s390_expand_plus_operand): Accept already\n\tvalid operands.\n\t(q_constraint): New function.\n\tconfig/s390/s390-protos.h (q_constraint): Declare it.\n\tconfig/s390/s390.h (EXTRA_CONSTRAINT): Use it.\n\t(EXTRA_MEMORY_CONSTRAINT): New macro.\n\n\t* config/s390/s390.md: Throughout the machine description,\n\treplace all instances of the constraint combinations 'Qo'\n\tor 'oQ' with simply 'Q'.\n\nFrom-SVN: r56291", "tree": {"sha": "f8955f2da7788407bd35a092c0a414ccd029de11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8955f2da7788407bd35a092c0a414ccd029de11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/comments", "author": null, "committer": null, "parents": [{"sha": "72c41e5adc70750cee23e185d6cbadb3950a5b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c41e5adc70750cee23e185d6cbadb3950a5b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c41e5adc70750cee23e185d6cbadb3950a5b2d"}], "stats": {"total": 442, "additions": 340, "deletions": 102}, "files": [{"sha": "d7348981e523c1acfeee938ec1159c2850851a05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1,3 +1,30 @@\n+2002-08-14  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads): Handle constraint letters marked by \n+\tEXTRA_ADDRESS_CONSTRAINT and EXTRA_MEMORY_CONSTRAINT.\n+\t(alternative_allows_memconst): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t* recog.c (asm_operand_ok, preprocess_constraints, \n+\tconstrain_operands): Likewise.\n+\t* regclass.c (record_operand_costs, record_reg_classes): Likewise.\n+\t* local-alloc.c (block_alloc, requires_inout): Likewise.\n+\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n+\n+\t* defaults.h (EXTRA_MEMORY_CONSTRAINT): Provide a default.\n+\t(EXTRA_ADDRESS_CONSTRAINT): Likewise.\n+\t* doc/tm.texi: Document these two new target macros.\n+\n+\t* config/s390/s390.c (s390_expand_plus_operand): Accept already\n+\tvalid operands.\n+\t(q_constraint): New function.\n+\tconfig/s390/s390-protos.h (q_constraint): Declare it.\n+\tconfig/s390/s390.h (EXTRA_CONSTRAINT): Use it.\n+\t(EXTRA_MEMORY_CONSTRAINT): New macro.\n+\n+\t* config/s390/s390.md: Throughout the machine description,\n+\treplace all instances of the constraint combinations 'Qo'\n+\tor 'oQ' with simply 'Q'.\n+\n 2002-08-14  Stephane Carrez  <stcarrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.h (LINK_SPEC): Support -mrelax."}, {"sha": "38c5c0b20353439dbee0cdd839ea88d55b7eb915", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -31,6 +31,7 @@ extern void s390_emit_epilogue PARAMS ((void));\n extern void s390_function_profiler PARAMS ((FILE *, int));\n \n #ifdef RTX_CODE\n+extern int q_constraint PARAMS ((rtx));\n extern int const0_operand PARAMS ((rtx, enum machine_mode));\n extern int consttable_operand PARAMS ((rtx, enum machine_mode));\n extern int larl_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "6a29b764f007b744f06cc855313dc9e62e7614f8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -995,6 +995,28 @@ s_imm_operand (op, mode)\n   return general_s_operand (op, mode, 1);\n }\n \n+/* Return true if OP is a valid operand for a 'Q' constraint.\n+   This differs from s_operand in that only memory operands\n+   without index register are accepted, nothing else.  */\n+\n+int\n+q_constraint (op)\n+     register rtx op;\n+{\n+  struct s390_address addr;\n+\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (!s390_decompose_address (XEXP (op, 0), &addr, FALSE))\n+    return 0;\n+\n+  if (addr.indx)\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Return true if OP is a valid operand for the BRAS instruction.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n@@ -1386,6 +1408,15 @@ s390_expand_plus_operand (target, src, scratch_in)\n   sum1 = find_replacement (&XEXP (src, 0));\n   sum2 = find_replacement (&XEXP (src, 1));\n \n+  /* Accept already valid addresses.  */\n+  src = gen_rtx_PLUS (Pmode, sum1, sum2);\n+  if (s390_decompose_address (src, NULL, 1))\n+    {\n+      src = legitimize_la_operand (src);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, src));\n+      return;\n+    }\n+\n   /* If one of the two operands is equal to the target,\n      make it the first one.  If one is a constant, make\n      it the second one.  */"}, {"sha": "c5ba4270d37f29248c85bdab0527f62548081272", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -533,9 +533,11 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled clas\n /* 'Q' means a memory-reference for a S-type operand.  */\n \n #define EXTRA_CONSTRAINT(OP, C)                               \t\\\n-     ((C) == 'Q' ?  s_operand (OP, GET_MODE (OP)) : \t\t\\\n+     ((C) == 'Q' ?  q_constraint (OP) : \t\t\t\\\n       (C) == 'S' ?  larl_operand (OP, GET_MODE (OP)) : 0)\n \n+#define EXTRA_MEMORY_CONSTRAINT(C) ((C) == 'Q')\n+\n /* Given an rtx X being reloaded into a reg required to be in class CLASS,\n    return the class of reg to actually use.  In general this is just CLASS;\n    but on some machines in some cases it is preferable to use a more"}, {"sha": "f8ddc2f82aa5c30aa1001b3545aa87da4d140310", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -278,7 +278,7 @@\n \n (define_insn \"*tmqi_ext\"\n   [(set (reg 33)\n-        (compare (zero_extract:SI (match_operand:QI 0 \"s_operand\" \"Qo\")\n+        (compare (zero_extract:SI (match_operand:QI 0 \"s_operand\" \"Q\")\n \t                          (match_operand:SI 1 \"const_int_operand\" \"n\")\n                                   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n                  (const_int 0)))]\n@@ -345,7 +345,7 @@\n \n (define_insn \"*tmdi_mem\"\n   [(set (reg 33)\n-        (compare (and:DI (match_operand:DI 0 \"s_operand\" \"%Qo\")\n+        (compare (and:DI (match_operand:DI 0 \"s_operand\" \"%Q\")\n                          (match_operand:DI 1 \"immediate_operand\" \"n\"))\n                  (match_operand:DI 2 \"immediate_operand\" \"n\")))]\n   \"TARGET_64BIT\n@@ -365,7 +365,7 @@\n \n (define_insn \"*tmsi_mem\"\n   [(set (reg 33)\n-        (compare (and:SI (match_operand:SI 0 \"s_operand\" \"%Qo\")\n+        (compare (and:SI (match_operand:SI 0 \"s_operand\" \"%Q\")\n                          (match_operand:SI 1 \"immediate_operand\" \"n\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n@@ -384,7 +384,7 @@\n \n (define_insn \"*tmhi_mem\"\n   [(set (reg 33)\n-        (compare (and:SI (subreg:SI (match_operand:HI 0 \"s_operand\" \"%Qo\") 0)\n+        (compare (and:SI (subreg:SI (match_operand:HI 0 \"s_operand\" \"%Q\") 0)\n                          (match_operand:SI 1 \"immediate_operand\" \"n\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n@@ -403,7 +403,7 @@\n \n (define_insn \"*tmqi_mem\"\n   [(set (reg 33)\n-        (compare (and:SI (subreg:SI (match_operand:QI 0 \"s_operand\" \"%Qo\") 0)\n+        (compare (and:SI (subreg:SI (match_operand:QI 0 \"s_operand\" \"%Q\") 0)\n                          (match_operand:SI 1 \"immediate_operand\" \"n\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\"\n@@ -502,7 +502,7 @@\n \n (define_insn \"*tsthi\"\n   [(set (reg 33)\n-        (compare (match_operand:HI 0 \"s_operand\" \"Qo\")\n+        (compare (match_operand:HI 0 \"s_operand\" \"Q\")\n                  (match_operand:HI 1 \"const0_operand\" \"\")))\n    (set (match_operand:HI 2 \"register_operand\" \"=d\")\n         (match_dup 0))]\n@@ -513,7 +513,7 @@\n \n (define_insn \"*tsthi_cconly\"\n   [(set (reg 33)\n-        (compare (match_operand:HI 0 \"s_operand\" \"Qo\")\n+        (compare (match_operand:HI 0 \"s_operand\" \"Q\")\n                  (match_operand:HI 1 \"const0_operand\" \"\")))\n    (clobber (match_scratch:HI 2 \"=d\"))]\n   \"s390_match_ccmode(insn, CCSmode)\"\n@@ -523,7 +523,7 @@\n \n (define_insn \"*tstqi\"\n   [(set (reg 33)\n-        (compare (match_operand:QI 0 \"s_operand\" \"Qo\")\n+        (compare (match_operand:QI 0 \"s_operand\" \"Q\")\n                  (match_operand:QI 1 \"const0_operand\" \"\")))\n    (set (match_operand:QI 2 \"register_operand\" \"=d\")\n         (match_dup 0))]\n@@ -534,7 +534,7 @@\n \n (define_insn \"*tstqi_cconly\"\n   [(set (reg 33)\n-        (compare (match_operand:QI 0 \"s_operand\" \"Qo\")\n+        (compare (match_operand:QI 0 \"s_operand\" \"Q\")\n                  (match_operand:QI 1 \"const0_operand\" \"\")))\n    (clobber (match_scratch:QI 2 \"=d\"))]\n   \"s390_match_ccmode(insn, CCSmode)\"\n@@ -628,7 +628,7 @@\n (define_insn \"*cmphi_ccu\"\n   [(set (reg 33)\n         (compare (match_operand:HI 0 \"register_operand\" \"d\")\n-                 (match_operand:HI 1 \"s_imm_operand\" \"Qo\")))]\n+                 (match_operand:HI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clm\\\\t%0,3,%1\"\n   [(set_attr \"op_type\" \"RS\")\n@@ -637,15 +637,15 @@\n (define_insn \"*cmpqi_ccu\"\n   [(set (reg 33)\n         (compare (match_operand:QI 0 \"register_operand\" \"d\")\n-                 (match_operand:QI 1 \"s_imm_operand\" \"Qo\")))]\n+                 (match_operand:QI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clm\\\\t%0,1,%1\"\n   [(set_attr \"op_type\" \"RS\")\n    (set_attr \"atype\"   \"mem\")])\n \n (define_insn \"*cli\"\n   [(set (reg 33)\n-        (compare (match_operand:QI 0 \"s_operand\" \"Qo\")\n+        (compare (match_operand:QI 0 \"s_operand\" \"Q\")\n                  (match_operand:QI 1 \"immediate_operand\" \"n\")))]\n   \"s390_match_ccmode (insn, CCUmode)\"\n   \"cli\\\\t%0,%b1\"\n@@ -654,35 +654,35 @@\n \n (define_insn \"*cmpdi_ccu_mem\"\n   [(set (reg 33)\n-        (compare (match_operand:DI 0 \"s_operand\" \"oQ\")\n-                 (match_operand:DI 1 \"s_imm_operand\" \"oQ\")))]\n+        (compare (match_operand:DI 0 \"s_operand\" \"Q\")\n+                 (match_operand:DI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clc\\\\t%O0(8,%R0),%1\"\n   [(set_attr \"op_type\" \"SS\")\n    (set_attr \"atype\"   \"mem\")])\n \n (define_insn \"*cmpsi_ccu_mem\"\n   [(set (reg 33)\n-        (compare (match_operand:SI 0 \"s_operand\" \"oQ\")\n-                 (match_operand:SI 1 \"s_imm_operand\" \"oQ\")))]\n+        (compare (match_operand:SI 0 \"s_operand\" \"Q\")\n+                 (match_operand:SI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clc\\\\t%O0(4,%R0),%1\"\n    [(set_attr \"op_type\" \"SS\")\n     (set_attr \"atype\"   \"mem\")])\n \n (define_insn \"*cmphi_ccu_mem\"\n   [(set (reg 33)\n-        (compare (match_operand:HI 0 \"s_operand\" \"oQ\")\n-                 (match_operand:HI 1 \"s_imm_operand\" \"oQ\")))]\n+        (compare (match_operand:HI 0 \"s_operand\" \"Q\")\n+                 (match_operand:HI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clc\\\\t%O0(2,%R0),%1\"\n   [(set_attr \"op_type\" \"SS\")\n    (set_attr \"atype\"   \"mem\")])\n \n (define_insn \"*cmpqi_ccu_mem\"\n   [(set (reg 33)\n-        (compare (match_operand:QI 0 \"s_operand\" \"oQ\")\n-                 (match_operand:QI 1 \"s_imm_operand\" \"oQ\")))]\n+        (compare (match_operand:QI 0 \"s_operand\" \"Q\")\n+                 (match_operand:QI 1 \"s_imm_operand\" \"Q\")))]\n   \"s390_match_ccmode(insn, CCUmode)\"\n   \"clc\\\\t%O0(1,%R0),%1\"\n   [(set_attr \"op_type\" \"SS\")\n@@ -780,8 +780,8 @@\n ;\n \n (define_insn \"*movti_ss\"\n-  [(set (match_operand:TI 0 \"s_operand\" \"=Qo\")\n-        (match_operand:TI 1 \"s_imm_operand\" \"Qo\"))]\n+  [(set (match_operand:TI 0 \"s_operand\" \"=Q\")\n+        (match_operand:TI 1 \"s_imm_operand\" \"Q\"))]\n   \"\"\n   \"mvc\\\\t%O0(16,%R0),%1\"\t\n   [(set_attr \"op_type\" \"SS\")\n@@ -914,8 +914,8 @@\n     (set_attr \"type\"    \"la\")])\n \n (define_insn \"*movdi_ss\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n-        (match_operand:DI 1 \"s_imm_operand\" \"Qo\"))]\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n+        (match_operand:DI 1 \"s_imm_operand\" \"Q\"))]\n   \"\"\n   \"mvc\\\\t%O0(8,%R0),%1\"\t\n   [(set_attr \"op_type\" \"SS\")\n@@ -1067,8 +1067,8 @@\n   [(set_attr \"op_type\" \"RI\")])\n \n (define_insn \"*movsi_ss\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n-        (match_operand:SI 1 \"s_imm_operand\" \"Qo\"))]\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n+        (match_operand:SI 1 \"s_imm_operand\" \"Q\"))]\n   \"\"\n   \"mvc\\\\t%O0(4,%R0),%1\"\t\n   [(set_attr \"op_type\" \"SS\")\n@@ -1156,7 +1156,7 @@\n \n (define_insn \"*movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n-                         (match_operand:HI 1 \"s_imm_operand\" \"Qo\"))\n+                         (match_operand:HI 1 \"s_imm_operand\" \"Q\"))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"icm\\\\t%0,3,%1\"\n@@ -1197,8 +1197,8 @@\n }\")\n \n (define_insn \"*movdf_ss\"\n-  [(set (match_operand:DF 0 \"s_operand\" \"=Qo\")\n-        (match_operand:DF 1 \"s_imm_operand\" \"Qo\"))]\n+  [(set (match_operand:DF 0 \"s_operand\" \"=Q\")\n+        (match_operand:DF 1 \"s_imm_operand\" \"Q\"))]\n   \"\"\n   \"mvc\\\\t%O0(8,%R0),%1\"\t\n   [(set_attr \"op_type\" \"SS\")\n@@ -1300,8 +1300,8 @@\n }\")\n \n (define_insn \"*movsf_ss\"\n-  [(set (match_operand:SF 0 \"s_operand\" \"=Qo\")\n-        (match_operand:SF 1 \"s_imm_operand\" \"Qo\"))]\n+  [(set (match_operand:SF 0 \"s_operand\" \"=Q\")\n+        (match_operand:SF 1 \"s_imm_operand\" \"Q\"))]\n   \"\"\n   \"mvc\\\\t%O0(4,%R0),%1\"\t\n   [(set_attr \"op_type\" \"SS\")\n@@ -1388,7 +1388,7 @@\n (define_insn \"*load_multiple_di\"\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:DI 1 \"register_operand\" \"=r\")\n-\t\t\t (match_operand:DI 2 \"s_operand\" \"oQ\"))])]\n+\t\t\t (match_operand:DI 2 \"s_operand\" \"Q\"))])]\n   \"\"\n   \"*\n {\n@@ -1407,7 +1407,7 @@\n (define_insn \"*load_multiple_si\"\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"register_operand\" \"=r\")\n-\t\t\t (match_operand:SI 2 \"s_operand\" \"oQ\"))])]\n+\t\t\t (match_operand:SI 2 \"s_operand\" \"Q\"))])]\n   \"\"\n   \"*\n {\n@@ -1491,7 +1491,7 @@\n \n (define_insn \"*store_multiple_di\"\n   [(match_parallel 0 \"store_multiple_operation\"\n-\t\t   [(set (match_operand:DI 1 \"s_operand\" \"=oQ\")\n+\t\t   [(set (match_operand:DI 1 \"s_operand\" \"=Q\")\n \t\t\t (match_operand:DI 2 \"register_operand\" \"r\"))])]\n   \"\"\n   \"*\n@@ -1511,7 +1511,7 @@\n \n (define_insn \"*store_multiple_si\"\n   [(match_parallel 0 \"store_multiple_operation\"\n-\t\t   [(set (match_operand:SI 1 \"s_operand\" \"=oQ\")\n+\t\t   [(set (match_operand:SI 1 \"s_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))])]\n   \"\"\n   \"*\n@@ -1697,8 +1697,8 @@\n ; The block length is taken as (operands[2] % 256) + 1.\n \n (define_insn \"movstrdi_short\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=oQ,oQ\")\n-        (match_operand:BLK 1 \"s_operand\" \"oQ,oQ\"))\n+  [(set (match_operand:BLK 0 \"s_operand\" \"=Q,Q\")\n+        (match_operand:BLK 1 \"s_operand\" \"Q,Q\"))\n    (use (match_operand:DI 2 \"nonmemory_operand\" \"n,a\"))\n    (clobber (match_scratch:DI 3 \"=X,&a\"))]\n   \"TARGET_64BIT\"\n@@ -1723,8 +1723,8 @@\n    (set_attr \"length\"  \"*,14\")])\n \n (define_insn \"movstrsi_short\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=oQ,oQ\")\n-        (match_operand:BLK 1 \"s_operand\" \"oQ,oQ\"))\n+  [(set (match_operand:BLK 0 \"s_operand\" \"=Q,Q\")\n+        (match_operand:BLK 1 \"s_operand\" \"Q,Q\"))\n    (use (match_operand:SI 2 \"nonmemory_operand\" \"n,a\"))\n    (clobber (match_scratch:SI 3 \"=X,&a\"))]\n   \"!TARGET_64BIT\"\n@@ -1927,7 +1927,7 @@\n ; Clear memory with length less than 256 bytes \n \n (define_insn \"clrstrsico\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:BLK 0 \"s_operand\" \"=Q\")\n         (const_int 0))\n    (use (match_operand 1 \"immediate_operand\" \"I\"))\n    (clobber (reg:CC 33))]\n@@ -2111,8 +2111,8 @@\n \n (define_insn \"cmpstr_const\"\n   [(set (reg:CCS 33)\n-        (compare:CCS (match_operand:BLK 0 \"s_operand\" \"oQ\")\n-                     (match_operand:BLK 1 \"s_operand\" \"oQ\")))\n+        (compare:CCS (match_operand:BLK 0 \"s_operand\" \"Q\")\n+                     (match_operand:BLK 1 \"s_operand\" \"Q\")))\n    (use (match_operand 2 \"immediate_operand\" \"I\"))]\n   \"(unsigned) INTVAL (operands[2]) < 256\"\n   \"clc\\\\t%O0(%c2,%R0),%1\"\n@@ -2193,7 +2193,7 @@\n \n (define_insn \"*sethighqisi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:QI 1 \"s_operand\" \"Qo\")] 10))\n+        (unspec:SI [(match_operand:QI 1 \"s_operand\" \"Q\")] 10))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"icm\\\\t%0,8,%1\"\n@@ -2202,7 +2202,7 @@\n \n (define_insn \"*sethighhisi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:HI 1 \"s_operand\" \"Qo\")] 10))\n+        (unspec:SI [(match_operand:HI 1 \"s_operand\" \"Q\")] 10))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"icm\\\\t%0,12,%1\"\n@@ -2211,7 +2211,7 @@\n \n (define_insn \"*sethighqidi_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"Qo\")] 10))\n+        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"Q\")] 10))\n    (clobber (reg:CC 33))]\n   \"TARGET_64BIT\"\n   \"icmh\\\\t%0,8,%1\"\n@@ -2220,7 +2220,7 @@\n \n (define_insn \"*sethighqidi_31\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"Qo\")] 10))\n+        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"Q\")] 10))\n    (clobber (reg:CC 33))]\n   \"!TARGET_64BIT\"\n   \"icm\\\\t%0,8,%1\"\n@@ -4486,18 +4486,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*anddi3_ss\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n         (and:DI (match_dup 0)\n-                (match_operand:DI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:DI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"nc\\\\t%O0(8,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*anddi3_ss_inv\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n-        (and:DI (match_operand:DI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n+        (and:DI (match_operand:DI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4570,18 +4570,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*andsi3_ss\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n         (and:SI (match_dup 0)\n-                (match_operand:SI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:SI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"nc\\\\t%O0(4,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*andsi3_ss_inv\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n-        (and:SI (match_operand:SI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n+        (and:SI (match_operand:SI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4616,18 +4616,18 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*andhi3_ss\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n         (and:HI (match_dup 0)\n-                (match_operand:HI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:HI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"nc\\\\t%O0(2,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*andhi3_ss_inv\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n-        (and:HI (match_operand:HI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n+        (and:HI (match_operand:HI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4662,9 +4662,9 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*andqi3_ss\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n         (and:QI (match_dup 0)\n-                (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")))\n+                (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"@\n@@ -4674,8 +4674,8 @@\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*andqi3_ss_inv\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n-        (and:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n+        (and:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4757,18 +4757,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*iordi3_ss\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n         (ior:DI (match_dup 0)\n-                (match_operand:DI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:DI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"oc\\\\t%O0(8,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*iordi3_ss_inv\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n-        (ior:DI (match_operand:DI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n+        (ior:DI (match_operand:DI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4841,18 +4841,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*iorsi3_ss\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n         (ior:SI (match_dup 0)\n-                (match_operand:SI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:SI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"oc\\\\t%O0(4,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*iorsi3_ss_inv\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n-        (ior:SI (match_operand:SI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n+        (ior:SI (match_operand:SI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4887,18 +4887,18 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*iorhi3_ss\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n         (ior:HI (match_dup 0)\n-                (match_operand:HI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:HI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"oc\\\\t%O0(2,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*iorhi3_ss_inv\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n-        (ior:HI (match_operand:HI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n+        (ior:HI (match_operand:HI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -4933,9 +4933,9 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*iorqi3_ss\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n         (ior:QI (match_dup 0)\n-                (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")))\n+                (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"@\n@@ -4945,8 +4945,8 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*iorqi3_ss_inv\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n-        (ior:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n+        (ior:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -5005,18 +5005,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*xordi3_ss\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n         (xor:DI (match_dup 0)\n-                (match_operand:DI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:DI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"xc\\\\t%O0(8,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*xordi3_ss_inv\"\n-  [(set (match_operand:DI 0 \"s_operand\" \"=Qo\")\n-        (xor:DI (match_operand:DI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:DI 0 \"s_operand\" \"=Q\")\n+        (xor:DI (match_operand:DI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -5068,18 +5068,18 @@\n    (set_attr \"atype\"    \"reg,mem\")])\n \n (define_insn \"*xorsi3_ss\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n         (xor:SI (match_dup 0)\n-                (match_operand:SI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:SI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"xc\\\\t%O0(4,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*xorsi3_ss_inv\"\n-  [(set (match_operand:SI 0 \"s_operand\" \"=Qo\")\n-        (xor:SI (match_operand:SI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:SI 0 \"s_operand\" \"=Q\")\n+        (xor:SI (match_operand:SI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -5102,18 +5102,18 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*xorhi3_ss\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n         (xor:HI (match_dup 0)\n-                (match_operand:HI 1 \"s_imm_operand\" \"Qo\")))\n+                (match_operand:HI 1 \"s_imm_operand\" \"Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"xc\\\\t%O0(2,%R0),%1\"\n   [(set_attr \"op_type\"  \"SS\")\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*xorhi3_ss_inv\"\n-  [(set (match_operand:HI 0 \"s_operand\" \"=Qo\")\n-        (xor:HI (match_operand:HI 1 \"s_imm_operand\" \"Qo\")\n+  [(set (match_operand:HI 0 \"s_operand\" \"=Q\")\n+        (xor:HI (match_operand:HI 1 \"s_imm_operand\" \"Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\"\n@@ -5136,9 +5136,9 @@\n    (set_attr \"atype\"    \"reg\")])\n \n (define_insn \"*xorqi3_ss\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n         (xor:QI (match_dup 0)\n-                (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")))\n+                (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")))\n    (clobber (reg:CC 33))]\n   \"\"\n   \"@\n@@ -5148,8 +5148,8 @@\n    (set_attr \"atype\"    \"mem\")])\n \n (define_insn \"*xorqi3_ss_inv\"\n-  [(set (match_operand:QI 0 \"s_operand\" \"=Qo,Qo\")\n-        (xor:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Qo\")\n+  [(set (match_operand:QI 0 \"s_operand\" \"=Q,Q\")\n+        (xor:QI (match_operand:QI 1 \"s_imm_operand\" \"n,Q\")\n                 (match_dup 0)))\n    (clobber (reg:CC 33))]\n   \"\""}, {"sha": "ae115b887fd3208eacd2fe5a4682be86448c09ae", "filename": "gcc/defaults.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -590,4 +590,16 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define DEFAULT_USE_CXA_ATEXIT 0\n #endif\n \n+/* Determine whether extra constraint letter should be handled\n+   via address reload (like 'o').  */\n+#ifndef EXTRA_MEMORY_CONSTRAINT\n+#define EXTRA_MEMORY_CONSTRAINT(C) 0\n+#endif\n+\n+/* Determine whether extra constraint letter should be handled\n+   as an address (like 'p').  */\n+#ifndef EXTRA_ADDRESS_CONSTRAINT\n+#define EXTRA_ADDRESS_CONSTRAINT(C) 0\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "064120d639af3d061b2dd3ddce6079d22c6f2b9d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -2614,6 +2614,44 @@ letter @samp{Q} is defined as representing a memory address that does\n a @samp{Q} constraint on the input and @samp{r} on the output.  The next\n alternative specifies @samp{m} on the input and a register class that\n does not include r0 on the output.\n+\n+@findex EXTRA_MEMORY_CONSTRAINT\n+@item EXTRA_MEMORY_CONSTRAINT (@var{c})\n+A C expression that defines the optional machine-dependent constraint\n+letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should\n+be treated like memory constraints by the reload pass.\n+\n+It should return 1 if the operand type represented by the constraint \n+letter @var{c} comprises a subset of all memory references including\n+all those whose address is simply a base register.  This allows the reload \n+pass to reload an operand, if it does not directly correspond to the operand \n+type of @var{c}, by copying its address into a base register.\n+\n+For example, on the S/390, some instructions do not accept arbitrary\n+memory references, but only those that do not make use of an index\n+register.  The constraint letter @samp{Q} is defined via\n+@code{EXTRA_CONSTRAINT} as representing a memory address of this type.\n+If the letter @samp{Q} is marked as @code{EXTRA_MEMORY_CONSTRAINT},\n+a @samp{Q} constraint can handle any memory operand, because the\n+reload pass knows it can be reloaded by copying the memory address\n+into a base register if required.  This is analogous to the way\n+a @samp{o} constraint can handle any memory operand.\n+\n+@findex EXTRA_ADDRESS_CONSTRAINT\n+@item EXTRA_ADDRESS_CONSTRAINT (@var{c})\n+A C expression that defines the optional machine-dependent constraint\n+letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should\n+be treated like address constraints by the reload pass.\n+\n+It should return 1 if the operand type represented by the constraint \n+letter @var{c} comprises a subset of all memory addresses including\n+all those that consist of just a base register.  This allows the reload \n+pass to reload an operand, if it does not directly correspond to the operand \n+type of @var{c}, by copying it into a base register.\n+\n+Any constraint marked as @code{EXTRA_ADDRESS_CONSTRAINT} can only\n+be used with the @code{address_operand} predicate.  It is treated \n+analogously to the @samp{p} constraint.\n @end table\n \n @node Stack and Calling"}, {"sha": "04e2fbe5a4c7cc5951bb03cc6b223b34b7cc8ac7", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1342,7 +1342,8 @@ block_alloc (b)\n \t\t  /* If the operand is an address, find a register in it.\n \t\t     There may be more than one register, but we only try one\n \t\t     of them.  */\n-\t\t  if (recog_data.constraints[i][0] == 'p')\n+\t\t  if (recog_data.constraints[i][0] == 'p'\n+\t\t      || EXTRA_ADDRESS_CONSTRAINT (recog_data.constraints[i][0]))\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n \t\t      r1 = XEXP (r1, 0);\n \n@@ -2472,7 +2473,8 @@ requires_inout (p)\n \tbreak;\n \n       default:\n-\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n+\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS\n+\t    && !EXTRA_ADDRESS_CONSTRAINT (c))\n \t  break;\n \t/* FALLTHRU */\n       case 'p':"}, {"sha": "6bb8670e166c283783ef8cb0663f424b9c5adf1a", "filename": "gcc/recog.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1848,6 +1848,18 @@ asm_operand_ok (op, constraint)\n #ifdef EXTRA_CONSTRAINT\n \t  if (EXTRA_CONSTRAINT (op, c))\n \t    return 1;\n+\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t    {\n+\t      /* Every memory operand can be reloaded to fit.  */\n+\t      if (memory_operand (op, VOIDmode))\n+\t        return 1;\n+\t    }\n+\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t    {\n+\t      /* Every address operand can be reloaded to fit.  */\n+\t      if (address_operand (op, VOIDmode))\n+\t        return 1;\n+\t    }\n #endif\n \t  break;\n \t}\n@@ -2287,6 +2299,19 @@ preprocess_constraints ()\n \t\t  break;\n \n \t\tdefault:\n+\t\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t    {\n+\t\t      op_alt[j].memory_ok = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t    {\n+\t\t      op_alt[j].is_address = 1;\n+\t\t      op_alt[j].class = reg_class_subunion[(int) op_alt[j].class]\n+\t\t        [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t      break;\n+\t\t    }\n+\n \t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) REG_CLASS_FROM_LETTER ((unsigned char) c)];\n \t\t  break;\n \t\t}\n@@ -2600,6 +2625,28 @@ constrain_operands (strict)\n #ifdef EXTRA_CONSTRAINT\n \t\t  else if (EXTRA_CONSTRAINT (op, c))\n \t\t    win = 1;\n+\n+\t\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t    {\n+\t\t      /* Every memory operand can be reloaded to fit,\n+\t\t\t so copy the condition from the 'm' case.  */\n+\t\t      if (GET_CODE (op) == MEM\n+\t\t          /* Before reload, accept what reload can turn into mem.  */\n+\t\t          || (strict < 0 && CONSTANT_P (op))\n+\t\t          /* During reload, accept a pseudo  */\n+\t\t          || (reload_in_progress && GET_CODE (op) == REG\n+\t\t\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER))\n+\t\t\twin = 1;\n+\t\t    }\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t    {\n+\t\t      /* Every address operand can be reloaded to fit,\n+\t\t\t so copy the condition from the 'p' case.  */\n+\t\t      if (strict <= 0\n+\t\t          || (strict_memory_address_p (recog_data.operand_mode[opno],\n+\t\t\t\t\t\t       op)))\n+\t\t        win = 1;\n+\t\t    }\n #endif\n \t\t  break;\n \t\t}"}, {"sha": "75335b1603071dae91bbbee4b2481a816ece6c9b", "filename": "gcc/regclass.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1007,7 +1007,8 @@ record_operand_costs (insn, op_costs, reg_pref)\n       if (GET_CODE (recog_data.operand[i]) == MEM)\n \trecord_address_regs (XEXP (recog_data.operand[i], 0),\n \t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n-      else if (constraints[i][0] == 'p')\n+      else if (constraints[i][0] == 'p'\n+\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0]))\n \trecord_address_regs (recog_data.operand[i],\n \t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n     }\n@@ -1709,6 +1710,27 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n #ifdef EXTRA_CONSTRAINT\n \t\telse if (EXTRA_CONSTRAINT (op, c))\n \t\t  win = 1;\n+\n+\t\tif (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t  {\n+\t\t    /* Every MEM can be reloaded to fit.  */\n+\t\t    allows_mem[i] = 1;\n+\t\t    if (GET_CODE (op) == MEM)\n+\t\t      win = 1;\n+\t\t  }\n+\t\tif (EXTRA_ADDRESS_CONSTRAINT (op))\n+\t\t  {\n+\t\t    /* Every address can be reloaded to fit.  */\n+\t\t    allows_addr = 1;\n+\t\t    if (address_operand (op, GET_MODE (op)))\n+\t\t      win = 1;\n+\t\t    /* We know this operand is an address, so we want it to be\n+\t\t       allocated to a register that can be the base of an\n+\t\t       address, ie BASE_REG_CLASS.  */\n+\t\t    classes[i]\n+\t\t      = reg_class_subunion[(int) classes[i]]\n+\t\t        [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t  }\n #endif\n \t\tbreak;\n \t      }"}, {"sha": "67f411b9040b7e8edd4001e173537bd88dfdc71f", "filename": "gcc/reload.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -2641,7 +2641,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       if (*constraints[i] == 0)\n \t/* Ignore things like match_operator operands.  */\n \t;\n-      else if (constraints[i][0] == 'p')\n+      else if (constraints[i][0] == 'p'\n+\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0]))\n \t{\n \t  find_reloads_address (VOIDmode, (rtx*) 0,\n \t\t\t\trecog_data.operand[i],\n@@ -3222,6 +3223,49 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n \t\t  {\n #ifdef EXTRA_CONSTRAINT\n+\t\t    if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t      {\n+\t\t\tif (force_reload)\n+\t\t\t  break;\n+\t\t        if (EXTRA_CONSTRAINT (operand, c))\n+\t\t          win = 1;\n+\t\t\t/* If the address was already reloaded,\n+\t\t\t   we win as well.  */\n+\t\t\tif (GET_CODE (operand) == MEM && address_reloaded[i])\n+\t\t\t  win = 1;\n+\t\t\t/* Likewise if the address will be reloaded because\n+\t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n+\t\t\t   we have to check.  */\n+\t\t        if (GET_CODE (operand) == REG\n+\t\t\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t    && reg_renumber[REGNO (operand)] < 0\n+\t\t\t    && ((reg_equiv_mem[REGNO (operand)] != 0\n+\t\t\t         && EXTRA_CONSTRAINT (reg_equiv_mem[REGNO (operand)], c))\n+\t\t\t        || (reg_equiv_address[REGNO (operand)] != 0)))\n+\t\t\t  win = 1;\n+\n+\t\t\t/* If we didn't already win, we can reload\n+\t\t\t   constants via force_const_mem, and other\n+\t\t\t   MEMs by reloading the address like for 'o'.  */\n+\t\t\tif ((CONSTANT_P (operand) && GET_CODE (operand) != HIGH)\n+\t\t\t    || GET_CODE (operand) == MEM)\n+\t\t\t  badop = 0;\n+\t\t\tconstmemok = 1;\n+\t\t\toffmemok = 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t      {\n+\t\t        if (EXTRA_CONSTRAINT (operand, c))\n+\t\t          win = 1;\n+\n+\t\t\t/* If we didn't already win, we can reload\n+\t\t\t   the address into a base register.  */\n+\t\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n+\t\t\tbadop = 0;\n+\t\t\tbreak;\n+\t\t      }\n+\n \t\t    if (EXTRA_CONSTRAINT (operand, c))\n \t\t      win = 1;\n #endif\n@@ -4291,7 +4335,7 @@ alternative_allows_memconst (constraint, altnum)\n   /* Scan the requested alternative for 'm' or 'o'.\n      If one of them is present, this alternative accepts memory constants.  */\n   while ((c = *constraint++) && c != ',' && c != '#')\n-    if (c == 'm' || c == 'o')\n+    if (c == 'm' || c == 'o' || EXTRA_MEMORY_CONSTRAINT (c))\n       return 1;\n   return 0;\n }"}, {"sha": "58b0bd04bce053da881e825492fd83cdd9331744", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1380,8 +1380,12 @@ maybe_fix_stack_asms ()\n \t\t  break;\n \n \t\tdefault:\n-\t\t  cls = (int) reg_class_subunion[cls][(int) REG_CLASS_FROM_LETTER (c)];\n-\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t    cls = (int) reg_class_subunion[cls]\n+\t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t  else\n+\t\t    cls = (int) reg_class_subunion[cls]\n+\t\t      [(int) REG_CLASS_FROM_LETTER (c)];\n \t\t}\n \t    }\n \t}"}, {"sha": "b2e2cad28c2b7075daec60e3c27b81d29dede922", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ccfc6cc8fa5ab66c0e2dede177aa5b1010523ffc", "patch": "@@ -1252,6 +1252,10 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n \tif (REG_CLASS_FROM_LETTER (*p) != NO_REGS)\n \t  *allows_reg = true;\n #ifdef EXTRA_CONSTRAINT\n+\telse if (EXTRA_ADDRESS_CONSTRAINT (*p))\n+\t  *allows_reg = true;\n+\telse if (EXTRA_MEMORY_CONSTRAINT (*p))\n+\t  *allows_mem = true;\n \telse\n \t  {\n \t    /* Otherwise we can't assume anything about the nature of\n@@ -1377,6 +1381,10 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n \tif (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n \t  *allows_reg = true;\n #ifdef EXTRA_CONSTRAINT\n+\telse if (EXTRA_ADDRESS_CONSTRAINT (constraint[j]))\n+\t  *allows_reg = true;\n+\telse if (EXTRA_MEMORY_CONSTRAINT (constraint[j]))\n+\t  *allows_mem = true;\n \telse\n \t  {\n \t    /* Otherwise we can't assume anything about the nature of"}]}