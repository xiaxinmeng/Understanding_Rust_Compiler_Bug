{"sha": "0083c9044f6a6d904380daffb0c5c34919861792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4M2M5MDQ0ZjZhNmQ5MDQzODBkYWZmYjBjNWMzNDkxOTg2MTc5Mg==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1998-10-16T07:00:18Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1998-10-16T07:00:18Z"}, "message": "These files are being moved from the contrib/fixinc directory.\n\nThey have been modified somewhat to work in the new environment.\n\nFrom-SVN: r23125", "tree": {"sha": "2bc549c1d8db840b9548be3c12e7838512ef26b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bc549c1d8db840b9548be3c12e7838512ef26b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0083c9044f6a6d904380daffb0c5c34919861792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0083c9044f6a6d904380daffb0c5c34919861792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0083c9044f6a6d904380daffb0c5c34919861792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0083c9044f6a6d904380daffb0c5c34919861792/comments", "author": null, "committer": null, "parents": [{"sha": "162bc98d096a61193b3cb490a5430fb852d059eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162bc98d096a61193b3cb490a5430fb852d059eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162bc98d096a61193b3cb490a5430fb852d059eb"}], "stats": {"total": 13425, "additions": 13425, "deletions": 0}, "files": [{"sha": "e220c22d47062a15e6d8b00756016e27ec7a7b34", "filename": "gcc/fixinc/Makefile.in", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FMakefile.in?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,132 @@\n+# Makefile for GNU C++ compiler.\n+#   Copyright (C) 1987, 88, 90-5, 1998 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+# The makefile built from this file lives in the fixinc subdirectory.\n+# Its purpose is to build the any-platforms fixinc.sh script.\n+\n+CFLAGS = -g\n+\n+CC = @CC@\n+SHELL = /bin/sh\n+\n+target=@target@\n+# Directory where sources are, from where we are.\n+srcdir = @srcdir@\n+VPATH = @srcdir@\n+\n+# End of variables for you to override.\n+\n+default : gen\n+\n+# Now figure out from those variables how to compile and link.\n+\n+# Specify the directories to be searched for header files.\n+# Both . and srcdir are used, in that order.\n+INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n+\n+# Always use -I$(srcdir)/config when compiling.\n+.c.o:\n+\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $(INCLUDES) $<\n+\n+# The only suffixes we want for implicit rules are .c and .o.\n+.SUFFIXES:\n+.SUFFIXES: .c .o\n+\n+#\f\n+\n+## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n+##\n+##  Makefile for constructing the \"best\" include fixer we can\n+##\n+##  $Id: Makefile.in,v 1.2 1998/12/16 21:18:54 law Exp $\n+##\n+## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n+\n+OBJ = fixincl.o server.o regex.o\n+HDR = server.h regex.h\n+\n+SH_TARGET  = inclhack.sh fixincl.sh\n+BIN_TARGET = fixincl\n+AG_TEXT    = $(SH_TARGET) fixincl.x \\\n+\tinclhack.def inclhack.tpl hackshell.tpl fixincl.tpl\n+TARGETS    = $(SH_TARGET) $(BIN_TARGET)\n+\n+all : $(TARGETS)\n+sh  : $(SH_TARGET)\n+gen : $(SH_TARGET) fixincl.x\n+\n+$(OBJ): $(HDR)\n+\n+fixincl: $(OBJ)\n+\t@echo $(CC) -o $@ $(OBJ) $(LIB) ; \\\n+\tif $(CC) -o $@ $(OBJ) $(LIB) ; then : ; else \\\n+\trm -f $@ ; (echo \"#! /bin/sh\" ; echo exit 1 ) > $@ ; \\\n+\tchmod 777 $@ ; fi\n+\n+regex.o: regex.c\n+\t-$(CC) $(CFLAGS) -DSTDC_HEADERS=1 -c regex.c\n+\n+fixincl.o : fixincl.x fixincl.c\n+server.o : server.c server.h\n+\n+fixincl.x: fixincl.tpl inclhack.def\n+\t@if ( autogen --help > /dev/null 2>&1 ) ; then \\\n+\t\techo autogen -T fixincl.tpl -b fixincl inclhack.def ; \\\n+\t\tautogen -T $(srcdir)/fixincl.tpl -b fixincl \\\n+\t\t\t$(srcdir)/inclhack.def ; \\\n+\telse echo You need to install autogen ; \\\n+\t\t$(CP) $(srcdir)/$@ . ; fi\n+\n+inclhack.sh: inclhack.def inclhack.tpl hackshell.tpl\n+\t@if ( autogen --help > /dev/null 2>&1 ) ; then \\\n+\t\techo autogen inclhack.def ; \\\n+\t\tautogen inclhack.def ; \\\n+\telse echo You need to install autogen ; \\\n+\t\t$(CP) $(srcdir)/$@ . ; fi\n+\n+fixincl.sh: inclhack.def inclhack.tpl\n+\t@if ( autogen --help > /dev/null 2>&1 ) ; then \\\n+\t\techo autogen -DPROGRAM=1 -b fixincl inclhack.def ; \\\n+\t\tautogen -DPROGRAM=1 -b fixincl inclhack.def ; touch $@ ; \\\n+\telse echo You need to install autogen ; \\\n+\t\t$(CP) $(srcdir)/$@ . ; fi\n+\n+clean:\n+\trm -f *.o $(TARGETS) fixincl.x\n+\n+#  Ensure all the targets are built.  If the program \"fixincl\"\n+#  failed to compile, link or load, then we install the\n+#  \"inclhack.sh\" script.  Otherwise, we install that program\n+#  plus the wrapper script, \"fixincl.sh\".\n+#\n+install: $(TARGETS)\n+\t@rm -f ../fixinc.sh ; \\\n+\tif ( ./fixincl -v > /dev/null 2>&1 ) ; then \\\n+\t\techo cp fixincl.sh ../fixinc.sh ; \\\n+\t\tcp fixincl.sh ../fixinc.sh ; \\\n+\t\tchmod 555 ../fixinc.sh ; \\\n+\t\trm -f ../fixincl ; \\\n+\t\techo cp fixincl .. ; \\\n+\t\tcp fixincl .. ; \\\n+\t\tchmod 555 ../fixincl ; \\\n+\telse \\\n+\t\techo cp inclhack.sh ../fixinc.sh ; \\\n+\t\tcp inclhack.sh ../fixinc.sh ; \\\n+\tfi"}, {"sha": "422ba5f725fd0d3ef3ed5986db8b5a1002f8fafb", "filename": "gcc/fixinc/fixinc.dgux", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.dgux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.dgux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.dgux?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,185 @@\n+#!/bin/sh\n+#\n+# modified for dgux by hassey@dg-rtp.dg.com based on\n+#\n+#   fixinc.svr4  written by Ron Guilmette (rfg@ncd.com).\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\n+#\tSee README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+\tcd $LIB; LIB=`${PWDCMD-pwd}`\n+\t;;\n+esac\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+# Determine whether this filesystem has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+\n+echo 'Making directories:'\n+cd ${INPUT}\n+if $LINKS; then\n+  files=`ls -LR | sed -n s/:$//p`\n+else\n+  files=`find . -type d -print | sed '/^.$/d'`\n+fi\n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic directory links'\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if [ \"$dest\" ]; then    \n+      cwd=`pwd`\n+      # In case $dest is relative, get to $file's dir first.\n+      cd ${INPUT}\n+      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n+      # Check that the target directory exists.\n+      # Redirections changed to avoid bug in sh on Ultrix.\n+      (cd $dest) > /dev/null 2>&1\n+      if [ $? = 0 ]; then\n+\tcd $dest\n+\t# X gets the dir that the link actually leads to.\n+\tx=`pwd`\n+\t# If link leads back into ${INPUT},\n+\t# make a similar link here.\n+\tif expr $x : \"${INPUT}/.*\" > /dev/null; then\n+\t  # Y gets the actual target dir name, relative to ${INPUT}.\n+\t  y=`echo $x | sed -n \"s&${INPUT}/&&p\"`\n+\t  # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+\t  dots=`echo \"$file\" |\n+\t    sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+\t  echo $file '->' $dots$y ': Making link'\n+\t  rm -fr ${LIB}/$file > /dev/null 2>&1\n+\t  ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n+\telse\n+\t  # If the link is to outside ${INPUT},\n+\t  # treat this directory as if it actually contained the files.\n+# This line used to have $dest instead of $x.\n+# $dest seemed to be wrong for links found in subdirectories\n+# of ${INPUT}.  Does this change break anything?\n+\t  treetops=\"$treetops $x ${LIB}/$file\"\n+\tfi\n+      fi\n+      cd $cwd\n+    fi\n+  done\n+fi\n+\n+# Completely replace <_int_varargs.h> with a file that defines\n+# va_list and gnuc_va_list\n+\n+file=_int_varargs.h\n+if [ -r ${INPUT}/$file ]; then\n+  echo Replacing $file\n+  cat > ${LIB}/$file << EOF\n+/* This file was generated by fixinc.dgux.  */\n+#ifndef __INT_VARARGS_H\n+#define __INT_VARARGS_H\n+\n+#if defined(__m88k__) && defined (__DGUX__)\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+typedef struct\n+{\n+  int  __va_arg;\t\t/* argument number */\n+  int *__va_stk;\t\t/* start of args passed on stack */\n+  int *__va_reg;\t\t/* start of args passed in regs */\n+} __gnuc_va_list;\n+#endif /* not __GNUC_VA_LIST */\n+#endif /* 88k && dgux */\n+\n+#ifndef _VA_LIST_\n+#define _VA_LIST_\n+typedef __gnuc_va_list va_list;\n+#endif /* _VA_LIST_ */\n+\n+#endif /* __INT_VARARGS_H */\n+\n+EOF\n+  chmod a+r ${LIB}/$file\n+fi\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > /dev/null 2>&1\n+done\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic non-directory links'\n+  cd ${INPUT}\n+  files=`find . -type l -print`\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if expr \"$dest\" : '[^/].*' > /dev/null; then    \n+      target=${LIB}/`echo file | sed \"s|[^/]*\\$|$dest|\"`\n+      if [ -f $target ]; then\n+        ln -s $dest ${LIB}/$file >/dev/null 2>&1\n+      fi\n+    fi\n+  done\n+fi\n+\n+cd ${ORIG_DIR}\n+\n+exit 0\n+"}, {"sha": "6562581df6eb1090d6fb2d0f9893deab37435fc7", "filename": "gcc/fixinc/fixinc.irix", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.irix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.irix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.irix?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,225 @@\n+#! /bin/sh\n+# Install modified versions of certain problematic Irix include files.\n+# If possible, create a wrapper (see fixinc.wrap) instead of copying files.\n+#\n+# Copyright (C) 1997 Free Software Foundation, Inc.\n+# Contributed by Brendan Kehoe (brendan@cygnus.com).\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\tSee README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+ \tLIB=$ORIG_DIR/$LIB\n+\t;;\n+esac\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+#\n+# Note: For Irix, we deliberately don't try to create the directory trees,\n+#       since we only modify math.h, limits.h and unistd.h.  If we\n+#\tADD ANY OTHERS, the \"Making directories:\" and symlinks code from\n+#\tfixinc.svr4 may have to go back in.\n+\n+# This math.h fix is copied from fixinc.wrap.  We want to avoid copying\n+# math.h because both math.h and stdlib.h have a declaration for initstate,\n+# and this declaration changed between Irix 6.2 and Irix 6.3.  If we copy this\n+# file, then the same toolchain can't be shared between 6.2 and 6.3+.\n+\n+# Some math.h files define struct exception, which conflicts with\n+# the class exception defined in the C++ file std/stdexcept.h.  We\n+# redefine it to __math_exception.  This is not a great fix, but I\n+# haven't been able to think of anything better.\n+file=math.h\n+if [ -r $INPUT/$file ]; then\n+  echo Checking $INPUT/$file\n+  if grep 'struct exception' $INPUT/$file >/dev/null\n+  then\n+    echo Fixed $file\n+    rm -f $LIB/$file\n+    cat <<'__EOF__' >$LIB/$file\n+#ifndef _MATH_H_WRAPPER\n+#ifdef __cplusplus\n+# define exception __math_exception\n+#endif\n+#include_next <math.h>\n+#ifdef __cplusplus\n+# undef exception\n+#endif\n+#define _MATH_H_WRAPPER\n+#endif /* _MATH_H_WRAPPER */\n+__EOF__\n+    # Define _MATH_H_WRAPPER at the end of the wrapper, not the start,\n+    # so that if #include_next gets another instance of the wrapper,\n+    # this will follow the #include_next chain until we arrive at\n+    # the real <math.h>.\n+    chmod a+r $LIB/$file\n+  fi\n+fi\n+\n+# Avoid the definition of the bool type in curses.h when using\n+# g++, since it's now an official type in the C++ language.\n+\n+# This is also from fixinc.wrap.\n+\n+file=curses.h\n+if [ -r $INPUT/$file ]; then\n+  echo Checking $INPUT/$file\n+  w='[\t ]'\n+  if grep \"typedef$w$w*char$w$w*bool$w*;\" $INPUT/$file >/dev/null\n+  then\n+    echo Fixed $file\n+    rm -f $LIB/$file\n+    cat <<'__EOF__' >$LIB/$file\n+#ifndef _CURSES_H_WRAPPER\n+#ifdef __cplusplus\n+# define bool __curses_bool_t\n+#endif\n+#include_next <curses.h>\n+#ifdef __cplusplus\n+# undef bool\n+#endif\n+#define _CURSES_H_WRAPPER\n+#endif /* _CURSES_H_WRAPPER */\n+__EOF__\n+    # Define _CURSES_H_WRAPPER at the end of the wrapper, not the start,\n+    # so that if #include_next gets another instance of the wrapper,\n+    # this will follow the #include_next chain until we arrive at\n+    # the real <curses.h>.\n+    chmod a+r $LIB/$file\n+  fi\n+fi\n+\n+# In limits.h, put #ifndefs around things that are supposed to be defined\n+# in float.h to avoid redefinition errors if float.h is included first.\n+\n+file=limits.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/[ \t]FLT_MIN[ \t]/i\\\n+#ifndef FLT_MIN\n+'\\\n+      -e '/[ \t]FLT_MIN[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]FLT_MAX[ \t]/i\\\n+#ifndef FLT_MAX\n+'\\\n+      -e '/[ \t]FLT_MAX[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]FLT_DIG[ \t]/i\\\n+#ifndef FLT_DIG\n+'\\\n+      -e '/[ \t]FLT_DIG[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_MIN[ \t]/i\\\n+#ifndef DBL_MIN\n+'\\\n+      -e '/[ \t]DBL_MIN[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_MAX[ \t]/i\\\n+#ifndef DBL_MAX\n+'\\\n+      -e '/[ \t]DBL_MAX[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_DIG[ \t]/i\\\n+#ifndef DBL_DIG\n+'\\\n+      -e '/[ \t]DBL_DIG[ \t]/a\\\n+#endif\n+' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# The Irix unistd.h will introduce a call to __vfork in its libc, but the\n+# function is never actually prototyped.\n+file=unistd.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/__vfork/i\\\n+extern pid_t __vfork(void);'\\\n+     $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+exit 0"}, {"sha": "93a8f2c5d0e8e21b3dfb1bc4d6b887f47637b867", "filename": "gcc/fixinc/fixinc.ptx", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.ptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.ptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.ptx?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,257 @@\n+#! /bin/sh\n+# Install modified versions of certain ANSI-incompatible\n+# native Sequent DYNIX/ptx System V Release 3.2 system include files.\n+# Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n+# Contributed by Bill Burton <billb@progress.com>\n+# Portions adapted from fixinc.svr4 and fixincludes.\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\tThis script munges the native include files provided with DYNIX/ptx\n+#\tso as to remove things which are violations of the ANSI C standard.\n+#\tThis is done by first running fixinc.svr4 which does most of the\n+#\twork.  A few includes have fixes made to them afterwards  by this\n+#\tscript.  Once munged, the resulting new system include files are\n+#\tplaced in a directory that GNU C will search *before* searching the\n+#\t/usr/include directory. This script should work properly for most\n+#\tDYNIX/ptx systems.  For other types of systems, you should use the\n+#\t`fixincludes' script instead.\n+#\n+#\tSee README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+ \tLIB=$ORIG_DIR/$LIB\n+\t;;\n+esac\n+\n+echo 'Running fixinc.svr4'\n+# DYNIX/ptx has dirname so this is no problem\n+`dirname $0`/fixinc.svr4 $*\n+echo 'Finished fixinc.svr4'\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+# Copied from fixincludes.\n+# Don't use or define the name va_list in stdio.h.\n+# This is for ANSI and also to interoperate properly with gcc's varargs.h.\n+file=stdio.h\n+if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+  cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+  chmod +w ${LIB}/$file 2>/dev/null\n+  chmod a+r ${LIB}/$file 2>/dev/null\n+fi\n+\n+if [ -r ${LIB}/$file ]; then\n+  echo Fixing $file, use of va_list\n+  # Arrange for stdio.h to use stdarg.h to define __gnuc_va_list\n+  (echo \"#define __need___va_list\"\n+   echo \"#include <stdarg.h>\") > ${LIB}/${file}.sed\n+  # Use __gnuc_va_list in arg types in place of va_list.\n+  # On 386BSD use __gnuc_va_list instead of _VA_LIST_. We're hoping the\n+  # trailing parentheses and semicolon save all other systems from this.\n+  # Define __va_list__ (something harmless and unused) instead of va_list.\n+  # Don't claim to have defined va_list.\n+  sed -e 's@ va_list @ __gnuc_va_list @' \\\n+      -e 's@ va_list)@ __gnuc_va_list)@' \\\n+      -e 's@ _VA_LIST_));@ __gnuc_va_list));@' \\\n+      -e 's@ va_list@ __va_list__@' \\\n+      -e 's@\\*va_list@*__va_list__@' \\\n+      -e 's@ __va_list)@ __gnuc_va_list)@' \\\n+      -e 's@_NEED___VA_LIST@_NEED___Va_LIST@' \\\n+      -e 's@VA_LIST@DUMMY_VA_LIST@' \\\n+      -e 's@_NEED___Va_LIST@_NEED___VA_LIST@' \\\n+    ${LIB}/$file >> ${LIB}/${file}.sed\n+  \n+  rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+  if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+    rm -f ${LIB}/$file\n+  fi\n+fi\n+\n+# In pwd.h, PTX 1.x needs stdio.h included since FILE * was added in a\n+# prototype later on in the file.\n+file=pwd.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep stdio $file_to_fix > /dev/null; then\n+    true\n+  else\n+    sed -e '/#include <sys\\/types\\.h>/a\\\n+\\\n+#if defined(__STDC__) || defined(__cplusplus)\\\n+#include <stdio.h>\\\n+#endif  /* __STDC__ */\n+' \\\n+    $file_to_fix > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    echo Fixed $file_to_fix\n+  fi\n+fi\n+\n+# Copied from fixincludes.\n+# math.h puts the declaration of matherr before the definition\n+# of struct exception, so the prototype (added by fixproto) causes havoc.\n+file=math.h\n+if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+  cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+  chmod +w ${LIB}/$file 2>/dev/null\n+  chmod a+r ${LIB}/$file 2>/dev/null\n+fi\n+\n+if [ -r ${LIB}/$file ]; then\n+  echo Fixing $file, matherr declaration\n+  sed -e '/^struct exception/,$b' \\\n+      -e '/matherr/i\\\n+struct exception;\n+'\\\n+    ${LIB}/$file > ${LIB}/${file}.sed\n+  rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+  if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+    rm -f ${LIB}/$file\n+  fi\n+fi\n+\n+# In netinet/in.h, the network byte swapping asm functions supported by the\n+# native cc compiler on PTX 1.x and 2.x is not supported in gcc.  Instead,\n+# include <sys/byteorder.h> written out by the fixinc.svr4 script which has\n+# these same routines written in an asm format supported by gcc.\n+file=netinet/in.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep __GNUC__ $file_to_fix > /dev/null; then\n+    true\n+  else\n+    sed -e '/#define NETSWAP/a\\\n+\\\n+#if defined (__GNUC__) || defined (__GNUG__)\\\n+#include <sys/byteorder.h>\\\n+#else  /* not __GNUC__ */\n+' \\\n+    -e '/#endif[ \t]*\\/\\* NETSWAP \\*\\//i\\\n+#endif /* not __GNUC__ */\n+' \\\n+    $file_to_fix > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    echo Fixed $file_to_fix\n+  fi\n+fi\n+\n+# /usr/include/sys/mc_param.h has an embedded asm for the cpuid instruction\n+# on the P5. This is not used by anything else so we ifdef it out.\n+file=sys/mc_param.h\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep __GNUC__ $file_to_fix > /dev/null; then\n+    true\n+  else\n+    sed -e '/__asm/,/}/{\n+/__asm/i\\\n+#if !defined (__GNUC__) && !defined (__GNUG__)\n+/}/a\\\n+#endif\n+}' \\\n+    $file_to_fix > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    echo Fixed $file_to_fix\n+  fi\n+fi\n+\n+# /usr/include/sys/mc_param.h has an embedded asm for the cpuid instruction\n+# on the P5. This is not used by anything else so we ifdef it out.\n+file=sys/mc_param.h\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep __GNUC__ $file_to_fix > /dev/null; then\n+    true\n+  else\n+    sed -e '/__asm/,/}/{\n+/__asm/i\\\n+#if !defined (__GNUC__) && !defined (__GNUG__)\n+/}/a\\\n+#endif\n+}' \\\n+    $file_to_fix > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    echo Fixed $file_to_fix\n+  fi\n+fi\n+\n+exit 0\n+"}, {"sha": "205a8822af1d60f4f85feffb22488d29cf8316ff", "filename": "gcc/fixinc/fixinc.sco", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.sco", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.sco", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.sco?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,427 @@\n+#! /bin/sh\n+#\n+#   fixinc.sco  --  Install modified versions of SCO system include\n+#   files.\n+#\n+#   Based on fixinc.svr4 script by Ron Guilmette (rfg@ncd.com) (SCO\n+#   modifications by Ian Lance Taylor (ian@airs.com)).\n+#\n+# Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\tThis script munges the native include files provided with SCO\n+#\t3.2v4 systems so as to provide a reasonable namespace when\n+#\tcompiling with gcc.  The header files by default do not\n+#\tprovide many essential definitions and declarations if\n+#\t__STDC__ is 1.  This script modifies the header files to check\n+#\tfor __STRICT_ANSI__ being defined instead.  Once munged, the\n+#\tresulting new system include files are placed in a directory\n+#\tthat GNU C will search *before* searching the /usr/include\n+#\tdirectory.  This script should work properly for most SCO\n+#\t3.2v4 systems.  For other types of systems, you should use the\n+#\t`fixincludes' or the `fixinc.svr4' script instead.\n+#\n+#\tSee README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+\tcd $LIB; LIB=`${PWDCMD-pwd}`\n+\t;;\n+esac\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+# Determine whether this filesystem has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+\n+echo 'Making directories:'\n+cd ${INPUT}\n+if $LINKS; then\n+  files=`ls -LR | sed -n s/:$//p`\n+else\n+  files=`find . -type d -print | sed '/^.$/d'`\n+fi\n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic directory links'\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if [ \"$dest\" ]; then    \n+      cwd=`pwd`\n+      # In case $dest is relative, get to $file's dir first.\n+      cd ${INPUT}\n+      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n+      # Check that the target directory exists.\n+      # Redirections changed to avoid bug in sh on Ultrix.\n+      (cd $dest) > /dev/null 2>&1\n+      if [ $? = 0 ]; then\n+\tcd $dest\n+\t# X gets the dir that the link actually leads to.\n+\tx=`pwd`\n+\t# If link leads back into ${INPUT},\n+\t# make a similar link here.\n+\tif expr $x : \"${INPUT}/.*\" > /dev/null; then\n+\t  # Y gets the actual target dir name, relative to ${INPUT}.\n+\t  y=`echo $x | sed -n \"s&${INPUT}/&&p\"`\n+\t  echo $file '->' $y ': Making link'\n+\t  rm -fr ${LIB}/$file > /dev/null 2>&1\n+\t  ln -s ${LIB}/$y ${LIB}/$file > /dev/null 2>&1\n+\telse\n+\t  # If the link is to outside ${INPUT},\n+\t  # treat this directory as if it actually contained the files.\n+# This line used to have $dest instead of $x.\n+# $dest seemed to be wrong for links found in subdirectories\n+# of ${INPUT}.  Does this change break anything?\n+\t  treetops=\"$treetops $x ${LIB}/$file\"\n+\tfi\n+      fi\n+      cd $cwd\n+    fi\n+  done\n+fi\n+\n+set - $treetops\n+while [ $# != 0 ]; do\n+  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n+  echo \"Finding header files in $1:\"\n+  cd ${INPUT}\n+  cd $1\n+  files=`find . -name '*.h' -type f -print`\n+  echo 'Checking header files:'\n+  for file in $files; do\n+    if egrep '!__STDC__' $file >/dev/null; then\n+      if [ -r $file ]; then\n+\tcp $file $2/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+\tchmod +w $2/$file\n+\tchmod a+r $2/$file\n+\n+# The following have been removed from the sed command below\n+# because it is more useful to leave these things in.\n+# The only reason to remove them was for -pedantic,\n+# which isn't much of a reason. -- rms.\n+#\t  /^[ \t]*#[ \t]*ident/d\n+\n+\tsed -e '\n+\t  s/!__STDC__/!defined (__STRICT_ANSI__)/g\n+\t' $2/$file > $2/$file.sed\n+\tmv $2/$file.sed $2/$file\n+\tif cmp $file $2/$file >/dev/null 2>&1; then\n+\t   rm $2/$file\n+\telse\n+\t   echo Fixed $file\n+\tfi\n+      fi\n+    fi\n+  done\n+  shift; shift\n+done\n+\n+# We shouldn't stay in the directory we just copied.\n+cd ${INPUT}\n+\n+# Fix first broken decl of getcwd present on some svr4 systems.\n+\n+file=stdlib.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\{0,\\}\\*, int)/getcwd(char *, size_t)/' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix second broken decl of getcwd present on some svr4 systems.  Also\n+# fix the incorrect decl of profil present on some svr4 systems.\n+\n+file=unistd.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\*, int)/getcwd(char *, size_t)/' $file_to_fix \\\n+    | sed -e 's/profil(unsigned short \\*, unsigned int, unsigned int, unsigned int)/profil(unsigned short *, size_t, int, unsigned)/' > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix third broken decl of getcwd on SCO.  Also fix incorrect decl of\n+# link.\n+file=prototypes.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\*, int)/getcwd(char *, size_t)/' $file_to_fix \\\n+    | sed -e 's/const  int\tlink(const char \\*, char \\*)/extern  int\tlink(const char *, const char *)/' > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix an error in this file: the #if says _cplusplus, not the double\n+# underscore __cplusplus that it should be\n+file=tinfo.h\n+if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+  mkdir ${LIB}/rpcsvc 2>/dev/null\n+  cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+  chmod +w ${LIB}/$file 2>/dev/null\n+  chmod a+r ${LIB}/$file 2>/dev/null\n+fi\n+\n+if [ -r ${LIB}/$file ]; then\n+  echo Fixing $file, __cplusplus macro\n+  sed -e 's/[ \t]_cplusplus/ __cplusplus/' ${LIB}/$file > ${LIB}/${file}.sed\n+  rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+  if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+    rm ${LIB}/$file\n+  fi\n+fi\n+\n+# Fix prototype declaration of utime in sys/times.h.  In 3.2v4.0 the\n+# const is missing.\n+file=sys/times.h\n+if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+  cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+  chmod +w ${LIB}/$file 2>/dev/null\n+  chmod a+r ${LIB}/$file 2>/dev/null\n+fi\n+\n+if [ -r ${LIB}/$file ]; then\n+  echo Fixing $file, utime prototype\n+  sed -e 's/(const char \\*, struct utimbuf \\*);/(const char *, const struct utimbuf *);/' ${LIB}/$file > ${LIB}/${file}.sed\n+  rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+  if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+    rm ${LIB}/$file\n+  fi\n+fi\n+\n+# This function is borrowed from fixinclude.svr4\n+# The OpenServer math.h defines struct exception, which conflicts with\n+# the class exception defined in the C++ file std/stdexcept.h.  We\n+# redefine it to __math_exception.  This is not a great fix, but I\n+# haven't been able to think of anything better.\n+#\n+# OpenServer's math.h declares abs as inline int abs...  Unfortunately,\n+# we blow over that one (with C++ linkage) and stick a new one in stdlib.h\n+# with C linkage.   So we eat the one out of math.h.\n+file=math.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/struct exception/i\\\n+#ifdef __cplusplus\\\n+#define exception __math_exception\\\n+#endif'\\\n+      -e '/struct exception/a\\\n+#ifdef __cplusplus\\\n+#undef exception\\\n+#endif' \\\n+      -e 's@inline int abs(int [a-z][a-z]*) {.*}@extern \"C\" int abs(int);@' \\\n+ $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+#\n+# Also, the static functions lstat() and fchmod() in <sys/stat.h> \n+# cause G++ grief since they're not wrapped in \"if __cplusplus\".   \n+# Fix that up now.\n+#\n+file=sys/stat.h\n+if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+  cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+  chmod +w ${LIB}/$file 2>/dev/null\n+  chmod a+r ${LIB}/$file 2>/dev/null\n+fi\n+\n+if [ -r ${LIB}/$file ]; then\n+  echo Fixing $file, static definitions not C++-aware.\n+  sed -e '/^static int[ \t]*/i\\\n+#if __cplusplus\\\n+extern \"C\"\\\n+{\\\n+#endif /* __cplusplus */ \\\n+' \\\n+-e '/^}$/a\\\n+#if __cplusplus\\\n+}\\\n+#endif /* __cplusplus */ \\\n+' ${LIB}/$file > ${LIB}/${file}.sed\n+  rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+  if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+    rm -f ${LIB}/$file\n+  fi\n+fi\n+\n+# This fix has the regex modified from the from fixinc.wrap\n+# Avoid the definition of the bool type in the following files when using\n+# g++, since it's now an official type in the C++ language.\n+for file in term.h tinfo.h\n+do\n+  if [ -r $INPUT/$file ]; then\n+    echo Checking $INPUT/$file\n+    w='[\t ]'\n+    if grep \"typedef$w.*char$w.*bool$w*;\" $INPUT/$file >/dev/null\n+    then\n+      echo Fixed $file\n+      rm -f $LIB/$file\n+      cat <<'__EOF__' >$LIB/$file\n+#ifndef _CURSES_H_WRAPPER\n+#ifdef __cplusplus\n+# define bool __curses_bool_t\n+#endif\n+#include_next <curses.h>\n+#ifdef __cplusplus\n+# undef bool\n+#endif\n+#define _CURSES_H_WRAPPER\n+#endif /* _CURSES_H_WRAPPER */\n+__EOF__\n+      # Define _CURSES_H_WRAPPER at the end of the wrapper, not the start,\n+      # so that if #include_next gets another instance of the wrapper,\n+      # this will follow the #include_next chain until we arrive at\n+      # the real <curses.h>.\n+      chmod a+r $LIB/$file\n+    fi\n+  fi\n+done\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > /dev/null 2>&1\n+done\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic non-directory links'\n+  cd ${INPUT}\n+  files=`find . -type l -print`\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if expr \"$dest\" : '[^/].*' > /dev/null; then    \n+      target=${LIB}/`echo file | sed \"s|[^/]*\\$|$dest|\"`\n+      if [ -f $target ]; then\n+        ln -s $dest ${LIB}/$file >/dev/null 2>&1\n+      fi\n+    fi\n+  done\n+fi\n+\n+exit 0"}, {"sha": "46e07ce0ac9fc508f8a929a261a972ed7acfbc4e", "filename": "gcc/fixinc/fixinc.svr4", "status": "added", "additions": 1726, "deletions": 0, "changes": 1726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.svr4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.svr4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.svr4?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,1726 @@\n+#! /bin/sh\n+# Install modified versions of certain ANSI-incompatible\n+# native System V Release 4 system include files.\n+# Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n+# Contributed by Ron Guilmette (rfg@monkeys.com).\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\tThis script munges the native include files provided with System V\n+#\tRelease 4 systems so as to remove things which are violations of the\n+#\tANSI C standard.  Once munged, the resulting new system include files\n+#\tare placed in a directory that GNU C will search *before* searching\n+#\tthe /usr/include directory. This script should work properly for most\n+#\tSystem V Release 4 systems.  For other types of systems, you should\n+#\tuse the `fixincludes' script instead.\n+#\n+#\tSee README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+ \tLIB=$ORIG_DIR/$LIB\n+\t;;\n+esac\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+# Determine whether this filesystem has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+\n+echo 'Making directories:'\n+cd ${INPUT}\n+if $LINKS; then\n+  files=`find . -follow -type d -print 2>/dev/null | sed '/^.$/d'`\n+else\n+  files=`find . -type d -print | sed '/^.$/d'`\n+fi\n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic directory links'\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if [ \"$dest\" ]; then    \n+      cwd=`pwd`\n+      # In case $dest is relative, get to $file's dir first.\n+      cd ${INPUT}\n+      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n+      rwd=`pwd`\n+      # Check that the target directory exists.\n+      # Redirections changed to avoid bug in sh on Ultrix.\n+      (cd $dest) > /dev/null 2>&1\n+      if [ $? = 0 ]; then\n+\tcd $dest\n+\t# X gets the dir that the link actually leads to.\n+\tx=`pwd`\n+\t# If link leads back into ${INPUT},\n+\t# make a similar link here.\n+        if expr \"$dest\" : '[^/][^/]*' >/dev/null && [ ! -h $dest ]; then\n+          echo $file '->'  $dest': Making link'\n+          rm -fr ${LIB}/$file > /dev/null 2>&1\n+          ln -s $dest ${LIB}/$file > /dev/null 2>&1\n+\telif expr $x : \"${INPUT}/.*\" > /dev/null; then\n+\t  # Y gets the actual target dir name, relative to ${INPUT}.\n+\t  y=`echo $x | sed -n \"s&${INPUT}/&&p\"`\n+\t  # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+\t  dots=`echo \"$file\" |\n+\t    sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+\t  echo $file '->' $dots$y ': Making link'\n+\t  rm -fr ${LIB}/$file > /dev/null 2>&1\n+\t  ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n+\telif expr $x : \"${rwd}/.*\" > /dev/null; then\n+\t  # Y gets the actual target dir name, relative to the directory where the link is.\n+\t  y=`echo $x | sed -n \"s&${rwd}/&&p\"`\n+\t  # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+\t  dots=`echo \"$file\" |\n+\t    sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+\t  echo $file '->' $dots$y ': Making link'\n+\t  rm -fr ${LIB}/$file > /dev/null 2>&1\n+\t  ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n+\telse\n+\t  # If the link is to outside ${INPUT},\n+\t  # treat this directory as if it actually contained the files.\n+# This line used to have $dest instead of $x.\n+# $dest seemed to be wrong for links found in subdirectories\n+# of ${INPUT}.  Does this change break anything?\n+\t  treetops=\"$treetops $x ${LIB}/$file\"\n+\tfi\n+      fi\n+      cd $cwd\n+    fi\n+  done\n+fi\n+\n+set - $treetops\n+while [ $# != 0 ]; do\n+  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n+  echo \"Finding header files in $1:\"\n+  cd ${INPUT}\n+  cd $1\n+  files=`find . -name '*.h' -type f -print`\n+  echo 'Checking header files:'\n+  for file in $files; do\n+      if [ -r $file ]; then\n+\tcp $file $2/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+\tchmod +w $2/$file\n+\tchmod a+r $2/$file\n+\n+# The following have been removed from the sed command below\n+# because it is more useful to leave these things in.\n+# The only reason to remove them was for -pedantic,\n+# which isn't much of a reason. -- rms.\n+#\t  /^[ \t]*#[ \t]*ident/d\n+\n+# This code makes Solaris SCSI fail, because it changes the\n+# alignment within some critical structures.  See <sys/scsi/impl/commands.h>.\n+#\t  s/u_char\\([ \t][ \t]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ \t]*:[ \t]*[0-9][0-9]*\\)/u_int\\1/\n+# Disable these also, since they probably aren't safe either.\n+#\t  s/u_short\\([ \t][ \t]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ \t]*:[ \t]*[0-9][0-9]*\\)/u_int\\1/\n+#\t  s/ushort\\([ \t][ \t]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ \t]*:[ \t]*[0-9][0-9]*\\)/u_int\\1/\n+#\t  s/evcm_t\\([ \t][ \t]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ \t]*:[ \t]*[0-9][0-9]*\\)/u_int\\1/\n+#\t  s/Pbyte\\([ \t][ \t]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ \t]*:[ \t]*SEQSIZ\\)/unsigned int\\1/\n+\n+# The change of u_char, etc, to u_int\n+# applies to bit fields.\n+\tsed -e '\n+\t  s%^\\([ \t]*#[ \t]*else\\)[ \t]*/[^*].*%\\1%\n+\t  s%^\\([ \t]*#[ \t]*else\\)[ \t]*[^/ \t].*%\\1%\n+\t  s%^\\([ \t]*#[ \t]*endif\\)[ \t]*/[^*].*%\\1%\n+\t  s%^\\([ \t]*#[ \t]*endif\\)[ \t]*[^/ \t].*%\\1%\n+  \t  s/#lint(on)/defined(lint)/g\n+  \t  s/#lint(off)/!defined(lint)/g\n+  \t  s/#machine(\\([^)]*\\))/defined(__\\1__)/g\n+  \t  s/#system(\\([^)]*\\))/defined(__\\1__)/g\n+  \t  s/#cpu(\\([^)]*\\))/defined(__\\1__)/g\n+\t  /#[a-z]*if.*[\t (]m68k/\t\ts/\\([^_]\\)m68k/\\1__m68k__/g\n+\t  /#[a-z]*if.*[\t (]__i386\\([^_]\\)/\ts/__i386/__i386__/g\n+\t  /#[a-z]*if.*[\t (]i386/\t\ts/\\([^_]\\)i386/\\1__i386__/g\n+\t  /#[a-z]*if.*[\t (!]__i860\\([^_]\\)/\ts/__i860/__i860__/g\n+\t  /#[a-z]*if.*[\t (!]i860/\t\ts/\\([^_]\\)i860/\\1__i860__/g\n+\t  /#[a-z]*if.*[\t (]sparc/\ts/\\([^_]\\)sparc/\\1__sparc__/g\n+\t  /#[a-z]*if.*[\t (]mc68000/\ts/\\([^_]\\)mc68000/\\1__mc68000__/g\n+\t  /#[a-z]*if.*[\t (]vax/\t\ts/\\([^_]\\)vax/\\1__vax__/g\n+\t  /#[a-z]*if.*[\t (]sun/\t\ts/\\([^_]\\)\\(sun[a-z0-9]*\\)\\([^a-z0-9_]\\)/\\1__\\2__\\3/g\n+\t  /#[a-z]*if.*[\t (]sun/\t\ts/\\([^_]\\)\\(sun[a-z0-9]*\\)$/\\1__\\2__/g\n+\t  /#[a-z]*if.*[\t (]ns32000/\ts/\\([^_]\\)ns32000/\\1__ns32000__/g\n+\t  /#[a-z]*if.*[\t (]pyr/\t\ts/\\([^_]\\)pyr/\\1__pyr__/g\n+\t  /#[a-z]*if.*[\t (]is68k/\ts/\\([^_]\\)is68k/\\1__is68k__/g\n+\t  s/__STDC__[ \t][ \t]*==[ \t][ \t]*0/!defined (__STRICT_ANSI__)/g\n+\t  s/__STDC__[ \t][ \t]*==[ \t][ \t]*1/defined (__STRICT_ANSI__)/g\n+\t  s/__STDC__[ \t][ \t]*!=[ \t][ \t]*0/defined (__STRICT_ANSI__)/g\n+\t  s/__STDC__[ \t][ \t]*!=[ \t][ \t]*1/!defined (__STRICT_ANSI__)/g\n+\t  s/__STDC__ - 0 == 0/!defined (__STRICT_ANSI__)/g\n+\t  s/__STDC__ - 0 == 1/defined (__STRICT_ANSI__)/g\n+\t  /^typedef[ \t][ \t]*[unsigned \t]*long[ \t][ \t]*[u_]*longlong_t;/s/long/long long/\n+\t' $2/$file > $2/$file.sed\n+\tmv $2/$file.sed $2/$file\n+\tif cmp $file $2/$file >/dev/null 2>&1; then\n+\t   rm $2/$file\n+\telse\n+\t   echo Fixed $file\n+\tfi\n+      fi\n+  done\n+  shift; shift\n+done\n+\n+# Install the proper definition of the three standard types in header files\n+# that they come from.\n+for file in sys/types.h stdlib.h sys/stdtypes.h stddef.h memory.h unistd.h; do\n+  if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+    cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+    chmod +w ${LIB}/$file 2>/dev/null\n+    chmod a+r ${LIB}/$file 2>/dev/null\n+  fi\n+\n+  if [ -r ${LIB}/$file ]; then\n+    echo Fixing size_t, ptrdiff_t and wchar_t in $file\n+    sed \\\n+      -e '/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]size_t/i\\\n+#ifndef __SIZE_TYPE__\\\n+#define __SIZE_TYPE__ long unsigned int\\\n+#endif\n+' \\\n+      -e 's/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]size_t/typedef __SIZE_TYPE__ size_t/' \\\n+      -e '/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]ptrdiff_t/i\\\n+#ifndef __PTRDIFF_TYPE__\\\n+#define __PTRDIFF_TYPE__ long int\\\n+#endif\n+' \\\n+      -e 's/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]ptrdiff_t/typedef __PTRDIFF_TYPE__ ptrdiff_t/' \\\n+      -e '/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]wchar_t/i\\\n+#ifndef __WCHAR_TYPE__\\\n+#define __WCHAR_TYPE__ int\\\n+#endif\n+' \\\n+      -e 's/typedef[ \t][ \t]*[a-z_][ \ta-z_]*[ \t]wchar_t/typedef __WCHAR_TYPE__ wchar_t/' \\\n+      ${LIB}/$file > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    if cmp $file ${LIB}/$file >/dev/null 2>&1; then\n+      rm ${LIB}/$file\n+    fi\n+  fi\n+done\n+\n+# Fix first broken decl of getcwd present on some svr4 systems.\n+\n+file=stdlib.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\*, int)/getcwd(char *, size_t)/' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix second broken decl of getcwd present on some svr4 systems.  Also\n+# fix the incorrect decl of profil present on some svr4 systems.\n+\n+file=unistd.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\*, int)/getcwd(char *, size_t)/' $file_to_fix \\\n+    | sed -e 's/profil(unsigned short \\*, unsigned int, unsigned int, unsigned int)/profil(unsigned short *, size_t, int, unsigned)/' > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix the definition of NULL in <sys/param.h> so that it is conditional\n+# and so that it is correct for both C and C++.\n+\n+file=sys/param.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  chmod a+r /tmp/$base\n+  sed -e '/^#define[ \t]*NULL[ \t]*0$/c\\\n+#ifndef NULL\\\n+#ifdef __cplusplus\\\n+#define __NULL_TYPE\\\n+#else /* !defined(__cplusplus) */\\\n+#define __NULL_TYPE (void *)\\\n+#endif /* !defined(__cplusplus) */\\\n+#define NULL (__NULL_TYPE 0)\\\n+#endif /* !defined(NULL) */' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Likewise fix the definition of NULL in <stdio.h> so that it is conditional\n+# and so that it is correct for both C and C++.\n+\n+file=stdio.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^#define[ \t]*NULL[ \t]*0$/c\\\n+#ifdef __cplusplus\\\n+#define __NULL_TYPE\\\n+#else /* !defined(__cplusplus) */\\\n+#define __NULL_TYPE (void *)\\\n+#endif /* !defined(__cplusplus) */\\\n+#define NULL (__NULL_TYPE 0)' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Likewise fix the definition of NULL in <dbm.h> so that it is conditional\n+# and so that it is correct for both C and C++.\n+\n+file=dbm.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^#define[ \t]*NULL[ \t]*((char \\*) 0)$/c\\\n+#ifndef NULL\\\n+#ifdef __cplusplus\\\n+#define __NULL_TYPE\\\n+#else /* !defined(__cplusplus) */\\\n+#define __NULL_TYPE (void *)\\\n+#endif /* !defined(__cplusplus) */\\\n+#define NULL (__NULL_TYPE 0)\\\n+#endif /* !defined(NULL) */' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Add a prototyped declaration of mmap to <sys/mman.h>.\n+\n+file=sys/mman.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^extern caddr_t mmap();$/c\\\n+#ifdef __STDC__\\\n+extern caddr_t mmap (caddr_t, size_t, int, int, int, off_t);\\\n+#else /* !defined(__STDC__) */\\\n+extern caddr_t mmap ();\\\n+#endif /* !defined(__STDC__) */' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Fix declarations of `ftw' and `nftw' in <ftw.h>.  On some/most SVR4 systems\n+# the file <ftw.h> contains extern declarations of these functions followed\n+# by explicitly `static' definitions of these functions... and that's not\n+# allowed according to ANSI C.  (Note however that on Solaris, this header\n+# file glitch has been pre-fixed by Sun.  In the Solaris version of <ftw.h>\n+# there are no static definitions of any function so we don't need to do\n+# any of this stuff when on Solaris.\n+\n+file=ftw.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if test -z \"$file_to_fix\" || grep 'define\tftw' $file_to_fix > /dev/null; then\n+# Either we have no <ftw.h> file at all, or else we have the pre-fixed Solaris\n+# one.  Either way, we don't have to do anything.\n+  true\n+else\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^extern int ftw(const/i\\\n+#if !defined(_STYPES)\\\n+static\\\n+#else\\\n+extern\\\n+#endif\n+'\\\n+  -e 's/extern \\(int ftw(const.*\\)$/\\1/' \\\n+  -e '/^extern int nftw/i\\\n+#if defined(_STYPES)\\\n+static\\\n+#else\\\n+extern\\\n+#endif\n+'\\\n+  -e 's/extern \\(int nftw.*\\)$/\\1/' \\\n+  -e '/^extern int ftw(),/c\\\n+#if !defined(_STYPES)\\\n+static\\\n+#else\\\n+extern\\\n+#endif\\\n+  int ftw();\\\n+#if defined(_STYPES)\\\n+static\\\n+#else\\\n+extern\\\n+#endif\\\n+  int nftw();' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Avoid the definition of the bool type in the Solaris 2.x curses.h when using\n+# g++, since it's now an official type in the C++ language.\n+file=curses.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e 's,^typedef[ \t]char[ \t]bool;$,#ifndef __cplusplus\\\n+typedef\tchar bool;\\\n+#endif /* !defined __cplusplus */,' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Add a `static' declaration of `getrnge' into <regexp.h>.\n+\n+# Don't do this if there is already a `static void getrnge' declaration\n+# present, since this would cause a redeclaration error.  Solaris 2.x has\n+# such a declaration.\n+\n+file=regexp.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep \"static void getrnge\" $file_to_fix > /dev/null; then\n+    true\n+  else\n+    cp $file_to_fix /tmp/$base\n+    chmod +w /tmp/$base\n+    sed -e '/^static int[ \t]*size;/c\\\n+static int\tsize ;\\\n+\\\n+static int getrnge ();' /tmp/$base > /tmp/$base.sed\n+    if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+      true\n+    else\n+      echo Fixed $file_to_fix\n+      rm -f ${LIB}/$file\n+      cp /tmp/$base.sed ${LIB}/$file\n+      chmod a+r ${LIB}/$file\n+    fi\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Disable apparent native compiler optimization cruft in SVR4.2 <string.h>\n+# that is visible to any ANSI compiler using this include.  Simply\n+# delete the lines that #define some string functions to internal forms.\n+\n+file=string.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/#define.*__std_hdr_/d' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Delete any #defines of `__i386' which may be present in <ieeefp.h>.  They\n+# tend to conflict with the compiler's own definition of this symbol.  (We\n+# will use the compiler's definition.)\n+# Likewise __sparc, for Solaris, and __i860, and a few others\n+# (guessing it is necessary for all of them).\n+\n+file=ieeefp.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/#define[ \t]*__i386 /d' -e '/#define[ \t]*__sparc /d' \\\n+      -e '/#define[ \t]*__i860 /d' -e '/#define[ \t]*__m88k /d' \\\n+      -e '/#define[ \t]*__mips /d' -e '/#define[ \t]*__m68k /d' \\\n+     /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix \n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file \n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed \n+fi \n+\n+# Add a #define of _SIGACTION_ into <sys/signal.h>.\n+# Also fix types of SIG_DFL, SIG_ERR, SIG_IGN, and SIG_HOLD.\n+\n+file=sys/signal.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^struct sigaction {/c\\\n+#define _SIGACTION_\\\n+struct  sigaction  {' \\\n+  -e '1,$s/(void *(\\*)())/(void (*)(int))/' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Fix declarations of `makedev', `major', and `minor' in <sys/mkdev.h>.\n+\n+file=sys/mkdev.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^dev_t makedev(const/c\\\n+static dev_t makedev(const major_t, const minor_t);' \\\n+  -e '/^dev_t makedev()/c\\\n+static dev_t makedev();' \\\n+  -e '/^major_t major(const/c\\\n+static major_t major(const dev_t);' \\\n+  -e '/^major_t major()/c\\\n+static major_t major();' \\\n+  -e '/^minor_t minor(const/c\\\n+static minor_t minor(const dev_t);' \\\n+  -e '/^minor_t minor()/c\\\n+static minor_t minor();' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Fix reference to NMSZ in <sys/adv.h>.\n+\n+file=sys/adv.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed 's/\\[NMSZ\\]/\\[RFS_NMSZ\\]/g' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Fix reference to NC_NPI_RAW in <sys/netcspace.h>.  Also fix types of\n+# array initializers.\n+\n+file=sys/netcspace.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed 's/NC_NPI_RAW/NC_TPI_RAW/g' $file_to_fix \\\n+    | sed 's/NC_/(unsigned long) NC_/' > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Conditionalize all of <fs/rfs/rf_cache.h> on _KERNEL being defined.\n+\n+file=fs/rfs/rf_cache.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/erec.h> on _KERNEL being defined.\n+\n+file=sys/erec.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/err.h> on _KERNEL being defined.\n+\n+file=sys/err.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/char.h> on _KERNEL being defined.\n+\n+file=sys/char.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/getpages.h> on _KERNEL being defined.\n+\n+file=sys/getpages.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/map.h> on _KERNEL being defined.\n+\n+file=sys/map.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/cmn_err.h> on _KERNEL being defined.\n+\n+file=sys/cmn_err.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize all of <sys/kdebugger.h> on _KERNEL being defined.\n+\n+file=sys/kdebugger.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep _KERNEL $file_to_fix > /dev/null; then\n+    true\n+  else\n+    echo '#ifdef _KERNEL' > /tmp/$base\n+    cat $file_to_fix >> /tmp/$base\n+    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+    rm -f /tmp/$base\n+  fi\n+fi\n+\n+# Conditionalize some of <netinet/in.h> on _KERNEL being defined.\n+# This has been taken out because it breaks on some versions of\n+# DYNIX/ptx, and it does not seem to do much good on any system.\n+# file=netinet/in.h\n+# base=`basename $file`\n+# if [ -r ${LIB}/$file ]; then\n+#   file_to_fix=${LIB}/$file\n+# else\n+#   if [ -r ${INPUT}/$file ]; then\n+#     file_to_fix=${INPUT}/$file\n+#   else\n+#     file_to_fix=\"\"\n+#   fi\n+# fi\n+# if [ \\! -z \"$file_to_fix\" ]; then\n+#   echo Checking $file_to_fix\n+#   if grep _KERNEL $file_to_fix > /dev/null; then\n+#     true\n+#   else\n+#     sed -e '/#ifdef INKERNEL/i\\\n+# #ifdef _KERNEL\n+# ' \\\n+#     -e '/#endif[ \t]*\\/\\* INKERNEL \\*\\//a\\\n+# #endif /* _KERNEL */\n+# ' \\\n+#     $file_to_fix > ${LIB}/${file}.sed\n+#     rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+#     echo Fixed $file_to_fix\n+#   fi\n+# fi\n+\n+# Conditionalize some of <sys/endian.h> on __GNUC__ and __GNUG__.\n+\n+file=sys/endian.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  if grep __GNUC__ $file_to_fix > /dev/null; then\n+    true\n+  else\n+    sed -e '/#\tifdef\t__STDC__/i\\\n+#   if !defined (__GNUC__) && !defined (__GNUG__)\n+' \\\n+    -e '/#\t\tinclude\t<sys\\/byteorder.h>/s/\t\t/   /'\\\n+    -e '/#   include\t<sys\\/byteorder.h>/i\\\n+#   endif /* !defined (__GNUC__) && !defined (__GNUG__) */\n+'\\\n+    $file_to_fix > ${LIB}/${file}.sed\n+    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+    echo Fixed $file_to_fix\n+  fi\n+fi\n+\n+# Commented out because tmcconne@sedona.intel.com says we don't clearly need it\n+# and the text in types.h is not erroneous.\n+## In sys/types.h, don't name the enum for booleans.\n+#\n+#file=sys/types.h\n+#base=`basename $file`\n+#if [ -r ${LIB}/$file ]; then\n+#  file_to_fix=${LIB}/$file\n+#else\n+#  if [ -r ${INPUT}/$file ]; then\n+#    file_to_fix=${INPUT}/$file\n+#  else\n+#    file_to_fix=\"\"\n+#  fi\n+#fi\n+#if [ \\! -z \"$file_to_fix\" ]; then\n+#  echo Checking $file_to_fix\n+#  if grep \"enum boolean\" $file_to_fix > /dev/null; then\n+#    sed -e 's/enum boolean/enum/' ${LIB}/$file > ${LIB}/${file}.sed\n+#    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n+#    echo Fixed $file_to_fix\n+#  else\n+#    true\n+#  fi\n+#fi\n+\n+# Remove useless extern keyword from struct forward declarations in\n+# <sys/stream.h> and <sys/strsubr.h>\n+\n+file=sys/stream.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '\n+    s/extern struct stdata;/struct stdata;/g\n+    s/extern struct strevent;/struct strevent;/g\n+  ' $file_to_fix > /tmp/$base \n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+file=sys/strsubr.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '\n+    s/extern struct strbuf;/struct strbuf;/g\n+    s/extern struct uio;/struct uio;/g\n+    s/extern struct thread;/struct thread;/g\n+    s/extern struct proc;/struct proc;/g\n+  ' $file_to_fix > /tmp/$base \n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Put storage class at start of decl, to avoid warning.\n+file=rpc/types.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '\n+    s/const extern/extern const/g\n+  ' $file_to_fix > /tmp/$base \n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Convert functions to prototype form, and fix arg names in <sys/stat.h>.\n+\n+file=sys/stat.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  cp $file_to_fix /tmp/$base\n+  chmod +w /tmp/$base\n+  sed -e '/^stat([ \t]*[^c]/{\n+N\n+N\n+s/(.*)\\n/( /\n+s/;\\n/, /\n+s/;$/)/\n+}' \\\n+  -e '/^lstat([ \t]*[^c]/{\n+N\n+N\n+s/(.*)\\n/( /\n+s/;\\n/, /\n+s/;$/)/\n+}' \\\n+  -e '/^fstat([ \t]*[^i]/{\n+N\n+N\n+s/(.*)\\n/( /\n+s/;\\n/, /\n+s/;$/)/\n+}' \\\n+  -e '/^mknod([ \t]*[^c]/{\n+N\n+N\n+N\n+s/(.*)\\n/( /\n+s/;\\n/, /g\n+s/;$/)/\n+}' \\\n+  -e '1,$s/\\([^A-Za-z]\\)path\\([^A-Za-z]\\)/\\1__path\\2/g' \\\n+  -e '1,$s/\\([^A-Za-z]\\)buf\\([^A-Za-z]\\)/\\1__buf\\2/g' \\\n+  -e '1,$s/\\([^A-Za-z]\\)fd\\([^A-Za-z]\\)/\\1__fd\\2/g' \\\n+  -e '1,$s/ret\\([^u]\\)/__ret\\1/g' \\\n+  -e '1,$s/\\([^_]\\)mode\\([^_]\\)/\\1__mode\\2/g' \\\n+  -e '1,$s/\\([^_r]\\)dev\\([^_]\\)/\\1__dev\\2/g' /tmp/$base > /tmp/$base.sed\n+  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base.sed ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base /tmp/$base.sed\n+fi\n+\n+# Sony NEWSOS 5.0 does not support the complete ANSI C standard.\n+\n+if [ -x /bin/sony ]; then\n+  if /bin/sony; then\n+\n+    # Change <stdio.h> to not define __filbuf, __flsbuf, and __iob\n+\n+    file=stdio.h\n+    base=`basename $file`\n+    if [ -r ${LIB}/$file ]; then\n+      file_to_fix=${LIB}/$file\n+    else\n+      if [ -r ${INPUT}/$file ]; then\n+        file_to_fix=${INPUT}/$file\n+      else\n+        file_to_fix=\"\"\n+      fi\n+    fi\n+    if [ \\! -z \"$file_to_fix\" ]; then\n+      echo Checking $file_to_fix\n+      cp $file_to_fix /tmp/$base\n+      chmod +w /tmp/$base\n+      sed -e '\n+        s/__filbuf/_filbuf/g\n+        s/__flsbuf/_flsbuf/g\n+        s/__iob/_iob/g\n+      ' /tmp/$base > /tmp/$base.sed\n+      mv /tmp/$base.sed /tmp/$base\n+      if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then\n+        true\n+      else\n+        echo Fixed $file_to_fix\n+        rm -f ${LIB}/$file\n+        cp /tmp/$base ${LIB}/$file\n+        chmod a+r ${LIB}/$file\n+      fi\n+      rm -f /tmp/$base\n+    fi\n+\n+    # Change <ctype.h> to not define __ctype\n+\n+    file=ctype.h\n+    base=`basename $file`\n+    if [ -r ${LIB}/$file ]; then\n+      file_to_fix=${LIB}/$file\n+    else\n+      if [ -r ${INPUT}/$file ]; then\n+        file_to_fix=${INPUT}/$file\n+      else\n+        file_to_fix=\"\"\n+      fi\n+    fi\n+    if [ \\! -z \"$file_to_fix\" ]; then\n+      echo Checking $file_to_fix\n+      cp $file_to_fix /tmp/$base\n+      chmod +w /tmp/$base\n+      sed -e '\n+        s/__ctype/_ctype/g\n+      ' /tmp/$base > /tmp/$base.sed\n+      mv /tmp/$base.sed /tmp/$base\n+      if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then\n+        true\n+      else\n+        echo Fixed $file_to_fix\n+        rm -f ${LIB}/$file\n+        cp /tmp/$base ${LIB}/$file\n+        chmod a+r ${LIB}/$file\n+      fi\n+      rm -f /tmp/$base\n+    fi\n+  fi\n+fi\n+\n+# In limits.h, put #ifndefs around things that are supposed to be defined\n+# in float.h to avoid redefinition errors if float.h is included first.\n+# Solaris 2.1 has this problem.\n+\n+file=limits.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/[ \t]FLT_MIN[ \t]/i\\\n+#ifndef FLT_MIN\n+'\\\n+      -e '/[ \t]FLT_MIN[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]FLT_MAX[ \t]/i\\\n+#ifndef FLT_MAX\n+'\\\n+      -e '/[ \t]FLT_MAX[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]FLT_DIG[ \t]/i\\\n+#ifndef FLT_DIG\n+'\\\n+      -e '/[ \t]FLT_DIG[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_MIN[ \t]/i\\\n+#ifndef DBL_MIN\n+'\\\n+      -e '/[ \t]DBL_MIN[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_MAX[ \t]/i\\\n+#ifndef DBL_MAX\n+'\\\n+      -e '/[ \t]DBL_MAX[ \t]/a\\\n+#endif\n+'\\\n+      -e '/[ \t]DBL_DIG[ \t]/i\\\n+#ifndef DBL_DIG\n+'\\\n+      -e '/[ \t]DBL_DIG[ \t]/a\\\n+#endif\n+' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Completely replace <sys/varargs.h> with a file that includes gcc's\n+# stdarg.h or varargs.h files as appropriate.\n+\n+file=sys/varargs.h\n+if [ -r ${INPUT}/$file ]; then\n+  echo Replacing $file\n+  cat > ${LIB}/$file << EOF\n+/* This file was generated by fixincludes.  */\n+#ifndef _SYS_VARARGS_H\n+#define _SYS_VARARGS_H\n+\n+#ifdef __STDC__\n+#include <stdarg.h>\n+#else\n+#include <varargs.h>\n+#endif\n+\n+#endif  /* _SYS_VARARGS_H */\n+EOF\n+  chmod a+r ${LIB}/$file\n+fi\n+\n+# In math.h, put #ifndefs around things that might be defined in a gcc\n+# specific math-*.h file.\n+\n+file=math.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/define[ \t]HUGE_VAL[ \t]/i\\\n+#ifndef HUGE_VAL\n+'\\\n+      -e '/define[ \t]HUGE_VAL[ \t]/a\\\n+#endif\n+' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+# Solaris math.h and floatingpoint.h define __P without protection,\n+# which conflicts with the fixproto definition.  The fixproto\n+# definition and the Solaris definition are used the same way.\n+for file in math.h floatingpoint.h; do\n+  base=`basename $file`\n+  if [ -r ${LIB}/$file ]; then\n+    file_to_fix=${LIB}/$file\n+  else\n+    if [ -r ${INPUT}/$file ]; then\n+      file_to_fix=${INPUT}/$file\n+    else\n+      file_to_fix=\"\"\n+    fi\n+  fi\n+  if [ \\! -z \"$file_to_fix\" ]; then\n+    echo Checking $file_to_fix\n+    sed -e '/^#define[ \t]*__P/i\\\n+#ifndef __P\n+'\\\n+        -e '/^#define[ \t]*__P/a\\\n+#endif\n+' $file_to_fix > /tmp/$base\n+    if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+      true\n+    else\n+      echo Fixed $file_to_fix\n+      rm -f ${LIB}/$file\n+      cp /tmp/$base ${LIB}/$file\n+      chmod a+r ${LIB}/$file\n+    fi\n+   rm -f /tmp/$base\n+  fi\n+done\n+\n+# The Solaris math.h defines struct exception, which conflicts with\n+# the class exception defined in the C++ file std/stdexcept.h.  We\n+# redefine it to __math_exception.  This is not a great fix, but I\n+# haven't been able to think of anything better.\n+file=math.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '/struct exception/i\\\n+#ifdef __cplusplus\\\n+#define exception __math_exception\\\n+#endif'\\\n+      -e '/struct exception/a\\\n+#ifdef __cplusplus\\\n+#undef exception\\\n+#endif' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > /dev/null 2>&1\n+done\n+\n+if $LINKS; then\n+  echo 'Making internal symbolic non-directory links'\n+  cd ${INPUT}\n+  files=`find . -type l -print`\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if expr \"$dest\" : '[^/].*' > /dev/null; then    \n+      target=${LIB}/`echo $file | sed \"s|[^/]*\\$|$dest|\"`\n+      if [ -f $target ]; then\n+        ln -s $dest ${LIB}/$file >/dev/null 2>&1\n+      fi\n+    fi\n+  done\n+fi\n+\n+cd ${ORIG_DIR}\n+\n+echo 'Replacing <sys/byteorder.h>'\n+if [ \\! -d $LIB/sys ]; then\n+  mkdir $LIB/sys\n+fi\n+rm -f ${LIB}/sys/byteorder.h\n+cat <<'__EOF__' >${LIB}/sys/byteorder.h\n+#ifndef _SYS_BYTEORDER_H\n+#define _SYS_BYTEORDER_H\n+\n+/* Functions to convert `short' and `long' quantities from host byte order\n+   to (internet) network byte order (i.e. big-endian).\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+   This isn't actually used by GCC.  It is installed by fixinc.svr4.\n+\n+   For big-endian machines these functions are essentially no-ops.\n+\n+   For little-endian machines, we define the functions using specialized\n+   asm sequences in cases where doing so yields better code (e.g. i386).  */\n+\n+#if !defined (__GNUC__) && !defined (__GNUG__)\n+#error You lose!  This file is only useful with GNU compilers.\n+#endif\n+\n+#ifndef __BYTE_ORDER__\n+/* Byte order defines.  These are as defined on UnixWare 1.1, but with\n+   double underscores added at the front and back.  */\n+#define __LITTLE_ENDIAN__   1234\n+#define __BIG_ENDIAN__      4321\n+#define __PDP_ENDIAN__      3412\n+#endif\n+\n+#ifdef __STDC__\n+static __inline__ unsigned long htonl (unsigned long);\n+static __inline__ unsigned short htons (unsigned int);\n+static __inline__ unsigned long ntohl (unsigned long);\n+static __inline__ unsigned short ntohs (unsigned int);\n+#endif /* defined (__STDC__) */\n+\n+#if defined (__i386__)\n+\n+#ifndef __BYTE_ORDER__\n+#define __BYTE_ORDER__ __LITTLE_ENDIAN__\n+#endif\n+\n+/* Convert a host long to a network long.  */\n+\n+/* We must use a new-style function definition, so that this will also\n+   be valid for C++.  */\n+static __inline__ unsigned long\n+htonl (unsigned long __arg)\n+{\n+  register unsigned long __result;\n+\n+  __asm__ (\"xchg%B0 %b0,%h0\\n\\\n+\tror%L0 $16,%0\\n\\\n+\txchg%B0 %b0,%h0\" : \"=q\" (__result) : \"0\" (__arg));\n+  return __result;\n+}\n+\n+/* Convert a host short to a network short.  */\n+\n+static __inline__ unsigned short\n+htons (unsigned int __arg)\n+{\n+  register unsigned short __result;\n+\n+  __asm__ (\"xchg%B0 %b0,%h0\" : \"=q\" (__result) : \"0\" (__arg));\n+  return __result;\n+}\n+\n+#elif ((defined (__i860__) && !defined (__i860_big_endian__))\t\\\n+       || defined (__ns32k__) || defined (__vax__)\t\t\\\n+       || defined (__spur__) || defined (__arm__))\n+\n+#ifndef __BYTE_ORDER__\n+#define __BYTE_ORDER__ __LITTLE_ENDIAN__\n+#endif\n+\n+/* For other little-endian machines, using C code is just as efficient as\n+   using assembly code.  */\n+\n+/* Convert a host long to a network long.  */\n+\n+static __inline__ unsigned long\n+htonl (unsigned long __arg)\n+{\n+  register unsigned long __result;\n+\n+  __result = (__arg >> 24) & 0x000000ff;\n+  __result |= (__arg >> 8) & 0x0000ff00;\n+  __result |= (__arg << 8) & 0x00ff0000;\n+  __result |= (__arg << 24) & 0xff000000;\n+  return __result;\n+}\n+\n+/* Convert a host short to a network short.  */\n+\n+static __inline__ unsigned short\n+htons (unsigned int __arg)\n+{\n+  register unsigned short __result;\n+\n+  __result = (__arg << 8) & 0xff00;\n+  __result |= (__arg >> 8) & 0x00ff;\n+  return __result;\n+}\n+\n+#else /* must be a big-endian machine */\n+\n+#ifndef __BYTE_ORDER__\n+#define __BYTE_ORDER__ __BIG_ENDIAN__\n+#endif\n+\n+/* Convert a host long to a network long.  */\n+\n+static __inline__ unsigned long\n+htonl (unsigned long __arg)\n+{\n+  return __arg;\n+}\n+\n+/* Convert a host short to a network short.  */\n+\n+static __inline__ unsigned short\n+htons (unsigned int __arg)\n+{\n+  return __arg;\n+}\n+\n+#endif /* big-endian */\n+\n+/* Convert a network long to a host long.  */\n+\n+static __inline__ unsigned long\n+ntohl (unsigned long __arg)\n+{\n+  return htonl (__arg);\n+}\n+\n+/* Convert a network short to a host short.  */\n+\n+static __inline__ unsigned short\n+ntohs (unsigned int __arg)\n+{\n+  return htons (__arg);\n+}\n+\n+__EOF__\n+\n+if [ -r ${INPUT}/sys/byteorder.h ]; then\n+  if grep BYTE_ORDER ${INPUT}/sys/byteorder.h >/dev/null 2>/dev/null; then\n+    cat <<'__EOF__' >>${LIB}/sys/byteorder.h\n+#ifndef BYTE_ORDER\n+#define LITTLE_ENDIAN __LITTLE_ENDIAN__\n+#define BIG_ENDIAN __BIG_ENDIAN__\n+#define PDP_ENDIAN __PDP_ENDIAN__\n+#define BYTE_ORDER __BYTE_ORDER__\n+#endif\n+\n+__EOF__\n+  fi\n+fi\n+\n+cat <<'__EOF__' >>${LIB}/sys/byteorder.h\n+#endif /* !defined (_SYS_BYTEORDER_H) */\n+__EOF__\n+\n+chmod a+r ${LIB}/sys/byteorder.h\n+\n+exit 0\n+"}, {"sha": "915ac723b85e386db4665a71b9b34e8edcce2189", "filename": "gcc/fixinc/fixinc.winnt", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.winnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.winnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.winnt?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,232 @@\n+#! sh\n+#\n+#   fixinc.winnt  --  Install modified versions of Windows NT system include\n+#   files.\n+#\n+#   Based on fixinc.sco script by Ian Lance Taylor (ian@airs.com)).\n+#   Modifications by Douglas Rupp (drupp@cs.washington.edu)\n+#\n+# This file is part of GNU CC.\n+# \n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+# \n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+#\tThis script munges the native include files provided with Windows NT\n+#\t3.5 SDK systems so as to provide a reasonable namespace when\n+#\tcompiling with gcc.  The header files by default do not\n+#\tprovide many essential definitions and declarations if\n+#\t__STDC__ is 1.  This script modifies the header files to check\n+#\tfor __STRICT_ANSI__ being defined instead.  Once munged, the\n+#\tresulting new system include files are placed in a directory\n+#\tthat GNU C will search *before* searching the Include\n+#\tdirectory.\n+#\n+#\tSee README-fixinc for more information.\n+\n+ORIG_DIR=`pwd`\n+\n+# Directory containing the original header files.\n+cd $2; SEDFILE=`${PWDCMD-pwd}`/fixinc-nt.sed\n+echo $SEDFILE\n+if [ ! -f $SEDFILE ]\n+then echo fixincludes: sed script 'fixinc-nt.sed' not found\n+exit 1\n+fi\n+echo 'Using sed script: ' ${SEDFILE}\n+\n+cd $ORIG_DIR\n+\n+INPUT=${INCLUDE}\n+echo 'Using the Include environment variable to find header files to fix'\n+\n+# Fail if no arg to specify a directory for the output.\n+if [ x$1 = x ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+ORIG_DIR=`pwd`\n+\n+# Make LIB absolute if it is relative.\n+# Don't do this if not necessary, since may screw up automounters.\n+case $LIB in\n+/*)\n+\t;;\n+*)\n+\tcd $LIB; LIB=`${PWDCMD-pwd}`\n+\t;;\n+esac\n+\n+echo 'Building fixincludes in ' ${LIB}\n+\n+# Determine whether this filesystem has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>NUL; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+\n+echo 'Making directories:'\n+cd ${INPUT}\n+if $LINKS; then\n+  files=`ls -LR | sed -n s/:$//p`\n+else\n+  files=`find . -type d -print | sed '/^.$/d'`\n+fi\n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+\n+set - $treetops\n+while [ $# != 0 ]; do\n+  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n+  echo \"Finding header files in $1:\"\n+  cd ${INPUT}\n+  cd $1\n+  files=`find . -name '*.[hH]' -type f -print`\n+  echo 'Checking header files:'\n+  for file in $files; do\n+    echo $file\n+    if egrep \"!__STDC__\" $file >NUL; then\n+      if [ -r $file ]; then\n+\tcp $file $2/$file >NUL 2>&1 || echo \"Can't copy $file\"\n+\tchmod +w,a+r $2/$file\n+\n+# The following have been removed from the sed command below\n+# because it is more useful to leave these things in.\n+# The only reason to remove them was for -pedantic,\n+# which isn't much of a reason. -- rms.\n+#\t  /^[ \t]*#[ \t]*ident/d\n+\n+\tsed -e '\n+\t  s/!__STDC__/!defined (__STRICT_ANSI__)/g\n+\t' $2/$file > $2/$file.sed\n+\tmv $2/$file.sed $2/$file\n+\tif cmp $file $2/$file >NUL 2>&1; then\n+\t   rm $2/$file\n+\telse\n+\t   echo Fixed $file\n+\tfi\n+      fi\n+    fi\n+  done\n+  shift; shift\n+done\n+\n+# Fix first broken decl of getcwd present on some svr4 systems.\n+\n+file=direct.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/getcwd(char \\*, int)/getcwd(char *, size_t)/' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >NUL 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+file=rpcndr.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e 's/Format\\[\\]/Format\\[1\\]/' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >NUL 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+file=winnt.h\n+base=`basename $file`\n+if [ -r ${LIB}/$file ]; then\n+  file_to_fix=${LIB}/$file\n+else\n+  if [ -r ${INPUT}/$file ]; then\n+    file_to_fix=${INPUT}/$file\n+  else\n+    file_to_fix=\"\"\n+  fi\n+fi\n+if [ \\! -z \"$file_to_fix\" ]; then\n+  echo Checking $file_to_fix\n+  sed -e '\n+    s/^#if !defined (__cplusplus)/#if 0/\n+    s/^#define DECLSPEC_IMPORT __declspec(dllimport)/#define DECLSPEC_IMPORT/\n+  ' $file_to_fix > /tmp/$base\n+  if cmp $file_to_fix /tmp/$base >NUL 2>&1; then \\\n+    true\n+  else\n+    echo Fixed $file_to_fix\n+    rm -f ${LIB}/$file\n+    cp /tmp/$base ${LIB}/$file\n+    chmod a+r ${LIB}/$file\n+  fi\n+  rm -f /tmp/$base\n+fi\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > NUL 2>&1\n+done\n+\n+exit 0"}, {"sha": "406c87e9c03bd42fe5ce35d8e7f1da8927ee16b6", "filename": "gcc/fixinc/fixinc.wrap", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.wrap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixinc.wrap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixinc.wrap?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,86 @@\n+#! /bin/sh\n+# Create wrappers for include files instead of replacing them.\n+#\n+# This script is designed for systems whose include files can be fixed\n+# by creating small wrappers around them.\n+# An advantage of this method is that if the system include files are changed\n+# (e.g. by OS upgrade), you need not re-run fixincludes.\n+#\n+# See README-fixinc for more information.\n+\n+# Directory containing the original header files.\n+# (This was named INCLUDES, but that conflicts with a name in Makefile.in.)\n+INPUT=${2-${INPUT-/usr/include}}\n+\n+# Directory in which to store the results.\n+LIB=${1?\"fixincludes: output directory not specified\"}\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || exit 1\n+fi\n+\n+echo Building fixed headers in ${LIB}\n+\n+# Some math.h files define struct exception, which conflicts with\n+# the class exception defined in the C++ file std/stdexcept.h.  We\n+# redefine it to __math_exception.  This is not a great fix, but I\n+# haven't been able to think of anything better.\n+file=math.h\n+if [ -r $INPUT/$file ]; then\n+  echo Checking $INPUT/$file\n+  if grep 'struct exception' $INPUT/$file >/dev/null\n+  then\n+    echo Fixed $file\n+    rm -f $LIB/$file\n+    cat <<'__EOF__' >$LIB/$file\n+#ifndef _MATH_H_WRAPPER\n+#ifdef __cplusplus\n+# define exception __math_exception\n+#endif\n+#include_next <math.h>\n+#ifdef __cplusplus\n+# undef exception\n+#endif\n+#define _MATH_H_WRAPPER\n+#endif /* _MATH_H_WRAPPER */\n+__EOF__\n+    # Define _MATH_H_WRAPPER at the end of the wrapper, not the start,\n+    # so that if #include_next gets another instance of the wrapper,\n+    # this will follow the #include_next chain until we arrive at\n+    # the real <math.h>.\n+    chmod a+r $LIB/$file\n+  fi\n+fi\n+\n+# Avoid the definition of the bool type in the Solaris 2.x curses.h when using\n+# g++, since it's now an official type in the C++ language.\n+file=curses.h\n+if [ -r $INPUT/$file ]; then\n+  echo Checking $INPUT/$file\n+  w='[\t ]'\n+  if grep \"typedef$w$w*char$w$w*bool$w*;\" $INPUT/$file >/dev/null\n+  then\n+    echo Fixed $file\n+    rm -f $LIB/$file\n+    cat <<'__EOF__' >$LIB/$file\n+#ifndef _CURSES_H_WRAPPER\n+#ifdef __cplusplus\n+# define bool __curses_bool_t\n+#endif\n+#include_next <curses.h>\n+#ifdef __cplusplus\n+# undef bool\n+#endif\n+#define _CURSES_H_WRAPPER\n+#endif /* _CURSES_H_WRAPPER */\n+__EOF__\n+    # Define _CURSES_H_WRAPPER at the end of the wrapper, not the start,\n+    # so that if #include_next gets another instance of the wrapper,\n+    # this will follow the #include_next chain until we arrive at\n+    # the real <curses.h>.\n+    chmod a+r $LIB/$file\n+  fi\n+fi\n+\n+exit 0"}, {"sha": "97aae47a4a4e0c6c12215fd7eba3e0f835a477a1", "filename": "gcc/fixinc/fixincl.c", "status": "added", "additions": 834, "deletions": 0, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,834 @@\n+/*\n+ * $Id: fixincl.c,v 1.2 1998/12/16 21:19:03 law Exp $\n+ *\n+ * Install modified versions of certain ANSI-incompatible system header\n+ * files which are fixed to work correctly with ANSI C and placed in a\n+ * directory that GNU C will search.\n+ *\n+ * See README-fixinc for more information.\n+ *\n+ *  fixincl is free software.\n+ *  \n+ *  You may redistribute it and/or modify it under the terms of the\n+ *  GNU General Public License, as published by the Free Software\n+ *  Foundation; either version 2, or (at your option) any later version.\n+ *  \n+ *  fixincl is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ *  See the GNU General Public License for more details.\n+ *  \n+ *  You should have received a copy of the GNU General Public License\n+ *  along with fixincl.  See the file \"COPYING\".  If not,\n+ *  write to:  The Free Software Foundation, Inc.,\n+ *             59 Temple Place - Suite 330,\n+ *             Boston,  MA  02111-1307, USA.\n+ */\n+\n+#include <sys/param.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <fcntl.h>\n+#include <ctype.h>\n+\n+#include \"regex.h\"\n+#include \"server.h\"\n+\n+#define tSCC static const char\n+#define tCC  const char\n+#define tSC  static char\n+\n+typedef int tSuccess;\n+\n+#define FAILURE  ((tSuccess)-1)\n+#define SUCCESS  ((tSuccess) 0)\n+#define PROBLEM  ((tSuccess) 1)\n+\n+#define SUCCEEDED( p )     ((p) == SUCCESS)\n+#define SUCCESSFUL( p )    SUCCEEDED( p )\n+#define FAILED( p )        ((p) <  SUCCESS)\n+#define HADGLITCH( p )     ((p) >  SUCCESS)\n+\n+#define NUL '\\0'\n+\n+typedef enum\n+  {\n+    TT_TEST, TT_EGREP, TT_NEGREP\n+  }\n+teTestType;\n+\n+typedef struct test_desc tTestDesc;\n+\n+struct test_desc\n+  {\n+    teTestType type;\n+    const char *pzTest;\n+    regex_t *pTestRegex;\n+  };\n+\n+typedef struct patch_desc tPatchDesc;\n+\n+#define FD_MACH_ONLY      0x0000\n+#define FD_MACH_IFNOT     0x0001\n+#define FD_SKIP_TEST      0x8000\n+\n+typedef struct fix_desc tFixDesc;\n+struct fix_desc\n+  {\n+    const char*   pzFixName;     /* Name of the fix */\n+    const char*   pzFileList;    /* List of files it applies to */\n+    const char**  papzMachs;     /* List of machine/os-es it applies to */\n+    regex_t*      pListRegex;\n+    int           testCt;\n+    int           fdFlags;\n+    tTestDesc*    pTestDesc;\n+    const char**  papzPatchArgs;\n+  };\n+\n+char *pzDestDir   = (char *) NULL;\n+char *pzSrcDir    = (char *) NULL;\n+char *pzMachine   = (char *) NULL;\n+\n+pid_t chainHead = (pid_t) - 1;\n+\n+const char zInclQuote[] = \"^[ \\t]*#[ \\t]*include[ \\t]*\\\"[^/]\";\n+regex_t inclQuoteRegex;\n+\n+char zFileNameBuf[0x8000];\n+\n+char *loadFile (const char *pzFile);\n+void process (char *data, const char *dir, const char *file);\n+void runCompiles (void);\n+\n+#include \"fixincl.x\"\n+\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  static const char zGnuLib[] =\n+  \"This file is part of the GNU C Library\";\n+  static const char zVarNotFound[] =\n+      \"fixincl ERROR:  %s environment variable not defined\\n\";\n+\n+#ifndef NO_BOGOSITY_LIMITS\n+# define BOGUS_LIMIT 256\n+  size_t loopCt;\n+#endif\n+\n+  char *apzNames[BOGUS_LIMIT];\n+  size_t fileNameCt;\n+\n+  if (argc != 1)\n+    {\n+      if (argc != 2)\n+        {\n+          fputs (\"fixincl ERROR:  too many command line arguments\\n\", stderr);\n+          exit (EXIT_FAILURE);\n+        }\n+\n+      if (strcmp (argv[1], \"-v\") == 0)\n+        {\n+          fputs (\"$Id: fixincl.c,v 1.2 1998/12/16 21:19:03 law Exp $\\n\", stderr);\n+          exit (EXIT_SUCCESS);\n+        }\n+\n+      freopen (argv[1], \"r\", stdin);\n+    }\n+\n+  {\n+    static const char zVar[] = \"TARGET_MACHINE\";\n+    pzMachine = getenv( zVar );\n+    if (pzMachine == (char *)NULL)\n+      {\n+        fprintf( stderr, zVarNotFound, zVar );\n+        exit (EXIT_FAILURE);\n+      }\n+  }\n+\n+  {\n+    static const char zVar[] = \"DESTDIR\";\n+    pzDestDir = getenv( zVar );\n+    if (pzDestDir == (char *)NULL)\n+      {\n+        fprintf( stderr, zVarNotFound, zVar );\n+        exit (EXIT_FAILURE);\n+      }\n+  }\n+\n+  {\n+    static const char zVar[] = \"SRCDIR\";\n+    pzSrcDir = getenv( zVar );\n+    if (pzSrcDir == (char *)NULL)\n+      {\n+        fprintf( stderr, zVarNotFound, zVar );\n+        exit (EXIT_FAILURE);\n+      }\n+  }\n+\n+  runCompiles ();\n+\n+  signal ( SIGQUIT, SIG_IGN );\n+  signal ( SIGIOT,  SIG_IGN );\n+  signal ( SIGPIPE, SIG_IGN );\n+  signal ( SIGALRM, SIG_IGN );\n+  signal ( SIGTERM, SIG_IGN );\n+  signal ( SIGCHLD, SIG_IGN );\n+\n+#ifndef NO_BOGOSITY_LIMITS\n+  for (;;)\n+    {\n+      char *pzBuf;\n+      pid_t child;\n+\n+      /*\n+       *  Only the parent process can read from stdin without\n+       *  confusing the world.  (How does the child tell the\n+       *  parent to skip forward?  Pipes and files behave differently.)\n+       */\n+      for (fileNameCt = 0, pzBuf = zFileNameBuf;\n+           (fileNameCt < BOGUS_LIMIT)\n+           && (pzBuf\n+               < (zFileNameBuf + sizeof (zFileNameBuf) - MAXPATHLEN));\n+        )\n+        {\n+\n+          if (fgets (pzBuf, MAXPATHLEN, stdin) == (char *) NULL)\n+            break;\n+          while (isspace (*pzBuf))\n+            pzBuf++;\n+          apzNames[fileNameCt++] = pzBuf;\n+          pzBuf += strlen (pzBuf);\n+          while (isspace (pzBuf[-1]))\n+            pzBuf--;\n+          *pzBuf++ = '\\0';\n+        }\n+\n+      if (fileNameCt == 0)\n+        return EXIT_SUCCESS;\n+\n+      child = fork ();\n+      if (child == NULLPROCESS)\n+        break;\n+\n+      if (child == NOPROCESS)\n+        {\n+          fprintf (stderr, \"Error %d (%s) forking in main\\n\",\n+                   errno, strerror (errno));\n+          exit (EXIT_FAILURE);\n+        }\n+\n+      waitpid (child, (int *) NULL, 0);\n+    }\n+#else\n+#error \"NON-BOGUS LIMITS NOT SUPPORTED?!?!\"\n+#endif\n+\n+  /*\n+   *  For every file specified in stdandard in\n+   *  (except as throttled for bogus reasons)...\n+   */\n+  for (loopCt = 0; loopCt < fileNameCt; loopCt++)\n+    {\n+      char *pzData;\n+      char *pzFile = apzNames[loopCt];\n+\n+      if (access (pzFile, R_OK) != 0)\n+        {\n+          int erno = errno;\n+          fprintf (stderr, \"Cannot access %s from %s\\n\\terror %d (%s)\\n\",\n+                   pzFile, getcwd ((char *) NULL, MAXPATHLEN),\n+                   erno, strerror (erno));\n+        }\n+      else if (pzData = loadFile (pzFile),\n+               (pzData != (char *) NULL))\n+        {\n+\n+          if (strstr (pzData, zGnuLib) == (char *) NULL)\n+            process (pzData, pzDestDir, pzFile);\n+\n+          free ((void *) pzData);\n+        }\n+    }\n+\n+  return EXIT_SUCCESS;\n+}\n+\n+\n+char *\n+loadFile (pzFile)\n+     const char *pzFile;\n+{\n+  char *pzDta;\n+  size_t fileSize;\n+\n+  {\n+    struct stat stbf;\n+    if (stat (pzFile, &stbf) != 0)\n+      {\n+        fprintf (stderr, \"error %d (%s) stat-ing %s\\n\",\n+                 errno, strerror (errno), pzFile);\n+        return (char *) NULL;\n+      }\n+    fileSize = stbf.st_size;\n+  }\n+  if (fileSize == 0)\n+    return (char *) NULL;\n+\n+  pzDta = (char *) malloc ((fileSize + 16) & ~0x00F);\n+  if (pzDta == (char *) NULL)\n+    {\n+      fprintf (stderr, \"error:  could not malloc %d bytes\\n\",\n+               fileSize);\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  {\n+    FILE *fp = fopen (pzFile, \"r\");\n+    size_t sizeLeft = fileSize;\n+    char *readPtr = pzDta;\n+\n+    if (fp == (FILE *) NULL)\n+      {\n+        fprintf (stderr, \"error %d (%s) opening %s\\n\", errno,\n+                 strerror (errno), pzFile);\n+        free ((void *) pzDta);\n+        return (char *) NULL;\n+      }\n+\n+    do\n+      {\n+        size_t sizeRead = fread ((void *) readPtr, 1, sizeLeft, fp);\n+\n+        if (sizeRead == 0)\n+          {\n+            if (feof (fp))\n+              break;\n+\n+            if (ferror (fp))\n+              {\n+                fprintf (stderr, \"error %d (%s) reading %s\\n\", errno,\n+                         strerror (errno), pzFile);\n+                free ((void *) pzDta);\n+                fclose (fp);\n+                return (char *) NULL;\n+              }\n+          }\n+\n+        readPtr += sizeRead;\n+        sizeLeft -= sizeRead;\n+      }\n+    while (sizeLeft != 0);\n+\n+    *readPtr = '\\0';\n+    fclose (fp);\n+    return pzDta;\n+  }\n+}\n+\n+\n+void\n+runCompiles ()\n+{\n+  tSCC zBadComp[] = \"fixincl ERROR:  cannot compile %s regex for %s\\n\"\n+    \"\\texpr = `%s'\\n\" \"\\terror %s\\n\";\n+  tFixDesc *pFD = fixDescList;\n+  int fixCt = FIX_COUNT;\n+  tTestDesc *pTD;\n+  int tstCt;\n+  int reCt = REGEX_COUNT;\n+  const char *pzErr;\n+  regex_t *pRegex = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n+\n+  if (pRegex == (regex_t *) NULL)\n+    {\n+      fprintf (stderr, \"fixincl ERROR:  cannot allocate %d bytes for regex\\n\",\n+               REGEX_COUNT * sizeof (regex_t));\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  re_set_syntax (RE_SYNTAX_EGREP);\n+  pzErr = re_compile_pattern (zInclQuote, strlen (zInclQuote),\n+                              &inclQuoteRegex);\n+  if (pzErr != (char *) NULL)\n+    {\n+      fprintf (stderr, zBadComp, \"quoted include\", \"runCompiles\",\n+               zInclQuote, pzErr);\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /*\n+   *  FOR every fixup, ...\n+   */\n+  do\n+    {\n+      pTD = pFD->pTestDesc;\n+      tstCt = pFD->testCt;\n+\n+      if (pFD->papzMachs != (const char**)NULL) {\n+        const char** papzMachs = pFD->papzMachs;\n+        char*        pz = zFileNameBuf;\n+        char*        pzSep = \"\";\n+        tCC*         pzIfTrue;\n+        tCC*         pzIfFalse;\n+        tSCC         zSkip[] = \"skip\";\n+        tSCC         zRun[]  = \"run\";\n+\n+        sprintf( pz, \"case %s in\\n\", pzMachine );\n+        pz += strlen( pz );\n+\n+        if (pFD->fdFlags & FD_MACH_IFNOT) {\n+          pzIfTrue  = zSkip;\n+          pzIfFalse = zRun;\n+        } else {\n+          pzIfTrue  = zRun;\n+          pzIfFalse = zSkip;\n+        }\n+\n+        for (;;) {\n+          const char* pzMach = *(papzMachs++);\n+          if (pzMach == (const char*)NULL)\n+            break;\n+          sprintf( pz, \"%s  %s\", pzSep, pzMach );\n+          pz += strlen( pz );\n+          pzSep = \" | \\\\\\n\";\n+        }\n+        sprintf( pz, \" )\\n    echo %s ;;\\n  * )\\n    echo %s ;;\\nesac\",\n+                 pzIfTrue, pzIfFalse );\n+        pz = runShell( zFileNameBuf );\n+        if (*pz == 's') {\n+          pFD->fdFlags |= FD_SKIP_TEST;\n+          continue;\n+        }\n+      }\n+\n+      /*\n+       *  FOR every test for the fixup, ...\n+       */\n+      while (--tstCt >= 0)\n+        {\n+          switch (pTD->type)\n+            {\n+            case TT_EGREP:\n+            case TT_NEGREP:\n+              if (--reCt < 0)\n+                {\n+                  fputs (\"out of RE's\\n\", stderr);\n+                  exit (EXIT_FAILURE);\n+                }\n+\n+              pTD->pTestRegex = pRegex++;\n+              pzErr = re_compile_pattern (pTD->pzTest,\n+                                          strlen (pTD->pzTest),\n+                                          pTD->pTestRegex);\n+              if (pzErr != (char *) NULL)\n+                {\n+                  fprintf (stderr, zBadComp, \"select test\", pFD->pzFixName,\n+                           pTD->pzTest, pzErr);\n+                  exit (EXIT_FAILURE);\n+                }\n+            }\n+          pTD++;\n+        }\n+    }\n+  while (pFD++, --fixCt > 0);\n+}\n+\n+\n+FILE *\n+createFile (pzFile)\n+     const char *pzFile;\n+{\n+  int fd;\n+  FILE *pf;\n+  char fname[MAXPATHLEN];\n+\n+  sprintf (fname, \"%s/%s\", pzDestDir, pzFile);\n+  unlink (fname);\n+\n+  fd = open (fname, O_WRONLY | O_CREAT);\n+\n+  if ((fd < 0) && (errno == ENOENT))\n+    {\n+      char *pzDir = strchr (fname + 1, '/');\n+      struct stat stbf;\n+\n+      while (pzDir != (char *) NULL)\n+        {\n+          *pzDir = NUL;\n+          if (stat (fname, &stbf) < 0)\n+            {\n+              mkdir (fname, S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP\n+                     | S_IROTH | S_IXOTH);\n+            }\n+\n+          *pzDir = '/';\n+          pzDir = strchr (pzDir + 1, '/');\n+        }\n+      fd = open (fname, O_WRONLY | O_CREAT);\n+    }\n+  if (fd < 0)\n+    {\n+      fprintf (stderr, \"Error %d (%s) creating %s\\n\",\n+               errno, strerror (errno), fname);\n+      exit (EXIT_FAILURE);\n+    }\n+  fprintf (stderr, \"Fixed:  %s\\n\", pzFile);\n+  pf = fdopen (fd, \"w\");\n+\n+#ifdef LATER\n+  {\n+    static const char zHdr[] =\n+    \"/*\\n\"\n+    \" *  DO NOT EDIT THIS FILE.\\n\"\n+    \" *\\n\"\n+    \" *  It has been auto-edited by fixincludes from /usr/include/%s\\n\"\n+    \" *  This had to be done to correct non-standard usages in the\\n\"\n+    \" *  original, manufacturer supplied header file.\\n\"\n+    \" */\\n\\n\";\n+\n+    fprintf (pf, zHdr, pzFile);\n+  }\n+#endif\n+  return pf;\n+}\n+\n+tSuccess\n+testTest (pTest, pzFile)\n+     tTestDesc *pTest;\n+     char*      pzFile;\n+{\n+  char *pzRes;\n+  tSuccess res = FAILURE;\n+\n+  static char zCmdBuf[4096];\n+  tSCC zCmdFmt[] = \"file=%s\\nif ( test %s ) > /dev/null 2>&1\\n\"\n+  \"then echo TRUE\\n\" \"else echo FALSE\\n\" \"fi\";\n+\n+  sprintf (zCmdBuf, zCmdFmt, pzFile, pTest->pzTest);\n+  pzRes = runShell (zCmdBuf);\n+  if (*pzRes == 'T')\n+    res = SUCCESS;\n+  free ((void *) pzRes);\n+  return res;\n+}\n+\n+\n+tSuccess\n+egrepTest (pzDta, pTest)\n+     char *pzDta;\n+     tTestDesc *pTest;\n+{\n+  regmatch_t match;\n+#ifndef NO_BOGOSITY\n+  if (pTest->pTestRegex == 0)\n+    fprintf (stderr, \"fixincl ERROR RE not compiled:  `%s'\\n\", pTest->pzTest);\n+#endif\n+  if (regexec (pTest->pTestRegex, pzDta, 1, &match, 0) == 0)\n+    return SUCCESS;\n+  return FAILURE;\n+}\n+\n+\n+\n+void\n+extractQuotedFiles (pzDta, pzFile, pMatch)\n+     char *pzDta;\n+     const char *pzFile;\n+     regmatch_t *pMatch;\n+{\n+  char *pzDirEnd = strrchr (pzFile, '/');\n+  char *pzInclQuot = pzDta;\n+\n+  fprintf (stderr, \"Quoted includes in %s\\n\", pzFile);\n+\n+  /*\n+   *  Set \"pzFile\" to point to the containing subdirectory of the source\n+   *  If there is none, then it is in our current direcory, \".\".\n+   */\n+  if (pzDirEnd == (char *) NULL)\n+    pzFile = \".\";\n+  else\n+    *pzDirEnd = '\\0';\n+\n+  for (;;)\n+    {\n+      pzInclQuot += pMatch->rm_so;\n+\n+      /*\n+       *  Skip forward to the included file name\n+       */\n+      while (isspace (*pzInclQuot))\n+        pzInclQuot++;\n+      while (isspace (*++pzInclQuot));\n+      pzInclQuot += sizeof (\"include\") - 1;\n+      while (*pzInclQuot++ != '\"');\n+\n+      /*\n+       *  Print the source directory and the subdirectory of the file\n+       *  in question.\n+       */\n+      printf (\"%s  %s/\", pzSrcDir, pzFile);\n+      pzDirEnd = pzInclQuot;\n+\n+      /*\n+       *  Append to the directory the relative path of the desired file\n+       */\n+      while (*pzInclQuot != '\"')\n+        putc (*pzInclQuot++, stdout);\n+\n+      /*\n+       *  Now print the destination directory appended with the relative\n+       *  path of the desired file\n+       */\n+      printf (\"  %s/%s/\", pzDestDir, pzFile);\n+      while (*pzDirEnd != '\"')\n+        putc (*pzDirEnd++, stdout);\n+\n+      /*\n+       *  End of entry\n+       */\n+      putc ('\\n', stdout);\n+\n+      /*\n+       *  Find the next entry\n+       */\n+      if (regexec (&inclQuoteRegex, pzInclQuot, 1, pMatch, 0) != 0)\n+        break;\n+    }\n+}\n+\n+\n+/*\n+ *  Process the potential fixes for a particular include file\n+ */\n+void\n+process (pzDta, pzDir, pzFile)\n+     char *pzDta;\n+     const char *pzDir;\n+     const char *pzFile;\n+{\n+  static char zEnvFile[1024] =\n+    {\"file=\"};\n+  tFixDesc *pFD = fixDescList;\n+  int todoCt = FIX_COUNT;\n+  tFdPair fdp =\n+    {-1, -1};\n+\n+  /*\n+   *  IF this is the first time through,\n+   *  THEN put the 'file' environment variable into the environment.\n+   *       This is used by some of the subject shell scripts and tests.\n+   */\n+  if (zEnvFile[5] == NUL)\n+    putenv (zEnvFile);\n+\n+  /*\n+   *  Ghastly as it is, this actually updates the value of the variable:\n+   *\n+   *    putenv(3C)             C Library Functions             putenv(3C)\n+   *\n+   *    DESCRIPTION\n+   *         putenv() makes the value of the  environment  variable  name\n+   *         equal  to value by altering an existing variable or creating\n+   *         a new one.  In either case, the string pointed to by  string\n+   *         becomes part of the environment, so altering the string will\n+   *         change the environment.  string points to a  string  of  the\n+   *         form  ``name=value.''  The space used by string is no longer\n+   *         used once a new string-defining name is passed to putenv().\n+   */\n+  strcpy (zEnvFile + 5, pzFile);\n+  chainHead = NOPROCESS;\n+\n+  /*\n+   *  For every fix in our fix list, ...\n+   */\n+  for (; todoCt > 0; pFD++, todoCt--)\n+    {\n+      tTestDesc *pTD;\n+      int tstCt;\n+      tSuccess egrepRes;\n+\n+      if (pFD->fdFlags & FD_SKIP_TEST)\n+        continue;\n+\n+      /*\n+       *  IF there is a file name restriction,\n+       *  THEN ensure the current file name matches one in the pattern\n+       */\n+      if (pFD->pzFileList != (char *) NULL)\n+        {\n+          const char *pzFil = pzFile;\n+          const char *pzScn = pFD->pzFileList;\n+          size_t nmLen;\n+\n+          while ((pzFil[0] == '.') && (pzFil[1] == '/'))\n+            pzFil += 2;\n+          nmLen = strlen (pzFil);\n+\n+          for (;;)\n+            {\n+              pzScn = strstr (pzScn + 1, pzFil);\n+              if (pzScn == (char *) NULL)\n+                goto nextFix;\n+\n+              if ((pzScn[-1] == '|') && (pzScn[nmLen] == '|'))\n+                break;\n+            }\n+        }\n+\n+      egrepRes = PROBLEM;\n+\n+      /*\n+       *  IF there are no tests\n+       *  THEN we always run the fixup\n+       */\n+      for (pTD = pFD->pTestDesc, tstCt = pFD->testCt;\n+           tstCt-- > 0;\n+           pTD++)\n+        {\n+          switch (pTD->type)\n+            {\n+            case TT_TEST:\n+              /*\n+               *  IF *any* of the shell tests fail,\n+               *  THEN do not process the fix.\n+               */\n+              if (!SUCCESSFUL (testTest (pTD, pzFile)))\n+                goto nextFix;\n+              break;\n+\n+            case TT_EGREP:\n+              /*\n+               *  IF       we have not had a successful egrep test\n+               *    *AND*  this test does not pass,\n+               *  THEN mark the egrep test as failing.  It starts\n+               *       out as a \"PROBLEM\", meaning that if we do not\n+               *       encounter any egrep tests, then we will let it pass.\n+               */\n+              if ((!SUCCESSFUL (egrepRes))\n+                  && (!SUCCESSFUL (egrepTest (pzDta, pTD))))\n+\n+                egrepRes = FAILURE;\n+\n+              break;\n+\n+            case TT_NEGREP:\n+              /*\n+               *  IF *any* of the negative egrep tests fail,\n+               *  THEN do not process the fix.\n+               */\n+              if (SUCCESSFUL (egrepTest (pzDta, pTD)))\n+                goto nextFix;\n+              break;\n+            }\n+        }\n+\n+      /*\n+       *  IF there were no egrep tests *OR* at least one passed, ...\n+       */\n+      if (!FAILED (egrepRes))\n+        {\n+          fprintf (stderr, \"Applying %-32s to %s\\n\",\n+                   pFD->pzFixName, pzFile);\n+\n+          if (fdp.readFd == -1)\n+            {\n+              fdp.readFd = open (pzFile, O_RDONLY);\n+              if (fdp.readFd < 0)\n+                {\n+                  fprintf (stderr, \"Error %d (%s) opening %s\\n\", errno,\n+                           strerror (errno), pzFile);\n+                  exit (EXIT_FAILURE);\n+                }\n+            }\n+\n+          for (;;)\n+            {\n+              int newFd = chainOpen (fdp.readFd,\n+                                     (tpChar *) pFD->papzPatchArgs,\n+                                     (chainHead == -1)\n+                                     ? &chainHead : (pid_t *) NULL);\n+              if (newFd != -1)\n+                {\n+                  fdp.readFd = newFd;\n+                  break;\n+                }\n+\n+              fprintf (stderr, \"Error %d (%s) starting filter process \"\n+                       \"for %s\\n\", errno, strerror (errno),\n+                       pFD->pzFixName);\n+\n+              if (errno != EAGAIN)\n+                exit (EXIT_FAILURE);\n+              sleep (1);\n+            }\n+        }\n+\n+    nextFix:;\n+    }\n+\n+  /*\n+   *  IF after all the tests we did not start any patch programs,\n+   *  THEN quit now.\n+   */\n+  if (fdp.readFd < 0)\n+    return;\n+\n+  {\n+    FILE *inFp = fdopen (fdp.readFd, \"r\");\n+    FILE *oFp = (FILE *) NULL;\n+    char *pzCmp = pzDta;\n+\n+    for (;;)\n+      {\n+        int ch;\n+\n+        ch = getc (inFp);\n+        if (ch == EOF)\n+          break;\n+\n+        if (oFp != (FILE *) NULL)\n+          putc (ch, oFp);\n+\n+        else if (ch != *pzCmp)\n+          {\n+            oFp = createFile (pzFile);\n+            if (pzCmp != pzDta)\n+              {\n+                char c = *pzCmp;\n+                *pzCmp = NUL;\n+                fputs (pzDta, oFp);\n+                *pzCmp = c;\n+              }\n+            putc (ch, oFp);\n+\n+          }\n+        else\n+          pzCmp++;\n+      }\n+\n+    if (oFp != (FILE *) NULL)\n+      {\n+        regmatch_t match;\n+\n+        fchmod (fileno (oFp), S_IRUSR | S_IRGRP | S_IROTH);\n+        fclose (oFp);\n+        if (regexec (&inclQuoteRegex, pzDta, 1, &match, 0) == 0)\n+          extractQuotedFiles (pzDta, pzFile, &match);\n+      }\n+\n+    fclose (inFp);\n+  }\n+\n+  close (fdp.readFd);\n+}"}, {"sha": "04b67ab537729bbe2d4b50f44cd846ff257550ee", "filename": "gcc/fixinc/fixincl.tpl", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixincl.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Ffixincl.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.tpl?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,169 @@\n+[= autogen template -*- Mode: C -*-\n+x =]\n+/*\n+[= _eval \"# * \" _DNE =]\n+ *\n+ * Install modified versions of certain ANSI-incompatible system header\n+ * files which are fixed to work correctly with ANSI C and placed in a\n+ * directory that GNU C will search.\n+ *\n+ * This script contains [=_eval fix _hilim 1 +=] fixup scripts.\n+ *\n+ * See README-fixinc for more information.\n+ *\n+[=_eval inclhack \"# *  \" _gpl=]\n+ *[=\n+\n+\n+_FOR fix =]\n+ *\n+ *  Description [=_eval _index 1 + \"#%3d -\" _printf=] [=hackname _Cap=] fix\n+ */\n+tSCC z[=hackname _cap=]Name[] =\n+     [=hackname _cap _str=];\n+/*\n+ *  File name selection pattern\n+ */[=\n+\n+  _IF files _exist=]\n+tSCC z[=hackname _cap=]List[] =[=\n+    _FOR files=]\n+        \"|\" [=files _str=][=\n+    /files=] \"|\";[=\n+\n+  _ELSE =]\n+#define z[=hackname _cap=]List (char*)NULL[=\n+  _ENDIF \"files _exist\" =]\n+/*\n+ *  Machine/OS name selection pattern\n+ */[=\n+\n+  _IF mach _exist=]\n+tSCC* apz[=hackname _cap=]Machs[] = {[=\n+    _FOR mach =]\n+        [=mach _str=],[=\n+    /mach=]\n+        (const char*)NULL };[=\n+\n+  _ELSE =]\n+#define apz[=hackname _cap=]Machs (const char**)NULL[=\n+  _ENDIF \"files _exist\" =][=\n+\n+  _IF exesel _exist=]\n+\n+/*\n+ *  content selection pattern\n+ */[=\n+    _FOR exesel =]\n+tSCC z[=hackname _cap=]Select[=_eval _index=][] =\n+       [=exesel _str=];[=\n+    /exesel =][=\n+\n+  _ELIF select _exist=]\n+\n+/*\n+ *  content selection pattern\n+ */[=\n+    _FOR select =]\n+tSCC z[=hackname _cap=]Select[=_eval _index=][] =\n+       [=select _str=];[=\n+    /select =][=\n+  _ENDIF =][=\n+\n+  _IF bypass _exist=]\n+\n+/*\n+ *  content bypass pattern\n+ */[=\n+    _FOR bypass =]\n+tSCC z[=hackname _cap=]Bypass[=_eval _index=][] =\n+       [=bypass _str=];[=\n+    /bypass =][=\n+  _ENDIF =][=\n+\n+  _IF test _exist=]\n+\n+/*\n+ *  content test pattern.  A shell will deal with it later.\n+ */[=\n+    _FOR test =]\n+tSCC z[=hackname _cap=]Test[=_eval _index=][] =\n+       [=test _str=];[=\n+    /test =][=\n+  _ENDIF =][=\n+\n+  _IF exesel _exist select _exist bypass _exist test _exist | | |\n+=]\n+\n+#define    [=hackname _up =]_TEST_CT  [=\n+    _IF exesel _exist =][=\n+       _eval test _count bypass _count exesel _count + + =][=\n+    _ELSE =][=\n+       _eval test _count bypass _count select _count + + =][=\n+    _ENDIF =]\n+tTestDesc a[=hackname _cap=]Tests[] = {[=\n+\n+    _IF test _exist =][=\n+      _FOR test=]\n+    { TT_TEST,   z[=hackname _cap=]Test[=_eval _index=], 0 /* unused */ },[=\n+      /test =][=\n+    _ENDIF =][=\n+\n+    _IF bypass _exist =][=\n+      _FOR bypass=]\n+    { TT_NEGREP, z[=hackname _cap=]Bypass[=_eval _index=], (regex_t*)NULL },[=\n+      /bypass =][=\n+    _ENDIF =][=\n+\n+    _IF exesel _exist =][=\n+      _FOR exesel ,=]\n+    { TT_EGREP,  z[=hackname _cap=]Select[=_eval _index=], (regex_t*)NULL }[=\n+      /exesel =][=\n+\n+    _ELIF select _exist =][=\n+      _FOR select ,=]\n+    { TT_EGREP,  z[=hackname _cap=]Select[=_eval _index=], (regex_t*)NULL }[=\n+      /select =][=\n+    _ENDIF =] };[=\n+  _ELSE =]\n+#define [=hackname _up=]_TEST_CT  0\n+#define a[=hackname _cap=]Tests   (tTestDesc*)NULL[=\n+  _ENDIF =]\n+\n+/*\n+ *  Fix Command Arguments for [=hackname _cap=]\n+ */\n+const char* apz[=hackname _cap=]Patch[] = {[=\n+    _IF   sed         _exist =] \"sed\"[=_FOR sed=],\n+    \"-e\" [=sed _str=][=/sed=][=\n+    _ELIF replacement _exist =] \"sed\",\n+    \"s@[=select[]=]@[=replacement=]@\"[=\n+    _ELIF shell       _exist =] \"sh\", \"-c\",\n+    [=shell _str=][=\n+    _ELSE =][=_ERROR hackname _get \"Error:  %s has two fixup specifications\"\n+                 _printf =][=\n+    _ENDIF=],\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *[=\n+/fix=]\n+ *\n+ *  List of all fixes\n+ */\n+#define  REGEX_COUNT  [=_eval fix.select _count\n+                              fix.bypass _count + =]\n+#define  FIX_COUNT    [=_eval fix _count =]\n+tFixDesc fixDescList[ [=_eval fix _count =] ] = {[=\n+\n+\n+_FOR fix \",\\n\" =]\n+  {  z[=hackname _cap=]Name,    z[=hackname _cap=]List,\n+     apz[=hackname _cap=]Machs, (regex_t*)NULL,\n+     [=hackname  _up=]_TEST_CT, [=\n+       _IF not_machine _exist =]FD_MACH_IFNOT[=\n+       _ELSE                  =]FD_MACH_ONLY[=\n+       _ENDIF =],\n+     a[=hackname _cap=]Tests,   apz[=hackname _cap=]Patch }[=\n+\n+/fix=]\n+};"}, {"sha": "b387a43b7a970debc0d5bdd474c622164889cc65", "filename": "gcc/fixinc/hackshell.tpl", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fhackshell.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fhackshell.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fhackshell.tpl?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,186 @@\n+[= autogen template include =]\n+[=\n+# $Id: hackshell.tpl,v 1.2 1998/12/16 21:19:08 law Exp $\n+#\n+#  This file contanes the shell template replacement for the\n+#  fixincl program.  It is the repetitive guts of the fixincludes logic.\n+#\n+=]\n+  if $LINKS; then\n+    files=`find . -name '*.h' \\( -type f -o -type l \\) -print`\n+  else\n+    files=`find . -name '*.h' -type f -print`\n+  fi\n+  echo Checking header files\n+  for file in $files; do\n+\n+    if ( test ! -r $file -o \\\n+    -n \"`fgrep 'This file is part of the GNU C Library' $file`\" )\n+    then continue ; fi\n+\n+    fixlist=\"\"\n+[=\n+#\n+#  FOR  every fix description,\n+#  DO:  emit the shell text to apply the fix to the current file\n+#\n+# =][=\n+\n+_FOR fix \"\\n\\n\" =]\n+    #\n+    # Fix [=_eval _index 1 + #%3d _printf=]:  [=hackname _Cap=]\n+    #[=\n+    _IF files _exist=]\n+    case \"$file\" in [=_FOR files \" | \\\\\\n\\t\"=]./[=files=][=/files=] )[=\n+    _ENDIF=][=\n+\n+    _IF mach _exist=]\n+    case \"$target_canonical\" in [=\n+        _FOR mach \" | \\\\\\n\\t\" =][=\n+            mach =][=\n+        /mach =] )[=\n+        _IF mach_unmatched _exist =] : ;;\n+    * )[=\n+        _ENDIF =][=\n+\n+    _ENDIF=][=\n+\n+    #  There are three conditional tests:  select, bypass and test.\n+       They may appear as often as desired.  They must all pass for\n+       the fix to be applied.  \"select\" and \"bypass\" are egrep expressions\n+       that must each appear (or not appear) in the target file.\n+       \"test\" is an arbitrary test program expression that must yield\n+       true or false.  It is enclosed in parenthesis to avoid\n+       precedence problems.  The output looks like this:\n+\n+       if ( test -n \"`egrep 'find-expr' $file`\" -a\n+                 -z \"`egrep 'not-find'  $file`\" -a\n+                 '(' <some-test-expression> ')'\n+          ) > /dev/null 2>&1 ; then\n+\n+    #  =][=\n+\n+    _IF select _exist =]\n+    if ( test [=\n+        _FOR select \" -a \\\\\\n              \"\n+              =]-n [=select _shrstr \"#`egrep %s $file`\"\n+                            _printf _shstr =][=\n+        /select=][=\n+\n+        _IF bypass _exist =][=\n+            _FOR bypass=] -a \\\n+              -z [=bypass _shrstr \"#`egrep %s $file`\"\n+                            _printf _shstr =][=\n+            /bypass=][=\n+        _ENDIF=][=\n+\n+        _IF test _exist=][=\n+            _FOR test=] -a \\\n+              '(' [=test=] ')'[=\n+            /test=][=\n+        _ENDIF=]\n+       ) > /dev/null 2>&1 ; then[=\n+\n+\n+    _ELIF test _exist =]\n+    if ( test [=\n+        _FOR test \" -a \\\\\\n              \"\n+              =]'(' [=test=] ')'[=\n+        /test=][=\n+\n+        _IF bypass _exist=][=\n+            _FOR bypass=] -a \\\n+              -z [=bypass _shrstr \"#`egrep %s $file`\"\n+                            _printf _shstr=][=\n+            /bypass=][=\n+        _ENDIF=]\n+       ) > /dev/null 2>&1 ; then[=\n+\n+\n+    _ELIF bypass _exist =]\n+    if ( test [=_FOR bypass \" -a \\\\\\n              \"\n+              =]-z [=bypass _shrstr \"#`egrep %s $file`\"\n+                            _printf _shstr=][=/bypass=]\n+       ) > /dev/null 2>&1 ; then[=\n+\n+      _ENDIF=]\n+    fixlist=\"${fixlist}\n+      [=hackname=]\"\n+    if [ ! -r ${DESTDIR}/$file ]\n+    then infile=$file\n+    else infile=${DESTDIR}/$file ; fi [=\n+\n+    _IF sed _exist=][=\n+        _IF shell _exist =][=\n+          _ERROR hackname _get\n+          \"fixincludes Error:  %s fix has multiple fixups\" _printf=][=\n+        _ENDIF=]\n+\n+    sed [=\n+        _FOR sed =]-e [=sed _shrstr=] \\\n+        [=\n+        /sed=]  < $infile > ${DESTDIR}/$file.[=\n+\n+\n+    _ELIF shell _exist =]\n+    ( [=shell=] ) < $infile > ${DESTDIR}/$file.\n+\n+    #  Shell scripts have the potential of removing the output\n+    #  We interpret that to mean the file is not to be altered\n+    #\n+    if test ! -f ${DESTDIR}/$file.\n+    then continue ; fi [=\n+\n+\n+    _ELSE=][=\n+        _ERROR hackname _get \"ERROR:  %s has no fixup\" _printf=][=\n+\n+    _ENDIF=]\n+    \n+    mv -f ${DESTDIR}/$file. ${DESTDIR}/$file[=\n+\n+    #  Close off any opened \"if\" or \"case\" statements in reverse order\n+\n+    # =][=\n+\n+    _IF select _exist test _exist | bypass _exist | =]\n+    fi # end of selection 'if'[=\n+    _ENDIF =][=\n+\n+    _IF mach _exist=]\n+    ;; # case end for machine type test\n+    esac[=\n+    _ENDIF =][=\n+\n+    _IF files _exist=]\n+    ;; # case end for file name test\n+    esac[=\n+    _ENDIF =][=\n+\n+/fix =][=\n+#\n+#  DONE with every fix for the current file\n+#\n+#=]\n+    #  IF the output has been removed OR it is unchanged,\n+    #  THEN ensure the output is gone\n+    #  ELSE look for local directory include syntax\n+    #\n+    if ( test ! -f ${DESTDIR}/$file || \\\n+         cmp $file ${DESTDIR}/$file ) > /dev/null 2>&1\n+    then\n+      rm -f ${DESTDIR}/$file\n+    else\n+      echo \"Fixed $file:${fixlist}\"\n+\n+      # Find any include directives that use \"file\".\n+      #\n+      for include in `\n+         egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' ${DESTDIR}/$file |\n+     sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n+      do\n+    dir=`echo $file | sed -e s'|/[^/]*$||'`\n+    required=\"$required ${SRCDIR} $dir/$include ${DESTDIR}/$dir/$include\"\n+      done\n+    fi\n+  done # for file in $files"}, {"sha": "332a3b16e180f90ffc5779844df48b523ce6c764", "filename": "gcc/fixinc/inclhack.def", "status": "added", "additions": 2340, "deletions": 0, "changes": 2340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,2340 @@\n+/* -*- Mode: C -*-  $Id: inclhack.def,v 1.2 1998/12/16 21:19:09 law Exp $  */\n+\n+autogen definitions inclhack;\n+\n+/*\n+ *  Define all the fixes we know about for repairing damaged headers\n+ */\n+\n+/*\n+ *  sys/wait.h on AIX 3.2.5 puts the declaration of wait3 before the definition\n+ *  of struct rusage, so the prototype (added by fixproto) causes havoc.\n+ */\n+fix = {\n+    hackname = aix_syswait;\n+    files    = sys/wait.h;\n+    select = \"bos325,\";\n+    sed    = \"/^extern pid_t wait3();$/i\\\\\\n\"\n+             \"struct rusage;\\n\";\n+};\n+\n+\n+/*\n+ *  sys/signal.h on some versions of AIX uses volatile in the typedef of\n+ *  sig_atomic_t, which causes gcc to generate a warning about duplicate\n+ *  volatile when a sig_atomic_t variable is declared volatile, as\n+ *  required by ANSI C.\n+ */\n+fix = {\n+    hackname = aix_volatile;\n+    files    = sys/signal.h;\n+    select   = \"typedef volatile int sig_atomic_t\";\n+    sed      = \"s/typedef volatile int sig_atomic_t\"\n+                \"/typedef int sig_atomic_t/\";\n+};\n+\n+\n+/*\n+ *  Fix getopt declarations in stdio.h and stdlib.h on Alpha OSF/1 and AIX.\n+ */\n+fix = {\n+    hackname = alpha_getopt;\n+    files  = \"stdio.h\";\n+    files  = \"stdlib.h\";\n+    select = 'getopt\\(int, char \\*\\[';\n+    sed    = 's/getopt(int, char \\*\\[\\],[ ]*char \\*)/'\n+               'getopt(int, char *const[], const char *)/';\n+};\n+\n+\n+/* \n+ * Determine if we're on Interactive Unix 2.2 or later, in which case we\n+ * need to fix some additional files.  This is the same test for ISC that\n+ * Autoconf uses.  On Interactive 2.2, certain traditional Unix\n+ * definitions (notably getc and putc in stdio.h) are omitted if __STDC__\n+ * is defined, not just if _POSIX_SOURCE is defined.  This makes it\n+ * impossible to compile any nontrivial program except with -posix.\n+ */\n+fix = {\n+    hackname = alpha_parens;\n+    files    = sym.h;\n+    select   = '#ifndef\\(__mips64\\)';\n+    sed      = \"s/#ifndef(__mips64)/#ifndef __mips64/\";\n+};\n+\n+\n+/*\n+ *  Fix return value of sbrk in unistd.h on Alpha OSF/1 V2.0\n+ */\n+fix = {\n+    hackname = alpha_sbrk;\n+    files    = unistd.h;\n+    select   = \"char[ \\t]*\\\\*[\\t ]*sbrk[ \\t]*\\\\(\";\n+    sed  = \"s/char\\\\([ \\t]*\\\\*[\\t ]*sbrk[ \\t]*(\\\\)/void\\\\1/\";\n+};\n+\n+\n+/*\n+ *  Fix this ARM/RISCiX file where ___type is a Compiler\n+ *  hint that is specific to the Norcroft compiler.\n+ */\n+fix = {\n+    hackname = arm_norcroft_hint;\n+    files    = \"X11/Intrinsic.h\";\n+    sed      = \"s/___type p_type/p_type/\";\n+};\n+\n+\n+/*\n+ *  Fix this ARM/RISCiX file to avoid interfering\n+ *  with the use of __wchar_t in cc1plus.\n+ */\n+fix = {\n+    hackname = arm_wchar;\n+    files  = stdlib.h;\n+    select = \"#[ \\t]*define[ \\t]*__wchar_t\";\n+    sed    = \"s/\\\\(#[ \\t]*ifndef[ \\t]*\\\\)__wchar_t/\\\\1_GCC_WCHAR_T/\";\n+    sed    = \"s/\\\\(#[ \\t]*define[ \\t]*\\\\)__wchar_t/\\\\1_GCC_WCHAR_T/\";\n+};\n+\n+\n+/*\n+ *  This file in A/UX 3.0.x/3.1.x contains an __asm directive for c89;\n+ *  gcc doesn't understand it.\n+ */\n+fix = {\n+    hackname = aux_asm;\n+    files    = sys/param.h;\n+    select   = \"#ifndef NOINLINE\";\n+    sed      = \"s|#ifndef NOINLINE\"\n+                \"|#if !defined(NOINLINE) \\\\&\\\\& !defined(__GNUC__)|\";\n+};\n+\n+\n+/*\n+ *  For C++, avoid any typedef or macro definition of bool,\n+ *  and use the built in type instead.\n+ */\n+fix = {\n+    hackname = avoid_bool;\n+    files    = curses.h;\n+    files    = term.h;\n+    files    = tinfo.h;\n+\n+    sed = \"/^#[ \\t]*define[ \\t][ \\t]*bool[ \\t][ \\t]*char[ \\t]*$/i\\\\\\n\"\n+                \"#ifndef __cplusplus\\n\";\n+\n+    sed = \"/^#[ \\t]*define[ \\t][ \\t]*bool[ \\t][ \\t]*char[ \\t]*$/a\\\\\\n\"\n+                \"#endif\\n\";\n+\n+    sed = \"/^typedef[ \\t][ \\t]*char[ \\t][ \\t]*bool[ \\t]*;/i\\\\\\n\"\n+                \"#ifndef __cplusplus\\n\";\n+\n+    sed = \"/^typedef[ \\t][ \\t]*char[ \\t][ \\t]*bool[ \\t]*;/a\\\\\\n\"\n+                \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  rpc/types.h on OSF1/2.0 is not C++ ready, even though NO_IMPLICIT_EXTERN_C\n+ *  is defined for the alpha.  The problem is the declaration of malloc.\n+ */\n+fix = {\n+    hackname = bad_malloc_decl;\n+    files    = rpc/types.h;\n+    bypass   = '\"C\"';\n+    sed      = \"1i\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"extern \\\"C\\\" {\\\\\\n\"\n+               \"#endif\\\\\\n\\n\";\n+    sed      = \"$a\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"}\\\\\\n\"\n+               \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix `typedef struct term;' on hppa1.1-hp-hpux9.\n+ */\n+fix = {\n+    hackname = bad_struct_term;\n+    files  = curses.h;\n+    select = \"^[ \\t]*typedef[ \\t]+struct[ \\t]+term[ \\t]*;\";\n+    sed    = \"s/^[ \\t]*typedef[ \\t][ \\t]*\"\n+             \"\\\\(struct[ \\t][ \\t]*term[ \\t]*;[ \\t]*\\\\)$/\\\\1/\";\n+};\n+\n+\n+/*\n+ *  Fix one other error in this file:\n+ *  a mismatched quote not inside a C comment.\n+ */\n+fix = {\n+    hackname = badquote;\n+    files    = sundev/vuid_event.h;\n+    sed      = \"s/doesn't/does not/\";\n+};\n+\n+\n+/*\n+ *  Fix #defines under Alpha OSF/1:\n+ *  The following files contain '#pragma extern_prefix \"_FOO\"' followed by\n+ *  a '#define something(x,y,z) _FOOsomething(x,y,z)'.  The intent of these\n+ *  statements is to reduce namespace pollution.  While these macros work\n+ *  properly in most cases, they don't allow you to take a pointer to the\n+ *  \"something\" being modified.  To get around this limitation, change these\n+ *  statements to be of the form '#define something _FOOsomething'.\n+ */\n+fix = {\n+    hackname = bad_lval;\n+    select   = \"^[ \\t]*#[ \\t]*pragma[ \\t]extern_prefix\";\n+    files    = libgen.h;\n+    files    = dirent.h;\n+    files    = ftw.h;\n+    files    = grp.h;\n+    files    = ndbm.h;\n+    files    = pthread.h;\n+    files    = pwd.h;\n+    files    = signal.h;\n+    files    = standards.h;\n+    files    = stdlib.h;\n+    files    = string.h;\n+    files    = stropts.h;\n+    files    = time.h;\n+    files    = unistd.h;\n+    sed      =\n+        \"s/^[ \\t]*#[ \\t]*define[ \\t]*\\\\([^(]*\\\\)\\\\(([^)]*)\\\\)[ \\t]*\"\n+               \"\\\\(_.\\\\)\\\\1\\\\2[ \\t]*$/#define \\\\1 \\\\3\\\\1/\";\n+};\n+\n+\n+/*\n+ *  check for broken assert.h that needs stdio.h\n+ */\n+fix = {\n+    hackname = broken_assert_stdio;\n+    files    = assert.h;\n+    select   = stderr;\n+    bypass   = \"include.*stdio.h\";\n+    sed      = \"1i\\\\\\n\"\n+               \"#include <stdio.h>\\n\";\n+};\n+\n+\n+/*\n+ *  check for broken assert.h that needs stdlib.h\n+ */\n+fix = {\n+    hackname = broken_assert_stdlib;\n+    files    = assert.h;\n+    select   = 'exit *\\(|abort *\\(';\n+    bypass   = \"include.*stdlib.h\";\n+    sed      = \"1i\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"#include <stdlib.h>\\\\\\n\"\n+               \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Note that BSD43_* are used on recent MIPS systems.\n+ */\n+fix = {\n+    hackname = bsd43_io_macros;\n+    select   = \"BSD43__IO\";\n+    /*\n+     *  Put single quotes aroung the character that appears after '('\n+     *  and before ',', UNLESS it is a 'c' or 'g' or 'x'.\n+     */\n+    sed = \"/[ \\t]BSD43__IO[A-Z]*[ \\t]*(/\"       's/(\\(.\\),/(\\'\\1\\',/';\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]BSD43__IO/\" 's/\\'\\([cgx]\\)\\'/\\1/g';\n+};\n+\n+#IFDEF no_more\n+/*\n+ *  And also with the HP-UX 10 and HP-UX 11 sys/pci.h file\n+ */\n+fix = {\n+    hackname = cxx_cmnt_hpux;\n+    files    = sys/pci.h;\n+    select   = \"System Private Structures\";\n+    sed      = \"s|//.*$||g\";\n+};\n+\n+\n+/*\n+ *  Turning // comments into normal comments trashes this IRIX 4.0.1\n+ *  header file, which embeds // comments inside multi-line\n+ *  comments.  If this looks like the IRIX header file, we refix it by\n+ *  just throwing away the // comments.\n+ */\n+fix = {\n+    hackname = cxx_cmnt_irix;\n+    files    = fam.h;\n+    select   = indigo.esd;\n+    sed      = \"s|//.*$||g\";\n+};\n+\n+\n+/*\n+ *  Same problem with a file from SunOS 4.1.3 : a header file containing\n+ *  the string \"//\" embedded in \"/ * * /\"\n+ */\n+fix = {\n+    hackname = cxx_cmnt_sunos;\n+    files    = sbusdev/audiovar.h;\n+    files    = sys/audiovar.h;\n+    sed      = \"s|//.*$||g\";\n+};\n+\n+\n+/*\n+ *  There is a similar problem with the VxWorks drv/netif/if_med.h file.\n+ */\n+fix = {\n+    hackname = cxx_cmnt_vxworks;\n+    files    = drv/netif/if_med.h;\n+    select   = \"Wind River\";\n+    sed      = \"s|//.*$||g\";\n+};\n+#endif\n+\n+/*\n+ *  Remove the double-slash comments\n+ *  They *must* be removed so it will not create nested comments!!\n+ *  However, they will *not* be removed if '++' is in any part of\n+ *  the file name, or if the name ends with \".hh\" or \".H\".\n+ *\n+ *  There *used* to be a number of similar problems in various OSes:\n+\n+ *  Turning // comments into normal comments trashes this IRIX 4.0.1\n+ *  header file, which embeds // comments inside multi-line\n+ *  comments.  If this looks like the IRIX header file, we refix it by\n+ *  just throwing away the // comments.\n+\n+ *  Same problem with a file from SunOS 4.1.3 : a header file containing\n+ *  the string \"//\" embedded in \"/ * * /\"\n+\n+ *  There is a similar problem with the VxWorks drv/netif/if_med.h file.\n+\n+ *  And also with the HP-UX 10 and HP-UX 11 sys/pci.h file\n+ */\n+fix = {\n+    hackname = no_double_slash;\n+    test     = '-z \"`echo ${file}|egrep \\'++$|\\.hh$|\\.H$\\'`\"';\n+    select = '//[^*]';\n+    sed    = '/\\/\\/[^*]/' \"s|//.*$||g\";\n+};\n+\n+\n+/*\n+ *  Multiline comment after typedef on IRIX 4.0.1.\n+ */\n+fix = {\n+    hackname = irix_bogus_cxx_cmnt;\n+    files  = \"elf_abi.h\";\n+    files  = \"elf.h\";\n+    /*\n+     *  This really looks like it is replacing \"/ * * /\" with \"//\"\n+     *  Shouldn't the replacement really be \" ## \"?\n+     */\n+    sed      = 's@\"/\\*\"\\*/@\"//\"@';\n+};\n+\n+\n+/*\n+ * Fix these Sun OS files to avoid an invalid identifier in an #ifdef.\n+ */\n+fix = {\n+    hackname = ecd_cursor;\n+    files  = \"sunwindow/win_lock.h\";\n+    files  = \"sunwindow/win_cursor.h\";\n+    sed    = \"s/ecd.cursor/ecd_cursor/\";\n+};\n+\n+\n+\n+/*\n+ *  Fix else directives that contain non-commentary text\n+ *\n+ * The fixinc_eol stuff is to work around a bug in the sed\n+ */\n+fix = {\n+    hackname = else_label;\n+    select   = \"^[ \\t]*#[ \\t]*else[ \\t]+[!-.0-~]\";\n+    sed =      \":loop\\n\"\n+               '/\\\\\\\\$/'                       \"N\\n\"\n+               's/\\\\\\\\$/\\\\\\\\+++fixinc_eol+++/' \"\\n\"\n+               '/\\\\\\\\$/'                       \"b loop\\n\"\n+               's/\\\\\\\\+++fixinc_eol+++/\\\\\\\\/g' \"\\n\"\n+\n+               \"s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t]*/[^*].*%\\\\1%\\n\"\n+               \"s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t]*[^/ \\t].*%\\\\1%\";\n+};\n+\n+\n+/*\n+ *  Fix endif directives that contain non-commentary text\n+ */\n+fix = {\n+    hackname = endif_label;\n+    /*\n+     *  Select files that contain '#endif' directives with\n+     *  some sort of following junk.  (Between the ascii '.'\n+     *  and '0' lies the character '/'.  This will *NOT*\n+     *  match '#endif / * foo * /', but it also wont match\n+     *  '#endif / done' either.\n+     *\n+     *  We use the pattern [!-.0-z{|}~] instead of [^/ \\t] to match a noncomment\n+     *  following #else or #endif because some buggy egreps think [^/] matches\n+     *  newline, and they thus think `#else ' matches\n+     *  `#e[ndiflse]*[ \\t]+[^/ \\t]'.\n+     *  [!-.0-~] does not work properly on AIX 4.1.\n+     */\n+    select   = \"^[ \\t]*#[ \\t]*endif[ \\t]+[!-.0-z\\{\\|\\}\\~]\";\n+\n+    /*\n+     *  First, join the continued input lines.\n+     *  IF the resulting line is an endif preprocessing directive,\n+     *  then trim off the following patterns:\n+     *  1.  sequences that start with '/' and is *NOT* followed by '*'\n+     *  2.  Sequences that start with '*' and is *NOT* followed by '/'\n+     *  3.  sequences that do not start with any of '/', '*', '\\t' or ' '.\n+     *\n+     * The fixinc_eol stuff is to work around a bug in the sed\n+     */\n+    sed =      \":loop\\n\"\n+               '/\\\\\\\\$/'                       \"N\\n\"\n+               's/\\\\\\\\$/\\\\\\\\+++fixinc_eol+++/' \"\\n\"\n+               '/\\\\\\\\$/'                       \"b loop\\n\"\n+               's/\\\\\\\\+++fixinc_eol+++/\\\\\\\\/g' \"\\n\"\n+\n+               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t]*/[^*].*%\\\\1%\\n\"\n+               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t]*\\\\*[^/].*%\\\\1%\\n\"\n+               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t]*[^/* \\t].*%\\\\1%\";\n+};\n+\n+\n+/*\n+ *  Fix HP's use of ../machine/inline.h to refer to\n+ *    /usr/include/machine/inline.h\n+ */\n+fix = {\n+    hackname = hp_inline;\n+    files  = sys/spinlock.h;\n+    select = 'include.*\"\\.\\./machine/';\n+    sed    = \"s,\\\"../machine/inline.h\\\",<machine/inline.h>,\";\n+    sed    = \"s,\\\"../machine/psl.h\\\",<machine/psl.h>,\";\n+};\n+\n+\n+/*\n+ *  Check for (...) in C++ code in HP/UX sys/file.h.\n+ */\n+fix = {\n+    hackname = hp_sysfile;\n+    files    = sys/file.h;\n+    select   = \"HPUX_SOURCE\";\n+    sed      = 's/(\\.\\.\\.)/(struct file * ...)/';\n+};\n+\n+\n+/*\n+ *  sys/mman.h on HP/UX is not C++ ready,\n+ *  even though NO_IMPLICIT_EXTERN_C is defined on HP/UX.\n+ */\n+fix = {\n+    hackname = hpux_cxx_unready;\n+    files    = sys/mman.h;\n+    bypass = '\"C\"|__BEGIN_DECLS';\n+\n+    sed      = \"1i\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"extern \\\"C\\\" {\\\\\\n\"\n+               \"#endif\\\\\\n\\n\";\n+    sed      = \"$a\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"}\\\\\\n\"\n+               \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  HPUX 10.x sys/param.h defines MAXINT which clashes with values.h\n+ */\n+fix = {\n+    hackname = hpux_maxint;\n+    files    = sys/param.h;\n+    sed      = \"/^#[ \\t]*define[ \\t]*MAXINT[ \\t]/i\\\\\\n\"\n+               \"#ifndef MAXINT\\n\";\n+\n+    sed      = \"/^#[ \\t]*define[ \\t]*MAXINT[ \\t]/a\\\\\\n\"\n+               \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix hpux10.20 <sys/time.h> to avoid invalid forward decl\n+ */\n+fix = {\n+    hackname = hpux_systime;\n+    files    = sys/time.h;\n+    select   = \"^extern struct sigevent;\";\n+    sed      = \"s/^extern struct sigevent;/struct sigevent;/\";\n+};\n+\n+\n+/*\n+ *  Fix various _IO* defines, but do *not* quote the characters cgxtf.\n+ */\n+fix = {\n+    hackname = interactv_add1;\n+\n+    test   = \"-d /etc/conf/kconfig.d\";\n+    test   = '-n \"`grep _POSIX_VERSION /usr/include/sys/unistd.h`\"';\n+\n+    files  = \"stdio.h\";\n+    files  = \"math.h\";\n+    files  = \"ctype.h\";\n+    files  = \"sys/limits.h\";\n+    files  = \"sys/fcntl.h\";\n+    files  = \"sys/dirent.h\";\n+\n+    sed    = \"s/!defined(__STDC__) && !defined(_POSIX_SOURCE)/\"\n+               \"!defined(_POSIX_SOURCE)/\";\n+};\n+\n+fix = {\n+    hackname = interactv_add2;\n+\n+    test   = \"-d /etc/conf/kconfig.d\";\n+    test   = '-n \"`grep _POSIX_VERSION /usr/include/sys/unistd.h`\"';\n+\n+    files  = math.h;\n+    sed    = \"s/fmod(double)/fmod(double, double)/\";\n+};\n+\n+fix = {\n+    hackname = interactv_add3;\n+\n+    test   = \"-d /etc/conf/kconfig.d\";\n+    test   = '-n \"`grep _POSIX_VERSION /usr/include/sys/unistd.h`\"';\n+\n+    files  = sys/limits.h;\n+\n+    sed    = \"/CHILD_MAX/s,/\\\\* Max, Max,\";\n+    sed    = \"/OPEN_MAX/s,/\\\\* Max, Max,\";\n+};\n+\n+\n+/*\n+ *  Remove erroneous parentheses in sym.h on Alpha OSF/1.\n+ */\n+fix = {\n+    hackname = io_def_quotes;\n+    select = \"[ \\t]_IO[A-Z]*[ \\t]*\\\\([A-Za-z]\";\n+    sed = \"s/\\\\([ \\t]_IO[A-Z]*[ \\t]*(\\\\)\\\\([A-Za-z]\\\\),/\\\\1'\\\\2',/\";\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]_IO/\"\n+              \"s/'\\\\([cgxtf]\\\\)'/\\\\1/g\";\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]DESIOC/\"    's/\\'\\([cdgx]\\)\\'/\\1/g';\n+};\n+\n+\n+/*\n+ *  Fix CTRL macros\n+ */\n+fix = {\n+    hackname = ioctl_fix_ctrl;\n+    select = \"CTRL[ \\t]\";\n+\n+    sed = \"/[^A-Z0-9_]CTRL[ \\t]*(/\"\n+              \"s/\\\\([^']\\\\))/'\\\\1')/\";\n+\n+    sed = \"/[^A-Z0-9]_CTRL[ \\t]*(/\"\n+              \"s/\\\\([^']\\\\))/'\\\\1')/\";\n+\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]CTRL/\"\n+              \"s/'\\\\([cgx]\\\\)'/\\\\1/g\";\n+\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]_CTRL/\"\n+              \"s/'\\\\([cgx]\\\\)'/\\\\1/g\";\n+\n+    sed = \"/#[ \\t]*define[ \\t]*[ \\t]BSD43_CTRL/\"\n+              \"s/'\\\\([cgx]\\\\)'/\\\\1/g\";\n+};\n+\n+\n+/*\n+ *  Check for missing ';' in struct\n+ */\n+fix = {\n+    hackname = ip_missing_semi;\n+    files    = netinet/ip.h;\n+    sed      = \"/^struct/,/^};/s/}$/};/\";\n+};\n+\n+\n+/*\n+ *  IRIX 4.0.5 <rpc/auth.h> uses struct sockaddr\n+ *  in prototype without previous definition.\n+ */\n+fix = {\n+    hackname = irix_multiline_cmnt;\n+    files    = sys/types.h;\n+\n+    sed   = \"s@type of the result@type of the result */@\";\n+    sed   = \"s@of the sizeof@/* of the sizeof@\";\n+};\n+\n+\n+/*\n+ *  Some IRIX header files contain the string \"//\"\n+ */\n+fix = {\n+    hackname = irix_sockaddr;\n+    files    = rpc/auth.h;\n+    select   = \"authdes_create.*struct sockaddr\";\n+    sed      = \"/authdes_create.*struct sockaddr/i\\\\\\n\"\n+               \"struct sockaddr;\\n\";\n+};\n+\n+\n+/*\n+ *  IRIX 4.0.5 <rpc/xdr.h> uses struct __file_s\n+ *  in prototype without previous definition.\n+ */\n+fix = {\n+    hackname = irix_struct__file;\n+    files = rpc/xdr.h;\n+    sed   = \"/xdrstdio_create.*struct __file_s/i\\\\\\n\"\n+            \"struct __file_s;\\n\";\n+};\n+\n+\n+/*\n+ * Fixing ISC fmod declaration\n+ */\n+fix = {\n+    hackname = isc_fmod;\n+    files    = math.h;\n+    select   = 'fmod\\(double\\)';\n+    sed      = \"s/fmod(double)/fmod(double, double)/\";\n+};\n+\n+  \n+/*\n+ * Fix nested comments in Motorola's <limits.h> and <sys/limits.h>\n+ */\n+fix = {\n+    hackname = motorola_nested;\n+    files    = limits.h;\n+    files    = sys/limits.h;\n+    sed = \"s@^\\\\(#undef[ \\t][ \\t]*PIPE_BUF[ \\t]*\"\n+                   \"/\\\\* max # bytes atomic in write to a\\\\)$@\\\\1 */@\";\n+    sed = \"s@\\\\(/\\\\*#define\\tHUGE_VAL\\t3.40282346638528860e+38 \\\\)\"\n+          \"\\\\(/\\\\*error value returned by Math lib\\\\*/\\\\)$@\\\\1*/ \\\\2@\";\n+};\n+\n+  \n+/*\n+ * Fixing nested comments in ISC <sys/limits.h>\n+ */\n+fix = {\n+    hackname = isc_sys_limits;\n+    files  = sys/limits.h;\n+    select = CHILD_MAX;\n+    sed    = \"/CHILD_MAX/s,/\\\\* Max, Max,\";\n+    sed    = \"/OPEN_MAX/s,/\\\\* Max, Max,\";\n+};\n+\n+\n+/*\n+ * These files in Sun OS 4.x and ARM/RISCiX and BSD4.3\n+ * use / * * / to concatenate tokens.\n+ */\n+fix = {\n+    hackname = kandr_concat;\n+    files  = \"sparc/asm_linkage.h\";\n+    files  = \"sun3/asm_linkage.h\";\n+    files  = \"sun3x/asm_linkage.h\";\n+    files  = \"sun4/asm_linkage.h\";\n+    files  = \"sun4c/asm_linkage.h\";\n+    files  = \"sun4m/asm_linkage.h\";\n+    files  = \"sun4c/debug/asm_linkage.h\";\n+    files  = \"sun4m/debug/asm_linkage.h\";\n+    files  = \"arm/as_support.h\";\n+    files  = \"arm/mc_type.h\";\n+    files  = \"arm/xcb.h\";\n+    files  = \"dev/chardefmac.h\";\n+    files  = \"dev/ps_irq.h\";\n+    files  = \"dev/screen.h\";\n+    files  = \"dev/scsi.h\";\n+    files  = \"sys/tty.h\";\n+    files  = \"Xm.acorn/XmP.h\";\n+    files  = bsd43/bsd43_.h;\n+    select = '/\\*\\*/';\n+    sed    = 's|/\\*\\*/| ## |g';\n+};\n+\n+\n+/*\n+ *  In limits.h, put #ifndefs around things that are supposed to be defined\n+ *  in float.h to avoid redefinition errors if float.h is included first.\n+ *  On HP/UX this patch does not work, because on HP/UX limits.h uses\n+ *  multi line comments and the inserted #endif winds up inside the\n+ *  comment.  Fortunately, HP/UX already uses #ifndefs in limits.h; if\n+ *  we find a #ifndef FLT_MIN we assume that all the required #ifndefs\n+ *  are there, and we do not add them ourselves.\n+ *  Also fix a nested comment problem in sys/limits.h on Motorola sysV68 R3V7.1\n+ */\n+fix = {\n+    hackname = limits_ifndefs;\n+    files  = \"limits.h\";\n+    bypass = \"ifndef[ \\t]+FLT_MIN\";\n+\n+    sed  = \"/[ \\t]FLT_MIN[ \\t]/i\\\\\\n#ifndef FLT_MIN\\n\";\n+    sed  = \"/[ \\t]FLT_MIN[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/[ \\t]FLT_MAX[ \\t]/i\\\\\\n#ifndef FLT_MAX\\n\";\n+    sed  = \"/[ \\t]FLT_MAX[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/[ \\t]FLT_DIG[ \\t]/i\\\\\\n#ifndef FLT_DIG\\n\";\n+    sed  = \"/[ \\t]FLT_DIG[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/[ \\t]DBL_MIN[ \\t]/i\\\\\\n#ifndef DBL_MIN\\n\";\n+    sed  = \"/[ \\t]DBL_MIN[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/[ \\t]DBL_MAX[ \\t]/i\\\\\\n#ifndef DBL_MAX\\n\";\n+    sed  = \"/[ \\t]DBL_MAX[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/[ \\t]DBL_DIG[ \\t]/i\\\\\\n#ifndef DBL_DIG\\n\";\n+    sed  = \"/[ \\t]DBL_DIG[ \\t]/a\\\\\\n#endif\\n\";\n+    sed  = \"/^\\\\(\\\\/\\\\*#define\\tHUGE_VAL\\t3\\\\.[0-9e+]* *\\\\)\\\\/\\\\*/s//\\\\1/\";\n+};\n+\n+\n+/*\n+ *  Delete the '#define void int' line from curses.h on Lynx\n+ */\n+fix = {\n+    hackname = lynx_void_int;\n+    files    = curses.h;\n+    select   = \"#[ \\t]*define[ \\t]+void[ \\t]+int\";\n+    sed      = \"/#[ \\t]*define[ \\t][ \\t]*void[ \\t]int/d\";\n+};\n+\n+\n+/*\n+ *  Fix fcntl prototype in fcntl.h on LynxOS.\n+ */\n+fix = {\n+    hackname = lynxos_fcntl_proto;\n+    files    = fcntl.h;\n+\n+  sed = 's/\\(fcntl.*(int, int, \\)int)/\\1...)/';\n+};\n+\n+\n+/*\n+ *  Fix incorrect S_IF* definitions on m88k-sysv3.\n+ */\n+fix = {\n+    hackname = m88k_bad_hypot_opt;\n+    mach     = \"m88k-motorola-sysv3*\";\n+    files    = \"math.h\";\n+\n+    sed = \"s/extern double floor(), ceil(), fmod(), fabs();/\"\n+            \"extern double floor(), ceil(), fmod(), fabs _PARAMS((double));/\";\n+\n+    sed = \"/^extern double hypot();$/a\\\\\\n\"\n+          \"\\\\/* Workaround a stupid Motorola optimization if one\\\\\\n\"\n+          \"   of x or y is 0.0 and the other is negative!  *\\\\/\\\\\\n\"\n+          \"#ifdef __STDC__\\\\\\n\"\n+          \"static __inline__ double fake_hypot (double x, double y)\\\\\\n\"\n+          \"#else\\\\\\n\"\n+          \"static __inline__ double fake_hypot (x, y)\\\\\\n\"\n+          \"\\tdouble x, y;\\\\\\n\"\n+          \"#endif\\\\\\n\"\n+          \"{\\\\\\n\"\n+          \"\\treturn fabs (hypot (x, y));\\\\\\n\"\n+          \"}\\\\\\n\"\n+          \"#define hypot\\tfake_hypot\\n\";\n+};\n+\n+\n+/*\n+ *  Fix non-ansi machine name defines\n+ *  This is split into two parts:  the shell version as a single\n+ *  patch, and the program version with each patch separate.\n+ *  Each is substantially faster for the particular environment.\n+ * You have a dual maintenance problem here.  */\n+fix = {\n+    hackname = m88k_bad_s_if;\n+    mach     = \"m88k-*-sysv3*\";\n+    files    = sys/stat.h;\n+    select   = \"#define[ \\t]+S_IS[A-Z]*(m)[ \\t]\";\n+\n+    sed = \"s/^\\\\(#define[ \\t]*S_IS[A-Z]*(m)\\\\)[ \\t]*\"\n+            \"(m[ \\t]*&[ \\t]*\\\\(S_IF[A-Z][A-Z][A-Z][A-Z]*\\\\)[ \\t]*)/\"\n+            \"\\\\1 (((m)\\\\&S_IFMT)==\\\\2)/\";\n+\n+    sed = \"s/^\\\\(#define[ \\t]*S_IS[A-Z]*(m)\\\\)[ \\t]*\"\n+            \"(m[ \\t]*&[ \\t]*\\\\(0[0-9]*\\\\)[ \\t]*)/\"\n+            \"\\\\1 (((m)\\\\&S_IFMT)==\\\\2)/\";\n+};\n+\n+\n+/*\n+ * Put cpp wrappers around these include files to avoid redeclaration\n+ * errors during multiple inclusion on m88k-tektronix-sysv3.\n+ */\n+fix = {\n+    hackname = m88k_multi_incl;\n+    mach     = \"m88k-tektronix-sysv3*\";\n+    files    = \"time.h\";\n+    bypass   = \"#ifndef\";\n+    shell    =\n+      \"echo Fixing $file, to protect against multiple inclusion. >&2\n+      cpp_wrapper=`echo $file | sed -e 's,\\\\.,_,g' -e 's,/,_,g'`\n+      sed -e \\\"1i\\\\\\n\"\n+        \"#ifndef __GCC_GOT_${cpp_wrapper}_\\\\\\n\"\n+        \"#define __GCC_GOT_${cpp_wrapper}_\\\\\\n\\\" \\\\\\n\"\n+                \"\\t-e \\\"$a\\\\\\n\"\n+        \"#endif /* ! __GCC_GOT_${cpp_wrapper}_ */\\n\\\"\";\n+};\n+\n+\n+/*\n+ *  libm.a on m88k-motorola-sysv3 contains a stupid optimization for\n+ *  function hypot(), which returns the second argument without even\n+ *  looking at its value if the other is 0.0 Another drawback is that\n+ *  fix-header doesn't fix fabs' prototype, and I have no idea why.\n+ */\n+fix = {\n+    hackname = machine_name;\n+    /*\n+     *  Select '#if.*' and '#elif\" with possible non-ansi symbols\n+     *  The only non-ansi symbols we know about start with one of:\n+     *     MRS_bhimnprstuv\n+     *  If any are added to the substitution list, then add it to\n+     *  the selection list as well.  Hopefully we can avoid names\n+     *  starting with \"d\" and \"l\", because this pattern would then\n+     *  match \"defined\" and \"lint\" as well.  I suppose we could add\n+     *  a \"bypass = lint\" if we had to though.\n+     *\n+     * The fixinc_eol stuff is to work around a bug in the sed\n+     */\n+    select = \"^#[ \\t]*(if|elif).*\"\n+             \"[^a-zA-Z0-9_](_*[MSRrhim]|[Mbimnpstuv])[a-zA-Z0-9_]\";\n+    exesel = \"^#[ \\t]*(if|elif).*[^a-zA-Z0-9_]\"\n+             \"(\"\n+                  \"M32\"\n+                 \"|_*(\"\n+                       \"MIPSE[LB]\"\n+                      \"|SYSTYPE_[A-Z0-9]\"\n+                      \"|[Rr][34]000\"\n+                      \"|host_mips\"\n+                      \"|i386\"\n+                      \"|mips\"\n+                    \")($|[^a-zA-Z0-9_])\"\n+                 \"|bsd4\"\n+                 \"|is68k\"\n+                 \"|m[68]8k\"\n+                 \"|mc680\"\n+                 \"|news\"\n+                 \"|ns32000\"\n+                 \"|pdp11\"\n+                 \"|pyr\"\n+                 \"|sel\"\n+                 \"|sony_news\"\n+                 \"|sparc\"\n+                 \"|sun\"\n+                 \"|tahoe\"\n+                 \"|tower\"\n+                 \"|u370\"\n+                 \"|u3b\"\n+                 \"|unix\"\n+                 \"|vax\"\n+             \")\";\n+\n+    sed =      \":loop\\n\"\n+               '/\\\\\\\\$/'                       \"N\\n\"\n+               's/\\\\\\\\$/\\\\\\\\+++fixinc_eol+++/' \"\\n\"\n+               '/\\\\\\\\$/'                       \"b loop\\n\"\n+               's/\\\\\\\\+++fixinc_eol+++/\\\\\\\\/g' \"\\n\"\n+\n+          \"/#[\\t ]*[el]*if/ {\\n\"\n+                \"\\ts/[a-zA-Z0-9_][a-zA-Z0-9_]*/ & /g\\n\"\n+\n+                \"\\ts/ M32 / __M32__ /g\\n\"\n+                \"\\ts/ _*MIPSE\\\\([LB]\\\\) / __MIPSE\\\\1__ /g\\n\"\n+                \"\\ts/ _*SYSTYPE_\\\\([A-Z0-9]*\\\\) / __SYSTYPE_\\\\1__ /g\\n\"\n+                \"\\ts/ _*\\\\([Rr][34]\\\\)000 / __\\\\1000__ /g\\n\"\n+                \"\\ts/ _*host_mips / __host_mips__ /g\\n\"\n+                \"\\ts/ _*i386 / __i386__ /g\\n\"\n+                \"\\ts/ _*mips / __mips__ /g\\n\"\n+                \"\\ts/ bsd4\\\\([0-9]\\\\) / __bsd4\\\\1__ /g\\n\"\n+                \"\\ts/ is68k / __is68k__ /g\\n\"\n+                \"\\ts/ m68k / __m68k__ /g\\n\"\n+                \"\\ts/ m88k / __m88k__ /g\\n\"\n+                \"\\ts/ mc680\\\\([0-9]\\\\)0 / __mc680\\\\10__ /g\\n\"\n+                \"\\ts/ news\\\\([0-9]*\\\\) / __news\\\\1__ /g\\n\"\n+                \"\\ts/ ns32000 / __ns32000__ /g\\n\"\n+                \"\\ts/ pdp11 / __pdp11__ /g\\n\"\n+                \"\\ts/ pyr / __pyr__ /g\\n\"\n+                \"\\ts/ sel / __sel__ /g\\n\"\n+                \"\\ts/ sony_news / __sony_news__ /g\\n\"\n+                \"\\ts/ sparc / __sparc__ /g\\n\"\n+                \"\\ts/ sun\\\\([a-z0-9]*\\\\) / __sun\\\\1__ /g\\n\"\n+                \"\\ts/ tahoe / __tahoe__ /g\\n\"\n+                \"\\ts/ tower\\\\([_0-9]*\\\\) / __tower\\\\1__ /g\\n\"\n+                \"\\ts/ u370 / __u370__ /g\\n\"\n+                \"\\ts/ u3b\\\\([0-9]*\\\\) / __u3b\\\\1__ /g\\n\"\n+                \"\\ts/ unix / __unix__ /g\\n\"\n+                \"\\ts/ vax / __vax__ /g\\n\"\n+\n+                \"\\ts/ \\\\([a-zA-Z0-9_][a-zA-Z0-9_]*\\\\) /\\\\1/g\\n\\t}\";\n+};\n+\n+\n+/*\n+ *  Some math.h files define struct exception, which conflicts with\n+ *  the class exception defined in the C++ file std/stdexcept.h.  We\n+ *  redefine it to __math_exception.  This is not a great fix, but I\n+ *  haven't been able to think of anything better.\n+ */\n+fix = {\n+    hackname = math_exception;\n+    files    = math.h;\n+    select   = \"struct exception\";\n+    sed      = \"/struct exception/i\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"#define exception __math_exception\\\\\\n\"\n+               \"#endif\\n\";\n+    sed      = \"/struct exception/a\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"#undef exception\\\\\\n\"\n+               \"#endif\\n\";\n+\n+    sed      = \"/matherr/i\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"#define exception __math_exception\\\\\\n\"\n+               \"#endif\\n\";\n+\n+    sed      = \"/matherr/a\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"#undef exception\\\\\\n\"\n+               \"#endif\\n\";\n+};\n+\n+\n+/*\n+ * In math.h, put #ifndefs around things that might be defined\n+ * in a gcc specific math-*.h file.\n+ */\n+fix = {\n+    hackname = math_gcc_ifndefs;\n+    files    = math.h;\n+    shell    = \" dbl_max_def=\"\n+        \"\\\"`egrep 'define[ \\t]+DBL_MAX[ \\t]+.*' ${SRCDIR}/float.h \"\n+                \"2>/dev/null`\\\"\\n\\n\"\n+\n+        \"\\tif ( test -n \\\"${dbl_max_def}\\\" \\\\\\n\"\n+        \"\\t\\t-a -n \\\"`egrep '#define[ \\t]*HUGE_VAL[ \\t]+DBL_MAX' $file`\\\" \\\\\\n\"\n+        \"\\t\\t-a -z \\\"`egrep '#define[ \\t]+DBL_MAX[ \\t]+' $file`\\\"\\n\"\n+              \"\\t   ) > /dev/null 2>&1\\n\"\n+\n+        \"\\tthen sed -e '/define[ \\t]HUGE_VAL[ \\t]/i\\\\\\n\"\n+            \"#ifndef HUGE_VAL\\n' \\\\\\n\"\n+        \"\\t-e '/define[ \\t]HUGE_VAL[ \\t]/a\\\\\\n#endif\\n'\\\\\\n\"\n+        \"\\t-e \\\"/define[ \\t]HUGE_VAL[ \\t]DBL_MAX/s/DBL_MAX/$dbl_max_def/\\\"\\n\"\n+\n+        \"\\telse sed -e '/define[ \\t]HUGE_VAL[ \\t]/i\\\\\\n\"\n+            \"#ifndef HUGE_VAL\\n' \\\\\\n\"\n+        \"\\t-e '/define[ \\t]HUGE_VAL[ \\t]/a\\\\\\n#endif\\n'\\n\"\n+        \"\\tfi\";\n+};\n+\n+\n+/*\n+ * libm.a on m88k-motorola-sysv3 contains a stupid optimization for\n+ * function hypot(), which returns the second argument without even\n+ * looking at its value\n+ */\n+fix = {\n+    hackname = motorola_stupid_opt;\n+    mach     = \"m88k-motorola-sysv3*\";\n+    files    = math.h;\n+    select   = \"^extern double hypot();$\";\n+    sed      =\n+          '/^extern double hypot();$/a' \"\\\\\\n\"\n+          '\\/* Workaround a stupid Motorola optimization if one' \"\\\\\\n\"\n+          '   of x or y is 0.0 and the other is negative!  *\\/' \"\\\\\\n\"\n+          '#ifdef __STDC__' \"\\\\\\n\"\n+          'static __inline__ double fake_hypot (double x, double y)' \"\\\\\\n\"\n+          '#else' \"\\\\\\n\"\n+          'static __inline__ double fake_hypot (x, y)' \"\\\\\\n\"\n+          \"\\tdouble x, y;\\\\\\n\"\n+          '#endif' \"\\\\\\n\"\n+          '{' \"\\\\\\n\"\n+          \"\\treturn fabs (hypot (x, y));\\\\\\n\"\n+          '}' \"\\\\\\n\"\n+          \"#define hypot\\tfake_hypot\\n\";\n+};\n+\n+\n+/*\n+ *  nested comment\n+ */\n+fix = {\n+    hackname = nested_comment;\n+    files    = rpc/rpc.h;\n+    sed      = 's@^\\(/\\*.*rpc/auth_des.h>.*\\)/\\*@\\1*/ /*@';\n+};\n+\n+\n+/*\n+ *  fix bogus recursive stdlib.h in NEWS-OS 4.0C\n+ */\n+fix = {\n+    hackname = news_os_recursion;\n+    files    = stdlib.h;\n+    select   = \"#include <stdlib.h>\";\n+    sed      = \"/^#include <stdlib.h>/i\\\\\\n\"\n+                    \"#ifdef BOGUS_RECURSION\\n\";\n+    sed      = \"/^#include <stdlib.h>/a\\\\\\n\"\n+                    \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  NeXT 3.2 adds const prefix to some math functions.\n+ *  These conflict with the built-in functions.\n+ */\n+fix = {\n+    hackname = next_math_prefix;\n+    files    = ansi/math.h;\n+    select   = \"^extern.*double.*__const__.*\";\n+\n+    sed = \"/^extern.*double.*__const__.*sqrt(/s/__const__//\";\n+    sed = \"/^extern.*double.*__const__.*fabs(/s/__const__//\";\n+    sed = \"/^extern.*double.*__const__.*cos(/s/__const__//\";\n+    sed = \"/^extern.*double.*__const__.*hypot(/s/__const__//\";\n+    sed = \"/^extern.*double.*__const__.*sin(/s/__const__//\";\n+};\n+\n+\n+/*\n+ *  NeXT 3.2 uses the word \"template\" as a parameter for some\n+ *  functions. GCC reports an invalid use of a reserved key word\n+ *  with the built-in functions. NeXT 3.2 includes the keyword\n+ *  volatile in the prototype for abort(). This conflicts with\n+ *  the built-in definition.\n+ */\n+fix = {\n+    hackname = next_template;\n+    files    = bsd/libc.h;\n+    select   = template;\n+\n+    sed = '/\\(.*template\\)/s/template//';\n+    sed = \"/extern.*volatile.*void.*abort/s/volatile//\";\n+};\n+\n+\n+/*\n+ *  NeXT 3.2 includes the keyword volatile in the abort() and  exit()\n+ *  function prototypes. That conflicts with the  built-in functions.\n+ */\n+fix = {\n+    hackname = next_volitile;\n+    files    = ansi/stdlib.h;\n+    select   = volatile;\n+\n+    sed    = \"/extern.*volatile.*void.*exit/s/volatile//\";\n+    sed    = \"/extern.*volatile.*void.*abort/s/volatile//\";\n+};\n+\n+\n+/*\n+ *  NeXT 2.0 defines 'int wait(union wait*)', which conflicts with Posix.1.\n+ *  Note that version 3 of the NeXT system has wait.h in a different directory,\n+ *  so that this code won't do anything.  But wait.h in version 3 has a\n+ *  conditional, so it doesn't need this fix.  So everything is okay.\n+ */\n+fix = {\n+    hackname = next_wait_union;\n+    files    = sys/wait.h;\n+\n+    select = 'wait\\(union wait';\n+\n+    sed = \"s@wait(union wait@wait(void@\";\n+};\n+\n+\n+/*\n+ *  a missing semi-colon at the end of the nodeent structure definition.\n+ */\n+fix = {\n+    hackname = nodeent_syntax;\n+    files    = netdnet/dnetdb.h;\n+    sed      = \"s/char.*na_addr *$/char *na_addr;/\";\n+};\n+\n+\n+/*\n+ *  sys/lc_core.h on some versions of OSF1/4.x pollutes the namespace by\n+ *  defining regex.h related types.  This causes libg++ build and usage\n+ *  failures.  Fixing this correctly requires checking and modifying 3 files.\n+ */\n+fix = {\n+    hackname = osf_namespace_a;\n+    files    = reg_types.h;\n+    files    = sys/lc_core.h;\n+    test     =    \"-r reg_types.h\"\n+               \"-a -r sys/lc_core.h\"\n+               \"-a -n \\\"`grep '} regex_t;' reg_types.h`\\\"\"\n+               \"-a -z \\\"`grep __regex_t regex.h`\\\"\";\n+\n+    sed      = \"s/regex_t/__regex_t/g\";\n+    sed      = \"s/regoff_t/__regoff_t/g\";\n+    sed      = \"s/regmatch_t/__regmatch_t/g\";\n+};\n+\n+fix = {\n+    hackname = osf_namespace_b;\n+    files    = regex.h;\n+    test     =    \"-r reg_types.h\"\n+               \"-a -r sys/lc_core.h\"\n+               \"-a -n \\\"`grep '} regex_t;' reg_types.h`\\\"\"\n+               \"-a -z \\\"`grep __regex_t regex.h`\\\"\";\n+    sed      = \"/#include <reg_types.h>/a\\\\\\n\"\n+               \"typedef __regex_t\\tregex_t;\\\\\\n\"\n+               \"typedef __regoff_t\\tregoff_t;\\\\\\n\"\n+               \"typedef __regmatch_t\\tregmatch_t;\\n\";\n+};\n+\n+\n+/*\n+ *  Fix __page_size* declarations in pthread.h AIX 4.1.[34].\n+ *  The original ones fail if uninitialized externs are not common.\n+ *  This is the default for all ANSI standard C++ compilers.\n+ */\n+fix = {\n+    hackname = pthread_page_size;\n+    files    = pthread.h;\n+    select   = \"^int __page_size\";\n+    sed      = \"s/^int __page_size/extern int __page_size/\";\n+};\n+\n+\n+/*\n+ *  Fix return type of fread and fwrite on sysV68\n+ */\n+#ifdef LATER\n+fix = {\n+    hackname = read_ret_type;\n+    files    = stdio.h;\n+    sed      = \"s/^\\\\(extern int\\tfclose(), fflush()\\\\), \"\n+                 \"\\\\(fread(), fwrite()\\\\)\\\\(.*\\\\)$\"\n+               \"/extern unsigned int\\t\\\\2;\\\\\\n\\\\1\\\\3/\";\n+};\n+#endif\n+\n+\n+/*\n+ *  function class(double x) conflicts with C++ keyword on rs/6000 \n+ */\n+fix = {\n+    hackname = rs6000_double;\n+    files    = math.h;\n+    select   = '[^a-zA-Z_]class\\(';\n+    \n+    sed   = \"/class[(]/i\\\\\\n#ifndef __cplusplus\\n\";\n+    sed   = \"/class[(]/a\\\\\\n#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Wrong fchmod prototype on RS/6000.\n+ */\n+fix = {\n+    hackname = rs6000_fchmod;\n+    files    = sys/stat.h;\n+    select   = 'fchmod\\(char';\n+    sed      = 's/fchmod(char \\*/fchmod(int/';\n+};\n+\n+\n+/*\n+ *  parameters conflict with C++ new on rs/6000 \n+ */\n+fix = {\n+    hackname = rs6000_param;\n+    files  = \"stdio.h\";\n+    files  = \"unistd.h\";\n+\n+    sed = 's@rename(const char \\*old, const char \\*new)@'\n+            'rename(const char *_old, const char *_new)@';\n+};\n+\n+\n+/*\n+ *  Sony NEWSOS 5.0 does not support the complete ANSI C standard.\n+ */\n+#ifdef SONY\n+fix = {\n+    hackname = sony_ctype;\n+    files    = ctype.h;\n+    test     = \"-x /bin/sony\";\n+    test     = \"! -z \\\"`if /bin/sony ; then echo true ; fi`\\\"\";\n+    sed      = \"s/__ctype/_ctype/g\";\n+};\n+#endif\n+\n+/*\n+ *  Incorrect #include in Sony News-OS 3.2.\n+ */\n+fix = {\n+    hackname = sony_include;\n+    files    = machine/machparam.h;\n+    select   = '\"\\.\\./machine/endian.h\"';\n+    sed      = 's@\"../machine/endian.h\"@<machine/endian.h>@';\n+};\n+\n+\n+/*\n+ *  Sony NEWSOS 5.0 does not support the complete ANSI C standard.\n+ */\n+#ifdef SONY\n+fix = {\n+    hackname = sony_stdio;\n+    files    = stdio.h;\n+    test     = \"-x /bin/sony\";\n+    test     = \"! -z \\\"`if /bin/sony ; then echo true ; fi`\\\"\";\n+    sed      = \"s/__filbuf/_filbuf/g\\n\"\n+               \"s/__flsbuf/_flsbuf/g\\n\"\n+               \"s/__iob/_iob/g\";\n+};\n+#endif\n+\n+/*\n+ *  Add a `static' declaration of `getrnge' into <regexp.h>.\n+ *\n+ *  Don't do this if there is already a `static void getrnge' declaration\n+ *  present, since this would cause a redeclaration error.  Solaris 2.x has\n+ *  such a declaration.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = static_getrnge;\n+    files    = regexp.h;\n+    bypass   = \"static void getrnge\";\n+    sed      = \"/^static int[ \\t]*size;/c\\\\\\n\"\n+               \"static int      size ;\\\\\\n\\\\\\n\"\n+               \"static int getrnge ();\";\n+};\n+#endif\n+\n+/*\n+ *  a missing semi-colon at the end of the statsswtch structure definition.\n+ */\n+fix = {\n+    hackname = statsswtch;\n+    files    = rpcsvc/rstat.h;\n+    select   = \"boottime$\";\n+    sed      = \"s/boottime$/boottime;/\";\n+};\n+\n+\n+/*\n+ *  Don't use or define the name va_list in stdio.h.\n+ *  This is for ANSI and also to interoperate properly with gcc's varargs.h.\n+ *  Arrange for stdio.h to use stdarg.h to define __gnuc_va_list\n+ */\n+fix = {\n+    hackname = stdio_va_list;\n+    files    = stdio.h;\n+\n+    /*\n+     * Use __gnuc_va_list in arg types in place of va_list.\n+     * On 386BSD use __gnuc_va_list instead of _VA_LIST_.  We're hoping the\n+     * trailing parentheses and semicolon save all other systems from this.\n+     * Define __va_list__ (something harmless and unused) instead of va_list.\n+     * Don't claim to have defined va_list.\n+     */\n+    shell =\n+ \"if ( egrep \\\"__need___va_list\\\" $file ) > /dev/null 2>&1 ; then\n+    :\n+  else\n+    echo \\\"#define __need___va_list\\\"\n+    echo \\\"#include <stdarg.h>\\\"\n+  fi\n+\n+  sed -e 's@ va_list @ __gnuc_va_list @' \\\\\n+      -e 's@ va_list)@ __gnuc_va_list)@' \\\\\n+      -e 's@ _BSD_VA_LIST_));@ __gnuc_va_list));@' \\\\\n+      -e 's@ _VA_LIST_));@ __gnuc_va_list));@' \\\\\n+      -e 's@ va_list@ __va_list__@' \\\\\n+      -e 's@\\\\*va_list@*__va_list__@' \\\\\n+      -e 's@ __va_list)@ __gnuc_va_list)@' \\\\\n+      -e 's@GNUC_VA_LIST@GNUC_Va_LIST@' \\\\\n+      -e 's@_NEED___VA_LIST@_NEED___Va_LIST@' \\\\\n+      -e 's@VA_LIST@DUMMY_VA_LIST@' \\\\\n+      -e 's@_Va_LIST@_VA_LIST@'\";\n+};\n+\n+\n+/*\n+ *  Check for strict ansi compliance\n+ */\n+#ifdef STRICT_ANSI\n+fix = {\n+    hackname = strict_ansi;\n+    select   = \"__STDC__[ \\t]*[=!]=[ \\t]*[01]\";\n+    sed      = \"s/__STDC__[ \\t]*==[ \\t]*0/!defined (__STRICT_ANSI__)/g\";\n+    sed      = \"s/__STDC__[ \\t]*!=[ \\t]*0/defined (__STRICT_ANSI__)/g\";\n+    sed      = \"s/__STDC__[ \\t]*==[ \\t]*1/defined (__STRICT_ANSI__)/g\";\n+    sed      = \"s/__STDC__[ \\t]*!=[ \\t]*1/!defined (__STRICT_ANSI__)/g\";\n+};\n+#endif\n+\n+/*\n+ *  Fix bogus #ifdef on SunOS 4.1.\n+ */\n+fix = {\n+    hackname = sun_bogus_ifdef;\n+    files  = \"hsfs/hsfs_spec.h\";\n+    files  = \"hsfs/iso_spec.h\";\n+    select = '#ifdef __i386__ || __vax__';\n+    sed    = \"s/\\\\#ifdef __i386__ || __vax__/\\\\#if __i386__ || __vax__/g\";\n+};\n+\n+\n+/*\n+ *  Fix bogus #ifdef on SunOS 4.1.\n+ */\n+fix = {\n+    hackname = sun_bogus_ifdef_sun4c;\n+    files  = \"hsfs/hsnode.h\";\n+    select = '#ifdef __i386__ || __sun4c__';\n+    sed    = \"s/\\\\#ifdef __i386__ || __sun4c__/\\\\#if __i386__ || __sun4c__/g\";\n+};\n+\n+\n+/*\n+ *  Fix the CAT macro in SunOS memvar.h.\n+ */\n+fix = {\n+    hackname = sun_catmacro;\n+    files  = pixrect/memvar.h;\n+    select = \"^#define[ \\t]+CAT(a,b)\";\n+    sed    = \"/^#define[ \\t]CAT(a,b)/ i\\\\\\n\"\n+                 \"#ifdef __STDC__ \\\\\\n\"\n+                 \"#define CAT(a,b) a##b\\\\\\n\"\n+                 \"#else\\n\";\n+\n+    sed    = \"/^#define[ \\t]CAT(a,b)/ a\\\\\\n\"\n+                 \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix return type of free and {c,m,re}alloc in <malloc.h> on SunOS 4.1.\n+ *  Also fix return type of {m,re}alloc in <malloc.h> on sysV68\n+ */\n+fix = {\n+    hackname = sun_malloc;\n+    files    = malloc.h;\n+\n+    sed   = \"s/typedef[ \\t]char \\\\*\\tmalloc_t/typedef void \\\\*\\tmalloc_t/g\";\n+    sed   = \"s/int[ \\t][ \\t]*free/void\\tfree/g\";\n+    sed   = \"s/char\\\\([ \\t]*\\\\*[ \\t]*malloc\\\\)/void\\\\1/g\";\n+    sed   = \"s/char\\\\([ \\t]*\\\\*[ \\t]*realloc\\\\)/void\\\\1/g\";\n+};\n+\n+\n+/*\n+ *  Fix non-ANSI memcpy declaration that conflicts with gcc's builtin\n+ *  declaration on Sun OS 4.x.  We must only fix this on Sun OS 4.x, because\n+ *  many other systems have similar text but correct versions of the file.\n+ *  To ensure only Sun's is fixed, we grep for a likely unique string.\n+ *  Fix also on sysV68 R3V7.1 (head/memory.h\\t50.1\\t )\n+ */\n+fix = {\n+    hackname = sun_memcpy;\n+    files    = memory.h;\n+    select = \"/\\\\*\\t@\\\\(#\\\\)\"\n+             \"(head/memory.h\\t50.1\\t \"\n+             \"|memory\\\\.h 1\\\\.[2-4] 8./../.. SMI; from S5R2 1\\\\.2\\t)\\\\*/\";\n+\n+    sed    = \"1i\\\\\\n/* This file was generated by fixincludes */\\\\\\n\"\n+             \"#ifndef __memory_h__\\\\\\n\"\n+             \"#define __memory_h__\\\\\\n\\\\\\n\"\n+             \"#ifdef __STDC__\\\\\\n\"\n+             \"extern void *memccpy();\\\\\\n\"\n+             \"extern void *memchr();\\\\\\n\"\n+             \"extern void *memcpy();\\\\\\n\"\n+             \"extern void *memset();\\\\\\n\"\n+             \"#else\\\\\\n\"\n+             \"extern char *memccpy();\\\\\\n\"\n+             \"extern char *memchr();\\\\\\n\"\n+             \"extern char *memcpy();\\\\\\n\"\n+             \"extern char *memset();\\\\\\n\"\n+             \"#endif /* __STDC__ */\\\\\\n\\\\\\n\"\n+             \"extern int memcmp();\\\\\\n\\\\\\n\"\n+             \"#endif /* __memory_h__ */\\n\";\n+\n+    sed    = \"1,$d\";\n+};\n+\n+\n+/*\n+ *  Check for yet more missing ';' in struct (in SunOS 4.0.x)\n+ */\n+fix = {\n+    hackname = sun_rusers_semi;\n+    files    = rpcsvc/rusers.h;\n+    select   = \"_cnt$\";\n+    sed      = \"/^struct/,/^};/s/_cnt$/_cnt;/\";\n+};\n+\n+\n+/*\n+ *  signal.h on SunOS defines signal using (),\n+ *  which causes trouble when compiling with g++ -pedantic.\n+ */\n+fix = {\n+    hackname = sun_signal;\n+    files    = sys/signal.h;\n+    files    = signal.h;\n+    select   = \"^void\\t\" '\\(\\*signal\\(\\)\\)\\(\\);';\n+\n+    sed = \"/^void\\t\" '(\\*signal())();$/i'  \"\\\\\\n\"\n+          \"#ifdef __cplusplus\"             \"\\\\\\n\"\n+          \"void\\t(*signal(...))(...);\"     \"\\\\\\n\"\n+          \"#else\"                          \"\\n\";\n+\n+    sed = \"/^void\\t\" '(\\*signal())();$/a'  \"\\\\\\n\"\n+          '#endif'                         \"\\n\";\n+};\n+\n+\n+/*\n+ *  On *some* SunOS-es, rpc/auth.h, rpc/clnt.h, rpc/svc.h, and\n+ *  rpc/xdr.h need prototypes for its ops function pointers.\n+ */\n+fix = {\n+    hackname = sun_auth_proto;\n+    files    = rpc/auth.h;\n+    files    = rpc/clnt.h;\n+    files    = rpc/svc.h;\n+    files    = rpc/xdr.h;\n+    mach     = \"*-sun-*\";\n+    /*\n+     *  Select those files containing '(*name)()' but *not*\n+     *  containing '(*name)(junk)'.  The change would be innocuous\n+     *  but there is no point bothering if the fix is not needed.\n+     */\n+    select   = '\\(\\*[a-z][a-z_]*\\)\\(\\)';\n+    bypass   = '\\(\\*[a-z][a-z_]*\\)\\(' \"[ \\t]*[a-zA-Z.].*\" '\\)';\n+    sed      = 's'\n+                '/^\\(.*(\\*[a-z][a-z_]*)(\\)'      '\\();.*\\)'\n+                \"/\\\\\\n\"\n+                    \"#ifdef __cplusplus\\\\\\n\"\n+                    '\\1...\\2' \"\\\\\\n\"\n+                    \"#else\\\\\\n\"\n+                    '\\1\\2' \"\\\\\\n\"\n+                    \"#endif\"\n+                \"/\";\n+};\n+\n+\n+/*\n+ *  This file on SunOS 4 has a very large macro.  When the sed loop\n+ *  tries pull it in, it overflows the pattern space size of the SunOS\n+ *  sed (GNU sed does not have this problem).  Since the file does not\n+ *  require fixing, we remove it from the fixed directory.\n+ */\n+fix = {\n+    hackname = sunos_large_macro;\n+    files    = sundev/ipi_error.h;\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to SunOS <sundev/ipi_error.h>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*\n+ *  math.h on SunOS 4 puts the declaration of matherr before the definition\n+ *  of struct exception, so the prototype (added by fixproto) causes havoc.\n+ */\n+fix = {\n+    hackname = sunos_matherr_decl;\n+    files    = math.h;\n+    /*\n+     *  Find the first occurrance of 'struct exception'.\n+     *  If it is the definition, then the file is okay.\n+     *  If it is a usage, then the order is wrong and we\n+     *  must insert a forward reference.\n+     */\n+    test = \"\\\"`fgrep 'struct exception' $file | line`\\\"\"\n+                  \" != 'struct exception {'\";\n+\n+    sed = \"/matherr/i\\\\\\nstruct exception;\\n\";\n+};\n+\n+\n+/*\n+ *  Correct the return type for strlen in strings.h in SunOS 4.\n+ */\n+fix = {\n+    hackname = sunos_strlen;\n+    files    = strings.h;\n+    sed = \"s/int[ \\t]*strlen();/__SIZE_TYPE__ strlen();/\";\n+};\n+\n+\n+/*\n+ *  Solaris math.h and floatingpoint.h define __P without protection,\n+ *  which conflicts with the fixproto definition.  The fixproto\n+ *  definition and the Solaris definition are used the same way.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4__p;\n+    files    = math.h;\n+    files    = floatingpoint.h;\n+    select   = \"^#define[ \\t]*__P\";\n+    sed      = \"/^#define[ \\t]*__P/i\\\\\\n#ifndef __P\\n\";\n+    sed      = \"/^#define[ \\t]*__P/a\\\\\\n#endif\\n\";\n+};\n+#endif\n+\n+/*\n+ *  Disable apparent native compiler optimization cruft in SVR4.2 <string.h>\n+ *  that is visible to any ANSI compiler using this include.  Simply\n+ *  delete the lines that #define some string functions to internal forms.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_disable_opt;\n+    files    = string.h;\n+    select   = '#define.*__std_hdr_';\n+    sed      = '/#define.*__std_hdr_/d';\n+};\n+#endif\n+\n+/*\n+ *  Conditionalize some of <sys/endian.h> on __GNUC__ and __GNUG__.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_endian;\n+    files    = sys/endian.h;\n+    bypass   = '__GNUC__';\n+\n+    sed      = \"/#\\tifdef\\t__STDC__/i\\\\\\n\"\n+               \"#   if !defined (__GNUC__) && !defined (__GNUG__)\\n\";\n+\n+    sed      = \"/#\\t\\tinclude\\t<sys\\\\/byteorder.h>/s/\\t\\t/   /\";\n+\n+    sed      = \"/#   include\\t<sys\\\\/byteorder.h>/i\\\\\\n\"\n+               \"#   endif /* !defined (__GNUC__) && !defined (__GNUG__) */\\n\";\n+};\n+#endif\n+\n+/*\n+ *  Remove useless extern keyword from struct forward declarations\n+ *  in <sys/stream.h> and <sys/strsubr.h>\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_extern_struct;\n+    files    = sys/stream.h;\n+    files    = sys/strsubr.h;\n+    select   = 'extern struct [a-z_]*;';\n+    sed      = 's/extern struct \\([a-z][a-z_]*\\)/struct \\1/';\n+};\n+#endif\n+\n+/*\n+ *  Fix declarations of `ftw' and `nftw' in <ftw.h>.  On some/most SVR4\n+ *  systems the file <ftw.h> contains extern declarations of these\n+ *  functions followed by explicitly `static' definitions of these\n+ *  functions... and that's not allowed according to ANSI C.  (Note\n+ *  however that on Solaris, this header file glitch has been pre-fixed by\n+ *  Sun.  In the Solaris version of <ftw.h> there are no static\n+ *  definitions of any function so we don't need to do any of this stuff\n+ *  when on Solaris.\n+ */\n+#ifdef SVR4\n+#ifndef SOLARIS\n+fix = {\n+    hackname = svr4_ftw;\n+    files    = ftw.h;\n+    select   = '^extern int ftw\\(const';\n+\n+    sed = '/^extern int ftw(const/i' \"\\\\\\n\"\n+            \"#if !defined(_STYPES)\\\\\\n\"\n+            \"static\\\\\\n\"\n+            \"#else\\\\\\n\"\n+            \"extern\\\\\\n\"\n+            \"#endif\";\n+    sed = 's/extern \\(int ftw(const.*\\)$/\\1/';\n+    sed = \"/^extern int nftw/i\\\\\\n\"\n+            \"#if defined(_STYPES)\\\\\\n\"\n+            \"static\\\\\\n\"\n+            \"#else\\\\\\n\"\n+            \"extern\\\\\\n\"\n+            \"#endif\";\n+    sed = 's/extern \\(int nftw.*\\)$/\\1/';\n+    sed = \"/^extern int ftw(),/c\\\\\\n\"\n+            \"#if !defined(_STYPES)\\\\\\n\"\n+            \"static\\\\\\n\"\n+            \"#else\\\\\\n\"\n+            \"extern\\\\\\n\"\n+            \"#endif\\\\\\n\"\n+            \"  int ftw();\\\\\\n\"\n+            \"#if defined(_STYPES)\\\\\\n\"\n+            \"static\\\\\\n\"\n+            \"#else\\\\\\n\"\n+            \"extern\\\\\\n\"\n+            \"#endif\\\\\\n\"\n+            \"  int nftw();\";\n+};\n+#endif\n+#endif\n+\n+\n+/*\n+ *   Fix broken decl of getcwd present on some svr4 systems.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_getcwd;\n+    files    = stdlib.h;\n+    files    = unistd.h;\n+    select   = 'getcwd\\(char \\*, int\\)';\n+\n+    sed = 's/getcwd(char \\*, int)/getcwd(char *, size_t)/';\n+};\n+#endif\n+\n+/*\n+ *  set ifdef _KERNEL\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_kernel;\n+    files    = fs/rfs/rf_cache.h;\n+    files    = sys/erec.h;\n+    files    = sys/err.h;\n+    files    = sys/char.h;\n+    files    = sys/getpages.h;\n+    files    = sys/map.h;\n+    files    = sys/cmn_err.h;\n+    files    = sys/kdebugger.h;\n+    bypass   = '_KERNEL';\n+    sed      = \"1i\\\\\\n#ifdef _KERNEL\";\n+    sed      = \"$a\\\\\\n#endif /* _KERNEL */\";\n+};\n+#endif\n+\n+/*\n+ *  Delete any #defines of `__i386' which may be present in <ieeefp.h>.  They\n+ *  tend to conflict with the compiler's own definition of this symbol.  (We\n+ *  will use the compiler's definition.)\n+ *  Likewise __sparc, for Solaris, and __i860, and a few others\n+ *  (guessing it is necessary for all of them).\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_mach_defines;\n+    files    = ieeefp.h;\n+    select   = \"#define[ \\t]*__(i386|i860|mips|sparc|m88k|m68k)[ \\t]\";\n+    sed      = \"/#define[ \\t]*__\\\\(i386|i860|mips|sparc|m88k|m68k\\\\)[ \\t]/d\";\n+};\n+#endif\n+\n+/*\n+ *  Fix declarations of `makedev', `major', and `minor' in <sys/mkdev.h>.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_mkdev;\n+    files    = sys/mkdev.h;\n+\n+    sed      = \"/^dev_t makedev(const/c\\\\\\n\"\n+               \"static dev_t makedev(const major_t, const minor_t);\";\n+\n+    sed      = \"/^dev_t makedev()/c\\\\\\n\"\n+               \"static dev_t makedev();\";\n+\n+    sed      = \"/^major_t major(const/c\\\\\\n\"\n+               \"static major_t major(const dev_t);\";\n+\n+    sed      = \"/^major_t major()/c\\\\\\n\"\n+               \"static major_t major();\";\n+\n+    sed      = \"/^minor_t minor(const/c\\\\\\n\"\n+               \"static minor_t minor(const dev_t);\";\n+\n+    sed      = \"/^minor_t minor()/c\\\\\\n\"\n+               \"static minor_t minor();\";\n+};\n+#endif\n+\n+/*\n+ *  Fix reference to NC_NPI_RAW in <sys/netcspace.h>.\n+ *  Also fix types of array initializers.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_netcspace;\n+    files    = sys/netcspace.h;\n+    select   = 'NC_NPI_RAW';\n+    sed      = 's/NC_NPI_RAW/NC_TPI_RAW/g';\n+    sed      = 's/NC_/(unsigned long) NC_/';\n+};\n+#endif\n+\n+/*\n+ *  Fix reference to NMSZ in <sys/adv.h>.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_nmsz;\n+    files    = sys/adv.h;\n+    select   = '\\[NMSZ\\]';\n+    sed      = 's/\\[NMSZ\\]/\\[RFS_NMSZ\\]/g';\n+};\n+#endif\n+\n+/*\n+ *  Completely replace <sys/varargs.h> with a file that includes gcc's\n+ *  stdarg.h or varargs.h files as appropriate.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_no_varargs;\n+    files    = sys/varargs.h;\n+    shell    = \"cat > /dev/null\\n\"\n+               \"cat << _EOF_\\n\"\n+               \"/* This file was generated by fixincludes.  */\\n\"\n+               \"#ifndef _SYS_VARARGS_H\\n\"\n+               \"#define _SYS_VARARGS_H\\n\\n\"\n+\n+               \"#ifdef __STDC__\\n\"\n+               \"#include <stdarg.h>\\n\"\n+               \"#else\\n\"\n+               \"#include <varargs.h>\\n\"\n+               \"#endif\\n\\n\"\n+\n+               \"#endif  /* _SYS_VARARGS_H */\\n\"\n+               \"_EOF_\";\n+};\n+#endif\n+\n+/*\n+ *   Fix broken decl of profil present on some svr4 systems.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_profil;\n+    files    = stdlib.h;\n+    files    = unistd.h;\n+\n+    sed = 's/profil(unsigned short \\*, unsigned int, '\n+                         'unsigned int, unsigned int)'\n+           '/profil(unsigned short *, size_t, int, unsigned)/';\n+};\n+#endif\n+\n+/*\n+ *  Convert functions to prototype form, and fix arg names in <sys/stat.h>.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_proto_form;\n+    files    = sys/stat.h;\n+    select   = 'const extern';\n+\n+    sed      = \"/^stat([ \\t]*[^c]/ {\\nN\\nN\\n\"\n+                   \"s/(.*)\\\\n/( /\\n\"\n+                   \"s/;\\\\n/, /\\n\"\n+                   \"s/;$/)/\\n\"  \"}\";\n+\n+    sed      = \"/^lstat([ \\t]*[^c]/ {\\nN\\nN\\n\"\n+                   \"s/(.*)\\\\n/( /\\n\"\n+                   \"s/;\\\\n/, /\\n\"\n+                   \"s/;$/)/\\n\"  \"}\";\n+\n+    sed      = \"/^fstat([ \\t]*[^i]/ {\\nN\\nN\\n\"\n+                   \"s/(.*)\\\\n/( /\\n\"\n+                   \"s/;\\\\n/, /\\n\"\n+                   \"s/;$/)/\\n\"  \"}\";\n+\n+    sed      = \"/^mknod([ \\t]*[^c]/{\\nN\\nN\\nN\\n\"\n+                   \"s/(.*)\\\\n/( /\\n\"\n+                   \"s/;\\\\n/, /g\\n\"\n+                   \"s/;$/)/\\n\"  \"}\";\n+\n+    sed      = \"1,$s/\\\\([^A-Za-z]\\\\)path\\\\([^A-Za-z]\\\\)/\\\\1__path\\\\2/g\";\n+    sed      = \"1,$s/\\\\([^A-Za-z]\\\\)buf\\\\([^A-Za-z]\\\\)/\\\\1__buf\\\\2/g\";\n+    sed      = \"1,$s/\\\\([^A-Za-z]\\\\)fd\\\\([^A-Za-z]\\\\)/\\\\1__fd\\\\2/g\";\n+    sed      = \"1,$s/ret\\\\([^u]\\\\)/__ret\\\\1/g\";\n+    sed      = \"1,$s/\\\\([^_]\\\\)mode\\\\([^_]\\\\)/\\\\1__mode\\\\2/g\";\n+    sed      = \"1,$s/\\\\([^_r]\\\\)dev\\\\([^_]\\\\)/\\\\1__dev\\\\2/g\";\n+};\n+#endif\n+\n+/*\n+ *  Add a prototyped declaration of mmap to <sys/mman.h>.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_proto_mmap;\n+    files    = sys/mman.h;\n+    select   = '^extern caddr_t mmap();$';\n+    sed = '/^extern caddr_t mmap();$/c' \"\\\\\\n\"\n+          \"#ifdef __STDC__\\\\\\n\"\n+          \"extern caddr_t mmap (caddr_t, size_t, int, int, int, off_t);\\\\\\n\"\n+          \"#else /* !defined(__STDC__) */\\\\\\n\"\n+          \"extern caddr_t mmap ();\\\\\\n\"\n+          \"#endif /* !defined(__STDC__) */\\\\\\n\";\n+};\n+#endif\n+\n+/*\n+ *  Add a #define of _SIGACTION_ into <sys/signal.h>.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_sigaction;\n+    files    = sys/signal.h;\n+    sed      = \"/^struct sigaction {/i\\\\\\n\"\n+               \"#define _SIGACTION_\";\n+    sed      = 's/(void *(\\*)())/(void (*)(int))/';\n+};\n+#endif\n+\n+/*\n+ *  Put storage class at start of decl, to avoid warning.\n+ */\n+#ifdef SVR4\n+fix = {\n+    hackname = svr4_storage_class;\n+    files    = rpc/types.h;\n+    select   = 'const extern';\n+    sed      = 's/const extern/extern const/g';\n+};\n+#endif\n+\n+/*\n+ *  Fix return value of mem{ccpy,chr,cpy,set} and str{len,spn,cspn}\n+ *  in string.h on sysV68\n+ *  Correct the return type for strlen in string.h on Lynx.\n+ *  Correct the argument type for ffs in string.h on Alpha OSF/1 V2.0.\n+ *  Add missing const for strdup on OSF/1 V3.0.\n+ *  On sysV88 layout is slightly different.\n+ */\n+fix = {\n+    hackname = systypes;\n+    files  = \"sys/types.h\";\n+    files  = \"stdlib.h\";\n+    files  = \"sys/stdtypes.h\";\n+    files  = \"stddef.h\";\n+    files  = \"memory.h\";\n+    files  = \"unistd.h\";\n+    select = \"typedef[ \\t]+[a-z_][ \\ta-z_]*[ \\t]\"\n+             \"(size|ptrdiff|wchar)_t\";\n+\n+      sed  = \"/^[ \\t]*\\\\*[ \\t]*typedef unsigned int size_t;/N\";\n+\n+      sed  = \"s/^\\\\([ \\t]*\\\\*[ \\t]*typedef unsigned int size_t;\\\\n\"\n+               \"[ \\t]*\\\\*\\\\/\\\\)/\\\\1\\\\\\n\"\n+             \"#ifndef __SIZE_TYPE__\\\\\\n\"\n+             \"#define __SIZE_TYPE__ long unsigned int\\\\\\n\"\n+             \"#endif\\\\\\n\"\n+             \"typedef __SIZE_TYPE__ size_t;\\\\\\n/\";\n+\n+      sed  = \"/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]size_t/i\\\\\\n\"\n+                   \"#ifndef __SIZE_TYPE__\\\\\\n\"\n+                   \"#define __SIZE_TYPE__ long unsigned int\\\\\\n\"\n+                   \"#endif\\n\";\n+\n+      sed  = \"s/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]size_t/\"\n+               \"typedef __SIZE_TYPE__ size_t/\";\n+\n+      sed  = \"/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]ptrdiff_t/i\\\\\\n\"\n+                   \"#ifndef __PTRDIFF_TYPE__\\\\\\n\"\n+                   \"#define __PTRDIFF_TYPE__ long int\\\\\\n\"\n+                   \"#endif\\n\";\n+\n+      sed  = \"s/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]ptrdiff_t/\"\n+               \"typedef __PTRDIFF_TYPE__ ptrdiff_t/\";\n+\n+      sed  = \"/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]wchar_t/i\\\\\\n\"\n+                   \"#ifndef __WCHAR_TYPE__\\\\\\n\"\n+                   \"#define __WCHAR_TYPE__ int\\\\\\n\"\n+                   \"#endif\\\\\\n\"\n+                   \"#ifndef __cplusplus\\n\";\n+\n+      sed  = \"/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]wchar_t/a\\\\\\n\"\n+                   \"#endif\\n\";\n+\n+      sed  = \"s/typedef[ \\t][ \\t]*[a-z_][ \\ta-z_]*[ \\t]wchar_t/\"\n+               \"typedef __WCHAR_TYPE__ wchar_t/\";\n+};\n+\n+\n+/*\n+ *  Fix return type of exit and abort in <stdlib.h> on SunOS 4.1.\n+ *  Also wrap protection around size_t for m88k-sysv3 systems.\n+ *  We use a funny name to ensure it follows 'systypes' fix.\n+ */\n+fix = {\n+    hackname = systypes_for_aix;\n+    files    = sys/types.h;\n+    select   = \"typedef[ \\t][ \\t]*[A-Za-z_][ \\tA-Za-z_]*[ \\t]size_t\";\n+    bypass   = \"_GCC_SIZE_T\";\n+\n+    sed    = \"/typedef[ \\t][ \\t]*[A-Za-z_][ \\tA-Za-z_]*[ \\t]size_t/i\\\\\\n\"\n+                 \"#ifndef _GCC_SIZE_T\\\\\\n\"\n+                 \"#define _GCC_SIZE_T\\n\";\n+\n+    sed    = \"/typedef[ \\t][ \\t]*[A-Za-z_][ \\tA-Za-z_]*[ \\t]size_t/a\\\\\\n\"\n+                 \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  if the #if says _cplusplus, not the double underscore __cplusplus\n+ *  that it should be\n+ */\n+fix = {\n+    hackname = sysv68_string;\n+    files    = string.h;\n+\n+    sed = \"s/extern[ \\t]*int[ \\t]*strlen();/extern unsigned int strlen();/\";\n+    sed = \"s/extern[ \\t]*int[ \\t]*ffs[ \\t]*(long);/extern int ffs(int);/\";\n+    sed = \"s/strdup(char \\\\*s1);/strdup(const char *s1);/\";\n+    sed = \"/^extern char$/N\";\n+    sed = \"s/^extern char\\\\(\\\\n\\t\\\\*memccpy(),\\\\)$/extern void\\\\1/\";\n+    sed = \"/^\\tstrncmp(),$/N\";\n+    sed = \"s/^\\\\(\\tstrncmp()\\\\),\\\\n\\\\(\\tstrlen(),\\\\)$/\\\\1;\\\\\\n\"\n+          \"extern unsigned int\\\\\\n\\\\2/\";\n+    sed = \"/^extern int$/N\";\n+    sed = \"s/^extern int\\\\(\\\\n\\tstrlen(),\\\\)/extern size_t\\\\1/\";\n+};\n+\n+\n+/*\n+ *  Replace definitions of size_t, ptrdiff_t and wchar_t\n+ *  Install the proper definition of the three standard types\n+ *  in header files that they come from.\n+ */\n+fix = {\n+    hackname = sysz_stdlib_for_sun;\n+    mach     = \"*-sun-*\";\n+    mach     = \"m88k-*-sysv3*\";\n+    files    = stdlib.h;\n+\n+    sed   = \"s/int\\tabort/void\\tabort/g\";\n+    sed   = \"s/int\\tfree/void\\tfree/g\";\n+    sed   = \"s/char[ \\t]*\\\\*[ \\t]*calloc/void \\\\*\\tcalloc/g\";\n+    sed   = \"s/char[ \\t]*\\\\*[ \\t]*malloc/void \\\\*\\tmalloc/g\";\n+    sed   = \"s/char[ \\t]*\\\\*[ \\t]*realloc/void \\\\*\\trealloc/g\";\n+    sed   = \"s/int[ \\t][ \\t]*exit/void\\texit/g\";\n+\n+    sed   = \"/typedef[ \\ta-zA-Z_]*[ \\t]size_t[ \\t]*;/i\\\\\\n\"\n+                \"#ifndef _GCC_SIZE_T\\\\\\n\"\n+                \"#define _GCC_SIZE_T\\n\";\n+\n+    sed   = \"/typedef[ \\ta-zA-Z_]*[ \\t]size_t[ \\t]*;/a\\\\\\n\"\n+                \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix this Sun file to avoid interfering with stddef.h.\n+ *  We use a funny name to ensure it follows 'systypes' fix.\n+ */\n+fix = {\n+    hackname = sysz_stdtypes_for_sun;\n+    files = sys/stdtypes.h;\n+    sed   = \"/[\\t ]size_t.*;/i\\\\\\n\"\n+              \"#ifndef _GCC_SIZE_T\\\\\\n\"\n+              \"#define _GCC_SIZE_T\\n\";\n+\n+    sed   = \"/[\\t ]size_t.*;/a\\\\\\n\"\n+              \"#endif\\n\";\n+\n+    sed   = \"/[\\t ]ptrdiff_t.*;/i\\\\\\n\"\n+              \"#ifndef _GCC_PTRDIFF_T\\\\\\n\"\n+              \"#define _GCC_PTRDIFF_T\\n\";\n+\n+    sed   = \"/[\\t ]ptrdiff_t.*;/a\\\\\\n\"\n+              \"#endif\\n\";\n+\n+    sed   = \"/[\\t ]wchar_t.*;/i\\\\\\n\"\n+              \"#ifndef _GCC_WCHAR_T\\\\\\n\"\n+              \"#define _GCC_WCHAR_T\\n\";\n+\n+    sed   = \"/[\\t ]wchar_t.*;/a\\\\\\n\"\n+              \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix this file to avoid interfering with stddef.h,\n+ *  but don't mistakenly match ssize_t present in AIX for the ps/2,\n+ *  or typedefs which use (but do not set) size_t.\n+ */\n+fix = {\n+    hackname = tinfo_cplusplus;\n+    files    = tinfo.h;\n+    sed      = \"s/[ \\t]_cplusplus/ __cplusplus/\";\n+};\n+\n+\n+/*\n+ *  Cancel out ansi_compat.h on Ultrix.  Replace it with empty file.\n+ */\n+fix = {\n+    hackname = ultrix_ansi_compat;\n+    files    = ansi_compat.h;\n+    select   = ULTRIX;\n+    sed      = \"1i\\\\\\n/* This file intentionally left blank. */\\n\";\n+    sed      = \"1,$d\";\n+};\n+\n+\n+/*\n+ *  parameter to atof not const on DECstation Ultrix V4.0 and NEWS-OS 4.2R.\n+ *  also get rid of bogus inline definitions in HP-UX 8.0\n+ */\n+fix = {\n+    hackname = ultrix_atof_param;\n+    files    = math.h;\n+\n+    sed = \"s@atof(\\\\([ \\t]*char[ \\t]*\\\\*[^)]*\\\\))@atof(const \\\\1)@\";\n+    sed = \"s@inline int abs(int [a-z][a-z]*) {.*}@extern \\\"C\\\" int abs(int);@\";\n+    sed = \"s@inline double abs(double [a-z][a-z]*) {.*}@@\";\n+    sed = \"s@inline int sqr(int [a-z][a-z]*) {.*}@@\";\n+    sed = \"s@inline double sqr(double [a-z][a-z]*) {.*}@@\";\n+};\n+\n+\n+/*\n+ *  parameters not const on DECstation Ultrix V4.0 and OSF/1.\n+ */\n+fix = {\n+    hackname = ultrix_const;\n+    files    = stdio.h;\n+\n+    sed   = 's@perror( char \\*__s );@perror( const char *__s );@';\n+    sed   = 's@fputs( char \\*__s,@fputs( const char *__s,@';\n+    sed   = 's@fopen( char \\*__filename, char \\*__type );@'\n+              'fopen( const char *__filename, const char *__type );@';\n+    sed   = 's@fwrite( void \\*__ptr,@fwrite( const void *__ptr,@';\n+    sed   = 's@fscanf( FILE \\*__stream, char \\*__format,@'\n+              'fscanf( FILE *__stream, const char *__format,@';\n+    sed   = 's@scanf( char \\*__format,@scanf( const char *__format,@';\n+    sed   = 's@sscanf( char \\*__s, char \\*__format,@'\n+              'sscanf( const char *__s, const char *__format,@';\n+    sed   = 's@popen(char \\*, char \\*);@popen(const char *, const char *);@';\n+    sed   = 's@tempnam(char\\*,char\\*);@tempnam(const char*,const char*);@';\n+};\n+\n+\n+/*\n+ *  Check for bad #ifdef line (in Ultrix 4.1)\n+ */\n+fix = {\n+    hackname = ultrix_ifdef;\n+    select   = \"#ifdef KERNEL\";\n+    files    = sys/file.h;\n+    sed      = \"s/#ifdef KERNEL/#if defined(KERNEL)/\";\n+};\n+\n+\n+/*\n+ *  Avoid nested comments on Ultrix 4.3.\n+ */\n+fix = {\n+    hackname = ultrix_nested_cmnt;\n+    files    = rpc/svc.h;\n+    sed      = \"s@^\\\\( \\\\*\\tint protocol;  \\\\)/\\\\*@\\\\1*/ /*@\";\n+};\n+\n+\n+/*\n+ *  Check for superfluous `static' (in Ultrix 4.2)\n+ *  On Ultrix 4.3, includes of other files (r3_cpu.h,r4_cpu.h) is broken.\n+ */\n+fix = {\n+    hackname = ultrix_static;\n+    files  = machine/cpu.h;\n+    select = '#include \"r[34]_cpu';\n+    sed    = \"s/^static struct tlb_pid_state/struct tlb_pid_state/\";\n+    sed    = 's/^#include \"r3_cpu\\.h\"$/#include <machine\\/r3_cpu\\.h>/';\n+    sed    = 's/^#include \"r4_cpu\\.h\"$/#include <machine\\/r4_cpu\\.h>/';\n+};\n+\n+\n+/*\n+ *  Fix multiple defines for NULL\n+ */\n+fix = {\n+    hackname = undefine_null;\n+    select = \"^#[ \\t]*define[ \\t]*[ \\t]NULL[ \\t]\";\n+    bypass = \"#[ \\t]*(ifn|un)def[ \\t]*[ \\t]NULL($|[ \\t])\";\n+    sed    = \"/^#[ \\t]*define[ \\t][ \\t]*NULL[ \\t]/i\\\\\\n\"\n+                \"#undef NULL\\n\";\n+};\n+\n+\n+/*\n+ *  Fix definitions of macros used by va-i960.h in VxWorks header file.\n+ */\n+fix = {\n+    hackname = va_i960_macro;\n+    files    = arch/i960/archI960.h;\n+    select   = \"__(vsiz|vali|vpad|alignof__)\";\n+    sed = \"s/__vsiz/__vxvsiz/\";\n+    sed = \"s/__vali/__vxvali/\";\n+    sed = \"s/__vpad/__vxvpad/\";\n+    sed = \"s/__alignof__/__vxalignof__/\";\n+};\n+\n+\n+/*\n+ *  AIX headers define NULL to be cast to a void pointer,\n+ *  which is illegal in ANSI C++.\n+ */\n+fix = {\n+    hackname = void_null;\n+    files    = curses.h;\n+    files    = dbm.h;\n+    files    = locale.h;\n+    files    = stdio.h;\n+    files    = stdlib.h;\n+    files    = string.h;\n+    files    = time.h;\n+    files    = unistd.h;\n+    files    = sys/dir.h;\n+    files    = sys/param.h;\n+    files    = sys/types.h;\n+    select   = \"#[ \\t]*define[ \\t][ \\t]*NULL[ \\t].*void\";\n+    sed      = \"s/^#[ \\t]*define[ \\t]*NULL[ \\t]*((void[ \\t]*\\\\*)0)\"\n+                \"/#define NULL 0/\";\n+};\n+\n+\n+/*\n+ *  Make VxWorks header which is almost gcc ready fully gcc ready.\n+ */\n+fix = {\n+    hackname = vxworks_gcc_problem;\n+    files    = types/vxTypesBase.h;\n+    select   = \"__GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__\";\n+\n+    sed = \"s/#ifdef __GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__/\"\n+          \"#if 1/\";\n+\n+    sed = \"/[ \\t]size_t/i\\\\\\n\"\n+        \"#ifndef _GCC_SIZE_T\\\\\\n\"\n+        \"#define _GCC_SIZE_T\\n\";\n+\n+    sed = \"/[ \\t]size_t/a\\\\\\n\"\n+        \"#endif\\n\";\n+\n+    sed = \"/[ \\t]ptrdiff_t/i\\\\\\n\"\n+        \"#ifndef _GCC_PTRDIFF_T\\\\\\n\"\n+        \"#define _GCC_PTRDIFF_T\\n\";\n+\n+    sed = \"/[ \\t]ptrdiff_t/a\\\\\\n\"\n+        \"#endif\\n\";\n+\n+    sed = \"/[ \\t]wchar_t/i\\\\\\n\"\n+        \"#ifndef _GCC_WCHAR_T\\\\\\n\"\n+        \"#define _GCC_WCHAR_T\\n\";\n+\n+    sed = \"/[ \\t]wchar_t/a\\\\\\n\"\n+        \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  Fix VxWorks <time.h> to not require including <vxTypes.h>.\n+ */\n+fix = {\n+    hackname = vxworks_needs_vxtypes;\n+    files    = time.h;\n+    select   = \"uint_t[ \\t][ \\t]*_clocks_per_sec\";\n+    sed      = \"s/uint_t/unsigned int/\";\n+};\n+\n+\n+/*\n+ *  Fix VxWorks <sys/stat.h> to not require including <vxWorks.h>.\n+ */\n+fix = {\n+    hackname = vxworks_needs_vxworks;\n+    files    = sys/stat.h;\n+    test     = \"-r types/vxTypesOld.h\";\n+    test     = \"-n \\\"`fgrep '#include' $file`\\\"\";\n+    test     = \"-n \\\"`fgrep ULONG $file`\\\"\";\n+    select   = \"#[ \\t]define[ \\t][ \\t]*__INCstath\";\n+\n+    sed = \"/#[ \\t]define[ \\t][ \\t]*__INCstath/a\\\\\\n\"\n+          \"#include <types/vxTypesOld.h>\\n\";\n+};\n+\n+\n+/*\n+ *  Another bad dependency in VxWorks 5.2 <time.h>.\n+ */\n+fix = {\n+    hackname = vxworks_time;\n+    files    = time.h;\n+    select   = \"VOIDFUNCPTR\";\n+    test     = \"-r vxWorks.h\";\n+    sed      = \"/VOIDFUNCPTR/i\\\\\\n\"\n+               \"#ifndef __gcc_VOIDFUNCPTR_defined\\\\\\n\"\n+               \"#ifdef __cplusplus\\\\\\n\"\n+               \"typedef void (*__gcc_VOIDFUNCPTR) (...);\\\\\\n\"\n+               \"#else\\\\\\n\"\n+               \"typedef void (*__gcc_VOIDFUNCPTR) ();\\\\\\n\"\n+               \"#endif\\\\\\n\"\n+               \"#define __gcc_VOIDFUNCPTR_defined\\\\\\n\"\n+               \"#endif\\n\";\n+\n+    sed      = \"s/VOIDFUNCPTR/__gcc_VOIDFUNCPTR/g\";\n+};\n+\n+\n+/*\n+ *  There are several name conflicts with C++ reserved words in X11 header\n+ *  files.  These are fixed in some versions, so don't do the fixes if\n+ *  we find __cplusplus in the file.  These were found on the RS/6000.\n+ */\n+fix = {\n+    hackname = x11_class;\n+    files    = X11/ShellP.h;\n+    bypass   = __cplusplus;\n+    sed      = \"/char \\\\*class;/i\\\\\\n\"\n+                   \"#ifdef __cplusplus\\\\\\n\"\n+                   \"\\tchar *c_class;\\\\\\n\"\n+                   \"#else\\n\";\n+    sed      = \"/char \\\\*class;/a\\\\\\n\"\n+                   \"#endif\\n\";\n+};\n+\n+\n+/*\n+ *  class in Xm/BaseClassI.h\n+ */\n+fix = {\n+    hackname = x11_class_usage;\n+    files    = Xm/BaseClassI.h;\n+    bypass   = \"__cplusplus\";\n+    sed      = \"s/ class[)]/ c_class)/g\";\n+};\n+\n+\n+/*\n+ *  new in Xm/Traversal.h\n+ */\n+fix = {\n+    hackname = x11_new;\n+    files    = Xm/Traversal.h;\n+    bypass   = __cplusplus;\n+\n+    sed      = \"/Widget\\told, new;/i\\\\\\n\"\n+                   \"#ifdef __cplusplus\\\\\\n\"\n+                   \"\\tWidget\\told, c_new;\\\\\\n\"\n+                   \"#else\\n\";\n+\n+    sed      = \"/Widget\\told, new;/a\\\\\\n\"\n+                   \"#endif\\n\";\n+\n+    sed      = \"s/Widget new,/Widget c_new,/g\";\n+};\n+\n+\n+/*\n+ *  Incorrect sprintf declaration in X11/Xmu.h\n+ */\n+fix = {\n+    hackname = x11_sprintf;\n+    files    = X11*/Xmu.h;\n+    sed      = \"s,^extern char \\\\*\\tsprintf();$,#ifndef __STDC__\\\\\\n\"\n+               \"extern char *\\tsprintf();\\\\\\n\"\n+               \"#endif /* !defined __STDC__ */,\";\n+};\n+\n+\n+/*\n+ *  Purge some HP-UX 11 files that are only borken after they are \"fixed\".\n+ */\n+fix = {\n+    hackname = zzz_ki_iface;\n+    files    = sys/ki_iface.h;\n+    select   = 'These definitions are for HP Internal developers';\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to HP-UX <$file>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*\n+ *  Purge some HP-UX 11 files that are only borken after they are \"fixed\".\n+ */\n+fix = {\n+    hackname = zzz_ki;\n+    files    = sys/ki.h;\n+    select   = '11.00 HP-UX LP64';\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to HP-UX <$file>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*\n+ *  Purge some HP-UX 11 files that are only borken after they are \"fixed\".\n+ */\n+fix = {\n+    hackname = zzz_ki_calls;\n+    files    = sys/ki_calls.h;\n+    select   = 'KI_MAX_PROCS is an arbitrary number';\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to HP-UX <$file>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*\n+ *  Purge some HP-UX 11 files that are only borken after they are \"fixed\".\n+ */\n+fix = {\n+    hackname = zzz_ki_defs;\n+    files    = sys/ki_defs.h;\n+    select   = 'Kernel Instrumentation Definitions';\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to HP-UX <$file>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*\n+ *  Purge some HP-UX 11 files that are only borken after they are \"fixed\".\n+ */\n+fix = {\n+    hackname = zzz_time;\n+    files    = sys/time.h;\n+    select   = 'For CASPEC, look in';\n+    shell    =\n+        \"echo \\\"Removing incorrect fix to HP-UX <$file>\\\" >&2\\n\"\n+         \"rm -f ${DESTDIR}/$file ${DESTDIR}/$file.\\ncat > /dev/null\";\n+};\n+\n+\n+/*EOF*/"}, {"sha": "19cf32e2aa47c40e22b2dcab98798713ce59b456", "filename": "gcc/fixinc/inclhack.tpl", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Finclhack.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Finclhack.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.tpl?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,391 @@\n+[= autogen template -*- Mode: ksh -*-\n+sh\n+#\n+#  $Id: inclhack.tpl,v 1.2 1998/12/16 21:19:11 law Exp $\n+#\n+=]\n+#!/bin/sh\n+#\n+[= _EVAL \"## \" _DNE =]\n+#\n+# Install modified versions of certain ANSI-incompatible system header\n+# files which are fixed to work correctly with ANSI C and placed in a\n+# directory that GNU C will search.\n+#\n+# This script contains [=_eval fix _count =] fixup scripts.\n+#\n+# See README-fixinc for more information.\n+#\n+[=_eval fixincludes \"## \" _gpl=]\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# Directory in which to store the results.\n+# Fail if no arg to specify a directory for the output.\n+if [ \"x$1\" = \"x\" ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+LIB=${1}\n+shift\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || {\n+    echo fixincludes:  output dir '`'$LIB\"' cannot be created\"\n+    exit 1\n+  }\n+else\n+  ( \\cd $LIB && touch DONE && rm DONE ) || {\n+    echo fixincludes:  output dir '`'$LIB\"' is an invalid directory\"\n+    exit 1\n+  }\n+fi\n+\n+# Define what target system we're fixing.\n+#\n+if test -r ./Makefile; then\n+  target_canonical=\"`sed -n -e 's,^target[ \t]*=[ \t]*\\(.*\\)$,\\1,p' < Makefile`\"\n+fi\n+\n+# If not from the Makefile, then try config.guess\n+#\n+if test -z \"${target_canonical}\" ; then\n+  if test -x ./config.guess ; then\n+    target_canonical=\"`config.guess`\" ; fi\n+  test -z \"${target_canonical}\" && target_canonical=unknown\n+fi\n+export target_canonical\n+\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# Define PWDCMD as a command to use to get the working dir\n+# in the form that we want.\n+PWDCMD=pwd\n+\n+case \"`$PWDCMD`\" in\n+//*)\n+    # On an Apollo, discard everything before `/usr'.\n+    PWDCMD=\"eval pwd | sed -e 's,.*/usr/,/usr/,'\"\n+    ;;\n+esac\n+\n+# Original directory.\n+ORIGDIR=`${PWDCMD}`[=\n+_IF PROGRAM _env =]\n+FIXINCL=${ORIGDIR}/fixincl\n+export FIXINCL[=\n+_ENDIF=]\n+\n+# Make LIB absolute only if needed to avoid problems with the amd.\n+case $LIB in\n+/*)\n+    ;;\n+*)\n+    cd $LIB; LIB=`${PWDCMD}`\n+    ;;\n+esac\n+\n+echo Fixing headers into ${LIB} for ${target_canonical} target\n+ \n+# Determine whether this system has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n+  rm -f /tmp/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+#  Search each input directory for broken header files.\n+#  This loop ends near the end of the file.\n+#\n+if test $# -eq 0\n+then\n+    INPUTLIST=\"/usr/include\"\n+else\n+    INPUTLIST=\"$@\"\n+fi\n+\n+for INPUT in ${INPUTLIST} ; do\n+\n+cd ${ORIGDIR}\n+\n+cd ${INPUT} || {\n+  echo 'fixincludes:  input dir `'$INPUT\"' is an invalid directory\"\n+  exit 1\n+}\n+\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+echo Finding directories and links to directories\n+\n+# Find all directories and all symlinks that point to directories.\n+# Put the list in $files.\n+# Each time we find a symlink, add it to newdirs\n+# so that we do another find within the dir the link points to.\n+# Note that $files may have duplicates in it;\n+# later parts of this file are supposed to ignore them.\n+dirs=\".\"\n+levels=2\n+while [ -n \"$dirs\" ] && [ $levels -gt 0 ]\n+do\n+    levels=`expr $levels - 1`\n+    newdirs=\n+    for d in $dirs\n+    do\n+    echo \" Searching $INPUT/$d\"\n+ \n+    # Find all directories under $d, relative to $d, excluding $d itself.\n+    # (The /. is needed after $d in case $d is a symlink.)\n+    files=\"$files `find $d/. -type d -print | \\\n+               sed -e '/\\/\\.$/d' -e 's@/./@/@g'`\"\n+    # Find all links to directories.\n+    # Using `-exec test -d' in find fails on some systems,\n+    # and trying to run test via sh fails on others,\n+    # so this is the simplest alternative left.\n+    # First find all the links, then test each one.\n+    theselinks=\n+    $LINKS && \\\n+      theselinks=`find $d/. -type l -print | sed -e 's@/./@/@g'`\n+    for d1 in $theselinks --dummy--\n+    do\n+        # If the link points to a directory,\n+        # add that dir to $newdirs\n+        if [ -d $d1 ]\n+        then\n+        files=\"$files $d1\"\n+        if [ \"`ls -ld $d1 | sed -n 's/.*-> //p'`\" != \".\" ]\n+        then\n+            newdirs=\"$newdirs $d1\"\n+        fi\n+        fi\n+    done\n+    done\n+ \n+    dirs=\"$newdirs\"\n+done\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+dirs=\n+echo \"All directories (including links to directories):\"\n+echo $files\n+ \n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+mkdir $LIB/root\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+ \n+if $LINKS; then\n+  echo 'Making symbolic directory links'\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if [ \"$dest\" ]; then\n+      cwd=`${PWDCMD}`\n+      # In case $dest is relative, get to $file's dir first.\n+      cd ${INPUT}\n+      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n+      # Check that the target directory exists.\n+      # Redirections changed to avoid bug in sh on Ultrix.\n+      (cd $dest) > /dev/null 2>&1\n+      if [ $? = 0 ]; then\n+    cd $dest\n+    # X gets the dir that the link actually leads to.\n+    x=`${PWDCMD}`\n+    # Canonicalize ${INPUT} now to minimize the time an\n+    # automounter has to change the result of ${PWDCMD}.\n+    cinput=`cd ${INPUT}; ${PWDCMD}`\n+    # If a link points to ., make a similar link to .\n+    if [ $x = ${cinput} ]; then\n+      echo $file '->' . ': Making link'\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s . ${LIB}/$file > /dev/null 2>&1\n+    # If link leads back into ${INPUT},\n+    # make a similar link here.\n+    elif expr $x : \"${cinput}/.*\" > /dev/null; then\n+      # Y gets the actual target dir name, relative to ${INPUT}.\n+      y=`echo $x | sed -n \"s&${cinput}/&&p\"`\n+      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+      dots=`echo \"$file\" |\n+        sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+      echo $file '->' $dots$y ': Making link'\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n+    else\n+      # If the link is to a dir $target outside ${INPUT},\n+      # repoint the link at ${INPUT}/root$target\n+      # and process $target into ${INPUT}/root$target\n+      # treat this directory as if it actually contained the files.\n+      echo $file '->' root$x ': Making link'\n+      if [ -d $LIB/root$x ]\n+      then true\n+      else\n+        dirname=root$x/\n+        dirmade=.\n+        cd $LIB\n+        while [ x$dirname != x ]; do\n+          component=`echo $dirname | sed -e 's|/.*$||'`\n+          mkdir $component >/dev/null 2>&1\n+          cd $component\n+          dirmade=$dirmade/$component\n+          dirname=`echo $dirname | sed -e 's|[^/]*/||'`\n+        done\n+      fi\n+      # Duplicate directory structure created in ${LIB}/$file in new\n+      # root area.\n+      for file2 in $files; do\n+        case $file2 in\n+          $file/*)\n+        dupdir=${LIB}/root$x/`echo $file2 | sed -n \"s|^${file}/||p\"`\n+        echo \"Duplicating ${file}'s ${dupdir}\"\n+        if [ -d ${dupdir} ]\n+        then true\n+        else\n+          mkdir ${dupdir}\n+        fi\n+        ;;\n+          *)\n+        ;;\n+        esac\n+          done\n+      # Get the path from ${LIB} to $file, accounting for symlinks.\n+      parent=`echo \"$file\" | sed -e 's@/[^/]*$@@'`\n+      libabs=`cd ${LIB}; ${PWDCMD}`\n+      file2=`cd ${LIB}; cd $parent; ${PWDCMD} | sed -e \"s@^${libabs}@@\"`\n+      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+      dots=`echo \"$file2\" | sed -e 's@/[^/]*@../@g'`\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s ${dots}root$x ${LIB}/$file > /dev/null 2>&1\n+      treetops=\"$treetops $x ${LIB}/root$x\"\n+    fi\n+      fi\n+      cd $cwd\n+    fi\n+  done\n+fi\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+required=\n+set x $treetops\n+shift\n+while [ $# != 0 ]; do\n+  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n+  #\n+  SRCDIR=`cd ${INPUT} ; cd $1 ; ${PWDCMD}`\n+  export SRCDIR\n+  shift\n+\n+  DESTDIR=`cd $1;${PWDCMD}`\n+  export DESTDIR\n+  shift\n+\n+  # The same dir can appear more than once in treetops.\n+  # There's no need to scan it more than once.\n+  #\n+  if [ -f ${DESTDIR}/DONE ]\n+  then continue ; fi\n+\n+  touch ${DESTDIR}/DONE\n+  echo Fixing directory ${SRCDIR} into ${DESTDIR}\n+\n+  # Check .h files which are symlinks as well as those which are files.\n+  # A link to a header file will not be processed by anything but this.\n+  #\n+  cd ${SRCDIR}\n+[=_IF PROGRAM _env ! =][=\n+\n+    _include hackshell =][=\n+\n+  _ELSE\n+\n+=]\n+  required=\"$required `if $LINKS; then\n+    find . -name '*.h' \\( -type f -o -type l \\) -print\n+  else\n+    find . -name '*.h' -type f -print\n+  fi | ${FIXINCL}`\"[=\n+\n+\n+  _ENDIF =]\n+done\n+\n+## Make sure that any include files referenced using double quotes\n+## exist in the fixed directory.  This comes last since otherwise\n+## we might end up deleting some of these files \"because they don't\n+## need any change.\"\n+set x `echo $required`\n+shift\n+while [ $# != 0 ]; do\n+  newreq=\n+  while [ $# != 0 ]; do\n+    # $1 is the directory to copy from,\n+    # $2 is the unfixed file,\n+    # $3 is the fixed file name.\n+    #\n+    cd ${INPUT}\n+    cd $1\n+    if [ -r $2 ] && [ ! -r $3 ]; then\n+      cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n+      chmod +w $3 2>/dev/null\n+      chmod a+r $3 2>/dev/null\n+      echo Copied $2\n+      for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n+             sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n+      do\n+\tdir=`echo $2 | sed -e s'|/[^/]*$||'`\n+\tdir2=`echo $3 | sed -e s'|/[^/]*$||'`\n+\tnewreq=\"$newreq $1 $dir/$include $dir2/$include\"\n+      done\n+    fi\n+    shift; shift; shift\n+  done\n+  set x $newreq\n+  shift\n+done\n+\n+echo 'Cleaning up DONE files.'\n+cd $LIB\n+find . -name DONE -exec rm -f '{}' ';'\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > /dev/null 2>&1 | :\n+done\n+\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# End of for INPUT directories\n+#\n+done\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+\n+cd $ORIGDIR\n+rm -f include/assert.h\n+cp ${EGCS_SRCDIR}/assert.h include/assert.h\n+chmod a+r include/assert.h\n+[=\n+\n+#  Make the output file executable\n+# =][=\n+_eval _outfile \"chmod +x %s\" _printf _shell=]"}, {"sha": "c0811aaf2e9d0a56092caab555d440d412f42912", "filename": "gcc/fixinc/mkfixinc.sh", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fmkfixinc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fmkfixinc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fmkfixinc.sh?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,116 @@\n+#! /bin/sh\n+\n+machine=$1\n+if [ -z \"$machine\" ]\n+then\n+\techo No machine name given\n+\texit 1\n+fi\n+\n+echo constructing fixinc.sh for $machine\n+fixincludes=\"../fixinc.sh\"\n+\n+case $machine in\n+\t*-*-gnu*)\n+\t\tfixincludes=\n+\t\t;;\n+\n+\t*-*-sysv4*)\n+\t\tfixincludes=fixinc.svr4\n+\t\t;;\n+\n+\tmips-dec-bsd*)\n+\t\t:\n+\t\t;;\n+\n+\ti[34567]86-*-sysv5* | \\\n+\ti[34567]86-*-udk* | \\\n+\ti[34567]86-*-solaris2.[0-4] | \\\n+\tpowerpcle-*-solaris2.[0-4] | \\\n+\tsparc-*-solaris2.[0-4] )\n+\t\tfixincludes=fixinc.svr4\n+\t\t;;\n+\n+\t*-*-netbsd* | \\\n+\talpha*-*-linux-gnulibc1* | \\\n+\ti[34567]86-*-freebsd* | \\\n+\ti[34567]86-*-netbsd* | i[34567]86-*-openbsd* | \\\n+\ti[34567]86-*-solaris2* | \\\n+\tsparcv9-*-solaris2* | \\\n+\tpowerpcle-*-solaris2*  | \\\n+\tsparc-*-solaris2* )\n+\t\tfixincludes=fixinc.wrap\n+\t\t;;\n+\n+\talpha*-*-winnt* | \\\n+\ti[34567]86-*-winnt3*)\n+\t\tfixincludes=fixinc.winnt\n+\t\t;;\n+\n+\ti[34567]86-sequent-ptx* | i[34567]86-sequent-sysv[34]*)\n+\t\tfixincludes=fixinc.ptx\n+\t\t;;\n+\n+\ti[34567]86-dg-dgux* | \\\n+\tm88k-dg-dgux*)\n+\t\tfixincludes=fixinc.dgux\n+\t\t;;\n+\n+\ti[34567]86-*-sco3.2v5* | \\\n+\ti[34567]86-*-sco3.2v4*)\n+\t\tfixincludes=fixinc.sco\n+\t\t;;\n+\n+\talpha*-*-linux-gnu* | \\\n+\talpha*-dec-vms* | \\\n+\tarm-semi-aout | armel-semi-aout | \\\n+\tarm-semi-aof | armel-semi-aof | \\\n+\tarm-*-linux-gnuaout* | \\\n+\tc*-convex-* | \\\n+\thppa1.1-*-osf* | \\\n+\thppa1.0-*-osf* | \\\n+\thppa1.1-*-bsd* | \\\n+\thppa1.0-*-bsd* | \\\n+\thppa*-*-lites* | \\\n+\t*-*-linux-gnu* | \\\n+\ti[34567]86-moss-msdos* | i[34567]86-*-moss* | \\\n+\ti[34567]86-*-osf1* | \\\n+\ti[34567]86-*-win32 | \\\n+\ti[34567]86-*-pe | i[34567]86-*-cygwin32 | \\\n+\ti[34567]86-*-mingw32* | \\\n+\tmips-sgi-irix5cross64 | \\\n+\tpowerpc-*-eabiaix* | \\\n+\tpowerpc-*-eabisim* | \\\n+\tpowerpc-*-eabi*    | \\\n+\tpowerpc-*-rtems*   | \\\n+\tpowerpcle-*-eabisim* | \\\n+\tpowerpcle-*-eabi*  | \\\n+        powerpcle-*-winnt* | \\\n+\tpowerpcle-*-pe | powerpcle-*-cygwin32 | \\\n+\tthumb-*-coff* | thumbel-*-coff* )\n+\t\tfixincludes=\n+\t\t;;\n+\n+\t*-sgi-irix*)\n+\t\tfixincludes=fixinc.irix\n+\t\t;;\n+esac\n+\n+if test -z \"$fixincludes\"\n+then\n+    cat > ../fixinc.sh  <<-\t_EOF_\n+\t#! /bin/sh\n+\texit 0\n+\t_EOF_\n+    exit 0\n+fi\n+\n+if test -f \"$fixincludes\"\n+then\n+    echo copying $fixincludes to $dest\n+    cp $fixincludes $dest\n+    exit 0\n+fi\n+\n+echo $MAKE install\n+$MAKE install || cp inclhack.sh .."}, {"sha": "adff8a248f17f89d0756f9461b2bde8bce37308c", "filename": "gcc/fixinc/regex.c", "status": "added", "additions": 5058, "deletions": 0, "changes": 5058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fregex.c?ref=0083c9044f6a6d904380daffb0c5c34919861792"}, {"sha": "bc4ec2e518ed81521d64e736b53bf520439a2dfb", "filename": "gcc/fixinc/regex.h", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fregex.h?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,503 @@\n+/* Definitions for data structures and routines for the regular\n+   expression library, version 0.12.\n+\n+   Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* $Id: regex.h,v 1.3 1999/01/11 13:34:25 law Exp $ */\n+\n+#ifndef __REGEXP_LIBRARY_H__\n+#define __REGEXP_LIBRARY_H__\n+\n+/* POSIX says that <sys/types.h> must be included (by the caller) before\n+   <regex.h>.  */\n+\n+#ifdef VMS\n+/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n+   should be there.  */\n+#include <stddef.h>\n+#endif\n+\n+\n+/* The following bits are used to determine the regexp syntax we\n+   recognize.  The set/not-set meanings are chosen so that Emacs syntax\n+   remains the value 0.  The bits are given in alphabetical order, and\n+   the definitions shifted by one from the previous bit; thus, when we\n+   add or remove a bit, only one other definition need change.  */\n+typedef unsigned reg_syntax_t;\n+\n+/* If this bit is not set, then \\ inside a bracket expression is literal.\n+   If set, then such a \\ quotes the following character.  */\n+#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)\n+\n+/* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n+     literals. \n+   If set, then \\+ and \\? are operators and + and ? are literals.  */\n+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n+\n+/* If this bit is set, then character classes are supported.  They are:\n+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],\n+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].\n+   If not set, then character classes are not supported.  */\n+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)\n+\n+/* If this bit is set, then ^ and $ are always anchors (outside bracket\n+     expressions, of course).\n+   If this bit is not set, then it depends:\n+        ^  is an anchor if it is at the beginning of a regular\n+           expression or after an open-group or an alternation operator;\n+        $  is an anchor if it is at the end of a regular expression, or\n+           before a close-group or an alternation operator.  \n+\n+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n+   POSIX draft 11.2 says that * etc. in leading positions is undefined.\n+   We already implemented a previous draft which made those constructs\n+   invalid, though, so we haven't changed the code back.  */\n+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)\n+\n+/* If this bit is set, then special characters are always special\n+     regardless of where they are in the pattern.\n+   If this bit is not set, then special characters are special only in\n+     some contexts; otherwise they are ordinary.  Specifically, \n+     * + ? and intervals are only special when not after the beginning,\n+     open-group, or alternation operator.  */\n+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n+\n+/* If this bit is set, then *, +, ?, and { cannot be first in an re or\n+     immediately after an alternation or begin-group operator.  */\n+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)\n+\n+/* If this bit is set, then . matches newline.\n+   If not set, then it doesn't.  */\n+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)\n+\n+/* If this bit is set, then . doesn't match NUL.\n+   If not set, then it does.  */\n+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)\n+\n+/* If this bit is set, nonmatching lists [^...] do not match newline.\n+   If not set, they do.  */\n+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n+\n+/* If this bit is set, either \\{...\\} or {...} defines an\n+     interval, depending on RE_NO_BK_BRACES. \n+   If not set, \\{, \\}, {, and } are literals.  */\n+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n+\n+/* If this bit is set, +, ? and | aren't recognized as operators.\n+   If not set, they are.  */\n+#define RE_LIMITED_OPS (RE_INTERVALS << 1)\n+\n+/* If this bit is set, newline is an alternation operator.\n+   If not set, newline is literal.  */\n+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)\n+\n+/* If this bit is set, then `{...}' defines an interval, and \\{ and \\}\n+     are literals.\n+  If not set, then `\\{...\\}' defines an interval.  */\n+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)\n+\n+/* If this bit is set, (...) defines a group, and \\( and \\) are literals.\n+   If not set, \\(...\\) defines a group, and ( and ) are literals.  */\n+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)\n+\n+/* If this bit is set, then \\<digit> matches <digit>.\n+   If not set, then \\<digit> is a back-reference.  */\n+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n+\n+/* If this bit is set, then | is an alternation operator, and \\| is literal. \n+   If not set, then \\| is an alternation operator, and | is literal.  */\n+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n+\n+/* If this bit is set, then an ending range point collating higher\n+     than the starting range point, as in [z-a], is invalid.\n+   If not set, then when ending range point collates higher than the\n+     starting range point, the range is ignored.  */\n+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)\n+\n+/* If this bit is set, then an unmatched ) is ordinary.\n+   If not set, then an unmatched ) is invalid.  */\n+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n+\n+/* This global variable defines the particular regexp syntax to use (for\n+   some interfaces).  When a regexp is compiled, the syntax used is\n+   stored in the pattern buffer, so changing this does not affect\n+   already-compiled regexps.  */\n+extern reg_syntax_t re_syntax_options;\n+\f\n+/* Define combinations of the above bits for the standard possibilities.\n+   (The [[[ comments delimit what gets put into the Texinfo file, so\n+   don't delete them!)  */ \n+/* [[[begin syntaxes]]] */\n+#define RE_SYNTAX_EMACS 0\n+\n+#define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n+  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL\t\t\t\\\n+   | RE_NO_BK_PARENS            | RE_NO_BK_REFS\t\t\t\t\\\n+   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES\t\t\t\\\n+   | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\n+#define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)\n+\n+#define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS\t\t\t\t\\\n+   | RE_NEWLINE_ALT)\n+\n+#define RE_SYNTAX_EGREP\t\t\t\t\t\t\t\\\n+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE\t\t\t\\\n+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS\t\t\t\t\\\n+   | RE_NO_BK_VBAR)\n+\n+#define RE_SYNTAX_POSIX_EGREP\t\t\t\t\t\t\\\n+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)\n+\n+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC\n+\n+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC\n+\n+/* Syntax bits common to both basic and extended POSIX regex syntax.  */\n+#define _RE_SYNTAX_POSIX_COMMON\t\t\t\t\t\t\\\n+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL\t\t\\\n+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)\n+\n+#define RE_SYNTAX_POSIX_BASIC\t\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)\n+\n+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes\n+   RE_LIMITED_OPS, i.e., \\? \\+ \\| are not recognized.  Actually, this\n+   isn't minimal, since other operators, such as \\`, aren't disabled.  */\n+#define RE_SYNTAX_POSIX_MINIMAL_BASIC\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)\n+\n+#define RE_SYNTAX_POSIX_EXTENDED\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES\t\t\t\t\\\n+   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR\t\t\t\t\\\n+   | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\n+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS\n+   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */\n+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES\t\t\t\t\\\n+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS\t\t\t\t\\\n+   | RE_NO_BK_VBAR\t    | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+/* [[[end syntaxes]]] */\n+\f\n+/* Maximum number of duplicates an interval can allow.  Some systems\n+   (erroneously) define this in other header files, but we want our\n+   value, so remove any previous define.  */\n+#ifdef RE_DUP_MAX\n+#undef RE_DUP_MAX\n+#endif\n+#define RE_DUP_MAX ((1 << 15) - 1) \n+\n+\n+/* POSIX `cflags' bits (i.e., information for `regcomp').  */\n+\n+/* If this bit is set, then use extended regular expression syntax.\n+   If not set, then use basic regular expression syntax.  */\n+#define REG_EXTENDED 1\n+\n+/* If this bit is set, then ignore case when matching.\n+   If not set, then case is significant.  */\n+#define REG_ICASE (REG_EXTENDED << 1)\n+ \n+/* If this bit is set, then anchors do not match at newline\n+     characters in the string.\n+   If not set, then anchors do match at newlines.  */\n+#define REG_NEWLINE (REG_ICASE << 1)\n+\n+/* If this bit is set, then report only success or fail in regexec.\n+   If not set, then returns differ between not matching and errors.  */\n+#define REG_NOSUB (REG_NEWLINE << 1)\n+\n+\n+/* POSIX `eflags' bits (i.e., information for regexec).  */\n+\n+/* If this bit is set, then the beginning-of-line operator doesn't match\n+     the beginning of the string (presumably because it's not the\n+     beginning of a line).\n+   If not set, then the beginning-of-line operator does match the\n+     beginning of the string.  */\n+#define REG_NOTBOL 1\n+\n+/* Like REG_NOTBOL, except for the end-of-line.  */\n+#define REG_NOTEOL (1 << 1)\n+\n+\n+  /* POSIX doesn't require that we do anything for the 0 case,\n+     but why not be nice.  */\n+\n+#define REG_ERR_TABLE                                           \\\n+  _RERR_( NOERROR,   \"Success\" )                                \\\n+  _RERR_( NOMATCH,   \"No match\" )                               \\\n+  /*                                                            \\\n+   *  POSIX regcomp return error codes.                         \\\n+   *  (In the order listed in the standard.)                    \\\n+   */                                                           \\\n+  _RERR_( BADPAT,    \"Invalid regular expression\" )             \\\n+  _RERR_( ECOLLATE,  \"Invalid collation character\" )            \\\n+  _RERR_( ECTYPE,    \"Invalid character class name\" )           \\\n+  _RERR_( EESCAPE,   \"Trailing backslash\" )                     \\\n+  _RERR_( ESUBREG,   \"Invalid back reference\" )                 \\\n+  _RERR_( EBRACK,    \"Unmatched [ or [^\" )                      \\\n+  _RERR_( EPAREN,    \"Unmatched ( or \\\\(\" )                     \\\n+  _RERR_( EBRACE,    \"Unmatched \\\\{\" )                          \\\n+  _RERR_( BADBR,     \"Invalid content of \\\\{\\\\}\" )              \\\n+  _RERR_( ERANGE,    \"Invalid range end\" )                      \\\n+  _RERR_( ESPACE,    \"Memory exhausted\" )                       \\\n+  _RERR_( BADRPT,    \"Invalid preceding regular expression\" )   \\\n+  _RERR_( ECHAR,     \"Invalid multibyte character\" )            \\\n+  _RERR_( EBOL,      \"^ anchor and not BOL\" )                   \\\n+  _RERR_( EEOL,      \"$ anchor and not EOL\" )                   \\\n+                                                                \\\n+  /*                                                            \\\n+   * Error codes we've added.                                   \\\n+   */                                                           \\\n+  _RERR_( EEND,      \"Premature end of regular expression\" )    \\\n+  _RERR_( ESIZE,     \"Regular expression too big\" )             \\\n+  _RERR_( ERPAREN,   \"Unmatched ) or \\\\)\" )\n+\n+#define _RERR_(n,t)  REG_ ## n,\n+\n+typedef enum { REG_ERR_TABLE REG_ERR_COUNT } reg_errcode_t;\n+\n+#undef _RERR_\n+\f\n+/* This data structure represents a compiled pattern.  Before calling\n+   the pattern compiler, the fields `buffer', `allocated', `fastmap',\n+   `translate', and `no_sub' can be set.  After the pattern has been\n+   compiled, the `re_nsub' field is available.  All other fields are\n+   private to the regex routines.  */\n+\n+struct re_pattern_buffer\n+{\n+/* [[[begin pattern_buffer]]] */\n+\t/* Space that holds the compiled pattern.  It is declared as\n+          `unsigned char *' because its elements are\n+           sometimes used as array indexes.  */\n+  unsigned char *buffer;\n+\n+\t/* Number of bytes to which `buffer' points.  */\n+  unsigned long allocated;\n+\n+\t/* Number of bytes actually used in `buffer'.  */\n+  unsigned long used;\t\n+\n+        /* Syntax setting with which the pattern was compiled.  */\n+  reg_syntax_t syntax;\n+\n+        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses\n+           the fastmap, if there is one, to skip over impossible\n+           starting points for matches.  */\n+  char *fastmap;\n+\n+        /* Either a translate table to apply to all characters before\n+           comparing them, or zero for no translation.  The translation\n+           is applied to a pattern when it is compiled and to a string\n+           when it is matched.  */\n+  char *translate;\n+\n+\t/* Number of subexpressions found by the compiler.  */\n+  size_t re_nsub;\n+\n+        /* Zero if this pattern cannot match the empty string, one else.\n+           Well, in truth it's used only in `re_search_2', to see\n+           whether or not we should use the fastmap, so we don't set\n+           this absolutely perfectly; see `re_compile_fastmap' (the\n+           `duplicate' case).  */\n+  unsigned can_be_null : 1;\n+\n+        /* If REGS_UNALLOCATED, allocate space in the `regs' structure\n+             for `max (RE_NREGS, re_nsub + 1)' groups.\n+           If REGS_REALLOCATE, reallocate space if necessary.\n+           If REGS_FIXED, use what's there.  */\n+#define REGS_UNALLOCATED 0\n+#define REGS_REALLOCATE 1\n+#define REGS_FIXED 2\n+  unsigned regs_allocated : 2;\n+\n+        /* Set to zero when `regex_compile' compiles a pattern; set to one\n+           by `re_compile_fastmap' if it updates the fastmap.  */\n+  unsigned fastmap_accurate : 1;\n+\n+        /* If set, `re_match_2' does not return information about\n+           subexpressions.  */\n+  unsigned no_sub : 1;\n+\n+        /* If set, a beginning-of-line anchor doesn't match at the\n+           beginning of the string.  */ \n+  unsigned not_bol : 1;\n+\n+        /* Similarly for an end-of-line anchor.  */\n+  unsigned not_eol : 1;\n+\n+        /* If true, an anchor at a newline matches.  */\n+  unsigned newline_anchor : 1;\n+\n+/* [[[end pattern_buffer]]] */\n+};\n+\n+typedef struct re_pattern_buffer regex_t;\n+\n+\n+/* search.c (search_buffer) in Emacs needs this one opcode value.  It is\n+   defined both in `regex.c' and here.  */\n+#define RE_EXACTN_VALUE 1\n+\f\n+/* Type for byte offsets within the string.  POSIX mandates this.  */\n+typedef int regoff_t;\n+\n+\n+/* This is the structure we store register match data in.  See\n+   regex.texinfo for a full description of what registers match.  */\n+struct re_registers\n+{\n+  unsigned num_regs;\n+  regoff_t *start;\n+  regoff_t *end;\n+};\n+\n+\n+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,\n+   `re_match_2' returns information about at least this many registers\n+   the first time a `regs' structure is passed.  */\n+#ifndef RE_NREGS\n+#define RE_NREGS 30\n+#endif\n+\n+\n+/* POSIX specification for registers.  Aside from the different names than\n+   `re_registers', POSIX uses an array of structures, instead of a\n+   structure of arrays.  */\n+typedef struct\n+{\n+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */\n+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */\n+} regmatch_t;\n+\f\n+/* Declarations for routines.  */\n+\n+/* To avoid duplicating every routine declaration -- once with a\n+   prototype (if we are ANSI), and once without (if we aren't) -- we\n+   use the following macro to declare argument types.  This\n+   unfortunately clutters up the declarations a bit, but I think it's\n+   worth it.  */\n+\n+#if __STDC__\n+\n+#define _RE_ARGS(args) args\n+\n+#else /* not __STDC__ */\n+\n+#define _RE_ARGS(args) ()\n+\n+#endif /* not __STDC__ */\n+\n+/* Sets the current default syntax to SYNTAX, and return the old syntax.\n+   You can also simply assign to the `re_syntax_options' variable.  */\n+extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n+\n+/* Compile the regular expression PATTERN, with length LENGTH\n+   and syntax given by the global `re_syntax_options', into the buffer\n+   BUFFER.  Return NULL if successful, and an error string if not.  */\n+extern const char *re_compile_pattern\n+  _RE_ARGS ((const char *pattern, int length,\n+             struct re_pattern_buffer *buffer));\n+\n+\n+/* Compile a fastmap for the compiled pattern in BUFFER; used to\n+   accelerate searches.  Return 0 if successful and -2 if was an\n+   internal error.  */\n+extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n+\n+\n+/* Search in the string STRING (with length LENGTH) for the pattern\n+   compiled into BUFFER.  Start searching at position START, for RANGE\n+   characters.  Return the starting position of the match, -1 for no\n+   match, or -2 for an internal error.  Also return register\n+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\n+extern int re_search\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+            int length, int start, int range, struct re_registers *regs));\n+\n+\n+/* Like `re_search', but search in the concatenation of STRING1 and\n+   STRING2.  Also, stop searching at index START + STOP.  */\n+extern int re_search_2\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, int range, struct re_registers *regs, int stop));\n+\n+\n+/* Like `re_search', but return how many characters in STRING the regexp\n+   in BUFFER matched, starting at position START.  */\n+extern int re_match\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+             int length, int start, struct re_registers *regs));\n+\n+\n+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\n+extern int re_match_2 \n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, struct re_registers *regs, int stop));\n+\n+\n+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory\n+   for recording register information.  STARTS and ENDS must be\n+   allocated with malloc, and must each be at least `NUM_REGS * sizeof\n+   (regoff_t)' bytes long.\n+\n+   If NUM_REGS == 0, then subsequent matches should allocate their own\n+   register data.\n+\n+   Unless this function is called, the first search or match using\n+   PATTERN_BUFFER will allocate its own register data, without\n+   freeing the old data.  */\n+extern void re_set_registers\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n+             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n+\n+/* 4.2 bsd compatibility.  */\n+extern char *re_comp _RE_ARGS ((const char *));\n+extern int re_exec _RE_ARGS ((const char *));\n+\n+/* POSIX compatibility.  */\n+extern int regcomp _RE_ARGS ((regex_t *preg, const char *pattern, int cflags));\n+extern int regexec\n+  _RE_ARGS ((const regex_t *preg, const char *string, size_t nmatch,\n+             regmatch_t pmatch[], int eflags));\n+extern size_t regerror\n+  _RE_ARGS ((int errcode, const regex_t *preg, char *errbuf,\n+             size_t errbuf_size));\n+extern void regfree _RE_ARGS ((regex_t *preg));\n+\n+#endif /* not __REGEXP_LIBRARY_H__ */\n+\f\n+/*\n+Local variables:\n+make-backup-files: t\n+version-control: t\n+trim-versions-without-asking: nil\n+End:\n+*/"}, {"sha": "296e30778cf6324ee207dcf65f07b1e7bc79b679", "filename": "gcc/fixinc/server.c", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fserver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fserver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.c?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,464 @@\n+\n+/*\n+ *  $Id: server.c,v 1.2 1998/12/16 21:19:16 law Exp $\n+ *\n+ *  Server Handling copyright 1992-1998 Bruce Korb\n+ *\n+ *  Server Handling is free software.\n+ *  You may redistribute it and/or modify it under the terms of the\n+ *  GNU General Public License, as published by the Free Software\n+ *  Foundation; either version 2, or (at your option) any later version.\n+ *\n+ *  Server Handling is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Server Handling.  See the file \"COPYING\".  If not,\n+ *  write to:  The Free Software Foundation, Inc.,\n+ *             59 Temple Place - Suite 330,\n+ *             Boston,  MA  02111-1307, USA.\n+ *\n+ * As a special exception, Bruce Korb gives permission for additional\n+ * uses of the text contained in his release of ServerHandler.\n+ *\n+ * The exception is that, if you link the ServerHandler library with other\n+ * files to produce an executable, this does not by itself cause the\n+ * resulting executable to be covered by the GNU General Public License.\n+ * Your use of that executable is in no way restricted on account of\n+ * linking the ServerHandler library code into it.\n+ *\n+ * This exception does not however invalidate any other reasons why\n+ * the executable file might be covered by the GNU General Public License.\n+ *\n+ * This exception applies only to the code released by Bruce Korb under\n+ * the name ServerHandler.  If you copy code from other sources under the\n+ * General Public License into a copy of ServerHandler, as the General Public\n+ * License permits, the exception does not apply to the code that you add\n+ * in this way.  To avoid misleading anyone as to the status of such\n+ * modified files, you must delete this exception notice from them.\n+ *\n+ * If you write modifications of your own for ServerHandler, it is your\n+ * choice whether to permit this exception to apply to your modifications.\n+ * If you do not wish that, delete this exception notice.\n+ */\n+\n+#include <fcntl.h>\n+#include <errno.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <sys/param.h>\n+\n+#include \"server.h\"\n+\n+#ifdef DEBUG\n+#define STATIC\n+#else\n+#define STATIC static\n+#endif\n+#ifndef tSCC\n+#define tSCC static const char\n+#endif\n+#ifndef NUL\n+#define NUL '\\0'\n+#endif\n+\n+STATIC bool readPipeTimeout;\n+\n+STATIC tpChar defArgs[] =\n+{(char *) NULL, \"-p\", (char *) NULL};\n+STATIC tpfPair serverPair =\n+{(FILE *) NULL, (FILE *) NULL};\n+STATIC pid_t serverId = NULLPROCESS;\n+/*\n+ *  Arbitrary text that should not be found in the shell output.\n+ *  It must be a single line and appear verbatim at the start of\n+ *  the terminating output line.\n+ */\n+tSCC zDone[] = \"ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd\";\n+STATIC tpChar pCurDir = (char *) NULL;\n+\n+/*\n+ *  chainOpen\n+ *\n+ *  Given an FD for an inferior process to use as stdin,\n+ *  start that process and return a NEW FD that that process\n+ *  will use for its stdout.  Requires the argument vector\n+ *  for the new process and, optionally, a pointer to a place\n+ *  to store the child's process id.\n+ */\n+int\n+chainOpen (stdinFd, ppArgs, pChild)\n+     int stdinFd;\n+     tpChar *ppArgs;\n+     pid_t *pChild;\n+{\n+  tFdPair stdoutPair =\n+  {-1, -1};\n+  pid_t chId;\n+  char *pzCmd;\n+\n+  /*\n+   *  Create a pipe it will be the child process' stdout,\n+   *  and the parent will read from it.\n+   */\n+  if ((pipe ((int *) &stdoutPair) < 0))\n+    {\n+      if (pChild != (pid_t *) NULL)\n+\t*pChild = NOPROCESS;\n+      return -1;\n+    }\n+\n+  /*\n+   *  If we did not get an arg list, use the default\n+   */\n+  if (ppArgs == (tpChar *) NULL)\n+    ppArgs = defArgs;\n+\n+  /*\n+   *  If the arg list does not have a program,\n+   *  assume the \"SHELL\" from the environment, or, failing\n+   *  that, then sh.  Set argv[0] to whatever we decided on.\n+   */\n+  if (pzCmd = *ppArgs,\n+      (pzCmd == (char *) NULL) || (*pzCmd == '\\0'))\n+    {\n+\n+      pzCmd = getenv (\"SHELL\");\n+      if (pzCmd == (char *) NULL)\n+\tpzCmd = \"sh\";\n+    }\n+#ifdef DEBUG_PRINT\n+  printf (\"START:  %s\\n\", pzCmd);\n+  {\n+    int idx = 0;\n+    while (ppArgs[++idx] != (char *) NULL)\n+      printf (\"  ARG %2d:  %s\\n\", idx, ppArgs[idx]);\n+  }\n+#endif\n+  /*\n+   *  Call fork() and see which process we become\n+   */\n+  chId = fork ();\n+  switch (chId)\n+    {\n+    case NOPROCESS:\t\t/* parent - error in call */\n+      close (stdoutPair.readFd);\n+      close (stdoutPair.writeFd);\n+      if (pChild != (pid_t *) NULL)\n+\t*pChild = NOPROCESS;\n+      return -1;\n+\n+    default:\t\t\t/* parent - return opposite FD's */\n+      if (pChild != (pid_t *) NULL)\n+\t*pChild = chId;\n+#ifdef DEBUG_PRINT\n+      printf (\"for pid %d:  stdin from %d, stdout to %d\\n\"\n+\t      \"for parent:  read from %d\\n\",\n+\t      chId, stdinFd, stdoutPair.writeFd, stdoutPair.readFd);\n+#endif\n+      close (stdinFd);\n+      close (stdoutPair.writeFd);\n+      return stdoutPair.readFd;\n+\n+    case NULLPROCESS:\t\t/* child - continue processing */\n+      break;\n+    }\n+\n+  /*\n+   *  Close the pipe end handed back to the parent process\n+   */\n+  close (stdoutPair.readFd);\n+\n+  /*\n+   *  Close our current stdin and stdout\n+   */\n+  close (STDIN_FILENO);\n+  close (STDOUT_FILENO);\n+\n+  /*\n+   *  Make the fd passed in the stdin, and the write end of\n+   *  the new pipe become the stdout.\n+   */\n+  fcntl (stdoutPair.writeFd, F_DUPFD, STDOUT_FILENO);\n+  fcntl (stdinFd, F_DUPFD, STDIN_FILENO);\n+\n+  if (*ppArgs == (char *) NULL)\n+    *ppArgs = pzCmd;\n+\n+  execvp (pzCmd, ppArgs);\n+  fprintf (stderr, \"Error %d:  Could not execvp( '%s', ... ):  %s\\n\",\n+\t   errno, pzCmd, strerror (errno));\n+  exit (EXIT_PANIC);\n+}\n+\n+\n+/*\n+ *  p2open\n+ *\n+ *  Given a pointer to an argument vector, start a process and\n+ *  place its stdin and stdout file descriptors into an fd pair\n+ *  structure.  The \"writeFd\" connects to the inferior process\n+ *  stdin, and the \"readFd\" connects to its stdout.  The calling\n+ *  process should write to \"writeFd\" and read from \"readFd\".\n+ *  The return value is the process id of the created process.\n+ */\n+pid_t\n+p2open (pPair, ppArgs)\n+     tFdPair *pPair;\n+     tpChar *ppArgs;\n+{\n+  pid_t chId;\n+\n+  /*\n+   *  Create a bi-directional pipe.  Writes on 0 arrive on 1\n+   *  and vice versa, so the parent and child processes will\n+   *  read and write to opposite FD's.\n+   */\n+  if (pipe ((int *) pPair) < 0)\n+    return NOPROCESS;\n+\n+  pPair->readFd = chainOpen (pPair->readFd, ppArgs, &chId);\n+  if (chId == NOPROCESS)\n+    close (pPair->writeFd);\n+\n+  return chId;\n+}\n+\n+\n+/*\n+ *  p2fopen\n+ *\n+ *  Identical to \"p2open()\", except that the \"fd\"'s are \"fdopen(3)\"-ed\n+ *  into file pointers instead.\n+ */\n+pid_t\n+p2fopen (pfPair, ppArgs)\n+     tpfPair *pfPair;\n+     tpChar *ppArgs;\n+{\n+  tFdPair fdPair;\n+  pid_t chId = p2open (&fdPair, ppArgs);\n+\n+  if (chId == NOPROCESS)\n+    return chId;\n+\n+  pfPair->pfRead = fdopen (fdPair.readFd, \"r\");\n+  pfPair->pfWrite = fdopen (fdPair.writeFd, \"w\");\n+  return chId;\n+}\n+\n+\n+/*\n+ *  loadData\n+ *\n+ *  Read data from a file pointer (a pipe to a process in this context)\n+ *  until we either get EOF or we get a marker line back.\n+ *  The read data are stored in a malloc-ed string that is truncated\n+ *  to size at the end.  Input is assumed to be an ASCII string.\n+ */\n+STATIC char *\n+loadData (fp)\n+     FILE *fp;\n+{\n+  char *pzText;\n+  size_t textSize;\n+  char *pzScan;\n+  char zLine[1024];\n+\n+  textSize = sizeof (zLine) * 2;\n+  pzScan = \\\n+    pzText = malloc (textSize);\n+\n+  if (pzText == (char *) NULL)\n+    return pzText;\n+\n+  for (;;)\n+    {\n+      size_t usedCt;\n+\n+      alarm (10);\n+      readPipeTimeout = BOOL_FALSE;\n+      if (fgets (zLine, sizeof (zLine), fp) == (char *) NULL)\n+\tbreak;\n+\n+      if (strncmp (zLine, zDone, sizeof (zDone) - 1) == 0)\n+\tbreak;\n+\n+      strcpy (pzScan, zLine);\n+      pzScan += strlen (zLine);\n+      usedCt = (size_t) (pzScan - pzText);\n+\n+      if (textSize - usedCt < sizeof (zLine))\n+\t{\n+\n+\t  size_t off = (size_t) (pzScan - pzText);\n+\t  void *p;\n+\t  textSize += 4096;\n+\t  p = realloc ((void *) pzText, textSize);\n+\t  if (p == (void *) NULL)\n+\t    {\n+\t      fprintf (stderr, \"Failed to get 0x%08X bytes\\n\", textSize);\n+\t      free ((void *) pzText);\n+\t      return (char *) NULL;\n+\t    }\n+\n+\t  pzText = (char *) p;\n+\t  pzScan = pzText + off;\n+\t}\n+    }\n+\n+  alarm (0);\n+  if (readPipeTimeout)\n+    {\n+      free ((void *) pzText);\n+      return (char *) NULL;\n+    }\n+\n+  while ((pzScan > pzText) && isspace (pzScan[-1]))\n+    pzScan--;\n+  *pzScan = NUL;\n+  return realloc ((void *) pzText, strlen (pzText) + 1);\n+}\n+\n+\n+/*\n+ *  SHELL SERVER PROCESS CODE\n+ */\n+\n+#ifdef DONT_HAVE_SIGSEND\n+typedef enum\n+{\n+  P_ALL, P_PID, P_GID, P_UID, P_PGID, P_SID, P_CID\n+}\n+idtype_t;\n+typedef long id_t;\n+\n+STATIC int\n+sigsend (idtype, id, sig)\n+     idtype_t idtype;\n+     id_t id;\n+     int sig;\n+{\n+  switch (idtype)\n+    {\n+    case P_PID:\n+      kill ((pid_t) id, sig);\n+      break;\n+\n+    case P_ALL:\n+    case P_GID:\n+    case P_UID:\n+    case P_PGID:\n+    case P_SID:\n+    case P_CID:\n+      errno = EINVAL;\n+      return -1;\n+      /*NOTREACHED */\n+    }\n+\n+  return 0;\n+}\n+#endif /* HAVE_SIGSEND */\n+\n+\n+STATIC void\n+closeServer ()\n+{\n+  kill( (pid_t) serverId, SIGKILL);\n+  serverId = NULLPROCESS;\n+  fclose (serverPair.pfRead);\n+  fclose (serverPair.pfWrite);\n+  serverPair.pfRead = serverPair.pfWrite = (FILE *) NULL;\n+}\n+\n+\n+struct sigaction savePipeAction;\n+struct sigaction saveAlrmAction;\n+struct sigaction currentAction;\n+\n+STATIC void\n+sigHandler (signo)\n+     int signo;\n+{\n+  closeServer ();\n+  readPipeTimeout = BOOL_TRUE;\n+}\n+\n+\n+STATIC void\n+serverSetup ()\n+{\n+#ifndef SA_SIGINFO\n+#  define SA_SIGINFO 0\n+#else\n+  currentAction.sa_sigaction =\n+#endif\n+  currentAction.sa_handler   = sigHandler;\n+  currentAction.sa_flags     = SA_SIGINFO;\n+  sigemptyset( &currentAction.sa_mask );\n+\n+  sigaction( SIGPIPE, &currentAction, &savePipeAction );\n+  sigaction( SIGALRM, &currentAction, &saveAlrmAction );\n+  atexit( &closeServer );\n+\n+  fputs (\"trap : INT\\n\", serverPair.pfWrite);\n+  fflush (serverPair.pfWrite);\n+  pCurDir = getcwd ((char *) NULL, MAXPATHLEN + 1);\n+}\n+\n+\n+char *\n+runShell (pzCmd)\n+     const char *pzCmd;\n+{\n+  tSCC zNil[] = \"\";\n+\n+  /*\n+   *  IF the shell server process is not running yet,\n+   *  THEN try to start it.\n+   */\n+  if (serverId == NULLPROCESS)\n+    {\n+      serverId = p2fopen (&serverPair, defArgs);\n+      if (serverId > 0)\n+\tserverSetup ();\n+    }\n+\n+  /*\n+   *  IF it is still not running,\n+   *  THEN return the nil string.\n+   */\n+  if (serverId <= 0)\n+    return (char *) zNil;\n+\n+  /*\n+   *  Make sure the process will pay attention to us,\n+   *  send the supplied command, and then\n+   *  have it output a special marker that we can find.\n+   */\n+  fprintf (serverPair.pfWrite, \"\\\\cd %s\\n%s\\n\\necho\\necho %s\\n\",\n+\t   pCurDir, pzCmd, zDone);\n+  fflush (serverPair.pfWrite);\n+  if (serverId == NULLPROCESS)\n+    return (char *) NULL;\n+\n+  /*\n+   *  Now try to read back all the data.  If we fail due to either\n+   *  a sigpipe or sigalrm (timeout), we will return the nil string.\n+   */\n+  {\n+    char *pz = loadData (serverPair.pfRead);\n+    if (pz == (char *) NULL)\n+      {\n+\tfprintf (stderr, \"CLOSING SHELL SERVER - command failure:\\n\\t%s\\n\",\n+\t\t pzCmd);\n+\tcloseServer ();\n+\tpz = (char *) zNil;\n+      }\n+    return pz;\n+  }\n+}"}, {"sha": "aef8df7da8423943d9df4c522c12cc80ba1071ec", "filename": "gcc/fixinc/server.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fserver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0083c9044f6a6d904380daffb0c5c34919861792/gcc%2Ffixinc%2Fserver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.h?ref=0083c9044f6a6d904380daffb0c5c34919861792", "patch": "@@ -0,0 +1,94 @@\n+\n+/*\n+ *  $Id: server.h,v 1.2 1998/12/16 21:19:17 law Exp $\n+ *\n+ *  Server Handling copyright 1992-1998 Bruce Korb\n+ *\n+ *  Server Handling is free software.\n+ *  You may redistribute it and/or modify it under the terms of the\n+ *  GNU General Public License, as published by the Free Software\n+ *  Foundation; either version 2, or (at your option) any later version.\n+ *\n+ *  Server Handling is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Server Handling.  See the file \"COPYING\".  If not,\n+ *  write to:  The Free Software Foundation, Inc.,\n+ *             59 Temple Place - Suite 330,\n+ *             Boston,  MA  02111-1307, USA.\n+ *\n+ * As a special exception, Bruce Korb gives permission for additional\n+ * uses of the text contained in his release of ServerHandler.\n+ *\n+ * The exception is that, if you link the ServerHandler library with other\n+ * files to produce an executable, this does not by itself cause the\n+ * resulting executable to be covered by the GNU General Public License.\n+ * Your use of that executable is in no way restricted on account of\n+ * linking the ServerHandler library code into it.\n+ *\n+ * This exception does not however invalidate any other reasons why\n+ * the executable file might be covered by the GNU General Public License.\n+ *\n+ * This exception applies only to the code released by Bruce Korb under\n+ * the name ServerHandler.  If you copy code from other sources under the\n+ * General Public License into a copy of ServerHandler, as the General Public\n+ * License permits, the exception does not apply to the code that you add\n+ * in this way.  To avoid misleading anyone as to the status of such\n+ * modified files, you must delete this exception notice from them.\n+ *\n+ * If you write modifications of your own for ServerHandler, it is your\n+ * choice whether to permit this exception to apply to your modifications.\n+ * If you do not wish that, delete this exception notice.\n+ */\n+\n+#ifndef FIXINC_SERVER_H\n+#define FIXINC_SERVER_H\n+\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+/*\n+ *  Dual pipe opening of a child process\n+ */\n+\n+typedef struct\n+  {\n+    int readFd;\n+    int writeFd;\n+  }\n+tFdPair;\n+\n+typedef struct\n+  {\n+    FILE *pfRead;\t\t/* parent read fp  */\n+    FILE *pfWrite;\t\t/* parent write fp */\n+  }\n+tpfPair;\n+\n+typedef char *tpChar;\n+\n+#define NOPROCESS   ((pid_t)-1)\n+#define NULLPROCESS ((pid_t)0)\n+\n+#define EXIT_PANIC   99\n+\n+typedef enum\n+  {\n+    BOOL_FALSE, BOOL_TRUE\n+  }\n+bool;\n+\n+#define _P_(p) ()\n+\n+char *runShell _P_ ((const char *pzCmd));\n+pid_t p2fopen _P_ ((tpfPair * pfPair, tpChar * ppArgs));\n+pid_t p2open _P_ ((tFdPair * pPair, tpChar * ppArgs));\n+int\n+chainOpen _P_ ((int stdinFd,\n+\t\ttpChar * ppArgs,\n+\t\tpid_t * pChild));\n+\n+#endif /* FIXINC_SERVER_H */"}]}