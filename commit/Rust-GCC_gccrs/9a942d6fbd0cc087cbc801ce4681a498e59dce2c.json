{"sha": "9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE5NDJkNmZiZDBjYzA4N2NiYzgwMWNlNDY4MWE0OThlNTlkY2UyYw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-18T14:51:36Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-20T09:59:22Z"}, "message": "Add in TupleStruct support\n\nThis adds in tuple struct support with name and type resolution. The\narguments and number of arguments are validated against. Test cases\nadded for those errors too.", "tree": {"sha": "5198e76f054e741f5ba9793e111bfd63be88e80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5198e76f054e741f5ba9793e111bfd63be88e80d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89631998d2ffda0c0c05066c148c6fc19398da5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89631998d2ffda0c0c05066c148c6fc19398da5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89631998d2ffda0c0c05066c148c6fc19398da5c"}], "stats": {"total": 448, "additions": 359, "deletions": 89}, "files": [{"sha": "a1b505dc8b310c167f485172b41716078ef9be82", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -1817,13 +1817,14 @@ struct StructField\n \t       Visibility vis,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_name (std::move (field_name)), field_type (std::move (field_type))\n+      field_name (std::move (field_name)), field_type (std::move (field_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor\n   StructField (StructField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_name (other.field_name)\n+      field_name (other.field_name), node_id (other.node_id)\n   {\n     // guard to prevent null dereference\n     if (other.field_type != nullptr)\n@@ -1838,6 +1839,7 @@ struct StructField\n     field_name = other.field_name;\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.field_type != nullptr)\n@@ -1959,6 +1961,7 @@ struct TupleField\n   std::unique_ptr<Type> field_type;\n \n   // should this store location info?\n+  NodeId node_id;\n \n public:\n   // Returns whether tuple field has outer attributes.\n@@ -1972,12 +1975,14 @@ struct TupleField\n   TupleField (std::unique_ptr<Type> field_type, Visibility vis,\n \t      std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_type (std::move (field_type))\n+      field_type (std::move (field_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility)\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      node_id (other.node_id)\n   {\n     // guard to prevent null dereference (only required if error)\n     if (other.field_type != nullptr)\n@@ -1991,6 +1996,7 @@ struct TupleField\n   {\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference (only required if error)\n     if (other.field_type != nullptr)\n@@ -2016,6 +2022,8 @@ struct TupleField\n \n   std::string as_string () const;\n \n+  NodeId get_node_id () const { return node_id; };\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n@@ -2053,6 +2061,15 @@ class TupleStruct : public Struct\n   std::vector<TupleField> &get_fields () { return fields; }\n   const std::vector<TupleField> &get_fields () const { return fields; }\n \n+  void iterate (std::function<bool (TupleField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "8b99574aba13158fd493de6f615d06633c73e057", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -86,24 +86,7 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (s);\n   }\n \n-  void visit (HIR::CallExpr &expr)\n-  {\n-    Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n-    rust_assert (fn != nullptr);\n-\n-    std::vector<Bexpression *> args;\n-    expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-      Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-      rust_assert (compiled_expr != nullptr);\n-      args.push_back (compiled_expr);\n-      return true;\n-    });\n-\n-    auto fncontext = ctx->peek_fn ();\n-    translated\n-      = ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t      nullptr, expr.get_locus ());\n-  }\n+  void visit (HIR::CallExpr &expr);\n \n   void visit (HIR::IdentifierExpr &expr)\n   {"}, {"sha": "c8cffc7eb9991c4c76e64c7e686ab28c798d77a2", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -37,35 +37,32 @@ class CompileItem : public HIRCompileBase\n     item->accept_vis (compiler);\n   }\n \n-  virtual ~CompileItem () {}\n-\n-  void visit (HIR::StructStruct &struct_decl)\n+  void visit (HIR::TupleStruct &struct_decl)\n   {\n-    std::vector<Backend::Btyped_identifier> fields;\n-    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n-      TyTy::TyBase *resolved_type = nullptr;\n-      bool ok\n-\t= ctx->get_tyctx ()->lookup_type (field.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &resolved_type);\n-      rust_assert (ok);\n+    TyTy::TyBase *resolved = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n+      {\n+\trust_fatal_error (struct_decl.get_locus (),\n+\t\t\t  \"Failed to lookup type for struct decl\");\n+\treturn;\n+      }\n \n-      Btype *compiled_field_ty\n-\t= TyTyCompile::compile (ctx->get_backend (), resolved_type);\n+    TyTyResolveCompile::compile (ctx, resolved);\n+  }\n \n-      Backend::Btyped_identifier f (field.field_name, compiled_field_ty,\n-\t\t\t\t    field.get_locus ());\n-      fields.push_back (std::move (f));\n-      return true;\n-    });\n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    TyTy::TyBase *resolved = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n+      {\n+\trust_fatal_error (struct_decl.get_locus (),\n+\t\t\t  \"Failed to lookup type for struct decl\");\n+\treturn;\n+      }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n-      = ctx->get_backend ()->named_type (struct_decl.get_identifier (),\n-\t\t\t\t\t struct_type_record,\n-\t\t\t\t\t struct_decl.get_locus ());\n-    ctx->push_type (named_struct);\n-    ctx->insert_compiled_type (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t       named_struct);\n+    TyTyResolveCompile::compile (ctx, resolved);\n   }\n \n   void visit (HIR::StaticItem &var)"}, {"sha": "37285b7215da0319d04b2dad5e411ed30fdf347d", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -32,15 +32,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n   if (!ctx->get_resolver ()->lookup_resolved_name (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n-      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n       return;\n     }\n \n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n     {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n       return;\n     }\n \n@@ -54,14 +53,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \texpr.get_mappings ().get_crate_num (), ref);\n       if (resolved_item == nullptr)\n \t{\n-\t  rust_fatal_error (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");\n \t  return;\n \t}\n \n       CompileItem::compile (resolved_item, ctx);\n       if (!ctx->lookup_function_decl (ref, &fn))\n \t{\n-\t  rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n \t  return;\n \t}\n     }\n@@ -78,22 +77,21 @@ ResolvePathType::visit (HIR::PathInExpression &expr)\n   if (!ctx->get_resolver ()->lookup_resolved_type (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n-      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n       return;\n     }\n \n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n     {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n       return;\n     }\n \n   // assumes paths are functions for now\n   if (!ctx->lookup_compiled_types (ref, &resolved))\n     {\n-      rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+      rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n       return;\n     }\n }"}, {"sha": "2f3cb68e2a7c56b20d146a54c07666806db03b1a", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -32,7 +32,6 @@ class ResolvePathRef : public HIRCompileBase\n   {\n     ResolvePathRef resolver (ctx);\n     expr->accept_vis (resolver);\n-    rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n \n@@ -51,7 +50,6 @@ class ResolvePathType : public HIRCompileBase\n   {\n     ResolvePathType resolver (ctx);\n     expr->accept_vis (resolver);\n-    rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n "}, {"sha": "6519a47353e22262e88cb63e86a20e271db1b8bb", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -48,6 +48,53 @@ CompileCrate::go ()\n     CompileItem::compile (item.get (), ctx, true);\n }\n \n+// rust-compile-expr.h\n+\n+void\n+CompileExpr::visit (HIR::CallExpr &expr)\n+{\n+  // this can be a function call or it can be a constructor for a tuple struct\n+  Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n+  if (fn != nullptr)\n+    {\n+      std::vector<Bexpression *> args;\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+    }\n+  else\n+    {\n+      Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n+      if (type == nullptr)\n+\t{\n+\t  rust_fatal_error (expr.get_locus (),\n+\t\t\t    \"failed to lookup type associated with call\");\n+\t  return;\n+\t}\n+\n+      // this assumes all fields are in order from type resolution and if a base\n+      // struct was specified those fields are filed via accesors\n+      std::vector<Bexpression *> vals;\n+      expr.iterate_params ([&] (HIR::Expr *argument) mutable -> bool {\n+\tBexpression *e = CompileExpr::Compile (argument, ctx);\n+\tvals.push_back (e);\n+\treturn true;\n+      });\n+\n+      translated\n+\t= ctx->get_backend ()->constructor_expression (type, vals,\n+\t\t\t\t\t\t       expr.get_locus ());\n+    }\n+}\n+\n // rust-compile-block.h\n \n void"}, {"sha": "61223353a0386f18aede66745d08a78e73ba9f28", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -38,10 +38,67 @@ class ASTLoweringItem : public ASTLoweringBase\n   {\n     ASTLoweringItem resolver;\n     item->accept_vis (resolver);\n+\n+    // this is useful for debugging\n+    // if (resolver.translated == nullptr)\n+    //   {\n+    //     rust_fatal_error (item->get_locus_slow (), \"failed to lower: %s\",\n+    //     \t\t  item->as_string ().c_str ());\n+    //     return nullptr;\n+    //   }\n+\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringItem () {}\n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+    std::vector<HIR::Attribute> outer_attrs;\n+\n+    std::vector<HIR::TupleField> fields;\n+    struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n+      std::vector<HIR::Attribute> outer_attrs;\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      // FIXME\n+      // AST::TupleField is missing Location info\n+      Location field_locus;\n+      HIR::TupleField translated_field (mapping,\n+\t\t\t\t\tstd::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\tfield_locus, outer_attrs);\n+      fields.push_back (std::move (translated_field));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t       struct_decl.get_identifier (),\n+\t\t\t\t       std::move (generic_params),\n+\t\t\t\t       std::move (where_clause), vis,\n+\t\t\t\t       std::move (outer_attrs),\n+\t\t\t\t       struct_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       struct_decl.get_locus ());\n+  }\n \n   void visit (AST::StructStruct &struct_decl)\n   {\n@@ -51,7 +108,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n     std::vector<HIR::Attribute> outer_attrs;\n \n-    bool is_unit = false;\n+    bool is_unit = struct_decl.is_unit_struct ();\n     std::vector<HIR::StructField> fields;\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n       std::vector<HIR::Attribute> outer_attrs;"}, {"sha": "6a58ca0db196324d3a878d1735f4185f97cc7edf", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -1604,7 +1604,9 @@ struct TupleField\n \n   std::unique_ptr<Type> field_type;\n \n-  // should this store location info?\n+  Location locus;\n+\n+  Analysis::NodeMapping mappings;\n \n public:\n   // Returns whether tuple field has outer attributes.\n@@ -1615,16 +1617,18 @@ struct TupleField\n   bool has_visibility () const { return !visibility.is_error (); }\n \n   // Complete constructor\n-  TupleField (std::unique_ptr<Type> field_type, Visibility vis,\n+  TupleField (Analysis::NodeMapping mapping, std::unique_ptr<Type> field_type,\n+\t      Visibility vis, Location locus,\n \t      std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_type (std::move (field_type))\n+      field_type (std::move (field_type)), locus (locus), mappings (mapping)\n   {}\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_type (other.field_type->clone_type ())\n+      field_type (other.field_type->clone_type ()), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   ~TupleField () = default;\n@@ -1635,6 +1639,8 @@ struct TupleField\n     field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1646,13 +1652,13 @@ struct TupleField\n   // Returns whether tuple field is in an error state.\n   bool is_error () const { return field_type == nullptr; }\n \n-  // Creates an error state tuple field.\n-  static TupleField create_error ()\n-  {\n-    return TupleField (nullptr, Visibility::create_error ());\n-  }\n-\n   std::string as_string () const;\n+\n+  Analysis::NodeMapping get_mappings () { return mappings; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<HIR::Type> &get_field_type () { return field_type; }\n };\n \n // Rust tuple declared using struct keyword HIR node\n@@ -1677,6 +1683,18 @@ class TupleStruct : public Struct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<TupleField> &get_fields () { return fields; }\n+  const std::vector<TupleField> &get_fields () const { return fields; }\n+\n+  void iterate (std::function<bool (TupleField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "9a7e2319232b159d642c7d110c4ea6c194dfaf57", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -83,7 +83,6 @@ class ResolveExpr : public ResolverBase\n       ResolveExpr::go (p, expr.get_node_id ());\n       return true;\n     });\n-    // resolver->insert_resolved_name(NodeId refId,NodeId defId)\n   }\n \n   void visit (AST::AssignmentExpr &expr)"}, {"sha": "02d6dfa12cce4b0b56282a235870e208d24d8483", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -40,10 +40,20 @@ class ResolveItem : public ResolverBase\n \n   ~ResolveItem () {}\n \n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n   void visit (AST::StructStruct &struct_decl)\n   {\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n-      ResolveType::go (field.get_field_type ().get (), field.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n       return true;\n     });\n   }"}, {"sha": "47435a73421d65c27cb5c2b76c6556539d4a6b51", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -36,6 +36,13 @@ class ResolveTopLevel : public ResolverBase\n \n   ~ResolveTopLevel () {}\n \n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n+\t\t\t\t\tstruct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_locus ());\n+  }\n+\n   void visit (AST::StructStruct &struct_decl)\n   {\n     resolver->get_type_scope ().insert (struct_decl.get_identifier (),"}, {"sha": "5f2477e97ed22ed60bfd552ed16d62102a4663bb", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -77,7 +77,7 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n     identifier += \")\";\n     infered = new TyTy::ADTType (expr.get_mappings ().get_hirid (), identifier,\n-\t\t\t\t fields);\n+\t\t\t\t true, fields);\n   }\n \n   void visit (HIR::ReturnExpr &expr)\n@@ -94,22 +94,26 @@ class TypeCheckExpr : public TypeCheckBase\n     auto fn = expr.get_fnexpr ();\n     auto fn_node_id = fn->get_mappings ().get_nodeid ();\n \n-    // then lookup the reference_node_id\n+    // CallExpr might be a function but it might also be a TupleStruct\n     NodeId ref_node_id;\n     if (!resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n+\tif (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"Failed to lookup reference for node: %s\",\n+\t\t\t   expr.as_string ().c_str ());\n+\t    return;\n+\t  }\n       }\n \n     // node back to HIR\n     HirId ref;\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref_node_id, &ref))\n       {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure for node %u\",\n+\t\t       ref_node_id);\n \treturn;\n       }\n \n@@ -125,6 +129,11 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = TyTy::TypeCheckCallExpr::go (lookup, expr);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n+\treturn;\n+      }\n \n     TyTy::InferType infer (expr.get_mappings ().get_hirid ());\n     infered = infer.combine (infered);"}, {"sha": "55c0d38a7c53d1fde036aeb4bec9841db229d6af", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -37,6 +37,32 @@ class TypeCheckTopLevel : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::TupleStruct &struct_decl)\n+  {\n+    std::vector<TyTy::StructFieldType *> fields;\n+\n+    size_t idx = 0;\n+    struct_decl.iterate ([&] (HIR::TupleField &field) mutable -> bool {\n+      TyTy::TyBase *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings ().get_hirid (),\n+\t\t\t    ty_field->get_field_type ());\n+      idx++;\n+      return true;\n+    });\n+\n+    TyTy::TyBase *type\n+      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t   struct_decl.get_identifier (), true,\n+\t\t\t   std::move (fields));\n+\n+    context->insert_type (struct_decl.get_mappings ().get_hirid (), type);\n+  }\n+\n   void visit (HIR::StructStruct &struct_decl)\n   {\n     std::vector<TyTy::StructFieldType *> fields;\n@@ -54,7 +80,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::TyBase *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\t\t\t   struct_decl.get_identifier (), false,\n+\t\t\t   std::move (fields));\n \n     context->insert_type (struct_decl.get_mappings ().get_hirid (), type);\n   }"}, {"sha": "77dc9c092f20817d316f7d783538faef98cd8a1e", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -107,7 +107,7 @@ class TypeCheckType : public TypeCheckBase\n       }\n     identifier += \")\";\n     translated = new TyTy::ADTType (tuple.get_mappings ().get_hirid (),\n-\t\t\t\t    identifier, fields);\n+\t\t\t\t    identifier, true, fields);\n   }\n \n   void visit (HIR::TypePath &path)"}, {"sha": "06918c257f81b11ef6e988a9ff564a6d5314e529", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -41,7 +41,6 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n   void visit (StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (ADTType &type) override { gcc_unreachable (); }\n   void visit (ParamType &type) override { gcc_unreachable (); }\n   void visit (ArrayType &type) override { gcc_unreachable (); }\n   void visit (BoolType &type) override { gcc_unreachable (); }\n@@ -50,6 +49,10 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (FloatType &type) override { gcc_unreachable (); }\n   void visit (ErrorType &type) override { gcc_unreachable (); }\n \n+  // tuple-structs\n+  void visit (ADTType &type) override;\n+\n+  // call fns\n   void visit (FnType &type) override;\n \n private:"}, {"sha": "0d8d856fe062274081cb12dce95206be986685ab", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -438,8 +438,9 @@ class ADTRules : protected BaseRules\n \tfields.push_back ((TyTy::StructFieldType *) combined);\n       }\n \n-    resolved = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t  type.get_name (), fields);\n+    resolved\n+      = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t   type.get_name (), type.is_tuple_struct (), fields);\n   }\n \n private:"}, {"sha": "7ca60c8335dee6bf689c482be892d3f4425f6bee", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -157,7 +157,8 @@ ADTType::clone ()\n   for (auto &f : fields)\n     cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-  return new ADTType (get_ref (), get_ty_ref (), get_name (), cloned_fields);\n+  return new ADTType (get_ref (), get_ty_ref (), get_name (),\n+\t\t      is_tuple_struct (), cloned_fields);\n }\n \n void\n@@ -386,12 +387,63 @@ FloatType::clone ()\n   return new FloatType (get_ref (), get_ty_ref (), get_kind ());\n }\n \n+void\n+TypeCheckCallExpr::visit (ADTType &type)\n+{\n+  if (!type.is_tuple_struct ())\n+    {\n+      rust_error_at (call.get_locus (), \"Expected TupleStruct\");\n+      return;\n+    }\n+\n+  if (call.num_params () != type.num_fields ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_fields ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+    StructFieldType *field = type.get_field (i);\n+    TyBase *field_tyty = field->get_field_type ();\n+\n+    TyBase *arg = Resolver::TypeCheckExpr::Resolve (p);\n+    if (arg == nullptr)\n+      {\n+\trust_error_at (p->get_locus_slow (), \"failed to resolve argument type\");\n+\treturn false;\n+      }\n+\n+    auto res = field_tyty->combine (arg);\n+    if (res == nullptr)\n+      return false;\n+\n+    delete res;\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.clone ();\n+}\n+\n void\n TypeCheckCallExpr::visit (FnType &type)\n {\n   if (call.num_params () != type.num_params ())\n     {\n-      rust_error_at (call.get_locus (), \"differing number of arguments\");\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_params ());\n       return;\n     }\n \n@@ -409,12 +461,18 @@ TypeCheckCallExpr::visit (FnType &type)\n     if (res == nullptr)\n       return false;\n \n+    delete res;\n     i++;\n     return true;\n   });\n \n   if (i != call.num_params ())\n-    return;\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n \n   resolved = type.get_return_type ();\n }"}, {"sha": "b0ccf24cc2eccba260badcd03df0485f656cddbc", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -169,15 +169,16 @@ class StructFieldType : public TyBase\n class ADTType : public TyBase\n {\n public:\n-  ADTType (HirId ref, std::string identifier,\n+  ADTType (HirId ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields)\n-    : TyBase (ref, ref, TypeKind::ADT), identifier (identifier), fields (fields)\n+    : TyBase (ref, ref, TypeKind::ADT), identifier (identifier),\n+      is_tuple (is_tuple), fields (fields)\n   {}\n \n-  ADTType (HirId ref, HirId ty_ref, std::string identifier,\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields)\n     : TyBase (ref, ty_ref, TypeKind::ADT), identifier (identifier),\n-      fields (fields)\n+      is_tuple (is_tuple), fields (fields)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -192,6 +193,8 @@ class ADTType : public TyBase\n \n   std::string get_name () const { return identifier; }\n \n+  bool is_tuple_struct () const { return is_tuple; }\n+\n   StructFieldType *get_field (size_t index) { return fields.at (index); }\n \n   StructFieldType *get_field (const std::string &lookup,\n@@ -218,6 +221,7 @@ class ADTType : public TyBase\n \n private:\n   std::string identifier;\n+  bool is_tuple;\n   std::vector<StructFieldType *> fields;\n };\n "}, {"sha": "65e29f718d8de52534a967404e029be1251b47d9", "filename": "gcc/testsuite/rust.test/compilable/tuple_struct1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(i32, i32, bool);\n+\n+fn main() {\n+    let a = Foo(1, 2, true);\n+}"}, {"sha": "eae433aa4da3e16201ab253572d582863099b523", "filename": "gcc/testsuite/rust.test/fail_compilation/func2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,7 @@\n+fn test(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let a = test(1);\n+}"}, {"sha": "781caf7866e24714f1036c1dbc16873f985471f5", "filename": "gcc/testsuite/rust.test/fail_compilation/func3.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,7 @@\n+fn test(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let a = test(1, true);\n+}"}, {"sha": "0df07d9d94792b9a4e7906feb9e7bfd9939f49c1", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,8 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+fn main() {\n+    let a = Foo(1, 2);\n+}"}, {"sha": "6c3c0ab2e59b245d0f2ec33759ce232e1e7e19e4", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,5 @@\n+struct Bar(i32, i32, bool);\n+\n+fn main() {\n+    let a = Bar(1, 2);\n+}"}, {"sha": "832df8bd7bcad5f400eec9e93e52df3ece725d5d", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a942d6fbd0cc087cbc801ce4681a498e59dce2c/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs?ref=9a942d6fbd0cc087cbc801ce4681a498e59dce2c", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(i32, i32, bool);\n+\n+fn main() {\n+    let c = Foo(1, 2f32, true);\n+}"}]}