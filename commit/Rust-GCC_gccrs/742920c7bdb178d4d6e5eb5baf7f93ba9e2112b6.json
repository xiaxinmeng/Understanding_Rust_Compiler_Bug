{"sha": "742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyOTIwYzdiZGIxNzhkNGQ2ZTVlYjViYWY3ZjkzYmE5ZTIxMTJiNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-21T01:51:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-21T01:51:52Z"}, "message": "(get_inner_reference): Simplify code by initializing OFFSET to integer_zero_node.\n\n(get_inner_reference): Simplify code by initializing OFFSET to\ninteger_zero_node.\nDo general index computation for ARRAY_REF and include lower bound of domain\nin calculation.\n(expand_expr, case ARRAY_REF): Include lower-bound in index computation.\n\nFrom-SVN: r3808", "tree": {"sha": "717ec4b4509a3ac4a543139b83cec82f887b6d15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717ec4b4509a3ac4a543139b83cec82f887b6d15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6/comments", "author": null, "committer": null, "parents": [{"sha": "ca86a57ae73f553818ebadb894d422930648a6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca86a57ae73f553818ebadb894d422930648a6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca86a57ae73f553818ebadb894d422930648a6e1"}], "stats": {"total": 300, "additions": 165, "deletions": 135}, "files": [{"sha": "a3f5970ba6c7737413ca028b0651250f3a8fb383", "filename": "gcc/expr.c", "status": "modified", "additions": 165, "deletions": 135, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=742920c7bdb178d4d6e5eb5baf7f93ba9e2112b6", "patch": "@@ -3318,8 +3318,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \f\n /* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,\n    or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or\n-   ARRAY_REFs at constant positions and find the ultimate containing object,\n-   which we return.\n+   ARRAY_REFs and find the ultimate containing object, which we return.\n \n    We set *PBITSIZE to the size in bits that we want, *PBITPOS to the\n    bit position, and *PUNSIGNEDP to the signedness of the field.\n@@ -3352,7 +3351,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n-  tree offset = 0;\n+  tree offset = integer_zero_node;\n \n   if (TREE_CODE (exp) == COMPONENT_REF)\n     {\n@@ -3409,37 +3408,55 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t\t}\n \t      else\n \t\tabort ();\n+\n \t      *pbitpos += TREE_INT_CST_LOW (constant);\n-\t      if (offset)\n-\t\toffset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t     size_binop (FLOOR_DIV_EXPR, var,\n-\t\t\t\t\t\t size_int (BITS_PER_UNIT)));\n-\t      else\n-\t\toffset = size_binop (FLOOR_DIV_EXPR, var,\n-\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t      offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t   size_binop (FLOOR_DIV_EXPR, var,\n+\t\t\t\t\t       size_int (BITS_PER_UNIT)));\n \t    }\n \t  else if (TREE_CODE (pos) == INTEGER_CST)\n \t    *pbitpos += TREE_INT_CST_LOW (pos);\n \t  else\n \t    {\n \t      /* Assume here that the offset is a multiple of a unit.\n \t\t If not, there should be an explicitly added constant.  */\n-\t      if (offset)\n-\t\toffset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t     size_binop (FLOOR_DIV_EXPR, pos,\n-\t\t\t\t\t\t size_int (BITS_PER_UNIT)));\n-\t      else\n-\t\toffset = size_binop (FLOOR_DIV_EXPR, pos,\n-\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t      offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t   size_binop (FLOOR_DIV_EXPR, pos,\n+\t\t\t\t\t       size_int (BITS_PER_UNIT)));\n \t    }\n \t}\n \n-      else if (TREE_CODE (exp) == ARRAY_REF\n-\t       && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t       && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n+      else if (TREE_CODE (exp) == ARRAY_REF)\n \t{\n-\t  *pbitpos += (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n-\t\t       * TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))));\n+\t  /* This code is based on the code in case ARRAY_REF in expand_expr\n+\t     below.  We assume here that the size of an array element is\n+\t     always an integral multiple of BITS_PER_UNIT.  */\n+\n+\t  tree index = TREE_OPERAND (exp, 1);\n+\t  tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t  tree low_bound\n+\t    = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n+\t  tree index_type = TREE_TYPE (index);\n+\n+\t  if (! integer_zerop (low_bound))\n+\t    index = fold (build (MINUS_EXPR, index_type, index, low_bound));\n+\n+\t  if (TYPE_PRECISION (index_type) != POINTER_SIZE)\n+\t    {\n+\t      index = convert (type_for_size (POINTER_SIZE, 0), index);\n+\t      index_type = TREE_TYPE (index);\n+\t    }\n+\n+\t  index = fold (build (MULT_EXPR, index_type, index,\n+\t\t\t       TYPE_SIZE (TREE_TYPE (exp))));\n+\n+\t  if (TREE_CODE (index) == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (index) == 0)\n+\t    *pbitpos += TREE_INT_CST_LOW (index);\n+\t  else\n+\t    offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t size_binop (FLOOR_DIV_EXPR, index,\n+\t\t\t\t\t     size_int (BITS_PER_UNIT)));\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n@@ -3463,6 +3480,9 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \tmode = VOIDmode;\n     }\n \n+  if (integer_zerop (offset))\n+    offset = 0;\n+\n   *pmode = mode;\n   *poffset = offset;\n #if 0\n@@ -4236,136 +4256,146 @@ expand_expr (exp, target, tmode, modifier)\n       }\n \n     case ARRAY_REF:\n-      if (TREE_CODE (TREE_OPERAND (exp, 1)) != INTEGER_CST\n-\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t{\n-\t  /* Nonconstant array index or nonconstant element size.\n-\t     Generate the tree for *(&array+index) and expand that,\n-\t     except do it in a language-independent way\n-\t     and don't complain about non-lvalue arrays.\n-\t     `mark_addressable' should already have been called\n-\t     for any array for which this case will be reached.  */\n-\n-\t  /* Don't forget the const or volatile flag from the array element. */\n-\t  tree variant_type = build_type_variant (type,\n-\t\t\t\t\t\t  TREE_READONLY (exp),\n-\t\t\t\t\t\t  TREE_THIS_VOLATILE (exp));\n-\t  tree array_adr = build1 (ADDR_EXPR, build_pointer_type (variant_type),\n-\t\t\t\t   TREE_OPERAND (exp, 0));\n-\t  tree index = TREE_OPERAND (exp, 1);\n-\t  tree elt;\n-\n-\t  /* Convert the integer argument to a type the same size as a pointer\n-\t     so the multiply won't overflow spuriously.  */\n-\t  if (TYPE_PRECISION (TREE_TYPE (index)) != POINTER_SIZE)\n-\t    index = convert (type_for_size (POINTER_SIZE, 0), index);\n-\n-\t  /* Don't think the address has side effects\n-\t     just because the array does.\n-\t     (In some cases the address might have side effects,\n-\t     and we fail to record that fact here.  However, it should not\n-\t     matter, since expand_expr should not care.)  */\n-\t  TREE_SIDE_EFFECTS (array_adr) = 0;\n-\n-\t  elt = build1 (INDIRECT_REF, type,\n-\t\t\tfold (build (PLUS_EXPR, TYPE_POINTER_TO (variant_type),\n-\t\t\t\t     array_adr,\n-\t\t\t\t     fold (build (MULT_EXPR,\n-\t\t\t\t\t\t  TYPE_POINTER_TO (variant_type),\n-\t\t\t\t\t\t  index, size_in_bytes (type))))));\n-\n-\t  /* Volatility, etc., of new expression is same as old expression.  */\n-\t  TREE_SIDE_EFFECTS (elt) = TREE_SIDE_EFFECTS (exp);\n-\t  TREE_THIS_VOLATILE (elt) = TREE_THIS_VOLATILE (exp);\n-\t  TREE_READONLY (elt) = TREE_READONLY (exp);\n-\n-\t  return expand_expr (elt, target, tmode, modifier);\n-\t}\n+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != ARRAY_TYPE)\n+\tabort ();\n \n-      /* Fold an expression like: \"foo\"[2].\n-\t This is not done in fold so it won't happen inside &.  */\n       {\n+\ttree array = TREE_OPERAND (exp, 0);\n+\ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n+\ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n+\ttree index = TREE_OPERAND (exp, 1);\n+\ttree index_type = TREE_TYPE (index);\n \tint i;\n-\ttree arg0 = TREE_OPERAND (exp, 0);\n-\ttree arg1 = TREE_OPERAND (exp, 1);\n \n-\tif (TREE_CODE (arg0) == STRING_CST\n-\t    && TREE_CODE (arg1) == INTEGER_CST\n-\t    && !TREE_INT_CST_HIGH (arg1)\n-\t    && (i = TREE_INT_CST_LOW (arg1)) < TREE_STRING_LENGTH (arg0))\n+\t/* Optimize the special-case of a zero lower bound.  */\n+\tif (! integer_zerop (low_bound))\n+\t  index = fold (build (MINUS_EXPR, index_type, index, low_bound));\n+\n+\tif (TREE_CODE (index) != INTEGER_CST\n+\t    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t  {\n+\t    /* Nonconstant array index or nonconstant element size.\n+\t       Generate the tree for *(&array+index) and expand that,\n+\t       except do it in a language-independent way\n+\t       and don't complain about non-lvalue arrays.\n+\t       `mark_addressable' should already have been called\n+\t       for any array for which this case will be reached.  */\n+\n+\t    /* Don't forget the const or volatile flag from the array\n+\t       element. */\n+\t    tree variant_type = build_type_variant (type,\n+\t\t\t\t\t\t    TREE_READONLY (exp),\n+\t\t\t\t\t\t    TREE_THIS_VOLATILE (exp));\n+\t    tree array_adr = build1 (ADDR_EXPR,\n+\t\t\t\t     build_pointer_type (variant_type), array);\n+\t    tree elt;\n+\n+\t    /* Convert the integer argument to a type the same size as a\n+\t       pointer so the multiply won't overflow spuriously.  */\n+\t    if (TYPE_PRECISION (index_type) != POINTER_SIZE)\n+\t      index = convert (type_for_size (POINTER_SIZE, 0), index);\n+\n+\t    /* Don't think the address has side effects\n+\t       just because the array does.\n+\t       (In some cases the address might have side effects,\n+\t       and we fail to record that fact here.  However, it should not\n+\t       matter, since expand_expr should not care.)  */\n+\t    TREE_SIDE_EFFECTS (array_adr) = 0;\n+\n+\t    elt = build1 (INDIRECT_REF, type,\n+\t\t\t  fold (build (PLUS_EXPR,\n+\t\t\t\t       TYPE_POINTER_TO (variant_type),\n+\t\t\t\t       array_adr,\n+\t\t\t\t       fold (build (MULT_EXPR,\n+\t\t\t\t\t\t    TYPE_POINTER_TO (variant_type),\n+\t\t\t\t\t\t    index,\n+\t\t\t\t\t\t    size_in_bytes (type))))));\n+\n+\t    /* Volatility, etc., of new expression is same as old\n+\t       expression.  */\n+\t    TREE_SIDE_EFFECTS (elt) = TREE_SIDE_EFFECTS (exp);\n+\t    TREE_THIS_VOLATILE (elt) = TREE_THIS_VOLATILE (exp);\n+\t    TREE_READONLY (elt) = TREE_READONLY (exp);\n+\n+\t    return expand_expr (elt, target, tmode, modifier);\n+\t  }\n+\n+\t/* Fold an expression like: \"foo\"[2].\n+\t   This is not done in fold so it won't happen inside &.  */\n+\n+\tif (TREE_CODE (array) == STRING_CST\n+\t    && TREE_CODE (index) == INTEGER_CST\n+\t    && !TREE_INT_CST_HIGH (index)\n+\t    && (i = TREE_INT_CST_LOW (index)) < TREE_STRING_LENGTH (array))\n \t  {\n-\t    if (TREE_TYPE (TREE_TYPE (arg0)) == integer_type_node)\n+\t    if (TREE_TYPE (TREE_TYPE (array)) == integer_type_node)\n \t      {\n-\t\texp = build_int_2 (((int *)TREE_STRING_POINTER (arg0))[i], 0);\n+\t\texp = build_int_2 (((int *)TREE_STRING_POINTER (array))[i], 0);\n \t\tTREE_TYPE (exp) = integer_type_node;\n \t\treturn expand_expr (exp, target, tmode, modifier);\n \t      }\n-\t    if (TREE_TYPE (TREE_TYPE (arg0)) == char_type_node)\n+\t    if (TREE_TYPE (TREE_TYPE (array)) == char_type_node)\n \t      {\n-\t\texp = build_int_2 (TREE_STRING_POINTER (arg0)[i], 0);\n+\t\texp = build_int_2 (TREE_STRING_POINTER (array)[i], 0);\n \t\tTREE_TYPE (exp) = integer_type_node;\n-\t\treturn expand_expr (convert (TREE_TYPE (TREE_TYPE (arg0)), exp), target, tmode, modifier);\n+\t\treturn expand_expr (convert (TREE_TYPE (TREE_TYPE (array)),\n+\t\t\t\t\t     exp),\n+\t\t\t\t    target, tmode, modifier);\n \t      }\n \t  }\n-      }\n \n-      /* If this is a constant index into a constant array,\n-\t just get the value from the array.  Handle both the cases when\n-\t we have an explicit constructor and when our operand is a variable\n-\t that was declared const.  */\n+\t/* If this is a constant index into a constant array,\n+\t   just get the value from the array.  Handle both the cases when\n+\t   we have an explicit constructor and when our operand is a variable\n+\t   that was declared const.  */\n \n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n-\t  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0)))\n-\t{\n-\t  tree index = fold (TREE_OPERAND (exp, 1));\n-\t  if (TREE_CODE (index) == INTEGER_CST\n-\t      && TREE_INT_CST_HIGH (index) == 0)\n-\t    {\n-\t      int i = TREE_INT_CST_LOW (index);\n-\t      tree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n-\n-\t      while (elem && i--)\n-\t\telem = TREE_CHAIN (elem);\n-\t      if (elem)\n-\t\treturn expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t    tmode, modifier);\n-\t    }\n-\t}\n+\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array))\n+\t  {\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& TREE_INT_CST_HIGH (index) == 0)\n+\t      {\n+\t\ttree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n+\n+\t\ti = TREE_INT_CST_LOW (index);\n+\t\twhile (elem && i--)\n+\t\t  elem = TREE_CHAIN (elem);\n+\t\tif (elem)\n+\t\t  return expand_expr (fold (TREE_VALUE (elem)), target,\n+\t\t\t\t      tmode, modifier);\n+\t      }\n+\t  }\n \t  \n-      else if (TREE_READONLY (TREE_OPERAND (exp, 0))\n-\t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n-\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == ARRAY_TYPE\n-\t       && TREE_CODE (TREE_OPERAND (exp, 0)) == VAR_DECL\n-\t       && DECL_INITIAL (TREE_OPERAND (exp, 0))\n-\t       && optimize >= 1\n-\t       && (TREE_CODE (DECL_INITIAL (TREE_OPERAND (exp, 0)))\n-\t\t   != ERROR_MARK))\n-\t{\n-\t  tree index = fold (TREE_OPERAND (exp, 1));\n-\t  if (TREE_CODE (index) == INTEGER_CST\n-\t      && TREE_INT_CST_HIGH (index) == 0)\n-\t    {\n-\t      int i = TREE_INT_CST_LOW (index);\n-\t      tree init = DECL_INITIAL (TREE_OPERAND (exp, 0));\n-\n-\t      if (TREE_CODE (init) == CONSTRUCTOR)\n-\t\t{\n-\t\t  tree elem = CONSTRUCTOR_ELTS (init);\n+\telse if (optimize >= 1\n+\t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n+\t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n+\t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK)\n+\t  {\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& TREE_INT_CST_HIGH (index) == 0)\n+\t      {\n+\t\ttree init = DECL_INITIAL (array);\n+\n+\t\ti = TREE_INT_CST_LOW (index);\n+\t\tif (TREE_CODE (init) == CONSTRUCTOR)\n+\t\t  {\n+\t\t    tree elem = CONSTRUCTOR_ELTS (init);\n+\n+\t\t    while (elem && i--)\n+\t\t      elem = TREE_CHAIN (elem);\n+\t\t    if (elem)\n+\t\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n+\t\t\t\t\t  tmode, modifier);\n+\t\t  }\n+\t\telse if (TREE_CODE (init) == STRING_CST\n+\t\t\t && i < TREE_STRING_LENGTH (init))\n+\t\t  {\n+\t\t    temp = GEN_INT (TREE_STRING_POINTER (init)[i]);\n+\t\t    return convert_to_mode (mode, temp, 0);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n \n-\t\t  while (elem && i--)\n-\t\t    elem = TREE_CHAIN (elem);\n-\t\t  if (elem)\n-\t\t    return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t\ttmode, modifier);\n-\t\t}\n-\t      else if (TREE_CODE (init) == STRING_CST\n-\t\t       && i < TREE_STRING_LENGTH (init))\n-\t\t{\n-\t\t  temp = GEN_INT (TREE_STRING_POINTER (init)[i]);\n-\t\t  return convert_to_mode (mode, temp, 0);\n-\t\t}\n-\t    }\n-\t}\n       /* Treat array-ref with constant index as a component-ref.  */\n \n     case COMPONENT_REF:"}]}