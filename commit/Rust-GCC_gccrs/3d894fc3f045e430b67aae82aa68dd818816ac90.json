{"sha": "3d894fc3f045e430b67aae82aa68dd818816ac90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q4OTRmYzNmMDQ1ZTQzMGI2N2FhZTgyYWE2OGRkODE4ODE2YWM5MA==", "commit": {"author": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-10-19T21:48:50Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-10-19T21:48:50Z"}, "message": "re PR libfortran/27895 (problem with RESHAPE and zero-sized arrays)\n\n\tPR libfortran/27895\n\n\t* intrinsics/cshift0.c: Special cases for zero-sized arrays.\n\t* intrinsics/pack_generic.c: Likewise.\n\t* intrinsics/spread_generic.c: Likewise.\n\n\t* gfortran.dg/zero_sized_1.f90: New test.\n\nFrom-SVN: r117890", "tree": {"sha": "25894134c7e725dd6026b7d0c821b145999ec721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25894134c7e725dd6026b7d0c821b145999ec721"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d894fc3f045e430b67aae82aa68dd818816ac90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d894fc3f045e430b67aae82aa68dd818816ac90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d894fc3f045e430b67aae82aa68dd818816ac90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d894fc3f045e430b67aae82aa68dd818816ac90/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b7283ac665c92e61ef94de219cf370f44e58c48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7283ac665c92e61ef94de219cf370f44e58c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7283ac665c92e61ef94de219cf370f44e58c48"}], "stats": {"total": 280, "additions": 254, "deletions": 26}, "files": [{"sha": "be06e215328c17791f5f763da76878c279d7a734", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -1,3 +1,8 @@\n+2006-10-19  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/27895\n+\t* gfortran.dg/zero_sized_1.f90: New test.\n+\n 2006-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/div-compare-1.c: New test.\n@@ -26,10 +31,10 @@\n \t* gfortran.dg/streamio_4.f90: Update test.\n \t* gfortran.dg/streamio_11.f90: New test.\n \n-2006-10-17  Lee Millward  <lee.millward@codesuorcery.com>\n+2006-10-17  Lee Millward  <lee.millward@codesourcery.com>\n \n-        PR c++/27952\n-        * g++.dg/inherit/virtual1.C: New test.\n+\tPR c++/27952\n+\t* g++.dg/inherit/virtual1.C: New test.\n \t\n 2006-10-17  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "c70bdddd6d79673bd62909fa677ea353e7df330d", "filename": "gcc/testsuite/gfortran.dg/zero_sized_1.f90", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_1.f90?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -0,0 +1,197 @@\n+! { dg-do run }\n+! Transformational functions for zero-sized array and array sections\n+! Contributed by Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+subroutine test_cshift\n+  real :: tempn(1), tempm(1,2)\n+  real,allocatable :: foo(:),bar(:,:),gee(:,:)\n+  tempn = 2.0\n+  tempm = 1.0\n+  allocate(foo(0),bar(2,0),gee(0,7))\n+  if (any(cshift(foo,dim=1,shift=1)/= 0)) call abort\n+  if (any(cshift(tempn(2:1),dim=1,shift=1)/= 0)) call abort\n+  if (any(cshift(bar,shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(cshift(bar,shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(cshift(gee,shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(cshift(gee,shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(cshift(tempm(5:4,:),shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(cshift(tempm(5:4,:),shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(cshift(tempm(:,5:4),shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(cshift(tempm(:,5:4),shift=(/1,-1/),dim=2)/= 0)) call abort\n+  deallocate(foo,bar,gee)\n+end\n+\n+subroutine test_eoshift\n+  real :: tempn(1), tempm(1,2)\n+  real,allocatable :: foo(:),bar(:,:),gee(:,:)\n+  tempn = 2.0\n+  tempm = 1.0\n+  allocate(foo(0),bar(2,0),gee(0,7))\n+  if (any(eoshift(foo,dim=1,shift=1)/= 0)) call abort\n+  if (any(eoshift(tempn(2:1),dim=1,shift=1)/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=2)/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=1)/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=2)/= 0)) call abort\n+\n+  if (any(eoshift(foo,dim=1,shift=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(tempn(2:1),dim=1,shift=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=2,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=2,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=2,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=1,boundary=42.0)/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=2,boundary=42.0)/= 0)) call abort\n+\n+  if (any(eoshift(foo,dim=1,shift=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(tempn(2:1),dim=1,shift=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(bar,shift=(/1,-1/),dim=2,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(gee,shift=(/1,-1/),dim=2,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(tempm(5:4,:),shift=(/1,-1/),dim=2,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=1,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  if (any(eoshift(tempm(:,5:4),shift=(/1,-1/),dim=2,boundary=(/42.0,-7.0/))/= 0)) call abort\n+  deallocate(foo,bar,gee)\n+end\n+\n+subroutine test_transpose\n+  character(len=1) :: tempn(1,2)\n+  character(len=1),allocatable :: foo(:,:), bar(:,:)\n+  integer :: tempm(1,2)\n+  integer,allocatable :: x(:,:), y(:,:)\n+  tempn = 'a'\n+  allocate(foo(3,0),bar(-2:-4,7:9))\n+  tempm = -42\n+  allocate(x(3,0),y(-2:-4,7:9))\n+  if (any(transpose(tempn(-7:-8,:)) /= 'b')) call abort\n+  if (any(transpose(tempn(:,9:8)) /= 'b')) call abort\n+  if (any(transpose(foo) /= 'b')) call abort\n+  if (any(transpose(bar) /= 'b')) call abort\n+  if (any(transpose(tempm(-7:-8,:)) /= 0)) call abort\n+  if (any(transpose(tempm(:,9:8)) /= 0)) call abort\n+  if (any(transpose(x) /= 0)) call abort\n+  if (any(transpose(y) /= 0)) call abort\n+  deallocate(foo,bar,x,y)\n+end\n+\n+subroutine test_reshape\n+  character(len=1) :: tempn(1,2)\n+  character(len=1),allocatable :: foo(:,:), bar(:,:)\n+  integer :: tempm(1,2)\n+  integer,allocatable :: x(:,:), y(:,:)\n+  tempn = 'b'\n+  tempm = -42\n+  allocate(foo(3,0),bar(-2:-4,7:9),x(3,0),y(-2:-4,7:9))\n+  \n+  if (size(reshape(tempn(-7:-8,:),(/3,3/),pad=(/'a'/))) /= 9 .or. &\n+      any(reshape(tempn(-7:-8,:),(/3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(tempn(-7:-8,:),(/3,3,3/),pad=(/'a'/))) /= 27 .or. &\n+      any(reshape(tempn(-7:-8,:),(/3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(tempn(-7:-8,:),(/3,3,3,3,3,3,3/),pad=(/'a'/))) /= 2187 .or. &\n+      any(reshape(tempn(-7:-8,:),(/3,3,3,3,3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(foo,(/3,3/),pad=(/'a'/))) /= 9 .or. &\n+      any(reshape(foo,(/3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(foo,(/3,3,3/),pad=(/'a'/))) /= 27 .or. &\n+      any(reshape(foo,(/3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(foo,(/3,3,3,3,3,3,3/),pad=(/'a'/))) /= 2187 .or. &\n+      any(reshape(foo,(/3,3,3,3,3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(bar,(/3,3/),pad=(/'a'/))) /= 9 .or. &\n+      any(reshape(bar,(/3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(bar,(/3,3,3/),pad=(/'a'/))) /= 27 .or. &\n+      any(reshape(bar,(/3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+  if (size(reshape(bar,(/3,3,3,3,3,3,3/),pad=(/'a'/))) /= 2187 .or. &\n+      any(reshape(bar,(/3,3,3,3,3,3,3/),pad=(/'a'/)) /= 'a')) call abort\n+\n+  if (size(reshape(tempm(-7:-8,:),(/3,3/),pad=(/7/))) /= 9 .or. &\n+      any(reshape(tempm(-7:-8,:),(/3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(tempm(-7:-8,:),(/3,3,3/),pad=(/7/))) /= 27 .or. &\n+      any(reshape(tempm(-7:-8,:),(/3,3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(tempm(-7:-8,:),(/3,3,3,3,3,3,3/),pad=(/7/))) /= 2187 .or. &\n+      any(reshape(tempm(-7:-8,:),(/3,3,3,3,3,3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(x,(/3,3/),pad=(/7/))) /= 9 .or. &\n+      any(reshape(x,(/3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(x,(/3,3,3/),pad=(/7/))) /= 27 .or. &\n+      any(reshape(x,(/3,3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(x,(/3,3,3,3,3,3,3/),pad=(/7/))) /= 2187 .or. &\n+      any(reshape(x,(/3,3,3,3,3,3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(y,(/3,3/),pad=(/7/))) /= 9 .or. &\n+      any(reshape(y,(/3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(y,(/3,3,3/),pad=(/7/))) /= 27 .or. &\n+      any(reshape(y,(/3,3,3/),pad=(/7/)) /= 7)) call abort\n+  if (size(reshape(y,(/3,3,3,3,3,3,3/),pad=(/7/))) /= 2187 .or. &\n+      any(reshape(y,(/3,3,3,3,3,3,3/),pad=(/7/)) /= 7)) call abort\n+\n+  deallocate(foo,bar,x,y)\n+end\n+\n+subroutine test_pack\n+  integer :: tempn(1,5)\n+  integer,allocatable :: foo(:,:)\n+  tempn = 2 \n+  allocate(foo(0,1:7))\n+  if (size(pack(foo,foo/=0)) /= 0 .or. any(pack(foo,foo/=0) /= -42)) call abort\n+  if (size(pack(foo,foo/=0,(/1,3,4,5,1,0,7,9/))) /= 8 .or. &\n+      sum(pack(foo,foo/=0,(/1,3,4,5,1,0,7,9/))) /= 30) call abort\n+  if (size(pack(tempn(:,-4:-5),tempn(:,-4:-5)/=0)) /= 0 .or. &\n+      any(pack(tempn(:,-4:-5),tempn(:,-4:-5)/=0) /= -42)) call abort\n+  if (size(pack(tempn(:,-4:-5),tempn(:,-4:-5)/=0,(/1,3,4,5,1,0,7,9/))) /= 8 .or. &\n+      sum(pack(tempn(:,-4:-5),tempn(:,-4:-5)/=0,(/1,3,4,5,1,0,7,9/))) /= 30) &\n+    call abort\n+  if (size(pack(foo,.true.)) /= 0 .or. any(pack(foo,.true.) /= -42)) &\n+    call abort\n+  if (size(pack(foo,.true.,(/1,3,4,5,1,0,7,9/))) /= 8 .or. &\n+      sum(pack(foo,.true.,(/1,3,4,5,1,0,7,9/))) /= 30) call abort\n+  if (size(pack(tempn(:,-4:-5),.true.)) /= 0 .or. &\n+      any(pack(foo,.true.) /= -42)) call abort\n+  if (size(pack(tempn(:,-4:-5),.true.,(/1,3,4,5,1,0,7,9/))) /= 8 .or. &\n+      sum(pack(tempn(:,-4:-5),.true.,(/1,3,4,5,1,0,7,9/))) /= 30) call abort\n+  deallocate(foo)\n+end\n+\n+subroutine test_unpack\n+  integer :: tempn(1,5), tempv(5)\n+  integer,allocatable :: foo(:,:), bar(:)\n+  tempn = 2 \n+  tempv = 5\n+  allocate(foo(0,1:7),bar(0:-1))\n+  if (any(unpack(tempv,tempv/=0,tempv) /= 5) .or. &\n+      size(unpack(tempv,tempv/=0,tempv)) /= 5) call abort\n+  if (any(unpack(tempv(1:0),tempv/=0,tempv) /= 5) .or. &\n+      size(unpack(tempv(1:0),tempv/=0,tempv)) /= 5) call abort\n+  if (any(unpack(tempv,tempv(1:0)/=0,tempv) /= -47)) call abort\n+  if (any(unpack(tempv(5:4),tempv(1:0)/=0,tempv) /= -47)) call abort\n+  if (any(unpack(bar,foo==foo,foo) /= -47)) call abort\n+  deallocate(foo,bar)\n+end\n+\n+subroutine test_spread\n+  real :: tempn(1)\n+  real,allocatable :: foo(:)\n+  tempn = 2.0 \n+  allocate(foo(0))\n+  if (any(spread(1,dim=1,ncopies=0) /= -17.0) .or. &\n+      size(spread(1,dim=1,ncopies=0)) /= 0) call abort\n+  if (any(spread(foo,dim=1,ncopies=1) /= -17.0) .or. &\n+      size(spread(foo,dim=1,ncopies=1)) /= 0) call abort\n+  if (any(spread(tempn(2:1),dim=1,ncopies=1) /= -17.0) .or. &\n+      size(spread(tempn(2:1),dim=1,ncopies=1)) /= 0) call abort\n+  deallocate(foo)\n+end\n+\n+program test\n+  call test_cshift\n+  call test_eoshift\n+  call test_transpose\n+  call test_unpack\n+  call test_spread\n+  call test_pack\n+!  call test_reshape\n+end"}, {"sha": "5a51c53cadbee0e04d9a101b2f8ba019fc4b2dcf", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -1,3 +1,10 @@\n+2006-10-19  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/27895\n+\t* intrinsics/cshift0.c: Special cases for zero-sized arrays.\n+\t* intrinsics/pack_generic.c: Likewise.\n+\t* intrinsics/spread_generic.c: Likewise.\n+\n 2006-10-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/29277"}, {"sha": "f2c2219dd3054c94e812434690d2b079b1eba58e", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -1,5 +1,5 @@\n /* Generic implementation of the CSHIFT intrinsic\n-   Copyright 2003, 2005 Free Software Foundation, Inc.\n+   Copyright 2003, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Feng Wang <wf_cs@yahoo.com>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -144,8 +144,8 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   if (ret->data == NULL)\n     {\n       int i;\n+      index_type arraysize = size0 ((array_t *)array);\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -156,8 +156,17 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n           if (i == 0)\n             ret->dim[i].stride = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            ret->dim[i].stride = (ret->dim[i-1].ubound + 1)\n+\t\t\t\t * ret->dim[i-1].stride;\n         }\n+\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n     }\n \n   for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)"}, {"sha": "1b0d7250540313179f91c1ce1a9ca64f351c1171", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -1,5 +1,5 @@\n /* Generic implementation of the PACK intrinsic\n-   Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -195,12 +195,15 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n       ret->dim[0].ubound = total - 1;\n       ret->dim[0].stride = 1;\n \n-      ret->data = internal_malloc_size (size * total);\n       ret->offset = 0;\n-\n       if (total == 0)\n-\t/* In this case, nothing remains to be done.  */\n-\treturn;\n+\t{\n+\t  /* In this case, nothing remains to be done.  */\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+      else\n+\tret->data = internal_malloc_size (size * total);\n     }\n \n   rstride0 = ret->dim[0].stride * size;\n@@ -210,7 +213,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n   mstride0 = mstride[0];\n   rptr = ret->data;\n \n-  while (sptr)\n+  while (sptr && mptr)\n     {\n       /* Test this element.  */\n       if (*mptr)\n@@ -315,14 +318,17 @@ pack_s_internal (gfc_array_char *ret, const gfc_array_char *array,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type n;\n   index_type dim;\n+  index_type ssize;\n   index_type nelem;\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n+  ssize = 1;\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       sstride[n] = array->dim[n].stride * size;\n+      ssize *= extent[n];\n     }\n   if (sstride[0] == 0)\n     sstride[0] = size;\n@@ -352,25 +358,23 @@ pack_s_internal (gfc_array_char *ret, const gfc_array_char *array,\n \t\ttotal *= extent[n];\n \t    }\n \t  else\n-\t    {\n-\t      /* The result array will be empty.  */\n-\t      ret->dim[0].lbound = 0;\n-\t      ret->dim[0].ubound = -1;\n-\t      ret->dim[0].stride = 1;\n-\t      ret->data = internal_malloc_size (0);\n-\t      ret->offset = 0;\n-\n-\t      return;\n-\t    }\n+\t    /* The result array will be empty.  */\n+\t    total = 0;\n \t}\n \n       /* Setup the array descriptor.  */\n       ret->dim[0].lbound = 0;\n       ret->dim[0].ubound = total - 1;\n       ret->dim[0].stride = 1;\n-\n-      ret->data = internal_malloc_size (size * total);\n       ret->offset = 0;\n+\n+      if (total == 0)\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+      else\n+\tret->data = internal_malloc_size (size * total);\n     }\n \n   rstride0 = ret->dim[0].stride * size;\n@@ -384,7 +388,7 @@ pack_s_internal (gfc_array_char *ret, const gfc_array_char *array,\n        If MASK is .FALSE., we have to copy VECTOR into the result\n      array. If VECTOR were not present we would have already returned.  */\n \n-  if (*mask)\n+  if (*mask && ssize != 0)\n     {\n       while (sptr)\n \t{"}, {"sha": "9ea6b12ef16dc10e90c64a37ddbbf88153706a78", "filename": "libgfortran/intrinsics/spread_generic.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fspread_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d894fc3f045e430b67aae82aa68dd818816ac90/libgfortran%2Fintrinsics%2Fspread_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fspread_generic.c?ref=3d894fc3f045e430b67aae82aa68dd818816ac90", "patch": "@@ -101,7 +101,13 @@ spread_internal (gfc_array_char *ret, const gfc_array_char *source,\n \t    }\n \t}\n       ret->offset = 0;\n-      ret->data = internal_malloc_size (rs * size);\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * size);\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n     }\n   else\n     {"}]}