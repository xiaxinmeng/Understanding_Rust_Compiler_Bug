{"sha": "f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQxNGYyZjM1ZTRjYjJmMThmMmRhOGYyODc3N2FkNzk3Y2Y3YjBmYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-08-28T21:15:19Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-08-28T21:15:19Z"}, "message": "re PR tree-optimization/28411 (\"Illegal instruction\" error with -ftrapv)\n\n\tPR tree-optimization/28411\n\t* double-int.c (double_int_div): Use double_int_divmod.\n\t(double_int_divmod, double_int_sdivmod, double_int_udivmod,\n\tdouble_int_mod, double_int_smod, double_int_umod): New functions.\n\t* double-int.h (double_int_divmod, double_int_sdivmod,\n\tdouble_int_udivmod, double_int_mod, double_int_smod, double_int_umod):\n\tDeclare.\n\t* tree-ssa-loop-ivopts.c (constant_multiple_of): Returns the result\n\tin double_int.\n\t(get_computation_aff, get_computation_cost_at): Handle double_int\n\treturn type of constant_multiple_of.\n\nFrom-SVN: r116529", "tree": {"sha": "30bc9b33718fe7a8c347a8df8410345bef4030ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30bc9b33718fe7a8c347a8df8410345bef4030ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/comments", "author": null, "committer": null, "parents": [{"sha": "689e7ddada015f50d4e535902f3079add578bbcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689e7ddada015f50d4e535902f3079add578bbcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/689e7ddada015f50d4e535902f3079add578bbcc"}], "stats": {"total": 206, "additions": 129, "deletions": 77}, "files": [{"sha": "b333fe2b1f41e91dd97af0aaa0748bb2367ac656", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "patch": "@@ -1,3 +1,17 @@\n+2006-08-28  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/28411\n+\t* double-int.c (double_int_div): Use double_int_divmod.\n+\t(double_int_divmod, double_int_sdivmod, double_int_udivmod,\n+\tdouble_int_mod, double_int_smod, double_int_umod): New functions.\n+\t* double-int.h (double_int_divmod, double_int_sdivmod,\n+\tdouble_int_udivmod, double_int_mod, double_int_smod, double_int_umod):\n+\tDeclare.\n+\t* tree-ssa-loop-ivopts.c (constant_multiple_of): Returns the result\n+\tin double_int.\n+\t(get_computation_aff, get_computation_cost_at): Handle double_int\n+\treturn type of constant_multiple_of.\n+\n 2006-08-28  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR middle-end/26632"}, {"sha": "3be0abf4f3a03b811b82a1f48be1e19b2b670843", "filename": "gcc/double-int.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "patch": "@@ -203,20 +203,48 @@ double_int_neg (double_int a)\n \n /* Returns A / B (computed as unsigned depending on UNS, and rounded as\n    specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n-   must be included before tree.h.  */\n+   must be included before tree.h.  The remainder after the division is\n+   stored to MOD.  */\n \n double_int\n-double_int_div (double_int a, double_int b, bool uns, unsigned code)\n+double_int_divmod (double_int a, double_int b, bool uns, unsigned code,\n+\t\t   double_int *mod)\n {\n-  unsigned HOST_WIDE_INT rem_lo;\n-  HOST_WIDE_INT rem_hi;\n   double_int ret;\n \n   div_and_round_double (code, uns, a.low, a.high, b.low, b.high,\n-\t\t\t&ret.low, &ret.high, &rem_lo, &rem_hi);\n+\t\t\t&ret.low, &ret.high, &mod->low, &mod->high);\n   return ret;\n }\n \n+/* The same as double_int_divmod with UNS = false.  */\n+\n+double_int\n+double_int_sdivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+{\n+  return double_int_divmod (a, b, false, code, mod);\n+}\n+\n+/* The same as double_int_divmod with UNS = true.  */\n+\n+double_int\n+double_int_udivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+{\n+  return double_int_divmod (a, b, true, code, mod);\n+}\n+\n+/* Returns A / B (computed as unsigned depending on UNS, and rounded as\n+   specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n+   must be included before tree.h.  */\n+\n+double_int\n+double_int_div (double_int a, double_int b, bool uns, unsigned code)\n+{\n+  double_int mod;\n+\n+  return double_int_divmod (a, b, uns, code, &mod);\n+}\n+\n /* The same as double_int_div with UNS = false.  */\n \n double_int\n@@ -233,6 +261,35 @@ double_int_udiv (double_int a, double_int b, unsigned code)\n   return double_int_div (a, b, true, code);\n }\n \n+/* Returns A % B (computed as unsigned depending on UNS, and rounded as\n+   specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n+   must be included before tree.h.  */\n+\n+double_int\n+double_int_mod (double_int a, double_int b, bool uns, unsigned code)\n+{\n+  double_int mod;\n+\n+  double_int_divmod (a, b, uns, code, &mod);\n+  return mod;\n+}\n+\n+/* The same as double_int_mod with UNS = false.  */\n+\n+double_int\n+double_int_smod (double_int a, double_int b, unsigned code)\n+{\n+  return double_int_mod (a, b, false, code);\n+}\n+\n+/* The same as double_int_mod with UNS = true.  */\n+\n+double_int\n+double_int_umod (double_int a, double_int b, unsigned code)\n+{\n+  return double_int_mod (a, b, true, code);\n+}\n+\n /* Constructs tree in type TYPE from with value given by CST.  */\n \n tree"}, {"sha": "eddd7b7e2fef4a74458ecf57b073538ddf44d483", "filename": "gcc/double-int.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "patch": "@@ -116,6 +116,12 @@ unsigned HOST_WIDE_INT double_int_to_uhwi (double_int);\n double_int double_int_div (double_int, double_int, bool, unsigned);\n double_int double_int_sdiv (double_int, double_int, unsigned);\n double_int double_int_udiv (double_int, double_int, unsigned);\n+double_int double_int_mod (double_int, double_int, bool, unsigned);\n+double_int double_int_smod (double_int, double_int, unsigned);\n+double_int double_int_umod (double_int, double_int, unsigned);\n+double_int double_int_divmod (double_int, double_int, bool, unsigned, double_int *);\n+double_int double_int_sdivmod (double_int, double_int, unsigned, double_int *);\n+double_int double_int_udivmod (double_int, double_int, unsigned, double_int *);\n bool double_int_negative_p (double_int);\n int double_int_cmp (double_int, double_int, bool);\n int double_int_scmp (double_int, double_int);"}, {"sha": "ae1905d05ded5ae28718da89658df739c0101c92", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 47, "deletions": 72, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f414f2f35e4cb2f18f2da8f28777ad797cf7b0fa", "patch": "@@ -2554,82 +2554,68 @@ tree_int_cst_sign_bit (tree t)\n   return (w >> bitno) & 1;\n }\n \n-/* If we can prove that TOP = cst * BOT for some constant cst in TYPE,\n-   return cst.  Otherwise return NULL_TREE.  */\n+/* If we can prove that TOP = cst * BOT for some constant cst,\n+   store cst to MUL and return true.  Otherwise return false.\n+   The returned value is always sign-extended, regardless of the\n+   signedness of TOP and BOT.  */\n \n-static tree\n-constant_multiple_of (tree type, tree top, tree bot)\n+static bool\n+constant_multiple_of (tree top, tree bot, double_int *mul)\n {\n-  tree res, mby, p0, p1;\n+  tree mby;\n   enum tree_code code;\n-  bool negate;\n+  double_int res, p0, p1;\n+  unsigned precision = TYPE_PRECISION (TREE_TYPE (top));\n \n   STRIP_NOPS (top);\n   STRIP_NOPS (bot);\n \n   if (operand_equal_p (top, bot, 0))\n-    return build_int_cst (type, 1);\n+    {\n+      *mul = double_int_one;\n+      return true;\n+    }\n \n   code = TREE_CODE (top);\n   switch (code)\n     {\n     case MULT_EXPR:\n       mby = TREE_OPERAND (top, 1);\n       if (TREE_CODE (mby) != INTEGER_CST)\n-\treturn NULL_TREE;\n+\treturn false;\n \n-      res = constant_multiple_of (type, TREE_OPERAND (top, 0), bot);\n-      if (!res)\n-\treturn NULL_TREE;\n+      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &res))\n+\treturn false;\n \n-      return fold_binary_to_constant (MULT_EXPR, type, res,\n-\t\t\t\t      fold_convert (type, mby));\n+      *mul = double_int_sext (double_int_mul (res, tree_to_double_int (mby)),\n+\t\t\t      precision);\n+      return true;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      p0 = constant_multiple_of (type, TREE_OPERAND (top, 0), bot);\n-      if (!p0)\n-\treturn NULL_TREE;\n-      p1 = constant_multiple_of (type, TREE_OPERAND (top, 1), bot);\n-      if (!p1)\n-\treturn NULL_TREE;\n+      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &p0)\n+\t  || !constant_multiple_of (TREE_OPERAND (top, 1), bot, &p1))\n+\treturn false;\n \n-      return fold_binary_to_constant (code, type, p0, p1);\n+      if (code == MINUS_EXPR)\n+\tp1 = double_int_neg (p1);\n+      *mul = double_int_sext (double_int_add (p0, p1), precision);\n+      return true;\n \n     case INTEGER_CST:\n       if (TREE_CODE (bot) != INTEGER_CST)\n-\treturn NULL_TREE;\n-\n-      bot = fold_convert (type, bot);\n-      top = fold_convert (type, top);\n-\n-      /* If BOT seems to be negative, try dividing by -BOT instead, and negate\n-\t the result afterwards.  */\n-      if (tree_int_cst_sign_bit (bot))\n-\t{\n-\t  negate = true;\n-\t  bot = fold_unary_to_constant (NEGATE_EXPR, type, bot);\n-\t}\n-      else\n-\tnegate = false;\n-\n-      /* Ditto for TOP.  */\n-      if (tree_int_cst_sign_bit (top))\n-\t{\n-\t  negate = !negate;\n-\t  top = fold_unary_to_constant (NEGATE_EXPR, type, top);\n-\t}\n-\n-      if (!zero_p (fold_binary_to_constant (TRUNC_MOD_EXPR, type, top, bot)))\n-\treturn NULL_TREE;\n+\treturn false;\n \n-      res = fold_binary_to_constant (EXACT_DIV_EXPR, type, top, bot);\n-      if (negate)\n-\tres = fold_unary_to_constant (NEGATE_EXPR, type, res);\n-      return res;\n+      p0 = double_int_sext (tree_to_double_int (bot), precision);\n+      p1 = double_int_sext (tree_to_double_int (top), precision);\n+      if (double_int_zero_p (p1))\n+\treturn false;\n+      *mul = double_int_sext (double_int_sdivmod (p0, p1, FLOOR_DIV_EXPR, &res),\n+\t\t\t      precision);\n+      return double_int_zero_p (res);\n \n     default:\n-      return NULL_TREE;\n+      return false;\n     }\n }\n \n@@ -2986,6 +2972,7 @@ get_computation_aff (struct loop *loop,\n   HOST_WIDE_INT ratioi;\n   struct affine_tree_combination cbase_aff, expr_aff;\n   tree cstep_orig = cstep, ustep_orig = ustep;\n+  double_int rat;\n \n   if (TYPE_PRECISION (utype) > TYPE_PRECISION (ctype))\n     {\n@@ -3040,21 +3027,15 @@ get_computation_aff (struct loop *loop,\n     }\n   else\n     {\n-      ratio = constant_multiple_of (uutype, ustep_orig, cstep_orig);\n-      if (!ratio)\n+      if (!constant_multiple_of (ustep_orig, cstep_orig, &rat))\n \treturn false;\n+      ratio = double_int_to_tree (uutype, rat);\n \n       /* Ratioi is only used to detect special cases when the multiplicative\n-\t factor is 1 or -1, so if we cannot convert ratio to HOST_WIDE_INT,\n-\t we may set it to 0.  We prefer cst_and_fits_in_hwi/int_cst_value\n-\t to integer_onep/integer_all_onesp, since the former ignores\n-\t TREE_OVERFLOW.  */\n-      if (cst_and_fits_in_hwi (ratio))\n-\tratioi = int_cst_value (ratio);\n-      else if (integer_onep (ratio))\n-\tratioi = 1;\n-      else if (integer_all_onesp (ratio))\n-\tratioi = -1;\n+\t factor is 1 or -1, so if rat does not fit to HOST_WIDE_INT, we may\n+\t set it to 0.  */\n+      if (double_int_fits_in_shwi_p (rat))\n+\tratioi = double_int_to_shwi (rat);\n       else\n \tratioi = 0;\n     }\n@@ -3775,19 +3756,13 @@ get_computation_cost_at (struct ivopts_data *data,\n     }\n   else\n     {\n-      tree rat;\n+      double_int rat;\n       \n-      rat = constant_multiple_of (utype, ustep, cstep);\n-    \n-      if (!rat)\n+      if (!constant_multiple_of (ustep, cstep, &rat))\n \treturn INFTY;\n-\n-      if (cst_and_fits_in_hwi (rat))\n-\tratio = int_cst_value (rat);\n-      else if (integer_onep (rat))\n-\tratio = 1;\n-      else if (integer_all_onesp (rat))\n-\tratio = -1;\n+    \n+      if (double_int_fits_in_shwi_p (rat))\n+\tratio = double_int_to_shwi (rat);\n       else\n \treturn INFTY;\n     }"}]}