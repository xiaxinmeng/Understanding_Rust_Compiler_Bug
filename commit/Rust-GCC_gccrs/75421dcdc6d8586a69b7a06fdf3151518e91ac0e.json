{"sha": "75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0MjFkY2RjNmQ4NTg2YTY5YjdhMDZmZGYzMTUxNTE4ZTkxYWMwZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-05T12:25:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-05T12:25:20Z"}, "message": "tree-ssa-loop-im.c (for_each_index): Do not handle ALIGN_INDIRECT_REF.\n\n2010-07-05  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (for_each_index): Do not handle\n\tALIGN_INDIRECT_REF.\n\t(gen_lsm_tmp_name): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t(op_code_prio): Likewise.\n\t(op_symbol_code): Likewise.\n\t* tree.c (staticp): Likewise.\n\t(build1_stat): Likewise.\n\t* tree.h (INDIRECT_REF_P): Likewise.\n\t* fold-const.c (maybe_lvalue_p): Likewise.\n\t(operand_equal_p): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n\t(ao_ref_init_from_vn_reference): Likewise.\n\t* tree-ssa-loop-ivopts.c (idx_find_step): Likewise.\n\t(find_interesting_uses_address): Likewise.\n\t* dwarf2out.c (loc_list_from_tree): Likewise.\n\t* gimplify.c (gimplify_expr): Likewise.\n\t* tree-eh.c (tree_could_trap_p): Likewise.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n\t* tree-cfg.c (verify_types_in_gimple_min_lval): Likewise.\n\t* config/rs6000/rs6000 (rs6000_check_sdmode): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* expr.c (safe_from_p): Likewise.\n\t(expand_expr_real_1): Likewise.  TER BIT_AND_EXPRs into MEM_REFs.\n\t* tree-vect-data-refs.c (vect_setup_realignment): Build\n\tBIT_AND_EXPR and MEM_REF instead of ALIGN_INDIRECT_REF.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t* tree.def (ALIGN_INDIRECT_REF): Remove.\n\nFrom-SVN: r161830", "tree": {"sha": "34ecef9e0e53eb11bb21987eca5fd01634451a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ecef9e0e53eb11bb21987eca5fd01634451a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d65726326a543c6203dc6c033fd9aba31be5c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d65726326a543c6203dc6c033fd9aba31be5c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d65726326a543c6203dc6c033fd9aba31be5c15"}], "stats": {"total": 177, "additions": 88, "deletions": 89}, "files": [{"sha": "1a1cce539d2de9c45491988ebf7b9812e3cb99bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -1,3 +1,38 @@\n+2010-07-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-loop-im.c (for_each_index): Do not handle\n+\tALIGN_INDIRECT_REF.\n+\t(gen_lsm_tmp_name): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(op_code_prio): Likewise.\n+\t(op_symbol_code): Likewise.\n+\t* tree.c (staticp): Likewise.\n+\t(build1_stat): Likewise.\n+\t* tree.h (INDIRECT_REF_P): Likewise.\n+\t* fold-const.c (maybe_lvalue_p): Likewise.\n+\t(operand_equal_p): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n+\t(ao_ref_init_from_vn_reference): Likewise.\n+\t* tree-ssa-loop-ivopts.c (idx_find_step): Likewise.\n+\t(find_interesting_uses_address): Likewise.\n+\t* dwarf2out.c (loc_list_from_tree): Likewise.\n+\t* gimplify.c (gimplify_expr): Likewise.\n+\t* tree-eh.c (tree_could_trap_p): Likewise.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n+\t* tree-cfg.c (verify_types_in_gimple_min_lval): Likewise.\n+\t* config/rs6000/rs6000 (rs6000_check_sdmode): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* expr.c (safe_from_p): Likewise.\n+\t(expand_expr_real_1): Likewise.  TER BIT_AND_EXPRs into MEM_REFs.\n+\t* tree-vect-data-refs.c (vect_setup_realignment): Build\n+\tBIT_AND_EXPR and MEM_REF instead of ALIGN_INDIRECT_REF.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\t* tree.def (ALIGN_INDIRECT_REF): Remove.\n+\n 2010-07-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44784"}, {"sha": "3e9ecbffee4d10ac99fc5093490843bd58fd6dc4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2239,7 +2239,6 @@ expand_debug_expr (tree exp)\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n   addr_space_t as;\n-  enum machine_mode address_mode;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -2444,28 +2443,15 @@ expand_debug_expr (tree exp)\n \treturn NULL;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n       op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n       if (!op0)\n \treturn NULL;\n \n       if (POINTER_TYPE_P (TREE_TYPE (exp)))\n-\t{\n-\t  as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));\n-\t  address_mode = targetm.addr_space.address_mode (as);\n-\t}\n+\tas = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));\n       else\n-\t{\n-\t  as = ADDR_SPACE_GENERIC;\n-\t  address_mode = Pmode;\n-\t}\n-\n-      if (TREE_CODE (exp) == ALIGN_INDIRECT_REF)\n-\t{\n-\t  int align = TYPE_ALIGN_UNIT (TREE_TYPE (exp));\n-\t  op0 = gen_rtx_AND (address_mode, op0, GEN_INT (-align));\n-\t}\n+\tas = ADDR_SPACE_GENERIC;\n \n       op0 = gen_rtx_MEM (mode, op0);\n "}, {"sha": "88f85760423fa37bf0e48623a4fe2dce8132ff9a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -13805,7 +13805,6 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case SSA_NAME:\n     case REAL_CST:\n     case MEM_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case VIEW_CONVERT_EXPR:\n       if (TYPE_MODE (TREE_TYPE (*tp)) == SDmode)"}, {"sha": "8e355450eefbee5986239dbfec6311dae7e9b23b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -15186,7 +15186,6 @@ loc_list_from_tree (tree loc, int want_address)\n \treturn 0;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n       list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n       have_address = 1;"}, {"sha": "35ca9d40d3bdcc0bbfaaaa214abff828f2faf2f7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -1611,7 +1611,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   /* We can set the alignment from the type if we are making an object,\n      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n   if (objectp || TREE_CODE (t) == INDIRECT_REF\n-      || TREE_CODE (t) == ALIGN_INDIRECT_REF\n       || TYPE_ALIGN_OK (type))\n     align = MAX (align, TYPE_ALIGN (type));\n   else if (TREE_CODE (t) == MEM_REF)\n@@ -1842,14 +1841,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \tsize = plus_constant (size, apply_bitpos / BITS_PER_UNIT);\n     }\n \n-  if (TREE_CODE (t) == ALIGN_INDIRECT_REF)\n-    {\n-      /* Force EXPR and OFFSET to NULL, since we don't know exactly what\n-\t we're overlapping.  */\n-      offset = NULL;\n-      expr = NULL;\n-    }\n-\n   /* Now set the attributes we computed above.  */\n   MEM_ATTRS (ref)\n     = get_mem_attrs (alias, expr, offset, size, align,"}, {"sha": "a43d708f2735f6cad2935db72e792916fbca1f85", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -6670,7 +6670,6 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n \t  break;\n \n \tcase MISALIGNED_INDIRECT_REF:\n-\tcase ALIGN_INDIRECT_REF:\n \tcase INDIRECT_REF:\n \t  if (MEM_P (x)\n \t      && alias_sets_conflict_p (MEM_ALIAS_SET (x),\n@@ -8646,12 +8645,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return expand_constructor (exp, target, modifier, false);\n \n     case MISALIGNED_INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       {\n \ttree exp1 = treeop0;\n \taddr_space_t as = ADDR_SPACE_GENERIC;\n-\tenum machine_mode address_mode = Pmode;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -8663,21 +8660,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  }\n \n \tif (POINTER_TYPE_P (TREE_TYPE (exp1)))\n-\t  {\n-\t    as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n-\t    address_mode = targetm.addr_space.address_mode (as);\n-\t  }\n+\t  as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address_addr_space (mode, op0, as);\n \n-\tif (code == ALIGN_INDIRECT_REF)\n-\t  {\n-\t    int align = TYPE_ALIGN_UNIT (type);\n-\t    op0 = gen_rtx_AND (address_mode, op0, GEN_INT (-align));\n-\t    op0 = memory_address_addr_space (mode, op0, as);\n-\t  }\n-\n \ttemp = gen_rtx_MEM (mode, op0);\n \n \tset_mem_attributes (temp, exp, 0);\n@@ -8742,6 +8729,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))));\n \tenum machine_mode address_mode;\n \ttree base = TREE_OPERAND (exp, 0);\n+\tgimple def_stmt;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n \tif (TREE_CODE (base) == ADDR_EXPR)\n@@ -8784,8 +8772,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      }\n \t  }\n \taddress_mode = targetm.addr_space.address_mode (as);\n-\top0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, address_mode,\n-\t\t\t   EXPAND_NORMAL);\n+\tbase = TREE_OPERAND (exp, 0);\n+\tif ((def_stmt = get_def_for_expr (base, BIT_AND_EXPR)))\n+\t  base = build2 (BIT_AND_EXPR, TREE_TYPE (base),\n+\t\t\t gimple_assign_rhs1 (def_stmt),\n+\t\t\t gimple_assign_rhs2 (def_stmt));\n+\top0 = expand_expr (base, NULL_RTX, address_mode, EXPAND_NORMAL);\n \tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n \t  {\n \t    rtx off;"}, {"sha": "8be8f3ee4a73ab0c3213c9c9ab3d60622ceafaa8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2041,8 +2041,8 @@ maybe_lvalue_p (const_tree x)\n   case SSA_NAME:\n \n   case COMPONENT_REF:\n+  case MEM_REF:\n   case INDIRECT_REF:\n-  case ALIGN_INDIRECT_REF:\n   case MISALIGNED_INDIRECT_REF:\n   case ARRAY_REF:\n   case ARRAY_RANGE_REF:\n@@ -2586,7 +2586,6 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       switch (TREE_CODE (arg0))\n \t{\n \tcase INDIRECT_REF:\n-\tcase ALIGN_INDIRECT_REF:\n \tcase MISALIGNED_INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n@@ -7596,7 +7595,6 @@ build_fold_addr_expr_with_type_loc (location_t loc, tree t, tree ptrtype)\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n \n-  /* Note: doesn't apply to ALIGN_INDIRECT_REF */\n   if (TREE_CODE (t) == INDIRECT_REF\n       || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n     {"}, {"sha": "5559f0e3698257a3afa638c06eb71510982c1150", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -6769,7 +6769,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  recalculate_side_effects (*expr_p);\n \t  break;\n \n-\tcase ALIGN_INDIRECT_REF:\n \tcase MISALIGNED_INDIRECT_REF:\n \t  /* We can only reach this through re-gimplification from\n \t     tree optimizers.  */"}, {"sha": "ccafa4d9e72d208cfe01aef152e723b582d7f88f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2850,8 +2850,7 @@ verify_types_in_gimple_min_lval (tree expr)\n   if (is_gimple_id (expr))\n     return false;\n \n-  if (TREE_CODE (expr) != ALIGN_INDIRECT_REF\n-      && TREE_CODE (expr) != MISALIGNED_INDIRECT_REF\n+  if (TREE_CODE (expr) != MISALIGNED_INDIRECT_REF\n       && TREE_CODE (expr) != TARGET_MEM_REF\n       && TREE_CODE (expr) != MEM_REF)\n     {\n@@ -3702,7 +3701,6 @@ verify_gimple_assign_single (gimple stmt)\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:"}, {"sha": "defa5586d405e8c3bcc9b24d55d9be3408f25416", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -571,7 +571,6 @@ dequeue_and_dump (dump_info_p di)\n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case CLEANUP_POINT_EXPR:\n     case SAVE_EXPR:"}, {"sha": "853aa5504fb0beecd6a03097731e20eb55e91ec5", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2442,7 +2442,6 @@ tree_could_trap_p (tree expr)\n \treturn false;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n       return !TREE_THIS_NOTRAP (expr);\n "}, {"sha": "a51fbe73236ee76060db8be0bdb4d681a794edc5", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -1586,7 +1586,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case ADDR_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       if (TREE_CODE (node) == ADDR_EXPR\n@@ -2549,7 +2548,6 @@ op_code_prio (enum tree_code code)\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case NEGATE_EXPR:\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n     case ADDR_EXPR:\n@@ -2720,9 +2718,6 @@ op_symbol_code (enum tree_code code)\n     case INDIRECT_REF:\n       return \"*\";\n \n-    case ALIGN_INDIRECT_REF:\n-      return \"A*\";\n-\n     case MISALIGNED_INDIRECT_REF:\n       return \"M*\";\n "}, {"sha": "2e65d10db9a6992893ba343c68915c5ff8adc984", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -273,7 +273,6 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \t  return cbck (*addr_p, addr_p, data);\n \n \tcase MISALIGNED_INDIRECT_REF:\n-\tcase ALIGN_INDIRECT_REF:\n \tcase MEM_REF:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  return cbck (*addr_p, nxt, data);\n@@ -1984,7 +1983,6 @@ gen_lsm_tmp_name (tree ref)\n   switch (TREE_CODE (ref))\n     {\n     case MISALIGNED_INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case MEM_REF:\n       gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n       lsm_tmp_name_add (\"_\");"}, {"sha": "740db68fee06e813c8465c9d75ccdb039c1af21a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -1360,8 +1360,7 @@ idx_find_step (tree base, tree *idx, void *data)\n   tree step, iv_base, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n \n-  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF\n-      || TREE_CODE (base) == ALIGN_INDIRECT_REF)\n+  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n     return false;\n \n   /* If base is a component ref, require that the offset of the reference\n@@ -1673,7 +1672,6 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \tgoto fail;\n       step = ifs_ivopts_data.step;\n \n-      gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n       gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n \n       /* Check that the base expression is addressable.  This needs"}, {"sha": "0282cbcc08a72581ce4256dfe62c0310e5e5933c", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -404,8 +404,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n   HOST_WIDE_INT idelta = 0, imult = 1;\n   affine_iv iv;\n \n-  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF\n-      || TREE_CODE (base) == ALIGN_INDIRECT_REF)\n+  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n     return false;\n \n   if (!simple_iv (ar_data->loop, loop_containing_stmt (ar_data->stmt),"}, {"sha": "5b17ce22427369482a9d50e4bd65026057bc7ac7", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -712,7 +712,7 @@ mark_address_taken (tree ref)\n \n \n /* A subroutine of get_expr_operands to handle MEM_REF,\n-   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.\n+   MISALIGNED_INDIRECT_REF.\n \n    STMT is the statement being processed, EXPR is the MEM_REF\n       that got us here.\n@@ -914,7 +914,6 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n       /* fall through */\n \n-    case ALIGN_INDIRECT_REF:\n     case MEM_REF:\n       get_indirect_ref_operands (stmt, expr, flags, true);\n       return;"}, {"sha": "8293e978d67b113326fc1c2cfdbd093a6b3b48f7", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2823,7 +2823,6 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \treturn folded;\n       }\n       break;\n-    case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n       {\n \ttree folded;"}, {"sha": "192d70f532980785368d2858f8c24df4ddd08f93", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -600,10 +600,6 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \n       switch (temp.opcode)\n \t{\n-\tcase ALIGN_INDIRECT_REF:\n-\t  /* The only operand is the address, which gets its own\n-\t     vn_reference_op_s structure.  */\n-\t  break;\n \tcase MISALIGNED_INDIRECT_REF:\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n \t  break;\n@@ -789,11 +785,6 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t  return false;\n \n \t/* Record the base objects.  */\n-\tcase ALIGN_INDIRECT_REF:\n-\t  *op0_p = build1 (op->opcode, op->type, NULL_TREE);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n-\t  break;\n-\n \tcase MISALIGNED_INDIRECT_REF:\n \t  *op0_p = build2 (MISALIGNED_INDIRECT_REF, op->type,\n \t\t\t   NULL_TREE, op->op0);"}, {"sha": "7755426876b32bd4a1adcce3c77a88e74874f3b9", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -3565,7 +3565,15 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n \t\t\t\t      &init_addr, &inc, true, &inv_p);\n-      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n+      new_stmt = gimple_build_assign_with_ops\n+\t\t   (BIT_AND_EXPR, NULL_TREE, ptr,\n+\t\t    build_int_cst (TREE_TYPE (ptr),\n+\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+      new_temp = make_ssa_name (SSA_NAME_VAR (ptr), new_stmt);\n+      gimple_assign_set_lhs (new_stmt, new_temp);\n+      new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n+      gcc_assert (!new_bb);\n+      data_ref = build_simple_mem_ref (new_temp);\n       new_stmt = gimple_build_assign (vec_dest, data_ref);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);"}, {"sha": "ee3c2dd76e5066d06d9272515de6083ef6637d9e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -3760,7 +3760,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\tdr_explicit_realign,\n \t\t\t\t\t\tdataref_ptr, NULL);\n \n-\t\tdata_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+\t\tnew_stmt = gimple_build_assign_with_ops\n+\t\t\t     (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n+\t\t\t      build_int_cst\n+\t\t\t        (TREE_TYPE (dataref_ptr),\n+\t\t\t\t -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\tptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t\tgimple_assign_set_lhs (new_stmt, ptr);\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\tdata_ref = build_simple_mem_ref (ptr);\n \t\tvec_dest = vect_create_destination_var (scalar_dest, vectype);\n \t\tnew_stmt = gimple_build_assign (vec_dest, data_ref);\n \t\tnew_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -3773,11 +3781,27 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\tbump = size_binop (MULT_EXPR, vs_minus_1,\n \t\t\t\t   TYPE_SIZE_UNIT (scalar_type));\n \t\tptr = bump_vector_ptr (dataref_ptr, NULL, gsi, stmt, bump);\n-\t        data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n+\t\tnew_stmt = gimple_build_assign_with_ops\n+\t\t\t     (BIT_AND_EXPR, NULL_TREE, ptr,\n+\t\t\t      build_int_cst\n+\t\t\t        (TREE_TYPE (ptr),\n+\t\t\t\t -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\tptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t\tgimple_assign_set_lhs (new_stmt, ptr);\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t        data_ref = build_simple_mem_ref (ptr);\n \t        break;\n \t      }\n \t    case dr_explicit_realign_optimized:\n-\t      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+\t      new_stmt = gimple_build_assign_with_ops\n+\t\t\t   (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n+\t\t\t    build_int_cst\n+\t\t\t      (TREE_TYPE (dataref_ptr),\n+\t\t\t       -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t      new_temp = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t      gimple_assign_set_lhs (new_stmt, new_temp);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      data_ref = build_simple_mem_ref (new_temp);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();"}, {"sha": "fbbca2fb95a9fb7971b8ace20ff707895ca9d213", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -2432,7 +2432,6 @@ staticp (tree arg)\n       return NULL;\n \n     case MISALIGNED_INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       return TREE_CONSTANT (TREE_OPERAND (arg, 0)) ? arg : NULL;\n \n@@ -3660,7 +3659,6 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n       break;\n \n     case MISALIGNED_INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       /* Whether a dereference is readonly has nothing to do with whether\n \t its operand is readonly.  */"}, {"sha": "493c75e79af70a3c54d905349ebd7b6bfb704109", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -416,15 +416,11 @@ DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", tcc_reference, 4)\n \n /* The ordering of the following codes is optimized for the checking\n    macros in tree.h.  Changing the order will degrade the speed of the\n-   compiler.  INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n+   compiler.  INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n \n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n \n-/* Like above, but aligns the referenced address (i.e, if the address\n-   in P is not aligned on TYPE_ALIGN boundary, then &(*P) != P).  */\n-DEFTREECODE (ALIGN_INDIRECT_REF, \"align_indirect_ref\", tcc_reference, 1)\n-\n /* Same as INDIRECT_REF, but also specifies the alignment of the referenced\n    address:\n    Operand 0 is the referenced address (a pointer);"}, {"sha": "c92833c8a94e2c361f7ad1ba193b38dff36cd25a", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75421dcdc6d8586a69b7a06fdf3151518e91ac0e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=75421dcdc6d8586a69b7a06fdf3151518e91ac0e", "patch": "@@ -118,7 +118,6 @@ extern const enum tree_code_class tree_code_type[];\n \n #define INDIRECT_REF_P(CODE)\\\n   (TREE_CODE (CODE) == INDIRECT_REF \\\n-   || TREE_CODE (CODE) == ALIGN_INDIRECT_REF \\\n    || TREE_CODE (CODE) == MISALIGNED_INDIRECT_REF)\n \n /* Nonzero if CODE represents a reference.  */\n@@ -1251,7 +1250,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    accessing the memory pointed to won't generate a trap.  However,\n    this only applies to an object when used appropriately: it doesn't\n    mean that writing a READONLY mem won't trap. Similarly for\n-   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.\n+   MISALIGNED_INDIRECT_REF.\n \n    In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index\n    (or slice of the array) always belongs to the range of the array."}]}