{"sha": "22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlZjRlOWI1OWY4ZGY0YjNhOGUzN2QxNzg0MjZiMmNmZTA1OTY1Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-02T01:33:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-02T01:33:45Z"}, "message": "stdarg.h: Include va-mn10300.h.\n\n        * ginclude/stdarg.h: Include va-mn10300.h.\n        * ginclude/varargs.h: Likewise.\n        * ginclude/va-mn10300.h: New file.\n        * mn10300/mn10300.c (expand_prologue): If current_function_varargs is\n        nonzero, then flush d0/d1 back into the stack.\n        (mn10300_builtin_saveregs): New function.\n        (function_arg, function_arg_partial_nregs): New functions.\n        (initial_offset): Tweak now that the RP save area is allocated\n        and deallocated around each call again.\n        * mn10300/mn10300.h (FIRST_PARM_OFFSET): Now 4.\n        (FRAME_POINTER_REQUIRED): Require a frame pointer for all non-leaf\n        functions.\n        (REG_PARM_STACK_SPACE): Now 8 bytes.\n        (FUNCTION_ARG_REGNO_P): Update for new parameter passing conventions.\n        (CUMULATIVE_ARGS, INIT_CUMULATIVE_ARGS): Likewise.\n        (FUNCTION_ARG_ADVANCE, FUNCTION_ARG): Likewise.\n        (FUNCTION_ARG_PARTIAL_NREGS): Likewise.\n        (TRAMPOLINE_TEMPLATE): Don't clobber d0 anymore.\n        (TRAMPOLINE_SIZE, INITIALIZE_TRAMPOLINE): Corresponding changes.\n        (EXPAND_BUILTIN_SAVEREGS): Define.\n        * mn10300/mn10300.md (call, call_value patterns): Allocate and\n        deallocate a stack slot for the return pointer around each call.\n\n        * mn10300/mn10300.h (RTX_COSTS): Refine.\n        (CASE_VALUES_THRESHHOLD, NO_FUNCTION_CSE): Likewise.\n        * mn10300/mn10300.c (output_tst): New function.\n        * mn10300/mn10300.md (movdi, movdf): Improve code to load constants\n        into registers.\n        (tst insns): Use output_tst to optimize some cases.  Add versions to\n        encourage more zero extensions instead of sign extensions of HImode\n        and QImode values.\n        (divsi3, udivsi3): Remove patterns.  Replaced by...\n        (divmodsi4, udivmodsi4): New expanders/patterns.\n        (andsi3): Optimize \"and\" operations with certain constants.\n\nFrom-SVN: r13827", "tree": {"sha": "dd8d664c5789730a9a8a40c022140026db3891e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd8d664c5789730a9a8a40c022140026db3891e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/comments", "author": null, "committer": null, "parents": [{"sha": "e8adce1747d6a07982425c014a7e1ae2639ce04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8adce1747d6a07982425c014a7e1ae2639ce04b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8adce1747d6a07982425c014a7e1ae2639ce04b"}], "stats": {"total": 485, "additions": 427, "deletions": 58}, "files": [{"sha": "5093351870df94251b604035c60f289a314f67ee", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 211, "deletions": 4, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "patch": "@@ -343,6 +343,20 @@ expand_prologue ()\n {\n   unsigned int size = get_frame_size ();\n \n+  /* If this is an old-style varargs function, then its arguments\n+     need to be flushed back to the stack.  */\n+  if (current_function_varargs)\n+    {\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (4))),\n+\t\t      gen_rtx (REG, SImode, 0));\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (8))),\n+\t\t      gen_rtx (REG, SImode, 1));\n+    }\n+\n   /* And now store all the registers onto the stack with a\n      single two byte instruction.  */\n   if (regs_ever_live[2] || regs_ever_live[3]\n@@ -519,23 +533,216 @@ initial_offset (from, to)\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || frame_pointer_needed)\n-\treturn 20;\n+\treturn 16;\n       else\n-\treturn 4;\n+\treturn 0;\n     }\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     {\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || frame_pointer_needed)\n-\treturn get_frame_size () + 20;\n+\treturn get_frame_size () + 16;\n       else\n-\treturn get_frame_size () + 4;\n+\treturn get_frame_size ();\n     }\n \n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return get_frame_size ();\n \n   abort ();\n }\n+\n+/* Flush the argument registers to the stack for a stdarg function;\n+   return the new argument pointer.  */\n+rtx\n+mn10300_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  rtx offset;\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  int argadj = ((!(TYPE_ARG_TYPES (fntype) != 0\n+                   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+                       != void_type_node)))\n+                ? UNITS_PER_WORD : 0);\n+\n+  if (argadj)\n+    offset = plus_constant (current_function_arg_offset_rtx, argadj);\n+  else\n+    offset = current_function_arg_offset_rtx;\n+\n+  emit_move_insn (gen_rtx (MEM, SImode, current_function_internal_arg_pointer),\n+\t\t  gen_rtx (REG, SImode, 0));\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   plus_constant\n+\t\t\t     (current_function_internal_arg_pointer, 4)),\n+\t\t  gen_rtx (REG, SImode, 1));\n+  return copy_to_reg (expand_binop (Pmode, add_optab,\n+\t\t\t\t    current_function_internal_arg_pointer,\n+\t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n+}\n+\n+/* Return an RTX to represent where a value with mode MODE will be returned\n+   from a function.  If the result is 0, the argument is pushed.  */\n+\n+rtx\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  rtx result = 0;\n+  int size, align;\n+\n+  /* We only support using 2 data registers as argument registers.  */\n+  int nregs = 2;\n+\n+  /* Figure out the size of the object to be passed.  */\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  /* Figure out the alignment of the object to be passed.  */\n+  align = size;\n+\n+  cum->nbytes = (cum->nbytes + 3) & ~3;\n+\n+  /* Don't pass this arg via a register if all the argument registers\n+     are used up.  */\n+  if (cum->nbytes > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  /* Don't pass this arg via a register if it would be split between\n+     registers and memory.  */\n+  if (type == NULL_TREE\n+      && cum->nbytes + size > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  switch (cum->nbytes / UNITS_PER_WORD)\n+    {\n+    case 0:\n+      result = gen_rtx (REG, mode, 0);\n+      break;\n+    case 1:\n+      result = gen_rtx (REG, mode, 1);\n+      break;\n+    default:\n+      result = 0;\n+    }\n+\n+  return result;\n+}\n+\n+/* Return the number of registers to use for an argument passed partially\n+   in registers and partially in memory.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int size, align;\n+\n+  /* We only support using 2 data registers as argument registers.  */\n+  int nregs = 2;\n+\n+  /* Figure out the size of the object to be passed.  */\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  /* Figure out the alignment of the object to be passed.  */\n+  align = size;\n+\n+  cum->nbytes = (cum->nbytes + 3) & ~3;\n+\n+  /* Don't pass this arg via a register if all the argument registers\n+     are used up.  */\n+  if (cum->nbytes > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  if (cum->nbytes + size <= nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  /* Don't pass this arg via a register if it would be split between\n+     registers and memory.  */\n+  if (type == NULL_TREE\n+      && cum->nbytes + size > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  return (nregs * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n+}\n+\n+/* Output a tst insn.  */\n+char *\n+output_tst (operand, insn)\n+     rtx operand, insn;\n+{\n+  \n+  rtx temp;\n+  int past_call = 0;\n+\n+  /* We can save a byte if we can find a register which has the value\n+     zero in it.  */\n+  temp = PREV_INSN (insn);\n+  while (temp)\n+    {\n+      rtx set;\n+\n+      /* We allow the search to go through call insns.  We record\n+\t the fact that we've past a CALL_INSN and reject matches which\n+\t use call clobbered registers.  */\n+      if (GET_CODE (temp) == CODE_LABEL\n+\t  || GET_CODE (temp) == JUMP_INSN\n+\t  || GET_CODE (temp) == BARRIER)\n+\tbreak;\n+\n+      if (GET_CODE (temp) == CALL_INSN)\n+\tpast_call = 1;\n+\n+      if (GET_CODE (temp) == NOTE)\n+\t{\n+\t  temp = PREV_INSN (temp);\n+\t  continue;\n+\t}\n+\n+      /* It must be an insn, see if it is a simple set. */\n+      set = single_set (temp);\n+      if (!set)\n+\t{\n+\t  temp = PREV_INSN (temp);\n+\t  continue;\n+\t}\n+\n+      /* Are we setting a data register to zero (this does not win for\n+\t address registers)? \n+\n+\t If it's a call clobbered register, have we past a call?\n+\n+\t Make sure the register we find isn't the same as ourself;\n+\t the mn10300 can't encode that.  */\n+      if (REG_P (SET_DEST (set))\n+\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n+\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n+\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) == DATA_REGS\n+\t  && REGNO (SET_DEST (set)) != REGNO (operand)\n+\t  && (!past_call \n+\t      || !call_used_regs[REGNO (SET_DEST (set))]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[0] = operand;\n+\t  xoperands[1] = SET_DEST (set);\n+\n+\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n+\t  return \"\";\n+\t}\n+      temp = PREV_INSN (temp);\n+    }\n+  return \"cmp 0,%0\";\n+}"}, {"sha": "f70b6bf6a01faa286fff95d124c398d79f5766d9", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "patch": "@@ -351,7 +351,7 @@ enum reg_class {\n /* Is equal to the size of the saved fp + pc, even if an fp isn't\n    saved since the value is used before we know.  */\n \n-#define FIRST_PARM_OFFSET(FNDECL) -4\n+#define FIRST_PARM_OFFSET(FNDECL) 4\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -404,7 +404,7 @@ enum reg_class {\n   OFFSET = initial_offset (FROM, TO)\n \n #define FRAME_POINTER_REQUIRED \\\n-  !(leaf_function_p () || current_function_outgoing_args_size == 0)\n+  !(leaf_function_p ())\n \n #define CAN_DEBUG_WITHOUT_FP\n \n@@ -420,21 +420,16 @@ enum reg_class {\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n-/* On the mn10300, the caller is responsible for allocating and deallocating\n-   a stack slot for the \"call\" and \"calls\" instructions to save their return\n-   pointer.  We used to do this in the \"call\" and \"call_value\" expanders,\n-   but that generated poor code.\n-\n-   Now we pretend that we have an outgoing register parameter space so that\n-   the generic function calling code will allocate the slot.  */\n-   \n-#define REG_PARM_STACK_SPACE(FNDECL) 4\n+/* We use d0/d1 for passing parameters, so allocate 8 bytes of space\n+   for a register flushback area.  */\n+#define REG_PARM_STACK_SPACE(DECL) 8\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n /* 1 if N is a possible register number for function argument passing.\n    On the MN10300, no registers are used in this way.  */\n \n-#define FUNCTION_ARG_REGNO_P(N) 0\n+#define FUNCTION_ARG_REGNO_P(N) ((N) <= 1)\n+\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -445,7 +440,8 @@ enum reg_class {\n    On the MN10300, this is a single integer, which is a number of bytes\n    of arguments scanned so far.  */\n \n-#define CUMULATIVE_ARGS int\n+#define CUMULATIVE_ARGS struct cum_arg\n+struct cum_arg {int nbytes; };\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -454,16 +450,16 @@ enum reg_class {\n    On the MN10300, the offset starts at 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM) = 0)\n+ ((CUM).nbytes = 0)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+ ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n+\t           ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t           : (int_size_in_bytes (TYPE) + 3) & ~3))\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -480,7 +476,12 @@ enum reg_class {\n \n /* On the MN10300 all args are pushed.  */   \n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+extern struct rtx_def *function_arg ();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n \n \f\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n@@ -531,20 +532,19 @@ enum reg_class {\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tadd -4,sp\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\t.long 0x0004fffa\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0x0004fffa\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (0,sp),a0\\n\");\t\t\\\n     fprintf (FILE, \"\\tadd 4,sp\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\tmov mdr,d0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov d0,a0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov (15,a0),a1\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov (19,a0),a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (13,a0),a1\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (17,a0),a0\\n\");\t\t\\\n     fprintf (FILE, \"\\tjmp (a0)\\n\");\t\t\t\\\n     fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n     fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n   } while (0)\n \n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE 0x1d\n+#define TRAMPOLINE_SIZE 0x1b\n \n #define TRAMPOLINE_ALIGNMENT 32\n \n@@ -554,11 +554,18 @@ enum reg_class {\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x16)),\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x14)),\t\\\n  \t\t (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x1a)),\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x18)),\t\\\n \t\t (FNADDR));\t\t\t\t\t\t\\\n }\n+/* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n+   reference the 2 integer arg registers.\n+   Ordinarily they are not call used registers, but they are for\n+   _builtin_saveregs, so we must make this explicit.  */\n+\n+extern struct rtx_def *mn10300_builtin_saveregs ();\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) mn10300_builtin_saveregs (ARGLIST)\n \n /* Addressing modes, and classification of registers for them.  */\n \n@@ -740,22 +747,28 @@ enum reg_class {\n /* A crude cut at RTX_COSTS for the MN10300.  */\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   There aren't DImode MOD, DIV or MULT operations, so call them\n-   very expensive.  Everything else is pretty much a costant cost.  */\n-\n+   switch on CODE.  */\n #define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n   case MOD:\t\t\\\n   case DIV:\t\t\\\n-    return 60;\t\t\\\n+    return 8;\t\t\\\n   case MULT:\t\t\\\n-    return 20;\n+    return 8;\n \n /* Nonzero if access to memory by bytes or half words is no faster\n    than accessing full words.  */\n #define SLOW_BYTE_ACCESS 1\n \n+/* Dispatch tables on the mn10300 are extremely expensive in terms of code\n+   and readonly data size.  So we crank up the case threshold value to\n+   encourage a series of if/else comparisons to implement many small switch\n+   statements.  In theory, this value could be increased much more if we\n+   were solely optimizing for space, but we keep it \"reasonable\" to avoid\n+   serious code efficiency lossage.  */\n+#define CASE_VALUES_THRESHOLD 6\n+\n+#define NO_FUNCTION_CSE\n+\n /* According expr.c, a value of around 6 should minimize code size, and\n    for the MN10300 series, that's our primary concern.  */\n #define MOVE_RATIO 6\n@@ -983,3 +996,4 @@ extern void notice_update_cc ();\n extern int call_address_operand ();\n extern enum reg_class secondary_reload_class ();\n extern int initial_offset ();\n+extern char *output_tst ();"}, {"sha": "5db2a944b92f791b9d3ccc8836d3a5d9a4bbf7c8", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 159, "deletions": 19, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "patch": "@@ -185,6 +185,9 @@\n    || register_operand (operands[1], DImode)\"\n   \"*\n {\n+  long val[2];\n+  REAL_VALUE_TYPE rv;\n+\n   switch (which_alternative)\n     {\n       case 0:\n@@ -202,6 +205,26 @@\n       case 8:\n       case 9:\n       case 10:\n+\tif (GET_CODE (operands[1]) == CONST_INT)\n+\t  {\n+\t    val[0] = INTVAL (operands[1]);\n+\t    val[1] = val[0] < 0 ? -1 : 0;\n+\t  }\n+\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t  {\n+\t    if (GET_MODE (operands[1]) == DFmode)\n+\t      {\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t      }\n+\t    else if (GET_MODE (operands[1]) == VOIDmode\n+\t\t     || GET_MODE (operands[1]) == DImode)\n+\t      {\n+\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n+\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n+\t      }\n+\t  }\n+\n \tif (GET_CODE (operands[1]) == MEM\n \t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t  {\n@@ -221,7 +244,24 @@\n \t      \n \t  }\n \telse\n-\t  return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n+\t  {\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[0] == 0\n+\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t      output_asm_insn (\\\"clr %L0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[1] == 0\n+\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t      output_asm_insn (\\\"clr %H0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t    return \\\"\\\";\n+\t  }\n     }\n }\"\n   [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n@@ -245,6 +285,9 @@\n    || register_operand (operands[1], DFmode)\"\n   \"*\n {\n+  long val[2];\n+  REAL_VALUE_TYPE rv;\n+\n   switch (which_alternative)\n     {\n       case 0:\n@@ -262,6 +305,26 @@\n       case 8:\n       case 9:\n       case 10:\n+\tif (GET_CODE (operands[1]) == CONST_INT)\n+\t  {\n+\t    val[0] = INTVAL (operands[1]);\n+\t    val[1] = val[0] < 0 ? -1 : 0;\n+\t  }\n+\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t  {\n+\t    if (GET_MODE (operands[1]) == DFmode)\n+\t      {\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t      }\n+\t    else if (GET_MODE (operands[1]) == VOIDmode\n+\t\t     || GET_MODE (operands[1]) == DImode)\n+\t      {\n+\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n+\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n+\t      }\n+\t  }\n+\n \tif (GET_CODE (operands[1]) == MEM\n \t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t  {\n@@ -281,7 +344,24 @@\n \t      \n \t  }\n \telse\n-\t  return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n+\t  {\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[0] == 0\n+\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t      output_asm_insn (\\\"clr %L0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[1] == 0\n+\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t      output_asm_insn (\\\"clr %H0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t    return \\\"\\\";\n+\t  }\n     }\n }\"\n   [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n@@ -297,9 +377,22 @@\n (define_insn \"tstsi\"\n   [(set (cc0) (match_operand:SI 0 \"register_operand\" \"da\"))]\n   \"\"\n-  \"cmp 0,%0\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"tst\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"tst\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"tst\")])\n \n+\n (define_insn \"cmpsi\"\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a,da\")\n@@ -441,18 +534,12 @@\n   \"mul %2,%0\"\n   [(set_attr \"cc\" \"set_zn_c0\")])\n \n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"ext %0\\;div %2,%0\"\n-  [(set_attr \"cc\" \"set_zn_c0\")])\n-\n-(define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n+(define_expand \"udivmodsi4\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"\")))\n+\t      (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t\t   (umod:SI (match_dup 1) (match_dup 2)))])]\n   \"\"\n   \"\n {\n@@ -462,11 +549,44 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"divu %2,%0\"\n+  \"*\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \\\"divu %2,%0\\\";\n+  else\n+    return \\\"divu %2,%0\\;mov mdr,%3\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_expand \"divmodsi4\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (div:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"\")))\n+\t      (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t\t   (mod:SI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+\t(mod:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \\\"ext %0\\;div %2,%0\\\";\n+  else\n+    return \\\"ext %0\\;div %2,%0\\;mov mdr,%3\\\";\n+}\"\n   [(set_attr \"cc\" \"set_zn_c0\")])\n \n (define_insn \"clear_mdr\"\n@@ -491,6 +611,22 @@\n     return \\\"extbu %0\\\";\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xffff)\n     return \\\"exthu %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fffffff)\n+    return \\\"add %0,%0\\;lsr 1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x3fffffff)\n+    return \\\"asl2 %0\\;lsr 2,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x1fffffff)\n+    return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x0fffffff)\n+    return \\\"asl2 %0,%0\\;asl2 %0\\;lsr 4,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffe)\n+    return \\\"lsr 1,%0\\;add %0,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffc)\n+    return \\\"lsr 2,%0\\;asl2 %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff8)\n+    return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff0)\n+    return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n   return \\\"and %2,%0\\\";\n }\"\n   [(set_attr \"cc\" \"none_0hit,set_zn_c0\")])\n@@ -826,7 +962,9 @@\n {\n   if (! call_address_operand (XEXP (operands[0], 0)))\n     XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (-4)));\n   emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (4)));\n   DONE;\n }\")\n \n@@ -849,9 +987,11 @@\n {\n   if (! call_address_operand (XEXP (operands[1], 0)))\n     XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (-4)));\n   emit_call_insn (gen_call_value_internal (operands[0],\n \t\t\t\t\t   XEXP (operands[1], 0),\n \t\t\t\t\t   operands[2]));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (4)));\n   DONE;\n }\")\n "}, {"sha": "3b3fdf5cc7fc528cb25ded29969e3bfadf2964fc", "filename": "gcc/ginclude/stdarg.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fginclude%2Fstdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fginclude%2Fstdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdarg.h?ref=22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "patch": "@@ -44,6 +44,9 @@\n #ifdef __sh__\n #include \"va-sh.h\"\n #else\n+#ifdef __mn10300__\n+#include \"va-mn10300.h\"\n+#else\n \n /* Define __gnuc_va_list.  */\n \n@@ -81,7 +84,7 @@ void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n /* We cast to void * and then to TYPE * because this avoids\n    a warning about increasing the alignment requirement.  */\n \n-#if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__) || defined (__mn10300__)\n+#if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__)\n /* This is for little-endian machines; small args are padded upward.  */\n #define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n  (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n@@ -100,6 +103,7 @@ void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n \n #endif /* _STDARG_H */\n \n+#endif /* not mn10300 */\n #endif /* not sh */\n #endif /* not powerpc with V.4 calling sequence */\n #endif /* not h8300 */"}, {"sha": "c8fa2059debcad315252fb64dcff01dc290f0c34", "filename": "gcc/ginclude/varargs.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fginclude%2Fvarargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ef4e9b59f8df4b3a8e37d178426b2cfe059657/gcc%2Fginclude%2Fvarargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fvarargs.h?ref=22ef4e9b59f8df4b3a8e37d178426b2cfe059657", "patch": "@@ -42,6 +42,9 @@\n #ifdef __sh__\n #include \"va-sh.h\"\n #else\n+#ifdef __mn10300__\n+#include \"va-mn10300.h\"\n+#else\n \n #ifdef __NeXT__\n \n@@ -100,7 +103,7 @@ typedef void *__gnuc_va_list;\n   (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n #endif\n \n-#if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__) || defined (__mn10300__)\n+#if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__)\n /* This is for little-endian machines; small args are padded upward.  */\n #define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n  (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n@@ -117,6 +120,7 @@ typedef void *__gnuc_va_list;\n /* Copy __gnuc_va_list into another variable of this type.  */\n #define __va_copy(dest, src) (dest) = (src)\n \n+#endif /* not mn10300 */\n #endif /* not sh */\n #endif /* not powerpc with V.4 calling sequence */\n #endif /* not h8300 */"}]}