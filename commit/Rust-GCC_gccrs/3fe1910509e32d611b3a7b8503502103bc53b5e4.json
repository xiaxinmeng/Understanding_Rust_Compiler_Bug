{"sha": "3fe1910509e32d611b3a7b8503502103bc53b5e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlMTkxMDUwOWUzMmQ2MTFiM2E3Yjg1MDM1MDIxMDNiYzUzYjVlNA==", "commit": {"author": {"name": "Thomas K\u00f6nig", "email": "tkoenig@gcc.gnu.org", "date": "2020-02-13T21:22:04Z"}, "committer": {"name": "Thomas K\u00f6nig", "email": "tkoenig@gcc.gnu.org", "date": "2020-02-18T18:45:25Z"}, "message": "Use au->lock exclusively for locking in async I/O.\n\n2020-02-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/93599\n\t* io/async.c (destroy_adv_cond): Do not destroy lock.\n\t(async_io): Make sure au->lock is locked for finishing of thread.\n\tDo not lock/unlock around signalling emptysignal. Unlock au->lock\n\tbefore return.\n\t(init_adv_cond): Do not initialize lock.\n\t(enqueue_transfer): Unlock after signal.\n\t(enqueue_done_id): Likewise.\n\t(enqueue_done): Likewise.\n\t(enqueue_close): Likewise.\n\t(enqueue_data_transfer): Likewise.\n\t(async_wait_id): Do not lock/unlock around signalling au->work.\n\t(async_wait): Unlock after signal.\n\t* io/async.h (SIGNAL): Add comment about needed au->lock.\n\tRemove locking/unlocking of advcond->lock.\n\t(WAIT_SIGNAL_MUTEX): Add comment. Remove locking/unlocking of\n\tadvcond->lock.  Unlock mutex only at the end.  Loop on\n\t__ghread_cond_wait returning zero.\n\t(REVOKE_SIGNAL): Add comment. Remove locking/unlocking of\n\tadvcond->lock.\n\t(struct adv_cond): Remove mutex from struct.\n\nasdf", "tree": {"sha": "557aab0db02180d59b1610126b61af354696056f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/557aab0db02180d59b1610126b61af354696056f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fe1910509e32d611b3a7b8503502103bc53b5e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe1910509e32d611b3a7b8503502103bc53b5e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe1910509e32d611b3a7b8503502103bc53b5e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe1910509e32d611b3a7b8503502103bc53b5e4/comments", "author": null, "committer": null, "parents": [{"sha": "9b8e2dea783b3e67813b12c7cb3036b5a9892c65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8e2dea783b3e67813b12c7cb3036b5a9892c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8e2dea783b3e67813b12c7cb3036b5a9892c65"}], "stats": {"total": 92, "additions": 55, "deletions": 37}, "files": [{"sha": "bef6306fbc64408a19b03b398945e2845c629319", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3fe1910509e32d611b3a7b8503502103bc53b5e4", "patch": "@@ -1,3 +1,27 @@\n+2020-02-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/93599\n+\t* io/async.c (destroy_adv_cond): Do not destroy lock.\n+\t(async_io): Make sure au->lock is locked for finishing of thread.\n+\tDo not lock/unlock around signalling emptysignal. Unlock au->lock\n+\tbefore return.\n+\t(init_adv_cond): Do not initialize lock.\n+\t(enqueue_transfer): Unlock after signal.\n+\t(enqueue_done_id): Likewise.\n+\t(enqueue_done): Likewise.\n+\t(enqueue_close): Likewise.\n+\t(enqueue_data_transfer): Likewise.\n+\t(async_wait_id): Do not lock/unlock around signalling au->work.\n+\t(async_wait): Unlock after signal.\n+\t* io/async.h (SIGNAL): Add comment about needed au->lock.\n+\tRemove locking/unlocking of advcond->lock.\n+\t(WAIT_SIGNAL_MUTEX): Add comment. Remove locking/unlocking of\n+\tadvcond->lock.  Unlock mutex only at the end.  Loop on\n+\t__ghread_cond_wait returning zero.\n+\t(REVOKE_SIGNAL): Add comment. Remove locking/unlocking of\n+\tadvcond->lock.\n+\t(struct adv_cond): Remove mutex from struct.\n+\n 2020-02-12  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR libstdc++/79193"}, {"sha": "63b9158c0ba0ee661c3857e8e07acdff235a3ddb", "filename": "libgfortran/io/async.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2Fio%2Fasync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2Fio%2Fasync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.c?ref=3fe1910509e32d611b3a7b8503502103bc53b5e4", "patch": "@@ -80,7 +80,6 @@ update_pdt (st_parameter_dt **old, st_parameter_dt *new) {\n static void\n destroy_adv_cond (struct adv_cond *ac)\n {\n-  T_ERROR (__gthread_mutex_destroy, &ac->lock);\n   T_ERROR (__gthread_cond_destroy, &ac->signal);\n }\n \n@@ -156,6 +155,7 @@ async_io (void *arg)\n \n \t\tcase AIO_CLOSE:\n \t\t  NOTE (\"Received AIO_CLOSE\");\n+\t\t  LOCK (&au->lock);\n \t\t  goto finish_thread;\n \n \t\tdefault:\n@@ -175,7 +175,6 @@ async_io (void *arg)\n \t      else if (ctq->type == AIO_CLOSE)\n \t\t{\n \t\t  NOTE (\"Received AIO_CLOSE during error condition\");\n-\t\t  UNLOCK (&au->lock);\n \t\t  goto finish_thread;\n \t\t}\n \t    }\n@@ -189,16 +188,15 @@ async_io (void *arg)\n       au->tail = NULL;\n       au->head = NULL;\n       au->empty = 1;\n-      UNLOCK (&au->lock);\n       SIGNAL (&au->emptysignal);\n-      LOCK (&au->lock);\n     }\n  finish_thread:\n   au->tail = NULL;\n   au->head = NULL;\n   au->empty = 1;\n   SIGNAL (&au->emptysignal);\n   free (ctq);\n+  UNLOCK (&au->lock);\n   return NULL;\n }\n \n@@ -223,7 +221,6 @@ static void\n init_adv_cond (struct adv_cond *ac)\n {\n   ac->pending = 0;\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&ac->lock);\n   __GTHREAD_COND_INIT_FUNCTION (&ac->signal);\n }\n \n@@ -279,8 +276,8 @@ enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)\n   au->tail = tq;\n   REVOKE_SIGNAL (&(au->emptysignal));\n   au->empty = false;\n-  UNLOCK (&au->lock);\n   SIGNAL (&au->work);\n+  UNLOCK (&au->lock);\n }\n \n /* Enqueue an st_write_done or st_read_done which contains an ID.  */\n@@ -303,8 +300,8 @@ enqueue_done_id (async_unit *au, enum aio_do type)\n   au->empty = false;\n   ret = au->id.high++;\n   NOTE (\"Enqueue id: %d\", ret);\n-  UNLOCK (&au->lock);\n   SIGNAL (&au->work);\n+  UNLOCK (&au->lock);\n   return ret;\n }\n \n@@ -324,8 +321,8 @@ enqueue_done (async_unit *au, enum aio_do type)\n   au->tail = tq;\n   REVOKE_SIGNAL (&(au->emptysignal));\n   au->empty = false;\n-  UNLOCK (&au->lock);\n   SIGNAL (&au->work);\n+  UNLOCK (&au->lock);\n }\n \n /* Enqueue a CLOSE statement.  */\n@@ -344,8 +341,8 @@ enqueue_close (async_unit *au)\n   au->tail = tq;\n   REVOKE_SIGNAL (&(au->emptysignal));\n   au->empty = false;\n-  UNLOCK (&au->lock);\n   SIGNAL (&au->work);\n+  UNLOCK (&au->lock);\n }\n \n /* The asynchronous unit keeps the currently active PDT around.\n@@ -374,9 +371,9 @@ enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)\n     au->tail->next = tq;\n   au->tail = tq;\n   REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = 0;\n-  UNLOCK (&au->lock);\n+  au->empty = false;\n   SIGNAL (&au->work);\n+  UNLOCK (&au->lock);\n }\n \n /* Collect the errors that may have happened asynchronously.  Return true if\n@@ -430,9 +427,7 @@ async_wait_id (st_parameter_common *cmp, async_unit *au, int i)\n   NOTE (\"Waiting for id %d\", i);\n   if (au->id.waiting < i)\n     au->id.waiting = i;\n-  UNLOCK (&au->lock);\n   SIGNAL (&(au->work));\n-  LOCK (&au->lock);\n   WAIT_SIGNAL_MUTEX (&(au->id.done),\n \t\t     (au->id.low >= au->id.waiting || au->empty), &au->lock);\n   LOCK (&au->lock);\n@@ -454,8 +449,8 @@ async_wait (st_parameter_common *cmp, async_unit *au)\n   if (cmp == NULL)\n     cmp = au->error.cmp;\n \n-  SIGNAL (&(au->work));\n   LOCK (&(au->lock));\n+  SIGNAL (&(au->work));\n \n   if (au->empty)\n     {"}, {"sha": "17d303c127b1a0dfee85568b96200417c5f3bcff", "filename": "libgfortran/io/async.h", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2Fio%2Fasync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe1910509e32d611b3a7b8503502103bc53b5e4/libgfortran%2Fio%2Fasync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.h?ref=3fe1910509e32d611b3a7b8503502103bc53b5e4", "patch": "@@ -229,44 +229,44 @@\n \n #if ASYNC_IO\n \n+/* au->lock has to be held when calling this macro.  */\n+\n #define SIGNAL(advcond) do{\t\t\t\t\t\t\\\n-    INTERN_LOCK (&(advcond)->lock);\t\t\t\t\t\\\n     (advcond)->pending = 1;\t\t\t\t\t\t\\\n     DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"SIGNAL: \" DEBUG_NORM \\\n \t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n-    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);\t\t\\\n-    INTERN_UNLOCK (&(advcond)->lock);\t\t\t\t\t\\\n+    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);\t\t\t\\\n   } while (0)\n \n+/* Has to be entered with mutex locked.  */\n+\n #define WAIT_SIGNAL_MUTEX(advcond, condition, mutex) do{\t\t\\\n     __label__ finish;\t\t       \t\t\t\t\t\\\n-    INTERN_LOCK (&((advcond)->lock));\t\t\t\t\t\\\n     DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_BLUE \"WAITING: \" DEBUG_NORM \\\n \t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n-    if ((advcond)->pending || (condition)){\t\t\t\t\\\n-      UNLOCK (mutex);\t\t\t\t\t\t\t\\\n+    if ((advcond)->pending || (condition))\t\t\t\t\\\n       goto finish;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    UNLOCK (mutex);\t\t\t\t\t\t\t\\\n-     while (!__gthread_cond_wait(&(advcond)->signal, &(advcond)->lock)) {\t\\\n-       { int cond;\t\t\t\t\t\t\t\\\n-\t LOCK (mutex); cond = condition; UNLOCK (mutex);\t\\\n-\t   if (cond){\t\t\t\t\t\t\t\\\n-\t     DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"REC: \" DEBUG_NORM \\\n-\t\t  #advcond,  __FUNCTION__, __LINE__, (void *)advcond);\t\\\n-\t   break;\t\t\t\t      \t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n+    while (1)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint err_ret = __gthread_cond_wait(&(advcond)->signal, mutex);\t\\\n+\tif (err_ret) internal_error (NULL, \"WAIT_SIGNAL_MUTEX failed\");\t\\\n+\tif (condition)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \\\n+\t\t\t  \"REC: \" DEBUG_NORM\t\t\t\t\\\n+\t\t\t  #advcond,  __FUNCTION__, __LINE__, (void *)advcond); \\\n+\t    break;\t\t\t\t      \t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n   finish:\t\t\t\t\t\t\t\t\\\n-\t\t (advcond)->pending = 0;\t\t\t\t\\\n-\t\t INTERN_UNLOCK (&((advcond)->lock));\t\t\t\\\n-\t\t } while (0)\n+    (advcond)->pending = 0;\t\t\t\t\t\t\\\n+    UNLOCK (mutex);\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* au->lock has to be held when calling this macro.  */\n \n #define REVOKE_SIGNAL(advcond) do{\t\t\\\n-    INTERN_LOCK (&(advcond)->lock);\t\t\\\n     (advcond)->pending = 0;\t\t\t\\\n-    INTERN_UNLOCK (&(advcond)->lock);\t\t\\\n   } while (0)\n \n #else\n@@ -330,7 +330,6 @@ struct adv_cond\n {\n #if ASYNC_IO\n   int pending;\n-  __gthread_mutex_t lock;\n   __gthread_cond_t signal;\n #endif\n };"}]}