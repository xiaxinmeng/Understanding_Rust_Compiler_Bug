{"sha": "9a90b311f22956addaf4f5f9bdb3592afd45083f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE5MGIzMTFmMjI5NTZhZGRhZjRmNWY5YmRiMzU5MmFmZDQ1MDgzZg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-01T01:09:44Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-07T02:25:07Z"}, "message": "Fix _mm256_zeroupper by representing the instructions as call_insns in which the call has a special vzeroupper ABI.\n\nWhen __builtin_ia32_vzeroupper is called explicitly, the corresponding\nvzeroupper pattern does not carry any CLOBBERS or SETs before LRA,\nwhich leads to incorrect optimization in pass_reload. In order to\nsolve this problem, this patch refine instructions as call_insns in\nwhich the call has a special vzeroupper ABI.\n\ngcc/ChangeLog:\n\n\tPR target/82735\n\t* config/i386/i386-expand.c (ix86_expand_builtin): Remove\n\tassignment of cfun->machine->has_explicit_vzeroupper.\n\t* config/i386/i386-features.c\n\t(ix86_add_reg_usage_to_vzerouppers): Delete.\n\t(ix86_add_reg_usage_to_vzeroupper): Ditto.\n\t(rest_of_handle_insert_vzeroupper): Remove\n\tix86_add_reg_usage_to_vzerouppers, add df_analyze at the end\n\tof the function.\n\t(gate): Remove cfun->machine->has_explicit_vzeroupper.\n\t* config/i386/i386-protos.h (ix86_expand_avx_vzeroupper):\n\tDeclared.\n\t* config/i386/i386.c (ix86_insn_callee_abi): New function.\n\t(ix86_initialize_callee_abi): Ditto.\n\t(ix86_expand_avx_vzeroupper): Ditto.\n\t(ix86_hard_regno_call_part_clobbered): Adjust for vzeroupper\n\tABI.\n\t(TARGET_INSN_CALLEE_ABI): Define as ix86_insn_callee_abi.\n\t(ix86_emit_mode_set): Call ix86_expand_avx_vzeroupper\n\tdirectly.\n\t* config/i386/i386.h (struct GTY(()) machine_function): Delete\n\thas_explicit_vzeroupper.\n\t* config/i386/i386.md (enum unspec): New member\n\tUNSPEC_CALLEE_ABI.\n\t(ABI_DEFAULT,ABI_VZEROUPPER,ABI_UNKNOWN): New\n\tdefine_constants for insn callee abi index.\n\t* config/i386/predicates.md (vzeroupper_pattern): Adjust.\n\t* config/i386/sse.md (UNSPECV_VZEROUPPER): Deleted.\n\t(avx_vzeroupper): Call ix86_expand_avx_vzeroupper.\n\t(*avx_vzeroupper): Rename to ..\n\t(avx_vzeroupper_callee_abi): .. this, and adjust pattern as\n\tcall_insn which has a special vzeroupper ABI.\n\t(*avx_vzeroupper_1): Deleted.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/82735\n\t* gcc.target/i386/pr82735-1.c: New test.\n\t* gcc.target/i386/pr82735-2.c: New test.\n\t* gcc.target/i386/pr82735-3.c: New test.\n\t* gcc.target/i386/pr82735-4.c: New test.\n\t* gcc.target/i386/pr82735-5.c: New test.", "tree": {"sha": "5a13931e235551b3b9b33235929ca269d4ba0cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a13931e235551b3b9b33235929ca269d4ba0cb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a90b311f22956addaf4f5f9bdb3592afd45083f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a90b311f22956addaf4f5f9bdb3592afd45083f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a90b311f22956addaf4f5f9bdb3592afd45083f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a90b311f22956addaf4f5f9bdb3592afd45083f/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd"}], "stats": {"total": 395, "additions": 252, "deletions": 143}, "files": [{"sha": "fb0676f11589e6787493a0cc7438c283f9da6d3d", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -13310,10 +13310,6 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \n       return 0;\n \n-    case IX86_BUILTIN_VZEROUPPER:\n-      cfun->machine->has_explicit_vzeroupper = true;\n-      break;\n-\n     default:\n       break;\n     }"}, {"sha": "a25769ae478ebd1f1c292af3e1e1be1cd8e3983e", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 13, "deletions": 86, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -1768,92 +1768,22 @@ convert_scalars_to_vector (bool timode_p)\n   return 0;\n }\n \n-/* Modify the vzeroupper pattern in INSN so that it describes the effect\n-   that the instruction has on the SSE registers.  LIVE_REGS are the set\n-   of registers that are live across the instruction.\n-\n-   For a live register R we use:\n-\n-     (set (reg:V2DF R) (reg:V2DF R))\n-\n-   which preserves the low 128 bits but clobbers the upper bits.  */\n-\n-static void\n-ix86_add_reg_usage_to_vzeroupper (rtx_insn *insn, bitmap live_regs)\n-{\n-  rtx pattern = PATTERN (insn);\n-  unsigned int nregs = TARGET_64BIT ? 16 : 8;\n-  unsigned int npats = nregs;\n-  for (unsigned int i = 0; i < nregs; ++i)\n-    {\n-      unsigned int regno = GET_SSE_REGNO (i);\n-      if (!bitmap_bit_p (live_regs, regno))\n-\tnpats--;\n-    }\n-  if (npats == 0)\n-    return;\n-  rtvec vec = rtvec_alloc (npats + 1);\n-  RTVEC_ELT (vec, 0) = XVECEXP (pattern, 0, 0);\n-  for (unsigned int i = 0, j = 0; i < nregs; ++i)\n-    {\n-      unsigned int regno = GET_SSE_REGNO (i);\n-      if (!bitmap_bit_p (live_regs, regno))\n-\tcontinue;\n-      rtx reg = gen_rtx_REG (V2DImode, regno);\n-      ++j;\n-      RTVEC_ELT (vec, j) = gen_rtx_SET (reg, reg);\n-    }\n-  XVEC (pattern, 0) = vec;\n-  INSN_CODE (insn) = -1;\n-  df_insn_rescan (insn);\n-}\n-\n-/* Walk the vzeroupper instructions in the function and annotate them\n-   with the effect that they have on the SSE registers.  */\n-\n-static void\n-ix86_add_reg_usage_to_vzerouppers (void)\n-{\n-  basic_block bb;\n-  rtx_insn *insn;\n-  auto_bitmap live_regs;\n-\n-  df_analyze ();\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bitmap_copy (live_regs, df_get_live_out (bb));\n-      df_simulate_initialize_backwards (bb, live_regs);\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-\t{\n-\t  if (!NONDEBUG_INSN_P (insn))\n-\t    continue;\n-\t  if (vzeroupper_pattern (PATTERN (insn), VOIDmode))\n-\t    ix86_add_reg_usage_to_vzeroupper (insn, live_regs);\n-\t  df_simulate_one_insn_backwards (bb, insn, live_regs);\n-\t}\n-    }\n-}\n-\n static unsigned int\n rest_of_handle_insert_vzeroupper (void)\n {\n-  if (TARGET_VZEROUPPER\n-      && flag_expensive_optimizations\n-      && !optimize_size)\n-    {\n-      /* vzeroupper instructions are inserted immediately after reload to\n-\t account for possible spills from 256bit or 512bit registers.  The pass\n-\t reuses mode switching infrastructure by re-running mode insertion\n-\t pass, so disable entities that have already been processed.  */\n-      for (int i = 0; i < MAX_386_ENTITIES; i++)\n-\tix86_optimize_mode_switching[i] = 0;\n+  /* vzeroupper instructions are inserted immediately after reload to\n+     account for possible spills from 256bit or 512bit registers.  The pass\n+     reuses mode switching infrastructure by re-running mode insertion\n+     pass, so disable entities that have already been processed.  */\n+  for (int i = 0; i < MAX_386_ENTITIES; i++)\n+    ix86_optimize_mode_switching[i] = 0;\n \n-      ix86_optimize_mode_switching[AVX_U128] = 1;\n+  ix86_optimize_mode_switching[AVX_U128] = 1;\n \n-      /* Call optimize_mode_switching.  */\n-      g->get_passes ()->execute_pass_mode_switching ();\n-    }\n-  ix86_add_reg_usage_to_vzerouppers ();\n+  /* Call optimize_mode_switching.  */\n+  g->get_passes ()->execute_pass_mode_switching ();\n+\n+  df_analyze ();\n   return 0;\n }\n \n@@ -1882,11 +1812,8 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return TARGET_AVX\n-\t     && ((TARGET_VZEROUPPER\n-\t\t  && flag_expensive_optimizations\n-\t\t  && !optimize_size)\n-\t\t || cfun->machine->has_explicit_vzeroupper);\n+      return TARGET_AVX && TARGET_VZEROUPPER\n+\t&& flag_expensive_optimizations && !optimize_size;\n     }\n \n   virtual unsigned int execute (function *)"}, {"sha": "e6ac93907779210409deafefe2024e951d5158b5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -216,6 +216,7 @@ extern rtx ix86_split_stack_guard (void);\n extern void ix86_move_vector_high_sse_to_mmx (rtx);\n extern void ix86_split_mmx_pack (rtx[], enum rtx_code);\n extern void ix86_split_mmx_punpck (rtx[], bool);\n+extern void ix86_expand_avx_vzeroupper (void);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);"}, {"sha": "b0d19a61a76c7f240c7f684c7e3cad93f7ac1505", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -14426,7 +14426,7 @@ ix86_emit_mode_set (int entity, int mode, int prev_mode ATTRIBUTE_UNUSED,\n       break;\n     case AVX_U128:\n       if (mode == AVX_U128_CLEAN)\n-\temit_insn (gen_avx_vzeroupper ());\n+\tix86_expand_avx_vzeroupper ();\n       break;\n     case I387_ROUNDEVEN:\n     case I387_TRUNC:\n@@ -19497,15 +19497,63 @@ ix86_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_INSN_CALLEE_ABI.  */\n+\n+const predefined_function_abi &\n+ix86_insn_callee_abi (const rtx_insn *insn)\n+{\n+  unsigned int abi_id = 0;\n+  rtx pat = PATTERN (insn);\n+  if (vzeroupper_pattern (pat, VOIDmode))\n+    abi_id = ABI_VZEROUPPER;\n+\n+  return function_abis[abi_id];\n+}\n+\n+/* Initialize function_abis with corresponding abi_id,\n+   currently only handle vzeroupper.  */\n+void\n+ix86_initialize_callee_abi (unsigned int abi_id)\n+{\n+  gcc_assert (abi_id == ABI_VZEROUPPER);\n+  predefined_function_abi &vzeroupper_abi = function_abis[abi_id];\n+  if (!vzeroupper_abi.initialized_p ())\n+    {\n+      HARD_REG_SET full_reg_clobbers;\n+      CLEAR_HARD_REG_SET (full_reg_clobbers);\n+      vzeroupper_abi.initialize (ABI_VZEROUPPER, full_reg_clobbers);\n+    }\n+}\n+\n+void\n+ix86_expand_avx_vzeroupper (void)\n+{\n+  /* Initialize vzeroupper_abi here.  */\n+  ix86_initialize_callee_abi (ABI_VZEROUPPER);\n+  rtx_insn *insn = emit_call_insn (gen_avx_vzeroupper_callee_abi ());\n+  /* Return false for non-local goto in can_nonlocal_goto.  */\n+  make_reg_eh_region_note (insn, 0, INT_MIN);\n+  /* Flag used for call_insn indicates it's a fake call.  */\n+  RTX_FLAG (insn, used) = 1;\n+}\n+\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The only ABI that\n    saves SSE registers across calls is Win64 (thus no need to check the\n    current ABI here), and with AVX enabled Win64 only guarantees that\n    the low 16 bytes are saved.  */\n \n static bool\n-ix86_hard_regno_call_part_clobbered (unsigned int, unsigned int regno,\n+ix86_hard_regno_call_part_clobbered (unsigned int abi_id, unsigned int regno,\n \t\t\t\t     machine_mode mode)\n {\n+  /* Special ABI for vzeroupper which only clobber higher part of sse regs.  */\n+  if (abi_id == ABI_VZEROUPPER)\n+      return (GET_MODE_SIZE (mode) > 16\n+\t      && ((TARGET_64BIT\n+\t\t   && (IN_RANGE (regno, FIRST_REX_SSE_REG, LAST_REX_SSE_REG)))\n+\t\t  || (IN_RANGE (regno, FIRST_SSE_REG, LAST_SSE_REG))));\n+\n   return SSE_REGNO_P (regno) && GET_MODE_SIZE (mode) > 16;\n }\n \n@@ -23926,6 +23974,9 @@ ix86_run_selftests (void)\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   ix86_hard_regno_call_part_clobbered\n \n+#undef TARGET_INSN_CALLEE_ABI\n+#define TARGET_INSN_CALLEE_ABI ix86_insn_callee_abi\n+\n #undef TARGET_CAN_CHANGE_MODE_CLASS\n #define TARGET_CAN_CHANGE_MODE_CLASS ix86_can_change_mode_class\n "}, {"sha": "919d0b2418ac2dd53eeb3251f2a7697273370bc3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -2659,10 +2659,6 @@ struct GTY(()) machine_function {\n   /* True if the function needs a stack frame.  */\n   BOOL_BITFIELD stack_frame_required : 1;\n \n-  /* True if __builtin_ia32_vzeroupper () has been expanded in current\n-     function.  */\n-  BOOL_BITFIELD has_explicit_vzeroupper : 1;\n-\n   /* True if we should act silently, rather than raise an error for\n      invalid calls.  */\n   BOOL_BITFIELD silent_p : 1;"}, {"sha": "5ff49ec2f1c78117630b544d9483f4b2923f0d93", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -191,6 +191,10 @@\n   ;; For MOVDIRI and MOVDIR64B support\n   UNSPEC_MOVDIRI\n   UNSPEC_MOVDIR64B\n+\n+  ;; For insn_callee_abi:\n+  UNSPEC_CALLEE_ABI\n+\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -447,6 +451,12 @@\n    (FIRST_PSEUDO_REG\t\t76)\n   ])\n \n+;; Insn callee abi index.\n+(define_constants\n+  [(ABI_DEFAULT\t\t0)\n+   (ABI_VZEROUPPER\t1)\n+   (ABI_UNKNOWN\t\t2)])\n+\n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n ;; from i386.c.\n "}, {"sha": "3dd134e7f223ec3dc4f671ba04fa941c31692730", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -1596,8 +1596,9 @@\n ;; return true if OP is a vzeroupper pattern.\n (define_predicate \"vzeroupper_pattern\"\n   (and (match_code \"parallel\")\n-       (match_code \"unspec_volatile\" \"a\")\n-       (match_test \"XINT (XVECEXP (op, 0, 0), 1) == UNSPECV_VZEROUPPER\")))\n+       (match_code \"unspec\" \"b\")\n+       (match_test \"XINT (XVECEXP (op, 0, 1), 1) == UNSPEC_CALLEE_ABI\")\n+       (match_test \"INTVAL (XVECEXP (XVECEXP (op, 0, 1), 0, 0)) == ABI_VZEROUPPER\")))\n \n ;; Return true if OP is an addsub vec_merge operation\n (define_predicate \"addsub_vm_operator\""}, {"sha": "9fc1176107b374164a4fdc39c11c73afe929a307", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -205,7 +205,6 @@\n   UNSPECV_MONITOR\n   UNSPECV_MWAIT\n   UNSPECV_VZEROALL\n-  UNSPECV_VZEROUPPER\n \n   ;; For KEYLOCKER\n   UNSPECV_LOADIWKEY\n@@ -20872,14 +20871,22 @@\n ;; if the upper 128bits are unused.  Initially we expand the instructions\n ;; as though they had no effect on the SSE registers, but later add SETs and\n ;; CLOBBERs to the PARALLEL to model the real effect.\n+\n (define_expand \"avx_vzeroupper\"\n-  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n-  \"TARGET_AVX\")\n+  [(parallel [(call (mem:QI (const_int 0))\n+\t\t    (const_int 0))\n+\t     (unspec [(const_int ABI_VZEROUPPER)] UNSPEC_CALLEE_ABI)])]\n+  \"TARGET_AVX\"\n+{\n+  ix86_expand_avx_vzeroupper ();\n+  DONE;\n+})\n \n-(define_insn \"*avx_vzeroupper\"\n-  [(match_parallel 0 \"vzeroupper_pattern\"\n-     [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n-  \"TARGET_AVX && XVECLEN (operands[0], 0) == (TARGET_64BIT ? 16 : 8) + 1\"\n+(define_insn \"avx_vzeroupper_callee_abi\"\n+  [(call (mem:QI (const_int 0))\n+\t (const_int 0))\n+    (unspec [(const_int ABI_VZEROUPPER)] UNSPEC_CALLEE_ABI)]\n+  \"TARGET_AVX\"\n   \"vzeroupper\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"modrm\" \"0\")\n@@ -20888,44 +20895,6 @@\n    (set_attr \"btver2_decode\" \"vector\")\n    (set_attr \"mode\" \"OI\")])\n \n-(define_insn_and_split \"*avx_vzeroupper_1\"\n-  [(match_parallel 0 \"vzeroupper_pattern\"\n-     [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n-  \"TARGET_AVX && XVECLEN (operands[0], 0) != (TARGET_64BIT ? 16 : 8) + 1\"\n-  \"#\"\n-  \"&& epilogue_completed\"\n-  [(match_dup 0)]\n-{\n-  /* For IPA-RA purposes, make it clear the instruction clobbers\n-     even XMM registers not mentioned explicitly in the pattern.  */\n-  unsigned int nregs = TARGET_64BIT ? 16 : 8;\n-  unsigned int npats = XVECLEN (operands[0], 0);\n-  rtvec vec = rtvec_alloc (nregs + 1);\n-  RTVEC_ELT (vec, 0) = XVECEXP (operands[0], 0, 0);\n-  for (unsigned int i = 0, j = 1; i < nregs; ++i)\n-    {\n-      unsigned int regno = GET_SSE_REGNO (i);\n-      if (j < npats\n-\t  && REGNO (SET_DEST (XVECEXP (operands[0], 0, j))) == regno)\n-\t{\n-\t  RTVEC_ELT (vec, i + 1) = XVECEXP (operands[0], 0, j);\n-\t  j++;\n-\t}\n-      else\n-\t{\n-\t  rtx reg = gen_rtx_REG (V2DImode, regno);\n-\t  RTVEC_ELT (vec, i + 1) = gen_rtx_CLOBBER (VOIDmode, reg);\n-\t}\n-    }\n-  operands[0] = gen_rtx_PARALLEL (VOIDmode, vec);\n-}\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"memory\" \"none\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"btver2_decode\" \"vector\")\n-   (set_attr \"mode\" \"OI\")])\n-\n (define_mode_attr pbroadcast_evex_isa\n   [(V64QI \"avx512bw\") (V32QI \"avx512bw\") (V16QI \"avx512bw\")\n    (V32HI \"avx512bw\") (V16HI \"avx512bw\") (V8HI \"avx512bw\")"}, {"sha": "1a63b9ae9c9aeca18cceaa94efc46e1db5e5b98d", "filename": "gcc/testsuite/gcc.target/i386/pr82735-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-1.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#include \"avx-check.h\"\n+\n+void\n+__attribute__ ((noipa))\n+mtest(char *dest)\n+{\n+  __m256i ymm1 = _mm256_set1_epi8((char)0x1);\n+  _mm256_storeu_si256((__m256i *)(dest + 32), ymm1);\n+  _mm256_zeroupper();\n+  __m256i ymm2 = _mm256_set1_epi8((char)0x1);\n+  _mm256_storeu_si256((__m256i *)dest, ymm2);\n+}\n+\n+void\n+avx_test ()\n+{\n+  char buf[64];\n+  for (int i = 0; i != 64; i++)\n+    buf[i] = 2;\n+  mtest (buf);\n+\n+  for (int i = 0; i < 32; ++i)\n+    if (buf[i] != 1)\n+      __builtin_abort ();\n+}"}, {"sha": "ac9d006f79430d12a205da811c2e5e724e381cc6", "filename": "gcc/testsuite/gcc.target/i386/pr82735-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-2.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx -O2\" } */\n+\n+#include <immintrin.h>\n+\n+void test(char *dest)\n+{\n+  /* xmm1 can be propagated to xmm2 by CSE.  */\n+  __m128i xmm1 = _mm_set_epi8(0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,\n+\t\t\t      0x9, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16);\n+  _mm_storeu_si128((__m128i *)(dest + 32), xmm1);\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  __m128i xmm2 = xmm1;\n+  _mm_storeu_si128((__m128i *)dest, xmm2);\n+}\n+\n+/* Darwin local constant symbol is \"lC0\", ELF targets \".LC0\" */\n+/* { dg-final { scan-assembler-times {(?n)vmovdqa\\t\\.?[Ll]C0[^,]*, %xmm[0-9]} 1 } } */"}, {"sha": "e3f801e69243798f55d7f6bbfa3018d421248719", "filename": "gcc/testsuite/gcc.target/i386/pr82735-3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-3.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx -O2 -mabi=ms\" } */\n+/* { dg-final { scan-assembler-not {(?n)xmm([6-9]|1[0-5])} } } */\n+\n+#include \"pr82735-2.c\""}, {"sha": "78c0a6cb2c8cbe3fafa8781da90d688ebf38ae14", "filename": "gcc/testsuite/gcc.target/i386/pr82735-4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-4.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile { target { ! ia32 } } }  */\n+/* { dg-options \"-mavx -O2 -mabi=ms -mno-avx512f -masm=att\" } */\n+/* { dg-final { scan-assembler-times {(?n)(?:vmovdqa[1-9]*|vmovap[sd])[\\t ]*%xmm[0-9]+, [0-9]*\\(%rsp\\)} 10 } } */\n+/* { dg-final { scan-assembler-times {(?n)(?:vmovdqa[1-9]*|vmovap[sd])[\\t ]*[0-9]*\\(%rsp\\), %xmm[0-9]+} 10 } } */\n+\n+#include <immintrin.h>\n+\n+void test(char *dest)\n+{\n+  __m256i ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9, ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;\n+  asm volatile (\"vmovdqa\\t%%ymm0, %0\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %1\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %2\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %3\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %4\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %5\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %6\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %7\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %8\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %9\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %10\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %11\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %12\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %13\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %14\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %15\\n\\t\"\n+\t\t: \"=v\" (ymm1), \"=v\" (ymm2), \"=v\"(ymm3), \"=v\" (ymm4), \"=v\" (ymm5),\n+\t\t  \"=v\" (ymm6), \"=v\" (ymm7), \"=v\"(ymm8), \"=v\" (ymm9), \"=v\" (ymm10),\n+\t\t  \"=v\" (ymm11), \"=v\" (ymm12), \"=v\"(ymm13), \"=v\" (ymm14), \"=v\" (ymm15),\n+\t\t  \"=v\"(ymm0)\n+\t\t::);\n+  _mm256_zeroupper();\n+  _mm256_storeu_si256((__m256i *)dest, ymm1);\n+  _mm256_storeu_si256((__m256i *)(dest + 32), ymm2);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 2), ymm3);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 3), ymm4);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 4), ymm5);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 5), ymm6);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 6), ymm7);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 7), ymm8);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 8), ymm9);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 9), ymm10);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 10), ymm11);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 11), ymm12);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 12), ymm13);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 13), ymm14);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 14), ymm15);\n+}"}, {"sha": "2a58cbe52d0c4c3b149a015a0a8ef35148b0e933", "filename": "gcc/testsuite/gcc.target/i386/pr82735-5.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a90b311f22956addaf4f5f9bdb3592afd45083f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82735-5.c?ref=9a90b311f22956addaf4f5f9bdb3592afd45083f", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile { target { ! ia32 } } }  */\n+/* { dg-options \"-mavx -O2 -mabi=ms -mno-avx512f -masm=att\" } */\n+/* { dg-final { scan-assembler-times {(?n)(?:vmovdqa[1-9]*|vmovap[sd])[\\t ]*%xmm[0-9]+, [0-9]*\\(%rsp\\)} 10 } } */\n+/* { dg-final { scan-assembler-times {(?n)(?:vmovdqa[1-9]*|vmovap[sd])[\\t ]*[0-9]*\\(%rsp\\), %xmm[0-9]+} 10 } } */\n+\n+#include <immintrin.h>\n+\n+void test(char *dest)\n+{\n+  __m256i ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9, ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;\n+  asm volatile (\"vmovdqa\\t%%ymm0, %0\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %1\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %2\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %3\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %4\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %5\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %6\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %7\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %8\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %9\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %10\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %11\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %12\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %13\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %14\\n\\t\"\n+\t\t\"vmovdqa\\t%%ymm0, %15\\n\\t\"\n+\t\t: \"=v\" (ymm1), \"=v\" (ymm2), \"=v\"(ymm3), \"=v\" (ymm4), \"=v\" (ymm5),\n+\t\t  \"=v\" (ymm6), \"=v\" (ymm7), \"=v\"(ymm8), \"=v\" (ymm9), \"=v\" (ymm10),\n+\t\t  \"=v\" (ymm11), \"=v\" (ymm12), \"=v\"(ymm13), \"=v\" (ymm14), \"=v\" (ymm15),\n+\t\t  \"=v\"(ymm0)\n+\t\t::);\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_zeroupper();\n+  _mm256_storeu_si256((__m256i *)dest, ymm1);\n+  _mm256_storeu_si256((__m256i *)(dest + 32), ymm2);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 2), ymm3);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 3), ymm4);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 4), ymm5);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 5), ymm6);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 6), ymm7);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 7), ymm8);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 8), ymm9);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 9), ymm10);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 10), ymm11);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 11), ymm12);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 12), ymm13);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 13), ymm14);\n+  _mm256_storeu_si256((__m256i *)(dest + 32 * 14), ymm15);\n+}"}]}