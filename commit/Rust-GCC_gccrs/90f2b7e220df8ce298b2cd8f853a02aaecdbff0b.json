{"sha": "90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBmMmI3ZTIyMGRmOGNlMjk4YjJjZDhmODUzYTAyYWFlY2RiZmYwYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-13T09:32:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-13T09:32:29Z"}, "message": "Make more use of byte_lowpart_offset\n\nThis patch uses byte_lowpart_offset in places that open-coded the\ncalculation.\n\n2017-10-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* caller-save.c (replace_reg_with_saved_mem): Use byte_lowpart_offset.\n\t* combine.c (gen_lowpart_for_combine): Likewise.\n\t* dwarf2out.c (rtl_for_decl_location): Likewise.\n\t* final.c (alter_subreg): Likewise.\n\t* rtlhooks.c (gen_lowpart_general): Likewise.\n\t(gen_lowpart_if_possible): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r253714", "tree": {"sha": "e6e6b7a6cd37b119b1118babd9d53aa30d191bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6e6b7a6cd37b119b1118babd9d53aa30d191bde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/comments", "author": null, "committer": null, "parents": [{"sha": "610c45fcbfff43176beefefcea74c6137a432220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c45fcbfff43176beefefcea74c6137a432220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c45fcbfff43176beefefcea74c6137a432220"}], "stats": {"total": 83, "additions": 22, "deletions": 61}, "files": [{"sha": "bdb6bccdb5c35ceed70294145c3901b83e351a81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -1,3 +1,14 @@\n+2017-10-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* caller-save.c (replace_reg_with_saved_mem): Use byte_lowpart_offset.\n+\t* combine.c (gen_lowpart_for_combine): Likewise.\n+\t* dwarf2out.c (rtl_for_decl_location): Likewise.\n+\t* final.c (alter_subreg): Likewise.\n+\t* rtlhooks.c (gen_lowpart_general): Likewise.\n+\t(gen_lowpart_if_possible): Likewise.\n+\n 2017-10-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7c787f751634fbb710df5e18426952d5f2b75cd7", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -1132,17 +1132,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t{\n \t  /* This is gen_lowpart_if_possible(), but without validating\n \t     the newly-formed address.  */\n-\t  int offset = 0;\n-\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    offset = (MAX (GET_MODE_SIZE (GET_MODE (mem)), UNITS_PER_WORD)\n-\t\t      - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    /* Adjust the address so that the address-after-the-data is\n-\t       unchanged.  */\n-\t    offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (mem))));\n-\n+\t  HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (mem));\n \t  mem = adjust_address_nv (mem, mode, offset);\n \t}\n     }"}, {"sha": "4d2f79b3d71f8be697467983884e1f1ff604c082", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -11618,8 +11618,6 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n \n   if (MEM_P (x))\n     {\n-      int offset = 0;\n-\n       /* Refuse to work on a volatile memory ref or one with a mode-dependent\n \t address.  */\n       if (MEM_VOLATILE_P (x)\n@@ -11632,14 +11630,7 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n       if (paradoxical_subreg_p (omode, imode))\n \treturn gen_rtx_SUBREG (omode, x, 0);\n \n-      if (WORDS_BIG_ENDIAN)\n-\toffset = MAX (isize, UNITS_PER_WORD) - MAX (osize, UNITS_PER_WORD);\n-\n-      /* Adjust the address so that the address-after-the-data is\n-\t unchanged.  */\n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= MIN (UNITS_PER_WORD, osize) - MIN (UNITS_PER_WORD, isize);\n-\n+      HOST_WIDE_INT offset = byte_lowpart_offset (omode, imode);\n       return adjust_address_nv (x, omode, offset);\n     }\n "}, {"sha": "beab5e4ce8e881d31e541402a40ae75c8a76a491", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -19077,23 +19077,21 @@ rtl_for_decl_location (tree decl)\n   else if (VAR_P (decl)\n \t   && rtl\n \t   && MEM_P (rtl)\n-\t   && GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl))\n-\t   && BYTES_BIG_ENDIAN)\n+\t   && GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl)))\n     {\n       machine_mode addr_mode = get_address_mode (rtl);\n-      int rsize = GET_MODE_SIZE (GET_MODE (rtl));\n-      int dsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl)));\n+      HOST_WIDE_INT offset = byte_lowpart_offset (TYPE_MODE (TREE_TYPE (decl)),\n+\t\t\t\t\t\t  GET_MODE (rtl));\n \n       /* If a variable is declared \"register\" yet is smaller than\n \t a register, then if we store the variable to memory, it\n \t looks like we're storing a register-sized value, when in\n \t fact we are not.  We need to adjust the offset of the\n \t storage location to reflect the actual value's bytes,\n \t else gdb will not be able to display it.  */\n-      if (rsize > dsize)\n+      if (offset != 0)\n \trtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),\n-\t\t\t   plus_constant (addr_mode, XEXP (rtl, 0),\n-\t\t\t\t\t  rsize - dsize));\n+\t\t\t   plus_constant (addr_mode, XEXP (rtl, 0), offset));\n     }\n \n   /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,"}, {"sha": "0ddf7793209bc6ede4e1723dd192a42cb458a475", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -3199,14 +3199,7 @@ alter_subreg (rtx *xp, bool final_p)\n       /* For paradoxical subregs on big-endian machines, SUBREG_BYTE\n \t contains 0 instead of the proper offset.  See simplify_subreg.  */\n       if (paradoxical_subreg_p (x))\n-        {\n-          int difference = GET_MODE_SIZE (GET_MODE (y))\n-\t\t\t   - GET_MODE_SIZE (GET_MODE (x));\n-          if (WORDS_BIG_ENDIAN)\n-            offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-          if (BYTES_BIG_ENDIAN)\n-            offset += difference % UNITS_PER_WORD;\n-        }\n+\toffset = byte_lowpart_offset (GET_MODE (x), GET_MODE (y));\n \n       if (final_p)\n \t*xp = adjust_address (y, GET_MODE (x), offset);"}, {"sha": "d20815e255b712b7dabf53a39ef90e6e75569d56", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f2b7e220df8ce298b2cd8f853a02aaecdbff0b/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=90f2b7e220df8ce298b2cd8f853a02aaecdbff0b", "patch": "@@ -59,8 +59,6 @@ gen_lowpart_general (machine_mode mode, rtx x)\n     }\n   else\n     {\n-      int offset = 0;\n-\n       /* The only additional case we can do is MEM.  */\n       gcc_assert (MEM_P (x));\n \n@@ -72,16 +70,7 @@ gen_lowpart_general (machine_mode mode, rtx x)\n \t  && !reload_completed)\n \treturn gen_lowpart_general (mode, force_reg (xmode, x));\n \n-      if (WORDS_BIG_ENDIAN)\n-\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n-\n-      if (BYTES_BIG_ENDIAN)\n-\t/* Adjust the address so that the address-after-the-data\n-\t   is unchanged.  */\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-\n+      HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (x));\n       return adjust_address (x, mode, offset);\n     }\n }\n@@ -126,19 +115,8 @@ gen_lowpart_if_possible (machine_mode mode, rtx x)\n   else if (MEM_P (x))\n     {\n       /* This is the only other case we handle.  */\n-      int offset = 0;\n-      rtx new_rtx;\n-\n-      if (WORDS_BIG_ENDIAN)\n-\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n-      if (BYTES_BIG_ENDIAN)\n-\t/* Adjust the address so that the address-after-the-data is\n-\t   unchanged.  */\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-\n-      new_rtx = adjust_address_nv (x, mode, offset);\n+      HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (x));\n+      rtx new_rtx = adjust_address_nv (x, mode, offset);\n       if (! memory_address_addr_space_p (mode, XEXP (new_rtx, 0),\n \t\t\t\t\t MEM_ADDR_SPACE (x)))\n \treturn 0;"}]}