{"sha": "1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwNjU5NTQ2YmNmNWI5NWMzMjYzY2RjNzMxNDlmNmMyYTA1ZWJlMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-12-15T20:46:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-15T20:46:37Z"}, "message": "nvptx.c (write_one_arg): Rename to ...\n\n\t* config/nvptx/nvptx.c (write_one_arg): Rename to ...\n\t(write_arg_mode): ... here.  Update callers.\n\t(write_arg): Rename to ...\n\t(write__arg_type): ... here.  Update callers.\n\t(write_return_mode): New fn, broken out of ...\n\t(write_return): ... here.  Rename to ...\n\t(write_return_type): ... here.  Call it. Update callers.\n\t(write_fn_proto_from_insn): Use write_arg_mode and\n\twrite_return_mode.\n\t(init_frame): New fn.\n\t(nvptx_declare_function_name): Call it for frame and varargs. Only\n\temit outgoing static chain, if it's live.\n\t(nvptx_output_return): Use reg_names for return reg name.\n\t(nvptx_output_call_insn): Likewise.\n\t(nvptx_reorg): Mark unused hard regs too.\n\nFrom-SVN: r231663", "tree": {"sha": "d0a23bb9a9a7efb5ef9976ff502db9fbb183f3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a23bb9a9a7efb5ef9976ff502db9fbb183f3a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b110e777bd7dbccc5e73a7955263c4c969155a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b110e777bd7dbccc5e73a7955263c4c969155a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b110e777bd7dbccc5e73a7955263c4c969155a16"}], "stats": {"total": 191, "additions": 111, "deletions": 80}, "files": [{"sha": "f48dfe74b0cc645c0b47a6dca8a857348239154a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "patch": "@@ -1,3 +1,21 @@\n+2015-12-15  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (write_one_arg): Rename to ...\n+\t(write_arg_mode): ... here.  Update callers.\n+\t(write_arg): Rename to ...\n+\t(write__arg_type): ... here.  Update callers.\n+\t(write_return_mode): New fn, broken out of ...\n+\t(write_return): ... here.  Rename to ...\n+\t(write_return_type): ... here.  Call it. Update callers.\n+\t(write_fn_proto_from_insn): Use write_arg_mode and\n+\twrite_return_mode.\n+\t(init_frame): New fn.\n+\t(nvptx_declare_function_name): Call it for frame and varargs. Only\n+\temit outgoing static chain, if it's live.\n+\t(nvptx_output_return): Use reg_names for return reg name.\n+\t(nvptx_output_call_insn): Likewise.\n+\t(nvptx_reorg): Mark unused hard regs too.\n+\n 2015-12-15  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.md (nvptx_register_operand): Don't accept and"}, {"sha": "0700937c8152710262e02d935b2a637541015454", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "patch": "@@ -569,7 +569,8 @@ nvptx_static_chain (const_tree fndecl, bool incoming_p)\n    copying to a specific hard register.  */\n \n static int\n-write_one_arg (std::stringstream &s, int for_reg, int argno, machine_mode mode)\n+write_arg_mode (std::stringstream &s, int for_reg, int argno,\n+\t\tmachine_mode mode)\n {\n   const char *ptx_type = nvptx_ptx_type_from_mode (mode, false);\n \n@@ -598,16 +599,16 @@ write_one_arg (std::stringstream &s, int for_reg, int argno, machine_mode mode)\n }\n \n /* Process function parameter TYPE to emit one or more PTX\n-   arguments. S, FOR_REG and ARGNO as for write_one_arg.  PROTOTYPED\n+   arguments. S, FOR_REG and ARGNO as for write_arg_mode.  PROTOTYPED\n    is true, if this is a prototyped function, rather than an old-style\n    C declaration.  Returns the next argument number to use.\n \n    The promotion behaviour here must match the regular GCC function\n    parameter marshalling machinery.  */\n \n static int\n-write_arg (std::stringstream &s, int for_reg, int argno,\n-\t   tree type, bool prototyped)\n+write_arg_type (std::stringstream &s, int for_reg, int argno,\n+\t\ttree type, bool prototyped)\n {\n   machine_mode mode = TYPE_MODE (type);\n \n@@ -630,21 +631,35 @@ write_arg (std::stringstream &s, int for_reg, int argno,\n \n       mode = promote_arg (mode, prototyped);\n       if (split)\n-\targno = write_one_arg (s, for_reg, argno, mode);\n+\targno = write_arg_mode (s, for_reg, argno, mode);\n     }\n \n-  return write_one_arg (s, for_reg, argno, mode);\n+  return write_arg_mode (s, for_reg, argno, mode);\n+}\n+\n+/* Emit a PTX return as a prototype or function prologue declaration\n+   for MODE.  */\n+\n+static void\n+write_return_mode (std::stringstream &s, bool for_proto, machine_mode mode)\n+{\n+  const char *ptx_type = nvptx_ptx_type_from_mode (mode, false);\n+  const char *pfx = \"\\t.reg\";\n+  const char *sfx = \";\\n\";\n+  \n+  if (for_proto)\n+    pfx = \"(.param\", sfx = \"_out) \";\n+  \n+  s << pfx << ptx_type << \" \" << reg_names[NVPTX_RETURN_REGNUM] << sfx;\n }\n \n /* Process a function return TYPE to emit a PTX return as a prototype\n-   or function prologue declaration.  DECL_RESULT is the decl result\n-   of the function and needed for determining named result\n-   behaviour. Returns true if return is via an additional pointer\n-   parameter.  The promotion behaviour here must match the regular GCC\n-   function return mashalling.  */\n+   or function prologue declaration.  Returns true if return is via an\n+   additional pointer parameter.  The promotion behaviour here must\n+   match the regular GCC function return mashalling.  */\n \n static bool\n-write_return (std::stringstream &s, bool for_proto, tree type)\n+write_return_type (std::stringstream &s, bool for_proto, tree type)\n {\n   machine_mode mode = TYPE_MODE (type);\n \n@@ -675,11 +690,7 @@ write_return (std::stringstream &s, bool for_proto, tree type)\n   else\n     mode = promote_return (mode);\n \n-  const char *ptx_type  = nvptx_ptx_type_from_mode (mode, false);\n-  if (for_proto)\n-    s << \"(.param\" << ptx_type << \" %out_retval) \";\n-  else\n-    s << \"\\t.reg\" << ptx_type << \" %retval;\\n\";\n+  write_return_mode (s, for_proto, mode);\n \n   return return_in_mem;\n }\n@@ -752,15 +763,15 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n   tree result_type = TREE_TYPE (fntype);\n \n   /* Declare the result.  */\n-  bool return_in_mem = write_return (s, true, result_type);\n+  bool return_in_mem = write_return_type (s, true, result_type);\n \n   s << name;\n \n   int argno = 0;\n \n   /* Emit argument list.  */\n   if (return_in_mem)\n-    argno = write_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, -1, argno, ptr_type_node, true);\n \n   /* We get:\n      NULL in TYPE_ARG_TYPES, for old-style functions\n@@ -779,19 +790,19 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n     {\n       tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n \n-      argno = write_arg (s, -1, argno, type, prototyped);\n+      argno = write_arg_type (s, -1, argno, type, prototyped);\n     }\n \n   if (stdarg_p (fntype))\n-    argno = write_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, -1, argno, ptr_type_node, true);\n \n   if (DECL_STATIC_CHAIN (decl))\n-    argno = write_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, -1, argno, ptr_type_node, true);\n \n   if (!argno && strcmp (name, \"main\") == 0)\n     {\n-      argno = write_arg (s, -1, argno, integer_type_node, true);\n-      argno = write_arg (s, -1, argno, ptr_type_node, true);\n+      argno = write_arg_type (s, -1, argno, integer_type_node, true);\n+      argno = write_arg_type (s, -1, argno, ptr_type_node, true);\n     }\n \n   if (argno)\n@@ -824,28 +835,19 @@ write_fn_proto_from_insn (std::stringstream &s, const char *name,\n     }\n \n   if (result != NULL_RTX)\n-    s << \"(.param\"\n-      << nvptx_ptx_type_from_mode (GET_MODE (result), false)\n-      << \" %rval) \";\n+    write_return_mode (s, true, GET_MODE (result));\n \n   s << name;\n \n-  const char *sep = \" (\";\n   int arg_end = XVECLEN (pat, 0);\n   for (int i = 1; i < arg_end; i++)\n     {\n-      /* We don't have to deal with mode splitting here, as that was\n-\t already done when generating the call sequence.  */\n+      /* We don't have to deal with mode splitting & promotion here,\n+\t as that was already done when generating the call\n+\t sequence.  */\n       machine_mode mode = GET_MODE (XEXP (XVECEXP (pat, 0, i), 0));\n \n-      s << sep\n-\t<< \".param\"\n-\t<< nvptx_ptx_type_from_mode (mode, false)\n-\t<< \" %arg\"\n-\t<< i;\n-      if (mode == QImode || mode == HImode)\n-\ts << \"[1]\";\n-      sep = \", \";\n+      write_arg_mode (s, -1, i - 1, mode);\n     }\n   if (arg_end != 1)\n     s << \")\";\n@@ -914,6 +916,20 @@ nvptx_maybe_record_fnsym (rtx sym)\n     nvptx_record_needed_fndecl (decl);\n }\n \n+/* Emit a local array to hold some part of a conventional stack frame\n+   and initialize REGNO to point to it.  */\n+\n+static void\n+init_frame (FILE  *file, int regno, unsigned align, unsigned size)\n+{\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\"\n+\t   \"\\t.local.align %d .b8 %s_ar[%u];\\n\"\n+\t   \"\\tcvta.local.u%d %s, %s_ar;\\n\",\n+\t   POINTER_SIZE, reg_names[regno],\n+\t   align, reg_names[regno], size ? size : 1,\n+\t   POINTER_SIZE, reg_names[regno], reg_names[regno]);\n+}\n+\n /* Emit code to initialize the REGNO predicate register to indicate\n    whether we are not lane zero on the NAME axis.  */\n \n@@ -944,9 +960,9 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   write_fn_proto (s, true, name, decl);\n   s << \"{\\n\";\n \n-  bool return_in_mem = write_return (s, false, result_type);\n+  bool return_in_mem = write_return_type (s, false, result_type);\n   if (return_in_mem)\n-    argno = write_arg (s, 0, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, 0, argno, ptr_type_node, true);\n   \n   /* Declare and initialize incoming arguments.  */\n   tree args = TYPE_ARG_TYPES (fntype);\n@@ -961,20 +977,22 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n     {\n       tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n \n-      argno = write_arg (s, 0, argno, type, prototyped);\n+      argno = write_arg_type (s, 0, argno, type, prototyped);\n     }\n \n   if (stdarg_p (fntype))\n-    argno = write_arg (s, ARG_POINTER_REGNUM, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, ARG_POINTER_REGNUM, argno, ptr_type_node, true);\n \n   if (DECL_STATIC_CHAIN (decl))\n-    argno = write_arg (s, STATIC_CHAIN_REGNUM, argno, ptr_type_node, true);\n+    argno = write_arg_type (s, STATIC_CHAIN_REGNUM, argno, ptr_type_node,\n+\t\t\t    true);\n \n   fprintf (file, \"%s\", s.str().c_str());\n \n-  fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n-\t   reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n-  \n+  if (regno_reg_rtx[OUTGOING_STATIC_CHAIN_REGNUM] != const0_rtx)\n+    fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n+\t     reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n+\n   /* Declare the pseudos we have as ptx registers.  */\n   int maxregs = max_reg_num ();\n   for (int i = LAST_VIRTUAL_REGISTER + 1; i < maxregs; i++)\n@@ -992,35 +1010,16 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t}\n     }\n \n-  /* The only reason we might be using outgoing args is if we call a stdargs\n-     function.  Allocate the space for this.  If we called varargs functions\n-     without passing any variadic arguments, we'll see a reference to outargs\n-     even with a zero outgoing_args_size.  */\n-  HOST_WIDE_INT sz = crtl->outgoing_args_size;\n-  if (sz == 0)\n-    sz = 1;\n+  /* Declare a local var for outgoing varargs.  */\n   if (cfun->machine->has_call_with_varargs)\n-    {\n-      fprintf (file, \"\\t.reg.u%d %%outargs;\\n\"\n-\t       \"\\t.local.align 8 .b8 %%outargs_ar[\"\n-\t       HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n-\t       BITS_PER_WORD, sz);\n-      fprintf (file, \"\\tcvta.local.u%d %%outargs, %%outargs_ar;\\n\",\n-\t       BITS_PER_WORD);\n-    }\n+    init_frame (file, STACK_POINTER_REGNUM,\n+\t\tUNITS_PER_WORD, crtl->outgoing_args_size);\n \n   /* Declare a local variable for the frame.  */\n-  sz = get_frame_size ();\n-  if (sz > 0 || cfun->machine->has_call_with_sc)\n-    {\n-      int alignment = crtl->stack_alignment_needed / BITS_PER_UNIT;\n-\n-      fprintf (file, \"\\t.reg.u%d %%frame;\\n\"\n-\t       \"\\t.local.align %d .b8 %%farray[\" HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n-\t       BITS_PER_WORD, alignment, sz == 0 ? 1 : sz);\n-      fprintf (file, \"\\tcvta.local.u%d %%frame, %%farray;\\n\",\n-\t       BITS_PER_WORD);\n-    }\n+  HOST_WIDE_INT sz = get_frame_size ();\n+  if (sz || cfun->machine->has_call_with_sc)\n+    init_frame (file, FRAME_POINTER_REGNUM,\n+\t\tcrtl->stack_alignment_needed / BITS_PER_UNIT, sz);\n \n   /* Emit axis predicates. */\n   if (cfun->machine->axis_predicate[0])\n@@ -1040,8 +1039,10 @@ nvptx_output_return (void)\n   machine_mode mode = (machine_mode)cfun->machine->ret_reg_mode;\n \n   if (mode != VOIDmode)\n-    fprintf (asm_out_file, \"\\tst.param%s\\t[%%out_retval], %%retval;\\n\",\n-\t     nvptx_ptx_type_from_mode (mode, false));\n+    fprintf (asm_out_file, \"\\tst.param%s\\t[%s_out], %s;\\n\",\n+\t     nvptx_ptx_type_from_mode (mode, false),\n+\t     reg_names[NVPTX_RETURN_REGNUM],\n+\t     reg_names[NVPTX_RETURN_REGNUM]);\n \n   return \"ret;\";\n }\n@@ -1817,8 +1818,9 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n \n   fprintf (asm_out_file, \"\\t{\\n\");\n   if (result != NULL)\n-    fprintf (asm_out_file, \"\\t\\t.param%s %%retval_in;\\n\",\n-\t     nvptx_ptx_type_from_mode (GET_MODE (result), false));\n+    fprintf (asm_out_file, \"\\t\\t.param%s %s_in;\\n\",\n+\t     nvptx_ptx_type_from_mode (GET_MODE (result), false),\n+\t     reg_names[NVPTX_RETURN_REGNUM]);\n \n   /* Ensure we have a ptx declaration in the output if necessary.  */\n   if (GET_CODE (callee) == SYMBOL_REF)\n@@ -1857,8 +1859,8 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n \n   fprintf (asm_out_file, \"\\t\\tcall \");\n   if (result != NULL_RTX)\n-    fprintf (asm_out_file, \"(%%retval_in), \");\n-\n+    fprintf (asm_out_file, \"(%s_in), \", reg_names[NVPTX_RETURN_REGNUM]);\n+  \n   if (decl)\n     {\n       const char *name = get_fnname_from_decl (decl);\n@@ -1897,7 +1899,18 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n        trap, which it does grok.  */\n     fprintf (asm_out_file, \"\\t\\ttrap; // (noreturn)\\n\");\n \n-  return result != NULL_RTX ? \"\\tld.param%t0\\t%0, [%%retval_in];\\n\\t}\" : \"}\";\n+  if (result)\n+    {\n+      static char rval[sizeof (\"\\tld.param%%t0\\t%%0, [%%%s_in];\\n\\t}\") + 8];\n+\n+      if (!rval[0])\n+\t/* We must escape the '%' that starts RETURN_REGNUM.  */\n+\tsprintf (rval, \"\\tld.param%%t0\\t%%0, [%%%s_in];\\n\\t}\",\n+\t\t reg_names[NVPTX_RETURN_REGNUM]);\n+      return rval;\n+    }\n+\n+  return \"}\";\n }\n \n /* Implement TARGET_PRINT_OPERAND_PUNCT_VALID_P.  */\n@@ -3760,7 +3773,7 @@ nvptx_reorg (void)\n   \n   /* Mark unused regs as unused.  */\n   int max_regs = max_reg_num ();\n-  for (int i = LAST_VIRTUAL_REGISTER + 1; i < max_regs; i++)\n+  for (int i = 0; i < max_regs; i++)\n     if (REG_N_SETS (i) == 0 && REG_N_REFS (i) == 0)\n       regno_reg_rtx[i] = const0_rtx;\n "}]}