{"sha": "d253656a7be7461c2fc7bb638e93b9943a91de9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI1MzY1NmE3YmU3NDYxYzJmYzdiYjYzOGU5M2I5OTQzYTkxZGU5Yg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-03-27T18:56:00Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-03-27T18:56:00Z"}, "message": "Split 32-byte AVX unaligned load/store.\n\ngcc/\n\n2011-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (flag_opts): Add -mavx256-split-unaligned-load\n\tand -mavx256-split-unaligned-store.\n\t(ix86_option_override_internal): Split 32-byte AVX unaligned\n\tload/store by default.\n\t(ix86_avx256_split_vector_move_misalign): New.\n\t(ix86_expand_vector_move_misalign): Use it.\n\n\t* config/i386/i386.opt: Add -mavx256-split-unaligned-load and\n\t-mavx256-split-unaligned-store.\n\n\t* config/i386/sse.md (*avx_mov<mode>_internal): Verify unaligned\n\t256bit load/store.  Generate unaligned store on misaligned memory\n\toperand.\n\t(*avx_movu<ssemodesuffix><avxmodesuffix>): Verify unaligned\n\t256bit load/store.\n\t(*avx_movdqu<avxmodesuffix>): Likewise.\n\n\t* doc/invoke.texi: Document -mavx256-split-unaligned-load and\n\t-mavx256-split-unaligned-store.\n\ngcc/testsuite/\n\n2011-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* gcc.target/i386/avx256-unaligned-load-1.c: New.\n\t* gcc.target/i386/avx256-unaligned-load-2.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-load-3.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-load-4.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-load-5.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-load-6.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-load-7.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-1.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-2.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-3.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-4.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-5.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-6.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-7.c: Likewise.\n\nFrom-SVN: r171578", "tree": {"sha": "6bde920e9a82430f7109eaf06eaa946470377eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bde920e9a82430f7109eaf06eaa946470377eb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d253656a7be7461c2fc7bb638e93b9943a91de9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d253656a7be7461c2fc7bb638e93b9943a91de9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d253656a7be7461c2fc7bb638e93b9943a91de9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d253656a7be7461c2fc7bb638e93b9943a91de9b/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c570af00f629db0876fcdbc5fb7ab12440b11d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c570af00f629db0876fcdbc5fb7ab12440b11d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c570af00f629db0876fcdbc5fb7ab12440b11d16"}], "stats": {"total": 627, "additions": 613, "deletions": 14}, "files": [{"sha": "ca0e3d69ef4a3e14bcf913839b255a2fd11c15dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -1,3 +1,25 @@\n+2011-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (flag_opts): Add -mavx256-split-unaligned-load\n+\tand -mavx256-split-unaligned-store.\n+\t(ix86_option_override_internal): Split 32-byte AVX unaligned\n+\tload/store by default.\n+\t(ix86_avx256_split_vector_move_misalign): New.\n+\t(ix86_expand_vector_move_misalign): Use it.\n+\n+\t* config/i386/i386.opt: Add -mavx256-split-unaligned-load and\n+\t-mavx256-split-unaligned-store.\n+\n+\t* config/i386/sse.md (*avx_mov<mode>_internal): Verify unaligned\n+\t256bit load/store.  Generate unaligned store on misaligned memory\n+\toperand.\n+\t(*avx_movu<ssemodesuffix><avxmodesuffix>): Verify unaligned\n+\t256bit load/store.\n+\t(*avx_movdqu<avxmodesuffix>): Likewise.\n+\n+\t* doc/invoke.texi: Document -mavx256-split-unaligned-load and\n+\t-mavx256-split-unaligned-store.\n+\n 2011-03-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/38598"}, {"sha": "a4ca762228ccb517d33ca9352fdba77cec4ff288", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -3130,6 +3130,8 @@ ix86_target_string (int isa, int flags, const char *arch, const char *tune,\n     { \"-mvect8-ret-in-mem\",\t\tMASK_VECT8_RETURNS },\n     { \"-m8bit-idiv\",\t\t\tMASK_USE_8BIT_IDIV },\n     { \"-mvzeroupper\",\t\t\tMASK_VZEROUPPER },\n+    { \"-mavx256-split-unaligned-load\",\tMASK_AVX256_SPLIT_UNALIGNED_LOAD},\n+    { \"-mavx256-split-unaligned-stroe\",\tMASK_AVX256_SPLIT_UNALIGNED_STORE},\n   };\n \n   const char *opts[ARRAY_SIZE (isa_opts) + ARRAY_SIZE (flag_opts) + 6][2];\n@@ -4274,11 +4276,18 @@ ix86_option_override_internal (bool main_args_p)\n   if (TARGET_AVX)\n     {\n       /* When not optimize for size, enable vzeroupper optimization for\n-\t TARGET_AVX with -fexpensive-optimizations.  */\n-      if (!optimize_size\n-\t  && flag_expensive_optimizations\n-\t  && !(target_flags_explicit & MASK_VZEROUPPER))\n-\ttarget_flags |= MASK_VZEROUPPER;\n+\t TARGET_AVX with -fexpensive-optimizations and split 32-byte\n+\t AVX unaligned load/store.  */\n+      if (!optimize_size)\n+\t{\n+\t  if (flag_expensive_optimizations\n+\t      && !(target_flags_explicit & MASK_VZEROUPPER))\n+\t    target_flags |= MASK_VZEROUPPER;\n+\t  if (!(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n+\t    target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n+\t  if (!(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n+\t    target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n+\t}\n     }\n   else \n     {\n@@ -15588,6 +15597,57 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n   emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n }\n \n+/* Split 32-byte AVX unaligned load and store if needed.  */\n+\n+static void\n+ix86_avx256_split_vector_move_misalign (rtx op0, rtx op1)\n+{\n+  rtx m;\n+  rtx (*extract) (rtx, rtx, rtx);\n+  rtx (*move_unaligned) (rtx, rtx);\n+  enum machine_mode mode;\n+\n+  switch (GET_MODE (op0))\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case V32QImode:\n+      extract = gen_avx_vextractf128v32qi;\n+      move_unaligned = gen_avx_movdqu256;\n+      mode = V16QImode;\n+      break;\n+    case V8SFmode:\n+      extract = gen_avx_vextractf128v8sf;\n+      move_unaligned = gen_avx_movups256;\n+      mode = V4SFmode;\n+      break;\n+    case V4DFmode:\n+      extract = gen_avx_vextractf128v4df;\n+      move_unaligned = gen_avx_movupd256;\n+      mode = V2DFmode;\n+      break;\n+    }\n+\n+  if (MEM_P (op1) && TARGET_AVX256_SPLIT_UNALIGNED_LOAD)\n+    {\n+      rtx r = gen_reg_rtx (mode);\n+      m = adjust_address (op1, mode, 0);\n+      emit_move_insn (r, m);\n+      m = adjust_address (op1, mode, 16);\n+      r = gen_rtx_VEC_CONCAT (GET_MODE (op0), r, m);\n+      emit_move_insn (op0, r);\n+    }\n+  else if (MEM_P (op0) && TARGET_AVX256_SPLIT_UNALIGNED_STORE)\n+    {\n+      m = adjust_address (op0, mode, 0);\n+      emit_insn (extract (m, op1, const0_rtx));\n+      m = adjust_address (op0, mode, 16);\n+      emit_insn (extract (m, op1, const1_rtx));\n+    }\n+  else\n+    emit_insn (move_unaligned (op0, op1));\n+}\n+\n /* Implement the movmisalign patterns for SSE.  Non-SSE modes go\n    straight to ix86_expand_vector_move.  */\n /* Code generation for scalar reg-reg moves of single and double precision data:\n@@ -15672,7 +15732,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t    case 32:\n \t      op0 = gen_lowpart (V32QImode, op0);\n \t      op1 = gen_lowpart (V32QImode, op1);\n-\t      emit_insn (gen_avx_movdqu256 (op0, op1));\n+\t      ix86_avx256_split_vector_move_misalign (op0, op1);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -15688,7 +15748,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t      emit_insn (gen_avx_movups (op0, op1));\n \t      break;\n \t    case V8SFmode:\n-\t      emit_insn (gen_avx_movups256 (op0, op1));\n+\t      ix86_avx256_split_vector_move_misalign (op0, op1);\n \t      break;\n \t    case V2DFmode:\n \t      if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n@@ -15701,7 +15761,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t      emit_insn (gen_avx_movupd (op0, op1));\n \t      break;\n \t    case V4DFmode:\n-\t      emit_insn (gen_avx_movupd256 (op0, op1));\n+\t      ix86_avx256_split_vector_move_misalign (op0, op1);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();"}, {"sha": "f63a40629e1b995de319ecc1be6e387df06991f1", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -420,3 +420,11 @@ Emit profiling counter call at function entry before prologue.\n m8bit-idiv\n Target Report Mask(USE_8BIT_IDIV) Save\n Expand 32bit/64bit integer divide into 8bit unsigned integer divide with run-time check\n+\n+mavx256-split-unaligned-load\n+Target Report Mask(AVX256_SPLIT_UNALIGNED_LOAD) Save\n+Split 32-byte AVX unaligned load\n+\n+mavx256-split-unaligned-store\n+Target Report Mask(AVX256_SPLIT_UNALIGNED_STORE) Save\n+Split 32-byte AVX unaligned store"}, {"sha": "de11f7362ec7f47521273d3930a8094e370aa98f", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -203,19 +203,35 @@\n       return standard_sse_constant_opcode (insn, operands[1]);\n     case 1:\n     case 2:\n+      if (GET_MODE_ALIGNMENT (<MODE>mode) == 256\n+\t  && ((TARGET_AVX256_SPLIT_UNALIGNED_STORE\n+\t       && misaligned_operand (operands[0], <MODE>mode))\n+\t      || (TARGET_AVX256_SPLIT_UNALIGNED_LOAD\n+\t\t  && misaligned_operand (operands[1], <MODE>mode))))\n+\tgcc_unreachable ();\n       switch (get_attr_mode (insn))\n         {\n \tcase MODE_V8SF:\n \tcase MODE_V4SF:\n-\t  return \"vmovaps\\t{%1, %0|%0, %1}\";\n+\t  if (misaligned_operand (operands[0], <MODE>mode)\n+\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t    return \"vmovups\\t{%1, %0|%0, %1}\";\n+\t  else\n+\t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n \tcase MODE_V4DF:\n \tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n+\t  if (misaligned_operand (operands[0], <MODE>mode)\n+\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t    return \"vmovupd\\t{%1, %0|%0, %1}\";\n+\t  else if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n \t    return \"vmovapd\\t{%1, %0|%0, %1}\";\n \tdefault:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n+\t  if (misaligned_operand (operands[0], <MODE>mode)\n+\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t    return \"vmovdqu\\t{%1, %0|%0, %1}\";\n+\t  else if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n \t    return \"vmovdqa\\t{%1, %0|%0, %1}\";\n@@ -400,7 +416,15 @@\n \t  UNSPEC_MOVU))]\n   \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"vmovu<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n+{\n+  if (GET_MODE_ALIGNMENT (<MODE>mode) == 256\n+      && ((TARGET_AVX256_SPLIT_UNALIGNED_STORE\n+\t   && misaligned_operand (operands[0], <MODE>mode))\n+\t  || (TARGET_AVX256_SPLIT_UNALIGNED_LOAD\n+\t      && misaligned_operand (operands[1], <MODE>mode))))\n+    gcc_unreachable ();\n+  return \"vmovu<ssemodesuffix>\\t{%1, %0|%0, %1}\";\n+}\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"movu\" \"1\")\n    (set_attr \"prefix\" \"vex\")\n@@ -459,7 +483,15 @@\n \t  [(match_operand:AVXMODEQI 1 \"nonimmediate_operand\" \"xm,x\")]\n \t  UNSPEC_MOVU))]\n   \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"vmovdqu\\t{%1, %0|%0, %1}\"\n+{\n+  if (GET_MODE_ALIGNMENT (<MODE>mode) == 256\n+      && ((TARGET_AVX256_SPLIT_UNALIGNED_STORE\n+\t   && misaligned_operand (operands[0], <MODE>mode))\n+\t  || (TARGET_AVX256_SPLIT_UNALIGNED_LOAD\n+\t      && misaligned_operand (operands[1], <MODE>mode))))\n+    gcc_unreachable ();\n+  return \"vmovdqu\\t{%1, %0|%0, %1}\";\n+}\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"movu\" \"1\")\n    (set_attr \"prefix\" \"vex\")"}, {"sha": "85bf2b4854e084cc09265a11c4c26b370efe7f2f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -602,7 +602,8 @@ Objective-C and Objective-C++ Dialects}.\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} -mabi=@var{name} @gol\n -m32  -m64 -mlarge-data-threshold=@var{num} @gol\n--msse2avx -mfentry -m8bit-idiv}\n+-msse2avx -mfentry -m8bit-idiv @gol\n+-mavx256-split-unaligned-load -mavx256-split-unaligned-store}\n \n @emph{i386 and x86-64 Windows Options}\n @gccoptlist{-mconsole -mcygwin -mno-cygwin -mdll @gol\n@@ -12669,6 +12670,12 @@ runt-time check.  If both dividend and divisor are within range of 0\n to 255, 8bit unsigned integer divide will be used instead of\n 32bit/64bit integer divide.\n \n+@item -mavx256-split-unaligned-load\n+@item -mavx256-split-unaligned-store\n+@opindex avx256-split-unaligned-load\n+@opindex avx256-split-unaligned-store\n+Split 32-byte AVX unaligned load and store.\n+\n @end table\n \n These @samp{-m} switches are supported in addition to the above"}, {"sha": "fdcc95f91b479a17faa8f945694bd083373fd560", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -1,3 +1,20 @@\n+2011-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/avx256-unaligned-load-1.c: New.\n+\t* gcc.target/i386/avx256-unaligned-load-2.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-load-3.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-load-4.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-load-5.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-load-6.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-load-7.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-1.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-2.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-3.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-4.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-5.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-6.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-7.c: Likewise.\n+\n 2011-03-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/47065"}, {"sha": "023e859b6c1dd21fbb3f4488cca171d889e8a11f", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#define N 1024\n+\n+float a[N], b[N+3], c[N];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] * b[i+3];\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movups256/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*avx_movups/1\" } } */\n+/* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "8394e27197b260bd5a17c16600ab8fea47cdbb75", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#define N 1024\n+\n+char **ep;\n+char **fp;\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+  char **ap;\n+  char **bp;\n+  char **cp;\n+\n+  ap = ep;\n+  bp = fp;\n+  for (i = 128; i >= 0; i--)\n+    {\n+      *ap++ = *cp++;\n+      *bp++ = 0;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movdqu256/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*avx_movdqu/1\" } } */\n+/* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "ec7d59d53ccee2cd650ccbea3922731d62002fde", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#define N 1024\n+\n+double a[N], b[N+3], c[N];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] * b[i+3];\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movupd256/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*avx_movupd/1\" } } */\n+/* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "0d3ef33312069b39499fc1e6e9c3d09a7504e925", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\" } */\n+\n+#define N 1024\n+\n+float a[N], b[N+3];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i] = a[i+3] * 2;\n+}\n+\n+/* { dg-final { scan-assembler \"\\\\*avx_movups256/1\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movups/1\" } } */\n+/* { dg-final { scan-assembler-not \"vinsertf128\" } } */"}, {"sha": "153b66f828797d7b07c3a030a6414573ed98dd34", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-5.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-5.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 8\n+\n+float a[N+3] = { -1, -1, -1, 24.43, 68.346, 43.35,\n+\t\t 546.46, 46.79, 82.78, 82.7, 9.4 };\n+float b[N];\n+float c[N];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i] = a[i+3] * 2;\n+}\n+\n+__attribute__ ((noinline))\n+float\n+bar (float x)\n+{\n+  return x * 2;\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    c[i] = bar (a[i+3]);\n+\n+  for (i = 0; i < N; i++)\n+    if (b[i] != c[i])\n+      abort ();\n+}"}, {"sha": "2fa984cc4a64069e661ad8e6c21d56ece1e9d9b3", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-6.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 4\n+\n+double a[N+3] = { -1, -1, -1, 24.43, 68.346, 43.35, 546.46 };\n+double b[N];\n+double c[N];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i] = a[i+3] * 2;\n+}\n+\n+__attribute__ ((noinline))\n+double\n+bar (double x)\n+{\n+  return x * 2;\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    c[i] = bar (a[i+3]);\n+\n+  for (i = 0; i < N; i++)\n+    if (b[i] != c[i])\n+      abort ();\n+}"}, {"sha": "ad16a5329bf1bd9e800cb8831ce236346359ad1a", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-7.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-load\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 128\n+\n+char **ep;\n+char **fp;\n+char **mp;\n+char **lp;\n+\n+__attribute__ ((noinline))\n+void\n+foo (void)\n+{\n+  mp = (char **) malloc (N);\n+  lp = (char **) malloc (N);\n+  ep = (char **) malloc (N);\n+  fp = (char **) malloc (N);\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+  char **ap, **bp, **cp, **dp;\n+  char *str = \"STR\";\n+\n+  foo ();\n+\n+  cp = mp;\n+  dp = lp;\n+\n+  for (i = N; i >= 0; i--)\n+    {\n+      *cp++ = str;\n+      *dp++ = str;\n+    }\n+\n+  ap = ep;\n+  bp = fp;\n+  cp = mp;\n+  dp = lp;\n+\n+  for (i = N; i >= 0; i--)\n+    {\n+      *ap++ = *cp++;\n+      *bp++ = *dp++;\n+    }\n+\n+  for (i = N; i >= 0; i--)\n+    {\n+      if (strcmp (*--ap, \"STR\") != 0)\n+\tabort ();\n+      if (strcmp (*--bp, \"STR\") != 0)\n+\tabort ();\n+    }\n+}"}, {"sha": "99db55c9d0add311851722e2ab7e4e787606d5a2", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#define N 1024\n+\n+float a[N], b[N+3], c[N], d[N];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i+3] = a[i] * 10.0;\n+\n+  for (i = 0; i < N; i++)\n+    d[i] = c[i] * 20.0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movups256/2\" } } */\n+/* { dg-final { scan-assembler \"movups.*\\\\*avx_movv4sf_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vextractf128\" } } */"}, {"sha": "38ee9e2a45c5a11e4187213b16b35370a0f4fa65", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#define N 1024\n+\n+char **ep;\n+char **fp;\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+  char **ap;\n+  char **bp;\n+  char **cp;\n+\n+  ap = ep;\n+  bp = fp;\n+  for (i = 128; i >= 0; i--)\n+    {\n+      *ap++ = *cp++;\n+      *bp++ = 0;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movdqu256/2\" } } */\n+/* { dg-final { scan-assembler \"movdqu.*\\\\*avx_movv16qi_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vextractf128\" } } */"}, {"sha": "eaab6fd775b94b980ee5c528d922ba8634d988a9", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#define N 1024\n+\n+double a[N], b[N+3], c[N], d[N];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i+3] = a[i] * 10.0;\n+\n+  for (i = 0; i < N; i++)\n+    d[i] = c[i] * 20.0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movupd256/2\" } } */\n+/* { dg-final { scan-assembler \"movupd.*\\\\*avx_movv2df_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vextractf128\" } } */"}, {"sha": "96cca66ae9c7afdb6b3f6e54cc54e360896169f6", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\" } */\n+\n+#define N 1024\n+\n+float a[N], b[N+3], c[N];\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i+3] = a[i] * c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"\\\\*avx_movups256/2\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movups/2\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\*avx_movv4sf_internal/3\" } } */\n+/* { dg-final { scan-assembler-not \"vextractf128\" } } */"}, {"sha": "642da3cf0ee08592185661bb7ca64176399c9d9a", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-5.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-5.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 8\n+\n+float a[N] = { 24.43, 68.346, 43.35, 546.46, 46.79, 82.78, 82.7, 9.4 };\n+float b[N+3];\n+float c[N+3];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i+3] = a[i] * 2;\n+}\n+\n+__attribute__ ((noinline))\n+float\n+bar (float x)\n+{\n+  return x * 2;\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    c[i+3] = bar (a[i]);\n+\n+  for (i = 0; i < N; i++)\n+    if (b[i+3] != c[i+3])\n+      abort ();\n+}"}, {"sha": "a0de7a56f638cb84dfc41ec83d39bb43521af8d4", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-6.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 4\n+\n+double a[N] = { 24.43, 68.346, 43.35, 546.46 };\n+double b[N+3];\n+double c[N+3];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i+3] = a[i] * 2;\n+}\n+\n+__attribute__ ((noinline))\n+double\n+bar (double x)\n+{\n+  return x * 2;\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    c[i+3] = bar (a[i]);\n+\n+  for (i = 0; i < N; i++)\n+    if (b[i+3] != c[i+3])\n+      abort ();\n+}"}, {"sha": "4272dc3cd0d959ab2ca4b85633d758d24046c94f", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d253656a7be7461c2fc7bb638e93b9943a91de9b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-7.c?ref=d253656a7be7461c2fc7bb638e93b9943a91de9b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+\n+#include \"avx-check.h\"\n+\n+#define N 128\n+\n+char **ep;\n+char **fp;\n+\n+__attribute__ ((noinline))\n+void\n+foo (void)\n+{\n+  ep = (char **) malloc (N);\n+  fp = (char **) malloc (N);\n+}\n+\n+void\n+avx_test (void)\n+{\n+  int i;\n+  char **ap, **bp;\n+  char *str = \"STR\";\n+\n+  foo ();\n+\n+  ap = ep;\n+  bp = fp;\n+\n+  for (i = N; i >= 0; i--)\n+    {\n+      *ap++ = str;\n+      *bp++ = str;\n+    }\n+\n+  for (i = N; i >= 0; i--)\n+    {\n+      if (strcmp (*--ap, \"STR\") != 0)\n+\tabort ();\n+      if (strcmp (*--bp, \"STR\") != 0)\n+\tabort ();\n+    }\n+}"}]}