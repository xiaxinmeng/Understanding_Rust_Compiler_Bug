{"sha": "267d80f146da679e44aa377f889d717032102268", "node_id": "C_kwDOANBUbNoAKDI2N2Q4MGYxNDZkYTY3OWU0NGFhMzc3Zjg4OWQ3MTcwMzIxMDIyNjg", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-03-20T03:17:04Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-03-25T08:47:56Z"}, "message": "expand: Add new ExpandVisitor class\n\nThis class takes care of actually performing the macro expansion by calling\ninto the MacroExpander for each node of a given AST, leaving the job of\ncfg-stripping nodes to the AttrVisitor.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add new object file.\n\t* expand/rust-attribute-visitor.cc (AttrVisitor::go): Visit all items of a\n\tcrate.\n\t(AttrVisitor::expand_struct_fields): Do not perform macro expansion anymore.\n\t(AttrVisitor::expand_function_params): Likewise.\n\t(AttrVisitor::expand_generic_args): Likewise.\n\t(AttrVisitor::expand_qualified_path_type): Likewise.\n\t(AttrVisitor::expand_self_param): Likewise.\n\t(AttrVisitor::expand_trait_function_decl): Likewise.\n\t(AttrVisitor::expand_trait_method_decl): Likewise.\n\t(AttrVisitor::visit): Likewise.\n\t(AttrVisitor::maybe_expand_expr): Remove function.\n\t(AttrVisitor::maybe_expand_type): Likewise.\n\t* expand/rust-attribute-visitor.h: Do not keep MacroExpander inside AttrVisitor\n\tanymore.\n\t* expand/rust-macro-expand.h (struct MacroExpander): Turn ContextType into an\n\tenum class for more type safety.\n\t* expand/rust-macro-expand.cc (MacroExpander::expand_crate): Use new ContextType\n\tAPI.\n\t* rust-session-manager.cc (Session::expansion): Call into ExpandVisitor.\n\t* expand/rust-expand-visitor.cc: New file.\n\t* expand/rust-expand-visitor.h: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/macro49.rs: New test.\n\t* rust/compile/macro50.rs: New test.", "tree": {"sha": "497a17c92f6cca03a8b6fa330921106ac2733187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497a17c92f6cca03a8b6fa330921106ac2733187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/267d80f146da679e44aa377f889d717032102268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267d80f146da679e44aa377f889d717032102268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/267d80f146da679e44aa377f889d717032102268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267d80f146da679e44aa377f889d717032102268/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e10e882ddf3d0f85f36e6645c4637f9725ee2562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10e882ddf3d0f85f36e6645c4637f9725ee2562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10e882ddf3d0f85f36e6645c4637f9725ee2562"}], "stats": {"total": 2013, "additions": 1711, "deletions": 302}, "files": [{"sha": "e39ee7cf355a5690a9f8c9380bdfca97caff1938", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -82,6 +82,7 @@ GRS_OBJS = \\\n     rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-attribute-visitor.o \\\n+\trust/rust-expand-visitor.o \\\n     rust/rust-macro-invoc-lexer.o \\\n     rust/rust-macro-substitute-ctx.o \\\n     rust/rust-macro-builtins.o \\"}, {"sha": "bc01a11c0d63eef758c7ba58b0aaa2f6b92a1b48", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 19, "deletions": 233, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -141,6 +141,20 @@ AttrVisitor::go (AST::Crate &crate)\n       crate.strip_crate ();\n       // TODO: maybe create warning here? probably not desired behaviour\n     }\n+\n+  auto &items = crate.items;\n+\n+  for (auto it = items.begin (); it != items.end ();)\n+    {\n+      auto &item = *it;\n+      item->accept_vis (*this);\n+\n+      if (item->is_marked_for_strip ())\n+\tit = items.erase (it);\n+      else\n+\tit++;\n+    }\n+\n   // expand module attributes?\n }\n \n@@ -160,20 +174,14 @@ AttrVisitor::expand_struct_fields (std::vector<AST::StructField> &fields)\n \t  continue;\n \t}\n \n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       // expand sub-types of type, but can't strip type itself\n       auto &type = field.get_field_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n-      expander.pop_context ();\n-\n       // if nothing else happens, increment\n       ++it;\n     }\n@@ -209,8 +217,6 @@ AttrVisitor::expand_tuple_fields (std::vector<AST::TupleField> &fields)\n void\n AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n {\n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   for (auto it = params.begin (); it != params.end ();)\n     {\n       auto &param = *it;\n@@ -233,17 +239,13 @@ AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n       // increment\n       ++it;\n     }\n-\n-  expander.pop_context ();\n }\n \n void\n@@ -252,8 +254,6 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n   // lifetime args can't be expanded\n   // FIXME: Can we have macro invocations for lifetimes?\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   // expand type args - strip sub-types only\n   for (auto &arg : args.get_generic_args ())\n     {\n@@ -262,7 +262,6 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n \t  case AST::GenericArg::Kind::Type: {\n \t    auto &type = arg.get_type ();\n \t    type->accept_vis (*this);\n-\t    maybe_expand_type (type);\n \n \t    if (type->is_marked_for_strip ())\n \t      rust_error_at (type->get_locus (),\n@@ -272,7 +271,6 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n \t  case AST::GenericArg::Kind::Const: {\n \t    auto &expr = arg.get_expression ();\n \t    expr->accept_vis (*this);\n-\t    maybe_expand_expr (expr);\n \n \t    if (expr->is_marked_for_strip ())\n \t      rust_error_at (expr->get_locus (),\n@@ -289,8 +287,6 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n \t}\n     }\n \n-  expander.pop_context ();\n-\n   // FIXME: Can we have macro invocations in generic type bindings?\n   // expand binding args - strip sub-types only\n   for (auto &binding : args.get_binding_args ())\n@@ -307,15 +303,9 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n void\n AttrVisitor::expand_qualified_path_type (AST::QualifiedPathType &path_type)\n {\n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   auto &type = path_type.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n-  expander.pop_context ();\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n@@ -353,17 +343,12 @@ AttrVisitor::AttrVisitor::expand_closure_params (\n \n       if (param.has_type_given ())\n \t{\n-\t  expander.push_context (MacroExpander::ContextType::TYPE);\n \t  auto &type = param.get_type ();\n \t  type->accept_vis (*this);\n \n-\t  maybe_expand_type (type);\n-\n \t  if (type->is_marked_for_strip ())\n \t    rust_error_at (type->get_locus (),\n \t\t\t   \"cannot strip type in this position\");\n-\n-\t  expander.pop_context ();\n \t}\n \n       // increment if found nothing else so far\n@@ -376,17 +361,12 @@ AttrVisitor::expand_self_param (AST::SelfParam &self_param)\n {\n   if (self_param.has_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = self_param.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n   /* TODO: maybe check for invariants being violated - e.g. both type and\n    * lifetime? */\n@@ -413,18 +393,12 @@ AttrVisitor::expand_trait_function_decl (AST::TraitFunctionDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -449,18 +423,12 @@ AttrVisitor::expand_trait_method_decl (AST::TraitMethodDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -525,7 +493,6 @@ AttrVisitor::visit (AST::MacroInvocation &macro_invoc)\n   // I don't think any macro token trees can be stripped in any way\n \n   // TODO: maybe have cfg! macro stripping behaviour here?\n-  expander.expand_invoc (macro_invoc, macro_invoc.has_semicolon ());\n }\n \n void\n@@ -575,18 +542,12 @@ AttrVisitor::visit (AST::TypePathSegmentFunction &segment)\n \n   if (type_path_function.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = type_path_function.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n }\n void\n@@ -745,13 +706,11 @@ AttrVisitor::visit (AST::ArithmeticOrLogicalExpr &expr)\n    * with outer expr */\n   auto &l_expr = expr.get_left_expr ();\n   l_expr->accept_vis (*this);\n-  maybe_expand_expr (l_expr);\n \n   /* should syntactically not have outer attributes, though this may\n    * not have worked in practice */\n   auto &r_expr = expr.get_right_expr ();\n   r_expr->accept_vis (*this);\n-  maybe_expand_expr (r_expr);\n \n   // ensure that they are not marked for strip\n   if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -774,13 +733,11 @@ AttrVisitor::visit (AST::ComparisonExpr &expr)\n    * with outer expr */\n   auto &l_expr = expr.get_left_expr ();\n   l_expr->accept_vis (*this);\n-  maybe_expand_expr (l_expr);\n \n   /* should syntactically not have outer attributes, though this may\n    * not have worked in practice */\n   auto &r_expr = expr.get_right_expr ();\n   r_expr->accept_vis (*this);\n-  maybe_expand_expr (r_expr);\n \n   // ensure that they are not marked for strip\n   if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -803,13 +760,11 @@ AttrVisitor::visit (AST::LazyBooleanExpr &expr)\n    * with outer expr */\n   auto &l_expr = expr.get_left_expr ();\n   l_expr->accept_vis (*this);\n-  maybe_expand_expr (l_expr);\n \n   /* should syntactically not have outer attributes, though this may\n    * not have worked in practice */\n   auto &r_expr = expr.get_right_expr ();\n   r_expr->accept_vis (*this);\n-  maybe_expand_expr (r_expr);\n \n   // ensure that they are not marked for strip\n   if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -859,13 +814,11 @@ AttrVisitor::visit (AST::AssignmentExpr &expr)\n    * with outer expr */\n   auto &l_expr = expr.get_left_expr ();\n   l_expr->accept_vis (*this);\n-  maybe_expand_expr (l_expr);\n \n   /* should syntactically not have outer attributes, though this may\n    * not have worked in practice */\n   auto &r_expr = expr.get_right_expr ();\n   r_expr->accept_vis (*this);\n-  maybe_expand_expr (r_expr);\n \n   // ensure that they are not marked for strip\n   if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -888,13 +841,11 @@ AttrVisitor::visit (AST::CompoundAssignmentExpr &expr)\n    * with outer expr */\n   auto &l_expr = expr.get_left_expr ();\n   l_expr->accept_vis (*this);\n-  maybe_expand_expr (l_expr);\n \n   /* should syntactically not have outer attributes, though this may\n    * not have worked in practice */\n   auto &r_expr = expr.get_right_expr ();\n   r_expr->accept_vis (*this);\n-  maybe_expand_expr (r_expr);\n \n   // ensure that they are not marked for strip\n   if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -1238,29 +1189,6 @@ AttrVisitor::visit (AST::CallExpr &expr)\n   // FIXME: Arthur: Figure out how to refactor this - This is similar to\n   // expanding items in the crate or stmts in blocks\n   expand_pointer_allow_strip (expr.get_params ());\n-  auto &params = expr.get_params ();\n-  for (auto it = params.begin (); it != params.end ();)\n-    {\n-      auto &stmt = *it;\n-\n-      stmt->accept_vis (*this);\n-\n-      auto final_fragment = expander.take_expanded_fragment ();\n-      if (final_fragment.should_expand ())\n-\t{\n-\t  // Remove the current expanded invocation\n-\t  it = params.erase (it);\n-\t  for (auto &node : final_fragment.get_nodes ())\n-\t    {\n-\t      it = params.insert (it, node.take_expr ());\n-\t      it++;\n-\t    }\n-\t}\n-      else if (stmt->is_marked_for_strip ())\n-\tit = params.erase (it);\n-      else\n-\tit++;\n-    }\n }\n void\n AttrVisitor::visit (AST::MethodCallExpr &expr)\n@@ -1356,26 +1284,18 @@ AttrVisitor::visit (AST::BlockExpr &expr)\n       return;\n     }\n \n-  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n-    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::BLOCK,\n-\t\t\t expr.get_statements (), extractor);\n-\n-  expander.push_context (MacroExpander::ContextType::BLOCK);\n+  expand_pointer_allow_strip (expr.get_statements ());\n \n   // strip tail expression if exists - can actually fully remove it\n   if (expr.has_tail_expr ())\n     {\n       auto &tail_expr = expr.get_tail_expr ();\n \n       tail_expr->accept_vis (*this);\n-      maybe_expand_expr (tail_expr);\n \n       if (tail_expr->is_marked_for_strip ())\n \texpr.strip_tail_expr ();\n     }\n-  expander.pop_context ();\n }\n \n void\n@@ -1393,19 +1313,13 @@ AttrVisitor::visit (AST::ClosureExprInnerTyped &expr)\n    * allowed by spec */\n   expand_closure_params (expr.get_params ());\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   // can't strip return type, but can strip sub-types\n   auto &type = expr.get_return_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   // can't strip expression itself, but can strip sub-expressions\n   auto &definition_block = expr.get_definition_block ();\n   definition_block->accept_vis (*this);\n@@ -1737,7 +1651,6 @@ AttrVisitor::visit (AST::IfExpr &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n-  maybe_expand_expr (condition_expr);\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1765,7 +1678,6 @@ AttrVisitor::visit (AST::IfExprConseqElse &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n-  maybe_expand_expr (condition_expr);\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1801,7 +1713,6 @@ AttrVisitor::visit (AST::IfExprConseqIf &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n-  maybe_expand_expr (condition_expr);\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1837,7 +1748,6 @@ AttrVisitor::visit (AST::IfExprConseqIfLet &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n-  maybe_expand_expr (condition_expr);\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -2156,17 +2066,12 @@ AttrVisitor::visit (AST::TypeParam &param)\n \n   if (param.has_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n }\n void\n@@ -2179,18 +2084,12 @@ AttrVisitor::visit (AST::TypeBoundWhereClauseItem &item)\n {\n   // for lifetimes shouldn't require\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   // don't strip directly, only components of bounds\n   for (auto &bound : item.get_type_param_bounds ())\n     bound->accept_vis (*this);\n@@ -2221,18 +2120,12 @@ AttrVisitor::visit (AST::Method &method)\n \n   if (method.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = method.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   if (method.has_where_clause ())\n@@ -2339,18 +2232,12 @@ AttrVisitor::visit (AST::Function &function)\n \n   if (function.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = function.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   if (function.has_where_clause ())\n@@ -2406,10 +2293,6 @@ AttrVisitor::visit (AST::StructStruct &struct_item)\n \n   if (struct_item.has_where_clause ())\n     expand_where_clause (struct_item.get_where_clause ());\n-\n-  /* strip struct fields if required - this is presumably\n-   * allowed by spec */\n-  expand_struct_fields (struct_item.get_fields ());\n }\n void\n AttrVisitor::visit (AST::TupleStruct &tuple_struct)\n@@ -2550,19 +2433,13 @@ AttrVisitor::visit (AST::ConstantItem &const_item)\n       return;\n     }\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   // strip any sub-types\n   auto &type = const_item.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2584,19 +2461,13 @@ AttrVisitor::visit (AST::StaticItem &static_item)\n       return;\n     }\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   // strip any sub-types\n   auto &type = static_item.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2670,19 +2541,13 @@ AttrVisitor::visit (AST::TraitItemConst &item)\n       return;\n     }\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   // strip any sub-types\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped */\n@@ -2747,11 +2612,7 @@ AttrVisitor::visit (AST::Trait &trait)\n   if (trait.has_where_clause ())\n     expand_where_clause (trait.get_where_clause ());\n \n-  std::function<std::unique_ptr<AST::TraitItem> (AST::SingleASTNode)> extractor\n-    = [] (AST::SingleASTNode node) { return node.take_trait_item (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::TRAIT,\n-\t\t\t trait.get_trait_items (), extractor);\n+  expand_pointer_allow_strip (trait.get_trait_items ());\n }\n void\n AttrVisitor::visit (AST::InherentImpl &impl)\n@@ -2776,26 +2637,16 @@ AttrVisitor::visit (AST::InherentImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n-  expander.push_context (MacroExpander::ContextType::ITEM);\n-\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n-  std::function<std::unique_ptr<AST::InherentImplItem> (AST::SingleASTNode)>\n-    extractor = [] (AST::SingleASTNode node) { return node.take_impl_item (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::IMPL,\n-\t\t\t impl.get_impl_items (), extractor);\n+  expand_pointer_allow_strip (impl.get_impl_items ());\n }\n void\n AttrVisitor::visit (AST::TraitImpl &impl)\n@@ -2820,18 +2671,12 @@ AttrVisitor::visit (AST::TraitImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n-  expander.push_context (MacroExpander::ContextType::ITEM);\n-\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n-  expander.pop_context ();\n-\n   auto &trait_path = impl.get_trait_path ();\n   visit (trait_path);\n   if (trait_path.is_marked_for_strip ())\n@@ -2841,12 +2686,7 @@ AttrVisitor::visit (AST::TraitImpl &impl)\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n-  std::function<std::unique_ptr<AST::TraitImplItem> (AST::SingleASTNode)>\n-    extractor\n-    = [] (AST::SingleASTNode node) { return node.take_trait_impl_item (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::TRAIT_IMPL,\n-\t\t\t impl.get_impl_items (), extractor);\n+  expand_pointer_allow_strip (impl.get_impl_items ());\n }\n \n void\n@@ -2873,17 +2713,11 @@ AttrVisitor::visit (AST::ExternalStaticItem &item)\n       return;\n     }\n \n-  expander.push_context (MacroExpander::ContextType::TYPE);\n-\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n \n-  maybe_expand_type (type);\n-\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n-\n-  expander.pop_context ();\n }\n \n void\n@@ -2916,19 +2750,13 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \t  continue;\n \t}\n \n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n-      expander.pop_context ();\n-\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -2941,18 +2769,12 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \n   if (item.has_return_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &return_type = item.get_return_type ();\n       return_type->accept_vis (*this);\n \n-      maybe_expand_type (return_type);\n-\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   if (item.has_where_clause ())\n@@ -2978,12 +2800,7 @@ AttrVisitor::visit (AST::ExternBlock &block)\n       return;\n     }\n \n-  std::function<std::unique_ptr<AST::ExternalItem> (AST::SingleASTNode)>\n-    extractor\n-    = [] (AST::SingleASTNode node) { return node.take_external_item (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::EXTERN,\n-\t\t\t block.get_extern_items (), extractor);\n+  expand_pointer_allow_strip (block.get_extern_items ());\n }\n \n // I don't think it would be possible to strip macros without expansion\n@@ -3327,18 +3144,12 @@ AttrVisitor::visit (AST::LetStmt &stmt)\n   // similar for type\n   if (stmt.has_type ())\n     {\n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &type = stmt.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n-\n-      expander.pop_context ();\n     }\n \n   /* strip any internal sub-expressions - expression itself isn't\n@@ -3353,8 +3164,6 @@ AttrVisitor::visit (AST::LetStmt &stmt)\n \trust_error_at (init_expr->get_locus (),\n \t\t       \"cannot strip expression in this position - outer \"\n \t\t       \"attributes not allowed\");\n-\n-      maybe_expand_expr (init_expr);\n     }\n }\n void\n@@ -3531,19 +3340,13 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n \t  continue;\n \t}\n \n-      expander.push_context (MacroExpander::ContextType::TYPE);\n-\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n \n-      maybe_expand_type (type);\n-\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n-      expander.pop_context ();\n-\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -3566,21 +3369,4 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n   // no where clause, apparently\n }\n \n-void\n-AttrVisitor::maybe_expand_expr (std::unique_ptr<AST::Expr> &expr)\n-{\n-  auto final_fragment = expander.take_expanded_fragment ();\n-  if (final_fragment.should_expand ()\n-      && final_fragment.is_expression_fragment ())\n-    expr = final_fragment.take_expression_fragment ();\n-}\n-\n-void\n-AttrVisitor::maybe_expand_type (std::unique_ptr<AST::Type> &type)\n-{\n-  auto final_fragment = expander.take_expanded_fragment ();\n-  if (final_fragment.should_expand () && final_fragment.is_type_fragment ())\n-    type = final_fragment.take_type_fragment ();\n-}\n-\n } // namespace Rust"}, {"sha": "a83d335e7ac8415166b65a976007c0942378f67c", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -25,12 +25,8 @@ namespace Rust {\n class AttrVisitor : public AST::ASTVisitor\n {\n private:\n-  MacroExpander &expander;\n-  void maybe_expand_expr (std::unique_ptr<AST::Expr> &expr);\n-  void maybe_expand_type (std::unique_ptr<AST::Type> &expr);\n-\n public:\n-  AttrVisitor (MacroExpander &expander) : expander (expander) {}\n+  AttrVisitor () {}\n \n   /* Run the AttrVisitor on an entire crate */\n   void go (AST::Crate &crate);\n@@ -47,58 +43,10 @@ class AttrVisitor : public AST::ASTVisitor\n   void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n \n   /**\n-   * Expand a set of values, erasing them if they are marked for strip, and\n-   * replacing them with expanded macro nodes if necessary.\n-   * This function is slightly different from `expand_pointer_allow_strip` as\n-   * it can only be called in certain expansion contexts - where macro\n-   * invocations are allowed.\n+   * Expand a set of values, erasing them if they are marked for strip.\n    *\n-   * @param ctx Context to use for macro expansion\n    * @param values Iterable reference over values to replace or erase\n-   * @param extractor Function to call when replacing values with the content\n-   * \t\tof an expanded AST node\n    */\n-  template <typename T, typename U>\n-  void expand_macro_children (MacroExpander::ContextType ctx, T &values,\n-\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n-  {\n-    expander.push_context (ctx);\n-\n-    for (auto it = values.begin (); it != values.end ();)\n-      {\n-\tauto &value = *it;\n-\n-\t// mark for stripping if required\n-\tvalue->accept_vis (*this);\n-\n-\tauto final_fragment = expander.take_expanded_fragment ();\n-\n-\tif (final_fragment.should_expand ())\n-\t  {\n-\t    it = values.erase (it);\n-\t    for (auto &node : final_fragment.get_nodes ())\n-\t      {\n-\t\tauto new_node = extractor (node);\n-\t\tif (new_node != nullptr && !new_node->is_marked_for_strip ())\n-\t\t  {\n-\t\t    it = values.insert (it, std::move (new_node));\n-\t\t    it++;\n-\t\t  }\n-\t      }\n-\t  }\n-\telse if (value->is_marked_for_strip ())\n-\t  {\n-\t    it = values.erase (it);\n-\t  }\n-\telse\n-\t  {\n-\t    ++it;\n-\t  }\n-      }\n-\n-    expander.pop_context ();\n-  }\n-\n   template <typename T> void expand_pointer_allow_strip (T &values)\n   {\n     for (auto it = values.begin (); it != values.end ();)\n@@ -108,13 +56,9 @@ class AttrVisitor : public AST::ASTVisitor\n \t// mark for stripping if required\n \tvalue->accept_vis (*this);\n \tif (value->is_marked_for_strip ())\n-\t  {\n-\t    it = values.erase (it);\n-\t  }\n+\t  it = values.erase (it);\n \telse\n-\t  {\n-\t    ++it;\n-\t  }\n+\t  ++it;\n       }\n   }\n "}, {"sha": "2a5dc79f8dd407ca4a3c0bccc470939ac4ce6f4d", "filename": "gcc/rust/expand/rust-expand-visitor.cc", "status": "added", "additions": 1340, "deletions": 0, "changes": 1340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -0,0 +1,1340 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-expand-visitor.h\"\n+\n+namespace Rust {\n+\n+/* Expand all of the macro invocations currently contained in a crate */\n+void\n+ExpandVisitor::go (AST::Crate &crate)\n+{\n+  expander.push_context (MacroExpander::ContextType::ITEM);\n+\n+  // expand attributes recursively and strip items if required\n+  //  AttrVisitor attr_visitor (*this);\n+  auto &items = crate.items;\n+  for (auto it = items.begin (); it != items.end ();)\n+    {\n+      auto &item = *it;\n+      item->accept_vis (*this);\n+\n+      auto fragment = expander.take_expanded_fragment ();\n+      if (fragment.should_expand ())\n+\t{\n+\t  // Remove the current expanded invocation\n+\t  it = items.erase (it);\n+\t  for (auto &node : fragment.get_nodes ())\n+\t    {\n+\t      it = items.insert (it, node.take_item ());\n+\t      it++;\n+\t    }\n+\t}\n+      else\n+\tit++;\n+    }\n+\n+  expander.pop_context ();\n+}\n+\n+void\n+ExpandVisitor::maybe_expand_expr (std::unique_ptr<AST::Expr> &expr)\n+{\n+  // FIXME: ARTHUR: Why isn't there a ContextType::EXPR? We can only\n+  // reach `parse_expr` once in MacroExpander::transcribe_rule(), but it\n+  // would make things clearer wouldn't it?\n+  expr->accept_vis (*this);\n+\n+  auto final_fragment = expander.take_expanded_fragment ();\n+  if (final_fragment.should_expand ()\n+      && final_fragment.is_expression_fragment ())\n+    expr = final_fragment.take_expression_fragment ();\n+}\n+\n+void\n+ExpandVisitor::maybe_expand_type (std::unique_ptr<AST::Type> &type)\n+{\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n+  type->accept_vis (*this);\n+  auto final_fragment = expander.take_expanded_fragment ();\n+  if (final_fragment.should_expand () && final_fragment.is_type_fragment ())\n+    type = final_fragment.take_type_fragment ();\n+\n+  expander.pop_context ();\n+}\n+\n+// FIXME: Can this be refactored into a `scoped` method? Which takes a\n+// ContextType as parameter and a lambda? And maybe just an std::vector<T>&?\n+void\n+ExpandVisitor::expand_struct_fields (std::vector<AST::StructField> &fields)\n+{\n+  for (auto &field : fields)\n+    maybe_expand_type (field.get_field_type ());\n+}\n+\n+void\n+ExpandVisitor::expand_tuple_fields (std::vector<AST::TupleField> &fields)\n+{\n+  for (auto &field : fields)\n+    maybe_expand_type (field.get_field_type ());\n+}\n+\n+// FIXME: This can definitely be refactored with the method above\n+void\n+ExpandVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n+{\n+  for (auto &param : params)\n+    maybe_expand_type (param.get_type ());\n+}\n+\n+void\n+ExpandVisitor::expand_generic_args (AST::GenericArgs &args)\n+{\n+  for (auto &arg : args.get_generic_args ())\n+    {\n+      switch (arg.get_kind ())\n+\t{\n+\tcase AST::GenericArg::Kind::Type:\n+\t  maybe_expand_type (arg.get_type ());\n+\t  break;\n+\tcase AST::GenericArg::Kind::Const:\n+\t  maybe_expand_expr (arg.get_expression ());\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t  // FIXME: Figure out what to do here if there is ambiguity. Since the\n+\t  // resolver comes after the expansion, we need to figure out a way to\n+\t  // strip ambiguous values here\n+\t  // TODO: ARTHUR: Probably add a `mark_as_strip` method to `GenericArg`\n+\t  // or something. This would clean up this whole thing\n+\t}\n+    }\n+\n+  // FIXME: Can we have macro invocations in generic type bindings?\n+  // expand binding args - strip sub-types only\n+  // FIXME: ARTHUR: This needs a test! Foo<Item = macro!()>\n+  for (auto &binding : args.get_binding_args ())\n+    maybe_expand_type (binding.get_type ());\n+}\n+\n+void\n+ExpandVisitor::expand_qualified_path_type (AST::QualifiedPathType &path_type)\n+{\n+  maybe_expand_type (path_type.get_type ());\n+\n+  // FIXME: ARTHUR: Can we do macro expansion in there? Needs a test!\n+  if (path_type.has_as_clause ())\n+    path_type.get_as_type_path ().accept_vis (*this);\n+}\n+\n+void\n+ExpandVisitor::expand_closure_params (std::vector<AST::ClosureParam> &params)\n+{\n+  for (auto &param : params)\n+    if (param.has_type_given ())\n+      maybe_expand_type (param.get_type ());\n+}\n+\n+void\n+ExpandVisitor::expand_self_param (AST::SelfParam &self_param)\n+{\n+  if (self_param.has_type ())\n+    maybe_expand_type (self_param.get_type ());\n+\n+  /* TODO: maybe check for invariants being violated - e.g. both type and\n+   * lifetime? */\n+}\n+\n+void\n+ExpandVisitor::expand_where_clause (AST::WhereClause &where_clause)\n+{\n+  for (auto &item : where_clause.get_items ())\n+    visit (item);\n+}\n+\n+void\n+ExpandVisitor::expand_trait_function_decl (AST::TraitFunctionDecl &decl)\n+{\n+  // just expand sub-stuff - can't actually strip generic params themselves\n+  for (auto &param : decl.get_generic_params ())\n+    visit (param);\n+\n+  /* strip function parameters if required - this is specifically\n+   * allowed by spec */\n+  expand_function_params (decl.get_function_params ());\n+\n+  if (decl.has_return_type ())\n+    maybe_expand_type (decl.get_return_type ());\n+\n+  if (decl.has_where_clause ())\n+    expand_where_clause (decl.get_where_clause ());\n+}\n+\n+void\n+ExpandVisitor::expand_trait_method_decl (AST::TraitMethodDecl &decl)\n+{\n+  for (auto &param : decl.get_generic_params ())\n+    visit (param);\n+\n+  /* assuming you can't strip self param - wouldn't be a method\n+   * anymore. spec allows outer attrs on self param, but doesn't\n+   * specify whether cfg is used. */\n+  expand_self_param (decl.get_self_param ());\n+\n+  /* strip function parameters if required - this is specifically\n+   * allowed by spec */\n+  expand_function_params (decl.get_function_params ());\n+\n+  if (decl.has_return_type ())\n+\n+    maybe_expand_type (decl.get_return_type ());\n+\n+  if (decl.has_where_clause ())\n+    expand_where_clause (decl.get_where_clause ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Token &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::DelimTokenTree &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::AttrInputMetaItemContainer &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::Lifetime &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::LifetimeParam &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::ConstGenericParam &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MacroInvocation &macro_invoc)\n+{\n+  // TODO: Can we do the AST fragment replacing here? Probably not, right?\n+  expander.expand_invoc (macro_invoc, macro_invoc.has_semicolon ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::PathInExpression &path)\n+{\n+  for (auto &segment : path.get_segments ())\n+    if (segment.has_generic_args ())\n+      expand_generic_args (segment.get_generic_args ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TypePathSegment &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::TypePathSegmentFunction &segment)\n+{\n+  auto &type_path_function = segment.get_type_path_function ();\n+\n+  for (auto &type : type_path_function.get_params ())\n+    visit (type);\n+\n+  if (type_path_function.has_return_type ())\n+    maybe_expand_type (type_path_function.get_return_type ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TypePath &path)\n+{\n+  for (auto &segment : path.get_segments ())\n+    visit (segment);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::QualifiedPathInExpression &path)\n+{\n+  expand_qualified_path_type (path.get_qualified_path_type ());\n+\n+  for (auto &segment : path.get_segments ())\n+    if (segment.has_generic_args ())\n+      expand_generic_args (segment.get_generic_args ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::QualifiedPathInType &path)\n+{\n+  expand_qualified_path_type (path.get_qualified_path_type ());\n+\n+  // this shouldn't strip any segments, but can strip inside them\n+  for (auto &segment : path.get_segments ())\n+    visit (segment);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::LiteralExpr &expr)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::AttrInputLiteral &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaItemLitExpr &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaItemPathLit &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::BorrowExpr &expr)\n+{\n+  visit (expr.get_borrowed_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::DereferenceExpr &expr)\n+{\n+  visit (expr.get_dereferenced_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ErrorPropagationExpr &expr)\n+{\n+  visit (expr.get_propagating_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::NegationExpr &expr)\n+{\n+  visit (expr.get_negated_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_left_expr ());\n+  maybe_expand_expr (expr.get_right_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ComparisonExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_left_expr ());\n+  maybe_expand_expr (expr.get_right_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::LazyBooleanExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_left_expr ());\n+  maybe_expand_expr (expr.get_right_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TypeCastExpr &expr)\n+{\n+  visit (expr.get_casted_expr ());\n+\n+  visit (expr.get_type_to_cast_to ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::AssignmentExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_left_expr ());\n+  maybe_expand_expr (expr.get_right_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_left_expr ());\n+  maybe_expand_expr (expr.get_right_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::GroupedExpr &expr)\n+{\n+  visit (expr.get_expr_in_parens ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    visit (elem);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArrayElemsCopied &elems)\n+{\n+  visit (elems.get_elem_to_copy ());\n+  visit (elems.get_num_copies ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArrayExpr &expr)\n+{\n+  visit (expr.get_array_elems ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArrayIndexExpr &expr)\n+{\n+  visit (expr.get_array_expr ());\n+  visit (expr.get_index_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleExpr &expr)\n+{\n+  for (auto &element : expr.get_tuple_elems ())\n+    visit (element);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleIndexExpr &expr)\n+{\n+  visit (expr.get_tuple_expr ());\n+\n+  // We can't have macro invocations for tuple indexes, right? Need a test!\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprStruct &expr)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprFieldIdentifier &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  visit (field.get_value ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  visit (field.get_value ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprStructFields &expr)\n+{\n+  for (auto &field : expr.get_fields ())\n+    visit (field);\n+\n+  if (expr.has_struct_base ())\n+    visit (expr.get_struct_base ().get_base_struct ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructExprStructBase &expr)\n+{\n+  visit (expr.get_struct_base ().get_base_struct ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::CallExpr &expr)\n+{\n+  visit (expr.get_function_expr ());\n+\n+  for (auto &param : expr.get_params ())\n+    maybe_expand_expr (param);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::MethodCallExpr &expr)\n+{\n+  visit (expr.get_receiver_expr ());\n+\n+  for (auto &param : expr.get_params ())\n+    maybe_expand_expr (param);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::FieldAccessExpr &expr)\n+{\n+  visit (expr.get_receiver_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ClosureExprInner &expr)\n+{\n+  expand_closure_params (expr.get_params ());\n+\n+  visit (expr.get_definition_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::BlockExpr &expr)\n+{\n+  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n+\n+  expand_macro_children (MacroExpander::ContextType::BLOCK,\n+\t\t\t expr.get_statements (), extractor);\n+\n+  expander.push_context (MacroExpander::ContextType::BLOCK);\n+\n+  if (expr.has_tail_expr ())\n+    maybe_expand_expr (expr.get_tail_expr ());\n+\n+  expander.pop_context ();\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ClosureExprInnerTyped &expr)\n+{\n+  expand_closure_params (expr.get_params ());\n+\n+  maybe_expand_type (expr.get_return_type ());\n+\n+  visit (expr.get_definition_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ContinueExpr &expr)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    visit (expr.get_break_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangeFromToExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangeFromExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangeToExpr &expr)\n+{\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangeFullExpr &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::RangeFromToInclExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangeToInclExpr &expr)\n+{\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ReturnExpr &expr)\n+{\n+  if (expr.has_returned_expr ())\n+    visit (expr.get_returned_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  visit (expr.get_block_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::LoopExpr &expr)\n+{\n+  visit (expr.get_loop_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::WhileLoopExpr &expr)\n+{\n+  visit (expr.get_predicate_expr ());\n+  visit (expr.get_loop_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::WhileLetLoopExpr &expr)\n+{\n+  for (auto &pattern : expr.get_patterns ())\n+    visit (pattern);\n+\n+  visit (expr.get_scrutinee_expr ());\n+  visit (expr.get_loop_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ForLoopExpr &expr)\n+{\n+  visit (expr.get_pattern ());\n+  visit (expr.get_iterator_expr ());\n+  visit (expr.get_loop_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_condition_expr ());\n+\n+  visit (expr.get_if_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfExprConseqElse &expr)\n+{\n+  maybe_expand_expr (expr.get_condition_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_else_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfExprConseqIf &expr)\n+{\n+  maybe_expand_expr (expr.get_condition_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_conseq_if_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfExprConseqIfLet &expr)\n+{\n+  maybe_expand_expr (expr.get_condition_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_conseq_if_let_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfLetExpr &expr)\n+{\n+  maybe_expand_expr (expr.get_value_expr ());\n+\n+  visit (expr.get_if_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfLetExprConseqElse &expr)\n+{\n+  maybe_expand_expr (expr.get_value_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_else_block ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfLetExprConseqIf &expr)\n+{\n+  maybe_expand_expr (expr.get_value_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_conseq_if_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::IfLetExprConseqIfLet &expr)\n+{\n+  maybe_expand_expr (expr.get_value_expr ());\n+\n+  visit (expr.get_if_block ());\n+  visit (expr.get_conseq_if_let_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::MatchExpr &expr)\n+{\n+  visit (expr.get_scrutinee_expr ());\n+\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      auto &arm = match_case.get_arm ();\n+\n+      for (auto &pattern : arm.get_patterns ())\n+\tvisit (pattern);\n+\n+      if (arm.has_match_arm_guard ())\n+\tvisit (arm.get_guard_expr ());\n+\n+      visit (match_case.get_expr ());\n+    }\n+}\n+\n+void\n+ExpandVisitor::visit (AST::AwaitExpr &expr)\n+{\n+  visit (expr.get_awaited_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::AsyncBlockExpr &expr)\n+{\n+  visit (expr.get_block_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TypeParam &param)\n+{\n+  for (auto &bound : param.get_type_param_bounds ())\n+    visit (bound);\n+\n+  if (param.has_type ())\n+    maybe_expand_type (param.get_type ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::LifetimeWhereClauseItem &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::TypeBoundWhereClauseItem &item)\n+{\n+  maybe_expand_type (item.get_type ());\n+\n+  for (auto &bound : item.get_type_param_bounds ())\n+    visit (bound);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Method &method)\n+{\n+  for (auto &param : method.get_generic_params ())\n+    visit (param);\n+\n+  expand_self_param (method.get_self_param ());\n+  expand_function_params (method.get_function_params ());\n+\n+  if (method.has_return_type ())\n+    visit (method.get_return_type ());\n+\n+  if (method.has_where_clause ())\n+    expand_where_clause (method.get_where_clause ());\n+\n+  visit (method.get_definition ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Module &module)\n+{\n+  if (module.get_kind () == AST::Module::ModuleKind::LOADED)\n+    for (auto &item : module.get_items ())\n+      visit (item);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExternCrate &crate)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::UseTreeGlob &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::UseTreeList &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::UseTreeRebind &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::Function &function)\n+{\n+  for (auto &param : function.get_generic_params ())\n+    visit (param);\n+\n+  expand_function_params (function.get_function_params ());\n+\n+  if (function.has_return_type ())\n+    maybe_expand_type (function.get_return_type ());\n+\n+  if (function.has_where_clause ())\n+    expand_where_clause (function.get_where_clause ());\n+\n+  visit (function.get_definition ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TypeAlias &type_alias)\n+{\n+  visit (type_alias.get_type_aliased ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructStruct &struct_item)\n+{\n+  for (auto &generic : struct_item.get_generic_params ())\n+    visit (generic);\n+\n+  if (struct_item.has_where_clause ())\n+    expand_where_clause (struct_item.get_where_clause ());\n+\n+  expand_struct_fields (struct_item.get_fields ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleStruct &tuple_struct)\n+{\n+  for (auto &generic : tuple_struct.get_generic_params ())\n+    visit (generic);\n+\n+  if (tuple_struct.has_where_clause ())\n+    expand_where_clause (tuple_struct.get_where_clause ());\n+\n+  expand_tuple_fields (tuple_struct.get_fields ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::EnumItem &item)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::EnumItemTuple &item)\n+{\n+  expand_tuple_fields (item.get_tuple_fields ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::EnumItemStruct &item)\n+{\n+  expand_struct_fields (item.get_struct_fields ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::EnumItemDiscriminant &item)\n+{\n+  visit (item.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Enum &enum_item)\n+{\n+  for (auto &generic : enum_item.get_generic_params ())\n+    visit (generic);\n+\n+  for (auto &variant : enum_item.get_variants ())\n+    visit (variant);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Union &union_item)\n+{\n+  for (auto &generic : union_item.get_generic_params ())\n+    visit (generic);\n+\n+  expand_struct_fields (union_item.get_variants ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ConstantItem &const_item)\n+{\n+  maybe_expand_type (const_item.get_type ());\n+\n+  visit (const_item.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StaticItem &static_item)\n+{\n+  maybe_expand_type (static_item.get_type ());\n+\n+  visit (static_item.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitItemFunc &item)\n+{\n+  expand_trait_function_decl (item.get_trait_function_decl ());\n+\n+  if (item.has_definition ())\n+    visit (item.get_definition ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitItemMethod &item)\n+{\n+  expand_trait_method_decl (item.get_trait_method_decl ());\n+\n+  if (item.has_definition ())\n+    visit (item.get_definition ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitItemConst &const_item)\n+{\n+  maybe_expand_type (const_item.get_type ());\n+\n+  if (const_item.has_expr ())\n+    visit (const_item.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitItemType &item)\n+{\n+  for (auto &type : item.get_type_param_bounds ())\n+    visit (type);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::Trait &trait)\n+{\n+  for (auto &generic : trait.get_generic_params ())\n+    visit (generic);\n+\n+  for (auto &bound : trait.get_type_param_bounds ())\n+    visit (bound);\n+\n+  if (trait.has_where_clause ())\n+    expand_where_clause (trait.get_where_clause ());\n+\n+  expander.push_context (MacroExpander::ContextType::TRAIT);\n+\n+  std::function<std::unique_ptr<AST::TraitItem> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_trait_item (); };\n+\n+  expand_macro_children (MacroExpander::ContextType::TRAIT,\n+\t\t\t trait.get_trait_items (), extractor);\n+\n+  expander.pop_context ();\n+}\n+\n+void\n+ExpandVisitor::visit (AST::InherentImpl &impl)\n+{\n+  // just expand sub-stuff - can't actually strip generic params themselves\n+  for (auto &generic : impl.get_generic_params ())\n+    visit (generic);\n+\n+  // FIXME: Is that correct? How do we test that?\n+  expander.push_context (MacroExpander::ContextType::ITEM);\n+\n+  maybe_expand_type (impl.get_type ());\n+\n+  expander.pop_context ();\n+\n+  if (impl.has_where_clause ())\n+    expand_where_clause (impl.get_where_clause ());\n+\n+  std::function<std::unique_ptr<AST::InherentImplItem> (AST::SingleASTNode)>\n+    extractor = [] (AST::SingleASTNode node) { return node.take_impl_item (); };\n+\n+  expand_macro_children (MacroExpander::ContextType::IMPL,\n+\t\t\t impl.get_impl_items (), extractor);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitImpl &impl)\n+{\n+  // just expand sub-stuff - can't actually strip generic params themselves\n+  for (auto &param : impl.get_generic_params ())\n+    visit (param);\n+\n+  // FIXME: Is that correct? How do we test that?\n+  expander.push_context (MacroExpander::ContextType::ITEM);\n+\n+  maybe_expand_type (impl.get_type ());\n+\n+  expander.pop_context ();\n+\n+  visit (impl.get_trait_path ());\n+\n+  if (impl.has_where_clause ())\n+    expand_where_clause (impl.get_where_clause ());\n+\n+  std::function<std::unique_ptr<AST::TraitImplItem> (AST::SingleASTNode)>\n+    extractor\n+    = [] (AST::SingleASTNode node) { return node.take_trait_impl_item (); };\n+\n+  expand_macro_children (MacroExpander::ContextType::TRAIT_IMPL,\n+\t\t\t impl.get_impl_items (), extractor);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExternalTypeItem &item)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::ExternalStaticItem &static_item)\n+{\n+  maybe_expand_type (static_item.get_type ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExternalFunctionItem &item)\n+{\n+  for (auto &param : item.get_generic_params ())\n+    visit (param);\n+\n+  // FIXME: Should this work? What is the difference between NamedFunctionParam\n+  // and FunctionParam?\n+  // expand_function_params (item.get_function_params ());\n+\n+  for (auto &param : item.get_function_params ())\n+    maybe_expand_type (param.get_type ());\n+\n+  if (item.has_return_type ())\n+    maybe_expand_type (item.get_return_type ());\n+\n+  if (item.has_where_clause ())\n+    expand_where_clause (item.get_where_clause ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExternBlock &block)\n+{\n+  std::function<std::unique_ptr<AST::ExternalItem> (AST::SingleASTNode)>\n+    extractor\n+    = [] (AST::SingleASTNode node) { return node.take_external_item (); };\n+\n+  expand_macro_children (MacroExpander::ContextType::EXTERN,\n+\t\t\t block.get_extern_items (), extractor);\n+}\n+\n+// I don't think it would be possible to strip macros without expansion\n+void\n+ExpandVisitor::visit (AST::MacroMatchFragment &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MacroMatchRepetition &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MacroMatcher &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaItemPath &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaItemSeq &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaWord &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaNameValueStr &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaListPaths &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::MetaListNameValueStr &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::LiteralPattern &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::IdentifierPattern &pattern)\n+{\n+  if (pattern.has_pattern_to_bind ())\n+    visit (pattern.get_pattern_to_bind ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::WildcardPattern &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::RestPattern &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::RangePatternBoundLiteral &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::RangePatternBoundPath &bound)\n+{\n+  visit (bound.get_path ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangePatternBoundQualPath &bound)\n+{\n+  visit (bound.get_qualified_path ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::RangePattern &pattern)\n+{\n+  visit (pattern.get_lower_bound ());\n+  visit (pattern.get_upper_bound ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ReferencePattern &pattern)\n+{\n+  visit (pattern.get_referenced_pattern ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructPatternFieldTuplePat &field)\n+{\n+  visit (field.get_index_pattern ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructPatternFieldIdentPat &field)\n+{\n+  visit (field.get_ident_pattern ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::StructPatternFieldIdent &field)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::StructPattern &pattern)\n+{\n+  visit (pattern.get_path ());\n+\n+  for (auto &inner :\n+       pattern.get_struct_pattern_elems ().get_struct_pattern_fields ())\n+    visit (inner);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_patterns ())\n+    visit (pattern);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleStructItemsRange &tuple_items)\n+{\n+  for (auto &lower_pattern : tuple_items.get_lower_patterns ())\n+    visit (lower_pattern);\n+  for (auto &upper_pattern : tuple_items.get_upper_patterns ())\n+    visit (upper_pattern);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleStructPattern &pattern)\n+{\n+  visit (pattern.get_path ());\n+\n+  if (pattern.has_items ())\n+    visit (pattern.get_items ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_patterns ())\n+    visit (pattern);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_lower_patterns ())\n+    visit (pattern);\n+  for (auto &pattern : tuple_items.get_upper_patterns ())\n+    visit (pattern);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TuplePattern &pattern)\n+{\n+  if (pattern.has_tuple_pattern_items ())\n+    visit (pattern.get_items ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::GroupedPattern &pattern)\n+{\n+  visit (pattern.get_pattern_in_parens ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::SlicePattern &pattern)\n+{\n+  for (auto &item : pattern.get_items ())\n+    visit (item);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::AltPattern &pattern)\n+{\n+  for (auto &alt : pattern.get_alts ())\n+    visit (alt);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::EmptyStmt &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::LetStmt &stmt)\n+{\n+  visit (stmt.get_pattern ());\n+\n+  if (stmt.has_type ())\n+    maybe_expand_type (stmt.get_type ());\n+\n+  if (stmt.has_init_expr ())\n+    maybe_expand_expr (stmt.get_init_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExprStmtWithoutBlock &stmt)\n+{\n+  visit (stmt.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ExprStmtWithBlock &stmt)\n+{\n+  visit (stmt.get_expr ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitBound &bound)\n+{\n+  visit (bound.get_type_path ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ImplTraitType &type)\n+{\n+  for (auto &bound : type.get_type_param_bounds ())\n+    visit (bound);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitObjectType &type)\n+{\n+  for (auto &bound : type.get_type_param_bounds ())\n+    visit (bound);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ParenthesisedType &type)\n+{\n+  visit (type.get_type_in_parens ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ImplTraitTypeOneBound &type)\n+{\n+  visit (type.get_trait_bound ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  visit (type.get_trait_bound ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::TupleType &type)\n+{\n+  for (auto &elem : type.get_elems ())\n+    visit (elem);\n+}\n+\n+void\n+ExpandVisitor::visit (AST::NeverType &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::RawPointerType &type)\n+{\n+  visit (type.get_type_pointed_to ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ReferenceType &type)\n+{\n+  visit (type.get_type_referenced ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::ArrayType &type)\n+{\n+  visit (type.get_elem_type ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::SliceType &type)\n+{\n+  visit (type.get_elem_type ());\n+}\n+\n+void\n+ExpandVisitor::visit (AST::InferredType &)\n+{}\n+\n+void\n+ExpandVisitor::visit (AST::BareFunctionType &type)\n+{\n+  for (auto &param : type.get_function_params ())\n+    maybe_expand_type (param.get_type ());\n+\n+  if (type.has_return_type ())\n+    visit (type.get_return_type ());\n+}\n+\n+} // namespace Rust"}, {"sha": "e832d4a06c03d1c74e0fbbef9e067c259635ed96", "filename": "gcc/rust/expand/rust-expand-visitor.h", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -0,0 +1,320 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-macro-expand.h\"\n+\n+namespace Rust {\n+\n+class ExpandVisitor : public AST::ASTVisitor\n+{\n+public:\n+  ExpandVisitor (MacroExpander &expander) : expander (expander) {}\n+\n+  /* Expand all of the macro invocations currently contained in a crate */\n+  void go (AST::Crate &crate);\n+\n+  /* Maybe expand a macro invocation in lieu of an expression */\n+  void maybe_expand_expr (std::unique_ptr<AST::Expr> &expr);\n+\n+  /* Maybe expand a macro invocation in lieu of a type */\n+  void maybe_expand_type (std::unique_ptr<AST::Type> &type);\n+\n+  /**\n+   * Expand all macro invocations in lieu of types within a vector of struct\n+   * fields\n+   */\n+  void expand_struct_fields (std::vector<AST::StructField> &fields);\n+\n+  /**\n+   * Expand all macro invocations in lieu of types within a vector of tuple\n+   * fields\n+   */\n+  void expand_tuple_fields (std::vector<AST::TupleField> &fields);\n+\n+  /**\n+   * Expand all macro invocations in lieu of types within a list of function\n+   * parameters\n+   */\n+  void expand_function_params (std::vector<AST::FunctionParam> &params);\n+\n+  /**\n+   * Expand all macro invocations in lieu of types within a list of generic\n+   * arguments\n+   */\n+  void expand_generic_args (AST::GenericArgs &args);\n+\n+  /**\n+   * Expand a macro invocation in lieu of a qualified path type\n+   */\n+  void expand_qualified_path_type (AST::QualifiedPathType &path_type);\n+\n+  void expand_closure_params (std::vector<AST::ClosureParam> &params);\n+  void expand_self_param (AST::SelfParam &self_param);\n+  void expand_where_clause (AST::WhereClause &where_clause);\n+  void expand_trait_function_decl (AST::TraitFunctionDecl &decl);\n+  void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n+\n+  /**\n+   * Expand a set of values, erasing them if they are marked for strip, and\n+   * replacing them with expanded macro nodes if necessary.\n+   * This function is slightly different from `expand_pointer_allow_strip` as\n+   * it can only be called in certain expansion contexts - where macro\n+   * invocations are allowed.\n+   *\n+   * @param ctx Context to use for macro expansion\n+   * @param values Iterable reference over values to replace or erase\n+   * @param extractor Function to call when replacing values with the content\n+   * \t\tof an expanded AST node\n+   */\n+  template <typename T, typename U>\n+  void expand_macro_children (MacroExpander::ContextType ctx, T &values,\n+\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n+  {\n+    expander.push_context (ctx);\n+\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// Perform expansion\n+\tvalue->accept_vis (*this);\n+\n+\tauto final_fragment = expander.take_expanded_fragment ();\n+\n+\t// FIXME: Is that correct? It seems *extremely* dodgy\n+\tif (final_fragment.should_expand ())\n+\t  {\n+\t    it = values.erase (it);\n+\t    for (auto &node : final_fragment.get_nodes ())\n+\t      {\n+\t\tauto new_node = extractor (node);\n+\t\tif (new_node != nullptr)\n+\t\t  {\n+\t\t    it = values.insert (it, std::move (new_node));\n+\t\t    it++;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    ++it;\n+\t  }\n+      }\n+\n+    expander.pop_context ();\n+  }\n+\n+  // TODO: See if possible to make more specialization for Impl items, Block\n+  // stmts etc? This could allow us to remove expand_macro_children or at least\n+  // its extractor parameter\n+  /**\n+   * These functions allow to easily visit `std::unique_ptr`s as well as\n+   * _replace_ them when necessary, e.g when expanding macro invocations in a\n+   * list of expressions or types. The most generic version of the function will\n+   * simply call the visitor again on the pointer, but there are two\n+   * specializations for `std::unique_ptr<Expr>` and `std::unique_ptr<Type>` to\n+   * enable replacing as well.\n+   */\n+  template <typename T> void visit (std::unique_ptr<T> &value)\n+  {\n+    value->accept_vis (*this);\n+  }\n+\n+  template <typename T> void visit (std::unique_ptr<AST::Expr> &expr)\n+  {\n+    maybe_expand_expr (expr);\n+  }\n+\n+  template <typename T> void visit (std::unique_ptr<AST::Type> &type)\n+  {\n+    maybe_expand_type (type);\n+  }\n+\n+  void visit (AST::Token &) override;\n+  void visit (AST::DelimTokenTree &) override;\n+  void visit (AST::AttrInputMetaItemContainer &) override;\n+  void visit (AST::IdentifierExpr &ident_expr) override;\n+  void visit (AST::Lifetime &) override;\n+  void visit (AST::LifetimeParam &) override;\n+  void visit (AST::ConstGenericParam &) override;\n+\n+  void visit (AST::MacroInvocation &macro_invoc) override;\n+\n+  void visit (AST::PathInExpression &path) override;\n+  void visit (AST::TypePathSegment &) override;\n+  void visit (AST::TypePathSegmentGeneric &segment) override;\n+  void visit (AST::TypePathSegmentFunction &segment) override;\n+  void visit (AST::TypePath &path) override;\n+  void visit (AST::QualifiedPathInExpression &path) override;\n+  void visit (AST::QualifiedPathInType &path) override;\n+\n+  void visit (AST::LiteralExpr &expr) override;\n+  void visit (AST::AttrInputLiteral &) override;\n+  void visit (AST::MetaItemLitExpr &) override;\n+  void visit (AST::MetaItemPathLit &) override;\n+  void visit (AST::BorrowExpr &expr) override;\n+  void visit (AST::DereferenceExpr &expr) override;\n+  void visit (AST::ErrorPropagationExpr &expr) override;\n+  void visit (AST::NegationExpr &expr) override;\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (AST::ComparisonExpr &expr) override;\n+  void visit (AST::LazyBooleanExpr &expr) override;\n+  void visit (AST::TypeCastExpr &expr) override;\n+  void visit (AST::AssignmentExpr &expr) override;\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n+  void visit (AST::GroupedExpr &expr) override;\n+  void visit (AST::ArrayElemsValues &elems) override;\n+  void visit (AST::ArrayElemsCopied &elems) override;\n+  void visit (AST::ArrayExpr &expr) override;\n+  void visit (AST::ArrayIndexExpr &expr) override;\n+  void visit (AST::TupleExpr &expr) override;\n+  void visit (AST::TupleIndexExpr &expr) override;\n+  void visit (AST::StructExprStruct &expr) override;\n+  void visit (AST::StructExprFieldIdentifier &) override;\n+  void visit (AST::StructExprFieldIdentifierValue &field) override;\n+\n+  void visit (AST::StructExprFieldIndexValue &field) override;\n+  void visit (AST::StructExprStructFields &expr) override;\n+  void visit (AST::StructExprStructBase &expr) override;\n+  void visit (AST::CallExpr &expr) override;\n+  void visit (AST::MethodCallExpr &expr) override;\n+  void visit (AST::FieldAccessExpr &expr) override;\n+  void visit (AST::ClosureExprInner &expr) override;\n+\n+  void visit (AST::BlockExpr &expr) override;\n+\n+  void visit (AST::ClosureExprInnerTyped &expr) override;\n+  void visit (AST::ContinueExpr &expr) override;\n+  void visit (AST::BreakExpr &expr) override;\n+  void visit (AST::RangeFromToExpr &expr) override;\n+  void visit (AST::RangeFromExpr &expr) override;\n+  void visit (AST::RangeToExpr &expr) override;\n+  void visit (AST::RangeFullExpr &) override;\n+  void visit (AST::RangeFromToInclExpr &expr) override;\n+  void visit (AST::RangeToInclExpr &expr) override;\n+  void visit (AST::ReturnExpr &expr) override;\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n+  void visit (AST::LoopExpr &expr) override;\n+  void visit (AST::WhileLoopExpr &expr) override;\n+  void visit (AST::WhileLetLoopExpr &expr) override;\n+  void visit (AST::ForLoopExpr &expr) override;\n+  void visit (AST::IfExpr &expr) override;\n+  void visit (AST::IfExprConseqElse &expr) override;\n+  void visit (AST::IfExprConseqIf &expr) override;\n+  void visit (AST::IfExprConseqIfLet &expr) override;\n+  void visit (AST::IfLetExpr &expr) override;\n+  void visit (AST::IfLetExprConseqElse &expr) override;\n+  void visit (AST::IfLetExprConseqIf &expr) override;\n+  void visit (AST::IfLetExprConseqIfLet &expr) override;\n+  void visit (AST::MatchExpr &expr) override;\n+  void visit (AST::AwaitExpr &expr) override;\n+  void visit (AST::AsyncBlockExpr &expr) override;\n+  void visit (AST::TypeParam &param) override;\n+  void visit (AST::LifetimeWhereClauseItem &) override;\n+  void visit (AST::TypeBoundWhereClauseItem &item) override;\n+  void visit (AST::Method &method) override;\n+  void visit (AST::Module &module) override;\n+  void visit (AST::ExternCrate &crate) override;\n+  void visit (AST::UseTreeGlob &) override;\n+  void visit (AST::UseTreeList &) override;\n+  void visit (AST::UseTreeRebind &) override;\n+  void visit (AST::UseDeclaration &use_decl) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::TypeAlias &type_alias) override;\n+  void visit (AST::StructStruct &struct_item) override;\n+  void visit (AST::TupleStruct &tuple_struct) override;\n+  void visit (AST::EnumItem &item) override;\n+  void visit (AST::EnumItemTuple &item) override;\n+  void visit (AST::EnumItemStruct &item) override;\n+  void visit (AST::EnumItemDiscriminant &item) override;\n+  void visit (AST::Enum &enum_item) override;\n+  void visit (AST::Union &union_item) override;\n+  void visit (AST::ConstantItem &const_item) override;\n+  void visit (AST::StaticItem &static_item) override;\n+  void visit (AST::TraitItemFunc &item) override;\n+  void visit (AST::TraitItemMethod &item) override;\n+  void visit (AST::TraitItemConst &item) override;\n+  void visit (AST::TraitItemType &item) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::InherentImpl &impl) override;\n+  void visit (AST::TraitImpl &impl) override;\n+  void visit (AST::ExternalTypeItem &item) override;\n+  void visit (AST::ExternalStaticItem &item) override;\n+  void visit (AST::ExternalFunctionItem &item) override;\n+  void visit (AST::ExternBlock &block) override;\n+\n+  // I don't think it would be possible to strip macros without expansion\n+  void visit (AST::MacroMatchFragment &) override;\n+  void visit (AST::MacroMatchRepetition &) override;\n+  void visit (AST::MacroMatcher &) override;\n+  void visit (AST::MacroRulesDefinition &rules_def) override;\n+  void visit (AST::MetaItemPath &) override;\n+  void visit (AST::MetaItemSeq &) override;\n+  void visit (AST::MetaWord &) override;\n+  void visit (AST::MetaNameValueStr &) override;\n+  void visit (AST::MetaListPaths &) override;\n+  void visit (AST::MetaListNameValueStr &) override;\n+  void visit (AST::LiteralPattern &) override;\n+  void visit (AST::IdentifierPattern &pattern) override;\n+  void visit (AST::WildcardPattern &) override;\n+  void visit (AST::RestPattern &) override;\n+  void visit (AST::RangePatternBoundLiteral &) override;\n+  void visit (AST::RangePatternBoundPath &bound) override;\n+  void visit (AST::RangePatternBoundQualPath &bound) override;\n+  void visit (AST::RangePattern &pattern) override;\n+  void visit (AST::ReferencePattern &pattern) override;\n+  void visit (AST::StructPatternFieldTuplePat &field) override;\n+  void visit (AST::StructPatternFieldIdentPat &field) override;\n+  void visit (AST::StructPatternFieldIdent &field) override;\n+  void visit (AST::StructPattern &pattern) override;\n+  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n+  void visit (AST::TupleStructItemsRange &tuple_items) override;\n+  void visit (AST::TupleStructPattern &pattern) override;\n+  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n+  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n+  void visit (AST::TuplePattern &pattern) override;\n+  void visit (AST::GroupedPattern &pattern) override;\n+  void visit (AST::SlicePattern &pattern) override;\n+  void visit (AST::AltPattern &pattern) override;\n+\n+  void visit (AST::EmptyStmt &) override;\n+  void visit (AST::LetStmt &stmt) override;\n+  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n+  void visit (AST::ExprStmtWithBlock &stmt) override;\n+\n+  void visit (AST::TraitBound &bound) override;\n+  void visit (AST::ImplTraitType &type) override;\n+  void visit (AST::TraitObjectType &type) override;\n+  void visit (AST::ParenthesisedType &type) override;\n+  void visit (AST::ImplTraitTypeOneBound &type) override;\n+  void visit (AST::TraitObjectTypeOneBound &type) override;\n+  void visit (AST::TupleType &type) override;\n+  void visit (AST::NeverType &) override;\n+  void visit (AST::RawPointerType &type) override;\n+  void visit (AST::ReferenceType &type) override;\n+  void visit (AST::ArrayType &type) override;\n+  void visit (AST::SliceType &type) override;\n+  void visit (AST::InferredType &) override;\n+  void visit (AST::BareFunctionType &type) override;\n+\n+private:\n+  MacroExpander &expander;\n+};\n+\n+} // namespace Rust"}, {"sha": "8e8dadc4859e7ae89d8d9646a07b2ef9a003c727", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-early-name-resolver.h\"\n \n namespace Rust {\n+\n AST::Fragment\n MacroExpander::expand_decl_macro (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc,\n@@ -297,18 +298,15 @@ MacroExpander::expand_crate ()\n   // TODO: does cfg apply for inner attributes? research.\n   // the apparent answer (from playground test) is yes\n \n-  push_context (ITEM);\n+  push_context (ContextType::ITEM);\n \n   // expand attributes recursively and strip items if required\n-  AttrVisitor attr_visitor (*this);\n+  //  AttrVisitor attr_visitor (*this);\n   auto &items = crate.items;\n   for (auto it = items.begin (); it != items.end ();)\n     {\n       auto &item = *it;\n \n-      // mark for stripping if required\n-      item->accept_vis (attr_visitor);\n-\n       auto fragment = take_expanded_fragment ();\n       if (fragment.should_expand ())\n \t{"}, {"sha": "06efa22b20a8b21445fb2e8b5449ab8f2536c9e2", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -213,7 +213,7 @@ class SubstitutionScope\n // Object used to store shared data (between functions) for macro expansion.\n struct MacroExpander\n {\n-  enum ContextType\n+  enum class ContextType\n   {\n     ITEM,\n     BLOCK,"}, {"sha": "66863f4747cf8572fe753aacb2ea0c80161f783e", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -40,6 +40,8 @@\n #include \"rust-extern-crate.h\"\n #include \"rust-attributes.h\"\n #include \"rust-early-name-resolver.h\"\n+#include \"rust-attribute-visitor.h\"\n+#include \"rust-expand-visitor.h\"\n \n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -846,10 +848,9 @@ Session::expansion (AST::Crate &crate)\n \n   while (!fixed_point_reached && iterations < cfg.recursion_limit)\n     {\n-      /* We need to name resolve macros and imports here */\n+      AttrVisitor ().go (crate);\n       Resolver::EarlyNameResolver ().go (crate);\n-\n-      expander.expand_crate ();\n+      ExpandVisitor (expander).go (crate);\n \n       fixed_point_reached = !expander.has_changed ();\n       expander.reset_changed_state ();"}, {"sha": "0900f7cecdb65f707a3af3349bc4f9e840b8462b", "filename": "gcc/testsuite/rust/compile/macro49.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro49.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro49.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro49.rs?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -0,0 +1,9 @@\n+macro_rules! closure {\n+    () => {{\n+        14 + 15\n+    }};\n+}\n+\n+fn main() {\n+    let _ = || closure!();\n+}"}, {"sha": "e85afa799f8ba9ccf7d51bca9f39951fc1926b79", "filename": "gcc/testsuite/rust/compile/macro50.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d80f146da679e44aa377f889d717032102268/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro50.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d80f146da679e44aa377f889d717032102268/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro50.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro50.rs?ref=267d80f146da679e44aa377f889d717032102268", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! foo {\n+    () => {\n+        u32\n+    };\n+}\n+\n+fn main() {\n+    let _a = 15i32;\n+    let _b = _a as foo!();\n+}"}]}