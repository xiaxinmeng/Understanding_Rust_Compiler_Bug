{"sha": "86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "node_id": "C_kwDOANBUbNoAKDg2YzBkOTg2MjBlZTNhOTYxMGEzZjlkNzI1ZTk0M2UxZDJkNGM3ZWM", "commit": {"author": {"name": "Haochen Jiang", "email": "haochen.jiang@intel.com", "date": "2022-06-23T06:16:43Z"}, "committer": {"name": "Haochen Jiang", "email": "haochen.jiang@intel.com", "date": "2022-08-19T03:25:27Z"}, "message": "i386: Add ABI test for __bf16 type\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/x86_64/abi/bf16/abi-bf16.exp: New test.\n\t* gcc.target/x86_64/abi/bf16/args.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/asm-support.S: Ditto.\n\t* gcc.target/x86_64/abi/bf16/bf16-check.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/bf16-helper.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/defines.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/abi-bf16-ymm.exp: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/args.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/asm-support.S: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/bf16-ymm-check.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/test_m256_returning.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/test_passing_m256.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/test_passing_structs.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/test_passing_unions.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m256bf16/test_varargs-m256.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/abi-bf16-zmm.exp: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/args.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/asm-support.S: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/bf16-zmm-check.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/test_m512_returning.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/test_passing_m512.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/test_passing_structs.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/test_passing_unions.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/m512bf16/test_varargs-m512.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/macros.h: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_3_element_struct_and_unions.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_alignment.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_array_size_and_align.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_returning.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_sizes.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_struct_size_and_align.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_basic_union_size_and_align.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_m128_returning.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_passing_floats.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_passing_m128.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_passing_structs.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_passing_unions.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_struct_returning.c: Ditto.\n\t* gcc.target/x86_64/abi/bf16/test_varargs-m128.c: Ditto.", "tree": {"sha": "02ffdf22e3a29925357ae26a68291c7eb2d0dcb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02ffdf22e3a29925357ae26a68291c7eb2d0dcb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/comments", "author": {"login": "jianghc724", "id": 10798680, "node_id": "MDQ6VXNlcjEwNzk4Njgw", "avatar_url": "https://avatars.githubusercontent.com/u/10798680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jianghc724", "html_url": "https://github.com/jianghc724", "followers_url": "https://api.github.com/users/jianghc724/followers", "following_url": "https://api.github.com/users/jianghc724/following{/other_user}", "gists_url": "https://api.github.com/users/jianghc724/gists{/gist_id}", "starred_url": "https://api.github.com/users/jianghc724/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jianghc724/subscriptions", "organizations_url": "https://api.github.com/users/jianghc724/orgs", "repos_url": "https://api.github.com/users/jianghc724/repos", "events_url": "https://api.github.com/users/jianghc724/events{/privacy}", "received_events_url": "https://api.github.com/users/jianghc724/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jianghc724", "id": 10798680, "node_id": "MDQ6VXNlcjEwNzk4Njgw", "avatar_url": "https://avatars.githubusercontent.com/u/10798680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jianghc724", "html_url": "https://github.com/jianghc724", "followers_url": "https://api.github.com/users/jianghc724/followers", "following_url": "https://api.github.com/users/jianghc724/following{/other_user}", "gists_url": "https://api.github.com/users/jianghc724/gists{/gist_id}", "starred_url": "https://api.github.com/users/jianghc724/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jianghc724/subscriptions", "organizations_url": "https://api.github.com/users/jianghc724/orgs", "repos_url": "https://api.github.com/users/jianghc724/repos", "events_url": "https://api.github.com/users/jianghc724/events{/privacy}", "received_events_url": "https://api.github.com/users/jianghc724/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30afe5e7638cb4233692978365e4ceb4f8d2dc84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30afe5e7638cb4233692978365e4ceb4f8d2dc84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30afe5e7638cb4233692978365e4ceb4f8d2dc84"}], "stats": {"total": 3933, "additions": 3933, "deletions": 0}, "files": [{"sha": "bd386f2a560b4382c3a2723235825d6c2fe83281", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/abi-bf16.exp", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fabi-bf16.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fabi-bf16.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fabi-bf16.exp?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,46 @@\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The x86-64 ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+load_lib clearcap.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64]\n+     || ![is-effective-target sse2] } then {\n+  return\n+}\n+\n+\n+torture-init\n+clearcap-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-W -Wall -msse2\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+        c-torture-execute [list $src \\\n+                                $srcdir/$subdir/asm-support.S] \\\n+                                $additional_flags\n+    }\n+}\n+\n+clearcap-finish\n+torture-finish"}, {"sha": "11d7e2b3a1caab1ebd852a4c8566857169a105e3", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/args.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fargs.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,164 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <string.h>\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 xmm0\n+#define F1 xmm1\n+#define F2 xmm2\n+#define F3 xmm3\n+#define F4 xmm4\n+#define F5 xmm5\n+#define F6 xmm6\n+#define F7 xmm7\n+\n+typedef union {\n+  __bf16 ___bf16[8];\n+  float _float[4];\n+  double _double[2];\n+  long long _longlong[2];\n+  int _int[4];\n+  ulonglong _ulonglong[2];\n+#ifdef CHECK_M64_M128\n+  __m64 _m64[2];\n+  __m128 _m128[1];\n+  __m128bf16 _m128bf16[1];\n+#endif\n+} XMM_T;\n+\n+typedef union {\n+  __bf16 ___bf16;\n+  float _float;\n+  double _double;\n+  ldouble _ldouble;\n+  ulonglong _ulonglong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+XMM_T xmm_regs[16];\n+X87_T x87_regs[8];\n+extern volatile unsigned long long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  ldouble st0, st1, st2, st3, st4, st5, st6, st7;\n+  XMM_T xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8, xmm9,\n+        xmm10, xmm11, xmm12, xmm13, xmm14, xmm15;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (xmm_regs, 0, sizeof (xmm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+/* Do the checking.  */\n+#define check_f_arguments(T) do { \\\n+  assert (num_fregs <= 0 || check_bf16 (fregs.xmm0._ ## T [0], xmm_regs[0]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 1 || check_bf16 (fregs.xmm1._ ## T [0], xmm_regs[1]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 2 || check_bf16 (fregs.xmm2._ ## T [0], xmm_regs[2]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 3 || check_bf16 (fregs.xmm3._ ## T [0], xmm_regs[3]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 4 || check_bf16 (fregs.xmm4._ ## T [0], xmm_regs[4]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 5 || check_bf16 (fregs.xmm5._ ## T [0], xmm_regs[5]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 6 || check_bf16 (fregs.xmm6._ ## T [0], xmm_regs[6]._ ## T [0]) == 1); \\\n+  assert (num_fregs <= 7 || check_bf16 (fregs.xmm7._ ## T [0], xmm_regs[7]._ ## T [0]) == 1); \\\n+  } while (0)\n+\n+#define check_bf16_arguments check_f_arguments(__bf16)\n+\n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.xmm0) + (O), \\\n+\t\t     &xmm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.xmm1) + (O), \\\n+\t\t     &xmm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.xmm2) + (O), \\\n+\t\t     &xmm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.xmm3) + (O), \\\n+\t\t     &xmm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.xmm4) + (O), \\\n+\t\t     &xmm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.xmm5) + (O), \\\n+\t\t     &xmm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.xmm6) + (O), \\\n+\t\t     &xmm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.xmm7) + (O), \\\n+\t\t     &xmm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m128_arguments check_vector_arguments(m128, 0)\n+\n+#define clear_float_registers \\\n+  clear_struct_registers\n+\n+#define clear_x87_registers \\\n+  clear_struct_registers\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "a8165d86317c8574c7d8b2759bc6be07ba67cb85", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/asm-support.S", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fasm-support.S?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,84 @@\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tvmovdqu\t%xmm0, xmm_regs+0(%rip)\n+\tvmovdqu\t%xmm1, xmm_regs+16(%rip)\n+\tvmovdqu\t%xmm2, xmm_regs+32(%rip)\n+\tvmovdqu\t%xmm3, xmm_regs+48(%rip)\n+\tvmovdqu\t%xmm4, xmm_regs+64(%rip)\n+\tvmovdqu\t%xmm5, xmm_regs+80(%rip)\n+\tvmovdqu\t%xmm6, xmm_regs+96(%rip)\n+\tvmovdqu\t%xmm7, xmm_regs+112(%rip)\n+\tvmovdqu\t%xmm8, xmm_regs+128(%rip)\n+\tvmovdqu\t%xmm9, xmm_regs+144(%rip)\n+\tvmovdqu\t%xmm10, xmm_regs+160(%rip)\n+\tvmovdqu\t%xmm11, xmm_regs+176(%rip)\n+\tvmovdqu\t%xmm12, xmm_regs+192(%rip)\n+\tvmovdqu\t%xmm13, xmm_regs+208(%rip)\n+\tvmovdqu\t%xmm14, xmm_regs+224(%rip)\n+\tvmovdqu\t%xmm15, xmm_regs+240(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tsubq\t$8, %rsp\n+\tcall\t*callthis(%rip)\n+\taddq\t$8, %rsp\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tvmovdqu\t%xmm0, xmm_regs+0(%rip)\n+\tvmovdqu\t%xmm1, xmm_regs+16(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\txmm_regs,256,32\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8\n+#ifdef __linux__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+#endif"}, {"sha": "25448fc6863670abba7bbf824c76e7b5d94474e1", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/bf16-check.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-check.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,24 @@\n+#include <stdlib.h>\n+#include \"bf16-helper.h\"\n+\n+static void do_test (void);\n+\n+int\n+main ()\n+{\n+\n+  if (__builtin_cpu_supports (\"sse2\"))\n+    {\n+      do_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+      return 0;\n+    }\n+\n+#ifdef DEBUG\n+  printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "83d89fcf62cbc6acacb5ced2cda6b2a843ad20fb", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/bf16-helper.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-helper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-helper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fbf16-helper.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,41 @@\n+typedef union\n+{\n+  float f;\n+  unsigned int u;\n+  __bf16 b[2];\n+} unionf_b;\n+\n+static __bf16 make_f32_bf16 (float f)\n+{\n+  unionf_b tmp;\n+  tmp.f = f;\n+  return tmp.b[1];\n+}\n+\n+static float make_bf16_f32 (__bf16 bf)\n+{\n+  unionf_b tmp;\n+  tmp.u = 0;\n+  tmp.b[1] = bf;\n+  return tmp.f;\n+}\n+\n+static int check_bf16 (__bf16 bf1, __bf16 bf2)\n+{\n+  unionf_b tmp1, tmp2;\n+  tmp1.u = 0;\n+  tmp2.u = 0;\n+  tmp1.b[1] = bf1;\n+  tmp2.b[1] = bf2;\n+  return (tmp1.u == tmp2.u);\n+}\n+\n+static int check_bf16_float (__bf16 bf, float f)\n+{\n+  unionf_b tmp1, tmp2;\n+  tmp1.u = 0;\n+  tmp1.b[0] = bf;\n+  tmp2.f = f;\n+  tmp2.u >>= 16;\n+  return (tmp1.u == tmp2.u);\n+}"}, {"sha": "a4df0b0528d0471dd519e894b1abe86db271f2d1", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/defines.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fdefines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fdefines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fdefines.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,163 @@\n+#ifndef DEFINED_DEFINES_H\n+#define DEFINED_DEFINES_H\n+\n+/* Get __m64 and __m128. */\n+#include <immintrin.h>\n+\n+typedef unsigned long long ulonglong;\n+typedef long double ldouble;\n+\n+/* These defines determines what part of the test should be run.  When\n+   GCC implements these parts, the defines should be uncommented to\n+   enable testing.  */\n+\n+/* Scalar type __int128.  */\n+/* #define CHECK_INT128 */\n+\n+/* Scalar type long double.  */\n+#define CHECK_LONG_DOUBLE\n+\n+/* Scalar type __float128.  */\n+/* #define CHECK_FLOAT128 */\n+\n+/* Scalar types __m64 and __m128.  */\n+#define CHECK_M64_M128\n+\n+/* Structs with size >= 16.  */\n+#define CHECK_LARGER_STRUCTS\n+\n+/* Checks for passing floats and doubles.  */\n+#define CHECK_FLOAT_DOUBLE_PASSING\n+\n+/* Union passing with not-extremely-simple unions.  */\n+#define CHECK_LARGER_UNION_PASSING\n+\n+/* Variable args.  */\n+#define CHECK_VARARGS\n+\n+/* Check argument passing and returning for scalar types with sizeof = 16.  */\n+/* TODO: Implement these tests. Don't activate them for now.  */\n+#define CHECK_LARGE_SCALAR_PASSING\n+\n+/* Defines for sizing and alignment.  */\n+\n+#define TYPE_SIZE_CHAR         1\n+#define TYPE_SIZE_SHORT        2\n+#define TYPE_SIZE_INT          4\n+#ifdef __ILP32__\n+# define TYPE_SIZE_LONG        4\n+#else\n+# define TYPE_SIZE_LONG        8\n+#endif\n+#define TYPE_SIZE_LONG_LONG    8\n+#define TYPE_SIZE_INT128       16\n+#define TYPE_SIZE_BF16\t       2\n+#define TYPE_SIZE_FLOAT        4\n+#define TYPE_SIZE_DOUBLE       8\n+#define TYPE_SIZE_LONG_DOUBLE  16\n+#define TYPE_SIZE_FLOAT128     16\n+#define TYPE_SIZE_M64          8\n+#define TYPE_SIZE_M128         16\n+#define TYPE_SIZE_ENUM         4\n+#ifdef __ILP32__\n+# define TYPE_SIZE_POINTER     4\n+#else\n+# define TYPE_SIZE_POINTER     8\n+#endif\n+\n+#define TYPE_ALIGN_CHAR        1\n+#define TYPE_ALIGN_SHORT       2\n+#define TYPE_ALIGN_INT         4\n+#ifdef __ILP32__\n+# define TYPE_ALIGN_LONG       4\n+#else\n+# define TYPE_ALIGN_LONG       8\n+#endif\n+#define TYPE_ALIGN_LONG_LONG   8\n+#define TYPE_ALIGN_INT128      16\n+#define TYPE_ALIGN_BF16\t       2\n+#define TYPE_ALIGN_FLOAT       4\n+#define TYPE_ALIGN_DOUBLE      8\n+#define TYPE_ALIGN_LONG_DOUBLE 16\n+#define TYPE_ALIGN_FLOAT128    16\n+#define TYPE_ALIGN_M64         8\n+#define TYPE_ALIGN_M128        16\n+#define TYPE_ALIGN_ENUM        4\n+#ifdef __ILP32__\n+# define TYPE_ALIGN_POINTER    4\n+#else\n+# define TYPE_ALIGN_POINTER    8\n+#endif\n+\n+/* These defines control the building of the list of types to check. There\n+   is a string identifying the type (with a comma after), a size of the type\n+   (also with a comma and an integer for adding to the total amount of types)\n+   and an alignment of the type (which is currently not really needed since\n+   the abi specifies that alignof == sizeof for all scalar types).  */\n+#ifdef CHECK_INT128\n+#define CI128_STR \"__int128\",\n+#define CI128_SIZ TYPE_SIZE_INT128,\n+#define CI128_ALI TYPE_ALIGN_INT128,\n+#define CI128_RET \"???\",\n+#else\n+#define CI128_STR\n+#define CI128_SIZ\n+#define CI128_ALI\n+#define CI128_RET\n+#endif\n+#ifdef CHECK_LONG_DOUBLE\n+#define CLD_STR \"long double\",\n+#define CLD_SIZ TYPE_SIZE_LONG_DOUBLE,\n+#define CLD_ALI TYPE_ALIGN_LONG_DOUBLE,\n+#define CLD_RET \"x87_regs[0]._ldouble\",\n+#else\n+#define CLD_STR\n+#define CLD_SIZ\n+#define CLD_ALI\n+#define CLD_RET\n+#endif\n+#ifdef CHECK_FLOAT128\n+#define CF128_STR \"__float128\",\n+#define CF128_SIZ TYPE_SIZE_FLOAT128,\n+#define CF128_ALI TYPE_ALIGN_FLOAT128, \n+#define CF128_RET \"???\",\n+#else\n+#define CF128_STR\n+#define CF128_SIZ\n+#define CF128_ALI\n+#define CF128_RET\n+#endif\n+#ifdef CHECK_M64_M128\n+#define CMM_STR \"__m64\", \"__m128\",\n+#define CMM_SIZ TYPE_SIZE_M64, TYPE_SIZE_M128,\n+#define CMM_ALI TYPE_ALIGN_M64, TYPE_ALIGN_M128,\n+#define CMM_RET \"???\", \"???\",\n+#else\n+#define CMM_STR\n+#define CMM_SIZ\n+#define CMM_ALI\n+#define CMM_RET\n+#endif\n+\n+/* Used in size and alignment tests.  */\n+enum dummytype { enumtype };\n+\n+extern void abort (void);\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+#ifdef __GNUC__\n+#define PACKED __attribute__((__packed__))\n+#else\n+#warning Some tests will fail due to missing __packed__ support\n+#define PACKED\n+#endif\n+\n+#endif /* DEFINED_DEFINES_H */"}, {"sha": "309db8ff12e0cf42caad10ae5df3bbd2a7bbb2ea", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/abi-bf16-ymm.exp", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fabi-bf16-ymm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fabi-bf16-ymm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fabi-bf16-ymm.exp?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,46 @@\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The x86-64 ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+load_lib clearcap.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64]\n+     || ![is-effective-target avx2] } then {\n+  return\n+}\n+\n+\n+torture-init\n+clearcap-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-W -Wall -mavx2\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+        c-torture-execute [list $src \\\n+                                $srcdir/$subdir/asm-support.S] \\\n+                                $additional_flags\n+    }\n+}\n+\n+clearcap-finish\n+torture-finish"}, {"sha": "94627ffbd4465d6af263620d7df8ee64863fe6dc", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/args.h", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fargs.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,152 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <immintrin.h>\n+#include <string.h>\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 ymm0\n+#define F1 ymm1\n+#define F2 ymm2\n+#define F3 ymm3\n+#define F4 ymm4\n+#define F5 ymm5\n+#define F6 ymm6\n+#define F7 ymm7\n+\n+typedef union {\n+  __bf16 ___bf16[16];\n+  float _float[8];\n+  double _double[4];\n+  long long _longlong[4];\n+  int _int[8];\n+  unsigned long long _ulonglong[4];\n+  __m64 _m64[4];\n+  __m128 _m128[2];\n+  __m256 _m256[1];\n+  __m256bf16 _m256bf16[1];\n+} YMM_T;\n+\n+typedef union {\n+  float _float;\n+  double _double;\n+  long double _ldouble;\n+  unsigned long long _ulonglong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+YMM_T ymm_regs[16];\n+X87_T x87_regs[8];\n+extern volatile unsigned long long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  long double st0, st1, st2, st3, st4, st5, st6, st7;\n+  YMM_T ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9,\n+        ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (ymm_regs, 0, sizeof (ymm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.ymm0) + (O), \\\n+\t\t     &ymm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.ymm1) + (O), \\\n+\t\t     &ymm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.ymm2) + (O), \\\n+\t\t     &ymm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.ymm3) + (O), \\\n+\t\t     &ymm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.ymm4) + (O), \\\n+\t\t     &ymm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.ymm5) + (O), \\\n+\t\t     &ymm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.ymm6) + (O), \\\n+\t\t     &ymm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.ymm7) + (O), \\\n+\t\t     &ymm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m256_arguments check_vector_arguments(m256, 0)\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "24c8b3c9023672d2815254e6ebd3e6ab91e22772", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/asm-support.S", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fasm-support.S?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,84 @@\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tvmovdqu\t%ymm2, ymm_regs+64(%rip)\n+\tvmovdqu\t%ymm3, ymm_regs+96(%rip)\n+\tvmovdqu\t%ymm4, ymm_regs+128(%rip)\n+\tvmovdqu\t%ymm5, ymm_regs+160(%rip)\n+\tvmovdqu\t%ymm6, ymm_regs+192(%rip)\n+\tvmovdqu\t%ymm7, ymm_regs+224(%rip)\n+\tvmovdqu\t%ymm8, ymm_regs+256(%rip)\n+\tvmovdqu\t%ymm9, ymm_regs+288(%rip)\n+\tvmovdqu\t%ymm10, ymm_regs+320(%rip)\n+\tvmovdqu\t%ymm11, ymm_regs+352(%rip)\n+\tvmovdqu\t%ymm12, ymm_regs+384(%rip)\n+\tvmovdqu\t%ymm13, ymm_regs+416(%rip)\n+\tvmovdqu\t%ymm14, ymm_regs+448(%rip)\n+\tvmovdqu\t%ymm15, ymm_regs+480(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tsubq\t$8, %rsp\n+\tcall\t*callthis(%rip)\n+\taddq\t$8, %rsp\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\tymm_regs,512,32\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8\n+#ifdef __linux__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+#endif"}, {"sha": "479ebc3ec3f3dd0452aa92acb461300d78c73a10", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/bf16-ymm-check.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fbf16-ymm-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fbf16-ymm-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Fbf16-ymm-check.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,24 @@\n+#include <stdlib.h>\n+#include \"../bf16-helper.h\"\n+\n+static void do_test (void);\n+\n+int\n+main ()\n+{\n+\n+  if (__builtin_cpu_supports (\"avx2\"))\n+    {\n+      do_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+      return 0;\n+    }\n+\n+#ifdef DEBUG\n+  printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "ea7512850aede85d0b0b7dbb1bec20da53651ab6", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/test_m256_returning.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_m256_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_m256_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_m256_returning.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,38 @@\n+#include <stdio.h>\n+#include \"bf16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+\n+__m256bf16\n+fun_test_returning___m256bf16 (void)\n+{\n+  volatile_var++;\n+  return (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16};\n+}\n+\n+__m256bf16 test_256bf16;\n+\n+static void\n+do_test (void)\n+{\n+  unsigned failed = 0;\n+  YMM_T ymmt1, ymmt2;\n+\n+  clear_struct_registers;\n+  test_256bf16 = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16};\n+  ymmt1._m256bf16[0] = test_256bf16;\n+  ymmt2._m256bf16[0] = WRAP_RET (fun_test_returning___m256bf16) ();\n+  if (memcmp (&ymmt1, &ymmt2, sizeof (ymmt2)) != 0)\n+    printf (\"fail m256bf16\\n\"), failed++;\n+\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "3fb2d7d20f86e88e3edbdd20acf04ccb83092b7f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/test_passing_m256.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_m256.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,235 @@\n+#include <stdio.h>\n+#include \"bf16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,\n+    i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+fun_check_passing_m256bf16_8_values (__m256bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m256bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256bf16);\n+  compare (values.i1, i1, __m256bf16);\n+  compare (values.i2, i2, __m256bf16);\n+  compare (values.i3, i3, __m256bf16);\n+  compare (values.i4, i4, __m256bf16);\n+  compare (values.i5, i5, __m256bf16);\n+  compare (values.i6, i6, __m256bf16);\n+  compare (values.i7, i7, __m256bf16);\n+}\n+\n+void\n+fun_check_passing_m256bf16_8_regs (__m256bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+void\n+fun_check_passing_m256bf16_20_values (__m256bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m256bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256bf16);\n+  compare (values.i1, i1, __m256bf16);\n+  compare (values.i2, i2, __m256bf16);\n+  compare (values.i3, i3, __m256bf16);\n+  compare (values.i4, i4, __m256bf16);\n+  compare (values.i5, i5, __m256bf16);\n+  compare (values.i6, i6, __m256bf16);\n+  compare (values.i7, i7, __m256bf16);\n+  compare (values.i8, i8, __m256bf16);\n+  compare (values.i9, i9, __m256bf16);\n+  compare (values.i10, i10, __m256bf16);\n+  compare (values.i11, i11, __m256bf16);\n+  compare (values.i12, i12, __m256bf16);\n+  compare (values.i13, i13, __m256bf16);\n+  compare (values.i14, i14, __m256bf16);\n+  compare (values.i15, i15, __m256bf16);\n+  compare (values.i16, i16, __m256bf16);\n+  compare (values.i17, i17, __m256bf16);\n+  compare (values.i18, i18, __m256bf16);\n+  compare (values.i19, i19, __m256bf16);\n+}\n+\n+void\n+fun_check_passing_m256bf16_20_regs (__m256bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m256bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+#define def_check_passing8(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, \\\n+\t\t\t    _i8, _i9, _i10, _i11, _i12, _i13, _i14, \\\n+\t\t\t    _i15, _i16, _i17, _i18, _i19, _func1, \\\n+\t\t\t    _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, \\\n+\t\t     _i16, _i17, _i18, _i19); \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, \\\n+\t\t     _i16, _i17, _i18, _i19);\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+\n+void\n+test_m256bf16_on_stack ()\n+{\n+  __m256bf16 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16};\n+  pass = \"m256bf16-8\";\n+  def_check_passing8 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t      fun_check_passing_m256bf16_8_values,\n+\t\t      fun_check_passing_m256bf16_8_regs, _m256bf16);\n+}\n+\n+void\n+test_too_many_m256bf16 ()\n+{\n+  __m256bf16 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16};\n+  pass = \"m256bf16-20\";\n+  def_check_passing20 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8],\n+\t\t       x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16],\n+\t\t       x[17], x[18], x[19], fun_check_passing_m256bf16_20_values,\n+\t\t       fun_check_passing_m256bf16_20_regs, _m256bf16);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_m256bf16_on_stack ();\n+  test_too_many_m256bf16 ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "e06350ed493f8f3cdcfbebea7d90a18692c0e884", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/test_passing_structs.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_structs.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,69 @@\n+#include \"bf16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+struct m256bf16_struct\n+{\n+  __m256bf16 x;\n+};\n+\n+struct m256bf16_2_struct\n+{\n+  __m256bf16 x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing1bf16 (struct m256bf16_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m256bf16_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_struct_passing2bf16 (struct m256bf16_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+40);\n+}\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+\n+static void\n+do_test (void)\n+{\n+  struct m256bf16_struct m256bf16s [8];\n+  struct m256bf16_2_struct m256bf16_2s = { \n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16},\n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16},\n+  };\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      m256bf16s[i].x = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\t      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16};\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256bf16[0] = m256bf16s[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1bf16) (m256bf16s[0], m256bf16s[1], m256bf16s[2], m256bf16s[3],\n+\t\t\t\t\t m256bf16s[4], m256bf16s[5], m256bf16s[6], m256bf16s[7]);\n+  WRAP_CALL (check_struct_passing2bf16) (m256bf16_2s);\n+}"}, {"sha": "6d663b88b1a63c6be5799b2e6522e87dba3bc638", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/test_passing_unions.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_passing_unions.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,179 @@\n+#include \"bf16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+union un1b\n+{\n+  __m256bf16 x;\n+  float f;\n+};\n+\n+union un1bb\n+{\n+  __m256bf16 x;\n+  __bf16 f;\n+};\n+\n+union un2b\n+{\n+  __m256bf16 x;\n+  double d;\n+};\n+\n+union un3b\n+{\n+  __m256bf16 x;\n+  __m128 v;\n+};\n+\n+union un4b\n+{\n+  __m256bf16 x;\n+  long double ld;\n+};\n+\n+union un5b\n+{\n+  __m256bf16 x;\n+  int i;\n+};\n+\n+void\n+check_union_passing1b (union un1b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing1bb (union un1bb u1 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u2 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u3 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u4 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u5 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u6 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u7 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing2b (union un2b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing3b (union un3b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing4b (union un4b u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+void\n+check_union_passing5b (union un5b u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+#define check_union_passing1b WRAP_CALL(check_union_passing1b)\n+#define check_union_passing1bb WRAP_CALL(check_union_passing1bb)\n+#define check_union_passing2b WRAP_CALL(check_union_passing2b)\n+#define check_union_passing3b WRAP_CALL(check_union_passing3b)\n+#define check_union_passing4b WRAP_CALL(check_union_passing4b)\n+#define check_union_passing5b WRAP_CALL(check_union_passing5b)\n+\n+static void\n+do_test (void)\n+{\n+  union un1b u1b[8];\n+  union un1bb u1bb[8];\n+  union un2b u2b[8];\n+  union un3b u3b[8];\n+  union un4b u4b;\n+  union un5b u5b;\n+  int i;\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1b[i].x = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16 };\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256bf16[0] = u1b[i].x;\n+  num_fregs = 8;\n+  check_union_passing1b (u1b[0], u1b[1], u1b[2], u1b[3],\n+\t\t         u1b[4], u1b[5], u1b[6], u1b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1bb[i].x = u1b[i].x;\n+      (&fregs.ymm0)[i]._m256bf16[0] = u1bb[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing1bb (u1bb[0], u1bb[1], u1bb[2], u1bb[3],\n+\t\t          u1bb[4], u1bb[5], u1bb[6], u1bb[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2b[i].x = u1b[i].x;\n+      (&fregs.ymm0)[i]._m256bf16[0] = u2b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2b (u2b[0], u2b[1], u2b[2], u2b[3],\n+\t\t         u2b[4], u2b[5], u2b[6], u2b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3b[i].x = u1b[i].x;\n+      (&fregs.ymm0)[i]._m256bf16[0] = u3b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3b (u3b[0], u3b[1], u3b[2], u3b[3],\n+\t\t         u3b[4], u3b[5], u3b[6], u3b[7]);\n+\n+  check_union_passing4b (u4b);\n+  check_union_passing5b (u5b);\n+}"}, {"sha": "b69e095d8084096b6864ab144832e4cf941d3b00", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m256bf16/test_varargs-m256.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_varargs-m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_varargs-m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm256bf16%2Ftest_varargs-m256.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,107 @@\n+/* Test variable number of 256-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"bf16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m256bf16_varargs (__m256bf16 i0, __m256bf16 i1, __m256bf16 i2,\n+\t\t\t\t __m256bf16 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m256bf16 *argp;\n+\n+  compare (values.i0, i0, __m256bf16);\n+  compare (values.i1, i1, __m256bf16);\n+  compare (values.i2, i2, __m256bf16);\n+  compare (values.i3, i3, __m256bf16);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m256bf16 *)(((char *) fp) + 8);\n+\n+  /* Check __m256bf16 arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m256bf16);\n+  compare (values.i5, argp[1], __m256bf16);\n+  compare (values.i6, argp[2], __m256bf16);\n+  compare (values.i7, argp[3], __m256bf16);\n+  compare (values.i8, argp[4], __m256bf16);\n+  compare (values.i9, argp[5], __m256bf16);\n+\n+  /* Check register contents.  */\n+  compare (fregs.ymm0, ymm_regs[0], __m256bf16);\n+  compare (fregs.ymm1, ymm_regs[1], __m256bf16);\n+  compare (fregs.ymm2, ymm_regs[2], __m256bf16);\n+  compare (fregs.ymm3, ymm_regs[3], __m256bf16);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m256bf16_varargs (void)\n+{\n+  __m256bf16 x[10];\n+  int i;\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+         bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m256bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16 };\n+  pass = \"m256bf16-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m256bf16_varargs,\n+\t\t\t\t _m256bf16);\n+}\n+\n+void\n+do_test (void)\n+{\n+  test_m256bf16_varargs ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "b6e0fed4cb4297426ab691c0b2281ec02fd32d3f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/abi-bf16-zmm.exp", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fabi-bf16-zmm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fabi-bf16-zmm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fabi-bf16-zmm.exp?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,46 @@\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The x86-64 ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+load_lib clearcap.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64]\n+     || ![is-effective-target avx512f] } then {\n+  return\n+}\n+\n+\n+torture-init\n+clearcap-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-W -Wall -mavx512f\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+        c-torture-execute [list $src \\\n+                                $srcdir/$subdir/asm-support.S] \\\n+                                $additional_flags\n+    }\n+}\n+\n+clearcap-finish\n+torture-finish"}, {"sha": "64b24783833670d0d9b0b8a6c4d2b34567a01a63", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/args.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fargs.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,155 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <immintrin.h>\n+#include <string.h>\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 zmm0\n+#define F1 zmm1\n+#define F2 zmm2\n+#define F3 zmm3\n+#define F4 zmm4\n+#define F5 zmm5\n+#define F6 zmm6\n+#define F7 zmm7\n+\n+typedef union {\n+  __bf16 ___bf16[32];\n+  float _float[16];\n+  double _double[8];\n+  long long _longlong[8];\n+  int _int[16];\n+  unsigned long long _ulonglong[8];\n+  __m64 _m64[8];\n+  __m128 _m128[4];\n+  __m256 _m256[2];\n+  __m512 _m512[1];\n+  __m512bf16 _m512bf16[1];\n+} ZMM_T;\n+\n+typedef union {\n+  float _float;\n+  double _double;\n+  long double _ldouble;\n+  unsigned long long _ulonglong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+ZMM_T zmm_regs[32];\n+X87_T x87_regs[8];\n+extern volatile unsigned long long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  long double st0, st1, st2, st3, st4, st5, st6, st7;\n+  ZMM_T zmm0, zmm1, zmm2, zmm3, zmm4, zmm5, zmm6, zmm7, zmm8, zmm9,\n+        zmm10, zmm11, zmm12, zmm13, zmm14, zmm15, zmm16, zmm17, zmm18,\n+\tzmm19, zmm20, zmm21, zmm22, zmm23, zmm24, zmm25, zmm26, zmm27,\n+\tzmm28, zmm29, zmm30, zmm31;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (zmm_regs, 0, sizeof (zmm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.zmm0) + (O), \\\n+\t\t     &zmm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.zmm1) + (O), \\\n+\t\t     &zmm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.zmm2) + (O), \\\n+\t\t     &zmm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.zmm3) + (O), \\\n+\t\t     &zmm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.zmm4) + (O), \\\n+\t\t     &zmm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.zmm5) + (O), \\\n+\t\t     &zmm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.zmm6) + (O), \\\n+\t\t     &zmm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.zmm7) + (O), \\\n+\t\t     &zmm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m512_arguments check_vector_arguments(m512, 0)\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "86d54d11c58e738169a1b93941b40064bf1e7a8a", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/asm-support.S", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fasm-support.S?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,100 @@\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tvmovdqu32 %zmm0, zmm_regs+0(%rip)\n+\tvmovdqu32 %zmm1, zmm_regs+64(%rip)\n+\tvmovdqu32 %zmm2, zmm_regs+128(%rip)\n+\tvmovdqu32 %zmm3, zmm_regs+192(%rip)\n+\tvmovdqu32 %zmm4, zmm_regs+256(%rip)\n+\tvmovdqu32 %zmm5, zmm_regs+320(%rip)\n+\tvmovdqu32 %zmm6, zmm_regs+384(%rip)\n+\tvmovdqu32 %zmm7, zmm_regs+448(%rip)\n+\tvmovdqu32 %zmm8, zmm_regs+512(%rip)\n+\tvmovdqu32 %zmm9, zmm_regs+576(%rip)\n+\tvmovdqu32 %zmm10, zmm_regs+640(%rip)\n+\tvmovdqu32 %zmm11, zmm_regs+704(%rip)\n+\tvmovdqu32 %zmm12, zmm_regs+768(%rip)\n+\tvmovdqu32 %zmm13, zmm_regs+832(%rip)\n+\tvmovdqu32 %zmm14, zmm_regs+896(%rip)\n+\tvmovdqu32 %zmm15, zmm_regs+960(%rip)\n+\tvmovdqu32 %zmm16, zmm_regs+1024(%rip)\n+\tvmovdqu32 %zmm17, zmm_regs+1088(%rip)\n+\tvmovdqu32 %zmm18, zmm_regs+1152(%rip)\n+\tvmovdqu32 %zmm19, zmm_regs+1216(%rip)\n+\tvmovdqu32 %zmm20, zmm_regs+1280(%rip)\n+\tvmovdqu32 %zmm21, zmm_regs+1344(%rip)\n+\tvmovdqu32 %zmm22, zmm_regs+1408(%rip)\n+\tvmovdqu32 %zmm23, zmm_regs+1472(%rip)\n+\tvmovdqu32 %zmm24, zmm_regs+1536(%rip)\n+\tvmovdqu32 %zmm25, zmm_regs+1600(%rip)\n+\tvmovdqu32 %zmm26, zmm_regs+1664(%rip)\n+\tvmovdqu32 %zmm27, zmm_regs+1728(%rip)\n+\tvmovdqu32 %zmm28, zmm_regs+1792(%rip)\n+\tvmovdqu32 %zmm29, zmm_regs+1856(%rip)\n+\tvmovdqu32 %zmm30, zmm_regs+1920(%rip)\n+\tvmovdqu32 %zmm31, zmm_regs+1984(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tsubq\t$8, %rsp\n+\tcall\t*callthis(%rip)\n+\taddq\t$8, %rsp\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tvmovdqu32\t%zmm0, zmm_regs+0(%rip)\n+\tvmovdqu32\t%zmm1, zmm_regs+64(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\tzmm_regs,2048,64\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8\n+#ifdef __linux__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+#endif"}, {"sha": "8379fcfaf8c41d3f328ac48e348bdbf3dc72c6e7", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/bf16-zmm-check.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fbf16-zmm-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fbf16-zmm-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Fbf16-zmm-check.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,23 @@\n+#include <stdlib.h>\n+\n+static void do_test (void);\n+\n+int\n+main ()\n+{\n+\n+  if (__builtin_cpu_supports (\"avx512f\"))\n+    {\n+      do_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+      return 0;\n+    }\n+\n+#ifdef DEBUG\n+  printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "1a2500bd88384a99402d967bf21db770f436a29c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/test_m512_returning.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_m512_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_m512_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_m512_returning.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,44 @@\n+#include <stdio.h>\n+#include \"bf16-zmm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\tbf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\tbf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32;\n+\n+__m512bf16\n+fun_test_returning___m512bf16 (void)\n+{\n+  volatile_var++;\n+  return (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\tbf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\tbf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+}\n+\n+__m512bf16 test_512bf16;\n+\n+static void\n+do_test (void)\n+{\n+  unsigned failed = 0;\n+  ZMM_T zmmt1, zmmt2;\n+\n+  clear_struct_registers;\n+  test_512bf16 = (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t\tbf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t\tbf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+  zmmt1._m512bf16[0] = test_512bf16;\n+  zmmt2._m512bf16[0] = WRAP_RET (fun_test_returning___m512bf16)();\n+  if (memcmp (&zmmt1, &zmmt2, sizeof (zmmt2)) != 0)\n+    printf (\"fail m512bf16\\n\"), failed++;\n+\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "1c5c407efee7d22bd649d4b7bff5b2be70414569", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/test_passing_m512.c", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_m512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_m512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_m512.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,243 @@\n+#include <stdio.h>\n+#include \"bf16-zmm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  ZMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,\n+    i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+fun_check_passing_m512bf16_8_values (__m512bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m512bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m512bf16);\n+  compare (values.i1, i1, __m512bf16);\n+  compare (values.i2, i2, __m512bf16);\n+  compare (values.i3, i3, __m512bf16);\n+  compare (values.i4, i4, __m512bf16);\n+  compare (values.i5, i5, __m512bf16);\n+  compare (values.i6, i6, __m512bf16);\n+  compare (values.i7, i7, __m512bf16);\n+}\n+\n+void\n+fun_check_passing_m512bf16_8_regs (__m512bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m512bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+void\n+fun_check_passing_m512bf16_20_values (__m512bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m512bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m512bf16);\n+  compare (values.i1, i1, __m512bf16);\n+  compare (values.i2, i2, __m512bf16);\n+  compare (values.i3, i3, __m512bf16);\n+  compare (values.i4, i4, __m512bf16);\n+  compare (values.i5, i5, __m512bf16);\n+  compare (values.i6, i6, __m512bf16);\n+  compare (values.i7, i7, __m512bf16);\n+  compare (values.i8, i8, __m512bf16);\n+  compare (values.i9, i9, __m512bf16);\n+  compare (values.i10, i10, __m512bf16);\n+  compare (values.i11, i11, __m512bf16);\n+  compare (values.i12, i12, __m512bf16);\n+  compare (values.i13, i13, __m512bf16);\n+  compare (values.i14, i14, __m512bf16);\n+  compare (values.i15, i15, __m512bf16);\n+  compare (values.i16, i16, __m512bf16);\n+  compare (values.i17, i17, __m512bf16);\n+  compare (values.i18, i18, __m512bf16);\n+  compare (values.i19, i19, __m512bf16);\n+}\n+\n+void\n+fun_check_passing_m512bf16_20_regs (__m512bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m512bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+#define def_check_passing8(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, \\\n+\t\t\t    _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, \\\n+\t\t\t    _i18, _i19, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, \\\n+\t\t     _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, \\\n+\t\t     _i18, _i19); \\\n+  \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, \\\n+\t\t     _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, \\\n+\t\t     _i18, _i19);\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\tbf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\tbf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32;\n+\n+void\n+test_m512bf16_on_stack ()\n+{\n+  __m512bf16 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t  bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t  bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+\n+  pass = \"m512bf16-8\";\n+  def_check_passing8 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t      fun_check_passing_m512bf16_8_values,\n+\t\t      fun_check_passing_m512bf16_8_regs, _m512bf16);\n+}\n+\n+void\n+test_too_many_m512bf16 ()\n+{\n+  __m512bf16 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t  bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t  bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+  pass = \"m512bf16-20\";\n+  def_check_passing20 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8],\n+\t\t       x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16],\n+\t\t       x[17], x[18], x[19], fun_check_passing_m512bf16_20_values,\n+\t\t       fun_check_passing_m512bf16_20_regs, _m512bf16);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_m512bf16_on_stack ();\n+  test_too_many_m512bf16 ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "f93a2b810869106726d2f334a5814d17ccb13812", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/test_passing_structs.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_structs.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,77 @@\n+#include \"bf16-zmm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+struct m512bf16_struct\n+{\n+  __m512bf16 x;\n+};\n+\n+struct m512bf16_2_struct\n+{\n+  __m512bf16 x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing1bf16 (struct m512bf16_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m512bf16_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+void\n+check_struct_passing2bf16 (struct m512bf16_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+72);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32;\n+  struct m512bf16_struct m512bf16s [8];\n+  struct m512bf16_2_struct m512bf16_2s = {\n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+      bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+      bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 },\n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+      bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+      bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 }\n+  };\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      m512bf16s[i].x = (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\t      bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t\t      bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t\t      bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.zmm0)[i]._m512bf16[0] = m512bf16s[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1bf16) (m512bf16s[0], m512bf16s[1], m512bf16s[2], m512bf16s[3],\n+\t\t\t\t\t m512bf16s[4], m512bf16s[5], m512bf16s[6], m512bf16s[7]);\n+  WRAP_CALL (check_struct_passing2bf16) (m512bf16_2s);\n+}"}, {"sha": "3769b38aeb7f82169696c9cfbe082d5a320bb6c6", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/test_passing_unions.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_passing_unions.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,222 @@\n+#include \"bf16-zmm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+union un1b\n+{\n+  __m512bf16 x;\n+  float f;\n+};\n+\n+union un1bb\n+{\n+  __m512bf16 x;\n+  __bf16 f;\n+};\n+\n+union un2b\n+{\n+  __m512bf16 x;\n+  double d;\n+};\n+\n+union un3b\n+{\n+  __m512bf16 x;\n+  __m128 v;\n+};\n+\n+union un4b\n+{\n+  __m512bf16 x;\n+  long double ld;\n+};\n+\n+union un5b\n+{\n+  __m512bf16 x;\n+  int i;\n+};\n+\n+union un6b\n+{\n+  __m512bf16 x;\n+  __m256 v;\n+};\n+\n+void\n+check_union_passing1b (union un1b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+void\n+check_union_passing1bb (union un1bb u1 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u2 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u3 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u4 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u5 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u6 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u7 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+\n+void\n+check_union_passing2b (union un2b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+void\n+check_union_passing3b (union un3b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+void\n+check_union_passing4b (union un4b u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+void\n+check_union_passing5b (union un5b u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+void\n+check_union_passing6b (union un6b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un6b u8 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m512_arguments;\n+}\n+\n+#define check_union_passing1b WRAP_CALL(check_union_passing1b)\n+#define check_union_passing1bf WRAP_CALL(check_union_passing1bf)\n+#define check_union_passing1bb WRAP_CALL(check_union_passing1bb)\n+#define check_union_passing2b WRAP_CALL(check_union_passing2b)\n+#define check_union_passing3b WRAP_CALL(check_union_passing3b)\n+#define check_union_passing4b WRAP_CALL(check_union_passing4b)\n+#define check_union_passing5b WRAP_CALL(check_union_passing5b)\n+#define check_union_passing6b WRAP_CALL(check_union_passing6b)\n+\n+\n+static void\n+do_test (void)\n+{\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32;\n+  union un1b u1b[8];\n+  union un1bb u1bb[8];\n+  union un2b u2b[8];\n+  union un3b u3b[8];\n+  union un4b u4b;\n+  union un5b u5b;\n+  union un6b u6b[8];\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1b[i].x =  (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t\t bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t\t bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t\t bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.zmm0)[i]._m512bf16[0] = u1b[i].x;\n+  num_fregs = 8;\n+  check_union_passing1b (u1b[0], u1b[1], u1b[2], u1b[3],\n+\t\t         u1b[4], u1b[5], u1b[6], u1b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1bb[i].x = u1b[i].x;\n+      (&fregs.zmm0)[i]._m512bf16[0] = u1bb[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing1bb (u1bb[0], u1bb[1], u1bb[2], u1bb[3],\n+\t\t          u1bb[4], u1bb[5], u1bb[6], u1bb[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2b[i].x = u1bb[i].x;\n+      (&fregs.zmm0)[i]._m512bf16[0] = u2b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2b (u2b[0], u2b[1], u2b[2], u2b[3],\n+\t\t         u2b[4], u2b[5], u2b[6], u2b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3b[i].x = u1b[i].x;\n+      (&fregs.zmm0)[i]._m512bf16[0] = u3b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3b (u3b[0], u3b[1], u3b[2], u3b[3],\n+\t\t\t u3b[4], u3b[5], u3b[6], u3b[7]);\n+\n+  check_union_passing4b (u4b);\n+  check_union_passing5b (u5b);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u6b[i].x = u1b[i].x;\n+      (&fregs.zmm0)[i]._m512bf16[0] = u6b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing6b (u6b[0], u6b[1], u6b[2], u6b[3],\n+\t\t\t u6b[4], u6b[5], u6b[6], u6b[7]);\n+}"}, {"sha": "2be57b8b5fbf47e49b7355930b5ee4ccd4968e0e", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/m512bf16/test_varargs-m512.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_varargs-m512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_varargs-m512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fm512bf16%2Ftest_varargs-m512.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,111 @@\n+/* Test variable number of 512-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"bf16-zmm-check.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  ZMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m512bf16_varargs (__m512bf16 i0, __m512bf16 i1, __m512bf16 i2,\n+\t\t\t\t __m512bf16 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m512bf16 *argp;\n+\n+  compare (values.i0, i0, __m512bf16);\n+  compare (values.i1, i1, __m512bf16);\n+  compare (values.i2, i2, __m512bf16);\n+  compare (values.i3, i3, __m512bf16);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m512bf16 *)(((char *) fp) + 8);\n+\n+  /* Check __m512bf16 arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m512bf16);\n+  compare (values.i5, argp[1], __m512bf16);\n+  compare (values.i6, argp[2], __m512bf16);\n+  compare (values.i7, argp[3], __m512bf16);\n+  compare (values.i8, argp[4], __m512bf16);\n+  compare (values.i9, argp[5], __m512bf16);\n+\n+  /* Check register contents.  */\n+  compare (fregs.zmm0, zmm_regs[0], __m512bf16);\n+  compare (fregs.zmm1, zmm_regs[1], __m512bf16);\n+  compare (fregs.zmm2, zmm_regs[2], __m512bf16);\n+  compare (fregs.zmm3, zmm_regs[3], __m512bf16);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m512bf16_varargs (void)\n+{\n+  __m512bf16 x[10];\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32;\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m512bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t  bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t  bf17,bf18,bf19,bf20,bf21,bf22,bf23,bf24,\n+\t\t\t  bf25,bf26,bf27,bf28,bf29,bf30,bf31,bf32 };\n+  pass = \"m512bf16-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m512bf16_varargs,\n+\t\t\t\t _m512bf16);\n+}\n+\n+void\n+do_test (void)\n+{\n+  test_m512bf16_varargs ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "98fbc660f277504edecccd7425b1cca41a19932f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/macros.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Fmacros.h?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,53 @@\n+#ifndef MACROS_H\n+\n+#define check_size(_t, _size) assert(sizeof(_t) == (_size))\n+\n+#define check_align(_t, _align) assert(__alignof__(_t) == (_align))\n+\n+#define check_align_lv(_t, _align) assert(__alignof__(_t) == (_align) \\\n+\t\t\t\t\t  && (((unsigned long)&(_t)) & ((_align) - 1) ) == 0)\n+\n+#define check_basic_struct_size_and_align(_type, _size, _align) { \\\n+  struct _str { _type dummy; } _t; \\\n+  check_size(_t, _size); \\\n+  check_align_lv(_t, _align); \\\n+}\n+\n+#define check_array_size_and_align(_type, _size, _align) { \\\n+  _type _a[1]; _type _b[2]; _type _c[16]; \\\n+  struct _str { _type _a[1]; } _s; \\\n+  check_align_lv(_a[0], _align); \\\n+  check_size(_a, _size); \\\n+  check_size(_b, (_size*2)); \\\n+  check_size(_c, (_size*16)); \\\n+  check_size(_s, _size); \\\n+  check_align_lv(_s._a[0], _align); \\\n+}\n+\n+#define check_basic_union_size_and_align(_type, _size, _align) { \\\n+  union _union { _type dummy; } _u; \\\n+  check_size(_u, _size); \\\n+  check_align_lv(_u, _align); \\\n+}\n+\n+#define run_signed_tests2(_function, _arg1, _arg2) \\\n+  _function(_arg1, _arg2); \\\n+  _function(signed _arg1, _arg2); \\\n+  _function(unsigned _arg1, _arg2);\n+\n+#define run_signed_tests3(_function, _arg1, _arg2, _arg3) \\\n+  _function(_arg1, _arg2, _arg3); \\\n+  _function(signed _arg1, _arg2, _arg3); \\\n+  _function(unsigned _arg1, _arg2, _arg3);\n+\n+/* Check size of a struct and a union of three types.  */\n+\n+#define check_struct_and_union3(type1, type2, type3, struct_size, align_size) \\\n+{ \\\n+  struct _str { type1 t1; type2 t2; type3 t3; } _t; \\\n+  union _uni { type1 t1; type2 t2; type3 t3; } _u; \\\n+  check_size(_t, struct_size); \\\n+  check_size(_u, align_size); \\\n+}\n+\n+#endif // MACROS_H"}, {"sha": "0c58db101e5a5329aed929291fa405d058616183", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_3_element_struct_and_unions.c", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_3_element_struct_and_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_3_element_struct_and_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_3_element_struct_and_unions.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,214 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+/* Check structs and unions of all permutations of 3 basic types.  */\n+int\n+main (void)\n+{\n+  check_struct_and_union3(char, char, __bf16, 4, 2);\n+  check_struct_and_union3(char, __bf16, char, 6, 2);\n+  check_struct_and_union3(char, __bf16, __bf16, 6, 2);\n+  check_struct_and_union3(char, __bf16, int, 8, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(char, __bf16, long, 16, 8);\n+#endif\n+  check_struct_and_union3(char, __bf16, long long, 16, 8);\n+  check_struct_and_union3(char, __bf16, float, 8, 4);\n+  check_struct_and_union3(char, __bf16, double, 16, 8);\n+  check_struct_and_union3(char, __bf16, long double, 32, 16);\n+  check_struct_and_union3(char, int, __bf16, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(char, long, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(char, long long, __bf16, 24, 8);\n+  check_struct_and_union3(char, float, __bf16, 12, 4);\n+  check_struct_and_union3(char, double, __bf16, 24, 8);\n+  check_struct_and_union3(char, long double, __bf16, 48, 16);\n+  check_struct_and_union3(__bf16, char, char, 4, 2);\n+  check_struct_and_union3(__bf16, char, __bf16, 6, 2);\n+  check_struct_and_union3(__bf16, char, int, 8, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(__bf16, char, long, 16, 8);\n+#endif\n+  check_struct_and_union3(__bf16, char, long long, 16, 8);\n+  check_struct_and_union3(__bf16, char, float, 8, 4);\n+  check_struct_and_union3(__bf16, char, double, 16, 8);\n+  check_struct_and_union3(__bf16, char, long double, 32, 16);\n+  check_struct_and_union3(__bf16, __bf16, char, 6, 2);\n+  check_struct_and_union3(__bf16, __bf16, __bf16, 6, 2);\n+  check_struct_and_union3(__bf16, __bf16, int, 8, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(__bf16, __bf16, long, 16, 8);\n+#endif\n+  check_struct_and_union3(__bf16, __bf16, long long, 16, 8);\n+  check_struct_and_union3(__bf16, __bf16, float, 8, 4);\n+  check_struct_and_union3(__bf16, __bf16, double, 16, 8);\n+  check_struct_and_union3(__bf16, __bf16, long double, 32, 16);\n+  check_struct_and_union3(__bf16, int, char, 12, 4);\n+  check_struct_and_union3(__bf16, int, __bf16, 12, 4);\n+  check_struct_and_union3(__bf16, int, int, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(__bf16, int, long, 16, 8);\n+#endif\n+  check_struct_and_union3(__bf16, int, long long, 16, 8);\n+  check_struct_and_union3(__bf16, int, float, 12, 4);\n+  check_struct_and_union3(__bf16, int, double, 16, 8);\n+  check_struct_and_union3(__bf16, int, long double, 32, 16);\n+#ifndef __ILP32__\n+  check_struct_and_union3(__bf16, long, char, 24, 8);\n+  check_struct_and_union3(__bf16, long, __bf16, 24, 8);\n+  check_struct_and_union3(__bf16, long, int, 24, 8);\n+  check_struct_and_union3(__bf16, long, long, 24, 8);\n+  check_struct_and_union3(__bf16, long, long long, 24, 8);\n+  check_struct_and_union3(__bf16, long, float, 24, 8);\n+  check_struct_and_union3(__bf16, long, double, 24, 8);\n+#endif\n+  check_struct_and_union3(__bf16, long, long double, 32, 16);\n+  check_struct_and_union3(__bf16, long long, char, 24, 8);\n+  check_struct_and_union3(__bf16, long long, __bf16, 24, 8);\n+  check_struct_and_union3(__bf16, long long, int, 24, 8);\n+  check_struct_and_union3(__bf16, long long, long, 24, 8);\n+  check_struct_and_union3(__bf16, long long, long long, 24, 8);\n+  check_struct_and_union3(__bf16, long long, float, 24, 8);\n+  check_struct_and_union3(__bf16, long long, double, 24, 8);\n+  check_struct_and_union3(__bf16, long long, long double, 32, 16);\n+  check_struct_and_union3(__bf16, float, char, 12, 4);\n+  check_struct_and_union3(__bf16, float, __bf16, 12, 4);\n+  check_struct_and_union3(__bf16, float, int, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(__bf16, float, long, 16, 8);\n+#endif\n+  check_struct_and_union3(__bf16, float, long long, 16, 8);\n+  check_struct_and_union3(__bf16, float, float, 12, 4);\n+  check_struct_and_union3(__bf16, float, double, 16, 8);\n+  check_struct_and_union3(__bf16, float, long double, 32, 16);\n+  check_struct_and_union3(__bf16, double, char, 24, 8);\n+  check_struct_and_union3(__bf16, double, __bf16, 24, 8);\n+  check_struct_and_union3(__bf16, double, int, 24, 8);\n+  check_struct_and_union3(__bf16, double, long, 24, 8);\n+  check_struct_and_union3(__bf16, double, long long, 24, 8);\n+  check_struct_and_union3(__bf16, double, float, 24, 8);\n+  check_struct_and_union3(__bf16, double, double, 24, 8);\n+  check_struct_and_union3(__bf16, double, long double, 32, 16);\n+  check_struct_and_union3(__bf16, long double, char, 48, 16);\n+  check_struct_and_union3(__bf16, long double, __bf16, 48, 16);\n+  check_struct_and_union3(__bf16, long double, int, 48, 16);\n+  check_struct_and_union3(__bf16, long double, long, 48, 16);\n+  check_struct_and_union3(__bf16, long double, long long, 48, 16);\n+  check_struct_and_union3(__bf16, long double, float, 48, 16);\n+  check_struct_and_union3(__bf16, long double, double, 48, 16);\n+  check_struct_and_union3(__bf16, long double, long double, 48, 16);\n+  check_struct_and_union3(int, char, __bf16, 8, 4);\n+  check_struct_and_union3(int, __bf16, char, 8, 4);\n+  check_struct_and_union3(int, __bf16, __bf16, 8, 4);\n+  check_struct_and_union3(int, __bf16, int, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(int, __bf16, long, 16, 8);\n+#endif\n+  check_struct_and_union3(int, __bf16, long long, 16, 8);\n+  check_struct_and_union3(int, __bf16, float, 12, 4);\n+  check_struct_and_union3(int, __bf16, double, 16, 8);\n+  check_struct_and_union3(int, __bf16, long double, 32, 16);\n+  check_struct_and_union3(int, int, __bf16, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(int, long, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(int, long long, __bf16, 24, 8);\n+  check_struct_and_union3(int, float, __bf16, 12, 4);\n+  check_struct_and_union3(int, double, __bf16, 24, 8);\n+  check_struct_and_union3(int, long double, __bf16, 48, 16);\n+#ifndef __ILP32__\n+  check_struct_and_union3(long, char, __bf16, 16, 8);\n+  check_struct_and_union3(long, __bf16, char, 16, 8);\n+  check_struct_and_union3(long, __bf16, __bf16, 16, 8);\n+  check_struct_and_union3(long, __bf16, int, 16, 8);\n+  check_struct_and_union3(long, __bf16, long, 24, 8);\n+  check_struct_and_union3(long, __bf16, long long, 24, 8);\n+  check_struct_and_union3(long, __bf16, float, 16, 8);\n+  check_struct_and_union3(long, __bf16, double, 24, 8);\n+#endif\n+  check_struct_and_union3(long, __bf16, long double, 32, 16);\n+#ifndef __ILP32__\n+  check_struct_and_union3(long, int, __bf16, 16, 8);\n+  check_struct_and_union3(long, long, __bf16, 24, 8);\n+  check_struct_and_union3(long, long long, __bf16, 24, 8);\n+  check_struct_and_union3(long, float, __bf16, 16, 8);\n+  check_struct_and_union3(long, double, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(long, long double, __bf16, 48, 16);\n+  check_struct_and_union3(long long, char, __bf16, 16, 8);\n+  check_struct_and_union3(long long, __bf16, char, 16, 8);\n+  check_struct_and_union3(long long, __bf16, __bf16, 16, 8);\n+  check_struct_and_union3(long long, __bf16, int, 16, 8);\n+#ifndef __ILP32__\n+  check_struct_and_union3(long long, __bf16, long, 24, 8);\n+#endif\n+  check_struct_and_union3(long long, __bf16, long long, 24, 8);\n+  check_struct_and_union3(long long, __bf16, float, 16, 8);\n+  check_struct_and_union3(long long, __bf16, double, 24, 8);\n+  check_struct_and_union3(long long, __bf16, long double, 32, 16);\n+  check_struct_and_union3(long long, int, __bf16, 16, 8);\n+#ifndef __ILP32__\n+  check_struct_and_union3(long long, long, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(long long, long long, __bf16, 24, 8);\n+  check_struct_and_union3(long long, float, __bf16, 16, 8);\n+  check_struct_and_union3(long long, double, __bf16, 24, 8);\n+  check_struct_and_union3(long long, long double, __bf16, 48, 16);\n+  check_struct_and_union3(float, char, __bf16, 8, 4);\n+  check_struct_and_union3(float, __bf16, char, 8, 4);\n+  check_struct_and_union3(float, __bf16, __bf16, 8, 4);\n+  check_struct_and_union3(float, __bf16, int, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(float, __bf16, long, 16, 8);\n+#endif\n+  check_struct_and_union3(float, __bf16, long long, 16, 8);\n+  check_struct_and_union3(float, __bf16, float, 12, 4);\n+  check_struct_and_union3(float, __bf16, double, 16, 8);\n+  check_struct_and_union3(float, __bf16, long double, 32, 16);\n+  check_struct_and_union3(float, int, __bf16, 12, 4);\n+#ifndef __ILP32__\n+  check_struct_and_union3(float, long, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(float, long long, __bf16, 24, 8);\n+  check_struct_and_union3(float, float, __bf16, 12, 4);\n+  check_struct_and_union3(float, double, __bf16, 24, 8);\n+  check_struct_and_union3(float, long double, __bf16, 48, 16);\n+  check_struct_and_union3(double, char, __bf16, 16, 8);\n+  check_struct_and_union3(double, __bf16, char, 16, 8);\n+  check_struct_and_union3(double, __bf16, __bf16, 16, 8);\n+  check_struct_and_union3(double, __bf16, int, 16, 8);\n+#ifndef __ILP32__\n+  check_struct_and_union3(double, __bf16, long, 24, 8);\n+#endif\n+  check_struct_and_union3(double, __bf16, long long, 24, 8);\n+  check_struct_and_union3(double, __bf16, float, 16, 8);\n+  check_struct_and_union3(double, __bf16, double, 24, 8);\n+  check_struct_and_union3(double, __bf16, long double, 32, 16);\n+  check_struct_and_union3(double, int, __bf16, 16, 8);\n+#ifndef __ILP32__\n+  check_struct_and_union3(double, long, __bf16, 24, 8);\n+#endif\n+  check_struct_and_union3(double, long long, __bf16, 24, 8);\n+  check_struct_and_union3(double, float, __bf16, 16, 8);\n+  check_struct_and_union3(double, double, __bf16, 24, 8);\n+  check_struct_and_union3(double, long double, __bf16, 48, 16);\n+  check_struct_and_union3(long double, char, __bf16, 32, 16);\n+  check_struct_and_union3(long double, __bf16, char, 32, 16);\n+  check_struct_and_union3(long double, __bf16, __bf16, 32, 16);\n+  check_struct_and_union3(long double, __bf16, int, 32, 16);\n+  check_struct_and_union3(long double, __bf16, long, 32, 16);\n+  check_struct_and_union3(long double, __bf16, long long, 32, 16);\n+  check_struct_and_union3(long double, __bf16, float, 32, 16);\n+  check_struct_and_union3(long double, __bf16, double, 32, 16);\n+  check_struct_and_union3(long double, __bf16, long double, 48, 16);\n+  check_struct_and_union3(long double, int, __bf16, 32, 16);\n+  check_struct_and_union3(long double, long, __bf16, 32, 16);\n+  check_struct_and_union3(long double, long long, __bf16, 32, 16);\n+  check_struct_and_union3(long double, float, __bf16, 32, 16);\n+  check_struct_and_union3(long double, double, __bf16, 32, 16);\n+  check_struct_and_union3(long double, long double, __bf16, 48, 16);\n+  return 0;\n+}"}, {"sha": "6490a5228cabd9e14159960a491b8e18ad794182", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_alignment.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_alignment.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,14 @@\n+/* This checks alignment of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* __bf16 point types.  */\n+  check_align(__bf16, TYPE_ALIGN_BF16);\n+\n+  return 0;\n+}"}, {"sha": "c004c35bb83e9af16935e9317b06fa3951184bd7", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_array_size_and_align.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_array_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_array_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_array_size_and_align.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,13 @@\n+/* This checks .  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  check_array_size_and_align(__bf16, TYPE_SIZE_BF16, TYPE_ALIGN_BF16);\n+\n+  return 0;\n+}"}, {"sha": "cfea2224733b82372d53b1754ec546fe304a2c3b", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_returning.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_returning.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,20 @@\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+__bf16\n+fun_test_returning_bf16 (void)\n+{\n+  __bf16 b = make_f32_bf16 (72.0f);\n+  volatile_var++;\n+  return b;\n+}\n+\n+static void\n+do_test (void)\n+{\n+  __bf16 var = WRAP_RET (fun_test_returning_bf16) ();\n+  assert (check_bf16_float (xmm_regs[0].___bf16[0], 72.0f) == 1);\n+  assert (check_bf16_float (var, 72.0f) == 1);\n+}"}, {"sha": "b81a8d971b53f741522a9924f931a0160ba17ca7", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_sizes.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_sizes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_sizes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_sizes.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,14 @@\n+/* This checks sizes of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Floating point types.  */\n+  check_size(__bf16, TYPE_SIZE_BF16);\n+\n+  return 0;\n+}"}, {"sha": "f282506703c93063e0a91c54daa2f4544bbf147c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_struct_size_and_align.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_struct_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_struct_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_struct_size_and_align.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,14 @@\n+/* This checks size and alignment of structs with a single basic type\n+   element. All basic types are checked.  */\n+\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+static void\n+do_test (void)\n+{\n+  /* Floating point types.  */\n+  check_basic_struct_size_and_align(__bf16, TYPE_SIZE_BF16, TYPE_ALIGN_BF16);\n+}"}, {"sha": "03afa68c0e4bf43ce839bdaa936567765c446025", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_basic_union_size_and_align.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_union_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_union_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_basic_union_size_and_align.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,12 @@\n+/* Test of simple unions, size and alignment.  */\n+\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+static void\n+do_test (void)\n+{\n+  /* Floating point types.  */\n+  check_basic_union_size_and_align(__bf16, TYPE_SIZE_BF16, TYPE_ALIGN_BF16);\n+}"}, {"sha": "64857ce7b71b0adb1d55d8aeffc5ec5f0b76541b", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_m128_returning.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_m128_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_m128_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_m128_returning.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,38 @@\n+#include <stdio.h>\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8;\n+\n+__m128bf16\n+fun_test_returning___m128bf16 (void)\n+{\n+  volatile_var++;\n+  return (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+}\n+\n+__m128bf16 test_128bf16;\n+\n+static void\n+do_test (void)\n+{\n+  unsigned failed = 0;\n+  XMM_T xmmt1, xmmt2;\n+\n+  clear_struct_registers;\n+  test_128bf16 = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+  xmmt1._m128bf16[0] = test_128bf16;\n+  xmmt2._m128bf16[0] = WRAP_RET (fun_test_returning___m128bf16)();\n+  if (xmmt1._longlong[0] != xmmt2._longlong[0]\n+      || xmmt1._longlong[0] != xmm_regs[0]._longlong[0])\n+    printf (\"fail m128bf16\\n\"), failed++;\n+\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "fe08042286b279d25f34794cccb169c5c2af52dc", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_passing_floats.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_floats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_floats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_floats.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,312 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  __bf16 f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14,\n+    f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values___bf16;\n+\n+void\n+fun_check_bf16_passing_8_values (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t\t __bf16 f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  check_bf16 (values___bf16.f0, f0);\n+  check_bf16 (values___bf16.f1, f1);\n+  check_bf16 (values___bf16.f2, f2);\n+  check_bf16 (values___bf16.f3, f3);\n+  check_bf16 (values___bf16.f4, f4);\n+  check_bf16 (values___bf16.f5, f5);\n+  check_bf16 (values___bf16.f6, f6);\n+  check_bf16 (values___bf16.f7, f7);\n+}\n+\n+void\n+fun_check_bf16_passing_8_regs (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t       __bf16 f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_bf16_arguments;\n+}\n+\n+void\n+fun_check_bf16_passing_16_values (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f7 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f8 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f9 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f10 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f11 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f12 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f13 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f14 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  check_bf16 (values___bf16.f0, f0);\n+  check_bf16 (values___bf16.f1, f1);\n+  check_bf16 (values___bf16.f2, f2);\n+  check_bf16 (values___bf16.f3, f3);\n+  check_bf16 (values___bf16.f4, f4);\n+  check_bf16 (values___bf16.f5, f5);\n+  check_bf16 (values___bf16.f6, f6);\n+  check_bf16 (values___bf16.f7, f7);\n+  check_bf16 (values___bf16.f8, f8);\n+  check_bf16 (values___bf16.f9, f9);\n+  check_bf16 (values___bf16.f10, f10);\n+  check_bf16 (values___bf16.f11, f11);\n+  check_bf16 (values___bf16.f12, f12);\n+  check_bf16 (values___bf16.f13, f13);\n+  check_bf16 (values___bf16.f14, f14);\n+  check_bf16 (values___bf16.f15, f15);\n+}\n+\n+void\n+fun_check_bf16_passing_16_regs (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f7 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f8 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f9 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f10 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f11 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f12 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f13 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f14 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_bf16_arguments;\n+}\n+\n+void\n+fun_check_bf16_passing_20_values (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f7 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f8 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f9 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f10 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f11 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f12 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f13 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f14 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f15 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f16 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f17 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f18 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __bf16 f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  check_bf16 (values___bf16.f0, f0);\n+  check_bf16 (values___bf16.f1, f1);\n+  check_bf16 (values___bf16.f2, f2);\n+  check_bf16 (values___bf16.f3, f3);\n+  check_bf16 (values___bf16.f4, f4);\n+  check_bf16 (values___bf16.f5, f5);\n+  check_bf16 (values___bf16.f6, f6);\n+  check_bf16 (values___bf16.f7, f7);\n+  check_bf16 (values___bf16.f8, f8);\n+  check_bf16 (values___bf16.f9, f9);\n+  check_bf16 (values___bf16.f10, f10);\n+  check_bf16 (values___bf16.f11, f11);\n+  check_bf16 (values___bf16.f12, f12);\n+  check_bf16 (values___bf16.f13, f13);\n+  check_bf16 (values___bf16.f14, f14);\n+  check_bf16 (values___bf16.f15, f15);\n+  check_bf16 (values___bf16.f16, f16);\n+  check_bf16 (values___bf16.f17, f17);\n+  check_bf16 (values___bf16.f18, f18);\n+  check_bf16 (values___bf16.f19, f19);\n+}\n+\n+void\n+fun_check_bf16_passing_20_regs (__bf16 f0 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f1 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f2 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f3 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f4 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f5 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f6 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f7 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f8 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f9 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f10 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f11 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f12 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f13 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f14 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f15 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f16 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f17 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f18 ATTRIBUTE_UNUSED,\n+\t\t\t\t__bf16 f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_bf16_arguments;\n+}\n+\n+#define def_check_bf16_passing8(_f0, _f1, _f2, _f3, _f4, _f5, _f6,\\\n+\t\t\t\t   _f7, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7); \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7);\n+\n+#define def_check_bf16_passing16(_f0, _f1, _f2, _f3, _f4, _f5, _f6, \\\n+\t\t\t\t    _f7, _f8, _f9, _f10, _f11, _f12, _f13, \\\n+\t\t\t\t    _f14, _f15, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, \\\n+\t\t     _f10, _f11, _f12, _f13, _f14, _f15); \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, \\\n+\t\t     _f10, _f11, _f12, _f13, _f14, _f15);\n+\n+#define def_check_bf16_passing20(_f0, _f1, _f2, _f3, _f4, _f5, _f6, \\\n+\t\t\t\t    _f7, _f8, _f9, _f10, _f11, _f12, \\\n+\t\t\t\t    _f13, _f14, _f15, _f16, _f17, \\\n+\t\t\t\t    _f18, _f19, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  values_ ## TYPE .f16 = _f16; \\\n+  values_ ## TYPE .f17 = _f17; \\\n+  values_ ## TYPE .f18 = _f18; \\\n+  values_ ## TYPE .f19 = _f19; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, \\\n+\t\t     _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, \\\n+\t\t     _f17, _f18, _f19); \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, \\\n+\t\t     _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, \\\n+\t\t     _f18, _f19);\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8, bf9, bf10,\n+\t\tbf11,bf12,bf13,bf14,bf15,bf16,bf17,bf18,bf19,bf20;\n+\n+void\n+test_bf16_on_stack ()\n+{\n+  def_check_bf16_passing8 (bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t   fun_check_bf16_passing_8_values,\n+\t\t\t   fun_check_bf16_passing_8_regs, __bf16);\n+\n+  def_check_bf16_passing16 (bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\t\t    bf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16,\n+\t\t\t    fun_check_bf16_passing_16_values,\n+\t\t\t    fun_check_bf16_passing_16_regs, __bf16);\n+}\n+\n+void\n+test_too_many_bf16 ()\n+{\n+  def_check_bf16_passing20 (bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8, bf9, bf10,\n+\t\t\t    bf11,bf12,bf13,bf14,bf15,bf16,bf17,bf18,bf19,bf20,\n+\t\t\t    fun_check_bf16_passing_20_values,\n+\t\t\t    fun_check_bf16_passing_20_regs, __bf16);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_bf16_on_stack ();\n+  test_too_many_bf16 ();\n+}"}, {"sha": "298b644e93df39609da81f608cd2a5653d4afd1f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_passing_m128.c", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_m128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_m128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_m128.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,238 @@\n+#include <stdio.h>\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  XMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,\n+    i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m128bf16_8_values (__m128bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t     __m128bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m128bf16);\n+  compare (values.i1, i1, __m128bf16);\n+  compare (values.i2, i2, __m128bf16);\n+  compare (values.i3, i3, __m128bf16);\n+  compare (values.i4, i4, __m128bf16);\n+  compare (values.i5, i5, __m128bf16);\n+  compare (values.i6, i6, __m128bf16);\n+  compare (values.i7, i7, __m128bf16);\n+}\n+\n+void\n+fun_check_passing_m128bf16_8_regs (__m128bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m128bf16 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m128_arguments;\n+}\n+\n+void\n+fun_check_passing_m128bf16_20_values (__m128bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t      __m128bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m128bf16);\n+  compare (values.i1, i1, __m128bf16);\n+  compare (values.i2, i2, __m128bf16);\n+  compare (values.i3, i3, __m128bf16);\n+  compare (values.i4, i4, __m128bf16);\n+  compare (values.i5, i5, __m128bf16);\n+  compare (values.i6, i6, __m128bf16);\n+  compare (values.i7, i7, __m128bf16);\n+  compare (values.i8, i8, __m128bf16);\n+  compare (values.i9, i9, __m128bf16);\n+  compare (values.i10, i10, __m128bf16);\n+  compare (values.i11, i11, __m128bf16);\n+  compare (values.i12, i12, __m128bf16);\n+  compare (values.i13, i13, __m128bf16);\n+  compare (values.i14, i14, __m128bf16);\n+  compare (values.i15, i15, __m128bf16);\n+  compare (values.i16, i16, __m128bf16);\n+  compare (values.i17, i17, __m128bf16);\n+  compare (values.i18, i18, __m128bf16);\n+  compare (values.i19, i19, __m128bf16);\n+}\n+\n+void\n+fun_check_passing_m128bf16_20_regs (__m128bf16 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t    __m128bf16 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m128_arguments;\n+}\n+\n+#define def_check_int_passing8(_i0, _i1, _i2, _i3, \\\n+\t\t\t       _i4, _i5, _i6, _i7, \\\n+\t\t\t       _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_int_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, \\\n+\t\t\t\t_i7, _i8, _i9, _i10, _i11, _i12, _i13, \\\n+\t\t\t\t_i14, _i15, _i16, _i17, _i18, _i19, \\\n+\t\t\t\t_func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, \\\n+\t\t     _i17, _i18, _i19); \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, \\\n+\t\t     _i17, _i18, _i19);\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8;\n+\n+void\n+test_m128bf16_on_stack ()\n+{\n+  __m128bf16 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+  pass = \"m128bf16-8\";\n+  def_check_int_passing8 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t\t  fun_check_passing_m128bf16_8_values,\n+\t\t\t  fun_check_passing_m128bf16_8_regs, _m128bf16);\n+}\n+\n+void\n+test_too_many_m128bf16 ()\n+{\n+  __m128bf16 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+  pass = \"m128bf16-20\";\n+  def_check_int_passing20 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t\t   x[8], x[9], x[10], x[11], x[12], x[13], x[14],\n+\t\t\t   x[15], x[16], x[17], x[18], x[19],\n+\t\t\t   fun_check_passing_m128bf16_20_values,\n+\t\t\t   fun_check_passing_m128bf16_20_regs, _m128bf16);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_m128bf16_on_stack ();\n+  test_too_many_m128bf16 ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "8d96600574170d590d39c327ee2fba7a818a1e39", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_passing_structs.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_structs.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,67 @@\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+struct m128bf16_struct\n+{\n+  __m128bf16 x;\n+};\n+\n+struct m128bf16_2_struct\n+{\n+  __m128bf16 x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing1bf16 (struct m128bf16_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t\t   struct m128bf16_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_struct_passing2bf16 (struct m128bf16_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+24);\n+}\n+\n+volatile __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8,\n+\t\tbf9, bf10,bf11,bf12,bf13,bf14,bf15,bf16;\n+\n+static void\n+do_test (void)\n+{\n+  struct m128bf16_struct m128bf16s [8];\n+  struct m128bf16_2_struct m128bf16_2s = { \n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 },\n+    { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 },\n+  };\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      m128bf16s[i].x = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.xmm0)[i]._m128bf16[0] = m128bf16s[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1bf16) (m128bf16s[0], m128bf16s[1], m128bf16s[2], m128bf16s[3],\n+\t\t\t\t\t m128bf16s[4], m128bf16s[5], m128bf16s[6], m128bf16s[7]);\n+  WRAP_CALL (check_struct_passing2bf16) (m128bf16_2s);\n+}"}, {"sha": "83e4380512bd05c3e6cc10c8c9c7147321236868", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_passing_unions.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_passing_unions.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,160 @@\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+unsigned int num_fregs, num_iregs;\n+\n+union un1b\n+{\n+  __m128bf16 x;\n+  float f;\n+};\n+\n+union un1bb\n+{\n+  __m128bf16 x;\n+  __bf16 f;\n+};\n+\n+union un2b\n+{\n+  __m128bf16 x;\n+  double d;\n+};\n+\n+union un3b\n+{\n+  __m128bf16 x;\n+  __m128 v;\n+};\n+\n+union un4b\n+{\n+  __m128bf16 x;\n+  long double ld;\n+};\n+\n+void\n+check_union_passing1b (union un1b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un1b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_union_passing1bb (union un1bb u1 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u2 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u3 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u4 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u5 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u6 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u7 ATTRIBUTE_UNUSED,\n+\t\t        union un1bb u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_union_passing2b (union un2b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un2b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_union_passing3b (union un3b u1 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u2 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u3 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u4 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u5 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u6 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u7 ATTRIBUTE_UNUSED,\n+\t\t       union un3b u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_union_passing4b (union un4b u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+#define check_union_passing1b WRAP_CALL(check_union_passing1b)\n+#define check_union_passing1bb WRAP_CALL(check_union_passing1bb)\n+#define check_union_passing2b WRAP_CALL(check_union_passing2b)\n+#define check_union_passing3b WRAP_CALL(check_union_passing3b)\n+#define check_union_passing4b WRAP_CALL(check_union_passing4b)\n+\n+static void\n+do_test (void)\n+{\n+  union un1b u1b[8];\n+  union un1bb u1bb[8];\n+  union un2b u2b[8];\n+  union un3b u3b[8];\n+  union un4b u4b;\n+  int i;\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1b[i].x = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.xmm0)[i]._m128bf16[0] = u1b[i].x;\n+  num_fregs = 8;\n+  check_union_passing1b (u1b[0], u1b[1], u1b[2], u1b[3],\n+\t\t         u1b[4], u1b[5], u1b[6], u1b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1bb[i].x = u1b[i].x;\n+      (&fregs.xmm0)[i]._m128bf16[0] = u1bb[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing1bb (u1bb[0], u1bb[1], u1bb[2], u1bb[3],\n+\t\t          u1bb[4], u1bb[5], u1bb[6], u1bb[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2b[i].x = u1b[i].x;\n+      (&fregs.xmm0)[i]._m128bf16[0] = u2b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2b (u2b[0], u2b[1], u2b[2], u2b[3],\n+\t\t         u2b[4], u2b[5], u2b[6], u2b[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3b[i].x = u1b[i].x;\n+      (&fregs.xmm0)[i]._m128bf16[0] = u3b[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3b (u3b[0], u3b[1], u3b[2], u3b[3],\n+\t\t         u3b[4], u3b[5], u3b[6], u3b[7]);\n+\n+  check_union_passing4b (u4b);\n+}"}, {"sha": "757ccc26b79fcc8bc27bb8ff2d1e23143b3cd49c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_struct_returning.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_struct_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_struct_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_struct_returning.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,176 @@\n+/* This tests returning of structures.  */\n+\n+#include <stdio.h>\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+int current_test;\n+int num_failed = 0;\n+\n+#undef assert\n+#define assert(test) do { if (!(test)) {fprintf (stderr, \"failed in test %d\\n\", current_test); num_failed++; } } while (0)\n+\n+#define xmm0b xmm_regs[0].___bf16\n+#define xmm1b xmm_regs[1].___bf16\n+#define xmm0f xmm_regs[0]._float\n+#define xmm0d xmm_regs[0]._double\n+#define xmm1f xmm_regs[1]._float\n+#define xmm1d xmm_regs[1]._double\n+\n+typedef enum {\n+  SSE_B = 0,\n+  SSE_D,\n+  MEM,\n+  INT_SSE,\n+  SSE_INT,\n+  SSE_F_H,\n+  SSE_F_H8\n+} Type;\n+\n+/* Structures which should be returned in SSE.  */\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s)); B; return s; }\n+\n+D(120,__bf16 f,SSE_B, s.f=make_f32_bf16(42.0f))\n+D(121,__bf16 f;__bf16 f2,SSE_B, s.f=make_f32_bf16(42.0f))\n+D(122,__bf16 f;float d,SSE_B, s.f=make_f32_bf16(42.0f))\n+D(123,__bf16 f;double d,SSE_B, s.f=make_f32_bf16(42.0f))\n+D(124,double d; __bf16 f,SSE_D, s.d=42)\n+D(125,__bf16 f[2],SSE_B, s.f[0]=make_f32_bf16(42.0f))\n+D(126,__bf16 f[3],SSE_B, s.f[0]=make_f32_bf16(42.0f))\n+D(127,__bf16 f[4],SSE_B, s.f[0]=make_f32_bf16(42.0f))\n+D(128,__bf16 f[2]; double d,SSE_B, s.f[0]=make_f32_bf16(42.0f))\n+D(129,double d;__bf16 f[2],SSE_D, s.d=42)\n+\n+#undef D\n+\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = INT_SSE; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s = { 42, make_f32_bf16(43.0f) }; return s; }\n+\n+D(310,char m1; __bf16 m2)\n+D(311,short m1; __bf16 m2)\n+D(312,int m1; __bf16 m2)\n+D(313,long long m1; __bf16 m2)\n+\n+#undef D\n+\n+void check_300 (void)\n+{\n+  XMM_T x;\n+  x._ulonglong[0] = rax;\n+  switch (current_test) {\n+    case 310: assert ((rax & 0xff) == 42\n+\t\t      && check_bf16_float (x.___bf16[1], 43.0f) == 1); break;\n+    case 311: assert ((rax & 0xffff) == 42\n+\t\t      && check_bf16_float (x.___bf16[1], 43.0f) == 1); break;\n+    case 312: assert ((rax & 0xffffffff) == 42\n+\t\t      && check_bf16_float (x.___bf16[2], 43.0f) == 1); break;\n+    case 313: assert (rax == 42\n+\t\t      && check_bf16_float (xmm0b[0], 43.0f) == 1); break;\n+\n+    default: assert (0); break;\n+  }\n+}\n+\n+/* Structures which should be returned in SSE (low) and INT (high).  */\n+#define D(I,MEMBERS,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = SSE_INT; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s));  B; return s; }\n+\n+D(402,__bf16 f[4];char c, s.f[0]=make_f32_bf16(42.0f); s.c=43)\n+\n+#undef D\n+\n+void check_400 (void)\n+{\n+  switch (current_test) {\n+    case 402: assert (check_bf16_float (xmm0b[0], 42.0f) == 1 && (rax & 0xff) == 43); break;\n+\n+    default: assert (0); break;\n+  }\n+}\n+\n+/* Structures which should be returned in MEM.  */\n+void *struct_addr;\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = MEM; \\\n+struct S_ ## I f_ ## I (void) { union {unsigned char c; struct S_ ## I s;} u; memset (&u.s, 0, sizeof(u.s)); u.c = 42; return u.s; }\n+\n+/* Unnaturally aligned members.  */\n+D(540,__bf16 m1[10])\n+D(541,char m1[1];__bf16 f[8])\n+\n+#undef D\n+\n+\n+/* Special tests.  */\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; B; return s; }\n+D(601,__bf16 f[4], SSE_F_H, s.f[0] = s.f[1] = s.f[2] = s.f[3] = make_f32_bf16 (42.0f))\n+D(602,__bf16 f[8], SSE_F_H8,\n+  s.f[0] = s.f[1] = s.f[2] = s.f[3] = s.f[4] = s.f[5] = s.f[6] = s.f[7] = make_f32_bf16 (42.0f))\n+#undef D\n+\n+void clear_all (void)\n+{\n+  clear_int_registers;\n+}\n+\n+void check_all (Type class, unsigned long size)\n+{\n+  switch (class) {\n+    case SSE_B: assert (check_bf16_float (xmm0b[0], 42.0f) == 1); break;\n+    case SSE_D: assert (xmm0d[0] == 42); break;\n+    case SSE_F_H: assert (check_bf16_float (xmm0b[0], 42) == 1\n+\t\t\t  && check_bf16_float (xmm0b[1], 42) == 1\n+\t\t\t  && check_bf16_float (xmm0b[2], 42) == 1\n+\t\t\t  && check_bf16_float (xmm0b[3], 42) == 1); break;\n+    case SSE_F_H8: assert (check_bf16_float (xmm0b[0], 42) == 1\n+\t\t\t   && check_bf16_float (xmm0b[1], 42) == 1\n+\t\t\t   && check_bf16_float (xmm0b[2], 42) == 1\n+\t\t\t   && check_bf16_float (xmm0b[3], 42) == 1\n+\t\t\t   && check_bf16_float (xmm1b[0], 42) == 1\n+\t\t\t   && check_bf16_float (xmm1b[1], 42) == 1\n+\t\t\t   && check_bf16_float (xmm1b[2], 42) == 1\n+\t\t\t   && check_bf16_float (xmm1b[3], 42) == 1); break;\n+    case INT_SSE: check_300(); break;\n+    case SSE_INT: check_400(); break;\n+    /* Ideally we would like to check that rax == struct_addr.\n+       Unfortunately the address of the target struct escapes (for setting\n+       struct_addr), so the return struct is a temporary one whose address\n+       is given to the f_* functions, otherwise a conforming program\n+       could notice the struct changing already before the function returns.\n+       This temporary struct could be anywhere.  For GCC it will be on\n+       stack, but no one is forbidding that it could be a static variable\n+       if there's no threading or proper locking.  Nobody in his right mind\n+       will not use the stack for that.  */\n+    case MEM: assert (*(unsigned char*)struct_addr == 42 && rdi == rax); break;\n+  }\n+}\n+\n+#define D(I) { struct S_ ## I s; current_test = I; struct_addr = (void*)&s; \\\n+  clear_all(); \\\n+  s = WRAP_RET(f_ ## I) (); \\\n+  check_all(class_ ## I, sizeof(s)); \\\n+}\n+\n+static void\n+do_test (void)\n+{\n+  D(120) D(121) D(122) D(123) D(124) D(125) D(126) D(127) D(128) D(129)\n+\n+  D(310) D(311) D(312) D(313)\n+\n+  D(402)\n+\n+  D(540) D(541)\n+\n+  D(601) D(602)\n+  if (num_failed)\n+    abort ();\n+}\n+#undef D"}, {"sha": "4eea7eb7d3ce03ddf2dcf86768c97f182e5897ba", "filename": "gcc/testsuite/gcc.target/x86_64/abi/bf16/test_varargs-m128.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_varargs-m128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_varargs-m128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fbf16%2Ftest_varargs-m128.c?ref=86c0d98620ee3a9610a3f9d725e943e1d2d4c7ec", "patch": "@@ -0,0 +1,111 @@\n+/* Test variable number of 128-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"bf16-check.h\"\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct FloatRegisters fregs;\n+struct IntegerRegisters iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  XMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m128bf16_varargs (__m128bf16 i0, __m128bf16 i1, __m128bf16 i2,\n+\t\t\t\t __m128bf16 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m128bf16 *argp;\n+\n+  compare (values.i0, i0, __m128bf16);\n+  compare (values.i1, i1, __m128bf16);\n+  compare (values.i2, i2, __m128bf16);\n+  compare (values.i3, i3, __m128bf16);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m128bf16 *) (((char *) fp) + 8);\n+\n+  /* Check __m128bf16 arguments passed on stack.  */\n+  compare (values.i8, argp[0], __m128bf16);\n+  compare (values.i9, argp[1], __m128bf16);\n+\n+  /* Check register contents.  */\n+  compare (fregs.xmm0, xmm_regs[0], __m128bf16);\n+  compare (fregs.xmm1, xmm_regs[1], __m128bf16);\n+  compare (fregs.xmm2, xmm_regs[2], __m128bf16);\n+  compare (fregs.xmm3, xmm_regs[3], __m128bf16);\n+  compare (fregs.xmm4, xmm_regs[4], __m128bf16);\n+  compare (fregs.xmm5, xmm_regs[5], __m128bf16);\n+  compare (fregs.xmm6, xmm_regs[6], __m128bf16);\n+  compare (fregs.xmm7, xmm_regs[7], __m128bf16);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m128bf16_varargs (void)\n+{\n+  __m128bf16 x[10];\n+  __bf16 bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8;\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m128bf16) { bf1, bf2, bf3, bf4, bf5, bf6, bf7, bf8 };\n+  pass = \"m128bf16-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m128bf16_varargs,\n+\t\t\t\t _m128bf16);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_m128bf16_varargs ();\n+  if (failed)\n+    abort ();\n+}"}]}