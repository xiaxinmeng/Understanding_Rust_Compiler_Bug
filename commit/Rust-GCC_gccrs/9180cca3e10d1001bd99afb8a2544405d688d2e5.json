{"sha": "9180cca3e10d1001bd99afb8a2544405d688d2e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4MGNjYTNlMTBkMTAwMWJkOTlhZmI4YTI1NDQ0MDVkNjg4ZDJlNQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@worldnet.fr", "date": "1999-10-14T10:21:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-14T10:21:27Z"}, "message": "stor-layout.c (layout_union): Use HOST_WIDE_INT for const_size...\n\n        * stor-layout.c (layout_union): Use HOST_WIDE_INT for const_size;\n        check for member bit-size overflow and use var_size if it occurs.\n        (layout_record): Use bitsize_int() to define the type size in bits.\n        Likewise for computation and assignment to DECL_FIELD_BITPOS.\n        (layout_decl): Likewise when assigning to DECL_SIZE.\n\nFrom-SVN: r29969", "tree": {"sha": "876b4e77c1c1ce12b309b934741da38cfaf70d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/876b4e77c1c1ce12b309b934741da38cfaf70d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9180cca3e10d1001bd99afb8a2544405d688d2e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9180cca3e10d1001bd99afb8a2544405d688d2e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9180cca3e10d1001bd99afb8a2544405d688d2e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9180cca3e10d1001bd99afb8a2544405d688d2e5/comments", "author": null, "committer": null, "parents": [{"sha": "25238622ec79cceb912a1382ff9afffb680aea0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25238622ec79cceb912a1382ff9afffb680aea0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25238622ec79cceb912a1382ff9afffb680aea0a"}], "stats": {"total": 33, "additions": 23, "deletions": 10}, "files": [{"sha": "48c6a9dbbcc4e5962a57c421ccf57c95cc833b87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9180cca3e10d1001bd99afb8a2544405d688d2e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9180cca3e10d1001bd99afb8a2544405d688d2e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9180cca3e10d1001bd99afb8a2544405d688d2e5", "patch": "@@ -1,3 +1,11 @@\n+Thu Oct 14 03:59:57 1999  Stephane Carrez  <stcarrez@worldnet.fr>\n+\n+\t* stor-layout.c (layout_union): Use HOST_WIDE_INT for const_size;\n+\tcheck for member bit-size overflow and use var_size if it occurs.\n+\t(layout_record): Use bitsize_int() to define the type size in bits.\n+\tLikewise for computation and assignment to DECL_FIELD_BITPOS.\n+\t(layout_decl): Likewise when assigning to DECL_SIZE.\n+\n Thu Oct 14 02:57:05 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* genrecog.c (validate_pattern): Typo last change.  Verify"}, {"sha": "f8a1e1dde63a5e9e94b221550124674c2731b2ec", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9180cca3e10d1001bd99afb8a2544405d688d2e5/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9180cca3e10d1001bd99afb8a2544405d688d2e5/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9180cca3e10d1001bd99afb8a2544405d688d2e5", "patch": "@@ -261,8 +261,8 @@ layout_decl (decl, known_align)\n       if (spec_size == 0 && DECL_NAME (decl) != 0)\n \tabort ();\n \n-      /* Size is specified number of bits.  */\n-      DECL_SIZE (decl) = size_int (spec_size);\n+      /* Size is specified in number of bits.  */\n+      DECL_SIZE (decl) = bitsize_int (spec_size, 0);\n     }\n   /* Force alignment required for the data type.\n      But if the decl itself wants greater alignment, don't override that.\n@@ -298,7 +298,7 @@ layout_decl (decl, known_align)\n \t  DECL_ALIGN (decl) = MAX ((unsigned) GET_MODE_ALIGNMENT (xmode),\n \t\t\t\t   DECL_ALIGN (decl));\n \t  DECL_MODE (decl) = xmode;\n-\t  DECL_SIZE (decl) = size_int (GET_MODE_BITSIZE (xmode));\n+\t  DECL_SIZE (decl) = bitsize_int (GET_MODE_BITSIZE (xmode), 0);\n \t  /* This no longer needs to be accessed as a bit field.  */\n \t  DECL_BIT_FIELD (decl) = 0;\n \t}\n@@ -517,7 +517,7 @@ layout_record (rec)\n \tDECL_FIELD_BITPOS (field) = var_size;\n       else\n \t{\n-\t  DECL_FIELD_BITPOS (field) = size_int (const_size);\n+\t  DECL_FIELD_BITPOS (field) = bitsize_int (const_size, 0L);\n \n \t  /* If this field ended up more aligned than we thought it\n \t     would be (we approximate this by seeing if its position\n@@ -559,7 +559,7 @@ layout_record (rec)\n \n   if (var_size == 0)\n     {\n-      TYPE_SIZE (rec) = size_int (const_size);\n+      TYPE_SIZE (rec) = bitsize_int (const_size, 0L);\n     }\n   else\n     {\n@@ -607,7 +607,7 @@ layout_union (rec)\n   /* The size of the union, based on the fields scanned so far,\n      is max (CONST_SIZE, VAR_SIZE).\n      VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */\n-  register int const_size = 0;\n+  register HOST_WIDE_INT const_size = 0;\n   register tree var_size = 0;\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n@@ -624,6 +624,8 @@ layout_union (rec)\n \n   for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n     {\n+      tree dsize;\n+      \n       /* Enums which are local to this class need not be laid out.  */\n       if (TREE_CODE (field) == CONST_DECL || TREE_CODE (field) == TYPE_DECL)\n \tcontinue;\n@@ -642,19 +644,22 @@ layout_union (rec)\n \tunion_align = MAX (union_align, TYPE_ALIGN (TREE_TYPE (field)));\n #endif\n \n+      dsize = DECL_SIZE (field);\n       if (TREE_CODE (rec) == UNION_TYPE)\n \t{\n \t  /* Set union_size to max (decl_size, union_size).\n \t     There are more and less general ways to do this.\n \t     Use only CONST_SIZE unless forced to use VAR_SIZE.  */\n \n-\t  if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+\t  if (TREE_CODE (dsize) == INTEGER_CST\n+              && ! TREE_CONSTANT_OVERFLOW (dsize)\n+              && TREE_INT_CST_HIGH (dsize) == 0)\n \t    const_size\n-\t      = MAX (const_size, TREE_INT_CST_LOW (DECL_SIZE (field)));\n+\t      = MAX (const_size, TREE_INT_CST_LOW (dsize));\n \t  else if (var_size == 0)\n-\t    var_size = DECL_SIZE (field);\n+\t    var_size = dsize;\n \t  else\n-\t    var_size = size_binop (MAX_EXPR, var_size, DECL_SIZE (field));\n+\t    var_size = size_binop (MAX_EXPR, var_size, dsize);\n \t}\n       else if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n \tvar_size = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),"}]}