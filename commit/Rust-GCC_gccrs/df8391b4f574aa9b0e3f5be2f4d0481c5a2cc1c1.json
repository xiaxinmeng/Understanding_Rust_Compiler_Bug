{"sha": "df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY4MzkxYjRmNTc0YWE5YjBlM2Y1YmUyZjRkMDQ4MWM1YTJjYzFjMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-11-28T10:00:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-28T10:00:43Z"}, "message": "re PR lto/78211 (-fcompare-debug failure with -flto -fno-use-linker-plugin)\n\n\tPR lto/78211\n\t* ipa-icf.h (sem_item_optimizer): Add m_classes_vec member.\n\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Initialize\n\tit.\n\t(sem_item_optimizer::~sem_item_optimizer): Traverse m_classes_vec\n\tvector instead of traversing m_classes hash table.  Release\n\tm_classes_vec.\n\t(sem_item_optimizer::read_section, sem_item_optimizer::add_class):\n\tFormatting fixes.\n\t(sem_item_optimizer::get_group_by_hash): When inserting a new group,\n\tadd it also to m_classes_vec vector.\n\t(sem_item_optimizer::remove_symtab_node,\n\tsem_item_optimizer::build_hash_based_classes,\n\tsem_item_optimizer::parse_nonsingleton_classes): Formatting fixes.\n\t(sem_item_optimizer::subdivide_classes_by_equality,\n\tsem_item_optimizer::subdivide_classes_by_sensitive_refs,\n\tsem_item_optimizer::verify_classes): Traverse m_classes_vec vector\n\tinstead of traversing m_classes hash table.  Formatting fixes.\n\t(sem_item_optimizer::traverse_congruence_split,\n\tsem_item_optimizer::do_congruence_step_for_index,\n\tsem_item_optimizer::do_congruence_step): Formatting fixes.\n\t(sem_item_optimizer::process_cong_reduction): Traverse m_classes_vec\n\tvector instead of traversing m_classes hash table.\n\t(sem_item_optimizer::dump_cong_classes): Likewise.  Formatting fixes.\n\t(sem_item_optimizer::merge_classes): Traverse m_classes_vec vector\n\tinstead of traversing m_classes hash table.\n\n\t* g++.dg/ipa/pr78211.C: New test.\n\nFrom-SVN: r242910", "tree": {"sha": "206c771bdd176d217f1421e76db8049998e8c2a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/206c771bdd176d217f1421e76db8049998e8c2a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "193273638fffd7a53434e11b28f817015aac9cc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193273638fffd7a53434e11b28f817015aac9cc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193273638fffd7a53434e11b28f817015aac9cc4"}], "stats": {"total": 363, "additions": 270, "deletions": 93}, "files": [{"sha": "9d1b81d82885bef23e747843499db00801514d0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "patch": "@@ -1,3 +1,32 @@\n+2016-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR lto/78211\n+\t* ipa-icf.h (sem_item_optimizer): Add m_classes_vec member.\n+\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Initialize\n+\tit.\n+\t(sem_item_optimizer::~sem_item_optimizer): Traverse m_classes_vec\n+\tvector instead of traversing m_classes hash table.  Release\n+\tm_classes_vec.\n+\t(sem_item_optimizer::read_section, sem_item_optimizer::add_class):\n+\tFormatting fixes.\n+\t(sem_item_optimizer::get_group_by_hash): When inserting a new group,\n+\tadd it also to m_classes_vec vector.\n+\t(sem_item_optimizer::remove_symtab_node,\n+\tsem_item_optimizer::build_hash_based_classes,\n+\tsem_item_optimizer::parse_nonsingleton_classes): Formatting fixes.\n+\t(sem_item_optimizer::subdivide_classes_by_equality,\n+\tsem_item_optimizer::subdivide_classes_by_sensitive_refs,\n+\tsem_item_optimizer::verify_classes): Traverse m_classes_vec vector\n+\tinstead of traversing m_classes hash table.  Formatting fixes.\n+\t(sem_item_optimizer::traverse_congruence_split,\n+\tsem_item_optimizer::do_congruence_step_for_index,\n+\tsem_item_optimizer::do_congruence_step): Formatting fixes.\n+\t(sem_item_optimizer::process_cong_reduction): Traverse m_classes_vec\n+\tvector instead of traversing m_classes hash table.\n+\t(sem_item_optimizer::dump_cong_classes): Likewise.  Formatting fixes.\n+\t(sem_item_optimizer::merge_classes): Traverse m_classes_vec vector\n+\tinstead of traversing m_classes hash table.\n+\n 2016-11-28  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.c (out_movhi_r_mr) [REG_X + PLUS]: Only SBIW if"}, {"sha": "553b81ee38c40301d2d6faec509e63508b4e6ea9", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 112, "deletions": 92, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "patch": "@@ -2284,6 +2284,7 @@ sem_item_optimizer::sem_item_optimizer ()\n   m_varpool_node_hooks (NULL)\n {\n   m_items.create (0);\n+  m_classes_vec.create (0);\n   bitmap_obstack_initialize (&m_bmstack);\n }\n \n@@ -2292,17 +2293,19 @@ sem_item_optimizer::~sem_item_optimizer ()\n   for (unsigned int i = 0; i < m_items.length (); i++)\n     delete m_items[i];\n \n-  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n     {\n-      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n-\tdelete (*it)->classes[i];\n+      for (unsigned int i = 0; i < it->classes.length (); i++)\n+\tdelete it->classes[i];\n \n-      (*it)->classes.release ();\n-      free (*it);\n+      it->classes.release ();\n+      free (it);\n     }\n \n   m_items.release ();\n+  m_classes_vec.release ();\n \n   bitmap_obstack_release (&m_bmstack);\n }\n@@ -2361,8 +2364,8 @@ void\n sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n \t\t\t\t  const char *data, size_t len)\n {\n-  const lto_function_header *header =\n-    (const lto_function_header *) data;\n+  const lto_function_header *header\n+    = (const lto_function_header *) data;\n   const int cfg_offset = sizeof (lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n@@ -2373,9 +2376,9 @@ sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n   lto_input_block ib_main ((const char *) data + main_offset, 0,\n \t\t\t   header->main_size, file_data->mode_table);\n \n-  data_in =\n-    lto_data_in_create (file_data, (const char *) data + string_offset,\n-\t\t\theader->string_size, vNULL);\n+  data_in\n+    = lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\t  header->string_size, vNULL);\n \n   count = streamer_read_uhwi (&ib_main);\n \n@@ -2473,9 +2476,9 @@ sem_item_optimizer::add_class (congruence_class *cls)\n {\n   gcc_assert (cls->members.length ());\n \n-  congruence_class_group *group = get_group_by_hash (\n-\t\t\t\t    cls->members[0]->get_hash (),\n-\t\t\t\t    cls->members[0]->type);\n+  congruence_class_group *group\n+    = get_group_by_hash (cls->members[0]->get_hash (),\n+\t\t\t cls->members[0]->type);\n   group->classes.safe_push (cls);\n }\n \n@@ -2495,6 +2498,7 @@ sem_item_optimizer::get_group_by_hash (hashval_t hash, sem_item_type type)\n   else\n     {\n       item->classes.create (1);\n+      m_classes_vec.safe_push (item);\n       *slot = item;\n     }\n \n@@ -2524,7 +2528,7 @@ sem_item_optimizer::varpool_removal_hook (varpool_node *node, void *data)\n void\n sem_item_optimizer::remove_symtab_node (symtab_node *node)\n {\n-  gcc_assert (!m_classes.elements());\n+  gcc_assert (!m_classes.elements ());\n \n   m_removed_items_set.add (node);\n }\n@@ -2752,8 +2756,8 @@ sem_item_optimizer::build_hash_based_classes (void)\n     {\n       sem_item *item = m_items[i];\n \n-      congruence_class_group *group = get_group_by_hash (item->get_hash (),\n-\t\t\t\t      item->type);\n+      congruence_class_group *group\n+\t= get_group_by_hash (item->get_hash (), item->type);\n \n       if (!group->classes.length ())\n \t{\n@@ -2827,8 +2831,10 @@ sem_item_optimizer::parse_nonsingleton_classes (void)\n       }\n \n   if (dump_file)\n-    fprintf (dump_file, \"Init called for %u items (%.2f%%).\\n\", init_called_count,\n-\t     m_items.length () ? 100.0f * init_called_count / m_items.length (): 0.0f);\n+    fprintf (dump_file, \"Init called for %u items (%.2f%%).\\n\",\n+\t     init_called_count,\n+\t     m_items.length () ? 100.0f * init_called_count / m_items.length ()\n+\t\t\t       : 0.0f);\n }\n \n /* Equality function for semantic items is used to subdivide existing\n@@ -2837,14 +2843,15 @@ sem_item_optimizer::parse_nonsingleton_classes (void)\n void\n sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n {\n-  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n     {\n-      unsigned int class_count = (*it)->classes.length ();\n+      unsigned int class_count = it->classes.length ();\n \n       for (unsigned i = 0; i < class_count; i++)\n \t{\n-\t  congruence_class *c = (*it)->classes [i];\n+\t  congruence_class *c = it->classes[i];\n \n \t  if (c->members.length() > 1)\n \t    {\n@@ -2853,48 +2860,53 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n \t      sem_item *first = c->members[0];\n \t      new_vector.safe_push (first);\n \n-\t      unsigned class_split_first = (*it)->classes.length ();\n+\t      unsigned class_split_first = it->classes.length ();\n \n \t      for (unsigned j = 1; j < c->members.length (); j++)\n \t\t{\n \t\t  sem_item *item = c->members[j];\n \n-\t\t  bool equals = in_wpa ? first->equals_wpa (item,\n-\t\t\t\tm_symtab_node_map) : first->equals (item, m_symtab_node_map);\n+\t\t  bool equals\n+\t\t    = in_wpa ? first->equals_wpa (item, m_symtab_node_map)\n+\t\t\t     : first->equals (item, m_symtab_node_map);\n \n \t\t  if (equals)\n \t\t    new_vector.safe_push (item);\n \t\t  else\n \t\t    {\n \t\t      bool integrated = false;\n \n-\t\t      for (unsigned k = class_split_first; k < (*it)->classes.length (); k++)\n+\t\t      for (unsigned k = class_split_first;\n+\t\t\t   k < it->classes.length (); k++)\n \t\t\t{\n-\t\t\t  sem_item *x = (*it)->classes[k]->members[0];\n-\t\t\t  bool equals = in_wpa ? x->equals_wpa (item,\n-\t\t\t\t\t\t\t\tm_symtab_node_map) : x->equals (item, m_symtab_node_map);\n+\t\t\t  sem_item *x = it->classes[k]->members[0];\n+\t\t\t  bool equals\n+\t\t\t    = in_wpa ? x->equals_wpa (item, m_symtab_node_map)\n+\t\t\t\t     : x->equals (item, m_symtab_node_map);\n \n \t\t\t  if (equals)\n \t\t\t    {\n \t\t\t      integrated = true;\n-\t\t\t      add_item_to_class ((*it)->classes[k], item);\n+\t\t\t      add_item_to_class (it->classes[k], item);\n \n \t\t\t      break;\n \t\t\t    }\n \t\t\t}\n \n \t\t      if (!integrated)\n \t\t\t{\n-\t\t\t  congruence_class *c = new congruence_class (class_id++);\n+\t\t\t  congruence_class *c\n+\t\t\t    = new congruence_class (class_id++);\n \t\t\t  m_classes_count++;\n \t\t\t  add_item_to_class (c, item);\n \n-\t\t\t  (*it)->classes.safe_push (c);\n+\t\t\t  it->classes.safe_push (c);\n \t\t\t}\n \t\t    }\n \t\t}\n \n-\t      // we replace newly created new_vector for the class we've just splitted\n+\t      // We replace newly created new_vector for the class we've just\n+\t      // splitted.\n \t      c->members.release ();\n \t      c->members.create (new_vector.length ());\n \n@@ -2919,15 +2931,16 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \n   unsigned newly_created_classes = 0;\n \n-  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n     {\n-      unsigned int class_count = (*it)->classes.length ();\n+      unsigned int class_count = it->classes.length ();\n       auto_vec<congruence_class *> new_classes;\n \n       for (unsigned i = 0; i < class_count; i++)\n \t{\n-\t  congruence_class *c = (*it)->classes [i];\n+\t  congruence_class *c = it->classes[i];\n \n \t  if (c->members.length() > 1)\n \t    {\n@@ -2937,11 +2950,12 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \t        {\n \t\t  sem_item *source_node = c->members[j];\n \n-\t\t  symbol_compare_collection *collection = new symbol_compare_collection (source_node->node);\n+\t\t  symbol_compare_collection *collection\n+\t\t    = new symbol_compare_collection (source_node->node);\n \n \t\t  bool existed;\n-\t\t  vec <sem_item *> *slot = &split_map.get_or_insert (collection,\n-\t\t\t\t\t\t\t\t     &existed);\n+\t\t  vec <sem_item *> *slot\n+\t\t    = &split_map.get_or_insert (collection, &existed);\n \t\t  gcc_checking_assert (slot);\n \n \t\t  slot->safe_push (source_node);\n@@ -2950,8 +2964,8 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \t\t    delete collection;\n \t        }\n \n-\t       /* If the map contains more than one key, we have to split the map\n-\t\t  appropriately.  */\n+\t       /* If the map contains more than one key, we have to split\n+\t\t  the map appropriately.  */\n \t      if (split_map.elements () != 1)\n \t        {\n \t\t  bool first_class = true;\n@@ -2970,7 +2984,7 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \n \t\t      if (first_class)\n \t\t        {\n-\t\t\t  (*it)->classes[i] = new_cls;\n+\t\t\t  it->classes[i] = new_cls;\n \t\t\t  first_class = false;\n \t\t\t}\n \t\t      else\n@@ -2992,7 +3006,7 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \t  }\n \n \tfor (unsigned i = 0; i < new_classes.length (); i++)\n-\t  (*it)->classes.safe_push (new_classes[i]);\n+\t  it->classes.safe_push (new_classes[i]);\n     }\n \n   return newly_created_classes;\n@@ -3012,12 +3026,13 @@ sem_item_optimizer::checking_verify_classes (void)\n void\n sem_item_optimizer::verify_classes (void)\n {\n-  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n     {\n-      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+      for (unsigned int i = 0; i < it->classes.length (); i++)\n \t{\n-\t  congruence_class *cls = (*it)->classes[i];\n+\t  congruence_class *cls = it->classes[i];\n \n \t  gcc_assert (cls);\n \t  gcc_assert (cls->members.length () > 0);\n@@ -3032,8 +3047,8 @@ sem_item_optimizer::verify_classes (void)\n \t      for (unsigned k = 0; k < item->usages.length (); k++)\n \t\t{\n \t\t  sem_usage_pair *usage = item->usages[k];\n-\t\t  gcc_assert (usage->item->index_in_class <\n-\t\t\t      usage->item->cls->members.length ());\n+\t\t  gcc_assert (usage->item->index_in_class\n+\t\t\t      < usage->item->cls->members.length ());\n \t\t}\n \t    }\n \t}\n@@ -3061,7 +3076,8 @@ sem_item_optimizer::release_split_map (congruence_class * const &,\n \n bool\n sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n-    bitmap const &b, traverse_split_pair *pair)\n+\t\t\t\t\t       bitmap const &b,\n+\t\t\t\t\t       traverse_split_pair *pair)\n {\n   sem_item_optimizer *optimizer = pair->optimizer;\n   const congruence_class *splitter_cls = pair->cls;\n@@ -3103,7 +3119,7 @@ sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n       g.hash = cls->members[0]->get_hash ();\n       g.type = cls->members[0]->type;\n \n-      congruence_class_group *slot = optimizer->m_classes.find(&g);\n+      congruence_class_group *slot = optimizer->m_classes.find (&g);\n \n       for (unsigned int i = 0; i < slot->classes.length (); i++)\n \tif (slot->classes[i] == cls)\n@@ -3126,9 +3142,10 @@ sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n \t  optimizer->worklist_push (newclasses[i]);\n       else /* Just smaller class is inserted.  */\n \t{\n-\t  unsigned int smaller_index = newclasses[0]->members.length () <\n-\t\t\t\t       newclasses[1]->members.length () ?\n-\t\t\t\t       0 : 1;\n+\t  unsigned int smaller_index\n+\t    = (newclasses[0]->members.length ()\n+\t       < newclasses[1]->members.length ()\n+\t       ? 0 : 1);\n \t  optimizer->worklist_push (newclasses[smaller_index]);\n \t}\n \n@@ -3156,7 +3173,7 @@ sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n \n void\n sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n-    unsigned int index)\n+\t\t\t\t\t\t  unsigned int index)\n {\n   hash_map <congruence_class *, bitmap> split_map;\n \n@@ -3184,8 +3201,8 @@ sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n \t    b = *slot;\n \n \t  gcc_checking_assert (usage->item->cls);\n-\t  gcc_checking_assert (usage->item->index_in_class <\n-\t\t\t       usage->item->cls->members.length ());\n+\t  gcc_checking_assert (usage->item->index_in_class\n+\t\t\t       < usage->item->cls->members.length ());\n \n \t  bitmap_set_bit (b, usage->item->index_in_class);\n \t}\n@@ -3196,12 +3213,12 @@ sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n   pair.cls = cls;\n \n   splitter_class_removed = false;\n-  split_map.traverse\n-  <traverse_split_pair *, sem_item_optimizer::traverse_congruence_split> (&pair);\n+  split_map.traverse <traverse_split_pair *,\n+\t\t      sem_item_optimizer::traverse_congruence_split> (&pair);\n \n   /* Bitmap clean-up.  */\n-  split_map.traverse\n-  <traverse_split_pair *, sem_item_optimizer::release_split_map> (NULL);\n+  split_map.traverse <traverse_split_pair *,\n+\t\t      sem_item_optimizer::release_split_map> (NULL);\n }\n \n /* Every usage of a congruence class CLS is a candidate that can split the\n@@ -3222,8 +3239,8 @@ sem_item_optimizer::do_congruence_step (congruence_class *cls)\n   EXECUTE_IF_SET_IN_BITMAP (usage, 0, i, bi)\n   {\n     if (dump_file && (dump_flags & TDF_DETAILS))\n-      fprintf (dump_file, \"  processing congruence step for class: %u, index: %u\\n\",\n-\t       cls->id, i);\n+      fprintf (dump_file, \"  processing congruence step for class: %u, \"\n+\t       \"index: %u\\n\", cls->id, i);\n \n     do_congruence_step_for_index (cls, i);\n \n@@ -3281,11 +3298,12 @@ sem_item_optimizer::worklist_pop (void)\n void\n sem_item_optimizer::process_cong_reduction (void)\n {\n-  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n-    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n-      if ((*it)->classes[i]->is_class_used ())\n-\tworklist_push ((*it)->classes[i]);\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+    for (unsigned i = 0; i < it->classes.length (); i++)\n+      if (it->classes[i]->is_class_used ())\n+\tworklist_push (it->classes[i]);\n \n   if (dump_file)\n     fprintf (dump_file, \"Worklist has been filled with: %lu\\n\",\n@@ -3317,27 +3335,29 @@ sem_item_optimizer::dump_cong_classes (void)\n     return;\n \n   fprintf (dump_file,\n-\t   \"Congruence classes: %u (unique hash values: %lu), with total: %u items\\n\",\n-\t   m_classes_count, (unsigned long) m_classes.elements(), m_items.length ());\n+\t   \"Congruence classes: %u (unique hash values: %lu), with total: \"\n+\t   \"%u items\\n\", m_classes_count,\n+\t   (unsigned long) m_classes.elements (), m_items.length ());\n \n   /* Histogram calculation.  */\n   unsigned int max_index = 0;\n   unsigned int* histogram = XCNEWVEC (unsigned int, m_items.length () + 1);\n \n-  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n-\n-    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+    for (unsigned i = 0; i < it->classes.length (); i++)\n       {\n-\tunsigned int c = (*it)->classes[i]->members.length ();\n+\tunsigned int c = it->classes[i]->members.length ();\n \thistogram[c]++;\n \n \tif (c > max_index)\n \t  max_index = c;\n       }\n \n   fprintf (dump_file,\n-\t   \"Class size histogram [num of members]: number of classe number of classess\\n\");\n+\t   \"Class size histogram [num of members]: number of classe number \"\n+\t   \"of classess\\n\");\n \n   for (unsigned int i = 0; i <= max_index; i++)\n     if (histogram[i])\n@@ -3347,16 +3367,16 @@ sem_item_optimizer::dump_cong_classes (void)\n \n \n   if (dump_flags & TDF_DETAILS)\n-    for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-\t it != m_classes.end (); ++it)\n+    FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n       {\n-\tfprintf (dump_file, \"  group: with %u classes:\\n\", (*it)->classes.length ());\n+\tfprintf (dump_file, \"  group: with %u classes:\\n\",\n+\t\t it->classes.length ());\n \n-\tfor (unsigned i = 0; i < (*it)->classes.length (); i++)\n+\tfor (unsigned i = 0; i < it->classes.length (); i++)\n \t  {\n-\t    (*it)->classes[i]->dump (dump_file, 4);\n+\t    it->classes[i]->dump (dump_file, 4);\n \n-\t    if(i < (*it)->classes.length () - 1)\n+\t    if (i < it->classes.length () - 1)\n \t      fprintf (dump_file, \" \");\n \t  }\n       }\n@@ -3381,11 +3401,12 @@ sem_item_optimizer::merge_classes (unsigned int prev_class_count)\n \n   bool merged_p = false;\n \n-  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n-    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+  unsigned int l;\n+  congruence_class_group *it;\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+    for (unsigned int i = 0; i < it->classes.length (); i++)\n       {\n-\tcongruence_class *c = (*it)->classes[i];\n+\tcongruence_class *c = it->classes[i];\n \tif (c->members.length () > 1)\n \t  {\n \t    non_singular_classes_count++;\n@@ -3410,11 +3431,10 @@ sem_item_optimizer::merge_classes (unsigned int prev_class_count)\n \t       item_count ? 100.0f * equal_items / item_count : 0.0f);\n     }\n \n-  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n-       it != m_classes.end (); ++it)\n-    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+    for (unsigned int i = 0; i < it->classes.length (); i++)\n       {\n-\tcongruence_class *c = (*it)->classes[i];\n+\tcongruence_class *c = it->classes[i];\n \n \tif (c->members.length () == 1)\n \t  continue;"}, {"sha": "0b4b56abd7dbbe0d88e767434bd4654331bc7cb4", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "patch": "@@ -609,9 +609,12 @@ class sem_item_optimizer\n   /* A set containing all items removed by hooks.  */\n   hash_set <symtab_node *> m_removed_items_set;\n \n-  /* Hashtable of congruence classes */\n+  /* Hashtable of congruence classes.  */\n   hash_table <congruence_class_group_hash> m_classes;\n \n+  /* Vector of congruence classes.  */\n+  vec <congruence_class_group *> m_classes_vec;\n+\n   /* Count of congruence classes.  */\n   unsigned int m_classes_count;\n "}, {"sha": "33eb39cbdf2f4b96ed207f45a45b5f0adbc63dea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "patch": "@@ -1,3 +1,8 @@\n+2016-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR lto/78211\n+\t* g++.dg/ipa/pr78211.C: New test.\n+\n 2016-11-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/78474"}, {"sha": "8207a6bf7fbb4dd16caa838c5cc771261af25282", "filename": "gcc/testsuite/g++.dg/ipa/pr78211.C", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr78211.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr78211.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr78211.C?ref=df8391b4f574aa9b0e3f5be2f4d0481c5a2cc1c1", "patch": "@@ -0,0 +1,120 @@\n+// PR lto/78211\n+// { dg-do compile { target { lto && c++11 } } }\n+// { dg-options \"-fcompare-debug -fno-printf-return-value -flto -fno-use-linker-plugin -O3\" }\n+\n+namespace std {\n+  typedef __SIZE_TYPE__ size_t;\n+  inline namespace __cxx11 { }\n+  template<typename...> using __void_t = void;\n+  template<class _E>\n+  class initializer_list {\n+    typedef size_t size_type;\n+    typedef const _E* iterator;\n+    iterator _M_array;\n+    size_type _M_len;\n+  };\n+}\n+extern \"C++\" {\n+  namespace std {\n+    template<typename _Tp> struct __is_char { enum { __value = 1 }; };\n+  }\n+  namespace __gnu_cxx {\n+    template<bool, typename> struct __enable_if { };\n+    template<typename _Tp> struct __enable_if<true, _Tp> { typedef _Tp __type; };\n+  }\n+}\n+namespace std {\n+  template<typename _Iterator, typename = __void_t<>> struct __iterator_traits { };\n+  template<typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> { };\n+  template<typename _Tp> struct iterator_traits<_Tp*> { typedef _Tp& reference; };\n+}\n+namespace __gnu_cxx {\n+  using std::iterator_traits;\n+  template<typename _Iterator, typename _Container> class __normal_iterator {\n+    typedef iterator_traits<_Iterator> __traits_type;\n+   public:\n+    typedef typename __traits_type::reference reference;\n+    reference operator*() const noexcept { }\n+  };\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+  inline bool operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs, const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept { }\n+}\n+namespace std {\n+  template<typename _CharT> struct char_traits;\n+  template<typename> class allocator;\n+  template<typename _Alloc> struct allocator_traits { };\n+  template<typename _Tp> struct allocator_traits<allocator<_Tp>> {\n+    using const_pointer = const _Tp*;\n+    template<typename _Up> using rebind_alloc = allocator<_Up>;\n+  };\n+}\n+namespace __gnu_cxx {\n+  template<typename _Alloc>   struct __alloc_traits : std::allocator_traits<_Alloc>   {\n+    typedef std::allocator_traits<_Alloc> _Base_type;\n+    template<typename _Tp> struct rebind {\n+      typedef typename _Base_type::template rebind_alloc<_Tp> other;\n+    };\n+  };\n+}\n+namespace std {\n+  namespace __cxx11 {\n+    template<typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT> > class basic_string;\n+    typedef basic_string<char> string;\n+  }\n+  template<typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\n+  operator==(const basic_string<_CharT>& __lhs, const basic_string<_CharT>& __rhs) noexcept { }\n+  template<typename _Tp, typename _Alloc> struct _Vector_base {\n+    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;\n+  };\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> > class vector {\n+    typedef _Vector_base<_Tp, _Alloc> _Base;\n+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+    typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;\n+   public:\n+    typedef typename _Alloc_traits::const_pointer const_pointer;\n+    typedef __gnu_cxx::__normal_iterator<const_pointer, vector> const_iterator;\n+    const_iterator end() const noexcept { }\n+  };\n+}\n+class VwViewPlane;\n+class VwViewer {\n+  std::vector<VwViewPlane*> mViewPlaneList;\n+  VwViewPlane* FindViewPlane (const std::string& name);\n+  const VwViewPlane* FindViewPlane (const std::string& name) const;\n+};\n+class VwAssimilatorStickyBox;\n+class VwViewer_2D final {\n+  VwAssimilatorStickyBox* mp_stickyAssimilator;\n+  void drawStickyBox();\n+  void undrawStickyBox();\n+};\n+struct VwViewPlane {\n+  const std::string& GetName() const { }\n+};\n+struct VwAssimilator_2D {\n+  virtual int DrawNext() = 0;\n+};\n+class VwAssimilator_2D_Geometry : public VwAssimilator_2D { };\n+class VwAssimilatorStickyBox final : public VwAssimilator_2D_Geometry { };\n+VwViewPlane* VwViewer::FindViewPlane (const std::string& name) {\n+  VwViewPlane* p_result = __null;\n+  std::vector<VwViewPlane*>::const_iterator it;\n+  while (it != mViewPlaneList.end()) {\n+    if ((*it) -> GetName() == name ) break;\n+  }\n+  return p_result;\n+}\n+const VwViewPlane* VwViewer::FindViewPlane (const std::string& name) const {\n+  VwViewPlane* p_result = __null;\n+  std::vector<VwViewPlane*>::const_iterator it;\n+  while (it != mViewPlaneList.end()) {\n+    if ((*it) -> GetName() == name ) break;\n+  }\n+  return p_result;\n+}\n+void VwViewer_2D::drawStickyBox() {\n+  mp_stickyAssimilator->DrawNext();\n+}\n+void VwViewer_2D::undrawStickyBox() {\n+  mp_stickyAssimilator->DrawNext();\n+}"}]}