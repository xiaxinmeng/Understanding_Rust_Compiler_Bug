{"sha": "fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRmYWNmYTExMmZiY2Q2NWVlMzIxODNjZTU0MzI3ZTBlZDIwZWYwYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-06-24T18:47:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-06-24T18:47:36Z"}, "message": "pt.c (lookup_template_class): Use currently_open_class, compare template args later.\n\n\t* pt.c (lookup_template_class): Use currently_open_class,\n\tcompare template args later.\n\nFrom-SVN: r148915", "tree": {"sha": "2b4e7e69a6de444b34017c35f734a9dba0771f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4e7e69a6de444b34017c35f734a9dba0771f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e450b4f353ab01834cbaeae8cf31a5e0737c31ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e450b4f353ab01834cbaeae8cf31a5e0737c31ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e450b4f353ab01834cbaeae8cf31a5e0737c31ad"}], "stats": {"total": 35, "additions": 10, "deletions": 25}, "files": [{"sha": "2a6ec5d6527d2810cd3945b839302f1801fe3831", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "patch": "@@ -1,5 +1,8 @@\n 2009-06-24  Jason Merrill  <jason@redhat.com>\n \n+\t* pt.c (lookup_template_class): Use currently_open_class,\n+\tcompare template args later.\n+\n \tPR c++/40342\n \t* decl.c (decls_match): Check DECL_TI_TEMPLATE too.\n \t* class.c (resolve_address_of_overloaded_function): Fix typo."}, {"sha": "e0a413bfb28da164dbc4ba3eebbb3db71be23558", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfacfa112fbcd65ee32183ce54327e0ed20ef0b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fdfacfa112fbcd65ee32183ce54327e0ed20ef0b", "patch": "@@ -5845,31 +5845,13 @@ lookup_template_class (tree d1,\n \n \t the `C<T>' is just the same as `C'.  Outside of the\n \t class, however, such a reference is an instantiation.  */\n-      if (comp_template_args (TYPE_TI_ARGS (template_type),\n-\t\t\t      arglist))\n-\t{\n-\t  found = template_type;\n-\n-\t  if (!entering_scope && PRIMARY_TEMPLATE_P (templ))\n-\t    {\n-\t      tree ctx;\n-\n-\t      for (ctx = current_class_type;\n-\t\t   ctx && TREE_CODE (ctx) != NAMESPACE_DECL;\n-\t\t   ctx = (TYPE_P (ctx)\n-\t\t\t  ? TYPE_CONTEXT (ctx)\n-\t\t\t  : DECL_CONTEXT (ctx)))\n-\t\tif (TYPE_P (ctx) && same_type_p (ctx, template_type))\n-\t\t  goto found_ctx;\n-\n-\t      /* We're not in the scope of the class, so the\n-\t\t TEMPLATE_TYPE is not the type we want after all.  */\n-\t      found = NULL_TREE;\n-\t    found_ctx:;\n-\t    }\n-\t}\n-      if (found)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n+      if ((entering_scope\n+\t   || !PRIMARY_TEMPLATE_P (templ)\n+\t   || currently_open_class (template_type))\n+\t  /* comp_template_args is expensive, check it last.  */\n+\t  && comp_template_args (TYPE_TI_ARGS (template_type),\n+\t\t\t\t arglist))\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, template_type);\n \n       /* If we already have this specialization, return it.  */\n       found = retrieve_specialization (templ, arglist,"}]}