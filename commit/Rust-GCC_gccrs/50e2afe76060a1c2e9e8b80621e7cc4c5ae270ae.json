{"sha": "50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlMmFmZTc2MDYwYTFjMmU5ZThiODA2MjFlN2NjNGM1YWUyNzBhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:15:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:15:53Z"}, "message": "[44/77] Make simplify_and_const_int take a scalar_int_mode\n\nAfter previous patches, top-level calls to simplify_and_const_int\nalways pass a scalar_int_mode.  The only call site that needs to\nbe updated is the recursive one in simplify_and_const_int_1,\nat which point we know \"varop\" has a scalar integer mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (simplify_and_const_int): Change the type of the mode\n\tparameter to scalar_int_mode.\n\t(simplify_and_const_int_1): Likewise.  Update recursive call.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251496", "tree": {"sha": "d4f21ac066911541461679069e4314a786f59cd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f21ac066911541461679069e4314a786f59cd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae/comments", "author": null, "committer": null, "parents": [{"sha": "bf62e687b552f87c36bc5579c65a24de0b4f59b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf62e687b552f87c36bc5579c65a24de0b4f59b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf62e687b552f87c36bc5579c65a24de0b4f59b9"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "8fc7bba3a11d793d58ec7afab8e66003ed09a9ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (simplify_and_const_int): Change the type of the mode\n+\tparameter to scalar_int_mode.\n+\t(simplify_and_const_int_1): Likewise.  Update recursive call.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "aa38770c00566cc7f3e57ccb8af07d4099553056", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=50e2afe76060a1c2e9e8b80621e7cc4c5ae270ae", "patch": "@@ -459,9 +459,9 @@ static int rtx_equal_for_field_assignment_p (rtx, rtx, bool = false);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n static rtx distribute_and_simplify_rtx (rtx, int);\n-static rtx simplify_and_const_int_1 (machine_mode, rtx,\n+static rtx simplify_and_const_int_1 (scalar_int_mode, rtx,\n \t\t\t\t     unsigned HOST_WIDE_INT);\n-static rtx simplify_and_const_int (rtx, machine_mode, rtx,\n+static rtx simplify_and_const_int (rtx, scalar_int_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n \t\t\t    HOST_WIDE_INT, machine_mode, int *);\n@@ -9905,7 +9905,7 @@ distribute_and_simplify_rtx (rtx x, int n)\n    (const_int CONSTOP)).  Otherwise, return NULL_RTX.  */\n \n static rtx\n-simplify_and_const_int_1 (machine_mode mode, rtx varop,\n+simplify_and_const_int_1 (scalar_int_mode mode, rtx varop,\n \t\t\t  unsigned HOST_WIDE_INT constop)\n {\n   unsigned HOST_WIDE_INT nonzero;\n@@ -9965,19 +9965,20 @@ simplify_and_const_int_1 (machine_mode mode, rtx varop,\n      won't match a pattern either with or without this.  */\n \n   if (GET_CODE (varop) == IOR || GET_CODE (varop) == XOR)\n-    return\n-      gen_lowpart\n-\t(mode,\n-\t apply_distributive_law\n-\t (simplify_gen_binary (GET_CODE (varop), GET_MODE (varop),\n-\t\t\t       simplify_and_const_int (NULL_RTX,\n-\t\t\t\t\t\t       GET_MODE (varop),\n-\t\t\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t\t\t       constop),\n-\t\t\t       simplify_and_const_int (NULL_RTX,\n-\t\t\t\t\t\t       GET_MODE (varop),\n-\t\t\t\t\t\t       XEXP (varop, 1),\n-\t\t\t\t\t\t       constop))));\n+    {\n+      scalar_int_mode varop_mode = as_a <scalar_int_mode> (GET_MODE (varop));\n+      return\n+\tgen_lowpart\n+\t  (mode,\n+\t   apply_distributive_law\n+\t   (simplify_gen_binary (GET_CODE (varop), varop_mode,\n+\t\t\t\t simplify_and_const_int (NULL_RTX, varop_mode,\n+\t\t\t\t\t\t\t XEXP (varop, 0),\n+\t\t\t\t\t\t\t constop),\n+\t\t\t\t simplify_and_const_int (NULL_RTX, varop_mode,\n+\t\t\t\t\t\t\t XEXP (varop, 1),\n+\t\t\t\t\t\t\t constop))));\n+    }\n \n   /* If VAROP is PLUS, and the constant is a mask of low bits, distribute\n      the AND and see if one of the operands simplifies to zero.  If so, we\n@@ -10020,7 +10021,7 @@ simplify_and_const_int_1 (machine_mode mode, rtx varop,\n    X is zero, we are to always construct the equivalent form.  */\n \n static rtx\n-simplify_and_const_int (rtx x, machine_mode mode, rtx varop,\n+simplify_and_const_int (rtx x, scalar_int_mode mode, rtx varop,\n \t\t\tunsigned HOST_WIDE_INT constop)\n {\n   rtx tem = simplify_and_const_int_1 (mode, varop, constop);"}]}