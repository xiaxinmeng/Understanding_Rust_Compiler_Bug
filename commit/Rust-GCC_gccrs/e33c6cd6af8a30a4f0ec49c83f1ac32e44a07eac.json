{"sha": "e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMzYzZjZDZhZjhhMzBhNGYwZWM0OWM4M2YxYWMzMmU0NGEwN2VhYw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-04-28T14:05:54Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-04-28T14:05:54Z"}, "message": "cgraph.h (struct cgraph_node): New field indirect_calls.\n\n2010-04-28  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (struct cgraph_node): New field indirect_calls.\n\t(struct cgraph_indirect_call_info): New type.\n\t(struct cgraph_edge): Removed field indirect_call. New fields\n\tindirect_info, indirect_inlining_edge and indirect_unknown_callee.\n\t(cgraph_create_indirect_edge): Declare.\n\t(cgraph_make_edge_direct): Likewise.\n\t(enum LTO_cgraph_tags): New item LTO_cgraph_indirect_edge.\n\t* ipa-prop.h (struct ipa_param_call_note): Removed.\n\t(struct ipa_node_params): Removed field param_calls.\n\t(ipa_create_all_structures_for_iinln): Declare.\n\t* cgraph.c: Described indirect edges and uids in initial comment.\n\t(cgraph_add_edge_to_call_site_hash): New function.\n\t(cgraph_edge): Search also among the indirect edges, use\n\tcgraph_add_edge_to_call_site_hash to add edges to the call site hash.\n\t(cgraph_set_call_stmt): Possibly turn an indirect edge into a direct\n\tone, use cgraph_add_edge_to_call_site_hash to add edges to the call\n\tsite hash.\n\t(initialize_inline_failed): Assign a reason to indirect edges.\n\t(cgraph_create_edge_1): New function.\n\t(cgraph_create_edge): Moved some functionality to\n\tcgraph_create_edge_1.\n\t(cgraph_create_indirect_edge): New function.\n\t(cgraph_edge_remove_callee): Add an assert checking for\n\tnon-indirectness.\n\t(cgraph_edge_remove_caller): Special-case indirect edges.\n\t(cgraph_remove_edge): Likewise.\n\t(cgraph_set_edge_callee): New function.\n\t(cgraph_redirect_edge_callee): Use cgraph_set_edge_callee.\n\t(cgraph_make_edge_direct): New function.\n\t(cgraph_update_edges_for_call_stmt_node): Do nothing only when also\n\tthe declaration of the call statement matches.\n\t(cgraph_node_remove_callees): Special-case indirect edges.\n\t(cgraph_clone_edge): Likewise.\n\t(cgraph_clone_node): Clone also the indirect edges.\n\t(dump_cgraph_node): Dump indirect_inlining_edge flag instead of\n\tindirect_call, dump count of indirect_calls edges.\n\t* ipa-prop.c (iinlining_processed_edges): New variable.\n\t(ipa_note_param_call): Create indirect edges instead of\n\tcreating notes.  New parameter node.\n\t(ipa_analyze_call_uses): New parameter node, pass it on to\n\tipa_note_param_call.\n\t(ipa_analyze_stmt_uses): Likewise.\n\t(ipa_analyze_params_uses): Pass node to ipa_analyze_stmt_uses.\n\t(print_edge_addition_message): Work on edges rather than on notes.\n\t(update_call_notes_after_inlining): Likewise, renamed to\n\tupdate_indirect_edges_after_inlining.\n\t(ipa_create_all_structures_for_iinln): New function.\n\t(ipa_free_node_params_substructures): Do not free notes.\n\t(ipa_edge_duplication_hook): Propagate bits within\n\tiinlining_processed_edges bitmap.\n\t(ipa_node_duplication_hook): Do not duplicate notes.\n\t(free_all_ipa_structures_after_ipa_cp): Renamed to\n\tipa_free_all_structures_after_ipa_cp.\n\t(free_all_ipa_structures_after_iinln): Renamed to\n\tipa_free_all_structures_after_iinln.g\n\t(ipa_write_param_call_note): Removed.\n\t(ipa_read_param_call_note): Removed.\n\t(ipa_write_indirect_edge_info): New function.\n\t(ipa_read_indirect_edge_info): Likewise.\n\t(ipa_write_node_info): Do not stream notes, do stream information\n\tin indirect edges.\n\t(ipa_read_node_info): Likewise.\n\t(lto_ipa_fixup_call_notes): Removed.\n\t* ipa-cp.c (pass_ipa_cp): Set stmt_fixup to NULL.\n\t* ipa-inline.c (pass_ipa_inline): Likewise.\n\t* cgraphunit.c (verify_cgraph_node): Check also indirect edges.\n\t* cif-code.def (INDIRECT_UNKNOWN_CALL): New reason.\n\t* tree-inline.c (copy_bb): Removed an unnecessary double check for\n\tis_gimple_call.\n\t* tree-inline.c (get_indirect_callee_fndecl): Do not consider indirect\n\tedges.\n\t* lto-cgraph.c (output_outgoing_cgraph_edges): New function.\n\t(output_cgraph): Stream also indirect edges.\n\t(lto_output_edge): Added capability to stream indirect edges.\n\t(input_edge): Likewise.\n\t(input_cgraph_1): Likewise.\n\n\t* testsuite/gcc.dg/lto/20091209-1_0.c: New testcase.\n\nFrom-SVN: r158827", "tree": {"sha": "c1439fe1fd5f33266aa3c67ebd246e03bffb1684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1439fe1fd5f33266aa3c67ebd246e03bffb1684"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18abb35edfc9f88c783813982e568978c2cb51cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18abb35edfc9f88c783813982e568978c2cb51cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18abb35edfc9f88c783813982e568978c2cb51cc"}], "stats": {"total": 877, "additions": 577, "deletions": 300}, "files": [{"sha": "8e92d2d885033ab8b4d1d4cc9c085e189ca4a876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1,3 +1,82 @@\n+2010-04-28  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (struct cgraph_node): New field indirect_calls.\n+\t(struct cgraph_indirect_call_info): New type.\n+\t(struct cgraph_edge): Removed field indirect_call. New fields\n+\tindirect_info, indirect_inlining_edge and indirect_unknown_callee.\n+\t(cgraph_create_indirect_edge): Declare.\n+\t(cgraph_make_edge_direct): Likewise.\n+\t(enum LTO_cgraph_tags): New item LTO_cgraph_indirect_edge.\n+\t* ipa-prop.h (struct ipa_param_call_note): Removed.\n+\t(struct ipa_node_params): Removed field param_calls.\n+\t(ipa_create_all_structures_for_iinln): Declare.\n+\t* cgraph.c: Described indirect edges and uids in initial comment.\n+\t(cgraph_add_edge_to_call_site_hash): New function.\n+\t(cgraph_edge): Search also among the indirect edges, use\n+\tcgraph_add_edge_to_call_site_hash to add edges to the call site hash.\n+\t(cgraph_set_call_stmt): Possibly turn an indirect edge into a direct\n+\tone, use cgraph_add_edge_to_call_site_hash to add edges to the call\n+\tsite hash.\n+\t(initialize_inline_failed): Assign a reason to indirect edges.\n+\t(cgraph_create_edge_1): New function.\n+\t(cgraph_create_edge): Moved some functionality to\n+\tcgraph_create_edge_1.\n+\t(cgraph_create_indirect_edge): New function.\n+\t(cgraph_edge_remove_callee): Add an assert checking for\n+\tnon-indirectness.\n+\t(cgraph_edge_remove_caller): Special-case indirect edges.\n+\t(cgraph_remove_edge): Likewise.\n+\t(cgraph_set_edge_callee): New function.\n+\t(cgraph_redirect_edge_callee): Use cgraph_set_edge_callee.\n+\t(cgraph_make_edge_direct): New function.\n+\t(cgraph_update_edges_for_call_stmt_node): Do nothing only when also\n+\tthe declaration of the call statement matches.\n+\t(cgraph_node_remove_callees): Special-case indirect edges.\n+\t(cgraph_clone_edge): Likewise.\n+\t(cgraph_clone_node): Clone also the indirect edges.\n+\t(dump_cgraph_node): Dump indirect_inlining_edge flag instead of\n+\tindirect_call, dump count of indirect_calls edges.\n+\t* ipa-prop.c (iinlining_processed_edges): New variable.\n+\t(ipa_note_param_call): Create indirect edges instead of\n+\tcreating notes.  New parameter node.\n+\t(ipa_analyze_call_uses): New parameter node, pass it on to\n+\tipa_note_param_call.\n+\t(ipa_analyze_stmt_uses): Likewise.\n+\t(ipa_analyze_params_uses): Pass node to ipa_analyze_stmt_uses.\n+\t(print_edge_addition_message): Work on edges rather than on notes.\n+\t(update_call_notes_after_inlining): Likewise, renamed to\n+\tupdate_indirect_edges_after_inlining.\n+\t(ipa_create_all_structures_for_iinln): New function.\n+\t(ipa_free_node_params_substructures): Do not free notes.\n+\t(ipa_edge_duplication_hook): Propagate bits within\n+\tiinlining_processed_edges bitmap.\n+\t(ipa_node_duplication_hook): Do not duplicate notes.\n+\t(free_all_ipa_structures_after_ipa_cp): Renamed to\n+\tipa_free_all_structures_after_ipa_cp.\n+\t(free_all_ipa_structures_after_iinln): Renamed to\n+\tipa_free_all_structures_after_iinln.g\n+\t(ipa_write_param_call_note): Removed.\n+\t(ipa_read_param_call_note): Removed.\n+\t(ipa_write_indirect_edge_info): New function.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\t(ipa_write_node_info): Do not stream notes, do stream information\n+\tin indirect edges.\n+\t(ipa_read_node_info): Likewise.\n+\t(lto_ipa_fixup_call_notes): Removed.\n+\t* ipa-cp.c (pass_ipa_cp): Set stmt_fixup to NULL.\n+\t* ipa-inline.c (pass_ipa_inline): Likewise.\n+\t* cgraphunit.c (verify_cgraph_node): Check also indirect edges.\n+\t* cif-code.def (INDIRECT_UNKNOWN_CALL): New reason.\n+\t* tree-inline.c (copy_bb): Removed an unnecessary double check for\n+\tis_gimple_call.\n+\t* tree-inline.c (get_indirect_callee_fndecl): Do not consider indirect\n+\tedges.\n+\t* lto-cgraph.c (output_outgoing_cgraph_edges): New function.\n+\t(output_cgraph): Stream also indirect edges.\n+\t(lto_output_edge): Added capability to stream indirect edges.\n+\t(input_edge): Likewise.\n+\t(input_cgraph_1): Likewise.\n+\n 2010-04-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43879"}, {"sha": "c7b619a3284cfccc18bbc311f5e87f69b2adee3f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 219, "deletions": 72, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -34,10 +34,16 @@ The callgraph:\n     based on DECL_UID.  The call-graph nodes are created lazily using\n     cgraph_node function when called for unknown declaration.\n \n-    The callgraph at the moment does not represent indirect calls or calls\n-    from other compilation unit.  Flag NEEDED is set for each node that may\n-    be accessed in such an invisible way and it shall be considered an\n-    entry point to the callgraph.\n+    The callgraph at the moment does not represent all indirect calls or calls\n+    from other compilation units.  Flag NEEDED is set for each node that may be\n+    accessed in such an invisible way and it shall be considered an entry point\n+    to the callgraph.\n+\n+    On the other hand, the callgraph currently does contain some edges for\n+    indirect calls with unknown callees which can be accessed through\n+    indirect_calls field of a node.  It should be noted however that at the\n+    moment only calls which are potential candidates for indirect inlining are\n+    added there.\n \n     Interprocedural information:\n \n@@ -48,6 +54,9 @@ The callgraph:\n       rtl_info used by RTL backend to propagate data from already compiled\n       functions to their callers.\n \n+      Moreover, each node has a uid which can be used to keep information in\n+      on-the-side arrays.  UIDs are reused and therefore reasonably dense.\n+\n     Inlining plans:\n \n       The function inlining information is decided in advance and maintained\n@@ -723,6 +732,19 @@ edge_eq (const void *x, const void *y)\n   return ((const struct cgraph_edge *) x)->call_stmt == y;\n }\n \n+/* Add call graph edge E to call site hash of its caller.  */\n+\n+static inline void\n+cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n+{\n+  void **slot;\n+  slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n+\t\t\t\t   e->call_stmt,\n+\t\t\t\t   htab_hash_pointer (e->call_stmt),\n+\t\t\t\t   INSERT);\n+  gcc_assert (!*slot);\n+  *slot = e;\n+}\n \n /* Return the callgraph edge representing the GIMPLE_CALL statement\n    CALL_STMT.  */\n@@ -743,26 +765,28 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n      solution.  It is not good idea to add pointer into CALL_EXPR itself\n      because we want to make possible having multiple cgraph nodes representing\n      different clones of the same body before the body is actually cloned.  */\n-  for (e = node->callees; e; e= e->next_callee)\n+  for (e = node->callees; e; e = e->next_callee)\n     {\n       if (e->call_stmt == call_stmt)\n \tbreak;\n       n++;\n     }\n \n+  if (!e)\n+    for (e = node->indirect_calls; e; e = e->next_callee)\n+      {\n+\tif (e->call_stmt == call_stmt)\n+\t  break;\n+\tn++;\n+      }\n+\n   if (n > 100)\n     {\n       node->call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n       for (e2 = node->callees; e2; e2 = e2->next_callee)\n-\t{\n-          void **slot;\n-\t  slot = htab_find_slot_with_hash (node->call_site_hash,\n-\t\t\t\t\t   e2->call_stmt,\n-\t\t\t\t\t   htab_hash_pointer (e2->call_stmt),\n-\t\t\t\t\t   INSERT);\n-\t  gcc_assert (!*slot);\n-\t  *slot = e2;\n-\t}\n+\tcgraph_add_edge_to_call_site_hash (e2);\n+      for (e2 = node->indirect_calls; e2; e2 = e2->next_callee)\n+\tcgraph_add_edge_to_call_site_hash (e2);\n     }\n \n   return e;\n@@ -774,26 +798,31 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n void\n cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n {\n+  tree decl;\n+\n   if (e->caller->call_site_hash)\n     {\n       htab_remove_elt_with_hash (e->caller->call_site_hash,\n \t\t\t\t e->call_stmt,\n \t\t\t\t htab_hash_pointer (e->call_stmt));\n     }\n+\n   e->call_stmt = new_stmt;\n+  if (e->indirect_unknown_callee\n+      && (decl = gimple_call_fndecl (new_stmt)))\n+    {\n+      /* Constant propagation (and possibly also inlining?) can turn an\n+\t indirect call into a direct one.  */\n+      struct cgraph_node *new_callee = cgraph_node (decl);\n+\n+      cgraph_make_edge_direct (e, new_callee);\n+    }\n+\n   push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n   e->can_throw_external = stmt_can_throw_external (new_stmt);\n   pop_cfun ();\n   if (e->caller->call_site_hash)\n-    {\n-      void **slot;\n-      slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n-\t\t\t\t       e->call_stmt,\n-\t\t\t\t       htab_hash_pointer\n-\t\t\t\t       (e->call_stmt), INSERT);\n-      gcc_assert (!*slot);\n-      *slot = e;\n-    }\n+    cgraph_add_edge_to_call_site_hash (e);\n }\n \n /* Like cgraph_set_call_stmt but walk the clone tree and update all\n@@ -895,7 +924,9 @@ initialize_inline_failed (struct cgraph_edge *e)\n {\n   struct cgraph_node *callee = e->callee;\n \n-  if (!callee->analyzed)\n+  if (e->indirect_unknown_callee)\n+    e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n+  else if (!callee->analyzed)\n     e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n   else if (callee->local.redefined_extern_inline)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n@@ -907,15 +938,16 @@ initialize_inline_failed (struct cgraph_edge *e)\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n }\n \n-/* Create edge from CALLER to CALLEE in the cgraph.  */\n+/* Allocate a cgraph_edge structure and fill it with data according to the\n+   parameters of which only CALLEE can be NULL (when creating an indirect call\n+   edge).  */\n \n-struct cgraph_edge *\n-cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    gimple call_stmt, gcov_type count, int freq, int nest)\n+static struct cgraph_edge *\n+cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n+\t\t       gimple call_stmt, gcov_type count, int freq, int nest)\n {\n   struct cgraph_edge *edge;\n \n-\n   /* LTO does not actually have access to the call_stmt since these\n      have not been loaded yet.  */\n   if (call_stmt)\n@@ -941,47 +973,83 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n     }\n \n   edge->aux = NULL;\n-\n   edge->caller = caller;\n   edge->callee = callee;\n+  edge->prev_caller = NULL;\n+  edge->next_caller = NULL;\n+  edge->prev_callee = NULL;\n+  edge->next_callee = NULL;\n+\n+  edge->count = count;\n+  gcc_assert (count >= 0);\n+  edge->frequency = freq;\n+  gcc_assert (freq >= 0);\n+  gcc_assert (freq <= CGRAPH_FREQ_MAX);\n+  edge->loop_nest = nest;\n+\n   edge->call_stmt = call_stmt;\n   push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (call_stmt) : false;\n   pop_cfun ();\n-  edge->prev_caller = NULL;\n+  edge->call_stmt_cannot_inline_p =\n+    (call_stmt ? gimple_call_cannot_inline_p (call_stmt) : false);\n+  if (call_stmt && caller->call_site_hash)\n+    cgraph_add_edge_to_call_site_hash (edge);\n+\n+  edge->indirect_info = NULL;\n+  edge->indirect_inlining_edge = 0;\n+\n+  return edge;\n+}\n+\n+/* Create edge from CALLER to CALLEE in the cgraph.  */\n+\n+struct cgraph_edge *\n+cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n+\t\t    gimple call_stmt, gcov_type count, int freq, int nest)\n+{\n+  struct cgraph_edge *edge = cgraph_create_edge_1 (caller, callee, call_stmt,\n+\t\t\t\t\t\t   count, freq, nest);\n+\n+  edge->indirect_unknown_callee = 0;\n+  initialize_inline_failed (edge);\n+\n   edge->next_caller = callee->callers;\n   if (callee->callers)\n     callee->callers->prev_caller = edge;\n-  edge->prev_callee = NULL;\n   edge->next_callee = caller->callees;\n   if (caller->callees)\n     caller->callees->prev_callee = edge;\n   caller->callees = edge;\n   callee->callers = edge;\n-  edge->count = count;\n-  gcc_assert (count >= 0);\n-  edge->frequency = freq;\n-  gcc_assert (freq >= 0);\n-  gcc_assert (freq <= CGRAPH_FREQ_MAX);\n-  edge->loop_nest = nest;\n-  edge->indirect_call = 0;\n-  edge->call_stmt_cannot_inline_p =\n-    (call_stmt ? gimple_call_cannot_inline_p (call_stmt) : false);\n-  if (call_stmt && caller->call_site_hash)\n-    {\n-      void **slot;\n-      slot = htab_find_slot_with_hash (caller->call_site_hash,\n-\t\t\t\t       edge->call_stmt,\n-\t\t\t\t       htab_hash_pointer\n-\t\t\t\t\t (edge->call_stmt),\n-\t\t\t\t       INSERT);\n-      gcc_assert (!*slot);\n-      *slot = edge;\n-    }\n \n+  return edge;\n+}\n+\n+\n+/* Create an indirect edge with a yet-undetermined callee where the call\n+   statement destination is a formal parameter of the caller with index\n+   PARAM_INDEX. */\n+\n+struct cgraph_edge *\n+cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n+\t\t\t     gcov_type count, int freq, int nest)\n+{\n+  struct cgraph_edge *edge = cgraph_create_edge_1 (caller, NULL, call_stmt,\n+\t\t\t\t\t\t   count, freq, nest);\n+\n+  edge->indirect_unknown_callee = 1;\n   initialize_inline_failed (edge);\n \n+  edge->indirect_info = GGC_NEW (struct cgraph_indirect_call_info);\n+  edge->indirect_info->param_index = -1;\n+\n+  edge->next_callee = caller->indirect_calls;\n+  if (caller->indirect_calls)\n+    caller->indirect_calls->prev_callee = edge;\n+  caller->indirect_calls = edge;\n+\n   return edge;\n }\n \n@@ -990,6 +1058,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n static inline void\n cgraph_edge_remove_callee (struct cgraph_edge *e)\n {\n+  gcc_assert (!e->indirect_unknown_callee);\n   if (e->prev_caller)\n     e->prev_caller->next_caller = e->next_caller;\n   if (e->next_caller)\n@@ -1008,7 +1077,12 @@ cgraph_edge_remove_caller (struct cgraph_edge *e)\n   if (e->next_callee)\n     e->next_callee->prev_callee = e->prev_callee;\n   if (!e->prev_callee)\n-    e->caller->callees = e->next_callee;\n+    {\n+      if (e->indirect_unknown_callee)\n+\te->caller->indirect_calls = e->next_callee;\n+      else\n+\te->caller->callees = e->next_callee;\n+    }\n   if (e->caller->call_site_hash)\n     htab_remove_elt_with_hash (e->caller->call_site_hash,\n \t\t\t       e->call_stmt,\n@@ -1037,8 +1111,9 @@ cgraph_remove_edge (struct cgraph_edge *e)\n   /* Call all edge removal hooks.  */\n   cgraph_call_edge_removal_hooks (e);\n \n-  /* Remove from callers list of the callee.  */\n-  cgraph_edge_remove_callee (e);\n+  if (!e->indirect_unknown_callee)\n+    /* Remove from callers list of the callee.  */\n+    cgraph_edge_remove_callee (e);\n \n   /* Remove from callees list of the callers.  */\n   cgraph_edge_remove_caller (e);\n@@ -1047,6 +1122,20 @@ cgraph_remove_edge (struct cgraph_edge *e)\n   cgraph_free_edge (e);\n }\n \n+/* Set callee of call graph edge E and add it to the corresponding set of\n+   callers. */\n+\n+static void\n+cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n+{\n+  e->prev_caller = NULL;\n+  if (n->callers)\n+    n->callers->prev_caller = e;\n+  e->next_caller = n->callers;\n+  n->callers = e;\n+  e->callee = n;\n+}\n+\n /* Redirect callee of E to N.  The function does not update underlying\n    call expression.  */\n \n@@ -1057,12 +1146,37 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   cgraph_edge_remove_callee (e);\n \n   /* Insert to callers list of the new callee.  */\n-  e->prev_caller = NULL;\n-  if (n->callers)\n-    n->callers->prev_caller = e;\n-  e->next_caller = n->callers;\n-  n->callers = e;\n-  e->callee = n;\n+  cgraph_set_edge_callee (e, n);\n+}\n+\n+/* Make an indirect EDGE with an unknown callee an ordinary edge leading to\n+   CALLEE.  */\n+\n+void\n+cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n+{\n+  edge->indirect_unknown_callee = 0;\n+\n+  /* Get the edge out of the indirect edge list. */\n+  if (edge->prev_callee)\n+    edge->prev_callee->next_callee = edge->next_callee;\n+  if (edge->next_callee)\n+    edge->next_callee->prev_callee = edge->prev_callee;\n+  if (!edge->prev_callee)\n+    edge->caller->indirect_calls = edge->next_callee;\n+\n+  /* Put it into the normal callee list */\n+  edge->prev_callee = NULL;\n+  edge->next_callee = edge->caller->callees;\n+  if (edge->caller->callees)\n+    edge->caller->callees->prev_callee = edge;\n+  edge->caller->callees = edge;\n+\n+  /* Insert to callers list of the new callee.  */\n+  cgraph_set_edge_callee (edge, callee);\n+\n+  /* We need to re-determine the inlining status of the edge.  */\n+  initialize_inline_failed (edge);\n }\n \n \n@@ -1091,9 +1205,10 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \n       if (e)\n \t{\n-\t  /* See if the call is already there.  It might be because of indirect\n-\t     inlining already found it.  */\n-\t  if (new_call && e->callee->decl == new_call)\n+\t  /* See if the edge is already there and has the correct callee.  It\n+\t     might be so because of indirect inlining has already updated\n+\t     it.  */\n+\t  if (new_call && e->callee && e->callee->decl == new_call)\n \t    return;\n \n \t  /* Otherwise remove edge and create new one; we can't simply redirect\n@@ -1171,7 +1286,8 @@ cgraph_node_remove_callees (struct cgraph_node *node)\n     {\n       f = e->next_callee;\n       cgraph_call_edge_removal_hooks (e);\n-      cgraph_edge_remove_callee (e);\n+      if (!e->indirect_unknown_callee)\n+\tcgraph_edge_remove_callee (e);\n       cgraph_free_edge (e);\n     }\n   node->callees = NULL;\n@@ -1627,6 +1743,8 @@ void\n dump_cgraph_node (FILE *f, struct cgraph_node *node)\n {\n   struct cgraph_edge *edge;\n+  int indirect_calls_count = 0;\n+\n   fprintf (f, \"%s/%i(%i)\", cgraph_node_name (node), node->uid,\n \t   node->pid);\n   dump_addr (f, \" @\", (void *)node);\n@@ -1708,8 +1826,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n-      if (edge->indirect_call)\n-\tfprintf(f, \"(indirect) \");\n+      if (edge->indirect_inlining_edge)\n+\tfprintf(f, \"(indirect_inlining) \");\n       if (edge->can_throw_external)\n \tfprintf(f, \"(can throw external) \");\n     }\n@@ -1721,8 +1839,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       edge->callee->uid);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n-      if (edge->indirect_call)\n-\tfprintf(f, \"(indirect) \");\n+      if (edge->indirect_inlining_edge)\n+\tfprintf(f, \"(indirect_inlining) \");\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n@@ -1736,6 +1854,12 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     }\n   fprintf (f, \"\\n\");\n \n+  for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n+    indirect_calls_count++;\n+  if (indirect_calls_count)\n+    fprintf (f, \"  has %i outgoing edges for indirect calls.\\n\",\n+\t     indirect_calls_count);\n+\n   if (node->same_body)\n     {\n       struct cgraph_node *n;\n@@ -1855,11 +1979,30 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n   freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n   if (freq > CGRAPH_FREQ_MAX)\n     freq = CGRAPH_FREQ_MAX;\n-  new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n-\t\t\t    e->loop_nest + loop_nest);\n+\n+  if (e->indirect_unknown_callee)\n+    {\n+      tree decl;\n+\n+      if (call_stmt && (decl = gimple_call_fndecl (call_stmt)))\n+\t{\n+\t  struct cgraph_node *callee = cgraph_node (decl);\n+\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq,\n+\t\t\t\t\t e->loop_nest + loop_nest);\n+\t}\n+      else\n+\t{\n+\t  new_edge = cgraph_create_indirect_edge (n, call_stmt, count, freq,\n+\t\t\t\t\t\t  e->loop_nest + loop_nest);\n+\t  new_edge->indirect_info->param_index = e->indirect_info->param_index;\n+\t}\n+    }\n+  else\n+    new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n+\t\t\t\t   e->loop_nest + loop_nest);\n \n   new_edge->inline_failed = e->inline_failed;\n-  new_edge->indirect_call = e->indirect_call;\n+  new_edge->indirect_inlining_edge = e->indirect_inlining_edge;\n   new_edge->lto_stmt_uid = stmt_uid;\n   if (update_original)\n     {\n@@ -1933,6 +2076,10 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, loop_nest, update_original);\n \n+  for (e = n->indirect_calls; e; e = e->next_callee)\n+    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n+\t\t       count_scale, freq, loop_nest, update_original);\n+\n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)\n     n->clones->prev_sibling_clone = new_node;"}, {"sha": "1bd4b2c2d4cc2f8c43e3d1bf0cbfa04b96cdd034", "filename": "gcc/cgraph.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -199,6 +199,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_edge *callers;\n   struct cgraph_node *next;\n   struct cgraph_node *previous;\n+  /* List of edges representing indirect calls with a yet undetermined\n+     callee.  */\n+  struct cgraph_edge *indirect_calls;\n   /* For nested functions points to function the node is nested in.  */\n   struct cgraph_node *origin;\n   /* Points to first nested function, if any.  */\n@@ -333,6 +336,14 @@ typedef enum {\n   CIF_N_REASONS\n } cgraph_inline_failed_t;\n \n+/* Structure containing additional information about an indirect call.  */\n+\n+struct GTY(()) cgraph_indirect_call_info\n+{\n+  /* Index of the parameter that is called.  */\n+  int param_index;\n+};\n+\n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n@@ -343,6 +354,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   struct cgraph_edge *prev_callee;\n   struct cgraph_edge *next_callee;\n   gimple call_stmt;\n+  /* Additional information about an indirect call.  Not cleared when an edge\n+     becomes direct.  */\n+  struct cgraph_indirect_call_info *indirect_info;\n   PTR GTY ((skip (\"\"))) aux;\n   /* When equal to CIF_OK, inline this call.  Otherwise, points to the\n      explanation why function was not inlined.  */\n@@ -358,8 +372,12 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   int uid;\n   /* Depth of loop nest, 1 means no loop nest.  */\n   unsigned short int loop_nest;\n-  /* Whether this edge describes a call that was originally indirect.  */\n-  unsigned int indirect_call : 1;\n+  /* Whether this edge was made direct by indirect inlining.  */\n+  unsigned int indirect_inlining_edge : 1;\n+  /* Whether this edge describes an indirect call with an undetermined\n+     callee.  */\n+  unsigned int indirect_unknown_callee : 1;\n+  /* Whether this edge is still a dangling  */\n   /* True if the corresponding CALL stmt cannot be inlined.  */\n   unsigned int call_stmt_cannot_inline_p : 1;\n   /* Can this call throw externally?  */\n@@ -461,7 +479,8 @@ void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n \t\t\t\t\tgimple, gcov_type, int, int);\n-\n+struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n+\t\t\t\t\t\t gcov_type, int, int);\n struct cgraph_node * cgraph_get_node (tree);\n struct cgraph_node *cgraph_node (tree);\n bool cgraph_same_body_alias (tree, tree);\n@@ -487,6 +506,7 @@ struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n+void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n \n struct cgraph_asm_node *cgraph_add_asm_node (tree);\n \n@@ -657,6 +677,7 @@ enum LTO_cgraph_tags\n   LTO_cgraph_overwritable_node,\n   LTO_cgraph_unavail_node,\n   LTO_cgraph_edge,\n+  LTO_cgraph_indirect_edge,\n   LTO_cgraph_last_tag\n };\n "}, {"sha": "5ace85ba9a9c967921f0749706cf30db9d7bc6c6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -607,6 +607,24 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"Inline clone is needed\");\n       error_found = true;\n     }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      if (e->aux)\n+\t{\n+\t  error (\"aux field set for indirect edge from %s\",\n+\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t  error_found = true;\n+\t}\n+      if (!e->indirect_unknown_callee\n+\t  || !e->indirect_info)\n+\t{\n+\t  error (\"An indirect edge from %s is not marked as indirect or has \"\n+\t\t \"associated indirect_info, the corresponding statement is: \",\n+\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t  debug_gimple_stmt (e->call_stmt);\n+\t  error_found = true;\n+\t}\n+    }\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       if (e->count < 0)\n@@ -759,10 +777,10 @@ verify_cgraph_node (struct cgraph_node *node)\n                  gsi_next (&gsi))\n \t      {\n \t\tgimple stmt = gsi_stmt (gsi);\n-\t\ttree decl;\n-\t\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n+\t\tif (is_gimple_call (stmt))\n \t\t  {\n \t\t    struct cgraph_edge *e = cgraph_edge (node, stmt);\n+\t\t    tree decl = gimple_call_fndecl (stmt);\n \t\t    if (e)\n \t\t      {\n \t\t\tif (e->aux)\n@@ -771,25 +789,38 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    debug_gimple_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n-\t\t\tif (e->callee->same_body_alias)\n+\t\t\tif (!e->indirect_unknown_callee)\n \t\t\t  {\n-\t\t\t    error (\"edge points to same body alias:\");\n-\t\t\t    debug_tree (e->callee->decl);\n-\t\t\t    error_found = true;\n+\t\t\t    if (e->callee->same_body_alias)\n+\t\t\t      {\n+\t\t\t\terror (\"edge points to same body alias:\");\n+\t\t\t\tdebug_tree (e->callee->decl);\n+\t\t\t\terror_found = true;\n+\t\t\t      }\n+\t\t\t    else if (!node->global.inlined_to\n+\t\t\t\t     && !e->callee->global.inlined_to\n+\t\t\t\t     && decl\n+\t\t\t\t     && !clone_of_p (cgraph_node (decl),\n+\t\t\t\t\t\t     e->callee))\n+\t\t\t      {\n+\t\t\t\terror (\"edge points to wrong declaration:\");\n+\t\t\t\tdebug_tree (e->callee->decl);\n+\t\t\t\tfprintf (stderr,\" Instead of:\");\n+\t\t\t\tdebug_tree (decl);\n+\t\t\t\terror_found = true;\n+\t\t\t      }\n \t\t\t  }\n-\t\t\telse if (!node->global.inlined_to\n-\t\t\t\t && !e->callee->global.inlined_to\n-\t\t\t\t && !clone_of_p (cgraph_node (decl), e->callee))\n+\t\t\telse if (decl)\n \t\t\t  {\n-\t\t\t    error (\"edge points to wrong declaration:\");\n-\t\t\t    debug_tree (e->callee->decl);\n-\t\t\t    fprintf (stderr,\" Instead of:\");\n-\t\t\t    debug_tree (decl);\n+\t\t\t    error (\"an indirect edge with unknown callee \"\n+\t\t\t\t   \"corresponding to a call_stmt with \"\n+\t\t\t\t   \"a known declaration:\");\n \t\t\t    error_found = true;\n+\t\t\t    debug_gimple_stmt (e->call_stmt);\n \t\t\t  }\n \t\t\te->aux = (void *)1;\n \t\t      }\n-\t\t    else\n+\t\t    else if (decl)\n \t\t      {\n \t\t\terror (\"missing callgraph edge for call stmt:\");\n \t\t\tdebug_gimple_stmt (stmt);\n@@ -805,7 +836,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \n       for (e = node->callees; e; e = e->next_callee)\n \t{\n-\t  if (!e->aux && !e->indirect_call)\n+\t  if (!e->aux)\n \t    {\n \t      error (\"edge %s->%s has no corresponding call_stmt\",\n \t\t     identifier_to_locale (cgraph_node_name (e->caller)),\n@@ -815,6 +846,17 @@ verify_cgraph_node (struct cgraph_node *node)\n \t    }\n \t  e->aux = 0;\n \t}\n+      for (e = node->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  if (!e->aux)\n+\t    {\n+\t      error (\"an indirect edge from %s has no corresponding call_stmt\",\n+\t\t     identifier_to_locale (cgraph_node_name (e->caller)));\n+\t      debug_gimple_stmt (e->call_stmt);\n+\t      error_found = true;\n+\t    }\n+\t  e->aux = 0;\n+\t}\n     }\n   if (error_found)\n     {"}, {"sha": "4898486c315e2e9800a3760c04729b6168d99f8d", "filename": "gcc/cif-code.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -84,3 +84,7 @@ DEFCIFCODE(MISMATCHED_ARGUMENTS, N_(\"mismatched arguments\"))\n /* Call was originally indirect.  */\n DEFCIFCODE(ORIGINALLY_INDIRECT_CALL,\n \t   N_(\"originally indirect function call not considered for inlining\"))\n+\n+/* Ths edge represents an indirect edge with a yet-undetermined callee .  */\n+DEFCIFCODE(INDIRECT_UNKNOWN_CALL,\n+\t   N_(\"indirect function call with a yet undetermined callee\"))"}, {"sha": "74d365e785d341f95b1f3dca75ab3f893d2f2e3a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1282,7 +1282,7 @@ ipcp_driver (void)\n       ipcp_print_profile_data (dump_file);\n     }\n   /* Free all IPCP structures.  */\n-  free_all_ipa_structures_after_ipa_cp ();\n+  ipa_free_all_structures_after_ipa_cp ();\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation end\\n\");\n   return 0;\n@@ -1346,7 +1346,7 @@ struct ipa_opt_pass_d pass_ipa_cp =\n  ipcp_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* write_optimization_summary */\n  NULL,\t\t\t\t\t/* read_optimization_summary */\n- lto_ipa_fixup_call_notes, \t\t/* stmt_fixup */\n+ NULL,\t\t\t \t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */"}, {"sha": "75adb011d15bcded0b62a41a260ae2894df09cc1", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1322,6 +1322,8 @@ cgraph_decide_inlining (void)\n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   if (in_lto_p && flag_indirect_inlining)\n     ipa_update_after_lto_read ();\n+  if (flag_indirect_inlining)\n+    ipa_create_all_structures_for_iinln ();\n \n   max_count = 0;\n   max_benefit = 0;\n@@ -1442,7 +1444,7 @@ cgraph_decide_inlining (void)\n \n   /* Free ipa-prop structures if they are no longer needed.  */\n   if (flag_indirect_inlining)\n-    free_all_ipa_structures_after_iinln ();\n+    ipa_free_all_structures_after_iinln ();\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -2138,7 +2140,7 @@ struct ipa_opt_pass_d pass_ipa_inline =\n  inline_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* write_optimization_summary */\n  NULL,\t\t\t\t\t/* read_optimization_summary */\n- lto_ipa_fixup_call_notes,\t\t/* stmt_fixup */\n+ NULL,\t\t\t\t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n  inline_transform,\t\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */"}, {"sha": "7ab3a3e607ccbab62767b82c908a1255169ae51f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 98, "deletions": 147, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -41,6 +41,10 @@ VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n+/* Bitmap with all UIDs of call graph edges that have been already processed\n+   by indirect inlining.  */\n+static bitmap iinlining_processed_edges;\n+\n /* Holders of ipa cgraph hooks: */\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n@@ -745,39 +749,31 @@ ipa_is_ssa_with_stmt_def (tree t)\n     return false;\n }\n \n-/* Creates a new note describing a call to a parameter number FORMAL_ID and\n-   attaches it to the linked list of INFO.  It also sets the called flag of the\n-   parameter.  STMT is the corresponding call statement.  */\n+/* Create a new indirect call graph edge describing a call to a parameter\n+   number FORMAL_ID and and set the called flag of the parameter.  NODE is the\n+   caller.  STMT is the corresponding call statement.  */\n \n static void\n-ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n-\t\t     gimple stmt)\n+ipa_note_param_call (struct cgraph_node *node, int formal_id, gimple stmt)\n {\n-  struct ipa_param_call_note *note;\n+  struct cgraph_edge *cs;\n   basic_block bb = gimple_bb (stmt);\n+  int freq;\n \n-  note = XCNEW (struct ipa_param_call_note);\n-  note->formal_id = formal_id;\n-  note->stmt = stmt;\n-  note->lto_stmt_uid = gimple_uid (stmt);\n-  note->count = bb->count;\n-  note->frequency = compute_call_stmt_bb_frequency (current_function_decl, bb);\n-  note->loop_nest = bb->loop_depth;\n-\n-  note->next = info->param_calls;\n-  info->param_calls = note;\n-\n-  return;\n+  freq = compute_call_stmt_bb_frequency (current_function_decl, bb);\n+  cs = cgraph_create_indirect_edge (node, stmt, bb->count, freq,\n+\t\t\t\t    bb->loop_depth);\n+  cs->indirect_info->param_index = formal_id;\n }\n \n-/* Analyze the CALL and examine uses of formal parameters of the caller\n+/* Analyze the CALL and examine uses of formal parameters of the caller NODE\n    (described by INFO).  Currently it checks whether the call calls a pointer\n    that is a formal parameter and if so, the parameter is marked with the\n-   called flag and a note describing the call is created.  This is very simple\n-   for ordinary pointers represented in SSA but not-so-nice when it comes to\n-   member pointers.  The ugly part of this function does nothing more than\n-   tries to match the pattern of such a call.  An example of such a pattern is\n-   the gimple dump below, the call is on the last line:\n+   called flag and an indirect call graph edge describing the call is created.\n+   This is very simple for ordinary pointers represented in SSA but not-so-nice\n+   when it comes to member pointers.  The ugly part of this function does\n+   nothing more than trying to match the pattern of such a call.  An example of\n+   such a pattern is the gimple dump below, the call is on the last line:\n \n      <bb 2>:\n        f$__delta_5 = f.__delta;\n@@ -817,7 +813,8 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n */\n \n static void\n-ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n+ipa_analyze_call_uses (struct cgraph_node *node, struct ipa_node_params *info,\n+\t\t       gimple call)\n {\n   tree target = gimple_call_fn (call);\n   gimple def;\n@@ -838,7 +835,7 @@ ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n       /* assuming TREE_CODE (var) == PARM_DECL */\n       index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (info, index, call);\n+\tipa_note_param_call (node, index, call);\n       return;\n     }\n \n@@ -935,20 +932,21 @@ ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n \n   index = ipa_get_param_decl_index (info, rec);\n   if (index >= 0 && !ipa_is_param_modified (info, index))\n-    ipa_note_param_call (info, index, call);\n+    ipa_note_param_call (node, index, call);\n \n   return;\n }\n \n-/* Analyze the statement STMT with respect to formal parameters (described in\n-   INFO) and their uses.  Currently it only checks whether formal parameters\n-   are called.  */\n+/* Analyze the call statement STMT with respect to formal parameters (described\n+   in INFO) of caller given by NODE.  Currently it only checks whether formal\n+   parameters are called.  */\n \n static void\n-ipa_analyze_stmt_uses (struct ipa_node_params *info, gimple stmt)\n+ipa_analyze_stmt_uses (struct cgraph_node *node, struct ipa_node_params *info,\n+\t\t       gimple stmt)\n {\n   if (is_gimple_call (stmt))\n-    ipa_analyze_call_uses (info, stmt);\n+    ipa_analyze_call_uses (node, info, stmt);\n }\n \n /* Scan the function body of NODE and inspect the uses of formal parameters.\n@@ -973,7 +971,7 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  ipa_analyze_stmt_uses (info, stmt);\n+\t  ipa_analyze_stmt_uses (node, info, stmt);\n \t}\n     }\n \n@@ -1029,9 +1027,8 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n    by JFUNC.  NODE is the node where the call is.  */\n \n static void\n-print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n-\t\t\t     struct ipa_jump_func *jfunc,\n-\t\t\t     struct cgraph_node *node)\n+print_edge_addition_message (FILE *f, struct cgraph_edge *e,\n+\t\t\t     struct ipa_jump_func *jfunc)\n {\n   fprintf (f, \"ipa-prop: Discovered an indirect call to a known target (\");\n   if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n@@ -1042,8 +1039,8 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n   else\n     print_node_brief(f, \"\", jfunc->value.constant, 0);\n \n-  fprintf (f, \") in %s: \", cgraph_node_name (node));\n-  print_gimple_stmt (f, nt->stmt, 2, TDF_SLIM);\n+  fprintf (f, \") in %s: \", cgraph_node_name (e->caller));\n+  print_gimple_stmt (f, e->call_stmt, 2, TDF_SLIM);\n }\n \n /* Update the param called notes associated with NODE when CS is being inlined,\n@@ -1053,41 +1050,47 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n    unless NEW_EDGES is NULL.  Return true iff a new edge(s) were created.  */\n \n static bool\n-update_call_notes_after_inlining (struct cgraph_edge *cs,\n-\t\t\t\t  struct cgraph_node *node,\n-\t\t\t\t  VEC (cgraph_edge_p, heap) **new_edges)\n+update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n+\t\t\t\t      struct cgraph_node *node,\n+\t\t\t\t      VEC (cgraph_edge_p, heap) **new_edges)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n   struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n-  struct ipa_param_call_note *nt;\n+  struct cgraph_edge *ie, *next_ie;\n   bool res = false;\n \n-  for (nt = info->param_calls; nt; nt = nt->next)\n+  ipa_check_create_edge_args ();\n+\n+  for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n+      struct cgraph_indirect_call_info *ici = ie->indirect_info;\n       struct ipa_jump_func *jfunc;\n \n-      if (nt->processed)\n+      next_ie = ie->next_callee;\n+      if (bitmap_bit_p (iinlining_processed_edges, ie->uid))\n \tcontinue;\n \n+      /* If we ever use indirect edges for anything other than indirect\n+\t inlining, we will need to skip those with negative param_indices. */\n+      gcc_assert (ici->param_index >= 0);\n+\n       /* We must check range due to calls with variable number of arguments:  */\n-      if (nt->formal_id >= ipa_get_cs_argument_count (top))\n+      if (ici->param_index >= ipa_get_cs_argument_count (top))\n \t{\n-\t  nt->processed = true;\n+\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n \t  continue;\n \t}\n \n-      jfunc = ipa_get_ith_jump_func (top, nt->formal_id);\n+      jfunc = ipa_get_ith_jump_func (top, ici->param_index);\n       if (jfunc->type == IPA_JF_PASS_THROUGH\n \t  && jfunc->value.pass_through.operation == NOP_EXPR)\n-\tnt->formal_id = jfunc->value.pass_through.formal_id;\n+\tici->param_index = jfunc->value.pass_through.formal_id;\n       else if (jfunc->type == IPA_JF_CONST\n \t       || jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n \t{\n \t  struct cgraph_node *callee;\n-\t  struct cgraph_edge *new_indirect_edge;\n \t  tree decl;\n \n-\t  nt->processed = true;\n+\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n \t  if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n \t    decl = jfunc->value.member_cst.pfn;\n \t  else\n@@ -1105,32 +1108,29 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \n \t  res = true;\n \t  if (dump_file)\n-\t    print_edge_addition_message (dump_file, nt, jfunc, node);\n-\n-\t  new_indirect_edge = cgraph_create_edge (node, callee, nt->stmt,\n-\t\t\t\t\t\t  nt->count, nt->frequency,\n-\t\t\t\t\t\t  nt->loop_nest);\n-\t  new_indirect_edge->lto_stmt_uid = nt->lto_stmt_uid;\n-\t  new_indirect_edge->indirect_call = 1;\n-\t  ipa_check_create_edge_args ();\n+\t    print_edge_addition_message (dump_file, ie, jfunc);\n+\n+\t  cgraph_make_edge_direct (ie, callee);\n+\t  ie->indirect_inlining_edge = 1;\n \t  if (new_edges)\n-\t    VEC_safe_push (cgraph_edge_p, heap, *new_edges, new_indirect_edge);\n+\t    VEC_safe_push (cgraph_edge_p, heap, *new_edges, ie);\n \t  top = IPA_EDGE_REF (cs);\n \t}\n       else\n \t{\n-\t  /* Ancestor jum functions and pass theoughs with operations should\n+\t  /* Ancestor jump functions and pass theoughs with operations should\n \t     not be used on parameters that then get called.  */\n \t  gcc_assert (jfunc->type == IPA_JF_UNKNOWN);\n-\t  nt->processed = true;\n+\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n \t}\n     }\n+\n   return res;\n }\n \n /* Recursively traverse subtree of NODE (including node) made of inlined\n    cgraph_edges when CS has been inlined and invoke\n-   update_call_notes_after_inlining on all nodes and\n+   update_indirect_edges_after_inlining on all nodes and\n    update_jump_functions_after_inlining on all non-inlined edges that lead out\n    of this subtree.  Newly discovered indirect edges will be added to\n    *NEW_EDGES, unless NEW_EDGES is NULL.  Return true iff a new edge(s) were\n@@ -1144,7 +1144,7 @@ propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n   struct cgraph_edge *e;\n   bool res;\n \n-  res = update_call_notes_after_inlining (cs, node, new_edges);\n+  res = update_indirect_edges_after_inlining (cs, node, new_edges);\n \n   for (e = node->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n@@ -1216,13 +1216,6 @@ ipa_free_node_params_substructures (struct ipa_node_params *info)\n   if (info->params)\n     free (info->params);\n \n-  while (info->param_calls)\n-    {\n-      struct ipa_param_call_note *note = info->param_calls;\n-      info->param_calls = note->next;\n-      free (note);\n-    }\n-\n   memset (info, 0, sizeof (*info));\n }\n \n@@ -1317,6 +1310,10 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   new_args->jump_functions = (struct ipa_jump_func *)\n     duplicate_ggc_array (old_args->jump_functions,\n \t\t         sizeof (struct ipa_jump_func) * arg_count);\n+\n+  if (iinlining_processed_edges\n+      && bitmap_bit_p (iinlining_processed_edges, src->uid))\n+    bitmap_set_bit (iinlining_processed_edges, dst->uid);\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -1326,7 +1323,6 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n-  struct ipa_param_call_note *note;\n   int param_count;\n \n   ipa_check_create_node_params ();\n@@ -1340,17 +1336,6 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t     sizeof (struct ipa_param_descriptor) * param_count);\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n   new_info->count_scale = old_info->count_scale;\n-\n-  for (note = old_info->param_calls; note; note = note->next)\n-    {\n-      struct ipa_param_call_note *nn;\n-\n-      nn = (struct ipa_param_call_note *)\n-\txcalloc (1, sizeof (struct ipa_param_call_note));\n-      memcpy (nn, note, sizeof (struct ipa_param_call_note));\n-      nn->next = new_info->param_calls;\n-      new_info->param_calls = nn;\n-    }\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n@@ -1387,11 +1372,19 @@ ipa_unregister_cgraph_hooks (void)\n   node_duplication_hook_holder = NULL;\n }\n \n+/* Allocate all necessary data strucutures necessary for indirect inlining.  */\n+\n+void\n+ipa_create_all_structures_for_iinln (void)\n+{\n+  iinlining_processed_edges = BITMAP_ALLOC (NULL);\n+}\n+\n /* Free all ipa_node_params and all ipa_edge_args structures if they are no\n    longer needed after ipa-cp.  */\n \n void\n-free_all_ipa_structures_after_ipa_cp (void)\n+ipa_free_all_structures_after_ipa_cp (void)\n {\n   if (!flag_indirect_inlining)\n     {\n@@ -1405,8 +1398,10 @@ free_all_ipa_structures_after_ipa_cp (void)\n    longer needed after indirect inlining.  */\n \n void\n-free_all_ipa_structures_after_iinln (void)\n+ipa_free_all_structures_after_iinln (void)\n {\n+  BITMAP_FREE (iinlining_processed_edges);\n+\n   ipa_free_all_edge_args ();\n   ipa_free_all_node_params ();\n   ipa_unregister_cgraph_hooks ();\n@@ -1974,40 +1969,31 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     }\n }\n \n-/* Stream out a parameter call note.  */\n+/* Stream out parts of cgraph_indirect_call_info corresponding to CS that are\n+   relevant to indirect inlining to OB.  */\n \n static void\n-ipa_write_param_call_note (struct output_block *ob,\n-\t\t\t   struct ipa_param_call_note *note)\n+ipa_write_indirect_edge_info (struct output_block *ob,\n+\t\t\t      struct cgraph_edge *cs)\n {\n-  gcc_assert (!note->processed);\n-  lto_output_uleb128_stream (ob->main_stream, gimple_uid (note->stmt));\n-  lto_output_sleb128_stream (ob->main_stream, note->formal_id);\n-  lto_output_sleb128_stream (ob->main_stream, note->count);\n-  lto_output_sleb128_stream (ob->main_stream, note->frequency);\n-  lto_output_sleb128_stream (ob->main_stream, note->loop_nest);\n+  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+\n+  lto_output_sleb128_stream (ob->main_stream, ii->param_index);\n }\n \n-/* Read in a parameter call note.  */\n+/* Read in parts of cgraph_indirect_call_info corresponding to CS that are\n+   relevant to indirect inlining from IB.  */\n \n static void\n-ipa_read_param_call_note (struct lto_input_block *ib,\n-\t\t\t  struct ipa_node_params *info)\n-\n+ipa_read_indirect_edge_info (struct lto_input_block *ib,\n+\t\t\t     struct data_in *data_in ATTRIBUTE_UNUSED,\n+\t\t\t     struct cgraph_edge *cs)\n {\n-  struct ipa_param_call_note *note = XCNEW (struct ipa_param_call_note);\n-\n-  note->lto_stmt_uid = (unsigned int) lto_input_uleb128 (ib);\n-  note->formal_id = (int) lto_input_sleb128 (ib);\n-  note->count = (gcov_type) lto_input_sleb128 (ib);\n-  note->frequency = (int) lto_input_sleb128 (ib);\n-  note->loop_nest = (int) lto_input_sleb128 (ib);\n+  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n \n-  note->next = info->param_calls;\n-  info->param_calls = note;\n+  ii->param_index = (int) lto_input_sleb128 (ib);\n }\n \n-\n /* Stream out NODE info to OB.  */\n \n static void\n@@ -2019,8 +2005,6 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   int j;\n   struct cgraph_edge *e;\n   struct bitpack_d *bp;\n-  int note_count = 0;\n-  struct ipa_param_call_note *note;\n \n   encoder = ob->decl_state->cgraph_node_encoder;\n   node_ref = lto_cgraph_encoder_encode (encoder, node);\n@@ -2046,12 +2030,8 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n \tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n     }\n-\n-  for (note = info->param_calls; note; note = note->next)\n-    note_count++;\n-  lto_output_uleb128_stream (ob->main_stream, note_count);\n-  for (note = info->param_calls; note; note = note->next)\n-    ipa_write_param_call_note (ob, note);\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    ipa_write_indirect_edge_info (ob, e);\n }\n \n /* Srtream in NODE info from IB.  */\n@@ -2064,7 +2044,6 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   int k;\n   struct cgraph_edge *e;\n   struct bitpack_d *bp;\n-  int i, note_count;\n \n   ipa_initialize_node_params (node);\n \n@@ -2094,10 +2073,8 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n \tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n     }\n-\n-  note_count = lto_input_uleb128 (ib);\n-  for (i = 0; i < note_count; i++)\n-    ipa_read_param_call_note (ib, info);\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    ipa_read_indirect_edge_info (ib, data_in, e);\n }\n \n /* Write jump functions for nodes in SET.  */\n@@ -2222,29 +2199,3 @@ ipa_update_after_lto_read (void)\n \t    ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n \t}\n }\n-\n-/* Walk param call notes of NODE and set their call statements given the uid\n-   stored in each note and STMTS which is an array of statements indexed by the\n-   uid.  */\n-\n-void\n-lto_ipa_fixup_call_notes (struct cgraph_node *node, gimple *stmts)\n-{\n-  struct ipa_node_params *info;\n-  struct ipa_param_call_note *note;\n-\n-  ipa_check_create_node_params ();\n-  info = IPA_NODE_REF (node);\n-  note = info->param_calls;\n-  /* If there are no notes or they have already been fixed up (the same fixup\n-     is called for both inlining and ipa-cp), there's nothing to do. */\n-  if (!note || note->stmt)\n-    return;\n-\n-  do\n-    {\n-      note->stmt = stmts[note->lto_stmt_uid];\n-      note = note->next;\n-    }\n-  while (note);\n-}"}, {"sha": "5a293d9018106fc5b08bb4acd0c74eac5427c53f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -135,32 +135,6 @@ struct ipcp_lattice\n   tree constant;\n };\n \n-/* Each instance of the following  structure describes a statement that calls a\n-   function parameter.  Those referring  to statements within the same function\n-   are linked in a list.  */\n-struct ipa_param_call_note\n-{\n-  /* Expected number of executions: calculated in profile.c.  */\n-  gcov_type count;\n-  /* Linked list's next */\n-  struct ipa_param_call_note *next;\n-  /* Statement that contains the call to the parameter above.  */\n-  gimple stmt;\n-  /* When in LTO, we the above stmt will be NULL and we need an uid. */\n-  unsigned int lto_stmt_uid;\n-  /* Index of the parameter that is called.  */\n-  int formal_id;\n-  /* Expected frequency of executions within the function. see cgraph_edge in\n-     cgraph.h for more on this. */\n-  int frequency;\n-  /* Depth of loop nest, 1 means no loop nest.  */\n-  unsigned short int loop_nest;\n-  /* Set when we have already found the target to be a compile time constant\n-     and turned this into an edge or when the note was found unusable for some\n-     reason.  */\n-  bool processed;\n-};\n-\n /* Structure describing a single formal parameter.  */\n struct ipa_param_descriptor\n {\n@@ -193,8 +167,6 @@ struct ipa_node_params\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n   struct ipa_param_descriptor *params;\n-  /* List of structures enumerating calls to a formal parameter.  */\n-  struct ipa_param_call_note *param_calls;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n@@ -337,8 +309,9 @@ void ipa_free_edge_args_substructures (struct ipa_edge_args *);\n void ipa_free_node_params_substructures (struct ipa_node_params *);\n void ipa_free_all_node_params (void);\n void ipa_free_all_edge_args (void);\n-void free_all_ipa_structures_after_ipa_cp (void);\n-void free_all_ipa_structures_after_iinln (void);\n+void ipa_create_all_structures_for_iinln (void);\n+void ipa_free_all_structures_after_ipa_cp (void);\n+void ipa_free_all_structures_after_iinln (void);\n void ipa_register_cgraph_hooks (void);\n \n /* This function ensures the array of node param infos is big enough to"}, {"sha": "b80576823e73010fc3f47a2570157feab7a3d3d8", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -139,15 +139,21 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   intptr_t ref;\n   struct bitpack_d *bp;\n \n-  lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_edge);\n+  if (edge->indirect_unknown_callee)\n+    lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_indirect_edge);\n+  else\n+    lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_edge);\n \n   ref = lto_cgraph_encoder_lookup (encoder, edge->caller);\n   gcc_assert (ref != LCC_NOT_FOUND);\n   lto_output_sleb128_stream (ob->main_stream, ref);\n \n-  ref = lto_cgraph_encoder_lookup (encoder, edge->callee);\n-  gcc_assert (ref != LCC_NOT_FOUND);\n-  lto_output_sleb128_stream (ob->main_stream, ref);\n+  if (!edge->indirect_unknown_callee)\n+    {\n+      ref = lto_cgraph_encoder_lookup (encoder, edge->callee);\n+      gcc_assert (ref != LCC_NOT_FOUND);\n+      lto_output_sleb128_stream (ob->main_stream, ref);\n+    }\n \n   lto_output_sleb128_stream (ob->main_stream, edge->count);\n \n@@ -157,7 +163,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_value (bp, edge->inline_failed, HOST_BITS_PER_INT);\n   bp_pack_value (bp, edge->frequency, HOST_BITS_PER_INT);\n   bp_pack_value (bp, edge->loop_nest, 30);\n-  bp_pack_value (bp, edge->indirect_call, 1);\n+  bp_pack_value (bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (bp, edge->call_stmt_cannot_inline_p, 1);\n   bp_pack_value (bp, edge->can_throw_external, 1);\n   lto_output_bitpack (ob->main_stream, bp);\n@@ -400,6 +406,25 @@ add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node)\n   lto_cgraph_encoder_encode (encoder, node);\n }\n \n+/* Output all callees or indirect outgoing edges.  EDGE must be the first such\n+   edge.  */\n+\n+static void\n+output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n+\t\t\t      struct lto_simple_output_block *ob,\n+\t\t\t      lto_cgraph_encoder_t encoder)\n+{\n+  if (!edge)\n+    return;\n+\n+  /* Output edges in backward direction, so the reconstructed callgraph match\n+     and it is easy to associate call sites in the IPA pass summaries.  */\n+  while (edge->next_callee)\n+    edge = edge->next_callee;\n+  for (; edge; edge = edge->prev_callee)\n+    lto_output_edge (ob, edge, encoder);\n+}\n+\n /* Output the part of the cgraph in SET.  */\n \n void\n@@ -468,16 +493,8 @@ output_cgraph (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      if (node->callees)\n-        {\n-\t  /* Output edges in backward direction, so the reconstructed callgraph\n-\t     match and it is easy to associate call sites in the IPA pass summaries.  */\n-\t  edge = node->callees;\n-\t  while (edge->next_callee)\n-\t    edge = edge->next_callee;\n-\t  for (; edge; edge = edge->prev_callee)\n-\t    lto_output_edge (ob, edge, encoder);\n-\t}\n+      output_outgoing_cgraph_edges (node->callees, ob, encoder);\n+      output_outgoing_cgraph_edges (node->indirect_calls, ob, encoder);\n     }\n \n   lto_output_uleb128_stream (ob->main_stream, 0);\n@@ -497,7 +514,6 @@ output_cgraph (cgraph_node_set set)\n   lto_destroy_simple_output_block (ob);\n }\n \n-\n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n    STACK_SIZE, SELF_TIME and SELF_SIZE.  This is called either to initialize\n    NODE or to replace the values in it, for instance because the first\n@@ -668,11 +684,14 @@ input_node (struct lto_file_decl_data *file_data,\n }\n \n \n-/* Read an edge from IB.  NODES points to a vector of previously read\n-   nodes for decoding caller and callee of the edge to be read.  */\n+/* Read an edge from IB.  NODES points to a vector of previously read nodes for\n+   decoding caller and callee of the edge to be read.  If INDIRECT is true, the\n+   edge being read is indirect (in the sense that it has\n+   indirect_unknown_callee set).  */\n \n static void\n-input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n+input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n+\t    bool indirect)\n {\n   struct cgraph_node *caller, *callee;\n   struct cgraph_edge *edge;\n@@ -688,9 +707,14 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n   if (caller == NULL || caller->decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n-  callee = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n-  if (callee == NULL || callee->decl == NULL_TREE)\n-    internal_error (\"bytecode stream: no callee found while reading edge\");\n+  if (!indirect)\n+    {\n+      callee = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+      if (callee == NULL || callee->decl == NULL_TREE)\n+\tinternal_error (\"bytecode stream: no callee found while reading edge\");\n+    }\n+  else\n+    callee = NULL;\n \n   count = (gcov_type) lto_input_sleb128 (ib);\n \n@@ -708,10 +732,14 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n       || caller_resolution == LDPR_PREEMPTED_IR)\n     return;\n \n-  edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n+  if (indirect)\n+    edge = cgraph_create_indirect_edge (caller, NULL, count, freq, nest);\n+  else\n+    edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n+\n+  edge->indirect_inlining_edge = bp_unpack_value (bp, 1);\n   edge->lto_stmt_uid = stmt_id;\n   edge->inline_failed = inline_failed;\n-  edge->indirect_call = bp_unpack_value (bp, 1);\n   edge->call_stmt_cannot_inline_p = bp_unpack_value (bp, 1);\n   edge->can_throw_external = bp_unpack_value (bp, 1);\n   bitpack_delete (bp);\n@@ -734,7 +762,9 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   while (tag)\n     {\n       if (tag == LTO_cgraph_edge)\n-        input_edge (ib, nodes);\n+        input_edge (ib, nodes, false);\n+      else if (tag == LTO_cgraph_indirect_edge)\n+        input_edge (ib, nodes, true);\n       else\n \t{\n \t  node = input_node (file_data, ib, tag);"}, {"sha": "3001f6522fc97fa40b8d5ea0d984847fe253f506", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1248,6 +1248,8 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts)\n   struct cgraph_edge *cedge;\n   for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n     cedge->call_stmt = stmts[cedge->lto_stmt_uid];\n+  for (cedge = node->indirect_calls; cedge; cedge = cedge->next_callee)\n+    cedge->call_stmt = stmts[cedge->lto_stmt_uid];\n }\n \n /* Fixup call_stmt pointers in NODE and all clones.  */"}, {"sha": "1d1b6f1e1de0cd333b75f596df90782fd54e6d9a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1,3 +1,7 @@\n+2010-04-28  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/lto/20091209-1_0.c: New testcase.\n+\n 2010-04-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43879"}, {"sha": "5aa2fe0b058abb752954f2f055f226d26aa597ee", "filename": "gcc/testsuite/gcc.dg/lto/20091209-1_0.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091209-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091209-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091209-1_0.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -0,0 +1,23 @@\n+/* Stream an indirect edge in and out.  */\n+\n+/* { dg-lto-do link } */\n+/* { dg-lto-options {{ -O3 -fno-early-inlining -flto }} } */\n+\n+volatile int something;\n+\n+static void hooray ()\n+{\n+  something = 1;\n+}\n+\n+static void hiphip (void (*f)())\n+{\n+  something = 2;\n+  f ();\n+}\n+\n+int main (int argc, int *argv[])\n+{\n+  hiphip (hooray);\n+  return 0;\n+}"}, {"sha": "383cc86f24371d21916e31dc5e67e6f170497c3f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e33c6cd6af8a30a4f0ec49c83f1ac32e44a07eac", "patch": "@@ -1698,9 +1698,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      /* Constant propagation on argument done during inlining\n \t\t may create new direct call.  Produce an edge for it.  */\n \t      if ((!edge\n-\t\t   || (edge->indirect_call\n+\t\t   || (edge->indirect_inlining_edge\n \t\t       && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n-\t\t  && is_gimple_call (stmt)\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n \t\t  struct cgraph_node *dest = cgraph_node (fn);\n@@ -3553,7 +3552,7 @@ get_indirect_callee_fndecl (struct cgraph_node *node, gimple stmt)\n   struct cgraph_edge *cs;\n \n   cs = cgraph_edge (node, stmt);\n-  if (cs)\n+  if (cs && !cs->indirect_unknown_callee)\n     return cs->callee->decl;\n \n   return NULL_TREE;\n@@ -3636,7 +3635,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       /* If this call was originally indirect, we do not want to emit any\n \t inlining related warnings or sorry messages because there are no\n \t guarantees regarding those.  */\n-      if (cg_edge->indirect_call)\n+      if (cg_edge->indirect_inlining_edge)\n \tgoto egress;\n \n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn))"}]}