{"sha": "9e916de77050832244aa0ca09c691e8cec0eb369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5MTZkZTc3MDUwODMyMjQ0YWEwY2EwOWM2OTFlOGNlYzBlYjM2OQ==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2012-03-27T09:50:10Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2012-03-27T09:50:10Z"}, "message": "unwind-ia64.h: Declare unw_word and unw_sword.\n\n2012-03-26  Tristan Gingold  <gingold@adacore.com>\n\n        * config/ia64/unwind-ia64.h: Declare unw_word and unw_sword.\n        (unw_table_entry): Use unw_word instead of unsigned long.\n        (_Unwind_FindTableEntry): Likewise.\n        * config/ia64/fde-glibc.c (_Unwind_FindTableEntry): Likewise.\n        * config/ia64/fde-vms.c (vms_unwtable_entry): Likewise.\n        (_Unwind_FindTableEntry): Likewise.\n        * config/ia64/unwind-ia64.c (unw_reg_info, unw_reg_state)\n        (unw_labeled_state, unw_state_record, unw_stack, _Uwind_Context)\n        (set_reg, alloc_spill_area, finish_prologue, ia64_rse_slot_num)\n        (ia64_rse_is_rnat_slot, ia64_rse_rnat_addr, ia64_rse_num_regs)\n        (ia64_rse_skip_regs, ia64_copy_rbs, unw_access_gr)\n        (uw_frame_state_for, uw_update_reg_address, uw_update_context)\n        (uw_init_context_1, uw_install_context): Likewise.\n        (unw_word): Move to unwind-ia64.h\n\nFrom-SVN: r185852", "tree": {"sha": "85a716476b201f6c76a556ab684640ce89eb60d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a716476b201f6c76a556ab684640ce89eb60d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e916de77050832244aa0ca09c691e8cec0eb369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e916de77050832244aa0ca09c691e8cec0eb369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e916de77050832244aa0ca09c691e8cec0eb369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e916de77050832244aa0ca09c691e8cec0eb369/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2283164d2efd0603c1f7694aa45164cc6e3198e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2283164d2efd0603c1f7694aa45164cc6e3198e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2283164d2efd0603c1f7694aa45164cc6e3198e8"}], "stats": {"total": 287, "additions": 154, "deletions": 133}, "files": [{"sha": "be35f81e0ad15db983ba5f725d2946015743963d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -1,3 +1,20 @@\n+2012-03-26  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* config/ia64/unwind-ia64.h: Declare unw_word and unw_sword.\n+\t(unw_table_entry): Use unw_word instead of unsigned long.\n+\t(_Unwind_FindTableEntry): Likewise.\n+\t* config/ia64/fde-glibc.c (_Unwind_FindTableEntry): Likewise.\n+\t* config/ia64/fde-vms.c (vms_unwtable_entry): Likewise.\n+\t(_Unwind_FindTableEntry): Likewise.\n+\t* config/ia64/unwind-ia64.c (unw_reg_info, unw_reg_state)\n+\t(unw_labeled_state, unw_state_record, unw_stack, _Uwind_Context)\n+\t(set_reg, alloc_spill_area, finish_prologue, ia64_rse_slot_num)\n+\t(ia64_rse_is_rnat_slot, ia64_rse_rnat_addr, ia64_rse_num_regs)\n+\t(ia64_rse_skip_regs, ia64_copy_rbs, unw_access_gr)\n+\t(uw_frame_state_for, uw_update_reg_address, uw_update_context)\n+\t(uw_init_context_1, uw_install_context): Likewise.\n+\t(unw_word): Move to unwind-ia64.h\n+\n 2012-03-26  Tristan Gingold  <gingold@adacore.com>\n \n \t* config/vms/vms-ucrt0.c: Update copyright years."}, {"sha": "64623078a3d79a5ada1b371b77e11e5612328679", "filename": "libgcc/config/ia64/fde-glibc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Ffde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Ffde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fia64%2Ffde-glibc.c?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -144,8 +144,7 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n    containing PC.  */\n \n struct unw_table_entry *\n-_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n-                        unsigned long *gp,\n+_Unwind_FindTableEntry (void *pc, unw_word *segment_base, unw_word *gp,\n                         struct unw_table_entry *ent ATTRIBUTE_UNUSED)\n {\n   struct unw_ia64_callback_data data;"}, {"sha": "7c5d24e3902e22b4c5e52e65b36d0de9b8febe92", "filename": "libgcc/config/ia64/fde-vms.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Ffde-vms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Ffde-vms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fia64%2Ffde-vms.c?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -35,8 +35,7 @@\n #include <stdio.h>\n #include \"unwind-ia64.h\"\n \n-#define __int64 long\n-#include <vms/ossddef.h>\n+#include <ossddef.h>\n #ifndef SS$_NORMAL\n #define SS$_NORMAL 1\n #endif\n@@ -45,10 +44,10 @@\n \n typedef struct\n {\n-  unsigned long start_offset;\n-  unsigned long end_offset;\n-  unsigned long info_offset;\n-  unsigned long gp_value;\n+  unw_word start_offset;\n+  unw_word end_offset;\n+  unw_word info_offset;\n+  unw_word gp_value;\n }  vms_unw_table_entry;\n \n typedef unsigned long long uqword;\n@@ -133,8 +132,8 @@ force_fallback_processing_for (void * pc, vms_unw_table_entry * entry)\n    calls for fallback processing.  */\n \n struct unw_table_entry *\n-_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n-                        unsigned long *gp, struct unw_table_entry *ent)\n+_Unwind_FindTableEntry (void *pc, unw_word *segment_base,\n+                        unw_word *gp, struct unw_table_entry *ent)\n {\n   vms_unw_table_entry vueblock;\n "}, {"sha": "10cf1363b1bd80f57a67f6f9e0167ccac1469089", "filename": "libgcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -114,33 +114,33 @@ enum unw_where\n \n struct unw_reg_info\n {\n-  unsigned long val;\t\t/* save location: register number or offset */\n+  unw_word val;\t\t\t/* save location: register number or offset */\n   enum unw_where where;\t\t/* where the register gets saved */\n   int when;\t\t\t/* when the register gets saved */\n };\n \n struct unw_reg_state {\n-\tstruct unw_reg_state *next;\t/* next (outer) element on state stack */\n-\tstruct unw_reg_info reg[UNW_NUM_REGS];\t/* register save locations */\n+  struct unw_reg_state *next;\t/* next (outer) element on state stack */\n+  struct unw_reg_info reg[UNW_NUM_REGS];\t/* register save locations */\n };\n \n struct unw_labeled_state {\n-\tstruct unw_labeled_state *next;\t\t/* next labeled state (or NULL) */\n-\tunsigned long label;\t\t\t/* label for this state */\n-\tstruct unw_reg_state saved_state;\n+  struct unw_labeled_state *next;\t/* next labeled state (or NULL) */\n+  unw_word label;\t\t\t/* label for this state */\n+  struct unw_reg_state saved_state;\n };\n \n typedef struct unw_state_record\n {\n   unsigned int first_region : 1;\t/* is this the first region? */\n   unsigned int done : 1;\t\t/* are we done scanning descriptors? */\n   unsigned int any_spills : 1;\t\t/* got any register spills? */\n-  unsigned int in_body : 1;\t/* are we inside a body? */\n+  unsigned int in_body : 1;\t\t/* are we inside a body? */\n   unsigned int no_reg_stack_frame : 1;\t/* Don't adjust bsp for i&l regs */\n-  unsigned char *imask;\t\t/* imask of spill_mask record or NULL */\n-  unsigned long pr_val;\t\t/* predicate values */\n-  unsigned long pr_mask;\t/* predicate mask */\n-  long spill_offset;\t\t/* psp-relative offset for spill base */\n+  unsigned char *imask;\t\t\t/* imask of spill_mask record or NULL */\n+  unw_word pr_val;\t\t\t/* predicate values */\n+  unw_word pr_mask;\t\t\t/* predicate mask */\n+  unw_sword spill_offset;\t\t/* psp-relative offset for spill base */\n   int region_start;\n   int region_len;\n   int epilogue_start;\n@@ -168,66 +168,64 @@ enum unw_nat_type\n \n struct unw_stack\n {\n-  unsigned long limit;\n-  unsigned long top;\n+  unw_word limit;\n+  unw_word top;\n };\n \n struct _Unwind_Context\n {\n   /* Initial frame info.  */\n-  unsigned long rnat;\t\t/* rse nat collection */\n-  unsigned long regstk_top;\t/* lowest address of rbs stored register\n-\t\t\t\t   which uses context->rnat collection */\n+  unw_word rnat;\t/* rse nat collection */\n+  unw_word regstk_top;\t/* lowest address of rbs stored register\n+\t\t\t   which uses context->rnat collection */\n \n   /* Current frame info.  */\n-  unsigned long bsp;\t\t/* backing store pointer value\n-\t\t\t\t   corresponding to psp.  */\n-  unsigned long sp;\t\t/* stack pointer value */\n-  unsigned long psp;\t\t/* previous sp value */\n-  unsigned long rp;\t\t/* return pointer */\n-  unsigned long pr;\t\t/* predicate collection */\n+  unw_word bsp;\t\t/* backing store pointer value\n+\t\t\t   corresponding to psp.  */\n+  unw_word sp;\t\t/* stack pointer value */\n+  unw_word psp;\t\t/* previous sp value */\n+  unw_word rp;\t\t/* return pointer */\n+  unw_word pr;\t\t/* predicate collection */\n \n-  unsigned long region_start;\t/* start of unwind region */\n-  unsigned long gp;\t\t/* global pointer value */\n-  void *lsda;\t\t\t/* language specific data area */\n+  unw_word region_start;/* start of unwind region */\n+  unw_word gp;\t\t/* global pointer value */\n+  void *lsda;\t\t/* language specific data area */\n \n   /* Preserved state.  */\n-  unsigned long *bsp_loc;\t/* previous bsp save location\n-  \t\t\t\t   Appears to be write-only?\t*/\n-  unsigned long *bspstore_loc;\n-  unsigned long *pfs_loc;\t/* Save location for pfs in current\n-  \t\t\t\t   (corr. to sp) frame.  Target\n-  \t\t\t\t   contains cfm for caller.\t*/\n-  unsigned long *signal_pfs_loc;/* Save location for pfs in current\n-\t\t\t\t   signal frame.  Target contains\n-\t\t\t\t   pfs for caller.  */\n-  unsigned long *pri_unat_loc;\n-  unsigned long *unat_loc;\n-  unsigned long *lc_loc;\n-  unsigned long *fpsr_loc;\n-\n-  unsigned long eh_data[4];\n+  unw_word *bsp_loc;    /* previous bsp save location\n+                           Appears to be write-only?    */\n+  unw_word *bspstore_loc;\n+  unw_word *pfs_loc;    /* Save location for pfs in current\n+                           (corr. to sp) frame.  Target\n+                           contains cfm for caller.     */\n+  unw_word *signal_pfs_loc;/* Save location for pfs in current\n+                           signal frame.  Target contains\n+                           pfs for caller.  */\n+  unw_word *pri_unat_loc;\n+  unw_word *unat_loc;\n+  unw_word *lc_loc;\n+  unw_word *fpsr_loc;\n+\n+  unw_word eh_data[4];\n \n   struct unw_ireg\n   {\n-    unsigned long *loc;\n+    unw_word *loc;\n     struct unw_ireg_nat\n     {\n       enum unw_nat_type type : 3;\n-      signed long off : 61;\t\t/* NaT word is at loc+nat.off */\n+      unw_sword off : 61;\t\t/* NaT word is at loc+nat.off */\n     } nat;\n   } ireg[32 - 2];\t/* Indexed by <register number> - 2 */\n \n-  unsigned long *br_loc[8];\n+  unw_word *br_loc[8];\n   void *fr_loc[32 - 2];\n \n   /* ??? We initially point pri_unat_loc here.  The entire NAT bit\n      logic needs work.  */\n-  unsigned long initial_unat;\n+  unw_word initial_unat;\n };\n \n-typedef unsigned long unw_word;\n-\n /* Implicit register save order.  See section 11.4.2.3 Rules for Using\n    Unwind Descriptors, rule 3.  */\n \n@@ -464,7 +462,7 @@ decode_abreg (unsigned char abreg, int memory)\n \n static void\n set_reg (struct unw_reg_info *reg, enum unw_where where,\n-\t int when, unsigned long val)\n+\t int when, unw_word val)\n {\n   reg->val = val;\n   reg->where = where;\n@@ -473,7 +471,7 @@ set_reg (struct unw_reg_info *reg, enum unw_where where,\n }\n \n static void\n-alloc_spill_area (unsigned long *offp, unsigned long regsize,\n+alloc_spill_area (unw_word *offp, unw_word regsize,\n \t\t  struct unw_reg_info *lo, struct unw_reg_info *hi)\n {\n   struct unw_reg_info *reg;\n@@ -512,7 +510,7 @@ static void\n finish_prologue (struct unw_state_record *sr)\n {\n   struct unw_reg_info *reg;\n-  unsigned long off;\n+  unw_word off;\n   int i;\n \n   /* First, resolve implicit register save locations\n@@ -1449,44 +1447,44 @@ unw_decode (unsigned char *dp, int inside_body, void *arg)\n \f\n /* RSE helper functions.  */\n \n-static inline unsigned long\n-ia64_rse_slot_num (unsigned long *addr)\n+static inline unw_word\n+ia64_rse_slot_num (unw_word *addr)\n {\n-  return (((unsigned long) addr) >> 3) & 0x3f;\n+  return (((unw_word) addr) >> 3) & 0x3f;\n }\n \n /* Return TRUE if ADDR is the address of an RNAT slot.  */\n-static inline unsigned long\n-ia64_rse_is_rnat_slot (unsigned long *addr)\n+static inline unw_word\n+ia64_rse_is_rnat_slot (unw_word *addr)\n {\n   return ia64_rse_slot_num (addr) == 0x3f;\n }\n \n /* Returns the address of the RNAT slot that covers the slot at\n    address SLOT_ADDR.  */\n-static inline unsigned long *\n-ia64_rse_rnat_addr (unsigned long *slot_addr)\n+static inline unw_word *\n+ia64_rse_rnat_addr (unw_word *slot_addr)\n {\n-  return (unsigned long *) ((unsigned long) slot_addr | (0x3f << 3));\n+  return (unw_word *) ((unw_word) slot_addr | (0x3f << 3));\n }\n \n /* Calculate the number of registers in the dirty partition starting at\n    BSPSTORE with a size of DIRTY bytes.  This isn't simply DIRTY\n    divided by eight because the 64th slot is used to store ar.rnat.  */\n-static inline unsigned long\n-ia64_rse_num_regs (unsigned long *bspstore, unsigned long *bsp)\n+static inline unw_word\n+ia64_rse_num_regs (unw_word *bspstore, unw_word *bsp)\n {\n-  unsigned long slots = (bsp - bspstore);\n+  unw_word slots = (bsp - bspstore);\n \n   return slots - (ia64_rse_slot_num (bspstore) + slots)/0x40;\n }\n \n /* The inverse of the above: given bspstore and the number of\n    registers, calculate ar.bsp.  */\n-static inline unsigned long *\n-ia64_rse_skip_regs (unsigned long *addr, long num_regs)\n+static inline unw_word *\n+ia64_rse_skip_regs (unw_word *addr, int num_regs)\n {\n-  long delta = ia64_rse_slot_num (addr) + num_regs;\n+  int delta = ia64_rse_slot_num (addr) + num_regs;\n \n   if (num_regs < 0)\n     delta -= 0x3e;\n@@ -1501,20 +1499,20 @@ ia64_rse_skip_regs (unsigned long *addr, long num_regs)\n    done with a simple memcpy as the nat collections will be\n    at different relative offsets and need to be combined together.  */\n static void\n-ia64_copy_rbs (struct _Unwind_Context *info, unsigned long dst,\n-               unsigned long src, long len, unsigned long dst_rnat)\n+ia64_copy_rbs (struct _Unwind_Context *info, unw_word dst,\n+               unw_word src, unw_word len, unw_word dst_rnat)\n {\n-  long count;\n-  unsigned long src_rnat;\n-  unsigned long shift1, shift2;\n+  unw_word count;\n+  unw_word src_rnat;\n+  unw_word shift1, shift2;\n \n   len <<= 3;\n-  dst_rnat &= (1UL << ((dst >> 3) & 0x3f)) - 1;\n+  dst_rnat &= (1ULL << ((dst >> 3) & 0x3f)) - 1;\n   src_rnat = src >= info->regstk_top\n-\t     ? info->rnat : *(unsigned long *) (src | 0x1f8);\n-  src_rnat &= ~((1UL << ((src >> 3) & 0x3f)) - 1);\n+\t     ? info->rnat : *(unw_word *) (src | 0x1f8);\n+  src_rnat &= ~((1ULL << ((src >> 3) & 0x3f)) - 1);\n   /* Just to make sure.  */\n-  src_rnat &= ~(1UL << 63);\n+  src_rnat &= ~(1ULL << 63);\n   shift1 = ((dst - src) >> 3) & 0x3f;\n   if ((dst & 0x1f8) < (src & 0x1f8))\n     shift1--;\n@@ -1529,9 +1527,9 @@ ia64_copy_rbs (struct _Unwind_Context *info, unsigned long dst,\n   while (len > 0)\n     {\n       src_rnat = src >= info->regstk_top\n-\t\t ? info->rnat : *(unsigned long *) (src | 0x1f8);\n+\t\t ? info->rnat : *(unw_word *) (src | 0x1f8);\n       /* Just to make sure.  */\n-      src_rnat &= ~(1UL << 63);\n+      src_rnat &= ~(1ULL << 63);\n       count = shift2 << 3;\n first:\n       if (count > len)\n@@ -1540,10 +1538,10 @@ ia64_copy_rbs (struct _Unwind_Context *info, unsigned long dst,\n       dst += count;\n       src += count;\n       len -= count;\n-      dst_rnat |= (src_rnat << shift1) & ~(1UL << 63);\n+      dst_rnat |= (src_rnat << shift1) & ~(1ULL << 63);\n       if (len <= 0)\n         break;\n-      *(long *) dst = dst_rnat;\n+      *(unw_word *) dst = dst_rnat;\n       dst += 8;\n       dst_rnat = 0;\n       count = shift1 << 3;\n@@ -1558,23 +1556,23 @@ ia64_copy_rbs (struct _Unwind_Context *info, unsigned long dst,\n     }\n   if ((dst & 0x1f8) == 0x1f8)\n     {\n-      *(long *) dst = dst_rnat;\n+      *(unw_word *) dst = dst_rnat;\n       dst += 8;\n       dst_rnat = 0;\n     }\n   /* Set info->regstk_top to lowest rbs address which will use\n      info->rnat collection.  */\n-  info->regstk_top = dst & ~0x1ffUL;\n+  info->regstk_top = dst & ~0x1ffULL;\n   info->rnat = dst_rnat;\n }\n \n /* Unwind accessors.  */\n \n static void\n unw_access_gr (struct _Unwind_Context *info, int regnum,\n-\t       unsigned long *val, char *nat, int write)\n+\t       unw_word *val, char *nat, int write)\n {\n-  unsigned long *addr, *nat_addr = 0, nat_mask = 0, dummy_nat;\n+  unw_word *addr, *nat_addr = 0, nat_mask = 0, dummy_nat;\n   struct unw_ireg *ireg;\n \n   if ((unsigned) regnum - 1 >= 127)\n@@ -1623,24 +1621,24 @@ unw_access_gr (struct _Unwind_Context *info, int regnum,\n \t      break;\n \n \t    case UNW_NAT_MEMSTK:\n-\t      nat_mask = 1UL << ((long) addr & 0x1f8)/8;\n+\t      nat_mask = 1UL << ((unw_word) addr & 0x1f8)/8;\n \t      break;\n \n \t    case UNW_NAT_REGSTK:\n-\t      if ((unsigned long) addr >= info->regstk_top)\n+\t      if ((unw_word) addr >= info->regstk_top)\n \t\tnat_addr = &info->rnat;\n \t      else\n \t\tnat_addr = ia64_rse_rnat_addr (addr);\n-\t      nat_mask = 1UL << ia64_rse_slot_num (addr);\n+\t      nat_mask = 1ULL << ia64_rse_slot_num (addr);\n \t      break;\n \t    }\n \t}\n     }\n   else\n     {\n       /* Access a stacked register.  */\n-      addr = ia64_rse_skip_regs ((unsigned long *) info->bsp, regnum - 32);\n-      if ((unsigned long) addr >= info->regstk_top)\n+      addr = ia64_rse_skip_regs ((unw_word *) info->bsp, regnum - 32);\n+      if ((unw_word) addr >= info->regstk_top)\n \tnat_addr = &info->rnat;\n       else\n \tnat_addr = ia64_rse_rnat_addr (addr);\n@@ -1734,7 +1732,7 @@ void *\n _Unwind_FindEnclosingFunction (void *pc)\n {\n   struct unw_table_entry *entp, ent;\n-  unsigned long segment_base, gp;\n+  unw_word segment_base, gp;\n \n   entp = _Unwind_FindTableEntry (pc, &segment_base, &gp, &ent);\n   if (entp == NULL)\n@@ -1774,9 +1772,9 @@ static _Unwind_Reason_Code\n uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n   struct unw_table_entry *entp, ent;\n-  unsigned long *unw, header, length;\n+  unw_word *unw, header, length;\n   unsigned char *insn, *insn_end;\n-  unsigned long segment_base;\n+  unw_word segment_base;\n   struct unw_reg_info *r;\n \n   memset (fs, 0, sizeof (*fs));\n@@ -1815,7 +1813,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   fs->when_target = ((context->rp & -16) - context->region_start) / 16 * 3\n \t\t    + (context->rp & 15);\n \n-  unw = (unsigned long *) (entp->info_offset + segment_base);\n+  unw = (unw_word *) (entp->info_offset + segment_base);\n   header = *unw;\n   length = UNW_LENGTH (header);\n \n@@ -1912,7 +1910,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n {\n   struct unw_reg_info *r = fs->curr.reg + regno;\n   void *addr;\n-  unsigned long rval;\n+  unw_word rval;\n \n   if (r->where == UNW_WHERE_NONE || r->when >= fs->when_target)\n     return;\n@@ -1922,12 +1920,12 @@ uw_update_reg_address (struct _Unwind_Context *context,\n     {\n     case UNW_WHERE_GR:\n       if (rval >= 32)\n-\taddr = ia64_rse_skip_regs ((unsigned long *) context->bsp, rval - 32);\n+\taddr = ia64_rse_skip_regs ((unw_word *) context->bsp, rval - 32);\n       else if (rval >= 2)\n \taddr = context->ireg[rval - 2].loc;\n       else if (rval == 0)\n \t{\n-\t  static const unsigned long dummy;\n+\t  static const unw_word dummy;\n \t  addr = (void *) &dummy;\n \t}\n       else\n@@ -1974,7 +1972,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n \t  {\n \t    context->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_MEMSTK;\n \t    context->ireg[regno - UNW_REG_R2].nat.off\n-\t      = context->pri_unat_loc - (unsigned long *) addr;\n+\t      = context->pri_unat_loc - (unw_word *) addr;\n \t  }\n \telse if (rval >= 2)\n \t  {\n@@ -2004,7 +2002,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n       case UNW_WHERE_SPREL:\n \tcontext->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_MEMSTK;\n \tcontext->ireg[regno - UNW_REG_R2].nat.off\n-\t  = context->pri_unat_loc - (unsigned long *) addr;\n+\t  = context->pri_unat_loc - (unw_word *) addr;\n \tbreak;\n \n       default:\n@@ -2030,13 +2028,13 @@ uw_update_reg_address (struct _Unwind_Context *context,\n       context->pfs_loc = addr;\n       break;\n     case UNW_REG_RP:\n-      context->rp = *(unsigned long *)addr;\n+      context->rp = *(unw_word *)addr;\n       break;\n     case UNW_REG_UNAT:\n       context->unat_loc = addr;\n       break;\n     case UNW_REG_PR:\n-      context->pr = *(unsigned long *) addr;\n+      context->pr = *(unw_word *) addr;\n       break;\n     case UNW_REG_LC:\n       context->lc_loc = addr;\n@@ -2046,7 +2044,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n       break;\n \n     case UNW_REG_PSP:\n-      context->psp = *(unsigned long *)addr;\n+      context->psp = *(unw_word *)addr;\n       break;\n \n     default:\n@@ -2057,7 +2055,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n static void\n uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n-  long i;\n+  int i;\n \n #ifdef MD_HANDLE_UNWABI\n   MD_HANDLE_UNWABI (context, fs);\n@@ -2100,10 +2098,10 @@ uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n      pfs_loc is valid.\t*/\n   if (!(fs -> no_reg_stack_frame))\n     {\n-      unsigned long pfs = *context->pfs_loc;\n-      unsigned long sol = (pfs >> 7) & 0x7f;\n-      context->bsp = (unsigned long)\n-\tia64_rse_skip_regs ((unsigned long *) context->bsp, -sol);\n+      unw_word pfs = *context->pfs_loc;\n+      unw_word sol = (pfs >> 7) & 0x7f;\n+      context->bsp = (unw_word)\n+\tia64_rse_skip_regs ((unw_word *) context->bsp, -sol);\n     }\n }\n \n@@ -2132,7 +2130,7 @@ uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n   /* Set psp to the caller's stack pointer.  */\n   void *psp = __builtin_dwarf_cfa () - 16;\n   _Unwind_FrameState fs;\n-  unsigned long rnat, tmp1, tmp2;\n+  unw_word rnat, tmp1, tmp2;\n \n   /* Flush the register stack to memory so that we can access it.\n      Get rse nat collection for the last incomplete rbs chunk of\n@@ -2147,13 +2145,13 @@ uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n        : \"=r\" (rnat), \"=r\" (tmp1), \"=r\" (tmp2));\n \n   memset (context, 0, sizeof (struct _Unwind_Context));\n-  context->bsp = (unsigned long) bsp;\n+  context->bsp = (unw_word) bsp;\n   /* Set context->regstk_top to lowest rbs address which will use\n      context->rnat collection.  */\n   context->regstk_top = context->bsp & ~0x1ffULL;\n   context->rnat = rnat;\n-  context->psp = (unsigned long) psp;\n-  context->rp = (unsigned long) rp;\n+  context->psp = (unw_word) psp;\n+  context->rp = (unw_word) rp;\n   asm (\"mov %0 = sp\" : \"=r\" (context->sp));\n   asm (\"mov %0 = pr\" : \"=r\" (context->pr));\n   context->pri_unat_loc = &context->initial_unat;\t/* ??? */\n@@ -2170,8 +2168,8 @@ static void __attribute__((noreturn))\n uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n \t\t    struct _Unwind_Context *target)\n {\n-  unsigned long ireg_buf[4], ireg_nat = 0, ireg_pr = 0;\n-  long i;\n+  unw_word ireg_buf[4], ireg_nat = 0, ireg_pr = 0;\n+  int i;\n \n   /* Copy integer register data from the target context to a\n      temporary buffer.  Do this so that we can frob AR.UNAT\n@@ -2183,7 +2181,7 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n       if (t)\n \t{\n \t  unw_access_gr (target, i, &ireg_buf[i - 4], &nat, 0);\n-          ireg_nat |= (long)nat << (((size_t)&ireg_buf[i - 4] >> 3) & 0x3f);\n+          ireg_nat |= (unw_word)nat << (((size_t)&ireg_buf[i - 4] >> 3) & 0x3f);\n \t  /* Set p6 - p9.  */\n \t  ireg_pr |= 4L << i;\n \t}\n@@ -2193,12 +2191,12 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n      target function.  The value that we install below will be\n      adjusted by the BR.RET instruction based on the contents\n      of AR.PFS.  So we must unadjust that here.  */\n-  target->bsp = (unsigned long)\n-    ia64_rse_skip_regs ((unsigned long *)target->bsp,\n+  target->bsp = (unw_word)\n+    ia64_rse_skip_regs ((unw_word *)target->bsp,\n \t\t\t(*target->pfs_loc >> 7) & 0x7f);\n \n   if (target->bsp < target->regstk_top)\n-    target->rnat = *ia64_rse_rnat_addr ((unsigned long *) target->bsp);\n+    target->rnat = *ia64_rse_rnat_addr ((unw_word *) target->bsp);\n \n   /* Provide assembly with the offsets into the _Unwind_Context.  */\n   asm volatile (\"uc_rnat = %0\""}, {"sha": "344ccd59685ddc284d4991d24c2931fb47734110", "filename": "libgcc/config/ia64/unwind-ia64.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Funwind-ia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Funwind-ia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fia64%2Funwind-ia64.h?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -18,11 +18,20 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+#ifdef __VMS__\n+/* On VMS, long is a 32 bit type.  */\n+typedef unsigned long long unw_word;\n+typedef long long unw_sword;\n+#else\n+typedef unsigned long unw_word;\n+typedef long unw_sword;\n+#endif\n+\n struct unw_table_entry\n {\n-  unsigned long start_offset;\n-  unsigned long end_offset;\n-  unsigned long info_offset;\n+  unw_word start_offset;\n+  unw_word end_offset;\n+  unw_word info_offset;\n };\n \n /* Accessors to fields of an unwind info block header.  In this common file to\n@@ -38,6 +47,6 @@ struct unw_table_entry\n #endif\n \n extern struct unw_table_entry *\n-_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n-\t\t\tunsigned long *gp, struct unw_table_entry *ent)\n+_Unwind_FindTableEntry (void *pc, unw_word *segment_base,\n+\t\t\tunw_word *gp, struct unw_table_entry *ent)\n \t\t\t__attribute__ ((__visibility__ (\"hidden\")));"}, {"sha": "2c94a3009b0984db70cdc29f0de1873278394053", "filename": "libgcc/config/ia64/vms-unwind.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Fvms-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e916de77050832244aa0ca09c691e8cec0eb369/libgcc%2Fconfig%2Fia64%2Fvms-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fia64%2Fvms-unwind.h?ref=9e916de77050832244aa0ca09c691e8cec0eb369", "patch": "@@ -22,12 +22,11 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n-#include <vms/libicb.h>\n-#include <vms/chfdef.h>\n-#include <vms/chfctxdef.h>\n-\n-#define __int64 long long\n-#include <vms/intstkdef.h>\n+#define __NEW_STARLET\n+#include <libicb.h>\n+#include <chfdef.h>\n+#include <lib_c/chfctxdef.h>\n+#include <lib_c/intstkdef.h>\n \n #include <stdio.h>\n #include <string.h>"}]}