{"sha": "35d0b14df6995e79e84201c45d49ef986f9e0b77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkMGIxNGRmNjk5NWU3OWU4NDIwMWM0NWQ0OWVmOTg2ZjllMGI3Nw==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-02-16T20:00:33Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-16T20:00:33Z"}, "message": "ByteBuffer.java (endian): Make non-private so other java.nio classes can inherit it.\n\n\n\t* java/nio/ByteBuffer.java (endian):  Make non-private so other\n\tjava.nio classes can inherit it.\n\t(<init>):  Don't bother clearing array_offset.\n\t* java/nio/ByteBuffer.java (allocate):  Re-implement using wrap.\n\t* java/nio/ByteBuffer.java (get(byte[],int,int)):  Check underflow.\n\tRemove redundant test.\n\n\t* java/nio/ByteBufferImpl.java (asCharBuffer, asShortBuffer,\n\tasIntBuffer, asLongBuffer, asFloatBuffer, asDoubleBuffer):\n\tUse new XxxViewBufferImpl constructors.\n\t* java/nio/MappedByteBufferImpl.java:  Likewise.\n\t* java/nio/DirectByteBufferImpl.java:  Likewise.\n\n\t* java/nio/ByteBufferImpl.java:  Remove one constructor.\n\tInline super in remaining constructor.\n\t* java/nio/ByteBuffer.java:  Remove unused constructor.\n\n\t* java/nio/ByteBufferImpl.java (shiftDown):  New optimized method.\n\n\t* java/nio/ByteBufferImpl.java (get, put):  Add array_offset.\n\t* java/nio/DirectByteBufferImpl.java (owner):  New field.\n\t(offset):  Remove unused field.\n\t(<init>):  Modify one and add another constructor.  Change callers.\n\t(allocateDirect):  Removed - not used.\n\t(getImpl, putImpl):  Make static and pass address explicitly,\n\tto make them useful for MappedByteBufferImpl.\n\t(get, put):  Check for underflow.  Modify for new getImpl.\n\t(getImpl):  New native method where target is array.\n\t(get(byte[],int,int)):  Use the above.\n\t(adjustAddress):  New static native method.\n\t(slice, duplicate, asReadOnly):  New implementations.\n\t* java/nio/natDirectByteBufferImpl.cc (getImpl, putImpl, shiftDown,\n\tadjustAddress):  New or updated native methods.\n\nFrom-SVN: r77919", "tree": {"sha": "b053bce2ad70d769c220be5941b4cd3ae9fdccaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b053bce2ad70d769c220be5941b4cd3ae9fdccaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35d0b14df6995e79e84201c45d49ef986f9e0b77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d0b14df6995e79e84201c45d49ef986f9e0b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35d0b14df6995e79e84201c45d49ef986f9e0b77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d0b14df6995e79e84201c45d49ef986f9e0b77/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5693912a7d109bb281efb8bf2ce107a6b516fc1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5693912a7d109bb281efb8bf2ce107a6b516fc1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5693912a7d109bb281efb8bf2ce107a6b516fc1f"}], "stats": {"total": 289, "additions": 193, "deletions": 96}, "files": [{"sha": "9e7199860a1f1f20139391c4f3dbde2057d1f49c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -19,6 +19,40 @@\n \t* java/nio/IntViewBufferImpl.java:  Likewise.\n \t* java/nio/LongViewBufferImpl.java:  Likewise.\n \t* java/nio/ShortViewBufferImpl.java:  Likewise.\n+\t\n+\t* java/nio/ByteBuffer.java (endian):  Make non-private so other\n+\tjava.nio classes can inherit it.\n+\t(<init>):  Don't bother clearing array_offset.\n+\t* java/nio/ByteBuffer.java (allocate):  Re-implement using wrap.\n+\t* java/nio/ByteBuffer.java (get(byte[],int,int)):  Check underflow.\n+\tRemove redundant test.\n+\n+\t* java/nio/ByteBufferImpl.java (asCharBuffer, asShortBuffer,\n+\tasIntBuffer, asLongBuffer, asFloatBuffer, asDoubleBuffer):\n+\tUse new XxxViewBufferImpl constructors.\n+\t* java/nio/MappedByteBufferImpl.java:  Likewise.\n+\t* java/nio/DirectByteBufferImpl.java:  Likewise.\n+\n+\t* java/nio/ByteBufferImpl.java:  Remove one constructor.\n+\tInline super in remaining constructor.\n+\t* java/nio/ByteBuffer.java:  Remove unused constructor.\n+\n+\t* java/nio/ByteBufferImpl.java (shiftDown):  New optimized method.\n+\n+\t* java/nio/ByteBufferImpl.java (get, put):  Add array_offset.\n+\t* java/nio/DirectByteBufferImpl.java (owner):  New field.\n+\t(offset):  Remove unused field.\n+\t(<init>):  Modify one and add another constructor.  Change callers.\n+\t(allocateDirect):  Removed - not used.\n+\t(getImpl, putImpl):  Make static and pass address explicitly,\n+\tto make them useful for MappedByteBufferImpl.\n+\t(get, put):  Check for underflow.  Modify for new getImpl.\n+\t(getImpl):  New native method where target is array.\n+\t(get(byte[],int,int)):  Use the above.\n+\t(adjustAddress):  New static native method.\n+\t(slice, duplicate, asReadOnly):  New implementations.\n+\t* java/nio/natDirectByteBufferImpl.cc (getImpl, putImpl, shiftDown,\n+\tadjustAddress):  New or updated native methods.\n \n 2004-02-15  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n "}, {"sha": "276b2dbcb81fdabf54c8ad816b2f1511f5916c4b", "filename": "libjava/java/nio/ByteBuffer.java", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBuffer.java?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -44,24 +44,16 @@\n public abstract class ByteBuffer extends Buffer\n   implements Comparable\n {\n-  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  ByteOrder endian = ByteOrder.BIG_ENDIAN;\n \n   int array_offset;\n   byte[] backing_buffer;\n \n   ByteBuffer (int capacity, int limit, int position, int mark)\n   {\n     super (capacity, limit, position, mark);\n-    array_offset = 0;\n   }\n \n-  ByteBuffer (byte[] buffer, int offset, int capacity, int limit, int position, int mark)\n-  {\n-    super (capacity, limit, position, mark);\n-    this.backing_buffer = buffer;\n-    this.array_offset = offset;\n-  }\n-  \n   /**\n    * Allocates a new direct byte buffer.\n    */ \n@@ -75,7 +67,7 @@ public static ByteBuffer allocateDirect (int capacity)\n    */\n   public static ByteBuffer allocate (int capacity)\n   {\n-    return new ByteBufferImpl (capacity);\n+    return wrap(new byte[capacity], 0, capacity);\n   }\n \n   /**\n@@ -87,6 +79,14 @@ public static ByteBuffer allocate (int capacity)\n    */\n   final public static ByteBuffer wrap (byte[] array, int offset, int length)\n   {\n+    // FIXME: In GCJ and other implementations where arrays may not\n+    // move we might consider, at least when offset==0:\n+    // return new DirectByteBufferImpl(array,\n+    //                                 address_of_data(array) + offset,\n+    //                                 length, length, 0, false);\n+    // This may be more efficient, mainly because we can then use the\n+    // same logic for all ByteBuffers.\n+\n     return new ByteBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n@@ -116,11 +116,10 @@ final public static ByteBuffer wrap (byte[] array)\n    */\n   public ByteBuffer get (byte[] dst, int offset, int length)\n   {\n-    if ((offset < 0)\n-        || (offset > dst.length)\n-        || (length < 0)\n-        || (length > (dst.length - offset)))\n+    if (offset < 0 || length < 0 || offset + length > dst.length)\n       throw new IndexOutOfBoundsException ();\n+    if (length > remaining())\n+      throw new BufferUnderflowException();\n \n     for (int i = offset; i < offset + length; i++)\n       {"}, {"sha": "5d3c3d31a86ba29ddcffc97611f7f889a88c337d", "filename": "libjava/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferImpl.java?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -45,45 +45,42 @@ final class ByteBufferImpl extends ByteBuffer\n {\n   private boolean readOnly;\n \n-  ByteBufferImpl (int capacity)\n-  {\n-    this (new byte [capacity], 0, capacity, capacity, 0, -1, false);\n-  }\n-  \n   ByteBufferImpl (byte[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (buffer, offset, capacity, limit, position, mark);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n     this.readOnly = readOnly;\n   }\n   \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new CharViewBufferImpl (this, remaining() >> 1);\n   }\n \n   public ShortBuffer asShortBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new ShortViewBufferImpl (this, remaining() >> 1);\n   }\n \n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new IntViewBufferImpl (this, remaining() >> 2);\n   }\n \n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new LongViewBufferImpl (this, remaining() >> 3);\n   }\n \n   public FloatBuffer asFloatBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new FloatViewBufferImpl (this, remaining() >> 2);\n   }\n \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new DoubleViewBufferImpl (this, remaining() >> 3);\n   }\n \n   public boolean isReadOnly ()\n@@ -106,6 +103,13 @@ public ByteBuffer asReadOnlyBuffer ()\n     return new ByteBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n   \n+  void shiftDown (int dst_offset, int src_offset, int count)\n+  {\n+    System.arraycopy(backing_buffer, array_offset + src_offset,\n+\t\t     backing_buffer, array_offset + dst_offset,\n+\t\t     count);\n+  }\n+\n   public ByteBuffer compact ()\n   {\n     int pos = position();\n@@ -129,7 +133,7 @@ public boolean isDirect ()\n    */\n   final public byte get ()\n   {\n-    byte result = backing_buffer [position ()];\n+    byte result = backing_buffer [position () + array_offset];\n     position (position () + 1);\n     return result;\n   }\n@@ -144,9 +148,10 @@ final public ByteBuffer put (byte value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-\t  \t    \n-    backing_buffer [position ()] = value;\n-    position (position () + 1);\n+\n+    int pos = position();\n+    backing_buffer [pos + array_offset] = value;\n+    position (pos + 1);\n     return this;\n   }\n   \n@@ -159,7 +164,7 @@ final public ByteBuffer put (byte value)\n    */\n   final public byte get (int index)\n   {\n-    return backing_buffer [index];\n+    return backing_buffer [index + array_offset];\n   }\n   \n   /**\n@@ -175,7 +180,7 @@ final public ByteBuffer put (int index, byte value)\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n     \t    \n-    backing_buffer [index] = value;\n+    backing_buffer [index + array_offset] = value;\n     return this;\n   }\n   "}, {"sha": "ef88d34a701fb4bf596eb142c7f4f7c45aaf5bf6", "filename": "libjava/java/nio/DirectByteBufferImpl.java", "status": "modified", "additions": 89, "deletions": 49, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -52,23 +52,25 @@ class DirectByteBufferImpl extends ByteBuffer\n       }\n   }\n   \n+  /** Used by MappedByteBufferImpl to prevent premature GC. */\n+  protected Object owner;\n+\n   RawData address;\n-  private int offset;\n   private boolean readOnly;\n \n   public DirectByteBufferImpl (RawData address, long len)\n   {\n-    this (address, 0, (int) len, (int) len, 0, -1, false);\n+    this (null, address, (int) len, (int) len, 0, false);\n   }\n   \n-  public DirectByteBufferImpl (RawData address, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+  public DirectByteBufferImpl (Object owner, RawData address,\n+\t\t\t       int capacity, int limit,\n+\t\t\t       int position, boolean readOnly)\n   {\n-    super (capacity, limit, position, mark);\n+    super (capacity, limit, position, -1);\n     this.address = address;\n-    this.offset = offset;\n     this.readOnly = readOnly;\n+    this.owner = owner;\n   }\n \n   private static native RawData allocateImpl (int capacity);\n@@ -79,41 +81,58 @@ protected void finalize () throws Throwable\n     freeImpl (address);\n   }\n   \n-  public static ByteBuffer allocateDirect (int capacity)\n-  {\n-    RawData address = allocateImpl (capacity);\n-\n-    if (address == null)\n-      throw new InternalError (\"Not enough memory to create direct buffer\");\n-    \n-    return new DirectByteBufferImpl (address, 0, capacity, capacity, 0, -1, false);\n-  }\n-  \n-  private native byte getImpl (int index);\n-  private native void putImpl (int index, byte value);\n+  static native byte getImpl (RawData address, int index);\n+  static native void putImpl (RawData address, int index, byte value);\n \n   public byte get ()\n   {\n-    byte result = getImpl (position () + offset);\n-    position (position () + 1);\n+    int pos = position();\n+    if (pos >= limit())\n+      throw new BufferUnderflowException();\n+    byte result = getImpl (address, pos);\n+    position (pos + 1);\n     return result;\n   }\n \n   public byte get (int index)\n   {\n-    return getImpl (index);\n+    if (index >= limit())\n+      throw new BufferUnderflowException();\n+    return getImpl (address, index);\n+  }\n+\n+  static native void getImpl (RawData address, int index,\n+\t\t\t      byte[] dst, int offset, int length);\n+\n+  public ByteBuffer get (byte[] dst, int offset, int length)\n+  {\n+    if (offset < 0 || length < 0 || offset + length > dst.length)\n+      throw new IndexOutOfBoundsException ();\n+    if (length > remaining())\n+      throw new BufferUnderflowException();\n+\n+    int index = position();\n+    getImpl(address, index, dst, offset, length);\n+    position(index+length);\n+\n+    return this;\n   }\n \n   public ByteBuffer put (byte value)\n   {\n-    putImpl (position (), value);\n-    position (position () + 1);\n+    int pos = position();\n+    if (pos >= limit())\n+      throw new BufferUnderflowException();\n+    putImpl (address, pos, value);\n+    position (pos + 1);\n     return this;\n   }\n   \n   public ByteBuffer put (int index, byte value)\n   {\n-    putImpl (index, value);\n+    if (index >= limit())\n+      throw new BufferUnderflowException();\n+    putImpl (address, index, value);\n     return this;\n   }\n   \n@@ -132,21 +151,42 @@ public ByteBuffer compact ()\n     return this;\n   }\n \n-  public ByteBuffer duplicate ()\n+  public static native RawData adjustAddress(RawData address, int offset);\n+\n+  public ByteBuffer slice ()\n   {\n-    return new DirectByteBufferImpl (\n-      address, offset, capacity (), limit (), position (), -1, isReadOnly ());\n+    int rem = remaining();\n+    return new DirectByteBufferImpl (owner,\n+\t\t\t\t     adjustAddress(address, position()),\n+\t\t\t\t     rem, rem, 0, isReadOnly ());\n   }\n \n-  public ByteBuffer slice ()\n+  private ByteBuffer duplicate (boolean readOnly)\n+  {\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    DirectByteBufferImpl result\n+      = new DirectByteBufferImpl (owner, address, capacity (), limit (),\n+\t\t\t\t  pos, readOnly);\n+    if (mark != pos)\n+      {\n+\tresult.position(mark);\n+\tresult.mark();\n+\tresult.position(pos);\n+      }\n+    return result;\n+  }\n+\n+  public ByteBuffer duplicate ()\n   {\n-    return new DirectByteBufferImpl (address, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return duplicate(isReadOnly());\n   }\n \n   public ByteBuffer asReadOnlyBuffer ()\n   {\n-    return new DirectByteBufferImpl (\n-      address, offset, capacity (), limit (), position (), -1, true);\n+    return duplicate(true);\n   }\n \n   public boolean isReadOnly ()\n@@ -161,34 +201,34 @@ public boolean isDirect ()\n \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n-  }\n-  \n-  public DoubleBuffer asDoubleBuffer ()\n-  {\n-    return new DoubleViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n+    return new CharViewBufferImpl (this, remaining() >> 1);\n   }\n-  \n-  public FloatBuffer asFloatBuffer ()\n+\n+  public ShortBuffer asShortBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n+    return new ShortViewBufferImpl (this, remaining() >> 1);\n   }\n-  \n+\n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n+    return new IntViewBufferImpl (this, remaining() >> 2);\n   }\n-  \n+\n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n+    return new LongViewBufferImpl (this, remaining() >> 3);\n   }\n-  \n-  public ShortBuffer asShortBuffer ()\n+\n+  public FloatBuffer asFloatBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n+    return new FloatViewBufferImpl (this, remaining() >> 2);\n   }\n-  \n+\n+  public DoubleBuffer asDoubleBuffer ()\n+  {\n+    return new DoubleViewBufferImpl (this, remaining() >> 3);\n+  }\n+\n   final public char getChar ()\n   {\n     return ByteBufferHelper.getChar(this, order());"}, {"sha": "5b02ef3c9112b91738644b48e47da48fc052f823", "filename": "libjava/java/nio/MappedByteBufferImpl.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -144,32 +144,32 @@ public ByteBuffer asReadOnlyBuffer ()\n \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new CharViewBufferImpl (this, remaining() >> 1);\n   }\n \n   public ShortBuffer asShortBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new ShortViewBufferImpl (this, remaining() >> 1);\n   }\n \n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new IntViewBufferImpl (this, remaining() >> 2);\n   }\n-  \n+\n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new LongViewBufferImpl (this, remaining() >> 3);\n   }\n \n   public FloatBuffer asFloatBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new FloatViewBufferImpl (this, remaining() >> 2);\n   }\n \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n+    return new DoubleViewBufferImpl (this, remaining() >> 3);\n   }\n \n   final public char getChar ()"}, {"sha": "94225c3988521e3d3d1b83343b3433035e0a6854", "filename": "libjava/java/nio/natDirectByteBufferImpl.cc", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d0b14df6995e79e84201c45d49ef986f9e0b77/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc?ref=35d0b14df6995e79e84201c45d49ef986f9e0b77", "patch": "@@ -1,6 +1,6 @@\n // natDirectByteBufferImpl.cc\n \n-/* Copyright (C) 2003  Free Software Foundation\n+/* Copyright (C) 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -18,7 +18,10 @@ details.  */\n #include <gnu/gcj/RawData.h>\n #include <java/nio/DirectByteBufferImpl.h>\n \n-gnu::gcj::RawData*\n+using gnu::gcj::RawData;\n+using java::nio::DirectByteBufferImpl;\n+\n+RawData*\n java::nio::DirectByteBufferImpl::allocateImpl (jint capacity)\n {\n   return reinterpret_cast<gnu::gcj::RawData*> (::malloc (capacity));\n@@ -31,24 +34,40 @@ java::nio::DirectByteBufferImpl::freeImpl (gnu::gcj::RawData* address)\n }\n \n jbyte\n-java::nio::DirectByteBufferImpl::getImpl (jint index)\n+DirectByteBufferImpl::getImpl (RawData* address, jint index)\n {\n-  jbyte* pointer = reinterpret_cast<jbyte*> (address) + offset + index;\n+  jbyte* pointer = reinterpret_cast<jbyte*> (address) + index;\n   return *pointer;\n }\n \n void\n-java::nio::DirectByteBufferImpl::putImpl (jint index, jbyte value)\n+DirectByteBufferImpl::getImpl (RawData* address, jint index,\n+\t\t\t       jbyteArray dst, jint offset, jint length)\n+{\n+  jbyte* src = reinterpret_cast<jbyte*> (address) + index;\n+  memcpy (elements (dst) + offset, src, length);\n+}\n+\n+void\n+java::nio::DirectByteBufferImpl::putImpl (gnu::gcj::RawData* address,\n+\t\t\t\t\t  jint index, jbyte value)\n {\n-  jbyte* pointer = reinterpret_cast<jbyte*> (address) + offset + index;\n+  jbyte* pointer = reinterpret_cast<jbyte*> (address) + index;\n   *pointer = value;\n }\n \n+RawData*\n+java::nio::DirectByteBufferImpl::adjustAddress (RawData* address, jint offset)\n+{\n+  jbyte* start = reinterpret_cast<jbyte*> (address) + offset;\n+  return reinterpret_cast<RawData*>(start);\n+}\n+\n void\n java::nio::DirectByteBufferImpl::shiftDown\n (jint dst_offset, jint src_offset, jint count)\n {\n-  jbyte* dst = reinterpret_cast<jbyte*> (address) + offset + dst_offset;\n-  jbyte* src = reinterpret_cast<jbyte*> (address) + offset + src_offset;\n+  jbyte* dst = reinterpret_cast<jbyte*> (address) + array_offset + dst_offset;\n+  jbyte* src = reinterpret_cast<jbyte*> (address) + array_offset + src_offset;\n   ::memmove(dst, src, count);\n }"}]}