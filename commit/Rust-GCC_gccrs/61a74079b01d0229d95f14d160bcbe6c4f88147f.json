{"sha": "61a74079b01d0229d95f14d160bcbe6c4f88147f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhNzQwNzliMDFkMDIyOWQ5NWYxNGQxNjBiY2JlNmM0Zjg4MTQ3Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-04T14:14:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-04T14:14:28Z"}, "message": "Makefile.in (ipa-devirt.o): Add dependency on diagnostic.h\n\n\t* Makefile.in (ipa-devirt.o): Add dependency on diagnostic.h\n\t* ipa-devirt.c: Include diganostic.h\n\t(odr_type_d): Add types and types_set.\n\t(hash_type_name): Work for types with vtables during LTO.\n\t(odr_hasher::remove): Fix comment; destroy types_set.\n\t(add_type_duplicate): New function,\n\t(get_odr_type): Use it.\n\t(dump_type_inheritance_graph): Dump type duplicates.\n\t* ipa.c (symtab_remove_unreachable_nodes): Build type inheritance\n\tgraph.\n\t* tree.c (types_same_for_odr): Give exact answers on types with\n\tvirtual tables.\n\nFrom-SVN: r202258", "tree": {"sha": "37a2f18b9ddc64a6fda6a6cc4c075c72734d0ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37a2f18b9ddc64a6fda6a6cc4c075c72734d0ce7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a74079b01d0229d95f14d160bcbe6c4f88147f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a74079b01d0229d95f14d160bcbe6c4f88147f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a74079b01d0229d95f14d160bcbe6c4f88147f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a74079b01d0229d95f14d160bcbe6c4f88147f/comments", "author": null, "committer": null, "parents": [{"sha": "24ba81955d92ff8c29f814867b887446f5c0be05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ba81955d92ff8c29f814867b887446f5c0be05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ba81955d92ff8c29f814867b887446f5c0be05"}], "stats": {"total": 272, "additions": 258, "deletions": 14}, "files": [{"sha": "2d2c7319a8dd3ce3d4e09eedc78d31a877996fe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -1,3 +1,18 @@\n+2013-09-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (ipa-devirt.o): Add dependency on diagnostic.h\n+\t* ipa-devirt.c: Include diganostic.h\n+\t(odr_type_d): Add types and types_set.\n+\t(hash_type_name): Work for types with vtables during LTO.\n+\t(odr_hasher::remove): Fix comment; destroy types_set.\n+\t(add_type_duplicate): New function,\n+\t(get_odr_type): Use it.\n+\t(dump_type_inheritance_graph): Dump type duplicates.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Build type inheritance\n+\tgraph.\n+\t* tree.c (types_same_for_odr): Give exact answers on types with\n+\tvirtual tables.\n+\n 2013-09-04  Dodji Seketeli  <dodji@redhat.com>\n \n \t* tree.h (DECL_BUILT_IN, DECL_IS_BUILTIN): Add more comments"}, {"sha": "87a09ba4d000ef455117706e037d4b7fac5bb695", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -2963,7 +2963,8 @@ ipa-profile.o : ipa-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRA\n    ipa-inline.h\n ipa-devirt.o : ipa-devirt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n-   $(IPA_UTILS_H) $(HASH_TABLE_H) ipa-inline.h ipa-utils.h $(TREE_PRETTY_PRINT_H)\n+   $(IPA_UTILS_H) $(HASH_TABLE_H) ipa-inline.h ipa-utils.h $(TREE_PRETTY_PRINT_H) \\\n+   $(DIAGNOSTIC_H)\n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\"}, {"sha": "743f30ca5ee8836173e9d24f5e447f0ecc9d3dac", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 180, "deletions": 5, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -119,6 +119,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"gimple.h\"\n #include \"ipa-inline.h\"\n+#include \"diagnostic.h\"\n \n /* Pointer set of all call targets appearing in the cache.  */\n static pointer_set_t *cached_polymorphic_call_targets;\n@@ -136,6 +137,11 @@ struct GTY(()) odr_type_d\n   /* All derrived types with virtual methods seen in unit.  */\n   vec<odr_type> GTY((skip)) derived_types;\n \n+  /* All equivalent types, if more than one.  */\n+  vec<tree, va_gc> *types;\n+  /* Set of all equivalent types, if NON-NULL.  */\n+  pointer_set_t * GTY((skip)) types_set;\n+\n   /* Unique ID indexing the type in odr_types array.  */\n   int id;\n   /* Is it in anonymous namespace? */\n@@ -185,6 +191,26 @@ hash_type_name (tree t)\n   if (type_in_anonymous_namespace_p (t))\n     return htab_hash_pointer (t);\n \n+  /* For polymorphic types, we can simply hash the virtual table.  */\n+  if (TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+    {\n+      tree v = BINFO_VTABLE (TYPE_BINFO (t));\n+      hashval_t hash = 0;\n+\n+      if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n+\t{\n+\t  hash = TREE_INT_CST_LOW (TREE_OPERAND (v, 1));\n+\t  v = TREE_OPERAND (TREE_OPERAND (v, 0), 0);\n+\t}\n+\n+      v = DECL_ASSEMBLER_NAME (v);\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (!strchr (IDENTIFIER_POINTER (v), '.'));\n+#endif\n+      hash = iterative_hash_hashval_t (hash, htab_hash_pointer (v));\n+      return hash;\n+    }\n+\n   /* Rest is not implemented yet.  */\n   gcc_unreachable ();\n }\n@@ -220,6 +246,8 @@ odr_hasher::remove (value_type *v)\n {\n   v->bases.release ();\n   v->derived_types.release ();\n+  if (v->types_set)\n+    pointer_set_destroy (v->types_set);\n   ggc_free (v);\n }\n \n@@ -235,6 +263,132 @@ static odr_hash_type odr_hash;\n static GTY(()) vec <odr_type, va_gc> *odr_types_ptr;\n #define odr_types (*odr_types_ptr)\n \n+/* TYPE is equivalent to VAL by ODR, but its tree representation differs\n+   from VAL->type.  This may happen in LTO where tree merging did not merge\n+   all variants of the same type.  It may or may not mean the ODR violation.\n+   Add it to the list of duplicates and warn on some violations.  */\n+\n+static void\n+add_type_duplicate (odr_type val, tree type)\n+{\n+  if (!val->types_set)\n+    val->types_set = pointer_set_create ();\n+\n+  /* See if this duplicate is new.  */\n+  if (!pointer_set_insert (val->types_set, type))\n+    {\n+      bool merge = true;\n+      bool base_mismatch = false;\n+      gcc_assert (in_lto_p);\n+      vec_safe_push (val->types, type);\n+      unsigned int i,j;\n+\n+      /* First we compare memory layout.  */\n+      if (!types_compatible_p (val->type, type))\n+\t{\n+\t  merge = false;\n+\t  if (BINFO_VTABLE (TYPE_BINFO (val->type))\n+\t      && warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n+\t\t\t     \"type %qD violates one definition rule  \",\n+\t\t\t     type))\n+\t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n+\t\t    \"a type with the same name but different layout is \"\n+\t\t    \"defined in another translation unit\");\n+\t    debug_tree (BINFO_VTABLE (TYPE_BINFO (type)));\n+\t    debug_tree (BINFO_VTABLE (TYPE_BINFO (val->type)));\n+\t  if (cgraph_dump_file)\n+\t    {\n+\t      fprintf (cgraph_dump_file, \"ODR violation or merging or ODR type bug?\\n\");\n+\t    \n+\t      print_node (cgraph_dump_file, \"\", val->type, 0);\n+\t      putc ('\\n',cgraph_dump_file);\n+\t      print_node (cgraph_dump_file, \"\", type, 0);\n+\t      putc ('\\n',cgraph_dump_file);\n+\t    }\n+\t}\n+\n+      /* Next sanity check that bases are the same.  If not, we will end\n+\t up producing wrong answers.  */\n+      for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO (TYPE_BINFO (type), i)))\n+\t  {\n+\t    odr_type base = get_odr_type\n+\t\t\t       (BINFO_TYPE\n+\t\t\t\t  (BINFO_BASE_BINFO (TYPE_BINFO (type),\n+\t\t\t\t\t\t     i)),\n+\t\t\t\ttrue);\n+\t    if (val->bases.length () <= j || val->bases[j] != base)\n+\t      base_mismatch = true;\n+\t    j++;\n+\t  }\n+      if (base_mismatch)\n+\t{\n+\t  merge = false;\n+\n+\t  if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n+\t\t\t  \"type %qD violates one definition rule  \",\n+\t\t\t  type))\n+\t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n+\t\t    \"a type with the same name but different bases is \"\n+\t\t    \"defined in another translation unit\");\n+\t  if (cgraph_dump_file)\n+\t    {\n+\t      fprintf (cgraph_dump_file, \"ODR bse violation or merging bug?\\n\");\n+\t    \n+\t      print_node (cgraph_dump_file, \"\", val->type, 0);\n+\t      putc ('\\n',cgraph_dump_file);\n+\t      print_node (cgraph_dump_file, \"\", type, 0);\n+\t      putc ('\\n',cgraph_dump_file);\n+\t    }\n+\t}\n+\n+      /* Regularize things a little.  During LTO same types may come with\n+\t different BINFOs.  Either because their virtual table was\n+\t not merged by tree merging and only later at decl merging or\n+\t because one type comes with external vtable, while other\n+\t with internal.  We want to merge equivalent binfos to conserve\n+\t memory and streaming overhead.\n+\n+\t The external vtables are more harmful: they contain references\n+\t to external declarations of methods that may be defined in the\n+\t merged LTO unit.  For this reason we absolutely need to remove\n+\t them and replace by internal variants. Not doing so will lead\n+         to incomplete answers from possible_polymorphic_call_targets.  */\n+      if (!flag_ltrans && merge)\n+\t{\n+\t  tree master_binfo = TYPE_BINFO (val->type);\n+\t  tree v1 = BINFO_VTABLE (master_binfo);\n+\t  tree v2 = BINFO_VTABLE (TYPE_BINFO (type));\n+\n+\t  if (TREE_CODE (v1) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      gcc_assert (TREE_CODE (v2) == POINTER_PLUS_EXPR\n+\t\t\t  && operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t\t\t      TREE_OPERAND (v2, 1), 0));\n+\t      v1 = TREE_OPERAND (TREE_OPERAND (v1, 0), 0);\n+\t      v2 = TREE_OPERAND (TREE_OPERAND (v2, 0), 0);\n+\t    }\n+\t  gcc_assert (DECL_ASSEMBLER_NAME (v1)\n+\t\t      == DECL_ASSEMBLER_NAME (v2));\n+\n+\t  if (DECL_EXTERNAL (v1) && !DECL_EXTERNAL (v2))\n+\t    {\n+\t      unsigned int i;\n+\n+\t      TYPE_BINFO (val->type) = TYPE_BINFO (type);\n+\t      for (i = 0; i < val->types->length(); i++)\n+\t\t{\n+\t\t  if (TYPE_BINFO ((*val->types)[i])\n+\t\t      == master_binfo)\n+\t\t    TYPE_BINFO ((*val->types)[i]) = TYPE_BINFO (type);\n+\t\t}\n+\t    }\n+\t  else\n+\t    TYPE_BINFO (type) = master_binfo;\n+\t}\n+    }\n+}\n+\n /* Get ODR type hash entry for TYPE.  If INSERT is true, create\n    possibly new entry.  */\n \n@@ -257,11 +411,10 @@ get_odr_type (tree type, bool insert)\n     {\n       val = *slot;\n \n-      /* With LTO we will need to support multiple tree representation of\n-\t the same ODR type.  For now we ignore this.  */\n-      if (val->type == type)\n-\treturn val;\n-      gcc_unreachable ();\n+      /* With LTO we need to support multiple tree representation of\n+\t the same ODR type.  */\n+      if (val->type != type)\n+        add_type_duplicate (val, type);\n     }\n   else\n     {\n@@ -340,6 +493,28 @@ dump_type_inheritance_graph (FILE *f)\n       if (odr_types[i]->bases.length() == 0)\n \tdump_odr_type (f, odr_types[i]);\n     }\n+  for (i = 0; i < odr_types.length(); i++)\n+    {\n+      if (odr_types[i]->types && odr_types[i]->types->length())\n+\t{\n+\t  unsigned int j;\n+\t  fprintf (f, \"Duplicate tree types for odr type %i\\n\", i);\n+\t  print_node (f, \"\", odr_types[i]->type, 0);\n+\t  for (j = 0; j < odr_types[i]->types->length(); j++)\n+\t    {\n+\t      tree t;\n+\t      fprintf (f, \"duplicate #%i\\n\", j);\n+\t      print_node (f, \"\", (*odr_types[i]->types)[j], 0);\n+\t      t = (*odr_types[i]->types)[j];\n+\t      while (TYPE_P (t) && TYPE_CONTEXT (t))\n+\t\t{\n+\t\t  t = TYPE_CONTEXT (t);\n+\t          print_node (f, \"\", t, 0);\n+\t\t}\n+\t      putc ('\\n',f);\n+\t    }\n+\t}\n+    }\n }\n \n /* Given method type T, return type of class it belongs to."}, {"sha": "37b6629b206b6c066196a96b5eadd1e568936c35", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -218,6 +218,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n #endif\n+  if (optimize && flag_devirtualize)\n+    build_type_inheritance_graph ();\n   if (file)\n     fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING"}, {"sha": "f27f2fd9affce2f27c779aab3f3aeedaaf35425c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -124,8 +124,11 @@ output_type_ref (struct output_block *ob, tree node)\n static bool\n tree_is_indexable (tree t)\n {\n+  /* Parameters and return values of functions of variably modified types\n+     must go to global stream, because they may be used in the type\n+     definition.  */\n   if (TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)\n-    return false;\n+    return variably_modified_type_p (TREE_TYPE (DECL_CONTEXT (t)), NULL_TREE);\n   else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t)\n \t   && !TREE_STATIC (t))\n     return false;"}, {"sha": "ddf72d2d14aea6c2b1cc6729dba366bda7efa329", "filename": "gcc/predict.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -232,8 +232,22 @@ bool\n probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n {\n   gcc_checking_assert (fun);\n-  if (profile_info && flag_branch_probabilities)\n-    return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n+  if (profile_status_for_function (fun) == PROFILE_READ)\n+    {\n+      if ((bb->count * 4 + profile_info->runs / 2) / profile_info->runs > 0)\n+\treturn false;\n+      if (!bb->frequency)\n+\treturn true;\n+      if (!ENTRY_BLOCK_PTR->frequency)\n+\treturn false;\n+      if (ENTRY_BLOCK_PTR->count && ENTRY_BLOCK_PTR->count < REG_BR_PROB_BASE)\n+\t{\n+\t  return (RDIV (bb->frequency * ENTRY_BLOCK_PTR->count,\n+\t\t        ENTRY_BLOCK_PTR->frequency)\n+\t\t  < REG_BR_PROB_BASE / 4);\n+\t}\n+      return true;\n+    }\n   if ((!profile_info || !flag_branch_probabilities)\n       && (cgraph_get_node (fun->decl)->frequency\n \t  == NODE_FREQUENCY_UNLIKELY_EXECUTED))"}, {"sha": "7e44b402c96b6b276af4512a2f0ce6c9e202db05", "filename": "gcc/tree.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a74079b01d0229d95f14d160bcbe6c4f88147f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=61a74079b01d0229d95f14d160bcbe6c4f88147f", "patch": "@@ -11853,11 +11853,6 @@ types_same_for_odr (tree type1, tree type2)\n   if (type1 == type2)\n     return true;\n \n-  /* If types are not structuraly same, do not bother to contnue.\n-     Match in the remainder of code would mean ODR violation.  */\n-  if (!types_compatible_p (type1, type2))\n-    return false;\n-\n #ifndef ENABLE_CHECKING\n   if (!in_lto_p)\n     return false;\n@@ -11868,7 +11863,46 @@ types_same_for_odr (tree type1, tree type2)\n   if (type_in_anonymous_namespace_p (type1)\n       || type_in_anonymous_namespace_p (type2))\n     return false;\n+  /* When assembler name of virtual table is available, it is\n+     easy to compare types for equivalence.  */\n+  if (TYPE_BINFO (type1) && TYPE_BINFO (type2)\n+      && BINFO_VTABLE (TYPE_BINFO (type1))\n+      && BINFO_VTABLE (TYPE_BINFO (type2)))\n+    {\n+      tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n+      tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n \n+      if (TREE_CODE (v1) == POINTER_PLUS_EXPR)\n+\t{\n+\t  if (TREE_CODE (v2) != POINTER_PLUS_EXPR\n+\t      || !operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t     TREE_OPERAND (v2, 1), 0))\n+\t    return false;\n+\t  v1 = TREE_OPERAND (TREE_OPERAND (v1, 0), 0);\n+\t  v2 = TREE_OPERAND (TREE_OPERAND (v2, 0), 0);\n+\t}\n+      v1 = DECL_ASSEMBLER_NAME (v1);\n+      v2 = DECL_ASSEMBLER_NAME (v2);\n+      /* If we ever start adding random .blah suffixes after\n+\t assembler names, we need to compare for match ignoring\n+\t these (and update odr_type_hash, too).  */\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (!strchr (IDENTIFIER_POINTER (v1), '.')\n+\t\t  && !strchr (IDENTIFIER_POINTER (v2), '.'));\n+#endif\n+      return (v1 == v2);\n+    }\n+\n+  /* FIXME: the code comparing type names consider all instantiations of the\n+     same template to have same name.  This is because we have no access\n+     to template parameters.  For types with no virtual method tables\n+     we thus can return false positives.  At the moment we do not need\n+     to compare types in other scenarios than devirtualization.  */\n+\n+  /* If types are not structuraly same, do not bother to contnue.\n+     Match in the remainder of code would mean ODR violation.  */\n+  if (!types_compatible_p (type1, type2))\n+    return false;\n   if (!TYPE_NAME (type1))\n     return false;\n   if (!decls_same_for_odr (TYPE_NAME (type1), TYPE_NAME (type2)))"}]}