{"sha": "e6179f45962b735f577d455f124e4f866e6a6918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxNzlmNDU5NjJiNzM1ZjU3N2Q0NTVmMTI0ZTRmODY2ZTZhNjkxOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-13T13:48:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-13T13:48:15Z"}, "message": "* gthr-solaris.h: Fix formatting.\n\nFrom-SVN: r59076", "tree": {"sha": "74d5ff5bbaf36cb7e392fff40252d420df525af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74d5ff5bbaf36cb7e392fff40252d420df525af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6179f45962b735f577d455f124e4f866e6a6918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6179f45962b735f577d455f124e4f866e6a6918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6179f45962b735f577d455f124e4f866e6a6918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6179f45962b735f577d455f124e4f866e6a6918/comments", "author": null, "committer": null, "parents": [{"sha": "93f93f9f2865f06a0929d5311101c5bc4b6565bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f93f9f2865f06a0929d5311101c5bc4b6565bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f93f9f2865f06a0929d5311101c5bc4b6565bc"}], "stats": {"total": 99, "additions": 51, "deletions": 48}, "files": [{"sha": "671c86e2f9a410b9da26697be1faad7d5dadf573", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6179f45962b735f577d455f124e4f866e6a6918/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6179f45962b735f577d455f124e4f866e6a6918/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6179f45962b735f577d455f124e4f866e6a6918", "patch": "@@ -1,3 +1,7 @@\n+2002-11-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* gthr-solaris.h: Fix formatting.\n+\n 2002-11-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gthr-posix.h: Fix formatting."}, {"sha": "726223dbb7d05de9a2eabb10479d309a933ce7dc", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6179f45962b735f577d455f124e4f866e6a6918/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6179f45962b735f577d455f124e4f866e6a6918/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=e6179f45962b735f577d455f124e4f866e6a6918", "patch": "@@ -39,8 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <errno.h>\n \n typedef thread_key_t __gthread_key_t;\n-typedef struct\n-{\n+typedef struct {\n   mutex_t mutex;\n   int once;\n } __gthread_once_t;\n@@ -110,19 +109,19 @@ static void *thread_local_storage = NULL;\n \n /* Initialize the threads subsystem.  */\n static inline int\n-__gthread_objc_init_thread_system(void)\n+__gthread_objc_init_thread_system (void)\n {\n   /* Initialize the thread storage key */\n   if (__gthread_active_p ()\n-      && thr_keycreate(&_objc_thread_storage, NULL) == 0)\n+      && thr_keycreate (&_objc_thread_storage, NULL) == 0)\n     return 0;\n \n   return -1;\n }\n \n /* Close the threads subsystem.  */\n static inline int\n-__gthread_objc_close_thread_system(void)\n+__gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ())\n     return 0;\n@@ -134,18 +133,18 @@ __gthread_objc_close_thread_system(void)\n \n /* Create a new thread of execution.  */\n static inline objc_thread_t\n-__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n+__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n {\n   objc_thread_t thread_id;\n   thread_t new_thread_id = 0;\n \n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (thr_create(NULL, 0, (void *)func, arg,\n-\t\t THR_DETACHED | THR_NEW_LWP,\n-\t\t &new_thread_id) == 0)\n-    thread_id = *(objc_thread_t *)&new_thread_id;\n+  if (thr_create (NULL, 0, (void *) func, arg,\n+\t\t  THR_DETACHED | THR_NEW_LWP,\n+\t\t  &new_thread_id) == 0)\n+    thread_id = *(objc_thread_t *) &new_thread_id;\n   else\n     thread_id = NULL;\n \n@@ -154,7 +153,7 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n \n /* Set the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_set_priority(int priority)\n+__gthread_objc_thread_set_priority (int priority)\n {\n   int sys_priority = 0;\n \n@@ -176,22 +175,22 @@ __gthread_objc_thread_set_priority(int priority)\n     }\n \n   /* Change priority */\n-  if (thr_setprio(thr_self(), sys_priority) == 0)\n+  if (thr_setprio (thr_self (), sys_priority) == 0)\n     return 0;\n   else\n     return -1;\n }\n \n /* Return the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_get_priority(void)\n+__gthread_objc_thread_get_priority (void)\n {\n   int sys_priority;\n \n   if (!__gthread_active_p ())\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n \n-  if (thr_getprio(thr_self(), &sys_priority) == 0)\n+  if (thr_getprio (thr_self (), &sys_priority) == 0)\n     {\n       if (sys_priority >= 250)\n \treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n@@ -206,41 +205,41 @@ __gthread_objc_thread_get_priority(void)\n \n /* Yield our process time to another thread.  */\n static inline void\n-__gthread_objc_thread_yield(void)\n+__gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    thr_yield();\n+    thr_yield ();\n }\n \n /* Terminate the current thread.  */\n static inline int\n-__gthread_objc_thread_exit(void)\n+__gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    thr_exit(&__objc_thread_exit_status);\n+    thr_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n }\n \n /* Returns an integer value which uniquely describes a thread.  */\n static inline objc_thread_t\n-__gthread_objc_thread_id(void)\n+__gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t)thr_self();\n+    return (objc_thread_t) thr_self ();\n   else\n-    return (objc_thread_t)1;\n+    return (objc_thread_t) 1;\n }\n \n /* Sets the thread's local storage pointer.  */\n static inline int\n-__gthread_objc_thread_set_data(void *value)\n+__gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n     {\n-      if (thr_setspecific(_objc_thread_storage, value) == 0)\n+      if (thr_setspecific (_objc_thread_storage, value) == 0)\n \treturn 0;\n       else\n \treturn -1;\n@@ -254,13 +253,13 @@ __gthread_objc_thread_set_data(void *value)\n \n /* Returns the thread's local storage pointer.  */\n static inline void *\n-__gthread_objc_thread_get_data(void)\n+__gthread_objc_thread_get_data (void)\n {\n   void *value = NULL;\n \n   if (__gthread_active_p ())\n     {\n-      if (thr_getspecific(_objc_thread_storage, &value) == 0)\n+      if (thr_getspecific (_objc_thread_storage, &value) == 0)\n \treturn value;\n       else\n \treturn NULL;\n@@ -273,53 +272,53 @@ __gthread_objc_thread_get_data(void)\n \n /* Allocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n+      && mutex_init ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n     return -1;\n \n   return 0;\n }\n \n /* Deallocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    mutex_destroy((mutex_t *)(&(mutex->backend)));\n+    mutex_destroy ((mutex_t *) (&(mutex->backend)));\n \n   return 0;\n }\n \n /* Grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+__gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n+      && mutex_lock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n }\n \n /* Try to grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n+      && mutex_trylock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n }\n \n /* Unlock the mutex */\n static inline int\n-__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n+      && mutex_unlock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -329,52 +328,52 @@ __gthread_objc_mutex_unlock(objc_mutex_t mutex)\n \n /* Allocate a condition.  */\n static inline int\n-__gthread_objc_condition_allocate(objc_condition_t condition)\n+__gthread_objc_condition_allocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD,\n-\t\t     NULL);\n+    return cond_init ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n+\t\t      NULL);\n   else\n     return 0;\n }\n \n /* Deallocate a condition.  */\n static inline int\n-__gthread_objc_condition_deallocate(objc_condition_t condition)\n+__gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_destroy((cond_t *)(&(condition->backend)));\n+    return cond_destroy ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n \n /* Wait on the condition */\n static inline int\n-__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return cond_wait((cond_t *)(&(condition->backend)),\n-\t\t     (mutex_t *)(&(mutex->backend)));\n+    return cond_wait ((cond_t *) (&(condition->backend)),\n+\t\t      (mutex_t *) (&(mutex->backend)));\n   else\n     return 0;\n }\n \n /* Wake up all threads waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_broadcast(objc_condition_t condition)\n+__gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_broadcast((cond_t *)(&(condition->backend)));\n+    return cond_broadcast ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n \n /* Wake up one thread waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_signal(objc_condition_t condition)\n+__gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_signal((cond_t *)(&(condition->backend)));\n+    return cond_signal ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -398,7 +397,7 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n       if (once->once == 0)\n \t{\n \t  (*func) ();\n-\t  once->once ++;\n+\t  once->once++;\n \t}\n       mutex_unlock (&once->mutex);\n     }"}]}