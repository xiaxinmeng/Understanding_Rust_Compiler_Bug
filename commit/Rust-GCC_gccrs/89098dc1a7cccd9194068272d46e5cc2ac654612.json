{"sha": "89098dc1a7cccd9194068272d46e5cc2ac654612", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwOThkYzFhN2NjY2Q5MTk0MDY4MjcyZDQ2ZTVjYzJhYzY1NDYxMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-17T18:26:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-17T18:26:42Z"}, "message": "regmove.c (optimize_reg_copy_1): Undo Aug 18 change.\n\n        * regmove.c (optimize_reg_copy_1): Undo Aug 18 change.  Update\n        REG_N_CALLS_CROSSED and REG_LIVE_LENGH if and only if we change\n        where a register is live.\n\nFrom-SVN: r24718", "tree": {"sha": "bbf24369179c5d4521bdd3c753d4bba4a116fe2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbf24369179c5d4521bdd3c753d4bba4a116fe2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89098dc1a7cccd9194068272d46e5cc2ac654612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89098dc1a7cccd9194068272d46e5cc2ac654612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89098dc1a7cccd9194068272d46e5cc2ac654612", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89098dc1a7cccd9194068272d46e5cc2ac654612/comments", "author": null, "committer": null, "parents": [{"sha": "20f7cbac8f4a12c71fca2b06fa94b565a8811cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f7cbac8f4a12c71fca2b06fa94b565a8811cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f7cbac8f4a12c71fca2b06fa94b565a8811cdd"}], "stats": {"total": 87, "additions": 38, "deletions": 49}, "files": [{"sha": "b299bcdb1d96c46177bf1484a536d6a68919eafb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89098dc1a7cccd9194068272d46e5cc2ac654612/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89098dc1a7cccd9194068272d46e5cc2ac654612/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89098dc1a7cccd9194068272d46e5cc2ac654612", "patch": "@@ -1,3 +1,14 @@\n+Sun Jan 17 19:23:20 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+        * regmove.c (optimize_reg_copy_1): Undo Aug 18 change.  Update\n+        REG_N_CALLS_CROSSED and REG_LIVE_LENGH if and only if we change\n+        where a register is live.\n+\n+Sun Jan 17 03:20:47 1999  H.J. Lu  (hjl@gnu.org)\n+\n+\t* reg-stack.c (subst_stack_regs_pat): Abort if the destination\n+\tof a FP conditional move is not on the FP register stack.\n+\n Sun Jan 17 01:15:04 PST 1999 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "9697fa23dc80274ffcf6ce6a13398ec36620ed1a", "filename": "gcc/regmove.c", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89098dc1a7cccd9194068272d46e5cc2ac654612/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89098dc1a7cccd9194068272d46e5cc2ac654612/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=89098dc1a7cccd9194068272d46e5cc2ac654612", "patch": "@@ -253,10 +253,10 @@ optimize_reg_copy_1 (insn, dest, src)\n \t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n \t{\n \t  int failed = 0;\n-\t  int length = 0;\n \t  int d_length = 0;\n-\t  int n_calls = 0;\n+\t  int s_length = 0;\n \t  int d_n_calls = 0;\n+\t  int s_n_calls = 0;\n \n \t  /* We can do the optimization.  Scan forward from INSN again,\n \t     replacing regs as we go.  Set FAILED if a replacement can't\n@@ -290,42 +290,14 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t\t insn in the REG_N_REFS updates below.  If this is not\n \t\t\t correct, no great harm is done.\n \n-\n-\t\t\t We do not undo this substitution if something later\n-\t\t\t fails.  Therefore, we must update the other REG_N_*\n-\t\t\t counters now to keep them accurate.  */\n+\t\t\t Since we do not know if we will change the lifetime of\n+\t\t\t SREGNO or DREGNO, we must not update REG_LIVE_LENGTH\n+\t\t\t or REG_N_CALLS_CROSSED at this time.   */\n \t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\t{\n-\t\t\t  REG_N_REFS (sregno) -= loop_depth;\n-\n-\t\t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n-\t\t\t    {\n-\t\t\t      REG_LIVE_LENGTH (sregno) -= length;\n-\t\t\t      /* REG_LIVE_LENGTH is only an approximation after\n-\t\t\t\t combine if sched is not run, so make sure that\n-\t\t\t\t we still have a reasonable value.  */\n-\t\t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n-\t\t\t\tREG_LIVE_LENGTH (sregno) = 2;\n-\t\t\t    }\n-\n-\t\t\t  REG_N_CALLS_CROSSED (sregno) -= n_calls;\n-\t\t\t}\n+\t\t\tREG_N_REFS (sregno) -= loop_depth;\n \n \t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\t{\n-\t\t\t  REG_N_REFS (dregno) += loop_depth;\n-\n-\t\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n-\t\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n-\n-\t\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n-\t\t\t}\n-\n-\t\t      /* We've done a substitution, clear the counters.  */\n-\t\t      length = 0;\n-\t\t      d_length = 0;\n-\t\t      n_calls = 0;\n-\t\t      d_n_calls = 0;\n+\t\t\tREG_N_REFS (dregno) += loop_depth;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -334,17 +306,20 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t    }\n \t\t}\n \n-\t      /* Count the insns and CALL_INSNs passed.  If we passed the\n-\t\t death note of DEST, show increased live length.  */\n-\t      length++;\n+\t      /* For SREGNO, count the total number of insns scanned.\n+\t\t For DREGNO, count the total number of insns scanned after\n+\t\t passing the death note for DREGNO.  */\n+\t      s_length++;\n \t      if (dest_death)\n \t\td_length++;\n \n \t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n \t\t as a call that has been crossed.  Otherwise, count it.  */\n \t      if (q != p && GET_CODE (q) == CALL_INSN)\n \t\t{\n-\t\t  n_calls++;\n+\t\t  /* Similarly, total calls for SREGNO, total calls beyond\n+\t\t     the death note for DREGNO.  */\n+\t\t  s_n_calls++;\n \t\t  if (dest_death)\n \t\t    d_n_calls++;\n \t\t}\n@@ -364,27 +339,21 @@ optimize_reg_copy_1 (insn, dest, src)\n \n \t  if (! failed)\n \t    {\n+\t      /* These counters need to be updated if and only if we are\n+\t\t going to move the REG_DEAD note.  */\n \t      if (sregno >= FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n \t\t    {\n-\t\t      REG_LIVE_LENGTH (sregno) -= length;\n+\t\t      REG_LIVE_LENGTH (sregno) -= s_length;\n \t\t      /* REG_LIVE_LENGTH is only an approximation after\n \t\t\t combine if sched is not run, so make sure that we\n \t\t\t still have a reasonable value.  */\n \t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n \t\t\tREG_LIVE_LENGTH (sregno) = 2;\n \t\t    }\n \n-\t\t  REG_N_CALLS_CROSSED (sregno) -= n_calls;\n-\t\t}\n-\n-\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n-\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n-\n-\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n+\t\t  REG_N_CALLS_CROSSED (sregno) -= s_n_calls;\n \t\t}\n \n \t      /* Move death note of SRC from P to INSN.  */\n@@ -398,6 +367,15 @@ optimize_reg_copy_1 (insn, dest, src)\n \t    {\n \t      XEXP (dest_death, 1) = REG_NOTES (p);\n \t      REG_NOTES (p) = dest_death;\n+\n+\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  /* If and only if we are moving the death note for DREGNO,\n+\t\t     then we need to update its counters.  */\n+\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n+\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n+\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n+\t\t}\n \t    }\n \n \t  return ! failed;"}]}