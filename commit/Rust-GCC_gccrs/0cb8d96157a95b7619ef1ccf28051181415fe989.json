{"sha": "0cb8d96157a95b7619ef1ccf28051181415fe989", "node_id": "C_kwDOANBUbNoAKDBjYjhkOTYxNTdhOTViNzYxOWVmMWNjZjI4MDUxMTgxNDE1ZmU5ODk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-01T13:54:57Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-01T13:54:57Z"}, "message": "libstdc++: Implement ranges::adjacent_transform_view from P2321R2\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__detail::__unarize): Define.\n\t(adjacent_view::_Iterator): Befriend adjacent_transform_view.\n\t(adjacent_transform_view): Define.\n\t(adjacent_transform_view::_Iterator): Define.\n\t(adjacent_transform_view::_Sentinel): Define.\n\t(views::__detail::__can_adjacent_transform_view): Define.\n\t(views::_AdjacentTransform): Define.\n\t(views::adjacent_transform): Define.\n\t(views::pairwise_transform): Define.\n\t* testsuite/std/ranges/adaptors/adjacent_transform/1.cc: New test.", "tree": {"sha": "ee9f441e60d67d9da0764beea30fee5f28d29907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee9f441e60d67d9da0764beea30fee5f28d29907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cb8d96157a95b7619ef1ccf28051181415fe989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb8d96157a95b7619ef1ccf28051181415fe989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb8d96157a95b7619ef1ccf28051181415fe989", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb8d96157a95b7619ef1ccf28051181415fe989/comments", "author": null, "committer": null, "parents": [{"sha": "47e15513c9e581ef04ad25fb0d561a45d345edd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e15513c9e581ef04ad25fb0d561a45d345edd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e15513c9e581ef04ad25fb0d561a45d345edd1"}], "stats": {"total": 447, "additions": 447, "deletions": 0}, "files": [{"sha": "dad1e4c9f939cf6ec58c460b9e749bf1260de8d7", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb8d96157a95b7619ef1ccf28051181415fe989/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb8d96157a95b7619ef1ccf28051181415fe989/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=0cb8d96157a95b7619ef1ccf28051181415fe989", "patch": "@@ -5156,6 +5156,20 @@ namespace views::__adaptor\n     // Yields tuple<_Tp, ..., _Tp> with _Nm elements.\n     template<typename _Tp, size_t _Nm>\n       using __repeated_tuple = decltype(std::tuple_cat(std::declval<array<_Tp, _Nm>>()));\n+\n+    // For a functor F that is callable with N arguments, the expression\n+    // declval<__unarize<F, N>>(x) is equivalent to declval<F>(x, ..., x).\n+    template<typename _Fp, size_t _Nm>\n+      struct __unarize\n+      {\n+\ttemplate<typename... _Ts>\n+\t  static invoke_result_t<_Fp, _Ts...>\n+\t  __tuple_apply(const tuple<_Ts...>&); // not defined\n+\n+\ttemplate<typename _Tp>\n+\t  decltype(__tuple_apply(std::declval<__repeated_tuple<_Tp, _Nm>>()))\n+\t  operator()(_Tp&&); // not defined\n+      };\n   }\n \n   template<forward_range _Vp, size_t _Nm>\n@@ -5203,6 +5217,13 @@ namespace views::__adaptor\n \n     friend class adjacent_view;\n \n+    template<forward_range _Wp, copy_constructible _Fp, size_t _Mm>\n+      requires view<_Wp> && (_Mm > 0) && is_object_v<_Fp>\n+        && regular_invocable<__detail::__unarize<_Fp&, _Mm>, range_reference_t<_Wp>>\n+        && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Mm>,\n+\t\t\t\t\t\t\t range_reference_t<_Wp>>>\n+      friend class adjacent_transform_view;\n+\n   public:\n     using iterator_category = input_iterator_tag;\n     using iterator_concept = decltype(_S_iter_concept());\n@@ -5437,6 +5458,326 @@ namespace views::__adaptor\n \n     inline constexpr auto pairwise = adjacent<2>;\n   }\n+\n+  template<forward_range _Vp, copy_constructible _Fp, size_t _Nm>\n+   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n+     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n+     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n+\t\t\t\t\t\t       range_reference_t<_Vp>>>\n+  class adjacent_transform_view : public view_interface<adjacent_transform_view<_Vp, _Fp, _Nm>>\n+  {\n+    [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n+    adjacent_view<_Vp, _Nm> _M_inner;\n+\n+    using _InnerView = adjacent_view<_Vp, _Nm>;\n+\n+    template<bool _Const>\n+      using _InnerIter = iterator_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n+\n+    template<bool _Const>\n+      using _InnerSent = sentinel_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n+\n+    template<bool> class _Iterator;\n+    template<bool> class _Sentinel;\n+\n+  public:\n+    adjacent_transform_view() = default;\n+\n+    constexpr explicit\n+    adjacent_transform_view(_Vp __base, _Fp __fun)\n+      : _M_fun(std::move(__fun)), _M_inner(std::move(__base))\n+    { }\n+\n+    constexpr auto\n+    begin()\n+    { return _Iterator<false>(*this, _M_inner.begin()); }\n+\n+    constexpr auto\n+    begin() const\n+      requires range<const _InnerView>\n+\t&& regular_invocable<__detail::__unarize<const _Fp&, _Nm>,\n+\t\t\t     range_reference_t<const _Vp>>\n+    { return _Iterator<true>(*this, _M_inner.begin()); }\n+\n+    constexpr auto\n+    end()\n+    {\n+      if constexpr (common_range<_InnerView>)\n+        return _Iterator<false>(*this, _M_inner.end());\n+      else\n+        return _Sentinel<false>(_M_inner.end());\n+    }\n+\n+    constexpr auto\n+    end() const\n+      requires range<const _InnerView>\n+\t&& regular_invocable<__detail::__unarize<const _Fp&, _Nm>,\n+\t\t\t     range_reference_t<const _Vp>>\n+    {\n+      if constexpr (common_range<const _InnerView>)\n+        return _Iterator<true>(*this, _M_inner.end());\n+      else\n+        return _Sentinel<true>(_M_inner.end());\n+    }\n+\n+    constexpr auto\n+    size() requires sized_range<_InnerView>\n+    { return _M_inner.size(); }\n+\n+    constexpr auto\n+    size() const requires sized_range<const _InnerView>\n+    { return _M_inner.size(); }\n+  };\n+\n+  template<forward_range _Vp, copy_constructible _Fp, size_t _Nm>\n+   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n+     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n+     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n+\t\t\t\t\t\t       range_reference_t<_Vp>>>\n+  template<bool _Const>\n+  class adjacent_transform_view<_Vp, _Fp, _Nm>::_Iterator\n+  {\n+    using _Parent = __detail::__maybe_const_t<_Const, adjacent_transform_view>;\n+    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n+    _Parent* _M_parent = nullptr;\n+    _InnerIter<_Const> _M_inner;\n+\n+    constexpr\n+    _Iterator(_Parent& __parent, _InnerIter<_Const> __inner)\n+      : _M_parent(std::__addressof(__parent)), _M_inner(std::move(__inner))\n+    { }\n+\n+    static auto\n+    _S_iter_cat()\n+    {\n+      using __detail::__maybe_const_t;\n+      using __detail::__unarize;\n+      using _Res = invoke_result_t<__unarize<__maybe_const_t<_Const, _Fp>&, _Nm>,\n+\t\t\t\t   range_reference_t<_Base>>;\n+      using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;\n+      if constexpr (!is_lvalue_reference_v<_Res>)\n+\treturn input_iterator_tag{};\n+      else if constexpr (derived_from<_Cat, random_access_iterator_tag>)\n+\treturn random_access_iterator_tag{};\n+      else if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n+\treturn bidirectional_iterator_tag{};\n+      else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n+\treturn forward_iterator_tag{};\n+      else\n+\treturn input_iterator_tag{};\n+    }\n+\n+    friend class adjacent_transform_view;\n+\n+  public:\n+    using iterator_category = decltype(_S_iter_cat());\n+    using iterator_concept = typename _InnerIter<_Const>::iterator_concept;\n+    using value_type\n+      = remove_cvref_t<invoke_result_t\n+\t\t       <__detail::__unarize<__detail::__maybe_const_t<_Const, _Fp>&, _Nm>,\n+\t\t\trange_reference_t<_Base>>>;\n+    using difference_type = range_difference_t<_Base>;\n+\n+    _Iterator() = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const && convertible_to<_InnerIter<false>, _InnerIter<_Const>>\n+      : _M_parent(__i._M_parent), _M_inner(std::move(__i._M_inner))\n+    { }\n+\n+    constexpr decltype(auto)\n+    operator*() const\n+    {\n+      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n+        return std::__invoke(*_M_parent->_M_fun, *__iters...);\n+      }, _M_inner._M_current);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      ++_M_inner;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--() requires bidirectional_range<_Base>\n+    {\n+      --_M_inner;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int) requires bidirectional_range<_Base>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x) requires random_access_range<_Base>\n+    {\n+      _M_inner += __x;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x) requires random_access_range<_Base>\n+    {\n+      _M_inner -= __x;\n+      return *this;\n+    }\n+\n+    constexpr decltype(auto)\n+    operator[](difference_type __n) const requires random_access_range<_Base>\n+    {\n+      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n+        return std::__invoke(*_M_parent->_M_fun, __iters[__n]...);\n+      }, _M_inner._M_current);\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+    { return __x._M_inner == __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator<(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_inner < __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_inner > __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator<=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_inner <= __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator>=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_inner >= __y._M_inner; }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base> &&\n+      three_way_comparable<_InnerIter<_Const>>\n+    { return __x._M_inner <=> __y._M_inner; }\n+\n+    friend constexpr _Iterator\n+    operator+(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __n, const _Iterator& __i)\n+      requires random_access_range<_Base>\n+    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n+\n+    friend constexpr _Iterator\n+    operator-(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    { return _Iterator(*__i._M_parent, __i._M_inner - __n); }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires sized_sentinel_for<_InnerIter<_Const>, _InnerIter<_Const>>\n+    { return __x._M_inner - __y._M_inner; }\n+  };\n+\n+  template<forward_range _Vp, copy_constructible _Fp, size_t _Nm>\n+   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n+     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n+     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n+\t\t\t\t\t\t       range_reference_t<_Vp>>>\n+  template<bool _Const>\n+  class adjacent_transform_view<_Vp, _Fp, _Nm>::_Sentinel\n+  {\n+    _InnerSent<_Const> _M_inner;\n+\n+    constexpr explicit\n+    _Sentinel(_InnerSent<_Const> __inner)\n+      : _M_inner(__inner)\n+    { }\n+\n+    friend class adjacent_transform_view;\n+\n+  public:\n+    _Sentinel() = default;\n+\n+    constexpr\n+    _Sentinel(_Sentinel<!_Const> __i)\n+      requires _Const && convertible_to<_InnerSent<false>, _InnerSent<_Const>>\n+      : _M_inner(std::move(__i._M_inner))\n+    { }\n+\n+    template<bool _OtherConst>\n+      requires sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n+    friend constexpr bool\n+    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_inner == __y._M_inner; }\n+\n+    template<bool _OtherConst>\n+      requires sized_sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n+    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_inner - __y._M_inner; }\n+\n+    template<bool _OtherConst>\n+      requires sized_sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n+    operator-(const _Sentinel& __x, const _Iterator<_OtherConst>& __y)\n+    { return __x._M_inner - __y._M_inner; }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<size_t _Nm, typename _Range, typename _Fp>\n+\tconcept __can_adjacent_transform_view\n+\t  = requires { adjacent_transform_view<all_t<_Range>, decay_t<_Fp>, _Nm>\n+\t\t         (std::declval<_Range>(), std::declval<_Fp>()); };\n+    }\n+\n+    template<size_t _Nm>\n+      struct _AdjacentTransform : __adaptor::_RangeAdaptor<_AdjacentTransform<_Nm>>\n+      {\n+\ttemplate<viewable_range _Range, typename _Fp>\n+\t  requires (_Nm == 0) || __detail::__can_adjacent_transform_view<_Nm, _Range, _Fp>\n+\t  constexpr auto\n+\t  operator() [[nodiscard]] (_Range&& __r, _Fp&& __f) const\n+\t  {\n+\t    if constexpr (_Nm == 0)\n+\t      return views::empty<tuple<>>;\n+\t    else\n+\t      return adjacent_transform_view<all_t<_Range>, decay_t<_Fp>, _Nm>\n+\t\t(std::forward<_Range>(__r), std::forward<_Fp>(__f));\n+\t  }\n+\n+\tusing __adaptor::_RangeAdaptor<_AdjacentTransform>::operator();\n+\tstatic constexpr int _S_arity = 2;\n+\tstatic constexpr bool _S_has_simple_extra_args = true;\n+      };\n+\n+    template<size_t _Nm>\n+      inline constexpr _AdjacentTransform<_Nm> adjacent_transform;\n+\n+    inline constexpr auto pairwise_transform = adjacent_transform<2>;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "07f20b702dd2fda08935cb8e00d5d76f27ca8818", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/adjacent_transform/1.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb8d96157a95b7619ef1ccf28051181415fe989/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent_transform%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb8d96157a95b7619ef1ccf28051181415fe989/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent_transform%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent_transform%2F1.cc?ref=0cb8d96157a95b7619ef1ccf28051181415fe989", "patch": "@@ -0,0 +1,106 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  auto v1 = std::array{1, 2, 3} | views::adjacent_transform<1>(std::identity{});\n+  VERIFY( ranges::equal(v1, (int[]){1, 2, 3}) );\n+  const auto i0 = v1.begin(), i1 = v1.begin() + 1;\n+  VERIFY( i0 + 1 - 1 == i0 );\n+  VERIFY( i0 < i1 );\n+  VERIFY( i1 < v1.end() );\n+  VERIFY( i1 - i0 == 1 );\n+  VERIFY( i0 - i1 == -1 );\n+  VERIFY( v1.end() - i1 == 2 );\n+  VERIFY( i1 - v1.end() == -2 );\n+  ranges::iter_swap(i0, i1);\n+  VERIFY( ranges::equal(std::move(v1), (int[]){2, 1, 3}) );\n+\n+  auto v2 = std::array{1, -1, 2, -2} | views::pairwise_transform(std::multiplies{});\n+  auto i2 = v2.begin();\n+  i2 += 1;\n+  i2 -= -2;\n+  VERIFY( i2 == v2.end() );\n+  VERIFY( ranges::size(v2) == 3 );\n+  VERIFY( ranges::size(std::as_const(v2)) == 3 );\n+  VERIFY( ranges::equal(v2, (int[]){-1, -2, -4}) );\n+\n+  int y[] = {1, 2, 3, 4, 5, 6};\n+  auto v3 = y | views::adjacent_transform<3>([](auto... xs) { return ranges::max({xs...}); });\n+  VERIFY( ranges::size(v3) == 4 );\n+  VERIFY( ranges::equal(v3, (int[]){3, 4, 5, 6}) );\n+\n+  const auto v6 = y | views::adjacent_transform<6>([](auto...) { return 0; });\n+  VERIFY( ranges::equal(v6, (int[]){0}) );\n+\n+  const auto v7 = y | views::adjacent_transform<7>([](auto...) { return 0; });\n+  VERIFY( ranges::empty(v7) );\n+\n+  const auto v0 = y | views::adjacent_transform<0>([] { return 0; });\n+  VERIFY( ranges::empty(v0) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  using __gnu_test::test_input_range;\n+  using __gnu_test::test_forward_range;\n+  using __gnu_test::test_random_access_range;\n+\n+  using ty1 = ranges::adjacent_transform_view<views::all_t<test_forward_range<int>>,\n+\t\t\t\t\t      std::plus<>, 2>;\n+  static_assert(ranges::forward_range<ty1>);\n+  static_assert(!ranges::bidirectional_range<ty1>);\n+  static_assert(!ranges::sized_range<ty1>);\n+\n+  using ty2 = ranges::adjacent_transform_view<views::all_t<test_random_access_range<int>>,\n+\t\t\t\t\t      decltype([](int, int, int) { return 0;}), 3>;\n+  static_assert(ranges::random_access_range<ty2>);\n+  static_assert(ranges::sized_range<ty2>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  auto v = views::iota(0, 4)\n+    | views::filter([](auto) { return true; })\n+    | views::pairwise_transform(std::plus{});\n+  using ty = decltype(v);\n+  static_assert(ranges::forward_range<ty>);\n+  static_assert(ranges::common_range<ty>);\n+  static_assert(!ranges::sized_range<ty>);\n+  VERIFY( v.begin() == v.begin() );\n+  VERIFY( v.begin() != v.end() );\n+  VERIFY( ranges::next(v.begin(), 3) == v.end() );\n+  auto it = v.begin();\n+  ++it;\n+  it++;\n+  VERIFY( ranges::next(it) == v.end() );\n+  it--;\n+  --it;\n+  VERIFY( it == v.begin() );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+}"}]}